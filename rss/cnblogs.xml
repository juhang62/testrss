<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>二项式反演学习笔记 - ATS_nantf</title>
<link>http://www.cnblogs.com/1000Suns/p/10353617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1000Suns/p/10353617.html</guid>
<description>&lt;p&gt;二项式反演似乎是个很有趣的东西~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;二项式反演似乎有很多条。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一条（最基本，最好记的一条）&lt;/strong&gt;：若序列 $f$ 和 $g$ 满足：&lt;/p&gt;
&lt;p&gt;$$g_n=\sum\limits^n_{i=0}(-1)^i{n\choose i}f_i$$&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}(-1)^i{n\choose i}g_i$$&lt;/p&gt;
&lt;p&gt;反过来也成立。&lt;/p&gt;
&lt;p&gt;证明：（公式恐惧症者可以跳过）&lt;/p&gt;
&lt;p&gt;第一个式子代入第二个式子：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}(-1)^i{n\choose i}\sum\limits^i_{j=0}(-1)^j{i\choose j}f_j$$&lt;/p&gt;
&lt;p&gt;全部放到后面：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}{n\choose i}{i\choose j}f_j$$&lt;/p&gt;
&lt;p&gt;拆开：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}\frac{n!}{i!(n-i)!}\frac{i!}{j!(i-j)!}f_j$$&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}\frac{n!}{(n-i)!j!(i-j)!}f_j$$&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}\frac{n!}{(n-j)!j!}\frac{(n-j)!}{(n-i)!(i-j)!}f_j$$&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}\frac{n!}{(n-j)!j!}\frac{(n-j)!}{(n-i)!((n-j)-(n-i))!}f_j$$&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{i+j}{n\choose j}{n-j\choose n-i}f_j$$&lt;/p&gt;
&lt;p&gt;改变枚举顺序：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}\sum\limits^n_{i=j}(-1)^{i+j}{n\choose j}{n-j\choose n-i}f_j$$&lt;/p&gt;
&lt;p&gt;跟 $i$ 无关的提出去：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}(-1)^j{n\choose j}f_j\sum\limits^n_{i=j}(-1)^i{n-j\choose n-i}$$&lt;/p&gt;
&lt;p&gt;枚举 $i$ 改为枚举 $i+j$：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}(-1)^j{n\choose j}f_j\sum\limits^{n-j}_{i=0}(-1)^{i+j}{n-j\choose n-(i+j)}$$&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}(-1)^{2j}{n\choose j}f_j\sum\limits^{n-j}_{i=0}(-1)^i{n-j\choose n-j-i}$$&lt;/p&gt;
&lt;p&gt;前面，$(-1)^{2j}$ 一定是 $1$，可以省略；后面，可以添上 $1^{n-j-i}$，式子不变。&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j\sum\limits^{n-j}_{i=0}(-1)^i1^{n-j-i}{n-j\choose n-j-i}$$&lt;/p&gt;
&lt;p&gt;后面用二项式定理：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j(-1+1)^{n-j}$$&lt;/p&gt;
&lt;p&gt;根据 $0^n=[n=0]$：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j[n=j]$$&lt;/p&gt;
&lt;p&gt;有用的只有 $n=j$：&lt;/p&gt;
&lt;p&gt;$$f_n={n\choose n}f_n$$&lt;/p&gt;
&lt;p&gt;得证。（似乎网上没有这个式子的证明，我仿照了别的证明才死磕出来的Q^Q）&lt;/p&gt;
&lt;p&gt;然而这个式子不是很常用。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;第二条（最常用的一条）&lt;/strong&gt;：若序列 $f$ 和 $g$ 满足：&lt;/p&gt;
&lt;p&gt;$$g_n=\sum^n_{i=0}{n\choose i}f_i$$&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;$$f_n=\sum^n_{i=0}(-1)^{n-i}{n\choose i}g_i$$&lt;/p&gt;
&lt;p&gt;反过来也成立。&lt;/p&gt;
&lt;p&gt;证明：（公式恐惧症者可以跳过）&lt;/p&gt;
&lt;p&gt;第一个式子代入第二个式子：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}(-1)^{n-i}{n\choose i}\sum\limits^i_{j=0}{i\choose j}f_j$$&lt;/p&gt;
&lt;p&gt;全部放到后面：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{n-i}{n\choose i}{i\choose j}f_j$$&lt;/p&gt;
&lt;p&gt;拆开，同上可得：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{i=0}\sum\limits^i_{j=0}(-1)^{n-i}{n\choose j}{n-j\choose n-i}f_j$$&lt;/p&gt;
&lt;p&gt;改变枚举顺序：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}\sum\limits^n_{i=j}(-1)^{n-i}{n\choose j}{n-j\choose n-i}f_j$$&lt;/p&gt;
&lt;p&gt;跟 $i$ 无关的提出去：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j\sum\limits^n_{i=j}(-1)^{n-i}{n-j\choose n-i}$$&lt;/p&gt;
&lt;p&gt;枚举 $i$ 改为枚举 $n-i$：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j\sum\limits^{n-j}_{i=0}(-1)^i{n-j\choose i}$$&lt;/p&gt;
&lt;p&gt;后面，可以添上 $1^{n-j-i}$，式子不变。&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j\sum\limits^{n-j}_{i=0}(-1)^i1^{n-j-i}{n-j\choose i}$$&lt;/p&gt;
&lt;p&gt;后面用二项式定理：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j(-1+1)^{n-j}$$&lt;/p&gt;
&lt;p&gt;根据 $0^n=[n=0]$：&lt;/p&gt;
&lt;p&gt;$$f_n=\sum\limits^n_{j=0}{n\choose j}f_j[n=j]$$&lt;/p&gt;
&lt;p&gt;有用的只有 $n=j$：&lt;/p&gt;
&lt;p&gt;$$f_n={n\choose n}f_n$$&lt;/p&gt;
&lt;p&gt;得证。实际上上面这两条和下面将提到的两条证明过程都十分相似，我就不赘述了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;第三条（比较冷门的一条）&lt;/strong&gt;：若序列 $f$ 和 $g$ 满足：&lt;/p&gt;
&lt;p&gt;$$g_k=\sum^n_{i=k}(-1)^i{i\choose k}f_i$$&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;$$f_k=\sum^n_{i=k}(-1)^i{i\choose k}g_i$$&lt;/p&gt;
&lt;p&gt;反过来也成立。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;第四条（比较常用的一条）&lt;/strong&gt;：若序列 $f$ 和 $g$ 满足：&lt;/p&gt;
&lt;p&gt;$$g_k=\sum^n_{i=k}{i\choose k}f_i$$&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;$$f_k=\sum^n_{i=k}(-1)^{i-k}{i\choose k}g_i$$&lt;/p&gt;
&lt;p&gt;反过来也成立。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;二项式定理主要用来解决一些形如“恰好”的这类计数问题。通常恰好的方案数不好算，但是至多或者至少的方案比较好算，就可以用二项式反演。&lt;/p&gt;
&lt;p&gt;那么来几道例题：&lt;/p&gt;
&lt;p&gt;Color：&lt;a href=&quot;https://vjudge.net/problem/UVALive-7040&quot; target=&quot;_blank&quot;&gt;UVAlive-7040&lt;/a&gt;（&lt;a href=&quot;https://www.cnblogs.com/1000Suns/p/10353695.html&quot; target=&quot;_blank&quot;&gt;题解&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;已经没什么好害怕的了：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4859&quot; target=&quot;_blank&quot;&gt;洛谷4859&lt;/a&gt;，&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3622&quot; target=&quot;_blank&quot;&gt;BZOJ3622&lt;/a&gt;（Todo）&lt;/p&gt;
&lt;p&gt;（欢迎dalao们帮忙找更多的例题，谢谢OvO）&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 07:01:00 +0000</pubDate>
<dc:creator>ATS_nantf</dc:creator>
<og:description>二项式反演似乎是个很有趣的东西~ 二项式反演似乎有很多条。 第一条（最基本，最好记的一条）：若序列 $f$ 和 $g$ 满足： $$g_n=\sum\limits^n_{i=0}(-1)^i{n\ch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1000Suns/p/10353617.html</dc:identifier>
</item>
<item>
<title>配置CLion作为Qt5开发环境 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10353698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10353698.html</guid>
<description>&lt;p&gt;使用Qt进行程序开发时QtCreator总是不二之选。作为老牌IDE在提供了强大的功能同时也对Qt的支持做了许多优化。如果没有特别的原因你应该使用它。&lt;/p&gt;
&lt;p&gt;然而一个顺手的工具将会极大得提升生产效率，而如果你之前使用别的工具进行开发，那么就要斟酌一下学习使用QtCreator的成本了。&lt;/p&gt;
&lt;p&gt;所以我将介绍配置CLion（另一个强大的c++ IDE）作为Qt5的开发环境，在利用现有工具链的同时避免了安装另一个大型软件。&lt;/p&gt;
&lt;h2 id=&quot;perpare&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;CLion的安装和激活超出了本文的讨论范围，我们假设你已经安装好了CLion。如果需要帮助可以去CLion官网查找安装方法。&lt;/p&gt;
&lt;p&gt;CLion默认使用GCC进行工程构建，然而使用GCC是无法使用代码补全功能的，所以我们将toolchains替换成clang：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141638533-1039972746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，CLion自带了一个cmake，如果我们想使用系统提供的一些cmake模块，那么就必须如图所示替换为系统的cmake。&lt;/p&gt;
&lt;p&gt;随后确保你的编译器至少要支持c++11，如果能支持c++14或者c++17那自然是最好。&lt;/p&gt;
&lt;h2 id=&quot;create-project&quot;&gt;创建Qt5项目&lt;/h2&gt;
&lt;p&gt;下面是创建Qt5项目，CLion没有区分普通c++项目和Qt项目（毕竟Qt项目一般也是c++项目或者c++/QML项目），所以这样创建即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141619463-20126742.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完成后项目结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141601932-706929034.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmake-build-release&lt;/code&gt;目录是生成moc等工具的中间代码以及可执行文件的地方，当然可执行文件的生成路径可以自己指定，这是CLion默认的选项。&lt;/p&gt;
&lt;p&gt;这时编译运行和代码补全还是不能用的，所以接下来我们设置编译和代码补全。&lt;/p&gt;
&lt;h2 id=&quot;settings&quot;&gt;设置Qt代码补全和项目编译&lt;/h2&gt;
&lt;p&gt;事先要说明的一点是，CLion是根据&lt;code&gt;CMakeLists.txt&lt;/code&gt;文件来组织和设置项目的，所以如果我们需要添加诸如Qt这样的第三方库或是改变编译行为，都只要修改&lt;code&gt;CMakeLists.txt&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;所以我们需要把&lt;code&gt;CMakeLists.txt&lt;/code&gt;修改成如下的样子：&lt;/p&gt;
&lt;pre class=&quot;cmakelists&quot;&gt;
&lt;code&gt;cmake_minimum_required(VERSION 3.0)
project(test)

# 指定c++标准的版本
set(CMAKE_CXX_STANDARD 17)

# 自动调用moc，uic，rcc处理qt的扩展部分
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_INCLUDE_CURRENT_DIR ON)

# 设置Qt5的cmake模块所在目录，如果不设置将使用系统提供的版本
# QT_DIR和QT_VERSION是指定了qt安装目录和版本的环境变量
# 如果你使用了系统的cmake，那么会优先使用系统提供模块，如果不想发生这种行为你需要自己运行cmake或者使用CLion自带的
set(CMAKE_PREFIX_PATH $ENV{QT_DIR}/$ENV{QT_VERSION}/gcc_64/lib/cmake)

# 找到对应的qt模块，名字为qmake中QT += &amp;lt;name&amp;gt;中的name首字母大写后加上Qt5前缀
# 例如core为QtCore，你也可以去${CMAKE_PREFIX_PATH}的目录中找到正确的模块名
find_package(Qt5Widgets REQUIRED)

aux_source_directory(. DIRS_SRCS)

add_executable(test ${DIRS_SRCS})

# 把对应Qt模块的库链接进程序
target_link_libraries(test Qt5::Widgets)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是，使用系统提供的Qt的一个好处是编译出来的程序可以使用系统的样式和主题，但缺点是版本可能会与我们想使用的不一致从而产生错误。&lt;/p&gt;
&lt;p&gt;修改之后点击图中的&lt;code&gt;Reload changes&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141516624-1338866483.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CLion会自动生成新的Makefile用于编译项目，现在代码补全也可以使用了。&lt;/p&gt;
&lt;h2 id=&quot;compile&quot;&gt;编译项目&lt;/h2&gt;
&lt;p&gt;我们先写一个小的示例，让一个spinbox和slider可以相互联动：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QFormLayout&amp;gt;
#include &amp;lt;QtGlobal&amp;gt;
#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QSlider&amp;gt;
#include &amp;lt;QSpinBox&amp;gt;
#include &amp;lt;QWidget&amp;gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    auto window = new QWidget;

    auto spinBox = new QSpinBox;
    spinBox-&amp;gt;setRange(0, 100);
    auto slider = new QSlider;
    slider-&amp;gt;setRange(0, 100);
    QObject::connect(spinBox,
                     // 对于重载函数需要给出确定的版本，QOverload需要编译器支持c++11
                     QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QSpinBox::valueChanged),
                     slider,
                     &amp;amp;QSlider::setValue);
    QObject::connect(slider,
                     &amp;amp;QSlider::valueChanged,
                     spinBox,
                     &amp;amp;QSpinBox::setValue);

    auto layout = new QFormLayout;
    layout-&amp;gt;addRow(&quot;spin box:&quot;, spinBox);
    layout-&amp;gt;addRow(&quot;slider:&quot;, slider);
    window-&amp;gt;setLayout(layout);
    window-&amp;gt;show();

    return app.exec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们点击&lt;code&gt;int main(...)&lt;/code&gt;左侧的运行按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141441452-2051567902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序就开始编译了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141423077-849002016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果编译成功程序就会自动运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141402652-580946372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此CLion已经可以正常配合Qt进行开发。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 06:17:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>使用Qt进行程序开发时QtCreator总是不二之选。作为老牌IDE在提供了强大的功能同时也对Qt的支持做了许多优化。如果没有特别的原因你应该使用它。 然而一个顺手的工具将会极大得提升生产效率，而如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10353698.html</dc:identifier>
</item>
<item>
<title>对比总结三个工厂模式（简单工厂，工厂方法，抽象工厂） - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/10353209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/10353209.html</guid>
<description>&lt;p&gt;简单工厂模式，工厂方法模式，抽象工厂模式，这三个模式，当然还有单例模式，建造者模式等等，应该是日常工作中常用的，尤其是工厂模式，应该是最最常见的模式，对理解面向对象有重要的实际意义。&lt;/p&gt;

&lt;p&gt;最简单，最直接，能满足大部分日常需求，不足是工厂类太简单——无法满足开闭原则，对多个产品的扩展不利&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201902/682679-20190205203614136-592161144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;工厂方法模式，有了进步，把工厂类进行改进，提升为一个抽象类（接口），把对具体产品的实现交给对应的具体的子类去做，解耦多个产品之间的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201902/682679-20190205203912938-1852565705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面都是针对一个产品族的设计，如果有多个产品族的话，就可以使用抽象工厂模式&lt;/p&gt;

&lt;p&gt;抽象工厂模式的工厂，不再维护一个产品等级的某个产品（或说一个产品结构的某个产品更好理解），而是维护产品结构里的所有产品（横向x轴），具体到代码就是多个抽象方法去对应产品等级结构的各个产品实例&lt;/p&gt;
&lt;p&gt;具体的工厂类实现抽象工厂接口，去对应各个产品族，每一个具体工厂对一个产品族，获得该产品族的产品结构（所有产品）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201902/682679-20190205205612862-1797251726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂模式中的方法对应产品等级结构（每个类型中的具体产品），具体子工厂对应不同的产品族（产品类型）&lt;/p&gt;

&lt;p&gt; 想到一个面试题： 写一个简单的计算器，满足加减乘除运算。逻辑比较简单：接受计算数据的输入，进行计算，返回结果。用Java实现。&lt;/p&gt;
&lt;h2 id=&quot;id-4.1、面向过程版&quot;&gt;面向过程版&lt;/h2&gt;
&lt;p&gt;面向过程的设计本身没有错，但是如果面试的是 java 的相关职位，使用一门面向对象的语言这样写是非常危险的。因为这样写，谁都会，但凡学过编程的，没有不会的。更重要的问题是，这样写的目的仅仅是为了完成任务，没有任何面向对象的思维体现。实际业务中，类似的程序一旦扩展，这样的代码是没有办法维护的。&lt;/p&gt;
&lt;p&gt;缺点：完全面向过程设计，所有逻辑都集中在一个类（方法、函数里），缺少代码的重用……&lt;/p&gt;
&lt;p&gt;这里的除 0 异常检测也是考点之一。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、先接受数据的输入
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、进行计算
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、返回计算结果&lt;/span&gt;
        System.out.println(&quot;******计算器********\n 请输入第一个数：&quot;&lt;span&gt;);
        Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String num1 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入运算符：&quot;&lt;span&gt;);
        String operation &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入第二个数：&quot;&lt;span&gt;);
        String num2 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;开始计算。。。。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;+&quot;&lt;span&gt;.equals(operation)) {
            result &lt;/span&gt;= Double.parseDouble(num1) +&lt;span&gt; Double.parseDouble(num2);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;-&quot;&lt;span&gt;.equals(operation)) {
            result &lt;/span&gt;= Double.parseDouble(num1) -&lt;span&gt; Double.parseDouble(num2);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;*&quot;&lt;span&gt;.equals(operation)) {
            result &lt;/span&gt;= Double.parseDouble(num1) *&lt;span&gt; Double.parseDouble(num2);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;/&quot;&lt;span&gt;.equals(operation)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Double.parseDouble(num2) != 0&lt;span&gt;) {
                result &lt;/span&gt;= Double.parseDouble(num1) /&lt;span&gt; Double.parseDouble(num2);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;除数不能为0！&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }

        System.out.println(num1 &lt;/span&gt;+ operation + num2 + &quot; = &quot; +&lt;span&gt; result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;面向对象的设计就是把各个操作抽象为一个个的类，加法类，减法类，乘法类，除法类……每个运算类的职责就是进行属于自己的运算符的计算，客户端去调用对应的运算类即可。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum1() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum1(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum2(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的运算符子类，只用加法举例，其他省略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Add &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、计算数据的输入
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、进行计算
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、返回计算结果&lt;/span&gt;
        System.out.println(&quot;******计算器********\n 请输入第一个数：&quot;&lt;span&gt;);
        Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String num1 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入运算符：&quot;&lt;span&gt;);
        String operation &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入第二个数：&quot;&lt;span&gt;);
        String num2 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;开始计算。。。。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型转换&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; Double.parseDouble(num1);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; Double.parseDouble(num2);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;+&quot;&lt;span&gt;.equals(operation)) {
            Operation o &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Add();
            o.setNum1(a);
            o.setNum2(b);
            result &lt;/span&gt;=&lt;span&gt; o.getResult();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写到这里，貌似比之前也没什么大的改变，只是使用了面向对象的一丢丢，使用了类……在客户端还是需要显式的去 new 对应的运算类对象进行计算，客户端里还是维护了大量的业务逻辑……&lt;/p&gt;
&lt;p&gt;继续改进，使用工厂模式——简单工厂模式&lt;/p&gt;
&lt;h2 id=&quot;id-4.3、简单工厂模式版&quot;&gt;简单工厂模式版&lt;/h2&gt;
&lt;p&gt;一般学过的人，会立即想到该模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum1() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum1(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum2(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Add &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}
 
&lt;/span&gt;&lt;span&gt;//////////////&lt;/span&gt;&lt;span&gt;/  简单工厂类（也可以使用反射机制）&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OpreationFactory {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Operation getOperation(String operation) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;+&quot;&lt;span&gt;.equals(operation)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Add();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;-&quot;&lt;span&gt;.equals(operation)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}
 
&lt;/span&gt;&lt;span&gt;//////////////&lt;/span&gt;&lt;span&gt; 调用者（客户端）&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;******计算器********\n请输入第一个数：&quot;&lt;span&gt;);
        Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String num1 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入运算符：&quot;&lt;span&gt;);
        String operation &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入第二个数：&quot;&lt;span&gt;);
        String num2 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;开始计算。。。。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型转换&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; Double.parseDouble(num1);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; Double.parseDouble(num2);

        Operation oper &lt;/span&gt;=&lt;span&gt; OpreationFactory.getOperation(operation);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 有空指针异常隐患&lt;/span&gt;
&lt;span&gt;        oper.setNum1(a);
        oper.setNum2(b);
        result &lt;/span&gt;=&lt;span&gt; oper.getResult();
        System.out.println(num1 &lt;/span&gt;+ operation + num2 + &quot; = &quot; +&lt;span&gt; result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写，客户端（调用者）无需反复修改程序，也不需要关注底层实现，调用者只需要简单了解或者指定一个工厂的接口，然后去调用即可一劳永逸，而底层的修改不会影响调用者的代码结构——实现了解耦。且每个操作符类都各司其职，单一职责，看着还可以&lt;/p&gt;
&lt;p&gt;但是这时候面试官说了，给我增加开平方运算，回想之前的简单工厂设计模式，每次增加新的产品都需要去修改原来的工厂代码——这样不符合OCP，那么自然想到了工厂方法模式&lt;/p&gt;
&lt;h2 id=&quot;id-4.4、工厂方法模式版&quot;&gt;工厂方法模式版&lt;/h2&gt;
&lt;p&gt;只举个加法的例子得了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将工厂，又抽象了一层&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; OpreationFactory {
    Operation getOperation();
}

&lt;/span&gt;&lt;span&gt;//////&lt;/span&gt;&lt;span&gt; 具体工厂类，生产不同的产品，比如加减乘除，开平方等&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OpreationFactory {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation getOperation() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Add();
    }
}
 
&lt;/span&gt;&lt;span&gt;////&lt;/span&gt;&lt;span&gt;/ 抽象的产品实体类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum1() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum1(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum2(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Add &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}
 
&lt;/span&gt;&lt;span&gt;//////////&lt;/span&gt;&lt;span&gt;/ 客户端&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;******计算器********\n 请输入第一个数：&quot;&lt;span&gt;);
        Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String num1 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入运算符：&quot;&lt;span&gt;);
        String operation &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;请输入第二个数：&quot;&lt;span&gt;);
        String num2 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();

        System.out.println(&lt;/span&gt;&quot;开始计算。。。。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; result = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型转换&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; Double.parseDouble(num1);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; Double.parseDouble(num2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 这里又需要判断了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;+&quot;&lt;span&gt;.equals(operation)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到加法工厂&lt;/span&gt;
            OpreationFactory opreationFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddFactory();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算 +&lt;/span&gt;
            Operation oper =&lt;span&gt; opreationFactory.getOperation();
            oper.setNum1(a);
            oper.setNum2(b);
            result &lt;/span&gt;=&lt;span&gt; oper.getResult();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;
        System.out.println(num1 + operation + num2 + &quot; = &quot; +&lt;span&gt; result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工厂方法模式虽然避免了每次扩展运算符的时候，都修改工厂类，但是把判断的业务逻辑放到了客户端里，各有缺点吧……不要为了面向对象而面向对象。&lt;/p&gt;
&lt;h2 id=&quot;id-4.5、改进的工厂方法模式版&quot;&gt;改进的工厂方法模式版&lt;/h2&gt;
&lt;p&gt;不过，还是可以改进的……使用反射动态加载类 + 配置文件/注解 等等，且对重复代码进行提炼和封装……其实框架就这么一步步来的。&lt;/p&gt;
&lt;p&gt;代码如下（+和-）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; OpreationFactory {
    Operation getOperation();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OpreationFactory {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation getOperation() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Add();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OpreationFactory {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation getOperation() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum1() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum1(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num1 =&lt;span&gt; num1;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getNum2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNum2(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num2 =&lt;span&gt; num2;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Add &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Operation {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getResult() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getNum1() - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getNum2();
    }
}

&lt;/span&gt;&lt;span&gt;//////////////&lt;/span&gt;&lt;span&gt; 封装了一些操作&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;  Util {
    MAP {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 写在配置文件里&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getMap() {
            Map&lt;/span&gt;&amp;lt;String, String&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
            hashMap.put(&lt;/span&gt;&quot;+&quot;, &quot;compute.object.AddFactory&quot;&lt;span&gt;);
            hashMap.put(&lt;/span&gt;&quot;-&quot;, &quot;compute.object.SubFactory&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashMap;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; compute(&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; b, OpreationFactory opreationFactory) {
            Operation oper &lt;/span&gt;=&lt;span&gt; opreationFactory.getOperation();
            oper.setNum1(a);
            oper.setNum2(b);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oper.getResult();
        }
    };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getMap();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; compute(&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; b, OpreationFactory opreationFactory);
}

&lt;/span&gt;&lt;span&gt;////////////&lt;/span&gt;&lt;span&gt; 客户端&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; result = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, IllegalAccessException, InstantiationException {
        System.out.println(&lt;/span&gt;&quot;******计算器********\n 请输入第一个数：&quot;&lt;span&gt;);
        Scanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        String num1 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();
        System.out.println(&lt;/span&gt;&quot;请输入运算符：&quot;&lt;span&gt;);
        String operation &lt;/span&gt;=&lt;span&gt; scanner.nextLine();
        System.out.println(&lt;/span&gt;&quot;请输入第二个数：&quot;&lt;span&gt;);
        String num2 &lt;/span&gt;=&lt;span&gt; scanner.nextLine();
        System.out.println(&lt;/span&gt;&quot;开始计算。。。。。。&quot;&lt;span&gt;);
        a &lt;/span&gt;=&lt;span&gt; Double.parseDouble(num1);
        b &lt;/span&gt;=&lt;span&gt; Double.parseDouble(num2);
        Class clazz &lt;/span&gt;=&lt;span&gt; Class.forName(MAP.getMap().get(operation));
        result &lt;/span&gt;=&lt;span&gt; MAP.compute(a, b, (OpreationFactory) clazz.newInstance());
        System.out.println(num1 &lt;/span&gt;+ operation + num2 + &quot; = &quot; +&lt;span&gt; result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里也差不多了，虽然还有很多问题……关键是思想的掌握 &lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 05:49:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 简单工厂模式，工厂方法模式，抽象工厂模式，这三个模式，当然还有单例模式，建造者模式等等，应该是日常工作中常用的，尤其是工厂模式，应该是最最常见的模式，对理解面向对象有重要的实际意义。 简单工厂模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/10353209.html</dc:identifier>
</item>
<item>
<title>（最全）Xpath、Beautiful Soup、Pyquery三种解析库解析html 功能概括 - xubin97</title>
<link>http://www.cnblogs.com/xubin97/p/10353670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xubin97/p/10353670.html</guid>
<description>&lt;h3 id=&quot;一xpath-解析&quot;&gt;一、Xpath 解析&lt;/h3&gt;
&lt;p&gt;  xpath：是一种在XMl、html文档中查找信息的语言，利用了lxml库对HTML解析获取数据。&lt;/p&gt;
&lt;p&gt;Xpath常用规则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;ensp; nodename ：选取此节点的所有子节点
&amp;amp;ensp; //  :从当前节点选取子孙节点
&amp;amp;ensp; / :从当前节点选取子节点
&amp;amp;ensp; .   :  选取当前节点
&amp;amp;ensp; ..  :  选取当前节点父节点
&amp;amp;ensp;@ : 选取属性&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;初始化html&quot;&gt;1.初始化html&lt;/h5&gt;
&lt;p&gt;etree.parse()是初始化html构造一个XPath解析对象；&lt;br/&gt;etree.tostring()是修复html文件中代码，把缺的头或尾节点补齐；&lt;br/&gt;result.deode('utf-8')修复后的HTML代码是字节类型，转化成字符串；&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from lxml import etreed

html=etree.parse('c:/.../test.html',etree.HTMLParser())
result=etree.tostring(html)
result.decode('utf-8')&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;获取所有节点&quot;&gt;2.获取所有节点&lt;/h5&gt;
&lt;p&gt;Xpath规则一般用 // 开头&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;例：
html.xpath('//*') //获取所有的节点
html.xpath('//li') //获取所有li节点&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;子节点子孙节点&quot;&gt;3.子节点、子孙节点&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li/a')  //所有li下是所有直接a子节点
html.xpath('//ul//a') //所有ul下的子孙a节点&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;父节点&quot;&gt;4.父节点&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//a[@href=&quot;links.html&quot;]/../@class')
 //找到所有a节点中href为links.html的父节点的class值
// ..  来实现查找父节点&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;属性匹配&quot;&gt;5.属性匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li[@class=&quot;item-0&quot;]') //找到class值为item-0是节点&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;文本获取&quot;&gt;6.文本获取&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li[@class=&quot;item-0&quot;]/a/text()')
或html.xpath('//li[@class=&quot;item-0&quot;]//text()')&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;属性获取&quot;&gt;7.属性获取&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li/a/@href')  //找到li下a中的href属性值&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;属性多值匹配&quot;&gt;8.属性多值匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li[contains(@class,&quot;li&quot;)]/a/text()')    //只要节点属性class中包含li就能匹配出来&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;多属性匹配&quot;&gt;9.多属性匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;html.xpath('//li[contains(@class,&quot;li&quot;) and @name=&quot;item&quot;]/a/text()') //匹配节点属性class值为li，name值为item的节点&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二beautiful-soup-解析&quot;&gt;二、Beautiful Soup 解析&lt;/h3&gt;
&lt;p&gt;Beautiful Soup是HTML或XML解析库。通过解析文档为用户提供需要抓取的的数据。&lt;/p&gt;
&lt;h6 id=&quot;需要解析器lxml-html解析库lxml-xml解析库python标准库html5lib&quot;&gt;需要解析器：lxml HTML解析库、lxml XML解析库、Python标准库、html5lib&lt;/h6&gt;
&lt;p&gt;基本用法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from bs4 import BeautifulSoup
soup=BeautifulSoup(html,'lxml')&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;soup.prettify&quot;&gt;1.soup.prettify()&lt;/h5&gt;
&lt;p&gt;调用prettify()方法把要解析的字符串以标准的缩进格式输出&lt;/p&gt;
&lt;h5 id=&quot;节点选择器&quot;&gt;2.节点选择器：&lt;/h5&gt;
&lt;p&gt;例：soup.title.string&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(1)选择元素：
 soup.title、soup.title.sring soup.head soup.p
(2)提取信息：
&amp;amp;ensp; 1）获取节点名称：soup.title.name
&amp;amp;ensp; 2) 获取属性:soup.p.attrs、soup.p.attrs['name']
&amp;amp;ensp; 3) 获取内容：soup.p.string
(3)嵌套选择：
soup.head.title.string
(4)关联选择：
&amp;amp;ensp; enumerate()    //生成器类型&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)soup.p.contents       //p节点下的直接子节点列表
(2)soup.p.descendants    //p节点下的所有子孙节点（生成器类型）
(3)父节点和祖先节点：soup.p.partent、soup.p.parents
(4)兄弟节点：
   soup.a.next_sibling
   soup.a.previous_sibling
   soup.a.next_siblings
   enumerate(soup.a.pervious_siblings)
(5)提取信息：soup.a.next_sibling.string&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;方法选择器&quot;&gt;3.方法选择器：&lt;/h5&gt;
&lt;p&gt;find_all(name,attrs,recursive,text,**kwargs)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)name:find_all(name='li')
(2)attrs:find_all(attrs={'id':'list-1'})、find_all(class_='element')
(3)text:匹配节点的文本，find_all(text='字符串或正则表达式')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特：find()用法与fand_all一样，只不过只匹配第一个元素&lt;/p&gt;
&lt;h5 id=&quot;css选择器&quot;&gt;4.css选择器&lt;/h5&gt;
&lt;p&gt;调用select()方法，传入相应css选择器&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;soup.select('.panel.panel-heading')
soup.select('ul li') //所有ul下的所有li
soup.select('#list-2.element')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)嵌套选择：
for ul in soup.select('ul'):
    ul.select('li')
(2)获取属性：
for ul in soup.select('ul')
    ul.attrs['id']
    ul['id']
(3)获取文本：
for li in soup.select('li'):
    li.get_text()
    lli.string&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-pyquery-解析&quot;&gt;三、 pyquery 解析&lt;/h3&gt;
&lt;p&gt;1.初始化：&lt;br/&gt;(1)字符串初始化：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html=''' *******
     '''
from pyquery import PyQuery as pq
doc=pq(html)
print(doc('li'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)URL初始化&lt;br/&gt;doc=pq(url=&quot; https:/ ... &quot;)&lt;/p&gt;
&lt;p&gt;(3)文件初始化&lt;br/&gt;doc=pq(filename='demo.html')&lt;br/&gt;print(doc(li))&lt;/p&gt;
&lt;h5 id=&quot;基本css选择器&quot;&gt;2.基本css选择器&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;doc('#container .list li')    //id 为container,class为list下的所有li&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;查找节点&quot;&gt;3.查找节点&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)子孙节点、子节点
.find():查找所有子孙节点
items=doc('.list')
items.find('li')

.children():查找子节点
items=doc('.list')
items.children('.active')

(2)父节点
doc=pq(html)
items=doc('.list')
items.parent()
祖先节点
items.parents()

(3)兄弟节点
doc=pq(html)
li=doc('.lsit .item-0.active')
li.siblings('.active')&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;遍历&quot;&gt;4.遍历&lt;/h5&gt;
&lt;p&gt;用items()函数生成列表生成器进行遍历&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;doc=pq(html)
lis=doc('li').items()
for li in lis:
  print(li)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;获取信息&quot;&gt;5.获取信息&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)获取属性
a=doc('.item-0.active a')
print(a.attr('href'))或print(a.attr.href)
特：attr只会输出第一个a节点属性，要用items()遍历

(2)获取文本
.text()
a=doc('.item-0.active a')
a.text() //text()函数会输出所有的li文本内容

.html()
li=doc('li')
li.html() //html()只会输出第一个li节点内的HTML文本&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;节点操作&quot;&gt;6.节点操作&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1) removeClass addClass
li=doc('.item-0.active')
print(li)
li.removeClass('active')   //移除active的class
li.addClass('active')    //增加active的class

(2) attr text html
li.attr('name','link')    //增加属性name=link
li.text('changed item')   //改变文本 changed item
li.html(&amp;lt;span&amp;gt;changed item &amp;lt;/span&amp;gt;)   //改变HTML

(3) remove()
wrap=doc('.wrap')
wrap.find('p').remove() //删除wrap中p节点
wrap.text()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特：伪类选择器&lt;br/&gt;选择第一个节点，最后一个节点，奇偶数节点，包含某一文本节点&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 05:48:00 +0000</pubDate>
<dc:creator>xubin97</dc:creator>
<og:description>一、Xpath 解析   xpath：是一种在XMl、html文档中查找信息的语言，利用了lxml库对HTML解析获取数据。 Xpath常用规则： 1.初始化html etree.parse</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xubin97/p/10353670.html</dc:identifier>
</item>
<item>
<title>整体二分浅谈 - Yang1208</title>
<link>http://www.cnblogs.com/yangsongyi/p/10353636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsongyi/p/10353636.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一、前置知识&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span&gt;在学习整体二分之前，要学会二分，以及二分的分治思想。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;二、整体二分浅谈及例题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;　　&lt;span class=&quot;md-expand&quot;&gt;例题：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=2527&quot;&gt;&lt;span&gt;bzoj2527: [Poi2011]Meteors&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于这道题是整体二分的经典例题，我们先抛开整体二分，思考二分怎么做。对于一个询问，因为答案有单调性，如果$x$时刻为最小可以时刻，则比$x$小的时刻都不可以，比$x$大的时刻都可以，所以我们可以进行二分答案，并加以验证。先不说怎样验证，就单是时间复杂度就不能接受，$O(nmlog_2^n)$。&lt;/p&gt;
&lt;p&gt;　　如果一个一个进行二分时间复杂度不允许，且这些询问不是强制在线的，我们不妨整体进行二分，我们把所有询问放在一起进行二分。我们设计一个函数$solve(l，r，x，y)$，表示当前询问序列$[x，y]$的答案在当前答案$[l，r]$区间。有一个问题，就是为什么答案在答案区间$[l，r]$的所有询问会连接在一起，在询问序列的连续一段呢？这个问题放在后面，先置之不理。我们思考，怎样进行二分。&lt;/p&gt;
&lt;p&gt;　　二分答案的思想是取出当前答案区间的中间值进行验证，如果比答案小，则让答案的区间的左端点为中间值加一，反之让答案的右端点为中间值。按照二分答案的思想，我们也进行中间值验证。看例题，我们思考怎么验证。&lt;/p&gt;
&lt;p&gt;　　对于当前答案区间$[l，r]$，我们把第$[l，mid]$场流星雨全部落下，看在当前答案区间$[l，r]$所属的所有询问是否在第$[l，mid]$场流星雨下过之后已经收集足够的陨石，如果当前询问已经收集够，我们把它归为答案区间$[l，mid ]$中，反之我们把它归为答案区间$[mid+1，r]$中，并且对于归为答案区间$[mid+1，r]$的询问我们需要进行修改，对于其希望要收集的陨石数要减去$[l，mid]$场流星雨的陨石总数，此处理解一下。&lt;/p&gt;
&lt;p&gt;　　现在解决一下上面留下的问题，我们怎么能将答案都在$[x，y]$区间的所有询问都放在一起呢？我们对于每一次划分，都将这些询问进行拷贝，并且修改，然后重新按左右排布，这样我们就能让这些答案在同一区间的询问在一起了。 &lt;/p&gt;
&lt;p&gt;　　我们分析一下时间复杂度：我们运用线段树的思想进行分析，我们一共有$log_2^{r-l+1}$层，在这个式子中的$r$表示答案可能到达的最大值，反之$l$表示的就是答案可能到达的最小值，在本题中，我们的$r=n，l=1$，但是下方的代码最开始的传参为$r=n+1$，这表示前$n$场流星雨都不能满足这个询问，所以最后落在$n+1$的所有询问表示不能在所有$n$个流行雨中的到满足，故输出$-1$。每一层中我们运用线段树的思想，知道遍历每一层的所有流星雨，一共是线性的时间复杂度，并且每一层正正好好摊分所有$m$个询问，在每一层中我们每一个询问和流星雨都会运用树状数组，所以总的时间复杂度是$O((n+m)log_2^{n}log_2^{r-l+1})$。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;85&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
#define N 300010
struct Per {int head,id;long long need;}per[N],per_[N&amp;lt;&amp;lt;1];
int n,m,k,L[N],R[N];long long A[N];int ans[N],nxt[N],to[N],idx;long long tmp[N&amp;lt;&amp;lt;1];
void add(int a,int b) {nxt[++idx]=per[a].head,to[idx]=b,per[a].head=idx;}
void change(int x,long long y) {while(x&amp;lt;=2*m) tmp[x]+=y,x+=x&amp;amp;-x;}
long long find(int x) {long long sum=0;while(x) sum+=tmp[x],x-=x&amp;amp;-x;return sum;}
void solve(int l,int r,int x,int y)
{
    if(l==r) {for(int i=x;i&amp;lt;=y;i++) ans[per[i].id]=l;return;}
    int mid=(l+r)&amp;gt;&amp;gt;1,tl=0,tr=n;
    for(int i=l;i&amp;lt;=mid;i++) change(L[i],A[i]),change(R[i]+1,-A[i]);
    for(int i=x;i&amp;lt;=y;i++)
    {
        long long tmp1=0;
        for(int j=per[i].head;j&amp;amp;&amp;amp;tmp1&amp;lt;=per[i].need;j=nxt[j])
            tmp1+=find(to[j]+m)+find(to[j]);
        if(tmp1&amp;gt;=per[i].need) per_[++tl]=per[i];
        else per_[++tr]=per[i],per_[tr].need-=tmp1;
    }
    for(int i=l;i&amp;lt;=mid;i++) change(L[i],-A[i]),change(R[i]+1,A[i]);
    for(int i=1;i&amp;lt;=tl;i++) per[x+i-1]=per_[i];
    for(int i=n+1;i&amp;lt;=tr;i++) per[x+tl+i-n-1]=per_[i];
    solve(l,mid,x,x+tl-1),solve(mid+1,r,y-tr+n+1,y);
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1,a;i&amp;lt;=m;i++) scanf(&quot;%d&quot;,&amp;amp;a),add(a,i);
    for(int i=1;i&amp;lt;=n;i++) scanf(&quot;%lld&quot;,&amp;amp;per[i].need),per[i].id=i;
    scanf(&quot;%d&quot;,&amp;amp;k);for(int i=1;i&amp;lt;=k;i++) scanf(&quot;%d%d%lld&quot;,&amp;amp;L[i],&amp;amp;R[i],&amp;amp;A[i]);
    for(int i=1;i&amp;lt;=k;i++) if(R[i]&amp;lt;L[i]) R[i]+=m; solve(1,k+1,1,n);
    for(int i=1;i&amp;lt;=n;i++) (ans[i]==k+1)?printf(&quot;NIE\n&quot;):printf(&quot;%d\n&quot;,ans[i]);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、习题&lt;/h3&gt;
&lt;p&gt;　　&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=2161&quot; target=&quot;_blank&quot;&gt;bzoj2161: 布娃娃&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　题解：这道题我们可以运用主席树，或是树状数组来解决。但是我们这道题要运用整体二分来解决，我们发现这道和上一道题差不多，也是区间覆盖，但是是找第$k​$大的，同样与上一道题一样，我们每一次进行验证答案的中间值，并进行左右递归，最后处理出答案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;116&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
#define N 300010
#define mod 19921228
int n,num[N],placel[N],placer[N],number[N],ans[N],idx,tmp[N],P[N],C[N],L[N],R[N];
struct Doll {int id,p,l,r,k,val;}doll[N],doll_[N];
char *p1,*p2,buf[100000];
#define nc() (p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int rd() {int x=0,f=1; char c=nc(); while(c&amp;lt;48)
    {if(c=='-') f=-1;c=nc();} while(c&amp;gt;47) x=(((x&amp;lt;&amp;lt;2)+x)&amp;lt;&amp;lt;1)+(c^48),c=nc(); return x*f;}
bool cmp(const Doll &amp;amp;a,const Doll &amp;amp;b) {return a.val&amp;gt;b.val;}
void change(int x,int y) {while(x&amp;lt;=idx) tmp[x]+=y,x+=x&amp;amp;-x;}
int find(int x) {int sum=0;while(x) sum+=tmp[x],x-=x&amp;amp;-x;return sum;}
int find_ord(int x) {int l=1,r=idx+1;
    while(l&amp;lt;r) {int mid=(l+r)&amp;gt;&amp;gt;1;(number[mid]&amp;gt;=x)?r=mid:l=mid+1;}return l;}
void solve(int l,int r,int x,int y)
{
    if(l==r) {for(int i=x;i&amp;lt;=y;i++) ans[doll[i].id]=num[l];return;}
    int mid=(l+r)&amp;gt;&amp;gt;1,tl=0,tr=n;
    for(int i=l;i&amp;lt;=mid;i++) change(placel[i],1),change(placer[i]+1,-1);
    for(int i=x;i&amp;lt;=y;i++)
    {
        int tmp1=find(doll[i].p);
        if(tmp1&amp;gt;=doll[i].k) doll_[++tl]=doll[i];
        else doll_[++tr]=doll[i],doll_[tr].k-=tmp1;
    }
    for(int i=l;i&amp;lt;=mid;i++) change(placel[i],-1),change(placer[i]+1,1);
    for(int i=1;i&amp;lt;=tl;i++) doll[x+i-1]=doll_[i];
    for(int i=n+1;i&amp;lt;=tr;i++) doll[x+tl+i-n-1]=doll_[i];
    solve(l,mid,x,x+tl-1),solve(mid+1,r,y-tr+n+1,y);
}
int main()
{
    n=rd();
        int Padd=rd(),Pfirst=rd(),Pmod=rd(),Pprod=rd();
        int Cadd=rd(),Cfirst=rd(),Cmod=rd(),Cprod=rd();
        int Ladd=rd(),Lfirst=rd(),Lmod=rd(),Lprod=rd();
        int Radd=rd(),Rfirst=rd(),Rmod=rd(),Rprod=rd();
        P[1]=Pfirst%Pmod; for(int i=2;i&amp;lt;=n;i++) P[i]=(1ll*P[i-1]*Pprod+Padd+i)%Pmod;
        C[1]=Cfirst%Cmod; for(int i=2;i&amp;lt;=n;i++) C[i]=(1ll*C[i-1]*Cprod+Cadd+i)%Cmod;
        L[1]=Lfirst%Lmod; for(int i=2;i&amp;lt;=n;i++) L[i]=(1ll*L[i-1]*Lprod+Ladd+i)%Lmod;
        R[1]=Rfirst%Rmod; for(int i=2;i&amp;lt;=n;i++) R[i]=(1ll*R[i-1]*Rprod+Radd+i)%Rmod;
    for(int i=1;i&amp;lt;=n;i++) if(L[i]&amp;gt;R[i]) swap(L[i],R[i]);
    for(int i=1;i&amp;lt;=n;i++) doll[i].l=L[i],doll[i].r=R[i],
        doll[i].p=P[i],doll[i].val=C[i],doll[i].k=i,doll[i].id=i;
    for(int i=1;i&amp;lt;=n;i++) number[++idx]=doll[i].p,number[++idx]=doll[i].l,number[++idx]=doll[i].r;
    sort(number+1,number+idx+1);
    for(int i=1;i&amp;lt;=n;i++)
        doll[i].p=find_ord(doll[i].p),doll[i].l=find_ord(doll[i].l),doll[i].r=find_ord(doll[i].r);
    sort(doll+1,doll+n+1,cmp);
    for(int i=1;i&amp;lt;=n;i++) num[i]=doll[i].val,doll[i].val=i,placel[i]=doll[i].l,placer[i]=doll[i].r;
    solve(1,n+1,1,n); for(int i=1;i&amp;lt;=n;i++) (ans[i]+=ans[i-1])%=mod; printf(&quot;%d\n&quot;,ans[n]);
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 06 Feb 2019 05:10:00 +0000</pubDate>
<dc:creator>Yang1208</dc:creator>
<og:description>整体二分浅谈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsongyi/p/10353636.html</dc:identifier>
</item>
<item>
<title>基于Unity的AR开发初探：发布AR应用到Android平台 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_02.html</guid>
<description>&lt;p&gt;本文接&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_01.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;，介绍一下如何通过Unity发布第一个AR应用至Android平台，在Android手机上使用我们的第一个AR应用。&lt;/p&gt;

&lt;h2&gt;1.1 准备Java JDK&lt;/h2&gt;
&lt;p&gt;　　这里选择的是JDK 1.8.x版本，可以从&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;h2&gt;1.2 准备Android SDK&lt;/h2&gt;
&lt;p&gt;　　这里选择的是R24.1.x-Windows版本，可以从&lt;a href=&quot;https://www.androiddevtools.cn/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;blockquote readability=&quot;5.775&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;/em&gt;为了减少配置的复杂性与挫败感，也可以直接从&lt;a href=&quot;https://pan.baidu.com/s/1DO9_Zutyl9el5bOcPqLDSw#list/path=%2F32469%E9%85%8D%E4%B9%A6%E6%8F%92%E4%BB%B6&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;直接下载打包配套的JDK与SDK，对于SDK来说直接解压后即可使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　需要注意的是，Unity 5.x版本最低的Android API要求为Level 23即Android 6.0，因此需要事先下载好SDK，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205131717352-206530335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.3 在Unity中配置External Tools&lt;/h2&gt;
&lt;p&gt;　　首先，通过File - Build Settings切换到Android平台：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205105109196-1546364872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其次，通过Edit - Preferences设置External Tools，以便告诉Unity我们的JDK和SDK安装在哪个目录下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205105255347-384263190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;*.确保SDK的一级文件夹中包含SDK Manager&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;2.1 重要发布选项&lt;/h2&gt;
&lt;p&gt;　　（1）作者信息&lt;/p&gt;
&lt;p&gt;　　这一选项在上一篇就有介绍，它就是Player Settings，如下图所示，填写公司名和应用名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128225410663-459064768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）旋转方向&lt;/p&gt;
&lt;p&gt;　　这个选项决定了程序运行时画面固定在手机的哪个旋转方向，我们可以在Resolution and Presentation - Default Orientation中进行设置，这里我们设置其为左向固定“Landscape Left”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205111920349-203390038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）App图标&lt;/p&gt;
&lt;p&gt;　　我们可以在Icon设置面板中为App选择一个Icon：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205112209454-678125527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）程序启动画面Splash Image&lt;/p&gt;
&lt;p&gt;　　这里由于是个人版，无法取消Unity字样的启动画面，但如果是专业版，可以在下图中设置自定义的启动画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205112458189-708445263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（5）Android App包名&lt;/p&gt;
&lt;p&gt; 　　我们可以在Other Settings中设置包名，但需要注意的是这里的包名需要跟AR相机中填写的密钥所对应的包名保持一致，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205113243490-423927869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205113249566-1060695670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（6）渲染模式&lt;/p&gt;
&lt;p&gt;　　在发布EasyAR的SDK制作的App时，渲染模式需要取消“Auto Graphics API”，并且选择“OpenGLES2”，如下图所示，仍然是Other Settings面板中设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205114143524-1760555066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这里，Android平台的发布设置就结束了，回到发布面板单击Build进行发布即可。&lt;/p&gt;
&lt;p&gt;　　如果出现了提示Android版本较低的对话框，单击Continue。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205114428804-1463062361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 Android中的效果&lt;/h2&gt;
&lt;p&gt;　　（1）apk文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190206105313438-239984250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）安装apk（测试机型：锤子坚果3）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190205221408587-671923377.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　（3）使用效果（测试机型：锤子坚果3）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201902/381412-20190206113438189-796634767.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;李晔，《&lt;a href=&quot;http://product.dangdang.com/25157639.html&quot; target=&quot;_blank&quot;&gt;Unity AR增强现实完全自学教程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127111609928-452614545.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EasyAR，&lt;a href=&quot;https://www.easyar.cn/doc/EasyAR%20SDK/Getting%20Started/Getting-Started-with-EasyAR.html#getting-started-with-easyar-sdk&quot; target=&quot;_blank&quot;&gt;SDK入门文档&lt;/a&gt;&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 06 Feb 2019 03:36:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>本文接上一篇，介绍一下如何通过Unity发布第一个AR应用至Android平台，在Android手机上使用我们的第一个AR应用。 一、一些准备工作 1.1 准备Java JDK 这里选择的是JDK 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_02.html</dc:identifier>
</item>
<item>
<title>🎨 简易调色盘控件 for .NET（English） - Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/simple-palette-control.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/simple-palette-control.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;By Conmajia&lt;br/&gt;Originally posted in 2012&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Simple &amp;amp; fast implementation of a rectangular RGB palette control for .NET Fx 2.0. Old-school shit.&lt;/p&gt;
&lt;p&gt;Name it as &lt;strong&gt;SRP&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Project download… Nah...&lt;/p&gt;
&lt;p&gt;(ancient project, where on earth can I retrieve those antiques?)&lt;/p&gt;
&lt;p&gt;The palette looks like:&lt;/p&gt;
&lt;img src=&quot;https://conmajia.github.io/assets/upload/2017/02/19/02/1.png&quot; class=&quot;noborder&quot;/&gt; ▲ The look of SRP


&lt;p&gt;Here I have several examples.&lt;/p&gt;
&lt;img src=&quot;https://conmajia.github.io/assets/upload/2017/02/19/02/2.png&quot; class=&quot;noborder&quot;/&gt; ▲ Block 5 &lt;img src=&quot;https://conmajia.github.io/assets/upload/2017/02/19/02/3.png&quot; class=&quot;noborder&quot;/&gt; ▲ Block 10 &lt;img src=&quot;https://conmajia.github.io/assets/upload/2017/02/19/02/4.png&quot; class=&quot;noborder&quot;/&gt; ▲ Block 15
&lt;p&gt;SRP is formed by a 6x36 color block matrix with variable block sizes.&lt;/p&gt;

&lt;p&gt;Disassemble SRP into layers for graphic painting. (bottom to top)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Canvas&lt;/li&gt;
&lt;li&gt;Color blocks&lt;/li&gt;
&lt;li&gt;Grids&lt;/li&gt;
&lt;li&gt;Border&lt;/li&gt;
&lt;li&gt;Cursor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Paint these layer sequentially.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;protected override void OnPaint(PaintEventArgs e) {
  Graphics g = e.Graphics;
  drawPalette(g);
  drawGrid(g);
  drawBorder(g);
  drawCursor(g);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A modern &lt;strong&gt;Flat UI&lt;/strong&gt; hello from 7 yrs. ago.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;void drawGrid(Graphics g) {
  for(int i = 0; i &amp;lt; rows; i++) {
    g.DrawLine(Pens.Black, 0, blockWidth * (i + 1), blockWidth * cols, blockWidth * (i + 1));
  }
  for(int i = 0; i &amp;lt; cols; i++) {
    g.DrawLine(Pens.Black, blockWidth * (i + 1), 0, blockWidth * (i + 1), blockWidth * rows);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Calculate coordinates of a color, fill blocks, proceed on. Here’s my algorithm of generating RGB colors, you can generate your own shits.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Color getColor(int row, int col) {
  byte r = 0, g = 0, b = 0;
  int step = 0xff / (rows - 1);
  r = (byte)(row * step);
  g = (byte)(step * (col / rows));
  b = (byte)(step * (col % rows));
  return Color.FromArgb(r, g, b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Instead of storing preset colors, all colors shown were automatically generated during run-time.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;current = getColor(pt.Y / blockWidth, pt.X / blockWidth);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Draw mouse cursor. Refresh only &lt;strong&gt;dirty&lt;/strong&gt; parts on canvas.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;void updateCursor(Point pt) {
  lastCursor.X = cursor.X;
  lastCursor.Y = cursor.Y;
  cursor.X = pt.X - pt.X % blockWidth;
  cursor.Y = pt.Y - pt.Y % blockWidth;
  current = getColor(pt.Y / blockWidth, pt.X / blockWidth);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redraw &lt;strong&gt;dirty&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;protected override void OnMouseMove(MouseEventArgs e) {
  updateCursor(e.Location);
  // redraw larger spaces
  Invalidate(new Rectangle(lastCursor.X - 1, lastCursor.Y - 1, lastCursor.Width + 2, lastCursor.Height + 2));
  Invalidate(new Rectangle(cursor.X - 1, cursor.Y - 1, cursor.Width + 2, cursor.Height + 2));
  // fire event
  OnColorChanged();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Trigger &lt;code&gt;OnColorChanged()&lt;/code&gt; event which happens after color is changed.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// -- custom events
public delegate void ColorChangedEventHandler(object sender, ColorChangedEventArgs e);
[Description(&quot;Fires every time when color changed.&quot;)]
public event ColorChangedEventHandler ColorChanged;
protected virtual void OnColorChanged() {
  if(ColorChanged != null) ColorChanged(this, new ColorChangedEventArgs(current));
}
// custom event args
public class ColorChangedEventArgs: EventArgs {
  Color color = Color.Black;
  public Color Color {
    get {
      return color;
    }
    set {
      color = value;
    }
  }
  public ColorChangedEventArgs(Color color): base() {
    this.color = color;
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;With some extra optimizations, you'll have your own palette.&lt;/p&gt;
&lt;img src=&quot;https://conmajia.github.io/assets/upload/2017/02/19/02/5.png&quot; class=&quot;noborder&quot;/&gt; ▲ SRP in use
&lt;p&gt;The End. &lt;span class=&quot;math inline&quot;&gt;\(\Box\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 02:55:00 +0000</pubDate>
<dc:creator>Conmajia</dc:creator>
<og:description>By Conmajia Originally posted in 2012 cnblogs_post_body p {text indent:0 !important;} Introduction S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/simple-palette-control.html</dc:identifier>
</item>
<item>
<title>进程同步概念简介 多线程上篇（四） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10350253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10350253.html</guid>
<description>&lt;div readability=&quot;142.5&quot;&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;h4&gt;&lt;span&gt;临界资源&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一旦有对资源的共享，就必然涉及竞争限制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如尽管有两个人去水井打水，但是水井却只有一个；合理安排的话刚好错开，但是如果安排不合理，那就会出现冲突，出现冲突怎么办？总有一个先来后到，等下就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个水井就是一个临界资源&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;临界资源用来表示一种公共资源或者说是共享数据，可以被多个线程使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;但是每一次，只能有一个线程使用它，一旦临界资源被占用，其他线程要想使用这个资源，就必须等待。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当多进程访问临界资源时，比如打印机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设A进程和B进程轮流获得CPU时间片执行，A打印数学，B打印英语，如果不进行任何的控制与限制，可能会打印出来一张纸上一道数学计算题，接下来是一段英语的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以尽管A进程和B进程轮流获得时间片运行，但是当需要访问临界资源时，一旦有一个进程已经开始使用，另外的进程就不能进行使用，只能等待。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;计算机就是那个计算机，硬盘就是那个硬盘，一段代码中的某个变量（共享变量）就是那个变量.....所有的一切都是只有一份，如果对于某个点多进程同时访问，必然要做一定的限制&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;进程同步的主要任务是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;两种制约关系&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;既然资源访问有限制，到底有哪些场景是需要同步处理的?也就是何时会出现资源冲突？&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133739822-1687398415.png&quot;&gt;&lt;img title=&quot;image_5c567cee_2c7a&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133740171-1543187152.png&quot; alt=&quot;image_5c567cee_2c7a&quot; width=&quot;975&quot; height=&quot;191&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看得出来，其实同步要解决的问题根本就是竞争，间接关系是赤裸裸的的竞争，共享同一个I/O就是一种竞争，尽管他们看似好像没有什么关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接的制约关系，源于进程间的合作，某种程度上来说也是一种竞争，只不过是有条件的竞争，他们共享缓冲区，当缓冲区满时只能是消费者可以运行，生产者需要阻塞，这可以认为缓冲区满这种情况下，消费者独占了缓冲区，生产者不能使用了，不过这种情况下还是说成合作比较容易理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以，要么是因为共享资源带来的竞争，要么就是相互合作带来的依赖。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;h4&gt;&lt;span&gt;临界区&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;有了临界资源的概念，就很容易理解临界区的概念，在程序中，所有的操作都是通过代码执行的，访问临界资源的那段代码就是临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以打水为例，所以在还没到井口，就要画一个大圈，不允许第二个人进入范围，“请站在安全黄线内”这句话熟悉么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是临界区。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133740398-323590729.png&quot;&gt;&lt;img title=&quot;image_5c567cef_528a&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133740618-1424553536.png&quot; alt=&quot;image_5c567cef_528a&quot; width=&quot;431&quot; height=&quot;303&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;h4&gt;&lt;span&gt;同步规则&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如何才能够合理处理竞争或者合作依赖导致的制约？&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;空闲让进&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;忙则等待&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;有限等待&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;让权等待&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;空闲让进和忙则等待很好理解，对于临界资源，如果空闲没有被使用，谁来了之后都可以使用；如果临界资源正在被使用，那么其他后来者就需要进行等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有限等待是指，要求访问临界资源的进程，应保证有限时间内能进入自己的临界区，自己不能傻傻的等，傻傻等受伤的是自己&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让权等待是指，如果无法进入自己的临界区时，应立即释放处理机，而不能占着CPU死等，你死等就算了，别人却也不能用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有限等待和让权等待是两个维度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你不能为了一件事情不顾一切代价等个天荒地老，太伤身了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你非要花五块钱去苏宁买一台电视（等待事件发生），人家不卖给你（无法进入临界区），你就赖着不走（忙等），你就耽误别人做生意了（别的进程无法获得CPU）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有限等待和让权等待的共同特性是必须保证有条件的退出以给其他进程提供运行的机会&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说就是有限时间内你就要走开，你得不到更要走开，你即使能得到但是时间太久也得先让一下别人&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133740813-505236355.png&quot;&gt;&lt;img title=&quot;image_5c567cef_6f63&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133741071-401777812.png&quot; alt=&quot;image_5c567cef_6f63&quot; width=&quot;647&quot; height=&quot;182&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;临界区的设置就是安全黄线的设置，同步规则其实就是临界区两条黄线进出规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于临界区，还可以进一步细分出来进入区和退出区以及剩余区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133741695-1644652383.png&quot;&gt;&lt;img title=&quot;image_5c567cef_1667&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133742126-1931427039.png&quot; alt=&quot;image_5c567cef_1667&quot; width=&quot;418&quot; height=&quot;346&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;临界区算法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Peterson算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以临界区方式解决同步问题就是借助于算法，合理的控制对于临界区的进入与退出，并且保障能够做到：空闲让进、忙则等待、有限等待、让权等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种有名的算法为 &lt;span&gt;&lt;strong&gt;Peterson&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;Peterson算法适用于两个进程在临界区与剩余区间交替执行。假设两个进程分别为p0 和 p1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了表示方便，使用pi表示其中一个进程时，pj表示另外一个，显然有i = 1-j（j = 1-i）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133742634-397669995.png&quot;&gt;&lt;img title=&quot;image_5c567cef_689f&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133742860-1618148418.png&quot; alt=&quot;image_5c567cef_689f&quot; width=&quot;443&quot; height=&quot;281&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用一个int类型变量turn 表示可以进入临界区的线程，如果turn == i，表示pi可以进入临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用boolean 类型数组flag，总共两个进程，所以flag[2]，用来表示哪个进程想要进入临界区，如果flag[i] = true；表示进程pi想要进入临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图红框内为进入区，蓝框内为退出区&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了进入临界区，进程pi首先设置flag[i]为true；并且设置turn为j；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，根据while的条件，只有flag[j] == false 或者turn == i 时，pi可以进入临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是如果我想进入的话，当对方不想进入或者当前允许我进入时，我就可以进入临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，如果只有一个进程想要进入，那么如上所述，对方不想进入时，可以进入临界区，符合空闲让进&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果两个进程都想进入，不管经过多么激烈的竞争，当执行到while时flag[0] 和 flag[1] 都是true，也就是while内部的两个条件，条件1始终是true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是turn只会有一个值，要么0 要么1，也就是说while的第2个条件决定了谁会被while阻塞，谁能够继续执行下去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况下必然能够有一个进程会进入临界区，另外一个被while循环阻塞，所以符合空闲让进、忙则等待&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当临界区内的进程执行结束后，会设置flag[] 标志位，如果此时另外的进程在等待，一旦设置后，其他进程就可以进入临界区（刚才已经说了，如果pi想进入，flag[j] == false 或者turn == i 时可以进入）也就是说当前进程结束后，下一个进程就能够进入了，所以满足有限等待&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的算法，满足了通过进入区和退出区代码的设置，可以做到同步的规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只有一个想要进入临界区，可以直接进入，如果两个竞争进入，只有一个能够进入，另一个会被while循环阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Peterson只是一种临界区算法，还有其他的&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;同步方式之信号量&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;1965年，荷兰学者Dijkstra 提出的信号量(Semaphores)机制是一种卓有成效的进程同步工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;临界区算法的原理可以让多进程对于临界区资源的访问串行化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信号量机制允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;整型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最初信号量机制被称之为整型信号量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;最初由Dijkstra 把整型信号量定义为一个用于表示资源数目的整型量 S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic  Operation)  wait(S)和 signal(S)来访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两个操作一直被分别称为P、V操作（据说，据说因为Dijkstra是荷兰人。在最初论文以及大多数文献中，用P代表wait。用V代表signal。是荷兰语中高度 proberen 和增量verhogen）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Wait(S)和 signal(S)操作可描述为：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   wait(S)：  &lt;span&gt;while&lt;/span&gt; （S&amp;lt;=0&lt;span&gt;）； 
                  S:&lt;/span&gt;=S-1&lt;span&gt;；
  signal(S)：S:&lt;/span&gt;=S+1； 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;wait表示资源申请：如果S小于等于0（资源不足）等待，如果满足那么将会进行S-1，也就是申请资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;signal表示资源释放：每释放一次资源，资源数目 S+1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P、V操作也称之为操作原语，就是指原子操作&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是指一个操作是不可中断的，要么全部执行成功要么全部执行失败(具体怎么保证的，此处可以不用关注） &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133743053-970508681.png&quot;&gt;&lt;img title=&quot;image_5c567cef_1c60&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133743351-85337988.png&quot; alt=&quot;image_5c567cef_1c60&quot; width=&quot;556&quot; height=&quot;212&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;多个线程并发的对资源进行访问时，借助于PV原语操作，可以有效地做到共享资源的限制访问。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;但是，对于整型信号量，P操作也就是 wait(S)&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wait(S)：  &lt;span&gt;while&lt;/span&gt; （S&amp;lt;=0&lt;span&gt;）；
                 S:&lt;/span&gt;=S-1；
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果获取不到资源，将会持续while （S&amp;lt;=0）；，将会永远等待，进程处于忙等状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于原语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(S)和 signal(S)这一原子操作叫做原语，原语是操作系统概念的术语，是由若干条指令组成的，用于完成一定功能的一个过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原语是操作系统的核心部分组成，原语有不可中断性。它必须在管态(内核态，系统态)下执行，并且常驻内存，而个别系统有一部分不在管态下运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以简单的理解是具有指定功能的操作系统提供的一个API性质的一种东西&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;记录型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;鉴于整型信号量机制中的“忙等”情况，演化出来记录型信号量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果进程无法进入临界区，那么进入等待释放CPU资源，并且通过一个链表记录等待的进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记录型信号量机制在整形信号量机制的基础上增加了进程链表指针L，这也是记录型信号量名称的由来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记录型信号量 semaphore 的结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;semaphore {
value：&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
L：进程等待链表（集合）；
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;value相当于整型信号量中的S，L就是一个链表（集合）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，将整形信号量中的整型S，演化为一个结构，这个结构包括一个整型值，还有一个等待的进程链表&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133743704-897643328.png&quot;&gt;&lt;img title=&quot;image_5c567cef_4151&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133744104-909932031.png&quot; alt=&quot;image_5c567cef_4151&quot; width=&quot;630&quot; height=&quot;178&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相对应整型信号量中的wait(S) 和 signal(S)可以描述为：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wait(S)：
var S &lt;/span&gt;=&lt;span&gt; semaphore；
S.value&lt;/span&gt;=S.value-1&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; S.value&amp;lt;0&lt;span&gt; then block(S.L)； 

signal(S):
var S &lt;/span&gt;=&lt;span&gt; semaphore；
S.value&lt;/span&gt;=S.value+1&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; S.value&amp;lt;=0 then wakeup(S.L)；  
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的操作中，均定义了一个semaphore类型的变量S&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果执行 wait 操作，先执行资源减一，如果此时S.value&amp;lt;0，说明在申请资源之前（S.value-1），原来的资源就是&amp;lt;=0，那么该进程阻塞，加入等待队列L中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果执行 signal 操作，先执行资源加一，如果此时S.value&amp;lt;=0，说明在释放资源之前（），原来的资源是&amp;lt;0的，那么将等待链表中的进程唤醒&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;上面逻辑的关键之处在于：&lt;/span&gt;&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;当申请资源时，先进行S.value-1，一旦资源出现负数，说明需要等待，S.value的绝对值就是等待进程的个数，也就是S.L的长度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当资源恢复时，先进行S.value+1，已经有人释放资源了然而资源个数还是小于等于0，说明原来就有人在等待，所以应该去唤醒&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;block 和 wakeup 也都是原语，也就是原子操作。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.L 中&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;wakeup原语，将S.L链表中的等待进程唤醒&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果 S.value的初值为 1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。（效果就如同Peterson算法了）&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;AND 型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;针对于临界区算法或者是整型信号量或者是记录型信号量是针对各进程之间只共享一个临界资源而言的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有些场景下，一个进程需要先获得两个或更多的共享资源后方能执行其任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设A，B两个进程，均需要申请资源D，E&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;238.8582599661&quot;&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;p&gt;&lt;span&gt;最终A，B都被阻塞，如果没有外力作用下，两者都无法从阻塞状态释放出来，这就是死锁&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;相关概念&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个水井，你在打水，另外的人就要等一等，这是人类大脑意识做出来的很基本的反应（人眼识别，大脑解析并且做出反应）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是计算机程序并没有这么智能，你需要对他进行某些处理，以限制别的线程的访问，比如你可以将“安全黄线”变成一个安全门，比如厕所，进去了之后把门关上。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这种概念就是锁，锁就是对资源施加控制，锁指的是一种控制权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当进入临界区时，我们称之为获得锁，获得锁之后就可以访问临界资源；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他线程想要进入临界区，也需要先获得锁，显然，他们获取不到，因为此时，锁被当前正在执行的线程持有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前线程结束后，将会释放锁，别得线程就可以获取这个资源的锁，然后....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;锁表示一种控制权，对临界资源的访问权限，如果临界资源不止一个，就可能出现这种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要先后访问两种临界资源A和B，thread1获得了A线程的锁之后，等待获得B的锁，但是thread2获得了资源B的锁，在等待A资源的锁，这就出现了互相等待的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如一条窄桥，同一时刻仅仅允许一辆车通过，如果一旦出现两辆车都走到桥的一半处，而且互不相让，怎么办？这就是死锁 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AND型信号量机制就是用于解决这种多共享资源下的同步问题的&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AND 同步机制的基本思想：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就是对若干个临界资源的分配，采取原子操作方式：要么把它所请求的资源全部分配到进程，要么一个也不分配。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种思维就是通过对“若干个临界资源“的原子分配，逻辑上就相当于一份共享资源，要么得到，也么得不到，所以就不会出现死锁&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在 wait 操作中，增加了一个“AND”条件，所以被称为AND 同步，也被称为同时wait操作，即Swait(Simultaneous wait)，相应的signal被称为Ssignal(Simultaneous signal)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133744630-700977407.png&quot;&gt;&lt;img title=&quot;image_5c567cef_1391&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133744929-763665978.png&quot; alt=&quot;image_5c567cef_1391&quot; width=&quot;508&quot; height=&quot;192&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Swait(S) 和 Ssignal(S)可以描述为：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Swait(S1，S2，…，Sn)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Si&amp;gt;=1 and …  and Sn&amp;gt;=1&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i=1&lt;span&gt; to n){
          Si&lt;/span&gt;=Si-1&lt;span&gt;;
          }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        将进程插入到第一个资源&lt;/span&gt;&amp;lt;1 的对应的S的队列中，并且程序计数器设置到Swait的开始(比如S1 S2 都大于等于1，但是 S3&amp;lt;1&lt;span&gt;，那么就插入到S3.L中；从头再来就是为了整体分配)
        }

  Ssignal(S1，S2，…，Sn)
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=1&lt;span&gt; to n){
          Si&lt;/span&gt;=Si+1&lt;span&gt;;
          将与Si关联的所有进程从等待队列中删除，移入到就绪队列中
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;AND型信号量机制借助于对于多个资源的“批量处理”的原子操作方式，将多资源的同步问题，转换为一个“同一批资源”的同步问题&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;信号量集&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;记录型信号量机制中，只是对信号量加1（S+1 或者S.value+1） 或者 减1（S-1 或者S.value-1）操作，也就是只能获得或者释放一个单位的临界资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要一次申请N个呢？&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;如果进行N次的资源申请怎么办，一种方式是可以使用多次Wait(S)操作，但是显然效率较低；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外有时候当资源数量低于某一下限值时，就不进行分配怎么办？需要在每次分配资源前检查资源的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这两个问题，对AND信号量机制进一步扩展，形成了一般化的“信号量集”机制。&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;Swait操作可描述如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其中S为信号量，d为需求值，而 t为下限值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Swait(S1，t1，d1，…，Sn，tn，dn)
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( Si&amp;gt;=t1 and …  and Sn&amp;gt;=&lt;span&gt;tn){
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=1&lt;span&gt; to n){
                  Si&lt;/span&gt;=Si-&lt;span&gt;di;
          }
  }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
          将进程插入到第一个资源Si&lt;/span&gt;&amp;lt;ti 的对应的S的队列中，并且程序计数器设置到Swait的开始(比如S1 S2 都大于等于t1,t2，但是 S3&amp;lt;&lt;span&gt;t3，那么就插入到S3.L中；从头再来就是为了整体分配)    
  }

Ssignal(S1，d1，…，Sn，dn)
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=1&lt;span&gt; to n){
                  Si&lt;/span&gt;=Si+&lt;span&gt;di;
                将与Si关联的所有进程从等待队列中删除，移入到就绪队列中
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;信号量集就是AND型信号量机制将资源限制扩展到Ti&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Swait(S，d，d)。此时在信号量集中只有一个信号量 S，但允许它每次申请 d 个资源，当现有资源数少于d时，不予分配。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Swait(S，1，1)。此时的信号量集已蜕化为一般的记录型信号量(S&amp;gt;1时)或互斥信号量(S=1 时)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Swait(S，1，0)。这是一种很特殊且很有用的信号量操作。当 S≥1 时，允许多个进程进入某特定区；当 S 变为 0 后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上面的格式为（s，t，d）也就是第一个为信号量，第二个为限制，第三个为需求量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以Swait(S，1，0)可以用做开关，只要S&amp;gt;=1，&amp;gt;=1时可分配，每次分配0个，所以只要S&amp;gt;=1，永远都进的来，一旦S&amp;lt;1，也就是0往后，那么就不满足条件，就一个都进不去&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;临界区机制通过算法控制进程串行进入临界区，而信号量机制则是借助于原语操作（原子性）对临界资源进行访问控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照各种信号量机制对应的规则以及相应的原语操作，就可以做到对资源的共享同步访问，而不会出现问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信号量机制总共有四种&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133745199-339354137.png&quot;&gt;&lt;img title=&quot;image_5c567cef_148c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133746319-2137886652.png&quot; alt=&quot;image_5c567cef_148c&quot; width=&quot;670&quot; height=&quot;161&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;整型信号量机制可以处理同一共享资源中，资源数目不止一个的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记录型信号量对整型信号量机制的“忙等”进行了优化，通过block以及weakup原语进行阻塞和通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AND型信号量机制解决了对于多个共享资源的同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信号量集是对AND的再一次优化，既能够处理多个共享资源同步的问题，还能够设置资源申请的下限，是一种更加通用的处理方式&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;信号量的应用&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;实现资源互斥访问&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后将各进程访问该资源的临界区 CS置于 wait(mutex)和 signal(mutex)操作之间即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对 mutex 执行wait操作，若该资源此刻未被访问，本次wait操作必然成功，进程便可进入自己的临界区，否则进程将会阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;步骤：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(mutex)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;临界区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signal(mutex)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;剩余区                                          &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;.......&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;实现前趋关系&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;前驱关系就是指执行顺序，比如要求语句S1执行结束之后才能执行语句S2&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;在进程P1中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signal(S)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在进程P2中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(S)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S2； &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;显然，初始时将资源S设置为0，S2需要获取到资源才会执行，而S1执行后就会释放资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个更加复杂的前驱关系图，如何实现？&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133747606-47486040.png&quot;&gt;&lt;img title=&quot;image_5c567cef_399c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133748125-1785800809.png&quot; alt=&quot;image_5c567cef_399c&quot; width=&quot;263&quot; height=&quot;197&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从图中可以看得出来，有S2和S3依赖S1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S4 和 S5依赖S2，而S6依赖S3、S4、S5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，S1应该提供两个信号量，提供给S2和S3 使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S2 应该等待S1的信号量，并且提供两个信号量给S4 和 S5 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S3 应该等待S1的信号量，并且提供一个信号量给S6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S4应该等待S2的信号量，并且提供一个给S6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S5应该等待S2的信号量，并且提供一个给S6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;S6应该等待S3、S4、S5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以总共需要2+2+1+1+1 6个信号量，我们取名为a，b，c，d，e，f，g&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133748478-369983392.png&quot;&gt;&lt;img title=&quot;image_5c567cef_64d4&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133748870-1359989198.png&quot; alt=&quot;image_5c567cef_64d4&quot; width=&quot;259&quot; height=&quot;197&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
Var a,b,c,d,e,f,g：semaphore: =0,0,0,0,0,0,0&lt;span&gt;;
P1{
        S1;
        signal(a);
        signal(b);
}
P2{
        wait(a);
        S2;
        signal(c);
        signal(d);
}
P3{
        wait(b);
        S3;
        signal(e);
}
P4{
        wait(c);
        S4;
        signal(f);
}
P5{
        wait(d);
        S5; 
        signal(g);
}
P6{
        wait(e);
        wait(f); 
        wait(g);
        S6;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有人可能会疑惑，这里的wait和signal又是什么？他就是信号量机制中的 wait 和 signal，他的内容是相当于下面的这些&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133749147-521442128.png&quot;&gt;&lt;img title=&quot;image_5c567cef_6edf&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133749344-114155864.png&quot; alt=&quot;image_5c567cef_6edf&quot; width=&quot;520&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;同步方式之管程&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;虽然信号量机制是一种既方便、又有效的进程同步机制&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;但每个要访问临界资源的进程都必须自备同步操作 wait(S)和 signal(S)，这就使大量的同步操作分散在各个进程中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这不仅&lt;/span&gt;&lt;span&gt;&lt;strong&gt;给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在解决上述问题的过程中，便产生了一种新的进程同步工具——管程(Monitors)。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以管程也可以这么理解：它能够确保临界资源的同步访问，并且还不用将大量的同步操作分散到各个进程中。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;管程的定义&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;系统中的各种硬件资源和软件资源，均可用&lt;/span&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;span&gt;抽象地描述其资源特性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如一个IO设备，有状态（空闲还是忙时？），以及可以对他采取的操作（读取还是写入？）以及等待该资源的进程队列来描述，所以就可以从这三个维度抽象描述一个IO设备，而不关注他们的内部细节&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133749516-570001096.png&quot;&gt;&lt;img title=&quot;image_5c567cef_5971&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133749716-936274317.png&quot; alt=&quot;image_5c567cef_5971&quot; width=&quot;430&quot; height=&quot;182&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;又比如，一个集合，可以使用集合大小，类型，以及一组可执行操作来描述，比如Java中的ArrayList，有属性，还有方法&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133749953-1733405537.png&quot;&gt;&lt;img title=&quot;image_5c567cef_4b29&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133750485-1081468944.png&quot; alt=&quot;image_5c567cef_4b29&quot; width=&quot;968&quot; height=&quot;395&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可以把对该共享数据结构实施的操作定义为一组&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如资源的请求和释放过程定义为request 和 release&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程对共享资源的申请、释放和其它操作，都是通过这组过程对共享数据结构的操作来实现的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类比到JavaBean的话，这些操作就如同setter和getter方法，所有对于指定对象的操作访问都需要通过getter和setter方法 ，类似，所有对共享数据结构实施的操作，都需要借助于这一组过程。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133751081-2146398184.png&quot;&gt;&lt;img title=&quot;image_5c567cef_216b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133753084-894473416.png&quot; alt=&quot;image_5c567cef_216b&quot; width=&quot;505&quot; height=&quot;341&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这组过程还可以根据资源的情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是类比到JavaBean，就是相当于又增加了几个方法，这些方法提供了更多的逻辑判断控制&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Dijkstra于1971年提出：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;把所有进程对某一种临界资源的同步操作都集中起来，构成一个所谓的秘书进程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管程的概念经由Dijkstra提出的概念演化而来，由Hoare和Hanson于1973年提出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义如下&lt;/strong&gt;&lt;/span&gt;： &lt;/p&gt;
&lt;p&gt;&lt;span&gt;一组相关的数据结构和过程一并称为管程。  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hansan的定义：一个管程定义了一个数据结构和能为并发进程在该数据结构上所执行的一组操作，这组操作能同步进程和改变管程中的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以管程的核心部分是对共享数据抽象描述的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;以及可以对该数据结构实施操作的一组&lt;/span&gt;&lt;span&gt;&lt;strong&gt;过程&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用数据结构对共享资源进行抽象描述，那么必然要初始化数据，比如一个队列Queue，有属性size，这是一个抽象的数据结构，那么一个具体的队列到底有多大？你需要设置size 的值，所以对于管程还包括&lt;/span&gt;&lt;span&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133753662-1014839462.png&quot;&gt;&lt;img title=&quot;image_5c567cef_1d53&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133754450-1736356759.png&quot; alt=&quot;image_5c567cef_1d53&quot; width=&quot;274&quot; height=&quot;165&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个基本的管程定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Minitor{
  管程内部的变量结构以及说明;
  函数1(){

  }
  ......
  函数N(){

  }
  init(){
       对管程中的局部变量进行初始化;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;管程特点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;管程就是管理进程，管程的概念就是设计模式中“依赖倒置原则”，依赖倒置原则是软件设计的一个理念，IOC的概念就是依赖倒置原则的一个具体的设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管程将对共享资源的同步处理封闭在管程内，需要申请和释放资源的进程调用管程，这些进程不再需要自主维护同步。有了管程这个大管家（门面模式？）进程的同步任务将会变得更加简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管程是墙，过程是门，想要访问共享资源，必须通过管程的控制（通过城墙上的门，也就是经过管程的过程）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而管程每次只准许一个进程进入管程，从而实现了进程互斥&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133755353-392859849.png&quot;&gt;&lt;img title=&quot;image_5c567cef_6ac2&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133755656-1838030640.png&quot; alt=&quot;image_5c567cef_6ac2&quot; width=&quot;491&quot; height=&quot;462&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管程的核心理念就是相当于构造了一个管理进程同步的“IOC”容器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管程是一个语言的组成成分（非操作系统支持部分），管程的互斥访问完全由编译程序在编译时自动添加上，无需程序员关心，而且保证正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一般的 monitor 实现模式是编程语言在语法上提供语法糖，而如何实现 monitor 机制，则属于编译器的工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，Java中使用synchronized时，这是不是一种管程理念？你只是写了一个synchronized关键字（语法糖），多线程的共享同步完全不用你操心了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（注意：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;并不是所有的语言都支持管程的概念&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133756495-876184343.png&quot;&gt;&lt;img title=&quot;image_5c567cef_476e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203133757454-1146920135.png&quot; alt=&quot;image_5c567cef_476e&quot; width=&quot;771&quot; height=&quot;478&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;条件变量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;管程可以保证互斥，同一时刻仅有一个进程进入管程，所以他必然需要同步工具，如两个同步操作原语 wait和 signal，他还需要互斥量用以控制管程进入的同步&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;当某进程通过管程请求获得临界资源而未能满足时，管程便调用 wait 原语使该进程等待，并将其排在等待队列上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅当另一进程访问完成并释放该资源之后，管程调用signal原语，唤醒等待队列中的队首进程 &lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是，仅仅这个互斥量是不够的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，如果需要处理之前提到过的“执行顺序控制”，如何控制前驱关系？&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以还需要其他的信号量用于针对其他条件进行同步，这些就是条件变量，所以一个完整的管程定义为：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Minitor{
  管程内部的变量结构以及说明;
  condition  条件变量列表;
  函数1(){

  }
  ......
  函数N(){

  }
  init(){
          对管程中的局部变量进行初始化;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;条件变量就是当调用管程过程的进程无法运行时，用于阻塞进程的一种信号量&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;管程中对每个条件变量都须予以说明，其形式为：Var x，y：condition。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对条件变量的操作仅仅是wait和signal，条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供的两个操作即可表示为 x.wait和x.signal，其含义为： &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;①   x.wait：正在调用管程的进程因 x 条件需要被阻塞或挂起，则调用 x.wait 将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。  &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;②   x.signal：正在调用管程的进程发现 x 条件发生了变化，则调用 x.signal，重新启动一个因 x 条件而阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程，而不产生任何结果。这与信号量机制中的 signal操作不同，因为后者总是要执行s:=s+1操作，因而总会改变信号量的状态。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果有进程Q因x条件处于阻塞状态， 当正在调用管程的进程P执行了x.signal操作后，进程Q 被重新启动，此时两个进程 P和Q，如何确定哪个执行，哪个等待，可采用下述两种方式之一进行处理：&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;(1)  P等待，直至Q 离开管程或等待另一条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)  Q等待，直至P离开管程或等待另一条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用哪种处理方式，当然是各执一词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hoare 采用了第一种处理方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 Hansan 选择了两者的折衷，他规定管程中的过程所执行的signal  操作是过程体的最后一个操作，于是，进程P执行signal操作后立即退出管程，因而进程Q马上被恢复执行。 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程控制是操作系统的一种硬性管理，是必须要有的，如果没有进程控制，就没办法合理安排运行进程， 根本无法完成状态的切换维护等。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的同步是一种软逻辑上的，如果不做，并不会导致系统出问题或者进程无法运行，但是如果不进行同步，结果却很可能是错误的，所以也是必须做的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类比装修的话，进程控制就是硬装，不装没法住，总归要水电搞搞好，进程同步就是家具家电和软装，硬装后住进去不会出现“生存问题”（至少有水喝有电用)，但是你要是连个热水壶都没有是打算要喝凉水么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程同步的概念多很复杂抽象，因为毕竟是概念表述，没有涉及到具体的实现细节。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程同步的核心是对于临界资源的访问控制，也就是对于临界区的访问。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不管是临界区算法还是信号量机制还是管程机制，终归也都是控制进入临界区的不同的实现思路。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每种不同的算法、机制都各自有各自的特色，场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信号量机制将临界资源的访问的互斥，演化为可以多个进程访问资源（整型信号量），记录型信号量对整型信号量机制进行优化，处理了忙等的问题 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后继续演化出AND型，可以对不同的资源进行同步，而不仅仅是同一种资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后发展为信号量集的形式，可以对不同的资源、不同的个数、不同的限制进行处理，变得更为通用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;管程更多的是一种设计思维，管程就是管理进程的程序，进程对于资源的同步操作全都依赖管程这一“大管家”，管程是编程语言级别的，不需要程序员进行过多的处理，一般会提供语法糖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意并不是所有的语言都有管程的概念（Java是有的），管程让你从同步的细节中解放出来，可以在很多场景下简化同步的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管程的概念是“线程同步”的“IOC”，大大简化了同步的代价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不管临界区算法还是信号量机制还是借助于管程，他们都是一种同步工具，可以认为他们就是一组“方法”，“方法”的逻辑就是本文前面介绍的原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在需要进程同步问题的解决思路中，可以直接使用“封装好的方法”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上，尽管都是在说操作系统关于进程的同步的处理，其实，在同步问题上进程和线程的设计理念是相通的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为这本质上都是在说并发----多道程序运行的操作系统，通常使用轮转时间片的方式并发的运行多个进程 &lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 06 Feb 2019 02:05:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>进程同步就是临界资源的安全访问策略，同步是多进程乃至后续的多线程必须了解的理论知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10350253.html</dc:identifier>
</item>
<item>
<title>手动添加Servlet构造函数出现的问题及猜想 - 刷书小将</title>
<link>http://www.cnblogs.com/zh1996/p/10353351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh1996/p/10353351.html</guid>
<description>&lt;p&gt;我们需要用到servlet的时候，都是右键，新建一个servlet，但是有人注意到一个细节没有，当我们手动给我们的servlet添加一个构造函数时候，会出现什么状况呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.尝试添加无参构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {

    Test(){
        System.out.println(&lt;/span&gt;&quot;这是构造函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，一个我们都熟悉的基本的servlet，它的名字叫做Test。&lt;/p&gt;
&lt;p&gt;为了方便起见，我们重写接口Servlet中的&lt;strong&gt;&lt;span&gt;init()&lt;/span&gt;&lt;/strong&gt;函数，并配置这个Servlet预加载，更直观的帮助我们理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    Test(){
        System.out.println(&lt;/span&gt;&quot;这是构造函数&quot;&lt;span&gt;);
    }&lt;br/&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        System.out.println(&lt;/span&gt;&quot;这是Init函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，关于预加载，简单说，就是服务器运行的的时候，就会实例化这个servlet并且走完init()函数，这样，我们只需开启服务器，不需要进行请求，就可以看出这个servlet'是否被正确实例化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，测试开始，启动服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实验结果：手动写的Test()构造函数没有被执行，init()函数也没被执行。浏览器访问此Servlet时，404错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实验结论：当我们手动一个无参Servlet构造函数时，服务器就不会创建我们请求的servlet实例，当然也不会走servlet的生命周期&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.尝试有参构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {

    Test(String a){
        System.out.println(&lt;/span&gt;&quot;这是构造函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        System.out.println(&lt;/span&gt;&quot;这是Init函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果同无参构造函数一样：服务器不会创建servlet实例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.web.xml给出错误提示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1121293/201902/1121293-20190205235143357-1128501017.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;错误说，我们的servlet没有默认的构造函数。&lt;/p&gt;
&lt;p&gt;我们现在证明了，手动写一个有参和无参构造函数后，服务器都不会创建这个实例，根据xml错误，我们保留默认无参构造函数，并重载一个有参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {

    Test(){}

    Test(String a){
        System.out.println(&lt;/span&gt;&quot;这是构造函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        System.out.println(&lt;/span&gt;&quot;这是Init函数&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实验结果：构造函数仍无法输出任何内容，init()方法也不输出，说明servlet仍未被创建实例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.结果猜想：我们都知道，当我们请求servlet时候，服务器会根据servlet的servlet-class，反射创建servlet对象，并且会将一些参数传入到实例中（例如request，response，servletConfig等），&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大致流程就是Class.from(&quot;我们的servlet-class&quot;).getDeclaredConstructor(上述说的参数类型...).newInstance(上述说的参数的值...)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因为，只有这样构造实例，才能把一些必要的数据（&lt;/strong&gt;request，response，servletConfig&lt;/span&gt;），封装到实例里面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;况且，这个有参构造函数，第一句又调用了无参构造函数，也就是 this();&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这样，通过有参构造函数将参数传递过来并保存，然后在无参构造函数中，进行初始化servlet，因此，当我们重写了无参构造，服务器就无法完成这些流程，因此，服务器直接做一个判断，如果你手动写了构造函数，直接让这个servlet无法初始化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Feb 2019 15:56:00 +0000</pubDate>
<dc:creator>刷书小将</dc:creator>
<og:description>我们需要用到servlet的时候，都是右键，新建一个servlet，但是有人注意到一个细节没有，当我们手动给我们的servlet添加一个构造函数时候，会出现什么状况呢？ 1.尝试添加无参构造函数 直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zh1996/p/10353351.html</dc:identifier>
</item>
<item>
<title>多媒体文件格式（三）：M3U8 格式 - 灰色飘零</title>
<link>http://www.cnblogs.com/renhui/p/10351870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renhui/p/10351870.html</guid>
<description>&lt;p&gt;M3U8文件是指UTF-8编码格式的M3U文件。M3U文件是记录了一个索引纯文本文件，打开它时播放软件并不是播放它，而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。&lt;/p&gt;
&lt;p&gt;M3U8是一种常见的流媒体格式，主要以文件列表的形式存在，既支持直播又支持点播，尤其在Android、iOS等平台最为常用。&lt;/p&gt;
&lt;p&gt;下面是CCTV6直播播放地址：&lt;a id=&quot;url&quot; href=&quot;http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8&quot; target=&quot;_blank&quot;&gt;http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8&lt;/a&gt;的M3U8的文件列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;35232&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272376000&lt;/span&gt;&lt;span&gt;.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272386000&lt;/span&gt;&lt;span&gt;.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272396000&lt;/span&gt;&lt;span&gt;.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272406000&lt;/span&gt;&lt;span&gt;.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272416000&lt;/span&gt;&lt;span&gt;.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000&lt;/span&gt;&lt;span&gt;,
cctv6hd&lt;/span&gt;-&lt;span&gt;1549272426000&lt;/span&gt;.ts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们来分别说明一下相关的几个字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EXTM3U：这个是M3U8文件必须包含的标签，并且必须在文件的第一行，所有的M3U8文件中必须包含这个标签。&lt;/li&gt;
&lt;li&gt;EXT-X-VERSION：M3U8文件的版本，常见的是3（目前最高版本应该是7）。&lt;/li&gt;
&lt;li&gt;EXT-X-TARGETDURATION：该标签指定了媒体文件持续时间的最大值，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次。&lt;/li&gt;
&lt;li&gt;EXT-X-MEDIA-SEQUENCE：M3U8直播是的直播切换序列，当播放打开M3U8时，以这个标签的值作为参考，播放对应的序列号的切片。&lt;/li&gt;
&lt;li&gt;EXTINF：EXTINF为M3U8列表中每一个分片的duration，如上面例子输出信息中的第一片的duration为10秒。在EXTINF标签中，除了duration值，还可以包含可选的描述信息，主要为标注切片信息，使用逗号分隔开。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于客户端播放M3U8的标准还有更多的讲究，下面我们来介绍一些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分片必须是动态改变的，序列不能相同，并且序列必须是增序的。&lt;/li&gt;
&lt;li&gt;当M3U8没有出现EXT-X-ENDLIST标签时，无论这个M3U8列表中有多少分片，播放分片都是从倒数第三片开始播放，如果不满三片则不应该播放。当然如果有些播放器做了特别定制了，则可以不遵照这个原则。&lt;/li&gt;
&lt;li&gt;以播放当前分片的duration时间刷新M3U8列表，然后做对应的加载动作。&lt;/li&gt;
&lt;li&gt;前一片分片和后一片分片有不连续的时候，播放可能会出错，那么需要X-DISCONTINUTY标签来解决这个错误。&lt;/li&gt;
&lt;li&gt;如果播放列表在刷新之后与之前的列表相同，那么在播放当前分片duration一半的时间内在刷新一次。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在上面，我们提到了，一些上面例子没有出现的一些标签字段，下面我们针对一些额外的标签做一些补充说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EXT-X-ENDLIST：若出现EXT-X-ENDLIST标签，则表明M3U8文件不会再产生更多的切片，可以理解为该M3U8已停止更新，并且播放分片到这个标签后结束。M3U8不仅仅是可以作为直播，也可以作为点播存在，在M3U8文件中保存所有切片信息最后使用EXT-X-ENDLIST结尾，这个M3U8即为点播M3U8。EXT-X-ENDLIST标签可能会出现在播放列表文件的任何地方，但是不能出现两次或以上。&lt;/li&gt;
&lt;li&gt;EXT-X-STREAM-INF：EXT-X-STREAM-INF标签出现在M3U8时，主要是出现在多级M3U8文件中时，例如M3U8中包含子M3U8列表，或者主M3U8中包含多码率M3U8时；该标签后需要跟一些属性，下面就来逐一说明一下这些属性：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;BANDWIDTH：BANDWIDTH的值为最高码率值，当播放EXT-X-STREAM-INF下对应的M3U8时占用的最大码率（必要参数）。&lt;/li&gt;
&lt;li&gt;AVERAGE-BANDWIDTH：AVERAGE-BANDWIDTH的值为平均码率值，当播放EXT-X-STREAM-INF下对应的M3U8时占用的平均码率。（可选参数）。&lt;/li&gt;
&lt;li&gt;CODECS：CODECS的值用于声明EXT-X-STREAM-INF下面对应M3U8里面的音视频编码、视频编码的信息（可选参数）。&lt;/li&gt;
&lt;li&gt;RESOLUTION：M3U8中视频的宽高信息描述（可选参数）。&lt;/li&gt;
&lt;li&gt;FRAME-RATE：子M3U8中的视频帧率（可选参数）。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HLS（全称：Http Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。&lt;/p&gt;
&lt;p&gt;HLS的优势为：自适应码率流播（adaptive streaming）。效果就是客户端会根据网络状况自动选择不同码率的视频流，条件允许的情况下使用高码率，网络繁忙的时候使用低码率，并且能够自动在二者之间随意切换。这对移动设备网络状况不稳定的情况下保障流畅播放非常有帮助。实现方法是服务器端提供多码率视频流，并且在列表文件中注明，播放器根据播放进度和下载速度进行自动调整。&lt;/p&gt;
&lt;p&gt;为什么要用 TS 而不是 MP4？这是因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，播放器连续播放两个 MP4 文件会出现破音和画面间断，影响用户体验。而且如果要在一段长达一小时的视频中跳转，如果使用单个 MP4 格式的视频文件，并且也是用 HTTP 协议，那么需要代理服务器支持 HTTP range request 获取大文件中的一部分。这样的话，对于代理服务器的性能来说要求较高。而 HTTP Live Streaming 则只需要根据列表文件中的时间轴找出对应的 TS 片段下载即可，不需要 range request，对代理服务器的要求小很多。所有代理服务器都支持小文件的高效缓存。&lt;/p&gt;

&lt;h3&gt;1. FFmpeg转MP4为HLS(M3U8)文件&lt;/h3&gt;
&lt;p&gt;将MP4文件转换成HLS(M3U8)命令行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i 好汉歌.mp4 -c copy -f hls -bsf:v h264_mp4toannexb output.m3u8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到生成的M3U8及相应的ts文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682616/201902/682616-20190205171531524-1337912163.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看一下生成的M3U8文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;19&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000000&lt;/span&gt;&lt;span&gt;,
output19.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;10.000000&lt;/span&gt;&lt;span&gt;,
output20.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;9.280000&lt;/span&gt;&lt;span&gt;,
output21.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;4.120000&lt;/span&gt;&lt;span&gt;,
output22.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;2.440000&lt;/span&gt;&lt;span&gt;,
output23.ts
#EXT&lt;/span&gt;-X-ENDLIST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;细心的人可能发现一个问题，就是生成的m3u8文件里只有最后的五个片段的信息。这是因为ffmpeg 默认的list size 为5，所以只获得最后的5个片段。为了解决这个问题，需要指定参数-hls_list_size 0，这样就能包含所有的片段。&lt;/p&gt;
&lt;p&gt;下面是优化后的命令行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i 好汉歌.mp4 -c copy -f hls -hls_list_size &lt;span&gt;0&lt;/span&gt; -bsf:v h264_mp4toannexb output.m3u8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，我们可以看到从output0.ts到output23.ts的文件列表了。&lt;/p&gt;
&lt;p&gt;可能有人会发现，无论是优化之前的命令行，还是优化后的命令行都有一个参数-bsf:v h264_mp4toannexb，这个参数的作用是将MP4中的H.264数据转换成为H.264 AnnexB标准的编码，AnnexB标准的编码常见于实时传输流中。如果源文件为FLV、TS等可以作为直播传输流的视频，则不需要这个参数。&lt;/p&gt;
&lt;p&gt;下面我们逐一介绍下使用FFmpeg生成HLS时还可以配置的其他参数。&lt;/p&gt;

&lt;h3&gt;1. start_number 参数&lt;/h3&gt;
&lt;p&gt;start_number 参数用于设置M3U8列表中的第一片的序列数。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们使用start_number参数设置M3U8中的第一片序列书为100，命令行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i huijia.mp4 -c copy -f hls -start_number &lt;span&gt;100&lt;/span&gt; -hls_list_size &lt;span&gt;0&lt;/span&gt; -bsf:v h264_mp4toannexb output.m3u8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的M3U8内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output100.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output101.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output102.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output103.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output104.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output105.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output106.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;1.000000&lt;/span&gt;&lt;span&gt;,
output107.ts
#EXT&lt;/span&gt;-X-ENDLIST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从输出可以看出，切片的第一片编号是100，上面的命令行参数的-start_number参数已生效。&lt;/p&gt;
&lt;h3&gt;2. hls_time 参数&lt;/h3&gt;
&lt;p&gt;hls_time参数用于设置M3U8列表中切片的duration。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们使用hls_time参数设置M3U8的TS文件的每一片时长为9秒左右。命令行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i huijia.mp4 -c copy -f hls -hls_time &lt;span&gt;9&lt;/span&gt; -hls_list_size &lt;span&gt;0&lt;/span&gt; -bsf:v h264_mp4toannexb output.m3u8 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后查看输出的M3U8内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;9&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;9.000000&lt;/span&gt;&lt;span&gt;,
output0.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;9.000000&lt;/span&gt;&lt;span&gt;,
output1.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;4.000000&lt;/span&gt;&lt;span&gt;,
output2.ts
#EXT&lt;/span&gt;-X-ENDLIST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到TS的文件每一片的时常都是9秒左右，hls_time参数生效。&lt;/p&gt;
&lt;p&gt;( 注意：hls_time设置后效果不一定准确，会受到关键帧大小及其他因素影响。)&lt;/p&gt;
&lt;p&gt;如果需要相对非常准确的切片，可以添加hls_flags的子参数split_by_time来保证生成的切片能够与hls_time设置的切片时长差不多。&lt;/p&gt;
&lt;p&gt;( 注意：split_by_time参数必须与hls_time配合使用，并且使用split_by_time参数有可能会影响首画面体验，例如花屏或者首画面显示慢的问题，因为视频的第一帧不一定是关键帧。)&lt;/p&gt;
&lt;h3&gt;3. hls_list_size 参数&lt;/h3&gt;
&lt;p&gt;hls_list_size参数用于为M3U8列表中的TS切片的个数。其中设置为0的时候，将包含所有。&lt;/p&gt;
&lt;p&gt;这个命令，我们在第3节优化MP4转HLS文件的命令行时使用到了。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们使用hls_list_size参数设置只保留2片TS切片。命令行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i huijia.mp4 -c copy -f hls -hls_list_size &lt;span&gt;2&lt;/span&gt; -bsf:v h264_mp4toannexb output.m3u8 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看输出的M3U8内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
output6.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;1.000000&lt;/span&gt;&lt;span&gt;,
output7.ts
#EXT&lt;/span&gt;-X-ENDLIST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从输出的M3U8内容可以看出，在M3U8文件中只保留了2片TS的文件信息，可以看出hls_list_size设置生效了。&lt;/p&gt;
&lt;h3&gt;4. hls_base_url参数&lt;/h3&gt;
&lt;p&gt;hls_base_url 参数用于为M3U8列表的文件路径设置前置基本路径参数，因为在FFmpeg中生成M3U8时写入的TS切片路径默认为M3U8生成的路径相同，但是实际上TS所存储的路径既可以为本地绝对路径，也可以为相对路径，还可以为网络路径，因此使用hls_base_url参数可以达到该效果，命令行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ffmpeg -re -i huijia.mp4 -c copy -f hls -hls_base_url /Users/renhui/Desktop/test/ -bsf:v h264_mp4toannexb output.m3u8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看输出的M3U8内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#EXTM3U
#EXT&lt;/span&gt;-X-VERSION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-TARGETDURATION:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXT&lt;/span&gt;-X-MEDIA-SEQUENCE:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;/Users/renhui/Desktop/test/&lt;span&gt;output3.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;/Users/renhui/Desktop/test/&lt;span&gt;output4.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;/Users/renhui/Desktop/test/&lt;span&gt;output5.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;3.000000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;/Users/renhui/Desktop/test/&lt;span&gt;output6.ts
#EXTINF:&lt;/span&gt;&lt;span&gt;1.000000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;/Users/renhui/Desktop/test/&lt;span&gt;output7.ts
#EXT&lt;/span&gt;-X-ENDLIST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，TS的路径变为绝对路径了，使用ffplay output.m3u8播放，看到播放是能够正常播放的。这样就可以说明hls_base_url生效了。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Feb 2019 15:38:00 +0000</pubDate>
<dc:creator>灰色飘零</dc:creator>
<og:description>一、M3U8 格式标准介绍 M3U8文件是指UTF-8编码格式的M3U文件。M3U文件是记录了一个索引纯文本文件，打开它时播放软件并不是播放它，而是根据它的索引找到对应的音视频文件的网络地址进行在线播</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renhui/p/10351870.html</dc:identifier>
</item>
</channel>
</rss>