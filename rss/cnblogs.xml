<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[学习笔记] 在Eclipse中使用Hibernate,并创建第一个工程，数据库为Oracle XE - 我有目标</title>
<link>http://www.cnblogs.com/abc789/p/11915224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abc789/p/11915224.html</guid>
<description>&lt;p&gt;前文参考：&lt;a href=&quot;https://www.cnblogs.com/abc789/p/11915234.html&quot; title=&quot;Oracle 11g xe 在windows安装&quot;&gt;Oracle 11g xe 在windows安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Eclipse中使用Hibernate&lt;/p&gt;

&lt;p&gt;https://tools.jboss.org/downloads/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123060736686-1634130997.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Add the following URL to your Eclipse 4.13 (2019-09) installation, via:&lt;/p&gt;
&lt;p&gt;Help &amp;gt; Install New Software… &amp;gt; Work with:&lt;/p&gt;
&lt;p&gt;http://download.jboss.org/jbosstools/photon/stable/updates/&lt;/p&gt;
&lt;p&gt;Then select the individual features that you want to install:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123061924222-1955544218.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123062142016-1429113433.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Next&lt;br/&gt;同意相关协议，点击Finish .&lt;/p&gt;
&lt;p&gt;则会开始下载安装。&lt;/p&gt;
&lt;p&gt;视网络速度，可能需要几分钟到十几分钟的时间才能完成安装。&lt;/p&gt;
&lt;p&gt;最后会提示重启Eclipse才能生效。&lt;/p&gt;
&lt;h2 id=&quot;在eclipse中新建hibernate应用&quot;&gt;在Eclipse中新建Hibernate应用&lt;/h2&gt;
&lt;p&gt;File-&amp;gt;New -&amp;gt; Java Project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123063225250-1691898937.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Finish&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目结构图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123063354770-307943596.png&quot; alt=&quot;项目结构图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在eclipse中新建用户库&quot;&gt;在Eclipse中新建用户库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123063852492-1295345372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123063945373-1236942909.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064014158-364027936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时下面显示了已经建立的用户库列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064058229-769943086.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要添加Hibernate的依赖库，因此点击用户库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064152403-1590199286.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hibernate_4.3.5_final&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064318522-72813841.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064349307-1212569796.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择jar文件&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064437539-514127783.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064528383-1647435935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064552448-836556232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目结构图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123064716858-668525515.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;继续配置hibernate&quot;&gt;继续配置Hibernate&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123065114951-1855146839.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123065217156-772324679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123065327249-1351284394.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123065635818-642295913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后自动形成 如下的文件内容：[本例使用oracle数据库]&lt;/p&gt;
&lt;p&gt;Oracle 11g xe 在windows安装请看如下链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/abc789/p/11915234.html&quot; title=&quot;Oracle 11g xe 在windows安装&quot;&gt;Oracle 11g xe 在windows安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hibernate.cfg.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
    &amp;lt;session-factory&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;123456&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:oracle:thin:@localhost:1521:xe&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;test&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.default_schema&quot;&amp;gt;test&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.Oracle10gDialect&amp;lt;/property&amp;gt;
    &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再增加几个属性&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123070449297-473560481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件更新后的内容如下： 注意要去掉name属性 更改 为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
                                         &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
 &amp;lt;session-factory &amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;123456&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:oracle:thin:@localhost:xe:orcl&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;test&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.default_schema&quot;&amp;gt;test&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.Oracle10gDialect&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
  &amp;lt;!-- 第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 --&amp;gt;
  &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt; 
  &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.default_entity_mode&quot;&amp;gt;pojo&amp;lt;/property&amp;gt;
 &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;继续完善工程hibernate_demo_001&quot;&gt;继续完善工程Hibernate_demo_001&lt;/h2&gt;
&lt;p&gt;新建一个包：mytest001.demo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123075928029-1125104581.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123075959389-1511429354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在包mytest001.demo之下新建一个PO类： Emp&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package mytest001.demo;

public class Emp {
    // 员工的标识属性
    private Integer id;
    // 姓名
    private String name;
    // 年龄
    private Integer age;
    // 工资 （分）
    private Integer salary;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getSalary() {
        return salary;
    }

    public void setSalary(Integer salary) {
        this.salary = salary;
    }

    @Override
    public String toString() {
        return &quot;Emp [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &quot;]&quot;;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此刻此PO Emp.java 尚不具备持久化能力。下面为其添加注解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123081626098-1075070037.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;@Entity 注解声明该类是一个Hibernate持久化类&lt;br/&gt;@Table 指定该类映射的表，对应的数据库表名是T_EMP&lt;br/&gt;@Id 指定该类的标识属性，映射到数据库的主键列&lt;br/&gt;@GeneratedValue(strategy=GenerationType.SEQUENCE) 指定了主键生成策略，由于本文使用Oracle Database, 因此指定了使用 SEQUENCE&lt;/p&gt;
&lt;p&gt;在hibernate.cfg.xml中增加持久化映射类名&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;增加一个新类：EmpManager，用于管理员工。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package mytest001.demo;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.Service;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.service.ServiceRegistryBuilder;


public class EmpManager {

    public static void main(String[] args)  throws Exception  {
         
    //实例化配置
    Configuration configuration  = new Configuration()
            //不带参数则默认加载hibernate.cfg.xml
            .configure();
    
    ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
            .applySettings(configuration.getProperties()).build();
    SessionFactory sFactory = configuration.buildSessionFactory(serviceRegistry);
    
    //创建session 
    Session session = sFactory.openSession();
    
    //开始事务
    Transaction tx = session.beginTransaction();
    //创建员工对象
    Emp emp = new Emp();
    // 设置员工信息
    emp.setAge(28);
    emp.setName(&quot;scott&quot;);
    emp.setSalary(10000);
    session.save(emp);
    // 提交事务
    tx.commit();
    session.close();
    sFactory.close();
            
    
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后配置文件的内容：hibernate.cfg.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
                                         &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
 &amp;lt;session-factory &amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;123456&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:oracle:thin:@localhost:1521:xe&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;test&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.default_schema&quot;&amp;gt;test&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.Oracle10gDialect&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
  &amp;lt;!-- 第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 --&amp;gt;
  &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt; 
  &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
  &amp;lt;property name=&quot;hibernate.default_entity_mode&quot;&amp;gt;pojo&amp;lt;/property&amp;gt;
  &amp;lt;mapping class=&quot;mytest001.demo.Emp&quot;/&amp;gt;
 &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Emp.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package mytest001.demo;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name=&quot;T_EMP&quot;)
public class Emp {
    // 员工的标识属性
    @Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE)
    private Integer id;
    // 姓名
    private String name;
    // 年龄
    private Integer age;
    // 工资 （分）
    private Integer salary;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getSalary() {
        return salary;
    }

    public void setSalary(Integer salary) {
        this.salary = salary;
    }

    @Override
    public String toString() {
        return &quot;Emp [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &quot;]&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行EmpManger&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;十一月 23, 2019 8:50:47 上午 org.hibernate.annotations.common.reflection.java.JavaReflectionManager &amp;lt;clinit&amp;gt;
INFO: HCANN000001: Hibernate Commons Annotations {4.0.4.Final}
十一月 23, 2019 8:50:47 上午 org.hibernate.Version logVersion
INFO: HHH000412: Hibernate Core {4.3.5.Final}
十一月 23, 2019 8:50:47 上午 org.hibernate.cfg.Environment &amp;lt;clinit&amp;gt;
INFO: HHH000206: hibernate.properties not found
十一月 23, 2019 8:50:47 上午 org.hibernate.cfg.Environment buildBytecodeProvider
INFO: HHH000021: Bytecode provider name : javassist
十一月 23, 2019 8:50:47 上午 org.hibernate.cfg.Configuration configure
INFO: HHH000043: Configuring from resource: /hibernate.cfg.xml
十一月 23, 2019 8:50:47 上午 org.hibernate.cfg.Configuration getConfigurationInputStream
INFO: HHH000040: Configuration resource: /hibernate.cfg.xml
十一月 23, 2019 8:50:47 上午 org.hibernate.cfg.Configuration doConfigure
INFO: HHH000041: Configured SessionFactory: null
十一月 23, 2019 8:50:47 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl configure
WARN: HHH000402: Using Hibernate built-in connection pool (not for production use!)
十一月 23, 2019 8:50:47 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH000401: using driver [oracle.jdbc.driver.OracleDriver] at URL [jdbc:oracle:thin:@localhost:1521:xe]
十一月 23, 2019 8:50:47 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH000046: Connection properties: {user=test, password=****}
十一月 23, 2019 8:50:47 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH000006: Autocommit mode: false
十一月 23, 2019 8:50:47 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl configure
INFO: HHH000115: Hibernate connection pool size: 20 (min=1)
十一月 23, 2019 8:50:48 上午 org.hibernate.dialect.Dialect &amp;lt;init&amp;gt;
INFO: HHH000400: Using dialect: org.hibernate.dialect.Oracle10gDialect
十一月 23, 2019 8:50:48 上午 org.hibernate.engine.transaction.internal.TransactionFactoryInitiator initiateService
INFO: HHH000399: Using default transaction strategy (direct JDBC transactions)
十一月 23, 2019 8:50:48 上午 org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory &amp;lt;init&amp;gt;
INFO: HHH000397: Using ASTQueryTranslatorFactory
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.SchemaUpdate execute
INFO: HHH000228: Running hbm2ddl schema update
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.SchemaUpdate execute
INFO: HHH000102: Fetching database metadata
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.SchemaUpdate execute
INFO: HHH000396: Updating schema
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata
INFO: HHH000262: Table not found: T_EMP
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata
INFO: HHH000262: Table not found: T_EMP
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata
INFO: HHH000262: Table not found: T_EMP
十一月 23, 2019 8:50:48 上午 org.hibernate.tool.hbm2ddl.SchemaUpdate execute
INFO: HHH000232: Schema update complete
Hibernate: 
    select
        test.hibernate_sequence.nextval 
    from
        dual
Hibernate: 
    insert 
    into
        test.T_EMP
        (age, name, salary, id) 
    values
        (?, ?, ?, ?)
十一月 23, 2019 8:50:48 上午 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop
INFO: HHH000030: Cleaning up connection pool [jdbc:oracle:thin:@localhost:1521:xe]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到数据库中查询表：(这个表会被自动创建)&lt;br/&gt;select * from t_emp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626817/201911/626817-20191123085310425-1231627725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果再次运行会增加新的记录。&lt;br/&gt;至此，本文完成。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 00:54:00 +0000</pubDate>
<dc:creator>我有目标</dc:creator>
<og:description>前文参考： 'Oracle 11g xe 在windows安装' 在Eclipse中使用Hibernate 安装 Hibernate Tools 插件 https://tools.jboss.org/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/abc789/p/11915224.html</dc:identifier>
</item>
<item>
<title>从网站上偷图偷音乐偷视频教程 - newmiracle宇宙</title>
<link>http://www.cnblogs.com/newmiracle/p/11915245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newmiracle/p/11915245.html</guid>
<description>&lt;p&gt;从网站上偷图偷音乐偷视频教程&lt;/p&gt;

&lt;p&gt;因为有些地方下载图片 音乐 都要下载客户端 或者 要vip 所以避免麻烦 所以&lt;/p&gt;
&lt;p&gt;必备工具:谷歌浏览器&lt;/p&gt;

&lt;p&gt;1 如何偷图&lt;/p&gt;
&lt;p&gt;随便打开个网站连接 &lt;/p&gt;

&lt;p&gt;(1)鼠标右键到图片上选择检查&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09RNQ3iceeib1ib9rVzFyupMQmz9FsBvSt0jybME8ibbJVf2rbPcopqpULlMQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09RNQ3iceeib1ib9rVzFyupMQmz9FsBvSt0jybME8ibbJVf2rbPcopqpULlMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)找图片&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09RuGCibwdTeQCCQd66lRcfibmnraEhWQvbibPia7A75PLlNdMhJf92b7abXA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;1.8152610441767068&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09RuGCibwdTeQCCQd66lRcfibmnraEhWQvbibPia7A75PLlNdMhJf92b7abXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鼠标放上去会有图片提示的 一般在src后面   &lt;/p&gt;

&lt;p&gt;有时候也会写在css里面 &lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.33811475409836067&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09Rew64M60I3hBykRAeoJ5OdYwvBSu1OaBwH2ZOASvHE19RlksyTmwepw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;488&quot;/&gt;&lt;/p&gt;

&lt;p&gt;右键 open new tab 然后 save就行了&lt;/p&gt;

&lt;p&gt;2 如何偷  音乐   &lt;/p&gt;
&lt;p&gt;这个比较简单了 &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.46059782608695654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09R8v1XcPqSBjmqWYtib10AfwGJkztw3dxfkMQXf5GqJtficuyf83iaB5BeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右键 open new tab 然后保存 就可以了 (注意 要开启flash 现在都默认禁止flash了)&lt;/p&gt;

&lt;p&gt;开启flash方法&lt;/p&gt;
&lt;p&gt;chrome://settings/content/flash&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.6732673267326733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OObmU4Bsde3VkGGdTJBUAeXJ0WMmE09Rc9sbb6p3EEhx9ibftQh2aDibuuaNOtwoVz02xu0DibOqwPu7OXJ8U4IhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3 如何偷视频 跟2 步骤一样 &lt;/p&gt;

&lt;p&gt;上面方法只基于 只能在谷歌浏览器打开的H5或者网站&lt;/p&gt;

&lt;p&gt;如果只能再微信上打开 就要用到charles抓包工具了 涉及东西比较多 我简单的说下 具体详细可以自己百度&lt;/p&gt;
&lt;p&gt;1 打开charles &lt;/p&gt;
&lt;p&gt;2点击help菜单点击local ip address 可以获取本地ip 手机上选择代理这个ip 端口8888&lt;/p&gt;
&lt;p&gt;3 然后手机访问网页&lt;/p&gt;
&lt;p&gt;4 charles会弹出弹窗提示 选择allow就行了&lt;/p&gt;

&lt;p&gt;中文乱码解决方案&lt;/p&gt;
&lt;p&gt;1 找到Charles.ini&lt;br/&gt;2 然后修改文件 加个vmarg.2=-Dfile.encoding=UTF-8 就可以了&lt;br/&gt;具体如下&lt;br/&gt;&amp;lt;pre&amp;gt;&lt;br/&gt;working.directory=.&lt;br/&gt;classpath.1=lib/charles.jar&lt;br/&gt;main.class=com.xk72.charles.gui.MainWithClassLoader&lt;br/&gt;vm.version.min=1.4&lt;br/&gt;vm.heapsize.preferred=256M&lt;br/&gt;vmarg.1=-Dsun.java2d.d3d=false&lt;br/&gt;vmarg.2=-Dfile.encoding=UTF-8&lt;br/&gt;dde.enabled=true&lt;br/&gt;dde.class=com.xk72.charles.win32.Win32DDEManager&lt;br/&gt;dde.server.name=Charles&lt;br/&gt;dde.topic=System&lt;br/&gt;single.instance=dde&lt;/p&gt;
&lt;p&gt;[ErrorMessages]&lt;br/&gt;java.not.found=A suitable Java installation was not found. Please visit http://www.java.com/ to install Java.&lt;br/&gt;java.failed=The Java installation is broken. Please uninstall and reinstall Java from http://www.java.com/&lt;br/&gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;



</description>
<pubDate>Sat, 23 Nov 2019 00:10:00 +0000</pubDate>
<dc:creator>newmiracle宇宙</dc:creator>
<og:description>从网站上偷图偷音乐偷视频教程 因为有些地方下载图片&amp;#160;音乐 都要下载客户端 或者 要vip&amp;#160;所以避免麻烦 所以 必备工具:谷歌浏览器 1 如何偷图 随便打开个网站连接 (1)鼠标右键</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newmiracle/p/11915245.html</dc:identifier>
</item>
<item>
<title>Spring框架学习总结（上） - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11915244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11915244.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;
&lt;h2 id=&quot;spring的概述&quot;&gt;1、Spring的概述&lt;/h2&gt;
&lt;p&gt;在学习SSM框架中，我建议初学者最好先学Spring框架，其次mybatis接着springMVC，先学mybatis当然也是可以的，今天我们就以绝对优雅的姿态闯进Spring世界，系好安全带，准备好了吗，出发了哦！！！咳咳....平时开发接触最多的估计就是IOC容器，它可以装载bean（所谓的bean也就是我们java中的类，当然也包括servicedao里面），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到键字new。另外spring的aop，事务管理等等都是我们经常用到的，可见Spring的尤为重要的作用Spring的核心是控制反转（IoC）和面向切面（AOP）&lt;/p&gt;
&lt;h4 id=&quot;什么是spring&quot;&gt;1.1什么是Spring&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a633548b?w=721&amp;amp;h=97&amp;amp;f=png&amp;amp;s=34022&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;肯定有熊dei会问SE/EE开发的一站式框架所谓的一站式是什么意思，（哼，人类，我早就猜到你会问了）&lt;br/&gt;所谓一站式框架指的是有EE开发的每一层解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WEB层 ：SpringMVC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Service层 ：Spring的Bean管理，Spring声明式事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DAO层 ：Spring的Jdbc模板，Spring的ORM模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么学习spring&quot;&gt;1.2为什么学习Spring&lt;/h4&gt;
&lt;p&gt;俗话说，人狠话不多（兄嘚看图）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a41223d8?w=720&amp;amp;h=487&amp;amp;f=png&amp;amp;s=157226&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spring的版本&quot;&gt;1.3Spring的版本&lt;/h4&gt;
&lt;p&gt;Spring3.x、Spring4.x和Spring5.x&lt;/p&gt;
&lt;h4 id=&quot;spring的体系结构&quot;&gt;1.4Spring的体系结构&lt;/h4&gt;
&lt;p&gt;正所谓，人狠话不多（兄嘚看图）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a7ab99eb?w=868&amp;amp;h=468&amp;amp;f=png&amp;amp;s=194758&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring的入门ioc&quot;&gt;2、Spring的入门（IOC）&lt;/h2&gt;
&lt;h4 id=&quot;什么ioc&quot;&gt;2.1什么IOC&lt;/h4&gt;
&lt;p&gt;一说起IOC我就想起了&lt;span&gt;武哥对IOC的理解的几个例子&lt;/span&gt;，可谓通俗易懂，&lt;span&gt;非常适合刚入门Spring的兄嘚&lt;/span&gt;！有兴趣的可以去了解了解武哥，武哥博客：https://blog.csdn.net/eson_15&lt;/p&gt;
&lt;p&gt;IOC（Inverse of Control）：&lt;span&gt;控制反转&lt;/span&gt;，也可以称为&lt;span&gt;依赖倒置。&lt;/span&gt;&lt;br/&gt;控制反转：将对象的创建权反转给（交给）Spring。&lt;/p&gt;
&lt;p&gt;所谓&lt;span&gt;依赖&lt;/span&gt;，从程序的角度看，就是比如A要调用B的方法，那么A就依赖于B，反正A要用到B，则A依&lt;/p&gt;
&lt;p&gt;赖于B。所谓倒置，你必须理解如果不倒置，会怎么着，因为A必须要有B，才可以调用B，如果不倒&lt;/p&gt;
&lt;p&gt;置，意思就是A主动获取B的实例：B b = new B()，这就是最简单的获取B实例的方法（当然还有各种&lt;/p&gt;
&lt;p&gt;设计模式可以帮助你去获得B的实例，比如工厂、Locator等等），然后你就可以调用b对象了。所&lt;/p&gt;
&lt;p&gt;以，不倒置，意味着A要主动获取B，才能使用B；到了这里，就应该明白了倒置的意思了。倒置就是&lt;/p&gt;
&lt;p&gt;A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。&lt;/p&gt;
&lt;h4 id=&quot;通俗理解ioc&quot;&gt;2.2通俗理解IOC&lt;/h4&gt;
&lt;p&gt;形象的举例就是：&lt;br/&gt;通常情况下，假如你有一天在家里口渴了，要喝水，那么你可以到你小区的小卖部去，告诉他们，你需要一瓶水，然后小卖部给你一瓶水！这本来没有太大问题，关键是如果小卖部很远，那么你必须知道：从你家如何到小卖部；小卖部里是否有你需要的水；你还要考虑是否开着车去；等等等等，也许有太多的问题要考虑了。也就是说，为了一瓶水，你还可能需要依赖于车等等这些交通工具或别的工具，问题是不是变得复杂了？那么如何解决这个问题呢？&lt;br/&gt;解决这个问题的方法很简单：小卖部提供送货上门服务，凡是小卖部的会员，你只要告知小卖部你需要什么，小卖部将主动把货物给你送上门来！这样一来，你只需要做两件事情，你就可以活得更加轻松自在：&lt;br/&gt;第一：向小卖部注册为会员。&lt;br/&gt;第二：告诉小卖部你需要什么。&lt;/p&gt;
&lt;p&gt;这和Spring的做法很类似！Spring就是小卖部，你就是A对象，水就是B对象&lt;br/&gt;第一：在Spring中声明一个类：A&lt;br/&gt;第二：告诉Spring，A需要B&lt;/p&gt;
&lt;p&gt;假设A是UserAction类，而B是UserService类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;org.leadfar.service.UserService&quot;/&amp;gt;
&amp;lt;bean id=&quot;documentService&quot; class=&quot;org.leadfar.service.DocumentService&quot;/&amp;gt;
&amp;lt;bean id=&quot;orgService&quot; class=&quot;org.leadfar.service.OrgService&quot;/&amp;gt;
 
&amp;lt;bean id=&quot;userAction&quot; class=&quot;org.leadfar.web.UserAction&quot;&amp;gt;
     &amp;lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Spring这个商店（工厂）中，有很多对象/服务：userService,documentService,orgService，也有很多会员：userAction等等，声明userAction需要userService即可，Spring将通过你给它提供的通道主动把userService送上门来，因此UserAction的代码示例类似如下所示：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package org.leadfar.web;
public class UserAction{
     private UserService userService;
     public String login(){
          userService.valifyUser(xxx);
     }
     public void setUserService(UserService userService){
          this.userService = userService;
     }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码里面，你无需自己创建UserService对象（Spring作为背后无形的手，把UserService对象通过你定义的setUserService()方法把它主动送给了你，这就叫依赖注入！），当然咯，我们也可以使用注解来注入。Spring依赖注入的实现技术是：&lt;span&gt;动态代理&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;下载spring的开发包以及解压说明&quot;&gt;2.3下载Spring的开发包以及解压说明&lt;/h4&gt;
&lt;p&gt;官网下载：http://spring.io/&lt;br/&gt;什么？不会下载？what？？？&lt;br/&gt;好吧，已打包好了QAQ：https://pan.baidu.com/s/18wyE-5SRWcCu12iPOX56pg&lt;br/&gt;什么？没有网盘？what？？？&lt;br/&gt;有事请烧香谢谢...&lt;/p&gt;
&lt;p&gt;解压之后，文件说明：&lt;br/&gt;docs ：Spring的开发规范和API&lt;br/&gt;libs ：Spring的开发的jar和源码&lt;br/&gt;schema ：Spring的配置文件的约束&lt;/p&gt;
&lt;h4 id=&quot;创建web项目引入jar包&quot;&gt;2.4创建web项目，引入jar包&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a67ed096?w=912&amp;amp;h=243&amp;amp;f=png&amp;amp;s=87404&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建普通接口和实现类&quot;&gt;2.5创建普通接口和实现类&lt;/h4&gt;
&lt;p&gt;创建普通接口，定义一个eat方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.sping;

public interface IUserDao {

    public void eat();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建普通实现类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.sping;

public class UserDaoimpl implements IUserDao {
  @Override
    public void eat() {
        // TODO Auto-generated method stub
        System.out.println(用户eat了&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring的ioc底层实现原理&quot;&gt;2.6Spring的IOC底层实现原理&lt;/h4&gt;
&lt;p&gt;创建普通接口和类出现的问题：&lt;br/&gt;如果底层的实现切换了，需要修改源代码，能不能不修改程序源代码对程序进行扩展？&lt;br/&gt;重点来了，要想不改变源码，Spring的IOC就能实现！如下图：&lt;span&gt;&lt;strong&gt;Spring的IOC底层实现&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a7b9ef7c?w=721&amp;amp;h=439&amp;amp;f=png&amp;amp;s=97239&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;将实现类交给spring管理&quot;&gt;2.7将实现类交给Spring管理&lt;/h4&gt;
&lt;p&gt;1、在&lt;span&gt;&lt;strong&gt;classpath&lt;/strong&gt;下（也就是&lt;strong&gt;src&lt;/strong&gt;）创建一个&lt;strong&gt;XML&lt;/strong&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、文件名最好统一叫&lt;span&gt;&lt;strong&gt;applicationContext.xml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、其xml文件的内容头为&lt;span&gt;&lt;strong&gt;schema约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、约束文件位置在spring的解压路径下lspring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.htm&lt;/p&gt;
&lt;p&gt;5、不要求xml文件的内容头能够背出来，但要了解的是你要知道它是怎么来的&lt;/p&gt;
&lt;p&gt;6、xml文件的内容头添加后，将实现类交给Spring管理&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a6692fad?w=1046&amp;amp;h=641&amp;amp;f=png&amp;amp;s=132822&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910abe5ea86?w=590&amp;amp;h=676&amp;amp;f=png&amp;amp;s=62819&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;applicationContext.xml配置文件如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans 
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

 &amp;lt;!-- 实现类UserDaoimpl交给Spring管理 --&amp;gt;
     &amp;lt;bean id=&quot;IuserDao&quot; class=&quot;com.gx.Ioc.UserDaoimpl&quot; &amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910abf16dc7?w=1401&amp;amp;h=558&amp;amp;f=png&amp;amp;s=153433&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编写测试类&quot;&gt;2.8编写测试类&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.Ioc;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpingDemo1 {
    @Test
    public void demo11() {
        // 面向接口传统方式
        UserDaoimpl userdao = new UserDaoimpl();
        userdao.eat();
    }
       //Spring的bean管理方式
    @Test
    public void demo22() {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IUserDao userdao = (IUserDao) applicationContext.getBean(&quot;IuserDao&quot;);
        userdao.eat();

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兄嘚，如果测试不成功最好看看二者是否对应！！！&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a4a358e4?w=1520&amp;amp;h=995&amp;amp;f=png&amp;amp;s=322007&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;兄dei,到这里，Spring的入门（IOC）算是入门了，是不是觉得很有成就感啊?&lt;/p&gt;
&lt;p&gt;拉倒吧! 我都不好意思说了.（兄dei,我错了，是我飘了，呀呀呀，兄dei别打脸鸭QAQ）&lt;/p&gt;
&lt;p&gt;但是我依旧是阻止不了你骄傲的心.&lt;/p&gt;
&lt;p&gt;那就顶我,让我感受感受你的骄傲!哈哈哈QAQ&lt;/p&gt;
&lt;h4 id=&quot;ioc和di&quot;&gt;2.9 IOC和DI&lt;/h4&gt;
&lt;p&gt;IOC不是什么技术，而是一种设计思想，IOC能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了Spring容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;br/&gt;IOC：控制反转，将对象的创建权反转给了Spring。&lt;br/&gt;DI：依赖注入，前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。比如说下面讲到的&lt;span&gt;Spring的属性注入其实就是典型的DI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所谓继承:is a&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Class A{

}
Class B extends A{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓依赖：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Class A{

}
Class B{
    public void xxx(A a){

}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓聚合:has a&lt;/p&gt;
&lt;h2 id=&quot;spring的工厂类&quot;&gt;3、Spring的工厂类&lt;/h2&gt;
&lt;h4 id=&quot;spring工厂类的结构&quot;&gt;3.1Spring工厂类的结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910aec56ac4?w=966&amp;amp;h=669&amp;amp;f=png&amp;amp;s=223776&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;老版本的工厂类beanfactory&quot;&gt;3.2老版本的工厂类：BeanFactory&lt;/h4&gt;
&lt;p&gt;BeanFactory：调用getBean的时候，才会生成类的实例。&lt;/p&gt;
&lt;h4 id=&quot;新版本的工厂类applicationcontext&quot;&gt;3.3新版本的工厂类：ApplicationContext&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;ApplicationContext：加载配置文件的时候，就会将Spring管理的类都实例化&lt;/span&gt;。&lt;br/&gt;ApplicationContext有两个实现类&lt;br/&gt;&lt;span&gt;1、ClassPathXmlApplicationContext ：加载类路径下的配置文件&lt;/span&gt;&lt;br/&gt;2、FileSystemXmlApplicationContext ：加载文件系统下的配置文件&lt;/p&gt;
&lt;h2 id=&quot;spring的配置&quot;&gt;4、Spring的配置&lt;/h2&gt;
&lt;h4 id=&quot;xml的提示配置schema的配置&quot;&gt;4.1XML的提示配置（Schema的配置）&lt;/h4&gt;
&lt;p&gt;在XML文件中要使用各种标签来给spring进行配置，博主我这佩奇脑袋怎么可能记住spring中所有的标签呢，不怕不怕，博主我会配置XML的提示配置QAQ，会了这一招就算兄dei你是乔治脑袋也不用担心（再说了我看兄dei各各英俊潇洒，玉树临风，聪明绝顶...咳咳，暴露了暴露了）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910ae37079d?w=929&amp;amp;h=267&amp;amp;f=png&amp;amp;s=82293&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910aeb44301?w=869&amp;amp;h=653&amp;amp;f=png&amp;amp;s=108110&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d1517755?w=1092&amp;amp;h=1025&amp;amp;f=png&amp;amp;s=213780&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d21e0fb0?w=569&amp;amp;h=540&amp;amp;f=png&amp;amp;s=89584&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;bean的相关的配置-bean-标签的id和name的配置&quot;&gt;4.2Bean的相关的配置（&amp;lt; bean &amp;gt;标签的id和name的配置）&lt;/h4&gt;
&lt;p&gt;id :使用了约束中的唯一约束。里面不能出现特殊字符的。上面提及到了要与getbean参数值对应&lt;/p&gt;
&lt;p&gt;name :没有使用约束中的唯一约束（理论上可以出现重复的，但是实际开发不能出现的）。里面可以出现特殊字符。&lt;/p&gt;
&lt;h4 id=&quot;bean的生命周期的配置了解&quot;&gt;4.3Bean的生命周期的配置（了解）&lt;/h4&gt;
&lt;p&gt;init-method :Bean被初始化的时候执行的方法&lt;br/&gt;destroy-method :Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d21b7fd2?w=1506&amp;amp;h=734&amp;amp;f=png&amp;amp;s=149404&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;bean的作用范围的配置重点&quot;&gt;4.4Bean的作用范围的配置（重点）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;scope属性&lt;/strong&gt;&lt;/span&gt; ：&lt;strong&gt;Bean的作用范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;scope属性值&lt;/strong&gt;如下&lt;/span&gt;（主要用的是前二者）&lt;br/&gt;&lt;span&gt;&lt;strong&gt;singleton&lt;/strong&gt;&lt;/span&gt; ：&lt;strong&gt;scope属性的默认值&lt;/strong&gt;，Spring会采用&lt;strong&gt;单例&lt;/strong&gt;模式创建这个对象。&lt;br/&gt;&lt;strong&gt;prototype&lt;/strong&gt; ：&lt;strong&gt;多例&lt;/strong&gt;模式。（Struts2和Spring整合一定会用到）&lt;br/&gt;request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。&lt;br/&gt;session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。&lt;br/&gt;globalsession ：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相对于session。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d184a32c?w=1338&amp;amp;h=620&amp;amp;f=png&amp;amp;s=584953&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d20c4772?w=1751&amp;amp;h=135&amp;amp;f=png&amp;amp;s=152609&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d3c8fa29?w=1745&amp;amp;h=786&amp;amp;f=png&amp;amp;s=778431&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring的属性注入&quot;&gt;5、Spring的属性注入&lt;/h2&gt;
&lt;p&gt;首先，创建几个普通类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.gx.spring.demo.Car
public class Car {
    private String name;
    private Double price;
    
    public Car(String name, Double price) {
        super();
        this.name = name;
        this.price = price;
    }
    @Override
    public String toString() {
        return &quot;Car [name=&quot; + name + &quot;, price=&quot; + price + &quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.gx.spring.demo.Car2
/**
 * 用作set方法的属性注入类
 */
public class Car2 {
    private String name;
    private Double price;
    public void setName(String name) {
        this.name = name;
    }
    public void setPrice(Double price) {
        this.price = price;
    }
    @Override
    public String toString() {
        return &quot;Car2 [name=&quot; + name + &quot;, price=&quot; + price + &quot;]&quot;;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;com.gx.spring.demo.Person 
/**
 * 用作set方法的对象属性注入类
 */
public class Person {
    private String name;
    private Car2 car2;
    public void setName(String name) {
        this.name = name;
    }
    public void setCar2(Car2 car2) {
        this.car2 = car2;
    }
    @Override
    public String toString() {
        return &quot;Employee [name=&quot; + name + &quot;, car2=&quot; + car2 + &quot;]&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造方法的方式的属性注入&quot;&gt;5.1构造方法的方式的属性注入&lt;/h4&gt;
&lt;p&gt;构造方法的属性注入&lt;br/&gt;&lt;span&gt;constructor-arg&lt;/span&gt; 标签用于配置构造方法的属性注入&lt;br/&gt;name ：参数的名称&lt;br/&gt;value：设置普通数据&lt;br/&gt;&lt;span&gt;ref：引用数据，一般是另一个bean id值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然了，构造方法的方式的属性注入也支持对象属性的注入，标签中对应属性也是ref&lt;br/&gt;如果只有一个有参数的构造方法并且参数类型与注入的bean类型匹配，那就会注入到该构造方法中&lt;/p&gt;
&lt;p&gt;applicationContext.xml中配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 构造方法的方式 --&amp;gt;
    &amp;lt;bean id=&quot;car&quot; class=&quot;com.gx.spring.demo.Car&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;玛莎拉蒂&quot;/&amp;gt;
        &amp;lt;constructor-arg name=&quot;price&quot; value=&quot;800000&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    /**
     * 构造方法方式的普通属性注入方法
     */
    public void demo1(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Car car = (Car) applicationContext.getBean(&quot;car&quot;);
        System.out.println(car);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;set方法的方式的属性注入开发常用&quot;&gt;5.2Set方法的方式的属性注入【开发常用】&lt;/h4&gt;
&lt;p&gt;Set方法的普通属性注入&lt;br/&gt;&lt;span&gt;&lt;strong&gt;property&lt;/strong&gt;&lt;/span&gt; 标签用于配置Set方法的属性注入&lt;br/&gt;name ：参数的名称&lt;br/&gt;value：设置普通数据&lt;br/&gt;&lt;span&gt;&lt;strong&gt;ref&lt;/strong&gt;：引用数据，一般是另一个bean id值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;applicationContext.xml中配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- set方法的方式 --&amp;gt;
&amp;lt;bean id=&quot;car2&quot; class=&quot;com.gx.spring.demo.Car2&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;法拉利黄金跑车&quot;/&amp;gt;
        &amp;lt;property name=&quot;price&quot; value=&quot;10000000&quot;/&amp;gt;
&amp;lt;/bean&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Test
    /**
     * set方法方式的属性注入
     */
    public void demo2(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Car2 car2 = (Car2) applicationContext.getBean(&quot;car2&quot;);
        System.out.println(car2);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Set方法设置对象类型的属性&lt;br/&gt;applicationContext.xml中配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- set方法注入对象类型的属性 --&amp;gt;
&amp;lt;bean id=&quot;Person&quot; class=&quot;com.gx.spring.demo.Person&quot;&amp;gt;
            &amp;lt;!-- value:设置普通类型的值，ref:设置其他的类的id或name--&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;涛哥&quot;/&amp;gt;
        &amp;lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Test
    /**
     * set方法注入对象类型
     */
    public void demo3(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Person person= (Person) applicationContext.getBean(&quot;Person&quot;);
        System.out.println(person);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注解的方式属性注入开发常用&quot;&gt;5.3注解的方式属性注入【开发常用】&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;@Component&lt;/span&gt; （作用在类上通用：组件）&lt;br/&gt;@Component（“userService”）相当于&amp;lt; bean id=”userService” class=”...”&amp;gt;&lt;/p&gt;
&lt;p&gt;衍生:&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@Controller&lt;/strong&gt;&lt;/span&gt; Web层&lt;br/&gt;&lt;strong&gt;@Service&lt;/strong&gt; 业务层&lt;br/&gt;&lt;strong&gt;@Repository&lt;/strong&gt; 持久层&lt;br/&gt;这三个注解是为了让标注类本身的用途清晰&lt;/p&gt;
&lt;p&gt;属性注入的注解 （ &lt;span&gt;可以没有set方法&lt;/span&gt;）&lt;br/&gt;&lt;span&gt;普通类型&lt;/span&gt;属性：&lt;span&gt;@Value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象类型&lt;/span&gt;属性：&lt;span&gt;&lt;strong&gt;@Resource&lt;/strong&gt;&lt;/span&gt; （&lt;strong&gt;对应bean中的id&lt;/strong&gt;）= &lt;strong&gt;@Autowired（类型）&lt;/strong&gt;+ @Qualifier(名称)&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d51846a3?w=1093&amp;amp;h=204&amp;amp;f=png&amp;amp;s=189397&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;注解的理解&quot;&gt;5.3.1注解的理解&lt;/h6&gt;
&lt;p&gt;额，初学框架，注解二字可能对于大部分熊dei来说，太过于陌生，注解其实就是在一个类、方法、属性上，使用@注解名称，就比如是我们最熟悉的接实现口中的方法默认会有一个 @Override （熊dei，这样理解能接受？）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910d6905979?w=842&amp;amp;h=232&amp;amp;f=png&amp;amp;s=39844&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;注解的jar包导入&quot;&gt;5.3.2注解的jar包导入&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spring3.x&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;注解的jar包&lt;/strong&gt;&lt;br/&gt;在Spring3.x的版本中，使用注解开发，只需要 &lt;span&gt;&lt;strong&gt;spring核心基础四包外 + log4j包 + 1个依赖包&lt;/strong&gt;&lt;/span&gt; 即可&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910a67ed096?w=912&amp;amp;h=243&amp;amp;f=png&amp;amp;s=87404&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Spring4.x&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;注解的jar包&lt;/strong&gt;&lt;br/&gt;然而在Spring4.x版本之后则需在 &lt;span&gt;再添加一个要引入 &lt;strong&gt;spring-aop 的 jar 包&lt;/strong&gt;&lt;/span&gt;，因为，spring4.x版本中一些注解的依赖方法封装在spring-aop 的 jar 包中&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910e4da1772?w=996&amp;amp;h=380&amp;amp;f=png&amp;amp;s=186787&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;引入注解的context约束&quot;&gt;5.3.3引入注解的context约束&lt;/h6&gt;
&lt;p&gt;所谓约束就是就是就是约束啦（搽汗），其中bean约束是最基本的约束！（下图也可以看出）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910da4d09b7?w=2400&amp;amp;h=774&amp;amp;f=png&amp;amp;s=524689&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;引入约束:(引入 context 的约束):&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;编写相关的类&quot;&gt;5.3.4编写相关的类&lt;/h6&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public interface UserDao {
public void sayHello();
}
public class UserDaoImpl implements UserDao {
@Override
public void sayHello() {
System.out.println(&quot;Hello Spring...&quot;);
} }&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;配置注解扫描&quot;&gt;5.3.5配置注解扫描&lt;/h6&gt;
&lt;p&gt;Spring的注解开发：组件扫描（&lt;span&gt;不使用类上注解的时候可以不用组件扫描&lt;/span&gt;）&lt;br/&gt;使用注解方式，需要开启组件扫描&amp;lt; &lt;strong&gt;context:component-scan base-package&lt;/strong&gt;=直接包名或者包名.类名/&amp;gt;，当然开发中一般都是&lt;strong&gt;base-package=包名&lt;/strong&gt;，毕竟这样可以扫描整个包，方便开发&lt;br/&gt;Spring 的注解开发:组件扫描(类上注解: 可以直接使用属性注入的注解)&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- Spring 的注解开发:组件扫描(类上注解: 可以直接使用属性注入的注解) --&amp;gt;
&amp;lt;context:component-scan base-package=&quot;com.gx.spring.demo1&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;在相关的类上添加注解&quot;&gt;5.3.6 在相关的类上添加注解&lt;/h6&gt;
&lt;p&gt;1、使用类上注解方式@Component（value=“userDao”），相当于&amp;lt; bean id=&quot;userDao class=&quot;com.gx.类名&quot;&amp;gt;&amp;lt; /bean&amp;gt;&lt;br/&gt;当然value属性名可以省去直接@Component（&quot;userDao&quot;），当然@Component（“value值任意写建议取的要有意义”）&lt;br/&gt;2、注解方式可以没有set方法&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910e51f23a9?w=1510&amp;amp;h=929&amp;amp;f=png&amp;amp;s=310007&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Component(value=&quot;userDao&quot;)  //相当于配置了&amp;lt;bean id=&quot;userDao&quot; class=&quot;com.gx.UserDaoImpl &quot;&amp;gt;&amp;lt;/bean&amp;gt;
public class UserDaoImpl implements UserDao {
@Override
public void sayHello() {
System.out.println(&quot;Hello Spring Annotation...&quot;);
} }&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;编写测试类-1&quot;&gt;5.3.7 编写测试类&lt;/h6&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Test
public void demo3() {
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);
userDao.sayHello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;p名称空间的属性注入spring2.5以后&quot;&gt;5.4P名称空间的属性注入（Spring2.5以后）&lt;/h4&gt;
&lt;p&gt;通过引入p名称空间完成属性的注入：&lt;br/&gt;写法：&lt;br/&gt;普通属性 p:属性名=”值”&lt;br/&gt;对象属性 p:属性名-ref=”值”&lt;/p&gt;
&lt;p&gt;P名称空间的约束引入&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910fa2afcfb?w=720&amp;amp;h=159&amp;amp;f=png&amp;amp;s=73621&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;使用p名称空间&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910faa0aa27?w=720&amp;amp;h=65&amp;amp;f=png&amp;amp;s=28411&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spel的属性注入spring3.0以后&quot;&gt;5.5 SpEL的属性注入（Spring3.0以后）&lt;/h4&gt;
&lt;p&gt;SpEL：Spring Expression Language，Spring的表达式语言。&lt;br/&gt;语法： #{SpEL}&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910fc21bc1b?w=721&amp;amp;h=248&amp;amp;f=png&amp;amp;s=84619&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;集合类型属性注入了解&quot;&gt;5.6集合类型属性注入(了解)&lt;/h4&gt;
&lt;p&gt;集合类型属性配置：&lt;br/&gt;&lt;strong&gt;集合的注入都是在&amp;lt; property&amp;gt;标签中添加子标签&lt;/strong&gt;&lt;br/&gt;数组：&amp;lt; array &amp;gt;&lt;br/&gt;List：&amp;lt; list &amp;gt;&lt;br/&gt;Set：&amp;lt; set &amp;gt;&lt;br/&gt;Map：&amp;lt; map &amp;gt; ，map存放k/v 键值对，使用描述&lt;br/&gt;Properties：&amp;lt; props&amp;gt; &amp;lt; prop key=&quot;&quot;&amp;gt;&amp;lt; /prop&amp;gt;&lt;br/&gt;普通数据：&amp;lt; value &amp;gt;&lt;br/&gt;引用数据：&amp;lt; ref &amp;gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    &amp;lt;!-- Spring的集合属性的注入============================ --&amp;gt;
    &amp;lt;!-- 注入数组类型 --&amp;gt;
    &amp;lt;bean id=&quot;collectionBean&quot; class=&quot;com.gx.spring.demo.CollectionBean&quot;&amp;gt;
        &amp;lt;!-- 数组类型 --&amp;gt;
        &amp;lt;property name=&quot;arrs&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;天才&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;王二&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;冠希&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 注入list集合 --&amp;gt;
        &amp;lt;property name=&quot;list&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;李兵&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;赵如何&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;邓凤&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 注入set集合 --&amp;gt;
        &amp;lt;property name=&quot;set&quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;value&amp;gt;aaa&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;bbb&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;ccc&amp;lt;/value&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 注入Map集合 --&amp;gt;
        &amp;lt;property name=&quot;map&quot;&amp;gt;
            &amp;lt;map&amp;gt;
                &amp;lt;entry key=&quot;aaa&quot; value=&quot;111&quot;/&amp;gt;
                &amp;lt;entry key=&quot;bbb&quot; value=&quot;222&quot;/&amp;gt;
                &amp;lt;entry key=&quot;ccc&quot; value=&quot;333&quot;/&amp;gt;
            &amp;lt;/map&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring的分模块开发的配置&quot;&gt;6、Spring的分模块开发的配置&lt;/h2&gt;
&lt;p&gt;分模块配置：&lt;br/&gt;在加载配置文件的时候，加载多个，没错，这就是传说中的骚操作，堪称开挂级别的操作（当然，这是可以的不是开挂）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e9591100a0216e?w=720&amp;amp;h=35&amp;amp;f=png&amp;amp;s=18927&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在一个配置文件中引入多个配置文件，简直优秀！！！&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/23/16e95910fe7da142?w=705&amp;amp;h=42&amp;amp;f=png&amp;amp;s=15383&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;到这里，恭喜恭喜，各位熊dei以优雅的仪式感闯进Spring世界，对Spring的IOC以及DI有了一定了解了，是不是也很期待Spring的Aop呐,毕竟Spring的核心是控制反转（IOC）和面向切面（AOP）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/99240061#5SpringAOP_487&quot;&gt;【Spring框架学习二】Spring的AOP通俗理解以及AOP的入门开发&lt;/a&gt;（哎哎，别打..别打..别打脸....）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果本文对你有一点点帮助，就请点个赞呗，手留余香，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/22/16e9060850cca455?w=430&amp;amp;h=430&amp;amp;f=png&amp;amp;s=94196&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 00:09:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 1、Spring的概述 在学习SSM框架中，我建议初学者最好先学Spring框架，其次mybatis接着springMVC，先学mybatis当然也是可以的，今天我们就以绝对优雅的姿态闯</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11915244.html</dc:identifier>
</item>
<item>
<title>那些令我倍感认同的句子 - chuyaoxin</title>
<link>http://www.cnblogs.com/cyx-b/p/11914893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyx-b/p/11914893.html</guid>
<description>&lt;p&gt;我愿能朝着太阳生长，做一个温暖的人，不卑不亢，清澈生活。&lt;/p&gt;
&lt;p&gt;时光静悄悄地流逝。世界上有些人因为忙而感到生活的沉重，也有些人因为闲而活得压抑。人啊，都有一本难念的经，可是不同处境的人又很难理解别人的苦处。 &lt;/p&gt;
&lt;p&gt;谁念西风独自凉，萧萧黄叶闭疏窗，沉思往事立残阳。被酒莫惊春睡重，赌书消得泼茶香，当时只道是寻常。&lt;/p&gt;
&lt;p&gt;昨日种种，皆成今我。切莫忧愁，更莫哀，从今往后，怎么收获，怎么栽。&lt;/p&gt;
&lt;p&gt;得不到陌生人的帮助，从来不会觉得痛苦；痛苦往往来自离你最近也是你认为会给予你帮助的人，但他却不愿意帮你。&lt;/p&gt;
&lt;p&gt;持之以恒地做一件事情，只能要求自己。&lt;/p&gt;
&lt;p&gt;牢骚太盛防肠断，风物长宜放眼量。&lt;/p&gt;
&lt;p&gt;雄关漫道真如铁，而今迈步从头越。&lt;/p&gt;
&lt;p&gt;长的是苦难，短的是人生。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 16:15:00 +0000</pubDate>
<dc:creator>chuyaoxin</dc:creator>
<og:description>我愿能朝着太阳生长，做一个温暖的人，不卑不亢，清澈生活。 时光静悄悄地流逝。世界上有些人因为忙而感到生活的沉重，也有些人因为闲而活得压抑。人啊，都有一本难念的经，可是不同处境的人又很难理解别人的苦处。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cyx-b/p/11914893.html</dc:identifier>
</item>
<item>
<title>JAVA继承中子父类的构造方法 - 程序员-可乐先生</title>
<link>http://www.cnblogs.com/12three/p/11914709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/12three/p/11914709.html</guid>
<description>
&lt;p&gt;首先，构造方法&lt;strong&gt;本身会有一个隐式的无参构造&lt;/strong&gt;(默认)：&lt;/p&gt;
&lt;p&gt;　　①不写构造方法，&lt;span&gt;类中的第一行代码事&lt;/span&gt;实上有一个&lt;strong&gt;默认的无参构造&lt;/strong&gt;（系统会&lt;span&gt;隐式&lt;/span&gt;为你写好）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        public Student() {}      隐式地“写”在这里，你看不见

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Strudent类中虽然没有写构造方法，但相当于有上面的无参构造
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   只不过是隐式的，你看不见&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　②只写带参构造方法，相当于只有该带参构造方法（隐式的无参构造会被&lt;span&gt;屏蔽无视掉&lt;/span&gt;，视为无效）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student(String name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  此时原来Strudent类中的隐式的无参构造方法被屏蔽了，无效了
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  类中只有带参构造&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　③若想同时拥有无参和带参构造，必须&lt;span&gt;显式地写出无参&lt;/span&gt;和带参构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显式地将无参构造写出来        &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student(String name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  若想Strudent类中拥有无参构造方法，必须显式地写出来&lt;/span&gt;
&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进一步结合继承，就需要考虑到子父类:&lt;/p&gt;
&lt;p&gt;　　④在子类的构造方法(无论是无参和有参)中，&lt;span&gt;方法中的第一行代码&lt;/span&gt;事实上都&lt;span&gt;隐式&lt;/span&gt;地包含了父类的无参构造方法&lt;br/&gt;　　　　即： super()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Stu &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stu() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; super();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在子类的无参构造中，super()是隐式的“写”在这里的&lt;/span&gt;
&lt;span&gt;    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stu(String name) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; super();&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在子类的带参构造，上面的super()同样也是隐式的“写”在这里的&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这就是为什么，调用子类的构造方法时，都会先调用父类的无参构造方法了，因为默认的super()存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;⑤同理，类似与上面的②，此时若写一个有参构造，&lt;span&gt;super(xx)会把隐式的super()屏蔽掉 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Stu &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Student {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stu(String name) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; super();  原来隐式写在这里的super()被屏蔽了，无效了&lt;/span&gt;
    &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在子类的带参构造， &lt;span&gt;由于的super(name)的存在，super()无效了
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时子类的带参构造中，只有super(name)&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这就是为什么当父类没有无参构造(即只有带参构造——对应情况②)时，子类的构造方法编译无法通过。这是因为子类的构造函数（带参或无参）将调用父类的无参构造函数。 由于编译器试图向子类中的2个构造函数中插入super() ，但父类的默认构造函数未定义，因此编译器会报告错误消息&lt;/span&gt;。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;要解决这个问题，只需要&lt;/p&gt;
&lt;p&gt;      1）添加一个无参构造函数给父类——显式地在父类中添加无参构造&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;      2）删除父类中自定义的有参构造函数——等价于恢复了默认的无参构造&lt;br/&gt;      3）将 Super(XXX) 添加到子类构造函数——通过⑤的原来来屏蔽默认的super()  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一些关于子父类有参无参的组合情况(其实就是排列组合)练习，有兴趣的可以自己验证一下，如下&lt;/span&gt;(图片来源&lt;a href=&quot;https://blog.csdn.net/asd991543753/article/details/89284108&quot;&gt;https://blog.csdn.net/asd991543753/article/details/89284108&lt;/a&gt;)：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1656389/201911/1656389-20191122225907648-24623407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Fri, 22 Nov 2019 15:03:00 +0000</pubDate>
<dc:creator>程序员-可乐先生</dc:creator>
<og:description>首先，构造方法本身会有一个隐式的无参构造(默认)： ①不写构造方法，类中的第一行代码事实上有一个默认的无参构造（系统会隐式为你写好） public class Student { private St</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/12three/p/11914709.html</dc:identifier>
</item>
<item>
<title>【面经系列】一线互联网大厂前端面试技巧深入浅出总结 - Web前端社区</title>
<link>http://www.cnblogs.com/fecommunity/p/11908984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fecommunity/p/11908984.html</guid>
<description>&lt;h2 id=&quot;一面基础面&quot;&gt;1. 一面基础面&lt;/h2&gt;
&lt;h3 id=&quot;面试准备&quot;&gt;1.1 面试准备&lt;/h3&gt;
&lt;h4 id=&quot;个人简历&quot;&gt;1.1.1 个人简历&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;基本信息：姓名-年龄-手机-邮箱-籍贯&lt;/li&gt;
&lt;li&gt;工作经历：时间-公司-岗位-职责-技术栈-业绩（哪些成就）&lt;/li&gt;
&lt;li&gt;学历： 博士 &amp;gt; 硕士 &amp;gt; 本科 &amp;gt; 大专&lt;/li&gt;
&lt;li&gt;工作经历：时间-公司-岗位-职责-技术栈-业绩&lt;/li&gt;
&lt;li&gt;开源项目：GitHub和说明&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自我陈述&quot;&gt;1.2.2 自我陈述&lt;/h4&gt;
&lt;h5 id=&quot;把我面试的沟通方向别把自己带到坑里面&quot;&gt;1.2.2.1 把我面试的沟通方向（别把自己带到坑里面）&lt;/h5&gt;
&lt;p&gt;答：我平时喜欢研究一些网站，并对一些技术的原理和好玩的点感兴趣，我自己也喜欢思考，也喜欢尝试探索有没有更好的方式和实现。（有所收留，不要全部说出来，稍微留一点悬念留作面试官来提问）&lt;/p&gt;
&lt;h5 id=&quot;豁达自信的适度发挥&quot;&gt;1.2.2.2 豁达、自信的适度发挥&lt;/h5&gt;
&lt;p&gt;答：适当自信，向自己擅长的方向上面来引路；要让面试官来欣赏我，而不是来鄙视他。&lt;/p&gt;
&lt;h5 id=&quot;自如谈兴趣&quot;&gt;1.2.2.3 自如谈兴趣&lt;/h5&gt;
&lt;p&gt;（豁达自信，适当收住），巧妙演示实例，适时讨论疑问（不知道的问题请求指导一下，如何去解决，不要说不知道，或者不了解）&lt;/p&gt;
&lt;h5 id=&quot;节奏要适宜&quot;&gt;1.2.2.4 节奏要适宜&lt;/h5&gt;
&lt;p&gt;切忌小聪明（尽量把问题的所有实现方法都写出来，表现出来的是熟练）&lt;/p&gt;
&lt;h3 id=&quot;面试实战&quot;&gt;1.2 面试实战&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;&amp;gt; 1. 方向要对，过程要细（性能优化，过程详细）&lt;br/&gt;&amp;gt; 2. 胆子要大、心态要和（算法题认真思考，认真使劲想；敢于承担责任，不要轻易放弃）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;css相关&quot;&gt;2. CSS相关&lt;/h2&gt;
&lt;h3 id=&quot;页面布局&quot;&gt;2.1 页面布局&lt;/h3&gt;
&lt;h4 id=&quot;如何实现垂直居中布局呢&quot;&gt;2.1.1 如何实现垂直居中布局呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;1.已知宽高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*v1*/
.container {
    position: absolute;
    left: 50%;
    top: 50%;
    marigin-left: -width / 2;
    marigin-top: -width / 2;
}

/*v2*/
.container {
    position: absolute;
    top: calc(50% - 5em);
    left: calc(50% - 9em);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;2.未知宽高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*v1*/
.container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/*v2:flex+ auto*/
.wrapper {
    dislay: flex;
}
.content {
    margin: auto;
}

/*v3. 父元素居中*/
.wrapper {
    display: flex;
    /* 盒子横轴的对齐方式 */
    justify-content: center;
    /* 盒子纵轴的对齐方式 */
    align-items: center;
}

/*v4.body内部居中*/
.content {
     /* 1vh = 1% * 视口高度 */
      margin: 50vh auto;
      transform: translateY(-50%);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何实现水平居中布局呢&quot;&gt;2.1.2 如何实现水平居中布局呢？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;如果需要居中的元素为常规流中 inline / inline-block 元素，为父元素设置 text-align: center;&lt;/li&gt;
&lt;li&gt;父元素上设置 text-align: center; 居中元素上margin 为 auto。&lt;/li&gt;
&lt;li&gt;如果元素positon: absolute; 那么
&lt;ul&gt;&lt;li&gt;0）设置父元素postion: relative&lt;/li&gt;
&lt;li&gt;1）为元素设置宽度，&lt;/li&gt;
&lt;li&gt;2）偏移量设置为 50%，&lt;/li&gt;
&lt;li&gt;3）偏移方向外边距设置为元素宽度一半乘以-1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何实现三栏布局呢&quot;&gt;2.1.3 如何实现三栏布局呢？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;left和right写在center前面，并且分别左右浮动；&lt;/li&gt;
&lt;li&gt;左右区域分别postion：absolute，固定到左右两边;中间的这个div因为是块级元素，所以在水平方向上按照他的包容块自动撑开。&lt;/li&gt;
&lt;li&gt;父元素display: table;并且宽度为100%; 每一个子元素display: table-cell; 左右两侧添加宽度，中间不加宽度&lt;/li&gt;
&lt;li&gt;包裹这个3个块的父元素display: flex; 中间的元素flex: 1;&lt;/li&gt;
&lt;li&gt;网格布局&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* 网格布局 */
.wrapper {
    display: grid;
    width: 100%;
    grid-template-columns: 300px 1fr 300px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;知道css动画的实现吗&quot;&gt;2.2 知道CSS动画的实现吗？&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;知道transition 过渡动画和animation 关键帧动画区别和具体实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.CSS动画实现轮播图&lt;/li&gt;
&lt;li&gt;2.CSS动画实现旋转的硬币&lt;/li&gt;
&lt;li&gt;3.CSS动画实现钟摆效果&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;css盒子模型&quot;&gt;2.3 CSS盒子模型&lt;/h3&gt;
&lt;h4 id=&quot;说一下css的盒子模型标准模型和ie模型的区别css如何设置这两种模型&quot;&gt;2.3.1 说一下CSS的盒子模型？标准模型和IE模型的区别？CSS如何设置这两种模型？&lt;/h4&gt;
&lt;h3 id=&quot;css样式获取&quot;&gt;2.4 CSS样式获取&lt;/h3&gt;
&lt;h4 id=&quot;js如何设置获取盒子模型对应的宽度和高度面试重点&quot;&gt;2.4.1 JS如何设置获取盒子模型对应的宽度和高度？(面试重点)&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;dom.style.width/height ： 只能取到内联样式的的属性信息（拿不到外部引入的CSS样式信息的）&lt;/li&gt;
&lt;li&gt;dom.currentStyle.width/height : 会拿到浏览器渲染之后的属性信息（IE浏览器）&lt;/li&gt;
&lt;li&gt;window.getComputedStyle(dom).width/height : Chrome/Firefox 兼容， Firefox可以通过document.defaultView.getComputedStyle(dom)的方式来获取&lt;/li&gt;
&lt;li&gt;dom.getBoundingClientRect().width/height : 可以获取距离viewport位置的宽度和高度&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bfc&quot;&gt;2.5 BFC&lt;/h3&gt;
&lt;h4 id=&quot;根据盒子模型解释边距额重叠问题边距重叠问题的解决方案&quot;&gt;2.5.1 根据盒子模型解释边距额重叠问题？边距重叠问题的解决方案？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121225123730-60633813.jpg&quot; alt=&quot;CSS盒子模型&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父子元素&lt;/li&gt;
&lt;li&gt;兄弟元素&lt;/li&gt;
&lt;li&gt;其他 --------------------------计算方式：以参数的最大值来进行计算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：对父级元素创建BFC&lt;/p&gt;
&lt;h4 id=&quot;bfc原理&quot;&gt;2.5.2 BFC原理&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;BFC： 块级格式化上下文，IFC（内联格式化上下文）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;在BFC的垂直边距上面会发生重叠&lt;/li&gt;
&lt;li&gt;BFC的区域不会与浮动元素的BOX重叠&lt;/li&gt;
&lt;li&gt;BFC在页面上是一个独立的渲染区域，外部的元素不会影响到我，同时也不会影响到外部的元素&lt;/li&gt;
&lt;li&gt;计算BFC的高度的时候，浮动元素也会参与运算&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何创建bfc&quot;&gt;2.5.3 如何创建BFC？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;float值不是none&lt;/li&gt;
&lt;li&gt;position值不是static或者relative&lt;/li&gt;
&lt;li&gt;display值为table, table-cell, inline-box1.&lt;/li&gt;
&lt;li&gt;overflow : auto/hidden&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;bfc的使用场景重点理解&quot;&gt;2.5.4 BFC的使用场景？（重点理解）&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;解决边距的重叠问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;section id=&quot;margin&quot;&amp;gt;
        &amp;lt;style&amp;gt;
            #margin {
                background-color: #4eff35;
                overflow: hidden;
            }
            #margin&amp;gt;p {
                /*上 左右 下*/
                margin: 5px auto 25px;
                background-color: #ff255f;
            }
        &amp;lt;/style&amp;gt;
        &amp;lt;p&amp;gt;1&amp;lt;/p&amp;gt;
        &amp;lt;!--把一个元素放在一个容器里面，为这个容器创建BFC即可解决边距重叠问题--&amp;gt;
        &amp;lt;div style=&quot;overflow: hidden&quot;&amp;gt;
            &amp;lt;p&amp;gt;2&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;p&amp;gt;3&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;BFC 不与float部分重叠的解决&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;section id=&quot;layout&quot;&amp;gt;
      &amp;lt;style&amp;gt;
          #layout {
              background-color: #48adff;
          }
          #layout .left {
              float: left;
              height: 300px;
              width: 200px;
              background-color: #ff4344;
          }
          #layout .right {
              height: 400px;
              background-color: #ff255f;
              /*给右边的这个盒子容器创建一个BFC, 这个容器里面的内容就会沿着垂直方向延伸*/
              overflow: auto;
              /*overflow: auto;*/
              /*display: table;*/
              /*float: left;*/
              /*position: fixed;*/
          }
      &amp;lt;/style&amp;gt;
      &amp;lt;div class=&quot;left&quot;&amp;gt;
          LEFT
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;right&quot;&amp;gt;
          RIGHT
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt;111&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/section&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;BFC子元素即使是float元素也要参与运算&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;section id=&quot;float&quot;&amp;gt;
      &amp;lt;style&amp;gt;
          /*一个盒子内部的内容如果是浮动的话，那么这个盒子的内容实际上是不参与父容器高度计算的*/
          #float {
              background-color: red;
              /*overflow: hidden;*/
              float: left;
          }
          #float .float {
              float: left;
              font-size: 30px;
          }
      &amp;lt;/style&amp;gt;
      &amp;lt;div class=&quot;float&quot;&amp;gt;
          我是浮动的元素
      &amp;lt;/div&amp;gt;
&amp;lt;/section&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;事件相关&quot;&gt;3. 事件相关&lt;/h2&gt;
&lt;h3 id=&quot;dom事件&quot;&gt;3.1 DOM事件&lt;/h3&gt;
&lt;h4 id=&quot;dom事件的级别有哪些&quot;&gt;3.1.1 DOM事件的级别有哪些？&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM0级事件处理，DOM2级事件处理和DOM3级事件处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;DOM0 : element.onclick = function(e) {}&lt;br/&gt;DOM1 ：该标准中未涉及到事件绑定的相关东西&lt;/li&gt;
&lt;li&gt;DOM2 : element.addEventListener('click', function(e){}, false)， 一个DOM元素可以添加多个事件&lt;/li&gt;
&lt;li&gt;DOM3 : element.addEventListener('keyup', function(e){}, false)，在DOM2标准基础上面增加了新的事件类型：鼠标事件，键盘事件，焦点事件&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;dom事件模型有哪些&quot;&gt;3.1.2 DOM事件模型有哪些？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;事件捕获：从外向内, window -&amp;gt; document -&amp;gt; body -&amp;gt; button&lt;/li&gt;
&lt;li&gt;事件冒泡：从内向外，button -&amp;gt; body -&amp;gt; document -&amp;gt; window&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;dom事件流&quot;&gt;3.1.3 DOM事件流？&lt;/h4&gt;
&lt;p&gt;浏览器为当前的页面与用户进行交互的过程中，点击鼠标后事件如何传入和响应的呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;捕获阶段：从外部容器开始向内&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;目标阶段：事件通过捕获到达目标阶段&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;冒泡阶段：从目标元素再上传到window对象&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;什么事件可以代理什么事件不可以代理呢&quot;&gt;3.1.4 什么事件可以代理？什么事件不可以代理呢？&lt;/h4&gt;
&lt;p&gt;什么样的事件可以用事件委托，什么样的事件不可以用呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通常支持事件冒泡（Event Bubbling）的事件类型为鼠标事件和键盘事件，例如：mouseover, mouseout, click, keydown, keypress。&lt;/li&gt;
&lt;li&gt;接口事件(&lt;strong&gt;指的是那些不一定与用户操作有关的事件&lt;/strong&gt;)则通常不支持事件冒泡（Event Bubbling），例如：load, change, submit, focus, blur。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;很明显&lt;/strong&gt;：focus 和 blur 都属于不支持冒泡的接口事件。既然都不支持冒泡，那又如何实现事件代理呢？&lt;/p&gt;
&lt;h4 id=&quot;ie和dom事件流的区别&quot;&gt;3.1.5 IE和DOM事件流的区别？&lt;/h4&gt;
&lt;p&gt;IE采用冒泡型事件 Netscape使用捕获型事件 DOM使用先捕获后冒泡型事件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;冒泡型事件模型： button -&amp;gt; div -&amp;gt; body (IE浏览器本身只支持Bubbling不支持Capturing)&lt;/li&gt;
&lt;li&gt;捕获型事件模型： body -&amp;gt; div-&amp;gt; button (Netscape事件流，网景浏览器公司)&lt;/li&gt;
&lt;li&gt;DOM事件模型： body -&amp;gt; div -&amp;gt; button -&amp;gt; button -&amp;gt; div -&amp;gt; body (先捕获后冒泡，除了IE以外的其他浏览器都支持标准的DOM事件处理模型)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;规范和浏览器实现的差别？
&lt;ul&gt;&lt;li&gt;DOM2级事件规范的捕获阶段，事件从文档节点document开始传播，现代浏览器大多数都是从window对象开始传播事件的；&lt;/li&gt;
&lt;li&gt;DOM2级事件规范捕获阶段不涉及事件目标，现代浏览器大多数都在这个阶段包含事件目标。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事件对象event的属性方法的差别&quot;&gt;3.1.6 事件对象event的属性方法的差别?&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;        IE                    DOM
cancelBubble = true    stopPropagation()    // 停止冒泡
returnValue = false    preventDefault()     // 阻止元素默认事件
srcEelement            target               // 事件目标&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;描述dom事件捕获的具体流程&quot;&gt;3.1.7 描述DOM事件捕获的具体流程？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;window -&amp;gt; document -&amp;gt; HTML标签 -&amp;gt; body -&amp;gt; ... -&amp;gt; 目标元素&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;关键点： 注意根节点是window这个对象的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;container&quot;&amp;gt;
      &amp;lt;style&amp;gt;
          #container {
              width: 200px;
              height: 200px;
              background-color: #ff255f;
          }
      &amp;lt;/style&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script&amp;gt;
      // 事件捕获机制
      window.addEventListener('click', function(){
          console.log('window capture');
      }, true)
      document.addEventListener('click', function () {
          console.log('document capture');
      }, true)
      document.documentElement.addEventListener('click', function () {
          console.log('HTML capture');
      }, true)
      document.body.addEventListener('click', function () {
          console.log('body capture');
      }, true)
      document.getElementById('container').addEventListener('click', function () {
          console.log('container capture');
      }, true)

      // 事件冒泡机制
      window.addEventListener('click', function(){
          console.log('window capture');
      })
      document.addEventListener('click', function () {
          console.log('document capture');
      })
      document.documentElement.addEventListener('click', function () {
          console.log('HTML capture');
      })
      document.body.addEventListener('click', function () {
          console.log('body capture');
      })
      document.getElementById('container').addEventListener('click', function () {
          console.log('container capture');
      })

      // 输出结果
      window capture  --&amp;gt; document capture --&amp;gt; HTML capture --&amp;gt; body capture --&amp;gt; container capture --&amp;gt; container capture --&amp;gt;  body capture --&amp;gt; HTML capture --&amp;gt; document capture --&amp;gt; window capture
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何拿到html这个标签节点元素呢加分项&quot;&gt;3.1.8 如何拿到HTML这个标签节点元素呢？(加分项)&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var html = document.documentElement;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;描述event对象的常见应用&quot;&gt;3.1.9 描述Event对象的常见应用？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;e.preventDefault() : 阻止默认事件（如阻止a标签的默认跳转行为）&lt;/li&gt;
&lt;li&gt;e.stopPropagation() : 阻止事件冒泡的行为&lt;/li&gt;
&lt;li&gt;*** e.stopImmediatePropagation() : 事件响应的优先级的应用场景，如果一个元素绑定了多个事件，但是又不想让其他的事件执行的时候使用该方法【也会阻止冒泡】&lt;/li&gt;
&lt;li&gt;e.currentTarget : 当前所绑定的事件对象&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  document.documentElement.onclick = function(e) {
    console.log(e.currentTarget, e.target);       // &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;...&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;（）给绑定事件的那个元素, 当前被点击的那个元素
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;e.target : 当前被点击的元素，父元素使用事件代理的方式来实现，可以直接使用该属性获取被点击的那个元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;如何自定义事件重点&quot;&gt;3.2 如何自定义事件？(重点))&lt;/h3&gt;
&lt;h4 id=&quot;如何给一个按钮绑定一个自己定义的事件呢&quot;&gt;3.2.1 如何给一个按钮绑定一个自己定义的事件呢？&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // v1. 使用Event对象来自定义事件
  // 开始创建一个自己定义的事件对象
  var eve = new Event('customEvent');
  // 使用dom2事件处理的方式来给这个元素绑定一个事件
  var dom = document.documentElement;
  dom.addEventListener('customEvent', function(e) {
    console.log('customEvent called!');
  });
  // 下面的这句话可以在适合的场景中来触发一个自己定义的事件对象
  setTimeout(function(){
    // 在1s之后触发这个事件
    dom.dispatchEvent(eve);
  }, 1000)


  // v2. 使用CustomEvent来实现自定义事件
  var dom = document.documentElement;
  // 使用CustomEvent的方式可以在事件触发的时候传递一个参数，然后通过e.detail 的方式来获取这个参数信息
  var myClick = new CustomEvent('myClick', {detail : {name : 'zhangsan', age : 24}});
  dom.addEventListener('myClick', function(e){
    console.log(e.detail, e.target)
  })
  dom.dispatchEvent(myClick);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;http协议&quot;&gt;4. HTTP协议&lt;/h2&gt;
&lt;h3 id=&quot;http协议的主要特点&quot;&gt;4.1 HTTP协议的主要特点？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;简单快速&lt;/li&gt;
&lt;li&gt;灵活&lt;/li&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;无状态&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;http报文的组成部分&quot;&gt;4.2 HTTP报文的组成部分？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;请求报文&lt;br/&gt;请求行：请求方法 资源地址 HTTP版本&lt;br/&gt;请求头： key : value&lt;br/&gt;空行 :&lt;br/&gt;请求体 : name=zhangsan&amp;amp;age=18&lt;/li&gt;
&lt;li&gt;响应报文 : HTTP版本 状态码&lt;br/&gt;状态行&lt;br/&gt;响应头&lt;br/&gt;空行&lt;br/&gt;响应体&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;http方法&quot;&gt;4.3 HTTP方法？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GET : 获取资源&lt;/li&gt;
&lt;li&gt;POST ： 传输资源&lt;/li&gt;
&lt;li&gt;PUT ：更新资源&lt;/li&gt;
&lt;li&gt;DELETE ： 删除资源&lt;/li&gt;
&lt;li&gt;HEAD ：获取报文首部&lt;/li&gt;
&lt;li&gt;OPTIONS : 允许客户端查看服务器的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;post和get的区别&quot;&gt;4.4 POST和GET的区别？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;GET请求在浏览器回退的时候是无害的，而POST会再次提交请求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;GET请求产生的URL地址可以被收藏，而POST不可以&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GET请求会被浏览器主动缓存，而POST不会，除非主动设置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;GET请求只能进行URL编码，而POST支持多种编码方式&lt;/li&gt;
&lt;li&gt;GET请求参数会被完整第保留在浏览器的历史记录里面，而POST参数不会被保留&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GET请求爱URL中传送的参数的长度是有限的（2KB），而POST没有限制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对参数的数据类型，GET值接受ASCII字符，而POST没有限制&lt;/li&gt;
&lt;li&gt;POST比GET更安全，GET参数直接暴露在URL上，所以不能用来传递敏感信息&lt;br/&gt;&lt;strong&gt;9. GET参数通过URL传递，POST参数直接放在了Request body中&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;http状态码&quot;&gt;4.5 HTTP状态码？&lt;/h3&gt;
&lt;h4 id=&quot;状态码的第一位&quot;&gt;4.5.1 状态码的第一位&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1xx&lt;/strong&gt; ：指示信息-表示请求已接收，继续处理（重点）&lt;/li&gt;
&lt;li&gt;2xx ：成功-表示请求已被成功接收&lt;/li&gt;
&lt;li&gt;3xx ：重定向-要完成请求必须进行更进一步的操作&lt;/li&gt;
&lt;li&gt;4xx ：客户端错误-请求有语法错误或请求无法实现&lt;/li&gt;
&lt;li&gt;5xx ：服务器错误-服务器未能实现合法的请求&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;状态码详解&quot;&gt;4.5.2 状态码详解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;200 OK ： 客户端请求成功&lt;/li&gt;
&lt;li&gt;206 Partial Content ： 客户端发送了一个带有Range头的GET请求（Video标签或者audio标签在请求数据的时候）&lt;/li&gt;
&lt;li&gt;301 Moved Permanently ： 请求的页面已经转移到了新的URL&lt;/li&gt;
&lt;li&gt;302 Found ： 所请求的页面已经临时转移到了新的URL&lt;/li&gt;
&lt;li&gt;304 Not Modified ：客户端有缓冲的文档并发出了一个条件下的请求，原来缓冲的文档还可以继续使用&lt;/li&gt;
&lt;li&gt;400 Bad Request ： 客户端请求有语法错误，不被服务器所理解&lt;/li&gt;
&lt;li&gt;401 Unauthorized ： 请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用&lt;/li&gt;
&lt;li&gt;403 Forbidden：对被请求页面的访问被禁止&lt;/li&gt;
&lt;li&gt;404 Not Found ： 请求资源不存在&lt;/li&gt;
&lt;li&gt;500 Internal Server Error ：服务器发生不可预期的错误，原来缓冲的文档还可以继续使用&lt;/li&gt;
&lt;li&gt;503 Service Unavailable ： 请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是持久连接&quot;&gt;4.6 什么是持久连接？&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;HTTP协议采用‘请求-应答’模式， HTTP1.1版本才支持的，使用Keep-alive字段可以建立一个长连接，从而不需要每次请求都去建立一个新的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是管线化&quot;&gt;4.7 什么是管线化？&lt;/h3&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;4.7.1 基本概念&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在使用持久连接（Keep-alive）的情况下，某个连接上的消息的传递类似于：请求1 --&amp;gt; 响应1 --&amp;gt; 请求2 --&amp;gt; 响应2 --&amp;gt; 请求3 --&amp;gt; 响应3&lt;/li&gt;
&lt;li&gt;管线化的过程： 请求1 --&amp;gt; 请求2 --&amp;gt; 请求3 --&amp;gt; 响应1 --&amp;gt; 响应2 --&amp;gt; 响应3&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;管线化的特点特点&quot;&gt;4.7.2 管线化的特点（特点）&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;管线化机制通过持久连接完成，仅在HTTP1.1版本之后支持&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只有GET和HEAD请求可以进行管线化，POST有所限制的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初次创建连接的时候不应该启动管线机制，因为对方（服务器）不一定支持HTTP1.1版本的协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;管线化不会影响到响应到来的顺序，HTTP响应返回的顺序并未改变&lt;/li&gt;
&lt;li&gt;HTTP1.1 要求服务器支持管线化，但并不要求服务器也对响应进行管线化处理，只是要求对于管线化的请求不失败即可&lt;/li&gt;
&lt;li&gt;由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器和代理程序对管线化的支持并不好，因此现代的浏览器如Chrome和Firefox默认并没有开启管线化支持&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;原型链&quot;&gt;5. 原型链&lt;/h2&gt;
&lt;h3 id=&quot;创建对象的几种方法&quot;&gt;5.1 创建对象的几种方法？&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 1. 使用字面量的方式来创建
var o1 = {name : 'zhangsan'};
var o11 = new Object({name : 'zhangsan'});

// 2. 使用普通构造函数的方式来创建
var M = function(){
    this.name = 'zhangsan';
}
var o2 = new M();

// 3. Object.create方法
var p = {name : 'zhangsan'};
var o3 = Object.create(p);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;原型构造函数实例原型链&quot;&gt;5.2 原型、构造函数、实例、原型链？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;：使用new运算符来声明一个实例（任何函数都是可以通过构造函数来使用的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链&lt;/strong&gt;：通过原型链可以找到上一级别的原型对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型对象&lt;/strong&gt;：多个实例公用的数据和属性或者方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121225247943-825633367.jpg&quot; alt=&quot;原型对象&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;instanceof的原理&quot;&gt;5.3 instanceof的原理？&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;instanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 2. 使用普通构造函数的方式来创建
var M = function(){
  this.name = 'zhangsan';
}
var o2 = new M();
undefined
o2.__proto__ == M.prototype
true
o2.__proto__ == M.prototype
true
o2.__proto__.constructor === Object
false
o2.__proto__.constructor === M
true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;new运算符的原理&quot;&gt;5.4 new运算符的原理？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一个新对象被创建。它继承于foo.prototype&lt;/li&gt;
&lt;li&gt;构造函数foo被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例，new foo等同于 new foo(),只能用在不传递任何参数的情况&lt;/li&gt;
&lt;li&gt;如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new 出来的结果为步骤1创建的对象&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// new 一个对象的过程
var _new = function (fn) {
  // 1. 创建一个对象，这个对象要继承fn这个构造函数的原型对象
  var o = Object.create(fn.prototype);
  // 2. 执行构造函数
  var k = fn.call(o, arguments);
  // 3. 看下执行的这个函数的运行效果是不是函数
  if (typeof k === 'object'){
      return k;
  }
  else
  {
      return o;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;6. 面向对象&lt;/h2&gt;
&lt;h3 id=&quot;类与继承如何实现继承继承的几种实现方式&quot;&gt;6.1 类与继承：如何实现继承，继承的几种实现方式&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script&amp;gt;
  // 类的声明
  function Animal1() {
      this.name = 'name';
  }
  // ES6 中的class的声明
  class Animal2 {
      constructor(){
          this.name = 'name';
      }
  }

  console.log(new Animal1(), new Animal2());
  ///////////////////////////////////////////////////////////////////////////////////////////


  // 如何实现类的继承呢？？？-----------本质：原型链
  // v1. 借助构造函数实现继承
  function Parent1() {
      this.name = 'parent1'
  }
  Parent1.prototype.sayHello = function () {
      console.log('hello');
  }
  function Child1() {
      // 执行父亲的构造函数：
      // 1. 实现原理：将父级函数的this指向了这个子类的实例上面去了
      // 2. 缺点：父亲的原型链上面的方法或者属性不能被继承；只能实现部分继承
      Parent1.call(this);
      this.type = 'child1';
  }
  // 没有参数的时候，可以直接new + 函数名称
  console.log(res = new Child1);




  // v2. 借助原型链实现继承
  function Parent2() {
      this.name = 'parent2';
      this.data = [1, 2, 3];
  }
  Parent2.prototype.sayHello = function () {
      console.log('hello');
  }
  function Child2() {
      this.type = 'child2';
  }
  // prototype 就是为了让这个对象的实例可以访问到原型链上的内容
  Child2.prototype = new Parent2();
  // new Child2().__proto__ === Child2.prototype  // true
  // new Child2().__proto__.name                  // parent2
  // 原型链继承的缺点：
  // 1. 原理：通过修改原型链来实现对象的继承关系
  // 2. 缺点：修改第一个对象上面的属性，会直接修改第二个对象属性数据(引用类型)
  var c1 = new Child2();
  var c2 = new Child2();
  c1.data.push(100, 200, 300);

  // v3. 组合继承
  function Parent3() {
      this.name = 'parent3';
      this.data = [1, 2, 3];
  }
  function Child3() {
      // 1. 借用构造函数继承
      Parent3.call(this);
      this.type = 'child3';
  }
  // 2. 原型链继承
  // child3的原型对象是Parent3的一个实例对象，但是这个实例对象中是没有constructor这个属性的，因此寻找属性的时候回沿着这个实例对象的原型链继续向上寻找new Parent3().prototype 这个原型对象的，
  // 最终在Parent3.prototype这个原型对象中找到了这个属性，new一个对象找的实际上是{Parent3.prototype.constructor : Parent3}
  Child3.prototype = new Parent3();
  var c1 = new Child3();
  var c2 = new Child3();
  c1.data.push(100, 200, 300);
  // 组合继承的特点：
  // 1. 原理：结合借用构造函数继承和原型链继承的优点，摒弃二者的缺点
  // 2. 缺点：父类构造函数在创建实例的时候总共执行了两次（new Parent3(), new Child3()）


  // v4. 组合继承的优化1
  function Parent4() {
      this.name = 'parent4';
      this.data = [1, 2, 3];
  }
  function Child4() {
      // 1. 借用构造函数继承
      Parent4.call(this);
      this.type = 'child4';
  }
  // 让子类的构造函数的原型对象和父类构造函数的原型对象执向同一个对象(都是同一个对象)
  Child4.prototype = Parent4.prototype;
  // 测试
  var c1 = new Child4();
  var c2 = new Child4();
  console.log(c1 instanceof Child4, c1 instanceof Parent4);
  console.log(c1.constructor)         // Parent4? 如何实现：c1.constructor(c1.__proto__.constructor) === Child4 呢？
  // 缺点：
  // 1. 无法通过原型对象的constructor属性来获取对象的属性对应的构造函数了(子类和父类公用的是一个contructor)
  // 2. obj instanceof Child4 === true; obj instanceof Parent4 === true
  // 3. obj.__proto__.constructor === Child4; obj.__proto__.constructor === Parent4  ???

  // v5. 组合继承的优化2【完美写法】
  function Parent5() {
      this.name = 'parent5';
      this.data = [1, 2, 3, 4, 5];
  }
  function Child5(){
      Parent5.call(this);
      this.type = 'child5';
  }

  // 通过创建中间对象的方式来把两个对象区分开
  // var obj = new Object(); obj.__proto__ = Constructor.prototype;
  // 1. Object.create创建的对象obj, 这个obj的原型对象就是参数
  // 2. Child5的原型对象是Child5.prototype
  // 3. Child5.prototype = obj，obj这个对象相当于就是一个中间的桥梁关系
  Child5.prototype = Object.create(Parent5.prototype);
  // 当前的方式还是会按照原型链一级一级向上寻找的, 给Child5的原型对象上面绑定一个自己定义的constructor属性
  Child5.prototype.constructor = Child5;

  // var s1 = new Child5()

  // 上面的代码等价于
  var obj = Object.create(Parent5.prototype);     // obj.prototype = Parent5.prototype
  Child5.prototype = obj;
  Child5.prototype.constructor = Child5;
  // 1. 对象之间就是通过__proto__ 属性向上寻找的
  // 2. 寻找规则： child5 ---&amp;gt; Child5.prototype ---&amp;gt; obj(Object.create(Parent5.prototype)) ---&amp;gt; Parent5.prototype


  // 技巧：不要让面试官问太多题目：拖拉时间【挤牙膏】，把一个问题尽量吃透
  // 消化这一块内容
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!WARNING]&lt;br/&gt;面试技巧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;不要让面试官问太多题目：拖拉时间【挤牙膏】，把一个问题尽量吃透&lt;/li&gt;
&lt;li&gt;知识深度&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;通信&quot;&gt;7. 通信&lt;/h2&gt;
&lt;h3 id=&quot;什么是同源策略个限制&quot;&gt;7.1 什么是同源策略个限制？&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;同源策略限制是从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（一个源的文档或脚本是没有权利直接操作另外一个源的文档或脚本的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Cookie， LocalStorage和IndexDB无法读取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DOM无法获得；（document.body是无法获取的）&lt;/li&gt;
&lt;li&gt;Ajax请求不能发送&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;前后端如何进行通信呢&quot;&gt;7.2 前后端如何进行通信呢？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Ajax（有同源策略限制）；Fetch API则是XMLHttpRequest的最新替代技术， 它是W3C的正式标准&lt;/li&gt;
&lt;li&gt;WebSocket：支持跨域请求数据，没有同源策略的限制&lt;/li&gt;
&lt;li&gt;CORS：新的协议通信标准；CORS则将导致跨域访问的请求分为三种：Simple Request，Preflighted Request以及Requests with Credential；cors相对于jsonp而言的好处就是支持所有的请求方式，不止是get请求，还支持post,put请求等等，而它的缺点就很明显，无法兼容所有的浏览器，对于要兼容到老式浏览器而言，还是使用jsonp好点&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何创建ajax呢&quot;&gt;7.3 如何创建Ajax呢？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;XMLHttpRequest对象的工作流程&lt;/li&gt;
&lt;li&gt;浏览器的兼容性处理【重点】&lt;/li&gt;
&lt;li&gt;事件的触发条件&lt;/li&gt;
&lt;li&gt;事件的触发顺序&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function ajax(params){
    // 1. 创建对象，考虑兼容性【重点】
    var xhr = XMLHTTPRequest ? new XMLHTTPRequest() : new window.ActiveXObject('Microsoft.XMLHTTP');      // *** 兼容性问题必须考虑
    // 2. 打开连接
    var type = params.type || 'GET',
        url = params.url || '',
        data = params.data || {},
        success = params.success,
        error = params.error,
        dataArr = [];
    for (var k in data) {
      dataArr.push(k + '=' + data[k]);
    }
    //带上Cookie
    xhr.withCredentials = true;
    if (type.toUpperCase() === 'GET') {
      // get
      url += '?' + dataArr.join('&amp;amp;');
      // 问号结尾的话，直接替换为空字符串
      xhr.open(type, url.replace(/\?$/g, ''), true);
      // GET 请求的话，是不需要再send方法中带上参数的
      xhr.send();
    }
    else {
      // POST
      xhr.open(type, url, true);
      xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      // POST 请求需要把数据放在send方法里面， data = name=zhangsna&amp;amp;age=18&amp;amp;sex=male
      xhr.send(dataArr.join('&amp;amp;'));
    }
    // 开始监听变化
    xhr.onreadystatechange = function(){
      // 这里需要考虑强缓存和协商缓存的话直接处理，206是媒体资源的创建方式
      if (xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200 || xhr.status === 304) {
          var res;
          if (success instanceof Function) {
            res = xhr.responseText;
            if (typeof res === 'string') {
              res = JSON.parse(res);
              // 开始执行成功的回调函数
              success.call(xhr, res);
            }
          } else {
            if (error instanceof Function) {
              // 失败的话直接返回这个responseText中的内容信息
              error.call(xhr, res);
            }
          }
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;跨域通信的几种方式&quot;&gt;7.4 跨域通信的几种方式？&lt;/h3&gt;
&lt;h4 id=&quot;jsonp&quot;&gt;7.4.1 JSONP&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function jsonp(url, onsuccess, onerror, charset){
    // 1. 全局注册一个callback
    var callbackName = 'callback' + Math.random() * 100;
    window[callbackName] = function(){
      if (onsuccess &amp;amp;&amp;amp; typeof onsuccess === 'Function') {
        onsuccess(arguments[0]);
      }
    }
    // 2. 动态创建一个script标签
    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    charset &amp;amp;&amp;amp; script.setAttribute('charset', charset);
    script.setAttribute('src', url);
    script.async = true;
    // 3. 开始监听处理的过程
    script.onload = script.onreadystatechange = function(){
      if (!script.readyState || /loaded|complete/.test(script.readyState)) {
        // 4. 成功之后移除这个事件
        script.onload = script.onreadystatechange = null;
        // 删除这个script的DOM对象（head.removeChild(script), 这个DOM节点的父节点相当于是head标签这个父节点）
        script.parentNode &amp;amp;&amp;amp; script.parentNode.removeChild(script);
        // 删除函数或变量
        window[callbackName] = null;
      }
    }
    script.onerror = function(){
      if (onerror &amp;amp;&amp;amp; typeof onerror === 'Function') {
        onerror();
      }
    }
    // 5. 开始发送这个请求(把这个标签放在页面中的head标签中即可)
    document.getElementsByTagName('head')[0].appendChild(script);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hash&quot;&gt;7.4.2 Hash&lt;/h4&gt;
&lt;p&gt;hash 改变后页面不会刷新的&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;使用场景：当前的页面A通过iframe或者frame嵌入了跨域的页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 1. A页面中的代码如下
  var B = document.getElementsByTagName('iframe');
  B.src = B.src + '#' + JSON.stringfy(data);
  // 2. B中的伪代码如下
  window.onhashchange = function(){
    var data = window.location.hash;    // 接受数据
    data = JSON.parse(data);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;postmessagehtml5中新增&quot;&gt;7.4.3 postMessage(HTML5中新增)&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;使用场景： 可以实现窗口A(A.com)向窗口B(B.com)发送信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 1. 窗口B中的代码如下
  var BWindow = window;
  BWindow.postMessage(JSON.stringfy(data), 'http://www.A.com');   
  // 2. 窗口A中代码
  var AWindow = window;
  AWindow.addEventListener('message', function(e){
      console.log(e.origin);                  // http://www.B.com
      console.log(e.source);                  // BWindow

      e.source.postMessage('已成功收到消息');

      console.log(JSON.parse(e.data));        // data
  }, false)
  // 父窗口给子窗口发信息，需要用iframe的contentWindow属性作为调用主体
  // 子窗口给父窗口发的信息需要使用window.top，多层iframe使用window.frameElement&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;websocket&quot;&gt;7.4.4 . WebSocket&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;不受同源策略影响，可以直接使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var ws = new window.WebSocket('ws://echo.websocket.org');

  // 打开连接
  ws.onopen = function(e){
    console.log('Connection open ……');
    ws.send('Hello WebSocket!');
  }

  // 接受消息
  ws.onmessage = function(e){
    console.log('Received Message : ', e.data);
  }

  // 关闭连接
  ws.onclose = function(e){
    console.log('Connection closed');
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cors&quot;&gt;7.4.5 CORS&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;支持跨域通信版本的Ajax，是一种新的标准（Origin头）【ajax的一个变种，适用于任何】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2016/04/cors.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  fetch('/get/name', {
    method : 'get'
  }).then(function(response){
    console.log(response);
  }).catch(function(err){
    // 出错了；等价于then的第二个参数
  });
  // 原因：浏览器默认会拦截ajax请求，会根据头中的origin消息进行判断处理消息；Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;cors请求的基本流程&quot;&gt;7.4.5.1 CORS请求的基本流程&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。&lt;/li&gt;
&lt;li&gt;Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&lt;/li&gt;
&lt;li&gt;如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。&lt;/li&gt;
&lt;li&gt;如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;  Access-Control-Allow-Origin: http://api.bob.com   // 必需的字段
  Access-Control-Allow-Credentials: true            // 可选字段： 是否允许发送cookie
  Access-Control-Expose-Headers: FooBar
  Content-Type: text/html; charset=utf-8&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。OPTIONS表示当前的这个请求是用来询问的；服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;jsonp和cors的区别&quot;&gt;7.4.5.2 JSONP和CORS的区别？&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;JSONP只支持GET请求，CORS支持所有类型的HTTP请求&lt;/li&gt;
&lt;li&gt;JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;安全&quot;&gt;8. 安全&lt;/h2&gt;
&lt;h3 id=&quot;csrf&quot;&gt;8.1 CSRF&lt;/h3&gt;
&lt;h4 id=&quot;基本概念和缩写&quot;&gt;8.1.1 基本概念和缩写&lt;/h4&gt;
&lt;p&gt;CSRF： 跨站请求伪造，Cross site request forgery&lt;/p&gt;
&lt;h4 id=&quot;csrf-攻击原理&quot;&gt;8.1.2 CSRF 攻击原理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121225629985-1372313601.jpg&quot; alt=&quot;CSRF攻击原理&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;可以成功攻击的条件&quot;&gt;8.1.3 可以成功攻击的条件？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;目标网站存在CSRF漏洞的请求接口（一般为get请求）&lt;/li&gt;
&lt;li&gt;目标用户之前已经成功登录过这个网站（留下了Cookie）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何防御呢&quot;&gt;8.1.4 如何防御呢？&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Token验证&lt;/strong&gt;：访问服务器接口的时候，会自动带上这个token&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Referer验证&lt;/strong&gt;：验证网站的页面来源（只有我当前网站下的页面才可以请求，对于来自其他网站的请求一律拦截）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐藏令牌&lt;/strong&gt;： 隐藏信息会放在header中（类似于Token）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;xss&quot;&gt;8.2 XSS&lt;/h3&gt;
&lt;h4 id=&quot;基本概念和缩写-1&quot;&gt;8.2.1 基本概念和缩写&lt;/h4&gt;
&lt;p&gt;XSS： cross-site scripting, 跨站脚本攻击&lt;/p&gt;
&lt;h4 id=&quot;xss防御&quot;&gt;8.2.2 XSS防御&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;攻击原理&lt;/strong&gt;: 注入JS脚本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防御措施&lt;/strong&gt;: 让JS代码无法解析执行&lt;/p&gt;
&lt;h3 id=&quot;csrf和xss的区别呢&quot;&gt;8.3 CSRF和XSS的区别呢？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;CSRF：网站本身存在漏洞的接口，依赖这些登录过目标网站的用户来实现信息的窃取；&lt;/li&gt;
&lt;li&gt;XSS：向页面中注入JS执行，JS函数体内执行目标任务；&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;一定要说出中文名称，实现原理，防范措施都说出来&lt;/li&gt;
&lt;li&gt;不要拖泥带水，言简意赅&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;算法&quot;&gt;9. 算法&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;算法攻略：多刷题才是硬道理！！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;渲染机制&quot;&gt;10. 渲染机制&lt;/h2&gt;
&lt;h3 id=&quot;什么是doctype及作用&quot;&gt;10.1 什么是DOCTYPE及作用？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;DTD（Document Type Definition）：文档类型定义，是一系列的语法规则，用来定义XML或者(X)HTML的文件类型。浏览器会使用它来判断文档的类型，决定使用哪一种协议来解析，以及切换浏览器模式；&lt;/li&gt;
&lt;li&gt;DOCTYPE： 是用来声明文档类型和DTD规范的，一个主要的用途是文件的合法性验证；如果文件代码不合法，那么浏览器解析的时候就会出现一些出错&lt;/li&gt;
&lt;li&gt;总结：Doctype就是通知浏览器当前的文档是属于那种类型的，包含哪些DTD。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;!--HTML5的写法--&amp;gt;
  &amp;lt;DOCTYPE html&amp;gt;
  &amp;lt;!-- HTML 4.01  Strict
    1. 这个DTD 包含所有的HTML元素和属性
    2. 但是不包含展示性的和弃用的元素（比如font）
  --&amp;gt;
  &amp;lt;DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot; &amp;gt;
  &amp;lt;!-- HTML 4.0.1 Transitional
    1. 这个DTD 包含所有的HTML元素和属性
    2. 也包含展示性的和弃用性的元素（比如font）
  --&amp;gt;
  &amp;lt;DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot; http://www.w3.org/TR/html4/loose.dtd&quot; &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;在W3C标准出来之前，不同的浏览器对页面渲染有不同的标准，产生了一定的差异。这种渲染方式叫做混杂模式。在W3C标准出来之后，浏览器对页面的渲染有了统一的标准，这种渲染方式叫做标准模式。&amp;lt;!DOCTYPE&amp;gt;不存在或者形式不正确会导致HTML或XHTML文档以混杂模式呈现，就是把如何渲染html页面的权利交给了浏览器，有多少种浏览器就有多少种展示方式。因此要提高浏览器兼容性就必须重视&amp;lt;!DOCTYPE&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;严格模式和混杂模式&quot;&gt;10.2 严格模式和混杂模式&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;严格模式和混杂模式都是浏览器的呈现模式，浏览器究竟使用混杂模式还是严格模式呈现页面与网页中的DTD（文件类型定义）有关，DTD里面包含了文档的规则。比如：loose.dtd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;严格模式&lt;/strong&gt;：又称标准模式，是指浏览器按照W3C标准来解析代码，呈现页面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混杂模式&lt;/strong&gt;：又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;浏览器的渲染过程&quot;&gt;10.3 浏览器的渲染过程？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121223946064-1608656753.jpg&quot; alt=&quot;浏览器渲染过程&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;开始进行dom解析渲染dom-tree&quot;&gt;10.3.1 开始进行DOM解析，渲染DOM Tree&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224006383-2075836042.jpg&quot; alt=&quot;DOM树渲染&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;开始进行css解析渲染cssom-tree&quot;&gt;10.3.2 开始进行CSS解析，渲染CSSOM Tree&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224728683-1053592436.jpg&quot; alt=&quot;CSSOM树渲染&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;dom树和css树的结合最后会转换为render-tree&quot;&gt;10.3.3 DOM树和CSS树的结合，最后会转换为Render Tree&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224747409-1633772052.jpg&quot; alt=&quot;Render树渲染&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;layout的过程计算每一个dom元素的位置宽度高度等信息最终渲染并显示页面到浏览器&quot;&gt;10.3.4 Layout的过程，计算每一个DOM元素的位置、宽度、高度等信息，最终渲染并显示页面到浏览器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224803487-1884573.jpg&quot; alt=&quot;Layout的过程&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;何时会触发reflow&quot;&gt;10.4 何时会触发Reflow？&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;定义：DOM结构中每个元素都有自己的盒子模型，这些都是需要根据各种样式来计算并根据计算结果将元素放在它该出现的位置，这个过程就是reflow；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;当你增加、删除、修改DOM节点的时候，会导致Reflow或Repaint&lt;/li&gt;
&lt;li&gt;当你移动DOM的位置，或者设置动画的时候&lt;/li&gt;
&lt;li&gt;当你修改CSS样式的时候&lt;/li&gt;
&lt;li&gt;当你Resize窗口的时候（移动端没有这个问题，与浏览器有关），或者在滚动窗口的时候&lt;/li&gt;
&lt;li&gt;当你修改网页的默认的字体的时候&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;何时回触发repaint&quot;&gt;10.5 何时回触发Repaint？&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;定义：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小都确定下来以后，浏览器于是便按照元素各自的特性绘制了一遍，于是页面的内容出现了，这个过程就是repaint&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;DOM改动&lt;/li&gt;
&lt;li&gt;CSS改动&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何最大程度上的减少浏览器的重绘repaint过程频率呢&quot;&gt;10.6 如何最大程度上的减少浏览器的重绘Repaint过程(频率)呢？&lt;/h3&gt;
&lt;h4 id=&quot;避免在document上直接进行频繁的dom操作如果确实需要可以采用off-document的方式进行&quot;&gt;10.6.1 避免在document上直接进行频繁的DOM操作，如果确实需要可以采用off-document的方式进行&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;先将元素从document中删除，完成修改之后然后再把元素放回原来的位置&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;将元素的display设置为none, 然后完成修改之后再把元素的display属性修改为原来的值&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;如果需要创建多个DOM节点，可以使用DocumentFragment创建完毕之后一次性地加入document中去&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var frag = document.createDocumentFragment();
  frag.appendChild(dom);    /*每次创建的节点先放入DocumentFragment中*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;集中修改样式&quot;&gt;10.6.2 集中修改样式&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;尽可能少的修改元素style上的属性&lt;/li&gt;
&lt;li&gt;尽量通过修改className来修改样式(一次性修改)&lt;/li&gt;
&lt;li&gt;通过cssText属性来设置样式值&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  document.getElementById(&quot;d1&quot;).style.cssText = &quot;color:red; font-size:13px;&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;缓存layout的属性值&quot;&gt;10.6.3 缓存Layout的属性值&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;对于Layout属性中非引用类型的值（数字型），如果需要多次访问则可以在一次访问时先存储到局部变量中，之后都使用局部变量，这样可以避免每次读取属性时造成浏览器的渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var width = el.offsetWidth;
  var scrollLeft = el.scrollLeft;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置元素的position为absolute或fixed&quot;&gt;10.6.4 设置元素的position为absolute或fixed&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;在元素的position为static和relative时，元素处于DOM树结构当中，当对元素的某个操作需要重新渲染时，浏览器会渲染整个页面。将元素的position设置为absolute和fixed可以使元素从DOM树结构中脱离出来独立的存在，而浏览器在需要渲染时只需要渲染该元素以及位于该元素下方的元素，从而在某种程度上缩短浏览器渲染时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;布局layout&quot;&gt;11. 布局Layout？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Layout属性包括&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;offsetLeft、offsetTop、offsetHeight、offsetWidth: 相对于父对象的边距信息，且返回值为数字；left获取或设置相对于具有定位属性(position定义为relative)的父对象的边距信息，返回值为字符串10px&lt;/li&gt;
&lt;li&gt;scrollTop/Left/Width/Height：滚动条在各个方向上拉动的距离，返回值为数字&lt;/li&gt;
&lt;li&gt;clientTop/Left/Width/Height：浏览器的可视区域的大小&lt;/li&gt;
&lt;li&gt;getComputedStyle()、currentStyle(in IE)：浏览器渲染DOM元素之后的宽度和高度等样式信息&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;js运行机制&quot;&gt;12. JS运行机制&lt;/h2&gt;
&lt;h3 id=&quot;如何理解js的单线程&quot;&gt;12.1 如何理解JS的单线程？&lt;/h3&gt;
&lt;p&gt;看代码，写结果？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 同步任务
  console.log(1);
  // 异步任务要挂起
  setTimeout(function(){
    console.log(2)
  }, 0);
  console.log(3)
  // out : 1 3 2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  console.log('A');
  setTimeout(function(){
    console.log('B')
  }, 0);
  while (true) {

  }

  // out : A&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;什么是任务队列&quot;&gt;12.2 什么是任务队列？&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  for (var i = 0; i &amp;lt; 4; i++) {
    // setTimeout , setInterval 只有在时间到了的时候，才会把这个事件放在异步队列中去
    setTimeout(function(){
      console.log(i);
    }, 1000);
  }
  // out : 4 4 4 4&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;什么是event-loop&quot;&gt;12.3 什么是Event Loop？&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;JS是单线程的，浏览器引擎会先来执行同步任务，遇到异步任务之后，会把当前的这个异步任务放在time模块中，等到主线程中的所有的同步任务全部执行完毕之后；然后当前的这个异步任务只有时间到了之后，才会把这个任务（回调函数）放在一个异步队列中；当当前的任务栈中的任务全部执行完毕了之后，会先去执行微任务队列中的任务（Promise），然后等到微任务队列中的所有任务全部执行完毕之后，再去执行process.nextTick()这个函数，等到这个函数执行完毕之后，本次的事件轮训结束；&lt;br/&gt;开启新的执行栈，从宏任务队列中依次取出异步任务，开始执行；每个宏任务执行都会重新开启一个新的任务执行栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;个关键点&quot;&gt;12.3.1 3个关键点&lt;/h4&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;执行栈执行的是同步任务；&lt;/li&gt;
&lt;li&gt;什么时候去异步队列中取这个任务；&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么时候向这个任务队列中放入新的异步任务&lt;/p&gt;
&lt;h4 id=&quot;异步任务的分类&quot;&gt;12.3.2 异步任务的分类&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;setTimeout, setInterval;&lt;/li&gt;
&lt;li&gt;DOM事件（点击按钮的时候也会先去执行同步任务）；&lt;/li&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;知识点总结&quot;&gt;13. 知识点总结&lt;/h2&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;理解JS的单线程的概念&lt;/li&gt;
&lt;li&gt;理解任务队列&lt;/li&gt;
&lt;li&gt;理解Event Loop&lt;/li&gt;
&lt;li&gt;理解哪些语句会翻入到异步任务队列&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;理解与放入到异步任务队列的时机&lt;/p&gt;
&lt;h3 id=&quot;页面性能&quot;&gt;13.1 页面性能&lt;/h3&gt;
&lt;h4 id=&quot;提升页面性能的方法有哪些&quot;&gt;13.1.1 提升页面性能的方法有哪些？&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;资源压缩合并，减少HTTP请求；&lt;/li&gt;
&lt;li&gt;非核心代码的异步加载 ---&amp;gt; 异步加载的方式有哪些？ ---&amp;gt; 异步加载的区别？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用浏览器的缓存 ---&amp;gt; 缓存的分类 ---&amp;gt; 缓存的原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用CDN加速&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;预解析DNS：DNS Prefetch 是一种DNS 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。（提前解析域名，而不是点击链接的时候才去进行DNS域名解析，可以节省DNS解析需要耗费的20-120毫秒时间）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;!-- https协议的网站，默认是关闭了DNS的预解析的，可以使用下面的语句开启  --&amp;gt;
  &amp;lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&amp;gt;
  &amp;lt;!-- 开始配置需要进行DNS预解析的域名 --&amp;gt;
  &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&amp;gt;                               &amp;lt;!--支持http和HTTPS--&amp;gt;
  &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&amp;gt;               &amp;lt;!--支持http的协议--&amp;gt;
  &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://nsclick.baidu.com&quot; /&amp;gt;
  &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://hm.baidu.com&quot; /&amp;gt;
  &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://eiv.baidu.com&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异步加载的方式&quot;&gt;14. 异步加载的方式&lt;/h2&gt;
&lt;h3 id=&quot;动态脚本的加载&quot;&gt;14.1 动态脚本的加载&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var script = document.createElement('script');
  document.getElementsByTagName('head')[0].appendChild(script);

  // 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
  &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defer&quot;&gt;14.2 defer&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 --&amp;gt;
&amp;lt;script defer src=&quot;myscript.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;async&quot;&gt;14.3 async&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;!-- 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 --&amp;gt;
  &amp;lt;script async src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异步加载的区别&quot;&gt;14.4 异步加载的区别？&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;defer是在HTML解析完成之后（DOMContentLoaded事件执行之后）才会执行，如果是多个，会按照加载的顺序依次执行（按照顺序执行）&lt;/li&gt;
&lt;li&gt;async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关（与顺序无关）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;说一下浏览器的缓存机制吧&quot;&gt;15. 说一下浏览器的缓存机制吧？&lt;/h2&gt;
&lt;h3 id=&quot;缓存的分类&quot;&gt;15.1 缓存的分类&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;缓存目的就是为了提升页面的性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;强缓存&quot;&gt;15.1.1 强缓存&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;直接从本地读取，不发送请求&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Response Headers
    cache-control: max-age=315360000（相对时间，优先级比expires高）
    expires: Sat, 10 Mar 2029 04:01:39 GMT(绝对时间)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;协商缓存&quot;&gt;15.1.2 协商缓存&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;问一下服务器，这个文件有没有过期，然后再使用这个文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Response Headers
    last-modified: Tue, 12 Mar 2019 06:22:34 GMT（绝对时间）
    etag: &quot;52-583dfb6f4de80&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向服务器请求资源的时候，带上if-Modified-Since或者if-None-Match这个请求头，去询问服务器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Request Headers
    if-Modified-Since: Tue, 12 Mar 2019 06:22:34 GMT
    if-None-Match: &quot;52-583dfb6f4de80&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;错误监控如何保证前端产品的上线质量&quot;&gt;16. 错误监控/如何保证前端产品的上线质量？&lt;/h2&gt;
&lt;h3 id=&quot;前端错误的分类&quot;&gt;16.1 前端错误的分类？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;即时运行错误：代码错误&lt;/li&gt;
&lt;li&gt;资源加载错误：图片/css/js文件加载失败&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;错误的捕获方式&quot;&gt;16.2 错误的捕获方式？&lt;/h3&gt;
&lt;h4 id=&quot;即时运行错误的捕获方式&quot;&gt;16.2.1 即时运行错误的捕获方式&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 方法一：使用try catch捕获
  try {
    // ...
  } catch (e) {
    // error
  } finally {
    // handle error
  }

  // 方法二：使用window.onerror 捕获错误
  // 无法捕获到资源加载错误
  window.onerror = function(msg, url, line, col, error){
    // ...
  }  
  window.addEventListener('error', function(msg, url, line, col, error){
    // ...
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;资源加载错误不会向上冒泡&quot;&gt;16.2.2 资源加载错误（不会向上冒泡）&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 方法一: 直接在script, img这些DOM标签上面直接加上onerror事件
  Object.onerror = function(e){
      // ...
  }

  // 方法二：window.performace.getEntries(间接获取资源加载错误的数量)
  var loadedResources = window.performance.getEntries();           // 1. 获取浏览器中已经加载的所有资源（包括各个阶段的详细加载时间）
  var loaderImgs = loadedResources.filter(item =&amp;gt; {
      return /\.jpg|png|gif|svg/.test(item.name)
  });
  var imgs = document.getElementsByTagName('img');                // 2. 获取页面中所有的img集合
  var len = imgs.length - loaderImgs.length;                      // 3. 加载失败的图片数量
  console.log('图片加载失败数量：', len, '条');


  // 方法三： 使用事件捕获的方式来实现Error事件捕获
  // 使用事件捕获的方式来实现资源加载错误的事件的捕获：window ---&amp;gt; document --&amp;gt; html --- &amp;gt; body ---&amp;gt; div ---...
  window.addEventListener('error', function (msg) {
      console.log(msg);
  }, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;补充的方法&quot;&gt;16.2.3 补充的方法&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;      // 使用事件捕获的方式来实现
     window.addEventListener('error', function (msg) {
         console.log('资源加载异常成功捕获：', msg);
     }, true);
     // 使用事件冒泡的方式是只能捕获到运行的时候的一些异常
     window.addEventListener('error', function (e) {
         console.log('运行异常成功捕获1：', e.message, e.filename, e.lineno, e.colno, e.error);
     }, false);

     // 这种方式是可以按照参数的方式来接受相关的参数信息
     window.onerror = function (msg, url, line, col, error) {
         console.log('运行异常成功捕获2：', msg, url, line, col, error);
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题的延伸跨域的js运行错误可以捕获吗错误提示是什么应该怎么处理呢&quot;&gt;16.2.4 问题的延伸：跨域的js运行错误可以捕获吗，错误提示是什么？应该怎么处理呢？&lt;/h4&gt;
&lt;h5 id=&quot;错误信息&quot;&gt;16.2.4.1 错误信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121225441025-149731049.jpg&quot; alt=&quot;JS跨域出现的错误&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;errorinfo :
Script0 error
0 row
0 col&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;处理方法&quot;&gt;16.2.4.2 处理方法&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;第一步&lt;/strong&gt;：在script标签上增加crossorigin属性&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;  &amp;lt;!-- script 表情添加crossorigin属性 --&amp;gt;
  &amp;lt;!-- 除了 script，所有能引入跨域资源的标签包括 link 和 img 之类，都有一样的属性 --&amp;gt;
  &amp;lt;script crossorigin  src=&quot;http://www.lmj.com/demo/crossoriginAttribute/error.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;第二步&lt;/strong&gt;：设置js资源响应头'Access-Control-Allow-Origin: * ',服务器端需要开启&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 服务器可以直接设置一个响应头信息
  res.setResponseHeader('Access-Control-Allow-Origin', 'www.lmj.com');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上报错误的基本原理&quot;&gt;16.3 上报错误的基本原理？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;采用Ajax通信的方式来上报&lt;/li&gt;
&lt;li&gt;利用Image对象进行上报（cnzz）[重点理解掌握]&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // 下面的两种方式都是可以实现错误信息的上报功能的
  (new Image).src = 'http://www.baidu.com?name=zhangsna&amp;amp;age=18&amp;amp;sex=male'
  (new Image()).src = 'https://www.baidu.com?name=zhangsan'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用js获取客户端的硬件信息呢&quot;&gt;17. 如何使用JS获取客户端的硬件信息呢？&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  // IE 浏览器提供的获取电脑硬件的API
  var locator = new ActiveXObject (&quot;WbemScripting.SWbemLocator&quot;);
  var service = locator.ConnectServer(&quot;.&quot;);
  var properties = service.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用window.performace-来实现用户体验的数据记录呢&quot;&gt;18. 使用window.performace 来实现用户体验的数据记录呢？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;可以参考性能优化章节-performance性能监控一文内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;知识面要广&lt;/li&gt;
&lt;li&gt;理解要深刻&lt;/li&gt;
&lt;li&gt;内心要诚实：没了解过，问面试官有哪些资料可以学习&lt;/li&gt;
&lt;li&gt;态度要谦虚&lt;/li&gt;
&lt;li&gt;回答要灵活：把握一个度，不要和面试官争执对错&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;要学会赞美：被问住了可以回答，适当赞美（没面试官理解的那么深，虚心请教）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;介绍一下你做过的项目&quot;&gt;19.介绍一下你做过的项目？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224842051-497833903.jpg&quot; alt=&quot;项目介绍&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目介绍模板业务能力体现&quot;&gt;19.1 项目介绍模板（业务能力体现）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;我做过什么业务？&lt;/li&gt;
&lt;li&gt;负责的业务有什么业绩？&lt;/li&gt;
&lt;li&gt;使用了什么技术方案？&lt;/li&gt;
&lt;li&gt;突破了什么技术难点？&lt;/li&gt;
&lt;li&gt;遇到了什么问题？&lt;/li&gt;
&lt;li&gt;最大的收获是什么？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;团队协作能力&quot;&gt;19.2 团队协作能力&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224902979-329201167.jpg&quot; alt=&quot;项目介绍&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事务推动能力&quot;&gt;19.3 事务推动能力&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224922289-979359606.jpg&quot; alt=&quot;项目介绍&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;带人能力&quot;&gt;19.4 带人能力&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1869492/201911/1869492-20191121224941844-1015628398.jpg&quot; alt=&quot;项目介绍&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;技术终面或hr面试要点&quot;&gt;20. 技术终面或HR面试要点&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;主要考察点：乐观积极、主动沟通、逻辑顺畅、上进有责任心、有主张，做事果断、职业竞争力、职业规划&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;职业竞争力&quot;&gt;20.1 职业竞争力&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;业务能力&lt;/strong&gt;：可以做到行业第一&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;思考能力&lt;/strong&gt;：对同一件事可以从不同角度去思考，找到最优解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;学习能力&lt;/strong&gt;：不断学习新的业务，沉淀、总结&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;无上限的付出&lt;/strong&gt;：对于无法解决的问题可以熬夜、加班&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;职业规划&quot;&gt;20.2 职业规划&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;目标是什么&lt;/strong&gt;：在业务上成为专家，在技术上成为行业大牛&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;近阶段的目标&lt;/strong&gt;：不断的学习积累各方面地经验，以学习为主&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;长期目标&lt;/strong&gt;：做几件有价值的事情，如开源作品、技术框架等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;方式方法&lt;/strong&gt;：先完成业务上的主要问题，做到极致，然后逐步向目标靠拢&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 22 Nov 2019 14:05:00 +0000</pubDate>
<dc:creator>Web前端社区</dc:creator>
<og:description>一二面（基础面） 1. 一面基础面 1.1 面试准备 1.1.1 个人简历 + 基本信息：姓名 年龄 手机 邮箱 籍贯 + 工作经历：时间 公司 岗位 职责 技术栈 业绩（哪些成就） + 学历： 博士</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fecommunity/p/11908984.html</dc:identifier>
</item>
<item>
<title>小程序云开发：菜鸟也能全栈做产品 - 逃离沙漠</title>
<link>http://www.cnblogs.com/demingblog/p/11914354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demingblog/p/11914354.html</guid>
<description>&lt;h2 id=&quot;我想独立实现一个全栈产品为什么这么难&quot;&gt;我想独立实现一个全栈产品为什么这么难&lt;/h2&gt;
&lt;p&gt;日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务”。与之对应的创造者分别称为“前端程序员”、“后端程序员”，然而，一个完整产品的开发不仅仅是只有前端和后端，还有设计师，架构师，运维等。有没有可能这些所有的事情都一个人干呢？有可能，事实上如今就有很多的“全栈工程师”，他们身兼数职，是多面手。能独立完成一个产品的方方面面。这种人固然十分了得，他们通常具有多年的经验，涉猎广泛，是老手，也是高手，当有一个产品想法的时候，他们可以用自己的全面专业技能，尽情的发挥去实现自己的想法。所以，从某种意义上讲“全栈也是一种自由”，你可以自由的实现你的想法，这简直太美妙了！&lt;/p&gt;
&lt;p&gt;然而，很多时候当我们有一个产品想法的时候，我们往往发现，前端写完了，后端怎么搞？数据库怎么搞？域名怎么搞？域名还要备案？应用部署怎么搞？我的买什么样的服务器啊？静态资源 CDN 怎么搞？文件上传服务器怎么搞？万一访问用户多了能撑住吗？等等……问题很多，导致你的一个个想法，都只是在脑海中昙花一现，从来都无法将她们实现，或者说你激情饱满的实现了其中自己最擅长的一部分，当碰到其他难题的时候就止步了。于是仰天长啸：我就想独立做一个完整的产品为什么这么难？年轻人，这一切都不怪你……&lt;/p&gt;
&lt;h2 id=&quot;破局小程序云开发&quot;&gt;破局：小程序云开发&lt;/h2&gt;
&lt;h3 id=&quot;为什么使用小程序云开发来破局&quot;&gt;为什么使用小程序云开发来破局？&lt;/h3&gt;
&lt;p&gt;为啥是用“小程序云开发”来破局？首先，我们的目的是全栈实现一个产品。全栈可以有多种技术方案，你可用任何你能会的技能来达到全栈的目的。你可以开发安卓，IOS，或者 PC 站，然而小程序是最实际的！为啥？手机上能做的事情为啥要用 PC 版？OK,既然手机版比较好，那能不能再简单一点？能，就是小程序，不需要开发IOS，安卓两个版本。可以快速产出，快速试错。&lt;/p&gt;
&lt;p&gt;其次，前面说到了，全栈实现一个产品并不容易，对很多人来说甚至是巨难！选择了小程序已经是比较划算的方案。而再集成云开发，全栈立马就有了。这就是为什么选择“小程序云开发”来破局。&lt;/p&gt;
&lt;h3 id=&quot;小程序云开发是什么&quot;&gt;小程序云开发是什么?&lt;/h3&gt;
&lt;p&gt;小程序云开发是什么？官方文档是这么说的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。&lt;strong&gt;云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代&lt;/strong&gt;，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。&lt;/p&gt;
&lt;p&gt;看完上面的描述，也许你仍然无法非常清楚的知道什么是“小程序云开发”，没关系，你只需要注意加粗的部分，大概知道它“无需搭建服务器”，从传统观念将，这个似乎“毁三观”咋可能没服务器啊？是的，可以没有传统意义上的服务器，这种模式是 serveless 的。&lt;/p&gt;
&lt;p&gt;那么，小程序云开发提供了哪些东西来破局呢？且看下面的表格：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;云函数&lt;/td&gt;
&lt;td&gt;无需自建服务器&lt;/td&gt;
&lt;td&gt;在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;数据库&lt;/td&gt;
&lt;td&gt;无需自建数据库&lt;/td&gt;
&lt;td&gt;一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;无需自建存储和 CDN&lt;/td&gt;
&lt;td&gt;在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;云调用&lt;/td&gt;
&lt;td&gt;原生微信服务集成&lt;/td&gt;
&lt;td&gt;基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面的表格中提到了“云开发”中的一些能力：“云函数”，“数据库”，“存储”，“云调用”，我们可以将这些词带入你曾经开发过的应用，看看它们分别代表了哪些部分。对于程序员来说，如果有疑问的话，没有什么是一个 helloword 解决不了的。&lt;/p&gt;
&lt;h2 id=&quot;实战独立开发一个简易的零售小程序&quot;&gt;实战：独立开发一个简易的零售小程序&lt;/h2&gt;
&lt;p&gt;哆嗦再多，不如实战。下面我们就来使用小程序云开发实现一个简单的零售小程序。&lt;/p&gt;
&lt;h3 id=&quot;项目构思&quot;&gt;项目构思&lt;/h3&gt;
&lt;p&gt;既然是一个零售小程序，那么我们可以思考一下零售小程序的大致业务流程，以及粗略的梳理一下，其功能点。现根据自己的想法，大致画一下草图，如果没有灵感可以参考一下别的 APP 是如何设计的。&lt;/p&gt;
&lt;p&gt;我根据自己的想法设计之后是这样的：&lt;/p&gt;
&lt;p&gt;功能模块：首页，商品列表页，购物车，确认订单，个人中心，个人订单，管你模块（商品添加，分类添加）其中商品需要上传图片。&lt;/p&gt;
&lt;p&gt;梳理完功能之后，我们对于要实现的东西已经有个初步的概念了。接下来，我们需要大概画一下页面设计、及功能流转。初次设计可能没有太多经验，没关系，开始做就行了，做着做着就会想法越来越多，然后优化的越来越好。。我也是经过了多番修改调整，最终找到了一些思路。我的（拙劣）设计如下，图片如果看不清楚可复制图片链接在新窗口打开查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1597929/o_allpage.png&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明，以上图片是根据成品（我真的开发了一个云小程序并上线使用了）截图的，而实际我再设计的时候也是经过几番修改才最终定成这样。&lt;/p&gt;
&lt;p&gt;同时，补充说明一下，这里前端页面使用的是 vant-weapp控件，非常好用。推荐！如果你和我一样是一个纯后端程序员，建议使用 vant-weapp 来作为 ui，非常方便。否则自己写页面样式的话可能就做不出来了。全栈不是那么好干的啊。选择自己能驾驭的，能实现最终功能，就是一个合格的全栈。&lt;/p&gt;
&lt;h3 id=&quot;创建小程序云开发项目&quot;&gt;创建小程序云开发项目&lt;/h3&gt;
&lt;p&gt;我们先下载微信小程序开发工具，下载地址&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot;&gt;在这里&lt;/a&gt;,安装好了之后，新建项目，界面如下，APPID 需要你自己去注册一个。然后注意，选择“小程序云开发”，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1597929/o_%E6%96%B0%E5%BB%BA%E4%BA%91%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE.png&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建好了之后，项目目录如下,先看 1 标注的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1597929/o_mulu.png&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你曾经有过小程序的开发经验，那么&lt;code&gt;miniprogram&lt;/code&gt;文件夹下面的结构你肯定熟悉了，&lt;code&gt;miniprogram&lt;/code&gt;下面的子目录分别是小程序对应的组件、图片、页面、样式以及&lt;code&gt;app.js&lt;/code&gt;,&lt;code&gt;app.json&lt;/code&gt;,&lt;code&gt;sitemap.json&lt;/code&gt;,其中&lt;code&gt;components&lt;/code&gt;下面的&lt;code&gt;vant-weapp&lt;/code&gt;就是上面提到的 ui 组件。&lt;/p&gt;
&lt;p&gt;最后一个比较重要的文件夹就是&lt;code&gt;cloudfunctions&lt;/code&gt;，这个目录是用来存放“云函数的”，云函数就是我们的后端。每一个云函数提供一个服务。一个个的云函数组成了我们整体的后端服务。云函数可以看做是 FaaS（function as a service）。途中，2 标记的位置的“云开发”按钮，我们点进去，就可以看到“云开发的控制台”，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1597929/o_kongzhitai.png&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果上图看不清楚，可以复制链接到新的浏览器窗口查看，如图，小程序云开发默认的免费套餐有一定的额度可供使用。首页便是使用统计。然后我们能看到，有“数据库”，“存储”，“云函数”。&lt;/p&gt;
&lt;p&gt;这里的“数据库”其实就是类似于一个 MongoDB，你可以点进去创建一个个的 collection（即：关系型数据库中的table）;这里的“存储”其实就是“文件夹”，我们可以通过微信提供的 api把图片上传到“存储”中；这里的“云函数”就是我们需要实现的后端业务逻辑，他就是一个个的函数（函数由我们自己写好后上传）。一般开发过程中我们在开发者工具中的&lt;code&gt;cloudfunctions&lt;/code&gt;目录下创建云函数（比方说是:user-add）开发完成之后在云函数目录点击右键——上传即可。然后就可以在小程序的代码中调用这个&lt;code&gt;user-add&lt;/code&gt;云函数。&lt;/p&gt;
&lt;h3 id=&quot;云开发之3-分钟实现文件上传&quot;&gt;云开发之——3 分钟实现文件上传&lt;/h3&gt;
&lt;p&gt;注意：在开始云开发之前，我们现在 小程序代码的 app.js 中加入&lt;code&gt;wx.cloud.init&lt;/code&gt;,如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;App({
  onLaunch: function () {
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力')
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
        env: 'your-env-id',
        traceUser: true,
      })
    }
    this.globalData = {}
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的图中，我们已经看到了“商品添加”页面的效果，它需要我们输入商品名称、价格、并上传图片，然后保存。传统架构中，上传图片需要前端页面摆一个控件，然后后端提供一个 api用来接收前端传来的文件，通常来说这个后端 api 接收到图片之后，会将图片文件保存到自己的文件服务器或者是阿里云存储、或者是七牛云存储之类的。然后返回给你一个文件链接地址。非常麻烦，然而，小程序云开发上传文件超级简单，上代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;页面代码：
&amp;lt;van-notice-bar
  scrollable=&quot;false&quot;
  text=&quot;发布商品&quot;
/&amp;gt;
  &amp;lt;van-field
    value=&quot;{{ productName }}&quot;
    required
    clearable
    label=&quot;商品名称&quot;
    placeholder=&quot;请输入商品名称&quot;
    bind:change=&quot;inputName&quot;
  /&amp;gt;
    &amp;lt;van-field
    value=&quot;{{ productPrice }}&quot;
    required
    clearable
    label=&quot;价格&quot;
    icon=&quot;question-o&quot;
     bind:click-icon=&quot;onClickPhoneIcon&quot;
    placeholder=&quot;请输入价格&quot;
    error-message=&quot;{{phoneerr}}&quot;
    border=&quot;{{ false }}&quot;
    bind:change=&quot;inputPrice&quot;
  /&amp;gt;

&amp;lt;van-action-sheet
  required
  show=&quot;{{ showSelect }}&quot;
  actions=&quot;{{ actions }}&quot;
  close-on-click-overlay=&quot;true&quot;
  bind:close=&quot;toggleSelect&quot;
  bind:select=&quot;onSelect&quot; cancel-text=&quot;取消&quot;
/&amp;gt;
  &amp;lt;van-field
    value=&quot;{{ productCategory }}&quot;
    center
    readonly
    label=&quot;商品分类&quot;
    border=&quot;{{ false }}&quot;
    use-button-slot
  &amp;gt;
    &amp;lt;van-button slot=&quot;button&quot; size=&quot;small&quot; plain type=&quot;primary&quot;  
     bind:click=&quot;toggleSelect&quot;&amp;gt;选择分类&amp;lt;/van-button&amp;gt;
  &amp;lt;/van-field&amp;gt;
  
  &amp;lt;van-button class=&quot;rightside&quot; type=&quot;default&quot; bind:click=&quot;uploadImage&quot; &amp;gt;上传商品图片&amp;lt;/van-button&amp;gt;
  &amp;lt;view class=&quot;imagePreview&quot;&amp;gt;
    &amp;lt;image src=&quot;{{productImg}}&quot; /&amp;gt;
  &amp;lt;/view&amp;gt;
 &amp;lt;van-submit-bar
  price=&quot;{{ totalShow }}&quot;
  button-text=&quot;提交&quot;
  bind:submit=&quot;onSubmit&quot;
  tip=&quot;{{ false }}&quot;
 &amp;gt;
 &amp;lt;/van-submit-bar&amp;gt; 
&amp;lt;van-toast id=&quot;van-toast&quot; /&amp;gt;
&amp;lt;van-dialog id=&quot;van-dialog&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有个控件，绑定了&lt;code&gt;uploadImage&lt;/code&gt;方法，其代码为：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  uploadImage:function(){
    let that = this;
    wx.chooseImage({
      count: 1,
      sizeType: ['compressed'],
      sourceType: ['album', 'camera'],
      success(res) {
        wx.showLoading({
          title: '上传中...',
        })
        const tempFilePath = res.tempFilePaths[0]
        const name = Math.random() * 1000000;
        const cloudPath = name + tempFilePath.match(/\.[^.]+?$/)[0]
        wx.cloud.uploadFile({
          cloudPath:cloudPath,//云存储图片名字
          filePath: tempFilePath,//临时路径
          success: res =&amp;gt; {
            let fileID = res.fileID;
            that.setData({
              productImg: res.fileID,
            });
            wx.showToast({
              title: '图片上传成功',
            })
          },
          fail: e =&amp;gt;{
            wx.showToast({
              title: '上传失败',
            })
          },
          complete:()=&amp;gt;{
            wx.hideLoading();
          }
        });
      }
    })
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;wx.chooseImage&lt;/code&gt;用于调起手机选择图片（相册/相机拍照），然后&lt;code&gt;wx.cloud.uploadFile&lt;/code&gt;用于上传图片到上面说到的云开发能力之一的“存储”中。上传图片成功之后返回一个文件 ID，类似：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;cloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个链接可以直接在小程序页面展示：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;image src=&quot;cloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  &quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以通过微信 api，装换成 http 形式的图片链接。&lt;/p&gt;
&lt;h3 id=&quot;云开发之操作数据库1-分钟写完保存商品到数据库的代码&quot;&gt;云开发之——操作数据库，1 分钟写完保存商品到数据库的代码&lt;/h3&gt;
&lt;p&gt;上面我们实现了商品图片上传，但是，商品图片并没有保存到数据库。正常录入商品的时候，我们会填好商品名称，价格等，然后上传图片，最终点击“保存”按钮，将商品保存到数据库。传统模式下，前端仍然是需要调用一个后端接口，通过 post 提交数据，最终由后端服务（比如 java 服务）将数据保存到数据库。小程序云开发使得操作数据库十分简单，首先我们在云开发控制台创建“商品表”，即一个 &lt;code&gt;collection&lt;/code&gt;,取名为：&lt;code&gt;products&lt;/code&gt;。然后我们就可以保存数据到数据库了，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;onSubmit:function(){
    // 校验代码，略
    let product = {};
    product.imgId = this.data.productImg;
    product.name= this.data.productName;
    product.categoryId = this.data.productCategoryId;
    product.price = this.data.productPrice;
    // 其他赋值，略
    const db = wx.cloud.database();
    db.collection('products').add({
     data: product,
     success(res) {
       wx.showToast({
         title: '保存成功',
       })
     }
   });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就实现了数据入库，就这点代码，超简单，1 分钟写完，诚不欺我。其中这里的&lt;code&gt;products&lt;/code&gt;就是我们的“商品表”，之前说过，类似 MongoDB 数据库，这里操作的是&lt;code&gt;db.collection&lt;/code&gt;，这和 MongoDB 的语法差不多。&lt;/p&gt;
&lt;h3 id=&quot;云开发之使用云函数完成后端业务逻辑订单创建&quot;&gt;云开发之——使用云函数完成后端业务逻辑，订单创建&lt;/h3&gt;
&lt;p&gt;小程序云开发提供了几大能力：“数据库”，“存储”，“云函数”，前两项我们已经有所体会了。下面我们能创建一个云函数来实现订单创建。这里说明，云函数其实就是 一段JavaScript 代码，上传至云服务器之后，最终也是运行在 nodejs 环境的，只是这一切，我们不需要关心。我们只需要关心我们这个云函数提供的功能是什么就可以了。&lt;/p&gt;
&lt;p&gt;创建云函数很简单，直接在开发工具中右键“新建Node.js 云函数”。然后以创建订单为例，假设我们创建一个云函数名为&lt;code&gt;c-order-add&lt;/code&gt;,创建好了之后，目录是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1597929/o_cloudfunction.png&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;云函数的主要代码在 index.js 中，其完整代码是这样：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 云函数入口文件
const cloud = require('wx-server-sdk')
cloud.init({
  env: 'release-xxx'// your-env-id
})
const db = cloud.database()

// 云函数入口函数
exports.main = async (event, context) =&amp;gt; {
  const wxContext = cloud.getWXContext();
  console.log(&quot;云函数 c-order-add : &quot;)  
  // 这里是一些逻辑处理...
  
  return await db.collection('uorder').add({
    data: {
      openid: event.userInfo.openId,
      address: event.address,
      userName: event.userName,
      phone: event.phone,
      shoppingInfo: event.shoppingInfo,
      totlePrice: event.totlePrice,
      shoppingStr: event.shoppingStr,
      remark:event.remark,
      createTime: now,
      // ...
    }
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个云函数写好之后，需要上传到服务器，直接在云函数目录点击右键，然后点击“上传并部署”即可，这就相当于部署好了后端服务。前端小程序页面调用的写法是这样的：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let orderData={};
orderData.userName = this.data.userName;
orderData.phone = this.data.phone;
orderData.address = this.data.address;
// ....
wx.cloud.callFunction({
      // 云函数名称
      name: 'c-order-add',
      // 传给云函数的参数
      data: orderData,
      complete: res =&amp;gt; {
        Dialog.alert({
          title: '提交成功',
          message: '您的订单成功，即将配送，请保持手机通畅。'
        }).then(() =&amp;gt; {
          // ....
          wx.redirectTo({
            url: '../uorder/uorder'
          });
        });
      }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，向程序前端，通过&lt;code&gt;wx.cloud.callFunction&lt;/code&gt;完成了对云函数的调用，也可以理解为对后端服务的调用。至此我们我们介绍完了，小程序云开发的功能。虽然，我只贴出了少量的代码，即保存商品，和提交订单。由于时间和篇幅有限，我不可能把整个完整的程序代码贴出来。但是你可以参照这个用法示例，将剩下的业务逻辑补充完整，最终完成“项目构思”一节中展示的成品截图效果。&lt;/p&gt;
&lt;h3 id=&quot;小程序审核的一点经验&quot;&gt;小程序审核的一点经验&lt;/h3&gt;
&lt;p&gt;我开发的小程序审核在提交审核的时候遭遇了两次退回，第一次是因为：“小程序具备电商性质，个人小程序号不支持”。所以，我只好申请了一个企业小程序号，使用的是超市的营业执照。服务类目的选择也被打回了一次，最后选择了食品还提交了食品经营许可证。第二次打回是因为：“用户体验问题”。其实就是“授权索取”的问题，微信不让打开首页就“要求授权”，同时不能强制用户接受授权，得提供拒绝授权也能使用部分功能。&lt;/p&gt;
&lt;p&gt;上面两条解决之后，更新新了好几版，都没有出现过被拒的情况。并且，有次我是夜晚 10 左右提价的审核，结果10 点多就提示审核通过，当时没看具体时间，就是接盆水泡了个脚的时间审核通过了。所以，我推断小程序审核初次审核会比较严，之后如果改动不大应该直接机审就过了。&lt;/p&gt;
&lt;h2 id=&quot;总结及对比&quot;&gt;总结及对比&lt;/h2&gt;
&lt;p&gt;这里我们可以对小程序云开发和传统模式做一个对比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;是否需要后端服务&lt;/td&gt;
&lt;td&gt;需要 （如一个java应用部署在 Tomcat 中）&lt;/td&gt;
&lt;td&gt;不需要 只需要“云函数”&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;是否需要域名&lt;/td&gt;
&lt;td&gt;需要 （还得在微信后台的把域名加入安全域名）&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;是否需要购买服务器&lt;/td&gt;
&lt;td&gt;需要 （你得部署后端 Java 应用，还得安装数据库）&lt;/td&gt;
&lt;td&gt;不需要&lt;br/&gt;开通云开发之后免费套餐够用&lt;br/&gt;不够的话购买套餐按调用量计费&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;是否需要懂运维&lt;/td&gt;
&lt;td&gt;需要&lt;br/&gt;（你得会折腾服务器，数据库之类的&lt;br/&gt;还得配置好相关的用户，端口，启动服务）&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;图片上传及 CDN&lt;/td&gt;
&lt;td&gt;麻烦&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取微信 openID&lt;/td&gt;
&lt;td&gt;麻烦&lt;/td&gt;
&lt;td&gt;超级简单，云函数中直接获取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;···&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;就对比这么多吧，总之，我非常喜欢小程序云开发，小程序真的可以让你轻松干全栈。或者咱们别动不动就提“全栈”，姑且说，小程序云开发可以让你更简单、更快速、更便宜的实现你的产品落地。我自己开发的云小程序上线之后，使用了一两个月，没出现任何问题。我也不用操心服务器什么的。所以，我已经给身边很多人安利了小程序云开发了。这里我就不贴出我的小程序码了，因为已经正式给我同学的超市使用了，所以不方便让别人去产生测试数据。如果你感兴趣想看的话，可以联系我。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 13:47:00 +0000</pubDate>
<dc:creator>逃离沙漠</dc:creator>
<og:description>我想独立实现一个全栈产品为什么这么难 日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/demingblog/p/11914354.html</dc:identifier>
</item>
<item>
<title>多线程编程（3）——synchronized原理以及使用 - 晓乎</title>
<link>http://www.cnblogs.com/helloworldcode/p/11914053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworldcode/p/11914053.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;一、对象头&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;  通常在java中一个对象主要包含三部分：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对象头 主要包含GC的状态、、类型、类的模板信息（地址）、synchronization状态等，在后面介绍。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;实例数据：程序代码中定义的各种类型的字段内容。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对齐数据：对象的大小必须是 8 字节的整数倍，此项根据情况而定，若对象头和实例数据大小正好是8的倍数，则不需要对齐数据，否则大小就是8的差数。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;先看下面的实例、程序的输出以及解释。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/*需提前引入jar包
&amp;lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core 解析java对象布局 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
​
*/
//Java对象以8个字节对其，不够则使用对其数据
public class Student {
    private int id;       // 4字节
    private boolean sex;  // 1字节
    public Student(int id, boolean sex){
        this.id = id;
        this.sex = sex;
    }
}
public class Test01 {
    public static void main(String[] args) {
        Student stu = new Student(6, true);
        //计算对象hash,底层是C++实现，不需要java去获取，如果此处不调用，则后面的hash值不会去计算
        System.out.println(&quot;hashcode: &quot; + stu.hashCode());  
        System.out.println(ClassLayout.parseInstance(stu).toPrintable());
    }
}
/* output
hashcode: 523429237
com.thread.synchronizeDemo.Student object internals:
OFFSET SIZE TYPE DESCRIPTION        VALUE
 0     4    (object header)    01 75 e5 32 (00000001 01110101 11100101 00110010) (853898497)
4      4     (object header)    1f 00 00 00 (00011111 00000000 00000000 00000000) (31)
8      4     (object header)    43 c1 00 20 (01000011 11000001 00000000 00100000) (536920387)
12     4       int Student.id                                6
16     1   boolean Student.sex                               true
17     7           (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 7 bytes external = 7 bytes total
​
备注：上述代码在64位的机器上运行，此时
对象头占  (4+4+4)*8 = 96 位(bit)
实例数据  (4+1)*8 = 40 位(bit)
对齐数据  7*8 = 56 位(bit) 因为Java对象以8个字节对其的方式，需补7byte去对齐
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;   下面主要陈述对对象头的解释，内容从hotspot官网摘抄下来的信息：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;object header&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object's layout, type, GC state, synchronization state, and identity hash code. Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;mark word&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;klass pointer&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-softbreak&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original objec&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;  由此可知，对象头主要包含GC的状态（用4位表示——表示范围0-15，用来记录GC年龄，这也就是为什么对象在survivor中从from区到to区来回转换15次后转入到老年代tenured区）、类型、类的模板信息（地址）、synchronization 状态等，由两个字组成mark word和klass pointer（类元素据信息地址，具体数据通常在堆的方法区中，即8字节，但有时候会有一些优化设置，会开启指针压缩，将代表klass pointer的8字节变成4字节大小，&lt;span&gt;&lt;strong&gt;这也是为什么在上述代码中对象头大小是(8+4)byte，而不是16byte。&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;）。本节最主要介绍对象头的mark word这部分。关于对象头中每部分bit所代表的意义可以查看hotspot源码中代码的注，这段注释是从openjdk中拷贝的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JVM和hotspot、openjdk的区别&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JVM是一种产品的规范定义，hotspot（Oracle公司）是对该规范实现的产品，还有遵循这些规范的其他产品，比如J9（IBM开发的一个高度模块化的JVM）、Zing VM等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;openjdk是一个hotspot项目的大部分源代码（可以通过编译后变成.exe文件），hotspot小部分代码Oracle并未公布&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// openjdk-8-src-b132-03_mar_2014\openjdk\hotspot\src\share\vm\oops\markOop.hpp
/*
Bit-format of an object header (most significant first, big endian layout below):
​
32 bits:
--------
        hash:25 ------------&amp;gt;| age:4    biased_lock:1 lock:2 (normal object)
        JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
        size:32 ------------------------------------------&amp;gt;| (CMS free block)
        PromotedObject*:29 ----------&amp;gt;| promo_bits:3 -----&amp;gt;| (CMS promoted object)
​
64 bits:
--------
unused:25 hash:31 --&amp;gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
PromotedObject*:61 ---------------------&amp;gt;| promo_bits:3 -----&amp;gt;| (CMS promoted object)
size:64 -----------------------------------------------------&amp;gt;| (CMS free block)
​
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看到在32位机器和64位机器中，对象的布局的差异还是很大的，本文主要 叙述64位机器下的布局，其实两者无非是位数不同而已，大同小异。在64位机器用64位（8byte）表示Mark Word，首先前25位(0-25)是未被使用，接下来31位表示hash值，然后是对象分代年龄大小，最后Synchronized的锁信息，分为两部分，共3bit，如下表，锁的严格性依次是锁、偏向锁、轻量级锁、重量级锁。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201911/1047362-20191122200421792-13876501.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;关于锁的一些解释&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;无锁&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;　　无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;　　&lt;/strong&gt;引入偏向锁是为了在无多线程竞争的情况下，一段同步代码一直被一个线程所访问因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令，当由另外的线程所访问，偏向锁就会升级为轻量级锁。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;轻量级锁 &lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;　　当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;　　依赖于操作系统Mutex Lock所实现的锁，JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。　　&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;GC&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;　　&lt;/strong&gt;这并不是锁的状态，而是GC标志，等待GC回收。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;1.png&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;1.png&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;现在开始从程序层面分析前面程序的对象头的布局信息，在此之前需要知道的是，在windows中对于数据的存储采用的是小端存储，所以要反过来读&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;大端模式——是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;小端模式——是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一般在网络中用的大端；本地用的小端；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运行程序如下，可以看到对应的hashcode值被打印出来：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37.5&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot; readability=&quot;6&quot;&gt;
public static void main(String[] args) {
     Student stu = new Student(6, true);
    //Integer.toHexString()此方法返回的字符串表示的无符号整数参数所表示的值以十六进制
     System.out.println(&quot;hashcode: &quot; + Integer.toHexString(stu.hashCode()));
     System.out.println(ClassLayout.parseInstance(stu).toPrintable());
}
/*
hashcode: 1f32e575
com.thread.synchronizeDemo.Student object internals:
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0     4           (object header)                           01 75 e5 32 (00000001 01110101 11100101 00110010) (853898497)
      4     4           (object header)                           1f 00 00 00 (00011111 00000000 00000000 00000000) (31)
      8     4           (object header)                           43 c1 00 20 (01000011 11000001 00000000 00100000) (536920387)
     12     4       int Student.id                                6
     16     1   boolean Student.sex                               true
     17     7           (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 7 bytes external = 7 bytes total&lt;p&gt;//前8个字节反过来看，可以看出对象头的hash是1f32e575，同时是无锁的状态00000&lt;strong&gt;001&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt; &lt;span class=&quot;md-plain&quot;&gt;二、Monitor&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;       可以把它理解为一个同步工具（数据结构），也可以描述为一种同步机制，通常被描述为一个对象。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态（每一个线程都有一个可用 monitor record 列表）[&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;具体可以看参考资料5]。需要注意的是这种监视器锁是发生在对象的内部锁已经变成重量级锁的时候。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/*  openjdk-8-src-b132-03_mar_2014\openjdk\hotspot\src\share\vm\runtime\ObjectMonitor.hpp&lt;br/&gt;// initialize the monitor, exception the semaphore, all other fields
  // are simple integers or pointers
  ObjectMonitor() {
    _header       = NULL;
    _count        = 0;  //记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL;  //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;   //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0;
  }
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;　　Monitor的实现主要借助三个结构去完成多线程的并发操作——_owner、_WaitSet 、_EntryList。当多个线程同时访问由synchronized修饰的对象、类或一段同步代码时，首先会进入_EntryList 集合，如果某个线程取得了_owner的所有权，该线程就可以去执行，如果该线程调用了wait()方法，就会放弃_owner的所有权，进入等待状态，等下一次唤醒。如下图（图片摘自参考资料5）。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1047362/201911/1047362-20191122212846722-1422337474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 class=&quot;md-end-block md-p&quot;&gt; &lt;span class=&quot;md-plain&quot;&gt;三、synchronized的用法&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;     synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。其中&lt;span&gt;&lt;strong&gt;synchronized(this) 与synchronized(class) 之间的区别&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;有以下五点要注意：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;    1、对于静态方法，由于此时对象还未生成，所以只能采用类锁；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;    2、只要采用类锁，就会拦截所有线程，只能让一个线程访问。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;    3、对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;   4、如果对象锁跟访问的对象没有关系，那么就会都同时访问。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;   5、当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当然，Synchronized也可修饰一个静态方法，而静态方法是属于类的而不属于对象的，所以synchronized修饰的静态方法锁定的是这个类的所有对象。关于如下synchronized的用法，我们经常会碰到的案例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Thread5 implements Runnable {
    private static int count = 0;
    public synchronized static void add() {
        count++;
    }
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 1000000; i++) {
            synchronized (Thread5.class){
                count++;
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(10);
        for (int i = 0; i &amp;lt; 20; i++) {
            es.execute(new Thread5());
        }
        es.shutdown();
        es.awaitTermination(6, TimeUnit.SECONDS);
        System.out.println(count);
    }
}
/* 类锁
  20000000
  */
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;而一旦换成对象锁，不同实例，就可以同时访问。则会出错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void run() {
        for (int i = 0; i &amp;lt; 1000000; i++) {
            synchronized (this){
                count++;
            }
        }
}
/* 对象锁
 10746948
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为静态变量并不属于某个实例对象，而是属于类所有，所以对某个实例加锁，并不会改变count变量脏读和脏写的情况，还是造成结果不正确。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;参考资料&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0.18867924528302&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.zhihu.com/question/29265430&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;目前主流的 Java 虚拟机有哪些?&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-0.59016393442623&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对象布局的各部分介绍——&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;HotSpot Glossary of Terms&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不可不说的Java“锁”事&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;%20[https://wenchao.ren/2019/09/Synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/](https://wenchao.ren/2019/09/Synchronized%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/)&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Synchronized的一些东西&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/javazejian/article/details/72828483&quot; target=&quot;_blank&quot;&gt;深入理解Java并发之synchronized实现原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 22 Nov 2019 12:57:00 +0000</pubDate>
<dc:creator>晓乎</dc:creator>
<og:description>一、对象头 通常在java中一个对象主要包含三部分： 对象头 主要包含GC的状态、、类型、类的模板信息（地址）、synchronization状态等，在后面介绍。 实例数据：程序代码中定义的各种类型的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/helloworldcode/p/11914053.html</dc:identifier>
</item>
<item>
<title>类加载器 - ClassLoader详解 - 夜的那种黑丶</title>
<link>http://www.cnblogs.com/fx-blog/p/11912433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fx-blog/p/11912433.html</guid>
<description>&lt;ul&gt;&lt;li&gt;获得当前类的ClassLoader
&lt;ul&gt;&lt;li&gt;&lt;code&gt;clazz.getClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获得当前线程上下文的ClassLoader
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Thread.currentThread().getContextClassLoader();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获得系统的ClassLoader
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获得调用者的ClassLoader
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DriverManager.getCallerClassLoader&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;blockquote readability=&quot;42&quot;&gt;
&lt;p&gt;类加载器是用于加载类的对象，ClassLoader是一个抽象类。如果我们给定了一个类的&lt;strong&gt;二进制名称&lt;/strong&gt;，类加载器应尝试去定位或生成构成定义类的数据。一种典型的策略是将给定的二进制名称转换为文件名，然后去文件系统中读取这个文件名所对应的class文件。&lt;/p&gt;
&lt;p&gt;每个Class对象都会包含一个定义它的ClassLoader的一个引用。&lt;/p&gt;
&lt;p&gt;数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器来说，是通过&lt;strong&gt;Class.getClassLoader()&lt;/strong&gt;返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是一个原生类型，数组类是没有类加载器的【代码一】。&lt;/p&gt;
&lt;p&gt;应用实现了ClassLoader的子类是为了扩展JVM动态加载类的方式。&lt;/p&gt;
&lt;p&gt;类加载器典型情况下时可以被安全管理器所使用去标识安全域问题。&lt;/p&gt;
&lt;p&gt;ClassLoader类使用了委托模型来寻找类和资源，ClassLoader的每一个实例都会有一个与之关联的父ClassLoader，当ClassLoader被要求寻找一个类或者资源的时候，ClassLoader实例在自身尝试寻找类或者资源之前会委托它的父类加载器去完成。虚拟机内建的类加载器，称之为启动类加载器，是没有父加载器的，但是可以作为一个类加载器的父类加载器【&lt;strong&gt;双亲委托机制&lt;/strong&gt;】。&lt;/p&gt;
&lt;p&gt;支持并发类加载的类加载器叫做并行类加载器，要求在初始化期间通过&lt;strong&gt;ClassLoader.registerAsParallelCapable&lt;/strong&gt; 方法注册自身，ClassLoader类默认被注册为可以并行，但是如果它的子类也是并行加载的话需要单独去注册子类。&lt;/p&gt;
&lt;p&gt;在委托模型不是严格的层次化的环境下，类加载器需要并行，否则类加载会导致死锁，因为加载器的锁在类加载过程中是一直被持有的。&lt;/p&gt;
&lt;p&gt;通常情况下，Java虚拟机以平台相关的形式从本地的文件系统中加载类，比如在UNIX系统，虚拟机从CLASSPATH环境所定义的目录加载类。&lt;br/&gt;然而，有些类并不是来自于文件；它们是从其它来源得到的，比如网络，或者是由应用本身构建【动态代理】。定义类（defineClass ）方法会将字节数组转换为Class的实例，这个新定义类的实例可以由&lt;strong&gt;Class.newInstance&lt;/strong&gt;创建。&lt;/p&gt;
&lt;p&gt;由类加载器创建的对象的方法和构造方法可能引用其它的类，为了确定被引用的类，Java虚拟机会调用最初创建类的类加载器的&lt;strong&gt;loadClass&lt;/strong&gt;方法。&lt;/p&gt;
&lt;p&gt;二进制名称：以字符串参数的形式向CalssLoader提供的任意一个类名，必须是一个二进制的名称，包含以下四种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;java.lang.String&quot; 正常类&lt;/li&gt;
&lt;li&gt;&quot;javax.swing.JSpinner$DefaultEditor&quot; 内部类&lt;/li&gt;
&lt;li&gt;&quot;java.security.KeyStore&lt;span class=&quot;math inline&quot;&gt;\(Builder\)&lt;/span&gt;FileBuilder$1&quot; KeyStore的内部类Builder的内部类FileBuilder的第一个匿名内部类&lt;/li&gt;
&lt;li&gt;&quot;java.net.URLClassLoader$3$1&quot; URLClassLoader类的第三个匿名内部类的第一个匿名内部类&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;代码一：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test12 {
    public static void main(String[] args) {
        String[] strings = new String[6];
        System.out.println(strings.getClass().getClassLoader());
        // 运行结果：null

        Test12[] test12s = new Test12[1];
        System.out.println(test12s.getClass().getClassLoader());
        // 运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2

        int[] ints = new int[2];
        System.out.println(ints.getClass().getClassLoader());
        // 运行结果：null
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;loadclass方法&quot;&gt;loadClass方法&lt;/h2&gt;
&lt;p&gt;loadClass的源码如下， loadClass方法加载拥有指定的二进制名称的Class，默认按照如下顺序寻找类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用findLoadedClass(String)检查这个类是否被加载&lt;/li&gt;
&lt;li&gt;调用父类加载器的loadClass方法，如果父类加载器为null，就会调用启动类加载器&lt;/li&gt;
&lt;li&gt;调用findClass(String)方法寻找&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用上述步骤如果类被找到且resolve为true，就会去调用resolveClass(Class)方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
  throws ClassNotFoundException
{
  synchronized (getClassLoadingLock(name)) {
      // First, check if the class has already been loaded
      Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
      if (c == null) {
          long t0 = System.nanoTime();
          try {
              if (parent != null) {
                  c = parent.loadClass(name, false);
              } else {
                  c = findBootstrapClassOrNull(name);
              }
          } catch (ClassNotFoundException e) {
              // ClassNotFoundException thrown if class not found
              // from the non-null parent class loader
          }

          if (c == null) {
              // If still not found, then invoke findClass in order
              // to find the class.
              long t1 = System.nanoTime();
              c = findClass(name);

              // this is the defining class loader; record the stats
              sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
              sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
              sun.misc.PerfCounter.getFindClasses().increment();
          }
      }
      if (resolve) {
          resolveClass(c);
      }
      return c;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;findclass方法&quot;&gt;findClass方法&lt;/h2&gt;
&lt;p&gt;findClass的源码如下，findClass寻找拥有指定二进制名称的类，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass方法调用，默认返回ClassNotFoundException异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;defineclass方法&quot;&gt;defineClass方法&lt;/h2&gt;
&lt;p&gt;defineClass的源码如下，defineClass方法将一个字节数组转换为Class的实例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final Class&amp;lt;?&amp;gt; defineClass(String name, byte[] b, int off, int len,
                                     ProtectionDomain protectionDomain)
    throws ClassFormatError
{
    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class&amp;lt;?&amp;gt; c = defineClass1(name, b, off, len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    return c;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 继承了ClassLoader，这是一个自定义的类加载器
 * @author 夜的那种黑丶
 */
public class ClassLoaderTest extends ClassLoader {
    public static void main(String[] args) throws Exception {
        ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
       Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
        Object object = clazz.newInstance();
        System.out.println(object);
        System.out.println(object.getClass().getClassLoader());
    }
    //------------------------------以上为测试代码---------------------------------

    /**
     * 类加载器名称，标识作用
     */
    private String classLoaderName;

    /**
     * 从磁盘读物字节码文件的扩展名
     */
    private String fileExtension = &quot;.class&quot;;

    /**
     * 创建一个类加载器对象，将系统类加载器当做该类加载器的父加载器
     * @param classLoaderName 类加载器名称
     */
    private ClassLoaderTest(String classLoaderName) {
        // 将系统类加载器当做该类加载器的父加载器
        super();
        this.classLoaderName = classLoaderName;
    }

    /**
     * 创建一个类加载器对象，显示指定该类加载器的父加载器
     * 前提是需要有一个类加载器作为父加载器
     * @param parent 父加载器
     * @param classLoaderName 类加载器名称
     */
    private ClassLoaderTest(ClassLoader parent, String classLoaderName) {
        // 显示指定该类加载器的父加载器
        super(parent);
        this.classLoaderName = classLoaderName;
    }

    /**
     * 寻找拥有指定二进制名称的类，重写ClassLoader类的同名方法，需要自定义加载器遵循双亲委托机制
     * 该方法会在检查完父类加载器之后被loadClass方法调用
     * 默认返回ClassNotFoundException异常
     * @param className 类名
     * @return Class的实例
     * @throws ClassNotFoundException 如果类不能被找到，抛出此异常
     */
    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String className) throws ClassNotFoundException {
        byte[] data = this.loadClassData(className);
        /*
         * 通过defineClass方法将字节数组转换为Class
         * defineClass：将一个字节数组转换为Class的实例，在使用这个Class之前必须要被解析
         */
        return this.defineClass(className, data, 0 , data.length);
    }

    /**
     * io操作，根据类名找到对应文件，返回class文件的二进制信息
     * @param className 类名
     * @return class文件的二进制信息
     * @throws ClassNotFoundException 如果类不能被找到，抛出此异常
     */
    private byte[] loadClassData(String className) throws ClassNotFoundException {
        InputStream inputStream = null;
        byte[] data;
        ByteArrayOutputStream byteArrayOutputStream = null;

        try {
            this.classLoaderName = this.classLoaderName.replace(&quot;.&quot;, &quot;/&quot;);
            inputStream = new FileInputStream(new File(className + this.fileExtension));
            byteArrayOutputStream = new ByteArrayOutputStream();

            int ch;
            while (-1 != (ch = inputStream.read())) {
                byteArrayOutputStream.write(ch);
            }

            data = byteArrayOutputStream.toByteArray();
        } catch (Exception e) {
            throw new ClassNotFoundException();
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
                if (byteArrayOutputStream != null) {
                    byteArrayOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return data;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是一段自定义类加载器的代码，我们执行这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;classloader.Test01@7f31245a
sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看见，这段代码中进行类加载的类加载器还是系统类加载器（AppClassLoader）。这是因为jvm的双亲委托机制造成的，&lt;code&gt;private ClassLoaderTest(String classLoaderName)&lt;/code&gt;将系统类加载器当做我们自定义类加载器的父加载器，jvm的双亲委托机制使自定义类加载器委托系统类加载器完成加载。&lt;/p&gt;
&lt;p&gt;改造以下代码，添加一个path属性用来指定类加载位置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClassLoaderTest extends ClassLoader {
    public static void main(String[] args) throws Exception {
        ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
        loader.setPath(&quot;/home/fanxuan/Study/java/jvmStudy/out/production/jvmStudy/&quot;);
        Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
        System.out.println(&quot;class:&quot; + clazz);

        Object object = clazz.newInstance();
        System.out.println(object);
        System.out.println(object.getClass().getClassLoader());
    }
    //------------------------------以上为测试代码---------------------------------

    /**
     * 从指定路径加载
     */
    private String path;

    ......
    
    /**
     * io操作，根据类名找到对应文件，返回class文件的二进制信息
     * @param className 类名
     * @return class文件的二进制信息
     * @throws ClassNotFoundException 如果类不能被找到，抛出此异常
     */
    private byte[] loadClassData(String className) throws ClassNotFoundException {
        InputStream inputStream = null;
        byte[] data;
        ByteArrayOutputStream byteArrayOutputStream = null;

        className = className.replace(&quot;.&quot;, &quot;/&quot;);

        try {
            this.classLoaderName = this.classLoaderName.replace(&quot;.&quot;, &quot;/&quot;);
            inputStream = new FileInputStream(new File(this.path + className + this.fileExtension));
            byteArrayOutputStream = new ByteArrayOutputStream();

            int ch;
            while (-1 != (ch = inputStream.read())) {
                byteArrayOutputStream.write(ch);
            }

            data = byteArrayOutputStream.toByteArray();
        } catch (Exception e) {
            throw new ClassNotFoundException();
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
                if (byteArrayOutputStream != null) {
                    byteArrayOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return data;
    }

    public void setPath(String path) {
        this.path = path;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class:class classloader.Test01
classloader.Test01@7f31245a
sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改一下测试代码，并删除工程下的Test01.class文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
   loader.setPath(&quot;/home/fanxuan/桌面/&quot;);
    Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz);

    Object object = clazz.newInstance();
    System.out.println(object);
    System.out.println(object.getClass().getClassLoader());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class:class classloader.Test01
classloader.Test01@135fbaa4
classloader.ClassLoaderTest@7f31245a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;p&gt;改造后的两块代码，第一块代码中加载类的是系统类加载器AppClassLoader，第二块代码中加载类的是自定义类加载器ClassLoaderTest。是因为ClassLoaderTest会委托他的父加载器AppClassLoader加载class，第一块代码的path直接是工程下，AppClassLoader可以加载到，而第二块代码的path在桌面目录下，所以AppClassLoader无法加载到，然后ClassLoaderTest自身尝试加载并成功加载到。如果第二块代码工程目录下的Test01.class文件没有被删除，那么依然是AppClassLoader加载。&lt;/p&gt;
&lt;p&gt;再来测试一块代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
    loader.setPath(&quot;/home/fanxuan/Study/java/jvmStudy/out/production/jvmStudy/&quot;);
    Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz.hashCode());

    Object object = clazz.newInstance();
    System.out.println(object.getClass().getClassLoader());

    ClassLoaderTest loader2 = new ClassLoaderTest(&quot;loader&quot;);
    loader2.setPath(&quot;/home/fanxuan/Study/java/jvmStudy/out/production/jvmStudy/&quot;);
    Class&amp;lt;?&amp;gt; clazz2 = loader2.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz2.hashCode());

    Object object2 = clazz2.newInstance();
    System.out.println(object2.getClass().getClassLoader());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显而易见，类由系统类加载器加载，并且clazz和clazz2是相同的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class:2133927002
sun.misc.Launcher$AppClassLoader@18b4aac2
class:2133927002
sun.misc.Launcher$AppClassLoader@18b4aac2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在改造一下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
    loader.setPath(&quot;/home/fanxuan/桌面/&quot;);
    Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz.hashCode());

    Object object = clazz.newInstance();
    System.out.println(object.getClass().getClassLoader());

    ClassLoaderTest loader2 = new ClassLoaderTest(&quot;loader2&quot;);
    loader2.setPath(&quot;/home/fanxuan/桌面/&quot;);
    Class&amp;lt;?&amp;gt; clazz2 = loader2.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz2.hashCode());

    Object object2 = clazz2.newInstance();
    System.out.println(object2.getClass().getClassLoader());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class:325040804
classloader.ClassLoaderTest@7f31245a
class:621009875
classloader.ClassLoaderTest@45ee12a7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClassLoaderTest是显而易见，但是clazz和clazz2是不同的，这是因为类加载器的命名空间的原因。&lt;/p&gt;
&lt;p&gt;我们可以通过设置父类加载器来让loader和loader2处于同一命名空间&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    ClassLoaderTest loader = new ClassLoaderTest(&quot;loader&quot;);
    loader.setPath(&quot;/home/fanxuan/桌面/&quot;);
    Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz.hashCode());

    Object object = clazz.newInstance();
    System.out.println(object.getClass().getClassLoader());

    ClassLoaderTest loader2 = new ClassLoaderTest(loader, &quot;loader2&quot;);
    loader2.setPath(&quot;/home/fanxuan/桌面/&quot;);
    Class&amp;lt;?&amp;gt; clazz2 = loader2.loadClass(&quot;classloader.Test01&quot;);
    System.out.println(&quot;class:&quot; + clazz2.hashCode());

    Object object2 = clazz2.newInstance();
    System.out.println(object2.getClass().getClassLoader());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class:325040804
classloader.ClassLoaderTest@7f31245a
class:325040804
classloader.ClassLoaderTest@7f31245a&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展命名空间&quot;&gt;扩展：命名空间&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每个类加载器都有自己的命名空间，&lt;strong&gt;命名空间由该加载器及所有的父加载器所加载的类组成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类&lt;/li&gt;
&lt;li&gt;在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 22 Nov 2019 11:49:00 +0000</pubDate>
<dc:creator>夜的那种黑丶</dc:creator>
<og:description>获得ClassLoader的途径 获得当前类的ClassLoader 获得当前线程上下文的ClassLoader 获得系统的ClassLoader 获得调用者的ClassLoader ClassLoa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fx-blog/p/11912433.html</dc:identifier>
</item>
<item>
<title>微服务架构 - Jimu(积木) 升级 1.0.0 支持 .Net Core 3.0 - Grissom007</title>
<link>http://www.cnblogs.com/grissom007/p/11913298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grissom007/p/11913298.html</guid>
<description>&lt;p&gt;如果不知道 Jimu(积木) 是啥，请移步 &lt;a href=&quot;https://www.cnblogs.com/grissom007/p/9291345.html&quot;&gt;.Net Core 分布式微服务框架介绍 - Jimu&lt;/a&gt;&lt;br/&gt;这次升级除了支持 .Net Core 3.0 还新增部分功能，如 REST, 链路跟踪等，以下为详细；&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;平台&lt;/td&gt;
&lt;td&gt;.Net Core 2.1&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td/&gt;
&lt;td&gt;.Net Core 3.0&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;服务注册与发现&lt;/td&gt;
&lt;td&gt;consul&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;网关&lt;/td&gt;
&lt;td&gt;Asp.Net Core Web&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;RPC&lt;/td&gt;
&lt;td&gt;DotNetty&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;鉴权&lt;/td&gt;
&lt;td&gt;JWT&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;负载均衡&lt;/td&gt;
&lt;td&gt;轮训&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;容错策略&lt;/td&gt;
&lt;td&gt;重试&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;容器&lt;/td&gt;
&lt;td&gt;docker&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;路由配置&lt;/td&gt;
&lt;td&gt;Attribute注解&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;日志记录&lt;/td&gt;
&lt;td&gt;log4net&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td/&gt;
&lt;td&gt;nlog&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;文档&lt;/td&gt;
&lt;td&gt;swagger&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;链路跟踪&lt;/td&gt;
&lt;td&gt;skywalking&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REST&lt;/td&gt;
&lt;td&gt;Attribute注解&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;健康监测&lt;/td&gt;
&lt;td&gt;心跳&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;文件上存下载&lt;/td&gt;
&lt;td&gt;多文件上存，单文件下载&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;跳转&lt;/td&gt;
&lt;td&gt;在服务端跳转到指定url&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;○&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ORM&lt;/td&gt;
&lt;td&gt;Dapper&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DDD&lt;/td&gt;
&lt;td&gt;MiniDDD&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;td&gt;●&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122182357309-894878087.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122184837866-2004442619.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122193211734-1924241634.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;拓扑图-user---jimu_apigateway---jimu_order---jimu_user&quot;&gt;拓扑图: user -&amp;gt; jimu_apigateway -&amp;gt; jimu_order -&amp;gt; jimu_user&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122190004464-855244825.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;trace-跟踪&quot;&gt;Trace 跟踪&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122185335495-355935127.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;服务器&quot;&gt;服务器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122193047985-663187182.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;微服务&quot;&gt;微服务&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122193107488-970791837.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;微服务详细&quot;&gt;微服务详细&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/488490/201911/488490-20191122193144505-1844340801.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/grissomlau/jimu&quot; class=&quot;uri&quot;&gt;https://github.com/grissomlau/jimu&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Nov 2019 11:45:00 +0000</pubDate>
<dc:creator>Grissom007</dc:creator>
<og:description>如果不知道 Jimu(积木) 是啥，请移步 '.Net Core 分布式微服务框架介绍 Jimu' 这次升级除了支持 .Net Core 3.0 还新增部分功能，如 REST, 链路跟踪等，以下为详细</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grissom007/p/11913298.html</dc:identifier>
</item>
</channel>
</rss>