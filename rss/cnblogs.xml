<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>「补课」进行时：设计模式(6)——郭靖大侠带你学原型模式 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13912714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13912714.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/java_design_pattern.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前文汇总&quot;&gt;1. 前文汇总&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/category/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/&quot;&gt;「补课」进行时：设计模式系列&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-找工作&quot;&gt;2. 找工作&lt;/h2&gt;
&lt;p&gt;这一天，郭靖大侠因为在桃花岛调戏侍女被黄蓉打出了桃花岛，这下可玩大了，从桃花岛被赶出来吃啥喝啥啊，得赶紧找份工作，西北风可喝不饱肚子哇~~~&lt;/p&gt;
&lt;p&gt;这不，我们的郭大侠就开始写简历，准备向丐帮、全真教、白驼山和段氏家族投一份简历，看看能不能先混碗饭吃，等老婆的气消了再回去。&lt;/p&gt;
&lt;p&gt;首先，先定义一个简历类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Resume {
    private String name;
    private String position;
    private int salary;

    // 省略 get/set

    @Override
    public String toString() {
        return &quot;Resume{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, position='&quot; + position + '\'' +
                &quot;, salary=&quot; + salary +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们的郭大侠开始了熬夜写简历的生活：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static void main(String[] args) {
        Resume resume1 = new Resume();
        resume1.setName(&quot;小郭&quot;);
        resume1.setPosition(&quot;一代大侠&quot;);
        resume1.setSalary(1000);
        System.out.println(resume1);

        Resume resume2 = new Resume();
        resume2.setName(&quot;小郭&quot;);
        resume2.setPosition(&quot;一代大侠&quot;);
        resume2.setSalary(1200);
        System.out.println(resume2);

        Resume resume3 = new Resume();
        resume3.setName(&quot;小郭&quot;);
        resume3.setPosition(&quot;一代大侠&quot;);
        resume3.setSalary(1500);
        System.out.println(resume3);

        // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简历这么一份一份的写太累了，工作都没找到可能先饿死了，不行，小郭同学需要提高写简历的效率，于是，他去找了一个打印机回来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static void main(String[] args) {
        // 效率倍增，直接循环开始写简历
        for (int i = 0; i &amp;lt; 5; i++) {
            Resume resume4 = new Resume();
            int salary = (int)(1000 + Math.random() * (2000 - 1000 + 1));
            resume4.setName(&quot;小郭&quot;);
            resume4.setPosition(&quot;一代大侠&quot;);
            resume4.setSalary(salary);
            System.out.println(resume4.toString());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候，感觉效率好像还是有点低，每次只能一张一张打印，浪费时间，于是乎，我们的郭大侠又去搞了一个复印机回来。&lt;/p&gt;
&lt;p&gt;可是使用复印机需要我们原本的简历支持这个功能，听过这个功能需要扩展 Cloneable 接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ResumeClone implements Cloneable {
    private String name;
    private String position;
    private int salary;
    // 省略 get/set
    @Override
    protected ResumeClone clone(){
        ResumeClone resumeClone = null;
        try{
            resumeClone = (ResumeClone) super.clone();
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return resumeClone;
    }

    @Override
    public String toString() {
        return &quot;ResumeClone{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, position='&quot; + position + '\'' +
                &quot;, salary=&quot; + salary +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们的复印机就能跑起来了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestClone {
    public static void main(String[] args) {
        int num = 5;
        ResumeClone resumeClone = new ResumeClone();
        while (num &amp;gt; 0){
            ResumeClone resume1 = resumeClone.clone();
            int salary = (int)(1000 + Math.random() * (2000 - 1000 + 1));
            resume1.setName(&quot;小郭&quot;);
            resume1.setPosition(&quot;一代大侠&quot;);
            resume1.setSalary(salary);
            System.out.println(resume1.toString());
            num --;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里实际上我们只有第一个对象是使用打印机打印出来的，后面的对象都是通过复印机直接复印出来的。&lt;/p&gt;
&lt;p&gt;这其实就是设计模式中的原型模式。&lt;/p&gt;
&lt;h2 id=&quot;3-原型模式&quot;&gt;3. 原型模式&lt;/h2&gt;
&lt;p&gt;原型模式（Prototype Pattern）的简单程度仅次于单例模式和迭代器模式。正是由于简单，使用的场景才非常地多，其定义如下：&lt;/p&gt;
&lt;p&gt;Specify the kinds of objects to create using a prototypical instance,andcreate new objects by copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/06/prototype_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个绝对是最简单的设计模式，整个模式的核心就只有一个 clone 方法，通过该方法进行对象的拷贝， Java 提供了一个 Cloneable 接口来标示这个对象是可拷贝的，为什么说是「标示」呢？翻开 JDK 的帮助看看 Cloneable 是一个方法都没有的，这个接口只是一个标记作用，在 JVM 中具有这个标记的对象才有可能被拷贝。那怎么才能从「有可能被拷贝」转换为「可以被拷贝」呢？方法是覆盖 &lt;code&gt;clone()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;通用代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PrototypeClass implements Cloneable{
    @Override
    protected PrototypeClass clone() {
        PrototypeClass prototypeClass = null;
        try {
            prototypeClass = (PrototypeClass) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return prototypeClass;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;性能优良&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;逃避构造函数的约束&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束。&lt;/p&gt;
&lt;h2 id=&quot;4-构造函数&quot;&gt;4. 构造函数&lt;/h2&gt;
&lt;p&gt;先看一个简单的有关构造函数的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConstructorDemo implements Cloneable {
    public ConstructorDemo() {
        System.out.println(&quot;我被执行了。。。&quot;);
    }

    @Override
    protected ConstructorDemo clone(){
        ConstructorDemo demo = null;
        try {
            demo = (ConstructorDemo) super.clone();
        }catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return demo;
    }
}

public class ConstructorTest {
    public static void main(String[] args) {
        ConstructorDemo demo = new ConstructorDemo();
        ConstructorDemo demo1 = demo.clone();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;我被执行了。。。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就输出一次，这里可以证明对象拷贝的时候构造函数是不会执行的，原因在于拷贝是直接在堆中进行，这其实也可以理解， new 的时候， JVM 要走一趟类加载流程，这个流程非常麻烦，在类加载流程中会调用构造函数，最后生成的对象会放到堆中，而拷贝就是直接拷贝堆中的现成的二进制对象，然后重新一个分配内存块。&lt;/p&gt;
&lt;h2 id=&quot;5-浅拷贝和深拷贝&quot;&gt;5. 浅拷贝和深拷贝&lt;/h2&gt;
&lt;p&gt;先看一个浅拷贝的案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ShallowCopy implements Cloneable {
    private ArrayList&amp;lt;String&amp;gt; array = new ArrayList&amp;lt;&amp;gt; ();
    @Override
    public ShallowCopy clone() {
        ShallowCopy copy = null;
        try {
            copy = (ShallowCopy) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return copy;
    }

    public void setValue(String value) {
        this.array.add(value);
    }

    public ArrayList&amp;lt;String&amp;gt; getValue() {
        return this.array;
    }
}

public class ShallowCopyTest {
    public static void main(String[] args) {
        ShallowCopy copy = new ShallowCopy();
        copy.setValue(&quot;123&quot;);
        ShallowCopy copy1 = copy.clone();
        copy1.setValue(&quot;456&quot;);
        System.out.println(copy.getValue());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[123, 456]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况就是浅拷贝， Java 只拷贝你指定的对象，至于你指定的对象里面的别的对象，它不拷贝，还是把引用给你，共享变量，这是一种非常不安全的方式，需要特别注意。&lt;/p&gt;
&lt;p&gt;内部的数组和引用对象不会拷贝，其他的原始基本类型和 String 类型会被拷贝。&lt;/p&gt;
&lt;p&gt;那么这种情况如何进行一个深拷贝呢？只需要修改一下刚才 clone 的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 深拷贝
@Override
public ShallowCopy clone() {
    ShallowCopy copy = null;
    try {
        copy = (ShallowCopy) super.clone();
        this.array = (ArrayList&amp;lt;String&amp;gt;) this.array.clone();
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return copy;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是刚才的测试类，这次的运行结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[123]
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 02 Nov 2020 00:48:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 前文汇总 「补课」进行时：设计模式系列 2. 找工作 这一天，郭靖大侠因为在桃花岛调戏侍女被黄蓉打出了桃花岛，这下可玩大了，从桃花岛被赶出来吃啥喝啥啊，得赶紧找份工作，西北风可喝不饱肚子哇~~~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13912714.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Authentication系列（二）实现认证、登录和注销 - 大杂草</title>
<link>http://www.cnblogs.com/liang24/p/13912695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liang24/p/13912695.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/liang24/p/13910368.html&quot;&gt;上一篇文章&lt;/a&gt;介绍ASP.NET Core Authentication的三个重要概念，分别是Claim, ClaimsIdentity, ClaimsPrincipal，以及claims-base authentication是怎么工作的。&lt;/p&gt;
&lt;p&gt;这篇文章来介绍一下如何基于claims-base authentication来实现认证、登录和注销功能的。源代码从&lt;a href=&quot;https://yxl-article.oss-cn-shenzhen.aliyuncs.com/files/CookieAuthenticationDemo.zip&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;p&gt;认证是一个确定发送请求的访问者身份的过程，与认证相关的还有另外两个基本操作：登录和注销。&lt;/p&gt;
&lt;p&gt;ASP.NET Core应用的认证实现在一个名为&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;的中间件中，该中间件在处理分发给它的请求时会按照指定的 &lt;strong&gt;认证方案（Authentication Scheme）&lt;/strong&gt; 从请求中提取能够验证用户真实身份的数据，我们一般将该数据称为 &lt;strong&gt;安全令牌（Security Token）&lt;/strong&gt; 。ASP.NET Core应用下的安全令牌被称为 &lt;strong&gt;认证票据（Authentication Ticket）&lt;/strong&gt; ，所以ASP.NET Core应用采用基于票据的认证方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;中间件的整个认证过程涉及下图的三种操作：认证票据的颁发、检验和撤销。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/19327/202003/19327-20200325083708342-258956203.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core应用的认证系统旨在构建一个标准的模型来完成针对请求的认证以及与之相关的登录和注销操作。接下来我们就通过一个简单的实例来演示如何在一个ASP.NET Core应用中实现认证、登录和注销的功能。&lt;/p&gt;

&lt;p&gt;大多数Web应用采用的是Cookie来保存认证票据，因此我们采用基于Cookie的认证方案。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Startup.ConfigureServices&lt;/code&gt;方法里，添加&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;中间件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;Startup.Configure&lt;/code&gt;方法里，调用&lt;code&gt;UseAuthentication&lt;/code&gt;和&lt;code&gt;UseAuthorization&lt;/code&gt;来设置&lt;code&gt;HttpContext.User&lt;/code&gt;属性以及允许请求经过&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;，并且要在&lt;code&gt;UseEndpoints&lt;/code&gt;之前调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ...
    
    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapControllerRoute(
            name: &quot;default&quot;,
            pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
        
    // ...
}
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;登录&quot;&gt;登录&lt;/h2&gt;
&lt;p&gt;接下来实现登录方法，常见是使用“用户名+密码”，这里使用一个静态字典来模拟用户表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AccountController : Controller
{
    // ....

    private static Dictionary&amp;lt;string, string&amp;gt; _accounts;

    static AccountController()
    {
        _accounts = new Dictionary&amp;lt;string, string&amp;gt;(StringComparer.OrdinalIgnoreCase);
        _accounts.Add(&quot;Foo&quot;, &quot;password&quot;);
        _accounts.Add(&quot;Bar&quot;, &quot;password&quot;);
        _accounts.Add(&quot;Baz&quot;, &quot;password&quot;);
    }

    [HttpGet]
    public IActionResult Login()
    {
        LoginModel model = new LoginModel();

        return View(model);
    }

    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Login(LoginModel model)
    {
        if (_accounts.TryGetValue(model.UserName, out var pwd) &amp;amp;&amp;amp; pwd == model.Password)
        {
            var claimsIdentity = new ClaimsIdentity(
                new Claim[] { new Claim(ClaimTypes.Name, model.UserName) }, &quot;Basic&quot;);
            var claimsPrincipal = new ClaimsPrincipal(claimsIdentity);                
            await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, claimsPrincipal);

            return Redirect(&quot;/&quot;);
        }
        else
        {
            model.ErrorMessage = &quot;Invalid user name or password!&quot;;

            return await Task.Run(() =&amp;gt; View(model));
        }
    }

    // ....
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的关键在于下面三行代码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建ClaimType为Name，值为用户名的Claim。&lt;/li&gt;
&lt;li&gt;创建ClaimsIdentity，注意AuthorizeType=&quot;Basic&quot;。&lt;/li&gt;
&lt;li&gt;创建ClaimsPrincipal。&lt;/li&gt;
&lt;li&gt;调用HttpContext.SignInAsync登录，其中认证方案为CookieAuthenticationDefaults.AuthenticationScheme，与配置时一致。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;var claimsIdentity = new ClaimsIdentity(
    new Claim[] { new Claim(ClaimTypes.Name, model.UserName) }, &quot;Basic&quot;);
var claimsPrincipal = new ClaimsPrincipal(claimsIdentity); 
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, claimsPrincipal);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;认证&quot;&gt;认证&lt;/h2&gt;
&lt;p&gt;需要授权访问的功能要验证登录状态，如果没有登录则不允许访问，使用方法很简单，只需要在&lt;code&gt;Action&lt;/code&gt;上加上特性&lt;code&gt;[Authorize]&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize]
public IActionResult Index()
{
    return View();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;未登录会跳转到/Account/Login（默认设置，可修改），避免未授权访问。&lt;/p&gt;
&lt;h2 id=&quot;注销&quot;&gt;注销&lt;/h2&gt;
&lt;p&gt;用户注释，即将具有认证票据的Cookie设置为过期，直接调用&lt;code&gt;HttpContext.SignOutAsync&lt;/code&gt;，注意认证方案要与配置和登录的一致：&lt;code&gt;CookieAuthenticationDefaults.AuthenticationScheme&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AccountController : Controller
{
    // ....

    public async Task&amp;lt;IActionResult&amp;gt; Logout()
    {
        _logger.LogInformation(&quot;User {Name} logged out at {Time}.&quot;,
                User.Identity.Name, DateTime.UtcNow);

        await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);

        return Redirect(&quot;/&quot;);
    }
    
    // ....
}
&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 02 Nov 2020 00:36:00 +0000</pubDate>
<dc:creator>大杂草</dc:creator>
<og:description>前言 在上一篇文章介绍ASP.NET Core Authentication的三个重要概念，分别是Claim, ClaimsIdentity, ClaimsPrincipal，以及claims-bas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liang24/p/13912695.html</dc:identifier>
</item>
<item>
<title>一个人独自做长期项目，如何提高工作效率？ - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/13912650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/13912650.html</guid>
<description>&lt;p&gt;我长期一个人或两个人创业，开发一个长期的项目。&lt;br/&gt;经过我的观察，如果不进行调整，工作效率会不断地下降，最终导致放弃项目。&lt;/p&gt;

&lt;p&gt;下面的情况会导致工作效率下降：&lt;br/&gt;1、从事不喜欢的工作&lt;br/&gt;2、长期在同一个环境中工作&lt;br/&gt;3、不断地增加任务，导致长时间不能发布版本&lt;br/&gt;4、完成了上一个阶段任务，即将开始新的阶段任务&lt;br/&gt;5、没有外界的反馈和交流，独自闭门造车&lt;/p&gt;

&lt;p&gt;通过下面的方法，可以提高工作效率：&lt;br/&gt;1、一定要做自己喜欢的事，这样才能一直坚持下去&lt;br/&gt;2、工作和生活的地点要分开，不要在家里面办公。否则，短期内工作效率确实会提升，但1-3个月之后，工作效率会下降20%-80%左右，然后长期保持低效的工作效率&lt;br/&gt;3、可以找1、2个人一起来开发项目（把你的项目通过Github发布到网上；或者写一些文章，介绍相关的技术、经验等。这样可以吸引感兴趣的同学加入你！）。&lt;br/&gt;每加入一个人，都可以互相激励和监督，这样至少在1个月内会大幅提高双方的工作状态（提高20%-50%）&lt;br/&gt;4、可以考虑切换工作环境，如在共享办公的地方租一个独立工位（一般3个月起租，但可以跟老板沟通下，从而可以只租1个月，并且付一个月的定金）。&lt;br/&gt;一个独立工位一般一个月500-1000元左右。&lt;br/&gt;一次最好只租一个月（反正共享办公的地方还是有很多的，可以在租期到了后再换另一家），因为需要先看下办公环境是否满意，并且可以保持新鲜感。&lt;br/&gt;5、如果多人一起创业的话，可以一起在僻静的地方（如山上）找个宾馆住1个月，吃住都在一起，进行封闭式闭关开发。&lt;br/&gt;这种方法我也试过几次。封闭式开发让我们在第1个月内大幅提高工作效率（提高50%）。但是超过1个月后，就会开始疲倦，工作效率降低。所以封闭式开发时间不能太长，最多1个月就好。&lt;br/&gt;而且开发任务最好已经确定了，不再调整，只需要干就行了。&lt;/p&gt;
&lt;p&gt;更多相关经验，可以参考：&lt;a href=&quot;https://www.zhihu.com/question/19893698&quot;&gt;组织一次封闭式开发要注意哪些事情&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/topic/19656128/hot&quot;&gt;封闭式开发&lt;/a&gt;&lt;br/&gt;6、项目版本的周期要短，最好1-2个星期就发1个版本。在版本周期内不要一直增加内容，这会导致版本周期变长。&lt;br/&gt;可以将要增加的内容记录下来，放到后面的版本中实现。这样既可以保持版本周期不变，也可以通过二次整理，确定有哪些内容是真正需要实现的，有哪些内容是不需要实现的。&lt;br/&gt;因为作为有追求的程序员，会希望不断加入酷炫的功能，总想实现牛逼的技术。这会导致项目版本的开发周期不断变长，而且很多功能并不是用户需要的！所以需要确保版本开发周期很短，以免自己不自觉地增加很多内容！&lt;br/&gt;另外，通过不断地、快速地发版本，也能收到外界的反馈，增加自己的信心和热情，快速地调整项目开发的方向。&lt;br/&gt;7、开始一个新版本时，一般需要进行技术调研和学习，这会让我们想拖延，不想学习新知识。所以可以去咖啡馆或图书馆进行学习，完成技术准备后再回到办公地点，开始正式开发版本。&lt;br/&gt;8、创建QQ群或者其它的技术社区，吸引关注项目的粉丝加入。&lt;br/&gt;在社区中与粉丝互动，回答他们的问题，发布项目的相关资料，这样可以持续收到外界反馈，也增加自己开发项目的热情。&lt;br/&gt;9、写文章或者做技术直播，讲解正在开发的项目的相关技术。&lt;br/&gt;这样做的好处是：&lt;br/&gt;跟发版本类似，及时收到外界反馈；&lt;br/&gt;因为要分享给别人（特别是做技术直播），所以会强迫自己补充相关的知识点。这样会提高正在开发的项目的质量，趁早发现存在的漏洞。&lt;/p&gt;

&lt;p&gt;总的来说，要保持长时间的工作效率，需要做到下面的几点：&lt;br/&gt;1、做你喜欢的事&lt;br/&gt;2、把你正在做的事的相关资料、进展情况分享给别人&lt;br/&gt;3、吸引更多的同伴加入你，一起做事&lt;br/&gt;4、建立社区，把关注你和你做的事的人聚集在一起&lt;br/&gt;5、切换环境，通过新环境的新鲜感来提高效率&lt;br/&gt;6、每隔几个月就可以进行一次1个月左右的封闭式开发，专注于做事，排除干扰&lt;br/&gt;7、不断地发布阶段性成果，以小步增量的方式递进，及时收到外界反馈&lt;/p&gt;
</description>
<pubDate>Mon, 02 Nov 2020 00:08:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>我长期一个人或两个人创业，开发一个长期的项目。 经过我的观察，如果不进行调整，工作效率会不断地下降，最终导致放弃项目。 导致工作效率下降的情况 下面的情况会导致工作效率下降： 1、从事不喜欢的工作 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/13912650.html</dc:identifier>
</item>
<item>
<title>测试平台开发(二) 高逼格登录页面 - 测试老树</title>
<link>http://www.cnblogs.com/df888/p/13909048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13909048.html</guid>
<description>&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201101120029633-1990222721.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;怎么样？哎哟，不错哦。本文就带大家一起用 Vue + Element-UI 把这个不错的登录页面开发出来。&lt;/p&gt;

&lt;p&gt;在使用 Vue-CLI 创建 2.x 的脚手架项目后，会生成如下目录文件：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201101120030773-439684971.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;针对这个目录文件我写了一个脑图进行说明：&lt;/p&gt;
&lt;p&gt;（文字稍微有点多，&lt;strong&gt;赶时间的同学看红色部分就可以了&lt;/strong&gt;）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201101120031048-1867324920.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;红色最多的是 &lt;strong&gt;src&lt;/strong&gt; 文件夹，写的代码大部分都是放在这个文件夹下面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要提示，一下就刷到这里，只看文字不看图的同学，还是把图多看几秒哦，看不清楚，可以放大看，哈哈哈。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按照我自己对 Vue 的理解，画了一张几个主要文件之间程序调用执行的流程图：&lt;/p&gt;
&lt;p&gt;（水平有限，有错误请指正）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201101120031353-1204673736.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;图中简单描绘了 index.html、main.js、App.vue、store\index.js、router\index.js、views\login\index.vue 这几个文件之间的调用逻辑。暂时没有用到 components，因为登录界面不涉及到功能组件，只是个页面，代码放在 views 文件夹下即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈哈我又来提醒了，只看文字不看图的同学，多看几眼，看不清楚，请放大！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文接下来会对这些文件逐个进行代码解析，为了不让文章变得冗长，只贴部分代码，&lt;strong&gt;完整代码请到 GitHub 获取：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongfanger/sprint-frontend&quot;&gt;https://github.com/dongfanger/sprint-frontend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果想把这个项目复原出来，只看我写的文章是不够的，&lt;code&gt;git clone&lt;/code&gt;，&lt;strong&gt;顺手点个 star&lt;/strong&gt;，学习效果更好哦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.html 是项目中唯一的 html 文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 Vue 实现的是&lt;strong&gt;单页面应用&lt;/strong&gt;。单页面应用，简单理解就是只有一个页面，其他页面都是通过组件的形式挂载到这个页面上的，这样页面切换就会更快速，如桌面应用一般丝滑顺畅。&lt;/p&gt;
&lt;p&gt;其他页面的挂载点其实就是一个 div，其他页面都在放在这个 div 里面的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;    &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本项目是基于 Element-UI 的，需要使用 npm 安装一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm i element-ui -S
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.vue 文件是 Vue 框架的代码文件，分为3个部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
    html 模板
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
        javascript 脚本
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
        css 样式
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了文章简洁，本文不展示 css 样式的代码。&lt;/p&gt;
&lt;p&gt;template html 模板代码如下，实现了用户名、密码、登录等输入框和按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;loginbody&quot; :style=&quot;`background-image: url(${appInfo.backgroundImageUrl})`&quot;&amp;gt;
    &amp;lt;div class=&quot;login-box&quot;&amp;gt;
      &amp;lt;div class=&quot;login-title&quot;&amp;gt;
        &amp;lt;img class=&quot;login-logo&quot; :src=&quot;appInfo.loginLogoUrl&quot; alt=&quot;logo&quot; /&amp;gt;
        &amp;lt;p&amp;gt;{{ appInfo.title }}&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;div class=&quot;login-info&quot;&amp;gt;
        &amp;lt;el-form ref=&quot;form&quot; class=&quot;form-box&quot; :model=&quot;form&quot; :rules=&quot;formRules&quot;&amp;gt;
          &amp;lt;el-form-item :label=&quot;'用户名'&quot; prop=&quot;username&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;form.username&quot; placeholder=&quot;请输入用户名&quot; @keyup.enter.native=&quot;login&quot; ref=&quot;username-input&quot;&amp;gt;
            &amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
          &amp;lt;el-form-item :label=&quot;'密码'&quot; prop=&quot;password&quot;&amp;gt;
            &amp;lt;el-input
                    v-model=&quot;form.password&quot;
                    placeholder=&quot;请输入密码&quot;
                    type=&quot;password&quot;
                    show-password
                    @keyup.enter.native=&quot;login&quot;
            &amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
          &amp;lt;el-form-item&amp;gt;
            &amp;lt;div class=&quot;clear&quot;&amp;gt;
              &amp;lt;el-checkbox
                      v-model=&quot;form.rememberMe&quot;
                      :value=&quot;true&quot;
                      :label=&quot;'记住密码'&quot;
                      name=&quot;type&quot;
                      class=&quot;remember-checkbox&quot;
              &amp;gt;&amp;lt;/el-checkbox&amp;gt;
              &amp;lt;span class=&quot;self-right forgetPwd&quot; @click=&quot;forgetPwd&quot;&amp;gt;忘记密码？&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
          &amp;lt;el-form-item&amp;gt;
            &amp;lt;el-button type=&quot;primary&quot; @click=&quot;login&quot; class=&quot;login-btn&quot; :loading=&quot;isLoging&quot;&amp;gt;
              {{ &quot;登录&quot; }}
            &amp;lt;/el-button&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/el-form&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中页面背景图、logo 图、页面标题是通过 Vuex 来存取的。&lt;/p&gt;
&lt;p&gt;Vuex 是 Vue 的状态管理工具。Vue 组件之间数据传递一般是通过 export 和 import 的方式，但是对于全局数据，这种方式很难管理和维护。Vuex 作为中间媒介，帮助组件之间更好的传递数据。&lt;/p&gt;
&lt;p&gt;javascript 脚本代码如下，给 template 模板填充数据，定义元素行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;script&amp;gt;
  import { mapGetters } from &quot;vuex&quot;;
  export default {
    data() {
      return {
        form: {
          username: &quot;&quot;,
          password: &quot;&quot;,
          rememberMe: true
        },
        formRules: {
          username: [
            { required: true, message: &quot;请输入用户名&quot;, trigger: &quot;blur&quot; },
            {
              trigger: &quot;blur&quot;,
            },
          ],
          password: [{ required: true, message: &quot;请输入密码&quot;, trigger: &quot;blur&quot; }],
        },
        isLoging: false,
      };
    },
    created() {
    },
    mounted() {
      let autofocusElement = this.$refs[&quot;username-input&quot;];
      if (autofocusElement) {
        autofocusElement.focus();
      }
    },
    methods: {
      login() {
      },
      forgetPwd() {
        this.$alert(&quot;请联系管理员！&quot;, &quot;提示&quot;, {
          confirmButtonText: &quot;确定&quot;,
          callback: action =&amp;gt; {
            this.$message({
              type: &quot;info&quot;,
              message: `action: ${action}`,
            });
          },
        });
      },
    },
    computed: {
      ...mapGetters([&quot;appInfo&quot;]),
    },
  };
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中最后几行的 appInfo 就是定义的全局变量，使用 Vuex 来传递数据。&lt;/p&gt;

&lt;p&gt;appInfo 的实现代码放在 store\index.js 文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import Vuex from 'vuex'

const navBarLogoUrl = require(&quot;@/assets/image/logo.png&quot;);
const loginLogoUrl = require(&quot;@/assets/image/logo@2x.png&quot;);
const backgroundImageUrl = require(&quot;@/assets/image/login-bg.png&quot;);
const favicon = require(&quot;@/assets/image/favicon.png&quot;);

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    appInfo: null,
  },
  getters: {
    appInfo: state =&amp;gt; {
      if (state.appInfo) {
        return state.appInfo;
      }
      let localAppInfo = localStorage.getItem(&quot;AppInfo&quot;);
      if (localAppInfo) {
        return JSON.parse(localAppInfo);
      }
      return {
        dsp: &quot;这是公众号“测试老树”开发的测试平台。&quot;,
        navBarLogoUrl,
        loginLogoUrl,
        backgroundImageUrl,
        faviconUrl: favicon,
        title: &quot;测试平台&quot;,
      };
    },
  },
  mutations: {
    commitAppInfo(state, appInfo) {
      state.appInfo = appInfo;
    },
  },
  actions: {
    setAppInfo({ commit }, appInfo) {
      let info = {
        dsp: appInfo.dsp,
        title: appInfo.title || &quot;测试平台&quot;,
        navBarLogoUrl: appInfo.navBarLogoUrl || navBarLogoUrl,
        loginLogoUrl: appInfo.loginLogoUrl || loginLogoUrl,
        backgroundImageUrl: appInfo.backgroundImageUrl || backgroundImageUrl,
        faviconUrl: appInfo.faviconUrl || favicon,
      };

      commit(&quot;commitAppInfo&quot;, info);
      localStorage.setItem(&quot;AppInfo&quot;, JSON.stringify(info));
      let { faviconUrl, title } = info;

      let iconElement = document.querySelector(&quot;#t-icon&quot;);
      iconElement.href = faviconUrl;

      document.title = title;
    },
  },
  modules: {},
});

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;App.vue 是根组件，适合做一些初始化工作。&lt;/p&gt;
&lt;p&gt;从“程序执行流程”小节的逻辑图中可以看到，数据存储的操作就是在 App.vue 调用的，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  import { mapActions } from &quot;vuex&quot;;
  export default {
    name: &quot;App&quot;,
    data() {
      return {};
    },
    created() {
    },
    methods: {
      ...mapActions([&quot;setAppInfo&quot;]),
    },
  };
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;methods 调用了 setAppInfo 方法，给 appInfo 赋值。&lt;/p&gt;

&lt;p&gt;到这里，登录页面的代码就已经撸完了。是吗？是的！&lt;/p&gt;
&lt;p&gt;但是还无法访问，因为还没有給它配置路由，浏览器还不知道怎么才能跳转到这个登录页面。&lt;/p&gt;
&lt;p&gt;路由就是访问路径，让浏览器知道输入一个 url 该把哪个页面展示给你看。在以前，页面跳转路由都是放到后端来做的，前端请求后端，后端把渲染好的 html 返回给前端。现在时代不同了，前端直接控制了路由，前后端传递的数据变少了，访问体验也更佳。比如以前地址栏 URL 跳转可能会白屏，现在不会了。&lt;/p&gt;
&lt;p&gt;路由配置代码是放在 router\index.js 文件中的，默认 / 展示 Home 页面，访问 /login 展示 login 页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../views/Home.vue'
import login from &quot;../views/login&quot;

Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
    meta: {
      requireAuth: true,
    },
  },
  {
    path: &quot;/login&quot;,
    meta: {
      title: &quot;测试平台登录&quot;,
    },
    name: &quot;login&quot;,
    component: login,
  },
]

const router = new VueRouter({
  routes
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是首页不能直接就给别人看呀，得先登录！所以需要编写一个拦截器，必须登录后，才可以访问首页，否则跳转到登录页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;router.beforeEach((to, from, next) =&amp;gt; {
  if (to.matched.some(auth =&amp;gt; auth.meta.requireAuth)) {
    let token = localStorage.getItem(&quot;token&quot;);
    if (token) {
      next();
    } else {
      next({
        path: &quot;/login&quot;,
      });
    }
  } else {
    next();
  }
});
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;main.js 是程序执行入口，以上所有代码都需要在 main.js 中声明一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import Element from &quot;element-ui&quot;
import &quot;./assets/style/global.scss&quot;;

Vue.config.productionTip = false

Vue.use(Element)
new Vue({
  router,
  store,
  render: h =&amp;gt; h(App)
}).$mount('#app')

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;vue.config.js 是 Vue 项目配置文件。比如 index.html 中，页面 title 是通过 &lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;&lt;/code&gt; 来定义的，可以在配置文件中添加自定义，为 “sprint”：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;const path = require(&quot;path&quot;);

function resolve(dir) {
  return path.join(__dirname, dir);
}
module.exports = {
  publicPath: process.env.NODE_ENV === &quot;development&quot; ? &quot;./&quot; : &quot;/frontend/&quot;,
  chainWebpack: config =&amp;gt; {
    config.plugin(&quot;html&quot;).tap(args =&amp;gt; {
      args[0].title = &quot;sprint&quot;;
      return args;
    });
  },
};

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文首先展示了登录页面的效果，接着介绍了 Vue-CLI 初始化之后的项目结构，并对程序执行逻辑进行了分析，梳理出来了主要几个文件的调用流程，最后分别对各文件的代码进行了分析。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 23:45:00 +0000</pubDate>
<dc:creator>测试老树</dc:creator>
<og:description>Vue学起来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13909048.html</dc:identifier>
</item>
<item>
<title>使用Azure静态Web应用部署Blazor Webassembly应用 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/staticwebapp-blazor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/staticwebapp-blazor.html</guid>
<description>&lt;p&gt;上一次演示了如何使用Azure静态web应用部署VUE前端项目（&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/azure-static-webapp-vue.html&quot;&gt;使用 Azure静态web应用+Github全自动部署VUE站点&lt;/a&gt;）。我们知道静态web应用支持VUE，react，angular等项目的部署。除了支持这些常见前端框架，静态web应用同样支持微软推出的最新的前端框架Blazor Webassembly。今天就来演示下如何通过静态web应用部署Blazor项目。&lt;/p&gt;
&lt;h2 id=&quot;新建blazor项目&quot;&gt;新建blazor项目&lt;/h2&gt;
&lt;p&gt;使用VS新建一个blazor项目，因为是演示项目所以啥都不用改。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sagU.png&quot; alt=&quot;B0sagU.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;项目名称：WebStaticAppp_Blazor，完成新建。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sU3T.png&quot; alt=&quot;B0sU3T.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建github仓库&quot;&gt;新建github仓库&lt;/h2&gt;
&lt;p&gt;我们把代码存放在github上，所以需要新建一个空repository。仓库名称命名为staticwebapp_balzor。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sJNq.png&quot; alt=&quot;B0sJNq.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;回到上面创建的blazor项目，把代码推送到github仓库。推送成功后目录结构如下：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sY40.png&quot; alt=&quot;B0sY40.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建静态web应用&quot;&gt;新建静态web应用&lt;/h2&gt;
&lt;p&gt;在azure portal找到静态web应用（预览），点击创建弹出创建资源界面：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sNCV.png&quot; alt=&quot;B0sNCV.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;名称：staticwebapp-blazor&lt;br/&gt;区域：选个离你近的&lt;br/&gt;SKU：免费&lt;/p&gt;
&lt;h3 id=&quot;登录github账号&quot;&gt;登录Github账号&lt;/h3&gt;
&lt;p&gt;在源代码管理信息界面点击“使用Github登录”，弹出Github授权页面，确认授权。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sluQ.png&quot; alt=&quot;B0sluQ.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;授权成功后就可以选择刚才创建的仓库。&lt;br/&gt;储存库：staticwebapp_blazor。&lt;br/&gt;分支：master。&lt;br/&gt;生成预设；Blazor。&lt;br/&gt;应用位置：WebStaticApp_Blazor。&lt;br/&gt;API位置：默认。因为我们没有部署api，所以默认不用管他。&lt;br/&gt;应用项目位置：wwwroot。&lt;br/&gt;最后点击查看创建。等待创建资源，过一会portal会提示资源创建成功。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sMjg.png&quot; alt=&quot;B0sMjg.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;资源创建成功后，我们打开github上的项目，点击Actions，可以看到Azure Static Web App CI/CD这个job正在运行。等到这个job提示绿色对勾的时候就表示执行成功了。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0s3Hs.png&quot; alt=&quot;B0s3Hs.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;返回portal查看刚新建的静态web应用，点击概述，查看URL。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/02/B0vdDe.png&quot; alt=&quot;B0vdDe.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;把URL贴到浏览器里访问一下，熟悉的Blazor默认项目首页显示出来了。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/02/B0vcgf.png&quot; alt=&quot;B0vcgf.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们把首页修改一下：然后推送到仓库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;
&amp;lt;h1&amp;gt;Azure static web app with BLAZOR .&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推送成功后，仓库的actions会立马执行新的CI/CD任务，等到提示成功后，再次访问一下上面的URL，界面已经变化为我们修改的样式，说明部署成功了。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/01/B0sGEn.png&quot; alt=&quot;B0sGEn.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过简单的演示，我们熟悉了如何使用Azure静态web应用来部署blazor项目。流程上同部署VUE几乎一致，就是预设模板那里需要选择blazor而已，相当方便。当然了只有前端界面没有api服务是无法真正用来生产的，下一次我们演示下如何使用Azure静态web应用集成并调用Azure Functions 。&lt;/p&gt;
&lt;h2 id=&quot;关注我的公众号一起玩转技术&quot;&gt;关注我的公众号一起玩转技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/29/NfQjds.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 17:49:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>上一次演示了如何使用Azure静态web应用部署VUE前端项目（使用 Azure静态web应用+Github全自动部署VUE站点）。我们知道静态web应用支持VUE，react，angular等项目的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/staticwebapp-blazor.html</dc:identifier>
</item>
<item>
<title>Android Choreographer 源码分析 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/13912202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/13912202.html</guid>
<description>&lt;p&gt;Choreographer 的作用主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机。目前大部分手机都是 60Hz 的刷新率，也就是 16.6ms 刷新一次，系统为了配合屏幕的刷新频率，将 Vsync 的周期也设置为 16.6 ms，每个 16.6 ms ， Vsync 信号唤醒 Choreographer 来做 App 的绘制操作，这就是引入 Choreographer 的主要作用。了解 Choreographer 还可以帮助 App 开发者知道程序每一帧运行的基本原理，也可以加深对 Message、Handler、Looper、MessageQueue、Measure、Layout、Draw 的理解&lt;/p&gt;

&lt;p&gt;在介绍 Choreographer 之前，我们先理一下 Android 主线程运行的本质，其实就是 Message 的处理过程，我们的各种操作，包括每一帧的渲染，手势操作 ，都是通过 Message 的形式发给主线程的 MessageQueue ，MessageQueue 处理完消息继续等下一个消息，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MethodTrace 图示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-link&quot; href=&quot;https://www.androidperformance.com/images/15717420275540.jpg&quot; data-fancybox=&quot;group&quot; data-caption=&quot;&quot;&gt;&lt;img src=&quot;https://www.androidperformance.com/images/15717420275540.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Systrace 图示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-link&quot; href=&quot;https://www.androidperformance.com/images/15717420373518.jpg&quot; data-fancybox=&quot;group&quot; data-caption=&quot;&quot;&gt;&lt;img src=&quot;https://www.androidperformance.com/images/15717420373518.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以发现，每一帧时间都是固定的。所以一旦一个 Message 的处理时间超过了 16.6ms 就会引起卡顿。关于如何发现卡顿，可以参考文章：&lt;/p&gt;
&lt;div class=&quot;postTitle&quot;&gt;&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/huansky/p/13901964.html&quot;&gt;Android 教你如何发现 APP 卡顿&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;postCon&quot; readability=&quot;37&quot;&gt;

&lt;p&gt;Choreographer 扮演 Android 渲染链路中承上启下的角色&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;承上&lt;/strong&gt;：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;启下&lt;/strong&gt;：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync) .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面可以看出来， Choreographer 担任的是一个工具人的角色，他之所以重要，是因为通过 &lt;strong&gt;Choreographer + SurfaceFlinger + Vsync + TripleBuffer&lt;/strong&gt; 这一套从上到下的机制，保证了 Android App 可以以一个稳定的帧率运行(目前大部分是 60fps)，减少帧率波动带来的不适感。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;Choreographer-的工作流程&quot;&gt;Choreographer 的工作流程&lt;/h2&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer 初始化SurfaceFlinger 的 appEventThread 唤醒发送 Vsync ，Choreographer 回调 FrameDisplayEventReceiver.onVsync , 进入 Choreographer 的主处理函数 doFrame&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer.doFrame 计算掉帧逻辑&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer.doFrame 处理 Choreographer 的第一个 callback ： input&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer.doFrame 处理 Choreographer 的第二个 callback ： animation&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer.doFrame 处理 Choreographer 的第三个 callback ： insets animation&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Choreographer.doFrame 处理 Choreographer 的第四个 callback ： traversalChoreographer.doFrame 处理 Choreographer 的第五个 callback ： commit ?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;RenderThread 处理绘制数据，真正进行渲染&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;将渲染好的 Buffer swap 给 SurfaceFlinger 进行合成&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Choreographer-的单例初始化&quot;&gt;Choreographer 的单例初始化&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread local storage for the choreographer.&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Choreographer&amp;gt; sThreadInstance =
            &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Choreographer&amp;gt;&lt;span&gt;() {
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Choreographer initialValue() {
            Looper looper &lt;/span&gt;=&lt;span&gt; Looper.myLooper();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (looper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;The current thread must have a looper!&quot;&lt;span&gt;);
            }
            Choreographer choreographer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Choreographer(looper, VSYNC_SOURCE_APP);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (looper ==&lt;span&gt; Looper.getMainLooper()) {
                mMainInstance &lt;/span&gt;=&lt;span&gt; choreographer;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; choreographer;
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里采用的是 ThreadLocal 来构造单例，这样每个线程都会有一个属于自己的 choreographer 实例。&lt;/p&gt;
&lt;p&gt;接下去看 choreographer 的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; Choreographer(Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vsyncSource) {
        mLooper &lt;/span&gt;=&lt;span&gt; looper;
        mHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrameHandler(looper);&lt;br/&gt;&lt;span&gt;　　　　　// 这里可以发现只有在为 true 的时候才会使用 vsync 
&lt;/span&gt;        mDisplayEventReceiver &lt;/span&gt;=&lt;span&gt; USE_VSYNC
                &lt;/span&gt;? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrameDisplayEventReceiver(looper, vsyncSource)
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        mLastFrameTimeNanos &lt;/span&gt;=&lt;span&gt; Long.MIN_VALUE;
&lt;span&gt;　　　　 // 每一帧的间隔是根据刷新频率来的
&lt;/span&gt;        mFrameIntervalNanos &lt;/span&gt;= (&lt;span&gt;long&lt;/span&gt;)(1000000000 /&lt;span&gt; getRefreshRate());

        mCallbackQueues &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CallbackQueue[CALLBACK_LAST + 1&lt;span&gt;];&lt;br/&gt;&lt;span&gt;　　　　　// 给每一种回调类型都创建了一个队列
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= CALLBACK_LAST; i++&lt;span&gt;) {
            mCallbackQueues[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CallbackQueue();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; b/68769804: For low FPS experiments.&lt;/span&gt;
        setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, 1&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;15.936165837206&quot;&gt;
&lt;p&gt;这里做了几个初始化操作，根据Looper对象生成，Looper和线程是一对一的关系，对应上面说明里的每个线程对应一个Choreographer。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;初始化FrameHandler。接收处理消息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;初始化FrameDisplayEventReceiver。FrameDisplayEventReceiver用来接收垂直同步脉冲，就是VSync信号，VSync信号是一个时间脉冲，一般为60HZ，用来控制系统同步操作，怎么同ChoreoGrapher一起工作的，将在下文介绍。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;初始化mLastFrameTimeNanos(标记上一个frame的渲染时间)以及mFrameIntervalNanos(帧率,fps，一般手机上为1s/60)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;初始化CallbackQueue，callback队列，将在下一帧开始渲染时回调。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下去看看 FrameHandler 和 FrameDisplayEventReceiver 的结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FrameHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Handler {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FrameHandler(Looper looper) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(looper);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleMessage(Message msg) {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (msg.what) {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MSG_DO_FRAME:
                    doFrame(System.nanoTime(), &lt;/span&gt;0&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MSG_DO_SCHEDULE_VSYNC:
                    doScheduleVsync();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MSG_DO_SCHEDULE_CALLBACK:
                    doScheduleCallback(msg.arg1);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;20.446672447431&quot;&gt;
&lt;p&gt;看上面的代码，就是一个简单的Handler。处理3个类型的消息。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MSG_DO_FRAME：开始渲染下一帧的操作&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MSG_DO_SCHEDULE_VSYNC：请求 Vsync 信号&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;MSG_DO_SCHEDULE_CALLBACK：请求执行 callback&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面再细分一下，分别详细看一下这三个步骤是怎么实现的。&lt;/p&gt;
&lt;h2&gt;FrameDisplayEventReceiver&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FrameDisplayEventReceiver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DisplayEventReceiver
            &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mHavePendingVsync;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; mTimestampNanos;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mFrame;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FrameDisplayEventReceiver(Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vsyncSource) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(looper, vsyncSource);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO(b/116025192): physicalDisplayId is ignored because SF only emits VSYNC events for
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the internal display and DisplayEventReceiver#scheduleVsync only allows requesting VSYNC
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for the internal display implicitly.&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onVsync(&lt;span&gt;long&lt;/span&gt; timestampNanos, &lt;span&gt;long&lt;/span&gt; physicalDisplayId, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; frame) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Post the vsync event to the Handler.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The idea is to prevent incoming vsync events from completely starving
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the message queue.  If there are no messages in the queue with timestamps
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; earlier than the frame time, then the vsync event will be processed immediately.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise, messages that predate the vsync event will be handled first.&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timestampNanos &amp;gt;&lt;span&gt; now) {
                Log.w(TAG, &lt;/span&gt;&quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f&lt;span&gt;)
                        &lt;/span&gt;+ &quot; ms in the future!  Check that graphics HAL is generating vsync &quot;
                        + &quot;timestamps using the correct timebase.&quot;&lt;span&gt;);
                timestampNanos &lt;/span&gt;=&lt;span&gt; now;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mHavePendingVsync) {
                Log.w(TAG, &lt;/span&gt;&quot;Already have a pending vsync event.  There should only be &quot;
                        + &quot;one at a time.&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                mHavePendingVsync &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            mTimestampNanos &lt;/span&gt;=&lt;span&gt; timestampNanos;
            mFrame &lt;/span&gt;=&lt;span&gt; frame;
            Message msg &lt;/span&gt;= Message.obtain(mHandler, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            msg.setAsynchronous(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            mHandler.sendMessageAtTime(msg, timestampNanos &lt;/span&gt;/&lt;span&gt; TimeUtils.NANOS_PER_MS);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            mHavePendingVsync &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            doFrame(mTimestampNanos, mFrame);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;18.447215749679&quot;&gt;
&lt;p&gt;FrameDisplayEventReceiver 继承自 DisplayEventReceiver，同时也实现了Runnable 接口，是处于 Choreographer 中的私有内部类。当接收到底层的 VSync 信号开始处理 UI 过程。VSync 信号由 SurfaceFlinger 实现并定时发送。FrameDisplayEventReceiver 收到信号后，调用 onVsync 方法组织消息发送到主线程处理。这个消息主要内容就是 run 方法里面的 doFrame 了，这里 mTimestampNanos 是信号到来的时间参数。&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;那么 FrameDisplayEventReceiver 是通过什么方式在 Vsync 信号到来的时候回调 onVsync 呢？答案是 FrameDisplayEventReceiver 的初始化的时候，最终通过监听文件句柄的形式，其对应的初始化流程如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; android/view/Choreographer.java&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; Choreographer(Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vsyncSource) {
    mLooper &lt;/span&gt;=&lt;span&gt; looper;
    mDisplayEventReceiver &lt;/span&gt;=&lt;span&gt; USE_VSYNC
            &lt;/span&gt;? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrameDisplayEventReceiver(looper, vsyncSource)
            : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    ......
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; android/view/Choreographer.java&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; FrameDisplayEventReceiver(Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vsyncSource) {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(looper, vsyncSource);
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; android/view/DisplayEventReceiver.java&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; DisplayEventReceiver(Looper looper, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vsyncSource) {
    ......
    mMessageQueue &lt;/span&gt;=&lt;span&gt; looper.getQueue();
    mReceiverPtr &lt;/span&gt;= nativeInit(&lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;DisplayEventReceiver&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;), mMessageQueue,
            vsyncSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nativeInit 后续的代码可以自己跟一下，可以对照这篇文章和源码，由于篇幅比较多，这里就不细说了。&lt;/p&gt;
&lt;p&gt;简单来说，FrameDisplayEventReceiver 的初始化过程中，通过 BitTube (本质是一个 socket pair)，来传递和请求 Vsync 事件，当 SurfaceFlinger 收到 Vsync 事件之后，通过 appEventThread 将这个事件通过 BitTube 传给 DisplayEventDispatcher ，DisplayEventDispatcher 通过 BitTube 的接收端监听到 Vsync 事件之后，回调 Choreographer.FrameDisplayEventReceiver.onVsync ，触发开始一帧的绘制。&lt;/p&gt;
&lt;p&gt;如下图&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-link&quot; href=&quot;https://www.androidperformance.com/images/15717421215251.jpg&quot; data-fancybox=&quot;group&quot; data-caption=&quot;&quot;&gt;&lt;img src=&quot;https://www.androidperformance.com/images/15717421215251.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.965477560414&quot;&gt;
&lt;h2&gt;ChoreoGrapher 的总体流程&lt;/h2&gt;
&lt;p&gt;FrameHandler 和 FrameDisplayEventReceiver 是怎么工作的呢？ChoreoGrapher 的总体流程图如下图(拷贝的图片)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202011/916005-20201101192147831-124396412.png&quot; alt=&quot;&quot; width=&quot;957&quot; height=&quot;1473&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以上是总体的流程图：&lt;/p&gt;
&lt;div readability=&quot;6.9757000694284&quot;&gt;
&lt;div&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;PostCallBack or postFrameCallback发起添加回调，这个FrameCallBack将在下一帧被渲染时执行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;AddToCallBackQueue，将 FrameCallBack 添加到回调队列里面，等待时机执行回调。每种类型的callback按照设置的执行时间(dueTime)顺序排序分别保存在一个单链表中。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;判断 FrameCallBack设定的执行时间是否在当前时间之后，若是，发送 MSG_DO_SCHEDULE_CALLBACK 消息到主线程，安排执行doScheduleCallback，安排执行CallBack。否则直接跳到第4步。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;执行 scheduleFrameLocked，安排执行下一帧。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;判断上一帧是否已经执行，若未执行，当前操作直接结束。若已经执行，根据情况执行以下6、7步。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;若使用垂直同步信号进行同步，则执行7.否则，直接跳到9。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;若当前线程是UI线程，则通过执行scheduleVsyncLocked请求垂直同步信号。否则，送MSG_DO_SCHEDULE_VSYNC消息到主线程，安排执行doScheduleVsync，在主线程调用scheduleVsyncLocked。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;收到垂直同步信号，调用FrameDisplayEventReceiver.onVsync()，发送消息到主线程，请求执行doFrame。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;执行doFrame，渲染下一帧。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;主要的工作在 doFrame 中，接下来我们具体看看 doFrame 函数都干了些什么。&lt;br/&gt;从名字看很容易理解 doFrame 函数就是开始进行下一帧的显示工作。好了以下源代码又来了，我们一行一行分析一下吧。&lt;/p&gt;
&lt;h2&gt;doFrame&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.935381691479&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @UnsupportedAppUsage
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; doFrame(&lt;span&gt;long&lt;/span&gt; frameTimeNanos, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; frame) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; startNanos;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mLock) {&lt;br/&gt;&lt;span&gt;　　　　　　　// 为false, 说明还未开始
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mFrameScheduled) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no work to do&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG_JANK &amp;amp;&amp;amp;&lt;span&gt; mDebugPrintNextFrameTimeDelta) {
                mDebugPrintNextFrameTimeDelta &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                Log.d(TAG, &lt;/span&gt;&quot;Frame time delta: &quot;
                        + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + &quot; ms&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; intendedFrameTimeNanos =&lt;span&gt; frameTimeNanos;
            startNanos &lt;/span&gt;=&lt;span&gt; System.nanoTime();&lt;br/&gt;&lt;span&gt;　　　　　　　// 计算当前时间与 vsync 信号的时间差
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jitterNanos = startNanos -&lt;span&gt; frameTimeNanos;&lt;br/&gt;&lt;span&gt;　　　　　　　// 说明出现掉帧情况,注意只有 jitterNanos 大于 16.6 ms 才说明掉帧，否则只是轻微的延迟。
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jitterNanos &amp;gt;=&lt;span&gt; mFrameIntervalNanos) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; skippedFrames = jitterNanos /&lt;span&gt; mFrameIntervalNanos;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (skippedFrames &amp;gt;=&lt;span&gt; SKIPPED_FRAME_WARNING_LIMIT) {
                    Log.i(TAG, &lt;/span&gt;&quot;Skipped &quot; + skippedFrames + &quot; frames!  &quot;
                            + &quot;The application may be doing too much work on its main thread.&quot;&lt;span&gt;);
                }&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 当发生掉帧后，需要计算被耽误的时间。比如处理了 36.6ms, 一个周期是 16.6 ms, 相当于延迟了 3.4 ms 执行
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lastFrameOffset = jitterNanos %&lt;span&gt; mFrameIntervalNanos;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_JANK) {
                    Log.d(TAG, &lt;/span&gt;&quot;Missed vsync by &quot; + (jitterNanos * 0.000001f) + &quot; ms &quot;
                            + &quot;which is more than the frame interval of &quot;
                            + (mFrameIntervalNanos * 0.000001f) + &quot; ms!  &quot;
                            + &quot;Skipping &quot; + skippedFrames + &quot; frames and setting frame &quot;
                            + &quot;time to &quot; + (lastFrameOffset * 0.000001f) + &quot; ms in the past.&quot;&lt;span&gt;);
                }&lt;br/&gt;&lt;span&gt;　　　　　　　　　 // 修正当前帧的时间 = 开始时间 - 耽误时间
&lt;/span&gt;                frameTimeNanos &lt;/span&gt;= startNanos -&lt;span&gt; lastFrameOffset;
            }
&lt;span&gt;　　　　　　　// 当前时间小于前一帧时间，不执行操作
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frameTimeNanos &amp;lt;&lt;span&gt; mLastFrameTimeNanos) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_JANK) {
                    Log.d(TAG, &lt;/span&gt;&quot;Frame time appears to be going backwards.  May be due to a &quot;
                            + &quot;previously skipped frame.  Waiting for next vsync.&quot;&lt;span&gt;);
                }&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 直接请求下一个 vsync 信号
&lt;/span&gt;                scheduleVsyncLocked();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
&lt;span&gt;　　　　　　　// 大于 1 说明采用的默认帧数的一半，因此需要根据时间间隔来判断是否有必要执行绘制
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mFPSDivisor &amp;gt; 1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeSinceVsync = frameTimeNanos -&lt;span&gt; mLastFrameTimeNanos;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeSinceVsync &amp;lt; (mFrameIntervalNanos * mFPSDivisor) &amp;amp;&amp;amp; timeSinceVsync &amp;gt; 0&lt;span&gt;) {&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　// 时间间隔小于指定的时间，继续请求下一个 vsync 信号
&lt;/span&gt;                    scheduleVsyncLocked();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
&lt;span&gt;　　　　　　　// 保存当前帧的相关信息
&lt;/span&gt;            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
            mFrameScheduled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            mLastFrameTimeNanos &lt;/span&gt;=&lt;span&gt; frameTimeNanos;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;　　　　　　　// 执行相关 callbacks 
&lt;/span&gt;            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &lt;/span&gt;&quot;Choreographer#doFrame&quot;&lt;span&gt;);
            AnimationUtils.lockAnimationClock(frameTimeNanos &lt;/span&gt;/&lt;span&gt; TimeUtils.NANOS_PER_MS);

            mFrameInfo.markInputHandlingStart();
            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);

            mFrameInfo.markAnimationsStart();
            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
            doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);

            mFrameInfo.markPerformTraversalsStart();
            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);

            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            AnimationUtils.unlockAnimationClock();
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_FRAMES) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; endNanos =&lt;span&gt; System.nanoTime();
            Log.d(TAG, &lt;/span&gt;&quot;Frame &quot; + frame + &quot;: Finished, took &quot;
                    + (endNanos - startNanos) * 0.000001f + &quot; ms, latency &quot;
                    + (startNanos - frameTimeNanos) * 0.000001f + &quot; ms.&quot;&lt;span&gt;);
        }
    }&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9.9506294742039&quot;&gt;
&lt;div readability=&quot;26.36916810664&quot;&gt;
&lt;p&gt;总结起来其实主要是两个操作：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;设置当前 frame 的启动时间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;判断是否跳帧，若跳帧修正当前 frame 的启动时间到最近的 VSync 信号时间。如果没跳帧，当前 frame 启动时间直接设置为当前 VSync 信号时间。修正完时间后，无论当前 frame 是否跳帧，使得当前 frame 的启动时间与 VSync 信号还是在一个节奏上的，可能延后了一到几个周期，但是都是在下一个 vsync 信号到来才进行处理 。&lt;/p&gt;
&lt;div readability=&quot;56.687442880643&quot;&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;如下图所示是时间修正的一个例子，&lt;/p&gt;
&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;651&quot; data-height=&quot;261&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1688934-77ecfd7adb3f0015.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1688934-77ecfd7adb3f0015.jpg&quot; data-original-width=&quot;651&quot; data-original-height=&quot;261&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;60784&quot; data-image-index=&quot;5&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;没有跳帧但延迟&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;由于第二个 frame 执行超时，第三个 frame 实际启动时间比第三个 VSync 信号到来时间要晚，因为这时候延时比较小，没有超过一个时钟周期，系统还是将 frameTimeNanos3 传给回调，回调拿到的时间和 VSync 信号同步。&lt;/p&gt;
&lt;p&gt;再来看看下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;820&quot; data-height=&quot;420&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1688934-3bacde7e73429d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/820/format/webp&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1688934-3bacde7e73429d73.png&quot; data-original-width=&quot;820&quot; data-original-height=&quot;420&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;21227&quot; data-image-index=&quot;6&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;跳帧&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;由于第二个 frame执行时间超过 2 个时钟周期，导致第三个 frame 延后执行时间大于一个时钟周期，系统认为这时候影响较大，判定为跳帧了，将第三个 frame 的时间修正为 frameTimeNanos4，比 VSync 真正到来的时间晚了一个时钟周期。&lt;/p&gt;
&lt;p&gt;时间修正，既保证了doFrame操作和 VSync 保持同步节奏，又保证实际启动时间与记录的时间点相差不会太大，便于同步及分析。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;顺序执行callBack队列里面的callback&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;然后接下来看看 doCallbacks 的执行过程:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; doCallbacks(&lt;span&gt;int&lt;/span&gt; callbackType, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; frameTimeNanos) {
        CallbackRecord callbacks;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mLock) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We use &quot;now&quot; to determine when callbacks become due because it's possible
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for earlier processing phases in a frame to post callbacks that should run
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in a following phase, such as an input event that causes an animation to start.&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.nanoTime();&lt;br/&gt;　　　　　　　// 
            callbacks &lt;/span&gt;=&lt;span&gt; mCallbackQueues[callbackType].extractDueCallbacksLocked(
                    now &lt;/span&gt;/&lt;span&gt; TimeUtils.NANOS_PER_MS);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callbacks == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            mCallbacksRunning &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update the frame time if necessary when committing the frame.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We only update the frame time if we are more than 2 frames late reaching
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the commit phase.  This ensures that the frame time which is observed by the
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; callbacks will always increase from one frame to the next and never repeat.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We never want the next frame's starting frame time to end up being less than
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or equal to the previous frame's commit frame time.  Keep in mind that the
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; next frame has most likely already been scheduled by now so we play it
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; safe by ensuring the commit time is always at least one frame behind.&lt;br/&gt;　　　　　　　// commit 类型是最后执行的，如果此时发现前面处理时间过长，就会进行纠正。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (callbackType ==&lt;span&gt; Choreographer.CALLBACK_COMMIT) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; jitterNanos = now -&lt;span&gt; frameTimeNanos;
                Trace.traceCounter(Trace.TRACE_TAG_VIEW, &lt;/span&gt;&quot;jitterNanos&quot;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) jitterNanos);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jitterNanos &amp;gt;= 2 *&lt;span&gt; mFrameIntervalNanos) {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lastFrameOffset = jitterNanos %&lt;span&gt; mFrameIntervalNanos
                            &lt;/span&gt;+&lt;span&gt; mFrameIntervalNanos;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_JANK) {
                        Log.d(TAG, &lt;/span&gt;&quot;Commit callback delayed by &quot; + (jitterNanos * 0.000001f&lt;span&gt;)
                                &lt;/span&gt;+ &quot; ms which is more than twice the frame interval of &quot;
                                + (mFrameIntervalNanos * 0.000001f) + &quot; ms!  &quot;
                                + &quot;Setting frame time to &quot; + (lastFrameOffset * 0.000001f&lt;span&gt;)
                                &lt;/span&gt;+ &quot; ms in the past.&quot;&lt;span&gt;);
                        mDebugPrintNextFrameTimeDelta &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                    frameTimeNanos &lt;/span&gt;= now -&lt;span&gt; lastFrameOffset;
                    mLastFrameTimeNanos &lt;/span&gt;=&lt;span&gt; frameTimeNanos;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (CallbackRecord c = callbacks; c != &lt;span&gt;null&lt;/span&gt;; c =&lt;span&gt; c.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_FRAMES) {
                    Log.d(TAG, &lt;/span&gt;&quot;RunCallback: type=&quot; +&lt;span&gt; callbackType
                            &lt;/span&gt;+ &quot;, action=&quot; + c.action + &quot;, token=&quot; +&lt;span&gt; c.token
                            &lt;/span&gt;+ &quot;, latencyMillis=&quot; + (SystemClock.uptimeMillis() -&lt;span&gt; c.dueTime));
                }&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 运行每一个 callback
&lt;/span&gt;                c.run(frameTimeNanos);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mLock) {
                mCallbacksRunning &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CallbackRecord next =&lt;span&gt; callbacks.next;
                    recycleCallbackLocked(callbacks);
                    callbacks &lt;/span&gt;=&lt;span&gt; next;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (callbacks != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;20.627659574468&quot;&gt;
&lt;div readability=&quot;34.853173398117&quot;&gt;
&lt;p&gt;callback的类型有以下 4 种，除了文章一开始提到的 3 种外，还有一个 CALLBACK_COMMIT。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;CALLBACK_INPUT：输入&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;CALLBACK_ANIMATION：动画&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;CALLBACK_TRAVERSAL：遍历，执行 measure、layout、draw&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;CALLBACK_COMMIT：遍历完成的提交操作，用来修正动画启动时间&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后看上面的源码，分析一下每个 callback 的执行过程：&lt;/p&gt;
&lt;p&gt;1. callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS);&lt;/p&gt;
&lt;p&gt;得到执行时间在当前时间之前的所有 CallBack，保存在单链表中。每种类型的 callback 按执行时间先后顺序排序分别存在一个单链表里面。为了保证当前 callback 执行时新 post 进来的 callback 在下一个 frame 时才被执行，这个地方 extractDueCallbacksLocked 会将需要执行的 callback 和以后执行的 callback 断开变成两个链表，新 post 进来的 callback 会被放到后面一个链表中。当前 frame 只会执行前一个链表中的 callback，保证了在执行 callback 时，如果callback中Post相同类型的callback，这些新加的 callback 将在下一个 frame 启动后才会被执行。&lt;/p&gt;
&lt;p&gt;2. 接下来，看一大段注释，如果类型是 CALLBACK_COMMIT，并且当前 frame 渲染时间超过了两个时钟周期，则将当前提交时间修正为上一个垂直同步信号时间。为了保证下一个frame 的提交时间和当前 frame 时间相差为一且不重复。&lt;br/&gt;这个地方注释挺难看懂，实际上这个地方 CALLBACK_COMMIT 是为了解决 ValueAnimator 的一个问题而引入的，主要是解决因为遍历时间过长导致动画时间启动过长，时间缩短，导致跳帧，这里修正动画第一个 frame 开始时间延后来改善，这时候才表示动画真正启动。为什么不直接设置当前时间而是回溯一个时钟周期之前的时间呢？看注释，这里如果设置为当前 frame 时间，因为动画的第一个 frame 其实已经绘制完成，第二个 frame 这时候已经开始了，设置为当前时间会导致这两个 frame 时间一样，导致冲突。&lt;/p&gt;
&lt;p&gt;详细情况请看官方针对这个问题的修改。&lt;a href=&quot;https://link.jianshu.com?t=https://android.googlesource.com/platform/frameworks/base/+/c42b28d%5E!/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Fix animation start jank due to expensive layout operations.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;795&quot; data-height=&quot;465&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1688934-146921f79d6f5935.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/795/format/webp&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1688934-146921f79d6f5935.jpg&quot; data-original-width=&quot;795&quot; data-original-height=&quot;465&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;94511&quot; data-image-index=&quot;7&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;修正commit时间&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;比如说在第二个frame开始执行时，开始渲染动画的第一个画面，第二个frame执行时间超过了两个时钟周期，Draw操作执行结束后，这时候完成了动画第一帧的渲染，动画实际上还没开始，但是时间已经过了两个时钟周期，后面动画实际执行时间将会缩短一个时钟周期。这时候系统通过修正commit时间到frameTimeNanos的上一个VSync信号时间，即完成动画第一帧渲染之前的VSync信号到来时间，修正了动画启动时间，保证动画执行时间的正确性。&lt;/p&gt;
&lt;h3&gt;调用 c.run(frameTimeNanos) 执行回调&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallbackRecord {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CallbackRecord next;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; dueTime;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object action; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Runnable or FrameCallback&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object token;

        @UnsupportedAppUsage
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; frameTimeNanos) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (token ==&lt;span&gt; FRAME_CALLBACK_TOKEN) {
                ((FrameCallback)action).doFrame(frameTimeNanos);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ((Runnable)action).run();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CallbackRecord 的代码如上所示。&lt;/p&gt;
&lt;h2&gt;发起绘制的请求&lt;/h2&gt;
&lt;/div&gt;
&lt;p&gt;doFrame 的逻辑了解清楚了，但是关于发起 vsync 请求的逻辑却没有讲。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ViewRootImpl    &lt;/span&gt;
&lt;span&gt; @UnsupportedAppUsage
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; scheduleTraversals() {&lt;br/&gt;&lt;span&gt;　　　　　// 如果已经请求绘制了，就不会再次请求，因为多次请求，只有有一个执行就满足要求了
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mTraversalScheduled) {
            mTraversalScheduled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;　　　　　　　// 同步
&lt;/span&gt;            mTraversalBarrier &lt;/span&gt;=&lt;span&gt; mHandler.getLooper().getQueue().postSyncBarrier();&lt;br/&gt;&lt;span&gt;　　　　　　  // 发送一个 callback 用于在下一帧来临时候处理
&lt;/span&gt;            &lt;span&gt;mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, &lt;/span&gt;&lt;/span&gt;&lt;span&gt;null);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }&lt;br/&gt;&lt;span&gt;　　　　　　　// 通知稍候绘制
&lt;/span&gt;            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接着会调用 postCallbackDelayed：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; postCallbackDelayed(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; callbackType,
            Runnable action, Object token, &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; delayMillis) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;action must not be null&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callbackType &amp;lt; 0 || callbackType &amp;gt;&lt;span&gt; CALLBACK_LAST) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;callbackType is invalid&quot;&lt;span&gt;);
        }

        postCallbackDelayedInternal(callbackType, action, token, delayMillis);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要是做一些逻辑判断，确保传入的是对的。 &lt;/p&gt;
&lt;p&gt;接着又会调用 postCallbackDelayedInternal，保存 callback，并发起请求下一帧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; postCallbackDelayedInternal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; callbackType,
            Object action, Object token, &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; delayMillis) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_FRAMES) {
            Log.d(TAG, &lt;/span&gt;&quot;PostCallback: type=&quot; +&lt;span&gt; callbackType
                    &lt;/span&gt;+ &quot;, action=&quot; + action + &quot;, token=&quot; +&lt;span&gt; token
                    &lt;/span&gt;+ &quot;, delayMillis=&quot; +&lt;span&gt; delayMillis);
        }

        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mLock) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; SystemClock.uptimeMillis();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; dueTime = now +&lt;span&gt; delayMillis;
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);
&lt;span&gt;　　　　　　　 // 小于当前时间，说明需要立即执行
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dueTime &amp;lt;=&lt;span&gt; now) {
                scheduleFrameLocked(now);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;　　　　　　　　　 // 发送一个延迟 msg
&lt;/span&gt;                Message msg &lt;/span&gt;=&lt;span&gt; mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 &lt;/span&gt;=&lt;span&gt; callbackType;
                msg.setAsynchronous(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说，就是判断当前是否有必要发起一个绘制请求，比如你发了一个 500ms 后重绘的消息，对于这个消息，会在 500ms 后在进行处理。但如果不是延迟消息，那说明需要立即处理。但是对于 view 的绘制逻辑，必须得等到下一个 vsync 到来的时候才会真正进行绘制。&lt;/p&gt;
&lt;p&gt;接下来看看 scheduleFrameLocked 的逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; scheduleFrameLocked(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; now) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mFrameScheduled) {
            mFrameScheduled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (USE_VSYNC) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_FRAMES) {
                    Log.d(TAG, &lt;/span&gt;&quot;Scheduling next frame on vsync.&quot;&lt;span&gt;);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If running on the Looper thread, then schedule the vsync immediately,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise post a message to schedule the vsync from the UI thread
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; as soon as possible.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　// 如果是在一个 looper 线程中，那么直接执行请求就好
&lt;/span&gt;                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRunningOnLooperThreadLocked()) {
                    scheduleVsyncLocked();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　// 如果是在主线程，那么需要发送一个请求 vsync 的消息，并插到最前面，需要确保前一个消息处理完后在开始请求
&lt;/span&gt;                    Message msg &lt;/span&gt;=&lt;span&gt; mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                    msg.setAsynchronous(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    mHandler.sendMessageAtFrontOfQueue(msg);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 如果不用 vsync 信号，那么就可以直接执行，只是需要记录每一帧的时间
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nextFrameTime =&lt;span&gt; Math.max(
                        mLastFrameTimeNanos &lt;/span&gt;/ TimeUtils.NANOS_PER_MS +&lt;span&gt; sFrameDelay, now);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG_FRAMES) {
                    Log.d(TAG, &lt;/span&gt;&quot;Scheduling next frame in &quot; + (nextFrameTime - now) + &quot; ms.&quot;&lt;span&gt;);
                }
                Message msg &lt;/span&gt;=&lt;span&gt; mHandler.obtainMessage(MSG_DO_FRAME);
                msg.setAsynchronous(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                mHandler.sendMessageAtTime(msg, nextFrameTime);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要是根据具体情况来判断如何发起下一帧的绘制。对于采用 vsync 信号的主线程，会发送一个 MSG_DO_SCHEDULE_VSYNC 的消息，插到最前面，确保可以最早执行。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当收到 MSG_DO_SCHEDULE_VSYNC 消息后，就会给他安排请求 vsync 信号的请求，最后会会调到 onVsync 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doScheduleVsync() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mLock) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mFrameScheduled) {
                scheduleVsyncLocked();
            }
        }
    }


    @UnsupportedAppUsage
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scheduleVsyncLocked() {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发起获取 vsync 信号的请求&lt;/span&gt;
&lt;span&gt;        mDisplayEventReceiver.scheduleVsync();
    }   

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Schedules a single vertical sync pulse to be delivered when the next
     * display frame begins.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @UnsupportedAppUsage
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scheduleVsync() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mReceiverPtr == 0&lt;span&gt;) {
            Log.w(TAG, &lt;/span&gt;&quot;Attempted to schedule a vertical sync pulse but the display event &quot;
                    + &quot;receiver has already been disposed.&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            nativeScheduleVsync(mReceiverPtr);
        }
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
到这里，就把 Choreographer 的基本原理都讲完了。&lt;br/&gt; &lt;/div&gt;
&lt;h2 id=&quot;源码小结&quot;&gt;源码小结&lt;/h2&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Choreographer&lt;/strong&gt; 是线程单例的，而且必须要和一个 Looper 绑定，因为其内部有一个 Handler 需要和 Looper 绑定，一般是 App 主线程的 Looper 绑定&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DisplayEventReceiver&lt;/strong&gt; 是一个 abstract class，其 JNI 的代码部分会创建一个IDisplayEventConnection 的 Vsync 监听者对象。这样，来自 AppEventThread 的 VSYNC 中断信号就可以传递给 Choreographer 对象了。当 Vsync 信号到来时，DisplayEventReceiver 的 onVsync 函数将被调用。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DisplayEventReceiver&lt;/strong&gt; 还有一个 scheduleVsync 函数。当应用需要绘制UI时，将首先申请一次 Vsync 中断，然后再在中断处理的 onVsync 函数去进行绘制。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Choreographer&lt;/strong&gt; 定义了一个 &lt;strong&gt;FrameCallback&lt;/strong&gt;&lt;strong&gt;interface&lt;/strong&gt;，每当 Vsync 到来时，其 doFrame 函数将被调用。这个接口对 Android Animation 的实现起了很大的帮助作用。以前都是自己控制时间，现在终于有了固定的时间中断。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Choreographer&lt;/strong&gt; 的主要功能是，当收到 Vsync 信号时，去调用使用者通过 postCallback 设置的回调函数。目前一共定义了五种类型的回调，它们分别是：&lt;strong&gt;ListView&lt;/strong&gt; 的 Item 初始化(obtain\setup) 会在 input 里面也会在 animation 里面，这取决于&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_INPUT&lt;/strong&gt; : 处理输入事件处理有关&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_ANIMATION&lt;/strong&gt; ： 处理 Animation 的处理有关&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_INSETS_ANIMATION&lt;/strong&gt; ： 处理 Insets Animation 的相关回调&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_TRAVERSAL&lt;/strong&gt; : 处理和 UI 等控件绘制有关&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_COMMIT&lt;/strong&gt; ： 处理 Commit 相关回调&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CALLBACK_INPUT&lt;/strong&gt; 、&lt;strong&gt;CALLBACK_ANIMATION&lt;/strong&gt; 会修改 view 的属性，所以要比 CALLBACK_TRAVERSAL 先执行&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;最后附上一张时序图，来回顾一下整个流程&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200909155024659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4MzI2NjY0MTYy,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;927&quot; height=&quot;686&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.androidperformance.com/2019/10/22/Android-Choreographer/?hmsr=codercto.com&amp;amp;utm_medium=codercto.com&amp;amp;utm_source=codercto.com&quot; target=&quot;_blank&quot;&gt;Android 基于 Choreographer 的渲染机制详解&lt;/a&gt;&lt;/h3&gt;

</description>
<pubDate>Sun, 01 Nov 2020 16:53:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>Choreographer 的作用主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，也就是 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/13912202.html</dc:identifier>
</item>
<item>
<title>云计算管理平台之OpenStack Web管理工具dashboard - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13909884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13909884.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;37&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_201027155620openstack.jpg&quot; class=&quot;desc_img&quot;/&gt; openstack是iaas（Infrastructure as a Service）服务模型，所谓iaas指基础设施及服务；它的意思就是把基础设施用服务的方式通过网络对外提供；比如，我们要10台虚拟机；我们可以在openstack的web界面上点点鼠标就能给我们启动10台虚拟机，至于这些虚拟机在哪里，怎么启动的我们不用关心；我们只需要关心我们期望的10台虚拟机是不是能够正常使用，是不是我们期望的配置，网络是不是通畅；简单点讲iaas就是把基础设施以服务的方式对外提供，对用户来讲，它隐藏了基础设施的构建过程；常用的还有其他服务模型，比如saas,paas，lbaas,fwaas等等，这些都是在讲把什么抽象成服务的形式对外提供；这些服务模型的出现，大大简化了传统从底层开始构建的复杂过程；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;168.33292831106&quot;&gt;
&lt;p&gt;　　在上一篇博客中，我们成功的基于两种网络启动虚拟机；这意味着openstack的核心服务都搭建完成，并正常运行着；有关启动虚拟机实例请参考上一篇博客；今天我们来了解下，基于一个web界面图形工具来管理openstack上的虚拟机；&lt;/p&gt;
&lt;p&gt;　　openstack是iaas（Infrastructure as a Service）服务模型，所谓iaas指基础设施及服务；它的意思就是把基础设施用服务的方式通过网络对外提供；比如，我们要10台虚拟机；我们可以在openstack的web界面上点点鼠标就能给我们启动10台虚拟机，至于这些虚拟机在哪里，怎么启动的我们不用关心；我们只需要关心我们期望的10台虚拟机是不是能够正常使用，是不是我们期望的配置，网络是不是通畅；简单点讲iaas就是把基础设施以服务的方式对外提供，对用户来讲，它隐藏了基础设施的构建过程；常用的还有其他服务模型，比如saas,paas，lbaas,fwaas等等，这些都是在讲把什么抽象成服务的形式对外提供；这些服务模型的出现，大大简化了传统从底层开始构建的复杂过程；&lt;/p&gt;
&lt;p&gt;　　在上一篇博客我们主要聊了下在命令行通过命令的方式在openstack环境上启动虚拟机，通常这种方式不太适合对普通用户使用；为了让openstack易用，我们得给openstack提供一个图形界面，以实现方便任何人使用；dashboard是openstack环境中提供web界面的服务，其项目名称叫horizon，主要作用就是提供一个web管理界面，方便用户管理运行在openstack之上的虚拟机；&lt;/p&gt;
&lt;p&gt;　　1、dashboard服务的安装配置&lt;/p&gt;
&lt;p&gt;　　环境说明，dashboard这个服务可以运行在控制节点，也可以运行在其他一个单独的节点上，但是运行在单独的一个节点上，请提前配置好yum仓库，时间同步，以及主机名解析等等；有关基础环境的配置，请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13886693.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13886693.html&lt;/a&gt;；我这里用一台独立的服务安装dashboard服务；&lt;/p&gt;
&lt;p&gt;　　安装dashboard&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# yum install openstack-dashboard -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编辑/etc/openstack-dashboard/local_settings配置文件，配置OPENSTACK_HOST地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_HOST = &quot;controller&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101142140850-1167441392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里可以是主机名，可以是ip地址，默认是127.0.0.1；如果配置主机名，请提前对主机名做名称解析；&lt;/p&gt;
&lt;p&gt;　　配置任何主机都允许访问dashboard服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ALLOWED_HOSTS = ['*', ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101142426105-997114913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：*表示通配所有主机；&lt;/p&gt;
&lt;p&gt;　　配置存储session的服务为memcached，并配置memcached的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'

CACHES = {
    'default': {
         'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
         'LOCATION': 'controller:11211',
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101143200173-2114662916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：配置了memcached作为session存储服务器，下面默认的CACHES配置就要全部注释；&lt;/p&gt;
&lt;p&gt;　　启用Identity API版本3&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101143416141-375460727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：上面红框中的配置表示把%s替换成OPENSTACK_HOST这个变量的值；也就是说OPENSTACK_KEYSTONE_URL = “http://controller:5000/v3”&lt;/p&gt;
&lt;p&gt;　　启用对域的支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101143709075-992090174.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置API版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_API_VERSIONS = {
#    &quot;data-processing&quot;: 1.1,
    &quot;identity&quot;: 3,
    &quot;image&quot;: 2,
    &quot;volume&quot;: 2,
#    &quot;compute&quot;: 2,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101143828350-1842844996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置default域为用户的默认域&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &quot;Default&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101144101777-1173208945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置创建用户的角色默认为user角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101144245986-2116611479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置网络相关参数，如果openstack中的neutron服务配置的的是provider network ，需要禁用对三层网络的支持，如果是self-service network保持默认即可&lt;/p&gt;
&lt;p&gt;　　默认配置是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101144817185-35757085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果选用的是provider network这种网络模型，配置是&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
OPENSTACK_NEUTRON_NETWORK = {
    ...
    'enable_router': False,
    'enable_quotas': False,
    'enable_distributed_router': False,
    'enable_ha_router': False,
    'enable_lb': False,
    'enable_firewall': False,
    'enable_vpn': False,
    'enable_fip_topology_check': False,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101145341123-663352192.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置时区&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
TIME_ZONE = &quot;Asia/Shanghai&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101145447777-2037847318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在/etc/httpd/conf.d/openstack-dashboard.conf配置文件导入以下配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
WSGIApplicationGroup %{GLOBAL}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101151330089-1450742290.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动httpd服务，并将其设置为开机启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101152002954-1269480333.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上启动httpd没有成功的原因是在node04上没有安装连接memcache的驱动，所以导致启动httpd时连接memcached找不到模块；&lt;/p&gt;
&lt;p&gt;　　安装连接memcached驱动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# yum install python-memcached
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * centos-qemu-ev: mirror.bit.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package python-memcached.noarch 0:1.58-1.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

========================================================================================================================
 Package                       Arch                Version                    Repository                           Size
========================================================================================================================
Installing:
 python-memcached              noarch              1.58-1.el7                 centos-openstack-rocky               38 k

Transaction Summary
========================================================================================================================
Install  1 Package

Total download size: 38 k
Installed size: 123 k
Is this ok [y/d/N]: y
Downloading packages:
python-memcached-1.58-1.el7.noarch.rpm                                                           |  38 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : python-memcached-1.58-1.el7.noarch                                                                   1/1 
  Verifying  : python-memcached-1.58-1.el7.noarch                                                                   1/1 

Installed:
  python-memcached.noarch 0:1.58-1.el7                                                                                  

Complete!
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次启动httpd,看看是否能够起来？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl start httpd
[root@node04 ~]# ss -ntl
State      Recv-Q Send-Q               Local Address:Port                              Peer Address:Port              
LISTEN     0      128                              *:22                                           *:*                  
LISTEN     0      100                      127.0.0.1:25                                           *:*                  
LISTEN     0      128                             :::80                                          :::*                  
LISTEN     0      128                             :::22                                          :::*                  
LISTEN     0      100                            ::1:25                                          :::*                  
[root@node04 ~]# systemctl enable httpd.service 
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用浏览器访问httpd所在服务器ip地址+/dashboard，看看是否能够访问到dashboard?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101153407537-1466039320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用default域demo用户帐号和密码，登录dashbroad&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154309437-1531173179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看demo用户启动的虚拟机实例，看看是否能够看到之前我们启动的实例？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154353821-532656231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　管理实例，连接实例控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154707896-661389477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154749220-866450635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154900738-1059842926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　停止实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101154946530-2101085149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101155047106-1438552680.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建3个虚拟机实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101155208478-1422700626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101155313606-1203633295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择镜像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101155412848-2071701901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101155459199-93368949.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101164627375-795439149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101164701641-897587638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101164744122-1988112235.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们想要的3个虚拟机实例创建好了；&lt;/p&gt;
&lt;p&gt;　　验证：在计算节点上，看看是否有4个虚拟机处于运行状态呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# virsh list 
 Id    Name                           State
----------------------------------------------------
 1     instance-00000001              running
 13    instance-0000000e              running
 14    instance-0000000c              running
 15    instance-0000000d              running

[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到有4个虚拟机处于运行状态；&lt;/p&gt;
&lt;p&gt;　　查看网络top图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101164859964-2024466970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201101164936947-981186349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ok，到此dashboard服务就搭建好了；后续我们就可以使用这个web图形界面去管理虚拟机了；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 01 Nov 2020 16:15:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>在上一篇博客中，我们成功的基于两种网络启动虚拟机；这意味着openstack的核心服务都搭建完成，并正常运行着；有关启动虚拟机实例请参考上一篇博客；今天我们来了解下，基于一个web界面图形工具来管理o</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13909884.html</dc:identifier>
</item>
<item>
<title>优雅手撕bind函数(面试官常问) - bigname22</title>
<link>http://www.cnblogs.com/bigname/p/13912474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigname/p/13912474.html</guid>
<description>&lt;center&gt;&lt;span&gt;优雅手撕bind函数&lt;/span&gt;&lt;/center&gt;&lt;p&gt;前言：
&lt;/p&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;为什么面试官总爱让实现一个bind函数？&lt;/li&gt;
&lt;li&gt;他想从bind中知道些什么？&lt;/li&gt;
&lt;li&gt;一个小小的bind里面内有玄机？&lt;br/&gt;今天来刨析一下实现一个bind要懂多少相关知识点，也方便我们将零碎的知识点串联起来。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;👍 &lt;span&gt;看完有用的同学记得点个赞再走，您的鼓励-我莫大的动力&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;看完能学到什么&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;实现bind&lt;/li&gt;
&lt;li&gt;new原理&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;本文章的叙事步骤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;bind函数作用&lt;/li&gt;
&lt;li&gt;模拟bind的要点&lt;/li&gt;
&lt;li&gt;实现思路&lt;/li&gt;
&lt;li&gt;new函数特殊情况（this&amp;amp;父原型）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;-------------人工分割线-------------&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;bind函数的作用&quot;&gt;&lt;span&gt;bind函数的作用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;返回一个能够改变this指向的函数。&lt;/p&gt;
&lt;h3 id=&quot;模拟bind的要点&quot;&gt;&lt;span&gt;模拟bind的要点&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;改变this指向&lt;/li&gt;
&lt;li&gt;返回函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现思路&quot;&gt;&lt;span&gt;实现思路&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建一个待返回的函数，函数内部利用call/apply改变指向，call/apply的参数从arguments中获取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;  Function.prototype.myBind = function () {
        let exeFunc = this;
        let beThis = arguments[0];
        let args = [].slice.call(arguments ,1);
        return function () {
            exeFunc.apply(beThis,args);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来份数据测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; let other = {
        name: 'other'
    }
        let obj = {
        name: 'obj',
        getName : function (age,height) {
            console.log(this.name);
            console.log('年龄' + age);
            console.log('身高' + height);
        }
    }
    obj.getName.myBind(other, 14, 200)();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果正常。打印的是other&lt;/p&gt;
&lt;p&gt;还挺简单的是吧！但考点通常不止如此。接着看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function Person() {
        this.name = 'person';
        this.getName = function (age, height) {
            console.log(this.name);
            console.log('age:' + age, 'height:' + height);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let PersonMyBind = Person.myBind(window);
let per3 = new PersonMyBind();
per3.getName();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;思考一下会打印person吗？&lt;/p&gt;
&lt;p&gt;答案：实际上per3是一个空对象。&lt;/p&gt;
&lt;h3 id=&quot;new函数特殊情况-this&quot;&gt;&lt;span&gt;new函数特殊情况-this&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;那么为什么会出现这样的错误。这就牵扯到关于new的知识：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/bigname22/article/details/107481087&quot;&gt;如果不太明白的可便宜看下这篇文章&lt;/a&gt;&lt;br/&gt;这是一段关于new的模拟代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function New (constructFunc) {
        // 生命中间对象，最后作为返回的实例，相当于let obj = New(Obj); =&amp;gt; obj = res
        var res = {};
        if(constructFunc.prototype !== null) {
                // 将实例的原型指向构造函数的原型
                res.__proto__ = constructFunc.prototype;
        }
        // 重点重点 ret为该构造函数执行的结果，将构造函数的this改为执行res
        var ret = constructFunc.apply(res, Array.prototype.slice.call(arguments, 1));
        // 如果构造函数有返回值，则直接返回
        if((typeof rest === &quot;object&quot; || typeof ret === &quot;function&quot;) &amp;amp;&amp;amp; ret !== null) {
                return ret;
        }
        // 否则返回该实例
        return res;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;其中，下面一行代码就是导致我们写的bind不能如愿以偿将name、getName属性创建到对象的致命原因&lt;/mark&gt;，且听我细细道来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var ret = constructFunc.apply(res, Array.prototype.slice.call(arguments, 1));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们执行Person.myBind()的时候，我的得到的返回结果是一个函数：function () {exeFunc.apply(beThis,args);}，来个图明显一点。&lt;br/&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b494b486c01d48ff9395a4b3f64c4a02~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么当这一行代码执行时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var ret = constructFunc.apply(res, Array.prototype.slice.call(arguments, 1));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来张图来看清new Person与new PersonMyBind()的区别：&lt;br/&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c460c66c344649d887a3248dacc5bf21~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在知道产生这种现象的原因之后我们该如何解决？其实非常简单，如果是new的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; let resultFunc = function () {
            exeFn.apply(this, args) // 这里传入的是this对象，对应着new过程中的res
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这个时候问题就是该如何区分new Person（）和Person（）！答案还是在new的实现原理中找答案，我们可以找到上面new的模拟代码中的这一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; // 将实例的原型指向构造函数的原型
        res.__proto__ = constructFunc.prototype;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说在执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; let resultFunc = function () {
                        // 此时的this__proto__等于Person.prototype
            exeFn.apply(this, args)
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的this.__proto__等于Person.prototype,利用这一特性就ok了。&lt;br/&gt;升级我们的myBind&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; Function.prototype.myBind = function () {
        if(typeof this !== 'function') {
            throw new Error('调用者必须为function类型');
        }
        let exeFn = this; // this 为待执行函数
        let currentThis = arguments[0]; // 待指定的this
        let args = [].slice.call(arguments,1); // 剩余的都作为参数传递
        let resultFunc = function () {
           // 区分new调用与普通调用
            exeFn.apply(this.__proto__=== resultFunc.prototype ? this : currentThis, args)
        }
        return resultFunc;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;new函数特殊情况-父原型&quot;&gt;&lt;span&gt;new函数特殊情况-父原型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;到这里还没结束，我们还要解决Person加入有父原型的情况，在知道上面的知识点后解决这个也非常easy&lt;br/&gt;再升级一版：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;    Function.prototype.myBind = function () {
        if(typeof this !== 'function') {
            throw new Error('调用者必须为function类型');
        }
        let exeFn = this; // this 为待执行函数
        let currentThis = arguments[0]; // 待指定的this
        let args = [].slice.call(arguments,1); // 剩余的都作为参数传递
        let resultFunc = function () {
            // 区分new调用跟普通调用
            exeFn.apply(this.__proto__=== resultFunc.prototype ? this : currentThis, args)
        }
        // 维持原来函数的父原型
        if (this.prototype) {
            resultFunc.prototype = this.prototype;
        }
        return resultFunc;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打完收工&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 16:09:00 +0000</pubDate>
<dc:creator>bigname22</dc:creator>
<og:description>优雅手撕bind函数 前言： 为什么面试官总爱让实现一个bind函数？ 他想从bind中知道些什么？ 一个小小的bind里面内有玄机？ 今天来刨析一下实现一个bind要懂多少相关知识点，也方便我们将零</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigname/p/13912474.html</dc:identifier>
</item>
<item>
<title>Docker学习—DockerFile - chaney1992</title>
<link>http://www.cnblogs.com/cwsheng/p/13875131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwsheng/p/13875131.html</guid>
<description>&lt;p&gt;　&lt;a href=&quot;https://www.cnblogs.com/cwsheng/p/13837502.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;文章简单使用了docker 拉取镜像、启动容器、编译镜像；其中编译镜像时，使用到了Dockerfile,那么接下来我们就详细的来说说Dockerfile&lt;/p&gt;
&lt;h3&gt;DockerFile是什么：&lt;/h3&gt;
&lt;p&gt;　　Dockerfile 是一个用来构建镜像的文本文件，Dockerfile内容中包含了一条条构建镜像所需的指令和说明。&lt;strong&gt;最终采用docker build 命令通过dockerfile中指令构建镜像&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;各种指令详情：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、From：指定基础镜像（dockerfile第一个指令）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
FROM [--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt; [AS &amp;lt;name&amp;gt;&lt;span&gt;]
OR
FROM [&lt;/span&gt;--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt;[:&amp;lt;tag&amp;gt;] [AS &amp;lt;name&amp;gt;&lt;span&gt;]
OR
FROM [&lt;/span&gt;--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt;[@&amp;lt;digest&amp;gt;] [AS &amp;lt;name&amp;gt;&lt;span&gt;]

例如：
FROM mysql:&lt;/span&gt;&lt;span&gt;5.8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;有效的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;&lt;span&gt;&lt;span&gt;必须从&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;span&gt;开始&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ARG是Dockerfile中唯一可能位于FROM之前的指令&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;FROM可以在一个Dockerfile中多次出现，以创建多个映像或将一个构建阶段用作另一个构建阶段的依赖项&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过FROM指令添加AS name，可以选择为新生成阶段指定名称。该名称可以在后续的FROM和COPY--FROM=&amp;lt;name&amp;gt;指令中使用，以引用在此阶段中构建的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;标记或摘要值是可选的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、RUN：&lt;/strong&gt;构建镜像时执行的命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;两种方式:
　　RUN &lt;/span&gt;&amp;lt;command&amp;gt;                               　 ##命令在shell中运行，默认情况下/bin/sh -c在Linux或cmd /S /&lt;span&gt;CWindows上运行
　　RUN [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]  　　　　##exec 方式
例如：
　　RUN [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、CMD：&lt;/strong&gt;构建容器后调用，也就是在容器启动时才进行调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;三种格式：
    CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]     　　 　　##执行可执行文件，优先
    CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]                      　　##设置了    ENTRYPOINT，则直接调用ENTRYPOINT添加参数
    CMD command param1 param2 　　                　　##执行shell内部命令
例如：
　　CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/bin/wc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--help&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;EXEC&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;形式被解析为一个JSON阵列，这意味着必须使用双引号（“）周围的话不单引号（'）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、LABE&lt;/strong&gt;L：设置镜像标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;添加（K-V）形式元数据到镜像中，如果标签值中需要包含空格时，需要设置引号；反斜杠用于换号设置；示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;br/&gt;例如:&lt;br/&gt;　　LABEL &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.vendor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ACME Incorporated&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　LABEL com.example.label&lt;/span&gt;-with-value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　LABEL version&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　LABEL description&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This text illustrates \&lt;/span&gt;
　　that label-values can span multiple lines.&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;镜像中可以有多个LABLE，可以在一行指令中指定多个标签，如以下两种格式：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
LABEL multi.label1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; multi.label2=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; other=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
LABEL multi.label1&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
      multi.label2&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
      other&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;可以继承基础镜像中包含的的标签，如果标签已存在时，但值不同；则最近设置的值将覆盖以前的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;&lt;strong&gt;MAINTAINER（废弃）：设置生成镜像的作者信息，可使用更加灵活的&lt;span&gt;LABEL&lt;/span&gt;替代&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MAINTAINER &amp;lt;name&amp;gt;&lt;span&gt;
例如：
    MAINTAINER &lt;/span&gt;&amp;lt;name&amp;gt;&lt;span&gt;
替代：
    LABEL maintainer&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、EXPOSE：指定容器运行时监听指定网络端口；可以设置端口是TCP或UDP，默认TCP；&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
语法：&lt;br/&gt;　　EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;/&amp;lt;protocol&amp;gt;&lt;span&gt;...]
例如：
    EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;/&lt;span&gt;tcp
    EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;/udp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　注意：&lt;strong&gt;EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在&lt;code class=&quot;hljs dockerfile&quot;&gt;docker &lt;span class=&quot;hljs-keyword&quot;&gt;run&lt;/span&gt;&lt;/code&gt;运行容器时通过-p来发布这些端口，或通过&lt;code class=&quot;hljs diff&quot;&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-P&lt;/span&gt;&lt;/code&gt;参数来发布EXPOSE导出的所有端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、ENV：设置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
语法：&lt;br/&gt;　ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ... 　　##可以设置多个环境变量，如果key中包含空格，使用&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;进行标识；反斜杠用于换行
　ENV &lt;/span&gt;&amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;span&gt; 　　　　 ##只能设置一个置，不推荐该写法
例如：
　ENV MY_NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John Doe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　ENV MY_DOG&lt;/span&gt;=&lt;span&gt;Rex\ The\ Dog
　ENV MY_CAT&lt;/span&gt;=fluffy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从生成的映像运行容器时，使用ENV设置的环境变量将保持不变。&lt;/li&gt;
&lt;li&gt;修改ENV：docker run --env &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;8、ADD：&lt;/strong&gt;&lt;strong&gt;将本地文件添加到容器中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;span&gt;　　　　
ADD [&lt;/span&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;src&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,... &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;dest&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] ##包含空格的路径时，使用该方式
例如：
　ADD test.txt relativeDir&lt;/span&gt;/&lt;span&gt;
　ADD test.txt &lt;/span&gt;/absoluteDir/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--chown&lt;/code&gt;功能仅在用于构建Linux容器的Dockerfiles上受支持，而在Windows容器上不起作用&lt;/li&gt;
&lt;li&gt;src可以指定读个资源，但是如果它们是文件或目录，则将其路径解释为相对于构建上下文源的路径。&lt;/li&gt;
&lt;li&gt;src支持通配符，匹配规则采用Go的 &lt;a href=&quot;http://golang.org/pkg/path/filepath#Match&quot;&gt;filepath.Match&lt;/a&gt;规则完成&lt;/li&gt;
&lt;li&gt;目录本身不被复制，仅其内容被复制。&lt;/li&gt;
&lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;是以公认的压缩格式（身份，gzip，bzip2或xz）作为&lt;em&gt;本地&lt;/em&gt;tar归档文件，则将其解压缩为目录，&lt;span&gt;&lt;span&gt;来自&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;远程&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;URL的&lt;/span&gt;&lt;span&gt;资源&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;不会被&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;解压缩。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;直接或由于使用通配符而指定了多个资源，则该资源&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;必须是目录，并且必须以斜杠结尾&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;不以斜杠结尾，则将其视为常规文件，并将其内容&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;写入&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;不存在，它将与路径中所有缺少的目录一起创建&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;9、COPY：复制文件到容器指定目录&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;span&gt;
COPY [&lt;/span&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;src&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,... &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;dest&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
例如：
　COPY test.txt &lt;/span&gt;/absoluteDir/&lt;span&gt;
　COPY test.txt relativeDir&lt;/span&gt;/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　注意：同ADD指令差不多，区别为以下内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不会自动解压文件，也不能访问网络资源&lt;/li&gt;
&lt;li&gt;src不能为网络资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;10、ENTRYPOINT：&lt;/strong&gt;配置容器，使其可执行化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] 　  ##(可执行文件, 优先)
ENTRYPOINT command param1 param2 　　　　　　　　　  ##(shell内部命令)
例如：
ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;understand-how-cmd-and-entrypoint-interact&quot;&gt;&lt;strong&gt;　CMD和ENTRYPOINT相互作用&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Dockerfile应至少指定&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;&lt;span&gt;或&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;&lt;span&gt;命令之一。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;&lt;span&gt; 使用容器作为可执行文件时应定义。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;&lt;span&gt;应该用作&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;&lt;span&gt;&lt;span&gt;在容器&lt;/span&gt;&lt;span&gt;中定义&lt;/span&gt;&lt;span&gt;命令或执行临时命令的&lt;/span&gt;&lt;span&gt;默认参数的方式&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;&lt;span&gt; 当使用替代参数运行容器时，将被覆盖。&lt;/span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;11、VOLUME：指定持久化目录&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
VOLUME [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
例如:
 VOLUME [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/log/apache2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/apache2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　注意：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：
&lt;ul&gt;&lt;li&gt;卷可以容器间共享和重用&lt;/li&gt;
&lt;li&gt;容器并不一定要和其它容器共享卷&lt;/li&gt;
&lt;li&gt;修改卷后会立即生效&lt;/li&gt;
&lt;li&gt;对卷的修改不会对镜像产生影响&lt;/li&gt;
&lt;li&gt;卷会一直存在，直到没有任何容器在使用它&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;基于Windows的容器上的卷&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：使用基于Windows的容器时：除C盘目录、不存在或空目录&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从Dockerfile中更改卷&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：如果在声明了卷之后有任何构建步骤更改了卷中的数据，则这些更改将被丢弃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;SON格式&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：列表被解析为JSON数组。&lt;/span&gt;&lt;span&gt;您必须用双引号（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;&lt;span&gt;&lt;span&gt;）而不是单引号（&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;括住单词&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;12、USER：&lt;/strong&gt;指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
USER &amp;lt;user&amp;gt;[:&amp;lt;group&amp;gt;&lt;span&gt;]
or
USER &lt;/span&gt;&amp;lt;UID&amp;gt;[:&amp;lt;GID&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。&lt;/li&gt;
&lt;li&gt;镜像构建完成后，通过&lt;code&gt;docker run&lt;/code&gt;运行容器时，可以通过-u参数来覆盖所指定的用户。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;13、WORKDIR：设置工作目录&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
WORKDIR /path/to/workdir
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; 　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;pre&gt;
通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
在使用&lt;code class=&quot;hljs dockerfile&quot;&gt;docker &lt;span class=&quot;hljs-keyword&quot;&gt;run&lt;/span&gt;&lt;/code&gt;运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;14、ARG：构建参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ARG &amp;lt;name&amp;gt;[=&amp;lt;&lt;span&gt;default&lt;/span&gt; value&amp;gt;&lt;span&gt;]
例如：
　ARG user1&lt;/span&gt;=&lt;span&gt;someuser
　ARG buildno&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ARG 设置的环境变量仅对 Dockerfile 内有效&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不建议使用构建变量传递敏感信息，构建变量值在docker history 可以查看&lt;/li&gt;
&lt;li&gt;内置Arg变量：
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP_PROXY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http_proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTPS_PROXY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https_proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FTP_PROXY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ftp_proxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NO_PROXY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;no_proxy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;15、ONBUILD：&lt;/strong&gt;设置镜像触发器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ONBUILD &amp;lt;INSTRUCTION&amp;gt;&lt;span&gt;
例如：
　ONBUILD ADD . &lt;/span&gt;/app/&lt;span&gt;src
　ONBUILD RUN &lt;/span&gt;/usr/local/bin/python-build --dir /app/src 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;不允许&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ONBUILD&lt;/code&gt;&lt;span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;链接&lt;/span&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ONBUILD ONBUILD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ONBUILD&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令可能不会触发&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;&lt;span&gt;&lt;span&gt;或&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MAINTAINER&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;16、STOPSIGNAL：&lt;/strong&gt; &lt;strong&gt;STOPSIGNAL指令设置将发送到容器以退出的系统调用信号&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
STOPSIGNAL signal 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;17、HEALTHCHECK：指定某个程序或者指令来监控 docker 容器服务的运行状态。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;两种形式：
　　HEALTHCHECK [OPTIONS] CMD command   (通过在容器内部运行命令来检查容器运行状况)
　　HEALTHCHECK NONE             (禁用从基映像继承的任何运行状况检查)
例如：
　　HEALTHCHECK &lt;/span&gt;--interval=5m --timeout=&lt;span&gt;3s \
  　　CMD curl &lt;/span&gt;-f http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost/ || exit 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18、SHELL：允许重写命令的SHELL形式所使用的默认SHELL。Linux上的默认shell为[“/bin/sh”、“-c”]；Windows上的默认shell为[“cmd”、“/S”、“/c”]&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
语法：&lt;br/&gt;　　SHELL [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parameters&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
例如：
　　SHELL [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;powershell&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-command&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;&lt;span&gt;&lt;span&gt;可以出现多次。&lt;/span&gt;&lt;span&gt;每个&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令将覆盖所有先前的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令，并影响所有后续的指令&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;&lt;span&gt;&lt;span&gt;指令在Windows上特别有用，在Windows上有两个常用且完全不同的本机shell：&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd&lt;/code&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;powershell&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;DockerFile示例：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#设置基础镜像
FROM mcr.microsoft.com&lt;/span&gt;/dotnet/core/aspnet:&lt;span&gt;3.1&lt;/span&gt;-buster-slim AS &lt;span&gt;base&lt;/span&gt;&lt;span&gt;
#设置工作目录&lt;br/&gt;WORKDIR &lt;/span&gt;/&lt;span&gt;app
#设置监听端口&lt;br/&gt;EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
&lt;br/&gt;#设置镜像
FROM mcr.microsoft.com&lt;/span&gt;/dotnet/core/sdk:&lt;span&gt;3.1&lt;/span&gt;-&lt;span&gt;buster AS build&lt;br/&gt;#设置工作目录
WORKDIR &lt;/span&gt;/&lt;span&gt;src&lt;br/&gt;#复制文件夹
COPY [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer/cz.IdentityServer.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
#执行项目还原命令&lt;br/&gt;RUN dotnet restore &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer/cz.IdentityServer.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#复制文件&lt;br/&gt;COPY . .
WORKDIR &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/src/cz.IdentityServer&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;#执行编译项目命令&lt;/span&gt;&lt;span&gt;
RUN dotnet build &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -c Release -o /app/&lt;span&gt;build
#执行发布项目
FROM build AS publish
RUN dotnet publish &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -c Release -o /app/&lt;span&gt;publish

FROM &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt; AS final
WORKDIR &lt;/span&gt;/&lt;span&gt;app&lt;br/&gt;#复制发布内容到docker目录
COPY &lt;/span&gt;--&lt;span&gt;from&lt;/span&gt;=publish /app/&lt;span&gt;publish .&lt;br/&gt;#启动项目
ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cz.IdentityServer.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参考：https://docs.docker.com/engine/reference/builder/&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 14:36:00 +0000</pubDate>
<dc:creator>chaney1992</dc:creator>
<og:description>前言： 上一篇文章简单使用了docker 拉取镜像、启动容器、编译镜像；其中编译镜像时，使用到了Dockerfile,那么接下来我们就详细的来说说Dockerfile DockerFile是什么： D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cwsheng/p/13875131.html</dc:identifier>
</item>
<item>
<title>0基础学算法 搜索篇第一讲 深度优先搜索 - 球君</title>
<link>http://www.cnblogs.com/qj-Network-Box/p/13910876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qj-Network-Box/p/13910876.html</guid>
<description>&lt;p&gt;　　相信绝大多数人对于深度优先搜索和广度优先搜索是不会特别陌生的，如果我这样说似乎你没听说过，那如果我说dfs和bfs呢？先不说是否学习过它们，至少它们的大名应该是都是听说过的吧，深度优先搜索（Depth-First-Search)和广度优先搜索（Breadth-First-Search）同为搜索（Search）中的两个大类。顾名思义，他们的作用便是在一定的元素当中选取符合要求的元素，有些情况下无论你使用dfs或bfs都能得出结果，但是事实上它们两个本质上是有区别的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一讲深度优先搜索（Depth-First-Search)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;深度优先搜索是一种用途很广泛的算法，这种搜索方法使用的是一种比较基本的概念----递归，dfs就是基于递归而产生的一种严格意义上的算法，最开始的时候dfs是一种在开发爬虫早期使用较多的方法，它的目的是要达到被搜索结构的叶结点。那么深度优先搜索到底是如何实现的呢？&lt;/p&gt;
&lt;p&gt;　　要能理解dfs，首先理解递归是必要的（递归链接https://www.cnblogs.com/qj-Network-Box/p/12729230.html），在理解了递归后，就可以来看看这种算法的思想了&lt;/p&gt;
&lt;p&gt;　　假如你要搜寻节点①~节点⑩，然后你通过遍历找到了节点①，那么接下来你可以使用dfs找到接下来的节点&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101183709683-359102718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;找到第一个节点是必须的，然后就可以接着往下递归&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101184003407-19769660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;然后就要一路找到底，即一直找到要回溯的节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101184427184-1395898409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;如果到了节点⑤的时候又找到了可以继续往下递归的条件，那么还可以继续往下搜索&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101185207699-1305038142.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;然后在②处又找到了下面的一个节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101194133654-544133920.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;到了新的节点又可以向下搜搜&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101194458112-2147080824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;虽然现在回溯到了①，但是搜索还差几步，因为①再往下还有节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101195549438-1794948118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;要一直等到这里才是dfs最终结束的地方&lt;/p&gt;

&lt;p&gt; 以上便是dfs的基本思想了，但是呢dfs并不是一种一成不变的算法，事实上不同的情况下所写出来的dfs是不同的，但是思路差不多就类似以上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索（Depth-First-Search)的例题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在某个神奇的网站上，你总可以找到一些有趣的题巩固你学的知识，题目链接--&amp;gt;https://www.luogu.com.cn/problem/P1162&lt;/p&gt;
&lt;p&gt;　　这一道题算是一道比较基础的练习题吧（应该），其实这道题在你能够理解dfs的情况下，并找到思路的情况下应该是手到擒来的事。&lt;/p&gt;
&lt;p&gt;　　首先我们来仔细地读一读题大概意思就是被1框住的0要改写成2，我想很多人看到题的第一反应是想着怎么区别圈里面和圈外面的0，然后把圈里面的0改成2，似乎这个思路只有一个难点，那就是如何确定一个0到底处在圈里还是圈外，我开始也是这么想的，然后我想到了一个解决办法，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101212428855-578471464.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;一般的情况就如左图，所以我后来的分析都是基于左图的&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101212926373-1098157889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;然后我就想到了这个判定方法，也许你也想到了，但是我在实现这种方法的时候我发现了一个很大的瑕疵，假如那个圈不是规则的，而且不仅不规则，而且还是凹多边形这种思路就会出问题，问题如下图所示&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101213457389-115566874.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;如果测试点给的是这样图形，之前的判定方法就彻底失效了，因为很明显这个本来是一个在圈外的点，却会被判定成圈内的，那到底该如何识别一个0到底是圈外还是圈内呢？说实话，我到现在还是没想出来，但是很多时候我们就可以使用&lt;strong&gt;逆向思维大法&lt;/strong&gt;，既然很难判定是否是圈内的，那就反过来判断他是不是圈外的不就完了？首先我们可以确定一个0处于方阵边缘处肯定不是圈内的，所以我们可以通过这个方法可以先找到边缘的零，那么，与它相邻的0以及相邻于与他相邻的0定然也是在圈外的，那么这道题dfs的思路也好说了，找到一个圈外边缘的0，标记一下，然后搜索与他相邻的0，并标记后继续搜索，由于题目要求，我们每到一点只要向周围四个方向搜索即可&lt;/p&gt;
&lt;p&gt;供上搜索部分的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; n,a[&lt;span&gt;35&lt;/span&gt;][&lt;span&gt;35&lt;/span&gt;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};//四个方向
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     a[x][y]=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(x+x1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;x+x1[i]&amp;lt;n&amp;amp;&amp;amp;y+y1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;y+y1[i]&amp;lt;&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(a[x+x1[i]][y+y1[i]]==&lt;span&gt;0&lt;/span&gt;)    dfs(x+x1[i],y+&lt;span&gt;y1[i]);//dfs
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这道题只搜索这一次肯定是不够的，我们还需要考虑其他情况，比如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202011/1965215-20201101215100148-991269451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;这种情况下有两块不在圈内的区域，所以我们需要不止一次地运行dfs，也就是说我们在主函数中可以将他的边缘“走”一圈以确保每一块圈外的0都可以被标记到&lt;/p&gt;


&lt;p&gt;供上主函数+dfs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,a[&lt;span&gt;35&lt;/span&gt;][&lt;span&gt;35&lt;/span&gt;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
{
    a[x][y]&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x+x1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;x+x1[i]&amp;lt;n&amp;amp;&amp;amp;y+y1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;y+y1[i]&amp;lt;&lt;span&gt;n)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[x+x1[i]][y+y1[i]]==&lt;span&gt;0&lt;/span&gt;)    dfs(x+x1[i],y+&lt;span&gt;y1[i]);
        }
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
    {
        cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;a[i][j];
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i==&lt;span&gt;0&lt;/span&gt;||i==n-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;a[i][j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) dfs(i,j);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;(j==&lt;span&gt;0&lt;/span&gt;||j==n-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;a[i][j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) dfs(i,j);
    }
    pp();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在的代码就可以实现把所有不在圈里的0标记成5，在圈里的不变，不过代码还差最后一步，因为我们标记的时候将圈外的0标记成5，所以输出的时候要将所有是5的地方输出0，将原本是0的地方输出2，所以将这种输出处理一下就完成了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,a[&lt;span&gt;35&lt;/span&gt;][&lt;span&gt;35&lt;/span&gt;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y1[&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; pp()        
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[i][j]==&lt;span&gt;5&lt;/span&gt;) cout&amp;lt;&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(a[i][j]==&lt;span&gt;1&lt;/span&gt;) cout&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(a[i][j]==&lt;span&gt;0&lt;/span&gt;) cout&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
{
    a[x][y]&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x+x1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;x+x1[i]&amp;lt;n&amp;amp;&amp;amp;y+y1[i]&amp;gt;=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;y+y1[i]&amp;lt;&lt;span&gt;n)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[x+x1[i]][y+y1[i]]==&lt;span&gt;0&lt;/span&gt;)    dfs(x+x1[i],y+&lt;span&gt;y1[i]);
        }
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
    {
        cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;a[i][j];
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((i==&lt;span&gt;0&lt;/span&gt;||i==n-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;a[i][j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) dfs(i,j);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;(j==&lt;span&gt;0&lt;/span&gt;||j==n-&lt;span&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;a[i][j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) dfs(i,j);
    }
    pp();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本期的内容就到这里了，如果你觉得对你有帮助，那么帮忙把赞👍点一下吧，如果还期待我日后的表现，就点个关注➕好了，我们下期说说bfs，再见！&lt;/p&gt;
</description>
<pubDate>Sun, 01 Nov 2020 14:03:00 +0000</pubDate>
<dc:creator>球君</dc:creator>
<og:description>相信绝大多数人对于深度优先搜索和广度优先搜索是不会特别陌生的，如果我这样说似乎你没听说过，那如果我说dfs和bfs呢？先不说是否学习过它们，至少它们的大名应该是都是听说过的吧，深度优先搜索（Depth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qj-Network-Box/p/13910876.html</dc:identifier>
</item>
</channel>
</rss>