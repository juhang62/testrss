<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Trie(字典树、前缀树) - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/12724463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/12724463.html</guid>
<description>&lt;h3 id=&quot;什么是trie&quot;&gt;什么是Trie?&lt;/h3&gt;
&lt;p&gt;  Trie是一个多叉树，Trie专门为处理字符串而设计的。使用我们之前实现的&lt;a href=&quot;https://www.cnblogs.com/reminis/p/12605606.html&quot; target=&quot;_blank&quot;&gt;二分搜索树&lt;/a&gt;来查询字典中的单词，查询的时间复杂度为O(logn),如果有100万（2&lt;sup&gt;20&lt;/sup&gt;）个单词，则logn大约等于20，但是使用Trie这种数据结构，查询每个条目的时间复杂度，和一共有多少个条目无关！时间复杂度为O（w），w为被查询单词的长度！大多数单词的长度小于10。&lt;/p&gt;&lt;p&gt;  Trie将整个字符串以字母为单位，一个一个拆开，从根节点开始一直到叶子节点去遍历，就形成了一个单词，下图中的Trie就存储的四个单词(cat,dog,deer,panda)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418081308865-121243800.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  每个节点有26个字母指向下个节点的指针，考虑不同的语言，不同的情境，比如现在这个26个字符是没有包含大写字母的，如果需要包含大写字母，则需要让每个节点有52个指向下个节点的指针，如果现在要加入邮箱呢？所以这里描述为每个节点有若干个指向下个节点的指针。&lt;/p&gt;&lt;p&gt;  由于很多单词可能是另外一个单词的前缀，比如pan就是panda的前缀，那么再Trie中如何存储呢？所以我们应该对节点添加一个标识符，判断该节点是否是某个单词的结尾，某一个单词的结尾只靠叶子节点是不能区别出来的，因此我们再设计Node节点时，应该添加一个IsWord，判断该节点是否是单词的结尾。&lt;/p&gt;
&lt;h3 id=&quot;创建一棵trie&quot;&gt;创建一棵Trie&lt;/h3&gt;
&lt;p&gt;  在创建Trie之前，我们需要先设计Trie的节点类，根据上面说的，每个节点都有若干个指向下个节点的指针，还需要一个isWord来判断是否是单词的结尾，代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //设计Trie的节点类
    private class Node{
        
        //判断是否是一个单词
        public boolean isWord;
        //每个节点有若干个指向下个节点的指针
        public TreeMap&amp;lt;Character,Node&amp;gt; next;

        //有参构造：对该节点进行初始化
        public Node(boolean isWord){
            this.isWord = isWord;
            next = new TreeMap&amp;lt;&amp;gt;();
        }
        
        //无参构造：默认当前节点不是单词的结尾
        public Node(){
            this(false);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  现在就让我们来实现一个Trie&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Trie {

    //设计Trie的节点类
    private class Node{

        //判断是否是一个单词
        public boolean isWord;
        //每个节点有若干个指向下个节点的指针
        public TreeMap&amp;lt;Character,Node&amp;gt; next;

        //有参构造：对该节点进行初始化
        public Node(boolean isWord){
            this.isWord = isWord;
            next = new TreeMap&amp;lt;&amp;gt;();
        }

        //无参构造：默认当前节点不是单词的结尾
        public Node(){
            this(false);
        }

    }

    private Node root;
    private int size;

    public Trie() {
        root = new Node();
        size = 0;
    }

    // 获得Trie中存储的单词数量
    public int getSize(){
        return size;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;向trie中添加元素&quot;&gt;向Trie中添加元素&lt;/h3&gt;
&lt;p&gt;  Trie的添加操作：添加的是一个字符串，要把这个字符串拆成一个一个字符，把这一个一个字符作为一个一个节点，存入Trie中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //向Trie中添加一个新的单词word
    public void add(String word){
        Node cur = root;
        for (int i = 0 ;i &amp;lt; word.length(); i++){
            //将这个新单词，拆成一个一个字符
            char c = word.charAt(i);
            //如果当前节点的若干个子节点中，没有存储当前字符的节点，则需要创建一个子节点，存储当前字符
            if (cur.next.get(c) == null){
                cur.next.put(c,new Node());
            }
            cur = cur.next.get(c);
        }
        //对添加的新单词遍历结束后，判断当前节点是否为单词的结尾,如果不是我们才对size加一，并且维护当前节点的isWord
        if (! cur.isWord){
            cur.isWord = true;
            size ++;
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;trie的查询操作&quot;&gt;Trie的查询操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    //Tire的查询操作
    public boolean contains(String word){
        Node cur = root;
        for (int i = 0;i &amp;lt; word.length(); i++){
            char c = word.charAt(i);
            if (cur.next.get(c) == null ){
                return false;
            }
            cur = cur.next.get(c);
        }
        return cur.isWord;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  与查询类型，我们可以写一个是否存在以某个单词为前缀的单词&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //查询在Trie中是否有单词以prefix为前缀
    public boolean isPrefix(String prefix){
        Node cur = root;
        for (int i = 0; i &amp;lt; prefix.length(); i++){
            char c = prefix.charAt(i);
            if (cur.next.get(c) == null) 
                return false;
            cur = cur.next.get(c);
        }
        return true;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对比二分搜索树和trie的性能&quot;&gt;对比二分搜索树和Trie的性能&lt;/h3&gt;
&lt;p&gt;  这里对比二分搜索树和Trie的性能，仍然是使用的以添加和统计《傲慢与偏见》这本书为例，关于该测试用例中的文件工具类，和《傲慢与偏见》文档，请前往我之前写的 &lt;a href=&quot;https://www.cnblogs.com/reminis/p/12627994.html&quot; target=&quot;_blank&quot;&gt;集合和映射&lt;/a&gt; 进行获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        System.out.println(&quot;Pride and Prejudice&quot;);

        List&amp;lt;String&amp;gt; words = new ArrayList&amp;lt;&amp;gt;();

        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)){
//            Collections.sort(words);

            long startTime = System.nanoTime();

            //使用基于二分搜索树实现的集合进行添加和查询操作
            BSTSet&amp;lt;String&amp;gt; set = new BSTSet&amp;lt;&amp;gt;();
            for(String word: words)
                set.add(word);

            for(String word: words)
                set.contains(word);

            long endTime = System.nanoTime();

            double time = (endTime - startTime) / 1000000000.0;
            //基于二分搜索树实现的集合进行添加和查询操作所花费的时间
            System.out.println(&quot;Total different words: &quot; + set.getSize());
            System.out.println(&quot;BSTSet: &quot; + time + &quot; s&quot;);

            // --- 测试通过Trie通过添加和查询所需要的时间

            startTime = System.nanoTime();

            Trie trie = new Trie();
            for(String word: words)
                trie.add(word);

            for(String word: words)
                trie.contains(word);

            endTime = System.nanoTime();

            time = (endTime - startTime) / 1000000000.0;

            System.out.println(&quot;Total different words: &quot; + trie.getSize());
            System.out.println(&quot;Trie: &quot; + time + &quot; s&quot;);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418092323171-1883525308.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  通过上面测试代码可以看出，其实数据量不大的情况下，对于一个随机字符串的集合，使用二分搜索书和Trie进行添加和查询操作，差别是不大的，如果我们加入的数据是有序的，这时二分搜索树就会退化成链表，时间复杂度就为O（n），运行效率是很低的，但是Trie并不受影响，我们可以对words进行排序后，在看一下运行结果:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418092747994-316846633.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  通过上面的测试，可以看出对有序的数据进行添加和查询操作，差距是特别大的。&lt;/p&gt;
&lt;h3 id=&quot;leetcode上的问题&quot;&gt;leetcode上的问题&lt;/h3&gt;
&lt;p&gt;  我们可以看到leetcode官网上的208好问题，就是实现一个Trie&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418093307425-1828894363.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其实从题目描述中就可以看出，这个问题中的三个方法就是我们实现的add(),contains(),isPrefix()操作，直接将我们写的代码改个方法名字提交就可以通过了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418093715248-845421814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们再来看一道leetcode上的211号问题：添加与搜索单词&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418094002906-1224109417.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  通过题目描述，我们会发现只是查询操作和我们实现的Trie有所不同，添加操作没有发改变。由于字符'.'可以代表任何一个字母，所以我们对于'.'，需要遍历所有的可能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public boolean search(String word) {
        //递归匹配查找
        return match(root,word,0);
    }

    private boolean match(Node node, String word, int index) {
        if (index == word.length())
            return node.isWord;

        char c = word.charAt(index);
        if (c != '.'){
            if (node.next.get(c) == null)
                return false;
            return match(node.next.get(c),word,index+1);
        }
        else {
            //如果当前节点的的值为‘.’,则需要遍历当前节点的所有子节点
            for (char nextChar : node.next.keySet()) {
                if (match(node.next.get(nextChar),word,index+1)){
                    return true;
                }
            }
            return false;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码提交到leetcode后，就会提示通过了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418100010891-1601819729.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们再来看看leetcode上的677号问题：Map Sum Pairs(键值映射)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418100330008-527435735.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  根据题目描述，我们可以理解为：映射中存储的是单词和权重值。sum()方法是求得包含这个前缀单词得权重和&lt;br/&gt;代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //设计节点类
    private class Node{
        //单词的权重值
        public int value;
        //每个节点都可能有若干个子节点
        public TreeMap&amp;lt;Character,Node&amp;gt; next;

        public Node(int value){
            this.value = value;
            next = new TreeMap&amp;lt;&amp;gt;();
        }

        public Node(){
            this(0);
        }
    }

    private Node root;

    public MapSum(){
        root = new Node();
    }

    //添加操作和我们实现的字典树中的添加操作类型
    public void insert(String word,int val){
        Node cur = root;

        for (int i = 0 ; i &amp;lt; word.length() ; i++){
            char c = word.charAt(i);
            if (cur.next.get(c) == null){
                cur.next.put(c,new Node());
            }
            cur = cur.next.get(c);
        }
        cur.value = val;
    }

    //求前缀为prefix的权重和
    public int sum(String prefix){
        Node cur = root;
        for (int i = 0 ; i &amp;lt; prefix.length() ; i++){
            char c = prefix.charAt(i);
            if ( cur.next.get(c) == null ){
                return 0;
            }
            cur = cur.next.get(c);
        }
        return sum(cur);
    }

    private int sum(Node node) {
        int res = node.value;
        for (char c : node.next.keySet()) {
            res += sum(node.next.get(c));
        }
        return res;
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;leetcode上的提交结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200418102326942-1549974834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Apr 2020 00:28:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>[TOC] 什么是Trie? Trie是一个多叉树，Trie专门为处理字符串而设计的。使用我们之前实现的二分搜索树来查询字典中的单词，查询的时间复杂度为O(logn),如果有100万（2^20^）个单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/12724463.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 6 期  - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12728731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12728731.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;152.3838325928&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/12633951.html&quot;&gt;《痞子衡嵌入式半月刊： 第 5 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是谷雨，春季的最后一个节气。新冠疫情虽然还没有彻底结束，但是各行各业都在慢慢恢复了，还是喜欢忙忙碌碌又生机勃勃的日子。&lt;/p&gt;
&lt;p&gt;本期共收录 1条资讯、3个项目、2个工具、1个RT产品，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;1、zlg推出一款拥有高性能、功能全面、智能美观的86盒智能面板完整解决方案&quot;&gt;&lt;span&gt;1、ZLG推出一款拥有高性能、功能全面、智能美观的86盒智能面板完整解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;随着物联网等新兴市场的成长，智能面板作为智慧场景的终端正走进千家万户。ZLG倾力推出一款基于RT1052硬件平台、AWorksOS+AWTK软件平台，拥有高性能、功能全面、智能美观的86盒智能面板完整解决方案。&lt;/p&gt;
&lt;p&gt;该方案采用标准86盒硬件结构，核心处理器采用NXP的i.MX RT1052，该处理器主频高达600MHz，性能强悍。显示模组采用的是4.0寸电容触摸屏，分辨率为480*480。板载2.4G Wi-Fi模组，可轻松实现云端交互、手机APP控制等功能。同时还集成蓝牙Mesh模组，可实现智能设备蓝牙组网控制。在低功耗设计上，可实现一键开关机功能，ToF传感器作为距离检测系统，可实现“人近屏亮、人走屏灭”。板载多款传感器，实现多种环境数据的测量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/ZLG_86_SmartPanel_main.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;语音识别采用战略合作伙伴上海互问信息科技有限公司的语音识别SoC，该芯片识别率高，有效识别距离远（大于8米），词条丰富可定制。在配合智能面板的使用上，通过语音可迅速向主板发送控制指令，从而达到控制其它外设的目的，语音识别的加入，使得面板更加“智慧”！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/ZLG_86_SmartPanel_audio.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;1、u8g2---一个用于嵌入式设备的单色-oledlcd-图形库&quot;&gt;&lt;span&gt;1、u8g2 - 一个用于嵌入式设备的单色 OLED/LCD 图形库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;u8g2 是目前 Arduino 平台上使用最广泛的单色图形库。U8g2 支持单色 OLED 和 LCD，基本上主流的显示控制器都支持。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5957446808511&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/olikraus/u8g2&quot;&gt;https://github.com/olikraus/u8g2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要运用 u8g2 库？也就是说 u8g2 库能带给我们什么样的开发便利。主要有以下几点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;- u8g2 库平台支持性好，基本上支持绝大部分 Arduino 开发板；
- u8g2 库显示控制器支持性好，基本上市面上的 OLED 都完美支持；
- u8g2 库 API 众多，特别支持了中文，支持了不同字体，这是一个对于开发者俩说不小的福利。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一张官方提供的 U8G2 库测试图，基于 ESP32 和 SSD1306 OLED：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/u8g2_esp32_ssd1306_oled.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、emxgui---一个经过十年深度优化的图像引擎gui&quot;&gt;&lt;span&gt;2、emXGUI - 一个经过十年深度优化的图像引擎(GUI)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;emXGUI 是由国内刘巍于 2008 年开始编写，2010 年开始商用的一款图像引擎，主要产品是警用酒精检测仪，产品主要是出口，没有在国内宣传过。&lt;/p&gt;
&lt;blockquote readability=&quot;2.027027027027&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;http://www.emxgui.com/&quot;&gt;http://www.emxgui.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;emXGUI 源码不开源，提供多平台的 LIB 文件，提供完善的 API 手册，无论是个人还是公司都可以很快的上手。目前测试过的平台有：Cortex-M0/3/4/7，Cortex-A系列，ARM9 等。&lt;/p&gt;
&lt;p&gt;emXGUI 的特色如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1、占用资源少，效率高，在STM32F103不外扩RAM的情况下可以流畅运行
3、友好地支持矢量字体，提供矢量字体制作工具，除了制作矢量字体外，还可以制作矢量的符号
3、使用unicode字符编码支持多国语言，中文，英文，越南语，西班牙语等等
4、支持鼠标，支持触摸
5、自带滑动控件，非常方便，即在液晶屏上可以实现类似现在手机界面滑动的效果
6、高性能的绘图引擎+高效的Z序剪切策略 双管齐下
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/emXGUI_tests.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、learninggui---一款100使用-c-语言开发的通用嵌入式开源-gui&quot;&gt;&lt;span&gt;3、LearningGUI - 一款100%使用 C 语言开发的通用嵌入式开源 GUI&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;LearningGUI 被设计成独立于具体的硬件平台和具体的软件平台，是一款通用的嵌入式开源 GUI 系统。LearningGUI 的目标是替代 emWin，同时抢占中低端的 QT 市场。&lt;/p&gt;
&lt;p&gt;LearningGUI 无浮点运算，只调用 C，无汇编代码。显示，键盘，鼠标等驱动由用户在应用中编写注册，因此，LearningGUI 的通用性,可移植性非常好！它可以裸奔，也可以在 RTOS 上运行，同时更适合在 Linux 下运行。&lt;/p&gt;
&lt;p&gt;LearningGUI 的特色如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1、占用内存小。Basic版实行静态内存管理，占用10多K RAM. Windows版实行动态内存管理，占用内存与建立控件多少相关。
2、支持内置GB2312—80标准汉字库。
3、提供开放式字库访问接口。
4、提供开放式颜色转换接口。
5、提供消息驱动机制。
6、提供类似于Win32 SDK式样的API接口。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/LearningGUI_test.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;1、xmind---大脑的全功能瑞士军刀，笔和纸的高科技替代者&quot;&gt;&lt;span&gt;1、XMind - 大脑的全功能瑞士军刀，笔和纸的高科技替代者&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;XMind 是一款非常实用的商业思维导图软件，应用全球最先进的 Eclipse RCP 软件架构，全力打造易用、高效的可视化思维软件，强调软件的可扩展、跨平台、稳定性和性能，致力于使用先进的软件技术帮助用户真正意义上提高生产率。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0833333333333&quot;&gt;
&lt;p&gt;软件官网：&lt;a href=&quot;https://www.xmind.cn/&quot;&gt;https://www.xmind.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XMind 有哪些特点优势？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1、非常实用的思维导图软件，高效易用的可视化思维软件
2、通过XMind可以随时开展头脑风暴，帮助人们快速理清思路
3、可绘制的思维导图、鱼骨图、二维图、树形图、逻辑图、组织结构图等
4、以结构化的方式来展示具体的内容
5、人们在用XMind绘制图形的时候，可以时刻保持头脑清晰
6、随时把握计划或任务的全局，帮助人们在学习和工作用提高效率
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/XMind_2020.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、fritzing---支持面包板视图的电路设计软件&quot;&gt;&lt;span&gt;2、Fritzing - 支持面包板视图的电路设计软件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Fritzing 是一款支持多国语言的电路设计软件，有 4 种视图，分别是——面包板、原理图、PCB和Code。用鼠标单击就能轻松切换！其中，对于前3种视图（面包板、原理图和PCB）而言，无论你在其中的哪一种进行电路设计，软件都会自动化同步其他两种视图，还可以生成制版厂生产所需要的 Greber 文件、PDF 图片和 CAD 格式文件。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8292682926829&quot;&gt;
&lt;p&gt;软件官网：&lt;a href=&quot;https://fritzing.org/home/&quot;&gt;https://fritzing.org/home/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者特别喜爱其面包板视图，平时写技术文档用它画系统硬件连接示意图，显得高端大气上档次！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Fritzing_board_view.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;imxrt出品&quot;&gt;i.MXRT出品&lt;/h2&gt;
&lt;h3 id=&quot;1、新北洋---针式收据打印机btp-m180ii&quot;&gt;&lt;span&gt;1、新北洋 - 针式收据打印机(BTP-M180II)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;BTP-M180II 是新北洋推出的升级款针式收据打印机，打印相关部件可靠性全面提升，固件控制更智能，继承了上一代产品更换耗材方便快捷、耗材适应性强等全部优势，稳定性全面提升。&lt;/p&gt;
&lt;blockquote readability=&quot;3.1632653061224&quot;&gt;
&lt;p&gt;RT芯片：i.MXRT1050&lt;br/&gt;产品主页： &lt;a href=&quot;http://www.snbc.cn/product/1289.html&quot;&gt;http://www.snbc.cn/product/1289.html&lt;/a&gt;&lt;br/&gt;参考售价： 369 元&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/SNBC_BTP-M180II.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 19 Apr 2020 00:14:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12728731.html</dc:identifier>
</item>
<item>
<title>Redis学习二：Redis高并发之主从模式 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12724622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12724622.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;22.jpg&quot; src=&quot;https://user-gold-cdn.xitu.io/2020/4/9/1715bf789456a6b6?w=212&amp;amp;h=274&amp;amp;f=jpeg&amp;amp;s=35861&quot; alt=&quot;22.jpg&quot;/&gt;22.jpg&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前面已经学习了Redis的持久化方式，接下来开始学习Redis主从架构的原理，来看看Redis如何利用主从架构来保证高并发的。&lt;/p&gt;
&lt;h3 id=&quot;hredis&quot;&gt;Redis如何支持高并发&lt;/h3&gt;
&lt;p&gt;单机的redis一般QPS不会超过超过10万+，一般单机QPS都在几万左右，如果需要支撑高并发，我们可以将Redis做成主从架构来支持读写分离。&lt;/p&gt;
&lt;p&gt;主从架构 -&amp;gt; 读写分离 -&amp;gt; 支撑10万+读QPS&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;主从架构的核心原理&lt;/h3&gt;
&lt;p&gt;当启动一个slave node的时候，它会发送一个PSYNC命令给master node&lt;/p&gt;
&lt;p&gt;如果这是salve node重复你给你连接master node，那么master node仅仅会复制给slave部分缺失的数据；否则如果是slave node第一次连接master node，那么会触发一次full resynchronization&lt;/p&gt;
&lt;p&gt;开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。&lt;/p&gt;
&lt;p&gt;RDB文件生成完毕之后，master将这个RDB发送给slave，salve会先写入本地磁盘，然后再从本地磁盘加载到内存中。&lt;/p&gt;
&lt;p&gt;接着master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;主从复制断点续传&lt;/h3&gt;
&lt;p&gt;slave node如果跟master node有网络故障，断开了连接，会自动重连。&lt;/p&gt;
&lt;p&gt;从redis 2.8之后，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份&lt;/p&gt;
&lt;p&gt;master node会在内存中创建一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offseet开始继续复制&lt;/p&gt;
&lt;p&gt;但是如果没有找到对应的offset，那么就会执行一次full resynchronization&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;无磁盘化复制&lt;/h3&gt;
&lt;p&gt;master在内存中直接创建rdb，然后发送给slave，不会在自己的本地落地磁盘了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hkey&quot;&gt;过期key处理&lt;/h3&gt;
&lt;p&gt;slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送个slave。&lt;/p&gt;
&lt;p&gt;以上的执行流程如图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.jpg&quot; src=&quot;https://i.loli.net/2020/04/07/BvuYfNXMtgyr1sV.png&quot; alt=&quot;image.jpg&quot;/&gt;image.jpg&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;复制的完整流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;slave node在redis.conf中的slaveof配置master的host信息，slave node启动，仅仅是保存了master node信息，此时复制流程并未开始&lt;/li&gt;
&lt;li&gt;slave node内部有个定时任务，每秒检查是否有新的master node需要连接和复制，如果发现，就跟master node建立socket网络连接&lt;/li&gt;
&lt;li&gt;slave node发送ping的命令给master node&lt;/li&gt;
&lt;li&gt;口令认证，如果master设置了requiresspass，那么slave node必须发送masterauth的口令过去认证&lt;/li&gt;
&lt;li&gt;master node第一次执行全量复制，将所有数据发送给slave node&lt;/li&gt;
&lt;li&gt;master node后续持续将写命令，异步复制给slave node&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体流程如下：(以下内容参考自：&lt;br/&gt;https://blog.csdn.net/houjixin/article/details/27680183)&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;全量复制&lt;/h4&gt;
&lt;p&gt;全备份过程中，在slave启动时，会向其master发送一条SYNC消息，master收到slave的这条消息之后，将可能启动后台进程进行备份，备份完成之后就将备份的数据发送给slave，初始时的全同步机制是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slave启动后向master发送同步指令SYNC，master接收到SYNC指令之后将调用该命令的处理函数syncCommand（）进行同步处理；&lt;/li&gt;
&lt;li&gt;在函数syncCommand中，将调用函数rdbSaveBackground启动一个备份进程用于数据同步，如果已经有一个备份进程在运行了，就不会再重新启动了。&lt;/li&gt;
&lt;li&gt;备份进程将执行函数rdbSave（）完成将redis的全部数据保存为rdb文件。&lt;/li&gt;
&lt;li&gt;在redis的时间事件函数serverCron（redis的时间处理函数是指它会定时被redis进行操作的函数）中，将对备份后的数据进行处理，在serverCron函数中将会检查备份进程是否已经执行完毕，如果备份进程已经完成备份，则调用函数backgroundSaveDoneHandler完成后续处理。&lt;/li&gt;
&lt;li&gt;在函数backgroundSaveDoneHandler中，首先更新master的各种状态，例如，备份成功还是失败，备份的时间等等。然后调用函数updateSlavesWaitingBgsave，将备份的rdb数据发送给等待的slave。&lt;/li&gt;
&lt;li&gt;在函数updateSlavesWaitingBgsave中，将遍历所有的等待此次备份的slave，将备份的rdb文件发送给每一个slave。另外，这里并不是立即就把数据发送过去，而是将为每个等待的slave注册写事件，并注册写事件的响应函数sendBulkToSlave，即当slave对应的socket能够发送数据时就调用函数sendBulkToSlave（），实际发送rdb文件的操作都在函数sendBulkToSlave中完成。&lt;/li&gt;
&lt;li&gt;sendBulkToSlave函数将把备份的rdb文件发送给slave。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述函数调用过程如下图1所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/04/07/FEyPOVJWix9saQA.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;h4 id=&quot;h-7&quot;&gt;数据修改操作的同步&lt;/h4&gt;
&lt;p&gt;Redis的正常部署中一般都是一个master用于写操作，若干个slave用于读操作，另外定期的数据备份操作也是单独选址一个slave完成，这样可以最大程度发挥出redis的性能。在部署完成，各master\slave程序启动之后，首先进行第一阶段初始化时的全同步操作，全同步操作完成之后，后续所有写操作都是在master上进行，所有读操作都是在slave上进行，因此用户的写操作需要及时扩散到所有的slave以便保持数据最大程度上的同步。Redis的master-slave进程在正常运行期间更新操作（包括写、删除、更改操作）的同步方式如下：&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;master接收到一条用户的操作后，将调用函数call函数来执行具体的操作函数（此过程可参考另一文档《redis命令执行流程分析》），在该函数中首先通过proc执行操作函数，然后将判断操作是否需要扩散到各slave，如果需要则调用函数propagate（）来完成此操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;propagate（）函数完成将一个操作记录到aof文件中或者扩散到其他slave中；在该函数中通过调用feedAppendOnlyFile（）将操作记录到aof中，通过调用replicationFeedSlaves（）将操作扩散到各slave中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;函数feedAppendOnlyFile（）中主要保存操作到aof文件，在该函数中首先将操作转换成redis内部的协议格式，并以字符串的形式存储，然后将字符串存储的操作追加到aof文件后。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;函数replicationFeedSlaves（）主要将操作扩散到每一个slave中；在该函数中将遍历自己下面挂的每一个slave，以此对每个slave进行如下两步的处理：将slave的数据库切换到本操作所对应的数据库（如果slave的数据库id与当前操作的数据id不一致时才进行此操作）；将命令和参数按照redis的协议格式写入到slave的回复缓存中。写入切换数据库的命令时将调用addReply，写入命令和参数时将调用addReplyMultiBulkLen和addReplyBulk，函数addReplyMultiBulkLen和addReplyBulk最终也将调用函数addReply。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在函数addReply中将调用prepareClientToWrite（）设置slave的socket写入事件处理函数sendReplyToClient（通过函数aeCreateFileEvent进行设置），这样一旦slave对应的socket发送缓存中有空间写入数据，即调用sendReplyToClient进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;函数sendReplyToClient（）的主要功能是将slave中要发送的数据通过socket发出去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://i.loli.net/2020/04/07/9YCMoAJu8zrbjWS.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;h3 id=&quot;h-8&quot;&gt;数据同步相关核心机制&lt;/h3&gt;
&lt;p&gt;第一次slave连接master的时候，执行的是全量复制，这个过程中有些细节的机制&lt;/p&gt;
&lt;div&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;master和slave都会维护一个offset&lt;/p&gt;
&lt;p&gt;master会在自身不断累加offset，slave也会在自身不断累加offset。slave每秒都会上报自己的offset给master，同时master也会保存每个slave的offset。&lt;/p&gt;
&lt;p&gt;offset并不是只用在全量复制中，主要是master和slave都要知道各自的数据offset，才能知道互相之间数据不一致的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;backlog机制&lt;/p&gt;
&lt;p&gt;master node有一个backlog，默认大小是1M，master node给slave node复制数据时，也会将数据backlog中同步写一份，backlog主要是用来做全量复制中断时候的增量复制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;master run id&lt;/p&gt;
&lt;p&gt;在redis中执行info server命令，可以看到master run id，如果根据host+ip定位master node，是不准确的，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run id区分，run id不同就做全量复制。&lt;br/&gt;如果需要不更改run id重启redis，可以使用redis-cli debug reload命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;psync命令&lt;/p&gt;
&lt;p&gt;从节点使用psync从master node进行复制，psync runid offset，master node会根据自身的情况返回响应信息，可能是FULLRESYNC runid offset触发全量复制，可能是CONTINUE触发增量复制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;heatbeat机制&lt;/p&gt;
&lt;p&gt;主从节点互相都会发送heartbeat信息，master默认每隔10秒发送一次heartbeat，slave node每隔1秒发送一个heartbeat&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 19 Apr 2020 00:10:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>申明 本文章首发自本人公众号：壹枝花算不算浪漫，如若转载请标明来源! 感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫 22.jpg 前言 前面已经学习了Redis的持久化方式，接下来开始学习Redi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12724622.html</dc:identifier>
</item>
<item>
<title>Spring Boot 和 Spring Cloud 应用内存如何管理？ - 泥瓦匠BYSocket</title>
<link>http://www.cnblogs.com/Alandre/p/12729489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/12729489.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025159-264099982.png&quot; alt=&quot;Memory Management&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在整体应用架构中，非生产环境情况下，一般 1GB 或者 2GB 的 RAM 就足够了。如果我们将这个应用程序划分为 20 或 30 个独立的微服务，那么很难期望 RAM 仍将保持在 1GB 或 2GB 左右。特别是如果我们使用 Spring Cloud 的时候。&lt;/p&gt;
&lt;p&gt;首先，准备三个服务，Eureka 服务 + 提供 REST API 的两个简单的微服务，并将微服务注册到 Eureka。此处，不以任何方式限制这些应用程序的内存使用。&lt;/p&gt;
&lt;blockquote readability=&quot;2.9885057471264&quot;&gt;
&lt;p&gt;提示：Spring Cloud 简单应用的搭建示例：&lt;a href=&quot;https://www.ictgu.cn/share/6644e468&quot;&gt;https://www.ictgu.cn/share/6644e468&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像你在下图看到的一样，三个微服务大概占用了电脑 1.5GB 的 RAM 内存。这三个服务是最简单的应用程序，基本没有数据处理量，对于这样的内存消耗量，显然是不理想的。RAM 的最低使用量是用于 Eureka&lt;br/&gt;发现服务，最大的用于初始化声明式客户端以调用其他服务的 API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025358-76500093.png&quot; alt=&quot;未限制的内存用量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于内存使用量如下图 JProfiler 制作的图表。如图所示，内存使用受堆影响，与非堆相比，它占用了大量空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025492-1178400560.png&quot; alt=&quot;Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025620-1282121628.png&quot; alt=&quot;Non-Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，第一个明显的问题是我们是否需要在堆上运行我们的微服务应用程序的空间。答案是否定的，我们没有。现在，我们来简要介绍一下在&lt;br/&gt;Java 8 中如何进行内存管理过程。&lt;/p&gt;
&lt;p&gt;我们可以将JVM内存分为两个不同的部分：&lt;strong&gt;堆（Heap）&lt;/strong&gt;、 &lt;strong&gt;非堆（Non-Heap）&lt;/strong&gt;。如上图所示，我们的微服务器的大小为大小（〜600MB）。反过来，JVM 内存 由 &lt;strong&gt;年轻代（Young Generation）&lt;/strong&gt; 、&lt;strong&gt;老年代（Old Generation）&lt;/strong&gt;组成。所有新创建的对象都位于年轻代中。当年轻代被填满时，执行&lt;strong&gt;次要垃圾收集（Minor GC）&lt;/strong&gt;。更准确的说，这些位于年轻代的一部分对象成为 &lt;strong&gt;Eden Space&lt;/strong&gt;。Minor GC将所有仍然使用的对象从 Eden Space 移动到 &lt;strong&gt;Survivor 0&lt;/strong&gt;。对于Survivor 0 和 Survivor 1 空间执行相同的过程。在 GC 的许多循环中幸存的所有对象都被移动到老年代内存空间。从哪里移除对象是由 &lt;strong&gt;Major GC&lt;/strong&gt; 负责的。为了更好地了解下图，在运行 java -jar 命令时，可以使用以下参数设置 Java Heap 的内存限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;-Xms&lt;/strong&gt; – JVM启动时的初始堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xmx&lt;/strong&gt; – 最大堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; - 年轻代的大小，其余的空间是老年代&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025781-1208690811.png&quot; alt=&quot;JVM 内存&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JVM内存的第二部分，从我们的角度来看，上图略显不重要，它是Non-Heap。 Non-Heap 包括以下部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Thread Stacks&lt;/strong&gt; ：所有运行的线程的空间。可以使用 &lt;strong&gt;-Xss&lt;/strong&gt; 参数设置最大线程大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metaspace&lt;/strong&gt; ： 它替代了 PermGem（Java 7中是JVM堆的一部分）。在 Metaspace 中，通过应用程序加载所有类和方法。看看Spring Cloud 包含的包数量，我们不会在这里节省大量的内存。可以通过设置 &lt;strong&gt;-XX:MetaspaceSize&lt;/strong&gt; 和 &lt;strong&gt;-XX:MaxMetaspaceSize&lt;/strong&gt; 参数来管理 Metaspace 大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code Cache&lt;/strong&gt; ： 这是由 JIT（即时）编译器编译为本地代码的本机代码（如JNI）或 Java 方法的空间。最大大小设置 &lt;strong&gt;-XX:ReservedCodeCacheSize&lt;/strong&gt; 参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compressed Class Space&lt;/strong&gt; ： 使用 &lt;strong&gt;-XX：CompressedClassSpaceSize&lt;/strong&gt; 设置为压缩类空间保留的最大内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Direct NIO Buffers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更简单来说，Heap 是用于对象，Non-Heap 是用于类。可以想像，当我们的应用程序 Non-Heap 大于 Heap 时，我们可以结束这种情况。首先，让我们用下面的参数来运行我们的服务发现。在我看来，如果您在 Spring Boot 上启动具有内嵌 Tomcat 的 Eureka，这些配置是最低的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Xms16m \
-Xmx32m \
-XX:MaxMetaspaceSize=48m \
-XX:CompressedClassSpaceSize=8m \
-Xss256k \
-Xmn8m \
-XX:InitialCodeCacheSize=4m \
-XX:ReservedCodeCacheSize=8m \
-XX:MaxDirectMemorySize=16m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用REST API 的微服务（带有 Feign 或 Ribbon），我们需要增加一些值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Xms16m \
-Xmx48m \
-XX:MaxMetaspaceSize=64m \
-XX:CompressedClassSpaceSize=8m \
-Xss256k \
-Xmn8m \
-XX:InitialCodeCacheSize=4m \
-XX:ReservedCodeCacheSize=8m \
-XX:MaxDirectMemorySize=16m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照如上配置，JProfiler 生成了如下图表。区别在于启动和请求处理时间。与早期的设置相比，该应用程序的运行速度较慢。当然，我不会在生产环境下设置这样的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011025903-1846495157.png&quot; alt=&quot;Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011026022-1991582332.png&quot; alt=&quot;Non-Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前的总内存使用情况如下。微服务仍然是内存占用最大的，而Eureka 最小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202004/509099-20200419011026195-407145417.png&quot; alt=&quot;低配置的内存用量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我也尝试使用不同的 Web 容器运行 Eureka 应用程序。您可以通过在&lt;code&gt;pom.xml&lt;/code&gt; 文件中包含以下的依赖关系轻松更改 Web 容器。&lt;/p&gt;
&lt;p&gt;使用 Undertow&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-undertow&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Jetty&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-jetty&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果排名：Undertow（116MB）、Tomcat（122MB）、Jetty（128MB）。&lt;br/&gt;此测试仅针对 Eureka 服务执行，而无需注册任何微服务。&lt;/p&gt;
&lt;h2 id=&quot;文末福利&quot;&gt;文末福利&lt;/h2&gt;
&lt;p&gt;Java 资料大全 链接:&lt;a href=&quot;https://pan.baidu.com/s/1pUCCPstPnlGDCljtBVUsXQ&quot;&gt;https://pan.baidu.com/s/1pUCCPstPnlGDCljtBVUsXQ&lt;/a&gt; 密码:b2xc&lt;br/&gt;更多资料： 2020 年 精选阿里 Java、架构、微服务精选资料等，加 v ❤ ：qwerdd111&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载，请保留原文地址，谢谢 ~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 18 Apr 2020 17:10:00 +0000</pubDate>
<dc:creator>泥瓦匠BYSocket</dc:creator>
<og:description>在整体应用架构中，非生产环境情况下，一般 1GB 或者 2GB 的 RAM 就足够了。如果我们将这个应用程序划分为 20 或 30 个独立的微服务，那么很难期望 RAM 仍将保持在 1GB 或 2GB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Alandre/p/12729489.html</dc:identifier>
</item>
<item>
<title>【高并发】高并发环境下如何防止Tomcat内存溢出？看完我懂了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12729409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12729409.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;随着系统并发量越来越高，Tomcat所占用的内存就会越来越大，如果对Tomcat的内存管理不当，则可能会引发Tomcat内存溢出的问题，那么，如何防止Tomcat内存溢出呢？我们今天就来一起探讨下这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;防止Tomcat内存溢出可以总结为两个方案：一个是设置Tomcat启动的初始内存，一个是防止Tomcat所用的JVM内存溢出。接下来，我们就分别对这两种方案作出简单的介绍。&lt;/p&gt;
&lt;h2 id=&quot;设置启动初始内存&quot;&gt;设置启动初始内存&lt;/h2&gt;
&lt;p&gt;其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下给出1G内存环境下java jvm 的参数设置参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;JAVA_OPTS=&quot;-server -Xms800m -Xmx800m  -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true &quot;
JAVA_OPTS=&quot;-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:NewSize=192m -XX:MaxNewSize=384m&quot;
CATALINA_OPTS=&quot;-server -Xms768m -Xmx768m -XX:PermSize=128m -XX:MaxPermSize=256m -XX:NewSize=192m -XX:MaxNewSize=384m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在/usr/local/apache-tomcat-7.0/bin 目录下的catalina.sh文件中，添加：JAVA_OPTS='-Xms512m -Xmx1024m'，要加“m”说明是MB，否则就是KB了，在启动tomcat时会报内存不足。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-Xms：初始值&lt;/li&gt;
&lt;li&gt;-Xmx：最大值&lt;/li&gt;
&lt;li&gt;-Xmn：最小值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在catalina.bat最前面加入set JAVA_OPTS=-Xms128m -Xmx350m，如果用startup.bat启动tomcat,OK设置生效。够成功的分配200M内存。但是如果不是执行startup.bat启动tomcat而是利用windows的系统服务启动tomcat服务,上面的设置就不生效了，就是说set JAVA_OPTS=-Xms128m -Xmx350m 没起作用。上面分配200M内存就OOM了。。&lt;br/&gt;windows服务执行的是bin\tomcat.exe。它读取注册表中的值，而不是catalina.bat的设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改注册表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Tomcat Service Manager\Tomcat5\Parameters\JavaOptions
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原值为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-Dcatalina.home=&quot;C:\ApacheGroup\Tomcat 7.0&quot;
-Djava.endorsed.dirs=&quot;C:\ApacheGroup\Tomcat 7.0\common\endorsed&quot;
-Xrs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入 -Xms300m -Xmx350m&lt;br/&gt;重起tomcat服务，设置生效。&lt;/p&gt;
&lt;h2 id=&quot;防止所用的jvm内存溢出&quot;&gt;防止所用的JVM内存溢出&lt;/h2&gt;
&lt;h3 id=&quot;1javalangoutofmemoryerror-java-heap-space&quot;&gt;&lt;strong&gt;1.java.lang.OutOfMemoryError: Java heap space&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heap size 设置&lt;/p&gt;
&lt;p&gt;JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。&lt;/p&gt;
&lt;p&gt;提示：在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。&lt;/p&gt;
&lt;p&gt;提示：Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;手动设置Heap size&lt;/p&gt;
&lt;p&gt;修改TOMCAT_HOME/bin/catalina.bat，在“echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot;”上面加入以下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m  
set JAVA_OPTS=%JAVA_OPTS% -server -Xms800m -Xmx800m -XX:MaxNewSize=256m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或修改catalina.sh&lt;/p&gt;
&lt;p&gt;在“echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot;”上面加入以下行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JAVA_OPTS=&quot;$JAVA_OPTS -server -Xms800m -Xmx800m -XX:MaxNewSize=256m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2javalangoutofmemoryerror-permgen-space&quot;&gt;2.java.lang.OutOfMemoryError: PermGen space&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PermGen space的全称是Permanent Generation space,是指内存的永久保存区域，这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很CLASS的话,就很可能出现PermGen space错误，这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;手动设置MaxPermSize大小&lt;/p&gt;
&lt;p&gt;修改TOMCAT_HOME/bin/catalina.bat（Linux下为catalina.sh），在代码&lt;br/&gt;“echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot;”上面加入以下行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot;”上面加入以下行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128M -XX:MaxPermSize=512m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;catalina.sh文件的修改如下。&lt;/p&gt;
&lt;p&gt;Java代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;JAVA_OPTS=&quot;$JAVA_OPTS -server -XX:PermSize=128M -XX:MaxPermSize=512m&quot; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3分析javalangoutofmemoryerror-permgen-space&quot;&gt;3.分析java.lang.OutOfMemoryError: PermGen space&lt;/h3&gt;
&lt;p&gt;发现很多人把问题归因于： spring,hibernate,tomcat，因为他们动态产生类,导致JVM中的permanent heap溢出 。然后解决方法众说纷纭，有人说升级 tomcat版本到最新甚至干脆不用tomcat。还有人怀疑spring的问题，在spring论坛上讨论很激烈，因为spring在AOP时使用CBLIB会动态产生很多类。&lt;/p&gt;
&lt;p&gt;但问题是为什么这些王牌的开源会出现同一个问题呢，那么是不是更基础的原因呢？tomcat在Q&amp;amp;A很隐晦的回答了这一点，我们知道这个问题，但这个问题是由一个更基础的问题产生。&lt;/p&gt;
&lt;p&gt;于是有人对更基础的JVM做了检查，发现了问题的关键。原来SUN 的JVM把内存分了不同的区，其中一个就是permenter区用来存放用得非常多的类和类描述。本来SUN设计的时候认为这个区域在JVM启动的时候就固定了，但他没有想到现在动态会用得这么广泛。而且这个区域有特殊的垃圾收回机制，现在的问题是动态加载类到这个区域后，gc根本没办法回收！&lt;/p&gt;
&lt;p&gt;对于以上两个问题，我的处理是：&lt;/p&gt;
&lt;p&gt;在catalina.bat的第一行增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;set JAVA_OPTS=-Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在catalina.sh的第一行增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;JAVA_OPTS= -Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发编程技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上并发编程需要掌握的核心技能知识图，祝大家在学习并发编程时，少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200419004434474.jpg&quot; alt=&quot;sandahexin_20200322&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Apr 2020 16:47:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 随着系统并发量越来越高，Tomcat所占用的内存就会越来越大，如果对Tomcat的内存管理不当，则可能会引发Tomcat内存溢出的问题，那么，如何防止Tomcat内存溢出呢？我们今天就来一起</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12729409.html</dc:identifier>
</item>
<item>
<title>SpringCloud入门(十)： Config 统一配置中心 - 愚蠢的猴子</title>
<link>http://www.cnblogs.com/jiangyaxiong1990/p/12725806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangyaxiong1990/p/12725806.html</guid>
<description>&lt;p&gt;&lt;strong&gt;SpringCloud Config 简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在分布式系统中，由于服务组件过多，为了方便争对不通的环境下的服务配置文件统一管理，实时更新，所以出现了分布式配置中心组件。市面上开源的配置中心有很多，360的QConf、淘宝的diamond、百度的disconf都是解决这类问题。国外也有很多开源的配置中心Apache的Apache Commons Configuration等。SpringCloud中选用的是SpringCloud Config。&lt;/p&gt;
&lt;p&gt;　　SpringCloud Config分为Config Server和Config Client两部分，为分布式系统外部化配置提供了支持。 由于Config Server和Config Client都实现了对Spring Environment和PropertySource抽象的映射，因此SpringCloud Config非常适合Spring应用程序，当然也可与其他语言应用程序配合使用。&lt;/p&gt;
&lt;p&gt; 　　Config Server是一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置（开发，测试，生产，灰度），默认使用Git存储配置内容(也可使用Subversion、本地文件系统或Vault存储配置),因此可以方便的实现对配置的版本控制与内容审计。 Config Client 是Config Server的客户端，用于操作存储在Config Server中的配置属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpringCloud Config带来的便利&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、集中管理配置，通过Config来对集群中所有组件服务的配置信息进行集中管理；&lt;/p&gt;
&lt;p&gt;2、争对不同的环境进行不同的配置（开发，联调，测试，灰度，生产）；&lt;/p&gt;
&lt;p&gt;3、运行期间可动态调整，根据服务器的负载情况动态的设置连接池信息或者熔断阈值；&lt;/p&gt;
&lt;p&gt;4、配置修改后，不需要关闭服务可自动更新配置；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpringCloud Config入门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、申请一个自己的git仓库，将测试项目得yml或properties文件上传至Git目录；&lt;/p&gt;
&lt;p&gt;2、构建Config Service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&amp;lt;!-- &lt;span&gt;1&lt;/span&gt;、引入Jar包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- &lt;span&gt;2&lt;/span&gt;、配置属性信息 --&amp;gt;&lt;span&gt;
server:
  port: &lt;/span&gt;&lt;span&gt;9005&lt;/span&gt;&lt;span&gt;
spring:
  application:
    name: ms&lt;/span&gt;-cfg-&lt;span&gt;service
  cloud:
    config:
      server:
        git:
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/******/springcloudconfig.git&lt;/span&gt;
          username: ******&lt;span&gt;
          password: &lt;/span&gt;******&lt;p&gt;&amp;lt;!-- 3、加注解@EnableConfigServer --&amp;gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;7&quot;&gt;
@SpringBootApplication&lt;br/&gt;@EnableConfigServer&lt;br/&gt;public class ConfigServiceApplication {&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;SpringApplication.run(ConfigServiceApplication.class, args);&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;备注：配置文件有三种访问方式，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）通过application-{profiles}.yml来访问，eg：http://localhost:8080/application-dev.yml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）通过/application/{profiles}/{lable}来访问， eg：http://localhost:8080/application/dev/master&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）通过/{lable}/application-{profiles}.yml来访问，eg：http://localhost:8080/master/application-dev.yml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、构建Config Client&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1. 引入Jar包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2. 创建配置文件bootstrap.yml --&amp;gt;&lt;span&gt;
spring:
  application:
    name: application
  cloud:
    config:
      uri: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/&lt;/span&gt;
&lt;span&gt;      profile: dev  
      label: master    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;备注： spring.application.name 对应访问规则中的{application}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　 spring.cloud.config.profile 对应访问规则中的{profiles}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　 spring.cloud.config.label 对应访问规则中的{lable}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpringCloud config的常规用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们定义一个openTest开关，来控制业务逻辑代码走新的逻辑分支还是走老的业务逻辑分支&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1、在属性文件中定义一个变量 --&amp;gt;&lt;span&gt;
ycdhz.openTest&lt;/span&gt;=&lt;span&gt;dev

&lt;/span&gt;&amp;lt;!-- 2、在代码中通过@Value注解引用 --&amp;gt;&lt;span&gt;
@Value(&lt;/span&gt;&quot;${ycdhz.openTest}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String openTest;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findInfo(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(openTest.equal(&quot;dev&quot;&lt;span&gt;)){
        System.out.print(&lt;/span&gt;&quot;开发环境&quot;&lt;span&gt;)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (openTest.equal(&quot;test&quot;&lt;span&gt;)){
        System.out.print(&lt;/span&gt;&quot;测试环境&quot;&lt;span&gt;)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        System.out.print(&lt;/span&gt;&quot;生产环境&quot;&lt;span&gt;)
    }
}

&lt;/span&gt;&amp;lt;!-- 3、修改属性文件，重启生效--&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1、再Client端工程，引入jar包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;    

&amp;lt;!-- 2、再Client端工程，开启refresh的监控端点 --&amp;gt;&lt;span&gt;
management:
  endpoints:
    web:
      exposure:
        include: &lt;/span&gt;&quot;*&quot;&lt;span&gt;   开启所有的端点

&lt;/span&gt;&amp;lt;!-- 3、在读取配置文件中的类上加入@RefreshScope --&amp;gt;&lt;span&gt;    
@RestController
@RequestMapping(&lt;/span&gt;&quot;/order&quot;&lt;span&gt;)
@RefreshScope
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Value(&lt;/span&gt;&quot;${openTest}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String openTest;
}

&lt;/span&gt;&amp;lt;!-- 4、在git上修改openTest的配置文件 --&amp;gt;&lt;span&gt;    
通过Post请求，执行http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8001/actuator/refresh刷新接口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：不在需要重启，只需要通过Post执行刷新方法即可。但是当需要在集群中大面积修改的情况下依旧很繁琐，需要对每一个服务进行刷新。&lt;/p&gt;
&lt;p&gt;方法三：&lt;/p&gt;
&lt;p&gt;配置Config Client&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1、在client端工程，引入jar包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2、在client端工程，配置属性 --&amp;gt;&lt;span&gt;
spring:
  application:
    name: application
  cloud:
    config:
      uri: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9000/&lt;/span&gt;
&lt;span&gt;      label: master
  rabbitmq:
    host: &lt;/span&gt;****IP地址****&lt;span&gt;
    port: &lt;/span&gt;****端口号****&lt;span&gt;
    virtual&lt;/span&gt;-host: ****host名****&lt;span&gt;
    username: root
    password: root
    connection&lt;/span&gt;-timeout: 10000&lt;span&gt;
    template:
      mandatory: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
management:
  endpoints:
    web:
      exposure:
        include: &lt;/span&gt;&quot;*&quot;&lt;span&gt;
  server:
    port: &lt;/span&gt;8080
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置 config Service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1、在Service端工程，引入jar包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2、在Service端工程，配置属性 --&amp;gt;&lt;span&gt;
server:
  port: &lt;/span&gt;9000&lt;span&gt;
spring:
  application:
    name: ms&lt;/span&gt;-cfg-&lt;span&gt;service
  cloud:
    config:
      server:
        git:
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/******/springcloudconfig.git&lt;/span&gt;
          username: ******&lt;span&gt;
          password: &lt;/span&gt;******&lt;span&gt;
  rabbitmq:
    host: &lt;/span&gt;****IP地址****&lt;span&gt;
    port: &lt;/span&gt;****端口号****&lt;span&gt;
    virtual&lt;/span&gt;-host: ****host名****&lt;span&gt;
    username: root
    password: root
    connection&lt;/span&gt;-timeout: 10000&lt;span&gt;
    template:
      mandatory: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
      
&amp;lt;!-- 3、在Git上更新配置信息，访问bus-refresh刷新服务配置 --&amp;gt;&lt;span&gt;
访问监控端点http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9000/actuator/bus-refresh刷新所有服务的配置信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：使用消息总线bus来实现，不再需要去争对一个个服务组件做刷新。原理如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202004/403345-20200419004014421-2147164429.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 Apr 2020 16:44:00 +0000</pubDate>
<dc:creator>愚蠢的猴子</dc:creator>
<og:description>SpringCloud Config 简介 在分布式系统中，由于服务组件过多，为了方便争对不通的环境下的服务配置文件统一管理，实时更新，所以出现了分布式配置中心组件。市面上开源的配置中心有很多，360</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiangyaxiong1990/p/12725806.html</dc:identifier>
</item>
<item>
<title>Cilium架构 (Cilium 2) - charlieroro</title>
<link>http://www.cnblogs.com/charlieroro/p/12728891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlieroro/p/12728891.html</guid>
<description>&lt;h2 id=&quot;cilium架构&quot;&gt;Cilium架构&lt;/h2&gt;
&lt;p&gt;译自：&lt;a href=&quot;http://docs.cilium.io/en/stable/architecture/&quot;&gt;http://docs.cilium.io/en/stable/architecture/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文档描述了Cilium的架构。它通过记录BPF数据路径(datapath)的钩子来实现Cilium数据路径，那么Cilium数据路径是如何与容器编排层继承，以及如何在各层(如BPF数据路径和Cilium代理)之间更新对象的？&lt;/p&gt;
&lt;h3 id=&quot;数据路径&quot;&gt;数据路径&lt;/h3&gt;
&lt;p&gt;Linux内核在网络栈中支持一个BPF钩子集，使用这些勾子可以允许BPF程序(&lt;em&gt;即使用回调函数运行&lt;/em&gt;)。Cilium数据路径使用这些钩子加载BPF程序，当一起使用时，这些程序会创建更高级别的网络结构。&lt;/p&gt;
&lt;p&gt;下面是Cilium使用的钩子列表以及简要概述。更详细的介绍可以参见&lt;a href=&quot;http://docs.cilium.io/en/stable/bpf/#bpf-guide&quot;&gt;BPF and XDP Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;XDP：XDP BPF钩子最早可以在网络驱动中使用，在报文接收时触发BPF程序。由于BPF程序能够(在进行其他处理前)直接作用于报文数据，因此能够获取最好的报文处理性能。该钩子可用于过滤程序丢弃恶意的或非期望的流量，以及其他常见的DDOS防护机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;Ingress/Egress流控：与XDP相同，附加到tc(traffic control) ingress钩子的BPF程序会附加到网络接口上，但是在网络栈完成初始的报文处理之后运行。该钩子在协议栈的L3层之前运行，但可以访问与报文相关的大多数元数据，适用于本地节点的处理，如配置L3/L4 endpoint策略以及限制达到endpoints的流量。对于面向设备的网络，tc ingress钩子可以与上面的XDP钩子耦合。完成该操作后，可以合理地假设此时的大多数流量是合法的，并且目的地是主机。&lt;/p&gt;
&lt;p&gt;容器通常会使用一个虚拟设备，称为veth对，可以看作是连接容器和主机的虚拟线路。通过连接到这对veth的主机侧的TC ingress钩子，Cilium可以监控和对一个容器中存在的所有流量强制执行制订的策略&lt;em&gt;(在主机侧监控和限制本机的容器的流量&lt;/em&gt;)。通过将一个BPF程序附加到与每个容器关联的veth对上，然后使用另外一个附加到tc ingress钩子上的BPF程序将所有网络流量路由到主机侧的虚拟设备上，这样Cilium也可以监控和对到达本节点或节点中存在的流量强制执行制订的策略(在容器侧监控和限制本机的流量)。&lt;/p&gt;
&lt;p&gt;根据场景的需要，容器也可能使用ipvlan设备进行连接。这种模式下，主机的物理设备作为ipvlan的master，容器中的虚拟ipvlan设备被设置为slave模式。使用ipvlan而不是veth对的好处是可以减少网络栈将报文推送到位于另一个网络命名空间中的ipvlan slave所需要的资源，因此可以获得更好的延迟结果。为了使用Cilium配置L3/L4 endpoint策略，需要将用于tc的BPF程序附加到容器网络命名空间中的ipvlan slave设备的tc egress钩子上。例如，与在ipvlan master的tc ingress钩子上运行的另一个BPF程序相结合，这样也可以限制节点上的传入流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;socket操作：socket操作钩子附加到一个特定的cgroup上，根据TCP时间运行。Cilium将BPF socket操作程序附加到根cgroup上，并使用该程序监控TCP状态变更，特别是对ESTABLISHED 状态变更。当一个socket转换为ESTABLISHED 状态，如果TCP socket的对端位于本地节点上(可能是本地代理)，则会附加socket 发送/接受程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;socket 发送/接收：当一个TCP socket执行发送操作时会运行socket 发送/接受钩子。此时，钩子或检查消息，最终会丢弃该消息，会将该消息发送到TCP层，会直接将该消息重定向到另外一个socket。如下所述，Cilium使用它来加速数据路径的重定向。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上述钩子与虚拟接口(cilium_host, cilium_net)，可选的overlay接口(cilium_vxlan)，Linux内核加密支持以及用户空间代理(Envoy)相结合，Cilium可以创建如下网络对象。&lt;/p&gt;
&lt;ul readability=&quot;14&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;预过滤(prefilter)：预过滤对象会运行一个XDP程序，并提供一组预过滤规则来过滤网络上的流量来达到更好的性能。特别使用一组Cilium agent提供的CIDR映射来查找报文，如在目的地不是一个有效的endpoint时丢弃报文，或允许网络栈处理该报文。可以很容易通过扩展来构建一个新的预过滤标准/能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;endpoint策略：endpoint策略对象实现了Cilium endpoint的执行方式。它使用一个映射来查找与身份相关的报文，且该层(layer)可以很好地扩展到多个endpoint。取决于本层的策略，可能会丢弃报文，转发到本地的endpoint或服务对象，或转发到L7策略对象，用于后续L7规则。它是Cilium数据路径中负责报文和身份映射以及执行L3和L4策略的主要对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;服务(service)：服务对象会根据该对象接收到的每个报文的目的IP(可能包含目的端口)来进行映射查找。如果找到一个匹配的表项，则将该报文转发到一个配置到的L3/L4 endpoint上。服务块可以使用TC ingress钩子在任何接口上实现一个独立的负载均衡，或集成到endpoint策略对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;L3加密：在ingress上，可以使用L3加密对象标识需要解密的报文，然后将报文传递到Linux xfrm(转换)层进行解密，在解密报文后，该对象会接受报文，然后将报文传递到网络栈，后续给其他对象进行处理。根据网络的模式(直接路由或overlay)，可能是BPF尾部调用或将数据包传递到下一个对象的Linux路由栈。解密需要的密钥编码在IPsec首部，这样我们不需要在ingress上使用映射查找来定位解密密钥。&lt;/p&gt;
&lt;p&gt;在egress上，会首先对目的地址执行映射查找来缺点该报文是否被加密，如果被加密，则找出目的节点上可用的密钥。在选出的节点上挑选最近使用的可用的密钥，并将报文标记为加密。然后改报文会传递到Linux xfrm层执行加密。当接收到现在加密的报文时，它被传递到下一层，或通过发送到Linux 栈进行路由，或(如果正在使用overlay)直接执行尾部调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;socket层强制(Enforcement)：socket层强制会使用两个钩子，socket 操作钩子和socket 发送/接收钩子来监控并附加到所有与Cilium管理的endpoint相关的TCP socket，包括L7代理。socket操作钩子会识别要加速的候选套接字，这些候选套接字包括所有的本地节点连接(endpoint到endpoint)以及所有到Cilium代理的连接。这些标识的连接将会包含所有由socket 发送/接收钩子处理的消息，并且使用sockmap快速重定向进行加速。快速重定向保证Cilium中实现的所有策略对于关联的socket/endpoint映射均有效，并假设它们会直接向对端socket发送消息。sockmap send/recv钩子确保消息不会被上面提到的任何对象处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;L7策略：L7策略对象将代理的流量重定向到一个Cilium用户空间代理实例中。Cilium使用一个Envoy作为它的用户空间代理。Envoy要么转发流量，要么会根据配置的L7策略生成拒绝消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cilium通过连接这些组件实现了灵活高效的数据路径。下面将展示连接单个节点上的endpoint可能存在的数据流(进入一个endpoint以及endpoint到网络设备)。在每种情况下，都会通过一个额外的图显示启用socket层强制时的可用的TCP加速路径。&lt;/p&gt;
&lt;h3 id=&quot;endpoint到endpoint&quot;&gt;Endpoint到Endpoint&lt;/h3&gt;
&lt;p&gt;首先展示的是本地endpoint到endpoint的数据流，在engress和ingress上使用了L7策略。紧跟着展示了启用socket层强制下相同endpoint到endpoint的数据流走向。通过对TCP流量启用socket层强制，发起连接的握手将遍历endpoint策略对象，直到TCP的状态变为ESTABLISHED。最后只有L7策略对象允许之后，连接状态才能变为ESTABLISHED。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.cilium.io/en/stable/_images/cilium_bpf_endpoint.svg&quot; alt=&quot;../_images/cilium_bpf_endpoint.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;从endpoint出站egress-from-endpoint&quot;&gt;从Endpoint出站(Egress from Endpoint)&lt;/h3&gt;
&lt;p&gt;下面展示了本地endpoint使用overlay网络进行出站的场景。overlay网络流量通过与overlay对应的Linux网络接口进行转发。默认的overlay接口称为cilium_vxlan。与上面类似，通过启用socket层强制并使用L7代理可以避免在TCP通信的endpoint和L7策略之间运行endpoint策略块。L3加密块可以在启用时加密报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.cilium.io/en/stable/_images/cilium_bpf_egress.svg&quot; alt=&quot;../_images/cilium_bpf_egress.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;入站到endpointingress-to-endpoin&quot;&gt;入站到Endpoint(Ingress to Endpoin)&lt;/h3&gt;
&lt;p&gt;最后展示了使用overlay网络时入站到endpoint的场景。与上面类似，通过启用socket层强制可以避免在代理和endpoint socket之间遍历策略集。如果接收到的报文被加密，则首先需要进行解密，并使用正常流程处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.cilium.io/en/stable/_images/cilium_bpf_ingress.svg&quot; alt=&quot;../_images/cilium_bpf_ingress.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于veth的数据路径和基于ipvlan的数据路径的对比&quot;&gt;基于veth的数据路径和基于ipvlan的数据路径的对比&lt;/h3&gt;
&lt;p&gt;|基于ipvlan的数据路径目前仅在技术预览中，用于实验目的。该限制会在后续的Cilium发布中移除。&lt;/p&gt;
&lt;p&gt;默认的Cilium CNI运行在基于veth的数据路径模式下，由于所有的BPF程序都由Cilium在主机网络命名空间之外进行管理，因此使用该模式可以获得更大的灵活性，这样容器就可以被授予其命名空间（如CAP_NET_ADMIN）的特权，而不会影响安全性(因为容器无法访问主机中的BPF强制点)。鉴于BPF程序是从主机的网络名称空间附加的，BPF也能够接管并有效地管理本地容器到主机之间的转发逻辑。但由于veth模式下，网络栈内部在处理从一个veth设备到位于另一个网络命名空间中的对端设备时需要重新遍历网络栈，因此会造成延迟。当在本地Cilium endpoint间进行通信时，这种出站到入站的转变需要执行两次，对于正在到达或从主机发送出去的数据包，则为一次。&lt;/p&gt;
&lt;p&gt;对于更具延迟优化的数据路径，Cilium CNI还支持ipvlan L3/L3S模式，但存在大量限制。为了支持老的且不存在ipvlan发夹模式的内核，Cilium会在tc egress层将BPF程序附加到位于容器的网络命名空间内的slave设备上，意味着这种数据路径模式只能用于使用非CAP_NET_ADMIN 和CAP_NET_RAW特权运行的容器。ipvlan使用内部转发逻辑直接进行slave-to-slave或slave-to-master的重定向，因此BPF程序本身不会执行到设备的转发。由于网络栈不需要像基于veth的数据路径一样在处理外部报文时重新遍历，因此能够更有效地切换命名空间。主机到容器网络命名空间的切换直接发生在L3层，在后续的ingress处理中无需排队和重新调度。在本地endpoint之间通信的情况下，会执行一次egress-to-ingress的且华北，而不必执行两次。&lt;/p&gt;
&lt;p&gt;目前的实现中，Cilium的ipvlan模式还有很多限制需要在接下来的工作中解决：目前还无法启用NAT64以及通过代理启用L7策略强制。当前未启用到本地endpoint的服务负载平衡以及容器到主机的本地通信。如果需要使用这些功能，仅以使用基于veth的数据路径模式。&lt;/p&gt;
&lt;p&gt;Cilium的CNI ipvlan模式运行在Cilium daemon中，例如&lt;code&gt;--datapath-mode=ipvlan --ipvlan-master-device=bond0&lt;/code&gt;，后者通常指定了物理网络设备，同时也作为ipvlan的master设备。注意在ipvlan 数据路径模式在kubernetes中部署在L3S模式下。确保有一个稳定运行内核，包括以下ipvlan修复：&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?id=d5256083f62e2720f75bb3c5a928a0afe47d6bc3&quot;&gt;d5256083f62e&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;更多BPF的特性参见 &lt;a href=&quot;http://docs.cilium.io/en/stable/bpf/#bpf-guide&quot;&gt;BPF and XDP Reference Guide&lt;/a&gt;，可以在 &lt;a href=&quot;http://docs.cilium.io/en/stable/envoy/#envoy&quot;&gt;Envoy&lt;/a&gt; 章节了解如何扩展L7策略。&lt;/p&gt;
&lt;h3 id=&quot;bpf-映射的限制&quot;&gt;BPF 映射的限制&lt;/h3&gt;
&lt;p&gt;所有创建的BPF映射都有上限限制。超出限制的插入将会失败，从而限制了数据路径的可伸缩性。下表展示了映射的默认值。每个限制都可以在源代码中进行修改，如果需要，可以根据请求添加配置选项。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Map Name&lt;/th&gt;
&lt;th&gt;Scope&lt;/th&gt;
&lt;th&gt;Default Limit&lt;/th&gt;
&lt;th&gt;Scale Implications&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Connection Tracking&lt;/td&gt;
&lt;td&gt;node or endpoint&lt;/td&gt;
&lt;td&gt;1M TCP/256K UDP&lt;/td&gt;
&lt;td&gt;Max 1M concurrent TCP connections, max 256K expected UDP answers&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Endpoints&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;64k&lt;/td&gt;
&lt;td&gt;Max 64k local endpoints + host IPs per node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;IP cache&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;512K&lt;/td&gt;
&lt;td&gt;Max 256K endpoints (IPv4+IPv6), max 512k endpoints (IPv4 or IPv6) across all clusters&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Load Balancer&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;64k&lt;/td&gt;
&lt;td&gt;Max 64k cumulative backends across all services across all clusters&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Policy&lt;/td&gt;
&lt;td&gt;endpoint&lt;/td&gt;
&lt;td&gt;16k&lt;/td&gt;
&lt;td&gt;Max 16k allowed identity + port + protocol pairs for specific endpoint&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Proxy Map&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;512k&lt;/td&gt;
&lt;td&gt;Max 512k concurrent redirected TCP connections to proxy&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Tunnel&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;64k&lt;/td&gt;
&lt;td&gt;Max 32k nodes (IPv4+IPv6) or 64k nodes (IPv4 or IPv6) across all clusters&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;kubernetes集成&quot;&gt;kubernetes集成&lt;/h3&gt;
&lt;p&gt;下图显示了kube-proxy安装的iptables规则和Cilium安装的iptables规则的集成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.cilium.io/en/stable/_images/kubernetes_iptables.svg&quot; alt=&quot;../_images/kubernetes_iptables.svg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Apr 2020 16:20:00 +0000</pubDate>
<dc:creator>charlieroro</dc:creator>
<og:description>Cilium架构 译自：http://docs.cilium.io/en/stable/architecture/ 本文档描述了Cilium的架构。它通过记录BPF数据路径(datapath)的钩子来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlieroro/p/12728891.html</dc:identifier>
</item>
<item>
<title>0基础算法基础学算法 第六弹 递归 - 球君</title>
<link>http://www.cnblogs.com/qj-Network-Box/p/12729230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qj-Network-Box/p/12729230.html</guid>
<description>&lt;p&gt;　　最近呢也是有很久没有更新博客了，主要是因为平时比较忙，毕竟等疫情彻底解封qj我也要小升初考试了，所以打算赶在今天更新点干货。&lt;/p&gt;
&lt;p&gt;　　在各大oi赛事上，递归和递推算是个基础而重要的算法，递归在熟练运用后可以实现dfs，dfs是深度优先搜索，以后会讲到关于dfs的；而递推是一种用若干步可重复运算来描述复杂问题的方法，比如斐波那契数列，上楼梯等都是可以通过递推来进行实现的，而下一讲即将会具体讲述递推，今天的主题是递归 &lt;/p&gt;
&lt;p&gt;现在切入正题&lt;/p&gt;
&lt;p&gt;一.递归&lt;/p&gt;
&lt;p&gt;　　递归函数其实在比赛中特别常见，很多人在比赛的时候遇到不会的题就直接打暴力，但是如果你会递归的话，你可以用一通pmn或者dfs直接爆搜（据有关人士称，去年提高组如果pmn可以的200+。。。）那到底什么是递归呢？递归函数，即是自己调用自己，理解递归最好是通过一个例子来理解，比如，超经典的基础题，1+2+3+4+...+n-2+n-1+n=？遇到这个题，一般做法是利用for循环一个一个的累加，提供一个c++代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;万能头文件，建议比赛时使用&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s,i,n;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    S&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　cin&amp;gt;&amp;gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;n&lt;/span&gt;;i++&lt;span&gt;)
        s&lt;/span&gt;=s+&lt;span&gt;i;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是最简单也最直观的代码，如果使用递归实现虽然会看起来麻烦一点，但对递归的理解有好处。算法的流程图大概是是这样的&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202004/1965215-20200418224527291-1783011879.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;314&quot;/&gt;过程有点类似于倒着的for法，结合代码我们一起看看，运行结果是一样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dg(&lt;span&gt;int&lt;/span&gt; n) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归函数，n定义的是局部变量不冲突 &lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n==&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (dg(n-&lt;span&gt;1&lt;/span&gt;)+n);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行递归 &lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;dg(n); 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202004/1965215-20200418225425672-241892358.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概就是这样子的，递归的一个基本的主体框架有两个部分，一个是反复递归的过程，还有就是中止条件，不然你的程序停不下来可很悲催的一件事，相信我，程序死活不输出你也找不到问题所在，只能浏览程序了，到了后期，这些细节要越发的注意，因为现在我写代码都动不动65+行，比如高精度就要占你数十行；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dg(&lt;span&gt;int&lt;/span&gt; n) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归函数，n定义的是局部变量不冲突 &lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(终止条件) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 中止的返回值;
    dg(n&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行递归 (举例)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归的形式需要根据需要而调整，比如有时候你也许会是是dg(n+1)+n; &lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    dg(n); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用递归函数 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归的基本模板👆；&lt;/p&gt;
&lt;p&gt;重点是自己调用自己这一块比较难理解，可以自己试图去尝试写一些递归程序&lt;/p&gt;
&lt;p&gt;这里再和大家分享一道经典的题：&lt;/p&gt;
&lt;p&gt;　　设有n个数已经按从大到小的顺序排列，现在输入x，判断它是否在这n个数中，如果存在则输出yes，否则输出 no；                                           &lt;/p&gt;
&lt;p&gt;　　拿到题目先分析（这里节省点位置，流程图留给你们自己去画吧🙂），这是一道比较简单的数据查找的问题，一般使用顺序查找，使用for循环，这个for循环也可以“递归化”；分别展示一下for做法和递归做法（其实还有一个做法会在未来讲二分查找的时候讲）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;万能头可以省好多事 &lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于录入10个数 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++) cin&amp;gt;&amp;gt;&lt;span&gt;a[i];
    sort(a,a&lt;/span&gt;+&lt;span&gt;10&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;快速排序函数库，加了万能头就不用加它的头文件了&lt;/span&gt;
    cin&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;) 
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[i]=&lt;span&gt;n)
        {
            cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
        }
    }
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;万能头可以省好多事 &lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于录入10个数&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; b=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n==&lt;span&gt;a[k])
    {
        b&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到了，标记一下，直接跳出，不需要再找了 &lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(k&amp;lt;&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全部找完都没找到，也不用找了 &lt;/span&gt;
    fun(n,k-&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用部分 &lt;/span&gt;
&lt;span&gt; } 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++) cin&amp;gt;&amp;gt;&lt;span&gt;a[i];
    sort(a,a&lt;/span&gt;+&lt;span&gt;10&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;快速排序函数库，加了万能头就不用加它的头文件了&lt;/span&gt;
    cin&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k=&lt;span&gt;9&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标从0开始 &lt;/span&gt;
&lt;span&gt;    fun(n,k);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b) cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释 上：for遍历法 递归遍历法 敬请期待二分查找（还不快关注。。。）&lt;/p&gt;
&lt;p&gt;上面的做法都是可行的，运行结果一切正常&lt;img src=&quot;https://img2020.cnblogs.com/blog/1965215/202004/1965215-20200418234736650-1736752084.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;231&quot;/&gt;。&lt;/p&gt;
&lt;p&gt; 博客留题！：&lt;/p&gt;
&lt;p&gt;　　洛谷递归题单 https://www.luogu.com.cn/training/109#problems&lt;/p&gt;
&lt;p&gt;　　酌量练习，把握分度，不然会沉迷于洛谷这个花花绿绿的游戏网站 （划去）&lt;/p&gt;
&lt;p&gt;　　今天的内容就是这些了，下次会讲递推，还会分享一些资料，假如你有兴趣，先点赞👍，关注➕走一波，关注后欢迎白嫖😀；&lt;/p&gt;
</description>
<pubDate>Sat, 18 Apr 2020 15:55:00 +0000</pubDate>
<dc:creator>球君</dc:creator>
<og:description>最近呢也是有很久没有更新博客了，主要是因为平时比较忙，毕竟等疫情彻底解封qj我也要小升初考试了，所以打算赶在今天更新点干货。 在各大oi赛事上，递归和递推算是个基础而重要的算法，递归在熟练运用后可以实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qj-Network-Box/p/12729230.html</dc:identifier>
</item>
<item>
<title>超详细-七种常见结构型模式的描述总结与代码分析 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12729129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12729129.html</guid>
<description>&lt;p&gt;&lt;strong&gt;结构型模式（Structural Pattern）&lt;/strong&gt;用于将类或对象结合在一起形成更强大的结构，就像搭积木，可以通过简单的积木组合出复杂、功能强大的模型。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;结构型模式&lt;/th&gt;
&lt;th&gt;重要程度&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;适配器模式(Adapter)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;桥接模式(Bridge)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;组合模式(Composite)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;装饰者模式(Decorator)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;外观模式(Facade)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;享元模式(Flyweight)&lt;/td&gt;
&lt;td&gt;⭐&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理模式(Proxy)&lt;/td&gt;
&lt;td&gt;⭐⭐⭐⭐&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;生活中，充电插头有两脚的、三脚的，还有圆形的，如果想使这些插头都能工作，就需要一个多功能适配器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200327171032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;适配器模式（Adapter Pattern）属于&lt;strong&gt;结构性模式&lt;/strong&gt;，它可以将某个类的接口转换为客户端期望的另一个接口表示，主要目的是&lt;strong&gt;兼容性&lt;/strong&gt;，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为&lt;strong&gt;包装器&lt;/strong&gt;（Wrapper）。适配器模式主要分为三类：&lt;strong&gt;类适配器模式&lt;/strong&gt;、&lt;strong&gt;对象适配器模式&lt;/strong&gt;、&lt;strong&gt;接口适配器模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200327172553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;让原本接口不兼容的类可以兼容&lt;/li&gt;
&lt;li&gt;从用户的角度看不到被适配者，是解耦的&lt;/li&gt;
&lt;li&gt;用户调用适配器转化出来的目标接口方法，适配器去再调用被适配者的相关接口方法&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;类适配器模式&quot;&gt;类适配器模式&lt;/h2&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;Adapter 类继承 src 类，实现 dst 接口，完成 src 对 dst 的适配。&lt;/p&gt;
&lt;h3 id=&quot;案例&quot;&gt;案例&lt;/h3&gt;
&lt;p&gt;插座（Voltage220V）的输出电压是220V，充电插头（Voltage5V）输出电压是5V，这时候就需要一个适配器（VoltageAdapter）转换电压，才能给手机（Phone）充电&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;电源输出电压为220V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Voltage220V {
    public int output220V() {
        int src = 220;
        System.out.println(&quot;电源输出&quot; + src + &quot;V&quot;);
        return src;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;充电器输出电压为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Voltage5V {
    int output5V();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;适配器需要将220V转为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VoltageAdapter extends Voltage220V implements Voltage5V {
    @Override
    public int output5V() {
        int src = super.output220V();
        int dst = src / 44;
        System.out.println(&quot;转换为&quot; + dst + &quot;V&quot;);
        return dst;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机接收5V电压，判断电压是否为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Phone {
    public static void charging(Voltage5V voltage5V){
        int v = voltage5V.output5V();
        if(v == 5){
            System.out.println(&quot;接收电压为5V，正常充电&quot;);
        }else if(v &amp;gt; 5){
            System.out.println(&quot;电压高于5V，无法充电&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test01(){
    System.out.println(&quot;====类适配器模式====&quot;);
    Phone.charging(new VoltageAdapter());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;====类适配器模式====
电源输出220V
转换为5V
接收电压为5V，正常充电
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;由于 Java 是单继承机制，所以类适配器模式有一定的&lt;strong&gt;局限性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;src 类的方法再 Adapter 中都会暴露出来，&lt;strong&gt;增加了使用的成本&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于继承了 src 类，所以它可以重写父类方法，使 Adapter 的&lt;strong&gt;灵活性增强了&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;对象适配器模式&quot;&gt;对象适配器模式&lt;/h2&gt;
&lt;h3 id=&quot;实现原理-2&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;基本的思路和类的适配器模式相同，只是将 Adapter 类做修改，&lt;strong&gt;使用聚合关系替代继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;沿用前面的代码，新建一个适配器，只是将原来的 Adapter 继承 src 类换为聚合的关系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VoltageAdapter2 implements Voltage5V {

    private Voltage220V voltage220V;

    public VoltageAdapter2(){
        this.voltage220V = new Voltage220V();
    }

    @Override
    public int output5V() {
        int src = this.voltage220V.output220V();
        int dst = src / 44;
        return dst;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test02(){
    System.out.println(&quot;====对象适配器模式====&quot;);
    Phone.charging(new VoltageAdapter2(new Voltage220V()));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;====对象适配器模式====
电源输出220V
转换为5V
接收电压为5V，正常充电
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口适配器模式&quot;&gt;接口适配器模式&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;接口适配器模式也可称为&lt;strong&gt;缺省适配器模式&lt;/strong&gt;，当不需要实现接口的全部方法时，可先设计一个抽象类实现接口，并为该接口的每个方法都提供一个&lt;strong&gt;默认实现&lt;/strong&gt;，那么该抽象类的子类就可以&lt;strong&gt;有选择的&lt;/strong&gt;覆盖父类的某些方法来实现需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;适用于一个接口不想使用其所有的方法的情况&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现-3&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;写一个接口，里面定义一些方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface InterfaceMethod {
    void m1();
    void m2();
    void m3();
    void m4();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个抽象类，实现该接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractAdapter implements InterfaceMethod {
    @Override
    public void m1() {
    }

    @Override
    public void m2() {
    }

    @Override
    public void m3() {
    }

    @Override
    public void m4() {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test(){
    //使用匿名内部类的方式
    AbstractAdapter adapter = new AbstractAdapter() {
        @Override
        public void m1() {
            System.out.println(&quot;我要用m1方法&quot;);
        }
    };
    adapter.m1();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我要用m1方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三种适配器模式总结&quot;&gt;三种适配器模式总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;三种命名方式是根据 src 是以怎样的形式给到 Adapter (在Adapter里的形式)来命名的。
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类适配器：以类给到，在 Adapter 里，就是将 src 当做类，&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象适配器：以对象给到，在 Adapter 里， 将 src 作为一个对象，&lt;strong&gt;持有&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本介绍-2&quot;&gt;基本介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;桥接模式是一种&lt;strong&gt;结构型&lt;/strong&gt;设计模式。&lt;/li&gt;
&lt;li&gt;将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。&lt;/li&gt;
&lt;li&gt;基于&lt;strong&gt;类的最小设计原则&lt;/strong&gt;，通过封装、聚合、继承等行为让不同的类承担不同的职责。&lt;/li&gt;
&lt;li&gt;它的主要特点是&lt;strong&gt;把抽象与行为实现分离&lt;/strong&gt;，从而可以保持各部分的独立性以及应对它们的功能扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;模式结构&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;桥接模式包含如下角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Abstraction：抽象类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RefinedAbstraction：扩充抽象类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implementor：实现类接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteImplementor：具体实现类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200331111609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单案例&quot;&gt;简单案例&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们以手机为例，手机有品牌（诺基亚、摩托罗拉）和样式（折叠式、直立式），我们需要生产不同的品牌和样式，比如折叠式诺基亚、直立式摩托罗拉... ...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;「实现类接口」&lt;/strong&gt; - 手机品牌，都有开机和关机的功能&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface PhoneBrand {
    void open();
    void close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「具体实现类」&lt;/strong&gt; - 手机品牌 Nokia 和 Moto&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Nokia implements PhoneBrand {
    @Override
    public void open() {
        System.out.println(&quot;诺基亚开机...&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;诺基亚关机...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class Moto implements PhoneBrand {
    @Override
    public void open() {
        System.out.println(&quot;摩托罗拉开机...&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;摩托罗拉关机...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「抽象类」&lt;/strong&gt; - 手机类，以&lt;strong&gt;聚合&lt;/strong&gt;的方式与品牌产生联系，充当着&lt;strong&gt;“桥”&lt;/strong&gt;的角色&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbsPhone{

    private PhoneBrand brand;

    public AbsPhone(PhoneBrand brand) {
        this.brand = brand;
    }

    protected void open(){
        brand.open();
    }

    protected void close(){
        brand.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「扩充抽象类」&lt;/strong&gt; - 折叠式手机 和 直立式手机&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FoldingPhone extends AbsPhone{

    public FoldingPhone(PhoneBrand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        System.out.print(&quot;折叠式 - &quot;);
        super.open();
    }

    @Override
    protected void close() {
        System.out.print(&quot;折叠式 - &quot;);
        super.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UpRightPhone extends AbsPhone{

    public UpRightPhone(PhoneBrand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        System.out.print(&quot;直立式 - &quot;);
        super.open();
    }

    @Override
    protected void close() {
        System.out.print(&quot;直立式 - &quot;);
        super.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test(){
    AbsPhone p1 = new FoldingPhone(new Nokia());
    p1.open();
    p1.close();
    System.out.println();
    AbsPhone p2 = new UpRightPhone(new Moto());
    p2.open();
    p2.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;折叠式 - 诺基亚开机...
折叠式 - 诺基亚关机...

直立式 - 摩托罗拉开机...
直立式 - 摩托罗拉关机...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想创建其他类型的手机，只需要改变创建方式即可。&lt;/p&gt;
&lt;h2 id=&quot;模式分析&quot;&gt;模式分析&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，这有助于系统进行分层设计，从而产生更好的结构化系统。&lt;/li&gt;
&lt;li&gt;对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。&lt;/li&gt;
&lt;li&gt;桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。&lt;/li&gt;
&lt;li&gt;桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。&lt;/li&gt;
&lt;li&gt;桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;桥接模式在-jdbc-中的应用&quot;&gt;桥接模式在 JDBC 中的应用&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在 Java 中我们通常使用 JDBC 连接数据库，但是数据库的种类有很多（MySQL、Oracle...），它们的连接方式、协议都不尽相同，很显然不能为每种数据库都写一个接口，这样就违背了精简设计原则，于是Java设计师就提供一套接口给厂商们自己实现，一套接口给用户调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在使用 JDBC 的时候需要写这样的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class.forName(&quot;数据库驱动名&quot;);
Connection conn = DriverManager.getConnection(&quot;数据库url&quot;, &quot;用户名&quot;, &quot;密码&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其过程是这样的：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;Class.forName()&lt;/code&gt; 的时候，通过反射机制，将 &lt;code&gt;.class&lt;/code&gt; 文件加载进Java虚拟机内存中，&lt;code&gt;Driver&lt;/code&gt; 类初始化，执行以下代码，向 &lt;code&gt;DriverManager&lt;/code&gt; 中注册一个驱动。&lt;code&gt;DriverManager&lt;/code&gt;是个 &lt;code&gt;Driver&lt;/code&gt; 容器，管理不同的 &lt;code&gt;Driver&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static {
    try {
        DriverManager.registerDriver(new Driver());
    } catch (SQLException var1) {
        throw new RuntimeException(&quot;Can't register driver!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;我们获取连接时，&lt;code&gt;DriverManager&lt;/code&gt; 就会根据驱动返回一个相应的数据库连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@CallerSensitive
public static Connection getConnection(String url,
    java.util.Properties info) throws SQLException {
    return (getConnection(url, info, Reflection.getCallerClass()));
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200330182256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际应用场景&quot;&gt;实际应用场景&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;银行转账系统
&lt;ul&gt;&lt;li&gt;转账分类：网上转账，柜台转账，AMT 转账&lt;/li&gt;
&lt;li&gt;转账用户类型：普通用户，银卡用户，金卡用户...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;消息管理
&lt;ul&gt;&lt;li&gt;消息类型：即时消息，延时消息&lt;/li&gt;
&lt;li&gt;消息分类：手机短信，邮件消息，QQ 消息...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本介绍-3&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;1、组合模式（Composite Pattern）又叫部分整体模式，他创建了&lt;strong&gt;对象组的树形结构&lt;/strong&gt;，将对象组合成树状结构以表示「&lt;strong&gt;整体 - 部分&lt;/strong&gt;」的层次关系。&lt;/p&gt;
&lt;p&gt;2、组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象&lt;/p&gt;
&lt;h2 id=&quot;模式结构-2&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Component（抽象构件）&lt;/strong&gt;：定义参加组合对象的公有方法和属性，可以定义一些默认的行为和属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Composite（容器构件）&lt;/strong&gt;：树枝对象，它的作用是组合树枝结点和叶子结点形成一个树形结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Leaf（叶子构件）&lt;/strong&gt;：叶子构件的下面没有其他分支，也就是遍历的最小单位。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;组合模式有两种实现：&lt;strong&gt;安全模式和透明模式&lt;/strong&gt;，其结构如下图所示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全组合模式：在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在容器构件 &lt;code&gt;Composite&lt;/code&gt; 类中声明并实现这些方法。&lt;/li&gt;
&lt;li&gt;透明组合模式：抽象构建角色中声明了所有用于管理成员对象的方法，对其它构件公开透明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200407115121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单案例-2&quot;&gt;简单案例&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;要求：在页面展示出公司的部门组成（一个公司有多个部门，每个部门有多个小组）；&lt;/p&gt;
&lt;p&gt;这是一种很明显的树形结构，因此可以用组合模式解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;「抽象构件」：&lt;/strong&gt;OrganizationComponent&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class OrganizationComponent {
    private String name;

    public OrganizationComponent(String name) {
        this.name = name;
    }

    protected void add(OrganizationComponent component) {
        throw new UnsupportedOperationException(&quot;不支持添加操作&quot;);
    }

    protected void remove(OrganizationComponent component) {
        throw new UnsupportedOperationException(&quot;不支持删除操作&quot;);
    }

    protected abstract void print();


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「容器构件」：&lt;/strong&gt;Company、Department&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Company extends OrganizationComponent {
    private List&amp;lt;OrganizationComponent&amp;gt; components = new ArrayList&amp;lt;&amp;gt;();

    public Company(String name) {
        super(name);
    }

    @Override
    protected void add(OrganizationComponent component) {
        components.add(component);
    }

    @Override
    protected void remove(OrganizationComponent component) {
        components.remove(component);
    }

    @Override
    protected void print() {
        System.out.println(&quot;=======&quot;+getName()+&quot;=======&quot;);
        for (OrganizationComponent component : components) {
            component.print();
        }
    }

    @Override
    public String getName() {
        return super.getName();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Department extends OrganizationComponent {
    private List&amp;lt;OrganizationComponent&amp;gt; components = new ArrayList&amp;lt;&amp;gt;();

    public Department(String name) {
        super(name);
    }

    @Override
    protected void add(OrganizationComponent component) {
        components.add(component);
    }

    @Override
    protected void remove(OrganizationComponent component) {
        components.remove(component);
    }

    @Override
    protected void print() {
        System.out.println(&quot;=======&quot;+getName()+&quot;=======&quot;);
        for (OrganizationComponent component : components) {
            component.print();
        }
    }

    @Override
    public String getName() {
        return super.getName();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「叶子构件」：&lt;/strong&gt;Group，叶子构件不没有子节点了，所以不需要添加、删除之类的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Group extends OrganizationComponent {
    public Group(String name) {
        super(name);
    }

    @Override
    protected void print() {
        System.out.println(getName());
    }

    @Override
    public String getName() {
        return super.getName();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「测试类」：&lt;/strong&gt;Client&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void test01(){
        OrganizationComponent company = new Company(&quot;阿里巴巴&quot;);

        OrganizationComponent department1 = new Department(&quot;市场部&quot;);
        OrganizationComponent department2 = new Department(&quot;技术部&quot;);

        OrganizationComponent group1 = new Group(&quot;市场一组&quot;);
        OrganizationComponent group2 = new Group(&quot;市场二组&quot;);
        OrganizationComponent group3 = new Group(&quot;技术一组&quot;);
        OrganizationComponent group4 = new Group(&quot;技术二组&quot;);

        //添加部门
        company.add(department1);
        company.add(department2);
        //添加小组
        department1.add(group1);
        department1.add(group2);
        department2.add(group3);
        department2.add(group4);

        //打印结果
        company.print();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「运行结果」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;=======阿里巴巴=======
=======市场部=======
市场一组
市场二组
=======技术部=======
技术一组
技术二组
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在-hashmap-中的应用&quot;&gt;在 HashMap 中的应用&lt;/h2&gt;
&lt;p&gt;在 Java（jdk 1.8为例） 的集合类 HashMap 中，抽象构件是 Map，容器构件是 HashMap，叶子构件是 Node&lt;/p&gt;
&lt;p&gt;进入源码可以看见，在 Map 中定义了许多公共方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200407132837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HashMap 实现了 Map，并对一些方法重写，而且 HashMap 中有一个静态内部类 Node，它就充当了叶子构件的角色，Node 中去除了 put、putAll 等方法，下面也没有子结点了&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test02(){
    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;k1&quot;, &quot;v1&quot;);
    map.put(&quot;k2&quot;, &quot;v2&quot;);
    System.out.println(map);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们 put 一个键值对的时候，在 HashMap 内部会调用 putVal 方法，将键值对封装为 Node。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1、简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。&lt;/p&gt;
&lt;p&gt;2、具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。&lt;/p&gt;
&lt;p&gt;3、方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。&lt;/p&gt;
&lt;p&gt;4、需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式。&lt;/p&gt;
&lt;p&gt;5、要求较高的抽象性。如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式。&lt;/p&gt;

&lt;h2 id=&quot;基本&quot;&gt;基本&lt;/h2&gt;
&lt;p&gt;装饰者模式属于&lt;strong&gt;结构型模式&lt;/strong&gt;，它可以&lt;strong&gt;动态的&lt;/strong&gt;将新功能&lt;strong&gt;附加到对象上&lt;/strong&gt;，同时又&lt;strong&gt;不改变其结构&lt;/strong&gt;。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（OCP）。&lt;/p&gt;
&lt;h2 id=&quot;模式结构-3&quot;&gt;模式结构&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;装饰者和被装饰者有&lt;strong&gt;相同的超类型&lt;/strong&gt;，因为装饰者和被装饰者必须是一样的类型，&lt;strong&gt;利用继承是为了达到类型的匹配，而不是利用继承获取行为&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200403155948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Component&lt;/strong&gt;：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteComponent&lt;/strong&gt;：定义具体对象，即被装饰者&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Decorator&lt;/strong&gt;：抽象装饰者，继承自 Component，从外类来扩展 ConcreteComponent。对于 ConcreteComponent来说，不需要知道Decorator的存在，Decorator 是一个接口或抽象类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteDecorator&lt;/strong&gt;：具体装饰者，用于扩展 ConcreteComponent&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;举例说明&quot;&gt;举例说明&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在咖啡店客人想点一杯&lt;strong&gt;加两份糖一份牛奶的摩卡咖啡&lt;/strong&gt;，各个商品的价格如下，我们需要根据用户点的咖啡、加的配料，动态的计算价格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;商品&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;拿铁咖啡（LatteCoffee）&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;摩卡咖啡（MochaCoffe）&lt;/td&gt;
&lt;td&gt;5.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;糖（Sugar）&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;牛奶（Milk）&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;「实体类」&lt;/strong&gt; Coffee&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Coffee{
    public String des = &quot;咖啡&quot;; //描述
    private float price = 0.0f; //价格

    protected abstract float cost(); //计算费用
    
    //省略getter setter方法
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「被装饰者」&lt;/strong&gt;LatteCoffee&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LatteCoffee extends Coffee{
    public LatteCoffee() {
        setDes(&quot;拿铁咖啡&quot;);
        setPrice(4.5f);
    }

    @Override
    protected float cost() {
        return getPrice();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「被装饰者」&lt;/strong&gt;MochaCoffee&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MochaCoffee extends Coffee {
    public MochaCoffee() {
        setDes(&quot;摩卡咖啡&quot;);
        setPrice(5.5f);
    }

    @Override
    protected float cost() {
        return getPrice();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「抽象装饰者」&lt;/strong&gt;Decorator&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Decorator extends Coffee {

    private Coffee coffee;

    public Decorator(Coffee drink) {
        this.coffee = drink;
    }

    @Override
    protected float cost() {
        return getPrice() + coffee.cost();
    }

    @Override
    public String getDes() {
        return coffee.getDes() + &quot;加&quot; + super.getDes();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「具体装饰者」&lt;/strong&gt;SugarDecorator&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SugarDecorator extends Decorator{
    public SugarDecorator(Coffee coffee) {
        super(coffee);
        setDes(&quot;糖&quot;);
        setPrice(1.0f);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「具体装饰者」&lt;/strong&gt;MilkDecorator&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MilkDecorator extends Decorator{
    public MilkDecorator(Coffee coffee) {
        super(coffee);
        setDes(&quot;牛奶&quot;);
        setPrice(2.0f);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「测试类」&lt;/strong&gt;Client&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    /**
     * 点一杯 加两份糖一份牛奶的摩卡咖啡
     */
    @Test
    public void test01() {
        Coffee order = new MochaCoffee();
        System.out.println(order.getDes() + &quot;，价格：&quot; + order.cost());
        //加两份糖
        order = new SugarDecorator(new SugarDecorator(order));
        System.out.println(order.getDes() + &quot;，价格：&quot; + order.cost());
        //加一份牛奶
        order = new MilkDecorator(order);
        System.out.println(order.getDes() + &quot;，价格：&quot; + order.cost());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「结果」&lt;/strong&gt;result&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;摩卡咖啡，价格：5.5
摩卡咖啡加糖加糖，价格：7.5
摩卡咖啡加糖加糖加牛奶，价格：9.5
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在-java-io-流中的应用&quot;&gt;在 Java IO 流中的应用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200403153813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图所示的关系中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实体类是 InputStream&lt;/li&gt;
&lt;li&gt;被装饰者是FileInputStream、StringBufferInputStream、ByteArrayInputStream&lt;/li&gt;
&lt;li&gt;抽象装饰者是FilterInputStream&lt;/li&gt;
&lt;li&gt;具体装饰者是BufferInputStream、DataInputStream、LineNumberInputStream&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体使用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;G:\\a.txt&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;装饰者模式总结&quot;&gt;装饰者模式总结&lt;/h2&gt;
&lt;p&gt;1、利用&lt;strong&gt;继承&lt;/strong&gt;设计子类，只能在编译时静态决定，并且所有子类都会继承相同的行为；利用&lt;strong&gt;组合&lt;/strong&gt;扩展对象，就可以在运行时动态的进行扩展。&lt;/p&gt;
&lt;p&gt;2、装饰者和被装饰者对象&lt;strong&gt;有相同的超类型&lt;/strong&gt;，所以在任何需要原始对象（被装饰者）的场合，都可以用装饰过的对象代替原始对象。&lt;/p&gt;
&lt;p&gt;3、可以用一个或多个装饰者包装一个对象（被装饰者）。&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;装饰者可以在所委托的装饰者行为之前或之后加上自己的行为，以达到特定的目的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5、被装饰者可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。&lt;/p&gt;
&lt;p&gt;6、装饰者会导致出现很多小对象，如果过度使用，会让程序变得复杂。&lt;/p&gt;

&lt;h2 id=&quot;基本介绍-4&quot;&gt;基本介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;外观模式（Facade Pattern）：外部与一个子系统的通信必须通过一个统一的外观对象进行，&lt;strong&gt;它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易被使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;外观模式又称为门面模式，它是一种对象结构型模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模式结构-4&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200413223610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、Client（客户端）：调用者&lt;/p&gt;
&lt;p&gt;2、Facade（外观类）：即上述所讲的高层接口&lt;/p&gt;
&lt;p&gt;3、SubSystem（子系统）：被调用者&lt;/p&gt;
&lt;h2 id=&quot;举例说明-2&quot;&gt;举例说明&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;想要使用电脑，你只需要按一下开机键（客户端），电脑的各个部件（子系统）就开始工作了，你不需要关心硬盘如何启动的，CPU怎么运转的等等，一切都交给内部程序（外观类）处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写简单的程序模拟一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「SubSystem」&lt;/strong&gt;：电脑的几个部件 CPU、内存、硬盘&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Cpu {
    //使用「单例模式--饿汉式」创建对象
    private static Cpu instance = new Cpu();

    private Cpu() {
    }

    public static Cpu getInstance() {
        return instance;
    }

    public void start() {
        System.out.println(&quot;CPU启动&quot;);
    }

    public void stop() {
        System.out.println(&quot;CPU停止工作&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Memory {
    private static Memory instance = new Memory();

    private Memory() {
    }

    public static Memory getInstance() {
        return instance;
    }

    public void start() {
        System.out.println(&quot;内存启动&quot;);
    }

    public void stop() {
        System.out.println(&quot;内存停止工作&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HardDisk {
    private static HardDisk instance = new HardDisk();

    private HardDisk() {
    }

    public static HardDisk getInstance() {
        return instance;
    }

    public void start() {
        System.out.println(&quot;硬盘启动&quot;);
    }

    public void stop() {
        System.out.println(&quot;硬盘停止工作&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「Facade」&lt;/strong&gt;：电脑，统一管理开机关机中硬件的启动与停止&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Computer {
    private Cpu cpu;
    private Memory memory;
    private HardDisk hardDisk;

    public Computer() {
        this.cpu = Cpu.getInstance();
        this.memory = Memory.getInstance();
        this.hardDisk = HardDisk.getInstance();
    }

    /**
     * 开机
     */
    public void boot(){
        cpu.start();
        memory.start();
        hardDisk.start();
    }

    /**
     * 关机
     */
    public void shutdown(){
        cpu.stop();
        memory.stop();
        hardDisk.stop();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「Client」&lt;/strong&gt;：电源键，可控制开机、关机&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    Computer computer = new Computer();

    @Test
    public void boot(){
        computer.boot();
    }

    @Test
    public void shutdown(){
        computer.shutdown();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模式分析-2&quot;&gt;模式分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现了客户端与子系统的&lt;strong&gt;低耦合&lt;/strong&gt;，使得子系统的变化不会影响客户端，只需要调整外观类即可。&lt;/li&gt;
&lt;li&gt;对客户端屏蔽子系统，减少了客户端处理的对象数目，操作变得更简单。&lt;/li&gt;
&lt;li&gt;降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不能很好的限制客户端对子系统的使用，如果对其做了太多限制会降低可变性和灵活性。&lt;/li&gt;
&lt;li&gt;在不引入「抽象外观类」的情况下，如果增加新的子系统，需要修改外观类代码，&lt;strong&gt;违背了「开闭原则」&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。&lt;/li&gt;
&lt;li&gt;客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。&lt;/li&gt;
&lt;li&gt;在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本介绍-5&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;享元模式（Flyweight Pattern）也叫蝇量模式，&lt;strong&gt;运用共享技术有效地支持大量细粒度对象的复用&lt;/strong&gt;。常用于系统底层开发，解决系统性能问题。例如数据库连接池，里面都是创建好的连接对象，如果有我们需要的，直接拿来用，避免重新创建，可以&lt;strong&gt;解决重复对象对内存造成浪费的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;内部状态和外部状态&quot;&gt;内部状态和外部状态&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;享元模式提出了细粒度和共享对象，这里就涉及了内部状态和外部状态的概念，即可以把对象的信息分为两个部分：内部状态和外部状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;内部状态（Intrinsic State）：可以共享的相同内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外部状态（Extrinsic State）：需要外部环境来设置的不能共享的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，围棋理论上有 361 个位置可以放棋子，每盘棋可能会产生两三百个棋子对象，由于内存有限，一台服务器很难支持更多玩家进行围棋对战，如果用享元模式来处理棋子，将棋子的颜色（黑与白）作为内部状态，棋子的位置（不确定）作为外部状态，就可以将棋子对象减少到两个实例（黑棋、白棋），这样就可以很好的解决内存开销问题。&lt;/p&gt;
&lt;h2 id=&quot;模式结构-5&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200414123721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Flyweight：抽象享元类&lt;/li&gt;
&lt;li&gt;ConcreteFlyweight：具体享元类&lt;/li&gt;
&lt;li&gt;UnsharedConcreteFlyweight：非共享具体享元类&lt;/li&gt;
&lt;li&gt;FlyweightFactory：享元工厂类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;举例说明-3&quot;&gt;举例说明&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一个开发团队接了这样的项目，客户希望做一个产品展示网站，但网站需要有多种发布形式，每个用户可以以新闻形式发布、以博客形式发布、以微信公众号形式发布...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;「抽象享元类」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractWebsite {
    public abstract void publish(User user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「非共享具体享元类」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「具体享元类」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcreteWebsite extends AbstractWebsite {
    /**
     * 发布类型
     */
    private String type = &quot;&quot;;

    public ConcreteWebsite(String type) {
        this.type = type;
    }

    /**
     * 发布
     */
    @Override
    public void publish(User user) {
        System.out.println(&quot;用户「&quot;+user.getName()+&quot;」发布的网站形式为「&quot; + type+&quot;」&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「享元工厂类」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class WebsiteFactory {

    /**
     * 以 HashMap 作为对象池
     */
    private Map&amp;lt;String, ConcreteWebsite&amp;gt; pool = new HashMap&amp;lt;&amp;gt;();

    /**
     * 从对象池中返回指定类型的对象，没有则创建
     */
    public AbstractWebsite getWebsite(String type) {
        if (!pool.containsKey(type)) {
            pool.put(type, new ConcreteWebsite(type));
        }
        return pool.get(type);
    }

    /**
     * 计算对象池中对象的个数
     */
    public int count() {
        return pool.size();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「测试类」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void test(){
        WebsiteFactory factory = new WebsiteFactory();

        AbstractWebsite website1 = factory.getWebsite(&quot;新闻&quot;);
        website1.publish(new User(&quot;张三&quot;));
        website1.publish(new User(&quot;李四&quot;));

        AbstractWebsite website2 = factory.getWebsite(&quot;博客&quot;);
        website2.publish(new User(&quot;王五&quot;));
        website2.publish(new User(&quot;赵六&quot;));

        AbstractWebsite website3 = factory.getWebsite(&quot;公众号&quot;);
        website3.publish(new User(&quot;陈七&quot;));
        website3.publish(new User(&quot;胡八&quot;));

        System.out.println(&quot;对象的个数：&quot; + factory.count());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;「运行结果」&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;用户「张三」发布的网站形式为「新闻」
用户「李四」发布的网站形式为「新闻」
用户「王五」发布的网站形式为「博客」
用户「赵六」发布的网站形式为「博客」
用户「陈七」发布的网站形式为「公众号」
用户「胡八」发布的网站形式为「公众号」
对象的个数：3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;享元模式在integer中的应用&quot;&gt;享元模式在Integer中的应用&lt;/h2&gt;
&lt;p&gt;首先我们看一段代码，运行结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class IntegerSource {
    public static void main(String[] args) {
        Integer v1 = 127;
        Integer v2 = 127;
        System.out.println(&quot;v1等于v2？ &quot; + (v1 == v2));
        Integer v3 = 128;
        Integer v4 = 128;
        System.out.println(&quot;v3等于v4？ &quot; + (v3 == v4));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;details readability=&quot;2&quot;&gt;答案
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;v1等于v2？ true
v3等于v4？ false
&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;查看 Integer 源码，找到 &lt;code&gt;valueOf&lt;/code&gt; 方法，可以看到，如果 &lt;code&gt;i&lt;/code&gt; 在某个范围内，就不会产生新的对象，直接从缓存数组中获取，点进 &lt;code&gt;IntegerCache&lt;/code&gt; 里就会发现 &lt;code&gt;low = -128&lt;/code&gt; &lt;code&gt;high = 127&lt;/code&gt;，因此，我们可以理解为这个数组就是「内部状态」&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Integer valueOf(int i) {
    //low = -128 , high = 127
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        //IntegerCache.cache是一个常量数组：static final Integer cache[];
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模式分析-3&quot;&gt;模式分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。&lt;/li&gt;
&lt;li&gt;为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;代理模式介绍&quot;&gt;代理模式介绍&lt;/h2&gt;
&lt;p&gt;代理模式提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以&lt;strong&gt;在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/18202945_lHIa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式分为三类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态代理&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;li&gt;Cglib 代理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;静态代理（不推荐使用）&quot;&gt;静态代理（不推荐使用）&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;要求目标对象和代理对象实现同一个接口&lt;/strong&gt;，调用的时候调用代理对象的方法，从而达到增强的效果&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;可以在不修改目标对象的前提下，增强目标对象方法的功能（所有代理模式都可以实现，因此不推荐使用此方法）&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;① 冗余。目标对象和代理对象实现同一个接口，会产生过多的代理类。&lt;/p&gt;
&lt;p&gt;② 不易维护。当接口方法增加，目标对象与代理对象都要进行修改。&lt;/p&gt;
&lt;h3 id=&quot;代码实现-4&quot;&gt;代码实现&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：厂家生产了商品，但是没有足够的精力、人力去销售，这时候就需要一个代理商帮他售卖，但是代理商需要从中抽取 20% 的利润。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公共接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IProducer {
    void sale(float money);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被代理对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Producer implements IProducer {
    @Override
    public void sale(float money) {
        System.out.println(&quot;卖出产品，厂家获得&quot; + money + &quot;元&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ProxyProducer implements IProducer{

    private IProducer producer;

    public ProxyProducer(IProducer producer) {
        this.producer = producer;
    }

    @Override
    public void sale(float money) {
        producer.sale(money * 0.8f);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void test(){
        IProducer producer = new Producer();
        ProxyProducer proxyProducer = new ProxyProducer(producer);
        proxyProducer.sale(1000f);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;卖出产品，厂家获得800.0元
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;h3 id=&quot;介绍-2&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;动态代理也称：JDK 代理、接口代理，&lt;strong&gt;需要目标对象实现接口，否则不能用动态代理&lt;/strong&gt;，利用 JDK 的 API（java.lang.reflect.Proxy），&lt;strong&gt;动态地在内存中构建代理对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;静态代理和动态代理的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态代理在编译时就已经实现，编译完后的代理类是一个实际的 class 文件&lt;/li&gt;
&lt;li&gt;动态代理实在运行时动态生成的，编译后没有实际的 class 文件，而是在运行时动态的生成类字节码，并加载到 JVM 中&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码实现-5&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;以静态代理的情景为例，我们只需要修改代理对象的代码，代理对象不需要实现公共接口了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ProxyProducer {
    /**
     * 维护一个目标对象
     */
    private Object target;

    public ProxyProducer(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 执行被代理对象的任何接口方法都会经过这里
                     * @param proxy 代理对象的引用
                     * @param method 当前执行的方法
                     * @param args 当前执行方法的参数
                     * @return 和被代理对象具有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //代理过程中执行一些方法
                        float money = (float) args[0] * 0.8f;
                        //反射机制调用目标对象的方法
                        Object invoke = method.invoke(target, money);
                        return invoke;
                    }
                });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cglib-代理&quot;&gt;Cglib 代理&lt;/h2&gt;
&lt;h3 id=&quot;介绍-3&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;Cglib 代理也叫子类代理，&lt;strong&gt;目标对象不需要实现任何接口&lt;/strong&gt;，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。&lt;/p&gt;
&lt;p&gt;Cglib 是一个强大的高性能的代码生成包，它可以在运行期间扩展 Java 类与实现 Java 接口，它广泛地被许多 AOP 的框架使用，例如 Spring AOP，用于实现方法拦截。&lt;/p&gt;
&lt;p&gt;Cglib 包底层实通过使用字节码处理框架 ASM 来转换字节码并生成新的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 AOP 编程中选择哪种代理模式？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;目标对象需要实现接口，用 JDK 代理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标对象不需要实现接口，用 Cglib 代理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码实现-6&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;&lt;em&gt;使用之前需要导入相关 jar 包，可去 maven 仓库下载&lt;/em&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;被代理对象，无需实现接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Producer {
    public void sale(float money) {
        System.out.println(&quot;卖出产品，厂家获得&quot; + money + &quot;元&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ProxyProducer implements MethodInterceptor {
    /**
     * 维护一个目标对象
     */
    private Object target;

    public ProxyProducer(Object target) {
        this.target = target;
    }

    /**
     * 为目标对象生成代理对象
     */
    public Object getProxyInstance(){
        //创建一个工具类
        Enhancer enhancer = new Enhancer();
        //设置父类
        enhancer.setSuperclass(target.getClass());
        //设置回调函数
        enhancer.setCallback(this);
        //创建子类对象（代理对象）
        return enhancer.create();
    }

    /**
     * 会拦截被代理对象的所有方法
     * @param obj 增强对象
     * @param method 被代理对象的方法
     * @param args 被代理对象方法的参数
     * @param methodProxy 代理对象
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;obj：&quot; + obj.getClass());
        Object returnValue = null;
        float money = (float) args[0] * 0.8f;
        if(&quot;sale&quot;.equals(method.getName())){
            returnValue = method.invoke(target, money);
        }
        return returnValue;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    @Test
    public void test() {
        Producer producer = new Producer();
        Producer proxyInstance = (Producer) new ProxyProducer(producer).getProxyInstance();
        proxyInstance.sale(1000f);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;🎉 以上所有代码和笔记均可在 &lt;a href=&quot;https://github.com/songjilong/Design-Pattern&quot;&gt;我的GitHub&lt;/a&gt; 获取&lt;/p&gt;
</description>
<pubDate>Sat, 18 Apr 2020 15:37:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>结构型模式（Structural Pattern） 用于将类或对象结合在一起形成更强大的结构，就像搭积木，可以通过简单的积木组合出复杂、功能强大的模型。 | 结构型模式 | 重要程度 | | | |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12729129.html</dc:identifier>
</item>
<item>
<title>C++生成随机数 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12728941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12728941.html</guid>
<description>&lt;p&gt;C++为随机数提供了两套工具：C风格的和C++风格的。&lt;/p&gt;
&lt;h3 id=&quot;c风格&quot;&gt;C风格&lt;/h3&gt;
&lt;p&gt;C为随机数提供的工具是&lt;code&gt;rand&lt;/code&gt;、&lt;code&gt;srand&lt;/code&gt;和&lt;code&gt;RAND_MAX&lt;/code&gt;，定义在&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;srand&lt;/code&gt;为&lt;code&gt;rand&lt;/code&gt;设置种子，如果不设置，相当于调用过&lt;code&gt;srand(1)&lt;/code&gt;。&lt;code&gt;rand&lt;/code&gt;产生伪随机数，其范围为&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;RAND_MAX&lt;/code&gt;，&lt;code&gt;RAND_MAX&lt;/code&gt;至少是&lt;code&gt;32767&lt;/code&gt;，在MSVC和GCC中这个值都是&lt;code&gt;32767&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;伪随机数看似随机，实则是有规律可循的，对于相同的种子值，&lt;code&gt;rand&lt;/code&gt;产生的序列完全相同，也就是说无论你给&lt;code&gt;srand&lt;/code&gt;一个什么数字，多次运行程序的结果都将相同——除非你给&lt;code&gt;srand&lt;/code&gt;的是不同的数字，比如时间。&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;中的&lt;code&gt;time&lt;/code&gt;函数返回整数表示的系统时间，可用于设置种子。&lt;/p&gt;
&lt;p&gt;如果我们只需要&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;9&lt;/code&gt;的随机数，可以把&lt;code&gt;rand&lt;/code&gt;的返回值&lt;code&gt;% 10&lt;/code&gt;；如果是&lt;code&gt;42&lt;/code&gt;到&lt;code&gt;233&lt;/code&gt;，可以写&lt;code&gt;rand() % 192 + 42&lt;/code&gt;。下面的&lt;code&gt;random&lt;/code&gt;函数封装了这项工作。注意只有在&lt;code&gt;b - a + 1&lt;/code&gt;远小于或整除&lt;code&gt;RAND_MAX&lt;/code&gt;时随机数的分布才比较均匀。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

int random(int a, int b)
{
    return rand() % (b - a + 1) + a;
}

int main()
{
    srand(time(NULL));
    printf(&quot;RAND_MAX = %d\n&quot;, RAND_MAX);
    for (int i = 0; i &amp;lt; 10; i++)
        printf(&quot;%d &quot;, rand());
    printf(&quot;\n&quot;);
    int count[10] = {0};
    for (int i = 0; i &amp;lt; 10000; i++)
        count[random(0, 9)]++;
    for (int i = 0; i &amp;lt; 10; i++)
    {
        printf(&quot;%d: &quot;, i);
        for (int j = 0; j &amp;lt; count[i] / 10; j++)
            printf(&quot;*&quot;);
        printf(&quot;\n&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;c风格-2&quot;&gt;C++风格&lt;/h3&gt;
&lt;p&gt;从C++11开始，C++标准规定了随机数设施，包括均匀随机位生成器（Uniform random bit generators，URBG）和随机数分布等，定义在&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;URBG分为随机数引擎、引擎适配器、预置随机数生成器和非确定随机数生成器4类，通常后两类就够用了。&lt;/p&gt;
&lt;p&gt;标准规定了3种随机数引擎：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线性同余&lt;code&gt;linear_congruential_engine&lt;/code&gt;（LCG），时间空间消耗都少；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;梅森旋转&lt;code&gt;mersenne_twister_engine&lt;/code&gt;（MT），占用较多内存（在PC上可以忽略），计算量较大；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;带进位减法（属于滞后斐波那契生成器，LFG）&lt;code&gt;subtract_with_carry_engine&lt;/code&gt;，性能与效果折中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;随机数引擎都需要一个种子，生成的都是伪随机数。&lt;/p&gt;
&lt;p&gt;引擎适配器可以套一个随机数引擎：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;discard_block_engine&lt;/code&gt;在连续若干个伪随机数中选择若干个；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;independent_bits_engine&lt;/code&gt;把位数多的伪随机数压缩成位数少的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;shuffle_order_engine&lt;/code&gt;把连续若干个伪随机数重排。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;套娃的方式是模板，理论上你还可以用适配器套适配器，不过CPU可能会有意见。&lt;/p&gt;
&lt;p&gt;随机数引擎的模板参数怎么取？标准定义了一些数学家们发现的效果良好的随机数引擎：LCG &lt;code&gt;minstd_rand0&lt;/code&gt;、&lt;code&gt;minstd_rand&lt;/code&gt;、&lt;code&gt;knuth_b&lt;/code&gt;；MT &lt;code&gt;mt19937&lt;/code&gt;、&lt;code&gt;mt19937_64&lt;/code&gt;；LFG &lt;code&gt;ranlux24_base&lt;/code&gt;、&lt;code&gt;ranlux48_base&lt;/code&gt;、&lt;code&gt;ranlux24&lt;/code&gt;、&lt;code&gt;ranlux48&lt;/code&gt;。如果你还是无从下手，那就用&lt;code&gt;default_random_engine&lt;/code&gt;，编译器的开发者们为你选好了他们认为最合适的，在MSVC中是&lt;code&gt;mt19937&lt;/code&gt;，在GCC中是&lt;code&gt;minstd_rand0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以上工具都生成伪随机数，标准还定义了真·随机数引擎&lt;code&gt;random_device&lt;/code&gt;，尽管标准也允许它是伪随机的。如果它是真随机的，那么使用起来它的效果无疑是最好的，但是多次调用后性能会急剧下降，通常只用于生成伪随机数引擎的种子。&lt;/p&gt;
&lt;p&gt;随机数生成器类型都定义了静态方法&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;，返回生成的随机数的范围，以及无参数的函数调用运算符&lt;code&gt;operator()&lt;/code&gt;，返回随机数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;random&amp;gt;

int main()
{
    auto engine = std::default_random_engine(std::random_device()());
    std::cout &amp;lt;&amp;lt; &quot;min = &quot; &amp;lt;&amp;lt; engine.min() &amp;lt;&amp;lt; &quot;; max = &quot; &amp;lt;&amp;lt; engine.max() &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;random numbers: &quot;;
    for (int i = 0; i != 10; ++i)
        std::cout &amp;lt;&amp;lt; engine() &amp;lt;&amp;lt; ' ';
    std::cout &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数情况下我们不需要&lt;code&gt;min&lt;/code&gt;到&lt;code&gt;max&lt;/code&gt;范围的整数，而需要一定分布的整数或实数。标准规定了许多随机数分布类型，我数学不好，不太懂这些。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;均匀分布&lt;code&gt;uniform_int_distribution&lt;/code&gt;、&lt;code&gt;uniform_real_distribution&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;伯努利分布&lt;code&gt;bernoulli_distribution&lt;/code&gt;、&lt;code&gt;binomial_distribution&lt;/code&gt;、&lt;code&gt;negative_binomial_distribution&lt;/code&gt;、&lt;code&gt;geometric_distribution&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;泊松分布&lt;code&gt;poisson_distribution&lt;/code&gt;、&lt;code&gt;exponential_distribution&lt;/code&gt;、&lt;code&gt;gamma_distribution&lt;/code&gt;、&lt;code&gt;weibull_distribution&lt;/code&gt;、&lt;code&gt;extreme_value_distribution&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;正态分布&lt;code&gt;normal_distribution&lt;/code&gt;、&lt;code&gt;lognormal_distribution&lt;/code&gt;、&lt;code&gt;chi_squared_distribution&lt;/code&gt;、&lt;code&gt;cauchy_distribution&lt;/code&gt;、&lt;code&gt;fisher_f_distribution&lt;/code&gt;、&lt;code&gt;student_t_distribution&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抽样分布&lt;code&gt;discrete_distribution&lt;/code&gt;、&lt;code&gt;piecewise_constant_distribution&lt;/code&gt;、&lt;code&gt;piecewise_linear_distribution&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造分布实例时传入分布的参数。调用&lt;code&gt;operator()&lt;/code&gt;获得结果，参数为随机数引擎。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;string&amp;gt;

int main()
{
    auto engine = std::default_random_engine(std::random_device()());
    std::uniform_int_distribution&amp;lt;int&amp;gt; uniform(0, 9);
    int count[10] = {0};
    for (int i = 0; i != 10000; ++i)
        ++count[uniform(engine)];
    for (int i = 0; i != 10; ++i)
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; std::string(count[i] / 10, '*') &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，与STL中左闭右开的习惯不同，&lt;code&gt;uniform_int_distribution&lt;/code&gt;构造函数接受的参数是闭区间。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Apr 2020 15:14:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>C++为随机数提供了两套工具：C风格的和C++风格的。 C风格 C为随机数提供的工具是 、`srand RAND_MAX 中。 为`rand srand(1) rand 0`到 ，`RAND_MAX</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12728941.html</dc:identifier>
</item>
</channel>
</rss>