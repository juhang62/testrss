<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>asp.net core系列 48 Identity  身份模型自定义 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10593987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10593987.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core Identity提供了一个框架，用于管理和存储在 ASP.NET Core 应用中的用户帐户。 Identity添加到项目时单个用户帐户选择作为身份验证机制。 默认情况下，Identity可以使用的 Entity Framework (EF) Core 数据模型。 本文介绍如何自定义的身份标识模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　1.1 下面是已经存在的身份模型&lt;span lang=&quot;EN-US&quot;&gt;, 由以下实体类型组成&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;
&lt;p&gt;&lt;strong&gt;实体类型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;
&lt;p&gt;&lt;strong&gt;关系&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;Users&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;登录用户&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;
&lt;p&gt;Roles&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p&gt;角色&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;UserClaims&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;用户拥有的权限&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;每个&lt;code&gt;Users&lt;/code&gt;有多个&lt;code&gt;UserClaims&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;UserTokens&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;用户的身份验证令牌&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;每个&lt;code&gt;Users&lt;/code&gt;有多个UserTokens&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;UserLogins&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;将用户与登录相关联。&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;每个&lt;code&gt;Users&lt;/code&gt;有多个UserLogins&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;RoleClaims&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;角色拥有的权限&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;每个&lt;code&gt;Roles&lt;/code&gt;有多个&lt;code&gt;RoleClaims&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;198&quot;&gt;UserRoles&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;用户和角色关联&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;265&quot;&gt;每个&lt;code&gt;Users&lt;/code&gt;有多个Roles&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;span lang=&quot;EN-US&quot;&gt;1.2 默认模型的配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　&lt;/span&gt;&lt;/strong&gt;Identity定义了许多从DbContext继承以配置和使用模型的上下文类，此配置是使用上下文类的OnModelCreating方法中的EF Core Code First Fluent API完成的。默认模型结构可以查看Migration文件以及查看模型关系ModelSnapshot文件，但要修改模型不在这里更改。下面是AspNetUsers模型代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201903/151560-20190325151308442-1551785679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　下面是默认模型生成的数据表以及关系：　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201903/151560-20190325151337794-1092569358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二.模型自定义&lt;/h3&gt;
&lt;p&gt;　　　在EF上下文中当重写&lt;code&gt;OnModelCreating&lt;/code&gt;&lt;code&gt;方法时&lt;/code&gt;，&lt;code&gt;base.OnModelCreating&lt;/code&gt;&lt;code&gt;方法&lt;/code&gt;首先调用; 接下来重写的会覆盖默认模型配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApplicationDbContext : IdentityDbContext&amp;lt;WebAppIdentityDemoUser&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ApplicationDbContext(DbContextOptions&amp;lt;ApplicationDbContext&amp;gt;&lt;span&gt; options)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(builder);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Customize the ASP.NET Core Identity model and override the defaults if needed.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For example, you can rename the ASP.NET Core Identity table names and more.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add your customizations after calling base.OnModelCreating(builder);&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1 自定义用户数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　在上篇有讲过自定义用户数据，这里在总结下。自定义用户数据支持通过继承IdentityUser类。 自定义类命名约定 {Application}User。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义{Application}User扩展类，实现用户模型&lt;/span&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebAppIdentityDemoUser : IdentityUser
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用{Application}User作为上下文的泛型参数的类型：&lt;/span&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApplicationDbContext : IdentityDbContext&amp;lt;WebAppIdentityDemoUser&amp;gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新Startup.ConfigureServices以使用新{Application}User类，最后生成迁移，同步数据库。&lt;/span&gt;
       services.AddDefaultIdentity&amp;lt;WebAppIdentityDemoUser&amp;gt;&lt;span&gt;()
               .AddDefaultUI()
               .AddEntityFrameworkStores&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;();    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　&lt;span lang=&quot;EN-US&quot;&gt;2.2 更改主键类型&lt;/span&gt;&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt; 　　　　在创建数据库之后更改PK列的数据类型在许多数据库系统上都存在问题。更改PK通常涉及删除和重新创建表。因此，&lt;span&gt;在创建数据库时，应在初始迁移中指定PK类型。&lt;span&gt;下面是更改主键类型步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　 　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(1) 删除数据库，命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   　　　　 Drop-Database  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(2) 移除之前生成的迁移，命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   　　　　 Remove-Migration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;(3) 修改&lt;span lang=&quot;EN-US&quot;&gt;user,role表主键类型，以及相关代码改动&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户表设置主键为Int&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebAppIdentityDemoUser : IdentityUser&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Full name
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [PersonalData]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Birth Date
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [PersonalData]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime DOB { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 角色表设置主键为Int&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebAppIdentityDemoRole : IdentityRole&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;
    {

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　(4) 修改上下文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApplicationDbContext : IdentityDbContext&amp;lt;WebAppIdentityDemoUser, WebAppIdentityDemoRole,&lt;span&gt;int&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(5) 修改服务注册&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
     　　services.AddIdentity&amp;lt;WebAppIdentityDemoUser, WebAppIdentityDemoRole&amp;gt;&lt;span&gt;()
    　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果使用Identity scaffolder将Identity文件添加到项目中，请删除对该项目的调用AddDefaultUI
    　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddDefaultUI()&lt;/span&gt;
     　　.AddEntityFrameworkStores&amp;lt;ApplicationDbContext&amp;gt;&lt;span&gt;()
     　　.AddDefaultTokenProviders();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(6) &lt;span lang=&quot;EN-US&quot;&gt;生成迁移代码，命令如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    　　 Add-Migration IdentitySchema
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(7) 同步数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    　　Update-Database IdentitySchema
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时表的主键类型已修改完成，包括关系表的外键类型也同步更新了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201903/151560-20190325152329224-11242967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.3 添加导航属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　导航属性仅存在于EF模型中，而不存在于数据库中，如果导航关系没有改变，模型更改不需要更新数据库。如果更改关系的模型配置可能比进行其他更改更困难。必须注意取代现有的关系。下面示例是不改变模型关系，只是在user模型上添加导航属性以及在上下文中指定关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebAppIdentityDemoUser : IdentityUser&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Full name
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [PersonalData]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Birth Date
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [PersonalData]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime DOB { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义导航属性&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;IdentityUserClaim&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; Claims { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(builder);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Customize the ASP.NET Core Identity model and override the defaults if needed.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For example, you can rename the ASP.NET Core Identity table names and more.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add your customizations after calling base.OnModelCreating(builder);&lt;/span&gt;
            builder.Entity&amp;lt;WebAppIdentityDemoUser&amp;gt;(b =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Each User can have many UserClaims&lt;/span&gt;
                b.HasMany(e =&amp;gt;&lt;span&gt; e.Claims)
                    .WithOne()
                    .HasForeignKey(uc &lt;/span&gt;=&amp;gt;&lt;span&gt; uc.UserId)
                    .IsRequired();
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　对于所有用户导航属性, 用户和角色导航属性，添加所有导航属性。参考官网文档。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.4  更改表/列名称,字段长度(上下文中更改)　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder builder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(builder);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更改表名称&lt;/span&gt;
            builder.Entity&amp;lt;IdentityUser&amp;gt;(b =&amp;gt;&lt;span&gt;
            {
                b.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyUsers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更改表字段名称&lt;/span&gt;
            builder.Entity&amp;lt;IdentityUserClaim&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;(b =&amp;gt;&lt;span&gt;
            {
                b.Property(e &lt;/span&gt;=&amp;gt; e.ClaimType).HasColumnName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                b.Property(e &lt;/span&gt;=&amp;gt; e.ClaimValue).HasColumnName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CValue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更改长度&lt;/span&gt;
            builder.Entity&amp;lt;IdentityUser&amp;gt;(b =&amp;gt;&lt;span&gt;
            {
                b.Property(u &lt;/span&gt;=&amp;gt; u.UserName).HasMaxLength(&lt;span&gt;128&lt;/span&gt;&lt;span&gt;);
            });    
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　参考文献&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;自定义&lt;/a&gt;Identity&lt;/p&gt;

</description>
<pubDate>Mon, 25 Mar 2019 07:51:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 ASP.NET Core Identity提供了一个框架，用于管理和存储在 ASP.NET Core 应用中的用户帐户。 Identity添加到项目时单个用户帐户选择作为身份验证机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10593987.html</dc:identifier>
</item>
<item>
<title>算法基础（一） - 不会敲代码的高手</title>
<link>http://www.cnblogs.com/huozhonghun/p/10591142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huozhonghun/p/10591142.html</guid>
<description>&lt;p&gt;&lt;span&gt;认识时间复杂度&lt;/span&gt;&lt;br/&gt;常数时间的操作：一个操作如果和数据量没有关系，每次都是 固定时间内完成的操作，叫做常数操作。&lt;br/&gt;时间复杂度为一个算法流程中，常数操作数量的指标。常用O （读作big O）来表示。具体来说，在常数操作数量的表达式中， &lt;span&gt;只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果记为f(N)，那么时间复杂度为O(f(N))。&lt;/p&gt;
&lt;p&gt;评价一个算法流程的好坏，先看时间复杂度的指标，然后再分 析不同数据样本下的实际运行时间，也就是常数项时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个简单的理解时间复杂度的例子&lt;br/&gt;一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。&lt;br/&gt;算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；&lt;br/&gt;算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；&lt;br/&gt;算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数；&lt;br/&gt;三个流程，三种时间复杂度的表达...&lt;br/&gt;如何分析好坏:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程1：　　o(m*n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程2：　　o(mlogn)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程3：数组B排序：o(mlogm)　　外排：(n+m)　　o(mlogm)+(n+m)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冒泡排序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; maopaosort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr==&lt;span&gt;null&lt;/span&gt;||arr.length&amp;lt;2&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = arr.length-1; i&amp;gt;0; i--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt;i; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从后面开始往前排序
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内循环是比较相邻的两个元素,把最大的元素交换到后面&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (arr[j]&amp;gt;arr[j+1&lt;span&gt;]){
                    swap(arr,j,j&lt;/span&gt;+1&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[i];
        arr[i]&lt;/span&gt;=&lt;span&gt;arr[j];
        arr[j]&lt;/span&gt;=&lt;span&gt;temp;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：等差数列，an^2+bn+1　　o(n^2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择排序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; xuanzesort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr==&lt;span&gt;null&lt;/span&gt;||arr.length&amp;lt;2&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;arr.length-1 ; i++&lt;span&gt;) {
           &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  min=&lt;span&gt;i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i+1; j &amp;lt;arr.length ; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每一次寻找都是&quot;在剩余子数组里面&quot;最小的那个&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(arr[j]&amp;lt;&lt;span&gt;arr[min]){
                    min&lt;/span&gt;=&lt;span&gt;j;
                }
            }
            swap(arr,min,i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[i];
        arr[i]&lt;/span&gt;=&lt;span&gt;arr[j];
        arr[j]&lt;/span&gt;=&lt;span&gt;temp;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：o(n^2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入排序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; charusort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr==&lt;span&gt;null&lt;/span&gt;||arr.length&amp;lt;2&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次先排好j到i范围的数，慢慢扩大范围&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;arr.length ; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i-1; j &amp;gt;=0; j--&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[j+1]&amp;lt;&lt;span&gt;arr[j]){
                    swap(arr,j,j&lt;/span&gt;+1&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[i];
        arr[i]&lt;/span&gt;=&lt;span&gt;arr[j];
        arr[j]&lt;/span&gt;=&lt;span&gt;temp;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;时间复杂度：最坏：o(n^2)　　最好(已经排好序)：o(n)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;剖析递归行为和递归行为时间复杂度的估算&lt;/span&gt;&lt;br/&gt;&lt;span&gt;符合T(N) = a*T(N/b) + O(N^d)，可以使用master公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N:父问题的样本量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a:过程发生多少次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N/b:子问题的样本量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;d:除去子过程外，剩下的时间复杂度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;master公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1) log(b,a) &amp;gt; d -&amp;gt; 复杂度为O(N^log(b,a))&lt;/p&gt;
&lt;p&gt;2) log(b,a) = d -&amp;gt; 复杂度为O(N^d * logN)&lt;/p&gt;
&lt;p&gt;3) log(b,a) &amp;lt; d -&amp;gt; 复杂度为O(N^d)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归并排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T(N)=2(N/2)+O(N)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;运用master公式2，算出&lt;/span&gt;&lt;span&gt;时间复杂度：o(nlogn)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr==&lt;span&gt;null&lt;/span&gt;||arr.length&amp;lt;2&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        sortProcess(arr,&lt;/span&gt;0,arr.length-1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sortProcess(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; R) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(L==&lt;span&gt;R){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mid=L+((R-L)&amp;gt;&amp;gt;1);&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; mid=(L+R)/2&lt;span&gt;;
        sortProcess(arr,L,mid);
        sortProcess(arr,mid&lt;/span&gt;+1&lt;span&gt;,R);
        merge(arr,L,mid,R);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; L, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; R) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] help=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[R-L+1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p1=L;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左指标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; p2=mid+1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右指标&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(p1&amp;lt;=mid&amp;amp;&amp;amp;p2&amp;lt;=&lt;span&gt;R)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右指标比较，谁小填谁&lt;/span&gt;
            help[i++]=arr[p1]&amp;lt;arr[p2]?arr[p1++]:arr[p2++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p2已经越界，拷贝p1&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(p1&amp;lt;=&lt;span&gt;mid)
            help[i&lt;/span&gt;++]=arr[p1++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p1已经越界，拷贝p2&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(p2&amp;lt;=&lt;span&gt;R)
            help[i&lt;/span&gt;++]=arr[p2++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=0;j&amp;lt;help.length;j++&lt;span&gt;)
            arr[L&lt;/span&gt;+j]=&lt;span&gt;help[j];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;span&gt;小和问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。&lt;br/&gt;例子：&lt;/p&gt;
&lt;p&gt;[1,3,4,2,5]&lt;/p&gt;
&lt;p&gt;1左边比1小的数，没有；&lt;/p&gt;
&lt;p&gt;3左边比3小的数，1；&lt;/p&gt;
&lt;p&gt;4左边比4小的数，1、3；&lt;/p&gt;
&lt;p&gt;2左边比2小的数，1；&lt;/p&gt;
&lt;p&gt;5左边比5小的数，1、3、4、2；&lt;/p&gt;
&lt;p&gt;所以小和为1+1+3+1+1+3+4+2=16&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SmallSum {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr={1,3,4,2,5&lt;span&gt;};
        System.out.println(smallSum(arr));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; smallSum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr==&lt;span&gt;null&lt;/span&gt;||arr.length&amp;lt;2&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mergeSort(arr,0,arr.length-1&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;[] arr,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l==r)  &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid=(l+r)/2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mergeSort(arr,l,mid)+mergeSort(arr,mid+1,r)+&lt;span&gt;merge(arr,l,mid,r);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] arr,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; mid,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] help=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r-l+1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p1=&lt;span&gt;l;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p2=mid+1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p1&amp;lt;=mid&amp;amp;&amp;amp;p2&amp;lt;=&lt;span&gt;r){
            res&lt;/span&gt;+=arr[p1]&amp;lt;arr[p2]?(r-p2+1)*arr[p1]:0&lt;span&gt;;
            help[i&lt;/span&gt;++]=arr[p1]&amp;lt;arr[p2]?arr[p1++]:arr[p2++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p1&amp;lt;=&lt;span&gt;mid)
            help[i&lt;/span&gt;++]=arr[p1++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p2&amp;lt;=&lt;span&gt;r)
            help[i&lt;/span&gt;++]=arr[p2++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt;help.length; j++&lt;span&gt;) {
            arr[l&lt;/span&gt;+j]=&lt;span&gt;help[j];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 25 Mar 2019 07:42:00 +0000</pubDate>
<dc:creator>不会敲代码的高手</dc:creator>
<og:description>认识时间复杂度常数时间的操作：一个操作如果和数据量没有关系，每次都是 固定时间内完成的操作，叫做常数操作。时间复杂度为一个算法流程中，常数操作数量的指标。常用O （读作big O）来表示。具体来说，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huozhonghun/p/10591142.html</dc:identifier>
</item>
<item>
<title>JAVA基础|从Class.forName初始化数据库到SPI破坏双亲委托机制 - faberry</title>
<link>http://www.cnblogs.com/faberry/p/10594002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/faberry/p/10594002.html</guid>
<description>&lt;p&gt;代码托管在：https://github.com/fabe2ry/classloaderDemo&lt;/p&gt;

&lt;p&gt;如果你写过操作数据库的程序的话，可能会注意，有的代码会在程序的开头，有Class.forName(&quot;com.mysql.jdbc.Driver&quot;);的代码，并且告诉你这是在进行数据库的初始化，注册jdbc的驱动；但是其实如果你去掉这段代码，并不会影响程序的正常运行，当然这是需要在JDK6之后才行这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.sql.*;
 
public class MySQLDemo {
 
    // JDBC 驱动名及数据库 URL
    static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;  
    static final String DB_URL = &quot;jdbc:mysql://localhost:3306/RUNOOB&quot;;
 
    // 数据库的用户名与密码，需要根据自己的设置
    static final String USER = &quot;root&quot;;
    static final String PASS = &quot;123456&quot;;
 
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        try{
            // 注册 JDBC 驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        
            // 打开链接
            System.out.println(&quot;连接数据库...&quot;);
            conn = DriverManager.getConnection(DB_URL,USER,PASS);
        
            // 执行查询
            System.out.println(&quot; 实例化Statement对象...&quot;);
            stmt = conn.createStatement();
            String sql;
            sql = &quot;SELECT id, name, url FROM websites&quot;;
            ResultSet rs = stmt.executeQuery(sql);
        
            // 展开结果集数据库
            while(rs.next()){
                // 通过字段检索
                int id  = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String url = rs.getString(&quot;url&quot;);
    
                // 输出数据
                System.out.print(&quot;ID: &quot; + id);
                System.out.print(&quot;, 站点名称: &quot; + name);
                System.out.print(&quot;, 站点 URL: &quot; + url);
                System.out.print(&quot;\n&quot;);
            }
            // 完成后关闭
            rs.close();
            stmt.close();
            conn.close();
        }catch(SQLException se){
            // 处理 JDBC 错误
            se.printStackTrace();
        }catch(Exception e){
            // 处理 Class.forName 错误
            e.printStackTrace();
        }finally{
            // 关闭资源
            try{
                if(stmt!=null) stmt.close();
            }catch(SQLException se2){
            }// 什么都不做
            try{
                if(conn!=null) conn.close();
            }catch(SQLException se){
                se.printStackTrace();
            }
        }
        System.out.println(&quot;Goodbye!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;com.mysql.jdbc.driver&quot;&gt;com.mysql.jdbc.Driver&lt;/h2&gt;
&lt;p&gt;首先我们要知道Class.forName()与ClassLoader.loadClass()的区别，二者都可以返回一个类对象&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class.forName()根据重载形式的不同，分别为public Class forName(String name)来初始化类，根据public Class forName(String name, boolean init, ClassLoader classLoader);来选择对于的classloader进行加载，并且是否需要初始化；二者没有互相调用的关系&lt;/li&gt;
&lt;li&gt;而ClassLoader.loadCLass()根据重载形式的不同，分别为public CLass loadClass(String name);和protect Class ClassLoader(String name, boolean reslove);，前者是我们调用加载器的方法，后者则是我们应该继承重写的方法，方法对应的第二个参数的意思是是否需要解析，这个解析就是我们在类加载机制中的一个环节了；二者的关系是前者默认调用带false常数的后者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;知道了这个区别之后，就应该了解使用Class.forName是希望完成类从加载，连接（包括验证，准备和解析）以及初始化的全过程，但是代码之后也没有使用过这个方法加载出来的类对象，说明使用这个方法，目的就是完成类的初始化，所以查看一下com.mysql.jdbc.Driver这个类的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.mysql.cj.jdbc;

import java.sql.DriverManager;
import java.sql.SQLException;

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException(&quot;Can't register driver!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到static代码块里有初始化的操作，使用这种方式初始化，可以保证初始化一次（jvm加载类的时候，默认会进行加锁同步，避免多线程下加载多个一样的类，自然也只有一次初始化操作）&lt;/p&gt;
&lt;h2 id=&quot;为什么需要spiservice-provider-interface&quot;&gt;为什么需要SPI（service provider interface）&lt;/h2&gt;
&lt;p&gt;首先我们可以看到如果没有引入spi，我们必须显示的调用Class.forName()来调用数据库初始化的操作，并且这种操作，有以下的问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用String的字面值，存在可能写错的情况，毕竟不是强类型的操作，像idea这些编译器也不能提前发现，只有程序运行才能检测出了&lt;/li&gt;
&lt;li&gt;需要硬编码到程序中，如果我更改了另一个数据库的驱动，需要修改到代码，你可能会说这只是改动一下，没什么关系，但是如果很蛋疼的是，你实际项目中，可能测试环境用一种驱动，生成环境用另一个驱动，你这会不就需要重复更改代码了么，而且更改代码还意味着需要重写编译，当项目很大的时候，这么做就会浪费很长的时间了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么有没有一种方法，只需要我们引入了某个驱动的jar包，程序就知道自动加载驱动，也就是帮我们根据jar包来调用Class.forName()的操作呢&lt;/p&gt;
&lt;p&gt;有，这就是spi的作用，下面我们通过一个例子，写一个自己的api接口，并且另外写两个jar包，分别提供不同的api接口的实现，使用spi来，帮助我们达到我们自动初始化的目的&lt;/p&gt;
&lt;h2 id=&quot;实现spi&quot;&gt;实现spi&lt;/h2&gt;
&lt;p&gt;我们先在项目一中新建一个接口Angle，并且写一个AngleManager管理类，这个类保存着我们的实现类，实现类需要向该类注册；再新建项目二与三，分别实现接口，并且打包成为jar包，同样，因为实现接口前，必须知道接口是啥，我们使用maven管理jar包，同时在项目二和三把项目一的jar给引入；最后，我们在项目四，引入项目一，并且根据需求，引入项目二或者项目三，来进行测试&lt;/p&gt;
&lt;h3 id=&quot;项目一&quot;&gt;项目一&lt;/h3&gt;
&lt;p&gt;Angle.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package api;

public interface Angle {
    void love(String singleDog);
    void hate(String coupleDog);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AngleManager.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package api;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ServiceLoader;

public class AngleManager {

    private static int angleIndex = 0;
    private static List&amp;lt;Angle&amp;gt; angles = new ArrayList&amp;lt;Angle&amp;gt;();

    /**
     * 提供注册功能
     * @param angle
     */
    public static void registerAngle(Angle angle){
        angles.add(angle);
    }

    /**
     * 获取一个接口实现
     * @return
     */
    public static Angle angleFall(){
        if(angles.size() &amp;gt; 0 &amp;amp;&amp;amp; angleIndex &amp;lt; angles.size()){
            return angles.get(angleIndex ++);
        }
        return null;
    }

    /**
     * 提供初始化操作，里面使用spi，来发现第三方的接口实现
     */
    private static void angleManagerInit() {
        ServiceLoader&amp;lt;Angle&amp;gt; angleServiceLoader = ServiceLoader.load(Angle.class);
        Iterator&amp;lt;Angle&amp;gt; angleIterator = angleServiceLoader.iterator();
        while(angleIterator.hasNext()) {
//            这里会调用Class.forName(name, init, classloader);
            angleIterator.next();
        }
    }

    static {
        System.out.println(&quot;angleManagerInit&quot;);
        angleManagerInit();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;paradise&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;


&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写完install下，发布到本地仓库，给后面项目引入&lt;/p&gt;
&lt;h3 id=&quot;项目二&quot;&gt;项目二&lt;/h3&gt;
&lt;p&gt;FireAngle.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package impl;

import api.Angle;
import api.AngleManager;

public class FireAngle implements Angle {

    static {
//        自定义的初始化操作
        System.out.println(&quot;i am fire angle, i init&quot;);
        AngleManager.registerAngle(new FireAngle());
    }

    public void love(String singleDog) {
        System.out.println(&quot;single dog is happy, very very happy&quot;);
    }

    public void hate(String coupleDog) {
        System.out.println(&quot;Burning coupleDog&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fire&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;paradise&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;


&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时为了使用SPI，我们还需要遵守规范，在resource文件下，新建META-INF/services文件夹，在下面以接口名称命名一个文本文件，在文件内写入接口实现类的全限定名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1229167/201903/1229167-20190325152753691-1405591840.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目三&quot;&gt;项目三&lt;/h3&gt;
&lt;p&gt;项目三就只贴实现类了&lt;/p&gt;
&lt;p&gt;Lucifer.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package hell;

import api.Angle;
import api.AngleManager;

public class Lucifer implements Angle {
    static {
    //  自定义的初始化操作
        System.out.println(&quot;i am lucifer, i init&quot;);
        AngleManager.registerAngle(new Lucifer());
    }

    public void love(String s) {
        System.out.println(&quot;Lucifer love single dog&quot;);
    }

    public void hate(String s) {
        System.out.println(&quot;Lucifer hate couple dog&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在同样将项目二和三给install一下，发布到本地仓库&lt;/p&gt;
&lt;h3 id=&quot;项目四&quot;&gt;项目四&lt;/h3&gt;
&lt;p&gt;TestMain.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import api.Angle;
import api.AngleManager;

public class TestMain {
    public static void main(String[] args) {
        Angle who = AngleManager.angleFall();
        who.love(&quot;zxzhang&quot;);
        who.hate(&quot;tr3eee&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;world&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;paradise&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;


        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fire&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--注释掉--&amp;gt;
        &amp;lt;!--&amp;lt;dependency&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;groupId&amp;gt;com.fabe2ry&amp;lt;/groupId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;artifactId&amp;gt;hell&amp;lt;/artifactId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/dependency&amp;gt;--&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当项目运行后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1229167/201903/1229167-20190325152816776-889907795.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改pom文件，引入项目三的jar包&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1229167/201903/1229167-20190325152821838-81013349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们全程面对接口编程，在没有修改代码的情况下，就更改的代码的实现，可以说一种控制反转了吧，同时第三方开发api接口实现类，需要做的初始化操作，全部通过静态代码块的方式执行了，用户完全不用参与&lt;/p&gt;
&lt;h2 id=&quot;破坏双亲委托机制&quot;&gt;破坏双亲委托机制&lt;/h2&gt;
&lt;p&gt;明白了SPI的作用后，再来看看为什么说SPI会破坏双亲委托机制呢&lt;/p&gt;
&lt;h3 id=&quot;类加载器分工&quot;&gt;类加载器分工&lt;/h3&gt;
&lt;p&gt;当一个类（A类）使用到另一个类（B类）的时候，被使用到的类（B类）如果没有被加载，这时候，应该由哪个类加载器来加载这个类呢？结论是由使用类（A类）的类加载器，下面我们用代码验证一下&lt;/p&gt;
&lt;p&gt;我们自定义一个类加载器MyClassLoader，这个类加载负责加载D盘下的class文件（不再classpath底下），同时我们定义A和B类，在A类中引用B类，然后看看B是会被哪个类加载器加载&lt;/p&gt;
&lt;p&gt;Entry.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.lang.reflect.Method;

public class Entry {
    public static void main(String[] args) throws Exception{
        MyClassLoader secondClassLoader = new MyClassLoader();
        Class aClazz = Class.forName(&quot;test.AClass&quot;, true, secondClassLoader);
        System.out.println(&quot;!!!!&quot;);
        Object a = aClazz.newInstance();
        System.out.println(&quot;!!!!&quot;);
        Method printMethod = aClazz.getMethod(&quot;print&quot;);
        printMethod.invoke(a);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package test;

public class AClass {
    static {
        System.out.println(&quot;AClass init&quot;);
    }

    private BClass b;

    public AClass(){
        b = new BClass();
    }

    public void print(){
        System.out.println(this.getClass().getClassLoader().getClass().getName());
        System.out.println(b.getClass().getClassLoader().getClass().getName());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package test;

public class BClass {
    static {
        System.out.println(&quot;BClass init&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyClassLoader.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

public class MyClassLoader extends ClassLoader{
    @Override
    public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
        System.out.println(&quot;my class loader load class：&quot; + name);
        File file = getClassFile(name);
        try {
            byte[] bytes = getClassBytes(file);
            Class&amp;lt;?&amp;gt; c = this.defineClass(name, bytes, 0, bytes.length);
            return c;
        }catch (Exception e){
        }

//        这里不用这个的话，会出现加载问题
        return super.loadClass(name);
    }

    private File getClassFile(String name){
        name = name.substring(name.lastIndexOf('.') + 1);
        File file = new File(&quot;D:/&quot; + name + &quot;.class&quot;);
        return file;
    }

    private byte[] getClassBytes(File file) throws Exception{
        // 这里要读入.class的字节，因此要使用字节流
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        WritableByteChannel wbc = Channels.newChannel(baos);
        ByteBuffer by = ByteBuffer.allocate(1024);
        while (true)
        {
            int i = fc.read(by);
            if (i == 0 || i == -1)
                break;
            by.flip();
            wbc.write(by);
            by.clear();
        }
        fis.close();
        return baos.toByteArray();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个加载器会加载D盘下的class文件，如果找不到才会交给父加载器加载，显然是不遵守双亲委托机制的；对于为什么需要调用super.loadClass(name)这个方法的，需要知道，对于类的解析过程，在这个过程中，会将符号引用转换为直接引用，对于类和接口的解析过程，是需要将递归解析父类的，如果父类没有进行加载，就会加载父类，如果这里我们在D盘找不到，就返回null的话，然后程序在解析的过程中就就会运行不起来，因为所有类的父类Object这个类加载器是加载不到的，所以必须调用super.loadClass(name)&lt;/p&gt;
&lt;h4 id=&quot;错误示范将super.loadclassname改为null&quot;&gt;错误示范(将super.loadClass(name)改为null)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1229167/201903/1229167-20190325152830530-1529035354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，其实已经可以证明我们的观点了，Object被AClass的类加载器引用，而不是使用应用程序加载器&lt;/p&gt;
&lt;h4 id=&quot;继续原来的步骤&quot;&gt;继续原来的步骤&lt;/h4&gt;
&lt;p&gt;我们修改会类加载器的代码，让它在找不到的时候，在委托给父类查找，保证程序正常运行&lt;/p&gt;
&lt;p&gt;同时，我们手动编译AClass.java和BClass.java，将class文件放入D盘（当然你也可以在idea里面写好AClass和BClass，然后运行一下，可以在target目录下找到编译的class文件，就不用手动编译了）&lt;/p&gt;
&lt;p&gt;现在运行代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1229167/201903/1229167-20190325152836404-1405133384.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;了解spi的实现过程&quot;&gt;了解SPI的实现过程&lt;/h3&gt;
&lt;p&gt;现在我们明白了一个类使用到另一个的类的时候，会用自己的类加载器去加载该类，那么就不难理解SPI破坏双亲委托机制了；不过先来了解一下，SPI做了什么&lt;/p&gt;
&lt;p&gt;可以看到我们之前是通过以下代码，来实现SPI的功能的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//      导入类
    import java.util.ServiceLoader;
    
    /**
     * 提供初始化操作，里面使用spi，来发现第三方的接口实现
     */
    private static void angleManagerInit() {
        ServiceLoader&amp;lt;Angle&amp;gt; angleServiceLoader = ServiceLoader.load(Angle.class);
        Iterator&amp;lt;Angle&amp;gt; angleIterator = angleServiceLoader.iterator();
        while(angleIterator.hasNext()) {
//            这里会调用Class.forName(name, init, classloader);
            angleIterator.next();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过打断点，调试，可以发现在angleIterator.next();的时候，会进入到ServiceLoader的匿名内部类Iterator&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常情况下，没有加载过，就会到lookupIterator.next();这个方法也是进入ServiceLoader的另一个内部类，最终会跳转到下面，完成类的加载&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        private S nextService() {
            if (!hasNextService())
                throw new NoSuchElementException();
            String cn = nextName;
            nextName = null;
            Class&amp;lt;?&amp;gt; c = null;
            try {
                c = Class.forName(cn, false, loader);
            } catch (ClassNotFoundException x) {
                fail(service,
                     &quot;Provider &quot; + cn + &quot; not found&quot;);
            }
            if (!service.isAssignableFrom(c)) {
                fail(service,
                     &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
            }
            try {
                S p = service.cast(c.newInstance());
                providers.put(cn, p);
                return p;
            } catch (Throwable x) {
                fail(service,
                     &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
                     x);
            }
            throw new Error();          // This cannot happen
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用了c = Class.forName(cn, false, loader);来进行类的加载，并且实例化了该类S p = service.cast(c.newInstance());，并且加入了缓存中；这里调用的loader是哪里来的呢？&lt;/p&gt;
&lt;p&gt;在ServiceLoader angleServiceLoader = ServiceLoader.load(Angle.class);过程，除了设置了对于api接口，其实也就是对于我们META-INF/services底下的文件名称，还在函数内部获取了线程上下文类加载器，并设置为了loader&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结合之前的结论&quot;&gt;结合之前的结论&lt;/h3&gt;
&lt;p&gt;到这里，基本就清楚了整个流程，首先，ServiceLoader是一个基础类，因为它所在的包名称java.util.ServiceLoader;这个类是使用bootstrap classloader来加载的，你可以在代码中使用获取它的类加载器，会出现空指针，因为bootstrap classloader是c++实现的，java中获取不到这个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServiceLoader.class.getClassLoader().getClass().getName()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而结合我们之前得出的结论，一个类的加载会被使用它的类所属的类价值器加载的话，那么ServiceLoader使用Class.forName(name)来加载类对象，而不是Class.forName(cn, false, loader)指定类加载器加载对象的话，那么就会出现无法找到类对象的问题，因为bootstrap classloader找的路径是JDK\jre\lib，所以就需要使用线程上下文类加载器，通过线程先获取到当前的类加载器，这个加载器具体在什么时候设置进入的话，暂时不清楚，但是可以确定如果没有通过Thread.currentThread().setContextClassLoader();去修改过的话，那么这个类加载器，会是应用程序加载器（application classloader），接下来，如果你的实现类在classpath（引入jar就会包含在这里），就可以被正常加载&lt;/p&gt;
&lt;h3 id=&quot;回顾一下&quot;&gt;回顾一下&lt;/h3&gt;
&lt;p&gt;在《深入理解JVM》这本书中，提过第二次破环是该双亲委托模弊端引起的&lt;/p&gt;
&lt;p&gt;一个例子：JNDI服务，它的代码由启动类加载器加载(在rt.jar中)，但JNDI目的就是对整个程序的资源进行几种管理和查找，需要调用由每个不同独立厂商实现并且部署在应用程序的ClassPath下的JNDI接口提供者的代码。但是在应用启动时候读取rt.jar包时候，是不认识这些三方厂商定义的类的，那么如何解决？&lt;/p&gt;
&lt;p&gt;java设计团队引入了一个新设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时候，还未设置，将会从父线程中继承一个。如果在应用程序全局范围都没有设置，默认是appClassLoader类加载器。&lt;/p&gt;
&lt;p&gt;这次破坏双亲委托并不是通过修改了loadClass方式，而是说对于类加载的行为，我们不是让其使用默认的类加载器，而是显示的指定类加载器加载，并且这个类加载器通过线程上下文加载器来传递的&lt;/p&gt;
&lt;h2 id=&quot;无关的几个问题&quot;&gt;无关的几个问题&lt;/h2&gt;
&lt;h3 id=&quot;是否可以实现一个自己的java.lang.string类&quot;&gt;是否可以实现一个自己的java.lang.String类&lt;/h3&gt;
&lt;p&gt;你可以看到网络上的回答是可能可以，打破类双亲委托的机制，是可能可以进行加载&lt;/p&gt;
&lt;p&gt;首先我们看看如果可以加载进入会发生什么问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先重复加载了String类，虽然这个类是不一样的实现&lt;/li&gt;
&lt;li&gt;假设可以加载进去，那么在类加载过程中，解析的时候，如何将符号引用转化为正确的直接应用呢，现在堆里面有两个全限定名称都堆java.lang.String的类对象，应该指向那一个，而且在进行方法的动态绑定的过程中，自己实现的String类没有对应的方法，就会出现程序异常，不能正常运行了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这么严重的问题，显然是不可能让它发生的，那么java是怎么避免这些问题发生呢&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java在加载以java.或者javax.开头的类，是不让你命名的，如果你这么命名，你编译能过，但是你的这个代码是不由bootstrap classloader加载的，其他类加载器会对这个命名进行检测，抛出异常java.lang.SecurityException: Prohibited package name&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;结论就应该是不可以，其实类加载也只是仅仅只能控制类加载过程个一部分，类加载过程中加载的部分可以细分分为3步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过一个类的全限定名来获取其定义的二进制字节流。&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而classloader.loadClass只可以控制第一点，后面两点都是通过调用defineClass来达成的，这个方法里面，就有对上面提到的包名的检测，并且它最终是调用native方法来实现的，你不能跳过它&lt;/p&gt;
&lt;h3 id=&quot;下面的程序是否可以正常运行&quot;&gt;下面的程序是否可以正常运行&lt;/h3&gt;
&lt;p&gt;这个我在写demo的时候，发生的一个问题，将AngleManager代码修改成如下，然后重新打包，运行程序，就会出现以下错误和空指针的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.util.ServiceConfigurationError: api.Angle: Provider hell.Lucifer could not be instantiated&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package api;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ServiceLoader;

public class AngleManager {
//  新位置
    static {
        System.out.println(&quot;angleManagerInit&quot;);
        angleManagerInit();
    }

    private static int angleIndex = 0;
    private static List&amp;lt;Angle&amp;gt; angles = new ArrayList&amp;lt;Angle&amp;gt;();

    /**
     * 提供注册功能
     * @param angle
     */
    public static void registerAngle(Angle angle){
        angles.add(angle);
    }

    /**
     * 获取一个接口实现
     * @return
     */
    public static Angle angleFall(){
        if(angles.size() &amp;gt; 0 &amp;amp;&amp;amp; angleIndex &amp;lt; angles.size()){
            return angles.get(angleIndex ++);
        }
        return null;
    }

    /**
     * 提供初始化操作，里面使用spi，来发现第三方的接口实现
     */
    private static void angleManagerInit() {
        ServiceLoader&amp;lt;Angle&amp;gt; angleServiceLoader = ServiceLoader.load(Angle.class);
        Iterator&amp;lt;Angle&amp;gt; angleIterator = angleServiceLoader.iterator();
        while(angleIterator.hasNext()) {
//            这里会调用Class.forName(name, init, classloader);
            angleIterator.next();
        }
    }
    
//  旧位置
//    static {
//        System.out.println(&quot;angleManagerInit&quot;);
//        angleManagerInit();
//    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到两次位置的对比，你基本就应该可以猜到发生问题的原因了，这里就不说明了&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>faberry</dc:creator>
<og:description>代码托管在：https://github.com/fabe2ry/classloaderDemo 初始化数据库 如果你写过操作数据库的程序的话，可能会注意，有的代码会在程序的开头，有Class.for</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/faberry/p/10594002.html</dc:identifier>
</item>
<item>
<title>微服务架构 - 解决Docker-Compose服务编排启动顺序问题 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10593396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10593396.html</guid>
<description>&lt;p&gt;基于Docker Compose进行服务编排时，一定碰到服务启动顺序的问题，例如：B服务启动之前，A服务要已经启动并且可以正常对外服务。&lt;/p&gt;
&lt;p&gt;这个启动顺序的问题，Docker Compose本身它是无法解决的，即使定义了depends_on或者links，它只能保证该服务依赖这些服务，启动本服务时会将依赖的服务也启动，但是启动顺序无法得到保证。&lt;/p&gt;
&lt;p&gt;目前本人实验比较好的方案有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于wait-for-it.sh实现，前提条件是本镜像要支持bash&lt;/li&gt;
&lt;li&gt;对于自己构建的镜像时，让工程本身带一个监听类，用于监听依赖服务是否启动，这种方式有侵入性，同时对于第3方的镜像，不太好实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;wait-for-it.sh方案&quot;&gt;1、wait-for-it.sh方案&lt;/h2&gt;
&lt;p&gt;wait-for-it.sh是GitHub中开源一个脚本，很轻量也很实用，以一个例子说明其的法：&lt;/p&gt;
&lt;p&gt;本例子中定义了2个服务，一个mysql服务，一个cs2_serv服务，这个cs2_serv需要等mysql启动好并做好初始化后才能启动，要不然cs2_serv服务会由于没法连接到数据库而报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: &quot;3&quot;
services:
  mysql:
    image: mysql:5.6
    ports:
      - &quot;3306:3306&quot;
    environment:
      - MYSQL_ROOT_PASSWORD=jgyw@123
      - MYSQL_USER=cs2
      - MYSQL_PASS=cs2123
    volumes:
      - ./db/mysql:/var/lib/mysql
      - ./db/init:/docker-entrypoint-initdb.d/

  cs2_serv:
    image: cs2_serv:v1
    ports:
      - &quot;81:81&quot;
    environment:
      - SERV_PORT=81
      - MYSQL_IP=mysql
      - MYSQL_PORT=3306
      - DB_USERNAME=root
      - DB_PASSWORD=jgyw@123
    links:
      - mysql
    volumes:
      - ./wait-for-it.sh:/wait-for-it.sh
    entrypoint: &quot;/wait-for-it.sh -t 0 mysql:3306 -- &quot;
    command:
      - /bin/sh
      - -c
      - |
        sleep 10
        java -Djava.security.egd=file:/dev/./urandom -jar /app.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处最为核心的代码就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    entrypoint: &quot;/wait-for-it.sh -t 0 mysql:3306 -- &quot;
    command:
      - /bin/sh
      - -c
      - |
        sleep 10
        java -Djava.security.egd=file:/dev/./urandom -jar /app.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这2个配置的意思是，要等到mysql:3306服务可以用了，才去执行command对应的命令。&lt;/p&gt;
&lt;p&gt;同时我在commad命令中再增加等待10s钟，主要为了完全确保mysql服务启动完成，还有就是初始化数据库也完成，最后才去启动cs2_serv服务。&lt;/p&gt;
&lt;h2 id=&quot;自定义监听类&quot;&gt;2、自定义监听类&lt;/h2&gt;
&lt;p&gt;这种方式有一定侵入性，但是配置起来会比较方便，在此以Spring Boot为例，写了一个简单的监听类，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.cs2.common.listener;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Map;

import org.apache.log4j.Logger;
import org.springframework.boot.context.event.ApplicationStartingEvent;
import org.springframework.context.ApplicationListener;

/**
 * 依赖服务检查
 */
public class DependsOnServiceCheckListener implements ApplicationListener&amp;lt;ApplicationStartingEvent&amp;gt; {
    private Logger logger = Logger.getLogger(DependsOnServiceCheckListener.class);

    @Override
    public void onApplicationEvent(ApplicationStartingEvent event) {
        // 获取环境变量
        Map&amp;lt;String, String&amp;gt; envs = System.getenv();
        
        // 环境变量中DEPENDS_ON值，即是依赖的服务，值的内容格式为：host1:port1,host2:port2
        if (envs.containsKey(&quot;DEPENDS_ON&quot;)) {
            // 依赖服务是否启动的标志
            boolean flag = false;
            
            String val = envs.get(&quot;DEPENDS_ON&quot;);
            String[] servs = val.split(&quot;,&quot;);
            
            while (!flag) {
                try {
                    Thread.sleep(5000L);
                } catch (InterruptedException e) {
                    logger.warn(&quot;Wait depends on Service started...&quot;);
                }
                
                for (String serv : servs) {
                    flag = checkServ(serv);
                    if (!flag) {
                        break;
                    }
                }
            }
            
            logger.info(&quot;Depends on Service started...&quot;);
        }
    }
    
    /**
     * 检查服务是否启动
     * 
     * @param serv
     * @return
     */
    private boolean checkServ(String serv) {
        String[] servs = serv.split(&quot;:&quot;);
        String host = servs[0].trim();
        int port = Integer.parseInt(servs[1].trim());
        
        Socket socket = null;
        try {
            socket = new Socket();
            socket.connect(new InetSocketAddress(host, port));
            logger.info(serv + &quot;: Service started...&quot;);
            return true;
        } catch (Exception e) {
            logger.warn(serv + &quot;: Service not started...&quot;);
            return false;
        } finally {
            if (socket != null) {
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个监听类，是将依赖的服务信息放到环境变量DEPENDS_ON中，即是依赖的服务，值的内容格式为：host1:port1,host2:port2，然后每隔5s去测试依赖的服务是否是通的，如果所有依赖的服务都是通的，那么本服务就可以启动，否则本服务一直处于等待状态。&lt;/p&gt;
&lt;p&gt;以一个实例说明使用方式，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  cs2_web:
    image: cs2_web:v1
    ports:
      - &quot;82:82&quot;
    environment:
      - WEB_PORT=82
      - SERV_DOMAIN=cs2_serv
      - DEPENDS_ON=cs2_serv:81
    links:
      - cs2_serv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了一个cs2_web服务，该服务是依赖上面例子中的cs2_serv，但是它配置依赖关系是通过环境变量DEPENDS_ON来配置的。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;3、参考资料&lt;/h2&gt;
&lt;p&gt;https://github.com/vishnubob/wait-for-it&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201903/840503-20190325140239920-1600886974.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 06:03:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>基于Docker Compose进行服务编排时，一定碰到服务启动顺序的问题，例如：B服务启动之前，A服务要已经启动并且可以正常对外服务。 这个启动顺序的问题，Docker Compose本身它是无法解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10593396.html</dc:identifier>
</item>
<item>
<title>测试用例是开发人员最后一块遮羞布 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/10593309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/10593309.html</guid>
<description>&lt;p&gt;最近一周写一个比较复杂的业务模块，越写到后面真心越心虚。操作越来越复杂了，代码也逐渐凌乱了起来。比如一个接口，传入的是一个比较复杂的大json，我需要解析这个大json，然后根据json中字段进行增删改查，调用第三方服务等操作。告诉前端接口已经完成的时候，总是有点没有底气。说实话，在写PHP的时候，我确实很少写单元测试，大都是对着页面进行一波一波的测试，现在想想，一个是懒，还有一个是确实PHP是不需要编译的语言，没有编译时间，测试-修正，整个流程非常短。但是这次是一个比较大的GoLang项目，如果还是按照“编译-起服务-调用-调整代码-编译-起服务-调用-...” 这种循环来做调试，真是会疯了的。所以我能静下心好好研究研究如何写Golang的单元测试了。&lt;/p&gt;

&lt;p&gt;这个是第一个需要思考的问题。这个问题和语言无关。一旦有数据库操作，就需要考虑如何在测试用例中如何处理数据库操作。我想了想，无外乎两种做法，一种是直接mock数据库的返回对象。另外一种，是搭建一个测试DB，然后灌入假数据，进行测试。这两种方式我选择了后一种。有几个理由：首先，mock数据库返回数据是一个比灌入DB数据更为复杂的逻辑，数据库返回的数据根据sql各种各样，要想在每个环节都写好数据库操作返回，倒不如我直接伪造一些数据来的方便。其次，mock数据库返回会丢失model层的测试逻辑，当然如果你是轻model层，整个model就只有一个orm，这个可能就不是理由了。&lt;/p&gt;
&lt;p&gt;所以，我操作的第一步，从线上把数据库表结构copy一份到我本地vagrant的mysql中。&lt;/p&gt;
&lt;p&gt;这里必须要注意，你的测试数据库和测试代码最好是同一个机器上，否则每跑一个测试用例，消耗的时间非常大，你的测试体验也不会太好。&lt;/p&gt;

&lt;p&gt;我的代码逻辑中也有一些第三方调用，调用其他服务。当然这里也有同样的两种办法，一种是直接在本地测试环境搭建第三方服务，另外一种是mock第三方服务的返回数据。这里我选择了mock数据的方式。基本想法是因为我这个测试毕竟不是一种全链路测试，测试的主体还是我的服务，我的服务基本上只包含服务+DB，如果要搭建第三方服务，这就有点舍本逐末的感觉了。&lt;/p&gt;
&lt;p&gt;好了，如何mock第三方服务呢？&lt;/p&gt;
&lt;p&gt;查了下golang中mock的包有两个比较出名，一个是golang官网出品的golang/mock，另外一个是monkey（&lt;a href=&quot;https://github.com/bouk/monkey&quot; class=&quot;uri&quot;&gt;https://github.com/bouk/monkey&lt;/a&gt;）。两个相比之下，我感觉golang/mock是师出有名，但是不如monkey好用，monkey属于黑科技，使用修改函数指针的方式进行mock函数。我想了想，实用第一位，投入了monkey的怀抱。&lt;/p&gt;
&lt;p&gt;基本使用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// mock路网接口
guard := monkey.Patch(lib.Curl, func(trace *lib.TraceContext, CurlType, urlString string, data url.Values, addToken bool) ([]byte, error) {
  return []byte(&quot;{[\&quot;10010\&quot;:\&quot;后厂村路\&quot;}&quot;]), nil
})
defer guard.Unpatch()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将lib.Curl整个函数给mock了，并且在函数结束后修改mock的函数，保证不影响其他测试用例。&lt;/p&gt;

&lt;p&gt;web服务一般都会有读取配置的代码，我的服务是读取一个参数config=base.json来进行配置的读取的。go test中是没有办法给test的代码传递参数的，（我看网上的一些文章说有个-args的参数，但是我在go1.11版本中确实没有看到这个参数）。于是我只能选择使用环境变量的方式。在运行go test的时候，在最开头的部分设置下当前这个go test的环境变量CONFIG_PATH，然后修改下我的初始化配置文件的代码，允许传入参数进行配置文件的读取。&lt;/p&gt;
&lt;p&gt;大概代码如下：&lt;/p&gt;
&lt;p&gt;在运行go test的时候设置环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONFIG_PATH=/home/vagrant/foo/conf/yejianfeng/base.json go test foo/signaledit/... -v -test.run TestGetGroups&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试环境的初始化配置文件逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package test

import (
    ..
)

var HasSetup = false

// signalEdit初始化，只调用一次
func SetUpSignalEdit() {
    if HasSetup == false {
        gin.SetMode(gin.TestMode)

        confPath := os.Getenv(&quot;CONFIG_PATH&quot;) // 获取环境变量
        commonlib.Init(confPath, &quot;&quot;)    // 初始化配置文件
        conf.ParseLocalConfig()
        db.InitDB()

        HasSetup = true
    }

    DestroyTestData(db.EditDB)
    CreateTestData(db.EditDB)
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于这个，httptest这个包提供给我们想要的逻辑了，网上的文章也一大堆了。使用起来也是很方便，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;router := gin.New()
jc := Controller{}
// 灯组模型表获取信息
router.GET(&quot;/group/all&quot;, jc.GroupAll)
...
//构建返回值
w := httptest.NewRecorder()
//构建请求
r, _ := http.NewRequest(&quot;GET&quot;, &quot;/group/all?logic_junction_id=test_junction&quot;, nil)
//调用请求接口
router.ServeHTTP(w, r)

resp := w.Result()
body, _ := ioutil.ReadAll(resp.Body)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就没有什么好说的了。&lt;/p&gt;

&lt;p&gt;既然我选择使用本地DB进行测试，那么按照逻辑，需要在测试用例开始初始化DB数据，然后在测试用例结束后销毁数据。这里我还选择在测试用例开始的时候，先销毁数据，然后初始化数据，测试用例结束的时候不要销毁数据。这样做我承认有不好的地方，就是有可能会有脏数据。比较好的地方，就是我在单个测试用例跑完的时候，我有机会去数据库看一眼现在数据库里面的测试数据是什么样子。&lt;/p&gt;
&lt;p&gt;不管怎么洋，数据初始化和销毁的工作就变得异常重要了，它们必须是幂等，而且可以循环幂等。（销毁-初始化）=（销毁-销毁-初始化）=（初始化-销毁-初始化）。要做到这个我的感受必须借助具体的业务数据表逻辑了。比如我的所有数据表都有一个路口id的字段，那么我就很容易做到销毁的幂等，我每次销毁的时候，就只要把这个路口的所有数据删除就可以了。如果没有的话，由于我们的数据库是本地数据库，不妨采用整个数据表清空的方式操作。&lt;/p&gt;
&lt;p&gt;数据初始化和销毁的函数我封装成两个函数，放在一个包里面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var (
    SignalID        = int64(999999)
    LogicJunctionId = &quot;test_junction&quot;
)

// 创建测试数据
func CreateTestData(db *gorm.DB) {

    // SignalInfo表创建一条数据
    signalInfo := &amp;amp;models.SignalInfo{}
    signalInfo.Id = SignalID
    signalInfo.Name = &quot;测试路口id&quot;
    signalInfo.LogicJunctionId = LogicJunctionId
    signalInfo.Status = 1
    db.Create(signalInfo)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 销毁测试数据
func DestroyTestData(db *gorm.DB) {

    db.Delete(&amp;amp;models.SignalInfo{}, &quot;logic_junctionid=&quot; + LogicJunctionId)

  ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把上面说的初始化操作封装成一个函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var HasSetup = false

// signalEdit初始化，只调用一次
func SetUpSignalEdit() {
    if HasSetup == false {
        gin.SetMode(gin.TestMode)
        confPath := os.Getenv(&quot;CONFIG_PATH&quot;)
        commonlib.Init(confPath, &quot;&quot;)
        conf.ParseLocalConfig()
        db.InitDB()

        HasSetup = true
    }
    DestroyTestData(db.EditDB)
    CreateTestData(db.EditDB)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有测试用例都先调用下这个函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func TestGetGroups(t *testing.T) {
    test.SetUpSignalEdit()
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里真心要吐槽下testing框架，既然做了测试框架，SetUp函数，SetDown函数这些都不考虑，和主流的测试框架的思想真的有点偏差，导致像这种“普通”的初始化的需求都要自己写方法来绕过，至少testing框架为应用思考的东西还是太少了。&lt;/p&gt;

&lt;p&gt;我一直知道写好测试用例是一个难度不亚于开发的工作。测试用例有粒度问题，我觉得，测试用例的粒度宜大不宜小。我这个项目是controller-service-mmodels架构，controller一个函数就是一个接口，service一个函数是一个通用性比较高的服务，model是比较瘦的model，基本只做增删改查。在我这个架构中，我写的测试用例粒度大多数是controller级别的，有少数是service级别的，model级别的测试用例基本没有。&lt;/p&gt;
&lt;p&gt;测试用例粒度大一些，有个明显的好处，就是对需求的容忍度高了很多。一般测试用例最痛的就是需求一旦修改了，我的业务逻辑就修改了，我的测试用例也要跟着修改。修改测试用例是很痛苦的事情。所以如果测试用例足够大，比如和接口一样大，那么基本上，由于业务接口的兼容性要求，我们的测试用例的输入输出一般不会进行大的变动（虽然里面的service或者model会进行比较大的变动）。这样有一些需求变化了之后，我甚至不需要修改任何测试用例的代码就可以。&lt;/p&gt;
&lt;p&gt;当然有的测试用例粒度太大，一些小的分支可能就测试不到，或者很难构建测试数据，所以有的时候，还是需要一写稍微小一点的粒度的测试用例。&lt;/p&gt;
&lt;p&gt;另外对于不需要依赖测试数据的类库函数，如果你对这个类库函数的输入输出的需求变更有把握控制的话，（你需要对自己的这个判断负责）这种类库函数的测试用例则是越细越好。&lt;/p&gt;

&lt;p&gt;说说写测试用例的一些原则性的东西。&lt;/p&gt;
&lt;h2 id=&quot;检验逻辑抗需求变更能力越强越好&quot;&gt;检验逻辑抗需求变更能力越强越好&lt;/h2&gt;
&lt;p&gt;首先，测试用例的检验逻辑不是越全越好，而且有很多技巧。比如一个插入的接口，你测试是否插入成功，有很多时候，你根据判断插入条数是否多一条会比你判断这个插入条数的所有字段是否是你要求的更好。原则还是那个，测试用例的抗需求变更能力会更高，首先基本上如果我的插入逻辑很简单，那么插入成功就约等于插入的每个字段都满足，当然这里是约等于，但是因为业务代码也是我自己写的，心里这个B数还是有的。然后，如果一旦需求变更我这个数据多了一个字段，那么我这个测试用例基本不需要做任何修改就还可以继续跑起来。&lt;/p&gt;
&lt;p&gt;再次强调下，这里的约等于的判断就是看你对你业务代码的感觉了。&lt;/p&gt;
&lt;h2 id=&quot;并不是所有的错误都需要完美处理&quot;&gt;并不是所有的错误都需要完美处理&lt;/h2&gt;
&lt;p&gt;测试代码毕竟不像业务代码那么需要完美的严谨，所有的panic都是欢迎的。换句话说，我们业务代码基本上对所有error都需要有所处理，但是测试用例并不一定了。如果我在上一行代码中没有处理这个error，那么我传递给下一行的参数很可能就是nil，很有可能在下一行代码中直接panic了一个错误出来。这个也能让我发现我的错误。&lt;/p&gt;
&lt;p&gt;所以，测试用例并不需要写那么严谨，有的地方直接panic错误也是一个很好的选择。&lt;/p&gt;
&lt;h2 id=&quot;fatal和error的选择&quot;&gt;Fatal和Error的选择&lt;/h2&gt;
&lt;p&gt;基本上我觉得Error没啥用，我目前的测试用例都要求所有的判断节点都跑成功，任何一个地方失败了，直接就报错进行调试。我的精力也不允许我一次性能处理多个错误case，基本上调试失败的测试用例是一个个调试的，所以error并没有什么用。&lt;/p&gt;
&lt;p&gt;这点纯粹我个人观点，估计会有很多人不同意。&lt;/p&gt;
&lt;h2 id=&quot;检验逻辑多用变量&quot;&gt;检验逻辑多用变量&lt;/h2&gt;
&lt;p&gt;检验逻辑尽量少用 response.Name == &quot;测试路口&quot; 这种代码，能尽量找到替换&quot;测试路口&quot; 这个的变量尽量使用变量，同样的理由，测试用例的抗需求变更能力会更高。&lt;/p&gt;

&lt;p&gt;测试用例是开发人员最后一块遮羞布，写Golang的代码和写PHP的代码确实体验完全不一样，在Golang代码中，首先写测试用例异常方便了。其次，Golang的调试成本远远高于PHP，写测试用例看起来是浪费时间，实际上是节省你的调试时间。最后，golang代码的每次重构（增加一个字段，少一个字段）影响的文件数远远高于PHP，如果没有这块遮羞布，你怎么确保你的代码修改后还能正常运行呢？&lt;/p&gt;
&lt;p&gt;Just Testing！&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 05:49:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>测试用例是开发人员最后一块遮羞布 最近一周写一个比较复杂的业务模块，越写到后面真心越心虚。操作越来越复杂了，代码也逐渐凌乱了起来。比如一个接口，传入的是一个比较复杂的大json，我需要解析这个大jso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/10593309.html</dc:identifier>
</item>
<item>
<title>大数据技术 - 分布式文件系统 HDFS 的设计 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/10588516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/10588516.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章内容介绍下 Hadoop 自带的分布式文件系统，HDFS 即 Hadoop Distributed Filesystem。HDFS 能够存储超大文件，可以部署在廉价的服务器上，适合一次写入多次读取的场景。但 HDFS 不适合低延迟，存储大量小文件以及修改文件内容的场景。HDFS 应用比较广泛，如：MR任务、Spark任务、Hive 数据仓库以及 Hbase 数据库，它们的底层存储都可以基于 HDFS 。本章将介绍 HDFS 集群的架构设计以及相关的重要概念。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;HDFS的设计以及概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;HDFS集群是典型的 master/slave 架构，master 节点叫做 NameNode，salve 节点叫做 DataNode。最简单的 HDFS 集群便是一个 NameNode 节点和多个 DataNode 节点，HDFS 集群的架构图如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201903/1129006-20190324155428900-643902365.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Block&lt;/strong&gt;：数据块，HDFS 集群将存储的文件划分为多个分块，块作为独立的存储单元，默认大小为为 128M。如果某个文件超过集群单机存储容量，分块可以解决该问题；其次按照块进行存储、备份能简化系统的设计。默认块大小修改 hdfs-site.xml 文件中的 dfs.blocksize 配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;NameNode&lt;/strong&gt;：HDFS 集群的 Master 节点，维护集群文件的目录结构（命名空间）和编辑日志文件，同时在内存中记录文件各个块所在的数据节点的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DataNode&lt;/strong&gt;：HDFS 集群的 Slave 节点，负责存储实际的数据。根据需要存储和检索数据块，并定期向 NameNode 发送他们所存储的数据块列表。为了实现数据存储的高可靠，HDFS 将一个块存储在不同的 DataNode 节点， 默认是 3 个，可以通过 hdfs-site.xml 文件中的 dfs.replication 配置修改默认值。如果当前 DataNode 中的数据块损坏， 可以从其他 DataNode 节点复制一个正确的数据块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是架构图中显而易见的几个重要概念，接下来将结合架构设计中的高可用、可扩展性来介绍下架构图中隐藏的几个重要概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联邦 HDFS&lt;/strong&gt;：这个主要是为了解决可扩展性的问题，我们知道 NameNode 进程的内存中存放了数据与数据位置的对应关系，对于一个文件数据量多的集群来说，NameNode 的内存将成为集群规模扩大的瓶颈。因此，单一 NameNode 的集群并不可取。Hadoop 2.x 的发行版引入了联邦 HDFS 允许向集群中添加 NameNode 节点实现横向扩展。每一个 NameNode 管理命名空间中的一部分，每个 NameNode 维护一个命名空间卷（namespace volume），命名空间卷之间相互独立，一个 NameNode 失效不会影响其他 NameNode 维护的命名空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HDFS HA&lt;/strong&gt;： 这个解决高可用，即 HDFS High Available。这一实现中配置了一对活动-备用（active-standby）NameNode。当活动的 NameNode 失效，备用 NameNode 会接管相应的任务，这一过程对用户透明。实现这一设计，需要在架构上做如下修改：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. HA 的两个 NameNode 之间通过高可用共享存储实现编辑日志的共享，目的是为了能够使备用 NameNode 接管工作后实现与主 NameNode 状态同步。QJM（日志管理器，quorum journal manager）是为提供一个高可用的日志编辑而设计的，被推荐用于大多数 HDFS 集群中。QJM 以一组日志节点的形式运行，一般是 3，每一次编辑必须写入多数日志节点，因此系统可以忍受任何一个节点丢失，日志节点便是 JournalNode。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. DataNode 需要同时向 2 个 NameNode 发送数据报告，因为数据块的映射信息存储在 NameNode 的内存中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 客户端需要处理 NameNode 失效的问题，对用户透明&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;HDFS的基本操作&lt;/h2&gt;
&lt;h3&gt;命令行接口&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令行接口操作 HDFS 是最简单、最方便的方式。HDFS 的命令与 Linux 本地命令非常相似，可以通过 hadoop fs help 命令查看 HDFS 所支持所有命令，接下来介绍下常用的命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
hadoop fs -put &amp;lt;localsrc&amp;gt; &amp;lt;dst&amp;gt;&lt;span&gt; #将本地文件上传至 HDFS
hadoop fs &lt;/span&gt;-&lt;span&gt;ls&lt;/span&gt; &amp;lt;path&amp;gt;&lt;span&gt; # 与 Linux ls命令类似
hadoop fs &lt;/span&gt;-&lt;span&gt;cat&lt;/span&gt; &amp;lt;src&amp;gt;&lt;span&gt; #查看 HDFS 文件数据
hadoop fs &lt;/span&gt;-text &amp;lt;path&amp;gt; # 同 &lt;span&gt;cat&lt;/span&gt; 命令， 可以看 SequenceFile、压缩文件&lt;br/&gt;hadoop fs -rm &amp;lt;src&amp;gt; # 删除 HDFS 文件或目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是比较常用的 HDFS 命令，查看帮助文档可以在每个命令上增加一些命令行选项，输出不同的信息。以 ls 命令为例，看一下 HDFS 输出的文件信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hadoop fs -&lt;span&gt;ls&lt;/span&gt; /hadoop-ex/wordcount/input
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
-rw-r--r--   3 root supergroup         32 2019-03-03 01:34&lt;span&gt; /hadoop-ex/wordcount/input/words
-rw-r--r--   &lt;/span&gt;3 root supergroup         28 2019-03-03 01:46 /hadoop-ex/wordcount/input/words2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以发现输出的内容与 Linux 下 ls 命令类似。第 1 部分显示文件类型与权限，第 2 部分是副本数量 3，第 3 、4部分是所属的用户和用户组，第 5 部分是文件大小，若是目录则为 0 ，第 6、7 部分是文件的修改日期和时间，第 8 部分是文件的路径和名称。 在 HDFS 中有个超级用户，即 启动 NameNode 的用户。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Java 接口&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;相对于命令行接口，Java接口更加灵活，更强大。但用起来不是很方便，一般可以在 MR 或者 Spark 任务中使用 Java 接口读取 HDFS 上的数据。本章仅举一个读取 HDFS 文件数据的例子介绍一下 Java 接口的使用方式，主要使用 FileSystem API 来实现，更具体和更多的使用方法读者可以自行查阅。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs.duma.hdfs;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.FileSystem;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.Path;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.io.IOUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileSystemEx {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        Configuration conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; uri 便是 core-site.xml 文件中 fs.defaultFS 配置的值&lt;/span&gt;
        FileSystem fs = FileSystem.get(URI.create(&quot;hdfs://hadoop0:9000&quot;&lt;span&gt;), conf);
        InputStream in &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定打开的文件&lt;/span&gt;
            in = fs.open(&lt;span&gt;new&lt;/span&gt; Path(&quot;/hadoop-ex/wordcount/input/words&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输入流拷贝到标准输出流&lt;/span&gt;
            IOUtils.copyBytes(in, System.out, 4096, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭输入流&lt;/span&gt;
&lt;span&gt;            IOUtils.closeStream(in);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本章主要介绍了 HDFS 的架构设计和一些重要的概念，这些设计上的东西可能对我们自己设计架构或者写代码会有帮助。所以，学习一个框架不光会用，更要注重他的架构设计，以及跟其他架构对比的优缺点，这对我们以后的成长有很大的帮助。最后花了少量篇幅介绍了 HDFS 的基本操作，这方便文档比较全，并且并不复杂，因此没有详细的介绍。个人认为 HDFS Java 接口应用场景相对有限，日后跟 HDFS 打交道更多的可能还是命令行接口。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 05:37:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>本章内容介绍下 Hadoop 自带的分布式文件系统，HDFS 即 Hadoop Distributed Filesystem。HDFS 能够存储超大文件，可以部署在廉价的服务器上，适合一次写入多次读取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duma/p/10588516.html</dc:identifier>
</item>
<item>
<title>JavaScript构造函数 - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10593242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10593242.html</guid>
<description>&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;不同于其他强类型语言，没有类的概念，但是它支持可以与实例共同使用特殊的&lt;code&gt;Constructor&lt;/code&gt;构造器，使用new关键字创建新的实例，并告知&lt;code&gt;JavaScript&lt;/code&gt;使用对象的内规则去定制这个实例。实际上实例中的&lt;code&gt;this&lt;/code&gt;指向的是新的实例。&lt;/p&gt;
&lt;p&gt;典型的面向对象编程语言如&lt;code&gt;java&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;都存在类（&lt;code&gt;class&lt;/code&gt;）的概念，在&lt;code&gt;javaScript&lt;/code&gt;使用&lt;code&gt;Object&lt;/code&gt;对象，其实在&lt;code&gt;javaScript&lt;/code&gt;就是一堆对象在用来用去。&lt;/p&gt;
&lt;p&gt;如果你还不知道，&lt;code&gt;javaScript&lt;/code&gt;函数可以兼作对象构造函数。例如，要编写面向对象编程中的类，可以写成下面这种代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name){
    this.name = name;
}
let Aaron = new Person(&quot;Aaron&quot;);
let Angie = new Person(&quot;Angie&quot;)
console.log(Angie instanceof Person); //  true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的输出结果可以得出&lt;code&gt;Angie&lt;/code&gt;确实是属于&lt;code&gt;Person&lt;/code&gt;这个构造函数的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造函数优/缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;javaScript&lt;/code&gt;创建对象的方式有很多，通过&lt;code&gt;Object&lt;/code&gt;构造函数或对象字面量的方式也可以创建单个对象。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码结构清晰，便于维护&lt;/li&gt;
&lt;li&gt;可以利用构造函数模拟&lt;code&gt;class&lt;/code&gt;做的事&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源浪费，每个对象都有其对应的属性，在&lt;code&gt;new&lt;/code&gt;构造函数的时候，那么需要为每个属性单独开辟空间，存放属性。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;构造函数与普通函数的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;构造函数使用new关键字调用；普通函数不用&lt;code&gt;new&lt;/code&gt;关键字调用&lt;/li&gt;
&lt;li&gt;构造函数内部可以使用&lt;code&gt;this&lt;/code&gt;关键字；普通函数内部不建议使用&lt;code&gt;this&lt;/code&gt;，因为这时候&lt;code&gt;this&lt;/code&gt;指向的是&lt;code&gt;window&lt;/code&gt;全局对象，这样无意间就会为&lt;code&gt;window&lt;/code&gt;添加了一些全局变量或函数&lt;/li&gt;
&lt;li&gt;构造函数默认不用&lt;code&gt;return&lt;/code&gt;返回值；普通函数一般都有&lt;code&gt;return&lt;/code&gt;返回值&lt;/li&gt;
&lt;li&gt;构造函数首字母建议大写；普通函数首字母建议小写&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;关于new&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上文中的&lt;code&gt;Person&lt;/code&gt;()函数举个栗子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个空对象。&lt;code&gt;var Person={}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将构造函数&lt;code&gt;Person()&lt;/code&gt;中的this指向新创建的对象&lt;code&gt;Aaron&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将Aaron的_proto_属性指向&lt;code&gt;Person&lt;/code&gt;函数的prototype，创建对象和原型间关系&lt;/li&gt;
&lt;li&gt;执行构造函数&lt;code&gt;Person()&lt;/code&gt;内的代码。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;创建对象的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第一种&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var Person = new Object();
Person.name = 'Nike';
Person.age = 29;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二种&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var Person = {
 name:'Nike'，
 age:29
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三种&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Object.defineProperty(objName,&quot;key&quot;,{
    // 能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
    configurable:false,
    // 对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    enumerable:false,
    // 对象属性是否可修改,flase为不可修改，默认值为true
    writable:false,
    // 对象属性的默认值，默认值为undefined
    value:'Aaron' 
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四种&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Object.defineProperties(objName,{
    &quot;a&quot;:{
        value:&quot;value&quot;,
        writable:true
    },
    &quot;b&quot;:{
        value:&quot;value&quot;,
        writable:true
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建构造函数的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方法最简单的一种方法，使用&lt;code&gt;object&lt;/code&gt;对象，在函数中最后返回。我们可能经常说的一句话就是，没对象，没对象，没对象，没对象你&lt;code&gt;new&lt;/code&gt;一个呀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象怎么办呢？那要是一个个的定义，就会产生大量的代码，何不建个工厂，批量的生产出我们的对象呢，然后就有了工厂模式，通过一个工厂来达到我们想要的目的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 工厂模式
function createPerson(name, job) {
  var o = new Object()
  o.name = name
  o.job = job
  o.sayName = function() {
    console.log(this.name)
  }
  return o
}
var person1 = createPerson(‘Jiang’, ‘student’)
var person2 = createPerson(‘X’, ‘Doctor’)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以无数次调用这个工厂函数，每次都会返回一个包含两个属性和一个方法的对象，工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别问题，即不能知道一个对象的类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工厂模式解决了多个相似对象的创建问题，但是问题又来了，然而这些对象是使用&lt;code&gt;object&lt;/code&gt;对象来实现的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name, job) {
  this.name = name
  this.job = job
  this.sayName = function() {
    console.log(this.name)
  }
}
var person1 = new Person(‘Jiang’, ‘student’)
var person2 = new Person(‘X’, ‘Doctor’)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有显示的创建对象，使用&lt;code&gt;new&lt;/code&gt;来调用这个构造函数，使用&lt;code&gt;new&lt;/code&gt;后会自动执行如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;这个新对象会被执行&lt;code&gt;prototype&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个新对象会绑定到函数调用的&lt;code&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回这个对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当你去&lt;code&gt;new&lt;/code&gt;一个构造函数的时候，该函数不在默认返回&lt;code&gt;undefined&lt;/code&gt;，而是把&lt;code&gt;this&lt;/code&gt;做为默认值&lt;code&gt;return&lt;/code&gt;出去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;person1 instanceof Object // true
person1 instanceof Person //true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们创建一个函数时，该函数就会具备一个&lt;code&gt;prototype&lt;/code&gt;属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。&lt;/p&gt;
&lt;p&gt;所有的对象都有一个原型对象&lt;code&gt;prototype&lt;/code&gt;，原型对象中有一个&lt;code&gt;constructor&lt;/code&gt;属性指向包含&lt;code&gt;prototype&lt;/code&gt;属性的函数，当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。&lt;/p&gt;
&lt;p&gt;在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person() {
}
Person.prototype = {
  name: ‘jiang’,
  job: ‘student’,
  sayName: function() {
    console.log(this.name)
  }
}
var person1 = new Person()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。&lt;/p&gt;
&lt;p&gt;将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。&lt;/p&gt;
&lt;p&gt;不过这种方式还是不够好，应为&lt;code&gt;constructor&lt;/code&gt;属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，&lt;code&gt;Object.defineProperty&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Object.defineProperty(Person.prototype, ‘constructor’, {
  enumerable: false,
  value: Person
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法四&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是使用最为广泛、认同度最高的一种创建自定义类型的方法。它可以解决上面那些模式的缺点。&lt;/p&gt;
&lt;p&gt;在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。&lt;/p&gt;
&lt;p&gt;使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
  this.name = name
  this.friends = [‘Shelby’, ‘Court’]
}
Person.prototype.sayName = function() {
  console.log(this.name)
}
var person1 = new Person()
var person2 = new Person()
person1.friends.push(‘Van’)
console.log(person1.friends)  //[“Shelby”, “Court”, “Van”]
console.log(person2.friends) // [“Shelby”, “Court”]
console.log(person1.friends === person2.friends) //false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法五&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name, job) {
  // 属性
  this.name = name
  this.job = job
  // 方法
  if(typeof this.sayName !== ‘function’) {
    Person.prototype.sayName = function() {
       console.log(this.name)
    }
  }
}
var person1 = new Person(‘Jiang’, ‘Student’)
person1.sayName()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有在&lt;code&gt;sayName&lt;/code&gt;方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 05:32:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>`JavaScript Constructor JavaScript this`指向的是新的实例。 典型的面向对象编程语言如 和`C++ class javaScript Object javaScr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10593242.html</dc:identifier>
</item>
<item>
<title>一个配置引发的血案 - 鱼天翱</title>
<link>http://www.cnblogs.com/fishsky/p/10593233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fishsky/p/10593233.html</guid>
<description>&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一个配置引发的血案，记一次线上事故的复盘。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一天晚上的业务高峰期，出现了超时（数据加载不出来的情况）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;联想到前一天有发版的工作，第一功能上并没有太大的调整，此次发版内容更多的是新增的功能，用户使用量也较少，基本可以排除因功能导致的问题；第二是否中间件出现问题，因数据的交互，有80%是和redis交互，从慢日志查询中未发现有异常情况；第三隐约有人说过用于负载的服务，昨天发版关闭掉了一台。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过netstat -an |grep 'ESTABLISHED' |grep -i 'port' |wc -l,可查看连接数的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;从上面的命令查看到当台服务已经到了瓶颈，然后立即从配置中查看，确实只有一台对外在运行着的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;处理方法：立即启动另外一个服务，修改配置后，验证。业务已正常运行。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;和昨晚参与发版的人员核对，昨晚关闭掉一台负载的原因。说是因为启动两台时，出现新加的功能，调用新的服务会出现报错的情况。因未找到原因，和运维沟通后，最后决定只起一台服务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;听完说明后，第一个联想到的就是配置的ip和端口是否正常? 一看配置，ip是本地IP，问题已定位。修改本地IP为域名，功能正常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;此次事件，有多个环节可避免掉此事件。结果各个环节上的疏漏，导致了此次事件的发生。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一、上生产环境的IP配置，统一采用域名的方式。这个是约定，因开发人员不清楚线上域名的情况，未能执行好。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二、运维是部署线上环境的第一人，各服务运行在那台对应的机子上，是最为清楚的一个人，对配置的检查，需要把好最后一道岗。因习惯，未对新增的配置进行审查。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;三、对于此次问题的处理，在一定程度上也是可行的方案。但是缺少了数据的支持，未做好测试、评估的工作。在用此方案处理后，未及时反馈给相关人员。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;四、对线上运行环境有一定了解的技术（开发）人员未在场。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于以上问题，解决的方法有很多种。但方法是对于特定问题，而提出的解决方案，是针对特定的场景和特定的人的，对于场景和人的依赖性比较大。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;有没有什么其他方式可以采用呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将方法上升到流程规范，让它具有一定的普适性，有具体的步骤或标准，让每个人都可以执行。减少对人的依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一、上面的问题，规范上加上明确的说明（可增加上线检查清单），生产环境只能采用域名的方式。开发人员或运维人员，其中一人都可以排除此问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二、对线上环境的调整，需要根据数据（业务高峰期的访问量等指标）进行评估、验证，才能进行调整。调整后需要通知（反馈）给相关人员。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;流程规范，是可以提高团队效率的。 从个体来看，因为流程规范的存在，可能存在效率降低的情况，但从团队的角度来看，好的流程规范是可以提高效率的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上面的问题，通过制定的规范去避免，执行得当，是可以提高效率的。多一步的检查，却少了线上问题的出现，也减少了其他人员排查定位的时间，可谓一举多得。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 25 Mar 2019 05:31:00 +0000</pubDate>
<dc:creator>鱼天翱</dc:creator>
<og:description>一个配置引发的血案，记一次线上事故的复盘。 一天晚上的业务高峰期，出现了超时（数据加载不出来的情况）。 联想到前一天有发版的工作，第一功能上并没有太大的调整，此次发版内容更多的是新增的功能，用户使用量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fishsky/p/10593233.html</dc:identifier>
</item>
<item>
<title>推荐：这才是你寻寻觅觅想要的 Python 可视化神器 - lemonbit</title>
<link>http://www.cnblogs.com/lemonbit/p/10593188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lemonbit/p/10593188.html</guid>
<description>&lt;p&gt;Plotly Express 是一个新的高级 Python 可视化库：它是 Plotly.py 的高级封装，它为复杂的图表提供了一个简单的语法。 受 Seaborn 和 ggplot2 的启发，它专门设计为具有简洁，一致且易于学习的 API ：只需一次导入，您就可以在一个函数调用中创建丰富的交互式绘图，包括分面绘图（faceting）、地图、动画和趋势线。 它带有数据集、颜色面板和主题，就像 Plotly.py 一样。Plotly Express 完全免费：凭借其宽松的开源 MIT 许可证，您可以随意使用它（是的，甚至在商业产品中！）。 最重要的是，Plotly Express 与 Plotly 生态系统的其他部分完全兼容：在您的 Dash 应用程序中使用它，使用 Orca 将您的数据导出为几乎任何文件格式，或使用JupyterLab 图表编辑器在 GUI 中编辑它们！&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;pip install plotly_express&lt;/code&gt; 命令可以安装 Plotly Express。&lt;/p&gt;
&lt;h2 id=&quot;使用-plotly-express-轻松地进行数据可视化&quot;&gt;使用 Plotly Express 轻松地进行数据可视化&lt;/h2&gt;
&lt;p&gt;一旦导入Plotly Express（通常是 &lt;code&gt;px&lt;/code&gt; ），大多数绘图只需要一个函数调用，接受一个整洁的Pandas dataframe，并简单描述你想要制作的图。 如果你想要一个基本的散点图，它只是&lt;code&gt;px.scatter（data，x =“column_name”，y =“column_name”）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下是 内置的 Gapminder 数据集 的示例，显示2007年按国家/地区的人均预期寿命和人均GDP 之间的趋势：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import plotly_express as px

gapminder = px.data.gapminder()
gapminder2007 = gapminder.query('year == 2007')
px.scatter(gapminder2007, x='gdpPercap', y='lifeExp')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/large/007EIIJlgy1g1arb3tfq0j30m80f8758.jpg&quot; alt=&quot;image01&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你想通过大陆区分它们，你可以使用 &lt;code&gt;color&lt;/code&gt; 参数为你的点着色，由 &lt;code&gt;px&lt;/code&gt; 负责设置默认颜色，设置图例等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/007EIIJlgy1g1arbyq4pbj30m80dldgq.jpg&quot; alt=&quot;image02&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的每一点都是一个国家，所以也许我们想要按国家人口来衡量这些点...... 没问题：这里也有一个参数来设置，它被称为 &lt;code&gt;size&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/007EIIJlgy1g1arckf7guj30m80drmyf.jpg&quot; alt=&quot;image03&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你好奇哪个国家对应哪个点？ 可以添加一个 &lt;code&gt;hover_name&lt;/code&gt; ，您可以轻松识别任何一点：只需将鼠标放在您感兴趣的点上即可！ 事实上，即使没有 &lt;code&gt;hover_name&lt;/code&gt; ，整个图表也是互动的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/007EIIJlgy1g1arczxuojg30s20hegy3.gif&quot; alt=&quot;image04&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以通过 &lt;code&gt;facet_col =”continent“&lt;/code&gt; 来轻松划分各大洲，就像着色点一样容易，并且让我们使用 x轴 对数（log_x）以便在我们在图表中看的更清晰：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/large/007EIIJlgy1g1ares0m2qj30m80ea76b.jpg&quot; alt=&quot;image06&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许你不仅仅对 2007年 感兴趣，而且你想看看这张图表是如何随着时间的推移而演变的。 可以通过设置 &lt;code&gt;animation_frame =“year”&lt;/code&gt; （以及 &lt;code&gt;animation_group =“country”&lt;/code&gt; 来标识哪些圆与控制条中的年份匹配）来设置动画。 在这个最终版本中，让我们在这里调整一些显示，因为像“gdpPercap” 这样的文本有点难看，即使它是我们的数据框列的名称。 我们可以提供更漂亮的“标签” （labels），可以在整个图表、图例、标题轴和悬停（hovers）中应用。 我们还可以手动设置边界，以便动画在整个过程中看起来更棒：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/large/007EIIJlgy1g1arfpds9ig30m80ei7wh.gif&quot; alt=&quot;image07&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为这是地理数据，我们也可以将其表示为动画地图，因此这清楚地表明 Plotly Express 不仅仅可以绘制散点图（不过这个数据集缺少前苏联的数据）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/large/007EIIJlgy1g1arg1r00ag30m80e1dyj.gif&quot; alt=&quot;image08&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上，Plotly Express 支持三维散点图、三维线形图、极坐标和地图上三元坐标以及二维坐标。 条形图（Bar）有二维笛卡尔和极坐标风格。进行可视化时，您可以使用单变量设置中的直方图（histograms）和箱形图（box）或小提琴图（violin plots），或双变量分布的密度等高线图（density contours）。 大多数二维笛卡尔图接受连续或分类数据，并自动处理日期/时间数据。 可以查看我们的图库 (ref-3) 来了解每个图表的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/007EIIJlgy1g1arhs15f9g30m80eiayp.gif&quot; alt=&quot;image09&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述动态图包含 10多张 图片的可视化，『Python数据之道』已将代码整合到 jupyter notebook 文件中，在公号回复 “code” 即可获得源代码。&lt;/p&gt;
&lt;p&gt;下图即是其中的一个图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/007EIIJlgy1g1cnut0791j30p00an0wm.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;可视化分布&quot;&gt;可视化分布&lt;/h2&gt;
&lt;p&gt;数据探索的主要部分是理解数据集中值的分布，以及这些分布如何相互关联。 Plotly Express 有许多功能来处理这些任务。&lt;/p&gt;
&lt;p&gt;使用直方图（histograms），箱形图（box）或小提琴图（violin plots）可视化单变量分布：&lt;/p&gt;
&lt;p&gt;直方图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/007EIIJlgy1g1ari57r90j30m80dp3yv.jpg&quot; alt=&quot;image10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;箱形图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007EIIJlgy1g1arimiqasj30m80e23ze.jpg&quot; alt=&quot;image11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小提琴图：&lt;br/&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/007EIIJlgy1g1ark2nulij30m80dywfn.jpg&quot; alt=&quot;image12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以创建联合分布图（marginal rugs），使用直方图，箱形图（box）或小提琴来显示双变量分布，也可以添加趋势线。 Plotly Express 甚至可以帮助你在悬停框中添加线条公式和R²值！ 它使用 statsmodels 进行普通最小二乘（OLS）回归或局部加权散点图平滑（LOWESS）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/007EIIJlgy1g1arkicljmj30m80dztad.jpg&quot; alt=&quot;image13&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;颜色面板和序列&quot;&gt;颜色面板和序列&lt;/h2&gt;
&lt;p&gt;在上面的一些图中你会注意到一些不错的色标。 在 Plotly Express 中， px.colors 模块包含许多有用的色标和序列：定性的、序列型的、离散的、循环的以及所有您喜欢的开源包：ColorBrewer、cmocean 和 Carto 。 我们还提供了一些功能来制作可浏览的样本供您欣赏（ref-3）：&lt;/p&gt;
&lt;p&gt;定性的颜色序列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/large/007EIIJlgy1g1arktti8uj30m80fyq3m.jpg&quot; alt=&quot;image14&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众多内置顺序色标中的一部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/large/007EIIJlgy1g1arl2ehaxj30m80ep0t8.jpg&quot; alt=&quot;image15&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用一行-python-代码进行交互式多维可视化&quot;&gt;用一行 Python 代码进行交互式多维可视化&lt;/h2&gt;
&lt;p&gt;我们特别为我们的交互式多维图表感到自豪，例如散点图矩阵（SPLOMS）、平行坐标和我们称之为并行类别的并行集。 通过这些，您可以在单个图中可视化整个数据集以进行数据探索。 在你的Jupyter 笔记本中查看这些单行及其启用的交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/007EIIJlgy1g1arle0dvmg30s60gk7wh.gif&quot; alt=&quot;image16&quot;/&gt;&lt;/p&gt;
&lt;p&gt;散点图矩阵（SPLOM）允许您可视化多个链接的散点图：数据集中的每个变量与其他变量的关系。 数据集中的每一行都显示为每个图中的一个点。 你可以进行缩放、平移或选择操作，你会发现所有图都链接在一起！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/007EIIJlgy1g1arlnnld2g30s50gk1kz.gif&quot; alt=&quot;image17&quot;/&gt;&lt;/p&gt;
&lt;p&gt;平行坐标允许您同时显示3个以上的连续变量。 dataframe 中的每一行都是一行。 您可以拖动尺寸以重新排序它们并选择值范围之间的交叉点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/007EIIJlgy1g1arm7dr3ag30s50gku0y.gif&quot; alt=&quot;image18&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并行类别是并行坐标的分类模拟：使用它们可视化数据集中多组类别之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;plotly-生态系统的一部分&quot;&gt;Plotly 生态系统的一部分&lt;/h2&gt;
&lt;p&gt;Plotly Express 之于 Plotly.py 类似 Seaborn 之于 matplotlib：Plotly Express 是一个高级封装库，允许您快速创建图表，然后使用底层 API 和生态系统的强大功能进行修改。 对于Plotly 生态系统，这意味着一旦您使用 Plotly Express 创建了一个图形，您就可以使用Themes，使用 FigureWidgets 进行命令性编辑，使用 Orca 将其导出为几乎任何文件格式，或者在我们的 GUI JupyterLab 图表编辑器中编辑它 。&lt;/p&gt;
&lt;p&gt;主题（Themes）允许您控制图形范围的设置，如边距、字体、背景颜色、刻度定位等。 您可以使用模板参数应用任何命名的主题或主题对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/large/007EIIJlgy1g1armxer1ug30m80dxgnl.gif&quot; alt=&quot;image19&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有三个内置的 Plotly 主题可以使用， 分别是 plotly， plotly_white 和 plotly_dark&lt;/p&gt;
&lt;p&gt;&lt;code&gt;px&lt;/code&gt; 输出继承自 Plotly.py 的 &lt;code&gt;Figure&lt;/code&gt; 类 &lt;code&gt;ExpressFigure&lt;/code&gt; 的对象，这意味着你可以使用任何 &lt;code&gt;Figure&lt;/code&gt; 的访问器和方法来改变 &lt;code&gt;px&lt;/code&gt; 生成的绘图。 例如，您可以将 &lt;code&gt;.update（）&lt;/code&gt; 调用链接到 &lt;code&gt;px&lt;/code&gt; 调用以更改图例设置并添加注释。 &lt;code&gt;.update（）&lt;/code&gt; 现在返回修改后的数字，所以你仍然可以在一个很长的 Python 语句中执行此操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007EIIJlgy1g1arng1pivj30m80g5abk.jpg&quot; alt=&quot;image20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里，在使用 Plotly Express 生成原始图形之后，我们使用 Plotly.py 的 API 来更改一些图例设置并添加注释。&lt;/p&gt;
&lt;h2 id=&quot;能够与-dash-完美匹配&quot;&gt;能够与 Dash 完美匹配&lt;/h2&gt;
&lt;p&gt;Dash 是 Plotly 的开源框架，用于构建具有 Plotly.py 图表的分析应用程序和仪表板。Plotly Express 产生的对象与 Dash 100％兼容，只需将它们直接传递到&lt;code&gt;dash_core_components.Graph&lt;/code&gt;，如下所示：&lt;code&gt;dcc.Graph（figure = px.scatter（...））&lt;/code&gt;。 这是一个非常简单的 50行 Dash 应用程序的示例，它使用 &lt;code&gt;px&lt;/code&gt; 生成其中的图表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/large/007EIIJlgy1g1arnq0nepg30u30k6qby.gif&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个 50 行的 Dash 应用程序使用 Plotly Express 生成用于浏览数据集的 UI 。&lt;/p&gt;
&lt;h2 id=&quot;设计理念为什么我们创建-plotly-express&quot;&gt;设计理念：为什么我们创建 Plotly Express ？&lt;/h2&gt;
&lt;p&gt;可视化数据有很多原因：有时您想要提供一些想法或结果，并且您希望对图表的每个方面施加很多控制，有时您希望快速查看两个变量之间的关系。 这是交互与探索的范畴。&lt;/p&gt;
&lt;p&gt;Plotly.py 已经发展成为一个非常强大的可视化交互工具：它可以让你控制图形的几乎每个方面，从图例的位置到刻度的长度。 不幸的是，这种控制的代价是冗长的：有时可能需要多行 Python 代码才能用 Plotly.py 生成图表。&lt;/p&gt;
&lt;p&gt;我们使用 Plotly Express 的主要目标是使 Plotly.py 更容易用于探索和快速迭代。&lt;/p&gt;
&lt;p&gt;我们想要构建一个库，它做出了不同的权衡：在可视化过程的早期牺牲一些控制措施来换取一个不那么详细的 API，允许你在一行 Python 代码中制作各种各样的图表。 然而，正如我们上面所示，该控件并没有消失：你仍然可以使用底层的 Plotly.py 的 API 来调整和优化用 Plotly Express 制作的图表。&lt;/p&gt;
&lt;p&gt;支持这种简洁 API 的主要设计决策之一是所有 Plotly Express 的函数都接受“整洁”的 dataframe 作为输入。 每个 Plotly Express 函数都体现了dataframe 中行与单个或分组标记的清晰映射，并具有图形启发的语法签名，可让您直接映射这些标记的变量，如 x 或 y 位置、颜色、大小、 facet-column 甚至是 动画帧到数据框（dataframe）中的列。 当您键入&lt;code&gt;px.scatter（data，x ='col1'，y ='col2'）&lt;/code&gt; 时，Plotly Express 会为数据框中的每一行创建一个小符号标记 - 这就是 &lt;code&gt;px.scatter&lt;/code&gt; 的作用 - 并将 “col1” 映射到 x 位置（类似于 y 位置）。 这种方法的强大之处在于它以相同的方式处理所有可视化变量：您可以将数据框列映射到颜色，然后通过更改参数来改变您的想法并将其映射到大小或进行行分面（facet-row）。&lt;/p&gt;
&lt;p&gt;接受整个整洁的 dataframe 的列名作为输入（而不是原始的 &lt;code&gt;numpy&lt;/code&gt; 向量）也允许 &lt;code&gt;px&lt;/code&gt; 为你节省大量的时间，因为它知道列的名称，它可以生成所有的 Plotly.py 配置用于标记图例、轴、悬停框、构面甚至动画帧。 但是，如上所述，如果你的 dataframe 的列被笨拙地命名，你可以告诉 &lt;code&gt;px&lt;/code&gt; 用每个函数的 &lt;code&gt;labels&lt;/code&gt; 参数替换更好的。&lt;/p&gt;
&lt;p&gt;仅接受整洁输入所带来的最终优势是它更直接地支持快速迭代：您整理一次数据集，从那里可以使用 &lt;code&gt;px&lt;/code&gt; 创建数十种不同类型的图表，包括在 SPLOM 中可视化多个维度 、使用平行坐标、在地图上绘制，在二维、三维极坐标或三维坐标中使用等，所有这些都不需要重塑您的数据！&lt;/p&gt;
&lt;p&gt;我们没有以权宜之计的名义牺牲控制的所有方面，我们只关注您想要在数据可视化过程的探索阶段发挥的控制类型。 您可以对大多数函数使用 &lt;code&gt;category_orders&lt;/code&gt; 参数来告诉 &lt;code&gt;px&lt;/code&gt; 您的分类数据“好”、“更好”、“最佳” 等具有重要的非字母顺序，并且它将用于分类轴、分面绘制 和图例的排序。 您可以使用 &lt;code&gt;color_discrete_map&lt;/code&gt; （以及其他 &lt;code&gt;* _map&lt;/code&gt; 参数）将特定颜色固定到特定数据值（如果这对您的示例有意义）。 当然，你可以在任何地方重构 &lt;code&gt;color_discrete_sequence&lt;/code&gt; 或 &lt;code&gt;color_continuous_scale&lt;/code&gt; （和其他 &lt;code&gt;* _sequence&lt;/code&gt; 参数）。&lt;/p&gt;
&lt;p&gt;在 API 级别，我们在 &lt;code&gt;px&lt;/code&gt; 中投入了大量的工作，以确保所有参数都被命名，以便在键入时最大限度地发现：所有 &lt;code&gt;scatter&lt;/code&gt; -类似的函数都以 &lt;code&gt;scatter&lt;/code&gt; 开头（例如 &lt;code&gt;scatter_polar&lt;/code&gt;，&lt;code&gt;scatter_ternary&lt;/code&gt;）所以你可以通过自动补全来发现它们。 我们选择拆分这些不同的散点图函数，因此每个散点图函数都会接受一组定制的关键字参数，特别是它们的坐标系。 也就是说，共享坐标系的函数集（例如 &lt;code&gt;scatter&lt;/code&gt;，&lt;code&gt;line&lt;/code&gt; ＆ &lt;code&gt;bar&lt;/code&gt;，或 &lt;code&gt;scatter_polar&lt;/code&gt;， &lt;code&gt;line_polar&lt;/code&gt; 和 &lt;code&gt;bar_polar&lt;/code&gt; ）也有相同的参数，以最大限度地方便学习。 我们还花了很多精力来提出简短而富有表现力的名称，这些名称很好地映射到底层的 Plotly.py 属性，以便于在工作流程中稍后调整到交互的图表中。&lt;/p&gt;
&lt;p&gt;最后，Plotly Express 作为一个新的 Python 可视化库，在 Plotly 生态系统下，将会迅速发展。所以不要犹豫，立即开始使用 Plotly Express 吧！&lt;/p&gt;
&lt;p&gt;『Python数据之道』已将代码整合到 jupyter notebook 文件中，在公号回复 “code” 即可获得源代码。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;文章来源：&lt;/p&gt;
&lt;p&gt;https://medium.com/@plotlygraphs/introducing-plotly-express-808df010143d&lt;/p&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;ref-1：https://nbviewer.jupyter.org/github/plotly/plotly_express/blob/master/walkthrough.ipynb&lt;/p&gt;
&lt;p&gt;ref-2：https://mybinder.org/v2/gh/plotly/plotly_express/master?filepath=walkthrough.ipynb&lt;/p&gt;
&lt;p&gt;ref-3：https://plotly.github.io/plotly_express/&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 25 Mar 2019 05:18:00 +0000</pubDate>
<dc:creator>lemonbit</dc:creator>
<og:description>Plotly Express 是一个新的高级 Python 可视化库：它是 Plotly.py 的高级封装，它为复杂的图表提供了一个简单的语法。 受 Seaborn 和 ggplot2 的启发，它专门</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lemonbit/p/10593188.html</dc:identifier>
</item>
<item>
<title>【9】JMicro微服务-发布订阅消息服 - JMICRO</title>
<link>http://www.cnblogs.com/jmicro/p/10593031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmicro/p/10593031.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;如非授权，禁止用于商业用途，转载请注明出处&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;作者：mynewworldyyl&lt;/strong&gt;&lt;/em&gt;&lt;em&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. JMicro消息服务目前实现特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. JMicro只支持发布订阅消息服务，不支持队列式消息服务；&lt;/p&gt;
&lt;p&gt;b. 不支持消息持久化，所以不能保证消息一定能被消费者消费；&lt;/p&gt;
&lt;p&gt;c. 发布消息时如果没有消费者，消息直接丢弃；&lt;/p&gt;
&lt;p&gt;d. 如果消息按配置的重发时间间隔重复发送多次（可配置）失败，消息直接丢弃；&lt;/p&gt;
&lt;p&gt;e. 如果消息失败重发队列超过预先配置的数量，最先失败的消息会被直接丢弃，而新失败消息直接入失败队列排队等待重发；&lt;/p&gt;
&lt;p&gt;f. 基于以上几点，如果要求绝对可靠的消息系统，而不是高性能的消息系统，不建议使用JMicro消息服务；&lt;/p&gt;
&lt;p&gt;JMicro追求的是简单并且高性能，如果消费者服务是正常等待消息状态，那么消息肯定能高效从消息发送者直达消费者服务，如果消费者不在线，或出了问题无法消费消息，直接失败告诉使用者系统出了问题才应该是最佳的避免问题的方法。&lt;/p&gt;
&lt;p&gt;一味地为了解决或支持次要的需求而增加系统的复杂度本身也会增加系统出问题的隐患，特别是复杂度达到一定程度后，很可能意味着软件的失败。&lt;/p&gt;
&lt;p&gt;Do one thing and do it well! 微服务口号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 启动消息服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新打开一个新的CMD窗口，CD进入/jmicro.pubsub，运行 &lt;/p&gt;
&lt;p&gt;mvn clean install -Pbuild-main  (只需构建一次，以后可以重复运行)&lt;/p&gt;
&lt;p&gt;运行pubsub服务&lt;/p&gt;
&lt;p&gt;java -jar target/jmicro.pubsub-0.0.1-SNAPSHOT-jar-with-dependencies.jar&lt;/p&gt;
&lt;p&gt;如果启动时最后出现如下信息，说明pubsub没有启动，需要将/PubSubManager/enableServer的值从false,改为true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596691/201903/1596691-20190325124100815-912898384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过ZKUI修改方式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596691/201903/1596691-20190325124342425-956163499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将enableServer的值从false改为true，然后重启服务即可，因为这个值是启动时就检测，只使用一次，即时生效是指：修改值后，之后的使用会使用新的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 开发消费者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/jmicro.example.provider/src/main/java/org/jmicro/example/pubsub/impl/SimplePubsubImpl.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Service(maxSpeed=-1,baseTimeUnit=&lt;span&gt;Constants.TIME_SECONDS)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SimplePubsubImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ISimplePubsub {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(SimplePubsubImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     @Subscribe(topic=&quot;/jmicro/test/topic01&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; helloTopic(PSData data) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;helloTopic: &quot;+data.getTopic()+&quot;, data: &quot;+&lt;span&gt; data.getData().toString());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     @Subscribe(topic=&quot;/jmicro/test/topic01&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTopic(PSData data) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;testTopic: &quot;+data.getTopic()+&quot;, data: &quot;+&lt;span&gt; data.getData().toString());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     @Subscribe(topic=&lt;span&gt;MonitorConstant.TEST_SERVICE_METHOD_TOPIC)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; statis(PSData data) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         Map&amp;lt;Integer,Double&amp;gt; ps = (Map&amp;lt;Integer,Double&amp;gt;&lt;span&gt;)data.getData();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         logger.info(&quot;总请求:{}, 总响应:{}, TO:{}, TOF:{}, QPS:{}&quot;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                ,ps.get(MonitorConstant.CLIENT_REQ_BEGIN)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                ,ps.get(MonitorConstant.STATIS_TOTAL_RESP)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                ,ps.get(MonitorConstant.CLIENT_REQ_TIMEOUT)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                ,ps.get(MonitorConstant.CLIENT_REQ_TIMEOUT_FAIL)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                ,ps.get(MonitorConstant.STATIS_QPS)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                );
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;Topic: &quot;+data.getTopic()+&quot;, data: &quot;+ data.getData().toString());&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;消息消费者也是一个RPC服务，由Component和Service注解实现类，不同点是方法不再由SMethod注解，而是由Subcribe注解，并增加topic属性，值是消息的主题。&lt;/p&gt;
&lt;p&gt;方法唯一参数是org.jmicro.api.pubsub.PSData,代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PSData &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 389875668374730999L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; context = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; flag = 0&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String topic;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object data;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; getFlag() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setFlag(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; flag) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.flag =&lt;span&gt; flag;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTopic() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; topic;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTopic(String topic) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.topic =&lt;span&gt; topic;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt;&lt;span&gt; getContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setContext(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; context) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setData(Object data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(String key,Object v) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context.put(key, v);
    }
    
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T get(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context.get(key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;data即是消息主体内容，可以是任意JMicro支持的参数类型，支持的参数类型后面会有专题小节详细说明，目前只需要知道：&lt;/p&gt;
&lt;p&gt;a. Java 8种基本字据类型，字符串，java.util.Date，java.nio.ByteBuffer;&lt;/p&gt;
&lt;p&gt;b. 由a组成的任意POJO类型；&lt;/p&gt;
&lt;p&gt;c. 由a,b,c,d组成的任意数组类型，集合类型（LIST，SET）；&lt;/p&gt;
&lt;p&gt;d. Key为String类型，值为a,b,c,d组成的任意Map类型；&lt;/p&gt;

&lt;p&gt;运行消费者&lt;/p&gt;
&lt;p&gt;java -jar target/jmicro.example.provider-0.0.1-SNAPSHOT-jar-with-dependencies.jar&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 消息生产者&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestPubSubServer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; JMicroBaseTestCase{&lt;/span&gt;&lt;span&gt;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPresurePublish() {
        
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Random ran = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        
        PubSubManager psm &lt;/span&gt;= of.get(PubSubManager.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        
        AtomicInteger id &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
        
        Runnable r &lt;/span&gt;= ()-&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.sleep(2000);&lt;/span&gt;
                    Thread.sleep(ran.nextInt(100&lt;span&gt;));
                    psm.publish(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;&lt;span&gt;(), TOPIC, 
                            &lt;/span&gt;&quot;test pubsub server id: &quot;+&lt;span&gt;id.getAndIncrement());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                    System.out.println(e.getMessage());;
                }
            }
        };
        
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(r).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(r).start();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;new Thread(r).start();
        new Thread(r).start();
        new Thread(r).start();&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        
        JMicro.waitForShutdown();
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPublishStringMessage() {
        PubSubManager psm &lt;/span&gt;= of.get(PubSubManager.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        psm.publish(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;(), TOPIC, &quot;test pubsub server&quot;&lt;span&gt;);
        JMicro.waitForShutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个基于JUnit4的单元测试类，继承自org.jmicro.test.JMicroBaseTestCase，消息发布通过org.jmicro.api.pubsub.PubSubManager的三个publish重载方法实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PubSubManager psm = of.get(PubSubManager.class&lt;span&gt;); psm.publish(new HashMap&amp;lt;String,Object&amp;gt;(), TOPIC, &quot;test pubsub server&quot;&lt;span&gt;);&lt;br/&gt;of是JMicroBaseTestCase成员变量，IObjectFactory类型，系统启动就可使用，类似Spring容器，目前知道点就行。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;PubSubManager也是系统预实例化的消息发送接口，从of拿来即用。&lt;/p&gt;&lt;p&gt;Eclipse或IDEA分别运行上面3个单元测试方法，查看消费者终端输出，消费端输出代码如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596691/201903/1596691-20190325122314050-253186342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;testPublishStringMessage：发送一个简单字符串消息,消费端输出如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596691/201903/1596691-20190325122009142-537009185.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;testPresurePublish开启多个线程重复发送消息，用于消息服务系统做压力测试 ，消费端输出如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596691/201903/1596691-20190325122149581-1318206336.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 25 Mar 2019 04:24:00 +0000</pubDate>
<dc:creator>JMICRO</dc:creator>
<og:description>如非授权，禁止用于商业用途，转载请注明出处作者：mynewworldyyl 1. JMicro消息服务目前实现特性 a. JMicro只支持发布订阅消息服务，不支持队列式消息服务； b. 不支持消息持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmicro/p/10593031.html</dc:identifier>
</item>
</channel>
</rss>