<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python数据采集——提取页面内容的几种手段 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10705360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10705360.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在我们获取了网页的信息后，往往需要对原始信息进行提取，得到我们想要的数据。对信息的提取方式主要有以下几种：正则表达式、XPath、BeautifulSoup。本篇博客主要总结这三种方式的基本语法，以及举一些例子来说明如何使用这些方法。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h2&gt;
&lt;p&gt;什么是正则表达式？&lt;/p&gt;
&lt;p&gt;正则表达式是使用某种预定义的模式去匹配一类具有共同特征的字符串，主要用于处理字符串，可以快速、准确地完成复杂的查找、替换等要求。&lt;/p&gt;
&lt;p&gt;在Python中，&lt;code&gt;re模块&lt;/code&gt;提供了正则表达式操作所需要的功能。所以，在Python中使用正则表达式需要先&lt;code&gt;import re&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用正则表达式提取信息时可以概括为以下三步（大部分提取信息方法的步骤也是如此）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;寻找规律&lt;/li&gt;
&lt;li&gt;使用正则符号表示规律&lt;/li&gt;
&lt;li&gt;提取信息&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;正则表达式的基本符号&quot;&gt;正则表达式的基本符号&lt;/h3&gt;
&lt;p&gt;这里主要介绍正则中的基本符号，高级的语法的部分会在后面附上链接供大家参考学习。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;一般符号&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;点号.&lt;/td&gt;
&lt;td&gt;匹配除换行符&lt;code&gt;\n&lt;/code&gt;以外任意单个字符，若是要匹配&lt;code&gt;.&lt;/code&gt;则需要使用转义字符&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a.c -&amp;gt; a&lt;strong&gt;b&lt;/strong&gt;c, a&lt;strong&gt;#&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;方括号[]&lt;/td&gt;
&lt;td&gt;字符集(字符类)。对应的位置可以是指定字符集中的任意字符，[]中的字符可以逐个列出，也可以给出范围。^符号表示取反，即除指定字符以外的其他字符。&lt;/td&gt;
&lt;td&gt;a[bcd]e -&amp;gt; a&lt;strong&gt;b&lt;/strong&gt;e; a[b-f]g -&amp;gt; a&lt;strong&gt;b&lt;/strong&gt;g; a[^bc]d -&amp;gt; aefd ad之间不可以出现bc字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数量相关&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;星号*&lt;/td&gt;
&lt;td&gt;星号表示它前面的一个子表达式(普通字符、另一个或几个正则表达式符号)0次或任意多次&lt;/td&gt;
&lt;td&gt;abc* -&amp;gt; ab, ab&lt;strong&gt;c&lt;/strong&gt;, ab&lt;strong&gt;cc&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;问号?&lt;/td&gt;
&lt;td&gt;问号表示它前面的子表达式0次或者1次。&lt;/td&gt;
&lt;td&gt;abc? -&amp;gt; ab, ab&lt;strong&gt;c&lt;/strong&gt; ; ab?c -&amp;gt;ac, a&lt;strong&gt;b&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;加号+&lt;/td&gt;
&lt;td&gt;加号表示它前面的子表达式1次或者任意多次&lt;/td&gt;
&lt;td&gt;abc+ -&amp;gt;ab&lt;strong&gt;c&lt;/strong&gt;, ab&lt;strong&gt;cc&lt;/strong&gt;, ab&lt;strong&gt;ccc&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;花括号{m}&lt;/td&gt;
&lt;td&gt;匹配前一个子表达式m次&lt;/td&gt;
&lt;td&gt;ab{3}c -&amp;gt; a&lt;strong&gt;bbb&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;花括号{m, n}&lt;/td&gt;
&lt;td&gt;匹配前一个子表达式m至n次，m和n可以省略，若省略m，则匹配0至n次，若省略n，则匹配m至无限次&lt;/td&gt;
&lt;td&gt;ab{2,3}c -&amp;gt;abbc, abbbc&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界匹配&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hat符号^&lt;/td&gt;
&lt;td&gt;匹配字符串的开头，在多行模式下匹配每一行的开头&lt;/td&gt;
&lt;td&gt;^a-&amp;gt;&lt;strong&gt;a&lt;/strong&gt;b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dollar符号$&lt;/td&gt;
&lt;td&gt;匹配字符串的末尾，在多行模式下匹配每一行的末尾&lt;/td&gt;
&lt;td&gt;$a-&amp;gt;bc&lt;strong&gt;a&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配一个单词边界&lt;/td&gt;
&lt;td&gt;er\b可以匹配nev&lt;strong&gt;er&lt;/strong&gt;但是不可以匹配verb&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界&lt;/td&gt;
&lt;td&gt;er\B可以匹配v&lt;strong&gt;er&lt;/strong&gt;b但是不可以匹配never&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预定义字符集&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;数字0-9&lt;/td&gt;
&lt;td&gt;a\dc-&amp;gt;a&lt;strong&gt;1&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;非数字&lt;/td&gt;
&lt;td&gt;a\Dc-&amp;gt;a&lt;strong&gt;#&lt;/strong&gt;c a&lt;strong&gt;e&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;空白字符(空格、\t、\r、\n、\f(换页)、\v(垂直跳格（垂直制表）))&lt;/td&gt;
&lt;td&gt;a\sc -&amp;gt;a c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;非空白字符&lt;/td&gt;
&lt;td&gt;a\Sc -&amp;gt;a&lt;strong&gt;b&lt;/strong&gt;c, a&lt;strong&gt;1&lt;/strong&gt;c, a&lt;strong&gt;#&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;单词字符(A-Z,a-z,0-9,_（下划线）)&lt;/td&gt;
&lt;td&gt;a\wc -&amp;gt;a&lt;strong&gt;0&lt;/strong&gt;c, a&lt;strong&gt;b&lt;/strong&gt;c, a&lt;strong&gt;2&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;非单词字符&lt;/td&gt;
&lt;td&gt;a\Wc -&amp;gt;a c, a&lt;strong&gt;#&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑、分组&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;代表左右表达式任意匹配一个。注：它总是先尝试匹配左边的表达式，一旦成功匹配，则跳过右边的匹配&lt;/td&gt;
&lt;td&gt;abc|def-&amp;gt;&lt;strong&gt;abc&lt;/strong&gt;, &lt;strong&gt;def&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;被括起来的表达式将作为分组，从表达式左边开始每遇到一个分组的左括号，编号+1，分组表达式作为一个整体，可以后面接数量词，通常用于提取内容&lt;/td&gt;
&lt;td&gt;(abc){3} -&amp;gt;&lt;strong&gt;abcabcabc&lt;/strong&gt;； a(123|456）-&amp;gt;a&lt;strong&gt;123&lt;/strong&gt;c a&lt;strong&gt;456&lt;/strong&gt;c&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复杂一点的用法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.和*共用&lt;/td&gt;
&lt;td&gt;. a.*d -&amp;gt;ad，a&lt;strong&gt;n&lt;/strong&gt;d，a&lt;strong&gt;mnopq&lt;/strong&gt;d&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;[]和*共用&lt;/td&gt;
&lt;td&gt;a[bc]*d -&amp;gt;a&lt;strong&gt;b&lt;/strong&gt;d, a&lt;strong&gt;c&lt;/strong&gt;d, a&lt;strong&gt;bbbb&lt;/strong&gt;d, a&lt;strong&gt;cbcc&lt;/strong&gt;d&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;.*&lt;/code&gt;和&lt;code&gt;.*?&lt;/code&gt;的区别：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;.*&lt;/code&gt;:贪婪模式，获取最长的满足条件的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;.*?&lt;/code&gt;:非贪婪模式，获取最短的能满足条件的字符串&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div&amp;gt;
   &amp;lt;a&amp;gt;123&amp;lt;/a&amp;gt; 
   &amp;lt;a&amp;gt;456&amp;lt;/a&amp;gt; 
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;&amp;lt;a&amp;gt;(.*)&amp;lt;/a&amp;gt;&lt;/code&gt;匹配出来的结果为：123&amp;lt;/a&amp;gt;&amp;lt;a&amp;gt;456&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;&amp;lt;a&amp;gt;(.*?)&amp;lt;/a&amp;gt;&lt;/code&gt;匹配出来的结果为：123 和 456&lt;/p&gt;
&lt;p&gt;在使用正则表达式提取文本内容时，也常常使用&lt;code&gt;.*?&lt;/code&gt; （最小匹配）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;re模块的常用方法&quot;&gt;RE模块的常用方法&lt;/h3&gt;
&lt;p&gt;使用re模块时，记得先导入&lt;code&gt;import re&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;re.match方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;match(pattern,string[,flags]):&lt;br/&gt;尝试从字符串的&lt;strong&gt;起始位置&lt;/strong&gt;进行匹配，若匹配成功，则返回一个匹配的对象，若匹配不成功，则返回none&lt;/p&gt;
&lt;p&gt;并且可以使用group(num)或 groups()匹配对象函数来获取匹配表达式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; print(re.match('www', 'www.cnblog.com'))
&amp;lt;_sre.SRE_Match object; span=(0, 3), match='www'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(re.match('com', 'www.cnblog.com'))
None&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; line = 'Who are you ?.'
&amp;gt;&amp;gt;&amp;gt; macth = re.match(r'(.*) are (.*?) ', line)
&amp;gt;&amp;gt;&amp;gt; macth.group()
'Who are you '
&amp;gt;&amp;gt;&amp;gt; macth.groups()
('Who', 'you')
&amp;gt;&amp;gt;&amp;gt; macth.group(1)
'Who'
&amp;gt;&amp;gt;&amp;gt; macth.group(2)
'you'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;re.search方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;search(pattern,string[,flags]):&lt;br/&gt;扫描&lt;strong&gt;整个字符串&lt;/strong&gt;并&lt;strong&gt;返回第一个&lt;/strong&gt;成功的匹配，若匹配成功则返回一个匹配的对象，否则返回None。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(re.search('www', 'www.cnblog.com'))
&amp;lt;_sre.SRE_Match object; span=(0, 3), match='www'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(re.search('cn', 'www.cnblog.com'))
&amp;lt;_sre.SRE_Match object; span=(4, 6), match='cn'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;re.findAll方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;findall(pattern,string[,flags]):&lt;br/&gt;在字符串中找到正则表达式&lt;strong&gt;所匹配的所有子串&lt;/strong&gt;，&lt;strong&gt;并返回一个列表&lt;/strong&gt;，如果没有找到匹配的，则返回空列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; line = 'cnblog-&amp;gt;123sakuraone456'
&amp;gt;&amp;gt;&amp;gt; print(re.findall(r'\d', line))
['1', '2', '3', '4', '5', '6']
&amp;gt;&amp;gt;&amp;gt; print(re.findall(r'\d+', line))
['123', '456']
&amp;gt;&amp;gt;&amp;gt; print(re.findall(r'\D+', line))
['cnblog-&amp;gt;', 'sakuraone']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;re.split方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;split(pattern,string[,maxsplit=0]):&lt;br/&gt;按照能够匹配的子串将字符串分割后返回列表。maxsplit指定分割次数。若是没有匹配的，则不分割。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; line = 'www.cnblog.com'
&amp;gt;&amp;gt;&amp;gt; print(re.split(r'\W+', line))
['www', 'cnblog', 'com']
&amp;gt;&amp;gt;&amp;gt; print(re.split(r'\W+', line, 2))
['www', 'cnblog', 'com']
&amp;gt;&amp;gt;&amp;gt; print(re.split(r'\W+', line, 1))
['www', 'cnblog.com']
&amp;gt;&amp;gt;&amp;gt; print(re.split(r'\d+', line, 1))
['www.cnblog.com']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;re.sub方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;sub(pattern,repl,string[,count=0]):&lt;br/&gt;将字符串中所有pattern的匹配项用repl替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;line = &quot;wodfj1234djsig808&quot;
print(re.sub(r'\D','',line))
1234808&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用xparh&quot;&gt;使用XParh&lt;/h2&gt;
&lt;p&gt;在复杂的文档结构中去使用正则表达式获取内容，可能需要花费大量的时间去构造正确的正则表达式。此时我们可能就需要换一种方式提取。&lt;/p&gt;
&lt;p&gt;XPath使用&lt;strong&gt;路径表达式&lt;/strong&gt;来选取XML文档中的&lt;strong&gt;节点或者节点集&lt;/strong&gt;。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。要获取一个节点就需要构造它的路径。&lt;/p&gt;
&lt;p&gt;主要在Python中，要使用XPath就需要先安装一个第三方库&lt;code&gt;lxml&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;节点类型&quot;&gt;节点类型&lt;/h3&gt;
&lt;p&gt;因为XPath是依靠路径来选取节点，我们首先就需要知道XPath中的节点类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;元素&lt;/li&gt;
&lt;li&gt;属性&lt;/li&gt;
&lt;li&gt;文本&lt;/li&gt;
&lt;li&gt;命名空间&lt;/li&gt;
&lt;li&gt;处理指令&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;li&gt;文档节点（根节点）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;bookstore&amp;gt;
  &amp;lt;book&amp;gt;
    &amp;lt;title lang=&quot;en&quot;&amp;gt;Harry Potter&amp;lt;/title&amp;gt;
    &amp;lt;author&amp;gt;J K. Rowling&amp;lt;/author&amp;gt;
    &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
    &amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;
  &amp;lt;/book&amp;gt;
&amp;lt;/bookstore&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bookstore&amp;gt; (文档节点)
&amp;lt;author&amp;gt;J K. Rowling&amp;lt;/author&amp;gt; (元素节点)
lang=&quot;en&quot; (属性节点)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;节点之间的关系&quot;&gt;节点之间的关系&lt;/h3&gt;
&lt;p&gt;XML 文档是被作为节点树来对待的，节点之间的关系如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父：bookstore元素是book、title、author、year 以及price元素的父&lt;/li&gt;
&lt;li&gt;子：book、title、author、year 以及 price 元素都是bookstore元素的子&lt;/li&gt;
&lt;li&gt;同胞：title、author、year 以及price元素都是同胞&lt;/li&gt;
&lt;li&gt;先辈：title 元素的先辈是book元素和bookstore&lt;/li&gt;
&lt;li&gt;后代：bookstore 的后代是book、title、author、year以及price&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用路径表达式选取节点&quot;&gt;使用路径表达式选取节点&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取nodename节点的所有子节点&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从根节点开始选取&lt;/td&gt;
&lt;td&gt;xpath('/div')&lt;/td&gt;
&lt;td&gt;从根节点上选取div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;选取所有的当前节点，不考虑他们的位置&lt;/td&gt;
&lt;td&gt;xpath('//div')&lt;/td&gt;
&lt;td&gt;选取所有div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点&lt;/td&gt;
&lt;td&gt;xpath(‘./div’)&lt;/td&gt;
&lt;td&gt;选取当前节点下的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点&lt;/td&gt;
&lt;td&gt;xpath('..')&lt;/td&gt;
&lt;td&gt;回到上一个节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性&lt;/td&gt;
&lt;td&gt;xpath（‘//@calss’)&lt;/td&gt;
&lt;td&gt;选取所有的class属性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;xpath谓词查找特定的节点&quot;&gt;XPath谓词查找特定的节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;谓语被嵌在方括号内，用来查找特定的节点。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[1]’)&lt;/td&gt;
&lt;td&gt;选取body下的第一个div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[last()]’)&lt;/td&gt;
&lt;td&gt;选取body下的最后一个div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[last()-1]’)&lt;/td&gt;
&lt;td&gt;选取body下的倒数第二个div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[positon()&amp;lt;3]’)&lt;/td&gt;
&lt;td&gt;选取body下的前两个div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[@class]’)&lt;/td&gt;
&lt;td&gt;选取body下带有class属性的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[@class=‘main’]’)&lt;/td&gt;
&lt;td&gt;选取body下class属性是main的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘/body/div[price&amp;gt;35.00]’)&lt;/td&gt;
&lt;td&gt;选取body下price元素大于35的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;xpath通配符&quot;&gt;XPath通配符&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配任何元素节点&lt;/td&gt;
&lt;td&gt;xpath(‘/div/*’)&lt;/td&gt;
&lt;td&gt;选取div下的所有子节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@*&lt;/td&gt;
&lt;td&gt;匹配任何属性节点&lt;/td&gt;
&lt;td&gt;xpath(‘/div[@*]’)&lt;/td&gt;
&lt;td&gt;选取所有带属性的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;选取多个路径的节点&quot;&gt;选取多个路径的节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt; &lt;strong&gt;|&lt;/strong&gt; &lt;strong&gt;运算符可以选取多个路径&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;xpath(‘//div丨//table’)&lt;/td&gt;
&lt;td&gt;选取所有div和table节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;//book/title丨//book/price&lt;/td&gt;
&lt;td&gt;选取 book 元素的所有 title 和 price 元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;/bookstore/book/title丨//price&lt;/td&gt;
&lt;td&gt;选取属于 bookstore元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;使用功能函数进行模糊搜索&quot;&gt;使用功能函数进行模糊搜索&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;starts-with&lt;/td&gt;
&lt;td&gt;xpath(‘//div[starts-with(@id,‘ma’)]’)&lt;/td&gt;
&lt;td&gt;选取id值以ma开头的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;contains&lt;/td&gt;
&lt;td&gt;xpath(‘//div[contains(@id, ‘ma’)]’)&lt;/td&gt;
&lt;td&gt;选取id值包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;xpath(‘//div[contains(@id, ‘ma’) and contains(@id,”in”)]’)&lt;/td&gt;
&lt;td&gt;选取id值包含ma和in的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;text()&lt;/td&gt;
&lt;td&gt;xpath(‘//div[contains(text(),‘ma’)]’)&lt;/td&gt;
&lt;td&gt;选取节点文本包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;获取节点的文本内容和属性值&quot;&gt;获取节点的文本内容和属性值&lt;/h3&gt;
&lt;p&gt;前面讲了那么多获取节点的方式，都是为了最终获取到想要的文本数据做准备。XPath中获取节点文本信息使用&lt;code&gt;text()&lt;/code&gt;，获取节点的属性值使用&lt;code&gt;@属性&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201904/1099419-20190414153058609-363245832.png&quot; width=&quot;700&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201904/1099419-20190414153128077-447368561.png&quot; width=&quot;700&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from lxml import etree
import requests

html = requests.get('https://movie.douban.com/top250').content.decode('utf8')
print(html)
selector = etree.HTML(html)
title = selector.xpath('//div[@id=&quot;content&quot;]/h1/text()')
print(title)  # ['豆瓣电影 Top 250']

link = selector.xpath('//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[1]/a/@href')
print(link)  # ['https://movie.douban.com/subject/1292052/']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上图所示，我们使用获取一个节点文本信息以及一个节点的属性值。为了方便我们使用XPath，在浏览器中的开发者模式下，选中节点，右键，就可以Copy我们的想要路径。不过，这种路径有时并不是我们想要的，因为只能获取到当前这个的节点，所以我们更多时候需要对xpath路径进行构造。&lt;/p&gt;
&lt;h2 id=&quot;使用beautifulsoup&quot;&gt;使用BeautifulSoup&lt;/h2&gt;
&lt;p&gt;BeautifulSoup4(BS4)是Python的一个第三方库，用来从HTML和XML中提取数据。BeautifulSoup4在某些方面比XPath易懂，但是不如XPath简洁，而且由于它是使用Python开发的，因此速度比XPath慢。&lt;/p&gt;
&lt;p&gt;使用Beautiful Soup4提取HTML内容，一般要经过以下两步：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;处理源代码生成BeautifulSoup对象&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;soup = BeautifulSoup(网页源代码, ‘解析器’)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析器可以使用&lt;code&gt;html.parser&lt;/code&gt;也可以使用&lt;code&gt;lxml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;常使用find_all()、find()和select来查找内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from bs4 import BeautifulSoup

html = requests.get('https://movie.douban.com/top250').content.decode('utf8')
print(html)
soup = BeautifulSoup(html, 'lxml')
title = soup.select('#content &amp;gt; h1')[0].text
print(title)  # 豆瓣电影 Top 250
print(soup.find('h1').text)  # 豆瓣电影 Top 250

link = soup.select('#content &amp;gt; div &amp;gt; div.article &amp;gt; ol &amp;gt; li:nth-child(1) &amp;gt; div &amp;gt; div.info &amp;gt; div.hd &amp;gt; a')[0].get('href')
print(link)  # https://movie.douban.com/subject/1292052/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于BeautifulSoup库的使用完全可以参考文档学习，附上中文文档链接：&lt;a href=&quot;https://docs.pythontab.com/beautifulsoup4/&quot; class=&quot;uri&quot;&gt;https://docs.pythontab.com/beautifulsoup4/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;花了小半下午整理了对信息的提取方式。其中，最令我头疼的还是正则表达式，学习正则表达式已经有好几遍了，但是在需要使用的时候仍然需要去看手册。可能这就是一个反复的过程吧。下面附上这三种方式的一些参考学习链接：&lt;/p&gt;
&lt;p&gt;正则表达式：&lt;/p&gt;
&lt;p&gt;XPath：&lt;/p&gt;
&lt;p&gt;BeautifulSoup：&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 07:39:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 在我们获取了网页的信息后，往往需要对原始信息进行提取，得到我们想要的数据。对信息的提取方式主要有以下几种：正则表达式、XPath、BeautifulSoup。本篇博客主要总结这三种方式的基本语法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10705360.html</dc:identifier>
</item>
<item>
<title>Java 入门 - coding-for-self</title>
<link>http://www.cnblogs.com/longjiang-uestc/p/10705257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longjiang-uestc/p/10705257.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;Java 入门 - coding-for-self - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Java 入门 入门书籍 Java相关书籍: 《Java编程思想》 算是比较经典和全面的书籍; 10章可以快速过一下，都是基本语法，不需要花太多时间. 中后段的一些章节，类型信息、泛型、容器、IO、并&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=svlZeZMvc3He7PqOD4T7SOuQn0_kIfLBYiy3idqd35Y1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/ThinkInside/bundle-ThinkInside.css?v=RRjf6pEarGnbXZ86qxNycPfQivwSKWRa4heYLB15rVE1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/ThinkInside/bundle-ThinkInside-mobile.css?v=dZdjlmVwTnNeYyn_3io0YWHboviYj5KY0ZYF2D-nD9U1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;

&lt;h2 id=&quot;入门书籍&quot;&gt;入门书籍&lt;/h2&gt;
&lt;h3 id=&quot;java相关书籍&quot;&gt;Java相关书籍:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《Java编程思想》
&lt;ul&gt;&lt;li&gt;算是比较经典和全面的书籍;&lt;/li&gt;
&lt;li&gt;10章可以快速过一下，都是基本语法，不需要花太多时间.&lt;/li&gt;
&lt;li&gt;中后段的一些章节，类型信息、泛型、容器、IO、并发等.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;《深入理解Java虚拟机》
&lt;ul&gt;&lt;li&gt;Java底层的运行环境是主要是C++构建的.&lt;/li&gt;
&lt;li&gt;Java之所以有跨平台的特性，也是依赖Java虚拟机完成的大量平台相关的工作.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可选清单:
&lt;ul&gt;&lt;li&gt;《Java并发编程的艺术》
&lt;ul&gt;&lt;li&gt;巩固一下并发的部分.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;《Java网络编程》
&lt;ul&gt;&lt;li&gt;巩固一下网络编程的部分.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;《Java性能权威指南》
&lt;ul&gt;&lt;li&gt;掌握一点性能调优的知识.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;电子书籍链接&quot;&gt;电子书籍链接&lt;/h3&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2019-04-14 15:13&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/longjiang-uestc/&quot;&gt;coding-for-self&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=10705257&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/longjiang-uestc/p/10705257.html#&quot; onclick=&quot;AddToWz(10705257);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sun, 14 Apr 2019 07:13:00 +0000</pubDate>
<dc:creator>coding-for-self</dc:creator>
<og:description>Java 入门 入门书籍 Java相关书籍: 《Java编程思想》 算是比较经典和全面的书籍; 10章可以快速过一下，都是基本语法，不需要花太多时间. 中后段的一些章节，类型信息、泛型、容器、IO、并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longjiang-uestc/p/10705257.html</dc:identifier>
</item>
<item>
<title>完美解决phpstudy安装后mysql无法启动（无需删除原数据库，无需更改任何配置，无需更改端口）直接共存 - Cherrison_Time</title>
<link>http://www.cnblogs.com/Cherrison-Time/p/10705189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cherrison-Time/p/10705189.html</guid>
<description>&lt;h2&gt;一.前言&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;今天学习php，当然是要先安装好运行环境了，phpstyudy是一个运行php的集成环境， 一键安装对新手很友好，与时作为一个新手，便跟着教程安装了phpstudy集成环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很快安装好了，嗯。对新手确实很友好。phpmyadmin，Apache，php直接配置安装好了。省去了很多时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可是安装后却遇到一个麻烦事，就是这个Mysql启动后就会过几秒就显示Mysql已经停止（这个是我现在的我已经解决这个问题了，应该是个红色的方框，不要介意，/嘿嘿）。重启了很多遍。还是无法启动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201904/1531462-20190414142301944-260953344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这个时候不仅phpstudy里的mysql无法启动，我原来的mysql也不能启动了。这可怎么办我原来的还有很多数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二.原因分析&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;于是便去网上查找phpstudy和mysql冲突的问题， 哦原来是 这两个mysql都占用的是3306端口， 而系统原来的mysql会开机启动（就是这里，会让原来的mysql作为服务开机启动监听）。那么当你打开phpstudy的时候， 便会再启动一个mysql服务，这个时候因为是同一个端口的关系，那就冲突了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201904/1531462-20190414143009799-1761700361.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　网上确实有人和我一样遇到了这个问题，无非就是把原来的mysql删掉，或者修改配置文件的方式，显然这样解决并不是我想要的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;三.解决问题&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;于是我想这样解决试试吧。把phpstudy里的mysql端口改为3307是不是就不冲突了，我改了，理论上来说是可以成功了，可是依然是原来那个样子。算了太麻烦了。换个方法吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　这个时候我想把phpstudy里的mysql卸载了吧， 可是有没有找到phpstudy里设置mysql路径的设置。这个方案便行不通另想方案。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　于是那，我便想到把安装好的mysql移动到phpstudy的mysql目录下，把原来mysql所在位置的文件全部删除，这样是不是就可以让phpstudy使用原来的mysql数据库了，这样我又尝试了，还是没能解决问题。因为就算这样移动了mysql运行文件配置文件数据文件，上面那个计算机管理里面的服务还是在启动原来位置的mysql服务，而且这个mysql服务指定的mysql服务文件路径无法修改。这个方案便行不通！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　我们再来换个思路。这次我把原来的mysql目录删除的文件全部恢复，这下原来的mysql和phpstudy的mysql文件夹的便有相同的内容，如下图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;移动时选择全部替换。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201904/1531462-20190414144732169-2084754808.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201904/1531462-20190414142047056-971945422.png&quot; alt=&quot;&quot; width=&quot;1109&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　&lt;span&gt;总结一下解决方法就是把上图左边所有文件，直接复制到→_→右边~~~&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后再来个成功截图，耶~~~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201904/1531462-20190414145306085-367418046.png&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;634&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;这个时候问题就完美的解决了，既能保留原来的数据，实现两个mysql共存，操作又无需修改配置文件，只要ctrl+c ctr+v就解决问题了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;本人水平有限如有问题欢迎指正。&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;span&gt;&lt;strong&gt;&lt;em&gt;有什么问题也可以到下方评论，我看到后还帮忙解决！&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Apr 2019 06:56:00 +0000</pubDate>
<dc:creator>Cherrison_Time</dc:creator>
<og:description>PHPstudy与原Mysql兼容解决 一.前言 今天学习php，当然是要先安装好运行环境了，phpstyudy是一个运行php的集成环境， 一键安装对新手很友好，与时作为一个新手，便跟着教程安装了p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cherrison-Time/p/10705189.html</dc:identifier>
</item>
<item>
<title>Linux framebuffer测试程序 - Vedic</title>
<link>http://www.cnblogs.com/vedic/p/10705191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vedic/p/10705191.html</guid>
<description>&lt;p&gt;　　Linux framebuffer的框架非常简单， 对于应用程序就是操作一块内存（俗称帧缓存）， 当然也有可能是双缓存， 一般用于高帧率场景， 一块帧在填充数据时， 另一块在显示， 接着对调过来，&lt;/p&gt;
&lt;p&gt;那通过设置哪里告知驱动层读取哪块帧数据呢？ 答案是用vinfo.xoffset， vinfo.yoffset&lt;/p&gt;
&lt;p&gt;　　需要注意的是， 无论用write()、还是mmap()后直接操作内存都只是填充内存而已， 并不代表能够立马显示， 这得看驱动， 如果驱动实现了自刷新（不断从帧缓存拿数据刷到LCD上）， 那填充数据到帧缓存就会立马显示出来，&lt;/p&gt;
&lt;p&gt;如果驱动没有实现，那应用程序需要主动的调用 ioctl(fp, FBIOPAN_DISPLAY, &amp;amp;vinfo);， 告知驱动可以刷数据了， 如果这都没显示出来， 估计驱动没实现FBIOPAN_DISPLAY功能。&lt;/p&gt;
&lt;p&gt;示例代码：（驱动实现自刷新， 应用依次显示黄、蓝、红，最后画线）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;linux/fb.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; RED    0xF800
&lt;span&gt;#define&lt;/span&gt; YELLOW    0xFFE0
&lt;span&gt;#define&lt;/span&gt; BLUE     0x001F
&lt;span&gt;#define&lt;/span&gt; WHITE    0xFFFF 
&lt;span&gt;#define&lt;/span&gt; BLACK    0x0000


&lt;span&gt;void&lt;/span&gt; fill_color16(&lt;span&gt;short&lt;/span&gt; *fb_addr, &lt;span&gt;short&lt;/span&gt; bit_map, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; psize)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;psize; i++&lt;span&gt;) {
        &lt;/span&gt;*fb_addr =&lt;span&gt; bit_map;
        fb_addr&lt;/span&gt;++&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()   
{  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fp=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; fb_var_screeninfo vinfo;  
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; fb_fix_screeninfo finfo;  
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; screensize=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *fbp = NULL, *test_fbp=&lt;span&gt;NULL;    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;, y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; location = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pix_size=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    fp &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/graphics/fb0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_RDWR);  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fp &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {  
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error : Can not open framebuffer device/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
    }  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ioctl(fp, FBIOGET_FSCREENINFO, &amp;amp;&lt;span&gt;finfo)){  
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error reading fixed information/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);  
    }  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ioctl(fp, FBIOGET_VSCREENINFO, &amp;amp;&lt;span&gt;vinfo)){  
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error reading variable information/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);  
    }  

    screensize &lt;/span&gt;= vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;  

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The phy mem = 0x%x, total size = %d(byte)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, finfo.smem_start, finfo.smem_len);  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xres =  %d, yres =  %d, bits_per_pixel = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;So the screensize = %d(byte), using %d frame\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, screensize, finfo.smem_len/&lt;span&gt;screensize);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.xoffset = %d, vinfo.yoffset = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.xoffset, vinfo.yoffset);  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.vmode is :%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.vmode);  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finfo.ypanstep is :%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, finfo.ypanstep);  
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.red.offset=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.red.offset);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.red.length=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.red.length);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.green.offset=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.green.offset);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.green.length=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.green.length);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.blue.offset=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.blue.offset);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.blue.length=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.blue.length);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.transp.offset=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.transp.offset);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinfo.transp.length=0x%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vinfo.transp.length);
    

    fbp &lt;/span&gt;=(&lt;span&gt;char&lt;/span&gt; *)mmap(&lt;span&gt;0&lt;/span&gt;, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fp,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;int&lt;/span&gt;)fbp == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)  
    {    
        printf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error: failed to map framebuffer device to memory./n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit (&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);  
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get virt mem = %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, fbp);  


    pix_size &lt;/span&gt;= vinfo.xres *&lt;span&gt; vinfo.yres;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; using first frame, for FBIOPAN_DISPLAY
     * 当刷新需要调用FBIOPAN_DISPLAY， 要告知驱动刷哪块帧， 用到下面两个参数
     * 如果使用第二帧buffer -&amp;gt; vinfo.xoffset = 0; vinfo.yoffset = vinfo.yres;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    vinfo.xoffset &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    vinfo.yoffset &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; show color loop &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(num--&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ndrawing YELLOW......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        fill_color16((&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *&lt;span&gt;)fbp, YELLOW, pix_size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ioctl(fp, FBIOPAN_DISPLAY, &amp;amp;vinfo);&lt;/span&gt;
        sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ndrawing BLUE......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        fill_color16((&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *&lt;span&gt;)fbp, BLUE, pix_size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ioctl(fp, FBIOPAN_DISPLAY, &amp;amp;vinfo);&lt;/span&gt;
        sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ndrawing RED......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        fill_color16((&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *&lt;span&gt;)fbp, RED, pix_size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ioctl(fp, FBIOPAN_DISPLAY, &amp;amp;vinfo);&lt;/span&gt;
        sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; 1
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;这是你想画的点的位置坐标,(0，0)点在屏幕左上角&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    
    x &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;  
    y &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;  
    location &lt;/span&gt;= x * (vinfo.bits_per_pixel / &lt;span&gt;8&lt;/span&gt;) + y  *&lt;span&gt;  finfo.line_length;  
    test_fbp &lt;/span&gt;= fbp +&lt;span&gt; location;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;draw line.......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; (vinfo.xres - x); i++&lt;span&gt;)
        &lt;/span&gt;*test_fbp++ = i+&lt;span&gt;30&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ioctl(fp, FBIOPAN_DISPLAY, &amp;amp;vinfo);&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

    munmap(fbp, screensize); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;解除映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  

    close (fp);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然用read()/write()， 也可以， 就是效率非常低， 太多系统调用导致系统在用户态和kernel态切换， 而且每次还传输一个字节， 但作为例子可以参考一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include &amp;lt;unistd.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;linux/fb.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;sys/mman.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; RED    0xF800
&lt;span&gt;#define&lt;/span&gt; YELLOW    0xFFE0
&lt;span&gt;#define&lt;/span&gt; BLUE     0x001F
&lt;span&gt;#define&lt;/span&gt; WHITE    0xFFFF 
&lt;span&gt;#define&lt;/span&gt; BLACK    0x0000



&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()   
{  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fp=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; fb_var_screeninfo vinfo;  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pix_size=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; color1, color2;

    fp &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/graphics/fb0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_RDWR);  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fp &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {  
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error : Can not open framebuffer device/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
    }  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ioctl(fp, FBIOGET_VSCREENINFO, &amp;amp;&lt;span&gt;vinfo)){  
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error reading variable information/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
        exit(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);  
    }  


    pix_size &lt;/span&gt;= vinfo.xres *&lt;span&gt; vinfo.yres;
    color1 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    color2 &lt;/span&gt;= &lt;span&gt;0xf8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;pix_size; i++&lt;span&gt;) {
        write(fp, &lt;/span&gt;&amp;amp;color1, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        write(fp, &lt;/span&gt;&amp;amp;color2, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);        
    }

    close (fp);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 14 Apr 2019 06:56:00 +0000</pubDate>
<dc:creator>Vedic</dc:creator>
<og:description>Linux framebuffer的框架非常简单， 对于应用程序就是操作一块内存（俗称帧缓存）， 当然也有可能是双缓存， 一般用于高帧率场景， 一块帧在填充数据时， 另一块在显示， 接着对调过来， 那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vedic/p/10705191.html</dc:identifier>
</item>
<item>
<title>highcharts之数据列分区 - Fine-YT</title>
<link>http://www.cnblogs.com/Fine-YT/p/10705107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fine-YT/p/10705107.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在highcharts中，用于数据列分区的主要 api 属性为 zones&lt;/strong&gt;&lt;br/&gt;官网api释义 ：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;An array defining zones within a series. Zones can be applied to the X axis, Y axis or Z axis for bubbles, according to the zoneAxis option. The zone definitions have to be in ascending order regarding to the value.&lt;br/&gt;定义系列中区域的数组。 根据zoneAxis选项，可以将区域应用于X轴，Y轴或Z轴以获得气泡。 区域定义必须按照值的升序排列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;备注:&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;设置图形的默认颜色可以在 series 中设置 color，也可以在 zones 中设置一组 {color: 'red'}此时不用设置 value,如果两者同时设置了，则 zones 中的颜色会覆盖掉 series 中的color&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于各种类型图的 zones 都差不多，这里只以 column 和 line 进行示例&lt;br/&gt;&lt;strong&gt;示例代码 :&lt;/strong&gt; &lt;a href=&quot;https://jshare.com.cn/columns/VFdvLu&quot; class=&quot;uri&quot; title=&quot;数据列分区&quot;&gt;https://jshare.com.cn/columns/VFdvLu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-column-类型&quot;&gt;一： column 类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求 :&lt;/strong&gt; 将 column 中月收益小于0的柱子显示为 绿色，大于 0 显示为 红色&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript&quot;&gt;
series: [{
  data: [-10, -5, 0, 5, 10, 15, 10, 10, 5, 0, -5],
  color: 'red', // 默认颜色
  zones: [{
    // 小于0显示 'green',大于0的则使用默认颜色 'red'
    value: 0,
    color: 'green',
    dashStyle: 'dot'
  }]
}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效果图 :&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334479/201904/1334479-20190414144407391-1494047544.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二line-类型&quot;&gt;二：line 类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求 :&lt;/strong&gt; 将数值小于0显示为绿色，0 - 10 显示为蓝色，大于10显示为红色&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript&quot;&gt;
series: [{
  data: [-10, -5, 0, 5, 10, 15, 10, 10, 5, 0, -5],
  color: 'green', // 默认颜色
  zones: [{
    value: 0,
    color: 'green',
    dashStyle: 'dot'
  }, {
    value: 10,
    color: 'blue'
  }, {
    color: 'red' // 这里设置的颜色会覆盖掉 series 中设置的颜色 'green',最终大于0部分显示为 'red'
  }]
}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效果图 :&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334479/201904/1334479-20190414144421834-828539692.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 06:40:00 +0000</pubDate>
<dc:creator>Fine-YT</dc:creator>
<og:description>zones 在highcharts中，用于数据列分区的主要 api 属性为 zones 官网api释义 ： An array defining zones within a series. Zones</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fine-YT/p/10705107.html</dc:identifier>
</item>
<item>
<title>形参与实参 - Baokx</title>
<link>http://www.cnblogs.com/FC-001/p/10705102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FC-001/p/10705102.html</guid>
<description>&lt;p&gt;今天偶然从书上看到“形参与实参”&lt;/p&gt;
&lt;p&gt;如果运行下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

void swap(int a,int b){

    int t=a;

    a=b;

    b=t;

}

int mian(){

    int x,y;

    swap(x,y);

    cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;y;

    return 0;

} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是得不到交换的&lt;/p&gt;
&lt;p&gt;因为a与b只是x与y的副本&lt;/p&gt;
&lt;p&gt;a与b的交换并不会导致x与y的交换&lt;/p&gt;
&lt;p&gt;就相当于a与b复制了x与y，但a与b做改动是不会影响x与y的&lt;/p&gt;
&lt;p&gt;同时，形参与实参也是有许多不同的&lt;/p&gt;
&lt;p&gt;实参一定要有一个确定的量&lt;/p&gt;
&lt;p&gt;而形参的量是由它复制的实参的量决定的&lt;/p&gt;
&lt;p&gt;所以怎么办才可以让x与y交换呢&lt;/p&gt;
&lt;p&gt;1.全局变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

void swap(){

    int t=x;

    x=y;

    y=t;

}

int mian(){

    swap();

    cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;y;

    return 0;

}     &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.加上“&amp;amp;”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

void swap(int &amp;amp;a,int &amp;amp;b){

    int t=a;

    a=b;

    b=t;

}

int mian(){

    int x,y;

    swap(x,y);

    cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;y;

    return 0;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个值得提一下，在a与b前加上&amp;amp;，就相当于说a与b就是x与y的小名啦&lt;/p&gt;
&lt;p&gt;既然只是名字不同那一个变另一个不也变吗&lt;/p&gt;
&lt;p&gt;3.我脑子疯啦™用什么函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;

using namespace std;

int mian(){

    int x,y;

    int t=x;

    x=y;

    y=t;

    cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;y;

    return 0;

}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（其实我理解的也不是很透彻啦，所以有bug欢迎回复QWQ）&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 06:39:00 +0000</pubDate>
<dc:creator>Baokx</dc:creator>
<og:description>实参与形参究竟有什么不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FC-001/p/10705102.html</dc:identifier>
</item>
<item>
<title>如何优化冒泡排序？ - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/10705097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/10705097.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;96&quot;&gt;
&lt;h3 id=&quot;hbubblesort&quot;&gt;&lt;span&gt;一、冒泡排序（BubbleSort）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：从左到右使用相邻两个元素进行比较，如果第一个比第二个大，则交换两个元素。这样会使较大数下沉到数组的尾端，即较小数像泡泡一样冒到数组首端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排序过程：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;比较相邻两个元素，如果第一个比第二个大，则交换两个元素；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从左到右依次比较，直到最大数位于数组尾端；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重复N-1次1、2步骤，(除去已经排序的最大数)依次将第二，第三。。。第N-1大的数排好位置。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;原序列&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;第1趟&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第2趟&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第3趟&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第4趟&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第5趟&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第6趟&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第7趟&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如表格所示，每一趟都将当前乱序序列中最大的数移到尾端。【小伙伴们从表格中看出基本冒泡排序可以优化的地方了吗？】下面先来基本实现代码。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;java实现冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == nums || nums.length == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数组为null或长度为0&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;T temp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = nums.length;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - i; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j].compareTo(nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;temp = nums[j];&lt;br/&gt;nums[j] = nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = temp;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从表格中，相信小伙伴已经看出，在第5趟其实已经排好序了，但基本的冒泡排序算法还会进行第7趟比较，这其实只是进行没必要的比较，而不会进行元素的交换。（第6趟还是必须要走的，下面会说明）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;时间、空间复杂度及稳定性分析：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;时间复杂度：由于内外循环都发生N次迭代，所以时间复杂度为&lt;strong&gt;O(n^2)&lt;/strong&gt;。并且这个界是精确的。思考最坏的情况，输入一个逆序的数组，则比较次数为：&lt;/p&gt;
&lt;p&gt;(N-1)+(N-2)+(N-3)+..+2+1 = n*(n-1)/2 = O(n^2)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;空间复杂度：只使用了一个临时变量，所以为&lt;strong&gt;O(1)&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;是否稳定：&lt;strong&gt;稳定排序&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;二、优化冒泡排序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;​ 我们换个角度看待这个问题。基本冒泡算法之所以进行了无用的多余扫描，是因为不知道已经排好了序；所以只要我们在第 i 趟（i小于N-1）就知道序列已经排好序，我们就不用进行之后的扫描了。&lt;/p&gt;
&lt;p&gt;综上所述，我们可以增加一个boolean变量，来标识是否已经排好序。优化代码如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序优化普通版：&lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == nums || nums.length == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数组为null或长度为0&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;T temp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = nums.length;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - i; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j].compareTo(nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;temp = nums[j];&lt;br/&gt;nums[j] = nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = temp;&lt;br/&gt;isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isOrdered) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：虽然第5趟已经排好序，但对于程序来说，它并不知道此趟已经排好序，需要进行下一趟扫描来确定上一趟是否已经将原序列排好序。所以第6趟是必须要去扫描的。&lt;/p&gt;
&lt;p&gt;你以为结束了吗？哈哈哈，还没有，这只是第一版优化。&lt;/p&gt;
&lt;p&gt;让我们想一想这样的情况。对于下列序列，前半部分乱序，后半部分有序。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;原序列&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;第一趟&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二趟&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第三趟&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简述排序过程：&lt;/p&gt;
&lt;p&gt;第一趟：发生交换的是5和3，接着是5和2；随后5与6比较，不需要换位置，相同地，6与7、7与8、8与9都不需要更换位置。所以第一趟结果为：[4,3,2,5,6,7,8,9]。&lt;/p&gt;
&lt;p&gt;第二趟：发生交换的是4与3，接着4与2；随后4与5、5与6，6与7、7与8都不需要更换位置。【8不需要与9比较，因为第一趟已经将最大的数下沉到尾端】。所以第二趟结果为：[3,2,4,5,6,7,8,9]。&lt;/p&gt;
&lt;p&gt;第三趟：发生交换的是3与2；随后3与4，4与5，5与6，6与7都不需要更换位置。所以第三趟结果为：[2,3,4,5,6,7,8,9]。&lt;/p&gt;
&lt;p&gt;大家看出什么了吗？其实进行了很多无意义的比较，因为这些都不需要更换位置，而很多趟都会重复比较。根据冒泡排序思想，我们知道，有序序列长度，其实跟排序趟数相等，每一趟就是将当前乱序中的最大值下沉到数组尾端。但其实序列真正有序的序列长度是大于当前排序趟数的。&lt;strong&gt;也就是说，只要我们找到了原序列中无序与有序的边界，就可以避免再去比较有序序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实最后一次交换的位置，就是无序序列与有序序列的边界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从例子中看：&lt;/p&gt;
&lt;p&gt;第一趟最后一次交换的位置是元素5与2交换的位置，即数组下标2的位置；&lt;/p&gt;
&lt;p&gt;第二趟最后一次交换的位置是元素4与2交换的位置，即数组下标1的位置；&lt;/p&gt;
&lt;p&gt;第三趟最后一次交换的位置是元素3与2交换的位置，即数组下标0的位置；&lt;/p&gt;
&lt;p&gt;所以，只要我们记录下当前趟最后一次交换的位置，在下一趟只比较到这个位置即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序优化加强版：&lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == nums || nums.length == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;数组为null或长度为0&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;T temp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; length = nums.length;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; lastExchangeIndex = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; unorderedBorder = length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j &amp;lt; unorderedBorder; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nums[j].compareTo(nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;temp = nums[j];&lt;br/&gt;nums[j] = nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;nums[j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = temp;&lt;br/&gt;isOrdered = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;lastExchangeIndex = j;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;unorderedBorder = lastExchangeIndex;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isOrdered) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，还可以进一步优化， 有兴趣的可以去看看鸡尾酒排序，我们已经很接近了。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;冒泡排序可以通过增加boolean标识是否已经排好序来进行优化；还可以记录下最后一次交换元素的位置来进行优化，防止无意义的比较。冒泡排序是稳定排序，时间复杂度为O(n^2)，空间复杂度为O(1)。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 14 Apr 2019 06:38:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>一、冒泡排序（BubbleSort） 基本思想：从左到右使用相邻两个元素进行比较，如果第一个比第二个大，则交换两个元素。这样会使较大数下沉到数组的尾端，即较小数像泡泡一样冒到数组首端。 排序过程： 比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9dragon/p/10705097.html</dc:identifier>
</item>
<item>
<title>servlet篇 之 跳转问题 - 千里之外kb</title>
<link>http://www.cnblogs.com/wskb/p/10705066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wskb/p/10705066.html</guid>
<description>&lt;p&gt;&lt;strong&gt;servlet&lt;span&gt;中的跳转&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跳转本质上是对文件传输操作&lt;/span&gt; &lt;span&gt;进行&lt;/span&gt; &lt;span&gt;封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;span&gt;客户端访问一个&lt;/span&gt;&lt;span&gt;servlet,&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;中需要把已经写好的页面&lt;/span&gt;&lt;span&gt;hello.html&lt;/span&gt;&lt;span&gt;返回给客户端浏览器，需要用&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;来实现这个功能&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;服务器内部跳转：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种情况&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器内部跳转到一个页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;获得一个指向&lt;/span&gt;&lt;span&gt;/hello.html&lt;/span&gt;&lt;span&gt;页面的跳转对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RequestDispatcher dispatcher =&lt;/p&gt;
&lt;p&gt;request.getRequestDispatcher(&quot;/hello.html&quot;);&lt;/p&gt;

&lt;p&gt;//&lt;span&gt;进行跳转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;跳转的同时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;response&lt;/span&gt;&lt;span&gt;传过去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;dispatcher.forward(request, response);&lt;/p&gt;

&lt;p&gt;&lt;span&gt;或者精简成一句代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;String url = &quot;/hello.html&quot;;&lt;/p&gt;
&lt;p&gt;request.getRequestDispatcher(url).forward(request, response);&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二种情况&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器内部跳转到另一个&lt;/span&gt;servlet&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1，&lt;span&gt;无论服务器内部跳转多少次&lt;/span&gt;,&lt;span&gt;每次都会把&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;res&lt;/span&gt;&lt;span&gt;转发给下一个跳转的地方&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;也就是整个过程里面&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;【&lt;/span&gt;&lt;span&gt;req&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;res&lt;/span&gt;&lt;span&gt;有且只有一个】，即最初的那个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2，&lt;span&gt;服务器内部跳转需要使用&lt;/span&gt;request&lt;span&gt;来完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3，&lt;span&gt;【跳转成功后】，【地址栏仍&lt;/span&gt;&lt;span&gt;显示最初&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;servlet&lt;span&gt;】信息。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;客户端重定向&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;第一种情况&lt;/span&gt;:&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;客户端重定向到一个页面&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;String url = &quot;hello.html&quot;;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;response.sendRedirect(url);&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;第二种情况&lt;/span&gt;:&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;客户端重定向到另一个&lt;/span&gt;servlet&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1，&lt;span&gt;每次进行客户端重定向&lt;/span&gt;,&lt;span&gt;都会是一个全新的&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;response&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2，&lt;span&gt;客户端重定向需要使用&lt;/span&gt;response&lt;span&gt;来完成&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3，&lt;span&gt;重定向到另一个资源中&lt;/span&gt;(&lt;span&gt;可能是页面也能&lt;/span&gt;&lt;span&gt;servlet),&lt;/span&gt;&lt;span&gt;那么浏览器的地址栏中显示的是重定向到的那个资源的地址！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Apr 2019 06:37:00 +0000</pubDate>
<dc:creator>千里之外kb</dc:creator>
<og:description>跳转分为服务器内部跳转和重定向，具体区别请看。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wskb/p/10705066.html</dc:identifier>
</item>
<item>
<title>JAVA并发编程&gt;&gt;四种实现方式 - DaxiaFreeman</title>
<link>http://www.cnblogs.com/zhujj1314/p/10704747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhujj1314/p/10704747.html</guid>
<description>&lt;p&gt;1、继承Thread&lt;/p&gt;
&lt;p&gt;2、实现Runable接口&lt;/p&gt;
&lt;p&gt;3、实现Callable接口通过FutureTask包装器来创建Thread线程&lt;/p&gt;
&lt;p&gt;4、通过Executor框架实现多线程的结构化，即线程池实现。（该实现方式将会下一篇单独介绍）&lt;/p&gt;
&lt;h2&gt;1、继承Thread&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0a6a9567-29c0-4087-818e-3124ad375f66')&quot; readability=&quot;8.5&quot;&gt;&lt;img id=&quot;code_img_closed_0a6a9567-29c0-4087-818e-3124ad375f66&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0a6a9567-29c0-4087-818e-3124ad375f66&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0a6a9567-29c0-4087-818e-3124ad375f66',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0a6a9567-29c0-4087-818e-3124ad375f66&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CreateThreadByExtendThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CreateThreadByExtendThread(String name) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=2;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;线程,线程号{&quot;+Thread.currentThread().getId()+&quot;},i=&quot;+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; 2、实现Runable接口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('127ec0d9-7186-4001-bbf7-b5ea01698cc2')&quot; readability=&quot;8&quot;&gt;&lt;img id=&quot;code_img_closed_127ec0d9-7186-4001-bbf7-b5ea01698cc2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_127ec0d9-7186-4001-bbf7-b5ea01698cc2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('127ec0d9-7186-4001-bbf7-b5ea01698cc2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_127ec0d9-7186-4001-bbf7-b5ea01698cc2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CreateThreadByImpleRunable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=2;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;线程,线程号{&quot;+Thread.currentThread().getId()+&quot;},i=&quot;+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;执行CreateThreadByExtendThread和CreateThreadByImpleRunable&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cbed3b8a-f85b-413c-b210-569c634207a3')&quot; readability=&quot;8&quot;&gt;&lt;img id=&quot;code_img_closed_cbed3b8a-f85b-413c-b210-569c634207a3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cbed3b8a-f85b-413c-b210-569c634207a3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cbed3b8a-f85b-413c-b210-569c634207a3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cbed3b8a-f85b-413c-b210-569c634207a3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateThread {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CreateThread() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * 测试并发编程实现方式
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         CreateThreadByExtendThread ctetThread = &lt;span&gt;new&lt;/span&gt; CreateThreadByExtendThread(&quot;AAAA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        ctetThread.start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Thread ctbrThread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; CreateThreadByImpleRunable(),&quot;BBBB&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        ctbrThread.start();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;执行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1568662/201904/1568662-20190414133654904-355164966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述是无返回结果的线程，二者区别：Thread类实现了Runable接口。从代码灵活性的角度考虑建议使用第二种方式。&lt;/p&gt;
&lt;h2&gt;3、实现Callable接口通过FutureTask包装器来创建Thread线程&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b37332bc-429a-4d9d-9ba0-5ec4d04159d8')&quot; readability=&quot;9.5&quot;&gt;&lt;img id=&quot;code_img_closed_b37332bc-429a-4d9d-9ba0-5ec4d04159d8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b37332bc-429a-4d9d-9ba0-5ec4d04159d8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b37332bc-429a-4d9d-9ba0-5ec4d04159d8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b37332bc-429a-4d9d-9ba0-5ec4d04159d8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CreateThreadByImpleCallable&amp;lt;String&amp;gt; &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; CreateThreadByImpleCallable&amp;lt;String&amp;gt; ctbc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=2;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             System.out.println(Thread.currentThread().getName()+&quot;线程,线程号{&quot;+Thread.currentThread().getId()+&quot;},i=&quot;+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (String) &quot;Game over&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  String getTask() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         ctbc = ctbc == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;new&lt;/span&gt; CreateThreadByImpleCallable&amp;lt;String&amp;gt;&lt;span&gt;() : ctbc;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         FutureTask&amp;lt;String&amp;gt; ftTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;&lt;span&gt;(ctbc);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Thread ftThread = &lt;span&gt;new&lt;/span&gt; Thread(ftTask,&quot;CCCC&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        ftThread.start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ftTask.get();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上述main方法添加此行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e883fa2d-de39-4e8c-8f28-cb6f588ad54b')&quot; readability=&quot;7&quot;&gt;&lt;img id=&quot;code_img_closed_e883fa2d-de39-4e8c-8f28-cb6f588ad54b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e883fa2d-de39-4e8c-8f28-cb6f588ad54b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e883fa2d-de39-4e8c-8f28-cb6f588ad54b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e883fa2d-de39-4e8c-8f28-cb6f588ad54b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             System.out.print(&lt;span&gt;new&lt;/span&gt; CreateThreadByImpleCallable&amp;lt;String&amp;gt;&lt;span&gt;().getTask());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (InterruptedException |&lt;span&gt; ExecutionException e) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;执行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1568662/201904/1568662-20190414145227591-325519900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Apr 2019 06:31:00 +0000</pubDate>
<dc:creator>DaxiaFreeman</dc:creator>
<og:description>概述 1、继承Thread 2、实现Runable接口 3、实现Callable接口通过FutureTask包装器来创建Thread线程 4、通过Executor框架实现多线程的结构化，即线程池实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhujj1314/p/10704747.html</dc:identifier>
</item>
<item>
<title>最优二叉搜索树 - BATcaesar</title>
<link>http://www.cnblogs.com/BATcaesar-mmm/p/OBST.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BATcaesar-mmm/p/OBST.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;已知二叉树集合p为根结点频率，集合q为叶结点的频率，根据比较权值大小，找出最优二叉搜索树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;span&gt;编程语言：c++&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　编译器：Code::Blocks 16.01&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　操作系统：windows 10&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;源代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//最优二叉搜索树&lt;/p&gt;
&lt;p&gt;/*测试数据&lt;br/&gt;5&lt;br/&gt;0.15 0.1 0.05 0.1  0.2&lt;br/&gt;0.05 0.1 0.05 0.05 0.05 0.1&lt;br/&gt;*/&lt;/p&gt;
&lt;p&gt;#include&amp;lt;iostream&amp;gt;&lt;br/&gt;#include &amp;lt;limits.h&amp;gt;  //极限值头文件，INT_MAX无穷大，INT_MIN无穷小&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;void OBST(double *p,double *q,int n,double **e,int **r,double **w)&lt;br/&gt;{&lt;br/&gt;    for(int i=1;i&amp;lt;=n+1;i++)&lt;br/&gt;    {&lt;br/&gt;        e[i][i-1]=q[i-1];&lt;br/&gt;        w[i][i-1]=q[i-1];&lt;br/&gt;    }&lt;br/&gt;    for(int l=1;l&amp;lt;=n;l++)&lt;br/&gt;    {&lt;br/&gt;        for(int i=1;i&amp;lt;=n-l+1;i++)&lt;br/&gt;        {&lt;br/&gt;            int j=i+l-1;&lt;br/&gt;            e[i][j]=INT_MAX;  //INT_MAX（无穷大）&lt;br/&gt;            w[i][j]=w[i][j-1]+p[j]+q[j];&lt;br/&gt;            for(int k=i;k&amp;lt;=j;k++)&lt;br/&gt;            {&lt;br/&gt;                double t=e[i][k-1]+e[k+1][j]+w[i][j];&lt;br/&gt;                if(t&amp;lt;e[i][j])&lt;br/&gt;                {&lt;br/&gt;                    e[i][j]=t;&lt;br/&gt;                    r[i][j]=k;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;int main()&lt;br/&gt;{&lt;br/&gt;    int nn;  //根结点个数&lt;br/&gt;    double *pp,*qq;  //pp数组：根结点概率  qq数组：叶结点概率&lt;br/&gt;    double **ee,**ww;  //ee二维数组：存储树的搜索权值  ww[i][j]=q[i-1]+p[i]+q[i]+...+p[j]+q[j]（i,j范围内的所有概率之和）&lt;br/&gt;    int **root;  //存放根结点&lt;/p&gt;
&lt;p&gt;    cout&amp;lt;&amp;lt;&quot;根结点个数：&quot;;&lt;br/&gt;    cin&amp;gt;&amp;gt;nn;&lt;/p&gt;
&lt;p&gt;    pp = new double[nn+1];&lt;br/&gt;    qq = new double[nn+1];&lt;br/&gt;    //输入数据&lt;br/&gt;    cout&amp;lt;&amp;lt;&quot;根结点概率：&quot;&amp;lt;&amp;lt;endl;&lt;br/&gt; for(int r=1;r&amp;lt;=nn;r++)&lt;br/&gt;        cin&amp;gt;&amp;gt;pp[r];&lt;br/&gt;    cout&amp;lt;&amp;lt;&quot;叶结点概率：&quot;&amp;lt;&amp;lt;endl;&lt;br/&gt; for(int r=0;r&amp;lt;=nn;r++)&lt;br/&gt;        cin&amp;gt;&amp;gt;qq[r];&lt;/p&gt;
&lt;p&gt;    //创建动态二维数组&lt;br/&gt;    ee = new double*[nn+2];&lt;br/&gt;    root = new int*[nn+2];&lt;br/&gt;    ww = new double*[nn+2];&lt;br/&gt; for(int i=0;i&amp;lt;=nn+1; i++)&lt;br/&gt; {&lt;br/&gt;  ee[i] = new double[nn+1];&lt;br/&gt;  root[i] = new int[nn+1];&lt;br/&gt;  ww[i] = new double[nn+1];&lt;br/&gt; }&lt;/p&gt;
&lt;p&gt; //赋初值&lt;br/&gt; for(int j=0;j&amp;lt;=nn+1;j++)&lt;br/&gt;    {&lt;br/&gt;        for(int k=0;k&amp;lt;=nn;k++)&lt;br/&gt;        {&lt;br/&gt;            ee[j][k]=-1;&lt;br/&gt;            root[j][k]=-1;&lt;br/&gt;            ww[j][k]=-1;&lt;br/&gt;        }&lt;br/&gt;    }&lt;/p&gt;
&lt;p&gt;    cout&amp;lt;&amp;lt;endl;&lt;br/&gt;    OBST(pp,qq,nn,ee,root,ww);//调用函数，根据二维数组root[i][j]画出二叉树&lt;/p&gt;
&lt;p&gt;    //输出二维数组&lt;br/&gt;    for(int j=0;j&amp;lt;=nn+1;j++)&lt;br/&gt;    {&lt;br/&gt;        for(int k=0;k&amp;lt;=nn;k++)&lt;br/&gt;            cout&amp;lt;&amp;lt;ee[j][k]&amp;lt;&amp;lt;&quot;\t&quot;;&lt;br/&gt;        cout&amp;lt;&amp;lt;endl;&lt;br/&gt;    }&lt;br/&gt;    cout&amp;lt;&amp;lt;endl;&lt;/p&gt;
&lt;p&gt;    for(int j=0;j&amp;lt;=nn+1;j++)&lt;br/&gt;    {&lt;br/&gt;        for(int k=0;k&amp;lt;=nn;k++)&lt;br/&gt;            cout&amp;lt;&amp;lt;root[j][k]&amp;lt;&amp;lt;&quot;\t&quot;;&lt;br/&gt;        cout&amp;lt;&amp;lt;endl;&lt;br/&gt;    }&lt;br/&gt;    cout&amp;lt;&amp;lt;endl;&lt;/p&gt;
&lt;p&gt;    for(int j=0;j&amp;lt;=nn+1;j++)&lt;br/&gt;    {&lt;br/&gt;        for(int k=0;k&amp;lt;=nn;k++)&lt;br/&gt;            cout&amp;lt;&amp;lt;ww[j][k]&amp;lt;&amp;lt;&quot;\t&quot;;&lt;br/&gt;        cout&amp;lt;&amp;lt;endl;&lt;br/&gt;    }&lt;br/&gt;    cout&amp;lt;&amp;lt;endl;&lt;/p&gt;
&lt;p&gt;    //释放空间&lt;br/&gt;    delete[] pp;&lt;br/&gt;    delete[] qq;&lt;/p&gt;
&lt;p&gt;    for(int i=0;i&amp;lt;=nn+1;i++)&lt;br/&gt; {&lt;br/&gt;  delete[] ee[i];&lt;br/&gt;  delete[] root[i];&lt;br/&gt;  delete[] ww[i];&lt;br/&gt; }&lt;br/&gt;    delete[] ee;&lt;br/&gt;    delete[] root;&lt;br/&gt;    delete[] ww;&lt;/p&gt;
&lt;p&gt;    return 0;&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行界面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1650840/201904/1650840-20190414142044304-52326137.png&quot; alt=&quot;&quot; width=&quot;931&quot; height=&quot;592&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 14 Apr 2019 06:25:00 +0000</pubDate>
<dc:creator>BATcaesar</dc:creator>
<og:description>问题描述： 已知二叉树集合p为根结点频率，集合q为叶结点的频率，根据比较权值大小，找出最优二叉搜索树。 备注： 编程语言：c++ 编译器：Code::Blocks 16.01 操作系统：windows</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BATcaesar-mmm/p/OBST.html</dc:identifier>
</item>
</channel>
</rss>