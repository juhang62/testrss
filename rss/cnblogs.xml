<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关系数据库基本术语 - Visitors</title>
<link>http://www.cnblogs.com/dmeck/p/10507936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dmeck/p/10507936.html</guid>
<description>&lt;h2&gt;来源&lt;/h2&gt;
&lt;p&gt;《数据库系统原理》&lt;/p&gt;
&lt;h2&gt;第二节　　关系数据模型&lt;/h2&gt;
&lt;p&gt;　　关系数据库系统是支持关系模型的数据库系统。作为一种数据模型，关系模型同样包含三个组成要素，分别是关系数据结构、关系操作集合和关系完整性约束。&lt;/p&gt;
&lt;h2&gt;一、关系数据结构&lt;/h2&gt;
&lt;p&gt;　　关系模型的数据结构非常简单，只包含单一的数据结构。即关系。在关系模型中，现实世界的实体以及实体间的各种联系，均是使用关系来表示。在用户看来，关系模型是把数据库表示为数据的集合，且关系数据库 是以二维表格的形式组织数据，例如表2.1就是一张记录学生基本信息的二维表格，该表格为学生基本信息登记表。&lt;/p&gt;
&lt;h3&gt;表2.1　　学生基本信息登记表&lt;/h3&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;col width=&quot;32*&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;学号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;姓名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;性别&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;出生日期&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;籍贯&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;民族&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;班号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;身份证号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;201311111&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张沙&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;男&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;1997/12/11&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;山西&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;201311112&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张萌&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;女&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;1996/6/1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;安徽&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;201311113&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张伊尉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;女&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;1998/1/1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;安徽&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　下面。以表2.1所示的二维表格为例，介绍关系数据库的基本术语。&lt;/p&gt;
&lt;h3&gt;　　1.表（Table）&lt;/h3&gt;
&lt;p&gt;　　表，也称为关系，是一个二维的数据结构，它由表名、构成表的各个列（如学号，姓名，性别，出生日期等）及若干行数据（各个学生的基本信息）组成。每个表有一个唯一的表名，表中每一行数据描述一条具体的记录值，如一个学生的基本信息。&lt;/p&gt;
&lt;h3&gt;　　2.关系（Relation）&lt;/h3&gt;
&lt;p&gt;　　一个关系逻辑上对应一张二维表，可以为每个关系取一个名称进行标识。例如，表2.1所示的学生基本信息登记表，也即学生基本信息登记表关系。&lt;/p&gt;
&lt;p&gt;　　关系可以有三种类型，即基本关系、查询表和视图表。其中，基本关系通常又称为基本表或基表，是实际存在的表，它是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，部队营实际存储的数据。&lt;/p&gt;
&lt;h3&gt;　　3.列（Column）&lt;/h3&gt;
&lt;p&gt;　　表中的列，也称作字段（Field）或属性（Attribute）。表中每一列有一个名称，称为列名、字段名或属性名。每一列表示实体的一个属性，具有相同的数据类型。如表2.2所示，它列出了表2.1学生基本信息登记表中各个字段的字段名及其数据类型的定义。&lt;/p&gt;
&lt;h3&gt;表2.2　　学生基本信息登记表的结构定义&lt;/h3&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;中文字段名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;数据类型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;宽度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;学号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;姓名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;性别&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;出生日期&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;日期型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;籍贯&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;民族&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;班号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;身份证号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;18&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;　　需要说明的是：在一个数据库中，表名必须唯一；在表中，字段名必须唯一，不同表中可以出现相同的字段名；表和字段的命名应尽量有意义，尽量简单。&lt;/p&gt;
&lt;h3&gt;　　4.属性（Attribute）&lt;/h3&gt;
&lt;p&gt;　　表中的一列即为一个属性，给每一个属性起一个名称极为属性名。与之同义的术语是“列”。表中属性的个数称为关系的元或度。列的值称为属性值；属性值的取值范围称为值域。例如，表2.1中学生基本信息登记表关系的属性有：学号、姓名、性别、出生日期、籍贯、民族、版号、身份证，所以元数是8，即学生基本信息登记表关系是一个8元关系或8度关系。&lt;/p&gt;
&lt;h3&gt;　　5.行（Row）&lt;/h3&gt;
&lt;p&gt;　　表中的行（Row），也称作元组（Tuple）或记录（Record）。表中的数据是按行存储的。表中的一行数据即为一个元组或一条记录，其每行由若干字段值组成，每个字段值描述该对象的一个属性或特征。例如，在表2.1中，第一行数据表示的是学号为201311111、姓名为张沙的学生基本信息。&lt;/p&gt;
&lt;h3&gt;　　6.元组（Tuple）&lt;/h3&gt;
&lt;p&gt;　　表中的一行即为一个元组。例如，在表2.1中的元组有：&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;201311111&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张沙&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;男&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;1997/12/11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;山西&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;201311112&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张萌&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;女&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;1996/6/1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;安徽&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;201311113&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张伊尉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;女&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;1998/1/1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;安徽&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;等。&lt;/p&gt;
&lt;h3&gt;　　7.分量（Component）&lt;/h3&gt;
&lt;p&gt;　　元组中的一个属性值，称为分量。例如，在学生基本信息登记表中元组&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;201311112&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;张萌&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;女&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;1996/6/1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;安徽&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;汉&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;AC1311&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;XXX2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;的每一个属性值：“201311112”、“张萌”、“女”、“1996/6/1”，“安徽”，“汉”，“AC1311”，“XXX2”都是它的分量。&lt;/p&gt;
&lt;h3&gt;　　8.码或键（Key）&lt;/h3&gt;
&lt;p&gt;　　如果在一个关系中，存在这样的属性（或属性组），使得在该关系的任何一个关系状态中的两个元组，在该属性（或属性组）上值的组合都不相同，即这些属性（或属性组）的值都能用来唯一标识该关系的元组，称这些属性（或属性组）为该关系的码或键。（读者译：物理数据“实际数据”值的引用）&lt;/p&gt;
&lt;h3&gt;　　9.超码或超键（Super Key）&lt;/h3&gt;
&lt;p&gt;　　　如果在关系的一个码中移去某个属性，它仍然是这个关系的码，则称这样的码或键为该关系的超码或超键。一般的，每个关系至少有一个默认的超码或超键，即该关系的所有属性的集合，也是这个关系的最大超码或超键。例如，在表2.1中，&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;学号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;姓名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;性别&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;出生日期&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;籍贯&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;民族&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;班号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;13%&quot;&gt;
&lt;p&gt;身份证号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　都是超码或超键。&lt;/p&gt;
&lt;h3&gt;　　10.候选码或候选键（Candidate Key）&lt;/h3&gt;
&lt;p&gt;　　如果在关系的一个码或键中，不能从中移去任何一个属性，否则它就不是这个关系的码或键，则称这样的为该关系的候选码或候选键。可见，一个关系的候选码是这个关系的最小超码或超键。例如，表2.1最中学号和身份证号都是候选建，因为若给定学号或身份证号，都可以确定一个学生的全部基本信息。&lt;/p&gt;
&lt;p&gt;　　有些情况下，需要几个属性（即属性组或属性集合）才能唯一确定一条记录。例如，对于表2.3所示的学生成绩表的结构定义，仅仅确定学号或课程号，都不能唯一确定某个学生具体一门课程的成绩。所以，学生成绩表的主键是由学号和课程号两个属性组成的属性集合，即（学号，课程号）。&lt;/p&gt;
&lt;h3&gt;表2.3　　学生成绩表的结构定义&lt;/h3&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;中文字段名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;数据类型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;宽度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;学号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;课程号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;开课学期&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot; height=&quot;18&quot;&gt;
&lt;p&gt;成绩&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;数值型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;　　11.主码或主键（Primary Key）&lt;/h3&gt;
&lt;p&gt;　　在一个关系的若干候选码或候选键中指定一个用来唯一标识关系的元组，则称这个被指定的候选码或候选键为该关系的主码或主键。&lt;/p&gt;
&lt;h3&gt;　　12.全码或全键（All-Key）&lt;/h3&gt;
&lt;p&gt;　　一个关系模式的所有属性集合是这个关系的主码或主键，责成这样的主码或主键为全码或全键。&lt;/p&gt;
&lt;h3&gt;　　13.主属性（Primary Attribute）和非主属性（Nonprimary Attribute）&lt;/h3&gt;
&lt;p&gt;　　关系中包含在任何一个候选码中的属性称为主属性或码属性，不包含在任何一个候选码中的属性称为非主属性或非码属性。例如，在表2.1在学生基本信息登记表中，学号和身份证号是主属性，其他属性是非主属性。&lt;/p&gt;
&lt;h3&gt;　　14.外码或外键（Foreign Key）&lt;/h3&gt;
&lt;p&gt;　　当关系中的某个属性（或属性组）不是这个关系的主码或候选码，而是另一关系的主码时，称该属性（或属性组）为这个关系的外码或外键。例如，在表2.4中班号是班级表的主键，而该属性又是表2.1学生基本信息登记表的一个属性，则成属性班号为学生基本信息表的外键。&lt;/p&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;col width=&quot;85*&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;中文字段名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;数据类型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;宽度&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;班号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;班级名称&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;所属院系&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;字符型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;入学时间&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;日期型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr valign=&quot;top&quot;&gt;&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;班级最大人数&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;
&lt;p&gt;数值型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;33%&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;　　15.参照关系（Referencing Relation）和被参照关系（Referened Relation）&lt;/h3&gt;
&lt;p&gt;　　参照关系也称为从关系，被参照关系也称为主关系，它们是指以外键相关联的两个关系。以为外键为主码的关系称为被参照关系；外键所在的关系称为参照关系。被参照关系与参照关系是通过外键相联系的，这种联系通常是一对多联系。例如，表2.4所定义的班级表是被参照关系，而表2.1所示的学生基本信息登记表是参照关系，它们通过外键“班号”相联系。&lt;/p&gt;
&lt;h3&gt;　　16.域（Domain）&lt;/h3&gt;
&lt;p&gt;　　域表示属性的取值范围。&lt;/p&gt;
&lt;h3&gt;　　17.数据类型（Date Type）&lt;/h3&gt;
&lt;p&gt;　　表中每个列都有对应的数据类型，它用于限制（或容许）该列中存储的数据。每个字段表示同一类信息，具有相同的数据类型。&lt;/p&gt;
&lt;h3&gt;　　18.关系模式（Relation Schema）&lt;/h3&gt;
&lt;p&gt;　　同数据模型一样，数据库也有“型”（Type）和“值”（Value）之分。在关系数据库中，关系模式是型，关系是值，即关系模式是对关系的描述，例如表2.2就是对对关系的结构定义，关系则是元组的集合，是关系模式在某一时刻的状态或内容。&lt;/p&gt;
&lt;p&gt;　　关系模式是静态的、稳定的，而关系是动态的、随时间变化的。这是因为关系操作在不断的更新着数据库中的数据，例如，（读者译：别例如了，这东西自己想象，哦描述了数据模式，用概念来创造一个概念模型，这个模型在开发中，是不能更改的，除非用户需求更改）。&lt;/p&gt;
&lt;p&gt;　　在实际工作中，人们常常会把关系模式和关系都笼统地称为关系，（读者译：甚至表&amp;gt;__&amp;lt;），当然这不难从上下文中加以区别。&lt;/p&gt;
&lt;h3&gt;　　19.关系数据库（Relation DateBase）&lt;/h3&gt;
&lt;p&gt;　　关系数据库是以关系模型作为数据的逻辑模型，并采用关系作为组织方式的一类数据库，其数据库操作建立在关系代数的基础上。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。&lt;/p&gt;


&lt;p&gt;　　此外，尽管关系模型的数据结构表示为二维表，但不是任意的一个二维表都可以作为一个关系。关系数据库对关系是有限定的，具体要求如下。&lt;/p&gt;
&lt;p&gt;　　i）每一个属性都是不可分解的。这是关系数据库对关系的最基本的一个限定，要求关系的每一个分量必须是一个不可分的数据项。&lt;/p&gt;
&lt;p&gt;　　ii）每一个关系仅仅有一种关系模式，即每一个关系模式中的属性的数据类型以及属性的个数是相对固定的。&lt;/p&gt;
&lt;p&gt;　　iii)每一个关系模式中的属性必须命名，在同一个关系模式中属性名必须是不同的。&lt;/p&gt;
&lt;p&gt;　　iv)同一个关系中不允许出现候选码或候选键完全相同的元组。&lt;/p&gt;
&lt;p&gt;　　v)在关系中元组顺序（即行序）是无关紧要的，任意交换。&lt;/p&gt;
&lt;p&gt;　　vi)在关系中属性的顺序（即列序）是无关紧要的。任意交换。&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:51:00 +0000</pubDate>
<dc:creator>Visitors</dc:creator>
<og:description>来源 《数据库系统原理》 第二节 关系数据模型 关系数据库系统是支持关系模型的数据库系统。作为一种数据模型，关系模型同样包含三个组成要素，分别是关系数据结构、关系操作集合和关系完整性约束。 一、关系数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dmeck/p/10507936.html</dc:identifier>
</item>
<item>
<title>Spring实战Day1 - 愉快的白萝卜</title>
<link>http://www.cnblogs.com/luo-bo/p/10503892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luo-bo/p/10503892.html</guid>
<description>&lt;h3&gt;为什么要学习使用Spring ------为了全方面简化Java开发&lt;/h3&gt;
&lt;p&gt;如何简化开发呢？&lt;/p&gt;
&lt;p&gt;1.基于POJO[简单老式Java对象(&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;Plain Old Java object)]&lt;/span&gt;&lt;/span&gt;的轻量级和最小侵入性编程，即意味着该POJO在Spring应用和非Spring应用中可以起到一样的作用。&lt;/p&gt;
&lt;p&gt;2.通过依赖注入和面向接口实现松解耦合度，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462954/201903/1462954-20190310002045056-2098120426.png&quot; alt=&quot;&quot; width=&quot;228&quot; height=&quot;102&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462954/201903/1462954-20190310001554283-933649185.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过注入和接口能很大程度的解耦，图片展示的是构造器注入。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;3.面向切面编程(AOP)把不属于业务的功能分离出来形成可用的组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;4.&amp;lt;!-- 使用模板消除样式代码 --&amp;gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:51:00 +0000</pubDate>
<dc:creator>愉快的白萝卜</dc:creator>
<og:description>为什么要学习使用Spring 为了全方面简化Java开发 如何简化开发呢？ 1.基于POJO[简单老式Java对象(Plain Old Java object)]的轻量级和最小侵入性编程，即意味着该P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luo-bo/p/10503892.html</dc:identifier>
</item>
<item>
<title>工程实践：如何规范地打印程序日志？ - Matrix海子</title>
<link>http://www.cnblogs.com/dolphin0520/p/10396894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphin0520/p/10396894.html</guid>
<description>&lt;h3&gt;工程实践：如何规范地打印程序日志？&lt;/h3&gt;
&lt;p&gt;    很久之前，有个朋友问我，如果一个老项目让你接手去进行后续维护，你会先从哪里入手、让自己更快地上手项目？当时我没有特别正面去回答这个朋友的问题，我说：一个老项目是否容易上手，一个非常关键的地方就是这个项目的日志是否打得足够好。因为通常来说，一个老项目相对比较稳定了，后续大概率不会有比较大的变更和改动，那么对于这样的项目，核心就是“维稳”。但是任何人都无法保证项目在线上运行时不会出线上故障，在出现线上问题或者故障时，如何快速止损就是第一要义，而日志在止损过程中就扮演着非常重要的角色。日志打的足够明了清晰，可以帮助开发和运维人员快速定位问题，继而决定采取何种方案进行止损。&lt;/p&gt;
&lt;p&gt;    今天就让我们一起来聊一聊如何把项目程序日志打“好”。以下是本文大纲目录：&lt;/p&gt;
&lt;p&gt;    一.为何需要规范地打印程序日志？&lt;/p&gt;
&lt;p&gt;    二.如何规范地打印程序日志？ &lt;/p&gt;
&lt;p&gt;    若有不正之处请多多谅解，并欢迎批评指正。&lt;/p&gt;
&lt;p&gt;    请尊重作者劳动成果，转载请标明原文链接：&lt;/p&gt;
&lt;p&gt;    http://www.dolphin0520.com/archives/2018/11/26/176.html&lt;/p&gt;

&lt;h2&gt;一.为何需要规范地打印程序日志？&lt;/h2&gt;
&lt;p&gt;    我们平时在写程序代码过程中，一般会把主要精力集中在功能实现上，往往会忽视日志的重要性，然而日志在系统上线后是极其重要的，因为系统上线后，只有通过日志才能了解当前系统的运行状态，在出现线上故障时，日志是否足够清晰明了决定了是否能够快速找到止损方案。我们可以看一下下面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
    private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

    private static int CONNECT_TIMEOUT = 5000;   // unit ms
    private static int READ_TIMEOUT = 10000;     // unit ms
    
    public static String sendPost(String url, String param) {
        OutputStream out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        try {
            URL realUrl = new URL(url);
            URLConnection conn = realUrl.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setConnectTimeout(CONNECT_TIMEOUT);
            conn.setReadTimeout(READ_TIMEOUT);
            conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
            out = new PrintWriter(conn.getOutputStream());
            out.print(parm);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                result += line;
            }
        } catch (Exception ex) {
            LOG.error(&quot;post request error!!!&quot;);
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException ex) {
                LOG.error(&quot;close stream error!!!&quot;);
            }
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    某一天线上突然大量http请求失败，然后查看日志，发现了大量的“post request error!!!”错误，此时假如看到这样的日志你可能完全不知道究竟是什么原因导致的，还得继续通过一些其他的手段来定位具体原因。&lt;/p&gt;
&lt;p&gt;    假如打印的错误日志是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
post request error!!!, url:[http://www.123.test.com], param:[name=jack]
java.net.ConnectException: Connection refused
        at java.net.PlainSocketImpl.socketConnect(Native Method)
        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
        at java.net.Socket.connect(Socket.java:579)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    那么便能很快地断定是下游http服务问题导致的，且下游http服务域名为www.123.test.com(Connection refused通常是由于下游服务端口未启动引起的)，可以迅速找相应的人员进行止损，避免在故障定位阶段耗费大量的时间。&lt;/p&gt;
&lt;p&gt;        上面举的例子只是一个非常小的例子，实际日常开发中可能碰到的线上问题比这个更加复杂和棘手，总结来看，日志的主要作用有以下几点：&lt;/p&gt;
&lt;p&gt;    1）日志是系统运行的“照妖镜”，通过它能够实时反映系统的运行状态；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/288799/201903/288799-20190304215151492-1943547461.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如上图所示，系统A中producer不断产生数据放入到data queue中，sender不断从data queue中取数据发送给下游系统B的receiver，那么对于系统A来说，data queue中的待发送数据量便是一个非常关键的指标，它能够从侧面真实反应当前系统的运行状况，如果data queue中的element个数超过容量的90%了，那么标志着此时系统可能运行不正常了，会有队列堵塞的风险；如果data queue中的element个数不到容量的10%，那么标志着此时系统运行比较正常，出现队列堵塞的风险较低。&lt;/p&gt;
&lt;p&gt;    如果这个指标没有输出到日志中，开发和运维人员是无法确切知道当前系统A的运行状态的(当然也有其他的方式来获取这个指标，比如通过http接口暴露出来也是一种方式之一)。&lt;/p&gt;
&lt;p&gt;    2）良好的日志便于后期运维和开发人员迅速定位线上问题，加快止损速度，减少系统故障带来的损失；&lt;/p&gt;
&lt;p&gt;    3）日志还有另外一个作用便是能够无缝与监控系统结合，通过监控系统进行日志采集，拿到系统运行的相关性能指标，有利于分析系统的性能瓶颈、提前规避风险；&lt;/p&gt;
&lt;p&gt;    举例说明：&lt;/p&gt;
&lt;p&gt;    假如有一个商城系统，在初期，数据库通过2台服务器提供服务(1台master，1台slave)，此时大部分接口能在秒级内响应用户请求。随着时间的推移，商城系统的用户量逐渐增多，并发查询和写入量都出现了一定的增长，数据库中的数据量也慢慢增多，导致部分sql语句查询越来越慢，突然有一天，数据库的slave机器由于过多的慢查询导致被拖垮，彻底宕机了，导致商城服务不可用。&lt;/p&gt;
&lt;p&gt;    如果商城系统在日志中记录了每个http请求的耗时情况，通过监控系统配置日志采集，同时配置相应的报警，那么便能提前发现由于业务增长带来的系统性能瓶颈，提前进行系统优化(如机器扩容、sql语句优化、分库分表等)，规避风险。&lt;/p&gt;
&lt;p&gt;    4）便于统计与业务相关的指标数据，进行相关业务分析和功能优化。&lt;/p&gt;
&lt;p&gt;    举例说明：&lt;/p&gt;
&lt;p&gt;    比如一个搜索系统，想统计过去一周不同地域(如南北地域)的搜索使用占比，如果日志中本身打印了每个搜索query请求的ip，则很容易统计，否则需要重新上线加日志才能统计。&lt;/p&gt;
&lt;p&gt;    因此，大家在日常编写代码过程中要注重日志书写的规范性，让它发挥出它应有的价值，在辅助保障我们服务稳定运行的同时，能够有效提升后期系统维护效率。&lt;/p&gt;
&lt;h2&gt;二.如何规范地打印程序日志？&lt;/h2&gt;
&lt;p&gt;    接下来，我们从以下几个方面来谈谈如何规范地打印日志。&lt;/p&gt;
&lt;h3&gt;2.1 日志文件命名&lt;/h3&gt;
&lt;p&gt;    通常来说日志文件的命名可包括以下几个关键信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
类型标识(logTypeName)
日志级别(logLevel)
日志生成时间(logCreateTime)
日志备份编号(logBackupNum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    类型标识&lt;/strong&gt;：指此日志文件的功能或者用途，比如一个web服务，记录http请求的日志通常命名为request.log或者access.log，request、access就是类型标识，而java的gc日志通常命名为gc.log，这样看一目了然；而通常用来记录服务的整体运行的日志一般用服务名称(serviceName、appKey)或者机器名(hostName)来命名，如 nginx.log；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志级别&lt;/strong&gt;：打印日志的时候直接通过文件来区分级别是一种比较推荐的方式，如果把所有级别的日志打到同一个日志文件中，在定位问题时，还需要去文件中进行查找操作，相对繁琐。日志级别一般包括DEBUG、INFO、WARN、ERROR、FATAL这五个级别，在实际编写代码中，可以采取严格匹配模式或者非严格匹配模式，严格匹配模式即INFO日志文件中只打印INFO日志，ERROR日志文件只打印ERROR日志；非严格匹配模式即INFO日志文件可以打印INFO日志、WARN日志、ERROR日志、FATAL日志，WARN日志文件可以打印WARN日志、ERROR日志、FATAL日志，以此类推。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志生成时间&lt;/strong&gt;：即在日志文件名称中附带上日志文件创建的时间，方便在查找日志文件时进行排序；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志备份编号&lt;/strong&gt;：当进行日志切割时，如果是以文件大小进行滚动，此时可以在日志文件名称末尾加上编号；&lt;/p&gt;
&lt;h3&gt;2.2 日志滚动&lt;/h3&gt;
&lt;p&gt;　　虽然日志中能够保存系统运行时的关键信息，但是由于磁盘空间有限，所以我们不能无限制地保留日志，因此必须有日志滚动策略。日志滚动通常有以下几种模式：&lt;/p&gt;
&lt;p&gt;　　第一种：按照时间滚动&lt;/p&gt;
&lt;p&gt;　　第二种：按照单个日志文件大小滚动&lt;/p&gt;
&lt;p&gt;　　第三种：同时按照时间和单个日志文件大小滚动。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按照时间滚动，即每隔一定的时间建立一个新的日志文件，通常可以按照小时级别滚动或者天级别滚动，具体采取哪种方式取决于系统日志的打印量。如果系统日志比较少，可以采取天级别滚动；而如果系统日常量比较大，则建议采取小时级别滚动。&lt;/li&gt;
&lt;li&gt;按照单个日志文件大小滚动，即每当日志文件达到一定大小则建立一个新的日志文件，通常建议单个日志文件大小不要超过500M，日志文件过大的话，对于日志监控或者问题定位排查都可能会造成一定影响。&lt;/li&gt;
&lt;li&gt;按照时间和单个日志文件大小滚动，这种模式通常适用于希望保留一定时间的日志，但是又不希望单个日志文件过大的场景。比如logback就提供了这种配置模式，可参考：&lt;a title=&quot;logback日志滚动方式&quot; href=&quot;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&quot; target=&quot;_blank&quot;&gt;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于日志滚动策略来说，有2个比较关键的参数：&lt;span&gt;最大保留日志数量和最大磁盘占用空间&lt;/span&gt;。这2个参数切记一定要设置，如果没有设置，则很有可能会出现把线上机器磁盘打满的情况。&lt;/p&gt;
&lt;h3&gt;2.3 日志级别&lt;/h3&gt;
&lt;p&gt;　　日志的级别通常有以下几种：&lt;/p&gt;
&lt;p&gt;　　debug/trace、info、warning、error、fatal&lt;/p&gt;
&lt;p&gt;　　这几种日志级别的严重程序依次递增：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;debug/trace&lt;/strong&gt;：debug和trace级别的日志由于打印内容较多，所以通常情况下不适用于线上生产环境使用，一般使用于前期线下环境调试。即使线上环境要使用，也需要通过开关来控制，只在定位追踪线上问题时才开启；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;info&lt;/strong&gt;：info日志一般用来记录系统运行的关键状态、关键业务逻辑或者关键执行节点。但切记一点，info日志绝不可滥用，如果info日志滥用，则和debug/trace日志没有太大区别了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;warning：&lt;/strong&gt;warning日志一般用来记录系统运行时的一些非预期情况，顾名思义，是作为一种警示，提醒开发和运维人员需要关注，但是不用人为介入立刻去处理的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;error&lt;/strong&gt;：error日志一般用来记录系统运行时的一些普通错误，这些错误一旦出现，则表示已经影响了用户的正常访问或者使用，通常意味着需要人为介入处理。但很多时候在生产环境中，也不一定是出现error日志就需要人工立即介入处理的，通常会结合error日志的数量以及持续时间来进行综合判断。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;fatal&lt;/strong&gt;：属于系统致命错误，一般出现意味着系统基本等于挂掉了，需要人工立即介入处理。&lt;/p&gt;
&lt;p&gt;　　下面举个简单的例子来说明，假如我们有这样一个场景，我们有一个工资计算系统，每隔月1号需要从员工考勤系统获取公司所有员工的考勤数据，然后根据考勤数据来计算上月应发工资，那么需要有一个函数从考勤系统获取员工考勤数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;66&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public Map&amp;lt;Long, Double&amp;gt; getEmployeeWorkDaysFromAttendance(int year, int month, Set&amp;lt;Long&amp;gt; employeeList) throws BusiessException {
        // 入口关键日志，需要打印关键的参数，因为employeeList可能数量较大，所以次数没有直接打印employeeList列表内容，只打印了size
        logger.info(&quot;get employee work days, year:{}, month:{}, employeeList.size:{}&quot;, year, month, employeeList.size());

        // 如果需要临时检验员工列表，可以把debug日志开关打开
        if (debugOpen()) {
            logger.debug(&quot;employ list content:{}&quot;, JSON.toJsonString(employeeList));
        }
        
        int retry = 1;
        while (retry &amp;lt;= MAX_RETRY_TIMES) {
            try {
                Map&amp;lt;Long, Double&amp;gt; employeeWorkDays = employeeAttendanceRPC.getEmployeeWorkDays(year, month, employeeList);
                logger.info(&quot;get employee work days success, year:{}, month:{}, employeeList.size:{}, employeeWorkDays.size:{}&quot;, year, month, employeeList.size(), employeeWorkDays.size());
                return employeeWorkDays;
            } catch (Exception ex) {
                logger.warning(&quot;rpc invoke failed(employeeAttendanceRPC.getEmployeeWorkDays), retry times:{}, year：{}, month:{},  employeeList.size:{}&quot;, retry, year, month, employeeList.size(), ex);
                
                // 连续重试失败之后，向上跑出异常
                // 对于没有异常机制的语言，此处应该打印error日志
                if (retry == MAX_RETRY_TIMES) {
                    throw new BusiessException(ex, &quot;rpc invoke failed(employeeAttendanceRPC.getEmployeeWorkDays)&quot;);
                }
            }
            retry++;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4 日志打印时机的选择&lt;/h3&gt;
&lt;p&gt;　　由于日志是为了方便我们了解系统当前的运行状况以及定位线上问题，所以日志打印的时机非常重要，如果滥用日志，则会导致日志内容过多，影响问题定位的效率；如果日志打印过少，则容易导致缺少关键日志，导致在线上定位问题时找不到问题根音。因此把握日志打印的时机至关重要，以下是常见的适合打印日志的时机：&lt;/p&gt;
&lt;p&gt;1）http调用或者rpc接口调用&lt;/p&gt;
&lt;p&gt;　　在程序调用其他服务或者系统的时候，需要打印接口调用参数和调用结果(成功/失败)。&lt;/p&gt;
&lt;p&gt;2）程序异常&lt;/p&gt;
&lt;p&gt;　　在程序出现exception的时候，要么选择向上抛出异常，要么必须在catch块中打印异常堆栈信息。不过需要注意的是，最好不要重复打印异常日志，比如在catch块里既向上抛出了异常，又去打印错误日志(对外rpc接口函数入口处除外)。&lt;/p&gt;
&lt;p&gt;3）特殊的条件分支&lt;/p&gt;
&lt;p&gt;　　程序进入到一些特殊的条件分支时，比如特殊的else或者switch分支。比如我们根据工龄计算薪资：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public double calSalaryByWorkingAge(int age) {
        if (age &amp;lt; 0) {
            logger.error(&quot;wrong age value, age:{}&quot;, age);
            return 0;
        }
        // ..
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　理论上工龄不可能小于0，所以需要打印出这种非预期情况，当然通过抛出异常的方式也是可行的。&lt;/p&gt;
&lt;p&gt;4）关键执行路径及中间状态&lt;/p&gt;
&lt;p&gt;　　在一些关键的执行路径以及中间状态也需要记录下关键日志信息，比如一个算法可能分为很多步骤，每隔步骤的中间输出结果是什么，需要记录下来，以方便后续定位跟踪算法执行状态。&lt;/p&gt;
&lt;p&gt;5）请求入口和出口&lt;/p&gt;
&lt;p&gt;　　在函数或者对外接口的入口/出口处需要打印入口/出口日志，一来方便后续进行日志统计，同时也更加方便进行系统运行状态的监控。&lt;/p&gt;
&lt;h3&gt;2.5 日志内容与格式&lt;/h3&gt;
&lt;p&gt;　　日志打印时机决定了能够根据日志去进行问题定位，而日志的内容决定了是否能够根据日志快速找出问题原因，因此日志内容也是至关重要的。通常来说，一行日志应该至少包括以下几个组成部分：&lt;/p&gt;
&lt;p&gt;　　logTag、param、exceptionStacktrace&lt;/p&gt;
&lt;p&gt;　　logTag为日志标识，用来标识此日志输出的场景或者原因，param为函数调用参数，exceptionStacktrace为异常堆栈。举例说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
        private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

        private static int CONNECT_TIMEOUT = 5000;   // unit ms
        private static int READ_TIMEOUT = 10000;     // unit ms

        public static String sendPost(String url, String param) {
            OutputStream out = null;
            BufferedReader in = null;
            String result = &quot;&quot;;
            try {
                URL realUrl = new URL(url);
                URLConnection conn = realUrl.openConnection();
                conn.setDoInput(true);
                conn.setDoOutput(true);
                conn.setConnectTimeout(CONNECT_TIMEOUT);
                conn.setReadTimeout(READ_TIMEOUT);
                conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
                out = new PrintWriter(conn.getOutputStream());
                out.print(parm);
                out.flush();
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String line;
                while ((line = in.readLine()) != null) {
                    result += line;
                }
            } catch (Exception ex) {
                // 有关键logTag，有参数信息，有错误堆栈
                LOG.error(&quot;post request error!!!, url:[[}], param:[{}]&quot;, url, param, ex);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    LOG.error(&quot;close stream error!!!, url:[[}], param:[{}]&quot;, url, param, ex);
                }
                return result;
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
    private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

    private static int CONNECT_TIMEOUT = 5000;   // unit ms
    private static int READ_TIMEOUT = 10000;     // unit ms
    
    public static String sendPost(String url, String param) {
        OutputStream out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        try {
            URL realUrl = new URL(url);
            URLConnection conn = realUrl.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setConnectTimeout(CONNECT_TIMEOUT);
            conn.setReadTimeout(READ_TIMEOUT);
            conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
            out = new PrintWriter(conn.getOutputStream());
            out.print(parm);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                result += line;
            }
        } catch (Exception ex) {
            // 没有任何错误信息
            LOG.error(&quot;post request error!!!&quot;);
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException ex) {
                LOG.error(&quot;close stream error!!!&quot;);
            }
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外，对于对外http接口或者rpc接口，&lt;strong&gt;最好对于每个请求都有requestId&lt;/strong&gt;，以便跟踪每个请求后续所有的执行路径。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27363484&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://zhuanlan.zhihu.com/p/27363484&quot;&gt;https://zhuanlan.zhihu.com/p/27363484&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zollty/article/details/53958428&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://blog.csdn.net/zollty/article/details/53958428&quot;&gt;https://blog.csdn.net/zollty/article/details/53958428&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/59cd61eb93c2&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.jianshu.com/p/59cd61eb93c2&quot;&gt;https://www.jianshu.com/p/59cd61eb93c2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6149463aec94&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.jianshu.com/p/6149463aec94&quot;&gt;https://www.jianshu.com/p/6149463aec94&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/56574/&quot; target=&quot;_blank&quot; data-ke-src=&quot;http://blog.jobbole.com/56574/&quot;&gt;http://blog.jobbole.com/56574/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kofxxf/p/3713472.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.cnblogs.com/kofxxf/p/3713472.html&quot;&gt;https://www.cnblogs.com/kofxxf/p/3713472.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&quot;&gt;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/7954610.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.cnblogs.com/xybaby/p/7954610.html&quot;&gt;https://www.cnblogs.com/xybaby/p/7954610.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.didispace.com/cxy-wsm-zml-4/&quot; target=&quot;_blank&quot; data-ke-src=&quot;http://blog.didispace.com/cxy-wsm-zml-4/&quot;&gt;http://blog.didispace.com/cxy-wsm-zml-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/digest/javabug/138401&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.kancloud.cn/digest/javabug/138401&quot;&gt;https://www.kancloud.cn/digest/javabug/138401&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bad_yu/article/details/81035862&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://blog.csdn.net/bad_yu/article/details/81035862&quot;&gt;https://blog.csdn.net/bad_yu/article/details/81035862&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:40:00 +0000</pubDate>
<dc:creator>Matrix海子</dc:creator>
<og:description>工程实践：如何规范地打印程序日志？ 很久之前，有个朋友问我，如果一个老项目让你接手去进行后续维护，你会先从哪里入手、让自己更快地上手项目？当时我没有特别正面去回答这个朋友的问题，我说：一个老项目是否容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphin0520/p/10396894.html</dc:identifier>
</item>
<item>
<title>神经网络入门——神经元算法 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10497816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10497816.html</guid>
<description>
&lt;p&gt;目前机器学习、深度学习在业界使用的越来越广泛，做为一个有着技术追求的it人，我觉得有必要学习和了解一下这块的知识，今天就从最简单的单层神经网络开始介绍。&lt;/p&gt;
&lt;p&gt;在介绍人工神经网络之前，首先认知下神经元。&lt;/p&gt;

&lt;h4 id=&quot;4f0e34e0&quot;&gt;神经元&lt;/h4&gt;
&lt;p&gt;不知道大家还有印象这个图吗？这个是出现在我们生物课本中的一幅图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190309094006876-920210380.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个神经元的组成基本就是上图这些东西组成。&lt;/p&gt;
&lt;p&gt;通常一个神经元具有多个树突，主要用来接受传入信息信息，信息通过轴突传递进来后经过一系列的计算（细胞核）最终产生一个信号传递到轴突，轴突只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“突触”。&lt;/p&gt;
&lt;p&gt;也就是说一个神经元接入了多个输入，最终只变成一个输出，给到了后面的神经元，那么基于此，我们尝试去构造一个类似的结构。&lt;/p&gt;

&lt;h4 id=&quot;8a95a6d1&quot;&gt;结构&lt;/h4&gt;
&lt;p&gt;神经元的树突我们类比为多条输入，而轴突可以类比为最终的输出。&lt;/p&gt;
&lt;p&gt;这里我们构造一个典型的神经元模型，该模型包含有3个输入，1个输出，以及中间的计算功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190310222105243-723483366.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意在每一个输入的“连接”上，都有一个对应的“权值”。&lt;/p&gt;

&lt;p&gt;说个通俗的例子来理解下权值。比如今天你要决定今是否要去看电影，可能要考虑这3个因素： 1、女朋友有没有时间，2、有没有好看的电影，3、今天工作忙不忙； 而这三个因素对于每个人来说权重都是不同的，因为有的人看重工作、有的人看重家人，不同的权重最终的结果也会不一样。&lt;/p&gt;
&lt;p&gt;因此权重的大小是比较关键的。而一个神经网络的训练算法就是让权重的值调整到最佳，以便使得整个网络的预测效果最好。&lt;/p&gt;

&lt;p&gt;接下里，我们用数学的方式来表示一下神经元，我们定义 w为权重，x为输入&lt;/p&gt;
&lt;p&gt;$$ w = \begin{bmatrix} w_{1}  \\  ... \\ w_{m} \end{bmatrix} ,  x = \begin{bmatrix} x_{1}  \\  ... \\ x_{m} \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;$$ z = w_{1} * x_{1}  + ... + w_{m} * x_{m} $$&lt;/p&gt;
&lt;p&gt;z输入的总和，也就是这两个矩阵的点乘，也叫内积。这里补充点数学知识。&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552032252550-893e545b-c2c2-47e1-964a-8910b637eb72.png%22%2C%22originWidth%22%3A1518%2C%22originHeight%22%3A524%2C%22name%22%3A%22image.png%22%2C%22size%22%3A190586%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A424%2C%22height%22%3A146%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​$$ z = w_{1} * x_{1}  + ... + w_{m} * x_{m} = \sum\limits_{j=1}^{m} w_{j} * w_{j} = w^{T}*x $$&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;lake-image&quot;&gt;
&lt;div class=&quot;lake-image-content lake-image-content-isvalid&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;lake-image-detail&quot; data-role=&quot;detail&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;$w^{T}$代表矩阵的转置，即将列转未行，举个例子：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;$\phi$(z) = { 1  if  z&amp;gt;=θ;   -1  otherwise&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意这里有一个阈值 &lt;span id=&quot;MathJax-Span-337&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-338&quot; class=&quot;mi&quot;&gt;θ ，阈值的确定也需要在训练过程中进行完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mi&quot;&gt;那么如何进行训练，这里的我们需要用到&lt;strong&gt;感知器（preceptron）&lt;/strong&gt;算法，具体过程分为下面这么几个步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、首先将权重向量w进行初始化，可以为0或者是[0,1]之间的随机数；&lt;/p&gt;
&lt;p&gt;2、将训练样本输入感知器（计算内积后输入激活函数得到最终结果），最后得到分类的结果（结果为1 或 -1）；&lt;/p&gt;
&lt;p&gt;3、根据分类的结果再次更新权重向量w；&lt;/p&gt;

&lt;p&gt;前面提到激活函数是当z值大于一定的阈值&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;​ θ 后，才进行激活或者不激活。因此为了计算方便呢，我们再多加入一组向量，w0 和 x0 ，w 取 -θ ，x0 取 1；将其放到等式左边，这样&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;当 z&amp;gt;0 的时候 激活函数输出 1，而 z&amp;lt;0 激活函数输出 -1。&lt;/p&gt;
&lt;p&gt;$$ z = w_{0} * x_{0} + w_{1} * x_{1}  + ... + w_{m} * x_{m} $$&lt;/p&gt;
&lt;p&gt;$\phi$(z) = { 1  if  z&amp;gt;=0;   -1  otherwise&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;权重更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好，前面所有的准备都已经完成，接下来我们看下刚才提到的第三步，权重向量的更新，其实也就是神经网络训练的过程：&lt;/p&gt;
&lt;p&gt;权重的更新每一轮迭代  Wj = Wj+ &lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​ ▽Wj&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;而 ▽Wj = η * ( y - y' ) * Xj &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;上式中 η 叫做&lt;strong&gt;学习率&lt;/strong&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是[0, 1]之间的一个小数，由我们自己定义；y是真实 的样本分类，而 y’ 是感知器计算出来的分类。&lt;/p&gt;
&lt;p&gt;我们可以简单推导一下，当 y 和 y' 相等，&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;▽Wj 的值为0，Wj则不会&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033463069-f125024c-0b4f-4e2e-8e2c-8e79af97716c.png%22%2C%22originWidth%22%3A56%2C%22originHeight%22%3A70%2C%22name%22%3A%22image.png%22%2C%22size%22%3A1858%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A28%2C%22height%22%3A35%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;更新。对应的意义就是真实和预测的结果是相同的，因此权重也不需要再更新了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里举个例子 : &lt;/p&gt;
&lt;p&gt;假设初始化 W = [ 0, 0, 0] ， X = [1, 2, 3],  假设定义 η = 0.3，y = 1，y' = -1 &lt;/p&gt;
&lt;p&gt;▽W(1) = 0.3 * (1 - (-1)) * X(1) = 0.3*2*1 = 0.6;      W(1) = W(1) + ▽W(1) = 0.6;&lt;/p&gt;
&lt;p&gt;▽W(2) = 0.3 * (1 - (-1)) * X(2) = 0.3*2*2 = 1.2;      W(1) = W(1) + ▽W(1) = 1.2;&lt;/p&gt;
&lt;p&gt;▽W(3) = 0.3 * (1 - (-1)) * X(3) = 0.3*2*3 = 1.8;      W(1) = W(1) + ▽W(1) = 1.8;&lt;/p&gt;
&lt;p&gt;更新之后的向量 w = [0.6, 1.2, 1.8]  然后接着继续计算，更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阈值更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到，我们将阈值经过变换后变成了 w0，再每一轮的迭代训练过程中，w0也需要跟着一起更新。&lt;/p&gt;
&lt;p&gt;最初w0 也需要初始化为0，因为x0等于1，因此 ▽W(0) = η * ( y - y' ) ；&lt;/p&gt;
&lt;p&gt;这里很多人可能会和我开始有一样的疑惑，阈值不是提前定义好的吗？其实不是的，这里不断的迭代，其实就是阀值计算的过程，和权重向量一样，最终都是通过一轮一轮更新计算出来的，由于一开始我们设定的w0 = - θ，所以当最终我们的阀值更新出来后，-w0 就是我们学习出来的阀值。&lt;/p&gt;

&lt;p&gt;看到上面的过程是否有些晕，从整体上看，其实就是这样一个过程：&lt;/p&gt;
&lt;p&gt;初始化权重向量和阈值，然后计算预测结果和真实结果是否存在误差，有误差就根据结果不断的更新权重，直到权重计算的结果最终达到最佳，权重的值就是我们学习出的规律。&lt;/p&gt;

&lt;p&gt;感知器目前的适用场景为线性可分的场景，就是用一条直线可以分割的二分类问题。&lt;/p&gt;

&lt;p&gt;用python实现了上述过程，可以看下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 简单神经网络 感知器&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

reload(sys)
sys.setdefaultencoding(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Perception(object):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    eta: 学习率 η
    time: 训练次数
    w_: 权重向量
    
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, eta = 0.01, time=10&lt;span&gt;):
        self.eta &lt;/span&gt;=&lt;span&gt; eta
        self.time &lt;/span&gt;=&lt;span&gt; time
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
        
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    输入训练数据，X为输入样本向量，y对应样本分类
    X:shape[n_samples, n_features]
    X:[[1,2,3], [4,5,6]]
    n_samples : 2
    n_features: 3
    y:[1, -1]
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fit(self, X, y):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化权重向量为0，加一为w0，也就是损失函数的阈值&lt;/span&gt;
        self.w_ = np.zero[1 + X.shape[1&lt;span&gt;]]
        self.errors_ &lt;/span&gt;=&lt;span&gt; []
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(self.time):
            errors &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; x:[[1,2,3], [4,5,6]]&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; y:[1, -1]&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zip(X,y) = [[1,2,3,1], [4,5,6.-1]]&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; xi, target &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(X, y):
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; update = η * ( y - y' )&lt;/span&gt;
                update = self.eta * (target -&lt;span&gt; self.predict(xi))
                
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; xi 为向量, 这里每个向量都会乘&lt;/span&gt;
                self.w_[1:] += update *&lt;span&gt; xi
                self.w_[0] &lt;/span&gt;+=&lt;span&gt; update;
                
                errors &lt;/span&gt;+= int(update != 0.0&lt;span&gt;)
                
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; predict(self, X):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; z = w1*x1+...+wj*xj + w0*1&lt;/span&gt;
        z = np.dot(X, self.w_[1:]) +&lt;span&gt; self.w_[0]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失函数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; z &amp;gt;= 0.0&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
        
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>目前机器学习、深度学习在业界使用的越来越广泛，做为一个有着技术追求的it人，我觉得有必要学习和了解一下这块的知识，今天就从最简单的单层神经网络开始介绍。 在介绍人工神经网络之前，首先认知下神经元。 神</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10497816.html</dc:identifier>
</item>
<item>
<title>利用过滤器和反射技术对string类型的入参进行统一trim - 五色花的</title>
<link>http://www.cnblogs.com/luao/p/10508054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10508054.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近做的一些项目都是后台管理系统，主要是对表单数据的增删改查操作，其中有些表单项是字符串类型的，对于这些类型的表单项就需要在保存或编辑之前要进行.trim()处理,刚开始感觉没什么，遇到了就手动进行.trim()一下，感觉很正常，因为Java本身就提供了这么一个字符串处理的方法，感觉每次都这么做也不能嫌麻烦，理所应当。但是是随着业务的发展，需要这么处理的地方越来越多，虽然每次都小心谨慎，但难免会有遗漏，导致不该出现问题的地方出现了问题，对于这些不该出现的低级错误感到痛心。于是想，能不能写一个拦截器或者过滤器对string类型的入参进行统一trim处理，不用在数据持久化前分别对string类型的参数进行trim操作呢？于是就有了这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;过滤器+重写HttpServletRequestWrapper类，将修改后的参数列表写回request中。&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;h3 id=&quot;第一步-编写-参数过滤器&quot;&gt;第一步 编写 参数过滤器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
package com.xx.controller.filter;

import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @description: 类描述：参数过滤器
 * @author: 
 * @createdate: 2019/3/10 22:33
 * @lastdate:
 */
public class ParamsFilter extends OncePerRequestFilter {
    /**
     * Same contract as for {@code doFilter}, but guaranteed to be
     * just invoked once per request within a single request thread.
     * See {@link #shouldNotFilterAsyncDispatch()} for details.
     * &amp;lt;p&amp;gt;Provides HttpServletRequest and HttpServletResponse arguments instead of the
     * default ServletRequest and ServletResponse ones.
     *
     * @param request
     * @param response
     * @param filterChain
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
            ParameterRequestWrapper requestWrapper = new ParameterRequestWrapper(request);
        filterChain.doFilter(requestWrapper, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步-重写-parameterrequestwrapper&quot;&gt;第二步 重写 ParameterRequestWrapper&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jd.lifetravel.assistincome.controller.filter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * @description: 类描述：重写 ParameterRequestWrapper
 * @author:
 * @createdate: 2019/3/10 22:35
 * @lastdate:
 */
public class ParameterRequestWrapper extends HttpServletRequestWrapper {
    private Map&amp;lt;String, String[]&amp;gt; params = new HashMap&amp;lt;String, String[]&amp;gt;();


    public ParameterRequestWrapper(HttpServletRequest request) {
        // 将request交给父类，以便于调用对应方法的时候，将其输出，其实父亲类的实现方式和第一种new的方式类似
        super(request);
        // 将参数表，赋予给当前的Map以便于持有request中的参数
        this.params.putAll(request.getParameterMap());
        this.modifyParameterValues();

    }

    /**
     * 重载一个构造方法
     *
     * @param request
     * @param extendParams
     */
    public ParameterRequestWrapper(HttpServletRequest request, Map&amp;lt;String, Object&amp;gt; extendParams) {
        this(request);
        addAllParameters(extendParams);
    }

    /**
     * 将parameter的值去除空格后重写回去
     */
    public void modifyParameterValues() {
        Set&amp;lt;String&amp;gt; set = params.keySet();
        Iterator&amp;lt;String&amp;gt; it = set.iterator();
        while (it.hasNext()) {
            String key = (String) it.next();
            String[] values = params.get(key);
            values[0] = values[0].trim();
            params.put(key, values);
        }
    }

    /**
     * 重写getParameter，代表参数从当前类中的map获取
     *
     * @param name
     * @return
     */
    @Override
    public String getParameter(String name) {
        String[] values = params.get(name);
        if (values == null || values.length == 0) {
            return null;
        }
        return values[0];
    }

    @Override
    public String[] getParameterValues(String name) {//同上
        return params.get(name);
    }

    public void addAllParameters(Map&amp;lt;String, Object&amp;gt; otherParams) {//增加多个参数
        for (Map.Entry&amp;lt;String, Object&amp;gt; entry : otherParams.entrySet()) {
            addParameter(entry.getKey(), entry.getValue());
        }
    }

    public void addParameter(String name, Object value) {//增加参数
        if (value != null) {
            if (value instanceof String[]) {
                params.put(name, (String[]) value);
            } else if (value instanceof String) {
                params.put(name, new String[]{(String) value});
            } else {
                params.put(name, new String[]{String.valueOf(value)});
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第三步-在web.xml配置过滤器&quot;&gt;第三步 在web.xml配置过滤器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    &amp;lt;filter&amp;gt;  
        &amp;lt;filter-name&amp;gt;ParamsFilter&amp;lt;/filter-name&amp;gt;  
        &amp;lt;filter-class&amp;gt;top.lushunde.interceptor.ParamsFilter&amp;lt;/filter-class&amp;gt;  
    &amp;lt;/filter&amp;gt;  
    &amp;lt;filter-mapping&amp;gt;  
        &amp;lt;filter-name&amp;gt;ParamsFilter&amp;lt;/filter-name&amp;gt;  
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
    &amp;lt;/filter-mapping&amp;gt; &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 10 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>五色花的</dc:creator>
<og:description>背景 最近做的一些项目都是后台管理系统，主要是对表单数据的增删改查操作，其中有些表单项是字符串类型的，对于这些类型的表单项就需要在保存或编辑之前要进行.trim()处理,刚开始感觉没什么，遇到了就手动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10508054.html</dc:identifier>
</item>
<item>
<title>spring 装配bean的三种方式 - max-先生</title>
<link>http://www.cnblogs.com/maxshare/p/10467761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maxshare/p/10467761.html</guid>
<description>&lt;p&gt;这段时间在学习Spring，&lt;strong&gt;依赖注入DI和面向切面编程AOP是Spring框架最核心的部分&lt;/strong&gt;。这次主要是总结依赖注入的bean的装配方式。&lt;/p&gt;
&lt;p&gt;什么是依赖注入呢？也可以称为控制反转，简单的来说，一般完成稍微复杂的业务逻辑，可能需要多个类，会出现有些类要引用其他类的实例，也可以称为依赖其他类。传统的方法就是直接引用那个类对象作为自己的一个属性，但如果我们每次创建这个类的对象时，都会创建依赖的类的对象，还有如果那个类将来可能不用了，还需要到这个类去删除这个对象，&lt;strong&gt;那破坏了代码的复用性和导致高度耦合&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;依赖注入的出现可以很好地解决这个问题，依赖注入就是由系统负责协调类的依赖对象的创建，我们无需自己去显示的创建依赖对象，而是由系统给我们注入这个对象，系统控制了这个对象的创建，也称为控制反转。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Spring给我们注入对象有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐式的bean扫描发现机制和自动装配&lt;/li&gt;
&lt;li&gt;在java中进行显示配置&lt;/li&gt;
&lt;li&gt;在XML中进行显示配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第一种：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring从两个角度实现自动化装配：组件扫描和自动装配。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当对一个类标注@Component注解时，表明该类会作为组件类，spring将为这个类创建bean。当在应用文中引用这个bean，spring会自动扫描事先指定的包查找这个 bean。但spring默认是不启用组件扫描的，可以在XML中配置加上&amp;lt;context:component-scan base-package=&quot;xx&quot;/&amp;gt;。还有一种方法：在新建一个配置类，类中可以什么不用写，在配置类上加上@ComponentScan注解，spring会自动扫描改配置类所在的包，一般应该倾向xml配置。下面是一个bbs论坛系统用户发帖的功能小例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bbs.dao;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Postdao {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *用户发帖 ，post表添加帖子信息
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; addpost(@Param(&quot;title&quot;) String title,@Param(&quot;content&quot;) String content,@Param(&quot;userid&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bbs.dao;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Userdao {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 用户发帖后，user表将用户发帖数加一
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; addpost(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再在bbs.service包中创建一个postservice接口及其实现类，依赖Postdao和Userdao。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bbs.service;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PostService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    用户发帖后，先添加帖子信息再更新用户发帖数量
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addpost(String title,String content,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; bbs.service;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; @&lt;span&gt;Component
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PostserviceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PostService {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Postdao postdao;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Userdao userdao;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setPostdao(Postdao postdao)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.postdao=postdao;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setUserdao(Userdao userdao)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.userdao=userdao;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PostserviceImpl(Postdao postdao,Userdao userdao)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.userdao=&lt;span&gt;userdao;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.postdao=&lt;span&gt;postdao;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addpost(String title, String content, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userid) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;postdao.addpost(title, content, userid);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;userdao.addpost(userid);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i==1&amp;amp;j==1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             System.out.println(&quot;发帖成功&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             System.out.println(&quot;发帖失败&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Component在接口实现上注解就可以，但发现在userdao、postdao接口也加上了，其实可以去掉，因为我采用mybatis在xml中配置数据库的操作，动态实现dao接口。等下会提到。上面代码出现的@Autowired注解实现bean自动装配，会在spring应用上下文中的组件类寻找需求的bean。一般有两种装配方式：构造器和Setter方法(其他方法名也行，只要能够使注入的bean成为这个类的属性就行）&lt;/p&gt;
&lt;p&gt;也可能出现spring没有查找到匹配的bean会抛出异常，在@Autowired加上required=false，如果没有匹配的bean时，spring会使这个bean处于未装配的状态，没有装配成功。还有可能会出现相同名字的bean有很多个，会产生歧义，一般在组件类上添加注解@Qualifier()括号写这个bean的id，在注入时也加上@Qualifier(),写上bean的id。像下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @Qualifier(&quot;postdao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Postdao{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;. . . .     
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; @Qualifier(&quot;userdao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Userdao{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;. . . . 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; @Qualifier(&quot;usedao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserdao(Userdao userdao)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{. . . 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;@Autowired
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; @Qualifier(&quot;postdao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserdao(Postdao postdao)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{. . . 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于java不允许在同一个条目上重复出现相同类型的多个注解，所有注入采用set方式。但是其实可以创建自定义的限定符注解。这里就不介绍啦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二种：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过java代码装配bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般通过组件扫描和自动装配方式就比较方便了，但如果由于需求我们要使用第三方的库的类，在这种情况没有办法到第三方库中去给类加注解，就不能使用第一种方法了。这时得采用显示装配，可以采用java代码或xml显示装配bean。使用java代码，先新建一个配置类JavaConfig，里面都是配置所需的bean，不应该有业务逻辑代码，所以单独建一个类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;em&gt;@Configuration&lt;br/&gt;@ContextConfiguration(&lt;/em&gt;locations = {&quot;classpath:spring/spring-dao.xml&quot;,&quot;classpath:scan.xml&quot;}）&lt;br/&gt;public class bbsConfig{&lt;br/&gt;　　private Postdao postdao;&lt;br/&gt;　　private Userdao userdao;&lt;br/&gt;　　@Bean(name=&quot;postservice&quot;)&lt;br/&gt;public PostService getPost()&lt;br/&gt;　　{&lt;br/&gt;　　return new PostserviceImpl(postdao,userdao);&lt;br/&gt;　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在对PostService的bean注入时，同时又依赖了两个bean，postdao和userdao。直接引用beanID就可以，spring会自动地从容器中获取这些bean，只要他们的配置是正确的就行。这个例子中userdao、postdao是&lt;strong&gt;Mybatis配置自动扫描将dao接口生成代理注入到spring的&lt;/strong&gt;，其实也算是xml装配bean。可参考这篇文章，写的挺清楚的。&lt;a href=&quot;https://bijian1013.iteye.com/blog/2318860&quot; target=&quot;_blank&quot;&gt; https://bijian1013.iteye.com/blog/2318860&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里如果再声明一个bean，返回的仍是postserviceImpl对象，和之前的那个bean完全一样，是同一个实例。一般spring@bean如果是同一个beanID，默认返回的是一个单例bean，注入的是同一个实例。如果修改其中一个会都改变的。&lt;/p&gt;
&lt;p&gt;不过在这里要注意进行测试时，由于spring的单元测试和springIoc容器是完全独立的，postdao和userdao注入检测时是使用locations加载xml文件，而postservice使用classes加载config类的&lt;strong&gt;，但是两个不能同时混用在@ContextConfiguration中。所以非要都测试的话，就分开测试吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三种：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在XML中装配bean&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;spring/spring-dao.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;postservice&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.bbs.service.impl.PostserviceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;postdao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;userdao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置postservice的bean时需要引入两个bean，postdao和userdao，放到constructor-arg的标签中，ref指的是依赖的bean的ID。如果是在javaConfig中配置的，就写@Bean的内容。如果是@Component就写@Qualifier的内容。这里是引入的是动态实现的dao接口的bean，是在spring-dao.xml中配置的，引入这个配置文件就可以自动获得beanID。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;混合使用三种装配：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.在类上可以使用@ import(bbsConfig.class)组合其他java注解&lt;/p&gt;
&lt;p&gt;2.在类上使用@ imortResource(&quot;classpath:spring-dao.xml&quot;)组合其他xml注解&lt;/p&gt;
&lt;p&gt;3.在类上可以使用@ContenxtConfiguration包含class或者xml&lt;/p&gt;
&lt;p&gt;4.在xml中可以用&amp;lt;import resource=&quot;spring-dao.xml&quot;&amp;gt;引入xml注解，也可以使用&amp;lt;bean class=&quot;com.bbs.dao.Userdao&quot;&amp;gt;引入java注解&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>max-先生</dc:creator>
<og:description>这段时间在学习Spring，依赖注入DI和面向切面编程AOP是Spring框架最核心的部分。这次主要是总结依赖注入的bean的装配方式。 什么是依赖注入呢？也可以称为控制反转，简单的来说，一般完成稍微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maxshare/p/10467761.html</dc:identifier>
</item>
<item>
<title>基本数据结构 —— 堆以及堆排序（C++实现） - 闽A2436</title>
<link>http://www.cnblogs.com/multhree/p/10507994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/multhree/p/10507994.html</guid>
<description>&lt;p&gt;堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;堆中某个节点的值总是不大于或不小于其父节点的值；&lt;/li&gt;
&lt;li&gt;堆总是一棵完全二叉树。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。&lt;/p&gt;

&lt;p&gt;堆一般使用&lt;strong&gt;数组&lt;/strong&gt;存储。当堆中有n个元素的时，可以将这些元素存放在数组&lt;code&gt;array&lt;/code&gt;的前n个单元里，其中堆的根节点中元素存放在&lt;code&gt;array[1]&lt;/code&gt;中。结点之间的关系有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果根节点在数组中的位置是1，那么第i个位置的左右节点下标分别为2i、2i+1，父节点下标为i/2。&lt;/li&gt;
&lt;li&gt;如果根节点在数组中的位置是0，那么第i个位置的左右节点下标分别为2i+1、2i+2，父节点下标为⌊（i-1） /2⌋。&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/874b0eb1gy1g0y1wjuvbnj20l30wzwfr.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以大根堆为例，给出堆支持的一些操作。&lt;/p&gt;
&lt;h2 id=&quot;结构体定义&quot;&gt;结构体定义&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;struct Heap
{
    int size;   // number of elements in array
    int *array;
    Heap()  //init
    {
        size = 0;
        array = new int[maxn];
    }
    Heap(int n) //init
    {
        size = 0;
        array = new int[n];
    } 
    ~Heap() //free memory
    {
        delete array;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;判断是否为空&quot;&gt;判断是否为空&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    bool empty()
    {
        if(size != 0) return false;
        return true;
    } &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;往堆中插入元素&quot;&gt;往堆中插入元素&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    void insert(int value) 
    {
        array[++size] = value; // 数组的最末尾插入新节点
        int index = size;
        while(index &amp;gt; 1)    // 自下而上地调整子节点与父节点的位置
        {
            // 如果大于父节点的值，根据最大堆的特点，子节点上升，而父节点要下降
            if(array[index] &amp;gt; array[index/2]) swap(array[index],array[index/2]);  
            index /= 2; // 继续向上搜索
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/874b0eb1gy1g0y2tajkjgj20l319jwgt.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;从堆中删除元素&quot;&gt;从堆中删除元素&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    void del() 
    {
        if(empty()) return; // 删除前不能为空
        swap(array[1],array[size--]); //用数组最末尾节点覆盖被删节点
        int index = 1;
        while(2*index &amp;lt;= size) // 从上到下调整二叉堆
        {
            int next = 2*index;
            // 选取子节点中最大的
            if(next &amp;lt; size &amp;amp;&amp;amp; array[next+1] &amp;gt; array[next]) next++;
            // 与子节点中最大的比较，如果小于则当前结点下降
            if(array[index] &amp;lt; array[next]) 
            {
                swap(array[index],array[next]);
                index = next;
            } 
            else break;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/874b0eb1gy1g0y30g2zkuj20l319j76i.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;取出堆中最大的元素&quot;&gt;取出堆中最大的元素&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    int max() {
        if(empty()) return -1;
        return array[1];
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;给定一个有size个元素的数组&lt;code&gt;array&lt;/code&gt;,可用下面的算法&lt;code&gt;buildHeap(array,size)&lt;/code&gt;在 &lt;strong&gt;O(n)&lt;/strong&gt; 时间内将数组&lt;code&gt;array&lt;/code&gt;调整为一个堆。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void buildHeap(int array[],int size)
{
    int i,tmp,index;
    for(i = size/2; i &amp;gt;= 1; i--) 
    {
        tmp = array[i];
        index = 2*i;
        while(index &amp;lt;= size)
        {
            if(index &amp;lt; size &amp;amp;&amp;amp; array[index+1] &amp;gt; array[index]) index++;
            if(array[index] &amp;lt; tmp) break;
            array[index/2]  = array[index];
            index *= 2;
        }
        array[index/2] = tmp;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define maxn 1001   //heap's size

using namespace std;

struct Heap {
    int size;   // number of elements in array
    int *array;
    Heap() {    //init
        size = 0;
        array = new int[maxn];
    }
    Heap(int n) {   //init
        size = 0;
        array = new int[n];
    }
    ~Heap() {   //free memory
        delete array;
    }
    bool empty() {
        if(size != 0) return false;
        return true;
    }
    void insert(int value) {
        array[++size] = value;
        int index = size;
        while(index &amp;gt; 1) {
            if(array[index] &amp;gt; array[index/2]) swap(array[index],array[index/2]);
            index /= 2;
        }
    }
    void del() 
    {
        if(empty()) return;
        swap(array[1],array[size--]);
        int index = 1;
        while(2*index &amp;lt;= size) 
        {
            int next = 2*index;
            if(next &amp;lt; size &amp;amp;&amp;amp; array[next+1] &amp;gt; array[next]) next++;
            if(array[index] &amp;lt; array[next]) 
            {
                swap(array[index],array[next]);
                index = next;
            } else break;
        }
    }
    int max() {
        if(empty()) return -1;
        return array[1];
    }
};
void buildHeap(int array[],int size) {
    int i,tmp,index;
    for(i = size/2; i &amp;gt;= 1; i--) {
        tmp = array[i];
        index = 2*i;
        while(index &amp;lt;= size) {
            if(index &amp;lt; size &amp;amp;&amp;amp; array[index+1] &amp;gt; array[index]) index++;
            if(array[index] &amp;lt; tmp) break;
            array[index/2]  = array[index];
            index *= 2;
        }
        array[index/2] = tmp;
    }
}
int main() {
    int n,i,j,k;
    cout &amp;lt;&amp;lt; &quot;input heap's size:&quot;;
    cin &amp;gt;&amp;gt; n;
    Heap H = Heap(n);
    int* array = new int[n];
    for(i = 1; i &amp;lt;= n; i++) {
        int tmp;
        cin &amp;gt;&amp;gt; tmp;
        array[i] = tmp;
        H.insert(tmp);
    }
    buildHeap(array,n);
    for(i = 1; i &amp;lt;= n; i++) {
        cout &amp;lt;&amp;lt; array[i] &amp;lt;&amp;lt; &quot; &quot;;
    }
    cout &amp;lt;&amp;lt; endl;
    while(!H.empty()) {
        cout &amp;lt;&amp;lt; H.max() &amp;lt;&amp;lt; endl;
        H.del();
    }
    return 0;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/874b0eb1gy1g0y3ar0i2cj21400j674p.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;amp;tqId=11182&amp;amp;tPage=2&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fcoding-interviews&amp;amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&quot;&gt;最小的K个数 —— 剑指offer&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class Solution {
public:
    struct Heap {
        int size;   // number of elements in array
        int *array;
        Heap() {    //init
            size = 0;
            array = new int[1001];
        }
        Heap(int n) {   //init
            size = 0;
            array = new int[n];
        }
        ~Heap() {   //free memory
            delete array;
        }
        bool empty() {
            if(size != 0) return false;
            return true;
        }
        void insert(int value) {
            array[++size] = value;
            int index = size;
            while(index &amp;gt; 1) {
                if(array[index] &amp;lt; array[index/2]) swap(array[index],array[index/2]);
                index /= 2;
            }
        }
        void del() 
        {
            if(empty()) return;
            swap(array[1],array[size--]);
            int index = 1;
            while(2*index &amp;lt;= size) 
            {
                int next = 2*index;
                if(next &amp;lt; size &amp;amp;&amp;amp; array[next+1] &amp;lt; array[next]) next++;
                if(array[index] &amp;gt; array[next]) 
                {
                    swap(array[index],array[next]);
                    index = next;
                } else break;
            }
        }
        int min() {
            if(empty()) return -1;
            return array[1];
        }
    };
    vector&amp;lt;int&amp;gt; GetLeastNumbers_Solution(vector&amp;lt;int&amp;gt; input, int k) {
        vector&amp;lt;int&amp;gt; ret;
        int i,n = input.size();
        if(n &amp;lt; k) return ret;
        Heap H = Heap(n);
        for(i = 0;i &amp;lt; n;i++)
        {
            H.insert(input[i]);
        }
        while(k) 
        {
            ret.push_back(H.min());
            H.del();
            k--;
        }
        return ret;
    }
};&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:12:00 +0000</pubDate>
<dc:creator>闽A2436</dc:creator>
<og:description>[toc] 什么是堆 堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/multhree/p/10507994.html</dc:identifier>
</item>
<item>
<title>10个小技巧助您写出高性能的ASP.NET Core代码 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10507984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10507984.html</guid>
<description>&lt;p&gt;今天这篇文章我们来聊一聊如何提升并优化ASP.NET Core应用程序的性能，本文的大部分内容来自翻译，当然中间穿插着自己的理解，希望对大家有所帮助！话不多说开始今天的主题吧！&lt;br/&gt;我们都知道性能是公共网站取得成功的关键因素之一。如果一个网站的响应时间超过3秒，那么用户通常不会再此光顾（此网站）。谷歌，Bing，百度以及其他搜索引擎也更倾向于推荐优化后的，移动友好的以及响应速度更快的网站。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文地址：https://www.cnblogs.com/yilezhu/p/10507984.html&lt;/p&gt;
&lt;p&gt;大部分内容翻译自：https://www.c-sharpcorner.com/article/10-tips-to-improve-performance-of-asp-net-core-application/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们举一个例子：我们有多个搜索引擎，如Google、Bing、百度、搜狗等等；然而，我们更喜欢Google或Bing，因为这些搜索引擎速度非常快，可以在3-4秒内获得结果。如果这些搜索引擎的响应速度超过10秒，你还会使用它们吗？我认为大伙应该不会用了吧。如今的用户最不能容忍的想必就是等待了吧。&lt;/p&gt;
&lt;p&gt;今天，我们将学习一些有助于提高ASP.NET Core网站性能的一些小技巧。希望大家能够有所收获。&lt;/p&gt;
&lt;p&gt;我们都知道ASP.NET Core是微软提供的一个免费的、开源的、跨平台的Web开发框架。它不是ASP.NET的升级版本，但它是一个从头开始完全重写的框架，它附带了ASP.NET MVC和ASP.NET Web API的单一编程模型。&lt;/p&gt;
&lt;p&gt;在这里，我不打算讨论ASP.NET Core及其特性。如果您是ASP.NET Core的新手，您可以阅读我的ASP.NET Core实战教程《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;下面我们就开始今天的主题，如何提升ASP.NET Core应用程序的性能的技巧开始吧。&lt;/p&gt;
&lt;h2 id=&quot;始终使用asp.net-core的最新版本&quot;&gt;始终使用ASP.NET Core的最新版本&lt;/h2&gt;
&lt;p&gt;ASP.NET Core的第一个版本是在2016年与VisualStudio 2015一起发布的，现在我们有了ASP.NET Core3.0，每一个新版本都越来越好。最新的ASP.NET Core 3.0的主要更新如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Razor组件的改进。&lt;/strong&gt;现在2个项目合并成单个项目模板，Razor组件支持端点路由和预渲染，Razor组件可以托管在Razor类库中。还改进了事件处理和表单和验证支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时编译。&lt;/strong&gt;它在ASP.NET Core 3.0模板中被禁用，但现在可以通过向项目添加特殊的NuGet包来打开它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Worker Service 模板。&lt;/strong&gt;需要编写Windows服务还是Linux守护进程？现在我们有了&lt;strong&gt;Worker Service&lt;/strong&gt; 模板。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gRPC模板。&lt;/strong&gt;与谷歌一起构建的gRPC是一种流行的远程过程调用（RPC）框架。此版本的ASP.NET Core在ASP.NET Core上引入了第一等的gRPC支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Angular模板使用Angular 7.&lt;/strong&gt; Angular SPA模板现在使用Angular 7，在第一次稳定释放之前，它将被Angular 8替换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SPA-s的身份验证。&lt;/strong&gt;Microsoft通过此预览为单页应用程序添加了现成的身份验证支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SignalR与端点路由集成。&lt;/strong&gt;小变化 - 现在使用端点路由定义SingalR路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SignalR Java客户端支持长轮询。&lt;/strong&gt;即使在不支持或不允许WebSocket的环境中，SignalR Java客户端现在也可以使用。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;友情提示：在构建新的ASP.NET Core项目时，不要忘记选择最新版本。VisualStudio 2019预览版现在已经支持ASP.NET Core 3.0了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;避免任何层的同步调用&quot;&gt;避免任何层的同步调用&lt;/h2&gt;
&lt;p&gt;在开发ASP.NET Core应用程序时，尽量避免创建阻塞的调用。阻塞调用是指当前请求未完成之前会一直阻止下一个执行的调用。阻塞调用或同步调用可以是任何东西，可以是从API中获取数据，也可以是执行一些内部操作。您应该始终以异步方式执行调用。&lt;/p&gt;
&lt;h2 id=&quot;始终使用异步编程async-await&quot;&gt;始终使用异步编程(ASYNC-AWAIT)&lt;/h2&gt;
&lt;p&gt;异步编程模型是在C#5.0中引入的，并变得非常流行。ASP.NET Core使用相同的异步编程范例来使应用程序更可靠、更快和更稳定。&lt;/p&gt;
&lt;p&gt;您应该在代码中使用端到端异步编程。&lt;/p&gt;
&lt;p&gt;让我们举一个例子；我们有一个ASP.NET CoreMVC应用程序，中间有一些数据库的操作。正如我们所知道的，它可能有很多分层结构，这都取决于用户的项目架构，但是让我们举一个简单的例子，其中我们有Controller》Repository 层等等。让我们看看如何在控制器层编写示例代码。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpGet]
[Route(&quot;GetPosts&quot;)]  
public async Task GetPosts()
{  
    try  
    {  
var posts = await postRepository.GetPosts();
        if (posts == null)  
        {  
            return NotFound();
        }  
  
        return Ok(posts);
    }  
    catch (Exception)
    {  
        return BadRequest();
  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的代码然是了我们如何在repository  层实现异步编程。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;List&amp;lt;PostViewModel&amp;gt;&amp;gt; GetPosts()
{  
    if (db != null)  
       {  
         return await (from p in db.Post
from c in db.Category
where p.CategoryId == c.Id
select new PostViewModel
                       {  
PostId = p.PostId,
Title = p.Title,
Description = p.Description,
CategoryId = p.CategoryId,
CategoryName = c.Name,
CreatedDate = p.CreatedDate
}).ToListAsync();
      }  
    
      return null;  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用异步编程避免task.wait或tast.result&quot;&gt;使用异步编程避免TASK.WAIT或TAST.RESULT&lt;/h2&gt;
&lt;p&gt;在使用异步编程时，我建议您避免使用Task.Wait和Task.Result并尝试使用WAIT，原因如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它们阻塞线程直到任务完成，并等待任务完成。等待同步阻塞线程，直到任务完成。&lt;/li&gt;
&lt;li&gt;Wait 和 Task.Result 在AggregateException中包含所有类型的异常，并在在执行异常处理时增加复杂性。如果您使用的是等待await 而不是 Task.Wait和Task.Result的话，那么您就不必担心异常的处理了。&lt;/li&gt;
&lt;li&gt;有时，它们都会阻塞当前线程并创建死锁。&lt;/li&gt;
&lt;li&gt;只有在并行任务执行正在进行时才能使用Wait 和Task.Result 。我们建议您不要在异步编程中使用它。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面让我们分别演示下正确使用以及不建议使用Task.Wait 的例子，来加深理解吧！&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 正确的例子 
Task task = DoWork();
await task;
  
// 不建议使用的例子 
Task task = DoWork();
task.Wait();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面让我们分别演示下正确使用以及不规范使用Task.Result 的例子，来加深理解吧！&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// Good Performance on UI  
Task&amp;lt;string&amp;gt; task = GetEmployeeName();
txtEmployeeName.Text = await task;
  
// Bad Performance on UI  
Task&amp;lt;string&amp;gt; task = GetEmployeeName();
txtEmployeeName.Text = task.Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解更多关于&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/jj991977.aspx&quot;&gt;异步编程的最佳实践&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;异步执行io操作&quot;&gt;异步执行I/O操作&lt;/h2&gt;
&lt;p&gt;在执行I/O操作时，您应该异步执行它们，这样就不会影响其他进程。I/O操作意味着对文件执行一些操作，比如上传或检索文件。它可以是任何操作如：图像上传，文件上传或其他任何操作。如果您试图以同步的方式完成它，那么它会阻塞主线程并停止其他后台执行，直到I/O完成为止。因此，从提升性能上来说，您在对I/O进行操作时应该始终进行异步执行。&lt;/p&gt;
&lt;p&gt;我们有很多异步方法可用于I/O操作，如ReadAsync、WriteAsync、FlushAysnc等。下面是一个简单的例子，说明我们如何异步创建一个文件的副本。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async void CreateCopyOfFile()
{  
    string dir = @&quot;c:\Mukesh\files\&quot;;  
  
    using (StreamReader objStreamReader= File.OpenText(dir + &quot;test.txt&quot;))  
    {  
        using (StreamWriter objStreamWriter= File.CreateText(dir+ &quot;copy_test.txt&quot;))  
        {  
await CopyFileToTarget(objStreamReader, objStreamWriter);
        }  
    }  
}  
  
public async Task CopyFileToTarget(StreamReader objStreamReader, StreamWriter objStreamWriter)
{   
    int num;
    char[] buffer = new char[0x1000];
  
    while ((num= await objStreamReader.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {  
await objStreamWriter.WriteAsync(buffer, 0, num);
    }   
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总是使用缓存&quot;&gt;总是使用缓存&lt;/h2&gt;
&lt;p&gt;如果我们能在每次执行的时候减少减少对服务器的请求次数，那么我们就可以提高应用程序的性能。这并不意味着您执行的时候不会请求服务器，而是意味着您不会每次执行都请求服务器。第一次，您将请求服务器并获得响应，此响应将在某个地方存储一段时间(将有一些到期)，下一次当您对相同的响应进行调用时，您将首先检查您是否已经在第一个请求中获得了数据并存储在某个地方，如果是的话，您将检查是否已经获得了数据。使用存储的数据，而不是调用服务器。&lt;/p&gt;
&lt;p&gt;将数据保存在某个位置并让下次请求从这个地方获取数据而不是从服务器获取是一种很好的做法。在这里，我们可以使用缓存。缓存内容有助于我们再次减少服务器调用，并帮助我们提高应用程序的性能。我们可以在客户端缓存、服务器端缓存或客户机/服务器端缓存等位置的任意点执行缓存。&lt;/p&gt;
&lt;p&gt;我们可以在ASP.NET Core中使用不同类型的缓存，比如我们可以在内存中进行缓存，也可以使用响应缓存，也可以使用分布式缓存。更多关于&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-2.2&quot;&gt;ASP.NET Core 中的缓存&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task GetCacheData()
{  
var cacheEntry = await
_cache.GetOrCreateAsync(CacheKeys.Entry, entry =&amp;gt;
    {  
entry.SlidingExpiration = TimeSpan.FromSeconds(120);
        return Task.FromResult(DateTime.Now);
    });  
  
    return View(&quot;Cache&quot;, cacheEntry);
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;优化数据访问&quot;&gt;优化数据访问&lt;/h2&gt;
&lt;p&gt;我们还可以通过优化数据访问逻辑、数据库表和查询来提高应用程序的性能。众所周知，大多数应用程序都使用某种数据库，每次从数据库获取数据时，都会影响应用程序的性能。如果数据库加载缓慢，则整个应用程序将缓慢运行。这里我们有一些建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少HTTP请求的次数，意味着您应该始终尝试减少网络往返次数。&lt;/li&gt;
&lt;li&gt;试着一次得到所有的数据。这意味着不对服务器进行多次调用，只需进行一两次调用就可以带来所有所需的数据。&lt;/li&gt;
&lt;li&gt;经常对不经常变化的数据设置缓存。&lt;/li&gt;
&lt;li&gt;不要试图提前获取不需要的数据，这会增加响应的负载，并导致应用程序的加载速度变慢。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;优化自定义代码&quot;&gt;优化自定义代码&lt;/h2&gt;
&lt;p&gt;除了业务逻辑和数据访问代码之外，应用程序中可能还有一些自定义代码。确保此代码也是优化的。这里有一些建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应该优化对每个请求执行的自定义日志记录、身份验证或某些自定义处理程序的代码。&lt;/li&gt;
&lt;li&gt;不要在业务逻辑层或中间件中执行长时间运行的代码，它会阻塞到服务器的请求，从而导致应用程序需要很长时间才能获得数据。您应该在客户端或数据库端为此进行优化代码。&lt;/li&gt;
&lt;li&gt;始终检查长期运行的任务是否应该异步执行，而不影响其他进程。&lt;/li&gt;
&lt;li&gt;您可以使用实时客户端-服务器通信框架，如：SignalR，来进行异步工作。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;entity-framework-core-的查询优化&quot;&gt;Entity Framework Core 的查询优化&lt;/h2&gt;
&lt;p&gt;众所周知，EF Core是一个面向.NET开发人员的ORM，它帮助我们处理数据库对象，而不像往常那样编写大量代码。它帮助我们使用模型的数据库。数据访问逻辑代码在性能上起着至关重要的作用。如果您的代码没有优化，那么应用程序的性能通常就不会很好。&lt;/p&gt;
&lt;p&gt;但是，如果您在EFCore中以优化的方式编写数据访问逻辑，那么肯定会提高应用程序的性能。在这里，我们有一些技巧来提高性能。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在获取只是用来只读显示的数据时不使用跟踪。它提高了性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;尝试在数据库端过滤数据，不要使用查询获取整个数据，然后在您的末尾进行筛选。您可以使用EF Core中的一些可用功能，可以帮助您在数据库端筛选数据的操作，如：WHERE，Select等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用Take和Skip来获取我们所必须要显示的数量的记录。这里可以举一个分页的例子，在这个例子中，您可以在单击页码的同时使用Take和Skip来获取当前页面的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;让我们以一个例子为例，了解如何使用Select和AsNoTracking优化EF Core的查询。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;PaginatedList&amp;gt; GetPagedPendingPosts(int pageIndex, int pageSize, List allowedCategories)
{  
var allowedCatIds = allowedCategories.Select(x =&amp;gt; x.Id);
var query = _context.Post
.Include(x =&amp;gt; x.Topic.Category)
.Include(x =&amp;gt; x.User)
.Where(x =&amp;gt; x.Pending == true &amp;amp;&amp;amp; allowedCatIds.Contains(x.Topic.Category.Id))
.OrderBy(x =&amp;gt; x.DateCreated);
  
    return await PaginatedList.CreateAsync(query.AsNoTracking(), pageIndex, pageSize);
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他一些提示&quot;&gt;其他一些提示&lt;/h2&gt;
&lt;p&gt;这里我们还有一些其他性能改进的东西可以在ASP.NET Core应用程序中进行实现。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;编写优化和测试代码。您还可以使用来自专业高级开发者的代码示例，包括产品文档。产品团队编写的代码(如C#团队)通常是优化的、现代化的，并且遵循最佳实践。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用经过优化和良好测试的API和库。例如，在某些情况下，ADO.NET可能是比 Entity Framework 或其他ORM库更好的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果您需要下载一个很大的文件的话，您可能需要考虑使用压缩算法。这里有几个内置的压缩库，如Gzip和Brotli。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{  
services.AddResponseCompression();
  
services.Configure(options =&amp;gt;
    {  
options.Level = CompressionLevel.Fastest;
    });  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;附加的建议面向client&quot;&gt;附加的建议(面向Client)&lt;/h2&gt;
&lt;p&gt;我想分享一些面向客户端的提升性能的技巧。如果您正在使用ASP.NET Core MVC创建网站，下面是一些提示：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;em&gt;捆绑和小型化&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;使用捆绑和小型化可以减少服务器请求次数。尝试一次加载所有客户端资源，如样式、js/css。您可以首先使用小型化缩小文件，然后将这些文件打包到一个文件中，这将加快加载速度并减少HTTP请求的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;em&gt;最后加载 JavaScript&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;您应该始终尝试在页面尾部加载JavaScript文件，除非在此之前需要使用它们。如果您这样做，您的网站将显示的更快，并且用户也不需要等待并看到这些内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;em&gt;压缩图像&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;确保使用压缩技术缩小图像的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;em&gt;使用 CDN&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果您只有几个样式和JS文件，那么可以从您的服务器加载。对于较大的静态文件，请尝试使用CDN。CDN通常可以在多个位置上使用，并且文件是从本地服务器提供的。从本地服务器加载文件可以提高网站性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;今天，我们学习了如何提升ASP.NET Core 应用程序的性能。非常希望这篇文章对你有所帮助，如果您有任何问题或建议，可以在博客下面进行留言或者点赞!最后感谢大伙的阅读，如果你有兴趣的话可以加入ASP.NET Core实战项目交流群跟大伙进行交流，或者加我微信：jkingzhu，备注：合肥，我拉你进入合肥.NET技术社区进行交流！&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 15:11:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>今天这篇文章我们来聊一聊如何提升并优化ASP.NET Core应用程序的性能，本文的大部分内容来自翻译，当然中间穿插着自己的理解，希望对大家有所帮助！话不多说开始今天的主题吧！ 我们都知道性能是公共网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10507984.html</dc:identifier>
</item>
<item>
<title>Netty源码分析之NioEventLoop(一)—NioEventLoop的创建 - bigfan</title>
<link>http://www.cnblogs.com/dafanjoy/p/10486019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dafanjoy/p/10486019.html</guid>
<description>&lt;p&gt;一、NioEventLoop的概述&lt;/p&gt;
&lt;p&gt;NioEventLoop做为Netty线程模型的核心部分，从本质上讲是一个事件循环执行器，每个NioEventLoop都会绑定一个对应的线程通过一个&lt;code&gt;for(;;)&lt;/code&gt;循环来处理与 Channel 相关的 IO 操作, 包括 调用 select 等待就绪的 IO 事件、读写数据与数据的处理等；其次作为任务队列, 执行 taskQueue 中的任务, 例如eventLoop.schedule 提交的定时任务也是这个线程执行的。而NioEventLoopGroup顾名思义，它是维护了一组这样的事件循环器，这也是Netty基于Reactor模式的具体设计体现。&lt;/p&gt;
&lt;p&gt;接下来我们就结合具体的代码，对NioEventLoop的整个创建流程进行一个说明与总结&lt;/p&gt;
&lt;p&gt;二、NioEventLoop的创建&lt;/p&gt;
&lt;p&gt;我们基于Netty构建服务端还是客户端时，都首先需要创建NioEventLoopGroup 实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure the server.&lt;/span&gt;
        EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        EventLoopGroup workerGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; NioEventLoopGroup 做为基于NIO的处理channle相关IO操作的事件循环器组，它的类层次结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780676/201903/780676-20190309174745845-1570340340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过NioEventLoopGroup构造函数传入线程数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new instance using the specified number of threads, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ThreadFactory} and the
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SelectorProvider} which is returned by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SelectorProvider#provider()}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(nThreads, (Executor) &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; NioEventLoopGroup最终的构造函数中会包含以下几个函数&lt;/p&gt;
&lt;p&gt;1、nThreads：传入的线程数量&lt;/p&gt;
&lt;p&gt;2、executor ：线程执行器Executor接口，默认为空&lt;/p&gt;
&lt;p&gt;3、selectorProvider：用于创建Selector的SelectorProvider &lt;/p&gt;
&lt;p&gt;4、selectStrategyFactory：传入DefaultSelectStrategyFactory.INSTANCE，  一个使用默认选择策略的工厂。&lt;/p&gt;
&lt;p&gt;5、RejectedExecutionHandlers.reject()：Netty自定义线程拒绝策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;int&lt;/span&gt; nThreads, Executor executor, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SelectorProvider selectorProvider,
                             &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; SelectStrategyFactory selectStrategyFactory) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在父类MultithreadEventLoopGroup中，会根据你传入nThreads大小，确定初始化的线程数量，为0切没有没有设置io.netty.eventLoopThreads参数项，则会以当前系统的核心线程数*2做为默认的线程数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有设置io.netty.eventLoopThreads参数项，则会以当前运行系统的核心线程数*2作为线程数&lt;/span&gt;
        DEFAULT_EVENT_LOOP_THREADS = Math.max(1&lt;span&gt;, SystemPropertyUtil.getInt(
                &lt;/span&gt;&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;-Dio.netty.eventLoopThreads: {}&quot;&lt;span&gt;, DEFAULT_EVENT_LOOP_THREADS);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; MultithreadEventLoopGroup(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads, Executor executor, Object... args) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(nThreads == 0 ?&lt;span&gt; DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在MultithreadEventExecutorGroup的构造函数中我们会根据传入的线程数，去初始化和创建一组NioEventLoop&lt;/p&gt;
&lt;p&gt;首先我们看下NioEventLoop的类层次结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780676/201903/780676-20190310194348315-1100312599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面在MultithreadEventExecutorGroup构造函数中主要完成以下几个功能：&lt;/p&gt;
&lt;p&gt;1、初始化ThreadPerTaskExecutor线程执行器，并传入一个线程创建工厂，用于NioEventLoop对应线程的创建&lt;/p&gt;
&lt;p&gt;2、根据传入的线程数，初始化一个EventExecutor数组，用于放置创建的NioEventLoop对象&lt;/p&gt;
&lt;p&gt;3、循环数组，通过newChild方法创建NioEventLoop对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;  
     * Create a new instance.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; nThreads          the number of threads that will be used by this instance.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; executor          the Executor to use, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if the default should be used.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; chooserFactory    the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EventExecutorChooserFactory} to use.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args              arguments which will passed to each {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #newChild(Executor, Object...)} call
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; MultithreadEventExecutorGroup(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nThreads &amp;lt;= 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &amp;gt; 0)&quot;&lt;span&gt;, nThreads));
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (executor == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程工厂，netty根据需要指定了线程的命名方式、优先级、是否是守护线程等属性
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该线程池没有任何队列，提交任务后，创建任何线程类型都是 FastThreadLocalRunnable, 并且立即start。&lt;/span&gt;
            executor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPerTaskExecutor(newDefaultThreadFactory());
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一组事件循环执行器&lt;/span&gt;
        children = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventExecutor[nThreads];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入的线程数，初始化一个线程数组&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nThreads; i ++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; success = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 new NioEventLoop&lt;/span&gt;
                children[i] =&lt;span&gt; newChild(executor, args);
                success &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Think about if this is a good exception type&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;failed to create a child event loop&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;success) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; i; j ++&lt;span&gt;) {
                        children[j].shutdownGracefully();
                    }

                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; i; j ++&lt;span&gt;) {
                        EventExecutor e &lt;/span&gt;=&lt;span&gt; children[j];
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;e.isTerminated()) {
                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                            }
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException interrupted) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Let the caller handle the interruption.&lt;/span&gt;
&lt;span&gt;                            Thread.currentThread().interrupt();
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 继续跟踪进入newChild(executor, args)内部，看到它会返回一个NioEventLoop对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; EventLoop newChild(Executor executor, Object... args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NioEventLoop(&lt;span&gt;this&lt;/span&gt;, executor, (SelectorProvider) args[0&lt;span&gt;],
            ((SelectStrategyFactory) args[&lt;/span&gt;1]).newSelectStrategy(), (RejectedExecutionHandler) args[2&lt;span&gt;]);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续查看NioEventLoop构造函数和他的父类构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(parent, executor, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selectorProvider == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;selectorProvider&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strategy == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;selectStrategy&quot;&lt;span&gt;);
        }
        provider &lt;/span&gt;=&lt;span&gt; selectorProvider;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SelectorTuple selectorTuple =&lt;span&gt; openSelector();
        selector &lt;/span&gt;=&lt;span&gt; selectorTuple.selector;
        unwrappedSelector &lt;/span&gt;=&lt;span&gt; selectorTuple.unwrappedSelector;
        selectStrategy &lt;/span&gt;=&lt;span&gt; strategy;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父类构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Create a new instance
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parent            the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EventExecutorGroup} which is the parent of this instance and belongs to it
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; executor          the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Executor} which will be used for executing
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; addTaskWakesUp    {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if and only if invocation of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #addTask(Runnable)} will wake up the
     *                          executor thread
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxPendingTasks   the maximum number of pending tasks before new tasks will be rejected.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; rejectedHandler   the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler} to use.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,
                                        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; addTaskWakesUp, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxPendingTasks,
                                        RejectedExecutionHandler rejectedHandler) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parent);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.addTaskWakesUp =&lt;span&gt; addTaskWakesUp;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maxPendingTasks = Math.max(16&lt;span&gt;, maxPendingTasks);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.executor = ObjectUtil.checkNotNull(executor, &quot;executor&quot;&lt;span&gt;);
        taskQueue &lt;/span&gt;= newTaskQueue(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.maxPendingTasks);
        rejectedExecutionHandler &lt;/span&gt;= ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的代码我们可以看到，初始化NioEventLoop主要完成了以下的功能&lt;/p&gt;
&lt;p&gt;1、保存线程执行器ThreadPerTaskExecutor&lt;/p&gt;
&lt;p&gt;2、创建一个selector &lt;/p&gt;
&lt;p&gt;3、基于LinkedBlockingQueue创建一个taskQueue任务队列，用于保存要执行的任务&lt;/p&gt;
&lt;p&gt;这些都是为了后续的循环执行Channel 相关事件所做准备。&lt;/p&gt;
&lt;p&gt;到这里其实我们创建了一组NioEventLoop，也就是一组事件循环执行器，每个NioEventLoop中都有对应的一个线程和一个selector ；创建完毕之后，自然就是要为每一个连接分配对应的NioEventLoop。Netty中通过&lt;/p&gt;
&lt;p&gt;实现EventLoopGroup接口中的next()方法来返回一个可以使用的的NioEventLoop&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; EventLoopGroup &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; EventExecutorGroup {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Return the next {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EventLoop} to use
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    EventLoop next();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MultithreadEventExecutorGroup中我们可以查看它的具体实现方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   chooser =&lt;span&gt; chooserFactory.newChooser(children);
    
   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventExecutor next() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; chooser.next();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入代码内部我们可以看到Netty针对数组大小，对数组下标的计算方式进行了优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Default implementation which uses simple round-robin to choose next {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; EventExecutor}.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@UnstableApi
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultEventExecutorChooserFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; EventExecutorChooserFactory {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; DefaultEventExecutorChooserFactory INSTANCE = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEventExecutorChooserFactory();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DefaultEventExecutorChooserFactory() { }

    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventExecutorChooser newChooser(EventExecutor[] executors) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是二的次幂，如果为true返回PowerOfTwoEventExecutorChooser，反之GenericEventExecutorChooser&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPowerOfTwo(executors.length)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PowerOfTwoEventExecutorChooser(executors);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericEventExecutorChooser(executors);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isPowerOfTwo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (val &amp;amp; -val) ==&lt;span&gt; val;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PowerOfTwoEventExecutorChooser &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; EventExecutorChooser {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger idx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; EventExecutor[] executors;

        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.executors =&lt;span&gt; executors;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过&amp;amp;运算的方式循环获取数组下标&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventExecutor next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; executors[idx.getAndIncrement() &amp;amp; executors.length - 1&lt;span&gt;];
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericEventExecutorChooser &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; EventExecutorChooser {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger idx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; EventExecutor[] executors;

        GenericEventExecutorChooser(EventExecutor[] executors) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.executors =&lt;span&gt; executors;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过取模的方式循环获取数组下标&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventExecutor next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; executors[Math.abs(idx.getAndIncrement() %&lt;span&gt; executors.length)];
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此我们基本把Netty中NioEventLoop及NioEventLoopGroup的创建流程及核心代码梳理了一遍。NioEventLoop做为Netty线程模型的核心部分包含的内容比较多，上面只是初始化及创建的一部分内容，后续的部分我会陆续的补齐，其中有错误和不足之处还请指正与海涵。&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 14:44:00 +0000</pubDate>
<dc:creator>bigfan</dc:creator>
<og:description>一、NioEventLoop的概述 NioEventLoop做为Netty线程模型的核心部分，从本质上讲是一个事件循环执行器，每个NioEventLoop都会绑定一个对应的线程通过一个for(;;)循</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dafanjoy/p/10486019.html</dc:identifier>
</item>
<item>
<title>Python：基于MD5的文件监听程序 - JYRoy</title>
<link>http://www.cnblogs.com/jyroy/p/10507653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyroy/p/10507653.html</guid>
<description>&lt;h2&gt;前述&lt;/h2&gt;
&lt;p&gt;　　写了一个基于MD5算法的文件监听程序，通过不同的文件能够生成不同的哈希函数，来实现实现判断文件夹中的文件的增加、修改、删除和过滤含有特定字符的文件名的文件。&lt;/p&gt;

&lt;h2&gt;需求说明&lt;/h2&gt;
&lt;p&gt;　　需要实现对一个文件夹下的文件的增加、修改和删除的监控， 一旦发生上述操作，则进行提示。可以选择过滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件。&lt;/p&gt;

&lt;h2&gt;简述&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt; 首先，关于文件的增加、修改、删除的反馈，可以想到利用MD5等类似的加密算法，因为文件本身可以生成哈希值，只要文件内容或者文件名被修改过，就会生成和修改之前的哈希值不同的值，因此可以利用dict来存储，一个文件名对应一个哈希值来存储。其中增加和删除就对应一个新增加的键值对和一个减少的键值对，而修改则可以理解为删除了旧的文件、增加了一个新的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　MD5算法可以直接利用第三方的 hashlib 库来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; m =&lt;span&gt; hashlib.md5()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; myFile = open(full_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; myFile.readlines(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以行为单位不断更新哈希值，避免文件过大导致一次产生大量开销&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;            m.update(line)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最后可以得到整个文件的哈希值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;第二，关于滤掉文件名中的特定字符和只监听文件名中含有特定字符的文件的功能，这个其实非常简单，只需要用 list 分别对需要过滤和必须存在字符串进行存储， 然后利用标志位和字符串的子串包含性进行判断就可以了，只有满足条件的文件可以产生哈希值，产生哈希值也就意味着被监听了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　判断字符串中是否含有字串最常用的方法是 in 和 string 中的 find 方法，这里就不再赘述，可以直接看下面的代码&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;第三，因为要同时监控多个文件夹，所以必须要利用到线程来处理，创建一个线程池来存储线程， 线程利用了 threading 库，并且实现一个线程类来处理线程的操作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; myListener(threading.Thread):
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; thread1 = myListener(mydir, json_list_include, json_list_exclude)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成线程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;　　需要额外说明的一点是，在传输需要监听的文件夹、必须包含的字段以及过滤字段的时候，我这里是利用配置文件的形式来存储的。说到底，是利用 toml 格式的数据进行的传输，toml格式和 json格式相比，用户的可读性更强一些，为了便于博客展示，因此利用了 toml 格式&lt;/p&gt;
&lt;p&gt;　　首先利用代码生成了一下toml格式的文件，以后再想用的话，程序打包之后，可以直接修改配置文件来实现对程序的控制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 1 #!/usr/bin/env python
 2 # -*- coding:utf-8 -*-
 3 # Author: JYRoooy
 4 import&lt;span&gt; collections
 5 import&lt;span&gt; json
 6 import&lt;span&gt; toml
 7 if __name__ == '__main__'&lt;span&gt;:
 8     myOrderDict =&lt;span&gt; collections.OrderedDict
 9     myOrderDict = {'dict':[{'path':'E:/testing', 'include':['log_'], 'exclude': ['.swp', '.swx', 'tmp']},{'path':'E:/tmp', 'include':['.record'], 'exclude': ['.tmp'&lt;span&gt;]}]}
10     myToml = toml.dump(myOrderDict, open('E:/python/code/PythonProject/tomlConfig.txt','w+'))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;toml文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　格式说明， 一个 dict 对应一个监听的文件夹和需要 过滤(exculde) 和 含有(include) 的字段，解释一下，这里的字段只是文件名的字段，监控 E:/testing 目录下的文件，要包含 log_ 字段的文件，且不包含 .swp .swx .tmp 字段的文件， 并且监控 E:/tmp 目录下的文件，要包含 .record 字段的文件，且不包含 .tmp 的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201903/1378215-20190310220533288-2115560742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;完整程序的代码，具体解释可以看注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Author: JYRoooy&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; toml
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; importlib
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;importlib.reload(sys)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; myListener(threading.Thread):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    监听类
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, input_dir, filt_in, filt_ex):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;文件夹路径，必须包含的字符，必须过滤的字符&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         threading.Thread.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.input_dir =&lt;span&gt; input_dir
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         self.filt_in =&lt;span&gt; filt_in
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         self.filt_ex =&lt;span&gt; filt_ex
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         self.dict = {}     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来存储文件名和对应的哈希值&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         self.file_list = []   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储每一次扫描时的文件的文件名&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         self.pop_list = []   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储需要删除的文件名&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (1):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保证文件夹一直处于被监听的状态&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; cur_dir, dirs, files &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.walk(self.input_dir):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; files !=&lt;span&gt; []:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     self.file_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; each_file_1 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; files:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         each_file =&lt;span&gt; each_file_1
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; self.filt_in:       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断文件名中是否有必须存在的字段&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                             flagone =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(self.filt_in)):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; self.filt_in[i] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; each_file:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                                     flagone += 1
&lt;span&gt;38&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; flagone ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; self.filt_ex:       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断文件名中是否有必须过滤掉的字段&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                             flagtwo =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(self.filt_ex)):
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; self.filt_ex[i] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; each_file:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                                     flagtwo = 1
&lt;span&gt;46&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; flagtwo==1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        self.file_list.append(each_file)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         full_path =&lt;span&gt; os.path.join(cur_dir, each_file)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                         m = hashlib.md5()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化md5算法&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;                         myFile = open(full_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; myFile.readlines():
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                            m.update(line)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; each_file &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; self.dict.keys():     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果当前的dict中没有这个文件，那么就添加进去&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                             self.dict[each_file] = m.hexdigest()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成哈希值&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;                             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文件夹:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +cur_dir+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中的文件名为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + each_file + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的文件为新文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                                                                                  time.localtime(time.time())))
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; each_file &lt;span&gt;in&lt;/span&gt; self.dict.keys() &lt;span&gt;and&lt;/span&gt; self.dict[each_file] != m.hexdigest():      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果当前dict中有这个文件，但是哈希值不同，说明文件被修改过，则需要对字典进行更新&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文件夹:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +cur_dir+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中的文件名为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + each_file + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的文件被修改于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                                                                                  time.localtime(time.time())))
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                             self.dict[each_file] =&lt;span&gt; m.hexdigest()
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                        myFile.close()
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 pop_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.dict.keys():
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; self.file_list:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当字典中有不在当前文件名列表中时，说明文件已经被删除&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;                         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文件夹:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +cur_dir+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中的文件名为:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的文件已被删除!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                                                                         time.localtime(time.time())))
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                        pop_list.append(i)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pop_list:
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;                    self.dict.pop(i)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;             time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     threads = []    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来存储线程的线程池&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;     with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:/python/code/PythonProject/tomlConfig.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as f:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取toml格式的文件，并分解格式&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;         mytoml =&lt;span&gt; toml.load(f)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         myList = mytoml[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(myList)):     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为可能同时需要监听多个文件夹，所以利用线程池处理多线程&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;             json_list_include =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             json_list_exclude =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             mydir = myList[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; sublist &lt;span&gt;in&lt;/span&gt; range(len(myList[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])):
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 json_list_include.append(myList[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;][sublist])
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; sublist &lt;span&gt;in&lt;/span&gt; range(len(myList[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])):
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                 json_list_exclude.append(myList[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;][sublist])
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;             thread1 = myListener(mydir, json_list_include, json_list_exclude)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成线程&lt;/span&gt;
&lt;span&gt;91&lt;/span&gt; &lt;span&gt;            threads.append(thread1)
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; 
&lt;span&gt;93&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; threads:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启所有线程&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt;             t.start();
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;p&gt;　　两个文件夹中的文件&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201903/1378215-20190310222104278-277366173.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201903/1378215-20190310222118642-318700904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　第一次运行程序， 可以看到已经按照过滤规则完成了过滤和监听&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201903/1378215-20190310222035587-1589636335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改 loko.record 文件为 loko.re，再来看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201903/1378215-20190310222250313-547727311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到已经完成了监听，因为 loko.re 文件，并符合监听的规则，所以不做出监听，而我们前面说过，一个修改相当于一个删除和一个新建操作，所以监听程序提示原文件被删除了&lt;/p&gt;

&lt;h2&gt;写在后面&lt;/h2&gt;
&lt;p&gt;　　其他的效果我就不一一展示了。&lt;/p&gt;
&lt;p&gt;　　程序也没有实现很复杂的效果，代码已经上传 github -- https://github.com/JYRoy/MyFileListener&lt;/p&gt;
&lt;p&gt;　　欢迎大佬们交流~&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 14:39:00 +0000</pubDate>
<dc:creator>JYRoy</dc:creator>
<og:description>前述 写了一个基于MD5算法的文件监听程序，通过不同的文件能够生成不同的哈希函数，来实现实现判断文件夹中的文件的增加、修改、删除和过滤含有特定字符的文件名的文件。 需求说明 需要实现对一个文件夹下的文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyroy/p/10507653.html</dc:identifier>
</item>
</channel>
</rss>