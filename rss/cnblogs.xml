<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小程序支付 - Jeff的技术栈</title>
<link>http://www.cnblogs.com/guyouyin123/p/12490480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyouyin123/p/12490480.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;amp;index=1&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;amp;index=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&amp;amp;index=1&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&amp;amp;index=1&lt;/a&gt; # 接口&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;1 用户发起请求下单支付
2 我们要保证用是登入状态。
3 组织数据，请求统一下单接口，微信官方会同步返回一个prepay_id
4 重新组织数据，进行签名，将重新组织的数据返回给小程序，小程序在吊起支付。
5 用户就可以进行支付，支付结果会同步返回给小程序
6 后台修改订单支付状态是通过微信官方服务器的异步通知&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;业务流程时序图&quot;&gt;业务流程时序图&lt;/h2&gt;
&lt;p&gt;小程序支付的交互图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pay.weixin.qq.com/wiki/doc/api/img/wxa-7-2.jpg&quot; alt=&quot;小程序支付时序图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;商户系统和微信支付系统主要交互：&lt;/p&gt;
&lt;p&gt;1、小程序内调用登录接口，获取到用户的openid,api参见公共api【&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html&quot;&gt;小程序登录API&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;2、商户server调用支付统一下单，api参见公共api【&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&amp;amp;index=1&quot;&gt;统一下单API&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;3、商户server调用再次签名，api参见公共api【&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&quot;&gt;再次签名&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;4、商户server接收支付通知，api参见公共api【&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_7&quot;&gt;支付结果通知API&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;5、商户server查询支付结果，api参见公共api【&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_2&quot;&gt;查询订单API&lt;/a&gt;】&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=4_3&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=4_3&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 签名
    def get_sign(self):
        data_dict = {
            &quot;appid&quot;: self.appid,
            &quot;mch_id&quot;: self.mch_id,
            &quot;nonce_str&quot;: self.nonce_str,
            &quot;body&quot;: self.body,
            &quot;out_trade_no&quot;: self.out_trade_no,
            &quot;total_fee&quot;: self.total_fee,
            &quot;spbill_create_ip&quot;: self.ip,
            &quot;notify_url&quot;: self.notify_url,
            &quot;trade_type&quot;: self.trade_type,
            &quot;openid&quot;: self.openid,
        }
        # 列表推导式，
        sign_str = &quot;&amp;amp;&quot;.join([f&quot;{k}={data_dict[k]}&quot; for k in sorted(data_dict)])
        sign_str = f&quot;{sign_str}&amp;amp;key={settings.pay_apikey}&quot;
        print(&quot;sign_str&quot;, sign_str)
        md5 = hashlib.md5()
        md5.update(sign_str.encode(&quot;utf-8&quot;))
        sign = md5.hexdigest()
        return sign.upper()&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;&amp;lt;xml&amp;gt;
  &amp;lt;appid name=&quot;属性值&quot; &amp;gt;{.child.text}&amp;lt;/appid&amp;gt;
   child.tag表示appid   
&amp;lt;/xml&amp;gt; 

import xml.etree.ElementTree as ET

如果我们要解析一个xml文件
tree = ET.parse('country_data.xml')
root = tree.getroot()

如果解析字符串
root = ET.fromstring(country_data_as_string)

这个root是 Element 
for child in root:
     print(child.tag, child.attrib)
     #child.tag表是标签名，child.attrib表示获取属性
     #child.text就表示获取内容
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 拼接的xml数据
body_data = f'''
    &amp;lt;xml&amp;gt;
    &amp;lt;appid&amp;gt;{self.appid}&amp;lt;/appid&amp;gt;
    &amp;lt;mch_id&amp;gt;{self.mch_id}&amp;lt;/mch_id&amp;gt;
    &amp;lt;nonce_str&amp;gt;{self.nonce_str}&amp;lt;/nonce_str&amp;gt;
    &amp;lt;body&amp;gt;{self.body}&amp;lt;/body&amp;gt;
    &amp;lt;out_trade_no&amp;gt;{self.out_trade_no}&amp;lt;/out_trade_no&amp;gt;
    &amp;lt;total_fee&amp;gt;{self.total_fee}&amp;lt;/total_fee&amp;gt;
    &amp;lt;spbill_create_ip&amp;gt;{self.spbill_create_ip}&amp;lt;/spbill_create_ip&amp;gt;
    &amp;lt;notify_url&amp;gt;{self.notify_url}&amp;lt;/notify_url&amp;gt;
    &amp;lt;trade_type&amp;gt;{self.trade_type }&amp;lt;/trade_type&amp;gt;
    &amp;lt;openid&amp;gt;{self.openid }&amp;lt;/openid&amp;gt;      
    &amp;lt;sign&amp;gt;{self.sign}&amp;lt;/sign&amp;gt;      
    &amp;lt;/xml&amp;gt; 
'''&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接收xml二进制数据转换为字典&quot;&gt;接收xml二进制数据，转换为字典&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 接收xml二进制数据，转换为字典
    def xml_to_dict(self, xml_data):
        import xml.etree.ElementTree as ET

        xml_dict = {}

        root = ET.fromstring(xml_data)

        for child in root:
            xml_dict[child.tag] = child.text
        return xml_dict&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 再次签名
    def get_two_sign(self, data):
        data_dict = {
            &quot;appId&quot;: settings.AppId,
            &quot;timeStamp&quot;: str(int(time.time())),
            &quot;nonceStr&quot;: data['nonce_str'],
            &quot;package&quot;: f&quot;prepay_id={data['prepay_id']}&quot;,
            &quot;signType&quot;: &quot;MD5&quot;

        }
        sign_str = &quot;&amp;amp;&quot;.join([f&quot;{k}={data_dict[k]}&quot; for k in sorted(data_dict)])
        sign_str = f&quot;{sign_str}&amp;amp;key={settings.pay_apikey}&quot;
        md5 = hashlib.md5()
        md5.update(sign_str.encode(&quot;utf-8&quot;))
        sign = md5.hexdigest()
        return sign.upper(), data_dict['timeStamp']&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;amp;index=3&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;wx.requestPayment(
    {
    'timeStamp':e.data.data.timeStamp,
    'nonceStr': e.data.data.nonceStr,
    'package': e.data.data.package,
    'signType': e.data.data.signType,
    'paySign': e.data.data.paySign,
    'success':function(res){
    console.log(&quot;成功&quot;,res)
    },
    'fail':function(res){
    console.log(&quot;失败&quot;,res)
    },

})&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1 接收到支付请求。我们先组织数据，然后进行统一下单前的签名
- 请求的数据与响应的数据都是xml.请求的时候，xml数据要变成二进制，heards中的content-type:&quot;application/xml&quot;
-响应的数据也是xml,我要用xml.etree.ElementTree将他转化为字典
2 拿到统一下单数据，最重要的prepay_id，进行再次签名。把一下数据发送给小程序。
            &quot;timeStamp&quot;: 时间戳
            &quot;nonceStr&quot;:随机字符串
            &quot;package&quot;: f&quot;prepay_id={data_dict['prepay_id']}&quot;,统一下单中的到的prepay_id
            &quot;signType&quot;: &quot;MD5&quot;,
            &quot;paySign&quot;:通过上面数据进行加密的结果
 3 小程序掉用wx.resquestPayment()吊起支付&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 14 Mar 2020 00:30:00 +0000</pubDate>
<dc:creator>Jeff的技术栈</dc:creator>
<og:description>[TOC] 一、小程序支付官方文档 接口 二、小程序支付流程 三、支付流程图(下方有接口) 业务流程时序图 小程序支付的交互图如下： 商户系统和微信支付系统主要交互： 1、小程序内调用登录接口，获取到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyouyin123/p/12490480.html</dc:identifier>
</item>
<item>
<title>如何设计分层架构和交互接口 API ? - IT老兵哥</title>
<link>http://www.cnblogs.com/itlaobingge/p/12490470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itlaobingge/p/12490470.html</guid>
<description>&lt;p&gt;在「 如何建立架构师的立体化思维？ 」这篇文章中，老兵哥 跟大家一起聊到架构设计涉及业务、技术、系统和时间等几个维度，也知道从技术维度可以将应用分成七层，那具体怎么做呢？今天我们继续来聊聊分层架构的设计流程，以及接口设计方法等内容。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;84.573211624441&quot;&gt;
&lt;h2 class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;架构设计流程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在「 &lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/itlaobingge/p/12484188.html&quot;&gt;如何建立架构师的立体化思维？&lt;/a&gt; 」这篇文章中，&lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;老兵哥&lt;/a&gt; 跟大家一起聊到架构设计涉及业务、技术、系统和时间等几个维度，也知道从技术维度可以将应用分成七层，那具体怎么做呢？今天我们继续来聊聊分层架构的设计流程，以及接口设计方法等内容。通常，我们可以将分层架构的设计流程分解为下列 4 个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;第一步，结合现实情况，将系统划分成多个层次。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;第二步，确定层与层之间的关系，梳理出层与层之间的交互接口。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;第三步，将功能相近的接口划归到一个模块，确保模块高内聚，对外低耦合。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;第四步，在此基础上进一步明晰接口的参数列表。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;仅仅四个步骤就完成了架构设计吗？这会不会太简单空洞了呢？各位看官，不要着急，请听蔡老师慢慢道来，每个步骤都有极具可操作性的方法及工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1876334/202003/1876334-20200314080917593-1121375932.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;301&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;图&lt;span class=&quot;s5&quot;&gt;5 &lt;span class=&quot;s3&quot;&gt;架构设计流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;p5&quot;&gt;&lt;span class=&quot;s6&quot;&gt;&lt;strong&gt;层次的切分方法&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;面对一个庞然大物，你该如何下手呢？不用担心，这已经给你准备了庖丁解牛的方法，轻轻松松把一个复杂的大系统变得可以掌控了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;li6&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;第一刀：&lt;/strong&gt;按照这套方法论来进行架构设计，最理想的情况是将&lt;span class=&quot;s4&quot;&gt;X&lt;span class=&quot;s3&quot;&gt;轴切分成七层。而第一刀应该先切在业务和领域之间，即通过&lt;span class=&quot;s4&quot;&gt;API&lt;span class=&quot;s3&quot;&gt;把两边解耦。交互和业务跟用户关联度高，经常随需求变化而改动，而领域和资源相对比较稳定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;第二刀：&lt;/strong&gt;考虑到要完成某些业务功能，系统可能需要调用外部系统协同完成，为了保证领域层相对稳定，我们需要隔离外部系统或数据持久层变化带来的影响，那第二刀应该切在领域和资源之间。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;第三刀：&lt;/strong&gt;考虑到同样的一个业务可能会有多套界面，例如有&lt;span class=&quot;s4&quot;&gt;Web&lt;span class=&quot;s3&quot;&gt;版、桌面版、移动版等，为了提高重用，隔离变更，那接下来要把交互和业务切开。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;通过上面这&lt;span class=&quot;s4&quot;&gt;“&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;温柔的三刀&lt;/strong&gt;&lt;span class=&quot;s4&quot;&gt;&lt;strong&gt;”&lt;/strong&gt;&lt;span class=&quot;s3&quot;&gt;，我们就可以把一个大块头切分成七个层次。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;p7&quot;&gt;&lt;span class=&quot;s6&quot;&gt;&lt;strong&gt;接口的设计方法&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;在确定分层之后，我们可以把每个业务需求的交互时序图画出来，而分层就是交互时序图的主角。这时候我们就可以清晰的找出层与层之间的交互接口，以及可以初步确定每个接口的参数列表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1876334/202003/1876334-20200314081033566-1649725677.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;326&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;图&lt;span class=&quot;s5&quot;&gt;6 &lt;span class=&quot;s3&quot;&gt;业务交互时序图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;考虑到&lt;span class=&quot;s4&quot;&gt;API&lt;span class=&quot;s3&quot;&gt;、领域模型接口、&lt;span class=&quot;s4&quot;&gt;SPI&lt;span class=&quot;s3&quot;&gt;是最为关键的接口，那良好的设计就显得更为重要。那如何能够设计出良好的接口呢？在这点上，蔡老师也有非常丰富的经验可以分享：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p8&quot;&gt;&lt;span class=&quot;s3&quot;&gt; &lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1876334/202003/1876334-20200314081059230-792775051.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;298&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;图&lt;span class=&quot;s5&quot;&gt;7 &lt;span class=&quot;s3&quot;&gt;接口设计流程图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol1&quot;&gt;&lt;li class=&quot;li6&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;找出领域对象：&lt;/strong&gt;通过多轮领域访谈，与业务专家一起分析出领域对象。另外，也可以通过研究外部接口及数据字典来明晰领域对象，反过来也可以丰富外部接口和数据字典。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li6&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;设计领域模型、资源模型、数据模型：&lt;/strong&gt;在挖掘领域对象的过程中，我们就可以开始设计领域模型了，确定领域对象之间的关联关系。当关联关系逐步清晰之后，我们还可以根据关联关系的密集程度对领域对象的组织方式做一些调整，找出核心的领域对象集合，其他领域对象可以归类到围绕核心领域对象集合的卫星集合里面。通过多轮调整，我们可以得到一个能够映射业务、关系简化的领域模型。然后兵分两路启动资源模型和数据模型的设计工作。上述三个模型之间的关系及区别，请参见下文。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li6&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;设计领域模型接口、&lt;/strong&gt;&lt;span class=&quot;s4&quot;&gt;&lt;strong&gt;API&lt;/strong&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;span class=&quot;s4&quot;&gt;&lt;strong&gt;SPI&lt;/strong&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;、数据库：&lt;/strong&gt;在设计领域模型接口时，我们要尽量做到不多不少，这些接口都是对外提供服务所必须的，也是全面的，并且粒度要细。在设计&lt;span class=&quot;s4&quot;&gt;API&lt;span class=&quot;s3&quot;&gt;时，我们要考虑内外客户的需求和特点，做到方便易用，可以参考&lt;span class=&quot;s4&quot;&gt;RESTful API&lt;span class=&quot;s3&quot;&gt;设计相关的资料。在设计&lt;span class=&quot;s4&quot;&gt;SPI&lt;span class=&quot;s3&quot;&gt;时，我们要尽量隔离资源层对领域层的影响。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;在完成上述工作之后，我们就可以进入实施阶段，开始启动代理层、核心层和服务层的代码设计工作。另外，如果是对线上已有系统进行升级，那还要开始制定数据的迁移计划。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;p5&quot;&gt;&lt;span class=&quot;s6&quot;&gt;&lt;strong&gt;三个模型之间的关系及区别&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;领域模型&lt;/strong&gt;，映射特定业务领域当中核心领域对象及其关联关系，这些对象及关系的存在都是完成业务规则所必须的，甚至是法律法规等明文要求的，不会轻易变动。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;资源模型&lt;/strong&gt;，基于领域模型，从为内外客户提供服务的角度分析定义出来的，包含了资源对象及其关联关系。根据内外客户的特点及需求，我们可以调整资源模型中的内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;p6&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;数据模型&lt;/strong&gt;，基于领域模型，从存储（持久化或缓存）信息的角度分析定义出来的，包含数据对象及其关联关系。根据存储载体的特点及需求，我们可以调整数据模型中的内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;p6&quot;&gt;先分享到这里，坚持原创不易，如果你觉得有价值，麻烦动动手指点个 「&lt;span&gt;&lt;strong&gt;赞&lt;/strong&gt;&lt;/span&gt;」，老兵哥会更有动力。另外，我还会持续分享职业规划、应聘面试、技能提升、影响力打造等经验，&lt;strong&gt;关注&lt;/strong&gt; 「 &lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;IT老兵哥&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt; 」，&lt;strong&gt;赋能程序人生&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://itlaobingge.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1876334/202002/1876334-20200226130104179-1718574467.jpg&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;240&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;近期文章索引：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 14 Mar 2020 00:19:00 +0000</pubDate>
<dc:creator>IT老兵哥</dc:creator>
<og:description>在「 如何建立架构师的立体化思维？ 」这篇文章中，老兵哥 跟大家一起聊到架构设计涉及业务、技术、系统和时间等几个维度，也知道从技术维度可以将应用分成七层，那具体怎么做呢？今天我们继续来聊聊分层架构的设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itlaobingge/p/12490470.html</dc:identifier>
</item>
<item>
<title>软件WEB自动化测试工具之智能元素定位 - sunLand</title>
<link>http://www.cnblogs.com/kylinTOP/p/12490442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kylinTOP/p/12490442.html</guid>
<description>&lt;p&gt; 江湖一直有着这么一句名言“&lt;strong&gt;天下武功，唯快不破&lt;/strong&gt;&quot;。那么在软件测试领域，自然而然我们会想到软件自动化测试。软件自动化测试的实现自然离不开软件自动化测试工具。软件自动化测试工具是软件自动化的载体，只有通过工具，我们才能实现。武林也是一样，成为武功盖世，除了武林秘决之外，还要有依天剑、屠龙刀的配合。&lt;/p&gt;
&lt;p&gt;    话说软件开发模式有：瀑布模型、增量式开发、螺旋开发、敏捷开发。软件业早期的开发模式主要以瀑布模型为主，后期逐渐专为敏捷开发。软件开发效率和变更频率也随着开发模式的变化而变化，优其到了敏捷开发模式。一些传统的自动化测试工具显示力不从心，很难应付软件开发的快速迭代和变更，导致一些公司开展自动化测试，徒劳无功。主要原因有：自动化用例建设速度慢，跟不上软件新增内容；软件变更频繁导致用例维护成本巨大；学习成本高。所有这些都是自动化测试在中国软件业难以建树的主要原因。&lt;/p&gt;
&lt;p&gt;     软件自动化测试工具工作流程：新建用例-&amp;gt;调试用例-&amp;gt;行执行用例-&amp;gt;分析结果-&amp;gt;输出报告-&amp;gt;维护用例。其中：新建用例和维护用例是消耗最大的工作量。敏捷开发模式的引入，导致维护工量大大提升，甚至一度有超过新建用例工作量的趋势，这一直困扰软件自动化测试的一个头痛问题。&lt;/p&gt;
&lt;p&gt;    自动化用例维护环节中，元素定位失效是一个主要原因。下面我们看一下一些常用自动化工具的元素定位原理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、selenium元素定位样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;以下是一段Python+ selenium的用例样例，对元素的操作是以元素id为基础的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
 from selenium import webdriver
 url = &quot;http://10.98.110.44/egov-portal/egov/shIndex.html&quot;
 # 打开浏览器，最大化浏览器
 driver = webdriver.Chrome()
 driver.get( url )
 driver.implicitly_wait( 10 )
 driver.maximize_window()
 #输入账号
 driver.find_element_by_id(&quot;username&quot;).send_keys(“zhangsan&quot;)
 #输入密码
 driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;ww1234&quot;)
 #点击登录按钮
 driver.find_element_by_id(&quot;submitButton&quot;).click()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　2、robotFramwork+seleniuLibrary元素定位样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1879954/202003/1879954-20200308185648320-1826319365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、UFT工具元素定位方法样例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:vbnet;gutter:true;&quot;&gt;
Dialog(&quot;Login&quot;).WinEdit(&quot;AgentName:&quot;).Set &quot;mercury&quot;
Dialog(&quot;Login_2&quot;).WinButton(&quot;Help&quot;).Click
Dialog(&quot;Login_2&quot;).Dialog(&quot;FlightReservations&quot;).Static(&quot;The password is 'MERCURY'&quot;).CheckCheckPoint(&quot;The password is 'MERCURY'&quot;)
Dialog(&quot;Login_2&quot;).Dialog(&quot;FlightReservations&quot;).WinButton(&quot;确定&quot;).Click
Dialog(&quot;Login&quot;).WinButton(&quot;OK&quot;).Click
Window(&quot;FlightReservation&quot;).Activate
Window(&quot;FlightReservation&quot;).ActiveX(&quot;MaskEdBox&quot;).Type &quot;102715&quot;
#选择日期
Window(&quot;Flight Reservation&quot;).WinComboBox(&quot;FlyFrom:&quot;).Select &quot;Frankfurt&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从以上信息我看到，元素的定位都是通过元素的属性定位，元素属性主要有以下8种：&lt;/p&gt;
&lt;p&gt;  1、id定位： driver.find_element_by_id(&quot;kw&quot;)&lt;/p&gt;
&lt;p&gt; 2、name定位： driver.find_element_by_name(&quot;wd&quot;)&lt;/p&gt;
&lt;p&gt; 3、class定位： driver.find_element_by_class_name(&quot;s_ipt&quot;)&lt;/p&gt;
&lt;p&gt; 4、tag定位：driver.find_element_by_tag_name(&quot;input&quot;)&lt;/p&gt;
&lt;p&gt; 5、link定位：driver.find_element_by_link_text(&quot;新闻&quot;)&lt;/p&gt;
&lt;p&gt; 6、partial_link定位：driver.find_element_by_partial_link_text()&lt;/p&gt;
&lt;p&gt; 7、xpath定位： driver.find_element_by_xpath(&quot;/html/body/div[2]/div/form/div/input&quot;)&lt;/p&gt;
&lt;p&gt; 8、CSS定位：driver.find_element_by_css_selector&lt;/p&gt;
&lt;p&gt;在现有的自动化软件当中，都是以上述8种定位方式中的一种对元素进行定位。现在现实的测试环境经常不是我们想象的那样平静。页面中出现id，name，tag 重复的很多。也许在我们写用例的不重复，经过一轮版本修改后很可能变得重复了。xpath是最不可能失效的，但是经常因父节点的修改而导致失效是常有的事。因此自动化设计人员疲于奔命的维护用例，工作量非常的巨大。&lt;/p&gt;
&lt;p&gt;4、元素智能定位&lt;/p&gt;
&lt;p&gt; kylinTOP的软件，支持智能元素定位， 我比较感兴趣就去研究了一下，该软件的用例主要通过录制生成，录制生成一些可视化的脚本,如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1879954/202003/1879954-20200308185509339-1506242141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1879954/202003/1879954-20200308220845777-1272370658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上图是点按钮的步骤，步骤中记录了按钮的多个属性：title|alt、src、border、alt、xpath以及它的孩子信息。有些属性并不能唯一定位元素（页面中存在重复），如：border。&lt;strong&gt;kylinTOP&lt;/strong&gt;记录下了按钮元素的所有身份信息。当笔者尝试修改页面代码中title|alt的值 ，使页面中title|alt的值有重复。在脚本回放时，仍然可以正常运行。恢复title|alt值 ，重复上述修改步骤，逐个修改其它属性值，仍然不影响脚本运行。通过测试发现，修改按钮任何属性都不影响脚本执行。&lt;/p&gt;
&lt;p&gt;   通过阅读官网资料，说元素定位是根据元素的一系列属性进行定位，并不依赖于某一个属性，采取的是一种元素智能定位算法。在软件自动化测试领域，kylinTOP的元素定位的确有过人之处，大大提高了自动化用例执行的稳定性，节省了用例的维护成本。官网：&lt;a href=&quot;http://www.70testing.com&quot; target=&quot;_blank&quot;&gt;www.70testing.com&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Mar 2020 23:51:00 +0000</pubDate>
<dc:creator>sunLand</dc:creator>
<og:description>江湖一直有着这么一句名言“天下武功，唯快不破&amp;quot;。那么在软件测试领域，自然而然我们会想到软件自动化测试。软件自动化测试的实现自然离不开软件自动化测试工具。软件自动化测试工具是软件自动化的载体，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kylinTOP/p/12490442.html</dc:identifier>
</item>
<item>
<title>再探循环神经网络 - renyuzhuo</title>
<link>http://www.cnblogs.com/renyuzhuo/p/12490220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renyuzhuo/p/12490220.html</guid>
<description>&lt;p&gt;上一篇中，我们讨论了循环神经网络相关的基本内容，今天我们继续探讨一下循环神经网络还有那些需要注意的更高级的用法。&lt;/p&gt;
&lt;h2 id=&quot;降低过拟合&quot;&gt;降低过拟合&lt;/h2&gt;
&lt;p&gt;在之前的讨论中，我们经常聊起过拟合的问题，我们一般判断训练的网络什么情况下算作训练完成，查看其精度和损失时，也都看的是其过拟合之前的数据，避免过拟合的一种方法是用 dropout 方法，随机清零的方式去实现，但是在循环神经网络中，这个问题就有点复杂了。&lt;/p&gt;
&lt;p&gt;人们在大量的实验中早已经发现，在循环层前进行 dropout 对于降低过拟合没什么帮助，甚至可能会影响网络的正常训练，在循环层中如何 dropout 是在 2015 年的一篇论文中提出来的，具体的方式是：在每一个时间步中，使用相同的 dropout 掩码，并且将这个不随时间步变化的 dropout 掩码应用于层的内部循环激活，这样就可以将其学习的误差传递下去，如果在 Keras 中使用 LSTM、GRU 等循环神经网络都可以通过设置 dropout（输入单元 dropout） 和 recurrent_out （循环单元 dropout）来降低过拟合，一般情况下，最佳情况不会有大的下降，但会稳定更多，是调优网络的一个思路。用的方法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;model.add(layers.GRU(32, dropout=0.2, recurrent_dropout=0.2, input_shape=(None, float_data.shape[-1])))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;循环层堆叠&quot;&gt;循环层堆叠&lt;/h2&gt;
&lt;p&gt;我们训练网络一般的过程都是构建一个网络，在未出现严重过拟合前我们都会尽可能大的增加网络容量（让特征点更多），这有助于让网络模型更好的抓住数据的特征，对于循环神经网络，也是类似的思路，进行循环层的堆叠，且一般情况下，都会让数据变得更好，这是最常用其有效（使数据变好，具体提高程度视情况而不同）的调优方法，Google 产品中有挺多类似的做法。用的方法是：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;model.add(layers.GRU(32, dropout=0.1, recurrent_dropout=0.5, return_sequences=True, input_shape=(None, float_data.shape[-1])))
model.add(layers.GRU(64, activation='relu', dropout=0.1, recurrent_dropout=0.5))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用双向-rnn&quot;&gt;使用双向 RNN&lt;/h3&gt;
&lt;p&gt;针对这个问题，我一直觉得是一个玄学。双向 RNN，顾名思义，就是这个循环网络中包含两个方向相反的普通 RN，一个正向处理数据，一个反向处理数据，因为我们知道 RNN 是对顺序敏感的前一项处理出的数据值，会作用到下一项数据上，因此数据的不同不同方向的处理会获取到数据的不同特征，或者说反向的 RN 会识别出被正向 RN 忽略的特征，进而补充正向 RN 的不足，如此一来，可能使得整个 RNN 效果更好，略有玄学特征但是也可以理解吧，总之这也是一个有效的办法。用的方法是：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;model.add(layers.Bidirectional(layers.LSTM(32)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于神经网络来说，具体哪一种调优的方法真的有效效果更好，其实根据实际问题实际的数据有比较大的差别，不能一概而论，因此这也是一项需要经验和耐心的工作，也许你还会发出这样的疑问：“我去，为什么这样不行？我去，为什么这样还不行？我去，为什么这样行了？”&lt;/p&gt;
&lt;p&gt;当然，还有一些其他的方法对于更好的训练网络可能有用，比如调节激活函数、调节优化器学习率等，用点耐心会训练出你满意的网络的。&lt;/p&gt;
&lt;p&gt;循环神经网络就暂时先讨论这些吧，还有很多细节但是很重要的问题还没有详细介绍，日后有机会继续讨论。&lt;/p&gt;
&lt;p&gt;愿世界和平！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文首发自公众号：&lt;a href=&quot;https://ai.renyuzhuo.cn&quot;&gt;RAIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 13 Mar 2020 17:11:00 +0000</pubDate>
<dc:creator>renyuzhuo</dc:creator>
<og:description>上一篇中，我们讨论了循环神经网络相关的基本内容，今天我们继续探讨一下循环神经网络还有那些需要注意的更高级的用法。 降低过拟合 在之前的讨论中，我们经常聊起过拟合的问题，我们一般判断训练的网络什么情况下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/renyuzhuo/p/12490220.html</dc:identifier>
</item>
<item>
<title>python中的迭代器和生成器 - 不愿透露姓名的高杨</title>
<link>http://www.cnblogs.com/thecatcher/p/12490184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thecatcher/p/12490184.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们学习迭代器和生成器之前的时候,我们要先搞清楚几个概念:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;迭代协议:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 有&lt;code&gt;__next__&lt;/code&gt;方法会前进道下一个结果,而且在一系列结果的末尾时,会引发&lt;code&gt;StopIteration&lt;/code&gt;异常的对象.&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;可迭代对象:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 实现了&lt;code&gt;__iter__&lt;/code&gt;方法的对象&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;迭代器:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 实现了&lt;code&gt;__iter__&lt;/code&gt;和&lt;code&gt;__next__&lt;/code&gt;方法的对象&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;生成器:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 通过生成器表达式或者yeild关键字实现的函数.&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里不太好理解,我们借用一个图 &lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200314/003516884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可迭代对象&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是可迭代对象不一定是迭代器.比如列表类型和字符串类型都是可迭代对象,但是他们都不是迭代器.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;6&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]: L1 = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]: type(L1)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]: list&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]: L1_iter=L1.__iter__()&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]: type(L1_iter)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]: list_iterator&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是对于容器以及文件这样的可迭代对象来说的话,他们都实现了一个&lt;code&gt;__iter__&lt;/code&gt;方法. 这个方法可以返回一个迭代器. &lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200314/003546850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;迭代器中的&lt;code&gt;__next__&lt;/code&gt;方法,&lt;code&gt;next()&lt;/code&gt;方法和&lt;code&gt;for&lt;/code&gt;语句&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先迭代器中都实现了&lt;code&gt;__next__()&lt;/code&gt;方法. 我们可以直接调用迭代器的&lt;code&gt;__next__&lt;/code&gt;方法来得到下一个值. 比如:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]: L1_iter.__next__()&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;]: next(L1_iter)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里,next()方法也是去调用迭代器内置的&lt;code&gt;__next__&lt;/code&gt;方法. 所以这两种操作是一样的. 但是在日常使用的时候,我们不会直接去调用next()方法来使用生成器.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多的操作是通过for语句来使用一个生成器.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就下面这两段代码来看,其作用上是等效的.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;L1 = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; L1:&lt;br/&gt;print(x, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;  &quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\nthe same result of those two statements!&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;L1_iter = L1.__iter__()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:&lt;br/&gt;x = L1_iter.__next__()&lt;br/&gt;print(x, end=&lt;span class=&quot;hljs-string&quot;&gt;&quot;  &quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; StopIteration:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是实际上,使用for语句在运行速度可能会更快一点. 因为迭代器在Python中是通过C语言实现的. 而while的方式则是以Python虚拟机运行Python字节码的方式来执行的.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟...你大爷永远是你大爷. C语言永远是你大爷...&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表解析式&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表解析式或者又叫列表生成式,这个东西就比较简单了. 举个简单的例子,比如我们要定义一个1-9的列表. 我们可以写&lt;code&gt;L=[1,2,3,4,5,6,78,9]&lt;/code&gt; 同样我们也可以写&lt;code&gt;L=[x for x in range(10)]&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再举一个简单的例子,我们现在已经有一个列表&lt;code&gt;L2=[1,2,3,4,5]&lt;/code&gt; 我们要得到每个数的平方的列表. 那么我们有两种做法:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;L2 = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(len(L2)):&lt;br/&gt;L2[i] = L2[i]*L2[i]&lt;br/&gt;L3 = [x*x &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; L2]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然从代码简洁渡上来说 第二种写法更胜一筹. 而且它的运算速度相对来说会更快一点(往往速度会快一倍.P.S.书上的原话,我没有验证...). 因为列表解析式式通过生成器来构造的,他们的迭代是python解释器内部以C语言的速度来运行的. 特别是对于一些较大的数据集合,列表解析式的性能优点更加突出.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表解析式还有一些高端的玩法. 比如可以与if语句配合使用:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;L4 = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]&lt;p&gt;L5 = [x &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; L4 &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x % &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以使用for语句嵌套;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;L6=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]&lt;br/&gt;L7=[&lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'d'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'e'&lt;/span&gt;]&lt;p&gt;L8=[str(x)+y &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; L6 &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; L7]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者可以写的更长&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;L9=[(x,y) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x % &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; ==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; y &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; y %&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; ==&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个更复杂的例子&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;M = [&lt;br/&gt;[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],&lt;br/&gt;[&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;],&lt;br/&gt;[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;print(M[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])&lt;br/&gt;print(M[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])&lt;br/&gt;print([row[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; M])&lt;br/&gt;print([M[row][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)])&lt;br/&gt;print([M[i][i] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(len(M))])&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的,我们可以通过for语句来实现上述的功能. 但是列表解析式想对而言会更加简洁.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外map函数比等效的for循环要更快,而列表解析式往往会比map调用还要快一点.&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;python3中新的可迭代对象&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;python3相比如python2.x来说,它更强调迭代. 除了文件,字典这样的内置类型相关的迭代外. 字典方法keys,values都在python3中返回可迭代对象. 就像map,range,zip方法一样. 它返回的并不是一个列表. 虽然从速度和内存占用上更有优势,但是有时候我们不得不使用list()方法使其一次性计算所有的结果.&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;range迭代器&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;]: R=range(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;]: R&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;]: range(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;]: I = iter(R)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;]: next(I)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;]: R[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;]: len(R)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;]: next(I)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range的话,仅支持迭代,len()和索引. 不支持其他的序列操作. 所以如果需要更多的列表工具的话,使用list()...&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;map,zip和filter迭代器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和range类似, map,zip和filter在python3.0中也转变成了迭代器以节约内存空间. 但是它们和range又不一样.(确切来说是range和它们不一样) 它们不能在它们的结果上拥有在那些结果中保持不同位置的多个迭代器.(第四版书上原话,看看这叫人话吗...)&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译一下就是,map,zip和filter返回的都是正经迭代器,不支持len()和索引. 以map为例做个对比.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;]: map_abs = map(abs,[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;])&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;]: M1 = iter(map_abs)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;]: M2=iter(map_abs)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;]: next(M1)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;]: next(M2)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而range不是正经的迭代器. 它支持在其结果上创建多个活跃的迭代器.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;]: R=range(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;]: r1 = iter(R)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt;]: r2=iter(R)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;]: next(r1)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;]: next(r2)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;字典中的迭代器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的,python3中字典的keys,values和items方法返回的都是可迭代对象.而非列表.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;12&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;18&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;]: D = dict(a=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,b=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,c=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;]: D&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;]: {&lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;]: K = D.keys()&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;]: K&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;]: dict_keys([&lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;])&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;34&lt;/span&gt;]: next(K)&lt;br/&gt;---------------------------------------------------------------------------&lt;br/&gt;TypeError                                 Traceback (most recent call last)&lt;br/&gt;&amp;lt;ipython-input&lt;span class=&quot;hljs-number&quot;&gt;-34&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;-02&lt;/span&gt;c2ef8731e9&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;br/&gt;----&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; next(K)&lt;/p&gt;&lt;p&gt;TypeError: &lt;span class=&quot;hljs-string&quot;&gt;'dict_keys'&lt;/span&gt; object &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; an iterator&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt;]: i = iter(K)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;36&lt;/span&gt;]: next(i)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;36&lt;/span&gt;]: &lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;37&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; D.keys(): print(k,end=&lt;span class=&quot;hljs-string&quot;&gt;' '&lt;/span&gt;)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的,我们可以利用list()函数来显式的把他们变成列表. 另外,python3中的字典仍然有自己的迭代器. 它返回连续的见. 因此在遍历的时候,无需显式的调用keys().&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;38&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; D: print(key,end=&lt;span class=&quot;hljs-string&quot;&gt;' '&lt;/span&gt;)&lt;br/&gt;a b c&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生成器&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成器可以说是迭代器的一个子集. 有两种创建方法:&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;生成器函数: 编写常规的以def为关键字的函数,使用yield关键字返回结果. 在每个结果之间挂起和继续他们的状态.&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;生成器表达式: 类似前面所说的列表解析式.&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生成器函数关键字 yeild&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;状态挂起&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和返回一个值并且退出的常规函数不同,生成器函数自动在生成值得时刻挂起并继续函数的执行. 它在挂起时会保存包括整个本地作用域在内的所有状态. 在恢复执行时,本地变量信息依旧可用.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成器函数使用yeild语句来挂起函数并想调用者发送回一个值.之后挂起自己. 在恢复执行的时候,生成器函数会从它离开的地方继续执行.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;生成器函数的应用&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gensquares&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(num)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(num):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; i**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; gensquares(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;):&lt;br/&gt;print(i)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的,生成器其实也是实现了迭代器协议. 提供了内置的&lt;code&gt;__next__&lt;/code&gt;方法.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子如果我们要改写为普通函数的话,可以写成如下的样子.&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;buildsquares&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(num)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;res = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(num):&lt;br/&gt;res.append(i**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; buildsquares(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;):&lt;br/&gt;print(i)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去实现的功能都是一样的. 但是区别在于 生成器的方式产生的是一个惰性计算序列. 在调用时才进行计算得出下一个值. 而第二种常规函数的方式,是先计算得出所有结果返回一个列表. 从内存占用的角度来说,生成器函数的方式更优一点.&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生成器表达式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与列表解析式差不多. 生成器表达式用来构造一些逻辑相对简单的生成器. 比如&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;g = (x**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用时可以通过next()函数或者for循环进行调用.&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实战:改写map和zip函数&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;改写map函数&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;一年级版本:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func,*seqs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;res=[]&lt;br/&gt;print(list(zip(*seqs)))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; args &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; zip(*seqs):&lt;br/&gt;res.append(func(*args))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;二年级版本:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func,*seqs)&lt;/span&gt;:&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [func(*args) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; args &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; zip(*seqs)]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;三年级版本:&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;14&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func,*seqs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;res=[]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; args &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; zip(*seqs):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; func(*args)&lt;p&gt;print(list(mymap(abs,[&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;])))&lt;br/&gt;print(list(mymap(pow,[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;])))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;小学毕业班版本&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mymap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func,*seqs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (func(*args) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; args &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; zip(*seqs))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;改写zip函数&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;一年级版本&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;myzip&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*seqs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;seqs = [list(S) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; S &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; seqs]&lt;br/&gt;print(seqs)&lt;br/&gt;res = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; all(seqs):&lt;br/&gt;res.append(tuple(S.pop(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; S &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; seqs))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res&lt;p&gt;print(myzip(&lt;span class=&quot;hljs-string&quot;&gt;'abc'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xyz'&lt;/span&gt;))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.0546875&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;知识点: all()函数和any()函数. &lt;a href=&quot;https://docs.python.org/zh-cn/3.7/library/functions.html#all&quot;&gt;all()函数&lt;/a&gt;,如果可迭代对象中的所有元素都为True或者可迭代对象为None. 则返回True. &lt;a href=&quot;https://docs.python.org/zh-cn/3.7/library/functions.html#any&quot;&gt;any()函数&lt;/a&gt;,可迭代对象中的任一元素为True则返回True.,如果迭代器为空,则返回False.&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;二年级版本&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;myzip&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*seqs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;seqs = [list(S) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; S &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; seqs]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; all(seqs):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; tuple(S.pop(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; S &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; seqs)&lt;p&gt;print(list(myzip(&lt;span class=&quot;hljs-string&quot;&gt;'abc'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xyz'&lt;/span&gt;)))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
</description>
<pubDate>Fri, 13 Mar 2020 16:45:00 +0000</pubDate>
<dc:creator>不愿透露姓名的高杨</dc:creator>
<og:description>对python迭代器和生成器的进一步学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thecatcher/p/12490184.html</dc:identifier>
</item>
<item>
<title>数字电路基础那些事1——组合逻辑：从译码器到编码器 - 三点羊羽</title>
<link>http://www.cnblogs.com/Wilson-hhx/p/12490169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wilson-hhx/p/12490169.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;声明：本文部分&lt;strong&gt;内容&lt;/strong&gt;选自《数字电子技术基础系统方法》与 华中科技大学的《电子技术基础 数字部分》，笔者将其两者精华加上自身的理解整理成一篇文章，使知识点易于理解！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;           如有疏漏欢迎指出！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;译码器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 译码器定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;译码器是一种用以检测输入位（码）的特定组合是否存在，并以特定的输出电平来指示这种特定码的存在的数字电路。——《数字电子技术基础系统方法》&lt;/p&gt;
&lt;p&gt;译码器的功能是将具有特定含义的二进制码转换成对应的输出信号， 具有译码功能的逻辑电路称为译码器。——《电子技术基础 数字部分》华中科技大学&lt;/p&gt;
&lt;p&gt;洋羽的解释：我们把译码器看做一个转换器，他的任务就是把一个我们不想要的的信号格式转换成另外一种我们想要的信号格式（两种信号表示的信息是一样的，变得只有格式），从“译”字下手，就是将难得化成简单的（此处的简单是指对于我们当前需求的简单）。做一个可能不太恰当的比喻：就是将我们难以利用的数字码（但对于机器与电路来说传输较为简单）来转换成我们易于利用的数字码（对于机器和电路来说传输较为麻烦）。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 举例说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;理论说明例子1：BCD码——&amp;gt;十进制码&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313222725093-1910774192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 输入4位8421BCD码，转换成10个十进制数中的一个数所对应的输出（10选1译码器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313222934397-346635285.jpg&quot; alt=&quot;&quot; width=&quot;899&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;实例芯片：74HC138&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313220404635-1177699656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道3位2进制码可以表示8个十进制数，A0,A1,A2对应的就是三位二进制数，而输出的Y0~Y7就相当于8个十进制数，当哪个输出为0，就相当于哪个十进制数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;理论说明例子2：BCD码—7段译码器（举例说明）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313223644577-1502325030.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先我们得知道数码管的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313223823694-899572324.png&quot; alt=&quot;&quot;/&gt;数码管位号图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313224430050-1155719930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;数码管的本质就是LED，一个数码管里面有8个LED，分别对应为a,b,c,d,e,f,g,p&lt;/p&gt;
&lt;p&gt;当我们需要表示什么数字时，我们就点亮相应的LED，如我们需要表示9这个数字，我们直接点亮a,f,g,b,c,d这6盏LED即可表示为9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313224147126-119727180.png&quot; alt=&quot;&quot; width=&quot;70&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 厂家为了节省开发人员的时间，让我们不用总是去思考需要怎么点亮数码管，就设计出显示专用的译码器（把易于程序处理与信号传输的信号转换为我们所需要，利于我们开发的编码）所以开发出这款芯片，我们只要输入对应的BCD码，就可以转换成该如何点亮LED的信息码。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 实操：DATASHEET解读时间: TI CD54HC4511&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;芯片引脚图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313225316456-1805433625.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;逻辑门表示电路&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313225411635-288220502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真值表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313225627088-315908676.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三大扩展功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313225842346-1199740008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;功能3对应DATASHEET真值表中中倒数第二行英文&lt;/p&gt;
&lt;p&gt;译码器有时候可以用作复用器（详情看下一篇从复用器到解复用器）&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;编码器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 编码器的定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编码器接收若干输入中有一个有效电平，每个输入表示一个数，例如十进制数或者八进制数，并且把这个数转换成代码输出，如BCD码或二进制码。  ——《数字电子技术基础系统方法》&lt;/p&gt;
&lt;p&gt;数字系统中存储或处理的信息，常常是用二进制码表示的。用一个二进制代码表示特定含义的信息称为编码。具有编码功能的逻辑电路称为编码器。  ——《电子技术基础数字部分》华中科技大学&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;洋羽的理解：&lt;/strong&gt;把我们熟悉的符号或者数字转换成一种代码形式的电路我们称为编码器（即译码器的相反作用）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;编码器的分类：普通编码器和优先编码器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）普通编码器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;普通编码器任何时刻只允许一个输入信号有效，否则将产生错误输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200314003034902-1791451000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）优先编码器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通编码器的升级版：&lt;/strong&gt;按照规定的优先级设计电路&lt;/p&gt;
&lt;p&gt;在实际应用中， 经常会遇到两个以上的输入同时为有效信号的情况。因此，必须根据轻重缓急，事先规定好这些输入编码的先后次序，即优先级别。&lt;/p&gt;
&lt;p class=&quot;op_exactqa_s_abstract c-gap-top-small&quot;&gt;&lt;span&gt;&lt;span class=&quot;c-gap-right-small&quot;&gt;&lt;strong&gt;优先编码器允许同时在几个输入端有输入信号&lt;/strong&gt;，编码器按输入信号排定的优先顺序，只对同时输入的几个信号中优先权最高的一个进行编码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;op_exactqa_s_abstract c-gap-top-small&quot;&gt;&lt;strong&gt;&lt;span class=&quot;c-gap-right-small&quot;&gt;举例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200314000854872-254172306.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200314000909020-2054365224.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 结合生活应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200314002904368-731561972.png&quot; alt=&quot;&quot;/&gt;                          &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200314002919946-231542430.png&quot; alt=&quot;&quot; width=&quot;397&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;





&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;小彩蛋：数字键盘功能演示（证明我们使用的键盘不是简单的、只用一个优先编码器就做出来的数字键盘）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以笔者的笔记本电脑来作为实例测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1618094/202003/1618094-20200313232651113-135824953.jpg&quot; alt=&quot;&quot; width=&quot;157&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;












&lt;p&gt;&lt;strong&gt;测试步骤1：&lt;/strong&gt;测试同时按下123键时系统的输出&lt;/p&gt;
&lt;p&gt;123 213 312 312 312 213 321 132 132 231 321 312 132  321 321 321  321 132 132 312 321 3211 321 312 321 321 321 312 312 123 123 312 321 231 321 123 132 123 132 321 132 321 123 312 123 321&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 可以得出结论：人手指误差不可避免，所以每次的输出不一定一样，但是不会出现缺失一个数字的情况，即按键每次按下都能得到响应&lt;/strong&gt;键盘开发人员设定的扫描频率很快&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试步骤2：&lt;/strong&gt;测试同一时间按下12键&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;211111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;1222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验结论：按下去由于人手指的误差，不可能同时按下，所以最后只能有一个信号是有效的。所以我们可以看到最后只有一个信号是持续输出的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试步骤3：&lt;/strong&gt;按下1之后，在不松开1的情况下按下并长按2（测试5次）&lt;/p&gt;
&lt;p&gt;111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;1111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;12222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;1111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;11111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试步骤4：&lt;/strong&gt;按下2之后，在不松开2的情况下按下1并长按1（测试5次）&lt;/p&gt;
&lt;p&gt;22222222222222111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;2111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;222222211111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;22222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试步骤5：&lt;/strong&gt;长按1不松开，轻轻按一次2并保持1不松开（测试5次）&lt;/p&gt;
&lt;p&gt;111111111111111111111111111111111111111111111111111112&lt;/p&gt;
&lt;p&gt;1111111111111111111111112&lt;/p&gt;
&lt;p&gt;111111111111111111111111111111111111111111111111111111111111111111111111111111112&lt;/p&gt;
&lt;p&gt;11111111111111111111111111111111111111111111112&lt;/p&gt;
&lt;p&gt;111111111111111111111111111111112&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据测试步骤3、4我们可以得出结论：只要键盘检测到新的输入，则旧的输入虽然没有变，但是内部已经将旧的作废并优先输出新的输入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据测试步骤5，我们进一步证实结论：一旦数字键盘检测到新的输入，旧输入优先级下降，转为新的输入，虽然新的输入信号已经停止输入，但是旧的输入信号仍为低优先级状态，系统等待新的输入来作为高优先级信号&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Mar 2020 16:40:00 +0000</pubDate>
<dc:creator>三点羊羽</dc:creator>
<og:description>声明：本文部分内容选自《数字电子技术基础系统方法》与 华中科技大学的《电子技术基础 数字部分》，笔者将其两者精华加上自身的理解整理成一篇文章，使知识点易于理解！ 如有疏漏欢迎指出！ 译码器 1. 译码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wilson-hhx/p/12490169.html</dc:identifier>
</item>
<item>
<title>LinkedHashMap源码解读 - 当我遇上你csy</title>
<link>http://www.cnblogs.com/idea360/p/12490131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idea360/p/12490131.html</guid>
<description>&lt;p&gt;还是从面试中来，到面试中去。面试官在面试 Redis 的时候经常会问到，Redis 的 LRU 是如何实现的？如果让你实现 LRU 算法，你会怎么实现呢？除了用现有的结构 LinkedHashMap 实现，你可以自己实现一个吗？跳跃表、小顶堆行不行...&lt;/p&gt;
&lt;p&gt;阅读这篇文章前建议大家先熟悉下&lt;a href=&quot;https://mp.weixin.qq.com/s/ugBm-koApBRepbSQ2kiV2A&quot;&gt;Java 面试必问之 Hashmap 底层实现原理(JDK1.8)&lt;/a&gt;。LinkedHashMap 基于 HashMap 实现，其中很多方法都是在 HashMap 上进行了增强。&lt;/p&gt;

&lt;p&gt;实现代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LRUCache&amp;lt;K, V&amp;gt; extends LinkedHashMap&amp;lt;K, V&amp;gt; {

    private int cacheSize;

    public LRUCache(int cacheSize) {
        super(16, (float) 0.75, true);
        this.cacheSize = cacheSize;
    }

    /**
     * 判断节点数是否超限
     * @param eldest
     * @return 超限返回 true，否则返回 false
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry&amp;lt;K, V&amp;gt; eldest) {
        return size() &amp;gt; cacheSize;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 输出结果:
 * 17:44:31.635 [main] INFO com.demo.cache.Test - 所有的缓存:{key0=0, key1=1, key2=2}
 * 17:44:31.641 [main] INFO com.demo.cache.Test - 访问key0后的缓存:{key1=1, key2=2, key0=0}
 * 17:44:31.642 [main] INFO com.demo.cache.Test - 测试热点缓存:{key2=2, key0=0, key3=3}
 */
@Slf4j
public class Test {

    public static void main(String[] args) {

        LRUCache&amp;lt;Object, Object&amp;gt; lruCache = new LRUCache&amp;lt;&amp;gt;(3);

        for (int i=0; i&amp;lt;3; i++) {
            lruCache.put(&quot;key&quot; + i, i);
        }

        log.info(&quot;所有的缓存:{}&quot;, lruCache);

        // 理论上刚访问过key0，key0应该放在链表尾部，代表最近使用，删除策略从头部删除
        lruCache.get(&quot;key0&quot;);
        log.info(&quot;访问key0后的缓存:{}&quot;, lruCache);

        // 新插入缓存，超过了缓存阈值，理论上会删除链表头部元素，并将新缓存放置在链表尾部。
        lruCache.put(&quot;key3&quot;, 3);
        log.info(&quot;测试热点缓存:{}&quot;, lruCache);

    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Redis 中 LRU 的实现暂时没有研究，大家可以看下别人的分析，这里只做 java 部分的分析。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;笔者的代码环境是 OpenJDK8&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LinkedHashMap 底层依旧基于 HashMap 实现，同时增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。&lt;/p&gt;
&lt;h2 id=&quot;基础节点-entry&quot;&gt;3.1 基础节点 Entry&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
        Entry&amp;lt;K,V&amp;gt; before, after;
        // 构造方法直接复用Hashmap的构造方法
        Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, value, next);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基础节点的继承自 HashMap 的 Node 节点.&lt;/p&gt;
&lt;h2 id=&quot;新增节点&quot;&gt;3.2 新增节点&lt;/h2&gt;
&lt;p&gt;查看源码方法列表可以看出，源码中没有 put()方法，那一定是继承父类 Hashmap 的 put()方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/idea360/oss/raw/master/images/java8-linkedhashmap-method-list.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们再看下链表的插入逻辑&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    // HashMap方法
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    // HashMap方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        // 判断数组是否为空，长度是否为0，是则进行扩容数组初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 通过hash算法找到数组下标得到数组元素，为空则新建
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
            // 找到数组元素，hash相等同时key相等，则直接覆盖
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            // 该数组元素在链表长度&amp;gt;8后形成红黑树结构的对象,p为树结构已存在的对象
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                // 该数组元素hash相等，key不等，同时链表长度&amp;lt;8.进行遍历寻找元素，有就覆盖无则新建
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        // 新建链表中数据元素，尾插法
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            // 链表长度&amp;gt;=8 结构转为 红黑树
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            // 新值覆盖旧值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                // onlyIfAbsent默认false
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                // 需要子类实现
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 判断是否需要扩容
        if (++size &amp;gt; threshold)
            resize();
        // 需要子类实现，默认是true
        afterNodeInsertion(evict);
        return null;
    }

    // 覆盖HashMap方法,新创建Entry节点的元素放在链表尾部(需要新建节点的走这里，包括链表和红黑树)
    Node&amp;lt;K,V&amp;gt; newNode(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; e) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
            new LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);
        linkNodeLast(p);
        return p;
    }

    // 将元素插入到双端链表尾部
    private void linkNodeLast(LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; last = tail;
        tail = p;
        // 数组和链表都为空，首尾指针指向当前节点
        if (last == null)
            head = p;
        else {
            // 移动尾指针指向新节点
            p.before = last;
            last.after = p;
        }
    }


    // 将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)
    void afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { // move node to last
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; last;
        if (accessOrder &amp;amp;&amp;amp; (last = tail) != e) {
            LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
                (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;)e, b = p.before, a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                b.after = a;
            if (a != null)
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }

    // 根据条件判断是否移除最近最少被访问的节点
    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; first;
        if (evict &amp;amp;&amp;amp; (first = head) != null &amp;amp;&amp;amp; removeEldestEntry(first)) {
            K key = first.key;
            // 删除头节点
            removeNode(hash(key), key, null, false, true);
        }
    }

    // 覆盖此方法可实现不同的策略缓存,
    protected boolean removeEldestEntry(Map.Entry&amp;lt;K,V&amp;gt; eldest) {
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本插入逻辑和 HashMap 是相同的，我把需要子类覆写的地方用不同颜色表示出来了，具体见下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/idea360/oss/raw/master/images/java8-linkedhashmap-put.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除节点&quot;&gt;3.3 删除节点&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    // HashMap实现
    public V remove(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    // HashMap实现
    final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
            Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                if (p instanceof TreeNode)
                    node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
                else {
                    do {
                        if (e.hash == hash &amp;amp;&amp;amp;
                            ((k = e.key) == key ||
                             (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;amp;&amp;amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                // 默认空实现，子类中实现删除回调
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }

    // LinkedHashMap中实现。删除节点后的链表维护
    void afterNodeRemoval(Node&amp;lt;K,V&amp;gt; e) { // unlink
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
            (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;)e, b = p.before, a = p.after;
        p.before = p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a == null)
            tail = b;
        else
            a.before = b;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除节点的逻辑比较简单，和 HashMap 基本一样，删除节点后重新维护前后节点指针即可。&lt;/p&gt;
&lt;h2 id=&quot;获取节点最近使用节点移动至尾节点&quot;&gt;3.4 获取节点(最近使用节点移动至尾节点)&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 重写HashMap方法
    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;

        // 如果accessOrder=true,则获取节点元素后将该节点移动至链表尾部(删除旧节点从头部删除)
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    }

    // LinkedHashMap 中覆写。将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)
    // 将被访问节点移动到链表最后(覆盖旧节点value的走这里，包括链表和红黑树)
    void afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { // move node to last
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; last;
        if (accessOrder &amp;amp;&amp;amp; (last = tail) != e) {
            LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
                (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;)e, b = p.before, a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                // 移除节点e,并重新维护前后节点链表指针
                b.after = a;
            if (a != null)
                // 移除节点e,并重新维护前后节点链表指针
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                // 将节点e移动到链表尾部
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看到，每次调用 get 方法时，如果开启了 accessOrder，则会将当前元素移动到链表尾部。&lt;/p&gt;

&lt;p&gt;本来源码加配图学习会更加容易明白，奈何绘图功底有限。大家有什么比较好用的工具可以推荐一下。到此，本篇文章就写完了，感谢大家的阅读！如果您觉得对您有帮助，请关注公众号【当我遇上你】。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Mar 2020 16:27:00 +0000</pubDate>
<dc:creator>当我遇上你csy</dc:creator>
<og:description>1. 前言 还是从面试中来，到面试中去。面试官在面试 Redis 的时候经常会问到，Redis 的 LRU 是如何实现的？如果让你实现 LRU 算法，你会怎么实现呢？除了用现有的结构 LinkedHa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/idea360/p/12490131.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（三点五）之决策树 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12490064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12490064.html</guid>
<description>&lt;h2 id=&quot;数据挖掘入门系列教程三点五之决策树&quot;&gt;数据挖掘入门系列教程（三点五）之决策树&lt;/h2&gt;
&lt;p&gt;本来还是想像以前一样，继续学习《 Python数据挖掘入门与实践 》的第三章“决策树”，但是这本书上来就直接给我怼了一大串代码，对于&lt;code&gt;决策树&lt;/code&gt;基本上没有什么介绍，可直接把我给弄懵逼了，主要我只听过决策树还没有认真的了解过它。&lt;/p&gt;
&lt;p&gt;这一章节主要是对决策树做一个介绍，在下一个章节，将使用决策树来进行预测分类 。&lt;/p&gt;
&lt;h3 id=&quot;决策树decision-tree介绍&quot;&gt;决策树（Decision Tree）介绍&lt;/h3&gt;
&lt;p&gt;Decision Tree是一类较为常见的机器学习的方法。它既可以作为分类算法，也可以作为回归算法。&lt;/p&gt;
&lt;p&gt;如何来介绍决策树，这里举一个例子：在大学，你找女朋友的时候，心目中顺序应该是这样的（仅仅是举一个例子）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Q：性别要求？&lt;/li&gt;
&lt;li&gt;A：不是女的不要。&lt;/li&gt;
&lt;li&gt;Q：年龄要求？&lt;/li&gt;
&lt;li&gt;A：大于我3岁的不要&lt;/li&gt;
&lt;li&gt;Q：专业要求？&lt;/li&gt;
&lt;li&gt;A：非CS不要&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了更好的表示上面的这一些问题，我们可以将其画成一张树状图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314013009046-254728980.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的这棵树就是我们找女朋友的决策过程，圆角矩形代表了判断条件，椭圆形代表了决策结果。通过性别，年龄，专业这几个属性，最终我们得出了最终的决策。而这棵树也就被称之为决策树。&lt;/p&gt;
&lt;p&gt;大家通过上图会发现有3个东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根节点：包含样本的全集&lt;/li&gt;
&lt;li&gt;内部节点：对应特征属性测试&lt;/li&gt;
&lt;li&gt;叶节点：代表决策的结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一棵决策树中，包含了一个&lt;code&gt;根节点&lt;/code&gt;，多个&lt;code&gt;内部节点（判断条件）&lt;/code&gt; 和若干个&lt;code&gt;叶子节点&lt;/code&gt;。先说叶子节点，在决策树中，叶子节点对应了决策结果，决策结果可以有多种类型（图中是yes和no，也可以为1，2，3）。内部节点和根节点对应的都是&lt;code&gt;属性测试&lt;/code&gt;，只不过先后顺序不同。&lt;/p&gt;
&lt;p&gt;总的来说，决策树体现的是一种“分而治之”的思想，&lt;/p&gt;
&lt;p&gt;那么这里就有一个问题，谁来当根节点？谁又来当中间的节点？先后顺序又是怎样的？（这里先不说算法流程，从简单开始说起，然后再说算法流程）&lt;/p&gt;
&lt;h3 id=&quot;结点的选择&quot;&gt;结点的选择&lt;/h3&gt;
&lt;p&gt;首先我们需要明白根节点和中间节点是不同的，一个是统领全局的开始包含所有的样本。一个是负责局部的决策，并且随着决策树的不断的进行决策，所包含的样本逐渐属于同一个类别，即节点的“纯度”越来越高。&lt;/p&gt;
&lt;p&gt;那么，我们如何来寻找合适根节点（也就是属性）呢？靠感觉？靠感觉当然不行，我们需要一个具体的数值来决定，很幸运，香农帮助我们做到了。&lt;/p&gt;
&lt;p&gt;“信息熵”（information entropy）：可以度量样本集合中的“纯度”。 在信息世界，熵越高，表示蕴含越多的信息，熵越低，则信息越少。 而根节点需要包含所以的样本，则&lt;code&gt;根结点的熵最大&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;信息熵information-entropy&quot;&gt;信息熵（Information Entropy）&lt;/h4&gt;
&lt;p&gt;设样本集合为&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;，第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;类样本所占比例为&lt;span class=&quot;math inline&quot;&gt;\(p_k(k = 1,2,3,……n)\)&lt;/span&gt;，则集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的信息熵为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Ent(D) = - \sum_{k=1}^{n}p_klog_2p_k\\ Ent(D)越大，则D的纯度越小，也就是说集合D越混乱。 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在，我们已经知道一个集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;中的信息熵是多少，那么我们如何来进行划分呢？首先，我们需要明确一个划分的标准（也就是目标），我们当然希望划分之后，划分之后的集合的熵越来越小，也就是划分后的集合越来越纯，这里我们引入信息增益这个概念。&lt;/p&gt;
&lt;h4 id=&quot;信息增益information-gain&quot;&gt;信息增益（information gain）&lt;/h4&gt;
&lt;p&gt;下面是西瓜书中对信息增益的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;假设离散属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;个可能的取值&lt;span class=&quot;math inline&quot;&gt;\(\{a^1,a^2,a^3……a^V\}\)&lt;/span&gt;，若以属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;对样本进行划分，则有V个分支，其中第&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;个分支包含了&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;中在属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;上取值为&lt;span class=&quot;math inline&quot;&gt;\(a^v\)&lt;/span&gt;的样本，记为&lt;span class=&quot;math inline&quot;&gt;\(D^v\)&lt;/span&gt;。我们可以计算出&lt;span class=&quot;math inline&quot;&gt;\(D^v\)&lt;/span&gt;的信息熵，然后考虑到不同分支结点的样本数不同，给分支结点赋予权重&lt;span class=&quot;math inline&quot;&gt;\(\frac{|D^v|}{|D|}\)&lt;/span&gt;，样本数愈多，则影响力越大，则可以计算出属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;对样本集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;进行划分的“信息增益”：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gain(D,a) = Ent(D) - \sum_{v=1}^V\frac{|D^v|}{|D|}Ent(D^v) \]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说，信息增益越大，则代表划分后的集合越“纯”，也就是说使用&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;属性来划分的效果最好，那么我们就可以使用&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;属性来进行划分。&lt;em&gt;ID3算法&lt;/em&gt;就是使用信息增益来作为标准划分属性的。&lt;/p&gt;
&lt;h3 id=&quot;决策树生成算法流程&quot;&gt;决策树生成算法流程&lt;/h3&gt;
&lt;p&gt;下面是来自《西瓜书》的决策树生成算法流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000242202-1589752613.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;决策树生成是一个递归的过程，在下面3中情况中，递归会返回：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前结点包含的样本全属于同一类别，无需划分&lt;/li&gt;
&lt;li&gt;当前属性集为空，或是所有样本在所有属性上取值相同，无法划分&lt;/li&gt;
&lt;li&gt;当前结点包含的样本集合为空，不能划分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;算法可能不是那么的形象好理解，下面将以实际的例子来展示。&lt;/p&gt;
&lt;p&gt;在最上面上面的找女朋友的例子并不是特别的好，属性太少。这里以西瓜书中的🍉来进行举例。这个属性还是挺多的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000242859-1520054524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，属性的集合是&lt;code&gt;{色泽，根蒂，敲声，纹理，脐部，触感}&lt;/code&gt;（目前不考虑编号这个属性），分类的集合是&lt;code&gt;{是，否}&lt;/code&gt;，一共有17个样本。&lt;/p&gt;
&lt;p&gt;首先让我们来及计算集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的熵值。在集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;中，好瓜（是）占&lt;span class=&quot;math inline&quot;&gt;\(p_1 = \frac{8}{17}\)&lt;/span&gt;，坏瓜（否）占&lt;span class=&quot;math inline&quot;&gt;\(p_1 = \frac{9}{17}\)&lt;/span&gt;，所以集合&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;的熵为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Ent(D) = -\sum_{k=1}^2p_klog_2p_k = -(\frac{8}{17}log_2\frac{8}{17} + \frac{9}{17}log_2\frac{9}{17}) = 0.998 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以色泽作为划分标准，可以得到3个子集：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ D^1(色泽=青绿) = \{1,4,6,10,13,17\} \\ 在D^1中p_1 = \frac{3}{6}，p_2=\frac{3}{6}\\ D^2(色泽=乌黑) = \{2,3,7,8,9,15\}\\ 在D^2中p_1 = \frac{4}{6}，p_2=\frac{2}{6}\\ D^3(色泽=浅白) = \{5,11,12,14,16\}\\ 在D^2中p_1 = \frac{1}{5}，p_2=\frac{4}{5} \\ 其中集合中的数字代表表格中的编号 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以获得&lt;span class=&quot;math inline&quot;&gt;\(D^1,D^2,D^3\)&lt;/span&gt;的信息熵：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Ent(D^1)=-(\frac{3}{6}log_2\frac{3}{6}+\frac{3}{6}log_2\frac{3}{6}) = 1.00 \\ Ent(D^2)=-(\frac{4}{6}log_2\frac{4}{6}+\frac{2}{6}log_2\frac{2}{6}) = 0.918 \\ Ent(D^3)=-(\frac{1}{5}log_2\frac{1}{5}+\frac{4}{5}log_2\frac{4}{5}) = 0.722 \\ \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;code&gt;色泽&lt;/code&gt;的信息增益为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{aligned} Gain(D，色泽) &amp;amp;= Ent(D) - \sum_{v=1}^3\frac{|D^v|}{|D|}Ent(D^v)\\ &amp;amp;= 0.99 - （\frac{6}{17}\times 1.00 + \frac{6}{17}\times0.918 +\frac{5}{17}\times0.722） \\ &amp;amp;= 0.109 \end{aligned} \end{equation} \]&lt;/span&gt;&lt;br/&gt;同理可以得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{split} &amp;amp; Gain(D，根蒂) = 0.143；Gain(D，敲声) = 0.141；\\ &amp;amp; Gain(D，纹理) = 0.381；Gain(D，脐部) = 0.289； \\ &amp;amp; Gain(D，触感) = 0.006；Gain(D，色泽)=0.109； \end{split} \end{equation} \]&lt;/span&gt;&lt;br/&gt;通过计算可以得到，纹理的信息增益最大，因此他被选为划分的属性如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000243315-357191223.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后以纹理是“清晰为例”，该集合&lt;span class=&quot;math inline&quot;&gt;\(D^1=\{1,2,3,4,5,6,8,10,15\}\)&lt;/span&gt;，可用的属性集合为{ 色泽，根蒂，敲声，脐部， 触感}。因此，基于&lt;span class=&quot;math inline&quot;&gt;\(D^1\)&lt;/span&gt;又可以计算出各个属性的信息增益：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{split} &amp;amp; Gain(D^1，色泽) = 0.043；Gain(D^1，根蒂) = 0.458；\\ &amp;amp;Gain(D^1，敲声) = 0.331； Gain(D^1，触感) = 0.458；\\ &amp;amp;Gain(D^1，脐部)=0.458； \end{split} \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此我们可以在“根蒂”，“触感”，“脐部”中任意选择其中一个作为划分属性。最终得到以下的决策树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000243775-899549420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的这些步骤，我们就得到了一颗关于西瓜的好坏的决策树。&lt;em&gt;ID3&lt;/em&gt;算法就是用&lt;em&gt;信息增益&lt;/em&gt;作为划分标准。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的例子来自西瓜书，以及计算的结果也来自西瓜书。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;增益率gain-ratio&quot;&gt;增益率（Gain Ratio）&lt;/h3&gt;
&lt;p&gt;在这里有一个问题，&lt;span class=&quot;math inline&quot;&gt;\(Gain(D，属性)\)&lt;/span&gt;越大，就一定能够作为划分标准吗？假如它是一个无用的属性呢？比如上图中&lt;code&gt;编号&lt;/code&gt;这个属性，如果在上面我们选择编号作为根节点，那么第一次划分就能够得到17个集合，每一个集合只有1个样本，&lt;span class=&quot;math inline&quot;&gt;\(Gain(D，编号)\)&lt;/span&gt;必定能够达到最大值。但是我们知道，编号这个属性在这里是毫无作用的。如果将这个问题进行泛化，如果一个属性在&lt;code&gt;分类&lt;/code&gt;中起到的作用给很小（也就是它对分类的影响很小），那么我们应该怎么考虑呢？&lt;/p&gt;
&lt;p&gt;这里我们可以使用&lt;code&gt;增益率&lt;/code&gt;来作为划分的标准，定义如下&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{split} &amp;amp;Gain\_ratio(D,a) = \frac{Gain(D,a)}{IV(a)} \\ &amp;amp;其中\\ &amp;amp;IV(a) = -\sum_{v=1}^V\frac{D^v}{D}log_2\frac{D^v}{D} \end{split} \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(IV(a)\)&lt;/span&gt;称之为属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;的&lt;code&gt;固有值&lt;/code&gt;(intrinsic value)，属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;的可能取值越多（划分的&lt;span class=&quot;math inline&quot;&gt;\(D^v\)&lt;/span&gt;的集合越多），&lt;span class=&quot;math inline&quot;&gt;\(IV(a)\)&lt;/span&gt;就会越大。若像编号一样进行划分（每一个划分的集合中只有一个样本），随着编号的增多，&lt;span class=&quot;math inline&quot;&gt;\(IV(a)\)&lt;/span&gt;的取值如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000244153-1757345148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中著名的&lt;em&gt;C4.5&lt;/em&gt;算法就是使用&lt;code&gt;增益率&lt;/code&gt;来划分属性。&lt;/p&gt;
&lt;p&gt;除了这种解决方案，还有一种解决方法，&lt;code&gt;基尼指数&lt;/code&gt;作为划分标准，&lt;code&gt;CART&lt;/code&gt;决策树使用这种方法。&lt;/p&gt;
&lt;h3 id=&quot;基尼指数gini-index&quot;&gt;基尼指数（Gini Index）&lt;/h3&gt;
&lt;p&gt;前面我们使用信息熵来表示集合的纯度，这里我们使用&lt;code&gt;基尼值&lt;/code&gt;来表示：&lt;/p&gt;
&lt;p&gt;设样本集合为&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;，第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;类样本所占比例为&lt;span class=&quot;math inline&quot;&gt;\(p_k(k = 1,2,3,……n)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{aligned} Gini(D) &amp;amp;= \sum_{k=1}^{|n|}\sum_{k'\neq k}p_kp_{k'}\\ &amp;amp;=1 - \sum_{k=1}^{|n|}p_k^2 \end{aligned} \end{equation} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Gini(D)\)&lt;/span&gt; 反映了从数据集中随机抽取两个样本，其类别标记不一致的概率。因此， $Gini(D) $越大，则数据集越复杂，纯度越低。&lt;/p&gt;
&lt;p&gt;同样，属性&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;的基尼指数定义为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gini\_index(D,a) = \sum_{v=1}^V\frac{D^v}{D}Gini({D^v}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此，在我们选择合适的属性进行划分的时候，选择划分后基尼指数较小的属性作为划分标准即可。&lt;/p&gt;
&lt;p&gt;这个时候我们再来看一看这幅图，应该就看的懂了吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000244669-1664760956.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;剪枝pruning处理&quot;&gt;剪枝（pruning）处理&lt;/h3&gt;
&lt;p&gt;首先，我们先说一下剪枝的目的——防止“过拟合”。在决策树的学习过程中，为了保证正确性，会不断的进行划分，这样可能会导致对于训练样本能够达到一个很好的准确性，但是对于测试集可能就不是很好了，这样的模型不具备泛化性。下面来举一个例子：&lt;/p&gt;
&lt;p&gt;我们有如下的数据集：&lt;/p&gt;
&lt;p&gt;坐标轴的上的每一个点代表一个样本，有&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;两种属性，其中，蓝色的点代表类0，橙色的点代表类1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000245047-416290476.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们使用决策树进行训练后，模型对于数据的识别区域如下，在粉红色区域，其认为里面的点为类0，蓝色的区域为类1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000245405-727696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可能发现一个问题，那就是这个区域划分的太&lt;strong&gt;“细致”&lt;/strong&gt;了。因为数据是有噪音(noise)的，这样划分明显是不合理的。这里大家可以看一看决策树的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xiaohuiduan/p/imgs/tree%20(1).png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何来缓解这种问题呢？其中有一种方法就是去掉一些分支（剪枝）来降低过拟合的风险。&lt;/p&gt;
&lt;p&gt;剪枝有两种方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预剪枝（prepruning）&lt;/li&gt;
&lt;li&gt;后剪枝（post-pruning）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;预剪枝&quot;&gt;预剪枝&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;预剪枝是指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用通俗的话来说，就是如果进行划分能够带来更好的结果就进行划分，否则不进行划分。首先，我们定义一个训练集和一个验证集如下：（西瓜书中间的例子）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000246040-336461108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面一部分是训练集，下面一部分是测试集。然后让我们来对&lt;strong&gt;训练集（记住是训练集）&lt;/strong&gt;进行划分，划分的规则与上面的一样。&lt;/p&gt;
&lt;p&gt;下面的这幅图是&lt;strong&gt;未剪枝&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000246636-2082826910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，剪枝是如何进行的呢？&lt;/p&gt;
&lt;p&gt;首先，我们先判断“脐部”，如果我们不对“脐部”进行划分，也就是说这棵决策树是这样的：&lt;/p&gt;
&lt;p&gt;只有一个好瓜的判断结果（根据上面的算法流程图，node节点直接就是叶子节点，其类别由样本中最多的决定【这里既可以是好瓜也可以是坏瓜，因为数量一样】）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000247009-83764515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样下来，也就是说无论你什么瓜过来我都判断它是好瓜。使用&lt;strong&gt;验证集&lt;/strong&gt;进行验证，验证的精准度为：&lt;span class=&quot;math inline&quot;&gt;\(\frac{3}{7} \times100\% = 42.9\%\)&lt;/span&gt;。如果进行划分呢？&lt;/p&gt;
&lt;p&gt;下图便是进行划分的情况，其中被红色圆圈框出来的部分表示验证正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000247346-1249828044.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果只划分“脐部”这个属性，我们可以通过其来划分好瓜和坏瓜，通过验证机去测试，我们可以得到划分后的准确性为：&lt;span class=&quot;math inline&quot;&gt;\(\frac{5}{7}\times100\%=71.4\% &amp;gt; 42.9\%\)&lt;/span&gt;，所以选择划分。&lt;/p&gt;
&lt;p&gt;下面便是进行&lt;strong&gt;前剪枝&lt;/strong&gt;后的划分结果,使用验证集进行验证，精度为&lt;span class=&quot;math inline&quot;&gt;\(71.4\%\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000247800-365528575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管该方案可以降低过拟合的风险，并在一定程度上能够降低算法的复杂度，但也会带来欠拟合的风险。因为会出现另外一种情况：有可能当前划分不能提升泛化能力，但是在此基础上的后续的划分也许可以导致性能显著提高。&lt;/p&gt;
&lt;h4 id=&quot;后剪枝&quot;&gt;后剪枝&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;后剪枝则是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后剪枝和前剪枝的不同在于后剪枝是在生成决策树后再进行剪枝。顺序是&lt;strong&gt;由下到上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们继续来看这幅图：&lt;/p&gt;
&lt;p&gt;通过验证集，我们易得到该决策树的识别率为&lt;span class=&quot;math inline&quot;&gt;\(42.9\%\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000248347-1307741236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们重新看一下数据吧，数据集和验证集如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000248827-1551109679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在让我们来进行剪枝吧！！首先先看节点⑥，节点6中包含编号为&lt;span class=&quot;math inline&quot;&gt;\(\{7（好瓜）,15（坏瓜）\}\)&lt;/span&gt;的训练样本，因此我们将节点⑥变成叶节点并标记为“好瓜（坏瓜也ok）”。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000249308-1510512591.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，验证集中序号为&lt;span class=&quot;math inline&quot;&gt;\(\{4，8，11，12\}\)&lt;/span&gt;验证正确，精度调高到&lt;span class=&quot;math inline&quot;&gt;\(\frac{4}{7} \times 100\%= 57.1\%\)&lt;/span&gt;，因此可以进行剪枝。&lt;/p&gt;
&lt;p&gt;考虑结点⑤，包含编号为&lt;span class=&quot;math inline&quot;&gt;\(\{6，7，15\}\)&lt;/span&gt;，将其变成叶节点（标记为“好瓜”），使用验证集去验证，其精度仍为&lt;span class=&quot;math inline&quot;&gt;\(57.1\%\)&lt;/span&gt;，没有提高，进行考虑。同理可得到下面的这副图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200314000249736-869994224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终，该决策树的精度为&lt;span class=&quot;math inline&quot;&gt;\(71.4\%\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比较预剪枝和后剪枝，后剪枝保留的分支更多，同时后剪枝的欠拟合的风险很小，泛化性能往往优于预剪枝决策树，但是显而易见，训练的时间要比预剪枝大得多。&lt;/p&gt;
&lt;h3 id=&quot;随机森林random-forest-rf&quot;&gt;随机森林（Random Forest | RF）&lt;/h3&gt;
&lt;p&gt;什么是随机森林呢？随机森林是一个包含多个决策树的分类器，由很多决策树构成，不同的决策树之间没有关联。当我们进行分类任务时，森林中的每一棵决策树&lt;strong&gt;都会&lt;/strong&gt;分别对样本进行判断和分类，每个决策树会得到一个自己的分类结果，决策树的分类结果中哪一个分类最多，那么随机森林就会把这个结果当做最终的结果。 （emm，少树服从多树）。好像很简单的样子，但是这里有一个问题，那就是随机森林中有多个决策树，那么，我们如何用已有的数据集去构建这么多的决策树呢？&lt;/p&gt;
&lt;p&gt;首先我们要明白，决策树是不同的，那么训练决策树所需要的数据也不同。那么具体该如何选择呢？既然是随机森林，那么它肯定是随机的！！它的随机有两层含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;样本随机：Bagging算法&lt;/li&gt;
&lt;li&gt;属性随机&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;样本随机&quot;&gt;样本随机&lt;/h4&gt;
&lt;p&gt;样本随机使用的是Bagging算法（Bootstrap aggregating，引导聚集算法）又称之为装袋算法。算法的流程如下：&lt;/p&gt;
&lt;p&gt;给定一个训练集大小为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的训练集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;，Bagging算法从中间随机的、有&lt;strong&gt;放回&lt;/strong&gt;的选出&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个大小为&lt;span class=&quot;math inline&quot;&gt;\(n'\)&lt;/span&gt;的子集&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;作为新的训练集。&lt;/p&gt;
&lt;p&gt;ps：通过以上这种取样得到的集合&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;中间可能会有重复的元素（因为是&lt;strong&gt;有放回&lt;/strong&gt;的抽取元素）&lt;/p&gt;
&lt;h4 id=&quot;属性随机&quot;&gt;属性随机&lt;/h4&gt;
&lt;p&gt;若样本有&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;个属性时，随机从这&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;个属性中选取出&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个属性（&lt;strong&gt;无放回&lt;/strong&gt;），满足条件&lt;span class=&quot;math inline&quot;&gt;\(m &amp;lt; M\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;ps：在这种情况下，&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个属性中是没有重复的属性的。&lt;/p&gt;
&lt;h4 id=&quot;随机森林的优缺点&quot;&gt;随机森林的优缺点&lt;/h4&gt;
&lt;p&gt;通过上面的样本随机和属性随机，我们就可以构建出很多棵不同的决策树了，然后组成一个森林，里面住着熊大和熊二，在一起快乐的生活。&lt;/p&gt;
&lt;p&gt;优缺点的整理来自&lt;a href=&quot;https://easyai.tech/ai-definition/random-forest/&quot;&gt;这里&lt;/a&gt;，基本上所有的文章都是这个说法，不同的在于文字的多少罢了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它可以出来很高维度（特征很多）的数据，并且不用降维，无需做特征选择&lt;/li&gt;
&lt;li&gt;它可以判断特征的重要程度&lt;/li&gt;
&lt;li&gt;可以判断出不同特征之间的相互影响&lt;/li&gt;
&lt;li&gt;不容易过拟合&lt;/li&gt;
&lt;li&gt;训练速度比较快，容易做成并行方法&lt;/li&gt;
&lt;li&gt;实现起来比较简单&lt;/li&gt;
&lt;li&gt;对于不平衡的数据集来说，它可以平衡误差。&lt;/li&gt;
&lt;li&gt;如果有很大一部分的特征遗失，仍可以维持准确度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合。&lt;/li&gt;
&lt;li&gt;对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;决策树的概念就暂时介绍到这里了，尽管内容有点多，但是还是挺好理解的，很类似于人类的思考方式。在下一篇的博客中，将使用scikit-learn工具包，基于决策树来对数据进行分类。决策树还有很多知识和算法，但是至少我们得掌握基本的概念。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;《西瓜书》决策树——第四章&lt;/li&gt;
&lt;li&gt;维基百科：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97&quot;&gt;随机森林&lt;/a&gt; &lt;a href=&quot;https://zh.wikipedia.org/wiki/Bagging%E7%AE%97%E6%B3%95&quot;&gt;Bagging算法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 13 Mar 2020 16:05:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>数据挖掘入门系列教程（三点五）之决策树 本来还是想像以前一样，继续学习《 Python数据挖掘入门与实践 》的第三章“决策树”，但是这本书上来就直接给我怼了一大串代码，对于 基本上没有什么介绍，可直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12490064.html</dc:identifier>
</item>
<item>
<title>django数据库分库migrate - rrh</title>
<link>http://www.cnblogs.com/yuruhao/p/12490034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuruhao/p/12490034.html</guid>
<description>&lt;p&gt;最近在研究微服务和分布式，设计到了数据库分库，记录一下&lt;br/&gt;首先，创建多个数据库，如果是已经生成的数据库，可以分库，这里我是新创建的项目，刚好可以用来尝试&lt;br/&gt;我是用docker创建的mysql数据库容器&lt;br/&gt;拉取docker镜像：&lt;br/&gt;&lt;code&gt;docker pull mysql:5.7&lt;/code&gt;&lt;br/&gt;创建容器：&lt;br/&gt;&lt;code&gt;docker run --name=mysql5.7 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7&lt;/code&gt;&lt;br/&gt;创建多个mysql容器之后，django配置好相应数据库，我这里分成了三个数据库，一个是默认，放django的user，group，permission，session之类的，另外一个是order和sale两个app的，这里我打算下一步微服务的时候再拆开，这里先记录分库的事情，数据库代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '192.168.1.112',
        'PORT': '13308',
        'NAME': 'default',
        'USER': 'root',
        'PASSWORD': '0123456789',
        'TEST': {
            'MIRROR': 'default'
        }
    },
    'sale': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '192.168.1.112',
        'PORT': '13306',
        'NAME': 'sale',
        'USER': 'root',
        'PASSWORD': '0123456789',
        'TEST': {
            'MIRROR': 'default'
        }
    },
    'order': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '192.168.1.112',
        'PORT': '13307',
        'NAME': 'order',
        'USER': 'root',
        'PASSWORD': '0123456789',
        'TEST': {
            'MIRROR': 'default'
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分库之后，在settings.py同级目录下，创建一个databaserouter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASE_MAPPING = {
    # example:
    # 'app_name':'database_name',
    'sale': 'sale',
    'order': 'order',
    'admin': 'default',
    'auth': 'default',
    'contenttypes': 'default',
    'sessions': 'default',
}


class DBAppsRouter(object):
    def db_for_read(self, model, **hints):
        &quot;&quot;&quot;&quot;Point all read operations to the specific database.&quot;&quot;&quot;
        if model._meta.app_label in DATABASE_MAPPING:
            return DATABASE_MAPPING[model._meta.app_label]
        return None

    def db_for_write(self, model, **hints):
        &quot;&quot;&quot;Point all write operations to the specific database.&quot;&quot;&quot;
        if model._meta.app_label in DATABASE_MAPPING:
            return DATABASE_MAPPING[model._meta.app_label]
        return None

    def allow_relation(self, obj1, obj2, **hints):
        &quot;&quot;&quot;Allow any relation between apps that use the same database.&quot;&quot;&quot;
        db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label)
        db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label)
        if db_obj1 and db_obj2:
            if db_obj1 == db_obj2:
                return True
            else:
                return False
        return None

    def allow_syncdb(self, db, model):
        &quot;&quot;&quot;Make sure that apps only appear in the related database.&quot;&quot;&quot;

        if db in DATABASE_MAPPING.values():
            return DATABASE_MAPPING.get(model._meta.app_label) == db
        elif model._meta.app_label in DATABASE_MAPPING:
            return False
        return None

    def allow_migrate(self, db, app_label, model=None, **hints):
        &quot;&quot;&quot;
        Make sure the auth app only appears in the 'auth_db'
        database.
        &quot;&quot;&quot;
        if db in DATABASE_MAPPING.values():
            return DATABASE_MAPPING.get(app_label) == db
        elif app_label in DATABASE_MAPPING:
            return False
        return None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里一定要把DATABASE_MAPPING里面的app名字和app名字对应，不然会读写不到，具体可以看上述代码，然后在模型类后面给每个模型添加一个app_label：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class Meta:
        app_label = 'order'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是migrate数据库了，先&lt;code&gt;makemigrations order&lt;/code&gt;,然后&lt;code&gt;migrate --database order&lt;/code&gt;&lt;br/&gt;后面sale app一样&lt;/p&gt;
</description>
<pubDate>Fri, 13 Mar 2020 15:54:00 +0000</pubDate>
<dc:creator>rrh</dc:creator>
<og:description>最近在研究微服务和分布式，设计到了数据库分库，记录一下 首先，创建多个数据库，如果是已经生成的数据库，可以分库，这里我是新创建的项目，刚好可以用来尝试 我是用docker创建的mysql数据库容器 拉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuruhao/p/12490034.html</dc:identifier>
</item>
<item>
<title>c++中的类型识别 - PRO_Z</title>
<link>http://www.cnblogs.com/nbk-zyc/p/12466779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbk-zyc/p/12466779.html</guid>
<description>&lt;p&gt;静态类型和动态类型、类型虚函数与多态、typeid、dynamic_cast、static_cast关键字的使用场合&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;144.5&quot;&gt;
&lt;h2&gt;1、类型识别的相关概念&lt;/h2&gt;
&lt;h3&gt;（1）类型识别的作用&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;类型识别&lt;/strong&gt;&lt;/span&gt;是面向对象中引入的一个新概念，主要用来&lt;span&gt;&lt;strong&gt;判断赋值兼容性原则中的类型问题，即此时的数据类型到底是基类类型还是派生类类型？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　当基类指针指向子类对象  或者 基类引用成为子类对象的别名  时，就需要使用类型识别；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Base *p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Derived();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Base &amp;amp;r = *p
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;       对于上面的语句，我们可以这样认识，指针p是Base类型，但是P 又指向了一个新的Derived类型，此时很难判断指针P 的数据类型；同理，引用r 本来作为父类的别名而存在，但由于赋值兼容性，引用r也可以作为子类的别名，同样此时 引用 r 的数据类型也不能确定；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　注：1）由之前所学知识，若没有虚函数重写，编译器为了安全起见，会将指针p 当作 Base 类型；（编译期间）　　　　&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　2）若有虚函数重写，就会发生动态多态特性，此时就会根据指针p 所指向的具体数据类型来确定指针p 的数据类型。（运行期间）&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;（2）类型识别的分类&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694641/201905/1694641-20190524195359547-1910467493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1）静态类型：变量（对象）自身的类型；在编译阶段就能确定所使用变量的数据类型。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　 2）动态类型：指针（引用）所指向对象的实际类型；在运行阶段根据指针所指向的具体数据类型来确定所使用的数据类型。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1438401/202003/1438401-20200311224759073-758674534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　Base *b 所指向的实际对象无法确定，若指针b 指向的是子类对象，则程序正常运行；若指针b 指向的是父类对象，则程序有可能出现 Bug；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　注：在 g++ 编译器下上述情况均可正常运行，但后者不建议使用；&lt;/p&gt;
&lt;p&gt; 　　在赋值兼容原则中，&lt;span&gt;&lt;strong&gt;基类指针是否可以强制类型转换为子类指针取决于动态类型；（很重要！！！）--- 只有动态类型是子类对象才能进行合法转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;2、如何得到动态类型&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;（1）利用多态&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　1）必须从基类开始提供类型虚函数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2）所有的派生类都必须重写类型虚函数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3）每个派生类的类型 ID必须唯一；&lt;/p&gt;
&lt;p&gt;　　　结果：调用类型虚函数就可以知道当前的对象究竟是什么类型，这样就可以得到动态类型，达到动态类型识别效果；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('956c5af9-c189-4d74-a4fa-5197bb888a43')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_956c5af9-c189-4d74-a4fa-5197bb888a43&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_956c5af9-c189-4d74-a4fa-5197bb888a43&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('956c5af9-c189-4d74-a4fa-5197bb888a43',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_956c5af9-c189-4d74-a4fa-5197bb888a43&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt; { ID = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; type()  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型虚函数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ID;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Derived : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt; { ID = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; type()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ID;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Derived. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt; { ID = &lt;span&gt;2&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; type()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ID;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;  
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(Base*&lt;span&gt; pb)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( pb-&amp;gt;type() ==&lt;span&gt; Child::ID )
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         Child* pc = static_cast&amp;lt;Child*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Child* pc = dynamic_cast&amp;lt;Child*&amp;gt;(pb);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同上&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         
&lt;span&gt;51&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pc &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Child. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( pb-&amp;gt;type() ==&lt;span&gt; Derived::ID )
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         Derived* pd = static_cast&amp;lt;Derived*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Derived* pd = dynamic_cast&amp;lt;Derived*&amp;gt;(pb); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同上&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         
&lt;span&gt;60&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pd &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         pd-&amp;gt;&lt;span&gt;print();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( pb-&amp;gt;type() ==&lt;span&gt; Base::ID )
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pb &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Base. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;  
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    Base b;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    Derived d;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     
&lt;span&gt;77&lt;/span&gt;     test(&amp;amp;&lt;span&gt;b);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     test(&amp;amp;&lt;span&gt;d);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     test(&amp;amp;&lt;span&gt;c);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     
&lt;span&gt;81&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt; * 运行结果：
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffccf0dd850
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt; * I'm a Base. 
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffccf0dd860
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt; * I'm a Derived.
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffccf0dd870
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt; * I'm a Child.
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;利用类型虚函数实现类型识别&lt;/span&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt; （2）利用 dynamic_cast&lt;/h3&gt;
&lt;p&gt;　　1）dynamic_cast这个关键字如果要转换的实际类型和指定的类型不一样，则会返回NULL。例如当指定类型为子类对象时，如果父类指针的动态类型是这个子类对象时，转换成功，而动态类型是父类对象或者其他子类对象时，转换失败；&lt;/p&gt;
&lt;p&gt;　　2）dynamic_cast 要求使用的目标对象类型必须是多态，即：所在类族至少有一个虚函数；&lt;/p&gt;
&lt;p&gt;　　3）只能用于指针和引用之间的转换&lt;/p&gt;
&lt;p&gt;　　　　1. 用于指针转换时，转换失败，返回空指针；&lt;/p&gt;
&lt;p&gt;　　　　2. 用于引用转换时，转换失败，将引发 bad_cast异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1f74ee30-6e87-473e-bd57-a7f0ad720895')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1f74ee30-6e87-473e-bd57-a7f0ad720895&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1f74ee30-6e87-473e-bd57-a7f0ad720895&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1f74ee30-6e87-473e-bd57-a7f0ad720895',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1f74ee30-6e87-473e-bd57-a7f0ad720895&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Base()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Derived : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:    
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Derived. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;  
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(Base*&lt;span&gt; pb)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dynamic_cast 只能确定最终的转化结果，无法获取动态类型的原型&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Derived* pd = dynamic_cast&amp;lt;Derived*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(pd !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Derived 类类型， 可以使用指针pd访问Derived类的成员&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pd &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         pd-&amp;gt;&lt;span&gt;print();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         Child* pc = dynamic_cast&amp;lt;Child*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(pc !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Child 类类型， 可以使用指针pc访问Child类的成员&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pc &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Child. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Base 类类型， 可以使用指针pb访问Base类的成员&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pc &amp;lt;&amp;lt;&lt;span&gt; endl; 
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Base. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;  
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    Base b;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    Derived d;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     
&lt;span&gt;65&lt;/span&gt;     test(&amp;amp;&lt;span&gt;b);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     test(&amp;amp;&lt;span&gt;d);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     test(&amp;amp;&lt;span&gt;c);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt; * 运行结果：
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt; * I'm a Base. 
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffccf0dd860
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt; * I'm a Derived.
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffccf0dd870
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt; * I'm a Child.
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;利用 dynamic_cast 实现类型识别&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt; （3）利用 typeid（推荐这种方法）&lt;/h3&gt;
&lt;p&gt;　　1）typeid 是一个关键字，专门用于动态类型识别；&lt;/p&gt;
&lt;p&gt;　　2）typeid 关键字返回对应参数的类型信息，此类型信息是一个type_info类对象；&lt;/p&gt;
&lt;p&gt;　　　　1. 当参数为类型时，返回静态类型信息；&lt;/p&gt;
&lt;p&gt;　　　　2. 当参数为变量时：1&amp;gt;   参数变量内部不存在虚函数表时，返回静态类型信息；    2&amp;gt;   参数变量内部存在虚函数表时，返回动态类型信息;&lt;/p&gt;
&lt;p&gt;　　　　3. 当参数为 NULL 时，将抛出异常；&lt;/p&gt;
&lt;p&gt; 　  3）typeid  使用时需要包含头文件&amp;lt;typeinfo&amp;gt;；&lt;/p&gt;
&lt;p&gt;　　4）typeid  使用时直接指定对象或者类型。&lt;/p&gt;
&lt;p&gt;　　5）typeid 在不同的编译器内部实现是不同的；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tiv = typeid(i);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 i 的类型信息放到 type_info 中去；&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tii = typeid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        
&lt;span&gt;6&lt;/span&gt; cout &amp;lt;&amp;lt; (tiv == tii) &amp;lt;&amp;lt; endl;  // 1
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3bb9defd-ee74-4ff9-8d6a-48718d692aef')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_3bb9defd-ee74-4ff9-8d6a-48718d692aef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3bb9defd-ee74-4ff9-8d6a-48718d692aef&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3bb9defd-ee74-4ff9-8d6a-48718d692aef',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3bb9defd-ee74-4ff9-8d6a-48718d692aef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;typeinfo&amp;gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Base()
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;  
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Derived : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print()
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Derived.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;  
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Base 
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print()
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Child.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;  
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(Base*&lt;span&gt; pb)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tb = typeid(*&lt;span&gt;pb);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( tb ==&lt;span&gt; typeid(Derived) )
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         Derived* pd = dynamic_cast&amp;lt;Derived*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     
&lt;span&gt; 41&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pd &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         pd-&amp;gt;&lt;span&gt;print();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( tb ==&lt;span&gt; typeid(Child) )
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         Child* pc = dynamic_cast&amp;lt;Child*&amp;gt;&lt;span&gt;(pb);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         
&lt;span&gt; 48&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pc &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         pc-&amp;gt;&lt;span&gt;print();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( tb ==&lt;span&gt; typeid(Base) )
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp; = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; pb &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm a Base. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     
&lt;span&gt; 58&lt;/span&gt;     cout &amp;lt;&amp;lt; tb.name() &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;  
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    Base b;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    Derived d;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tp =&lt;span&gt; typeid(b);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tc =&lt;span&gt; typeid(d);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tn =&lt;span&gt; typeid(c);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; ti =&lt;span&gt; typeid(index);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; type_info&amp;amp; tch =&lt;span&gt; typeid(ch);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     
&lt;span&gt; 75&lt;/span&gt;     cout&amp;lt;&amp;lt;tp.name()&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     cout&amp;lt;&amp;lt;tc.name()&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     cout&amp;lt;&amp;lt;tn.name()&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     cout&amp;lt;&amp;lt;ti.name()&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     cout&amp;lt;&amp;lt;tch.name()&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     
&lt;span&gt; 81&lt;/span&gt;     test(&amp;amp;&lt;span&gt;b);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     test(&amp;amp;&lt;span&gt;d);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     test(&amp;amp;&lt;span&gt;c);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt; * 运行结果：
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt; * 4Base
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt; * 7Derived
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt; * 5Child
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt; * i
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt; * c
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffcbd4d6280
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt; * I'm a Base. 
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt; * 4Base
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffcbd4d6290
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt; * I'm a Derived.
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt; * 7Derived
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt; * &amp;amp; = 0x7ffcbd4d62a0
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt; * I'm a Child.
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt; * 5Child
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;利用 typeid 实现类型识别&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 　   结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3 种动态类型的实现方法 建议选 第3种 （typeid）。&lt;/p&gt;
&lt;p&gt;　　对于多态实现，存在以下缺陷：&lt;/p&gt;
&lt;p&gt;　　　　1）必须从基类开始提供类型虚函数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      　　 2）所有的派生类都必须重写类型虚函数；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       　　3）每个派生类的类型名必须唯一；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　对于 dynamic_cast 实现，只能得到类型转换的结果，不能获取真正的动态类型，同时 dynamic_cast 必须多态实现。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 13 Mar 2020 15:52:00 +0000</pubDate>
<dc:creator>PRO_Z</dc:creator>
<og:description>静态类型和动态类型、类型虚函数与多态、typeid、dynamic_cast、static_cast关键字的使用场合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nbk-zyc/p/12466779.html</dc:identifier>
</item>
</channel>
</rss>