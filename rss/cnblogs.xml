<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>QT学习小demo之LightMD（MarkDown编辑器） - Asche</title>
<link>http://www.cnblogs.com/asche/p/10834587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/asche/p/10834587.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;很早之前就有了写一个类似Windows记事本的想法，加上最近也刚好在学编译原理，所以就想把两者结合起来，于是就打算结合MarkDown，开发一款MarkDown编辑器。&lt;br/&gt;不过由于我之前一直使用的是Java语言居多，对c++并不熟悉，所以一些糟糕的代码风格和规范还望各位大佬谅解！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/asche910/LightMD&quot;&gt;&lt;strong&gt;LightMD&lt;/strong&gt;&lt;/a&gt; 即一款基于QT实现的markdown编辑器，当然也可以作为代码编辑器，由于时间与个人能力等原因，目前实现的功能非常有限！&lt;/p&gt;
&lt;p&gt;主要包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持语法高亮（目前支持C/C++）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持MarkDown预览&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码行数、文本信息统计等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其它一些基本的文件处理相关功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了直接上图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508205235739-283039740.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508205249824-1786194754.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本项目主要目的在于学习qt相关的windows开发，其中主要有以下几个模块：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整体布局&lt;/li&gt;
&lt;li&gt;代码编辑器&lt;/li&gt;
&lt;li&gt;markdown编辑器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;整体布局&quot;&gt;整体布局&lt;/h2&gt;
&lt;p&gt;最外面当然是_QMainWindow_， 然后从上到下依次是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;menuBar&lt;/li&gt;
&lt;li&gt;QSplitter&lt;/li&gt;
&lt;li&gt;statusBar&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;menubar的简单示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    QMenu *menuFile = menuBar()-&amp;gt;addMenu(tr(&quot;&amp;amp;File&quot;));
    QAction *itemNew = new QAction(tr(&quot;&amp;amp;New&quot;), this);
    itemNew-&amp;gt;setStatusTip(tr(&quot;Create a new file&quot;));
    connect(itemNew, &amp;amp;QAction::triggered, this, &amp;amp;Home::newFile);
    menuFile-&amp;gt;addAction(itemNew);
   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中QMenu就是最外面显示的menu，即鼠标不点击就可以看见的那个menu；QAction则是QMenu上众多选项之一；然后是调用connect函数为QAction设置点击事件。&lt;/p&gt;
&lt;p&gt;中间主体则是QSplitter，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
    QSplitter *centralSplitter = new QSplitter(this);

    setCentralWidget(centralSplitter);

    centralSplitter-&amp;gt;addWidget(codeEditor);
    centralSplitter-&amp;gt;addWidget(preview);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先new一个QSplitter，然后将其设置为中间组件，然后在QSplitter上再添加两个组件，分别为代码编辑区域和markdown预览区域的组件。&lt;br/&gt;这两个区域在文章下面将有具体讲解。&lt;/p&gt;
&lt;p&gt;底部则是statusBar：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    label = new QLabel(&quot;LightMD is ready!&quot;);
    textType = new QLabel(&quot;Plain Text&quot;);
    codeLength = new QLabel(&quot;Length:652&quot;);
    codeLines = new QLabel(&quot;Lines:54&quot;);

    statusBar()-&amp;gt;addWidget(label, 1);
    statusBar()-&amp;gt;addPermanentWidget(textType);
    statusBar()-&amp;gt;addPermanentWidget(codeLength);
    statusBar()-&amp;gt;addPermanentWidget(codeLines);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;label用来显示正常的提示消息；textType用来显示当前的文本类型，如markdown或c++等；codeLength和codeLines就不用过多解释了吧。&lt;/p&gt;
&lt;h2 id=&quot;代码编辑器&quot;&gt;代码编辑器&lt;/h2&gt;
&lt;p&gt;其中代码编辑框我纠结了半天，用QPlainTextEdit好呢，还是QTextEdit好？？？其中StackOverflow上一高赞回答如下：&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;QPlainTextEdit is an advanced viewer/editor supporting plain text. It is optimized to handle large documents and to respond quickly to user input.&lt;/p&gt;
&lt;p&gt;QPlainText uses very much the same technology and concepts as QTextEdit, but is optimized for plain text handling.&lt;/p&gt;
&lt;p&gt;QPlainTextEdit works on paragraphs and characters. A paragraph is a formatted string which is word-wrapped to fit into the width of the widget. By default when reading plain text, &amp;gt; one newline signifies a paragraph. A document consists of zero or more paragraphs. Paragraphs are separated by hard line breaks. Each character within a paragraph has its&lt;br/&gt;own attributes, for example, font and color.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单点说，就是QPlainTextEdit对普通文本的支持度特别高，也就是很方便，不过一些复杂功能却不能实现；而QTextEdit是一个更加重量级的组件，支持各种复杂功能，不过一些简单的功能可能没有QPlainTextEdit使用的那么方便。&lt;/p&gt;
&lt;p&gt;两者我都简单试用后，发现还是QPlainTextEdit用着比较方便，于是就决定采用QPlainTextEdit了。&lt;/p&gt;
&lt;p&gt;然后关于代码框和代码行数的实现，QT的官方demo里面好像有现成的（不得不说，qt的demo是真的多！）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508223249653-563185469.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，这里的实现我就不解释啥了。&lt;/p&gt;
&lt;h2 id=&quot;markdown编辑器&quot;&gt;markdown编辑器&lt;/h2&gt;
&lt;p&gt;这里官方也有个markdown的demo，下载就行了。不过要注意的是，这里由于用到了web引擎，所以这里必须使用vs来编译运行，安装vs环境这里不懂的还是自行百度吧。&lt;/p&gt;
&lt;p&gt;官方demo中好像实现的都挺全的，我只是做了个小修改，然后就转移到LightMD来了。&lt;br/&gt;其中markdown预览流程是先将markdown内容转换为对应的html内容，然后web引擎来显示HTML页面。&lt;br/&gt;其中转换官方也全部为我们做好了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470456/201905/1470456-20190508224007661-1374021705.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;由于时间关系，当然是直接套用了。不过以后有空的话，自己再去实现一下吧。&lt;/p&gt;
&lt;p&gt;最后，LightMd项目地址：&lt;a href=&quot;https://github.com/asche910/LightMD&quot;&gt;LightMD&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:48:00 +0000</pubDate>
<dc:creator>Asche</dc:creator>
<og:description>很早之前就有了写一个类似Windows记事本的想法，加上最近也刚好在学编译原理，所以就想把两者结合起来，于是就打算结合MarkDown，开发一款MarkDown编辑器。 不过由于我之前一直使用的是Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/asche/p/10834587.html</dc:identifier>
</item>
<item>
<title>微服务熔断限流Hystrix之流聚合 - 程序员果果</title>
<link>http://www.cnblogs.com/huanchupkblog/p/10835570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huanchupkblog/p/10835570.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;上一篇介绍了 Hystrix Dashboard 监控单体应用的例子，在生产环境中，监控的应用往往是一个集群，我们需要将每个实例的监控信息聚合起来分析，这就用到了 Turbine 工具。Turbine有一个重要的功能就是汇聚监控信息，并将汇聚到的监控信息提供给Hystrix Dashboard来集中展示和监控。&lt;/p&gt;
&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224203653-1490838029.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;
&lt;h3 id=&quot;工程说明&quot;&gt;工程说明&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eureka-server&lt;/td&gt;
&lt;td&gt;8761&lt;/td&gt;
&lt;td&gt;注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;service-hi&lt;/td&gt;
&lt;td&gt;8762&lt;/td&gt;
&lt;td&gt;服务提供者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;service-consumer&lt;/td&gt;
&lt;td&gt;8763&lt;/td&gt;
&lt;td&gt;服务消费者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;service-turbine&lt;/td&gt;
&lt;td&gt;8765&lt;/td&gt;
&lt;td&gt;Turbine服务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;核心代码&quot;&gt;核心代码&lt;/h3&gt;
&lt;p&gt;eureka-server 、service-hi、service-consumer 工程代码与上一节 &lt;a href=&quot;https://mp.weixin.qq.com/s/Nmqu2ul4aRT6iXecxrmt9A&quot;&gt;微服务熔断限流Hystrix之Dashboard&lt;/a&gt; 相同，下面是 service-turbine 工程的核心代码。&lt;/p&gt;
&lt;h4 id=&quot;pom.xml&quot;&gt;pom.xml&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-turbine&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;application.yml&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8765

spring:
  application:
    name: service-turbine
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/

turbine:
  app-config: service-consumer
  cluster-name-expression: new String(&quot;default&quot;)
  combine-host-port: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;turbine.app-config：指定要监控的应用名&lt;/li&gt;
&lt;li&gt;turbine.cluster-name-expression：指定集群的名字&lt;/li&gt;
&lt;li&gt;turbine.combine-host-port：表示同一主机上的服务通过host和port的组合来进行区分，默认情况下是使用host来区分，这样会使本地调试有问题&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动类&quot;&gt;启动类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableEurekaClient
@EnableHystrixDashboard
@EnableTurbine
public class ServiceTurbineApplication {

    public static void main(String[] args) {
        SpringApplication.run( ServiceTurbineApplication.class, args );
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模拟多实例&quot;&gt;模拟多实例&lt;/h3&gt;
&lt;p&gt;启动多个 service-consumer 工程，来模拟多实例，可以通过命令java -jar service-consumer.jar --server.port=XXXX 来实现。&lt;/p&gt;
&lt;p&gt;为了方便，在编辑器中实现启动工程。但 idea 不支持单个应用的多次启动， 需要开启并行启动：&lt;/p&gt;
&lt;p&gt;选择 “Edit Configurations...”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224247934-54106350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;勾选 “Allow running in parallel”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224258847-65412686.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;启动工程，访问 http//localhost:8763/hi , http//localhost:8764/hi , http//localhost:8763/oh , http//localhost:8764/oh，来产生测试数据。&lt;/p&gt;
&lt;p&gt;访问 http://localhost:8765/hystrix ，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224310961-1018349054.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入监控流地址 http://localhost:8765/turbine.stream ，点击 Monitor Stream 进入监控页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190508224337299-967613962.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到聚合了两个实例的 Hystrix dashbord 数据。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;https://github.com/gf-huanchupk/SpringCloudLearning/tree/master/chapter18&lt;/p&gt;
&lt;p&gt;欢迎扫码或微信搜索公众号《程序员果果》关注我，关注有惊喜~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201903/528977-20190311112108481-2022563516.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:45:00 +0000</pubDate>
<dc:creator>程序员果果</dc:creator>
<og:description>简介 上一篇介绍了 Hystrix Dashboard 监控单体应用的例子，在生产环境中，监控的应用往往是一个集群，我们需要将每个实例的监控信息聚合起来分析，这就用到了 Turbine 工具。Turb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huanchupkblog/p/10835570.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合Redis使用Restful风格实现CRUD功能 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10835571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10835571.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要介绍的是SpringBoot整合Redis，使用Restful风格实现的CRUD功能。&lt;/p&gt;
&lt;h2 id=&quot;redis-介绍&quot;&gt;Redis 介绍&lt;/h2&gt;
&lt;p&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value缓存产品有以下三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多的使用说明可以查看官方的文档。&lt;br/&gt;官方文档: https://redis.io&lt;/p&gt;
&lt;h2 id=&quot;springboot整合redis&quot;&gt;SpringBoot整合Redis&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;br/&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：1.5.15.RELEASE&lt;br/&gt;&lt;strong&gt;Redis&lt;/strong&gt;：3.2或以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;：Redis的偶数为稳定版本，奇数为非稳定版本，所以在使用的时候最好使用偶数的版本！&lt;/p&gt;
&lt;p&gt;Reids的可以看我之前的写的这篇文章: &lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/7536708.html&quot;&gt;Redis安装教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;fastjson&amp;gt;1.2.41&amp;lt;/fastjson&amp;gt;
    &amp;lt;springboot&amp;gt;1.5.15.RELEASE&amp;lt;/springboot&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
  
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${fastjson}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
  
  &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加了相应的maven依赖之后，我们再来查看配置。&lt;br/&gt;&lt;strong&gt;Redis&lt;/strong&gt;配置的说明在下面中已经说的很详细了，这里就不在过多说明了，不过需要注意的是如果&lt;strong&gt;Redis&lt;/strong&gt;是集群版的话，需要使用这个&lt;code&gt;spring.redis.cluster.nodes&lt;/code&gt;这个配置，该配置为Redis的Host加上Port，多个之间用，逗号隔开。&lt;br/&gt;&lt;strong&gt;application.properties&lt;/strong&gt;的配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Redis服务器地址
# 单机版配置
spring.redis.host = 127.0.0.1
spring.redis.port = 6379
# redis最大重连数
redis.cluster.max-redirects=3
# Redis服务器连接密码（默认为空）
redis.password=
# 最大空闲数  
redis.maxIdle=5  
# 连接池的最大数据库连接数。
redis.maxTotal=5 
# 最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。  
redis.maxWaitMillis=1000  
# 连接的最小空闲时间 默认1800000毫秒(30分钟)  
redis.minEvictableIdleTimeMillis=300000  
# 每次释放连接的最大数目,默认3  
redis.numTestsPerEvictionRun=3 
# 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1  
redis.timeBetweenEvictionRunsMillis=30000  
# 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个  
redis.testOnBorrow=true  
# 在空闲时检查有效性, 默认false  
redis.testWhileIdle=true  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;首先是编写Redis的配置类，对Redis这块进行配置。&lt;br/&gt;在使用SpringBoot整合Redis的时候，SpringBoot是可以根据配置自动完成Redis的相关配置，不过为了更灵活一点，我们这边还是手动加载一下配置，配置成自己想要的那种效果吧。&lt;br/&gt;首先，配置一个Redis的连接池，使用&lt;code&gt;redis.clients.jedis.JedisPoolConfig&lt;/code&gt;这个类来进行实现，相关的配置在代码的注释中说明得很详细了，这里就不在过多讲述了；&lt;br/&gt;然后，再来配置一个Redis的工厂，加载Redis的连接池配置，这里我们也可以进行一下设置，如果Redis设置了密码，我们就加载改密码，否则就不进行加载。&lt;br/&gt;继而，我们再来设置数据存入Redis的序列化的方式并开启事务。这里也顺便说下为什么要设置序列化器，如果不设置，那么在用实体类(未序列化)进行存储的时候，会提示错误: &lt;code&gt;Failed to serialize object using DefaultSerializer&lt;/code&gt;; 当然，也可以不设置，不过存储的实体类必须进行序列化。&lt;br/&gt;最后，我们再来实例化RedisTemplate的对象，加载上述的配置。在使用的时候，只需要使用如下的方式注入就可以使用了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Autowired
RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Redis的配置类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 
 * @Title: RedisConfig
 * @Description: redis初始化配置
 * @Version:1.0.0
 * @author pancm
 * @date 2018年6月7日
 */
@Component
public class RedisConfig {

    @Value(&quot;${redis.maxIdle}&quot;)
    private Integer maxIdle;

    @Value(&quot;${redis.maxTotal}&quot;)
    private Integer maxTotal;

    @Value(&quot;${redis.maxWaitMillis}&quot;)
    private Integer maxWaitMillis;

    @Value(&quot;${redis.minEvictableIdleTimeMillis}&quot;)
    private Integer minEvictableIdleTimeMillis;

    @Value(&quot;${redis.numTestsPerEvictionRun}&quot;)
    private Integer numTestsPerEvictionRun;

    @Value(&quot;${redis.timeBetweenEvictionRunsMillis}&quot;)
    private long timeBetweenEvictionRunsMillis;

    @Value(&quot;${redis.testOnBorrow}&quot;)
    private boolean testOnBorrow;

    @Value(&quot;${redis.testWhileIdle}&quot;)
    private boolean testWhileIdle;

    @Value(&quot;${redis.cluster.max-redirects}&quot;)
    private Integer mmaxRedirectsac;

    @Value(&quot;${redis.password}&quot;)
    private String redispwd;

    /**
     * JedisPoolConfig 连接池
     * 
     * @return
     */
    @Bean
    public JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 最大空闲数
        jedisPoolConfig.setMaxIdle(maxIdle);
        // 连接池的最大数据库连接数
        jedisPoolConfig.setMaxTotal(maxTotal);
        // 最大建立连接等待时间
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        // 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
        jedisPoolConfig.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        // 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3
        jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        // 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        // 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个
        jedisPoolConfig.setTestOnBorrow(testOnBorrow);
        // 在空闲时检查有效性, 默认false
        jedisPoolConfig.setTestWhileIdle(testWhileIdle);
        return jedisPoolConfig;
    }



    
    /**
     * 配置工厂
     */
    @Bean
    public JedisConnectionFactory JedisConnectionFactory(JedisPoolConfig jedisPoolConfig) {
        JedisConnectionFactory JedisConnectionFactory = new JedisConnectionFactory(jedisPoolConfig);
        if (redispwd == null || redispwd.length() == 0) {
            JedisConnectionFactory.setPassword(redispwd);
        }
        return JedisConnectionFactory;
    }

    

    /**
     * 设置数据存入 redis 的序列化方式,并开启事务
     * 
     * @param redisTemplate
     * @param factory
     */
    private void initDomainRedisTemplate(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate, RedisConnectionFactory factory) {
        /*
         * 设置 序列化器 .
         * 如果不设置，那么在用实体类(未序列化)进行存储的时候，会提示错误: Failed to serialize object using DefaultSerializer;
         */
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        // 开启事务
        redisTemplate.setEnableTransactionSupport(true);
        // 将连接工厂设置到模板类中
        redisTemplate.setConnectionFactory(factory);
    }
    
    /**
     * 实例化 RedisTemplate 对象
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; functionDomainRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate = new RedisTemplate&amp;lt;&amp;gt;();
        initDomainRedisTemplate(redisTemplate, redisConnectionFactory);
        return redisTemplate;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果自己想使用自定义的Redis工具类进行实现，那么只需在该配置类中注册一个Bean注入封装一下就可以了，然后在工具类中加载一下就可以了。&lt;br/&gt;配置类中添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Bean(name = &quot;redisUtil&quot;)
    public RedisUtil redisUtil(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate) {
        RedisUtil redisUtil = new RedisUtil();
        redisUtil.setRedisTemplate(redisTemplate);
        return redisUtil;
    }'
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis的工具类添加如下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;

    public void setRedisTemplate(RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Redis工具类示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Resource
    private RedisUtil redisUtil;
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;讲完Redis的配置类之后，我们再来进行编写相应的实体类、dao层、service层和Controller层的代码了。&lt;br/&gt;由于这块的代码比较简单，而且格式和之前的&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;项目&lt;/a&gt;基本类似，因此这里我就简单的贴下代码了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又是万能的用户表 (&lt;em&gt;^▽^&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class User implements Serializable{
    private static final long serialVersionUID = 1L;
    /** 编号 */
     private int id;
     /** 姓名 */
     private String name;
     /** 年龄 */
     private int age;
     
     public User(){
     }

    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String toString() {
        return JSONObject.toJSONString(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Dao 数据层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我是使用的自定义的Redis工具类，其实也就是对&lt;code&gt;RedisTemplate&lt;/code&gt;做了二次封装。&lt;br/&gt;因为使用的是set（集合）方式存储的，所以我这边把用户数据的ID作为key，用户数据作为value了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Repository
public class UserDaoImpl implements UserDao {

    @Resource
    private RedisUtil redisUtil;
    

    @Override
    public void addUser(User user) {
        redisUtil.set(String.valueOf(user.getId()), user.toString());
    }


    @Override
    public void updateUser(User user) {
        redisUtil.set(String.valueOf(user.getId()), user.toString());
    }


    @Override
    public void deleteUser(int id) {
        redisUtil.del(String.valueOf(id));
    }

    
    @Override
    public User findByUserId(int id) {
        String data = redisUtil.get(String.valueOf(id)).toString();
        User user = JSON.parseObject(data, User.class);
        return  user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Service 业务层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务层这边处理比较简单，成功就返回true，失败就返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类的代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Service
public class UserServiceImpl implements UserService {   

    private  final Logger logger = LoggerFactory.getLogger(this.getClass());
    @Autowired
    private UserDao userDao;    
    
    @Override
    public boolean addUser(User user) {
        boolean flag=false;
        try{
            userDao.addUser(user);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;新增失败!&quot;,e);
        }
        return flag;
    }

    @Override
    public boolean updateUser(User user) {
        boolean flag=false;
        try{
            userDao.updateUser(user);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;修改失败!&quot;,e);
        }
        return flag;
    }

    @Override
    public boolean deleteUser(int id) {
        boolean flag=false;
        try{
            userDao.deleteUser(id);
            flag=true;
        }catch(Exception e){
            logger.error(&quot;删除失败!&quot;,e);
        }
        return flag;
    }


    @Override
    public User findByUserId(int id) {
        return userDao.findByUserId(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Controller 控制层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制层这边也比较简单，使用Restful风格实现的CRUD功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@RestController
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {
    
    private  final Logger logger = LoggerFactory.getLogger(this.getClass());

    
    @Autowired
    private UserService userService;
 
    @PostMapping(&quot;/user&quot;)
    public boolean addUser(@RequestBody User user) {
        logger.info(&quot;开始新增...&quot;);
        return userService.addUser(user);
    }
    
    @PutMapping(&quot;/user&quot;)
    public boolean updateUser(@RequestBody User user) {
        logger.info(&quot;开始更新...&quot;);
        return userService.updateUser(user);
    }
    
    @DeleteMapping(&quot;/user&quot;)
    public boolean delete(@RequestParam(value = &quot;id&quot;, required = true) int userId) {
        logger.info(&quot;开始删除...&quot;);
        return userService.deleteUser(userId);
    }
    

    @GetMapping(&quot;/user&quot;)
    public User findByUserId(@RequestParam(value = &quot;id&quot;, required = true) int userId) {
        logger.info(&quot;开始查询所有数据...&quot;);
        return userService.findByUserId(userId);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App 入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和普通的SpringBoot项目基本一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@SpringBootApplication
public class App 
{
    public static void main( String[] args )
    {
        SpringApplication.run(App.class, args);
        System.out.println(&quot;程序正在运行...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;我们成功启动该程序之后，使用Postman工具来进行接口测试。&lt;/p&gt;
&lt;p&gt;首先添加一条数据，使用POST方式进行请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;POST http://localhost:8180/api/user&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212843449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;界面返回true，表示新增成功了！&lt;/p&gt;
&lt;p&gt;然后在进行查询，使用GET请求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET http://localhost:8180/api/user?id=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213152690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再来使用&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/10393111.html&quot;&gt;RedisDesktopManager&lt;/a&gt;工具进行查询看下，是否真的写入到Redis中去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213342227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功写入到Redis中了。&lt;/p&gt;
&lt;p&gt;然后我们再来更新下更新该数据，使用PUT方式请求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PUT http://localhost:8180/api/user&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里只是更改了下age年龄，Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:19}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213514420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功更新了。&lt;/p&gt;
&lt;p&gt;最后我们再来查询一遍看下是否成功更新。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GET http://localhost:8180/api/user?id=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:19}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050821361881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到已经成功更新了。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;其实SpringBoot整合Redis整个项目很早之前就已经写好并且上传到Github了，但是一直没有抽出时间写篇博客讲述(还有很多SpringBoot的项目也是如此)，最近不是那么的忙了，于是准备了下时间编写本篇博文。后续个人Github上的SpringBoot项目中以后有时间的话，也会对其中的一些发表博文进行讲解，不过那是以后的事了ヽ(ー_ー)ノ&lt;/p&gt;
&lt;p&gt;关于SpringBoot整合Redis的文章就讲解到这里了，如有不妥，欢迎指正！&lt;/p&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;SpringBoot整合Redis的项目工程地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-Redis&lt;/p&gt;
&lt;p&gt;SpringBoot整个集合的地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study&lt;/p&gt;
&lt;h3 id=&quot;springboot整合系列的文章&quot;&gt;SpringBoot整合系列的文章&lt;/h3&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 14:41:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇文章主要介绍的是SpringBoot整合Redis，使用Restful风格实现的CRUD功能。 Redis 介绍 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key valu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10835571.html</dc:identifier>
</item>
<item>
<title>【面试被虐】说说游戏中的敏感词过滤是如何实现的？ - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10834993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10834993.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;版权声明：本文为&lt;strong&gt;苦逼的码农&lt;/strong&gt;原创。未经同意禁止任何形式转载，特别是那些复制粘贴到别的平台的，否则，必定追究。欢迎大家多多转发，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而小秋对敏感词过滤算法一点也没听说过。于是，有了下下事情的发生.....&lt;/p&gt;
&lt;h3 id=&quot;面试官开怼&quot;&gt;面试官开怼&lt;/h3&gt;
&lt;p&gt;面试官：玩过王者荣耀吧？了解过&lt;strong&gt;敏感词过滤吗？&lt;/strong&gt;，例如在游戏里，如果我们发送“你在干嘛？麻痹演员啊你？”，由于“麻痹”是一个敏感词，所以当你把聊天发出来之后，我们会用“**”来代表“麻痹”这次词，所以发送出来的聊天会变成这样：“你在干嘛？**演员啊你？”。&lt;/p&gt;
&lt;p&gt;小秋：听说过啊，在各大社区也经常看到，例如评论一个问题等，一些粗话经常被过滤掉了。&lt;/p&gt;
&lt;p&gt;面试官：嗯，如果我给你一段文字，以及给你一些需要过滤的敏感词，你会怎么来实现这个敏感词过滤的算法呢？例如我给你一段字符串“abcdefghi&quot;,以及三个敏感词&quot;de&quot;, &quot;bca&quot;, &quot;bcf&quot;。&lt;/p&gt;
&lt;p&gt;小秋：（敏感词过来算法？？不就是字符串匹配吗？）我可以通过字符串匹配算法，例如在字符串”abcdefghi&quot;在查找是否存在字串“de&quot;，如果找到了就把”de“用&quot;&lt;strong&gt;&quot;代替。通过三次匹配之后，接变成这样了：“abc&lt;/strong&gt; fghi&quot;。&lt;/p&gt;
&lt;p&gt;面试官：可以说说你采用哪种字符串匹配算法吗？&lt;/p&gt;
&lt;p&gt;小秋：最简单的方法就是采用两个for循环保留求解了，不过每次匹配的都时间复杂度为O(n*m)，我可以采用 KMP 字符串匹配算法，这样时间复杂度是 O(m+n)。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;n 表示字符串的长度，m 表示每个敏感词的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面试官：这是一个方法，对于敏感词过滤，你还有其他方法吗？&lt;/p&gt;
&lt;p&gt;小秋：（其他方法？说实话，我也觉得不是采用这种 KMP 算法来匹配的了，可是，之前也没去了解过敏感词，这下要凉）对敏感词过来之前也没了解过，暂时没想到其他方法。&lt;/p&gt;
&lt;h3 id=&quot;trie-树&quot;&gt;trie 树&lt;/h3&gt;
&lt;p&gt;面试官：了解过 trie 树吗？&lt;/p&gt;
&lt;p&gt;小秋：（嘿嘿，数据结构这方法，我得争气点）了解过，我还用代码实现过。&lt;/p&gt;
&lt;p&gt;面试官：可以说说它的特点吗？&lt;/p&gt;
&lt;p&gt;小秋：trie 树也称为字典树、单词查找树，最大的特点就是共享&lt;strong&gt;字符串的公共前缀&lt;/strong&gt;来达到节省空间的目的了。例如，字符串 &quot;abc&quot;和&quot;abd&quot;构成的 trie 树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9220f8cb8b0f8?w=471&amp;amp;h=336&amp;amp;f=png&amp;amp;s=17359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;trie 树的&lt;strong&gt;根节点&lt;/strong&gt;不存任何数据，每&lt;strong&gt;整个&lt;/strong&gt;个分支代表一个完整的字符串。像 abc 和 abd 有公共前缀 ab，所以我们可以共享节点 ab。如果再插入 abf，则变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92247a12117dc?w=475&amp;amp;h=348&amp;amp;f=png&amp;amp;s=19729&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我再插入 bc，则是这样（bc 和其他三个字符串没有公共前缀）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a922651588ed2e?w=489&amp;amp;h=342&amp;amp;f=png&amp;amp;s=23915&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;面试官：那如果再插入 &quot;ab&quot; 这个字符串呢？&lt;/p&gt;
&lt;p&gt;小秋：差点说了，每个分支的内部可能也含有完整的字符串，所以我们可以对于那些是某个字符串结尾的节点做一个&lt;strong&gt;标记&lt;/strong&gt;，例如 abc, abd,abf 都包含了字符串 ab,所以我们可以在节点 b 这里做一个标记。如下（我用红色作为标记）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a922b03ec436fa?w=432&amp;amp;h=370&amp;amp;f=png&amp;amp;s=23677&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官：可以说说 trie 树有哪些应用吗？&lt;/p&gt;
&lt;p&gt;小秋：trie 最大的特点就是利用了字符串的公共前缀，像我们有时候在百度、谷歌输入某个关键字的时候，它会给我们列举出很多相关的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92311b4dfcdf2?w=984&amp;amp;h=236&amp;amp;f=png&amp;amp;s=25030&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种就是通过 trie 树来实现的。&lt;/p&gt;
&lt;p&gt;小秋：（嗯？ trie 又称为单词查找树，好像可以用 trie 来实现刚才的敏感词匹配？面试官无缘无故提 trie 树难道别有用意？）&lt;/p&gt;
&lt;p&gt;面试官：刚才的敏感词过滤，其实也可以采用 trie 来实现，你知道怎么实现吗？&lt;/p&gt;
&lt;h3 id=&quot;trie-树来实现敏感词过滤&quot;&gt;trie 树来实现敏感词过滤&lt;/h3&gt;
&lt;p&gt;小秋：（果然，面试官真是个好人啊，直接提示了，要是还不知道怎么实现，那不真凉？）我想想........我知道了，我可以这样来实现：&lt;/p&gt;
&lt;p&gt;先把你给我的三个敏感词：&quot;de&quot;, &quot;bca&quot;, &quot;bcf&quot; 建立一颗 trie 树，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a923f595a6fae5?w=411&amp;amp;h=349&amp;amp;f=png&amp;amp;s=21076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们可以采用三个指针来遍历，我直接用上面你给你例子来演示吧。&lt;/p&gt;
&lt;p&gt;1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9241249414d30?w=950&amp;amp;h=509&amp;amp;f=png&amp;amp;s=34588&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9243c3fe2e11c?w=914&amp;amp;h=405&amp;amp;f=png&amp;amp;s=32150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，&lt;strong&gt;我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92475d7f0be9d?w=926&amp;amp;h=413&amp;amp;f=png&amp;amp;s=32744&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a92496237eb3cf?w=919&amp;amp;h=412&amp;amp;f=png&amp;amp;s=32450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，&lt;strong&gt;不存在以字符b作为前缀的敏感词&lt;/strong&gt;。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924bda72bba94?w=1019&amp;amp;h=400&amp;amp;f=png&amp;amp;s=33486&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924cf1a5d0009?w=980&amp;amp;h=483&amp;amp;f=png&amp;amp;s=35107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，&lt;strong&gt;我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动。&lt;/strong&gt;（看到这里，我猜你已经懂了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a924e6fa468db5?w=1046&amp;amp;h=375&amp;amp;f=png&amp;amp;s=33005&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，&lt;strong&gt;并且，这里e是最后一个节点了，查找结束，所以存在敏感词de&lt;/strong&gt;，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/7/16a9251b45b50014?w=954&amp;amp;h=422&amp;amp;f=png&amp;amp;s=33004&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。&lt;/p&gt;
&lt;h3 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h3&gt;
&lt;p&gt;面试官：可以说说时间复杂度吗？&lt;/p&gt;
&lt;p&gt;小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里我说明一下，在实际的应用中，构建 trie 树的时间复杂度我觉得可以忽略，因为 trie 树我们可以在一开始就构建了，以后可以无数次重复利用的了。而刚才的 kmp 算法时间复杂度是 t *(m+n)，不过kmp需要维护 next 数组比较费空间，而且在实际情况中,敏感词的数量 t 是比较大，而 n 反而比较小的吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10、如果让你来 构建 trie 树，你会用什么数据结构来实现？&lt;/p&gt;
&lt;p&gt;小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。&lt;/p&gt;
&lt;p&gt;面试官：嗯，回去等通知吧。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;今天主要将了 trie 树以及 trie 树的一些应用，还要就是如何通过 trie 树来实现敏感词的过滤，至于代码的实现，我这里就不给出了，在实现的时候，为了防止这种”麻 痹&quot;或者“麻￥痹”等，我们也要对特殊字符进行过滤等，有兴趣的可以去实现一波。&lt;/p&gt;
&lt;p&gt;今天也是第一次尝试采用这种对话的方式来写文章，可能写的没有平常的好，不过我会慢慢改进，希望大家多多支持。&lt;/p&gt;
&lt;blockquote readability=&quot;6.4939759036145&quot;&gt;
&lt;p&gt;最后推荐下我的公众号：苦逼的码农，主要分享一下技术文章、面试题、算法题，各种工具、视频资源等，里面已有100多篇原创文章，期待各路英雄来交流，点击即可扫码关注&lt;a href=&quot;https://qr.tschangcun.net/q/zsDeBp&quot;&gt;戳我即可关注&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 May 2019 14:01:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>版权声明：本文为 苦逼的码农 原创。未经同意禁止任何形式转载，特别是那些复制粘贴到别的平台的，否则，必定追究。欢迎大家多多转发，谢谢。 小秋今天去面试了，面试官问了一个与敏感词过滤算法相关的问题，然而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10834993.html</dc:identifier>
</item>
<item>
<title>gitbook 入门教程之解决windows热加载失败问题 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10834754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10834754.html</guid>
<description>&lt;h2 id=&quot;破镜如何贴花黄&quot;&gt;破镜如何贴花黄&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 在 &lt;code&gt;Windows&lt;/code&gt; 系统无法热加载,总是报错!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 是一款文档编写利器,可以方便地 &lt;code&gt;markdown&lt;/code&gt; 输出成美观优雅的 &lt;code&gt;html&lt;/code&gt; ,&lt;code&gt;gitbook serve&lt;/code&gt; 启动服务器后,原来相貌平平的 &lt;code&gt;markdown&lt;/code&gt; 丑小鸭摇身一变就成了倾国倾城的 &lt;code&gt;html&lt;/code&gt; 绝色佳人.&lt;/p&gt;
&lt;p&gt;如果源文件发生更改,&lt;code&gt;Windows&lt;/code&gt; 却无法按照预期那样重启服务器,直接抛出一个异常,立即终止了 &lt;code&gt;markdown&lt;/code&gt; 的化妆.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Restart after change in file README.md

Stopping server
events.js:183
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'F:\workspace\private-cloud-backup\gitbook-test\_book'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对镜贴花黄&quot;&gt;对镜贴花黄&lt;/h3&gt;
&lt;p&gt;现在看一下 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘变身 &lt;code&gt;html&lt;/code&gt; 小姐姐的神奇过程吧!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --log=debug
Live reload server started on port: 35729
Press CTRL+C to quit ...

debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
...
info: loading plugin &quot;theme-default&quot;... OK
info: found 1 pages
info: found 0 asset files
debug: calling hook &quot;config&quot;
debug: calling hook &quot;init&quot;
debug: copy assets from theme C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-theme-default\_assets\website
...
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-livereload\book
debug: generate page &quot;README.md&quot;
debug: calling hook &quot;page:before&quot;
debug: calling hook &quot;page&quot;
debug: index page README.md
debug: calling hook &quot;finish:before&quot;
debug: calling hook &quot;finish&quot;
debug: write search index
info: &amp;gt;&amp;gt; generation finished with success in 1.5s !

Starting server ...
Serving book on http://localhost:4000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上述输出日志,我们可以分析出 &lt;code&gt;gitbook&lt;/code&gt; 的基本运行流程.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载 &lt;code&gt;readme&lt;/code&gt; 和 &lt;code&gt;summary&lt;/code&gt; 文件,若存在 &lt;code&gt;glossary&lt;/code&gt; 文件也会加载,并删除 &lt;code&gt;_book&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;加载依赖插件,若没有找到相应插件会报错,提示运行 &lt;code&gt;gitbook install&lt;/code&gt; 安装插件.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
info: loading plugin &quot;highlight&quot;... OK
info: loading plugin &quot;search&quot;... OK
info: loading plugin &quot;lunr&quot;... OK
info: loading plugin &quot;sharing&quot;... OK
info: loading plugin &quot;fontsettings&quot;... OK
info: loading plugin &quot;theme-default&quot;... OK&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;扫描页面和静态资源文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;info: found 1 pages
info: found 0 asset files&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读取配置文件并初始化&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: calling hook &quot;config&quot;
debug: calling hook &quot;init&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拷贝样式资源和插件资源&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: copy assets from theme C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-theme-default\_assets\website
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-fontsettings\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-sharing\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-lunr\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-search\assets
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-highlight\css
debug: copy resources from plugin C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\gitbook-plugin-livereload\book&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;开始生成单独页面,依次执行 &lt;code&gt;page:before&lt;/code&gt; ,&lt;code&gt;page&lt;/code&gt; 回调函数,全部页面执行完毕后执行 &lt;code&gt;finish:before&lt;/code&gt; 和 &lt;code&gt;finish&lt;/code&gt; 回调函数.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: generate page &quot;README.md&quot;
debug: calling hook &quot;page:before&quot;
debug: calling hook &quot;page&quot;
debug: index page README.md
debug: calling hook &quot;finish:before&quot;
debug: calling hook &quot;finish&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成搜索文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: write search index&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动完毕,输出成功信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Starting server ...
Serving book on http://localhost:4000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下服务器启动后会占用两个端口,一个是对外暴露的 &lt;code&gt;4000&lt;/code&gt; 端口,用于浏览器访问项目.&lt;/p&gt;
&lt;p&gt;另外一个是 &lt;code&gt;35729&lt;/code&gt; 端口,用于监听本地文件变化,重启服务器进而实现热加载功能.&lt;/p&gt;
&lt;p&gt;本地服务器启动后我们就可以访问 &lt;code&gt;http://localhost:4000&lt;/code&gt; 预览静态网站效果,&lt;code&gt;markdown&lt;/code&gt; 源文件华丽演变成 &lt;code&gt;html&lt;/code&gt; 富文本文件.&lt;/p&gt;
&lt;h3 id=&quot;破镜怎化妆&quot;&gt;破镜怎化妆&lt;/h3&gt;
&lt;p&gt;不幸的是,&lt;code&gt;Windows&lt;/code&gt; 热加载可能会有问题,也就是说如果启动服务器后,本地文件发生改变,此时会触发热加载功能而报错 &lt;code&gt;Error: EPERM: operation not permitted&lt;/code&gt; ,这样一来浏览器又无法访问了.&lt;/p&gt;
&lt;p&gt;刚刚变身的 &lt;code&gt;markdown&lt;/code&gt; 瞬间又被打回原形,无法欣赏化妆后的容颜了,这样的体验相当不好!&lt;/p&gt;
&lt;p&gt;边化妆边照镜子才是做到心中有谱,随时调整,如果不照镜子而直接化妆,那不是一般人能做到的.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 启动本地服务器给我们提供了镜子,但热加载失败又把镜子摔碎了,还怎么愉快的化妆?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Restart after change in file README.md

Stopping server
debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;寻医问诊修破镜&quot;&gt;寻医问诊修破镜&lt;/h2&gt;
&lt;p&gt;现在问题已经复现,接下来就要开始寻医问诊,试图让破镜重圆,好让 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘变成人见人爱的 &lt;code&gt;html&lt;/code&gt; 小姐姐.&lt;/p&gt;
&lt;p&gt;根据报错信息描述,定位到删除 &lt;code&gt;_book&lt;/code&gt; 目录再次创建该目录时,提示 &lt;code&gt;EPERM: operation not permitted&lt;/code&gt; ,即无权操作.&lt;/p&gt;
&lt;h3 id=&quot;柯南附体&quot;&gt;柯南附体&lt;/h3&gt;
&lt;p&gt;既然说是操作权限的问题,那我们看一下 &lt;code&gt;_book&lt;/code&gt; 目录现在是怎样状态吧!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ ls
gitbook-errorforwindows-preview.png  README.md  SUMMARY.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前项目已经没有 &lt;code&gt;_book&lt;/code&gt; 目录,证明发生报错时确实已经删除了 &lt;code&gt;_book&lt;/code&gt; 目录,但是某种原因无权再次创建该文件夹而重启失败.&lt;/p&gt;
&lt;p&gt;然而,这只是表现现象,老师告诉我们,要透过现象看本质,即使现在没有 &lt;code&gt;_book&lt;/code&gt; 文件再次启动服务器还是会启动成功并创建 &lt;code&gt;_book&lt;/code&gt; 文件的,所以真想只有一个!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c2b30c8fb721e6e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-onlyonetruth.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那就是,&lt;code&gt;gitbook&lt;/code&gt; 控制台在说谎!&lt;/p&gt;
&lt;p&gt;虽然排除了 &lt;code&gt;gitbook&lt;/code&gt; 无权创建 &lt;code&gt;_book&lt;/code&gt; 目录的嫌疑,那又怎么解释重启服务器却没能创建 &lt;code&gt;_book&lt;/code&gt;目录这件事呢?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;debug: cleanup folder &quot;G:\sublime\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\snowdreams1006\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一下 &lt;code&gt;FSWatcher._handleError&lt;/code&gt; 异常信息: &lt;code&gt;sed -n &quot;223,239p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;分析发现: &lt;code&gt;FSWatcher._handleError&lt;/code&gt; 是私有方法,作用是处理异常信息,和这起事故关联不大.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ sed -n &quot;223,239p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/index.js
// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error &amp;amp;&amp;amp; error.code;
  var ipe = this.options.ignorePermissionErrors;
  if (error &amp;amp;&amp;amp;
    code !== 'ENOENT' &amp;amp;&amp;amp;
    code !== 'ENOTDIR' &amp;amp;&amp;amp;
    (!ipe || (code !== 'EPERM' &amp;amp;&amp;amp; code !== 'EACCES'))
  ) this.emit('error', error);
  return error || this.closed;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们接着往下找,再看一下 &lt;code&gt;ReaddirpReadable.emit (events.js:189:13)&lt;/code&gt; ,这里没有给出文件的具体路径,所以暂时无法定位.&lt;/p&gt;
&lt;p&gt;那我们再看下一个 &lt;code&gt;Immediate.&amp;lt;anonymous&amp;gt;&lt;/code&gt; : &lt;code&gt;sed -n &quot;78,96p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ sed -n &quot;78,96p&quot; ~/.gitbook/versions/3.2.3/node_modules/chokidar/node_modules/readdirp/stream-api.js
proto._handleFatalError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  });
}

function createStreamAPI () {
  var stream = new ReaddirpReadable();

  return {
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遗憾的是,仍然没有找到具体问题,那就继续看一下一条线索.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timers.js:705:18&lt;/code&gt; 和 &lt;code&gt;events.js:189:13&lt;/code&gt; 都没有显示具体的文件位置,如果也在 &lt;code&gt;chokidar&lt;/code&gt; 模块的话就好了.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ tree -P &quot;events.js&quot; --prune ~/.gitbook/versions/3.2.3/
/c/Users/Administrator/.gitbook/versions/3.2.3/
└── node_modules
    ├── cheerio
    │   └── node_modules
    │       └── jsdom
    │           └── lib
    │               └── jsdom
    │                   └── level2
    │                       └── events.js
    └── gitbook-plugin-theme-default
        └── src
            └── js
                └── core
                    └── events.js

11 directories, 2 files

Administrator@snowdreams1006 MINGW64 /f/workspace/private-cloud-backup/gitbook-test (master)
$ tree -P &quot;timers.js&quot; --prune ~/.gitbook/versions/3.2.3/
/c/Users/Administrator/.gitbook/versions/3.2.3/
0 directories, 0 files&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;git-bash&lt;/code&gt; 命令行正常没有 &lt;code&gt;tree&lt;/code&gt; 命令,如需扩展参考我另外一篇文章.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过肉眼验证,发现 &lt;code&gt;events.js&lt;/code&gt; 根本就没有 &lt;code&gt;174&lt;/code&gt; 行文件,所以这两个文件大都不是目标文件.&lt;/p&gt;
&lt;p&gt;既然命令行中无法找到目标文件,那就请专业的搜索工具全系统查找这两个文件吧,这里使用的是 &lt;code&gt;Everything&lt;/code&gt; 搜索工具.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-2a095ad83b8a6486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-everything-search.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然并卵,依然没有找到目标文件.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;毕竟不是柯南,没有发现真相&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-08ed138a63853ff1.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-errorforwindows-emoj-sad.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;求助官方&quot;&gt;求助官方&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 可是开源产品,出现问题的应该不止我一个,所以去 &lt;code&gt;github&lt;/code&gt; 看看有没有遇到和我一样的问题.&lt;/p&gt;
&lt;p&gt;虽然找到了志同道合的小伙伴,但是并没有提供解决方案,连官方都放弃了,那我还有什么可留恋的?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-790761d5835e8ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-errorforwindows-issue.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5116279069767&quot;&gt;
&lt;p&gt;点击查看 &lt;a href=&quot;https://github.com/GitbookIO/gitbook-cli/issues/67&quot;&gt;gitbook serve livereload error&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;自己动手&quot;&gt;自己动手&lt;/h3&gt;
&lt;p&gt;最害怕的不是 &lt;code&gt;bug&lt;/code&gt;,而是发现了 &lt;code&gt;bug&lt;/code&gt; 却无法定位,虽然控制台有报错信息但是没有找到真正的文件!&lt;/p&gt;
&lt;p&gt;首先确认下当前系统版本,然后采取版本切换方式测试其他版本是否存在该问题.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook --version
CLI version: 2.3.2
GitBook version: 3.2.3&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;升级到最新版&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;gitbook ls&lt;/code&gt; 是列出当前已安装的版本,而 &lt;code&gt;gitbook ls-remote&lt;/code&gt; 则是列出远程服务器版本.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 列出本地已安装版本
$ gitbook ls
GitBook Versions Installed:

    * 3.2.3

Run &quot;gitbook update&quot; to update to the latest version.

# 列出远程可用版本
$ gitbook ls-remote
Available GitBook Versions:

     4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1

Tags:

     latest : 2.6.9
     pre : 4.0.0-alpha.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前最新发布版本是 &lt;code&gt;3.2.3&lt;/code&gt; ,而我们本地已安装的版本正是该版本,所以现在应该测试 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版.&lt;/p&gt;
&lt;p&gt;看到 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 心里有些忐忑,根据版本管理约定,版本号一般有三部分组成,第一部分代表不兼容的重大升级,第二部分代表主干兼容的功能升级,第三部分是小版本修复.&lt;/p&gt;
&lt;p&gt;由 &lt;code&gt;3.2.3&lt;/code&gt; 直接跨度到 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 意味着 &lt;code&gt;gitbook&lt;/code&gt; 发生了重大重构!&lt;/p&gt;
&lt;p&gt;算了,先下载试试看!&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook fetch&lt;/code&gt; 下载 和 &lt;code&gt;gitbook update&lt;/code&gt;升级,两种方式都可以体验最新版本,这里选择下载方式方便进行不同版本的切换.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 下载 `4.0.0-alpha.6` 版本
$ gitbook fetch 4.0.0-alpha.6
Installing GitBook 4.0.0-alpha.6
gitbook@4.0.0-alpha.6 C:\Users\SNOWDR~1\AppData\Local\Temp\tmp-8912hSrxNvTCrFEH\node_modules\gitbook
├── escape-html@1.0.3
├── escape-string-regexp@1.0.5
├── destroy@1.0.4
├── ignore@3.1.2
└── ied@2.3.6 (lodash.memoize@4.1.2, lodash.frompairs@4.0.1, force-symlink@0.0.2, semver@5.7.0, minimist@1.2.0, node-uuid@1.4.8, npm-package-arg@4.2.1, source-map-support@0.4.18, ora@0.2.3, easy-table@1.1.1, rimraf@2.6.3, tar-fs@1.16.3, gunzip-maybe@1.4.1, init-package-json@1.10.3, rxjs@5.0.0-rc.1, needle@1.0.0, node-pre-gyp@0.6.39, node-gyp@3.8.0)

GitBook 4.0.0-alpha.6 has been installed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一下本地安装 &lt;code&gt;gitbook&lt;/code&gt; 版本,确保待会运行时使用最新的 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版本.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 列出本地已安装版本
$ gitbook ls
GitBook Versions Installed:

    * 4.0.0-alpha.6
      3.2.3

Run &quot;gitbook update&quot; to update to the latest version.

# 列出当前正在使用版本
$ gitbook current
GitBook version is 3.2.3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;gitbook serve --gitbook=4.0.0-alpha.6 --log=debug&lt;/code&gt; 运行 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; 版本并打印 &lt;code&gt;debug&lt;/code&gt; 级别日志.&lt;/p&gt;
&lt;p&gt;意外的是,竟然没有连启动都没启动成功,提示无法打开 &lt;code&gt;~\.gitbook\versions\4.0.0-alpha.6\node_modules\gitbook-plugin-livereload\_assets\plugin.js&lt;/code&gt; 文件.&lt;/p&gt;
&lt;p&gt;回想到版本号规范,可能 &lt;code&gt;v3&lt;/code&gt; 到 &lt;code&gt;v4&lt;/code&gt; 更改比较大,版本不兼容吧,重新初始化项目试试看!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 初始化项目并指定 `gitbook` 运行版本
$ gitbook init --gitbook=4.0.0-alpha.6
Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in  React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs
info: create SUMMARY.md
info: initialization is finished&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而,仍然还是同样的报错,依旧无法启动.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --gitbook=4.0.0-alpha.6 --log=debug                             Warning: Accessing PropTypes via the main React package is deprecated, and will be removed in  React v16.0. Use the latest available v15.* prop-types package from npm instead. For info on usage, compatibility, migration and more, see https://fb.me/prop-types-docs
Live reload server started on port: 35729
Press CTRL+C to quit ...

...

Error: ENOENT: no such file or directory, open 'C:\Users\snowdreams1006\.gitbook\versions\4.0.0-alpha.6\node_modules\gitbook-plugin-livereload\_assets\plugin.js'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此路不通,再换一条,既然向上无法处理,那向下回退会不会有结果呢?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回退版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当前系统版本是 &lt;code&gt;3.2.3&lt;/code&gt;,最新测试版本是 &lt;code&gt;4.0.0-alpha.6&lt;/code&gt; ,然而最近一次提交的版本却是 &lt;code&gt;2.6.9&lt;/code&gt; ?&lt;/p&gt;
&lt;p&gt;为什么 &lt;code&gt;gitbook-ci&lt;/code&gt; 管理的 &lt;code&gt;gitbook&lt;/code&gt; 版本号会突然跳水,会不会有什么猫腻,难不成修复了什么 &lt;code&gt;bug&lt;/code&gt; ?&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook ls-remote
Available GitBook Versions:

     4.0.0-alpha.6, 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.3, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.9, 2.6.8, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1, 2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2, 2.0.0-alpha.1

Tags:

     latest : 2.6.9
     pre : 4.0.0-alpha.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;带着这些疑问,不妨下载 &lt;code&gt;2.6.9&lt;/code&gt; 版本试试,看一下能否热加载?&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook serve --log=debug --gitbook=2.6.9&lt;/code&gt; 指定 &lt;code&gt;gitbook&lt;/code&gt; 版本,依旧失败!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ gitbook serve --log=debug --gitbook=2.6.9
Error loading version latest: Error: Cannot find module 'q'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:582:15)
    at Function.Module._load (internal/modules/cjs/loader.js:508:25)
    at Module.require (internal/modules/cjs/loader.js:637:17)
    at require (internal/modules/cjs/helpers.js:22:18)
    at Object.&amp;lt;anonymous&amp;gt; (C:\Users\myHome\.gitbook\versions\2.6.9\lib\index.js:3:9)
    at Module._compile (internal/modules/cjs/loader.js:701:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)
    at Module.load (internal/modules/cjs/loader.js:600:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)
    at Function.Module._load (internal/modules/cjs/loader.js:531:3)

TypeError: Cannot read property 'commands' of null&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重回现场&quot;&gt;重回现场&lt;/h3&gt;
&lt;p&gt;现在把目光再次聚焦到最初的案发现场,这一次只能背水一战了,自己动手要么丰衣足食要么饿死冻死!&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Stopping server
debug: readme found at README.md
debug: summary file found at SUMMARY.md
debug: cleanup folder &quot;G:\sublime\private-cloud-backup\gitbook-test\_book&quot;
events.js:174
      throw er; // Unhandled 'error' event
      ^

Error: EPERM: operation not permitted, lstat 'G:\sublime\private-cloud-backup\gitbook-test\_book'
Emitted 'error' event at:
    at FSWatcher._handleError (C:\Users\myHome\.gitbook\versions\3.2.3\node_modules\chokidar\index.js:236:10)
    at ReaddirpReadable.emit (events.js:189:13)
    at Immediate.&amp;lt;anonymous&amp;gt; (C:\Users\myHome\.gitbook\versions\3.2.3\node_modules\chokidar\node_modules\readdirp\stream-api.js:82:32)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于上述错误描述中,在&lt;strong&gt;真相只有一个&lt;/strong&gt;章节中已经探讨过,当时得出的结论是 &lt;code&gt;gitbook&lt;/code&gt; 是删除 &lt;code&gt;_book&lt;/code&gt; 文件夹再新建 &lt;code&gt;_book&lt;/code&gt; 文件夹时发生了意外.&lt;/p&gt;
&lt;p&gt;如果这个行为不是由 &lt;code&gt;gitbook&lt;/code&gt; 发生而是由我们手动干预的话,也就是说,当成功启动本地服务器后并在即将发生热加载之前,此时人为删除 &lt;code&gt;_book&lt;/code&gt; 文件夹,会发生什么?&lt;/p&gt;
&lt;p&gt;我的猜想是:&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;gitbook&lt;/code&gt; 的热加载机制是监听本地文件目录系统发生改变,进而停止服务器再重新启动服务器.&lt;/p&gt;
&lt;p&gt;当我们手动删除了 &lt;code&gt;_book&lt;/code&gt; 文件夹,对于 &lt;code&gt;gitbook&lt;/code&gt; 来说,再触发重启服务器的那一刻来说,突然发现没有 &lt;code&gt;_book&lt;/code&gt; 文件夹,此时就不会删除也不会新建时发生异常,相当于直接新建 &lt;code&gt;_book&lt;/code&gt; 文件夹,变相把&lt;strong&gt;热加载&lt;/strong&gt;弄成了&lt;strong&gt;初始启动&lt;/strong&gt;模式!&lt;/p&gt;
&lt;p&gt;希望苍天不负我,如若不行,只能看源码逻辑找 &lt;code&gt;bug&lt;/code&gt; 了!&lt;/p&gt;
&lt;p&gt;你猜猜会怎么样? &lt;code&gt;it works&lt;/code&gt; !&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-7e5df990d64afa29.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-errorforwindows-rm_book.gif&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在实验中,&lt;code&gt;gitbook serve --log=debug&lt;/code&gt; 启动本地服务器后,如果本地文件发生修改会重启失败!&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;但是,如果在启动本地服务器后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录,当本地文件发生修改时重启服务就能成功了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此为止,总算找到一个解决方案,那就是启动服务后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录.&lt;/p&gt;
&lt;h2 id=&quot;不算完美的总结&quot;&gt;不算完美的总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;windows&lt;/code&gt; 系统上启动 &lt;code&gt;gitbook&lt;/code&gt; 服务后,如果本地文件发生更改,热加会失败.&lt;/p&gt;
&lt;p&gt;如果启动服务器后立即删除 &lt;code&gt;_book&lt;/code&gt; 目录,那么之后再怎么修改本地文件都能顺利重启.&lt;/p&gt;
&lt;p&gt;目前还没有找到问题的根源,下一次将深入源码继续探讨到底是哪里出问题导致 &lt;code&gt;Windows&lt;/code&gt; 系统无法重启.&lt;/p&gt;
&lt;p&gt;虽然及时删除 &lt;code&gt;_book&lt;/code&gt; 目录并不算是很好的解决方案,但至少 &lt;code&gt;markdown&lt;/code&gt; 灰姑娘又能化妆成 &lt;code&gt;html&lt;/code&gt; 小姐姐了呢!&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 13:23:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>破镜如何贴花黄 在 系统无法热加载,总是报错! 是一款文档编写利器,可以方便地 输出成美观优雅的 , 启动服务器后,原来相貌平平的 丑小鸭摇身一变就成了倾国倾城的 绝色佳人. 如果源文件发生更改, 却</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10834754.html</dc:identifier>
</item>
<item>
<title>大白话5分钟带你走进人工智能-第二十三节决策树系列之特点和数学表达形式(2) - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/10834580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/10834580.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                                                                                                             第二十三节决策树系列之特点和数学表达形式(2)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上节我们讲解了决策树的概念，本节的话我们讲解决策树的特点以及其数学表达形式。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;main-toc&quot;&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;1-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10834580.html#1-决策树的特点&quot; data-cke-saved-href=&quot;#1-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9&quot;&gt;1-决策树的特点&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10834580.html#       %202-决策树的数学表达形式&quot; data-cke-saved-href=&quot;#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F&quot;&gt;2-决策树的数学表达形式&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr id=&quot;hr-toc&quot;/&gt;&lt;h3 id=&quot;1-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9&quot;&gt;&lt;span&gt;1-决策树的特点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;决策树的特点大致有以下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、可以处理非线性问题&lt;/strong&gt;。逻辑回归处理非线性问题有一些捉襟见肘，没有特别完善的方法能解决，我们有若干种妥协的方法来让它凑合能用，而决策树天生就可以处理非线性问题。假设在一个二维的平面上，有若干数据如图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每一个数据有两个维度，x1和x2。总共9个数据点。如果我们想用逻辑回归来分类，无论怎么分，都找不到一条很好地直线将图中点分开。假设我们用决策树分裂的话，第一次分裂选择条件是x＜3，相当于画一条竖线，所有x＜3的都分到左边，x＞3分到右边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分到左边的都是O点，分到右边的有一半是O点一半是X点，给它落成一个叶子节点不太合适，就需要再次分裂，再选择分裂条件是x＜6，就将数据完美的分开了。我们的决策树的分裂图如图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原来逻辑回归处理不了的非线性问题，决策树轻而易举的就把它们分开了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再比如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数据点如图，想把蓝色，红色的数据点分开，同样的线性不可分，而决策树却可以会画出一个波浪线，把数据分开，相当于每一个折点部分就多出分裂一个条件。所以说通过决策树不断分裂的方式，可以处理各种各样的非线性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、可解释性强。&lt;/strong&gt;从数据集上抓到一个算法，生成出来一个模型，逻辑回归模型的本质，记在计算机里面的是一组w，训练出来这个模型是个一组数，它没有具体的物理含义。比如0.8和 0.7，怎么解释这两个w到底差别在哪？说不太清，可解释性差一些，机器到底学少什么你不知道。而&lt;strong&gt;决策树算法，记录下来的是一组分类条件&lt;/strong&gt;，相比一组w来说，它的可解释性是要强不少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;          3、 决策树的模型非常简单&lt;/strong&gt;。它不需要借助函数最优化工具，在原生的决策树里面是没有损失函数这个概念的。决策树其实特别像森林球，某一条数据顺根节点、分支节点下来，最后落到某一个叶子节点上。它这个模型相对于梯度下降的训练过程中是比较简单的，预测就更简单了，直接跑一遍if…else，最后该是谁就是谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;strong&gt;    4、缺点 不容易显示地使用函数表达，不可微&lt;/strong&gt;。可能带来一个问题是不好给它加正则项，正则项是用来评估模型简单程度的。原来的损失函数，给它加一个L1正则，组成了一个新的形式函数叫obj，原本是让L损失函数最小，现在要变成让它们俩合obj最小。为什么加上它效果就能好？在算法模型里边是通过这L1和L2两个指标来评估模型到底是简单还是复杂的。如果有更简单的方式能得到更好的模型，当然要优先简单的，因为复杂模型容易过拟合，这也就是正则存在的意义。但是决策树很难加这种正则表达式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202-%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F&quot;&gt;&lt;span&gt;2-决策树的数学表达形式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;决策树虽然不容易显示地使用函数表达，非得要表达的话，我们有两种方式表达。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;           第一种是从路径的角度（Path View），将每个从根到叶子的路径作为一个假设 g，通过不同的条件组合得到最后的 G (X)。&lt;br/&gt;           第二种是从递归的角度（Recursive View），父树是由子树递归定义的 &lt;code&gt;tree=(root,sub-trees)&lt;/code&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、我们先说第一种从路径的角度：&lt;/strong&gt;表达如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                 &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24G%28%5Cmathbf%7Bx%7D%29%3D%5Csum_%7Bt%3D1%7D%5E%7BT%7D%20q_%7Bt%7D%28%5Cmathbf%7Bx%7D%29%20%5Ccdot%20g_%7Bt%7D%28%5Cmathbf%7Bx%7D%29%24&quot; alt=&quot;$G(\mathbf{x})=\sum_{t=1}^{T} q_{t}(\mathbf{x}) \cdot g_{t}(\mathbf{x})$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24G%28%5Cmathbf%7Bx%7D%29%3D%5Csum_%7Bt%3D1%7D%5E%7BT%7D%20q_%7Bt%7D%28%5Cmathbf%7Bx%7D%29%20%5Ccdot%20g_%7Bt%7D%28%5Cmathbf%7Bx%7D%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面G(x)是一个函数，对于&lt;strong&gt;函数我们永远就把它理解成一个机器，你给我一个原材料，我给你生产一个东西。&lt;/strong&gt;所以这里面的G(x)也不例外，对于决策树来说一般是做分类的，所以我们可以想到这个函数G(x)其实就代表着你给我一个X，我给你一个分类结果。所以G代表着这棵已经生成好的决策树，X代表着扔进去的一个原数据。而函数后面的表达式代表我这个机器如何工作的，如何从已知得到结果的，是表达式记录的信息。我们看到后面是个连加符号，给它拆解出来就是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24G%28x%29%3Dq_%7B1%7D%28x%29%5Ccdot%20g_%7B1%7D%28x%29&amp;amp;plus;q_%7B2%7D%28x%29%5Ccdot%20g_%7B2%7D%28x%29&amp;amp;plus;q_%7B3%7D%28x%29%5Ccdot%20g_%7B3%7D%28x%29%24&amp;amp;plus;...&amp;amp;plus;q_%7BT%7D%28x%29%5Ccdot%20g_%7BT%7D%28x%29%24%24&quot; alt=&quot;$G(x)=q_{1}(x)\cdot g_{1}(x)+q_{2}(x)\cdot g_{2}(x)+q_{3}(x)\cdot g_{3}(x)$+...+q_{T}(x)\cdot g_{T}(x)$$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24G%28x%29%3Dq_%7B1%7D%28x%29%5Ccdot%20g_%7B1%7D%28x%29&amp;amp;plus;q_%7B2%7D%28x%29%5Ccdot%20g_%7B2%7D%28x%29&amp;amp;plus;q_%7B3%7D%28x%29%5Ccdot%20g_%7B3%7D%28x%29%24&amp;amp;plus;...&amp;amp;plus;q_%7BT%7D%28x%29%5Ccdot%20g_%7BT%7D%28x%29%24%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;               &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是什么意思呢？比如下图的决策树，我把叶子节点编号如图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里面&lt;strong&gt;q代表所有决策树的路径&lt;/strong&gt;，比如我们的X是qutitingtime&amp;lt;17:00 并且没有约会，那么在上述决策树存在的情况下，这个数据会落到2号节点，&lt;strong&gt;能够通往几号节点的路径就叫几号路径&lt;/strong&gt;，所以X扔进来的情况下，会通往2号路径，所以我们定义此时的X只有q(2)x=1，其他路径都为0，即q(1)x=0,q(3)x=0...。所以&lt;strong&gt;我们qt是定义出来的，代表着x是不是在第t号路径上，is x on path t。gt(x)代表某一号叶子节点的表达，&lt;/strong&gt;比如这里的X，落在2号节点上，所以表达为Y，也就是说以后甭管X是什么样，只要落在2号节点上，就写成Y，&lt;strong&gt;因此qt(x).gt(x)就是代表来一条数据，先是通过qt(x)看看落在哪个叶子节点上，然后再通过gt(x)看看这个叶子结点的表达是什么，我们就返回什么（Y 或者N），简直就是一个很无聊的表达，并且表达的很简单。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面公式表达的前提就是树已经存在了，它的判别函数怎么表达。&lt;/strong&gt;所以还是针对上述落在2号节点的X，我们针对上面的决策树把连加符号拆解出来就是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24G%28x%29%3D0%5Ccdot%20g_%7B1%7D%28x%29&amp;amp;plus;1%20%5Ccdot%20g_%7B2%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B3%7D%28x%29%24&amp;amp;plus;0%5Ccdot%20g_%7B4%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B5%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B6%7D%28x%29%24%24&quot; alt=&quot;$G(x)=0\cdot g_{1}(x)+1 \cdot g_{2}(x)+0\cdot g_{3}(x)$+0\cdot g_{4}(x)+0\cdot g_{5}(x)+0\cdot g_{6}(x)$$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24G%28x%29%3D0%5Ccdot%20g_%7B1%7D%28x%29&amp;amp;plus;1%20%5Ccdot%20g_%7B2%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B3%7D%28x%29%24&amp;amp;plus;0%5Ccdot%20g_%7B4%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B5%7D%28x%29&amp;amp;plus;0%5Ccdot%20g_%7B6%7D%28x%29%24%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为只有2号节点的q2(x)=1，其他都为0。这里面的点乘代表着对应关系，并不是真正的乘。T代表第几号叶子结点即叶子节点的序号。&lt;strong&gt;gt(x)是一个base hyponthesis 基础的假设&lt;/strong&gt;，这里就是假设我所有的叶子结点的表达的形式是Y还是N，是一个常数。因为这里面gt(x)的值只有Y或者N。不是取决于X的输入，而是取决于我当前落在第几号节点，g(1)(x)就是N，g(2)X就是Y。所以总结如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                        &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24G%28%5Cmathbf%7Bx%7D%29%3D%5Csum_%7Bc%3D1%7D%5E%7BC%7D%5Bb%28%5Cmathbf%7Bx%7D%29%3Dc%5D%20%5Ccdot%20G_%7Bc%7D%28%5Cmathbf%7Bx%7D%29%24&quot; alt=&quot;$G(\mathbf{x})=\sum_{c=1}^{C}[b(\mathbf{x})=c] \cdot G_{c}(\mathbf{x})$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24G%28%5Cmathbf%7Bx%7D%29%3D%5Csum_%7Bc%3D1%7D%5E%7BC%7D%5Bb%28%5Cmathbf%7Bx%7D%29%3Dc%5D%20%5Ccdot%20G_%7Bc%7D%28%5Cmathbf%7Bx%7D%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通过下面举例解释下上面公式：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实际上上面是个递归的表达形式。比如对于根节点(qutting time )来说，有3个子节点，如图所示。对于1号子节点的根(has a date)来说有两个子节点 N或者Y。还是拿上面X是qutitingtime&amp;lt;17:00 并且没有约会的例子来说，从根节点下来会落到1号子节点，这里面的b(x)是分支的条件，这个例子中b(x)=1 ，C代表几个子节点，而对于qutting time的根节点来说，有3个子节点，所以C=3。落在几号节点上，只有当前子节点为1，其他都为0，所以对于这里只有G1(x)=1。当落到1号节点之后，继续往下走，同理接着遍历，会落到1号子节点中的Y子节点上，同理对于 has a date 作为根节点来说，C=2，因为落在Y子节点上，此时是叶子结点，不在遍历，所以向上依次返回最终结果Y。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下一节我们讲解决策树的分裂流程以及分裂条件的评估。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 12:52:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>第二十三节决策树系列之特点和数学表达形式(2) 上节我们讲解了决策树的概念，本节的话我们讲解决策树的特点以及其数学表达形式。 目录 1-决策树的特点 2-决策树的数学表达形式 1-决策树的特点 决策树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/10834580.html</dc:identifier>
</item>
<item>
<title>链接的思考 - kangheng</title>
<link>http://www.cnblogs.com/kangheng/p/10821754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangheng/p/10821754.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;最近做一些工程，经常遇到链接错误，为此翻阅了相关的资料，梳理了一下编译链接的流程和原理。编程语言分为编译型和解释型，编译型语言是用编译器将高级语言翻译成计算机可执行的低级语言；而解释型语言是使用解释器是将低级语言“提升”成高级语言。解释型语言一次执行一句，缺少程序的全局信息，解释器中包含大量的“if”“else”判断，因此速度较慢，但是一次执行一句的方式却增加了语言灵活性，直观来说python使用起来比c++方便多了吧；而编译型语言，需要将程序整体进行编译，编译器知道程序的全局信息，可以省略一些“if”、“else”的判断。所以编译型语言比解释型语言使用麻烦些，但是执行速度却要快得多。C/C++ 就属于编译型语言，一个大的C/C++工程往往由大量的源代码文件组成，这些源代码通过编译后会得到一个个“.o”的“零部件”（可重定位文件），而工程中的“.h”文件就像是这些零部件的连接指南，链接器的工作就是将“零部件”通过“.h”.文件组装成可执行文件。有时候这些“零部件”太多了，将这些相关的“零部件”放在一起就组成了一个库（.lib or .a）,“零部件”组合起来生成一个库文件的过程我们就叫做“打包”。&lt;br/&gt;那么链接器如何将这些“零部件”组装起来呢？其实每个“零部件”（可重定位文件）都有许多对外显示的“名字”（例如函数名字，全局变量），这些名字就是这个“零部件”对外的“触角”，有的名字是这个零部件定义好了的，而另一些名字是这个“零部件”内没有定义的，链接器要做的就是要将不同零部件的未定义的名字与其他零部件已定义的名字关联上，就能得到一个可执行的文件。&lt;/p&gt;
&lt;h3 id=&quot;一个实例&quot;&gt;一个实例&lt;/h3&gt;
&lt;p&gt;现在举一个简单的c语言例子来说明，这个程序非常简单分别有main.c、function1.h、function1.c、function2.h、function2.c、function3.h、function3.c、function31.h、function31.c、function32.h、function32.c 几个文件，各个文件中代码如下：&lt;/p&gt;
&lt;p&gt;main.c:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function1.h&quot;
#include &quot;function2.h&quot;
#include &quot;function3.h&quot;
extern int i;
int main()
{
    printf(&quot;%d\n&quot;,i);
    function1();
    function2();
    function3();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function1.h:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void function1();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function1.c:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function1.h&quot;
void function1()
{
    printf(&quot;function1\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function2.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void function2();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function2.c&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function2.h&quot;
void function2()
{
    printf(&quot;function2\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function3.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void function3();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function3.c&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function3.h&quot;
#include &quot;function31.h&quot;
#include &quot;function32.h&quot;

int i = 123;
void function3()
{
    function31();
    function32();
    printf(&quot;function3\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function31.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void function3();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function31.c&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function31.h&quot;
void function31()
{
    printf(&quot;function31\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function32.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void function32();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;function32.c&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function32.h&quot;
void function32()
{
    printf(&quot;function32\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到main.c分别引用了function1.c 、function2.c、function3.c中的函数，而function3.c中又引用了function31.c和function32.c的函数，它们之间通过各自的.h文件和#include引用“粘合”在一起。&lt;br/&gt;现在我们通过&lt;code&gt;gcc -c main.c function1.c function2.c function3.c function31.c function32.c&lt;/code&gt;命令编译出各个.c文件对应的.o文件(可重定位文件)，这些.o文件是我们可执行文件的零部件。链接的工作是将这些零部件“拼装”起。上文说了链接器是将不同零部件的名字对应上实现链接。在linux中可以通过&lt;code&gt;nm&lt;/code&gt;命令查看零部件的名字。例如我们要看main.o的名字，使用&lt;code&gt;gcc -c main.o&lt;/code&gt;，结果如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                 U function1
                 U function2
                 U function3
                 U i
0000000000000000 T main
                 U printf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中标志U代表未定义的符号，链接器要把这些未定义的名字在其他零部件.o文件中或者零部件的集合——库文件中对应上才能实现链接，生成可执行文件。我们再看看function3.o的名字&lt;code&gt;gcc -c function3.o&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000000000000000 T function3
                 U function31
                 U function32
0000000000000000 D i
                 U puts
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和预料中的一样吧，可以看出main.o 中未定义的function3 和 i 都能在function3.o中找到。接下我们利用这些“零部件”生成可执行文件&lt;code&gt;gcc -o main *.o&lt;/code&gt;，可以看出程序没有报错，并且正常执行。&lt;br/&gt;现在我们再试一下我们故意将function2.c中的function2 改成functionX：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;function2.h&quot;
void functionX()
{
    printf(&quot;function2\n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们重新进行之前的实验，这次能够成功编译生成.o文件，但是连接时出现如下错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main.o: In function `main':
main.c:(.text+0x2b): undefined reference to `function2'
collect2: error: ld returned 1 exit status&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出这次连接器报错，在main.o中未定义的function2在其他零部件中找不到对应名字。&lt;/p&gt;
&lt;h3 id=&quot;示意图&quot;&gt;示意图&lt;/h3&gt;
&lt;p&gt;以下对上述简单例子的直观示意图&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译的过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534176/201905/1534176-20190506201441069-85473518.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;链接的过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534176/201905/1534176-20190506201453634-9034048.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;
&lt;p&gt;这篇文章是对链接过程的直观思考，写得并不严谨，但希望能对读者有所启发，主要参考了《深入理解计算机系统》《c专家编程》两本书。仔细想来这种将一个大的工程分解成一个个的“零部件”的做法在现实中也是广泛存在的，比如飞机、汽车这些复杂的机器哪个不是由零部件组成的？试想使用板钢一块制造一辆汽车其难度得有多大。所以链接器的存在也是合情合理。&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 11:25:00 +0000</pubDate>
<dc:creator>kangheng</dc:creator>
<og:description>引言 最近做一些工程，经常遇到链接错误，为此翻阅了相关的资料，梳理了一下编译链接的流程和原理。编程语言分为编译型和解释型，编译型语言是用编译器将高级语言翻译成计算机可执行的低级语言；而解释型语言是使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangheng/p/10821754.html</dc:identifier>
</item>
<item>
<title>企业级SpringBoot与Dubbo的并用 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10833555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10833555.html</guid>
<description>&lt;p&gt;企业级SpringBoot与Dubbo的并用&lt;br/&gt;SpringBoot越来越热门以至于达到烂大街可见的程度，而Dubbo这个基于二进制的微服务框架又捐献给Apache孵化，如果不会如何使用那么是不是很不好意思呢？&lt;br/&gt;这次从公司的项目中抽一个小列子来熟悉下如果从零构建，至于深入了解-&amp;gt;传送门:&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/quick-start.html&quot;&gt;Dubbo官方中文手册&lt;/a&gt;&lt;br/&gt;版本:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Springboot2.x&lt;/li&gt;
&lt;li&gt;Double2.6&lt;/li&gt;
&lt;li&gt;Zk3.4.14&lt;/li&gt;
&lt;li&gt;JDK8&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里就不介绍Dubbo了，传送去看看以前的：&lt;a href=&quot;https://www.cnblogs.com/SimpleWu/p/9769797.html&quot;&gt;互联网级微服务架构神器Duubo&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;zookeepr安装&quot;&gt;zookeepr安装&lt;/h4&gt;
&lt;p&gt;下载去官网查找稳定的版本进行使用:http://www.apache.org/dyn/closer.cgi/zookeeper/&lt;br/&gt;先在服务器上安装zookeeper。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /usr/local/src/
#下载
sudo wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz
#解压
tar -zxvf zookeeper-3.4.14.tar.gz
#修改配置文件名称
mv conf/zoo_sample.cfg zoo.cfg
#启动zk
./bin/zkServer.sh start
#出现以下字样代表启动成功，默认端口2181
Starting zookeeper ... STARTED&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;springboot2.x整合dubbo&quot;&gt;SpringBoot2.x整合Dubbo&lt;/h4&gt;
&lt;h5 id=&quot;父工程搭建pom工程&quot;&gt;父工程搭建(pom工程)&lt;/h5&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;yun-double&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
&amp;lt;name&amp;gt;yun-double&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;double&amp;lt;/description&amp;gt;

&amp;lt;!--统一管理依赖版本--&amp;gt;
&amp;lt;properties&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;double.version&amp;gt;2.0.0&amp;lt;/double.version&amp;gt;
    &amp;lt;zkclient.version&amp;gt;0.10&amp;lt;/zkclient.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;!-- 依赖于SpringBoot --&amp;gt;
&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;!--依赖定义--&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${double.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${zkclient.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建公共接口工程common&quot;&gt;创建公共接口工程common&lt;/h5&gt;
&lt;p&gt;该工程用于存储服务层接口，以减少代码的冗余。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;yun-double&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;common&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;

&amp;lt;name&amp;gt;common&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;公共接口&amp;lt;/description&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建公共接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface UserService {

    String getUserById(int id);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建服务提供者provider&quot;&gt;创建服务提供者(provider)&lt;/h5&gt;
&lt;p&gt;Pom文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

&amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;provider&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

&amp;lt;name&amp;gt;provider&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;生产者&amp;lt;/description&amp;gt;


&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;yun-double&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- SpringBoot快速启动Duubbo --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.spring.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Zk客户端依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;!-- 排除依赖里的日志 --&amp;gt;
        &amp;lt;exclusions&amp;gt;
            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;

            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;

            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 导入公共接口依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;common&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在pom文件中我们需要引入Dubbo,Zk客户端并且引入公共接口工程&lt;br/&gt;application.properties配置文件&lt;/p&gt;
&lt;pre class=&quot;propertiies&quot;&gt;
&lt;code&gt;#dubbo.application.name 应用名称
#dubbo.registry.address 注册中心地址
#dubbo.protocol.name 协议名称
#dubbo.protocol.port 协议端口
#dubbo.scan dubbo 服务类包目录
#server.port=8080
spring.application.name=user-pro
dubbo.application.name=user-provider1
dubbo.registry.address=zookeeper://192.168.197.133:2181
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里dubbo.application.name应用名称一定不能重复&lt;br/&gt;实现UserService&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Service(timeout = 10000,interfaceClass = UserService.class)
public class UserServiceImpl implements UserService {

    @Override
    public String getUserById(int id) {
        if(id == 1) {
            return &quot;SimpleWu&quot;;
        }else {
            return &quot;Apache Dubbo&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@Service 这个注解使用的不是Spring里面的而是com.alibaba.dubbo.config.annotation.Service&lt;br/&gt;timeout 配置超时时间&lt;br/&gt;interfaceClass 接口类&lt;br/&gt;version 服务版本，如果配置了服务版本在消费端引用也必须一样，具体等会说&lt;br/&gt;创建启动类&lt;br/&gt;在该工程中我们不需要引入Web模块浪费端口号，只需要这样写启动类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDubbo
@EnableDubboConfiguration
@DubboComponentScan(&quot;com.simple.springboot.provider.common.impl&quot;)
public class ProviderApplication {

    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(ProviderApplication.class);
        app.run(args);
        //dubbo Main独立运行，脱离web容器
        Main.main(args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@EnableDubbo 启动Dubbo功能&lt;br/&gt;@EnableDubboConfiguration 启动Duubbo配置&lt;br/&gt;@DubboComponentScan &lt;strong&gt;扫描提供者实现类&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建服务消费者consumer&quot;&gt;创建服务消费者(consumer)&lt;/h5&gt;
&lt;p&gt;POM文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;


&amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;consumer&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;


&amp;lt;name&amp;gt;consumer&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;消费者&amp;lt;/description&amp;gt;

&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;yun-double&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- SpringBoot快速启动Duubbo --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.spring.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Zk客户端依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;!-- 排除依赖里的日志 --&amp;gt;
        &amp;lt;exclusions&amp;gt;
            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;

            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;

            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 导入公共接口依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.simple.springboot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;common&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个工程中我们是需要依赖Web的，不然咋访问呢&lt;br/&gt;编写Application.properties配置文件&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.application.name=user-con
server.port=8080
dubbo.application.name=user-consumer
dubbo.registry.address=zookeeper://192.168.197.133:2181
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
#dubbo.scan=com.simple.springboot.provider.common.impl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里dubbo.application.name应用名称一定不能重复&lt;br/&gt;dubbo.scan 该配置指向应该是要和服务提供方一致&lt;br/&gt;编写Controller&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class UserController {

    //timeout 可以不指定，如果提供则有填写但是version一定要指定 不然会找不到服务 直连需要加url=&quot;dubbo://localhost:20880&quot;
    @Reference
    private UserService userService;

    @GetMapping(&quot;/dubbo/user/{id}&quot;)
    public String getUserById(@PathVariable int id){
        return userService.getUserById(id);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里是使用@Reference去发现服务而不是@Autowired去注入Bean&lt;br/&gt;@Reference 里面可以配置version,timeout超时时间&lt;br/&gt;如果需要Dubbo直连url=&quot;dubbo://localhost:20880&quot;&lt;/p&gt;
&lt;p&gt;dubbo提供了四种负载均衡策略,分别是：&lt;br/&gt;1、Random LoadBalance 按权重的随机负载均衡,也是dubbo默认的负载均衡策略&lt;br/&gt;2、RoundRobin LoadBalance 按权重的轮询负载均衡,即在轮询的基础上添加了权重的策略&lt;br/&gt;3、LeastActive LoadBalance 最少活跃调用数,相同活跃数的随机访问,活跃数指调用前后的计数差即响应时间的长短;这种策略可以使响应慢的提供者收到的请求较少,大大提供系统性能&lt;br/&gt;4、ConsistentHash LoadBalance 一致性哈希；相同参数的请求总是发到同一提供者&lt;/p&gt;
&lt;p&gt;负载均衡的配置：@Reference(loadbalance = &quot;roundrobin&quot;)，loadbalance 的值即为四种负载均衡的名称,全部小写&lt;/p&gt;
&lt;p&gt;在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。下面列举dubbo支持的容错策略：&lt;/p&gt;
&lt;p&gt;1、Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;XXX&quot; 来设置重试次数(不含第一次)。&lt;br/&gt;2、Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。&lt;br/&gt;3、Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。&lt;br/&gt;4、Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。&lt;br/&gt;5、Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。&lt;br/&gt;6、Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。&lt;/p&gt;
&lt;p&gt;配置如下：@Reference(cluster = &quot;failsafe&quot;)这里表示使用失败安全的容错策略&lt;/p&gt;
&lt;p&gt;编写启动类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author:SimpleWu
 * @date: 2019-05-08
 */
@EnableDubbo
@SpringBootApplication
@EnableDubboConfiguration
@DubboComponentScan(&quot;com.simple.springboot.provider.common.impl&quot;)
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class,args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后直接就可以访问成功了。&lt;br/&gt;如果不想使用注解扫描可以使用properties进行配置&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;#dubbo.scan=com.simple.springboot.provider.common.impl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考代码：&lt;a href=&quot;https://gitlab.com/450255266/code/tree/master/SpringBoot/dubbo/yun-double&quot;&gt;传送门&lt;/a&gt;&lt;br/&gt;注意事项:&lt;br/&gt;Dubbo是一个二进制的Rpc框架在传输数据过程中，实体类必须经过序列化。&lt;br/&gt;在使用poi导出功能时一定不能把response传到Service层，否则传输到Service是导出不了文件而报错，至于文件下载也一样但是相信一般都会有单独的文件服务器。&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 10:10:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>企业级SpringBoot与Dubbo的并用 SpringBoot越来越热门以至于达到烂大街可见的程度，而Dubbo这个基于二进制的微服务框架又捐献给Apache孵化，如果不会如何使用那么是不是很不好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10833555.html</dc:identifier>
</item>
<item>
<title>JAVA兼职架构师 - 我是2货呀</title>
<link>http://www.cnblogs.com/jay-wu/p/10833451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-wu/p/10833451.html</guid>
<description>&lt;p&gt;在一些小企业或者公司人力不足的时候，经常会出现一个人干多个人的活。开发可能会干架构、测试、运维，一些小项目可能需要一个人完成。我把这些角色合并在一起称之为兼职架构师。&lt;/p&gt;
&lt;p&gt;我用我的经历来说说兼职架构师的需要干的事吧。&lt;/p&gt;
&lt;p&gt;1.首先，幸运的事情至少我还有一个产品经理，可以给出RoadMap，比如下：&lt;/p&gt;
&lt;p&gt;单独项目的唯一好处是，产品经理会给你安排一个大致时间，可以把控一下时间和进度。你也不需要开会，因为就你一个人，不过看过《人月神话》的都知道，1+1有时并不能大于2。当然我们底层功能的版本有人C++的人来支持，这边不叙说了。&lt;/p&gt;
&lt;p&gt;first，你拿到roadmap心中需要有个大致安排时间，技术选型，功能组织架构。尽量多思考，花多一点时间去想如何实现比较好，哪些重点功能，哪些列出来可以不需要首先完成的（可以自由安排优先级，一般周末很少需要加班，效率非常高）&lt;/p&gt;
&lt;p&gt;second,因为我们测试人少，基本一个月一个小版本（小版本自己测试），一个季度保持一个大版本（大版本有测试帮测）。没有运维，就要考虑到部署人员通俗易懂，一个脚本需要执行所有环境的安排（内网实体机，需要安装包带所有功能，jdk,tomcat,mysql等脚本安装），所以非常考验脚本功底。尽量多想、多测，你也不想实施人员半夜打你电话吧？&lt;/p&gt;
&lt;p&gt;at last，你需要geek最新技术，我重构的项目经历过struts2 到spring mvc ，然后到现在最新的spring boot。其间遇到的问题也很多。小企业不仅需要你会后端知识，前端也需要你独立完成。所以前端从jsp，到vm，再到现在的html5，也多多少少的要了解一些。前端框架我们主要能接受mvc模式，backbone.js是当初选型的，后来我们过渡过了react.js。所以你需要多看主流的技术和一些实际的知识，可以为以后技术选型提供帮助，这是架构师的成长之路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201905/1531118-20190508151049773-1622307789.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.我们拿到了RoadMap ，可以选自己画一些图，把主要功能给拎清楚，这样才能让我们更好的完成功能。&lt;/p&gt;
&lt;p&gt;2.1 比如我们拿到日志模块，可以先画一个时序图。在时序图中画出大致的功能点（如图功能链路比较长，我建议可以画泳道图，这样比较清楚一些）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201905/1531118-20190508174421821-479875945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.时序图画完，我们就可以先做出具体的功能逻辑了，画出来就代码写起来比较简单了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201905/1531118-20190508174551953-1724493130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.有了流程设计图，表设计结构做出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201905/1531118-20190508174933014-1645489032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.最后写业务逻辑，定义好接口规范，这样就可以完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201905/1531118-20190508175047118-1256010918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;在中国的创业型公司或者小企业中，大部分开发人员身兼多职。这样可以使人成长非常快，但提前是需要有良好的技术和全面的应对排查能力，对你进阶架构师有个良好的基础。一句话，不想做架构师的开发，不是一个好开发！一起加油。&lt;/p&gt;

</description>
<pubDate>Wed, 08 May 2019 09:56:00 +0000</pubDate>
<dc:creator>我是2货呀</dc:creator>
<og:description>在一些小企业或者公司人力不足的时候，经常会出现一个人干多个人的活。开发可能会干架构、测试、运维，一些小项目可能需要一个人完成。我把这些角色合并在一起称之为兼职架构师。 我用我的经历来说说兼职架构师的需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jay-wu/p/10833451.html</dc:identifier>
</item>
<item>
<title>[项目实战］训练retinanet(pytorch版） - wuzeyuan</title>
<link>http://www.cnblogs.com/wzyuan/p/10822162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzyuan/p/10822162.html</guid>
<description>&lt;p&gt;采用github上star比较高的一个开源实现&lt;a href=&quot;https://github.com/yhenon/pytorch-retinanet&quot;&gt;https://github.com/yhenon/pytorch-retinanet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在anaconda中新建了一个环境，因为一开始并没有新建环境，在原有的环境里，遇到了pytorch，numpy等版本问题，尤其是一开始用0.1.2版的pytorch，有一个ＴＨ路径不对，导致编译错误，这是我最讨厌的错误，遇到编译错误往往一脸懵逼，如果ＮＭＳ部分不用编译，直接用python实现就好了，当然那样速度可能会慢很多．&lt;/p&gt;
&lt;p&gt;先记录下我的各个包的版本&lt;/p&gt;
&lt;p&gt;cffi                      1.12.2&lt;/p&gt;
&lt;p&gt;cudatoolkit               9.0&lt;/p&gt;
&lt;p&gt;cudnn                     7.3.1&lt;/p&gt;
&lt;p&gt;Cython                    0.29.7&lt;/p&gt;
&lt;p&gt;matplotlib                3.0.3&lt;/p&gt;
&lt;p&gt;numpy                     1.15.4&lt;/p&gt;
&lt;p&gt;pytorch                   0.4.0&lt;/p&gt;
&lt;p&gt;torchvision               0.2.1&lt;/p&gt;
&lt;p&gt;当然了，其他版本也可以，但是这个版本一定是可行的．&lt;/p&gt;
&lt;p&gt;然后准备训练coco，首先需要下载coco，这里采用wget下载，几个压缩包的地址链接&lt;a href=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxcheckurl?requrl=https%3A%2F%2Fblog.csdn.net%2Fdaniaokuye%2Farticle%2Fdetails%2F78699138%23commentsedit&amp;amp;skey=%40crypt_dc908151_7eb803d2f28fdd5c7662e20c3d802247&amp;amp;deviceid=e582240107253285&amp;amp;pass_ticket=8jK3TQRoOJhKOvr0P0tBqfTYOFl75D1A6Tylv%252FmGuypH4ET27SfB8BcFnd7e6OcY&amp;amp;opcode=2&amp;amp;scene=1&amp;amp;username=@4dad1bc3d7b9c80e7854b41103e8173d532b2c04bf7e27dbf3f325dda877fa6e&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/daniaokuye/article/details/78699138#commentsedit&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;采用wget下载意外地很慢，于是采用迅雷，意外地很快&lt;/p&gt;
&lt;p&gt;网络开始训练，没有采用预训练权重，既没有用coco训练好的，也没有用resnet的预训练权重（下载起来太慢了）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python train.py --dataset coco --coco_path ../coco --depth &lt;span&gt;50&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;训练截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439008/201905/1439008-20190507152201870-1078403467.png&quot; alt=&quot;&quot; width=&quot;1494&quot; height=&quot;851&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用２个图片作为一个batch训练，ＧＰＵ占用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439008/201905/1439008-20190507152403982-1064789565.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;batchsize为２，训练一个epoch大约６个小时，按照代码中默认的１００个epoch，恐怕得６００个小时，一个月了&lt;/p&gt;
&lt;p&gt;幸好源代码中提供了训练好的coco权重,可以为我们所用,那就先看一下训练好的效果,调用可视化代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python visualize.py --dataset coco --coco_path ../coco --model ./coco_resnet_50_map_0_335_state_dict.pt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439008/201905/1439008-20190508174221218-1474323762.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;435&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439008/201905/1439008-20190508173930212-820634653.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;434&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439008/201905/1439008-20190508174028984-1431369285.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;

&lt;p&gt;检测效果还是ok的~&lt;/p&gt;
&lt;p&gt;这个版本的实现代码量在2000行左右,很适宜阅读,尤其是与Mask R-CNN(matterport版,大概6000行)相比&lt;/p&gt;
&lt;p&gt;可视化代码稍加改造,就可以作为一个目标检测器使用了,棒!&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 09:48:00 +0000</pubDate>
<dc:creator>wuzeyuan</dc:creator>
<og:description>pytorch, retinanet,目标检测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wzyuan/p/10822162.html</dc:identifier>
</item>
</channel>
</rss>