<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#中Lambda表达式总结 - 江湖逍遥</title>
<link>http://www.cnblogs.com/xu-yi/p/10372394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu-yi/p/10372394.html</guid>
<description>&lt;p&gt;       在C#的语法中有一种比较特殊的写法，叫做Lambda表达式，这种表达式的写法在于你查询数据的时候直接是使用以下箭头的形式来表示查询语句的：=&amp;gt;。例如，我们要查找学生的List&amp;lt;Student&amp;gt;集合中班级编号为1001的所有学生数据，我们即可用Studentlist.Where(t=&amp;gt;t.ClassCode=‘1001’)语句来直接完成，无需再写繁琐的foreach语句或者for循环。Lambda表达式的运算符即为=&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Lambda表达式定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Lambda表达式实际上是一种匿名函数，在Lambda表达式中可以包含语句以及运算等操作。并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。使用Lambda表达式可大大减少代码量，使得代码更加的优美、简洁，更有可观性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Lambda表达式的表现形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;表达式形式：(Input Param)=&amp;gt;Expression。在表达式左侧的表示输入参数，右侧的为相应的运算语句或者判断语句等，可包含函数调用等复杂方式。运算符=&amp;gt;读作为goes to，例如下面这个表达t=&amp;gt;t.ClassCode='1001'，多做goes to ClassCode equal 1001。&lt;/p&gt;
&lt;p&gt;       在上述的表达式中，仅仅只有当参数只有一个的时候，括号是可选择的，例如下面这种含有两个参数时候的情况应该是这样子的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
     (a,b)=&amp;gt;a==b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当表达式中的多个参数编译器无法自动判断类型的时候，则需要显式指定类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
   (int firstIndex, string str) =&amp;gt; str.IndexOf('Hello') &amp;gt; firstIndex
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、下面介绍List集合中的Lambda表达式的运用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在C#的List集合中，我们时常需要使用到大量的运算或者筛选等操作，按常规的方式无非就是利用foreach或者for对List集合进行循环操作，最后运算出结果。此种方法往往需要写多行语句，阅读性稍微差点，当然复杂的情况下编写也费时。博主遇到这种情况一般比较喜欢偷懒，很少会去直接写循环，而是直接使用Lambda表达式一条语句完成。&lt;/p&gt;
&lt;p&gt;     先假定好我们待会使用的范例的格式：&lt;/p&gt;
&lt;p&gt;     studentList对象：此对象是一个List集合，集合中的对象为学生实体Student。此集合中存放着整个学校学生的信息。&lt;/p&gt;
&lt;p&gt;     scoreList对象：此对象是个List集合，集合中的对象是成绩实体Score，此集合中存放着为学生的成绩信息。&lt;/p&gt;
&lt;p&gt;     Student实体：此实体包含下列几个属性，StudentName，StudentCode，ClassCode，ClassName，BirthDay，Grade。以上几个英文单词都比较简单，就不做解释了。&lt;/p&gt;
&lt;p&gt;     Score实体：此实体包含下列几个属性，StudentCode,SubjectName(科目名称),ScoreValue(分数，0-100的数字)。一个学生可能有多门成绩数据存放在此。&lt;/p&gt;
&lt;p&gt;    (1)查询班级编号为1001的班级下面的所有学生实体并返回到list1001中存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 var list1001=Studentlist.Where(t=&amp;gt;t.ClassCode==‘1001’)；
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　(2)查询班级编号为1001的班级下面的所有学生实体并返回到list1001中存储，并按照学生的出生日期从小到大排列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var list1001=Studentlist.Where(t=&amp;gt;t.ClassCode==‘1001’).OrderBy(t=&amp;gt;t.BirthDay)；
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;   在此说一下，OrderBy是从小到大排序，需要从大到小排列则用OrderByDescending。&lt;/p&gt;
&lt;p&gt;　(3)查询班级编号为1001的班级下面的姓氏为【李】的同学的所有集合，并按照学生的出生日期从小到大排列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var list1001=Studentlist.Where(t=&amp;gt;t.ClassCode==‘1001’&amp;amp;&amp;amp;t.StudentName.StartWith（“李”）).OrderBy(t=&amp;gt;t.BirthDay)；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　(4)查询出班级编号为1001的班级，并且存在至少一门考试科目成绩低于60分的所有同学。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  var result = studentList.Where(t =&amp;gt; (t.ClassCode == &quot;1001&quot;) &amp;amp;&amp;amp; (scoreList.Exists(p =&amp;gt; p.ScoreValue &amp;lt; 60 &amp;amp;&amp;amp; p.StudentCode == t.StudentCode)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上述语句中，lambda表达式中再次嵌入了一个lambda表达式。t参数是studentList中的lambda表达式参数，代表实体为student。p参数为scoreList中的lambda表达式参数，代表的实体为score。&lt;/p&gt;
&lt;p&gt;   (5)其他较常用的Lambda表达式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; a = studentList.FirstOrDefault(t =&amp;gt; t.StudentCode == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10012&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FirstOrDefault返回第一个符合条件的数据，不存在的时候返回Null。&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; b = studentList.Count(t =&amp;gt; t.StudentName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李世民&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回符合条件的实体个数&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; c = studentList.FindAll(t =&amp;gt; t.StudentName.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找所有名字中含有【中】的实体集合&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; d = studentList.GroupBy(t =&amp;gt; t.ClassCode);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对studentList按照ClassCode分组&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; f = studentList.Max(t =&amp;gt; t.BirthDay);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回最大的出生日期。&lt;/span&gt;
&lt;span&gt; var&lt;/span&gt; e = scoreList.Sum(t =&amp;gt; t.ScoreValue);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对所有成绩求和&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; g = scoreList.Average(t =&amp;gt; t.ScoreValue);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对所有成绩求平均分&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; h = studentList.Select(t =&amp;gt; t.StudentName).Distinct();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有的学生姓名，并去除重名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    Lambda表达式的总结大致如此，从上述例子来看，可以大大简化代码的量，并增加可读性。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;最后，附上博主的个人博客站点，更多的文章在博主的个人站点中，欢迎各位同行来进行指导交流：&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;http://50bit.cn/&quot; target=&quot;_blank&quot;&gt;IT技术小屋&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Feb 2019 15:31:00 +0000</pubDate>
<dc:creator>江湖逍遥</dc:creator>
<og:description>在C#的语法中有一种比较特殊的写法，叫做Lambda表达式，这种表达式的写法在于你查询数据的时候直接是使用以下箭头的形式来表示查询语句的：=&gt;。例如，我们要查找学生的List&lt;Studen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu-yi/p/10372394.html</dc:identifier>
</item>
<item>
<title>欧拉线性筛 和 欧拉函数的求值 - Jack_Pei</title>
<link>http://www.cnblogs.com/Jackpei/p/10372392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackpei/p/10372392.html</guid>
<description>&lt;p&gt;PS：求逆元的部分在文章最后。。。最好也看看前边的知识吧qwq&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;用筛法求素数的基本思想是：把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。&lt;em&gt;（来自 百度百科）&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 一般的筛法（埃拉托斯特尼筛法）的效率是O(nlglgn)，但出题人卡你可就凉了。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599173/201902/1599173-20190213224029391-37799291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(就不介绍了（逃）)&lt;/p&gt;
&lt;h3&gt;下面我们来说O(n)的欧拉线性筛&lt;/h3&gt;
&lt;p&gt;埃筛之所以慢，是因为有些合数被重复筛除（如：6会被2和3重复筛）&lt;/p&gt;
&lt;p&gt;但是欧拉筛保证&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;每一个数p，只会被其最小的素因子mp[p]筛一次&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define R register int&lt;br/&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; M=&lt;span&gt;1000010&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mp[M],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mp[i] 为i的最小素因子 &lt;/span&gt;
    prime[M],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;prime[i] 代表2-n中的第i个质数 &lt;/span&gt;
    cnt；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;素数计数 &lt;/span&gt;
inline &lt;span&gt;void&lt;/span&gt; Prime(&lt;span&gt;int&lt;/span&gt; n)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;筛的范围&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!mp[i]) prime[++cnt]=mp[i]=&lt;span&gt;i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R j=&lt;span&gt;1&lt;/span&gt;,k=i*prime[j];j&amp;lt;=cnt&amp;amp;&amp;amp;prime[j]&amp;lt;mp[i]&amp;amp;&amp;amp;(k=i*prime[j])&amp;lt;=m;i++) mp[k]=&lt;span&gt;prime[j];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也有一些别的写法，如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inline void&lt;/span&gt; Prime(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=x;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!mp[i]) prime[++cnt]=i,mp[i]=&lt;span&gt;i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;i*prime[j]&amp;lt;=x;j++&lt;span&gt;)
        {
            mp[i&lt;/span&gt;*prime[j]]=&lt;span&gt;prime[j];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%prime[j]==&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if(prime[j]&amp;gt;=mp[i]) break; &lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;if(i%prime[j]==0) break&lt;span&gt;; 这个很重要qwq&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;若 i%prime[j]==0,则 i=k*prime[j](k为正整数).&lt;/p&gt;
&lt;p&gt;如果不 break,下一个循环中的 mp(i*prime[j+1])=prime[j+1],&lt;/p&gt;
&lt;p&gt;就是 mp(k*prime[j]*prime[j+1])=prime[j+1],&lt;/p&gt;
&lt;p&gt;但 显然k*prime[j]*prime[j+1]的最小质因子为 prime[j] 而非 prime[j+1]（prime[]数组中的素数是递增的）&lt;/p&gt;
&lt;p&gt;所以应 break&lt;/p&gt;
&lt;p&gt;if(prime[j]&amp;gt;=mp[i]) break;也可用这句话，一个意思，就是不能让 i乘上的质因子 大于 i的最小质因子&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;欧拉函数。。。&lt;/h3&gt;
&lt;p&gt;在数论，对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler's totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。&lt;/p&gt;
&lt;p&gt;所以求某个φ(p)可以有很朴素&lt;span&gt;（朴素的不行）&lt;/span&gt;的求法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是枚举每个素因子&lt;/span&gt;
inline &lt;span&gt;int&lt;/span&gt; phi(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) 
{
    R ans&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R i=&lt;span&gt;2&lt;/span&gt;;i*i&amp;lt;=n;++i) &lt;span&gt;if&lt;/span&gt;(n%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        n&lt;/span&gt;/=&lt;span&gt;i;
        ans&lt;/span&gt;*=i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n%i==&lt;span&gt;0&lt;/span&gt;) n/=i,ans*=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n&amp;gt;&lt;span&gt;1&lt;/span&gt;) ans*=n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果求p∈[1,n]，每个φ(p)，那上面的算法就太菜了。&lt;/p&gt;
&lt;p&gt;数论上的积性函数f(x)满足a与b互素时（a,b∈N&lt;sup&gt;+&lt;/sup&gt;），f(a·b)=f(a)·f(b)，f(1)=1;&lt;/p&gt;
&lt;p&gt;而φ(p)就是一个积性函数。&lt;/p&gt;
&lt;p&gt;此时可以利用刚学的欧拉筛&lt;/p&gt;
&lt;p&gt;正确性：&lt;/p&gt;
&lt;p&gt;1.φ(p)是一个积性函数，当a与b互素时，满足φ(a·b)=φ(a)·φ(b)。&lt;/p&gt;
&lt;p&gt;2.当正整数p是素数时，φ(p)=p-1 (定义)&lt;/p&gt;
&lt;p&gt;3.每个合数只会被筛到一次（前面说明过）。&lt;/p&gt;
&lt;p&gt;4.当p是素数时，φ(p&lt;sup&gt;k&lt;/sup&gt;)=(p-1)·φ(p&lt;sup&gt;k-1&lt;/sup&gt;)，因为有(p-1)个数与p互素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; R register int 
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N=&lt;span&gt;10000010&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,cnt,prime[N],p[N];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vis[N];

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Euler(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
{
    vis[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;) 
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!vis[i]) prime[++cnt]=i,p[i]=i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;i*prime[j]&amp;lt;=n;j++&lt;span&gt;)
        {
            vis[i&lt;/span&gt;*prime[j]]=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%prime[j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
            {
                p[i&lt;/span&gt;*prime[j]]=p[i]*&lt;span&gt;prime[j];
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            p[i&lt;/span&gt;*prime[j]]=(prime[j]-&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;p[i];
        }
    }
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p[i]即为φ(i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;所以隆重推出......::::::&lt;/p&gt;
&lt;h3&gt;欧拉定理：&lt;/h3&gt;
&lt;p&gt;若p,a为正整数，且p,a互质，则：a^φ(p) ≡1 (mod p) (是不是有些眼熟)&lt;/p&gt;
&lt;p&gt;其实欧拉定理相当于费马小定理的扩展&lt;/p&gt;
&lt;p&gt;所以我们可用其求乘法逆元：&lt;/p&gt;
&lt;p&gt;a*a^(φ(p)-1) ≡1 (mod p) &lt;/p&gt;
&lt;p&gt;a^(φ(p)-1)即为a mod p 意义下的逆元&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cctype&amp;gt;
&lt;span&gt;#define&lt;/span&gt; R register int
&lt;span&gt;#define&lt;/span&gt; ll long long
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; ll a,p;

inline ll q_pow(ll x,ll ind,ll mod)
{
    x&lt;/span&gt;%=&lt;span&gt;mod;
    register ll a&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;ind;ind&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,(x*=x)%=mod) &lt;span&gt;if&lt;/span&gt;(ind&amp;amp;&lt;span&gt;1&lt;/span&gt;) (a*=x)%=&lt;span&gt;mod;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}

inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; phi(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) 
{
    R ans&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R i=&lt;span&gt;2&lt;/span&gt;;i*i&amp;lt;=n;++i) &lt;span&gt;if&lt;/span&gt;(n%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        n&lt;/span&gt;/=&lt;span&gt;i;
        ans&lt;/span&gt;*=i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n%i==&lt;span&gt;0&lt;/span&gt;) n/=i,ans*=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n&amp;gt;&lt;span&gt;1&lt;/span&gt;) ans*=n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;p);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,q_pow(a,phi(p)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,p));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如有错误，恳请您指正（我太菜了）；如有不理解，可留言，我会尽量回复。。。（高中生(逃)。。）&lt;/p&gt;
&lt;p&gt;by Jackpei 2019.2.13&lt;/p&gt;
</description>
<pubDate>Wed, 13 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>Jack_Pei</dc:creator>
<og:description>PS：求逆元的部分在文章最后。。。最好也看看前边的知识吧qwq 用筛法求素数的基本思想是：把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jackpei/p/10372392.html</dc:identifier>
</item>
<item>
<title>《Java编程思想》读书笔记-基本规范、注释、static关键字、import关键字 - Lurker潜行者</title>
<link>http://www.cnblogs.com/lurker-yaojiang/p/10372377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurker-yaojiang/p/10372377.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;78.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;扫一扫加我的微信公众号，和我一起打好Java的基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486497/201902/1486497-20190213232356712-863672921.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文作为构建第一个Java程序的番外篇二，主要跟大家伙儿从浅层次的探讨下Java中的关键字&lt;code&gt;import&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;，此外为了让我们的代码可读性更强，必要的包和代码的命名规范是必须的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-&quot;&gt;今日份重点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;命名规范&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;li&gt;static关键字&lt;/li&gt;
&lt;li&gt;import关键字&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;命名规范&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;规范的包名&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;名字管理是所有编程语言都必须重视的一个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java为了解决命名冲突，建议开发者反过来使用当前应用所归属的Internet域名来作为包名的前缀。比如说百度，其域名为&lt;code&gt;baidu.com&lt;/code&gt;，那么其对应的应用的包名前缀就应该为&lt;code&gt;com.baidu...&lt;/code&gt;。包名格式一般为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;前缀.应用名称.所有者.分层信息&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如百度的搜索业务，假如其所有者为tony，当前为service层，则当前的包名理论上应该为：&lt;code&gt;com.baidu.search.tony.service&lt;/code&gt;，其中的&lt;code&gt;.&lt;/code&gt;代表目录分层，按照当前包名，你应该得到一个如&lt;code&gt;com/baidu/search/tony/service&lt;/code&gt;的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486497/201902/1486497-20190213232338226-1721133042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：包名要求全小写哦&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;规范的类名称&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;首字母大写&lt;/li&gt;
&lt;li&gt;如有由多个单词组成，则每个单词的首字母大写&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;-&quot;&gt;规范的变量名称、方法名称&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;变量和方法名&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首字母小写&lt;/li&gt;
&lt;li&gt;如果由多个单词组成，则除首个单词外其他单词的首字母大写&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;常量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全部大写&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;-&quot;&gt;需要共同遵循的公共规则&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;名字只能由字母、数字、$符号、下划线_、组成&lt;/li&gt;
&lt;li&gt;不能以数字开头&lt;/li&gt;
&lt;li&gt;不能使用Java中的关键字&lt;/li&gt;
&lt;li&gt;不能出现中文及拼音（国际化）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;注释&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注释就是故事中的旁白，告诉你前因后果，但却从来不出现在荧幕上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java中支持两种风格的注释&lt;/p&gt;
&lt;p&gt;以上是两种基本的注释方式。在Java中，有把自己提供的接口发布出去的需求，因此可能需要生成JavaDoc文件。为了简便生成JavaDoc的流程，先简单介绍一种接口的注释，其以&lt;code&gt;/**&lt;/code&gt;开头，以&lt;code&gt;*/&lt;/code&gt;结尾：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-javadoc&quot;&gt;/**
 * 这是一个获取数据的接口，这里做一个接口注释的范例
 *&lt;span class=&quot;hljs-javadoctag&quot;&gt; @param&lt;/span&gt; id 这是id属性的说明
 *&lt;span class=&quot;hljs-javadoctag&quot;&gt; @param&lt;/span&gt; name 这是name属性的说明
 *&lt;span class=&quot;hljs-javadoctag&quot;&gt; @return&lt;/span&gt; 没有返回值
 */&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Integer id, String name)&lt;/span&gt;&lt;/span&gt;{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上示范的是接口注释的使用，其中的@param用于说明接口参数，@return用于说明接口返回值。这些在后面会详细讲，这里只做简单了解。&lt;/p&gt;
&lt;h3 id=&quot;static-&quot;&gt;static关键字&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;只有在执行了&lt;code&gt;new&lt;/code&gt;操作的时候，数据存储空间才被分配，类的方法才可以提供给外部使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java中，&lt;code&gt;static&lt;/code&gt;关键字用于把属性或方法从对象中剥离出来。意味着，按照惯例，类必须实例化（即使用new关键词新建对象）后，才能访问其属性和方法，而使用了static之后，即使类没有实例化，我同样可以访问。&lt;/p&gt;
&lt;p&gt;static关键字以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与对象无关，调用方法直接使用&lt;code&gt;类名.方法名&lt;/code&gt;，调用属性则使用&lt;code&gt;类名.属性名&lt;/code&gt;，当然，以前的调用方式还是保留的，你仍然可以使用对象来调用&lt;/li&gt;
&lt;li&gt;static修饰的属性，无论创建多少个对象，在内存中都只有&lt;code&gt;一份存储空间&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;static修饰的方法不能调用非static修饰的属性或方法，反之则可以&lt;/li&gt;
&lt;li&gt;static修饰的类，必然是静态内部类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;static&lt;/code&gt;关键字的放置位置，一般是在类的&lt;code&gt;class&lt;/code&gt;关键字前；或在属性的类型前，或在方法的返回类型前：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TypeName&lt;/span&gt;&lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; String s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;;
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt; &lt;/span&gt;{
        System.out.println(s);
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Inner&lt;/span&gt; &lt;/span&gt;{}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于static关键字，在后面的内容中会深入分析，这里只做简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;import-&quot;&gt;import关键字&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;众人拾柴火焰高，我们不仅仅要自己写代码，还要复用别人的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java是开源的，因此存在大量附生的开源项目可以供我们使用，Java提供了import关键字用于帮助我们引用别人提供的类或方法。&lt;code&gt;import&lt;/code&gt;引入的内容，需要放在代码头部&lt;/p&gt;
&lt;p&gt;如使用&lt;code&gt;import java.util.ArrayList;&lt;/code&gt;，你向编译器发出了要使用ArrayList类的信号，其在编译时就会自动定位到这个类。如果你想引用同一个包中的多个类，那么试试&lt;code&gt;import java.util.*&lt;/code&gt;，这里用了&lt;code&gt;*&lt;/code&gt;来匹配&lt;code&gt;java.util&lt;/code&gt;包下的所有类。&lt;/p&gt;
&lt;p&gt;还有一种情况，可能你会在当前类中多次用到某个类的某个静态方法或属性，那么你可以试试这样引入：&lt;code&gt;import static java.util.stream.Collectors.*&lt;/code&gt;，这里直接把Colloctors类静态引入，注意后面的&lt;code&gt;*&lt;/code&gt;，它表示引入该类下所有可见的静态的方法和属性，这样你在调用的时候，就更简便了。比如说你要调用&lt;code&gt;Collectors.toSet()&lt;/code&gt;的时候，你就可以直接写&lt;code&gt;toSet()&lt;/code&gt;就可以啦！是不是很方便呢？&lt;/p&gt;
&lt;p&gt;记住哦，在Java中有个比较特别的包，它是默认引入的，不需要我们显式引入。是谁这么大牌？&lt;code&gt;java.lang.*&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文主要介绍了Java中的命名规范、注解、import关键字、static关键字等内容。其中，命名规范能极大提高代码的可读性，在实际的协同工作中，能让同事更快地明白你代码表达的意思。代码注解则是你对代码的说明，于己于人都是有益的。我们不会每天都接触同一段代码，注释则帮助我们记忆代码中的重点。import关键字用于引入当前包之外的其他类，帮助我们扩展程序和复用代码。static关键字则是Java中非常重要的一个关键字，在后续还会继续深入探讨，理清它的特性，对我们编写代码，排除bug有很大的益处。&lt;/p&gt;
&lt;p&gt;对，你学到了一个新词，&lt;code&gt;bug&lt;/code&gt;，后面，它会教你做人！&lt;/p&gt;
&lt;p&gt;下一节，我们开始运用这些只是来编写我们的第一个Java程序！期待着吧！&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 13 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>Lurker潜行者</dc:creator>
<og:description>扫一扫加我的微信公众号，和我一起打好Java的基础 本文作为构建第一个Java程序的番外篇二，主要跟大家伙儿从浅层次的探讨下Java中的关键字import和static，此外为了让我们的代码可读性更强</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurker-yaojiang/p/10372377.html</dc:identifier>
</item>
<item>
<title>记录一次短信轰炸漏洞挖掘 - 飘渺__红尘</title>
<link>http://www.cnblogs.com/piaomiaohongchen/p/10372046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/piaomiaohongchen/p/10372046.html</guid>
<description>&lt;p&gt;　　　　　短信轰炸漏洞一般分为两种：&lt;/p&gt;
&lt;p&gt;　　　　1.对一个手机号码轰炸n次&lt;/p&gt;
&lt;p&gt;　　　　2.对单个手机号码做了接收验证次数，但是可以对不同手机号发送短信无次数限制&lt;/p&gt;
&lt;p&gt;　　　　在漏洞挖掘中遇到个有意思的案例，写篇文章分享出来。&lt;/p&gt;
&lt;p&gt;　　 　　在接收短信处都有可能存在短信轰炸漏洞。输入手机号然后接收短信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213221032389-1234494746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先我会查看响应接收和cookie中是否会返回正确的验证码，好吧～我在做梦，这种设计缺陷已经很少见了。&lt;/p&gt;
&lt;p&gt;　　接着看加密完整的数据包post data的值：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213213438620-769761806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我输入手机号码接收短信，数据包中对phone进行了加密，一般在漏洞挖掘中遇到这种情况我一般扭头就是换地方测试漏洞了，我觉得这里存在问题的可能性很小，但是这次我想尝试下，下面是我的尝试之旅：&lt;/p&gt;
&lt;p&gt;　　这里对手机号进行加密，可能是前端加密也可能是后端加密，我尝试接收多次验证码，看数据包中的phone是否会发生随机性的变化：&lt;/p&gt;
&lt;p&gt;　　我发现我的手机号phone始终是BYiJiNlLxDYiDJOUEoUQdQ%3D%3D，不管我接收多少次验证码，他都是唯一的加密值，并没有产生随机性变化。&lt;/p&gt;
&lt;p&gt;　　现在我尝试查看源码，看看能不能寻找到phone的加密方式：&lt;/p&gt;
&lt;p&gt;　　查看源码发现他这里对phone进行了前端加密，首先是通过encrypt加密然后对加密的内容进行url编码。前面的%3D的url解码就是=&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213213904021-1720762129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　开始定位到encrypt函数：&lt;/p&gt;
&lt;p&gt;　　控制台上输出encrypt&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213214118120-180841847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;单机点击进去：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213214225221-704809035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;得到加密手机号码的方法，以及解密手机号码的方法。&lt;/p&gt;
&lt;p&gt;　　现在我们知道了我们手机号的加密方式，下一步就是批量对每个手机号进行轰炸：&lt;/p&gt;
&lt;p&gt;　　如何操作呢？&lt;/p&gt;
&lt;p&gt;　　我们批量手机号码的最后两位：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213214932509-554422986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我少生成点，生成20个：&lt;/p&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;

&lt;p&gt;var k=10;&lt;br/&gt;while(k&amp;lt;30){&lt;br/&gt;var m=encrypt(&quot;138330781&quot;+k);&lt;br/&gt;k++;&lt;br/&gt;console.log(m);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;把这些生成的加密phone保存到文档中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213215723948-1806460109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;爆破之：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201902/1090320-20190213215908425-693990661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单记录下～&lt;/p&gt;

</description>
<pubDate>Wed, 13 Feb 2019 14:00:00 +0000</pubDate>
<dc:creator>飘渺__红尘</dc:creator>
<og:description>短信轰炸漏洞一般分为两种： 1.对一个手机号码轰炸n次 2.对单个手机号码做了接收验证次数，但是可以对不同手机号发送短信无次数限制 在漏洞挖掘中遇到个有意思的案例，写篇文章分享出来。 在接收短信处都有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/piaomiaohongchen/p/10372046.html</dc:identifier>
</item>
<item>
<title>Android 个人手机通讯录开发 - Pretty_girll</title>
<link>http://www.cnblogs.com/prettygirll/p/10371967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/prettygirll/p/10371967.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Android 个人手机通讯录开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　数据存储：SQLite 数据库&lt;/p&gt;
&lt;p&gt;　　开发工具：Android Studio&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Phone Module 简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 界面展示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213202152416-1845830320.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;525&quot;/&gt;              &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213202343649-547228220.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;520&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 文件结构简单分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213195650756-1165420901.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;494&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、个人手机通讯录代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 清单文件 (AndroidManifest.xml)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    &lt;span&gt;package&lt;/span&gt;=&quot;com.example.alan.directory&quot; &amp;gt;

    &amp;lt;&lt;span&gt;application
        android:allowBackup&lt;/span&gt;=&quot;true&quot;&lt;span&gt;
        android:icon&lt;/span&gt;=&quot;@drawable/icon_phone&quot;&lt;span&gt;
        android:label&lt;/span&gt;=&quot;@string/app_name&quot;&lt;span&gt;
        android:supportsRtl&lt;/span&gt;=&quot;true&quot;&lt;span&gt;
        android:theme&lt;/span&gt;=&quot;@style/AppTheme&quot; &amp;gt;
        &amp;lt;activity android:name=&quot;.MainActivity&quot; &amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;

                &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
        &amp;lt;/activity&amp;gt;
    &amp;lt;/application&amp;gt;

&amp;lt;/manifest&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2. MainActivity.java (主文件)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Alan J on 13/2/2019.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.alan.directory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.Cursor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteDatabase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.support.v7.app.AppCompatActivity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.method.ScrollingMovementMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.EditText;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt; AppCompatActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; View.OnClickListener{

    MyHelper myHelper;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText etName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText etPhone;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView tvShow;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button btnAdd;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button btnQuery;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button btnUpdate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button btnDelete;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        myHelper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MyHelper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        init(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化控件&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        etName &lt;/span&gt;=&lt;span&gt; (EditText)findViewById(R.id.et_name);
        etPhone &lt;/span&gt;=&lt;span&gt; (EditText)findViewById(R.id.et_phone);
        tvShow &lt;/span&gt;=&lt;span&gt; (TextView)findViewById(R.id.tv_show);
        btnAdd &lt;/span&gt;=&lt;span&gt; (Button)findViewById(R.id.btn_add);
        btnQuery &lt;/span&gt;=&lt;span&gt; (Button)findViewById(R.id.btn_query);
        btnUpdate &lt;/span&gt;=&lt;span&gt; (Button)findViewById(R.id.btn_update);
        btnDelete &lt;/span&gt;=&lt;span&gt; (Button)findViewById(R.id.btn_delete);
        btnAdd.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Button控件设置监听&lt;/span&gt;
        btnQuery.setOnClickListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        btnUpdate.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        btnDelete.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        tvShow.setMovementMethod(ScrollingMovementMethod.getInstance());  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文本滚动&lt;/span&gt;
&lt;span&gt;    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v){
        String name;
        String phone;
        SQLiteDatabase db;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (v.getId()){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; R.id.btn_add:       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加联系人&lt;/span&gt;
                name =&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                db &lt;/span&gt;=&lt;span&gt; myHelper.getWritableDatabase();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息添加失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;insert into person (name,phone) values(?,?)&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息添加成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; R.id.btn_query:    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询联系人&lt;/span&gt;
                db =&lt;span&gt; myHelper.getReadableDatabase();
                Cursor cursor &lt;/span&gt;= db.rawQuery(&quot;select name,phone from person&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cursor.getCount() == 0&lt;span&gt;){
                    tvShow.setText(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;空目录&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    cursor.moveToFirst();
                    tvShow.setText(&lt;/span&gt;&quot;Name：&quot; + cursor.getString(0) + &quot; ; Tel：&quot; + cursor.getString(1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (cursor.moveToNext()){
                        tvShow.append(&lt;/span&gt;&quot;\n&quot; + &quot;Name：&quot; + cursor.getString(0) + &quot; ; Tel：&quot; + cursor.getString(1&lt;span&gt;));
                    }
                }
                cursor.close();
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; R.id.btn_update:    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改联系人&lt;/span&gt;
                db =&lt;span&gt; myHelper.getWritableDatabase();
                name &lt;/span&gt;=&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;update person set name=?,phone=? where name=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone, name});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; R.id.btn_delete:   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除联系人&lt;/span&gt;
                db =&lt;span&gt; myHelper.getWritableDatabase();
                name &lt;/span&gt;=&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;delete from person where name=? and phone=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. MyHelper.java (数据库文件)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Alan J on 13/2/2019.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.alan.directory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteDatabase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteOpenHelper;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyHelper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SQLiteOpenHelper{


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyHelper(Context context){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(context, &quot;alan.db&quot;, &lt;span&gt;null&lt;/span&gt; ,2&lt;span&gt;);
    }
    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(SQLiteDatabase db){
        db.execSQL(&lt;/span&gt;&quot;create table person(id integer primary key autoincrement,name varchar(20),phone varchar(20) unique)&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onUpgrade(SQLiteDatabase db, &lt;span&gt;int&lt;/span&gt; oldVersion, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newVersion){

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;4. activity_main.xml (&lt;/strong&gt;&lt;strong&gt;XML Layout 布局文件)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&lt;span&gt;
    xmlns:tools&lt;/span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;span&gt;
    android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:layout_height&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
    android:background&lt;/span&gt;=&quot;@drawable/background&quot;&lt;span&gt;
    tools:context&lt;/span&gt;=&quot;.MainActivity&quot;&amp;gt;
    &amp;lt;&lt;span&gt;LinearLayout
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:id&lt;/span&gt;=&quot;@+id/lineOne&quot;&amp;gt;
        &amp;lt;&lt;span&gt;ImageView
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:background&lt;/span&gt;=&quot;@drawable/head&quot;&lt;span&gt;
            android:layout_margin&lt;/span&gt;=&quot;30dp&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;TextView
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot;通 讯 录&quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;30dp&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;&lt;span&gt;
            android:textColor&lt;/span&gt;=&quot;#BC8F8F&quot;&lt;span&gt;
            android:layout_gravity&lt;/span&gt;=&quot;center&quot;&lt;span&gt;
            android:layout_marginLeft&lt;/span&gt;=&quot;50dp&quot;
            /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;&lt;span&gt;LinearLayout
        android:id&lt;/span&gt;=&quot;@+id/lineTwo&quot;&lt;span&gt;
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:layout_below&lt;/span&gt;=&quot;@+id/lineOne&quot;&lt;span&gt;
        android:layout_marginTop&lt;/span&gt;=&quot;20dp&quot;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
        android:layout_marginRight&lt;/span&gt;=&quot;18dp&quot;&amp;gt;
        &amp;lt;&lt;span&gt;TextView
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot;姓 名 : &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;EditText
            android:id&lt;/span&gt;=&quot;@+id/et_name&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:hint&lt;/span&gt;=&quot;     请输入姓名&quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:maxLength&lt;/span&gt;=&quot;14&quot;/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;&lt;span&gt;LinearLayout
        android:id&lt;/span&gt;=&quot;@+id/lineTree&quot;&lt;span&gt;
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:layout_below&lt;/span&gt;=&quot;@+id/lineTwo&quot;&lt;span&gt;
        android:layout_marginTop&lt;/span&gt;=&quot;10dp&quot;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
        android:layout_marginRight&lt;/span&gt;=&quot;18dp&quot;&amp;gt;
        &amp;lt;&lt;span&gt;TextView
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot;电 话 : &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;EditText
            android:id&lt;/span&gt;=&quot;@+id/et_phone&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:hint&lt;/span&gt;=&quot;     请输入手机号码&quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:maxLength&lt;/span&gt;=&quot;11&quot;/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;&lt;span&gt;LinearLayout
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
        android:id&lt;/span&gt;=&quot;@+id/lineFour&quot;&lt;span&gt;
        android:layout_below&lt;/span&gt;=&quot;@+id/lineTree&quot;&lt;span&gt;
        android:layout_marginTop&lt;/span&gt;=&quot;30dp&quot;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
        android:layout_marginRight&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
        android:orientation&lt;/span&gt;=&quot;horizontal&quot;&amp;gt;
        &amp;lt;&lt;span&gt;Button
            android:id&lt;/span&gt;=&quot;@+id/btn_add&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:background&lt;/span&gt;=&quot;@drawable/shape&quot;&lt;span&gt;
            android:layout_weight&lt;/span&gt;=&quot;1&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot; 添 加 &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:textColor&lt;/span&gt;=&quot;#c2c8ec&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;Button
            android:id&lt;/span&gt;=&quot;@+id/btn_query&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:background&lt;/span&gt;=&quot;@drawable/shape&quot;&lt;span&gt;
            android:layout_weight&lt;/span&gt;=&quot;1&quot;&lt;span&gt;
            android:layout_marginLeft&lt;/span&gt;=&quot;4dp&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot; 查 询 &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:textColor&lt;/span&gt;=&quot;#c2c8ec&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;Button
            android:id&lt;/span&gt;=&quot;@+id/btn_update&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:background&lt;/span&gt;=&quot;@drawable/shape&quot;&lt;span&gt;
            android:layout_weight&lt;/span&gt;=&quot;1&quot;&lt;span&gt;
            android:layout_marginLeft&lt;/span&gt;=&quot;4dp&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot; 修 改 &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:textColor&lt;/span&gt;=&quot;#c2c8ec&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
        &amp;lt;&lt;span&gt;Button
            android:id&lt;/span&gt;=&quot;@+id/btn_delete&quot;&lt;span&gt;
            android:layout_width&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
            android:background&lt;/span&gt;=&quot;@drawable/shape&quot;&lt;span&gt;
            android:layout_weight&lt;/span&gt;=&quot;1&quot;&lt;span&gt;
            android:layout_marginLeft&lt;/span&gt;=&quot;4dp&quot;&lt;span&gt;
            android:text&lt;/span&gt;=&quot; 删 除 &quot;&lt;span&gt;
            android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
            android:textColor&lt;/span&gt;=&quot;#c2c8ec&quot;&lt;span&gt;
            android:textStyle&lt;/span&gt;=&quot;bold&quot;/&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;&lt;span&gt;TextView
        android:id&lt;/span&gt;=&quot;@+id/tv_show&quot;&lt;span&gt;
        android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
        android:layout_height&lt;/span&gt;=&quot;180dp&quot;&lt;span&gt;
        android:scrollbars&lt;/span&gt;=&quot;vertical&quot;&lt;span&gt;
        android:layout_below&lt;/span&gt;=&quot;@+id/lineFour&quot;&lt;span&gt;
        android:layout_marginTop&lt;/span&gt;=&quot;20dp&quot;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;=&quot;20dp&quot;&lt;span&gt;
        android:layout_marginRight&lt;/span&gt;=&quot;18dp&quot;&lt;span&gt;
        android:textSize&lt;/span&gt;=&quot;20dp&quot;/&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. shape.xml (Button 按钮设置)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&lt;span&gt;
    android:shape&lt;/span&gt;=&quot;rectangle&quot;&amp;gt;

    &amp;lt;!--设置背景色--&amp;gt;
    &amp;lt;solid android:color=&quot;#BC8F8F&quot; /&amp;gt;

    &amp;lt;!--设置圆角--&amp;gt;
    &amp;lt;corners android:radius=&quot;105dip&quot; /&amp;gt;

    &amp;lt;!--设置边框线的宽度和颜色--&amp;gt;
    &amp;lt;stroke android:width=&quot;0dp&quot; android:color=&quot;#B0C4DE&quot; /&amp;gt;
&amp;lt;/shape&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、Android 个人通讯录功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 添加&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 分别添加联系人：姓名：小 明    电话：13888899922&lt;/p&gt;
&lt;p&gt;　　　　　　　　 姓名：小 莉    电话：15866655588&lt;/p&gt;
&lt;p&gt; 添加联系人功能验证：姓名：小 明    电话：13888899922&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213203519380-1839626276.png&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;524&quot;/&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213203737937-1880892816.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;526&quot;/&gt;&lt;/p&gt;

&lt;p&gt;添加联系人功能验证：姓名：小 莉    电话：15866655588&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213203918734-1371216367.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;524&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213204023510-1188916175.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;523&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 测试中的一些问题：1. 联系人电话号码不能重复添加，程序会终止退出，因为联系人的电话号码是唯一的（一个人可以有多个手机号，而一个手机号只能一个人使用 {该功能程序已经实现} ）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　 2. 电话号码长度限制为11位。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　 3. 联系人信息为空不能成功添加。&lt;/p&gt;
&lt;p&gt;再次添加联系人：姓名：小 莉    电话：15866655588&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213204435475-223414439.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;520&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213204857045-1540511247.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;519&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213205210551-1093175318.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;519&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上述功能问题限制的重点代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人电话号码唯一性&lt;/span&gt;
&lt;span&gt;
@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(SQLiteDatabase db){
        db.execSQL(&lt;/span&gt;&quot;create table person(id integer primary key autoincrement,name varchar(20),phone varchar(20) unique)&quot;&lt;span&gt;);
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;电话号码长度限制&lt;/span&gt;

&amp;lt;&lt;span&gt;EditText
   android:id&lt;/span&gt;=&quot;@+id/et_phone&quot;&lt;span&gt;
   android:layout_width&lt;/span&gt;=&quot;match_parent&quot;&lt;span&gt;
   android:layout_height&lt;/span&gt;=&quot;wrap_content&quot;&lt;span&gt;
   android:hint&lt;/span&gt;=&quot;     请输入手机号码&quot;&lt;span&gt;
   android:textSize&lt;/span&gt;=&quot;16dp&quot;&lt;span&gt;
   android:maxLength&lt;/span&gt;=&quot;11&quot;/&amp;gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息为空时的限制&lt;/span&gt;

　　　　　　　　&lt;span&gt;case&lt;/span&gt; R.id.btn_add:       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加联系人&lt;/span&gt;
                name =&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                db &lt;/span&gt;=&lt;span&gt; myHelper.getWritableDatabase();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息添加失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;insert into person (name,phone) values(?,?)&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息添加成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查询通讯录联系人功能验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213210122412-1488852430.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;508&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213210413069-1673161054.png&quot; alt=&quot;&quot; width=&quot;285&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;

&lt;p&gt;联系人查询重点代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询联系人&lt;/span&gt;

　　　　　　&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.btn_query:    
                db &lt;/span&gt;=&lt;span&gt; myHelper.getReadableDatabase();
                Cursor cursor &lt;/span&gt;= db.rawQuery(&quot;select name,phone from person&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cursor.getCount() == 0&lt;span&gt;){
                    tvShow.setText(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;空目录&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    cursor.moveToFirst();
                    tvShow.setText(&lt;/span&gt;&quot;Name：&quot; + cursor.getString(0) + &quot; ; Tel：&quot; + cursor.getString(1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (cursor.moveToNext()){
                        tvShow.append(&lt;/span&gt;&quot;\n&quot; + &quot;Name：&quot; + cursor.getString(0) + &quot; ; Tel：&quot; + cursor.getString(1&lt;span&gt;));
                    }
                }
                cursor.close();
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;修改联系人功能验证：姓名：小 明    电话：13888899922   ===》》》  姓名：小 明    电话：15888899922&lt;/p&gt;
&lt;p&gt;注意小问题：必须输入联系人姓名和电话号码，才可以成功进行修改，在数据库中修改一句name字段值进行匹配&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213211747688-1148477254.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;518&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213212003324-1092540981.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;519&quot;/&gt;&lt;/p&gt;

&lt;p&gt;联系人修改重点代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改联系人&lt;/span&gt;

　　　　　　&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.btn_update:    
                db &lt;/span&gt;=&lt;span&gt; myHelper.getWritableDatabase();
                name &lt;/span&gt;=&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;update person set name=?,phone=? where name=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone, name});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试中的一些问题：联系人为空时不能进行修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213212302290-897551366.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;524&quot;/&gt;            &lt;/p&gt;

&lt;p&gt;上述功能问题限制的重点代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;update person set name=?,phone=? where name=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone, name});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息修改成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 删除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 删除联系人功能验证：姓名：小 明    电话：15888899922&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213212840769-2108913330.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;524&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213213307779-1510316120.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;523&quot;/&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213213430256-1990309805.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;

&lt;p&gt;联系人删除重点代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除联系人&lt;/span&gt;

　　　　　　　&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.btn_delete:   
                db &lt;/span&gt;=&lt;span&gt; myHelper.getWritableDatabase();
                name &lt;/span&gt;=&lt;span&gt; etName.getText().toString().trim();
                phone &lt;/span&gt;=&lt;span&gt; etPhone.getText().toString().trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;delete from person where name=? and phone=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                db.close();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试中的一些问题：联系人为空时不能进行删除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201902/1594459-20190213213714700-1160686762.png&quot; alt=&quot;&quot; width=&quot;314&quot; height=&quot;563&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上述功能问题限制的重点代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　if&lt;/span&gt; (name.equals(&quot;&quot;) || phone.equals(&quot;&quot;)){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;联系人信息不能为空&lt;/span&gt;
                    Toast.makeText(&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除失败&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    db.execSQL(&lt;/span&gt;&quot;delete from person where name=? and phone=?&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{name, phone});
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;联系人信息删除成功&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 13 Feb 2019 13:41:00 +0000</pubDate>
<dc:creator>Pretty_girll</dc:creator>
<og:description>一、Android 个人手机通讯录开发 数据存储：SQLite 数据库 开发工具：Android Studio 二、Phone Module 简介 1. 界面展示 2. 文件结构简单分析 三、个人手机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/prettygirll/p/10371967.html</dc:identifier>
</item>
<item>
<title>[总结] 圆方树学习笔记 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/10371908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/10371908.html</guid>
<description>&lt;p&gt;分为圆方树和广义圆方树。前者处理仙人掌，后者处理一般无向图。&lt;/p&gt;
&lt;p&gt;只学了后一个。&lt;/p&gt;

&lt;p&gt;在无向图中进行&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{Tarjan}\)&lt;/span&gt;，对于每个点双构建一个方点，方点向点双中的所有点连边。&lt;/p&gt;
&lt;p&gt;这就建好了一张新图。&lt;/p&gt;
&lt;p&gt;对于一般的题，可以在圆点上维护这个点的信息，方点上维护这个点双的信息。这样就可以支持一些对无向图路径的操作了。&lt;/p&gt;
&lt;p&gt;贴一张网上找来的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/cjoieryl/1143095/o_a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察一些性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;圆点只能和方点相邻，同样的，方点只和圆点相邻。&lt;/li&gt;
&lt;li&gt;如果两个方点有公共相邻的圆点，那这个圆点就是这两个方点代表的点双的割点。&lt;/li&gt;
&lt;li&gt;还有很多但是我找不到了...&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;apio2018-铁人两项&quot;&gt;[APIO2018] 铁人两项&lt;/h2&gt;
&lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;p&gt;给定一张 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个点 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 条边的无向图，请求出三元组 &lt;span class=&quot;math inline&quot;&gt;\((s,c,f)\)&lt;/span&gt; 的个数，使得存在一条从 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 经过点 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的简单路径。&lt;span class=&quot;math inline&quot;&gt;\(n,m\leq 2\cdot 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;sol&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;先求出圆方树。&lt;/p&gt;
&lt;p&gt;考虑枚举 &lt;span class=&quot;math inline&quot;&gt;\(s,f\)&lt;/span&gt;，那么合法的 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 个数就是 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 间的点双的点数和减去 &lt;span class=&quot;math inline&quot;&gt;\(s,f\)&lt;/span&gt; 这两个点。&lt;/p&gt;
&lt;p&gt;设方点权值为点双的点数，圆点的权值为 &lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的数量就是 &lt;span class=&quot;math inline&quot;&gt;\(s,f\)&lt;/span&gt; 两点之间的点权和。&lt;/p&gt;
&lt;p&gt;考虑枚举中点 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;，那点 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的贡献就是经过 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的路径数目*它的权值。&lt;/p&gt;
&lt;p&gt;树形&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{DP}\)&lt;/span&gt;即可&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://paste.ubuntu.com/p/vBmsgm6P3j/&quot;&gt;代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;cf487e-tourists&quot;&gt;[CF487E] Tourists&lt;/h2&gt;
&lt;h3 id=&quot;description-1&quot;&gt;Description&lt;/h3&gt;
&lt;p&gt;给定一张 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个点 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 条边的无向联通图，每个点有权值 &lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;。要求支持：带修改，求两点之间所有路径上的最小权值。&lt;/p&gt;
&lt;h3 id=&quot;sol-1&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;如果不带修改怎么办？&lt;/p&gt;
&lt;p&gt;还是求出圆方树。&lt;/p&gt;
&lt;p&gt;把方点的点权设为点双中的最小权值，圆点权值即为本身的权值。&lt;/p&gt;
&lt;p&gt;问题就变成了询问链上最小值。树剖即可。&lt;/p&gt;
&lt;p&gt;加上修改呢？&lt;/p&gt;
&lt;p&gt;如果还按照刚才的方法维护，假设一个点是割点，同时属于很多点双，那么在修改这个点的权值时，会顺便修改与它相连的所有方点的权值。如果这是个菊花图就卡掉了。&lt;/p&gt;
&lt;p&gt;考虑一种套路，就是让每个点维护的信息少一点点，然后修改的复杂度就不那么大了，例子就是用&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{lct}\)&lt;/span&gt;做&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{Qtree6}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里也可以这样做，具体是让每个方点的权值不包含它的父亲（它的父亲肯定是圆点以及肯定在这个点双中），也就是说每个圆点的值只对圆方树上它的父亲有贡献。这样如果修改一个点的复杂度就降下来了。&lt;/p&gt;
&lt;p&gt;那再回来考虑询问因为少维护了一些信息会出什么&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{bug}\)&lt;/span&gt;，发现就是当&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{lca}\)&lt;/span&gt;为方点时，会少算这个方点的父亲的点权，特判一下就好了。&lt;/p&gt;
&lt;p&gt;所以拿圆方树+树剖+&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{mutiset}\)&lt;/span&gt;就可以解决本题了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://paste.ubuntu.com/p/fMYYSCb76X/&quot;&gt;代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Feb 2019 13:34:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<og:description>圆方树。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/10371908.html</dc:identifier>
</item>
<item>
<title>一步步封装实现自己的网络请求框架 - leavesC</title>
<link>http://www.cnblogs.com/leavesC/p/10371873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leavesC/p/10371873.html</guid>
<description>&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;现如今 Android 领域流行的网络请求框架基本都是用 &lt;strong&gt;Retrofit 加 RxJava&lt;/strong&gt; 来搭配构建的，而以 &lt;strong&gt;ViewModel + LiveData + Retrofit + RxJava&lt;/strong&gt; 来构建请求框架的例子要相对少得多。而本文就是以这四者作为基础组件，介绍如何一步步封装实现自己的网络请求框架（本文实现的例子不仅仅只是一个网络请求框架，同时也是在介绍应用的架构模式），希望对你有所帮助&lt;/p&gt;
&lt;p&gt;目前已实现的功能或者说特色包含以下几点：&lt;/p&gt;
&lt;p&gt;1、网络请求结果基于观察者模式进行传递，回调操作与 UI 层的生命周期相绑定，避免了内存泄漏&lt;/p&gt;
&lt;p&gt;2、数据加载时的 startLoading 与加载结束后的 dismissLoading 操作都是自动调用的，具体实现都封装在基类中。当然，子类也可以实现自己的特定实现。例如，本文提供的例子中，BaseActivity 实现的加载对话框是 ProgressDialog ，子 Activity 可以自主实现其他弹窗形式&lt;/p&gt;
&lt;p&gt;3、当网络请求结果为非成功状态时（网络请求失败或者业务请求失败），默认操作是用 Toast 提示失败原因，支持自定义实现失败时的操作&lt;/p&gt;
&lt;p&gt;4、逻辑操作与 UI 层相分离，基于观察者模式来实现消息驱动 UI 变化。提供了在 ViewModel 中操作 UI 变化的能力，包括使 Activity / Fragment 弹出对话框、Toast 消息、finishActivity 等 UI 操作，但 ViewModel 不持有 Activity / Fragment 的引用，而是基于消息驱动实现，从而避免了内存泄漏&lt;/p&gt;
&lt;h4 id=&quot;源码点击这里查看viewmodel_retrofit_rxjava&quot;&gt;源码点击这里查看：&lt;a href=&quot;https://github.com/leavesC/ViewModel_Retrofit_RxJava&quot;&gt;ViewModel_Retrofit_RxJava&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;apk-点击这里下载viewmodel_retrofit_rxjava&quot;&gt;Apk 点击这里下载：&lt;a href=&quot;https://www.pgyer.com/ViewModel_Retrofit_RxJava&quot;&gt;ViewModel_Retrofit_RxJava&lt;/a&gt;&lt;/h4&gt;
&lt;h3 id=&quot;二封装-baseviewmodel-与-baseactivity&quot;&gt;二、封装 BaseViewModel 与 BaseActivity&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ViewModel&lt;/strong&gt; 与 &lt;strong&gt;LiveData&lt;/strong&gt; 都是 &lt;strong&gt;Android Jetpack&lt;/strong&gt; 架构组件之一。ViewModel 被设计用来存储和管理 UI 相关数据，以便数据能在界面销毁时（比如屏幕旋转）保存数据，而与 &lt;strong&gt;ViewModel&lt;/strong&gt; 相挂钩的 &lt;strong&gt;LiveData&lt;/strong&gt; 是一个用于保存可以被观察的值的数据持有类，且遵循应用组件的生命周期，只有在组件的生命周期处于活跃状态时才会收到数据更新通知&lt;/p&gt;
&lt;p&gt;既然是消息驱动，那么自然需要一个用于抽象消息类型的 &lt;strong&gt;Event&lt;/strong&gt; 类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/9/30 22:17
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public class BaseEvent {

    private int action;

    public BaseEvent(int action) {
        this.action = action;
    }

    public int getAction() {
        return action;
    }

}

public class BaseActionEvent extends BaseEvent {

    public static final int SHOW_LOADING_DIALOG = 1;

    public static final int DISMISS_LOADING_DIALOG = 2;

    public static final int SHOW_TOAST = 3;

    public static final int FINISH = 4;

    public static final int FINISH_WITH_RESULT_OK = 5;

    private String message;

    public BaseActionEvent(int action) {
        super(action);
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BaseActionEvent&lt;/strong&gt; 即用于向 &lt;strong&gt;View 层&lt;/strong&gt;传递 &lt;strong&gt;Action&lt;/strong&gt; 的 &lt;strong&gt;Model&lt;/strong&gt;，在 &lt;strong&gt;ViewModel&lt;/strong&gt; 通过向 &lt;strong&gt;View 层&lt;/strong&gt;传递不同的消息类型，从而触发相对应的操作。因此，&lt;strong&gt;BaseViewModel&lt;/strong&gt; 需要向子类提供默认的实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IViewModelAction {

    void startLoading();

    void startLoading(String message);

    void dismissLoading();

    void showToast(String message);

    void finish();

    void finishWithResultOk();

    MutableLiveData&amp;lt;BaseActionEvent&amp;gt; getActionLiveData();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/9/30 22:24
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public class BaseViewModel extends ViewModel implements IViewModelAction {

    private MutableLiveData&amp;lt;BaseActionEvent&amp;gt; actionLiveData;

    protected LifecycleOwner lifecycleOwner;

    public BaseViewModel() {
        actionLiveData = new MutableLiveData&amp;lt;&amp;gt;();
    }

    @Override
    public void startLoading() {
        startLoading(null);
    }

    @Override
    public void startLoading(String message) {
        BaseActionEvent baseActionEvent = new BaseActionEvent(BaseActionEvent.SHOW_LOADING_DIALOG);
        baseActionEvent.setMessage(message);
        actionLiveData.setValue(baseActionEvent);
    }

    @Override
    public void dismissLoading() {
        actionLiveData.setValue(new BaseActionEvent(BaseActionEvent.DISMISS_LOADING_DIALOG));
    }

    @Override
    public void showToast(String message) {
        BaseActionEvent baseActionEvent = new BaseActionEvent(BaseActionEvent.SHOW_TOAST);
        baseActionEvent.setMessage(message);
        actionLiveData.setValue(baseActionEvent);
    }

    @Override
    public void finish() {
        actionLiveData.setValue(new BaseActionEvent(BaseActionEvent.FINISH));
    }

    @Override
    public void finishWithResultOk() {
        actionLiveData.setValue(new BaseActionEvent(BaseActionEvent.FINISH_WITH_RESULT_OK));
    }

    @Override
    public MutableLiveData&amp;lt;BaseActionEvent&amp;gt; getActionLiveData() {
        return actionLiveData;
    }

    void setLifecycleOwner(LifecycleOwner lifecycleOwner) {
        this.lifecycleOwner = lifecycleOwner;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那作为消息发送方的 &lt;strong&gt;BaseViewModel&lt;/strong&gt; 的具体实现就完成了，之后是消息的接收方 &lt;strong&gt;BaseActivity / BaseFragment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BaseActivity&lt;/strong&gt; 通过监听 &lt;strong&gt;BaseViewModel&lt;/strong&gt; 中 &lt;strong&gt;actionLiveData&lt;/strong&gt; 的数据变化从而在&lt;strong&gt;网络请求开始加载时 startLoading&lt;/strong&gt;，在&lt;strong&gt;加载结束时 dismissLoading&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般一个 &lt;strong&gt;Activity&lt;/strong&gt; 对应一个 &lt;strong&gt;ViewModel&lt;/strong&gt;，少部分情况是会对应多个 &lt;strong&gt;ViewModel&lt;/strong&gt;，因此 &lt;strong&gt;initViewModel()&lt;/strong&gt; 声明为了抽象方法，而 &lt;strong&gt;initViewModelList()&lt;/strong&gt; 默认返回了 null&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2017/11/29 21:04
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
@SuppressLint(&quot;Registered&quot;)
public abstract class BaseActivity extends AppCompatActivity {

    private ProgressDialog loadingDialog;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initViewModelEvent();
    }

    protected abstract ViewModel initViewModel();

    protected List&amp;lt;ViewModel&amp;gt; initViewModelList() {
        return null;
    }

    private void initViewModelEvent() {
        List&amp;lt;ViewModel&amp;gt; viewModelList = initViewModelList();
        if (viewModelList != null &amp;amp;&amp;amp; viewModelList.size() &amp;gt; 0) {
            observeEvent(viewModelList);
        } else {
            ViewModel viewModel = initViewModel();
            if (viewModel != null) {
                List&amp;lt;ViewModel&amp;gt; modelList = new ArrayList&amp;lt;&amp;gt;();
                modelList.add(viewModel);
                observeEvent(modelList);
            }
        }
    }

    private void observeEvent(List&amp;lt;ViewModel&amp;gt; viewModelList) {
        for (ViewModel viewModel : viewModelList) {
            if (viewModel instanceof IViewModelAction) {
                IViewModelAction viewModelAction = (IViewModelAction) viewModel;
                viewModelAction.getActionLiveData().observe(this, baseActionEvent -&amp;gt; {
                    if (baseActionEvent != null) {
                        switch (baseActionEvent.getAction()) {
                            case BaseActionEvent.SHOW_LOADING_DIALOG: {
                                startLoading(baseActionEvent.getMessage());
                                break;
                            }
                            case BaseActionEvent.DISMISS_LOADING_DIALOG: {
                                dismissLoading();
                                break;
                            }
                            case BaseActionEvent.SHOW_TOAST: {
                                showToast(baseActionEvent.getMessage());
                                break;
                            }
                            case BaseActionEvent.FINISH: {
                                finish();
                                break;
                            }
                            case BaseActionEvent.FINISH_WITH_RESULT_OK: {
                                setResult(RESULT_OK);
                                finish();
                                break;
                            }
                        }
                    }
                });
            }
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        dismissLoading();
    }

    protected void startLoading() {
        startLoading(null);
    }

    protected void startLoading(String message) {
        if (loadingDialog == null) {
            loadingDialog = new ProgressDialog(this);
            loadingDialog.setCancelable(false);
            loadingDialog.setCanceledOnTouchOutside(false);
        }
        loadingDialog.setTitle(message);
        loadingDialog.show();
    }

    protected void dismissLoading() {
        if (loadingDialog != null &amp;amp;&amp;amp; loadingDialog.isShowing()) {
            loadingDialog.dismiss();
        }
    }

    protected void showToast(String message) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }

    protected void finishWithResultOk() {
        setResult(RESULT_OK);
        finish();
    }

    protected BaseActivity getContext() {
        return BaseActivity.this;
    }

    protected void startActivity(Class cl) {
        startActivity(new Intent(this, cl));
    }

    public void startActivityForResult(Class cl, int requestCode) {
        startActivityForResult(new Intent(this, cl), requestCode);
    }

    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)
    protected boolean isFinishingOrDestroyed() {
        return isFinishing() || isDestroyed();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三封装-retrofit-与-rxjava&quot;&gt;三、封装 Retrofit 与 RxJava&lt;/h3&gt;
&lt;p&gt;在前言中说了，框架默认实现了请求失败时的操作（Toast 提示失败原因），也支持自定义回调接口。因此，需要两个回调接口，一个只包含请求成功时的回调接口，另一个多包含了一个请求失败时的回调接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/10/27 20:53
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public interface RequestCallback&amp;lt;T&amp;gt; {

    void onSuccess(T t);

}

public interface RequestMultiplyCallback&amp;lt;T&amp;gt; extends RequestCallback&amp;lt;T&amp;gt; {

    void onFail(BaseException e);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，为了在网络请求成功但业务逻辑请求失败时（例如，请求参数缺失、Token失效等），可以抛出详细的失败信息，需要自定义 &lt;strong&gt;BaseException&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BaseException extends RuntimeException {

    private int errorCode = HttpCode.CODE_UNKNOWN;

    public BaseException() {
    }

    public BaseException(int errorCode, String errorMessage) {
        super(errorMessage);
        this.errorCode = errorCode;
    }

    public int getErrorCode() {
        return errorCode;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现具体的异常类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ParamterInvalidException extends BaseException {

    public ParamterInvalidException() {
        super(HttpCode.CODE_PARAMETER_INVALID, &quot;参数有误&quot;);
    }

}

public class TokenInvalidException extends BaseException {

    public TokenInvalidException() {
        super(HttpCode.CODE_TOKEN_INVALID, &quot;Token失效&quot;);
    }

}

···&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了提升性能，&lt;strong&gt;Retrofit&lt;/strong&gt; 一般是设计成单例模式。为了应对应用中 &lt;strong&gt;BaseUrl&lt;/strong&gt; 可能有多个的情况（本文提供的Demo就是如此），此处使用 &lt;strong&gt;Map&lt;/strong&gt; 来存储多个 &lt;strong&gt;Retrofit&lt;/strong&gt; 实例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/10/26 23:11
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public class RetrofitManagement {

    private static final long READ_TIMEOUT = 6000;

    private static final long WRITE_TIMEOUT = 6000;

    private static final long CONNECT_TIMEOUT = 6000;

    private final Map&amp;lt;String, Object&amp;gt; serviceMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private RetrofitManagement() {

    }

    public static RetrofitManagement getInstance() {
        return RetrofitHolder.retrofitManagement;
    }

    private static class RetrofitHolder {
        private static final RetrofitManagement retrofitManagement = new RetrofitManagement();
    }

    private Retrofit createRetrofit(String url) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .readTimeout(READ_TIMEOUT, TimeUnit.MILLISECONDS)
                .writeTimeout(WRITE_TIMEOUT, TimeUnit.MILLISECONDS)
                .connectTimeout(CONNECT_TIMEOUT, TimeUnit.MILLISECONDS)
                .addInterceptor(new HttpInterceptor())
                .addInterceptor(new HeaderInterceptor())
                .addInterceptor(new FilterInterceptor())
                .retryOnConnectionFailure(true);
        if (BuildConfig.DEBUG) {
            HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();
            httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
            builder.addInterceptor(httpLoggingInterceptor);
            builder.addInterceptor(new ChuckInterceptor(ContextHolder.getContext()));
        }
        OkHttpClient client = builder.build();
        return new Retrofit.Builder()
                .client(client)
                .baseUrl(url)
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                .build();
    }

    &amp;lt;T&amp;gt; ObservableTransformer&amp;lt;BaseResponseBody&amp;lt;T&amp;gt;, T&amp;gt; applySchedulers() {
        return observable -&amp;gt; observable.subscribeOn(Schedulers.io())
                .unsubscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .flatMap(result -&amp;gt; {
                    switch (result.getCode()) {
                        case HttpCode.CODE_SUCCESS: {
                            return createData(result.getData());
                        }
                        case HttpCode.CODE_TOKEN_INVALID: {
                            throw new TokenInvalidException();
                        }
                        case HttpCode.CODE_ACCOUNT_INVALID: {
                            throw new AccountInvalidException();
                        }
                        default: {
                            throw new ServerResultException(result.getCode(), result.getMsg());
                        }
                    }
                });
    }


    private &amp;lt;T&amp;gt; Observable&amp;lt;T&amp;gt; createData(T t) {
        return Observable.create(new ObservableOnSubscribe&amp;lt;T&amp;gt;() {
            @Override
            public void subscribe(ObservableEmitter&amp;lt;T&amp;gt; emitter) {
                try {
                    emitter.onNext(t);
                    emitter.onComplete();
                } catch (Exception e) {
                    emitter.onError(e);
                }
            }
        });
    }

    &amp;lt;T&amp;gt; T getService(Class&amp;lt;T&amp;gt; clz) {
        return getService(clz, HttpConfig.BASE_URL_WEATHER);
    }

    &amp;lt;T&amp;gt; T getService(Class&amp;lt;T&amp;gt; clz, String host) {
        T value;
        if (serviceMap.containsKey(host)) {
            Object obj = serviceMap.get(host);
            if (obj == null) {
                value = createRetrofit(host).create(clz);
                serviceMap.put(host, value);
            } else {
                value = (T) obj;
            }
        } else {
            value = createRetrofit(host).create(clz);
            serviceMap.put(host, value);
        }
        return value;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外还需要一个自定义的 &lt;strong&gt;Observer&lt;/strong&gt; 来对数据请求结果进行自定义回调&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/10/27 20:52
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public class BaseSubscriber&amp;lt;T&amp;gt; extends DisposableObserver&amp;lt;T&amp;gt; {

    private BaseViewModel baseViewModel;

    private RequestCallback&amp;lt;T&amp;gt; requestCallback;

    public BaseSubscriber(BaseViewModel baseViewModel) {
        this.baseViewModel = baseViewModel;
    }

    BaseSubscriber(BaseViewModel baseViewModel, RequestCallback&amp;lt;T&amp;gt; requestCallback) {
        this.baseViewModel = baseViewModel;
        this.requestCallback = requestCallback;
    }

    @Override
    public void onNext(T t) {
        if (requestCallback != null) {
            requestCallback.onSuccess(t);
        }
    }

    @Override
    public void onError(Throwable e) {
        e.printStackTrace();
        if (requestCallback instanceof RequestMultiplyCallback) {
            RequestMultiplyCallback callback = (RequestMultiplyCallback) requestCallback;
            if (e instanceof BaseException) {
                callback.onFail((BaseException) e);
            } else {
                callback.onFail(new BaseException(HttpCode.CODE_UNKNOWN, e.getMessage()));
            }
        } else {
            if (baseViewModel == null) {
                Toast.makeText(ContextHolder.getContext(), e.getMessage(), Toast.LENGTH_SHORT).show();
            } else {
                baseViewModel.showToast(e.getMessage());
            }
        }
    }

    @Override
    public void onComplete() {

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四baseremotedatasource-与-baserepo&quot;&gt;四、BaseRemoteDataSource 与 BaseRepo&lt;/h3&gt;
&lt;p&gt;上文所介绍的 &lt;strong&gt;RequestCallback、RetrofitManagement 与 BaseSubscriber&lt;/strong&gt; 还是一个个单独的个体，还需要一个&lt;strong&gt;链接器&lt;/strong&gt;来将之串起来，这个链接器的实现类即 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里，对 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 的定位是将之当成一个&lt;strong&gt;接口实现者&lt;/strong&gt;，即在 &lt;strong&gt;RemoteDataSource&lt;/strong&gt; 中实际调用各个请求接口，并通过 &lt;strong&gt;RxJava&lt;/strong&gt; 来控制 &lt;strong&gt;loading 弹出以及销毁的时机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般而言，&lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 的实现类中声明的是具有相关逻辑的接口。例如，对于登录模块，可声明一个 &lt;strong&gt;LoginDataSource&lt;/strong&gt;，对于设置模块，可以声明一个 &lt;strong&gt;SettingsDataSource&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/10/27 7:42
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public abstract class BaseRemoteDataSource {

    private CompositeDisposable compositeDisposable;

    private BaseViewModel baseViewModel;

    public BaseRemoteDataSource(BaseViewModel baseViewModel) {
        this.compositeDisposable = new CompositeDisposable();
        this.baseViewModel = baseViewModel;
    }

    protected &amp;lt;T&amp;gt; T getService(Class&amp;lt;T&amp;gt; clz) {
        return RetrofitManagement.getInstance().getService(clz);
    }

    protected &amp;lt;T&amp;gt; T getService(Class&amp;lt;T&amp;gt; clz, String host) {
        return RetrofitManagement.getInstance().getService(clz, host);
    }

    private &amp;lt;T&amp;gt; ObservableTransformer&amp;lt;BaseResponseBody&amp;lt;T&amp;gt;, T&amp;gt; applySchedulers() {
        return RetrofitManagement.getInstance().applySchedulers();
    }

    protected &amp;lt;T&amp;gt; void execute(Observable observable, RequestCallback&amp;lt;T&amp;gt; callback) {
        execute(observable, new BaseSubscriber&amp;lt;&amp;gt;(baseViewModel, callback), true);
    }

    protected &amp;lt;T&amp;gt; void execute(Observable observable, RequestMultiplyCallback&amp;lt;T&amp;gt; callback) {
        execute(observable, new BaseSubscriber&amp;lt;&amp;gt;(baseViewModel, callback), true);
    }

    public void executeWithoutDismiss(Observable observable, Observer observer) {
        execute(observable, observer, false);
    }

    private void execute(Observable observable, Observer observer, boolean isDismiss) {
        Disposable disposable = (Disposable) observable
                .throttleFirst(500, TimeUnit.MILLISECONDS)
                .subscribeOn(Schedulers.io())
                .unsubscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .compose(applySchedulers())
                .compose(isDismiss ? loadingTransformer() : loadingTransformerWithoutDismiss())
                .subscribeWith(observer);
        addDisposable(disposable);
    }

    private void addDisposable(Disposable disposable) {
        compositeDisposable.add(disposable);
    }

    public void dispose() {
        if (!compositeDisposable.isDisposed()) {
            compositeDisposable.dispose();
        }
    }

    private void startLoading() {
        if (baseViewModel != null) {
            baseViewModel.startLoading();
        }
    }

    private void dismissLoading() {
        if (baseViewModel != null) {
            baseViewModel.dismissLoading();
        }
    }

    private &amp;lt;T&amp;gt; ObservableTransformer&amp;lt;T, T&amp;gt; loadingTransformer() {
        return observable -&amp;gt; observable
                .subscribeOn(AndroidSchedulers.mainThread())
                .unsubscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSubscribe(disposable -&amp;gt; startLoading())
                .doFinally(this::dismissLoading);
    }

    private &amp;lt;T&amp;gt; ObservableTransformer&amp;lt;T, T&amp;gt; loadingTransformerWithoutDismiss() {
        return observable -&amp;gt; observable
                .subscribeOn(AndroidSchedulers.mainThread())
                .unsubscribeOn(AndroidSchedulers.mainThread())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnSubscribe(disposable -&amp;gt; startLoading());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 外，还需要一个 &lt;strong&gt;BaseRepo&lt;/strong&gt;。对 &lt;strong&gt;BaseRepo&lt;/strong&gt; 的定位是将其当做一个接口调度器，其持有 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 的实例并中转 &lt;strong&gt;ViewModel&lt;/strong&gt; 的接口调用请求，并可以在 &lt;strong&gt;BaseRepo&lt;/strong&gt; 分担一部分&lt;strong&gt;数据处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 作者：leavesC
 * 时间：2018/10/27 21:10
 * 描述：
 * GitHub：https://github.com/leavesC
 * Blog：https://www.jianshu.com/u/9df45b87cfdf
 */
public class BaseRepo&amp;lt;T&amp;gt; {

    protected T remoteDataSource;

    public BaseRepo(T remoteDataSource) {
        this.remoteDataSource = remoteDataSource;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，&lt;strong&gt;ViewModel&lt;/strong&gt; 不关心接口的实际调用实现，方便以后更换 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 的实现方式，且将一部分的数据处理逻辑放到了 &lt;strong&gt;BaseRepo&lt;/strong&gt; ，有利于逻辑的复用&lt;/p&gt;
&lt;h3 id=&quot;五实践操作1-请求天气数据&quot;&gt;五、实践操作（1）-请求天气数据&lt;/h3&gt;
&lt;p&gt;上文讲了一些基础组件的逻辑实现以及对其的定位，此小节就以一个请求天气数据的接口为例，来介绍如何具体实现一个网络请求的整体流程&lt;/p&gt;
&lt;p&gt;首先是声明接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ApiService {

    @Headers({HttpConfig.HTTP_REQUEST_TYPE_KEY + &quot;:&quot; + HttpConfig.HTTP_REQUEST_WEATHER})
    @GET(&quot;onebox/weather/query&quot;)
    Observable&amp;lt;BaseResponseBody&amp;lt;Weather&amp;gt;&amp;gt; queryWeather(@Query(&quot;cityname&quot;) String cityName);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加的头部信息是为了标明该接口的请求类型，因为本文作为 demo 的几个接口所用到的 &lt;strong&gt;baseUrl&lt;/strong&gt; 以及 &lt;strong&gt;请求key&lt;/strong&gt; 并不相同，因此通过声明头部来为接口动态指定请求参数，而这就需要用到 &lt;strong&gt;Retrofit 的拦截器了&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterInterceptor implements Interceptor {

    @NonNull
    @Override
    public Response intercept(@NonNull Chain chain) throws IOException {
        Request originalRequest = chain.request();
        HttpUrl.Builder httpBuilder = originalRequest.url().newBuilder();
        Headers headers = originalRequest.headers();
        if (headers != null &amp;amp;&amp;amp; headers.size() &amp;gt; 0) {
            String requestType = headers.get(HttpConfig.HTTP_REQUEST_TYPE_KEY);
            if (!TextUtils.isEmpty(requestType)) {
                switch (requestType) {
                    case HttpConfig.HTTP_REQUEST_WEATHER: {
                        httpBuilder.addQueryParameter(HttpConfig.KEY, HttpConfig.KEY_WEATHER);
                        break;
                    }
                    case HttpConfig.HTTP_REQUEST_QR_CODE: {
                        httpBuilder.addQueryParameter(HttpConfig.KEY, HttpConfig.KEY_QR_CODE);
                        break;
                    }
                    case HttpConfig.HTTP_REQUEST_NEWS: {
                        httpBuilder.addQueryParameter(HttpConfig.KEY, HttpConfig.KEY_NEWS);
                        break;
                    }
                }
            }
        }
        Request.Builder requestBuilder = originalRequest.newBuilder()
                .removeHeader(HttpConfig.HTTP_REQUEST_TYPE_KEY)
                .url(httpBuilder.build());
        return chain.proceed(requestBuilder.build());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明 &lt;strong&gt;BaseRemoteDataSource&lt;/strong&gt; 的实现类 &lt;strong&gt;WeatherDataSource&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeatherDataSource extends BaseRemoteDataSource implements IWeatherDataSource {

    public WeatherDataSource(BaseViewModel baseViewModel) {
        super(baseViewModel);
    }

    @Override
    public void queryWeather(String cityName, RequestCallback&amp;lt;Weather&amp;gt; responseCallback) {
        execute(getService(ApiService.class).queryWeather(cityName), responseCallback);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明 &lt;strong&gt;BaseRepo&lt;/strong&gt; 的实现类 &lt;strong&gt;WeatherRepo&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeatherRepo extends BaseRepo&amp;lt;IWeatherDataSource&amp;gt; {

    public WeatherRepo(IWeatherDataSource remoteDataSource) {
        super(remoteDataSource);
    }

    public MutableLiveData&amp;lt;Weather&amp;gt; queryWeather(String cityName) {
        MutableLiveData&amp;lt;Weather&amp;gt; weatherMutableLiveData = new MutableLiveData&amp;lt;&amp;gt;();
        remoteDataSource.queryWeather(cityName, new RequestCallback&amp;lt;Weather&amp;gt;() {
            @Override
            public void onSuccess(Weather weather) {
                weatherMutableLiveData.setValue(weather);
            }
        });
        return weatherMutableLiveData;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还需要一个 &lt;strong&gt;WeatherViewModel&lt;/strong&gt;，&lt;strong&gt;View 层&lt;/strong&gt;通过调用 &lt;strong&gt;queryWeather()&lt;/strong&gt; 方法在请求成功时触发 &lt;strong&gt;weatherLiveData&lt;/strong&gt; 更新数据，&lt;strong&gt;View 层&lt;/strong&gt;已事先监听 &lt;strong&gt;weatherLiveData&lt;/strong&gt;，并在数据更新时就可以立即收到最新数据&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeatherViewModel extends BaseViewModel {

    private MutableLiveData&amp;lt;Weather&amp;gt; weatherLiveData;

    private WeatherRepo weatherRepo;

    public WeatherViewModel() {
        weatherLiveData = new MutableLiveData&amp;lt;&amp;gt;();
        weatherRepo = new WeatherRepo(new WeatherDataSource(this));
    }

    public void queryWeather(String cityName) {
        weatherRepo.queryWeather(cityName).observe(lifecycleOwner, new Observer&amp;lt;Weather&amp;gt;() {
            @Override
            public void onChanged(@Nullable Weather weather) {
                weatherLiveData.setValue(weather);
            }
        });
    }

    public MutableLiveData&amp;lt;Weather&amp;gt; getWeatherLiveData() {
        return weatherLiveData;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;QueryWeatherActivity&lt;/strong&gt; 中打印出接口的请求结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QueryWeatherActivity extends BaseActivity {

    private static final String TAG = &quot;QueryWeatherActivity&quot;;

    private WeatherViewModel weatherViewModel;

    private EditText et_cityName;

    private TextView tv_weather;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_query_weather);
        et_cityName = findViewById(R.id.et_cityName);
        tv_weather = findViewById(R.id.tv_weather);
    }

    @Override
    protected ViewModel initViewModel() {
        weatherViewModel = LViewModelProviders.of(this, WeatherViewModel.class);
        weatherViewModel.getWeatherLiveData().observe(this, this::handlerWeather);
        return weatherViewModel;
    }

    private void handlerWeather(Weather weather) {
        StringBuilder result = new StringBuilder();
        for (Weather.InnerWeather.NearestWeather nearestWeather : weather.getData().getWeather()) {
            result.append(&quot;\n\n&quot;).append(new Gson().toJson(nearestWeather));
        }
        tv_weather.setText(result.toString());
    }

    public void queryWeather(View view) {
        tv_weather.setText(null);
        weatherViewModel.queryWeather(et_cityName.getText().toString());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-fe4f1a54a0520919.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许有人会觉得为了请求一个接口需要建立三个实现类（&lt;strong&gt;WeatherDataSource、WeatherRepo、WeatherViewModel&lt;/strong&gt;）以及一个接口（&lt;strong&gt;IQrCodeDataSource&lt;/strong&gt;）有点繁琐，但这是想要划分职责并实现逻辑与UI相隔离的必然结果。&lt;strong&gt;WeatherDataSource 用来实现接口的实际调用，只负责请求数据并传递请求结果。WeatherRepo 用来屏蔽 WeatherViewModel 对 WeatherDataSource 的感知，并承担起一部分数据处理逻辑。WeatherViewModel 用于实现逻辑与 UI 的隔离，并保障数据不因为页面重建而丢失。这样，Activity 就可以尽量只承担数据呈现的职责，而不必掺杂数据处理逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;六实践操作2-请求生成二维码&quot;&gt;六、实践操作（2）-请求生成二维码&lt;/h3&gt;
&lt;p&gt;此处再来看一个例子，用于生成指定内容的二维码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QrCodeDataSource extends BaseRemoteDataSource implements IQrCodeDataSource {

    public QrCodeDataSource(BaseViewModel baseViewModel) {
        super(baseViewModel);
    }

    @Override
    public void createQrCode(String text, int width, RequestCallback&amp;lt;QrCode&amp;gt; callback) {
        execute(getService(ApiService.class, HttpConfig.BASE_URL_QR_CODE).createQrCode(text, width), callback);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处接口请求回来的只是一段 base64 编码的字符串，而外部希望获取到的自然是一个可以直接使用的 Bitmap ，因此可以在 Repo 中先对数据进行转换后再传递到外部&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QrCodeRepo extends BaseRepo&amp;lt;IQrCodeDataSource&amp;gt; {

    public QrCodeRepo(IQrCodeDataSource remoteDataSource) {
        super(remoteDataSource);
    }

    public MutableLiveData&amp;lt;QrCode&amp;gt; createQrCode(String text, int width) {
        MutableLiveData&amp;lt;QrCode&amp;gt; liveData = new MutableLiveData&amp;lt;&amp;gt;();
        remoteDataSource.createQrCode(text, width, new RequestCallback&amp;lt;QrCode&amp;gt;() {
            @SuppressLint(&quot;CheckResult&quot;)
            @Override
            public void onSuccess(QrCode qrCode) {
                Observable.create(new ObservableOnSubscribe&amp;lt;Bitmap&amp;gt;() {
                    @Override
                    public void subscribe(@NonNull ObservableEmitter&amp;lt;Bitmap&amp;gt; emitter) throws Exception {
                        Bitmap bitmap = base64ToBitmap(qrCode.getBase64_image());
                        emitter.onNext(bitmap);
                        emitter.onComplete();
                    }
                }).subscribeOn(Schedulers.io())
                        .observeOn(AndroidSchedulers.mainThread())
                        .subscribe(new Consumer&amp;lt;Bitmap&amp;gt;() {
                            @Override
                            public void accept(@NonNull Bitmap bitmap) throws Exception {
                                qrCode.setBitmap(bitmap);
                                liveData.setValue(qrCode);
                            }
                        });
            }
        });
        return liveData;
    }

    private static Bitmap base64ToBitmap(String base64String) {
        byte[] decode = Base64.decode(base64String, Base64.DEFAULT);
        return BitmapFactory.decodeByteArray(decode, 0, decode.length);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QrCodeViewModel extends BaseViewModel {

    private MutableLiveData&amp;lt;QrCode&amp;gt; qrCodeLiveData;

    private QrCodeRepo qrCodeRepo;

    public QrCodeViewModel() {
        qrCodeLiveData = new MutableLiveData&amp;lt;&amp;gt;();
        qrCodeRepo = new QrCodeRepo(new QrCodeDataSource(this));
    }

    public void createQrCode(String text, int width) {
        qrCodeRepo.createQrCode(text, width).observe(lifecycleOwner, new Observer&amp;lt;QrCode&amp;gt;() {
            @Override
            public void onChanged(@Nullable QrCode qrCode) {
                qrCodeLiveData.setValue(qrCode);
            }
        });
    }

    public MutableLiveData&amp;lt;QrCode&amp;gt; getQrCodeLiveData() {
        return qrCodeLiveData;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-ed8dc39db70fa115.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;七实践操作3-请求失败示例&quot;&gt;七、实践操作（3）-请求失败示例&lt;/h3&gt;
&lt;p&gt;前言说了，本文封装的网络框架当网络请求结果为非成功状态时（网络请求失败或者业务请求失败），默认操作是用 Toast 提示失败原因，也支持自定义实现失败时的操作。此处就来看当请求失败时如何进行处理&lt;/p&gt;
&lt;p&gt;此处需要声明两个并不存在的接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ApiService {

    @GET(&quot;leavesC/test1&quot;)
    Observable&amp;lt;BaseResponseBody&amp;lt;String&amp;gt;&amp;gt; test1();

    @GET(&quot;leavesC/test2&quot;)
    Observable&amp;lt;BaseResponseBody&amp;lt;String&amp;gt;&amp;gt; test2();

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FailExampleDataSource extends BaseRemoteDataSource implements IFailExampleDataSource {

    public FailExampleDataSource(BaseViewModel baseViewModel) {
        super(baseViewModel);
    }

    @Override
    public void test1(RequestCallback&amp;lt;String&amp;gt; callback) {
        execute(getService(ApiService.class).test1(), callback);
    }

    @Override
    public void test2(RequestCallback&amp;lt;String&amp;gt; callback) {
        execute(getService(ApiService.class).test2(), callback);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FailExampleRepo extends BaseRepo&amp;lt;IFailExampleDataSource&amp;gt; {

    public FailExampleRepo(IFailExampleDataSource remoteDataSource) {
        super(remoteDataSource);
    }

    public MutableLiveData&amp;lt;String&amp;gt; test1() {
        MutableLiveData&amp;lt;String&amp;gt; newsPackMutableLiveData = new MutableLiveData&amp;lt;&amp;gt;();
        remoteDataSource.test1(new RequestCallback&amp;lt;String&amp;gt;() {
            @Override
            public void onSuccess(String newsPack) {
                newsPackMutableLiveData.setValue(newsPack);
            }
        });
        return newsPackMutableLiveData;
    }

    public void test2(RequestMultiplyCallback&amp;lt;String&amp;gt; callback) {
        remoteDataSource.test2(callback);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;test1()&lt;/strong&gt; 方法用的是基础类的默认失败回调，即直接 Toast 提示失败信息。而 &lt;strong&gt;test2()&lt;/strong&gt; 方法则是自定义了请求失败时的回调操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FailExampleViewModel extends BaseViewModel {

    private MutableLiveData&amp;lt;String&amp;gt; test1LiveData = new MutableLiveData&amp;lt;&amp;gt;();

    private MutableLiveData&amp;lt;String&amp;gt; test2LiveData = new MutableLiveData&amp;lt;&amp;gt;();

    private FailExampleRepo failExampleRepo = new FailExampleRepo(new FailExampleDataSource(this));

    public void test1() {
        failExampleRepo.test1().observe(lifecycleOwner, new Observer&amp;lt;String&amp;gt;() {
            @Override
            public void onChanged(@Nullable String s) {
                test1LiveData.setValue(s);
            }
        });
    }

    public void test2() {
        failExampleRepo.test2(new RequestMultiplyCallback&amp;lt;String&amp;gt;() {
            @Override
            public void onFail(BaseException e) {
                showToast(&quot;test2方法请求失败：&quot; + e.getMessage());
                finish();
            }

            @Override
            public void onSuccess(String s) {
                test2LiveData.setValue(s);
            }
        });
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-6a1c91865f644910.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;八结束语&quot;&gt;八、结束语&lt;/h3&gt;
&lt;p&gt;这就是整个请求框架的大体架构了，也经过了实际项目的考验了，目前运行良好，但里面可能还会包含一些不合理的地方，欢迎大家指正反馈，如果觉得对你有所帮助，也欢迎 star&lt;/p&gt;
&lt;h4 id=&quot;源码点击这里查看viewmodel_retrofit_rxjava-1&quot;&gt;源码点击这里查看：&lt;a href=&quot;https://github.com/leavesC/ViewModel_Retrofit_RxJava&quot;&gt;ViewModel_Retrofit_RxJava&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;apk-点击这里下载viewmodel_retrofit_rxjava-1&quot;&gt;Apk 点击这里下载：&lt;a href=&quot;https://www.pgyer.com/ViewModel_Retrofit_RxJava&quot;&gt;ViewModel_Retrofit_RxJava&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Wed, 13 Feb 2019 13:19:00 +0000</pubDate>
<dc:creator>leavesC</dc:creator>
<og:description>一、前言 现如今 Android 领域流行的网络请求框架基本都是用 Retrofit 加 RxJava 来搭配构建的，而以 ViewModel + LiveData + Retrofit + RxJa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leavesC/p/10371873.html</dc:identifier>
</item>
<item>
<title>JDK源码分析（10）之 Hashtable 相关 - 三枣</title>
<link>http://www.cnblogs.com/sanzao/p/10371789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanzao/p/10371789.html</guid>
<description>&lt;p&gt;本文的目的并不是让你对&lt;code&gt;Hashtable&lt;/code&gt;更加了解，然后灵活运用；因为&lt;code&gt;Hashtable&lt;/code&gt;的一个历史遗留的类，目前并不建议使用，所以本文主要和&lt;code&gt;HashMap&lt;/code&gt;对比，感受同样功能的不同实现，知道什么是好的代码；所以在阅读本文之前最好先了解一下 &lt;code&gt;HashMap&lt;/code&gt;，可以参考 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10245212.html&quot;&gt;HashMap 相关&lt;/a&gt;；&lt;/p&gt;
&lt;h2 id=&quot;一-类定义&quot;&gt;一、 类定义&lt;/h2&gt;
&lt;pre class=&quot;、&quot;&gt;
&lt;code&gt;public class Hashtable&amp;lt;K,V&amp;gt; extends Dictionary&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1119937/201902/1119937-20190213204745613-1551690469.png&quot; width=&quot;500&quot; alt=&quot;hashtable&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到它和&lt;code&gt;HashMap&lt;/code&gt;虽然都是哈希表，但是结构完全不一样，他是继承于&lt;code&gt;Dictionary&lt;/code&gt;；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Maps the specified &amp;lt;code&amp;gt;key&amp;lt;/code&amp;gt; to the specified
 * &amp;lt;code&amp;gt;value&amp;lt;/code&amp;gt; in this dictionary. Neither the key nor the
 * value can be &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;.
 */
abstract public V put(K key, V value);

abstract public Enumeration&amp;lt;K&amp;gt; keys();
abstract public Enumeration&amp;lt;V&amp;gt; elements();

public interface Enumeration&amp;lt;E&amp;gt; {
  boolean hasMoreElements();
  E nextElement();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同&lt;code&gt;AbstractMap&lt;/code&gt;相比功能结构基本一样，但是有两点很重要的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;要求 key 和 value，都不能为 null，也就意味着这每次 put 元素的时候都需要判空，真是想想都好痛苦；&lt;/li&gt;
&lt;li&gt;另外 keys 和 elements 返回的居然是 &lt;code&gt;Enumeration&lt;/code&gt;，这也是一个比较古老的接口，用于枚举（一次获得一个）对象集合中的元素；但是目前大多已经被&lt;code&gt;Iterator&lt;/code&gt;给取代了；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二构造方法和成员变量&quot;&gt;二、构造方法和成员变量&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private transient Entry&amp;lt;?,?&amp;gt;[] table;  // 哈希槽
private int threshold;                 // 阈值
private float loadFactor;              // 负载系数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上三个应该就是 Map 中最重要的成员变量了，阈值和负载系数控制扩容时机，同&lt;code&gt;HashMap&lt;/code&gt;的作用是一样的，哈希槽也是一样的，但是注意&lt;code&gt;Entry&amp;lt;?,?&amp;gt;[]&lt;/code&gt;这里用的居然是通配符，而不是&lt;code&gt;K V&lt;/code&gt;，也就意味着在取 entry 的时候，还需要强转类型，这也是非常神奇的地方；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Hashtable(int initialCapacity, float loadFactor) {
  if (initialCapacity &amp;lt; 0)
    throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);
  if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
    throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

  if (initialCapacity==0)
    initialCapacity = 1;
  this.loadFactor = loadFactor;
  table = new Entry&amp;lt;?,?&amp;gt;[initialCapacity];
  threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
}

public Hashtable(int initialCapacity) {
  this(initialCapacity, 0.75f);
}

public Hashtable() {
  this(11, 0.75f);
}

public Hashtable(Map&amp;lt;? extends K, ? extends V&amp;gt; t) {
  this(Math.max(2*t.size(), 11), 0.75f);
  putAll(t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如代码所示四个构造函数，主要就是为了初始化以上三个成员变量，但是注意&lt;code&gt;table&lt;/code&gt;的容量；熟悉&lt;code&gt;HashMap&lt;/code&gt;的肯定知道，&lt;code&gt;HashMap&lt;/code&gt;的容量要求是2的幂，目的是为了使用&lt;code&gt;hash % length = hash &amp;amp; (length-1)&lt;/code&gt;，优化哈希槽的定位；但是如上面代码所示&lt;code&gt;Hashtable&lt;/code&gt;的容量却不是，初始容量默认11，扩容是2倍加1；这样做的优缺点有什么呢：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缺点，不能利用“与”来优化哈希槽定位；&lt;/li&gt;
&lt;li&gt;优点，减小了哈希冲突的几率（hashmap 的容量虽然是偶数，但是对哈希做了高位与低位，以及红黑树，使得即使hash冲突十分严重，性能也能得以保证），详情可以参考 &lt;a href=&quot;https://blog.csdn.net/liuqiyao_01/article/details/14475159&quot;&gt;为什么一般hashtable的桶数会取一个素数&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三重要方法&quot;&gt;三、重要方法&lt;/h2&gt;
&lt;h3 id=&quot;哈希槽定位&quot;&gt;1. 哈希槽定位&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈希表中最重要的方法肯定是哈希槽定位，如上面的原因&lt;code&gt;Hashtable&lt;/code&gt;寻址的时候并不能做优化，所以只是用的典型除留余数法，&lt;code&gt;(hash &amp;amp; 0x7FFFFFFF)&lt;/code&gt;则是为了保证第一位符号位是0，也就是正数，保证最终的余数是正数；&lt;/p&gt;
&lt;h3 id=&quot;get-方法&quot;&gt;2. get 方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized V get(Object key) {
  Entry&amp;lt;?,?&amp;gt; tab[] = table;
  int hash = key.hashCode();
  int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
  for (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
    if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
      return (V)e.value;
    }
  }
  return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;Hashtable&lt;/code&gt;的所有方法都是&lt;code&gt;synchronized&lt;/code&gt;修饰的，所以&lt;code&gt;Hashtable&lt;/code&gt;是线程安全的容器；&lt;br/&gt;代码很简单，就是得到哈希，计算哈希桶，再一次遍历链表；但是需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;int hash = key.hashCode();&lt;/code&gt;，这里是直接取的 key 的 hashCode，所以这里不能避免极端哈希的情况；&lt;/li&gt;
&lt;li&gt;另外就是不能使用可变 key （所有容器都不能使用可变 key），例如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class A {
  String name;
  
  public A(String name) {this.name = name;}

  @Override
  public boolean equals(Object o) { ... }

  @Override
  public int hashCode() { ... }
}

private static void test01() {
  Map&amp;lt;A, String&amp;gt; map = new Hashtable&amp;lt;&amp;gt;();
  A a1 = new A(&quot;a&quot;);
  A a2 = new A(&quot;a&quot;);

  map.put(a1, &quot;a&quot;);
  map.put(a2, &quot;a&quot;);

  System.out.println(map.get(a1));

  a1.name = &quot;b&quot;;
  System.out.println(map.get(a1));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 打印：&lt;br/&gt;a&lt;br/&gt;null&lt;/p&gt;
&lt;h3 id=&quot;put-方法&quot;&gt;3. put 方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized V put(K key, V value) {
  // Make sure the value is not null
  if (value == null) {
    throw new NullPointerException();
  }

  // Makes sure the key is not already in the hashtable.
  Entry&amp;lt;?,?&amp;gt; tab[] = table;
  int hash = key.hashCode();
  int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
  @SuppressWarnings(&quot;unchecked&quot;)
  Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;)tab[index];
  for(; entry != null ; entry = entry.next) {
    if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) {
      V old = entry.value;
      entry.value = value;
      return old;
    }
  }

  addEntry(hash, key, value, index);
  return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Hashtable&lt;/code&gt;的&lt;code&gt;put&lt;/code&gt;方法和&lt;code&gt;HashMap&lt;/code&gt;相比，就显得十分清晰，先判空，在查找，找到就替换，找不到就插入新节点；但是在插入顺序（后面会讲到），红黑树性能保证等方面也就不能和&lt;code&gt;HashMap&lt;/code&gt;相比了；另外这里取出来的&lt;code&gt;Entry&lt;/code&gt;也是进行了类型强制转换；&lt;/p&gt;
&lt;h3 id=&quot;addentry-方法&quot;&gt;4. addEntry 方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void addEntry(int hash, K key, V value, int index) {
  modCount++;

  Entry&amp;lt;?,?&amp;gt; tab[] = table;
  if (count &amp;gt;= threshold) {
    // Rehash the table if the threshold is exceeded
    rehash();

    tab = table;
    hash = key.hashCode();
    index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
  }

  // Creates the new entry.
  @SuppressWarnings(&quot;unchecked&quot;)
  Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) tab[index];
  tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
  count++;
}

private static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
  final int hash;
  final K key;
  V value;
  Entry&amp;lt;K,V&amp;gt; next;

  protected Entry(int hash, K key, V value, Entry&amp;lt;K,V&amp;gt; next) {
    this.hash = hash;
    this.key =  key;
    this.value = value;
    this.next = next;
  }
  
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里添加元素的时候首先判断是否扩容，然后添加节点；值得注意的是&lt;strong&gt;添加的节点是直接放在哈希槽里的&lt;/strong&gt;（&lt;code&gt;tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);&lt;/code&gt;）大部分的 Map 实现都是将添加的节点放在链表尾部；所以&lt;code&gt;Hashtable&lt;/code&gt;中节点的相对顺序是不断变化的；&lt;/p&gt;
&lt;h3 id=&quot;rehash-方法&quot;&gt;5. rehash 方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void rehash() {
  int oldCapacity = table.length;
  Entry&amp;lt;?,?&amp;gt;[] oldMap = table;

  // overflow-conscious code
  int newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1;
  if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) {
    if (oldCapacity == MAX_ARRAY_SIZE)
      // Keep running with MAX_ARRAY_SIZE buckets
      return;
    newCapacity = MAX_ARRAY_SIZE;
  }
  Entry&amp;lt;?,?&amp;gt;[] newMap = new Entry&amp;lt;?,?&amp;gt;[newCapacity];

  modCount++;
  threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
  table = newMap;

  for (int i = oldCapacity ; i-- &amp;gt; 0 ;) {
    for (Entry&amp;lt;K,V&amp;gt; old = (Entry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != null ; ) {
      Entry&amp;lt;K,V&amp;gt; e = old;
      old = old.next;

      int index = (e.hash &amp;amp; 0x7FFFFFFF) % newCapacity;
      e.next = (Entry&amp;lt;K,V&amp;gt;)newMap[index];
      newMap[index] = e;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩容的时候也是，先计算新容量，在得到一个新的哈希槽，然后将节点在依次放入；同添加节点一样是将节点直接放到哈希槽中，那么在扩容完毕之后，链表的相对顺序会反向；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;的 key 和 value 都不能为 null，在使用的时候需要判空。。。。蛋疼&lt;/li&gt;
&lt;li&gt;哈希值完全依赖 key 的 &lt;code&gt;hashCode&lt;/code&gt;方法，所以在使用的时候，需要额外注意&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;的容量可以是任意值，默认是11，不能使用“与”来优化寻址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;的节点相对位置是不断变化的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;是线程安全的；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 13 Feb 2019 12:48:00 +0000</pubDate>
<dc:creator>三枣</dc:creator>
<og:description>本文的目的并不是让你对 更加了解，然后灵活运用；因为 的一个历史遗留的类，目前并不建议使用，所以本文主要和 对比，感受同样功能的不同实现，知道什么是好的代码；所以在阅读本文之前最好先了解一下 ，可以参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanzao/p/10371789.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（七） AVL树 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10371676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10371676.html</guid>
<description>&lt;p&gt;　　前面我们已经介绍了&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/10277762.html&quot; target=&quot;_blank&quot;&gt;二叉搜索树&lt;/a&gt;。普通的二叉搜索树在插入、删除数据时可能使得全树的数据分布不平衡，退化，导致二叉搜索树最关键的查询效率急剧降低。这也引出了平衡二叉搜索树的概念，平衡二叉搜索树在此前的基础上，通过一系列的等价变换使二叉搜索树得以始终处于&quot;&lt;strong&gt;平衡&lt;/strong&gt;&quot;的状态，拥有稳定且高效的查询效率。&lt;br/&gt;　　AVL树是最早被计算机科学家发明的自平衡二叉搜索树，AVL树得名于它的发明者G. M. &lt;strong&gt;A&lt;/strong&gt;delson-&lt;strong&gt;V&lt;/strong&gt;elsky和E. M. &lt;strong&gt;L&lt;/strong&gt;andis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。&lt;/p&gt;
&lt;p&gt;　　不同的平衡二叉搜索树对所谓&quot;平衡&quot;有不同的定义，AVL树认为&lt;strong&gt;当所有节点的左右子树高度之差不超过正负1时，全树是平衡的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　在插入新节点和删除旧节点之后，AVL树会判断当前是否有节点失去平衡，并对失衡的节点进行相应的重平衡操作，恢复到AVL树定义的适度平衡状态。&lt;/p&gt;

&lt;h2&gt;2.1 等价变换介绍&lt;/h2&gt;
&lt;p&gt;　　二叉搜索树有一个重要的特性：&lt;strong&gt;所存储元素的中序遍历次序是有序的&lt;/strong&gt;，这也是二叉搜索树能够使用二分法加速查找的基础。&lt;/p&gt;
&lt;p&gt;　　对于同一中序遍历次序，二叉搜索树的拓扑结构可以是多样的，在保持二叉搜索树中序遍历次序不变的情况下&lt;strong&gt;(等价)&lt;/strong&gt;，对其拓扑结构进行一系列变换&lt;strong&gt;(变换)&lt;/strong&gt;，被称为&lt;strong&gt;等价变换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　等价变换是平衡二叉搜索树重平衡操作的理论基础。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213163050977-263460375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 等价变换方式&lt;/h2&gt;
&lt;p&gt;　　等价变换的基本操作有两种：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;顺时针旋转(zig)，可以形象的理解为x-&amp;gt;y箭头方向下午两点变成了下午四点，也被称为右旋&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　逆时针旋转(zag)，可以形象的理解为y-&amp;gt;x箭头方向上午十点变成了上午八点，也被称为左旋&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　顺时针旋转和逆时针旋转的操作是互逆的，复杂等价变换操作可以看成是由这两种基本操作组合而成。&lt;/p&gt;
&lt;h4&gt;顺时针旋转：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190212155637550-749643254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;逆时针旋转：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190212160119990-331318801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 AVL树的失衡状态及重平衡&lt;/h2&gt;
&lt;p&gt;在了解如何恢复AVL树平衡状态之前，需要先理解几个关键点：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.&lt;/strong&gt;无论是插入新节点还是删除老节点，最多只会导致插入/删除节点位置的上层的历代祖先节点失去平衡(数量大致为 logN)，而不会导致全树节点都失去平衡，因此只需要判断其历代祖先节点的平衡状态，即可判断其是否破坏了AVL树的平衡状态&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt;当原先&lt;strong&gt;较高的子树&lt;/strong&gt;中&lt;strong&gt;插入新节点&lt;/strong&gt;时，可能会导致历代祖先节点失衡(部分祖先节点，而非全部)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.&lt;/strong&gt;当原先&lt;strong&gt;较低的子树&lt;/strong&gt;中&lt;strong&gt;删除老节点&lt;/strong&gt;时，可能会导致历代祖先节点失衡(部分祖先节点，而非全部)&lt;/p&gt;
&lt;p&gt;　　针对AVL树的失衡节点进行重平衡时，主要关注&lt;strong&gt;失衡节点自身(N Node)、引起失衡方向的孩子节点(S Son)、&lt;/strong&gt;引起失衡方向的孙子节点(GS GrandSon)及所属子树，对其进行等价变换操作，使之恢复平衡。&lt;/p&gt;
&lt;p&gt;　　我们从失衡节点出发，依据失衡节点和其引起失衡方向的孩子节点、其引起失衡方向的孙子节点的共同构成的拓扑结构，共以下四种形态：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213101334180-399445577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.3.1 左左形&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;左左形 插入节点引起失衡及重平衡：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213112809850-1318126026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左左形 删除节点引起失衡&lt;/strong&gt;及重平衡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213114253969-1350171462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.3.3 左右形&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;左右形 插入节点引起失衡&lt;/strong&gt;及重平衡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213112431582-958152650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左右形 删除节点引起失衡&lt;/strong&gt;及重平衡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213115552750-1214616447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.3.2 右右形&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;右右形和左左形是镜像的拓扑结构，失衡场景和重平衡手段与&lt;strong&gt;&quot;2.3.1 左左形&quot;&lt;/strong&gt;原理相同，限于篇幅，不再展开说明。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.3.4 右左形&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;右左形和左右形是镜像的拓扑结构，失衡场景和重平衡手段与&lt;strong&gt;&quot;2.3.2 左右形&quot;&lt;/strong&gt;原理相同，限于篇幅，不再展开说明。&lt;/p&gt;
&lt;h3&gt;2.3.5 插入和删除操作重平衡的区别&lt;/h3&gt;
&lt;p&gt;　　在示意图中，注意观察标识树高层次的&lt;strong&gt;横向细长的白色箭头&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　插入和删除操作会导致操作节点位置的历代祖先失去平衡，这需要从低到高依次检查平衡状态并进行重平衡处理。&lt;/p&gt;
&lt;p&gt;　　插入新节点导致失衡并重平衡的过程中，当前失衡节点(&lt;strong&gt;最低的失衡祖先节点&lt;/strong&gt;)所在&lt;strong&gt;子树的高度&lt;/strong&gt;在重平衡操作完成后和未插入新节点之前&lt;strong&gt;是一样的&lt;/strong&gt;。因而当最低位置的祖先节点恢复了平衡后，更高的祖先节点也将自动的恢复平衡（因为插入前是平衡的，而插入后失衡子树的高度在重平衡后也和原先一致了）。&lt;/p&gt;
&lt;p&gt;　　删除老节点导致失衡并重平衡的过程中，当前失衡节点(&lt;strong&gt;最低的&lt;/strong&gt;失衡祖先节点)所在&lt;strong&gt;子树的高度&lt;/strong&gt;在重平衡操作完成后和未插入新节点之前&lt;strong&gt;可能是不一样的(所在子树高度降低1)&lt;/strong&gt;。因而当最低位置的祖先节点恢复平衡后，可能会导致更高的祖先节点进而失去平衡，这种现象会向上逐层传播。最坏的极端情况下，每当恢复一个较低的祖先节点平衡时，都会导致更高一层祖先节点失衡，直至根节点完成重平衡，这样的重平衡操作最多需要执行&lt;strong&gt;(logN)&lt;/strong&gt;次。&lt;/p&gt;
&lt;h2&gt;2.4 3+4重构&lt;/h2&gt;
&lt;p&gt;　　前面介绍了针对不同失衡状态拓扑结构进行重平衡的方法，都是使用一&lt;strong&gt;次或多次旋转&lt;/strong&gt;的方式完成的。&lt;/p&gt;
&lt;p&gt;　　如果我们聚焦于&lt;strong&gt;重平衡操作所涉及的元素&lt;/strong&gt;，会发现其实质只是改变了&lt;strong&gt;Node&lt;/strong&gt;，&lt;strong&gt;Son&lt;/strong&gt;，&lt;strong&gt;GrandSon&lt;/strong&gt;三个节点及所挂载的四颗子树&lt;strong&gt;(T0,T1,T2,T3)&lt;/strong&gt;的位置关系。更为重要的是，无论是左左形还是其它三种形状，其重平衡完成之后的拓扑结构是一样的，&lt;strong&gt;区别只在于N，S，GS三个节点的相对位置不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　因此，便有了另一种更高效的重平衡等价变换的方式，被称为&lt;strong&gt;&quot;3+4重构&quot;&lt;/strong&gt;。3+4重构在重平衡时，暴力的将元素打散，&lt;strong&gt;并不使用旋转的技巧&lt;/strong&gt;，而是直接改变节点和节点、节点和子树之间的引用关系，一口气将其转变为重平衡之后的最终拓扑结构，直达目标。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190213160319324-2130527065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.1 二叉搜索树拓展&lt;/h2&gt;
&lt;p&gt;　　AVL树的实现继承自前面介绍的普通二叉搜索树—TreeMap类。由于AVL树通过树高作为判断平衡的依据，因此在二叉搜索树&lt;strong&gt;TreeMap&lt;/strong&gt;的节点中增加了一个&lt;strong&gt;height(高度)&lt;/strong&gt;属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 二叉搜索树 内部节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * key值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        K key;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * value值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        V value;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 高度值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; left;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 双亲节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent;

        EntryNode(K key, V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height = 1&lt;span&gt;;
        }

        EntryNode(K key, V value,EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height = 1&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; K getKey() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; + value + &quot; height=&quot; +&lt;span&gt; height;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 辅助方法&lt;/h2&gt;
&lt;p&gt;　　在AVL树的实现过程中，存在一些通用的，细节的逻辑，将其抽取成辅助函数，简化主要代码逻辑，增强代码可读性和可维护性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前节点 是否满足AVL树约定的平衡条件
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAVLBalanced(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; entryNode){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得 左子树高度&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; leftChildHeight =&lt;span&gt; getHeight(entryNode.left);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得右子树高度&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; rightChildHeight =&lt;span&gt; getHeight(entryNode.right);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得左右子树高度差&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; difference = leftChildHeight -&lt;span&gt; rightChildHeight;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高度差绝对值在1之内,认为是满足AVL平衡条件&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; -1 &amp;lt;= difference &amp;amp;&amp;amp; difference &amp;lt;= 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新当前节点高度
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateHeight(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; entryNode){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftHeight =&lt;span&gt; getHeight(entryNode.left);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightHeight =&lt;span&gt; getHeight(entryNode.right);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右子树高度较高者 + 1&lt;/span&gt;
        entryNode.height = 1 +&lt;span&gt; Math.max(leftHeight,rightHeight);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前节点的高度
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getHeight(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; entryNode){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(entryNode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entryNode.height;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得较高子树分支孩子节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; getTallerChild(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; entryNode){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftChildHeight =&lt;span&gt; getHeight(entryNode.left);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightChildHeight =&lt;span&gt; getHeight(entryNode.right);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(leftChildHeight &amp;gt;&lt;span&gt; rightChildHeight){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树高度 &amp;gt; 右子树高度&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entryNode.left;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树高度 &amp;lt;= 右子树高度&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entryNode.right;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否是左孩子
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isLeftChild(EntryNode&amp;lt;K,V&amp;gt; parent,EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getRelativeByParent(parent,target) ==&lt;span&gt; RelativePosition.LEFT;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 3+4重构实现&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;refactor34&lt;/strong&gt;方法：方法的参数为3+4重构目标拓扑结构所需的三个节点(左，中，右)，左右孩子的分别挂载的四颗子树。在&lt;strong&gt;refactor34&lt;/strong&gt;方法中，依照3+4重构的原理直接调整节点和子树的关系引用，拼接成最终的所需的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;rotateAt&lt;/strong&gt;方法：方法的参数为重平衡所涉及到的祖孙三代节点(&lt;strong&gt;Node、Son、GrandSon&lt;/strong&gt;)，通过判断&lt;strong&gt;N、S、GS&lt;/strong&gt;的拓扑结构，决定调用&lt;strong&gt;refactor34&lt;/strong&gt;方法时传递的参数。方法的返回值为3+4重构后的子树树根节点，便于重平衡操作之后，将重构后新的子树重新接入整颗AVL树中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 3+4 重构
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refactor34(
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; leftNode, EntryNode&amp;lt;K,V&amp;gt; middleNode, EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; rightNode,
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; llChild, EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; lrChild,
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; rlChild, EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; rrChild){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整 左节点和对应子树的拓扑结构&lt;/span&gt;
        leftNode.left =&lt;span&gt; llChild;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(llChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            llChild.parent &lt;/span&gt;=&lt;span&gt; leftNode;
        }

        leftNode.right &lt;/span&gt;=&lt;span&gt; lrChild;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lrChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            lrChild.parent &lt;/span&gt;=&lt;span&gt; leftNode;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新高度&lt;/span&gt;
&lt;span&gt;        updateHeight(leftNode);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整 右节点和对应子树的拓扑结构&lt;/span&gt;
        rightNode.left =&lt;span&gt; rlChild;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rlChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            rlChild.parent &lt;/span&gt;=&lt;span&gt; rightNode;
        }

        rightNode.right &lt;/span&gt;=&lt;span&gt; rrChild;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rrChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            rrChild.parent &lt;/span&gt;=&lt;span&gt; rightNode;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新高度&lt;/span&gt;
&lt;span&gt;        updateHeight(rightNode);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整 中间节点 和左、右节点的拓扑结构&lt;/span&gt;
        middleNode.left =&lt;span&gt; leftNode;
        middleNode.right &lt;/span&gt;=&lt;span&gt; rightNode;

        leftNode.parent &lt;/span&gt;=&lt;span&gt; middleNode;
        rightNode.parent &lt;/span&gt;=&lt;span&gt; middleNode;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新高度&lt;/span&gt;
&lt;span&gt;        updateHeight(middleNode);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 进行旋转,使用3+4重构完成重平衡
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 重构之后子树的树根节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; rotateAt(EntryNode&amp;lt;K,V&amp;gt; currentNode,EntryNode&amp;lt;K,V&amp;gt; sonNode,EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; grandSonNode){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLeftChild(currentNode,sonNode)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左 zig&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLeftChild(sonNode,grandSonNode)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左-左   zig-zig旋转&lt;/span&gt;
&lt;span&gt;                refactor34(grandSonNode,sonNode,currentNode,
                    grandSonNode.left,grandSonNode.right,sonNode.right,currentNode.right);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sonNode;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左-右   zig-zag旋转&lt;/span&gt;
&lt;span&gt;                refactor34(sonNode,grandSonNode,currentNode,
                    sonNode.left,grandSonNode.left,grandSonNode.right,currentNode.right);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; grandSonNode;
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右 zag&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLeftChild(sonNode,grandSonNode)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右-左   zag-zig旋转&lt;/span&gt;
&lt;span&gt;                refactor34(currentNode,grandSonNode,sonNode,
                    currentNode.left,grandSonNode.left,grandSonNode.right,sonNode.right);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; grandSonNode;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右-右   zag-zag旋转&lt;/span&gt;
&lt;span&gt;                refactor34(currentNode,sonNode,grandSonNode,
                    currentNode.left,sonNode.left,grandSonNode.left,grandSonNode.right);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sonNode;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.4 插入方法重写&lt;/h2&gt;
&lt;p&gt;　　AVL树的实现中，重写了普通二叉搜索树的插入方法(&lt;strong&gt;put&lt;/strong&gt;)，整体逻辑和之前TreeMap的实现大致一样，唯一的区别在于，当插入了新的节点之后，会调用&lt;strong&gt;afterNewNodeInsert&lt;/strong&gt;方法，进行AVL树重平衡的一系列操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;afterNewNodeInsert&lt;/strong&gt;方法：&lt;/p&gt;
&lt;p&gt;　　参数为新插入的节点。从下至上，遍历检查新插入节点的历代祖先，判断其是否失衡。一旦发现当前迭代的祖先节点失衡，则调用&lt;strong&gt;rotateAt&lt;/strong&gt;方法，使其恢复平衡，全树重新接入子树；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;插入节点时，导致的失衡不会向上传播&lt;/strong&gt;，所属子树的高度能够复原，在恢复平衡之后，直接结束方法的执行，不再继续向上检查。另外，对于未失衡的祖先节点，其&lt;strong&gt;子树插入新节点&lt;/strong&gt;时&lt;strong&gt;可能&lt;/strong&gt;会导致&lt;strong&gt;高度上升&lt;/strong&gt;，因此需要更新其高度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标节点存在于当前容器

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;暂存之前的value&lt;/span&gt;
            V oldValue =&lt;span&gt; targetEntryNode.target.value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换为新的value&lt;/span&gt;
            targetEntryNode.target.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回之前的value&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标节点不存在于当前容器&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; targetEntryNode.parent;
            EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; newEntryNode = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value,parent);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标节点位于左边&lt;/span&gt;
                parent.left =&lt;span&gt; newEntryNode;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标节点位于右边&lt;/span&gt;
                parent.right =&lt;span&gt; newEntryNode;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入新节点后进行重平衡操作&lt;/span&gt;
&lt;span&gt;            afterNewNodeInsert(newEntryNode);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入后 重平衡操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newEntryNode 新插入的节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterNewNodeInsert(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; newEntryNode){
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; currentAncestorNode =&lt;span&gt; newEntryNode.parent;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历新插入节点的祖先节点,逐层向上&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(currentAncestorNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前祖先节点是否失去平衡&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isAVLBalanced(currentAncestorNode)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不平衡

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得重构之前 失衡节点的父节点及其相对位置，用于之后重新连接重平衡后的子树&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; currentAncestorNode.parent;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得更高子树分支对应的孙辈节点，决定AVL树重平衡的策略&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; tallerSonNode =&lt;span&gt; getTallerChild(currentAncestorNode);
                EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; tallerGrandSonNode =&lt;span&gt; getTallerChild(tallerSonNode);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以孙辈节点为基准，进行旋转，重平衡&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; newSubTreeRoot =&lt;span&gt; rotateAt(currentAncestorNode,tallerSonNode,tallerGrandSonNode);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重构之后的子树 重新和全树对接&lt;/span&gt;
                newSubTreeRoot.parent =&lt;span&gt; parent;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能currentAncestorNode是根节点，不存在双亲节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原子树根节点的双亲节点 和新的子树进行连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLeftChild(parent,currentAncestorNode)){
                        parent.left &lt;/span&gt;=&lt;span&gt; newSubTreeRoot;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        parent.right &lt;/span&gt;=&lt;span&gt; newSubTreeRoot;
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; newSubTreeRoot;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入时，最低失衡节点重平衡后，全树即恢复平衡，因此结束循环&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;平衡

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新当前祖先节点的高度&lt;/span&gt;
&lt;span&gt;                updateHeight(currentAncestorNode);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向上一层祖先节点&lt;/span&gt;
            currentAncestorNode =&lt;span&gt; currentAncestorNode.parent;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.5 删除方法重写&lt;/h2&gt;
&lt;p&gt;　　AVL树的实现中，重写了普通二叉搜索树的删除方法(&lt;strong&gt;remove&lt;/strong&gt;)，整体逻辑和之前TreeMap的实现大致一样，唯一的区别在于，当删除了之前老的节点之后，会调用&lt;strong&gt;afterNodeRemove&lt;/strong&gt;方法，进行AVL树重平衡的一系列操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;afterNodeRemove&lt;/strong&gt;方法：&lt;/p&gt;
&lt;p&gt;　　参数为之前被删除节点的双亲节点。从下至上，遍历检查被删除节点双亲的历代祖先，判断其是否失衡。一旦发现当前迭代的祖先节点失衡，则调用&lt;strong&gt;rotateAt&lt;/strong&gt;方法，使其恢复平衡，全树重新接入子树。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;删除节点时，失衡现象会向上传播&lt;/strong&gt;，因此必须一直向上遍历至根节点。另外，对于未失衡的祖先节点，&lt;strong&gt;子树删除老节点&lt;/strong&gt;时&lt;strong&gt;可能&lt;/strong&gt;会导致&lt;strong&gt;高度降低&lt;/strong&gt;，因此需要更新其高度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(K key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition !=&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有找到目标节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到了目标节点&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; target =&lt;span&gt; targetEntryNode.target;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先保存被删除节点 删除之前的双亲节点&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; target.parent;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从二叉树中删除目标节点&lt;/span&gt;
&lt;span&gt;            deleteEntryNode(target);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点后，对其历代祖先节点进行重平衡操作&lt;/span&gt;
&lt;span&gt;            afterNodeRemove(parent);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetEntryNode.target.value;
        }
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入后 重平衡操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; deletedNode 被删除的节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterNodeRemove(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; deletedNode){
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; currentAncestorNode =&lt;span&gt; deletedNode;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历新插入节点的祖先节点,逐层向上&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(currentAncestorNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前祖先节点是否失去平衡&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isAVLBalanced(currentAncestorNode)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不平衡

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得重构之前 失衡节点的父节点及其相对位置&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; currentAncestorNode.parent;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得更高子树分支对应的孙辈节点，决定AVL树重平衡的策略&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; tallerSonNode =&lt;span&gt; getTallerChild(currentAncestorNode);
                EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; tallerGrandSonNode =&lt;span&gt; getTallerChild(tallerSonNode);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以孙辈节点为基准，进行旋转，重平衡&lt;/span&gt;
                EntryNode&amp;lt;K,V&amp;gt; newSubTreeRoot =&lt;span&gt; rotateAt(currentAncestorNode,tallerSonNode,tallerGrandSonNode);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重构之后的子树 重新和全树对接&lt;/span&gt;
                newSubTreeRoot.parent =&lt;span&gt; parent;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能currentAncestorNode是根节点，不存在双亲节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原子树根节点的双亲节点 和新的子树进行连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLeftChild(parent,currentAncestorNode)){
                        parent.left &lt;/span&gt;=&lt;span&gt; newSubTreeRoot;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        parent.right &lt;/span&gt;=&lt;span&gt; newSubTreeRoot;
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; newSubTreeRoot;
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;平衡

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新当前祖先节点的高度&lt;/span&gt;
&lt;span&gt;                updateHeight(currentAncestorNode);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向上一层祖先节点&lt;/span&gt;
            currentAncestorNode =&lt;span&gt; currentAncestorNode.parent;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.1 插入性能&lt;/h2&gt;
&lt;p&gt;　　AVL树的插入操作引起的失衡不会向上传播，只需要一次重平衡操作。&lt;/p&gt;
&lt;p&gt;　　相比普通二叉搜索树，AVL树插入重平衡操作额外引入的&lt;strong&gt;时间复杂度为O(1)&lt;/strong&gt;，十分高效。&lt;/p&gt;
&lt;h2&gt;4.2 删除性能&lt;/h2&gt;
&lt;p&gt;　　AVL树的删除操作引起的失衡会向上传播，最坏情况下每一个祖先节点都需要进行重平衡。&lt;/p&gt;
&lt;p&gt;　　相比普通二叉搜索树，AVL树删除重平衡操作额外引入的时间复杂度为&lt;strong&gt;O(logN)&lt;/strong&gt;，删除效率比起红黑树&lt;strong&gt;(O(1))&lt;/strong&gt;等更加高效的BBST相对要差。&lt;/p&gt;
&lt;h2&gt;4.3 查询性能&lt;/h2&gt;
&lt;p&gt;　　AVL树适度平衡的条件比较苛刻，因此AVL树是非常接近完全二叉树的一种BBST。其查询效率和红黑树等综合性能更加优秀的BBST相比，查询时，虽然渐进的时间复杂度都为&lt;strong&gt;O(logN)&lt;/strong&gt;，但在常数倍率上看，效率要稍高一点点。&lt;/p&gt;

&lt;p&gt;　　AVL树作为最早被发明的自平衡二叉搜索树，其删除效率与随后被发明的红黑树、伸展树相比，相差一个数量级&lt;strong&gt;(O(logN) vs O(1))&lt;/strong&gt;。其主要原因是红黑树等BBST在&quot;平衡&quot;的定义上进一步放松了标准，全树结构不如AVL树那么紧凑，略为降低了查询效率，但换来了删除效率的巨大提升。&lt;/p&gt;
&lt;p&gt;　　AVL树作为一种相对效率较低的BBST，其原理相比红黑树来说更为简单。我个人认为，理解AVL树是理解更为强大、复杂的BBST的基础之一。希望大家能更好的理解平衡二叉搜索树，更好的理解自己所使用的数据结构，从而写出更高效，易维护的程序。&lt;/p&gt;
&lt;p&gt;　　本系列博客的代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Feb 2019 12:15:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.AVL树介绍 前面我们已经介绍了二叉搜索树。普通的二叉搜索树在插入、删除数据时可能使得全树的数据分布不平衡，退化，导致二叉搜索树最关键的查询效率急剧降低。这也引出了平衡二叉搜索树的概念，平衡二叉搜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10371676.html</dc:identifier>
</item>
<item>
<title>重温分布式系统的CAP理论 - justinme</title>
<link>http://www.cnblogs.com/justinme/p/10371684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justinme/p/10371684.html</guid>
<description>&lt;h3 id=&quot;cap理论的历史&quot;&gt;1. CAP理论的历史&lt;/h3&gt;
&lt;p&gt;2000年7月，Eric Brewer教授提出CAP猜想；2年后，Seth Gilbert和Nancy Lynch从理论上证明了CAP；之后，CAP理论正式成为分布式计算领域的公认定理。&lt;/p&gt;
&lt;h3 id=&quot;cap的背景和定义&quot;&gt;2. CAP的背景和定义&lt;/h3&gt;
&lt;p&gt;CAP理论讨论的对象是分布式场景。一个分布式系统需要满足三个最基本的特性，分别是一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance，这个中文翻译很不直观，没能体现Partition原来的意思，这也人为拉高了理解成本，至少对以前的我是这样，后面会单独介绍）。CAP理论的简单解释就是，不可能存在一个完美的分布式架构，能同时满足这三个特性。架构师们不要试图花精力去设计一个“完美”的架构来满足这三个特性，而是应该因地制宜，根据实际的需求在CAP之间做权衡。&lt;/p&gt;
&lt;p&gt;这里也只是从字面意思对CAP做了个翻译，并不便于理解，下面结合一个具体的例子来说明。&lt;/p&gt;
&lt;p&gt;下图是一个假想的最小（典型的）分布式应用场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/833df1ccly1g051vrsywrj20ds0bqgm3.jpg&quot; alt=&quot;image-20190212175317444&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两台服务器Node1, Node2（在分布式环境中，习惯叫节点）构成一个服务集群，对外提供服务&lt;/li&gt;
&lt;li&gt;客户Client可以随机访问任何一台服务器上的服务&lt;/li&gt;
&lt;li&gt;两台服务器内部之间也可以互相访问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个简单的分布式系统需要满足哪些特性才算得上是一个比较好的系统（产品）呢？思考以下几个场景：&lt;/p&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;客户访问Node1时写入了一个数据（比如往账户存了100元），当客户要读取该值时又随机访问了Node2，系统需要保证Node2也能够返回正确的值，这个就是所谓的一致性要求（Consistency）。&lt;/p&gt;
&lt;p&gt;一致性的权威解释如下（来自证明CAP理论的原作者）：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Consistency&lt;/p&gt;
&lt;p&gt;any read operation that begins after a write operation completes must return that value, or the result of a later write operation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;当客户访问某个节点时，如果该节点正常工作，系统需要保证该节点必须要给客户一个响应（可以是错误的响应，也可以有一定的延迟，但是不能没有响应），也就是说任何时刻必须保证请求能得到响应，这就是系统的可用性要求（Availability）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Availability&lt;/p&gt;
&lt;p&gt;every request received by a non-failing node in the system must result in a response&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;在分布式环境中，每个节点都不是可靠的，各节点之间的通信也可能出问题。当某些节点出现故障（或者节点本身的故障，或者部分网络故障）时，整个系统就产生了所谓的”分区“。当系统产生”分区“的时候，如果还能对外提供比较好的服务（例如较好的一致性和可用性），就可以说该系统具有较好的”分区容错性“（Partition Tolerance）。&lt;/p&gt;
&lt;p&gt;如果对分区还不好理解的话，看看partition的英文解释吧：&lt;/p&gt;
&lt;p&gt;(n.) a wall or screen that separate one part of a room from another&lt;/p&gt;
&lt;p&gt;(v.) to separate one area, one part of a room, etc. from another with a wall or screen&lt;/p&gt;
&lt;p&gt;就是分割、隔离的意思，也就是说因为某些原因，部分节点被隔离到集群之外的时候，整个系统还能够正常工作，对外表现得就像没事儿一样。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Partition Tolerance&lt;/p&gt;
&lt;p&gt;the network will be allowed to lose arbitrarily many messages sent from one node to another&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;cap为什么不能同时满足&quot;&gt;3. CAP为什么不能同时满足&lt;/h3&gt;
&lt;p&gt;有兴趣深入了解的同学，可以在这里看原始的证明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf&quot; class=&quot;uri&quot;&gt;https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;浅显易懂点的，可以参考这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/&quot; class=&quot;uri&quot;&gt;https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再简单点的解释就是这样，考虑下面的一个场景：&lt;/p&gt;
&lt;p&gt;Client写入数据到Node1；Node2出现分区导致Node1的数据没有同步到Node2；Client访问Node2读取数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同时满足AP：系统保证在Node2出现分区的情况下，还能立即返回结果给Client。但此时Node2还没有同步到Node1的数据，所以没法保证数据的一致性&lt;/li&gt;
&lt;li&gt;同时满足CP：系统保证在Node2出现分区的情况下，能返回一致的结果给Client。这个只能等到Node2正确同步到Node1的数据之后才能返回（有可能永远同步不了），因此不能立即返回（也可能永远无法返回），也就失去了可用性&lt;/li&gt;
&lt;li&gt;同时满足CA：Node2能保证返回准确一致的数据给到Client，但考虑到这是一个分布式系统，是没法保证每个节点都能正常工作不产生分区的（虽然集群的所有节点同时出现故障的概率非常低，但是单个节点出现故障的概率还是比较高的）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cap理论在现实中的应用&quot;&gt;4. CAP理论在现实中的应用&lt;/h3&gt;
&lt;p&gt;既然理论是这样，我们就不要浪费时间去设计完美的分布式系统，这就是方法论起的作用。&lt;/p&gt;
&lt;p&gt;考虑到在分布式场景中，系统产生分区的情况无法避免，我们就只能尽量提供一个比较好的”分区容错性“的产品。换句话说，我们需要在系统出现分区的时候，在一致性和可用性之间做权衡。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;CP：优先保证数据的一致性，在数据没有一致的情况下，可以适当降低系统的可用性，比如放弃当前的请求，让客户端重试；或者降低对客户端的响应速度（比如银行转账结束时等待5s的提示界面）。ZooKeeper被设计为在分布式系统中协调服务、保证各服务节点数据一致的产品，就是CP的例子。还有各种分布式数据库产品，如Redis、HBase，也都是偏向数据一致性的CP的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;AP：优先保证系统的可用性，降低数据的一致性诉求。比如电商网站的下单界面展示的可购买数量，这个是时时变化的。如果要保证一致性，则需要系统时时刷新获取最新的数据，势必会影响网站的响应速度，也就降低了可用性，影响用户体验（可以改为在真正下单的那一刻再提示库存是否满足下单条件）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，随着基础设施越来越完善，分布式系统中出现P的情况也可以控制的越来越精细。在不用特别担心P的情况下，系统在大多数情况下是可以做到完美的C和A的，具体可参考原作者的另外一篇文章（强烈推荐）：CAP 理论十二年回顾：&quot;规则&quot;变了&lt;/p&gt;
&lt;p&gt;中文版：&lt;a href=&quot;https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed&quot; class=&quot;uri&quot;&gt;https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文版：&lt;a href=&quot;https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed&quot; class=&quot;uri&quot;&gt;https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Feb 2019 12:10:00 +0000</pubDate>
<dc:creator>justinme</dc:creator>
<og:description>1. CAP理论的历史 2000年7月，Eric Brewer教授提出CAP猜想；2年后，Seth Gilbert和Nancy Lynch从理论上证明了CAP；之后，CAP理论正式成为分布式计算领域的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justinme/p/10371684.html</dc:identifier>
</item>
</channel>
</rss>