<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>spring学习总结(一)_Ioc基础(上) - Kevin_zheng</title>
<link>http://www.cnblogs.com/zhenghengbin/p/10087889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/10087889.html</guid>
<description>&lt;blockquote readability=&quot;7.9047619047619&quot;&gt;
&lt;p&gt;最近经历了许许多多的事情，学习荒废了很久。自己的目标成了摆设。现在要奋起直追了。最近发现了&lt;a href=&quot;https://www.cnblogs.com/best/p/5727935.html#_label1&quot;&gt;张果&lt;/a&gt;的博客。应该是一个教师。看了他写的spring系列的博客，写的不错。于是本文的内容参考自他的博客，当然都是手打书写。由于我感觉他写的博客篇幅过长。我根据我的习惯进行拆分学习。而且他的文章一系列很清楚。也值得我去学习。自己写博客就零零散散。不是很系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;spring概述&quot;&gt;spring概述&lt;/h3&gt;
&lt;p&gt;spring可以做很多事情，它为企业级开发提供了丰富的功能。但是这些功能的底层都依赖于它的两个核心特性，控制反转（IOC）和面向切面（AOP)、&lt;br/&gt;本篇文章主要介绍IOC。&lt;/p&gt;
&lt;p&gt;现在 springboot 和spring cloud十分火爆，还是有必要看看两者之间的关系的&lt;/p&gt;
&lt;p&gt;Spring Boot 是 Spring 的一套快速配置脚手架，可以基于&lt;strong&gt;Spring Boot 快速开发单个微服务&lt;/strong&gt;，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，&lt;strong&gt;Spring Cloud关注全局的服务治理框架&lt;/strong&gt;；Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，&lt;strong&gt;Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891580/201812/891580-20181208125228231-1796435488.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ioc基础&quot;&gt;Ioc基础&lt;/h3&gt;
&lt;p&gt;控制反转IOC是一种设计思想，DI(依赖注入)是实现IOC的一种方法。（下面的这张图画的太好了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891580/201812/891580-20181208131124324-994747249.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有IOC的程序中我们使用面向对象编程对象的创建于对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。&lt;/li&gt;
&lt;li&gt;控制反转后将对象的创建转移给第三方。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IOC是spring框架的核心内容，使用多种方式完美的实现了IOC，可以使用xml配置，也可以使用注解，新版本的spring可以零配置实现IOC。&lt;/p&gt;
&lt;h3 id=&quot;使用xml配置方式实现ioc&quot;&gt;使用XML配置方式实现IOC&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建maven项目&lt;/li&gt;
&lt;li&gt;pom文件如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.kevin&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;spring.version&amp;gt;4.3.0.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;version&amp;gt;4.10&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.8.9&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.2.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用无参构造方法创建对象&quot;&gt;使用无参构造方法创建对象&lt;/h4&gt;
&lt;p&gt;新建一个Music类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 音乐
 *
 * @author: kevin
 * @Date: 2018/12/8
 */
public class Music {
    public Music() {
        System.out.println(&quot;播放周杰伦的《七里香》&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;resources文件夹下新建music.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;jay&quot; class=&quot;com.kevin.spring.demo1.entity.Music&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo1.test;

import com.kevin.spring.demo1.entity.Music;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @author: kevin
 * @Date: 2018/12/8
 */
public class Test {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;music.xml&quot;);
        Music jay = ctx.getBean(&quot;jay&quot;, Music.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;信息: Loading XML bean definitions from class path resource [music.xml]
播放周杰伦的《七里香》
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用有参构造方法创建对象&quot;&gt;使用有参构造方法创建对象&lt;/h4&gt;
&lt;p&gt;Person&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo2.entity;

/**
 * 人类
 */
public abstract class Person {

    public String name;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Student&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo2.entity;

/**
 * 学生
 */
public class Student extends Person{

    /**
     * 身高
     */
    public int height;

    /**
     * 有参构造函数
     * @param name
     * @param height
     */
    public Student(String name,int height) {
        this.name = name;
        this.height = height;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;height=&quot; + height +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;student.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;kevin&quot; class=&quot;com.kevin.spring.demo2.entity.Student&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;kevin&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;height&quot; value=&quot;170&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--使用索引指定参数--&amp;gt;
    &amp;lt;bean id=&quot;maomao&quot; class=&quot;com.kevin.spring.demo2.entity.Student&quot;&amp;gt;
        &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;maomao&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;100&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo2.test;

import com.kevin.spring.demo2.entity.Person;
import com.kevin.spring.demo2.entity.Student;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;student.xml&quot;);
        Person kevin = ctx.getBean(&quot;kevin&quot;, Student.class);
        Person maomao = ctx.getBean(&quot;maomao&quot;, Student.class);
        System.out.println(maomao);
        System.out.println(kevin);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;信息: Loading XML bean definitions from class path resource [student.xml]
Student{height=100, name='maomao'}
Student{height=170, name='kevin'}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过属性赋值&quot;&gt;通过属性赋值&lt;/h4&gt;
&lt;p&gt;Animal&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo3.entity;

/**
 * 动物
 */
public class Animal {

    /**
     * 动物名称
     */
    private String name;

    public Animal() {
    }

    public Animal(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Animal{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;animal.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;dog&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    
    &amp;lt;bean id=&quot;cat&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot; p:name=&quot;cat&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo3.test;

import com.kevin.spring.demo3.entity.Animal;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * 测试类
 */
public class Test {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;animal.xml&quot;);
        Animal dog = ctx.getBean(&quot;dog&quot;,Animal.class);
        Animal cat = ctx.getBean(&quot;cat&quot;,Animal.class);
        System.out.println(cat);
        System.out.println(dog);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;信息: Loading XML bean definitions from class path resource [animal.xml]
Animal{name='cat'}
Animal{name='dog'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对象引用&quot;&gt;对象引用&lt;/h4&gt;
&lt;p&gt;Tyre&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo4.entity;

/**
 * 轮胎
 * @author: kevin
 * @Date: 2018/12/8
 */
public class Tyre {

    private String name;

    public Tyre(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Tyre{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Car&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo4.entity;

/**
 * 车
 */
public class Car {

    private String name;

    private Tyre tyre;

    public Car(String name, Tyre tyre) {
        this.name = name;
        this.tyre = tyre;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Tyre getTyre() {
        return tyre;
    }

    public void setTyre(Tyre tyre) {
        this.tyre = tyre;
    }

    @Override
    public String toString() {
        return &quot;Car{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, tyre=&quot; + tyre +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo4.test;

import com.kevin.spring.demo4.entity.Car;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {

    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;car.xml&quot;);
        Car bike = ctx.getBean(&quot;bike&quot;, Car.class);
        System.out.println(bike);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;信息: Loading XML bean definitions from class path resource [car.xml]
Car{name='bike', tyre=Tyre{name='自行车轮胎'}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对象作用域&quot;&gt;对象作用域&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。在这种情况下，将class声明为单例的bean会被污染，稍后重用的时候会出现意想不到的问题。 -《spring实战》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring定义了多种作用域，可以基于这些作用域创建bean，包括：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;单例（Singleton）&lt;/td&gt;
&lt;td&gt;在整个应用中，只创建bean的一个实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;原型（Prototype）&lt;/td&gt;
&lt;td&gt;每次注入或者通过spring应用上下文获取的时候，都会创建一个新的bean实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;会话（Session）&lt;/td&gt;
&lt;td&gt;在web应用中，为每个会话创建一个bean实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;请求（Request）&lt;/td&gt;
&lt;td&gt;在web应用中，为每个请求创建一个bean实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;spring中默认是单例的我们通过之前的代码演示下&quot;&gt;1、spring中默认是单例的，我们通过之前的代码演示下&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;dog&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;bean id=&quot;cat&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot; p:name=&quot;cat&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.kevin.spring.demo3.test;

import com.kevin.spring.demo3.entity.Animal;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * 测试类
 */
public class Test {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;animal.xml&quot;);
        Animal dog1 = ctx.getBean(&quot;dog&quot;,Animal.class);
        Animal dog2 = ctx.getBean(&quot;dog&quot;,Animal.class);

        System.out.println(dog1 == dog2);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样验证了从容器中取回的对象默认是单例的。&lt;/p&gt;
&lt;h5 id=&quot;设置成prototype&quot;&gt;2、设置成Prototype&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;dog&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;bean id=&quot;cat&quot; class=&quot;com.kevin.spring.demo3.entity.Animal&quot; p:name=&quot;cat&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;animal.xml&quot;);
        Animal dog1 = ctx.getBean(&quot;dog&quot;,Animal.class);
        Animal dog2 = ctx.getBean(&quot;dog&quot;,Animal.class);

        System.out.println(dog1 == dog2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;延迟初始化bean&quot;&gt;延迟初始化bean&lt;/h4&gt;
&lt;p&gt;ApplicationContext实现的默认行为是在启动时将所有的singleton bean 提前进行实例化。这样配置中或者运行环境的错误就会立刻发现。如果你想延迟初始化。可以在xml中进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;bean id=&quot;kevin&quot; class=&quot;com.kevin.spring.demo2.entity.Student&quot; lazy-init=&quot;true&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;kevin&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;height&quot; value=&quot;170&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) throws InterruptedException {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;student.xml&quot;);
        Thread.sleep(3000);
        Person kevin = ctx.getBean(&quot;kevin&quot;, Student.class);
        System.out.println(kevin);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家自己运行后发现，确实并不是启动后就加载的。&lt;/p&gt;
&lt;h4 id=&quot;回调方法&quot;&gt;回调方法&lt;/h4&gt;
&lt;p&gt;Student&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void init() {
        System.out.println(&quot;执行init方法&quot;);
    }

    public void over() {
        System.out.println(&quot;执行over方法&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;student.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;bean id=&quot;kevin&quot; class=&quot;com.kevin.spring.demo2.entity.Student&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;over&quot;&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;kevin&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg name=&quot;height&quot; value=&quot;170&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) throws InterruptedException {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;student.xml&quot;);
        Thread.sleep(3000);
        Person kevin = ctx.getBean(&quot;kevin&quot;, Student.class);
        System.out.println(kevin);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Student 初始化
执行init方法
Student{height=170, name='kevin'}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;本篇文章暂时先介绍到这里，天气真的很冷，没有暖气，冻死我的手了。好了，玩的开心！&lt;/p&gt;
&lt;p&gt;完整代码：https://github.com/runzhenghengbin/spring-study/tree/master/spring-demo01&lt;/p&gt;
&lt;p&gt;参考：https://www.cnblogs.com/best/p/5727935.html&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:42:00 +0000</pubDate>
<dc:creator>Kevin_zheng</dc:creator>
<og:description>最近经历了许许多多的事情，学习荒废了很久。自己的目标成了摆设。现在要奋起直追了。最近发现了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/10087889.html</dc:identifier>
</item>
<item>
<title>.NET Core 2.2发布一览 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10087581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10087581.html</guid>
<description>&lt;p&gt;本周终于发布了.NET Core 2.2，ASP.NET Core 2.2以及Entity Framework Core 2.2，虽然更大的新闻可能是.NET Core 3.0的特性公布，但不妨先将现有的.NET Core版本升级到2.2，及时体验一下新的功能。&lt;/p&gt;

&lt;h2 id=&quot;分层编译&quot;&gt;分层编译&lt;/h2&gt;
&lt;p&gt;分层编译特性使得运行时可以更灵活地使用JIT编译器，从而提升在启动方面和最大化吞吐量上的性能。该特性在.NET Core 2.1时已作为可选特性加入其中，在.NET Core 2.2的预览版本中被默认使用，而到了最终发布阶段，还是改回了可选特性。.NET Core 3.0之后或许会成为默认选项吧。&lt;/p&gt;
&lt;h2 id=&quot;运行时事件&quot;&gt;运行时事件&lt;/h2&gt;
&lt;p&gt;为了获悉在运行应用程序时服务的工作情况，需要监测在当前进程中的诸如垃圾回收，JIT和线程池等运行时服务。在Windows系统中，一般ETW(Event Tracing for Windows) 的监测功能就可以满足此要求。但在.NET Core 2.2之前，ETW的执行效果并不令人如意。&lt;br/&gt;现在， 通过EventListener类可以使用CoreCLR事件。这些事件描述了垃圾回收，JIT，线程池和interop的行为。它们在Windows上作为CoreCLR ETW provider的一部分对外公开。这将允许应用程序可以使用这些事件，又或者使用传输机制发送给其它监测服务。&lt;/p&gt;
&lt;h2 id=&quot;在sqlconnection中提供对accesstoken的支持&quot;&gt;在SqlConnection中提供对AccessToken的支持&lt;/h2&gt;
&lt;p&gt;SQL Server的ADO.NET provider，SqlClient，现在支持通过设置AccessToken属性以认证使用Azure Active Directory的SQL Server连接。该属性包含在Microsoft.IdentityModel.Clients.ActiveDirectory类库里。&lt;/p&gt;
&lt;h2 id=&quot;在main方法之前插入代码&quot;&gt;在Main方法之前插入代码&lt;/h2&gt;
&lt;p&gt;现在通过Startup Hook可以在运行应用程序的Main方法之前插入特定的代码。对于已经发布的应用程序，不用重新编译或者改变程序，Startup Hook能够定制所需的行为。&lt;/p&gt;
&lt;h2 id=&quot;windows-arm32&quot;&gt;Windows ARM32&lt;/h2&gt;
&lt;p&gt;与.NET Core 2.1中对Linux ARM32支持相似的，在.NET Core 2.2里加入了对Windows ARM32的支持。但在发布时遇到了较严重的bug，所以可能在之后的版本中，比如2019年1月即将发布的.NET Core 2.1.1中会真正附加此特性。&lt;/p&gt;
&lt;h2 id=&quot;平台支持&quot;&gt;平台支持&lt;/h2&gt;
&lt;p&gt;NET Core 2.2支持下列操作系统：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows Client: 7, 8.1, 10 (1607+)&lt;/li&gt;
&lt;li&gt;Windows Server: 2008 R2 SP1+&lt;/li&gt;
&lt;li&gt;macOS: 10.12+&lt;/li&gt;
&lt;li&gt;RHEL: 6+&lt;/li&gt;
&lt;li&gt;Fedora: 26+&lt;/li&gt;
&lt;li&gt;Ubuntu: 16.04+&lt;/li&gt;
&lt;li&gt;Debian: 9+&lt;/li&gt;
&lt;li&gt;SLES: 12+&lt;/li&gt;
&lt;li&gt;openSUSE: 42.3+&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;芯片支持包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x64 on Windows, macOS, and Linux&lt;/li&gt;
&lt;li&gt;x86 on Windows&lt;/li&gt;
&lt;li&gt;ARM32 on Linux (Ubuntu 16.04+, Debian 9+)&lt;/li&gt;
&lt;li&gt;ARM32 on Windows (1809+; available in January)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这次的更新主要是为了提高开发者的生产力以及增强创建Web/HTTP API的功能。同时，也在性能方面有所改善。这些更新包含以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与Swagger类库更好地集成，代码分析提供了设计时检查。&lt;/li&gt;
&lt;li&gt;引入终端路由，提升了MVC中20%的路由性能&lt;/li&gt;
&lt;li&gt;改进LinkGenerator的URL生成，支持路由参数转换&lt;/li&gt;
&lt;li&gt;加入了对于应用程序的健康进行监测新API(此功能来源自和BeatPulse项目的集成)&lt;/li&gt;
&lt;li&gt;由于进程内托管的支持，在IIS上提升了400%的吞吐量&lt;/li&gt;
&lt;li&gt;提升了15%的MVC模型验证性能&lt;/li&gt;
&lt;li&gt;在MVC中加入了对问题明细(Problem Details)(RFC 7807)的支持&lt;/li&gt;
&lt;li&gt;在ASP.NET Core中可以预览对HTTP/2 server的支持&lt;/li&gt;
&lt;li&gt;对于Bootstrap 4与Angular 6模板的升级&lt;/li&gt;
&lt;li&gt;提供了ASP.NET Core SignalR的Java客户端&lt;/li&gt;
&lt;li&gt;在Linux上提升了60%的HTTP客户端性能，同时在Windows上提升了20%&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;支持空间数据&quot;&gt;支持空间数据&lt;/h2&gt;
&lt;p&gt;空间数据可以用于表示物理距离和目标形状。在EF Core 2.2中借助NetTopologySuite类库的帮助对空间数据提供了支持。当前已支持的数据库包括SQL Server，SQlite和PostgreSQL。&lt;/p&gt;
&lt;h2 id=&quot;所有型实体owned-entity集合&quot;&gt;所有型实体(owned entity)集合&lt;/h2&gt;
&lt;p&gt;所有型实体中仅可以出现其它实体类型的导航属性。&lt;br/&gt;EF Core 2.0中新加了一对一关联的所有型实体，而在EF Core 2.2中则进一步地扩展到了一对多的关联。&lt;/p&gt;
&lt;h2 id=&quot;查询标签&quot;&gt;查询标签&lt;/h2&gt;
&lt;p&gt;该特性简化了代码中Linq语句与日志中生成的SQL语句之间的关联。&lt;/p&gt;
&lt;p&gt;加上标签的方法是TagWith。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  var nearestFriends =
      (from f in context.Friends.TagWith(@&quot;This is my spatial query!&quot;)
      orderby f.Location.Distance(myLocation) descending
      select f).Take(5).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后生成的SQL语句中包含了Linq代码中附加的标签。&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;-- This is my spatial query!

SELECT TOP(@__p_1) [f].[Name], [f].[Location]
FROM [Friends] AS [f]
ORDER BY [f].[Location].STDistance(@__myLocation_0) DESC&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 08 Dec 2018 07:36:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>本周终于发布了.NET Core 2.2，ASP.NET Core 2.2以及Entity Framework Core 2.2，虽然更大的新闻可能是.NET Core 3.0的特性公布，但不妨先将现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10087581.html</dc:identifier>
</item>
<item>
<title>filebeat-kafka日志收集 - mathli</title>
<link>http://www.cnblogs.com/mathli/p/10087825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mathli/p/10087825.html</guid>
<description>&lt;p&gt;由于线上的logstash吃掉大量的CPU,占用较多的系统资源,就想找其它的组件替代.我们的日志需要收集并发送到kafka,生成的日志已经是需要的数据,不用过滤.经过调研发现filebeat也支持发往kafka.&lt;/p&gt;
&lt;p&gt;filebeat很轻量,用于转发和收集日志数据.filebeat作为代理安装在服务器上,监视指定的日志文件或位置,收集日志事件,并将他们转发到logstash,elasticsearch,kafka等.架构图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531082/201812/1531082-20181208152752755-1668355607.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;获取安装包并解压&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.5.1-linux-x86_64.tar.gz
# tar -xvf filebeat-6.5.1-linux-x86_64.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;filebeat支持很多种输入和输出.具体可看&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html&quot;&gt;input&lt;/a&gt;,&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-output.html&quot;&gt;output&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;项目中用到的输入是log,输出的kafka.在这只讲这两种配置.&lt;/p&gt;
&lt;h3 id=&quot;输入配置log&quot;&gt;输入配置log&lt;/h3&gt;
&lt;p&gt;log输入是从文件中按行读取.在paths指定需要监视的文件.&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;filebeat.inputs:
- type: log
  paths:
    - /var/log/messages
    - /var/log/*.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要有以下几个配置项.&lt;/p&gt;
&lt;h3 id=&quot;paths&quot;&gt;paths&lt;/h3&gt;
&lt;p&gt;需要监视的文件路径.支持&lt;a href=&quot;https://golang.org/pkg/path/filepath/#Glob&quot;&gt;Go Glab&lt;/a&gt;的所有模式.例如: /var/log/*.log.这个配置将监视/var/log文件夹下所有以.log结尾的文件.可以用recursive_glob来递归子文件夹.&lt;/p&gt;
&lt;h3 id=&quot;recursive_glob.enabled&quot;&gt;recursive_glob.enabled&lt;/h3&gt;
&lt;p&gt;允许扩展 * * 为递归的glob模式.启用此功能后. /foo/* * 扩展到/foo, /foo/* ,/foo/* /* ,等等,它会将单个扩展 * * 为8级深度*模式.&lt;/p&gt;
&lt;p&gt;默认情况下启用此功能.设置false禁用.&lt;/p&gt;
&lt;h3 id=&quot;exclude_lines&quot;&gt;exclude_lines&lt;/h3&gt;
&lt;p&gt;正则表达式列表,用于匹配您希望Filebeat排除的行.Filebeat会删除与列表中的正则表达式匹配的所有行.默认情况下,不会删除任何行.空行被忽略.&lt;/p&gt;
&lt;p&gt;以下示例将Filebeat配置为删除任何以DBG开头的行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;filebeat.inputs:
- type: log
  ...
  exclude_lines: ['^DBG']&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;include_lines&quot;&gt;include_lines&lt;/h3&gt;
&lt;p&gt;正则表达式列表,用于匹配您希望Filebeat包含的行.Filebeat仅导出与列表中的正则表达式匹配的行.默认情况下,将导出所有行.空行被忽略.&lt;/p&gt;
&lt;p&gt;以下示例将Filebeat配置为导出以ERR或WARN开头的所有行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;filebeat.inputs:
- type: log
  ...
  include_lines: ['^ERR', '^WARN']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS: 如果include_lines和exclude_lines两个配置同时出现,优先执行inlcude_lines再执行exclude_lines.和配置项放的位置没有关系.&lt;/p&gt;
&lt;h3 id=&quot;json&quot;&gt;json&lt;/h3&gt;
&lt;p&gt;filebeat支持json格式的消息日志.它将逐行处理日志,因此只有每行有一个json对象时,json解码才有效.&lt;/p&gt;
&lt;p&gt;配置示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;json.keys_under_root: true
json.add_error_key: true
json.message_key: log&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;enabled&quot;&gt;enabled&lt;/h3&gt;
&lt;p&gt;输入开关.默认true打开.&lt;/p&gt;
&lt;h2 id=&quot;输出配置kafka&quot;&gt;输出配置kafka&lt;/h2&gt;
&lt;p&gt;kafka将输出流发送到Apache Kafka.&lt;/p&gt;
&lt;p&gt;配置示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;output.kafka:
  # initial brokers for reading cluster metadata
  hosts: [&quot;kafka1:9092&quot;, &quot;kafka2:9092&quot;, &quot;kafka3:9092&quot;]

  # message topic selection + partitioning
  topic: '%{[fields.log_topic]}'
  partition.round_robin:
    reachable_only: false

  required_acks: 1
  compression: gzip
  max_message_bytes: 1000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要以下几个配置项&lt;/p&gt;
&lt;h3 id=&quot;enabled-1&quot;&gt;enabled&lt;/h3&gt;
&lt;p&gt;是否打开输出配置项.true打开,false关闭.默认是true.&lt;/p&gt;
&lt;h3 id=&quot;hosts&quot;&gt;hosts&lt;/h3&gt;
&lt;p&gt;kafka的broker地址.&lt;/p&gt;
&lt;h3 id=&quot;topic&quot;&gt;topic&lt;/h3&gt;
&lt;p&gt;kafka的topic.&lt;/p&gt;
&lt;h3 id=&quot;worker&quot;&gt;worker&lt;/h3&gt;
&lt;p&gt;并发负载均衡Kafka输出工作线程的数量.&lt;/p&gt;
&lt;h3 id=&quot;timeout&quot;&gt;timeout&lt;/h3&gt;
&lt;p&gt;kafka返回应答的等待时间.默认30(秒).&lt;/p&gt;
&lt;h3 id=&quot;keep_alive&quot;&gt;keep_alive&lt;/h3&gt;
&lt;p&gt;连接的存活时间.如果为0,表示短连,发送完就关闭.默认为0秒.&lt;/p&gt;
&lt;h3 id=&quot;required_acks&quot;&gt;required_acks&lt;/h3&gt;
&lt;p&gt;ACK的可靠等级.0=无响应,1=等待本地消息,-1=等待所有副本提交.默认1.&lt;/p&gt;
&lt;p&gt;PS: 如果设为0,kafka无应答返回时,消息将丢失.&lt;/p&gt;
&lt;h2 id=&quot;配置例子&quot;&gt;配置例子&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#=========================== Filebeat inputs =============================
#------------------------------log-----------------------------------
filebeat.inputs:
- type: log
  enabled: true 
  paths:
    - /data/collect_log/info.*
#=========================== Filebeat outputs =============================
#------------------------------kafka-----------------------------------
output.kafka:
  hosts: [&quot;test1:9092&quot;,&quot;test2:9092&quot;]
  topic: test_collect
  keep_alive: 10s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;收集/data/collect_log目录下以info开头的文件,发送到kafka,kafka的topic是test_collect.&lt;/p&gt;
&lt;h2 id=&quot;启动&quot;&gt;启动&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# /home/filebeat -c filebeat-kafka.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志在filebeat下的log目录.想要显示的看日志启动时加 -e 参数.&lt;/p&gt;
&lt;p&gt;参考文档: &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:33:00 +0000</pubDate>
<dc:creator>mathli</dc:creator>
<og:description>filebeat kafka日志收集 由于线上的logstash吃掉大量的CPU,占用较多的系统资源,就想找其它的组件替代.我们的日志需要收集并发送到kafka,生成的日志已经是需要的数据,不用过滤.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mathli/p/10087825.html</dc:identifier>
</item>
<item>
<title>浅析Vue Router中关于路由守卫的应用以及在全局导航守卫中检查元字段 - 【godDie】</title>
<link>http://www.cnblogs.com/w-819/p/10087855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w-819/p/10087855.html</guid>
<description>&lt;p&gt;#在切换路由时，组件会被复用，不过，这也意味着组件的生命周期钩子不会再被调用。&lt;/p&gt;
&lt;p&gt;　　　解决办法有两种，1简单地 watch (监测变化) &lt;code&gt;$route&lt;/code&gt; 对象：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; User =&lt;span&gt; {
  template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  watch: {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$route&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (to, &lt;span&gt;from&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对路由变化作出响应...&lt;/span&gt;
&lt;span&gt;    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2.使用 2.2 中引入的 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; 导航守卫：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; User =&lt;span&gt; {
  template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  beforeRouteUpdate (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; react to route changes...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't forget to call next()&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#全局守卫&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;code&gt;router.beforeEach&lt;/code&gt; 注册一个全局前置守卫：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({ ... })

router.beforeEach((to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;to: Route&lt;/code&gt;: 即将要进入的目标 路由对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;from: Route&lt;/code&gt;: 当前导航正要离开的路由&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;next: Function&lt;/code&gt;: 一定要调用该方法来 resolve 这个钩子&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;#全局解析守卫&lt;/p&gt;
&lt;p&gt;在 2.5.0+ 你可以用 &lt;code&gt;router.beforeResolve&lt;/code&gt; 注册一个全局守卫。这和 &lt;code&gt;router.beforeEach&lt;/code&gt; 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。&lt;/p&gt;
&lt;p&gt;#全局后置钩子&lt;/p&gt;
&lt;p&gt;你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 &lt;code&gt;next&lt;/code&gt; 函数也不会改变导航本身：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
router.afterEach((to, &lt;span&gt;from&lt;/span&gt;) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#路由独享的守卫&lt;/p&gt;
&lt;p&gt;你可以在路由配置上直接定义 &lt;code&gt;beforeEnter&lt;/code&gt; 守卫&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    {
      path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      component: Foo,
      beforeEnter: (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;, next) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;      }
    }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些守卫与全局前置守卫的方法参数是一样的。&lt;/p&gt;
&lt;p&gt;#组件内的守卫&lt;/p&gt;
&lt;p&gt;你可以在路由组件内直接定义以下路由导航守卫：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Foo =&lt;span&gt; {
  template: `...`,
  beforeRouteEnter (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在渲染该组件的对应路由被 confirm 前调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不！能！获取组件实例 `this`
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为当守卫执行前，组件实例还没被创建&lt;/span&gt;
&lt;span&gt;  },
  beforeRouteUpdate (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在当前路由改变，但是该组件被复用时调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以访问组件实例 `this`&lt;/span&gt;
&lt;span&gt;  },
  beforeRouteLeave (to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导航离开该组件的对应路由时调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以访问组件实例 `this`&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt; 守卫 不能 访问 &lt;code&gt;this&lt;/code&gt;，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。&lt;/p&gt;
&lt;p&gt;不过，你可以通过传一个回调给 &lt;code&gt;next&lt;/code&gt;来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
             num: &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
        }
    },
    beforeRouteEnter(to, &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;, next){
        next(vm&lt;/span&gt;=&amp;gt;&lt;span&gt;{
            vm.num&lt;/span&gt;=&lt;span&gt;22&lt;/span&gt;&lt;span&gt;;
        })
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 是支持给 &lt;code&gt;next&lt;/code&gt; 传递回调的唯一守卫。对于 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; 和 &lt;code&gt;beforeRouteLeave&lt;/code&gt; 来说，&lt;code&gt;this&lt;/code&gt; 已经可用了，所以不支持传递回调，因为没有必要了&lt;/p&gt;
&lt;p&gt;#完整的导航解析流程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.导航被触发。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.在失活的组件里调用离开守卫。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.调用全局的 beforeEach 守卫。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;.在重用的组件里调用 beforeRouteUpdate 守卫 (&lt;span&gt;2.2&lt;/span&gt;+&lt;span&gt;)。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.在路由配置里调用 beforeEnter。
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;.解析异步路由组件。
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.在被激活的组件里调用 beforeRouteEnter。
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;.调用全局的 beforeResolve 守卫 (&lt;span&gt;2.5&lt;/span&gt;+&lt;span&gt;)。
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;.导航被确认。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.调用全局的 afterEach 钩子。
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;.触发 DOM 更新。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#在全局导航守卫中检查元字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
router.beforeEach((to, &lt;span&gt;from&lt;/span&gt;, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to.matched.some(record =&amp;gt;&lt;span&gt; record.meta.requiresAuth)) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果路由中有meta的requireAuth，且为true，就不进行登录验证，否则进行登录验证&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;auth.loggedIn()) {
      next({
        path: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        query: { redirect: to.fullPath }
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      next()
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    next() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确保一定要调用 next()&lt;/span&gt;
&lt;span&gt;  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个路由匹配到的所有路由记录会暴露为 &lt;code&gt;$route&lt;/code&gt; 对象 (还有在导航守卫中的路由对象) 的 &lt;code&gt;$route.matched&lt;/code&gt; 数组。因此，我们需要遍历 &lt;code&gt;$route.matched&lt;/code&gt; 来检查路由记录中的 &lt;code&gt;meta&lt;/code&gt; 字段。&lt;/p&gt;
&lt;p&gt;　　注：1、meta 字段就是路由元信息字段，requiresAuth 是自己起的字段名称，用来标记这个路由信息是否需要检测，true 表示要检测，false 表示不需要检测（这个名称随便起，比如我自己的就起的 requiresId，建议起个有意义的名称）&lt;/p&gt;
&lt;p&gt;　　2、if (to.matched.some(record =&amp;gt; record.meta.requiresAuth) )，如果对这类写法不熟悉，可以去看看es6的箭头函数，这句话就是返回遍历的某个路由对象，我们定义为为record，检测这个对象是否拥有meta这个对象，如果有meta这个对象，检测它的meta对象是不是有requiresAuth这个属性，且为true，如果满足上述条件，就确定了是这个/foo/bar路由。&lt;/p&gt;
&lt;p&gt;　　3、some() 方法测试数组中的某些元素是否通过了指定函数的测试。语法：arr.some(callback[, thisArg])；&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;　　　　some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。&lt;/p&gt;
&lt;p&gt;  　　　callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　4、vue-router路由元信息说白了就是通过meta对象中的一些属性来判断当前路由是否需要进一步处理，如果需要处理，按照自己想要的效果进行处理即可！&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:33:00 +0000</pubDate>
<dc:creator>【godDie】</dc:creator>
<og:description>#在切换路由时，组件会被复用，不过，这也意味着组件的生命周期钩子不会再被调用。 解决办法有两种，1简单地 watch (监测变化) $route 对象： 2.使用 2.2 中引入的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w-819/p/10087855.html</dc:identifier>
</item>
<item>
<title>百度前端学院参考答案：第二十五天到第二十七天 倒数开始 滴答滴 滴答滴（1） - JoeJoan</title>
<link>http://www.cnblogs.com/Joe-and-Joan/p/10087853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-and-Joan/p/10087853.html</guid>
<description>&lt;h3 id=&quot;-&quot;&gt;编码&lt;/h3&gt;
&lt;p&gt;我们现在来做一个最简单的时钟，通过小练习来学习 Date，复习定时，然后再练习一下函数的封装&lt;br/&gt;具体需求如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在页面中显示当前日期及时间，按秒更新&lt;/li&gt;
&lt;li&gt;格式为 YYYY 年 MM 月 DD 日 星期 D HH:mm:ss&lt;/li&gt;
&lt;li&gt;注意位数的补齐，比如：&lt;br/&gt;-- 假设时间为2008年10月10日星期一的12点12分12秒，显示2008年10月10日星期一 12:12:12&lt;br/&gt;-- 假设时间为2008年1月1日星期一的3点2分2秒，显示2008年01月01日星期一 03:02:02&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编码过程中，我们希望你注意对函数的封装，尽量让一个函数就做一个事情，而不要把所有的功能、代码揉在一起：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装一个函数，来根据某个日期返回这一天是星期几&lt;/li&gt;
&lt;li&gt;封装一个函数，把月、日、小时等出现个位数的情况前面补充0，补充为两位，比如1变为01&lt;/li&gt;
&lt;li&gt;封装一个函数，把最后的日期时间，按照要求的格式进行包装&lt;/li&gt;
&lt;li&gt;可能不止上面这些，尽可能地进行功能的解耦和拆解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;编码&lt;/h3&gt;
&lt;p&gt;完成上面需求后，现在需求做一些小的变更&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出格式变为：2008-10-10 Monday 07:10:30 PM&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;编码&lt;/h3&gt;
&lt;p&gt;基于上面的需求，要求，同时在页面上，输出两种格式的日期时间&lt;br/&gt;希望通过上面的练习，让你体会函数的概念、作用和价值&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;函数和时钟练习1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;date&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt;&lt;span&gt; datetxt &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种星期显示格式&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getWeekday1(weekday) {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (weekday) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期一&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期二&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星期六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; weekday;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种星期显示格式&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getWeekday2(weekday) {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (weekday) {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sunday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Monday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tuesday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wednesday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thursday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Friday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                    weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Saturday&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; weekday;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;作为补零函数&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; addZero(a) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (a &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                a &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断时间超过12点就-12&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; changeHour(hour) {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hour &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                hour &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hour &lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hour;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种时钟显示格式&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; startTime1() {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; newdate &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时间要写在内部 不然只是获取加载时的第一次日期对象，并不更新&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; year &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getFullYear();
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; month &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getMonth() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mon &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(month);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; day &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getDate();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; d &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(day);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; hour &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getHours();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; minute &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getMinutes();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; second &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getSeconds();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; h &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(hour);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; m &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(minute);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(second);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            datetxt.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; year &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; mon &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;月&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; d &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; h &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; m &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            t &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setTimeout(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;startTime1()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种调用函数&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种时钟显示格式&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; startTime2() {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; newdate &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时间要写在内部 不然只是获取加载时的第一次日期对象，并不更新&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; year &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getFullYear();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; month &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getMonth() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mon &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(month);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; day &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getDate();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; d &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(day);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; weekday &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; getWeekday2(newdate.getDay());
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; hour &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getHours();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; minute &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getMinutes();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; second &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; newdate.getSeconds();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; h &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(changeHour(hour));
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; m &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(minute);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; addZero(second);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hour &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                datetxt.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; year &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; mon &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; d &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; weekday &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; h &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; m &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                datetxt.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; year &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; mon &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; d &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; weekday &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; h &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; m &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            t &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; setTimeout(startTime2, &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种调用函数&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用第一种时钟显示&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;startTime1();&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用第二种时钟显示&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        startTime2();
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意点：获取星期和月份需要特殊处理才能对应上，如date.getMonth()+1=月份；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               date.getDay()=0，代表周日，date.getDay()=1，代表周一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;              函数要自身调用，才能实时更新时间，并且newDate需要写在函数内部，每次都要获取新的时间。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:32:00 +0000</pubDate>
<dc:creator>JoeJoan</dc:creator>
<og:description>编码 我们现在来做一个最简单的时钟，通过小练习来学习 Date，复习定时，然后再练习一下函数的封装具体需求如下： 在页面中显示当前日期及时间，按秒更新 格式为 YYYY 年 MM 月 DD 日 星期</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joe-and-Joan/p/10087853.html</dc:identifier>
</item>
<item>
<title>Python并发编程系列之协程 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10087813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10087813.html</guid>
<description>&lt;h3&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;2 协程的意义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　2.1 什么是协程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.2 协程的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.3 相关概念&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3 定义协程&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;4 使用协程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　4.1 单个协程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.2多协程并发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.3 获取返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.4 绑定回调函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.5 协程的嵌套使用&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5 总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　协程是近几年并发编程的一个热门话题，与Python多进程、多线程相比，协程在很多方面优势明显。本文从协程的定义和意义出发，结合asyncio模块详细讲述了协程的使用。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.1 什么是协程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　协程，又称微线程，英文名为Coroutine。对于多线程，在执行一个个不同任务时，遇到阻塞（例如IO操作）时，操作系统会自动将CPU资源切换给另一个线程。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.2 协程的作用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;         与线程不同的是，协程需要用户自己进行手动切换——当某线程在执行任务中的函数A（协程A））时，可任意终端，手动切换到任务中的另一个函数B（协程B），然后在适当的时候在回到函数A（协程A）中继续执行，这样虽然繁琐，但也提供了更大的操作自由度，同时协程A和协程B都属于同一线程，切换效率相比于线程或进程间的切换有极大地优势。另外，协程不需要多线程的锁机制，因为都属于同一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         我们以爬虫为例子，说明协程的应用。启动一个爬虫程序一定属于一个进程，这是毋庸置疑的，但进程本身并不会执行任何操作，所有操作都是通过线程来完成，所以一个进程有一个主线程。一般爬虫的步骤包括发送request请求、写入文件等操作，而这些都是IO操作，当线程执行到这些操作时，要么等待这一操作完成要么切换到其他线程。如果使用了协程呢？如果协程遇到了此类IO操作，可以立即切换到其他操作，例如直接发送下一个request请求，甚至发送第二个、第三个请求……直至原来的协程中IO请求完成，那么回到原来的协程继续下一步操作。这就是协程的工作原理，充分利用线程的工作效率，也没有多线程切换的开销，所以在处理IO操作时协程非常高效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       简单总结一下协程的优缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）无需线程上下文切换的开销（还是单线程）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）无需原子操作的锁定和同步的开销；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）方便切换控制流，简化编程模型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）高并发+高扩展+低成本：一个cpu支持上万的协程都没有问题，适合用于高并发处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）无法利用多核的资源，协程本身是个单线程，它不能同时将单个cpu的多核用上，协程需要和进程配合才能运用到多cpu上（协程是跑在线程上的）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）进行阻塞操作时会阻塞掉整个程序：如io；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       现在，各位读者应该已经对协程的概念又说了解了，也感受到了协程的魅力了吧！那么该怎么使用协程了……&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3 相关概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在Python中， asyncio、tornado和gevent等模块都实现了协程的功能。本篇中主要介绍asyncio。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在介绍通过asyncio的使用协程之前，首先有必要先介绍一下asyncio中涉及的几个概念，要想掌握asyncio这这几个贯穿始终的概念必须好好理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1&lt;/strong&gt;&lt;strong&gt;）event_loop&lt;/strong&gt;&lt;strong&gt;事件循环：&lt;/strong&gt;程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2&lt;/strong&gt;&lt;strong&gt;）coroutine&lt;/strong&gt; &lt;strong&gt;协程：&lt;/strong&gt;协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3&lt;/strong&gt;&lt;strong&gt;）future&lt;/strong&gt; &lt;strong&gt;对象：&lt;/strong&gt; 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4&lt;/strong&gt;&lt;strong&gt;）task&lt;/strong&gt; &lt;strong&gt;任务：&lt;/strong&gt;一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。Task 对象是 Future 的子类，它将coroutine和Future联系在一起，将 coroutine 封装成一个 Future 对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　5&lt;/strong&gt;&lt;strong&gt;）async/await&lt;/strong&gt; &lt;strong&gt;关键字：&lt;/strong&gt;python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口，await就类似于说下面过程阻塞，暂时执行别的协程。await关键字添加了一个新的协程到循环里，而不需要明确地添加协程到这个事件循环里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　定义协程比定义进程或者线程还要简单，你只需要在普通函数定义时在“def”关键字前面加上一个“asyncio”，即可把普通函数定义为一个协程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt; firstCorouctine(path=&lt;span&gt;‘a.txt’):

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行开始……’)

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(‘协程执行结束……’)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果单单看firstCorouctine()，我想大家都看得出这个函数的功能。有 “async”这个关键字在前面修饰之后，这个函数就变成了一个协程——这就是定义协程的方法。所以说，协程某种意义上就是一个函数。我们可以通过asyncio.iscoroutinefunction函数来查看某个函数到底是不是协程，如果是协程则返回True，否则返回False：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; firstCorouctine():

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行开始……’)

await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行结束……’)

 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(path):

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘这是一个普通函数’)

 

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘firstCorouctine是协程吗：{}’.format(asyncio.iscoroutinefunction(firstCorouctine)))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(‘fun是协程吗：{}’.format(asyncio.iscoroutinefunction(fun)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;firstCorouctine是协程吗：True&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　fun是协程吗：False&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么样，简单吧？不过我猜，你心里还是一团懵，甚至在想这有什么用呢？请继续往下看。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4.1 单个协程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;         使用协程须得经过一下几个步骤：定义协程-&amp;gt;（封装成task-&amp;gt;）获取事件循环-&amp;gt;将task放到事件循环中执行。定义好的协程并不能直接使用，需要将其包装成为了一个任务（task对象），然后放到事件循环中才能被执行。所谓task对象是Future类的一个子类，保存了协程运行后的状态，用于未来获取协程的结果。在上面的步骤中，之所以在封装task这一个步骤上加上括号，是因为我们也可以选择直接将协程放到事件循环中，事件循环会自动帮我们完成这一操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，从定义好一个协程，到执行一个协程就有不同的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一种，通过asyncio 再带的ensure_future()函数创建task，然后执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

　　&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行开始……’)

　　await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行结束……’)


coroutine &lt;/span&gt;= firstCorouctine() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将协程赋值给coroutine&lt;/span&gt;
&lt;span&gt;
task &lt;/span&gt;= asyncio.ensure_future(coroutine) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装为task&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;= asyncio.get_event_loop() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取事件循环&lt;/span&gt;
&lt;span&gt;
loop.run_until_complete(task) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　第二种，直接通过事件循环的create_task方法创建task，然后执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行开始……’)

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行结束……’)

 

coroutine &lt;/span&gt;= firstCorouctine() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将协程赋值给coroutine&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;= asyncio.get_event_loop() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取事件循环&lt;/span&gt;
&lt;span&gt;
task &lt;/span&gt;= loop.create_task(coroutine) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装为task&lt;/span&gt;
&lt;span&gt;
loop.run_until_complete(task) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　第三种：直接将协程放到事件循环中执行。这种方法并不是说不用将协程封装为task，而是事件循环内部会自动帮我们完成这一步骤。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

　　&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行开始……’)

　　await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(‘协程执行结束……’)


coroutine &lt;/span&gt;= firstCorouctine() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将协程赋值给coroutine&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;= asyncio.get_event_loop() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取事件循环&lt;/span&gt;
&lt;span&gt;
loop.run_until_complete(coroutine) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　当然，无论是上述哪一种方法，最终都需要通过run_until_complete方法去执行我们定义好的协程。run_until_complete 是一个阻塞（blocking）调用，直到协程运行结束，它才返回。这一点从函数名中就可以看得出来。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.2 多协程并发&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　协程往往是多个一起应用在事件循环里的，将多个协程加入事件循环需要借助 asyncio.gather 函数或者asyncio.wait函数，两个函数功能极其相似，不同的是，gather接受的参数是多个协程，而wait接受的是一个协程列表。async.wait会返回两个值:done和pending，done为已完成的task，pending为超时未完成的task。而async.gather只返回已完成task。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         使用waiter函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(n): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

task_list &lt;/span&gt;=&lt;span&gt; [

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;1&lt;span&gt;)),

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;2&lt;span&gt;)),

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;3&lt;span&gt;))

]

loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(asyncio.wait(task_list)) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用wait函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程1开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3结束执行…… &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用gather函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(n):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

 
task1 &lt;/span&gt;= asyncio.ensure_future(firstCorouctine(1&lt;span&gt;))

task2 &lt;/span&gt;= asyncio.ensure_future(firstCorouctine(2&lt;span&gt;))

task3 &lt;/span&gt;= asyncio.ensure_future(firstCorouctine(3&lt;span&gt;))


tasks &lt;/span&gt;= asyncio.gather(task1, task2, task3)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果协程有返回值时，最好赋值给一个tasks，方便回去返回结果&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(tasks)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;协程1开始执行……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.3&lt;/strong&gt; &lt;strong&gt;获取返回值&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前面的章节中说到，协程本质上来说也是一种函数，既然是函数就可以返回值。那么，协程执行完后，怎么获取它的返回值呢？task是future实例化对象，它封装有一个result()方法，通过task调用result()方法，可以获取协程的返回值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;
&lt;span&gt;
await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ‘1234567890&lt;span&gt;’

coroutine &lt;/span&gt;= firstCorouctine() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将协程赋值给coroutine&lt;/span&gt;
&lt;span&gt;
task &lt;/span&gt;= asyncio.ensure_future(coroutine) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装为task&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;= asyncio.get_event_loop() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取事件循环&lt;/span&gt;
&lt;span&gt;
loop.run_until_complete(task) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
&lt;span&gt;
 

return_value &lt;/span&gt;= task.result() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取协程返回值&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(‘协程返回的值为：{}’.format(return_value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回的值为：1234567890&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的例子是单个协程是获取返回值，如果多个协程呢？使用多个协程并发时，将多个task列表传入事件循环中执行，返回的task列表中的每一个task对象就包含了返回值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(n): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n

task_list &lt;/span&gt;=&lt;span&gt; [

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;1&lt;span&gt;)),

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;2&lt;span&gt;)),

    asyncio.ensure_future(firstCorouctine(&lt;/span&gt;3&lt;span&gt;))

]

loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(asyncio.wait(task_list))

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; task_list:

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(task.result())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;协程1开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程3结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.4&lt;/strong&gt; &lt;strong&gt;绑定回调函数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在实际应用中，协程执行结束之后并不意味这整个任务就完成了，还需要运行其他函数，且其他函数也会用到协程的返回值，这就涉及到回调函数。协程中设置回调函数时需要将future对象（也就是我们创建的task）传入函数中，不过这个传参是自动完成的，所以回调函数必须至少设置一个形参：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;
&lt;span&gt;
    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

   

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; callBack(future): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个回调函数&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是回调函数，协程返回值为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(future.result()))

 

coroutine &lt;/span&gt;=&lt;span&gt; firstCorouctine()

task &lt;/span&gt;=&lt;span&gt; asyncio.ensure_future(coroutine)

task.add_done_callback(callBack) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定回调函数&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(task)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我是回调函数，协程返回值为：1234567890&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果还需要传入其他参数，就需要借助偏函数（functools.partial）来辅助使用了，这时候切记future对象是放在最后的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; firstCorouctine(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义协程&lt;/span&gt;
&lt;span&gt;
    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234567890&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

 

&lt;span&gt;def&lt;/span&gt; callBack(value , future): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个回调函数&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是回调函数，你输入的第一个参数为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是回调函数，协程返回值为：{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(future.result()))

coroutine &lt;/span&gt;=&lt;span&gt; firstCorouctine()

task &lt;/span&gt;=&lt;span&gt; asyncio.ensure_future(coroutine)

task.add_done_callback(functools.partial(callBack , &lt;/span&gt;123)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定回调函数&lt;/span&gt;
&lt;span&gt;
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(task)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我是回调函数，你输入的第一个参数为：123&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我是回调函数，协程返回值为：1234567890&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4.5&lt;/strong&gt; &lt;strong&gt;协程的嵌套使用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　事件循环执行协程时是通过run_until_complete方法，这个方法只接收一个协程或者future对象作为参数。在前面章节中，我们在介绍多协程并发操作时，用的是asyncio.wait函数和asyncio.gather函数，这两个函数本身也是一个协程，当接收多个协程作为参数时，实际上是在wait（或gather）协程里面执行了我们传入的多个协程，然后把结果返回。这就证明，协程是可以嵌套的。我们也可以通过wait和gather来写我们自己的嵌套协程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         使用wait函数嵌套：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; innerCorouctine(n): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 嵌套在里层的协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outerCorouctine():

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerCorouctine开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    coroutine1 &lt;/span&gt;= innerCorouctine(1&lt;span&gt;)

    coroutine2 &lt;/span&gt;= innerCorouctine(2&lt;span&gt;)

    coroutine3 &lt;/span&gt;= innerCorouctine(3&lt;span&gt;)

    tasks &lt;/span&gt;=&lt;span&gt; [

        asyncio.ensure_future(coroutine1),

        asyncio.ensure_future(coroutine2),

        asyncio.ensure_future(coroutine3)

    ]

     dones, pendings &lt;/span&gt;=&lt;span&gt; await asyncio.wait(tasks)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dones:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程返回值：{} &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(task.result()))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerCorouctine结束行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

 
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(outerCorouctine())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　outerCorouctine开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　outerCorouctine结束行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用gather方法进行嵌套：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; innerCorouctine(n): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 嵌套在里层的协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outerCorouctine():

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerCorouctine开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    coroutine1 &lt;/span&gt;= innerCorouctine(1&lt;span&gt;)

    coroutine2 &lt;/span&gt;= innerCorouctine(2&lt;span&gt;)

    coroutine3 &lt;/span&gt;= innerCorouctine(3&lt;span&gt;)


    tasks &lt;/span&gt;=&lt;span&gt; [

        asyncio.ensure_future(coroutine1),

        asyncio.ensure_future(coroutine2),

        asyncio.ensure_future(coroutine3)

    ]

    tasks &lt;/span&gt;= await asyncio.gather(*&lt;span&gt;tasks)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tasks:

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程返回值：{} &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(task))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerCorouctine结束行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(outerCorouctine())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;outerCorouctine开始执行……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值：3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　outerCorouctine结束行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，也还有第三种方法进行嵌套，那就是使用run_until_complete函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; innerCorouctine(n): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 嵌套在里层的协程&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;innerCorouctine-{}结束执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outerCorouctine():

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;outerCorouctine开始执行……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    coroutine1 &lt;/span&gt;= innerCorouctine(1&lt;span&gt;)

    coroutine2 &lt;/span&gt;= innerCorouctine(2&lt;span&gt;)

    coroutine3 &lt;/span&gt;= innerCorouctine(3&lt;span&gt;)

    tasks &lt;/span&gt;=&lt;span&gt; [

        asyncio.ensure_future(coroutine1),

        asyncio.ensure_future(coroutine2),

        asyncio.ensure_future(coroutine3)

    ]

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt; asyncio.as_completed(tasks):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用as_completed函数&lt;/span&gt;
&lt;span&gt;
        result &lt;/span&gt;=&lt;span&gt; await task

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;协程返回值: {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(result))

loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()

loop.run_until_complete(outerCorouctine())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　outerCorouctine开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3开始执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-1结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-2结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　innerCorouctine-3结束执行……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值: 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值: 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　协程返回值: 3&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文介绍了协程概念、意义和单线程下协程基本使用方法，但对于多线程下如何使用协程并未涉及，后续再进行补充。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://python.jobbole.com/87541/&quot;&gt;　　http://python.jobbole.com/87541/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　http://python.jobbole.com/87310/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:25:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>协程是近几年并发编程的一个热门话题，与Python多进程、多线程相比，协程在很多方面优势明显。本文从协程的定义和意义出发，结合asyncio模块详细总结了协程的使用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10087813.html</dc:identifier>
</item>
<item>
<title>STL源码分析之第二级配置器 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10087810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10087810.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;第一级是直接调用&lt;code&gt;malloc&lt;/code&gt;分配空间, 调用&lt;code&gt;free&lt;/code&gt;释放空间, 第二级三就是建立一个内存池, 小于128字节的申请都直接在内存池申请, 不直接调用&lt;code&gt;malloc&lt;/code&gt;和&lt;code&gt;free&lt;/code&gt;. 本节分析第二级空间配置器, STL将第二级配置器设置为默认的配置器, 所以只要一次申请的空间不超过128字节就默认在内存池中申请空间, 超过才会调用第一级配置器.&lt;/p&gt;
&lt;h3 id=&quot;第二级配置器&quot;&gt;第二级配置器&lt;/h3&gt;
&lt;p&gt;首先先来介绍3个常量.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;__ALIGN&lt;/code&gt; : 以8字节进行对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__MAX_BYTES&lt;/code&gt; : 二级分配器最大分配的内存大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__NFREELISTS&lt;/code&gt; : 128字节能分配的的链表个数, 并且从每个链表保存的内存大小都是8的倍数, 而且都比前一个大8字节, 也就是分别是8, 16, 32...128字节&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 二级配置器
enum {__ALIGN = 8}; // 设置对齐要求. 对齐为8字节, 没有8字节自动补齐
enum {__MAX_BYTES = 128};   // 第二级配置器的最大一次性申请大小, 大于128就直接调用第一级配置器
enum {__NFREELISTS = __MAX_BYTES/__ALIGN};  // 链表个数, 分别代表8, 16, 32....字节的链表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再介绍一个宏操作, 这是进行对齐操作, 将不满8的倍数的填充成8的倍数.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static size_t FREELIST_INDEX(size_t bytes) \
{\
    return (((bytes) + ALIGN-1) / __ALIGN - 1);\
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;从allocate先切入分析&quot;&gt;从allocate先切入分析&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;先判断申请的字节大小是不是大于128字节, 是, 则交给第一级配置器来处理. 否, 继续往下执行&lt;/li&gt;
&lt;li&gt;找到分配的地址对齐后分配的是第几个大小的链表.&lt;/li&gt;
&lt;li&gt;获得该链表指向的首地址, 如果链表没有多余的内存, 就先填充链表.&lt;/li&gt;
&lt;li&gt;返回链表的首地址, 和一块能容纳一个对象的内存, 并更新链表的首地址&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static void * allocate(size_t n)
{
      obj * __VOLATILE * my_free_list;
      obj * __RESTRICT result;
    
      if (n &amp;gt; (size_t) __MAX_BYTES) 
      {
        return(malloc_alloc::allocate(n));
      }
      my_free_list = free_list + FREELIST_INDEX(n);
      result = *my_free_list;
      if (result == 0)  // 没有多余的内存, 就先填充链表.
      {
        void *r = refill(ROUND_UP(n));
        return r;
      }
      *my_free_list = result -&amp;gt; free_list_link;
      return (result);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;refill&lt;/code&gt;内存填充.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;向内存池申请空间的起始地址&lt;/li&gt;
&lt;li&gt;如果只申请到一个对象的大小, 就直接返回一个内存的大小, 如果有更多的内存, 就继续执行&lt;/li&gt;
&lt;li&gt;从第二个块内存开始, 把从内存池里面分配的内存用链表给串起来, 并返回一个块内存的地址给用户&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 内存填充
template &amp;lt;bool threads, int inst&amp;gt;
void* __default_alloc_template&amp;lt;threads, inst&amp;gt;::refill(size_t n)
{
    int nobjs = 20;
    char * chunk = chunk_alloc(n, nobjs);             // 向内存池申请空间的起始地址
    obj * __VOLATILE * my_free_list;
    obj * result;
    obj * current_obj, * next_obj;
    int i;

    // 如果只申请到一个对象的大小, 就直接返回一个内存的大小
    if (1 == nobjs) return(chunk);
    my_free_list = free_list + FREELIST_INDEX(n);

    // 申请的大小不只一个对象的大小的时候
    result = (obj *)chunk;
    // my_free_list指向内存池返回的地址的下一个对齐后的地址
    *my_free_list = next_obj = (obj *)(chunk + n);
    // 这里从第二个开始的原因主要是第一块地址返回给了用户, 现在需要把从内存池里面分配的内存用链表给串起来
    for (i = 1; ; i++) 
    {
        current_obj = next_obj;
        next_obj = (obj *)((char *)next_obj + n);
        if (nobjs - 1 == i) 
        {
            current_obj -&amp;gt; free_list_link = 0;
            break;
        } 
        else 
        {
            current_obj -&amp;gt; free_list_link = next_obj;
        }
        }
    return(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;再从deallocate结束&quot;&gt;再从deallocate结束&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;释放的内存大于128字节直接调用一级配置器进行释放&lt;/li&gt;
&lt;li&gt;将内存直接还给对应大小的链表就行了, 并不用直接释放内存, 以便后面分配内存的时候快速.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static void deallocate(void *p, size_t n)
{
      obj *q = (obj *)p;
      obj * __VOLATILE * my_free_list;
    
      // 释放的内存大于128字节直接调用一级配置器进行释放
      if (n &amp;gt; (size_t) __MAX_BYTES) 
      {
        malloc_alloc::deallocate(p, n);
        return;
      }
      my_free_list = free_list + FREELIST_INDEX(n);
      q -&amp;gt; free_list_link = *my_free_list;
      *my_free_list = q;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;统一的接口&quot;&gt;统一的接口&lt;/h4&gt;
&lt;p&gt;定义符合STL规格的配置器接口, 不管是一级配置器还是二级配置器都是使用这个接口进行分配的&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 定义符合STL规格的配置器接口, 不管是一级配置器还是二级配置器都是使用这个接口进行分配的
template&amp;lt;class T, class Alloc&amp;gt;
class simple_alloc {
  public:
    static T *allocate(size_t n)
    { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }
    static T *allocate(void)
    { return (T*) Alloc::allocate(sizeof (T)); }
    static void deallocate(T *p, size_t n)
    { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }
    static void deallocate(T *p)
    { Alloc::deallocate(p, sizeof (T)); }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;用链表来保存不同字节大小的内存块, 就很容易的进行维护, 而且每次的内存分配都直接可以从链表或者内存池中获得, 提升了我们申请内存的效率, 毕竟每次调用malloc和free效率是很低的, 特别是很小内存的时候.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STL默认的就是第二级配置器, 它会自动判断我们使用哪一个配置器.&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 07:24:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>前言 第一级是直接调用 分配空间, 调用 释放空间, 第二级三就是建立一个内存池, 小于128字节的申请都直接在内存池申请, 不直接调用 和`free`. 本节分析第二级空间配置器, STL将第二级配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10087810.html</dc:identifier>
</item>
<item>
<title>java实现哈夫曼编码 - 银海、</title>
<link>http://www.cnblogs.com/yu-kunpeng/p/10087415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yu-kunpeng/p/10087415.html</guid>
<description>&lt;h2 id=&quot;哈夫曼树&quot;&gt;哈夫曼树&lt;/h2&gt;
&lt;p&gt;  既然是学习哈夫曼编码，我们首先需要知道什么是哈夫曼树：&lt;strong&gt;给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1332925/201812/1332925-20181208133933708-5875812.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;哈夫曼编码&quot;&gt;哈夫曼编码&lt;/h2&gt;
&lt;p&gt;  在日常计算机的使用中，我们一定会出现下面这种情况：假如给定a、b、c、d、e五个字符，它们在文本中出现的概率如下图所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0.12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;0.40&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;0.15&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;0.05&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0.25&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们现在要将文本编码成0/1序列从而使得计算机能够进行读取和计算。为了保证每个字符的独一性，所以我们给予不同的的字符以不同的编码。如果给每个字符赋予等长的编码的话，会使得平均的编码长度过长，影响计算时的性能，浪费计算机的资源(&lt;strong&gt;定长编码&lt;/strong&gt;的缺点)。这时我们就想到了&lt;strong&gt;变长编码&lt;/strong&gt;，理所当然的，给出现概率较大的字符赋予较短的编码，概率较小的字符赋予较长的编码，这样在计算的时候不就可以节省很多时间了吗？可这样我们又面临到了一个巨大的问题，我们来看下面这种情况，我们对字符进行编码：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0.12&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;0.40&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;0.15&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;0.05&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0.25&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  假设现在文本中的字符是bcd，转换之后的0/1序列为00010，可我们要在转换成文本的时候究竟是把第一位的0读作b还是把前两位的00读作c呢？为了解决这个问题，就又有了&lt;strong&gt;前缀码&lt;/strong&gt;的概念。顾名思义，前缀码的含义就是任意字符的编码都不是其他字符编码的前缀。那么该如何形成前缀码呢？首先我们要构造一棵二叉树，指向左孩子的&quot;边&quot;记作0,指向右孩子的点记作“1”，叶子节点为代编码的字符，出现概率越大的字符离根的距离就越近。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1332925/201812/1332925-20181208141108066-1393219409.jpg&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0.12&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;0.40&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;0.15&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;0.05&lt;/td&gt;
&lt;td&gt;011&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0.25&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  我们在前面提到：哈夫曼树的带权路径最小，所以有哈夫曼树构成的前缀码记作哈夫曼编码。哈夫曼作为已知的最佳无损压缩算法，满足前缀码的性质，可以即时解码。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;哈夫曼编码（Huffman Coding），又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码（VLC）的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;java代码实现&quot;&gt;java代码实现&lt;/h2&gt;
&lt;p&gt;  实现哈夫曼编码的主要思路为从指定的文件中读出文本，首先通过遍历获得各个字符出现的概率，根据出现概率的大小构造二叉树，在此基础上进行编码解码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先来构造哈夫曼树的结点类，在结点类中有老生常谈的变量数据data、权重weight、指向左孩子的指针left、指向右孩子的指针right。除此之外，为了在构造了哈夫曼树之后容易对data进行编码，在这里我还使用了一个变量code来储存0/1字符。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1332925/201812/1332925-20181208142958708-1820730063.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Node&amp;lt;T&amp;gt; implements Comparable&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt; {
    private T data;
    private double weight;
    private Node&amp;lt;T&amp;gt; left;
    private Node&amp;lt;T&amp;gt; right;
    String code;

    public Node(T data, double weight){
        this.data = data;
        this.weight = weight;
        this.code = &quot;&quot;;

    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }

    public Node&amp;lt;T&amp;gt; getLeft() {
        return left;
    }

    public void setLeft(Node&amp;lt;T&amp;gt; left) {
        this.left = left;
    }

    public Node&amp;lt;T&amp;gt; getRight() {
        return right;
    }

    public void setRight(Node&amp;lt;T&amp;gt; right) {
        this.right = right;
    }

    public String getCode(){
        return code;
    }

    public void setCode(String str){
        code = str;
    }

    @Override
    public String toString(){
        return &quot;data:&quot;+this.data+&quot;;weight:&quot;+this.weight+&quot;;code: &quot;+this.code;
    }

    @Override
    public int compareTo(Node&amp;lt;T&amp;gt; other) {
        if(other.getWeight() &amp;gt; this.getWeight()){
            return 1;
        }
        if(other.getWeight() &amp;lt; this.getWeight()){
            return -1;
        }

        return 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;紧接着我们来构建哈夫曼树。
&lt;ul&gt;&lt;li&gt;createTree方法返回一个结点，也就是根结点。首先把所有的nodes结点类都储存在一个List中，利用Collections的sort方法把结点按照权值的大小按照从大到小的顺序进行排列。然后把List中的倒数第二个元素设为左孩子，倒数第一个元素设为右孩子。&lt;strong&gt;这个时候要注意:&lt;/strong&gt;它们的双亲结点为以左右孩子的权值的和作为权值的构成的新的结点。然后删去左右孩子结点，将形成的新结点加入的List中。直到List中只剩下一个结点，也就是根结点时为止。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public Node&amp;lt;T&amp;gt; createTree(List&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt; nodes) {
      while (nodes.size() &amp;gt; 1) {
          Collections.sort(nodes);

          Node&amp;lt;T&amp;gt; left = nodes.get(nodes.size() - 2);
          left.setCode(0 + &quot;&quot;);
          Node&amp;lt;T&amp;gt; right = nodes.get(nodes.size() - 1);
          right.setCode(1 + &quot;&quot;);
          Node&amp;lt;T&amp;gt; parent = new Node&amp;lt;T&amp;gt;(null, left.getWeight() + right.getWeight());
          parent.setLeft(left);
          parent.setRight(right);
          nodes.remove(left);
          nodes.remove(right);
          nodes.add(parent);
      }
      return nodes.get(0);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在构建哈夫曼树的类中还实现了一个广度遍历的方法,在遍历的时候，每遍历到左孩子，就把结点中的code变量加上“0”，这里的加不是简单的数学运算，而是字符串的叠加。每遍历到右孩子，就把结点中的code变量加上“1”，这样遍历过一遍后，叶子结点中的code储存的就是对应的哈夫曼编码值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; public List&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt; breadth(Node&amp;lt;T&amp;gt; root) {
      List&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt; list = new ArrayList&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;();
      Queue&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt; queue = new ArrayDeque&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;();

      if (root != null) {
          queue.offer(root);
          root.getLeft().setCode(root.getCode() + &quot;0&quot;);
          root.getRight().setCode(root.getCode() + &quot;1&quot;);
      }

      while (!queue.isEmpty()) {
          list.add(queue.peek());
          Node&amp;lt;T&amp;gt; node = queue.poll();
          if (node.getLeft() != null)
              node.getLeft().setCode(node.getCode() + &quot;0&quot;);
          if (node.getRight() != null)
              node.getRight().setCode(node.getCode() + &quot;1&quot;);

          if (node.getLeft() != null) {
              queue.offer(node.getLeft());
          }

          if (node.getRight() != null) {
              queue.offer(node.getRight());
          }
      }
      return list;
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;接下来我们首先从指定的文件中读取文本：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;File file = new File(&quot;G:/usually/input/input1.txt&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里我们还需要构造一个类对读取的文本进行处理：chars数组储存的是文本中所有可能的字符，number数组中储存的是文本中所有字符出现的次数，这里我所申请的number数组的长度为27，为什么是27呢？因为在这里加上了空格。在num方法中利用双循环对字符进行计数，在这里不再过多赘述。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class readtxt {
    char[] chars = new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s'
                                  ,'t','u','v','w','x','y','z',' '};
    int[] number = new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    public String txtString(File file){
        StringBuilder result = new StringBuilder();
        try{
            BufferedReader br = new BufferedReader(new FileReader(file));//构造一个BufferedReader类来读取文件
            String s = null;
            while((s = br.readLine())!=null){//使用readLine方法，一次读一行
                result.append(System.lineSeparator()+s);
                num(s);
            }
            br.close();
        }catch(Exception e){
            e.printStackTrace();
        }
        return result.toString();
    }

    public void num(String string){
        for(int i = 0;i&amp;lt;27;i++){
            int temp = 0;
            for(int j = 0;j&amp;lt;string.length();j++){
                if(string.charAt(j) == chars[i])
                    temp++;
            }
            number[i] += temp;
        }
    }

    public int[] getNumber(){
        return number;
    }

    public char[] getChars(){
        return chars;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;调用上面readtxt中的方法对文本进行处理,定义两个数组获得文本中出现的字符和字符出现的次数。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        readtxt read = new readtxt();
        String temp = read.txtString(file);
        int[] num = read.getNumber();
        char[] chars = read.getChars();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;利用一个循环把对应的data值和weight权重值构造成结点加入到list中。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for(int i = 0;i&amp;lt;27;i++){
            System.out.print(chars[i]+&quot;：&quot;+num[i]+&quot;   &quot;);
            list.add(new Node&amp;lt;String&amp;gt;(chars[i]+&quot;&quot;,num[i]));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构建哈夫曼树并得到根结点。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        HuffmanTree huffmanTree = new HuffmanTree();
        Node&amp;lt;String&amp;gt; root = huffmanTree.createTree(list);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;调用哈夫曼树中广度遍历方法，在建立两个新的list用来储存遍历之后的字符以及相对应的哈夫曼编码。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;list2=huffmanTree.breadth(root);
        for(int i = 0;i&amp;lt;list2.size();i++){
            if(list2.get(i).getData()!=null) {
                list3.add(list2.get(i).getData());
                list4.add(list2.get(i).getCode());
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对从指定文本中读出的数据进行遍历，并与list3中的字符进行比较，如若相等，则转换为对应的变码。直至遍历结束，哈夫曼编码完成。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for(int i = 0;i&amp;lt;temp.length();i++){
            for(int j = 0;j&amp;lt;list3.size();j++){
                if(temp.charAt(i) == list3.get(j).charAt(0))
                    result += list4.get(j);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在解码的过程中我在这里选择了用一个list5把已编码完成的字符串分开来储存，然后对list5在进行遍历，从list5中取出一位元素temp2与list4中对应的编码进行比对，如果没有相同的，再从list5中读取一位加到temp2的后面，如果有，则清空temp2。每次找到相同的，就把对应的字符加到temp3的后面，直至整个list5遍历结束，temp3即为解码后的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for(int i = 0;i&amp;lt;result.length();i++){
            list5.add(result.charAt(i)+&quot;&quot;);
        }
        while (list5.size()&amp;gt;0){
            temp2 = temp2+&quot;&quot; +list5.get(0);
            list5.remove(0);
            for(int i=0;i&amp;lt;list4.size();i++){
                if (temp2.equals(list4.get(i))) {
                    temp3 = temp3+&quot;&quot;+list3.get(i);
                    temp2 = &quot;&quot;;
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;写入文件，大功告成！&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;File file2 =new File(&quot;G:/usually/input/input2.txt&quot;);
        Writer out =new FileWriter(file2);
        out.write(temp3);
        out.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  最后得到的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1332925/201812/1332925-20181208150310520-1275201814.png&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 08 Dec 2018 07:06:00 +0000</pubDate>
<dc:creator>银海、</dc:creator>
<og:description>java实现哈夫曼编码 哈夫曼树   既然是学习哈夫曼编码，我们首先需要知道什么是哈夫曼树： 给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yu-kunpeng/p/10087415.html</dc:identifier>
</item>
<item>
<title>进阶的Redis之数据持久化RDB与AOF - 公众号_Zack说码</title>
<link>http://www.cnblogs.com/zackku/p/10087701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zackku/p/10087701.html</guid>
<description>&lt;p&gt;大家都知道，Redis之所以性能好，读写快，是因为Redis是一个内存数据库，它的操作都几乎基于内存。但是内存型数据库有一个很大的弊端，就是当数据库进程崩溃或系统重启的时候，如果内存数据不保存的话，里面的数据就会丢失不见了。这样的数据库并不是一个可靠的数据库。&lt;/p&gt;
&lt;p&gt;所以数据的持久化是内存型数据库的重中之重。它不仅提供数据保存硬盘的功能，还可以借此用硬盘容量扩展数据存储空间，使得Redis的可以存储超过机器本身内存大小的数据。&lt;/p&gt;
&lt;p&gt;Redis对于数据持久化提供了两种持久化的方案，RDB与AOF。它们的原理和使用场景都大不相同，下面我们来详细地了解下。&lt;/p&gt;

&lt;p&gt;RDB，提供一个某个时间点的数据的Snapshot，保存在RDB文件中。它可以通过&lt;code&gt;SAVE/BGSAVE&lt;/code&gt;命令手动执行，把数据Snapshot写到RDB文件，也可以通过配置，定时执行。&lt;/p&gt;
&lt;p&gt;Redis也可以通过加载RDB文件，把数据从磁盘加载读取到Redis中。&lt;/p&gt;
&lt;h2 id=&quot;rdb文件创建&quot;&gt;RDB文件创建&lt;/h2&gt;
&lt;p&gt;连上Redis，设值一些值，然后执行&lt;code&gt;SAVE&lt;/code&gt;命令。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/set-value-save.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以查看下redis.conf的持久化工作目录。进入目录可以看到保存了一个dump.rdb文件。该文件是一个二进制文件，无法直接正常打开。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/save-rdb.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;SAVE/BGSAVE&lt;/code&gt;的区别，就是前置是阻塞执行，此时服务不会接受请求，后者是Fork一个子进程出来，由该进程去执行保存RDB文件的操作，不影响用户请求。&lt;/p&gt;
&lt;p&gt;P.S. Redis是单进程的，所以&lt;code&gt;BGSAVE&lt;/code&gt;只能Fork一个子进程，而不是创建一个线程处理。&lt;/p&gt;
&lt;p&gt;以上是手动执行的过程。但在生产我们很少会手动登上服务去执行操作，所以更多的时候是依赖Redis的配置，定时保存RDB文件。&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;redis.conf&lt;/code&gt;配置文件，找到&lt;strong&gt;SNAPSHOTTING&lt;/strong&gt;的配置，Save Point的设置。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/db-conf.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;图中的配置意思是，当至少有一个key变更时，900秒后会执行一次SAVE。其他配置同理，有10次变更，300秒后保存一次.....&lt;/p&gt;
&lt;p&gt;在Redis中，这个自动保存RDB的功能是默认开启的。&lt;/p&gt;
&lt;h2 id=&quot;rdb文件加载&quot;&gt;RDB文件加载&lt;/h2&gt;
&lt;p&gt;先kill掉Redis进程，再重新启动Redis Server，会发现日志会有这样的一行，&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/redis-load-2.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且Redis中，依然有之前设置的三个值。说明Redis在启动的时候，会加载数据初始化。&lt;/p&gt;
&lt;p&gt;不过，这里加载的初始化数据不一定是RDB的。如果Redis开启了AOF，会优先从AOF初始化数据，否则才会加载RDB的数据。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/load-rule.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;（出处《Redis设计与实现》——黄健宏）&lt;/p&gt;
&lt;h2 id=&quot;rdb优缺点&quot;&gt;RDB优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RDB是某一时间点的快照，是一个紧凑的单文件，更多用于数据备份。可以按每小时或每日来备份，方便从不同的版本恢复数据。&lt;/li&gt;
&lt;li&gt;单文件容易传输到远程服务做故障恢复。&lt;/li&gt;
&lt;li&gt;RDB可以Fork子进程进行持久化，使Redis可以更好地处理用户请求&lt;/li&gt;
&lt;li&gt;在大量数据的情况下，RDB相比较于AOF会更快的加载。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果Redis不及时保存RDB文件，会造成数据的丢失。例如系统突然断电，但未来得及保存数据。即使你设置更多的Save point，也无法保证100%的数据不丢失。&lt;/li&gt;
&lt;li&gt;RDB经常需要fork子进程去执行，但如果再大量数据的情况下，这个fork操作会非常耗CPU资源的。对比AOF虽然也是fork，但是它的数据保存处理是可以控制的，不需要全量保存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redis的另外一种持久化方案就是AOF，Append Only File。AOF相当于一个操作的日志记录，每次对于数据的变更都会记录追加到AOF日志。当服务启动的时候就会读这些操作日志，重新执行一次操作，从而恢复原始数据。&lt;/p&gt;
&lt;h2 id=&quot;aof启用&quot;&gt;AOF启用&lt;/h2&gt;
&lt;p&gt;AOF默认是关闭的。打开redis.conf配置文件，找到&lt;code&gt;appendonly no&lt;/code&gt;改成&lt;code&gt;appendonly yes&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/append.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;AOF和RDB是可以共存的，只要保存的文件名不冲突。&lt;/p&gt;
&lt;h2 id=&quot;aof-fsync同步规则&quot;&gt;AOF fsync同步规则&lt;/h2&gt;
&lt;p&gt;配置文件往下拉，看到&lt;code&gt;fsync&lt;/code&gt;的配置。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/fsync.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;fsync()是一个系统调用函数，告诉操作系统把数据写到硬盘上，而不是缓存更多数据才写到硬盘。这样的调用可以及时保存数据到硬盘上。&lt;/p&gt;
&lt;p&gt;Redis提供了三种fsync的调用方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;appendfsync always，每次操作记录都同步到硬盘上，最低效，最安全。&lt;/li&gt;
&lt;li&gt;appendfsync everysec，每秒执行一次把操作记录同步到硬盘上。默认选项。&lt;/li&gt;
&lt;li&gt;appendfsync no，不执行fysnc调用，让操作系统自动操作把缓存数据写到硬盘上，不可靠，但最快。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;aof文件格式解析&quot;&gt;AOF文件格式解析&lt;/h2&gt;
&lt;p&gt;开启AOF后，会再工作目录看到&lt;code&gt;appendonly.aof&lt;/code&gt;文件。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/aof-file.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;在客户端上执行一些命令后，打开AOF文件，可以观察到有对应的操作的记录日志。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/aof-data.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;文件解析说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*，表示命令的参数个数，例如&lt;code&gt;set a 1&lt;/code&gt;是三个参数，所以是*3&lt;/li&gt;
&lt;li&gt;$，表示参数的字节数，例如&lt;code&gt;set&lt;/code&gt;这个参数是三字节，所以是$3，key值a是一个字节，所以是$1&lt;/li&gt;
&lt;li&gt;无符号，表示是参数的数据，例如&lt;code&gt;set&lt;/code&gt;,&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;就是具体的数据&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;日志重写&quot;&gt;日志重写&lt;/h2&gt;
&lt;p&gt;AOF虽然比RDB更可靠，但缺点也是比较明显的，就是每次写操作都要把操作日志写到文件上，这样会导致文件非常冗余。&lt;/p&gt;
&lt;p&gt;假若你要自增一个计数器100次，如果不重写，AOF文件就就会有这100次的自增记录，如&lt;code&gt;INCR a&lt;/code&gt;。如果执行了日志重写，那么文件只会保留&lt;code&gt;set a 100&lt;/code&gt;而不是100条&lt;code&gt;INCR a&lt;/code&gt;。这样拥有相同的结果，但可以大大减少AOF的文件大小，并且可以让AOF载入的时候提升载入的效率。&lt;/p&gt;
&lt;p&gt;看回&lt;code&gt;redis.conf&lt;/code&gt;配置，有两项控制rewrite的选项。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/aof-rewrite.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auto-aof-rewrite-percentage 100，当文件增长100%（一倍）时候，自动重写。&lt;/li&gt;
&lt;li&gt;auto-aof-rewrite-min-size 64mb，日志重写最小文件大小，如果小于该大小，不会自动重写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来实验一下重写的结果，我们先设定一个a值，然后自增多次，查看AOF文件内容。里面有很多INCR的语句记录&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/incr-test.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们手动执行下&lt;code&gt;BGREWRITEOF&lt;/code&gt;，执行日志重写。&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/rewrite-test-2.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;可以看到，多个incr语句，变成了一个&lt;code&gt;set a 6&lt;/code&gt;语句，减少了5个&lt;code&gt;incr a&lt;/code&gt;语句的操作日志。&lt;/p&gt;
&lt;h2 id=&quot;aof优缺点&quot;&gt;AOF优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AOF可以设置 完全不同步、每秒同步、每次操作同，默认是每秒同步。因为AOF是操作指令的追加，所以可以频繁的大量的同步。&lt;/li&gt;
&lt;li&gt;AOF文件是一个值追加日志的文件，即使服务宕机为写入完整的命令，也可以通过redis-check-aof工具修复这些问题。&lt;/li&gt;
&lt;li&gt;如果AOF文件过大，Redis会在后台自动地重写AOF文件。重写后会使AOF文件压缩到最小所需的指令集。&lt;/li&gt;
&lt;li&gt;AOF文件是有序保存数据库的所有写入操作，易读，易分析。即使如果不小心误操作数据库，也很容易找出错误指令，恢复到某个数据节点。例如不小心FLUSHALL，可以非常容易恢复到执行命令之前。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;相同数据量下，AOF的文件通常体积会比RDB大。因为AOF是存指令的，而RDB是所有指令的结果快照。但AOF在日志重写后会压缩一些空间。&lt;/li&gt;
&lt;li&gt;在大量写入和载入的时候，AOF的效率会比RDB低。因为大量写入，AOF会执行更多的保存命令，载入的时候也需要大量的重执行命令来得到最后的结果。RDB对此更有优势。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上已经基本了解过RDB和AOF的使用、基本原理以及对应的优缺点。那么在实际当中，我们到底怎么去选择用哪种持久化方式呢？&lt;/p&gt;
&lt;p&gt;一般来说，不考虑硬盘大小，最安全的做法是RDB与AOF同时使用，即使AOF损坏无法修复，还可以用RDB来恢复数据。&lt;/p&gt;
&lt;p&gt;如果Redis的数据在你的服务中并不是必要的数据，例如只是当简单的缓存，没有缓存也不会造成缓存雪崩。说明数据的安全可靠性并不是首要考虑范围内，那么单独只使用RDB就可以了。&lt;/p&gt;
&lt;p&gt;不推荐单独使用AOF，因为AOF对于数据的恢复载入来说，比RDB慢。并且Redis官方也说明了，AOF有一个罕见的bug。出了问题无法很好的解决。所以使用AOF的时候，最好还是有RDB作为数据备份。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/redis-rdb-aof/plan.png?imageMogr2/auto-orient/blur/1x0/quality/75%7Cwatermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;br/&gt;根据官方的意愿描述，在未来可能会有一种RDB与AOF相结合的持久化模型。到时Redis持久化就不再如此麻烦费劲了，我们拭目以待吧。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;更多技术文章、精彩干货，请关注&lt;br/&gt;博客：zackku.com&lt;br/&gt;微信公众号：Zack说码&lt;br/&gt;&lt;img src=&quot;http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 06:55:00 +0000</pubDate>
<dc:creator>公众号_Zack说码</dc:creator>
<og:description>大家都知道，Redis之所以性能好，读写快，是因为Redis是一个内存数据库，它的操作都几乎基于内存。但是内存型数据库有一个很大的弊端，就是当数据库进程崩溃或系统重启的时候，如果内存数据不保存的话，里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zackku/p/10087701.html</dc:identifier>
</item>
<item>
<title>加载loading对话框的功能(不退出沉浸式效果) - cczheng</title>
<link>http://www.cnblogs.com/cczheng-666/p/10087607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cczheng-666/p/10087607.html</guid>
<description>&lt;p&gt;上一篇基于修改系统源码的前提下，实现了完全的沉浸式体验效果。可参考这篇 &lt;a href=&quot;https://www.cnblogs.com/cczheng-666/p/9792842.html&quot;&gt;戳这&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在沉浸式效果下，当界面弹出对话框时，对话框将获取到焦点，这将导致界面退出沉浸式效果，那么是不是能通过屏蔽对话框获取焦点来达到不退出沉浸式的目的呢。说干就干，我们先来看一下改善后的效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BuuqwRI.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通对话框弹出效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Ta95xZH.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LoadingDialog弹出效果&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义loadingdialog&quot;&gt;自定义LoadingDialog&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class LoadingDialog extends Dialog {

    public LoadingDialog(Context context) {
        super(context);
    }

    public LoadingDialog(Context context, int theme) {
        super(context, theme);
    }

     @Override
    public void show() {
        //在show之前添加禁止获取焦点
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);
        super.show();
        if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.KITKAT) {
            int uiOptions = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_FULLSCREEN;
            this.getWindow().getDecorView().setSystemUiVisibility(uiOptions);
        }
        //在show之后取消禁止获取焦点属性，否则会导致dialog无法处理点击
        this.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面不难看出，在show之前，我们添加了一个window的FLAG_NOT_FOCUSABLE属性，让window不能获取焦点，在show之后，移除刚刚添加的FLAG_NOT_FOCUSABLE属性，这样就实现了所需要的效果。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;private WindowManager mwWindowManager;
private FrameLayout mForewarnLayout;
private boolean isShowing = false;
/**显示全屏的加载动画*/
public void alertLoadingDialog(){
    if (!isShowing){
        mForewarnLayout = (FrameLayout) LayoutInflater.from(getApplicationContext())
                .inflate(R.layout.view_loading, null, false);
        // 获取window管理对象
        mwWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
        // 设置布局参数
        WindowManager.LayoutParams forewarnLayoutParams = new WindowManager.LayoutParams();
        forewarnLayoutParams.type = WindowManager.LayoutParams.TYPE_PHONE; // 设置window TYPE
        forewarnLayoutParams.format = PixelFormat.RGBA_8888; // 设置图片格式，效果位背景透明
        // 设置Window flag
        forewarnLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
        forewarnLayoutParams.gravity = Gravity.LEFT | Gravity.TOP; //
        // 调整悬浮窗口至左上角，便于调整坐标
        // 设置悬浮窗口长宽数据
        forewarnLayoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        forewarnLayoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
        // forewarnLayoutParams.windowAnimations = R.style.anim_view;// 添加进入动画
        // 添加布局视图
        mwWindowManager.addView(mForewarnLayout, forewarnLayoutParams);
        isShowing = true;
    }
}

/**取消全屏的加载动画*/
public void dismissTwo() {
    if (isShowing) {
        mwWindowManager.removeViewImmediate(mForewarnLayout);
        isShowing = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/SDHUHFV.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addView弹出效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理没啥可说的，直接用就完了，需要注意的是，addView和removeView需要一一对应，以上代码已经加了判断处理。还需要添加权限，不然会报错。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里顺带说一下removeView和removeViewImmediate的区别，两个方法设计到线程同步问题，removeViewImmediate()是通知View立刻调用View.onDetachWindow()，这说明这个方法是通过一个监听或者观察者来实现的，因为线程的同步跟异步问题导致activity销毁了，但view还没有被remove完，会导致窗体泄露。&lt;/p&gt;
&lt;p&gt;例子比较简单，如需demo请留言&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Sat, 08 Dec 2018 06:31:00 +0000</pubDate>
<dc:creator>cczheng</dc:creator>
<og:description>上一篇基于修改系统源码的前提下，实现了完全的沉浸式体验效果。可参考这篇 [戳这][1] 一、自定义Dialog 在沉浸式效果下，当界面弹出对话框时，对话框将获取到焦点，这将导致界面退出沉浸式效果，那么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cczheng-666/p/10087607.html</dc:identifier>
</item>
</channel>
</rss>