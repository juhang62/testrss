<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>漫谈网站优化提速 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11173611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11173611.html</guid>
<description>&lt;p&gt;前几天的一个晚上，在和一个偶然认识的小白，聊了半个晚上的网站加速的事情，总觉自己最后没有讲清楚，固有此文产生。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本篇文章只涉及前端优化，暂不涉及后端操作，默认后端能抗住所有访问，算力无限大，响应时间无限小。因为加上后端的话，这个命题不是短短的几篇文章搞的定的，大多数都要依据具体的业务来确定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文涉及到的浏览器为Chrome浏览器，不具有统一性，仅供参考使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户和网站的交互是通过浏览器来完成的，要谈前端优化，那么，我们就要搞清楚，从用户输入了一串url以后，浏览器到底做了什么。&lt;/p&gt;
&lt;h2 id=&quot;浏览器如何打开一个网页&quot;&gt;1. 浏览器如何打开一个网页&lt;/h2&gt;
&lt;p&gt;这里我们先不考虑路由寻址的事情，后面我们再细细道来，在Chrome浏览器中先打开F12，打开network，可以看到一个网站从输入url到页面显示，具体发送了多少请求。我们以百度为示例，看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/baidu1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先第一行，可以看到浏览器请求了百度这个页面的主题文件HTML，当浏览器收到这个HTML之后，浏览器和这个页面的缘分，就此开始。&lt;/p&gt;
&lt;h3 id=&quot;浏览器渲染流程&quot;&gt;1.1 浏览器渲染流程&lt;/h3&gt;
&lt;p&gt;用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/webkit1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/webkit2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;渲染流程有四个主要步骤：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;解析HTML生成DOM树 - 渲染引擎首先解析HTML文档，生成DOM树&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构建Render树 - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;布局Render树 - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;绘制Render树 - 最后遍历渲染树并用UI后端层将每一个节点绘制出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。&lt;/p&gt;
&lt;h3 id=&quot;渲染细节&quot;&gt;1.2 渲染细节&lt;/h3&gt;
&lt;p&gt;浏览器渲染一个页面的过程叫做“关键渲染路径（Critical Rendering Path 简称CRP）”，下面我们来聊一下什么是CRP，这对我们进行代码级的优化有很大的指导意义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CRP的相关知识对于如何提升网站性能是相当有用的，共有6个步骤：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;构建DOM树&lt;/li&gt;
&lt;li&gt;构建CSSOM树&lt;/li&gt;
&lt;li&gt;运行JavaScript&lt;/li&gt;
&lt;li&gt;创建渲染树&lt;/li&gt;
&lt;li&gt;生成布局&lt;/li&gt;
&lt;li&gt;绘制页面&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/crp1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面详细聊一下什么是CRP，不感兴趣的童鞋可以直接跳过这一段看结论。&lt;/p&gt;
&lt;h4 id=&quot;构建dom树&quot;&gt;1.1.1 构建DOM树&lt;/h4&gt;
&lt;p&gt;DOM（Document Object Model）树是一个表示整个解析过的HTML页面的对象，从根节点&amp;lt;html&amp;gt;开始，会创建页面中的每个元素/文本节点。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;  
&amp;lt;head&amp;gt;  
  &amp;lt;title&amp;gt;Understanding the Critical Rendering Path&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
  &amp;lt;header&amp;gt;
      &amp;lt;h1&amp;gt;Understanding the Critical Rendering Path&amp;lt;/h1&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;main&amp;gt;
      &amp;lt;h2&amp;gt;Introduction&amp;lt;/h2&amp;gt;
      &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet&amp;lt;/p&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
      &amp;lt;small&amp;gt;Copyright 2017&amp;lt;/small&amp;gt;
  &amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 HTML 将会被解析成下面的DOM树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/crp2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTML的优点在于它不必等待整个页面加载完成才呈现页面，可以解析一部分，显示一部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;但是像CSS、JavaScript等其他资源会阻止页面渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;构建cssom树&quot;&gt;1.1.2 构建CSSOM树&lt;/h4&gt;
&lt;p&gt;CSSOM（CSS Object Model） 是一个跟DOM相关的样式对象。它跟DOM的表示方法是相似的，但是不论显式声明还是隐式继承，每个节点都存在关联样式。&lt;/p&gt;
&lt;p&gt;在上面提到的html页面的style.css中的样式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;body { font-size: 18px; }

header { color: plum; }  
h1 { font-size: 28px; }

main { color: firebrick; }  
h2 { font-size: 20px; }

footer { display: none; } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会被构建成下面的CSSOM树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/crp3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CSS 被认为是 “渲染阻塞资源”，它意味着如果不首先完全解析资源，渲染树是无法构建的。CSS由于它的层叠继承的性质，不能像HTML一样解析一部分，显示一部分。定义在文档后面的样式会覆盖或改写之前定义的样式，因为在整个样式表都被解析之前，如果我们使用了在样式表中较早定义的样式，那错误的样式将被应用。这意味着CSS必须被全部解析之后，才能开始下一步。&lt;/p&gt;
&lt;h4 id=&quot;运行javascript&quot;&gt;1.1.3 运行JavaScript&lt;/h4&gt;
&lt;p&gt;JavaScript被认为是解析阻塞资源，这意味着HTML的解析会被JavaScript阻塞。&lt;/p&gt;
&lt;p&gt;当解析器解析到 &amp;lt;script&amp;gt; 标签时，无论该资源是内部还是外链的都会停止解析，先去下载资源。这也是为什么，当页面内有引用JavaScript文件时，引用标签要放到可视元素之后了。&lt;/p&gt;
&lt;p&gt;为避免JavaScript解析阻塞，它可以通过设定 async 属性来要求其异步加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script async src=&quot;script.js&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建渲染树&quot;&gt;1.1.4 创建渲染树&lt;/h4&gt;
&lt;p&gt;渲染树是DOM和CSSOM的结合体，它代表最终会渲染在页面上的元素的结构对象。这意味着它只关注可见内容，对于被隐藏或者CSS属性 display:none 的属性，不会被包含在结构内。&lt;/p&gt;
&lt;p&gt;使用上面例子的DOM和CSSOM，渲染树被创建如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/crp4.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;生成布局&quot;&gt;1.1.5 生成布局&lt;/h4&gt;
&lt;p&gt;布局决定了浏览器视窗的大小,它提供了上下文依赖的CSS样式，如百分比或窗口的单位。视窗尺寸通常通过 &amp;lt;head&amp;gt; 标签中的 &amp;lt;meta&amp;gt; 中的 viewport 设定来决定。如果不存在该标签，则通常默认为 980px&lt;/p&gt;
&lt;p&gt;例如，最常用的 meta veiwport 的值将会被设置为和设备宽度相符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用户访问网页的设备宽度为1000px。然后整体视窗尺寸就会基于这个宽度值了，比如 50% 就是500px, 10vw 就是100px 等等。&lt;/p&gt;
&lt;h4 id=&quot;绘制页面&quot;&gt;1.1.6 绘制页面&lt;/h4&gt;
&lt;p&gt;最后，在绘制页面步骤。页面上的所有可见内容都会被转换为像素并呈现在屏幕上。&lt;/p&gt;
&lt;p&gt;具体的绘制时间跟DOM数以及应用的样式有关。有些样式会花费更多的执行时间，比如复杂的渐变背景图片所需要的计算时间远超过简单固定背景色。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;1.2 总结&lt;/h3&gt;
&lt;p&gt;纵观整个CRP流程，CSS，JS等静态资源加载是阻塞式的，而我们的目标是让整个页面最快呈现在用户面前，并可以使用，而一个页面的呈现和HTML、CSS息息相关，那么这两个一定是要最先被加载的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键的css需要放在html的头部位置，保证被最先加载，加载完成后可以开始渲染页面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JS只是关系了网站的一些交互操作，包括一些动态效果，那么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;js应该放在html的最下部，和渲染视图脱离，保证视图渲染完成后再加载js，同时，js应尽量保持异步加载，不要阻塞主线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;页面除了HTML，JS，CSS还有一个使用最多的那就是图片&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图片要做压缩，很多时候高清大图并不是一个好的选择&lt;/li&gt;
&lt;li&gt;图片尽量使用jpg格式（体积小）&lt;/li&gt;
&lt;li&gt;图片除了首屏以外，最好使用懒加载的方式，减少初次页面渲染所需要的时间&lt;/li&gt;
&lt;li&gt;小的icon整合成一张大图，减少图片加载请求数（使用时可以使用css对图片显示做定位）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，还可以从网络层考虑优化方向：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重新review整个页面，去除所有不必要的资源加载&lt;/li&gt;
&lt;li&gt;css样式表可以合并成为一个文件，减少浏览器请求数&lt;/li&gt;
&lt;li&gt;css样式表需要做压缩，减少网络传输时间（具体有工具，大家可以自己去网上找）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有很多我一下想不到的地方，不过总体的思想就几句话：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽一切可能减少网络请求数&lt;/li&gt;
&lt;li&gt;尽一切可能减少网络传输数据&lt;/li&gt;
&lt;li&gt;如果以上两点都做到了，那么除了关键html和css以外，其他资源的加载请尽量走异步的形式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;从url到浏览器之间到底都经历了什么&quot;&gt;2. 从url到浏览器之间到底都经历了什么？&lt;/h2&gt;
&lt;p&gt;上面我们聊了浏览器接受到资源请求后的一些操作处理，那么从url输入浏览器到浏览器接收到资源中间到底都经历了什么，这一块我们能做什么优化呢？&lt;/p&gt;
&lt;p&gt;首先，我们来看一下从url到浏览器之间到底都经历了什么？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，在浏览器地址栏中输入url&lt;/li&gt;
&lt;li&gt;浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。&lt;/li&gt;
&lt;li&gt;在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。&lt;/li&gt;
&lt;li&gt;浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。&lt;/li&gt;
&lt;li&gt;握手成功后，浏览器向服务器发送http请求，请求数据包。&lt;/li&gt;
&lt;li&gt;服务器处理收到的请求，将数据返回至浏览器&lt;/li&gt;
&lt;li&gt;浏览器收到HTTP响应&lt;/li&gt;
&lt;li&gt;读取页面内容，浏览器渲染，解析html源码&lt;/li&gt;
&lt;li&gt;生成Dom树、解析css样式、js交互&lt;/li&gt;
&lt;li&gt;客户端和服务器交互&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先，我们能做优化的地方只有可怜的2，包括4、5、6、7、8都是标准的处理流程，我们也无法干涉。&lt;/p&gt;
&lt;h3 id=&quot;缓存查找&quot;&gt;2.1 缓存查找&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；&lt;/li&gt;
&lt;li&gt;操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；&lt;/li&gt;
&lt;li&gt;路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；&lt;/li&gt;
&lt;li&gt;ISP缓存：若上述均失败，继续向ISP搜索。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在很少有改动的页面上开启浏览器缓存，在打开页面时尽可能的利用浏览器缓存&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;网站访问慢还有什么可能&quot;&gt;3. 网站访问慢还有什么可能？&lt;/h2&gt;
&lt;p&gt;网站打开速度慢受很多因素的影响，简单归纳下常见的几个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主机服务器不堪重负，响应速度慢；&lt;/li&gt;
&lt;li&gt;静态资源占用了主机服务大量的带宽，达到了上限；&lt;/li&gt;
&lt;li&gt;网站的图片和内容太大，需要花费很多时间下载；&lt;/li&gt;
&lt;li&gt;网站使用了太多不同的脚本和图片，这些脚本和图片没有针对快速加载网站进行优化，加载时间长；&lt;/li&gt;
&lt;li&gt;网站的服务器位置与终端用户位于不同的地理位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实还有许多其他的原因，但这些以上列举的几点是比较常见的。&lt;/p&gt;
&lt;h3 id=&quot;终极大杀器cdn&quot;&gt;3.1 终极大杀器——CDN&lt;/h3&gt;
&lt;h4 id=&quot;什么是cdn&quot;&gt;3.1.1 什么是CDN？&lt;/h4&gt;
&lt;p&gt;CDN指的是内容分发网络。其基本思路是尽可能的避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。&lt;/p&gt;
&lt;p&gt;通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;p&gt;简单打个比方，我们常喜欢在京东上买东西，今天下单明天就能送到。而在淘宝上，我们享受不到这样的速度。为什么呢？因为京东的物流体系完善。假设你在上海购买了海南的一件商品，淘宝走快递可能要走3天才到你手上，但是京东在全国设有仓库物流点，从就近的杭州发货点发货到上海，一天就可以到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/image/2019-07-10/image/cdn.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而CDN一般都由运营商或者大型云服务提供商来提供，可以给更大的网络带宽，可以部署的离终端用户位置更近，有智能DNS，有效缓解所有流量全部回源对我们的主服务造成的流量冲击，带来更高的可用性，当然，这样会造成静态资源缓存，如果我们需要更新静态资源，面临着缓存的挑战，不过，也不是没有解决方案的，所有的静态资源在访问的时候都应该加上版本号，防止访问到前面版本的资源，造成更新不及时。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/csdnnews/article/details/95267307&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/csdnnews/article/details/95267307&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 00:41:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>漫谈网站优化提速 前几天的一个晚上，在和一个偶然认识的小白，聊了半个晚上的网站加速的事情，总觉自己最后没有讲清楚，固有此文产生。 本篇文章只涉及前端优化，暂不涉及后端操作，默认后端能抗住所有访问，算力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11173611.html</dc:identifier>
</item>
<item>
<title>Docker笔记（一）：什么是Docker - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11186877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11186877.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文地址： &lt;a href=&quot;http://blog.jboost.cn/2019/07/13/docker-1.html&quot;&gt;http://blog.jboost.cn/2019/07/13/docker-1.html&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工具服务，部署业务项目，基于gitlab+jenkins pipeline+docker的CI/CD实现等。了解其基本知识与操作，但不能说深度掌握，故借此系列进行梳理与学习，也希望对有意学习Docker的人提供参考。&lt;/p&gt;
&lt;h2 id=&quot;2-Docker简介&quot;&gt;2. Docker简介&lt;/h2&gt;
&lt;p&gt;Docker最初是dotCloud公司（后来也改名为Docker）的一个内部项目，于2013年3月开源。Docker使用Google推出的Go语言实现，基于Linux内核的cgroup、namespace、Union FS等技术（先不用急着了解这些都是啥），对进程进行隔离，是操作系统层面的虚拟化技术。相对于传统的硬件层面的虚拟化技术（虚拟机），Docker显得更为轻量化。下图为传统虚拟机与Docker的结构对比&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/vm-docker.png&quot; alt=&quot;vm-docker&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可看出传统虚拟机技术是在硬件层面虚拟出一套硬件（CPU、内存、磁盘、网卡等）后，在其上运行一个完整的操作系统，再在操作系统上运行应用进程；而Docker的应用进程是直接运行在宿主机的内核上，也不需要进行硬件虚拟，因此，Docker要比传统虚拟机更为轻便。&lt;/p&gt;
&lt;p&gt;总结Docker相对传统虚拟化技术的优势如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;更高的资源利用率：&lt;/strong&gt;Docker不需要硬件虚拟与运行完整操作系统的开销，所以资源利用率更高，同样配置的主机，采用Docker往往可以运行更多数量的应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高效的使用体验：&lt;/strong&gt;在操作系统上安装一些常用软件，如mysql，redis等，往往需要折腾好一阵，有些还要手动安装各种依赖，而采用Docker，可能几行命令就可以让一个服务快速运行起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致的运行环境：&lt;/strong&gt;Docker镜像功能可以把程序运行需要的环境进行封装，确保程序在开发、测试、生产环境都能保持一致性，避免因环境不一致导致程序运行异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CI/CD支持：&lt;/strong&gt;使用Docker可以定制镜像来实现持续集成、持续部署，如基于gitlab + jenkins pipeline + docker的自动化部署。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更轻松的维护：&lt;/strong&gt;因为Docker保证了运行环境的一致性，因此应用的迁移或缩放将变得很容易；Docker的分层存储与镜像技术，也使得应用重复部分的复用变得更简单，基于基础镜像可以进一步扩展定义自己的镜像，也可以直接使用官方镜像来使用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;3-Docker的基本架构&quot;&gt;3. Docker的基本架构&lt;/h2&gt;
&lt;p&gt;Docker的基本架构图如下&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/docker-arch.png&quot; alt=&quot;docker-arch&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要包括几部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Docker daemon（Docker守护进程 &lt;code&gt;dockerd&lt;/code&gt;）：Docker的执行引擎，负责监听处理Docker客户端请求与管理Docker相关对象，如镜像、容器、网络、数据卷等。一个Docker守护进程可与其它Docker守护进程进行通信，作为Docker服务进行管理。&lt;/li&gt;
&lt;li&gt;Docker client（Docker客户端 &lt;code&gt;docker&lt;/code&gt;）：Docker客户端（&lt;code&gt;docker&lt;/code&gt; CLI命令）是大多数用户用来与Docker守护进程交互的方式，比如你在命令行执行&lt;code&gt;docker run&lt;/code&gt;，Docker客户端将发送该命令请求到Docker守护进程，由守护进程执行。Docker客户端可通过REST API, UNIX Socket或网络接口来与Docker守护进程进行通信，并且可与多个Docker守护进程进行通信。&lt;/li&gt;
&lt;li&gt;Docker Registry（Docker注册中心）：用来存储Docker镜像的仓库，类似于Maven的Nexus。Docker官方提供了一个公共镜像仓库Docker Hub（ &lt;a href=&quot;https://hub.docker.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/&lt;/a&gt; ），&lt;code&gt;docker&lt;/code&gt;相关命令默认会从Docker Hub上搜索与下载镜像，我们可以配置一些国内镜像仓库地址来进行加速，甚至搭建自己的私有镜像仓库。&lt;/li&gt;
&lt;li&gt;Docker Objects：Docker管理的对象，主要包括镜像、容器、网络、数据卷等。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;4-Docker的用途&quot;&gt;4. Docker的用途&lt;/h2&gt;
&lt;p&gt;根据第二部分Docker的优势及笔者的经验来看，目前Docker主要用于&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常用软件服务的搭建运行，如Mysql、Redis、Nginx等&lt;/li&gt;
&lt;li&gt;业务服务的发布部署，尤其是基于SpringBoot的微服务&lt;/li&gt;
&lt;li&gt;CI/CD实现，结合Gitlab的webhook，Jenkins的pipeline，实现自动化集成与部署&lt;/li&gt;
&lt;li&gt;快速的弹性伸缩，在容器集群化管理的场景中，如Swarm、K8s解决方案中，可基于容器对服务进行快速的弹性伸缩来应对业务量的突发情况&lt;/li&gt;
&lt;li&gt;执行环境封装，如一些深度学习框架模型，打成Docker镜像的方式进行发布，可以快速在不同的环境中运行起来&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;在微服务架构、DevOps这些概念盛行的时代，容器化技术变得越来越重要，几乎成为每一位开发人员需要掌握的技能。本系列文章是笔者基于自身实践及相关文献参考，对Docker相关技术进行整理，欢迎关注，共同学习。&lt;/p&gt;&lt;p&gt;我的个人博客地址：&lt;a href=&quot;http://blog.jboost.cn/&quot;&gt;http://blog.jboost.cn&lt;/a&gt;&lt;br/&gt;我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）&lt;br/&gt;———————————————————————————————————————————————————————————————&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/qrcode-05.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 00:39:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>原文地址： http://blog.jboost.cn/2019/07/13/docker-1.html 1. 前言 接触Docker也有两年多了，断断续续玩过一些应用场景，如安装一些常用工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11186877.html</dc:identifier>
</item>
<item>
<title>Android 开发你需要了解的那些事 - AndroidTraveler</title>
<link>http://www.cnblogs.com/nesger/p/11186144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/11186144.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文微信公众号「AndroidTraveler」首发。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;最近部门有新入职员工，作为规划技术路线的导师，这边给新员工安排了学习路线。&lt;/p&gt;
&lt;p&gt;除了基本的学习路线之外，每次沟通，我都留了一个小问题，让小伙伴去思考。&lt;/p&gt;
&lt;p&gt;这些问题有些是刚接触 Android 开发的小伙伴所不熟悉的，有些则是部分初级工程师都没有注意到的。&lt;/p&gt;
&lt;p&gt;因此这边纪录一下，希望帮助刚毕业进入职场的 Android 小伙伴，或是对这些还不是很熟悉的 Android 开发工程师们。&lt;/p&gt;
&lt;p&gt;如有补充或者交流，欢迎留言。&lt;/p&gt;
&lt;h3 id=&quot;第一点anr-的其中一个条件并不是在-activity-主线程做耗时任务&quot;&gt;第一点：ANR 的其中一个条件并不是在 Activity 主线程做耗时任务&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 你是否了解过 ANR？&lt;br/&gt;&lt;strong&gt;A：&lt;/strong&gt; 知道，但不是很了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 什么情况下会出现 ANR？&lt;br/&gt;假设这里回答的不是“在主线程执行耗时任务”的话，可以不继续追问，直接让小伙伴去了解 ANR，后期再讨论。&lt;br/&gt;如果回答了是“在主线程执行耗时任务”的话，那么继续：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 多久算耗时？&lt;br/&gt;&lt;strong&gt;A：&lt;/strong&gt; 不要超过 5s。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 那么假设我在 Activity sleep 20s，是不是就一定会 ANR？&lt;/p&gt;
&lt;p&gt;上代码例子：&lt;br/&gt;MainActivity.java 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Log.e(&quot;zengyu&quot;,&quot;before sleep&quot;);
                try {
                    Thread.sleep(20000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Log.e(&quot;zengyu&quot;,&quot;after sleep&quot;);
            }
        });
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;activity_main.xml 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&amp;gt;

    &amp;lt;Button
        android:id=&quot;@+id/button&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;8dp&quot;
        android:text=&quot;Button&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;

&amp;lt;/android.support.constraint.ConstraintLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码功能很简单，就是一个按钮，点击之后会 sleep 20 秒。在 sleep 前和 sleep 后都会打印日志。&lt;/p&gt;
&lt;p&gt;如果你只是点击按钮，然后什么都不动，是不会有 ANR 的。&lt;/p&gt;
&lt;p&gt;但是你点击了按钮之后，你继续多次点击按钮，那么就会有 ANR 了。&lt;/p&gt;
&lt;p&gt;以下四个条件都可以造成ANR发生：&lt;br/&gt;&lt;strong&gt;InputDispatching Timeout：&lt;/strong&gt; 5秒内无法响应屏幕触摸事件或键盘输入事件&lt;br/&gt;&lt;strong&gt;BroadcastQueue Timeout ：&lt;/strong&gt; 在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。&lt;br/&gt;&lt;strong&gt;Service Timeout ：&lt;/strong&gt; 前台服务20秒内，后台服务在200秒内没有执行完毕。&lt;br/&gt;&lt;strong&gt;ContentProvider Timeout ：&lt;/strong&gt; ContentProvider的publish在10s内没进行完。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所以可能很多小伙伴会把上面四个条件的第一个和 Activity 直接挂钩，以为是在主线程耗时超过 5s 就会 ANR。实际上是 &lt;strong&gt;InputDispatching。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第二点子线程使用&quot;&gt;第二点：子线程使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 既然主线程不能做耗时任务，那么有耗时任务怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：&lt;/strong&gt; 通过 new Thread 启动一个子线程，在子线程处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 考虑一个场景，比如类似微信这类 IM 软件收到消息。需要写数据库，这个时候需要启动线程。当收到消息 N 多的时候，如果都用 new Thread 启动线程的话，是否会有问题。场景模拟可以通过循环创建子线程模拟。&lt;/p&gt;
&lt;p&gt;上代码例子：&lt;br/&gt;MainActivity.java 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        for (int i = 0; i &amp;lt; 10000; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个部分手机厂商比如（华为）有对线程数目做限制的话，一运行就会 crash，Logcat 会看到下面信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pthread_create (1040KB stack) failed: Out of memory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这边一开始在三星 S7 上面运行，并没有出现。后面换成华为 5x 手机就出现了。&lt;/p&gt;
&lt;p&gt;Android 开发的小伙伴都知道兼容是硬伤，所以我们不能抱有侥幸心理。&lt;/p&gt;
&lt;p&gt;针对这种情况，我们不能一遇到耗时任务，就很潇洒的一个 new Thread 全部搞定。&lt;/p&gt;
&lt;p&gt;如果你当前界面只有一个耗时任务，而且只需要调用一次，那么你进入该界面用 new Thread 来处理没有问题。&lt;/p&gt;
&lt;p&gt;但是假设像上面我们描述的场景那样，需要调用多次的时候。你就不能简单粗暴的使用 new Thread 了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;推荐方式是使用线程池。&lt;/strong&gt;&lt;br/&gt;一个原因是避免一些厂商的线程数目限制。&lt;br/&gt;另一个原因是减少线程的频繁创建和销毁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第三点内部类都可能存在的问题&quot;&gt;第三点：内部类都可能存在的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 上面我们说到了，如果界面调用一次，而且需要启动线程的时候。可以使用 new Thread 创建，那么直接使用 new Thread 可能还有什么问题吗？&lt;/p&gt;
&lt;p&gt;这里想考察的点可能比较晦涩一点。&lt;/p&gt;
&lt;p&gt;由于内部类会持有外部类的引用。假设在 Activity 里面通过匿名内部类的方式来启动线程做耗时任务。当用户退出界面时，由于内部类还持有 Activity 的引用，因此 Activity 没法得到释放。&lt;/p&gt;
&lt;p&gt;就会存在&lt;strong&gt;内存泄漏问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法也比较统一，那就是将内部类改为静态内部类。&lt;/p&gt;
&lt;p&gt;所以修改后的代码对比如下：&lt;/p&gt;
&lt;p&gt;修改前：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        new Thread(new Runnable() {
            @Override
            public void run() {
                //TODO
            }
        }).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        new StaticThread().start();
    }

    private static class StaticThread extends Thread {
        @Override
        public void run() {
            super.run();
            //TODO
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四点弱引用场景应用&quot;&gt;第四点：弱引用场景应用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 用过 Handler 吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：&lt;/strong&gt; 用过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; 写一下简单的 demo 我看下。&lt;/p&gt;
&lt;p&gt;这个是紧接第三点。如果不涉及界面交互，只需要使用到静态内部类就可以解决。但是当 Handler 里面需要做界面更新处理时，那么需要使用弱引用。因为静态内部类的处理方式本来就是为了避免 Activity 无法得到释放。你如果把 Activity 直接传进来，那么 Activity 的引用被静态内部类持用了，所以这个时候就需要使用到弱引用了。&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MainActivity extends AppCompatActivity {
    private static class StaticHandler extends Handler {
        private WeakReference&amp;lt;MainActivity&amp;gt; activityWeakReference;

        public StaticHandler(MainActivity mainActivity) {
            this.activityWeakReference = new WeakReference&amp;lt;&amp;gt;(mainActivity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            //TODO
            //use activityWeakReference.get() to get view
        }
    }

    private StaticHandler mStaticHandler = new StaticHandler(this);
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mStaticHandler.sendEmptyMessage(0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第五点持久化-sharedpreferences-的使用&quot;&gt;第五点：持久化 SharedPreferences 的使用&lt;/h3&gt;
&lt;p&gt;一般很多网上教程和例子在 SharedPreferences 的数据写入时，一般都会使用 Editor 的 commit 方法。&lt;/p&gt;
&lt;p&gt;由于 commit 方法是同步写入的。并且写文件属于 I/O 操作，如果你有大量的数据需要写入，并且你是在主线程处理的，可能会导致流畅性受影响。极端情况下可能会出现 ANR。&lt;/p&gt;
&lt;p&gt;我们点进去源码看下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;If you don't care about the return value and you're using this from your application's main thread, consider using {@link #apply} instead.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实源码也说的很清楚了。如果你不关心返回值并且你是在应用的主线程使用的话，考虑使用 apply 替换 commit。&lt;/p&gt;
&lt;p&gt;由于我们一般不会处理返回值，因此建议使用 apply 替换 commit。&lt;/p&gt;
&lt;p&gt;apply 会把变化马上写进内存，然后通过异步方式去写入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Unlike {@link #commit}, which writes its preferences out to persistent storage synchronously, {@link #apply} commits its changes to the in-memory {@link SharedPreferences} immediately but starts an asynchronous commit to disk and you won't be notified of any failures.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然源码还有一个注释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;If another editor on this {@link SharedPreferences} does a regular {@link #commit} while a {@link #apply} is still outstanding, the {@link #commit} will block until all async commits are completed as well as the commit itself.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概意思就是 apply 如果在处理中还未完成的情况下，commit 会阻塞直到所有异步操作完成才会去 commit。&lt;/p&gt;
&lt;p&gt;因此如果要替换，建议将 commit 都替换为 apply。&lt;/p&gt;
&lt;h3 id=&quot;第六点数据库相关处理&quot;&gt;第六点：数据库相关处理&lt;/h3&gt;
&lt;p&gt;这里主要是考虑类似微信 IM 登录后拉取大量离线消息写入数据库的问题。&lt;/p&gt;
&lt;p&gt;通过对比开启事务和不开启事务的耗时来进行说明。&lt;/p&gt;
&lt;p&gt;比如不开启事务插入 10000 条纪录和开启事务插入 10000 条纪录耗时对比。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于大量的数据库操作，建议开启事务的方式，速度的提升是很明显的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/388166988cef&quot;&gt;Android ANR：原理分析及解决办法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/5/16bc08e14696aba3?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=231181&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 00:38:00 +0000</pubDate>
<dc:creator>AndroidTraveler</dc:creator>
<og:description>本文微信公众号「AndroidTraveler」首发。 背景 最近部门有新入职员工，作为规划技术路线的导师，这边给新员工安排了学习路线。 除了基本的学习路线之外，每次沟通，我都留了一个小问题，让小伙伴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nesger/p/11186144.html</dc:identifier>
</item>
<item>
<title>设计一个全局异常处理器 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11186867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11186867.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a7010e6815837.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近稍微闲了一点于是把这个半年都没更新的开源项目 &lt;a href=&quot;https://github.com/TogetherOS/cicada&quot;&gt;cicada&lt;/a&gt; 重新捡了起来。&lt;/p&gt;
&lt;p&gt;一些新关注的朋友应该还不知道这项目是干啥的？先来看看官方介绍吧（其实就我自己写的😀）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;cicada: 基于 Netty4 实现的快速、轻量级 WEB 框架；没有过多的依赖，核心 jar 包仅 &lt;code&gt;30KB&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a70635d532624.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这个轮子以前也写过相关的介绍，感兴趣的可以再翻回去看看：&lt;/p&gt;
&lt;p&gt;这些都看完了相信对这个小玩意应该会有更多的想法。&lt;/p&gt;

&lt;p&gt;广告打完了，回到正题；大家平时最常用的 &lt;code&gt;MVC&lt;/code&gt; 框架当属 &lt;code&gt;SpringMVC&lt;/code&gt; 了，而在搭建脚手架的时候相信全局异常处理是必不可少的。&lt;/p&gt;
&lt;h2 id=&quot;spring-用法&quot;&gt;Spring 用法&lt;/h2&gt;
&lt;p&gt;通常我们的做法如下：&lt;/p&gt;
&lt;p&gt;传统 &lt;code&gt;Spring&lt;/code&gt; 版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现一个 &lt;code&gt;Spring&lt;/code&gt; 自带的接口，重写其中的方法，最后的异常处理便在此处。&lt;/li&gt;
&lt;li&gt;将这个类配置在 &lt;code&gt;Spring&lt;/code&gt; 的 &lt;code&gt;xml&lt;/code&gt; ，当做一个 bean 注册到 &lt;code&gt;Spring&lt;/code&gt; 容器中。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CustomExceptionResolver implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request,
            HttpServletResponse response, Object handler, Exception ex) {
    //自定义处理
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;ssm.exception.CustomExceptionResolver&quot;&amp;gt;&amp;lt;/bean&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;当然现在流行的 &lt;code&gt;SpringBoot&lt;/code&gt; 也有对应的简化版本：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    public Object defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
        //自定义处理
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全部都换为注解形式，但本质上还是一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;都是要在容器中创建一个特殊的 bean，这个 bean 专门用于处理异常，当系统运行时出现异常，就从容器中找到该 bean，并执行其中的方法即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于这个特殊的 &lt;code&gt;bean&lt;/code&gt; 如何标识出来，无非就是实现某个特定接口或者用注解声明，也就对应了传统 &lt;code&gt;Spring&lt;/code&gt; 和 &lt;code&gt;SpringBoot&lt;/code&gt; 的用法。&lt;/p&gt;
&lt;h2 id=&quot;cicada-用法&quot;&gt;cicada 用法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cicada&lt;/code&gt; 在设计自己的全局异常处理器时也参考了 Spring 的相关设计，所以最终用法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@CicadaBean
public class ExceptionHandle implements GlobalHandelException {
    private final static Logger LOGGER = LoggerBuilder.getLogger(ExceptionHandle.class);

    @Override
    public void resolveException(CicadaContext context, Exception e) {
        LOGGER.error(&quot;Exception&quot;, e);
        WorkRes workRes = new WorkRes();
        workRes.setCode(&quot;500&quot;);
        workRes.setMessage(e.getClass().getName() + &quot;系统运行出现异常&quot;);
        context.json(workRes);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义一个实现了 &lt;code&gt;GlobalHandelException&lt;/code&gt; 接口的类，当请求出现异常时，页面和后台将会如下输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a708987b32808.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a70e668052739.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看得出用法和 &lt;code&gt;Spring&lt;/code&gt; 非常类似，也是需要实现一个接口 &lt;code&gt;GlobalHandelException&lt;/code&gt;，同时使用 &lt;code&gt;@CicadaBean&lt;/code&gt; 注解该类将他加载到 &lt;code&gt;cicada&lt;/code&gt; 内置的 &lt;code&gt;IOC&lt;/code&gt; 容器内。&lt;/p&gt;
&lt;p&gt;当出现异常时则在这个 &lt;code&gt;IOC&lt;/code&gt; 容器中找到该对象调用它的 &lt;code&gt;resolveException&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;其中还可以通过 &lt;code&gt;CicadaContext&lt;/code&gt; 全局上下文响应不同的输出（&lt;code&gt;json/text/html&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;核心原理&quot;&gt;核心原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a712df5717670.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单画了下流程图，步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化时会找到实现了 &lt;code&gt;GlobalHandelException&lt;/code&gt; 接口的类，将它实例化并注册到 &lt;code&gt;IOC&lt;/code&gt; 容器中。&lt;/li&gt;
&lt;li&gt;当发生异常时从容器中获取到异常处理器的对象，执行其中的处理函数即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说了半天原理来看看源码是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a716caeb94532.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初始化 &lt;code&gt;bean&lt;/code&gt; 时，如果是一个异常处理器则会将他单独存放（也就相当于前文说的打标识）。&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;GlobalHandelException&lt;/code&gt; 本身的定义也非常简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a7198bb390309.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来是运行时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a71bc98986729.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a71f27d495514.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/07/14/5d2b4a7221b4f38396.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当出现异常时则会通过之前的保存的异常处理 &lt;code&gt;bean&lt;/code&gt; 进行异常处理，在调用的同时将全局上下文及异常信息传递过去就齐活了。&lt;/p&gt;
&lt;p&gt;这样就可以在这个实现类中实现我们自己的异常处理逻辑了。&lt;/p&gt;

&lt;p&gt;万一今后面试官问你们 &lt;code&gt;SpringMVC&lt;/code&gt; 的异常处理是如何实现的？你该知道怎么回答了吧😏。&lt;/p&gt;
&lt;p&gt;同时也可以发散一下，是否可以配置一个针对于某一个 &lt;code&gt;controller&lt;/code&gt; 的异常处理，这样每个 &lt;code&gt;controller&lt;/code&gt; 产生的异常可以单独处理，如果没有配置则进入全局异常；原理也差不多，感兴趣的朋友可以提个 &lt;code&gt;PR&lt;/code&gt; 完成该 &lt;code&gt;feature&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/TogetherOS/cicada&quot; class=&quot;uri&quot;&gt;https://github.com/TogetherOS/cicada&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 00:34:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>最近稍微闲了一点于是把这个半年都没更新的开源项目 cicada 重新捡了起来。 一些新关注的朋友应该还不知道这项目是干啥的？先来看看官方介绍吧（其实就我自己写的😀）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11186867.html</dc:identifier>
</item>
<item>
<title>SpringBoot事物Transaction实战讲解教程 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/11184162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/11184162.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要介绍的是SpringBoot的事物Transaction使用的教程。&lt;/p&gt;
&lt;h2 id=&quot;springboot-transaction&quot;&gt;SpringBoot Transaction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;transaction&quot;&gt;Transaction&lt;/h3&gt;
&lt;h4 id=&quot;事务管理方式&quot;&gt;事务管理方式&lt;/h4&gt;
&lt;p&gt;在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。&lt;/li&gt;
&lt;li&gt;声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。&lt;br/&gt;声明式事务管理不需要入侵代码，通过@Transactional就可以进行事务操作，更快捷而且简单，推荐使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事务提交方式&quot;&gt;事务提交方式&lt;/h4&gt;
&lt;p&gt;默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。&lt;br/&gt;对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，spring会将底层连接的自动提交特性设置为false。也就是在使用spring进行事物管理的时候，spring会将是否自动提交设置为false，等价于JDBC中的 &lt;code&gt;connection.setAutoCommit(false);&lt;/code&gt;，在执行完之后在进行提交，&lt;code&gt;connection.commit();&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;事务隔离级别&quot;&gt;事务隔离级别&lt;/h4&gt;
&lt;p&gt;隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事务传播行为&quot;&gt;事务传播行为&lt;/h4&gt;
&lt;p&gt;所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事务回滚规则&quot;&gt;事务回滚规则&lt;/h4&gt;
&lt;p&gt;指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。&lt;br/&gt;默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。&lt;br/&gt;可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。&lt;/p&gt;
&lt;h4 id=&quot;事务常用配置&quot;&gt;事务常用配置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;readOnly：该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true)；&lt;/li&gt;
&lt;li&gt;rollbackFor： 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})；&lt;/li&gt;
&lt;li&gt;rollbackForClassName： 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称@Transactional(rollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”})。&lt;/li&gt;
&lt;li&gt;noRollbackFor：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class})。&lt;/li&gt;
&lt;li&gt;noRollbackForClassName：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName={“RuntimeException”,”Exception”})。&lt;/li&gt;
&lt;li&gt;propagation ： 该属性用于设置事务的传播行为。例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)。&lt;/li&gt;
&lt;li&gt;isolation：该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置。&lt;/li&gt;
&lt;li&gt;timeout：该属性用于设置事务的超时秒数，默认值为-1表示永不超时。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;事物注意事项&quot;&gt;事物注意事项&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;要根据实际的需求来决定是否要使用事物，最好是在编码之前就考虑好，不然到以后就难以维护；&lt;/li&gt;
&lt;li&gt;如果使用了事物，请务必进行事物测试，因为很多情况下以为事物是生效的，但是实际上可能未生效！&lt;/li&gt;
&lt;li&gt;事物@Transactional的使用要放再类的&lt;strong&gt;公共(public)方法&lt;/strong&gt;中，需要注意的是在 protected、private 方法上使用 @Transactional 注解，它也不会报错(IDEA会有提示)，但事务无效。&lt;/li&gt;
&lt;li&gt;事物@Transactional是不会对该方法里面的子方法生效！也就是你在公共方法A声明的事物@Transactional，但是在A方法中有个子方法B和C，其中方法B进行了数据操作，但是该异常被B自己处理了，这样的话事物是不会生效的！反之B方法声明的事物@Transactional，但是公共方法A却未声明事物的话，也是不会生效的！如果想事物生效，需要将子方法的事务控制交给调用的方法，在子方法中使用&lt;code&gt;rollbackFor&lt;/code&gt;注解指定需要回滚的异常或者将异常抛出交给调用的方法处理。一句话就是在使用事物的时候子方法最好将异常抛出！&lt;/li&gt;
&lt;li&gt;事物@Transactional由spring控制的时候，它会在抛出异常的时候进行回滚。如果自己使用catch捕获了处理了，是不生效的，如果想生效可以进行手动回滚或者在catch里面将异常抛出，比如&lt;code&gt;throw new RuntimeException();&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;环境要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;：1.8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;：1.5.17.RELEASE&lt;/p&gt;
&lt;p&gt;首先还是Maven的相关依赖:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.17.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath /&amp;gt; 
    &amp;lt;/parent&amp;gt;
  &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- Spring Boot Web 依赖 核心 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
            &amp;lt;!-- Spring Boot Test 依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
          &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      &amp;lt;!-- MySQL 连接驱动依赖 --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;5.1.44&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      &amp;lt;!-- Druid 数据连接池依赖 --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.1.8&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt;的文件的配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;banner.charset=UTF-8
server.tomcat.uri-encoding=UTF-8
spring.http.encoding.charset=UTF-8
spring.http.encoding.enabled=true
spring.http.encoding.force=true
spring.messages.encoding=UTF-8
spring.application.name=springboot-transactional
server.port=8182

spring.datasource.url=jdbc:mysql://localhost:3306/springBoot?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;allowMultiQueries=true
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5
spring.datasource.minIdle=5
spring.datasource.maxActive=20
spring.datasource.maxWait=60000
spring.datasource.timeBetweenEvictionRunsMillis=60000
spring.datasource.minEvictableIdleTimeMillis=300000
spring.datasource.validationQuery=SELECT 1 FROM DUAL
spring.datasource.testWhileIdle=true
spring.datasource.testOnBorrow=false
spring.datasource.testOnReturn=false
spring.datasource.poolPreparedStatements=true
spring.datasource.maxPoolPreparedStatementPerConnectionSize=20
spring.datasource.filters=stat,wall,log4j
spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000

logging.level.com.pancm.dao=debug&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;SpringBoot在使用事物Transactional的时候，要在main方法上加上 &lt;code&gt;@EnableTransactionManagement&lt;/code&gt; 注解开发事物声明，在使用的service层的公共方法加上 &lt;code&gt;@Transactional&lt;/code&gt; (spring)注解。&lt;/p&gt;
&lt;h4 id=&quot;使用示例一&quot;&gt;使用示例一&lt;/h4&gt;
&lt;p&gt;那么首先我们来看下 &lt;code&gt;@Transactional&lt;/code&gt; 这个注解的使用方法吧，只需要你在需要添加公共方法上面添加该注解即可。但是这么使用的话需要你将异常抛出，由spring进行去控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Transactional
    public boolean test1(User user) throws Exception {
        long id = user.getId();
        System.out.println(&quot;查询的数据1:&quot; + udao.findById(id));
        // 新增两次，会出现主键ID冲突，看是否可以回滚该条数据
        udao.insert(user);
        System.out.println(&quot;查询的数据2:&quot; + udao.findById(id));
        udao.insert(user);
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用示例二&quot;&gt;使用示例二&lt;/h4&gt;
&lt;p&gt;如果我们在使用事物 &lt;code&gt;@Transactional&lt;/code&gt; 的时候，想自己对异常进行处理的话，那么我们可以进行手动回滚事物。在catch中加上 &lt;code&gt;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();&lt;/code&gt; 方法进行手动回滚。不过需要注意的是发生异常需要第一时间进行手动回滚事物，也就是要在异常抛出之前！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Transactional
    public boolean test2(User user) {

        long id = user.getId();
        try {
            System.out.println(&quot;查询的数据1:&quot; + udao.findById(id));
            // 新增两次，会出现主键ID冲突，看是否可以回滚该条数据
            udao.insert(user);
            System.out.println(&quot;查询的数据2:&quot; + udao.findById(id));
            udao.insert(user);
        } catch (Exception e) {
            System.out.println(&quot;发生异常,进行手动回滚！&quot;);
            // 手动回滚事物
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            e.printStackTrace();
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用示例三&quot;&gt;使用示例三&lt;/h4&gt;
&lt;p&gt;如果我们在使用事物 &lt;code&gt;@Transactional&lt;/code&gt; 的时候，调用了其他的子方法进行了数据库的操作，但是我们想使其事物生效的话，我们可以使用&lt;code&gt;rollbackFor&lt;/code&gt;注解或者将该子方法的异常抛出由调用的方法进行处理，不过这里需要注意的是，子方法也必须是公共的方法！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Transactional
    public boolean test3(User user) {

        /*
         * 子方法出现异常进行回滚
         */
        try {
            System.out.println(&quot;查询的数据1:&quot; + udao.findById(user.getId()));
            deal1(user);
            deal2(user);
            deal3(user);
        } catch (Exception e) {
            System.out.println(&quot;发生异常,进行手动回滚！&quot;);
            // 手动回滚事物
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
            e.printStackTrace();
        } 
        return false;

    }

    public void deal1(User user) throws SQLException {
        udao.insert(user);
        System.out.println(&quot;查询的数据2:&quot; + udao.findById(user.getId()));
    }

    public void deal2(User user)  throws SQLException{
        if(user.getAge()&amp;lt;20){
            //SQL异常
            udao.insert(user);
        }else{
            user.setAge(21);
            udao.update(user);
            System.out.println(&quot;查询的数据3:&quot; + udao.findById(user.getId()));
        }
    }


    @Transactional(rollbackFor = SQLException.class)
    public void deal3(User user)  {
        if(user.getAge()&amp;gt;20){
            //SQL异常
            udao.insert(user);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用示例四&quot;&gt;使用示例四&lt;/h4&gt;
&lt;p&gt;如果我们不想使用事物 &lt;code&gt;@Transactional&lt;/code&gt; 注解，想自己进行事物控制(编程事物管理)，控制某一段的代码事物生效，但是又不想自己去编写那么多的代码，那么可以使用springboot中的&lt;code&gt;DataSourceTransactionManager&lt;/code&gt;和&lt;code&gt;TransactionDefinition&lt;/code&gt;这两个类来结合使用，能够达到手动控制事物的提交回滚。不过在进行使用的时候，需要注意在回滚的时候，要确保开启了事物但是未提交，如果未开启或已提交的时候进行回滚是会在catch里面发生异常的！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;
    @Autowired
    private TransactionDefinition transactionDefinition;

    public boolean test4(User user) {
        /*
         * 手动进行事物控制
         */
        TransactionStatus transactionStatus=null;
        boolean isCommit = false;
        try {
            transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
            System.out.println(&quot;查询的数据1:&quot; + udao.findById(user.getId()));
            // 进行新增/修改
            udao.insert(user);
            System.out.println(&quot;查询的数据2:&quot; + udao.findById(user.getId()));
            if(user.getAge()&amp;lt;20) {
                user.setAge(user.getAge()+2);
                udao.update(user);
                System.out.println(&quot;查询的数据3:&quot; + udao.findById(user.getId()));
            }else {
                throw new Exception(&quot;模拟一个异常!&quot;);
            }
            //手动提交
            dataSourceTransactionManager.commit(transactionStatus);
            isCommit= true;
            System.out.println(&quot;手动提交事物成功!&quot;);
            throw new Exception(&quot;模拟第二个异常!&quot;);

        } catch (Exception e) {
            //如果未提交就进行回滚
            if(!isCommit){
                System.out.println(&quot;发生异常,进行手动回滚！&quot;);
                //手动回滚事物
                dataSourceTransactionManager.rollback(transactionStatus);
            }
            e.printStackTrace();
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的这几种示例是比较常见使用的，基本可以满足日常我们对事物的使用，spring里面还有一种事物的控制方法，就是设置断点进行回滚。但是这种方法个人还没实际验证过，可靠性待确认。&lt;br/&gt;使用方法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Object savePoint =null;
    try{
    //设置回滚点
    savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint();
    }catch(Exception e){
        //出现异常回滚到savePoint。
     TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的使用示例介绍完毕之后，我们再来介绍一下几个主要的类。&lt;/p&gt;
&lt;p&gt;首先还是实体类:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又是万能的用户表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    public class User {
        
         private Long id;
    
         private String name;
         
         private Integer age;
         
        //getter 和 setter 略
        
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Controller 控制层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后便是控制层，控制层这块的我做了下最后的查询，用于校验事物是否成功生效！&lt;/p&gt;
&lt;p&gt;控制层代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @RestController
    @RequestMapping(value = &quot;/api/user&quot;)
    public class UserRestController {
    
        @Autowired
        private UserService userService;
        
        @Autowired
        private UserDao userDao;
        
    
        @PostMapping(&quot;/test1&quot;)
        public boolean test1(@RequestBody User user) {
            System.out.println(&quot;请求参数:&quot; + user);
            try {
                userService.test1(user);
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            System.out.println(&quot;最后查询的数据:&quot; + userDao.findById(user.getId()));
            return true;
        }
        
        @PostMapping(&quot;/test2&quot;)
        public boolean test2(@RequestBody User user) {  
            System.out.println(&quot;请求参数:&quot; + user);
            userService.test2(user);
            System.out.println(&quot;最后查询的数据:&quot; + userDao.findById(user.getId()));
            return true;
        }
                
        @PostMapping(&quot;/test3&quot;)
        public boolean test3(@RequestBody User user) {  
            System.out.println(&quot;请求参数:&quot; + user);
            userService.test3(user);
            System.out.println(&quot;最后查询的数据:&quot; + userDao.findById(user.getId()));
            return true;
        }
        
        @PostMapping(&quot;/test4&quot;)
        public boolean test4(@RequestBody User user) {  
            System.out.println(&quot;请求参数:&quot; + user);
            userService.test4(user);
            System.out.println(&quot;最后查询的数据:&quot; + userDao.findById(user.getId()));
            return true;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App 入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和普通的SpringBoot项目基本一样，只不过需要加上 &lt;code&gt;@EnableTransactionManagement&lt;/code&gt; 注解！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @EnableTransactionManagement
    @SpringBootApplication
    public class TransactionalApp
    {
            
        public static void main( String[] args )
        {
            SpringApplication.run(TransactionalApp.class, args);
            System.out.println(&quot;Transactional 程序正在运行...&quot;);
        
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;我们在启动程序之后，来进行上述的几个示例测试，这里的测试示例分别对应上述的使用示例，有的示例需要测试两边以上才能验证事物是否能够生效！这里我们使用&lt;a href=&quot;https://blog.csdn.net/qazwsxpcm/article/details/70578600&quot;&gt;Postman&lt;/a&gt;进行测试！&lt;/p&gt;
&lt;h4 id=&quot;测试示例一&quot;&gt;测试示例一&lt;/h4&gt;
&lt;p&gt;两次测试，第一次不使用&lt;code&gt;@Transactional&lt;/code&gt;注解，第二次使用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释掉&lt;code&gt;@Transactional&lt;/code&gt;注解！&lt;br/&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=18]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=18]
 Duplicate entry '1' for key 'PRIMARY'
 最后查询的数据:User [id=1, name=xuwujing, age=18]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解除&lt;code&gt;@Transactional&lt;/code&gt;注解注释！&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=18]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=18]
 Duplicate entry '1' for key 'PRIMARY'
 最后查询的数据:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; 在第二次测试的之前是把第一次测试写入数据库的id为1的数据个删除了！&lt;/p&gt;
&lt;p&gt;第一次测试中由于没有添加&lt;code&gt;@Transactional&lt;/code&gt;注解，因此发生了异常数据还是写入了，但是第二次测试中添加了&lt;code&gt;@Transactional&lt;/code&gt;注解，发现即使数据已经写入了，但是出现了异常之后，数据最终被回滚了，没有写入！&lt;br/&gt;从上述的测试用例中可以看到测试用例一种的事物已经生效了！&lt;/p&gt;
&lt;h4 id=&quot;测试示例二&quot;&gt;测试示例二&lt;/h4&gt;
&lt;p&gt;由于使用示例二中的代码几乎和使用示例一种的一样，不同的是异常由我们自己进行控制！&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=18]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=18]
 发生异常,进行手动回滚!
 Duplicate entry '1' for key 'PRIMARY'
 最后查询的数据:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到事物生效了！&lt;/p&gt;
&lt;h4 id=&quot;测试示例三&quot;&gt;测试示例三&lt;/h4&gt;
&lt;p&gt;由于使用示例三中进行了子方法调用，这里我们进行两次测试，根据不同的请求条件来进行测试！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=18]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=18]
 发生异常,进行手动回滚！
 Duplicate entry '1' for key 'PRIMARY'
 最后查询的数据:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:21}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=21]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=21]
 查询的数据3:User [id=1, name=xuwujing2, age=21]
 发生异常,进行手动回滚！
 Duplicate entry '1' for key 'PRIMARY'
 最后查询的数据:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上述的两次测试，可以得出使用&lt;code&gt;rollbackFor&lt;/code&gt;注解或者将该子方法的异常抛出由调用的方法进行处理都可以使事物生效！&lt;/p&gt;
&lt;h4 id=&quot;测试示例四&quot;&gt;测试示例四&lt;/h4&gt;
&lt;p&gt;由于使用示例四中进行了手动控制事物，这里我们进行两次测试，根据不同的请求条件来进行测试！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  请求参数:User [id=1, name=xuwujing, age=18]
  查询的数据1:null
  查询的数据2:User [id=1, name=xuwujing, age=18]
  查询的数据3:User [id=1, name=xuwujing2, age=20]
  手动提交事物成功!
  模拟第二个异常!
  最后查询的数据:User [id=1, name=xuwujing, age=20]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二次测试:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事先还是把数据库id为1的数据给删除！&lt;/p&gt;
&lt;p&gt;使用进行POST请求&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;http://localhost:8182/api/user/test4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Body参数为:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;{&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:21}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制台打印的数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 请求参数:User [id=1, name=xuwujing, age=21]
 查询的数据1:null
 查询的数据2:User [id=1, name=xuwujing, age=21]
 发生异常,进行手动回滚！
 模拟一个异常!
 最后查询的数据:null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上述的两次测试，我们可以得出使用手动控制事物完全ok，只要提交了事物，即使后面发生了异常也不回影响之前的写入！如果在控制的范围之类发生了异常，也可以进行回滚！&lt;/p&gt;
&lt;p&gt;测试示例图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201907/1138196-20190714141143841-523989780.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1138196/201907/1138196-20190714141151113-928155266.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;参考:&lt;br/&gt;https://www.cnblogs.com/yepei/p/4716112.html&lt;/p&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;SpringBoot 事物Transaction的项目工程地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-transactional&lt;/p&gt;
&lt;p&gt;SpringBoot整个集合的地址:&lt;br/&gt;https://github.com/xuwujing/springBoot-study&lt;/p&gt;
&lt;h3 id=&quot;springboot整合系列的文章&quot;&gt;SpringBoot整合系列的文章&lt;/h3&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 00:15:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本篇文章主要介绍的是SpringBoot的事物Transaction使用的教程。 SpringBoot Transaction 说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/11184162.html</dc:identifier>
</item>
<item>
<title>React躬行记（7）——表单 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/10634778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/10634778.html</guid>
<description>&lt;p&gt;　　表单元素是一类拥有内部状态的元素，这些状态由其自身维护，通过这类元素可让用户与Web应用进行交互。HTML中的表单元素（例如&amp;lt;input&amp;gt;、&amp;lt;select&amp;gt;和&amp;lt;radio&amp;gt;等）在React中都有相应的组件实现，不仅如此，React还将它们分成两种：受控组件和非受控组件。&lt;/p&gt;

&lt;p&gt;　　受控组件（Controlled Component）是指那些受React控制的表单元素，其状态（value、checked等属性）的变更由组件的state管理。对于不同的表单元素，其受控组件的形式会有所差异，接下来会讲解其中的三类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）文本框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　常用的单行文本框是一个type属性为“text”的&amp;lt;input&amp;gt;元素，它的值（即状态）由value属性控制。如果要监听文本框的状态变化，那么可以像下面这样操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Text extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = {value: &quot;init&quot;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle(e) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({value: e.target.value.toUpperCase()});
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input value={&lt;span&gt;this&lt;/span&gt;.state.value} onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;text&quot; /&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码实现了一个简单的功能，在改变文本框中的内容时，自动将其转换成大写字母。具体的更新过程可分为四步：&lt;/p&gt;
&lt;p&gt;（1）在构造函数中初始化组件的state，并为文本框设置默认值。&lt;/p&gt;
&lt;p&gt;（2）文本框注册onChange事件，监听其值的变化。&lt;/p&gt;
&lt;p&gt;（3）在事件处理程序handle()中，通过e.target.value读取到输入的值，修改并同步（调用this.setState()方法）到组件的state中。&lt;/p&gt;
&lt;p&gt;（4）组件重新渲染，完成文本框的内容更新。&lt;/p&gt;
&lt;p&gt;　　其他两类受控组件的更新过程与之类似，只是在细节处理上有所不同。&lt;/p&gt;
&lt;p&gt;　　观察上面的示例可以发现，文本框的数据来源于组件的state，通过onChange事件将输入的新数据再同步给组件的state，从而完成了一次双向数据绑定。&lt;/p&gt;
&lt;p&gt;　　React中的&amp;lt;textarea&amp;gt;元素（多行文本框），其使用类似于上面的&amp;lt;input&amp;gt;元素，也是通过value属性来获取值的，如下代码所示，省略了构造函数和事件处理程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class TextArea extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;textarea value={&lt;span&gt;this&lt;/span&gt;.state.value} onChange={&lt;span&gt;this&lt;/span&gt;.handle} /&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而HTML中的&amp;lt;textarea&amp;gt;元素则会将值定义成子元素，并且包含结束标签，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;init&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）单选框和复选框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　单选框是一个type属性为“radio”的&amp;lt;input&amp;gt;元素，复选框是一个type属性为“checkbox”的&amp;lt;input&amp;gt;元素。与之前的文本框不同，React控制的不是它们的值，而是选中状态，即布尔属性checked。在下面的例子中，监听了每个单选框的checked属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Radio extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = { gender: &quot;&quot;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle(e) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
      gender: e.target.value
    });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&amp;gt;
        &amp;lt;input name=&quot;gender&quot; value=&quot;1&quot; onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;radio&quot;&lt;span&gt; 
          checked&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;.state.gender == &quot;1&quot;&lt;span&gt;}
        &lt;/span&gt;/&amp;gt;男
        &amp;lt;input name=&quot;gender&quot; value=&quot;2&quot; onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;radio&quot;&lt;span&gt;
          checked&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;.state.gender == &quot;2&quot;&lt;span&gt;}
        &lt;/span&gt;/&amp;gt;女
      &amp;lt;/&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复选框能选中多个项，其操作要比单选框繁琐许多。在下面的例子中，不但监听了每个复选框的checked属性，还将处于选中状态的值提取了出来，组成一个数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = { colors: [] };        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存复选框值的数组&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle(e) {
    const { checked, value } &lt;/span&gt;=&lt;span&gt; e.target;
    let { colors } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (checked &amp;amp;&amp;amp; colors.indexOf(value) == -1&lt;span&gt;) {
      colors.push(value);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已选中并且数组中未有该值，就在末尾插入&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {    
      colors &lt;/span&gt;= colors.filter(item =&amp;gt; item != value);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未选中，就将该值过滤掉&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ colors });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&amp;gt;
        &amp;lt;input name=&quot;colors&quot; value=&quot;1&quot; onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;checkbox&quot;&lt;span&gt;
          checked&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;.state.colors.indexOf(&quot;1&quot;) &amp;gt;= 0&lt;span&gt;}
        &lt;/span&gt;/&amp;gt;红
        &amp;lt;input name=&quot;colors&quot; value=&quot;2&quot; onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;checkbox&quot;&lt;span&gt;
          checked&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;.state.colors.indexOf(&quot;2&quot;) &amp;gt;= 0&lt;span&gt;}
        &lt;/span&gt;/&amp;gt;绿
        &amp;lt;input name=&quot;colors&quot; value=&quot;3&quot; onChange={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;checkbox&quot;&lt;span&gt;
          checked&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;.state.colors.indexOf(&quot;3&quot;) &amp;gt;= 0&lt;span&gt;}
        &lt;/span&gt;/&amp;gt;蓝
      &amp;lt;/&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然React处理单选框和复选框的方式要比在HTML中复杂一点，但是保证了组件的state是元素状态的唯一来源，进而让更新过程更加可靠和可控。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）选择框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在HTML中，&amp;lt;select&amp;gt;元素（选择框）会包含多个用来表示选项的&amp;lt;option&amp;gt;元素，而选中的项会被定义一个selected属性，如下代码所示，第二个&amp;lt;option&amp;gt;元素处于选中状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; selected&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;freedom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jane&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在React中，只需对&amp;lt;select&amp;gt;元素定义value属性就能决定当前的选中项，如下代码所示，这比用DOM的方式操作选项要简洁得多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Select extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = { value: &quot;&quot;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle(e) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ value: e.target.value });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;select value={&lt;span&gt;this&lt;/span&gt;.state.value} onChange={&lt;span&gt;this&lt;/span&gt;.handle}&amp;gt;
        &amp;lt;option value=&quot;1&quot;&amp;gt;strick&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;2&quot;&amp;gt;freedom&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;3&quot;&amp;gt;jane&amp;lt;/option&amp;gt;
      &amp;lt;/select&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只要给&amp;lt;select&amp;gt;元素添加multiple属性并将其赋为true就能变为多选，如下代码所示，此时传给value属性的是一个数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class MulSelect extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; { values: [] };
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle(e) {
    const { options } &lt;/span&gt;= e.target;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;options是一个类数组对象&lt;/span&gt;
    const values = Object.keys(options)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将options的索引组成一个数组&lt;/span&gt;
      .filter(i =&amp;gt; options[i].selected)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤出选中项&lt;/span&gt;
      .map(i =&amp;gt; options[i].value);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提取选中项组成新数组&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ values });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;select value={&lt;span&gt;this&lt;/span&gt;.state.values} onChange={&lt;span&gt;this&lt;/span&gt;.handle} multiple={&lt;span&gt;true&lt;/span&gt;}&amp;gt;
        &amp;lt;option value=&quot;1&quot;&amp;gt;strick&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;2&quot;&amp;gt;freedom&amp;lt;/option&amp;gt;
        &amp;lt;option value=&quot;3&quot;&amp;gt;jane&amp;lt;/option&amp;gt;
      &amp;lt;/select&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　非受控组件（Uncontrolled Component）的定义正好与受控组件的相左，其状态由自己管理，通常使用ref属性（&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/10593862.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;第5篇&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中讲解过）获取表单元素的值。在下面的示例中，文本框在失去焦点时，能自动将其内容转换成大写字母。如果用受控组件的形式完成相同的功能，那么会较为繁琐。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Text extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handle = &lt;span&gt;this&lt;/span&gt;.handle.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handle() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.input.value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.input.value.toUpperCase();
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input onBlur={&lt;span&gt;this&lt;/span&gt;.handle} type=&quot;text&quot; ref={ input =&amp;gt; {&lt;span&gt;this&lt;/span&gt;.input = input}}/&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在render()方法中，首先为文本框注册onBlur事件，然后定义ref属性，其值是一个回调函数。当组件被挂载时，就会执行该回调函数，然后就能让this.input指向一个文本框，从而在事件处理程序handle()中就能通过this.input读取到文本框中的内容。&lt;/p&gt;
&lt;p&gt;　　在React中，有一个表单元素比较特殊，那就是上传按钮。它只有非受控组件的形式，因为其值只能由用户传入，不能被组件的state所控制。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）默认值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果要指定非受控组件的默认值，那么可通过定义defaultValue或defaultChecked属性实现，前者适用于文本框、选择框等元素，后者适用于单选框和复选框。下面的示例分别给文本框和单选框设置了默认值，为了便于观察，只放出了关键代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Text extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input type=&quot;text&quot; defaultValue=&quot;init&quot;/&amp;gt;;
&lt;span&gt;  }
}
class Radio extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&amp;gt;
        &amp;lt;input name=&quot;gender&quot; value=&quot;1&quot; type=&quot;radio&quot;/&amp;gt;男
        &amp;lt;input name=&quot;gender&quot; value=&quot;2&quot; type=&quot;radio&quot; defaultChecked={&lt;span&gt;true&lt;/span&gt;}/&amp;gt;女
      &amp;lt;/&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 14 Jul 2019 22:10:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>表单元素是一类拥有内部状态的元素，这些状态由其自身维护，通过这类元素可让用户与Web应用进行交互。HTML中的表单元素（例如&lt;input&gt;、&lt;select&gt;和&lt;radio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/10634778.html</dc:identifier>
</item>
<item>
<title>PCB 板边倒圆角的实现方法（基本算法一） - pcbren</title>
<link>http://www.cnblogs.com/pcbren/p/11141062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pcbren/p/11141062.html</guid>
<description>&lt;p&gt;&lt;span&gt;当PCB外形是直角时,通常工程制作外形(锣带）时,会将直角或尖角的地方倒成圆角，主要是为了防止&lt;/span&gt;&lt;span&gt;板边容易划伤板且容易扎伤人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以当客户没有特殊要求时,PCB外形是直角一般会默认倒角0.5mm圆角(如下图所示)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190715004130178-1242427190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 一.PCB板边倒圆角点分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt; 原PCB外形&lt;/span&gt;  如下图图示:看了这个PCB外形,产生有2个问题点.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.外形中哪些点需倒圆角?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.如何怎么倒圆角?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714222119344-723038408.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.外形中哪些点需倒圆角?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看下图: PCB外形倒圆角的点,刚好就是我们凸包需求出的点,接下来我们将玩转凸包了,只要求出凸包，那么就可以实现PCB板边倒圆角啦。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714222411330-641620008.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt; 求凸包的算法：&lt;/span&gt;我们可以借鉴算法导论中的查找凸包的算法（加以改进得到新的求凸包方法，详见【方法一】与【方法二】）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714223800207-685339313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.如何怎么倒圆角?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  在下面有说明倒角方法.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 二. 求凸点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;方法一&lt;strong&gt;求凸点&lt;/strong&gt;&lt;/span&gt;:&lt;/span&gt;&lt;strong&gt;【采用多轮遍历,一遍一遍将凹点踢除，剩于的即是凸点】&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714231300926-390544696.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;方法一&lt;/strong&gt;求凸点&lt;/span&gt;:  代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求最大多边形最大凸包1  【采用多轮遍历将凹点踢除，剩于的即是凸点】
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt; s_convex_polyon1(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            add addCOM &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; add();
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isOK = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            List&lt;/span&gt;&amp;lt;gSur_Point&amp;gt; PointList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isCCW =&lt;span&gt; s_isCCW(gSur_Point_list);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; gSur_Point_list.Count();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexPre = (i - &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (IndexPre == -&lt;span&gt;1&lt;/span&gt;) IndexPre = sum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexCurrent = i %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexNext = (i + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[IndexPre].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[IndexCurrent].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; multiVal =&lt;span&gt; multi(gSur_Point_list[IndexPre].p, gSur_Point_list[IndexCurrent].p, gSur_Point_list[IndexNext].p);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;) || (!isCCW &amp;amp;&amp;amp; multiVal &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
                    PointList.Add(gSur_Point_list[IndexCurrent]);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    isOK &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            List&lt;/span&gt;&amp;lt;gSur_Point&amp;gt; Point2List = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt;&lt;span&gt;(PointList);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;isOK)
            {
                isOK &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                PointList.Clear();
                PointList.AddRange(Point2List);
                Point2List.Clear();
                sum &lt;/span&gt;= PointList.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                n &lt;/span&gt;=&lt;span&gt; PointList.Count();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexPre = (i - &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (IndexPre == -&lt;span&gt;1&lt;/span&gt;) IndexPre = sum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexCurrent = i %&lt;span&gt; sum;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexNext = (i + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; multiVal =&lt;span&gt; multi(PointList[IndexPre].p, PointList[IndexCurrent].p, PointList[IndexNext].p);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;) || (!isCCW &amp;amp;&amp;amp; multiVal &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
                        Point2List.Add(PointList[IndexCurrent]);
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        isOK &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Point2List;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法二求凸包&lt;/span&gt;：&lt;/strong&gt;【采用一边遍历找出凸点并加入队列，并同时将队列中的凸点队列中找出凹点踢除】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714232811205-760237731.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;方法二求凸包&lt;/strong&gt;代码&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求最大多边形最大凸包2  【采用一边遍历找出凸点并加入队列，并同时将队列中的凸点队列中找出凹点踢除】
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt; s_convex_polyon2(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            Stack&lt;/span&gt;&amp;lt;gSur_Point&amp;gt; StackPoint = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;gSur_Point&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isCCW =&lt;span&gt; s_isCCW(gSur_Point_list);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; gSur_Point_list.Count();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexPre = (i - &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (IndexPre == -&lt;span&gt;1&lt;/span&gt;) IndexPre = sum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexCurrent = i %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexNext = (i + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[IndexPre].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[IndexCurrent].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; multiVal =&lt;span&gt; multi(gSur_Point_list[IndexPre].p, gSur_Point_list[IndexCurrent].p, gSur_Point_list[IndexNext].p);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;) || (!isCCW &amp;amp;&amp;amp; multiVal &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
                {
                    L1:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StackPoint.Count &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Top1Point =&lt;span&gt; StackPoint.Pop();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Top2Point =&lt;span&gt; StackPoint.Peek();
                        multiVal &lt;/span&gt;=&lt;span&gt; multi(Top2Point.p, Top1Point.p, gSur_Point_list[IndexCurrent].p);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;) || (!isCCW &amp;amp;&amp;amp; multiVal &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
                            StackPoint.Push(Top1Point);
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                            &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; L1;   
                    }
                    StackPoint.Push(gSur_Point_list[IndexCurrent]);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StackPoint.Reverse().ToList();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;方法三求凸包&lt;/span&gt;:&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;【&lt;/strong&gt;按算法导论Graham扫描法 各节点按方位角+距离 逆时针排序  依次检查,当不属凸点于则弹出】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190714234631811-2123657445.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 方法三求凸包代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求最大多边形最大凸包5  【按算法导论Graham扫描法 各节点按方位角+距离 逆时针排序  依次检查,当不属凸点于则弹出】
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 由于把各点的排列顺序重新排序了，只支持折线节点(当存在弧节点时会出异常 ！！！)
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt; s_convex_polyon3(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; LeftBottomPoint = gSur_Point_list.OrderBy(tt =&amp;gt; tt.p.y).ThenBy(tt =&amp;gt;&lt;span&gt; tt.p.x).FirstOrDefault();
            gSur_Point_list.RemoveAt(gSur_Point_list.Count &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            gSur_Point_list.ForEach(tt &lt;/span&gt;=&amp;gt;&lt;span&gt;
                                        {
                                            tt.Value &lt;/span&gt;=&lt;span&gt; p2p_di(LeftBottomPoint.p, tt.p);
                                            tt.Angle &lt;/span&gt;=&lt;span&gt; p_ang(LeftBottomPoint.p, tt.p);
                                        }
                );
            gSur_Point_list &lt;/span&gt;= gSur_Point_list.OrderBy(tt =&amp;gt; tt.Angle).ThenBy(tt =&amp;gt;&lt;span&gt; tt.Value).ToList();
            gSur_Point_list.Add(gSur_Point_list[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            Stack&lt;/span&gt;&amp;lt;gSur_Point&amp;gt; StackPoint = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;gSur_Point&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isCCW = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; gSur_Point_list.Count();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexPre = (i - &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (IndexPre == -&lt;span&gt;1&lt;/span&gt;) IndexPre = sum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexCurrent = i %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IndexNext = (i + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; sum;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; multiVal =&lt;span&gt; multi(gSur_Point_list[IndexPre].p, gSur_Point_list[IndexCurrent].p, gSur_Point_list[IndexNext].p);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    L1:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StackPoint.Count &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Top1Point =&lt;span&gt; StackPoint.Pop();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Top2Point =&lt;span&gt; StackPoint.Peek();
                        multiVal &lt;/span&gt;=&lt;span&gt; multi(Top2Point.p, Top1Point.p, gSur_Point_list[IndexCurrent].p);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isCCW &amp;amp;&amp;amp; multiVal &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                            StackPoint.Push(Top1Point);
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                            &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; L1;
                    }
                    StackPoint.Push(gSur_Point_list[IndexCurrent]);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StackPoint.Reverse().ToList();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;公共方法与数据结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('77bb5b5e-6976-43f7-8d47-673a5b4782a4')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_77bb5b5e-6976-43f7-8d47-673a5b4782a4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77bb5b5e-6976-43f7-8d47-673a5b4782a4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('77bb5b5e-6976-43f7-8d47-673a5b4782a4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77bb5b5e-6976-43f7-8d47-673a5b4782a4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Surface 坐标泛型集类1
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; gSur_Point
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gSur_Point()
        { }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gSur_Point(&lt;span&gt;double&lt;/span&gt; x_val, &lt;span&gt;double&lt;/span&gt; y_val, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; type_point_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p.x =&lt;span&gt; x_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p.y =&lt;span&gt; y_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type_point =&lt;span&gt; type_point_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gSur_Point(gPoint p, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; type_point_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type_point =&lt;span&gt; type_point_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint p;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 0为折点  1为顺时针 2为逆时针  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; type_point { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 角度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Angle { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标记
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isFalg { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 点  数据类型 (XY)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; gPoint
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint(gPoint p_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; p_.x;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; p_.y;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gPoint(&lt;span&gt;double&lt;/span&gt; x_val, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; y_val)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y_val;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gPoint &lt;span&gt;operator&lt;/span&gt; +&lt;span&gt;(gPoint p1, gPoint p2)
        {
            p1.x &lt;/span&gt;+=&lt;span&gt; p2.x;
            p1.y &lt;/span&gt;+=&lt;span&gt; p2.y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gPoint &lt;span&gt;operator&lt;/span&gt; -&lt;span&gt;(gPoint p1, gPoint p2)
        {
            p1.x &lt;/span&gt;-=&lt;span&gt; p2.x;
            p1.y &lt;/span&gt;-=&lt;span&gt; p2.y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gPoint &lt;span&gt;operator&lt;/span&gt; +(gPoint p1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; val)
        {
            p1.x &lt;/span&gt;+=&lt;span&gt; val;
            p1.y &lt;/span&gt;+=&lt;span&gt; val;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; ==&lt;span&gt;(gPoint p1, gPoint p2)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (p1.x == p2.x &amp;amp;&amp;amp; p1.y ==&lt;span&gt; p2.y);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; !=&lt;span&gt;(gPoint p1, gPoint p2)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !(p1.x == p2.x &amp;amp;&amp;amp; p1.y ==&lt;span&gt; p2.y);
        }
    }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求叉积   判断【点P与线L】位置关系【小于0】在右边   【大于0】在左边   【等于0】共线
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;【小于0】在右边   【大于0】在左边   【等于0】共线&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; multi(gPoint ps, gPoint pe, gPoint p)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((ps.x - p.x) * (pe.y - p.y) - (pe.x - p.x) * (ps.y -&lt;span&gt; p.y));
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 检测 Surface是否逆时针   
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; s_isCCW(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; NextI = i + &lt;span&gt;1&lt;/span&gt; + (gSur_Point_list[i + &lt;span&gt;1&lt;/span&gt;].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                d &lt;/span&gt;+= -&lt;span&gt;0.5&lt;/span&gt; * (gSur_Point_list[NextI].p.y + gSur_Point_list[i].p.y) * (gSur_Point_list[NextI].p.x -&lt;span&gt; gSur_Point_list[i].p.x);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回两点之间欧氏距离
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p1&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p2&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; p2p_di(gPoint p1, gPoint p2)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.Sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y -&lt;span&gt; p2.y));
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求方位角
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; p_ang(gPoint ps, gPoint pe)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a_ang = Math.Atan((pe.y - ps.y) / (pe.x - ps.x)) / Math.PI * &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;象限角  转方位角   计算所属象限   并求得方位角&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pe.x &amp;gt;= ps.x &amp;amp;&amp;amp; pe.y &amp;gt;= ps.y)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;↗    第一象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a_ang;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!(pe.x &amp;gt;= ps.x) &amp;amp;&amp;amp; pe.y &amp;gt;= ps.y)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ↖   第二象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!(pe.x &amp;gt;= ps.x) &amp;amp;&amp;amp; !(pe.y &amp;gt;= ps.y))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;↙   第三象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pe.x &amp;gt;= ps.x &amp;amp;&amp;amp; !(pe.y &amp;gt;= ps.y))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ↘   第四象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a_ang;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 三.板边凸点倒圆角方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;方法一&lt;/span&gt;.也最简单的倒角方法,我们将PCB板边凸点找出来后，可以直接借助genesis倒角功能就可以实现了&lt;/p&gt;
&lt;p&gt;                   当然但偶尔会报错的, 且当N个小线段组成的尖角倒角会出错(要实现完美效果只有自己写倒角算法啦)             &lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190715000926473-391652890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   方法二:&lt;span&gt;自己写倒角算法，这个算法和加内角孔算法类似（这里只是介绍简单的倒角)考虑特殊的需要扩展&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         可以参考这篇文章: &lt;a href=&quot;https://www.cnblogs.com/pcbren/p/9665304.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/pcbren/p/9665304.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190715001647354-1718546350.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;535&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 四.凸点加倒圆角实现效果   &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190715000339000-1530602588.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jul 2019 16:56:00 +0000</pubDate>
<dc:creator>pcbren</dc:creator>
<og:description>当PCB外形是直角时,通常工程制作外形(锣带）时,会将直角或尖角的地方倒成圆角，主要是为了防止板边容易划伤板且容易扎伤人 所以当客户没有特殊要求时,PCB外形是直角一般会默认倒角0.5mm圆角(如下图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pcbren/p/11141062.html</dc:identifier>
</item>
<item>
<title>一个最简单的设计模式-模板方法 - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/11186438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/11186438.html</guid>
<description>&lt;p&gt;《Head First设计模式》已经读了不止一遍，但是始终没有进行系统的进行总结。所以近期开始总结设计模式相关的知识，从模板方法模式开始，因为是一个我认为是最简单的设计模式。（推荐视频资源&lt;a href=&quot;https://www.bilibili.com/video/av24176315&quot;&gt;23个设计模式&lt;/a&gt;）&lt;/p&gt;
&lt;h3 id=&quot;提出解决问题&quot;&gt;提出&amp;amp;解决问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;提出问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现制作咖啡功能&lt;/strong&gt;。且制作咖啡需要四个步骤 ：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;烧水&lt;/li&gt;
&lt;li&gt;冲泡咖啡&lt;/li&gt;
&lt;li&gt;倒入杯中&lt;/li&gt;
&lt;li&gt;加糖&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 一杯加糖咖啡
 *
 * @author Jann Lee
 * @date 2019-07-14 18:37
 */
public class Coffee {

    /**
     * 制作一杯加糖咖啡
     */
    public void prepareRecipe() {
        boilWater();
        steepTeaBag();
        portInCup();
        addLemon();
    }

    /**
     * step1: 烧水
     */
    private void boilWater() {
        System.out.println(&quot;烧水...&quot;);
    }

    /**
     * step2：冲泡咖啡
     */
    private void steepTeaBag() {
        System.out.println(&quot;冲泡咖啡...&quot;);
    }

    /**
     * step3: 倒入杯中
     */
    private void portInCup() {
        System.out.println(&quot;倒入杯中...&quot;);
    }

    /**
     * step4: 加糖
     */
    private void addLemon() {
        System.out.println(&quot;加糖...&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;再次提出问题此时此刻我需要一杯柠檬茶呢？【烧水，冲泡茶包，倒入杯中，加柠檬】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题当然很简单，我们只需要如法炮制即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Tea {

    /**
     * 制作一杯柠檬茶
     */
    public void prepareRecipe(){
        boilWater();
        brewCoffeeGrinds();
        portInCup();
        addSugarAndMilk();
    }

    /**
     * step1: 烧水
     */
    private void boilWater() {
        System.out.println(&quot;烧水...&quot;);
    }

    /**
     * step2：冲泡咖啡
     */
    private void brewCoffeeGrinds() {
        System.out.println(&quot;冲泡茶包...&quot;);
    }

    /**
     * step3: 倒入杯中
     */
    private void portInCup() {
        System.out.println(&quot;倒入杯中...&quot;);
    }

    /**
     * step4: 加柠檬
     */
    private void addSugarAndMilk() {
        System.out.println(&quot;加入柠檬片...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;思考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 如果此时我们又需要一杯不加柠檬的茶，加奶的咖啡...，当然我们可以按照上面方式重新依次实现即可。但是如果你是一个有经验的程序员，或者你学习过设计模式。你可能会发现以上功能实现的&lt;strong&gt;步骤/流程固定&lt;/strong&gt;，当需求发生变化时，只有小部分步骤有所&lt;strong&gt;改变&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;优化代码&quot;&gt;优化代码&lt;/h3&gt;
&lt;p&gt;根据面向对象程序的特点，既抽象，封装，继承，多态。我们可以对代码进行抽象，将公共代码提取到基类。我们将咖啡和茶抽象成咖啡因饮料，将其中相同的两步，烧水和倒入杯中再父类中实现，将冲泡和添加调料延迟到子类。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义一个基类&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class CafeineBeverage {
    /**
     * 制作一杯咖啡因饮料
     */
    public void prepareRecipe() {
        boilWater();
        brew();
        portInCup();
        addCondiments();
    }

    /**
     * step1: 烧水
     */
    private void boilWater() {
        System.out.println(&quot;烧水...&quot;);
    }

    /**
     * step2：冲泡
     */
    protected abstract void brew();

    /**
     * step3: 入杯中
     */
    private void portInCup() {
        System.out.println(&quot;倒入杯中...&quot;);
    }

    /**
     * step4: 加调料
     */
    protected abstract void addCondiments();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 一杯加糖咖啡
public class CoffeeBeverage extends CafeineBeverage{

    @Override
    protected void brew() {
        System.out.println(&quot;冲泡咖啡...&quot;);
    }

    @Override
    protected void addCondiments() {
        System.out.println(&quot;加糖...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 一杯柠檬茶
public class TeaBeverage extends CafeineBeverage {
    @Override
    protected void brew() {
        System.out.println(&quot;冲泡茶包...&quot;);
    }

    @Override
    protected void addCondiments() {
        System.out.println(&quot;加柠檬...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模板方法模式&quot;&gt;模板方法模式&lt;/h2&gt;
&lt;p&gt;如果按以上方式对代码进行了优化，其实就实现了&lt;strong&gt;模板方法&lt;/strong&gt;模式。一下是模板方法模式相关概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;动机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在软件构建过程中，对于某一项任务，它常常有&lt;strong&gt;稳定&lt;/strong&gt;的整体操作结构，但是各个子步骤却有很多&lt;strong&gt;改变&lt;/strong&gt;的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现&lt;/li&gt;
&lt;li&gt;如何在确定&lt;strong&gt;稳定&lt;/strong&gt;的操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义一个操作中算法的骨架（稳定），而将一些步骤延迟（变化）到子类。Template Method使得子类可以不改变（复用）一个算法的结构，即可重新定义（override）该算法的特定步骤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要点总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Template Method是一种非常基础性的设计模式，在面向对象系统中，有着大量的应用。他用最简洁的机制(抽象类的多态，为很多应用框架提供了灵活的扩展点，是代码复用方面最基本实现结构)&lt;/li&gt;
&lt;li&gt;除了可以灵活应对子步骤的变化外，“&lt;strong&gt;不要调用我，让我来调用你&lt;/strong&gt;”的反向控制结构是Template Method的典型应用&lt;/li&gt;
&lt;li&gt;在具体实现方面，被Template Method调用得虚方法可以有实现，也可以没有实现(抽象方法)，但一般推荐设置为protected方法&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;类图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201907/1055780-20190714232628161-1397587844.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mycookies.cn&quot;&gt;个人博客网站（正在建设中）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jul 2019 15:29:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>一个最简单的设计模式【适合初级选手】</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/11186438.html</dc:identifier>
</item>
<item>
<title>最近学习了HBase - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/11134806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/11134806.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase是什么&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近学习了HBase，正常来说写这篇文章，应该从DB有什么缺点，HBase如何弥补DB的缺点开始讲会更有体感，但是本文这些暂时不讲，只讲HBase，把HBase相关原理和使用讲清楚，后面有一篇文章会专门讲DB与NoSql各自的优缺点以及使用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HBase是谷歌Bigtable的开源版本，2006年谷歌发布《Bigtable：A Distributed Storage System For Structured Data》论文之后，Powerset公司就宣布HBase在Hadoop项目中成立，作为子项目存在。后来，在2010年左右逐渐成为Apache旗下的一个顶级项目，因此HBase名称的由来就是由于其作为Hadoop Database存在的，用于存储非结构化、半结构化的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图展示了HBase在Hadoop生态中的位置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190705215531258-839307325.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;267&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到HBase建立在HDFS上，HBase内部管理的文件全部都是存储在HDFS中，同时MapReduce这个计算框架在HBase之上又提供了高性能的计算能力来处理海量数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的特点与不足&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HBase的基本特点概括大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;海量数据存储（PB）级别，在PB级别数据以及采用廉价PC存储的情况下，数据能在几十到百毫秒内返回数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高可用，WAL + Replication机制保证集群异常不会导致写入数据丢失与数据损坏，且HBase底层使用HDFS，HDFS本身也有备份&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据写入性能强劲&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;列式存储，和传统数据库行式存储有本质的区别，这个在之后HBase存储原理的时候详细解读&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;半结构化或非结构化数据存储&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;存储稀松灵活，列数据为空的情况下不占据存储空间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同一份数据，可存储多版本号数据，方便历史数据回溯&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;行级别事务，可以保证行级别数据的ACID特性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;扩容方便，无需数据迁移，及扩即用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当然事事不是完美的，HBase也存在着以下两个最大的不足：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无法做到条件查询，这是最大的问题，假如你的代码中存在多个查询条件，且每次使用哪个/哪组查询条件不确定，那么使用HBase是不合适的，除非数据冗余，设计多份RowKey&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;做不了分页，数据总记录数几乎无法统计，因为HBase本身提供的表行数统计功能是一个MapReduce任务，极为耗时，既然拿不到总记录数，分页总署也没法确定，自然分页也无法做了&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总的来说，对于HBase需要了解以上的一些个性应该大致上就可以了，根据HBase的特点与不足，在合适的场景下选择使用HBase，接下来针对HBase的一些知识点逐一解读。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;HBase的基本架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图是HBase的基本架构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190706205004866-531336229.png&quot; alt=&quot;&quot; width=&quot;649&quot; height=&quot;338&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从图上可以看到，HBase中包含的一些组件如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Client----包含访问HBase的接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Zookeeper----通过选举保证任何时候集群中只有一个HMaster、HMaster与Region Server启动时向注册、存储所有Region的寻址入口、实时监控Region Server的上下线信息并实时通知给HMaster、存储HBase的Schema与Table原数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HMaster----为Region Server分配Region、负责Region Server的负载均衡、发现失效的Region Server并重新分配其上的Region、管理用户对Table的增删改查&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Region Server----维护Region并处理对Region的IO请求、切分在运行过程中变得过大的Region&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其中，Region是分布式存储和负载均衡中的最小单元，不过并不是存储的最小单元。Region由一个或者多个Store组成，每个Store保存一个列簇；每个Store又由一个memStore和0~N个StoreFile组成，StoreFile包含HFile，StoreFile只是对HFile做了轻量级封装，底层就是HFile。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;介于上图元素有点多，我这边画了一张图，把HBase架构中涉及的元素的关系理了一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190714113841966-322203727.png&quot; alt=&quot;&quot; width=&quot;889&quot; height=&quot;186&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看一下HBase的一些基本概念，HBase是以Table（表）组织数据的，一个Table中有着以下的一些元素：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;RowKey（行键）----即关系型数据库中的主键，它是唯一的，在HBase中这个主键可以是任意的字符串，最大长度为64K，在内部存储中会被存储为字节数组，&lt;span&gt;&lt;strong&gt;HBase表中的数据是按照RowKey的字典序排列的&lt;/strong&gt;&lt;/span&gt;。例如1、2、3、4、5、10，按照自然数的顺序是这样的，但是在HBase中1后面跟的是10而不是2，因此在设计RowKey的时候一定要充分利用字典序这个特性，将一下经常读取的行存储到一起或者靠近，减少Scan耗时，提高读取的效率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Column Family（列族）----表Schema的一部分，HBase表中的每个列都归属于某个列族，即列族是由一系列的列组成的，&lt;span&gt;&lt;strong&gt;必须在创建表的时候就指定好&lt;/strong&gt;&lt;/span&gt;。列明都以列族作为前缀，例如courses:history、courses:math都属于courses这个列族。列族不是越多越好，过多的列族会导致io增多及分裂时数据不均匀，&lt;span&gt;&lt;strong&gt;官方推荐列族数量为1~3个&lt;/strong&gt;&lt;/span&gt;。列族不仅能帮助开发者构建数据的语义边界，还能有助于开发者设置某些特性，例如可以指定某个列族内的数据压缩形式。访问控制、磁盘和内存怒的使用统计都是在列族层面进行的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Column（列）----一般从属于某个列族，列的数量一般没有强限制，一个列族中可以有数百万列且这些列都可以动态添加&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Version Number（版本号）----HBase中每一列的值或者说每个单元格的值都是具有版本号的，默认使用系统当前时间，精确到毫秒，也可以用户显式地设置。每个单元格中，&lt;span&gt;&lt;strong&gt;不同版本的数据按照时间倒序排序，即最新的数据排在最前面&lt;/strong&gt;&lt;/span&gt;。另外，为了避免数据存在过多版本造成的管理（存储 + 索引）负担，HBase提供了两种数据版本回收的方式，一是保存数据的最后n个版本，二是保存最近一段时间内的版本，用户可以针对每个列族进行设置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cell（单元格）----一个单元格就是由RowKey、Column Family:Column、Version Number唯一确定的，Cell中的数据是没有类型的，全部都是字节码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;另外一个概念就是，访问HBase Table中的行，只有三种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过单个Row Key访问&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过Row Key的range&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全表扫描&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这部分介绍的Table、RowKey、Column Family、Column等都属于逻辑概念，而上部分中的Region Server、Region、Store等都属于物理概念，下图展示了逻辑概念与物理概念之间的关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190714113904001-1865249117.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;289&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即：&lt;span&gt;&lt;strong&gt;table和region是一对多的关系，因为table的数据可能被打在多个region中；region和columnFamily是一对多的关系，一个store对应一个columnFamily，一个region可能对应多个store&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的逻辑表视图与物理表视图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看一下HBase中的表逻辑视图与物理视图。首先是逻辑表视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190707205937815-1832025692.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到这里定义了2个列族，一个Personal Info、一个Family Info，对应到数据库中，相当于把两张表合并到一个一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从逻辑视图看，上图由ZhangSan、LiSi两行组成，但是在实际物理存储上却不是按照这种方式进行的存储：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190707210923282-671048891.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;264&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190707211052697-1525771613.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到主要是有两点差别：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一行被拆开了，按照列族进行存储&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;空列不会被存储，例如LiSi在Peronal Info中没有Provice与Phone，在Family Info中没有Brother&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的增删改查&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;光说不练假把式，不能光讲理论，代码也是要有的，为了方便起见，我用的是阿里云HBase，和HBase一样，只是省去了运维成本。当然虽然本人是内部员工，但是工作之外的学习是不会占用公司资源的^_^悄悄告诉大家，阿里云HBase有个福利，第一个月免费试用，想同样玩一下HBase的可以去阿里云搞一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先添加一下pom依赖，用阿里云指定的HBase，使用上和原生的HBase API一模一样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.aliyun.hbase&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;alihbase-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdk.tools&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdk.tools&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;systemPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}/lib/tools.jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;systemPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意一下第二个dependency，jdk.tools不添加pom文件可能会报错&quot;Missing artifact jdk.tools:jdk.tools:jar:1.8&quot;，错误原因是tools.jar包是JDK自带的，pom.xml中的包隐式依赖tools.jar包，而tools.jar并未在库中，因此需要将tools.jar包添加到jdk库中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先写个HBaseUtil，用单例模式来写，好久没写了，顺便练习一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 五月的仓颉https://www.cnblogs.com/xrq730/p/11134806.html
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HBaseUtil {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HBaseUtil hBaseUtil;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Configuration config = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Connection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Table&amp;gt; tableMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Table&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HBaseUtil() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HBaseUtil getInstance() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (hBaseUtil == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt; (HBaseUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (hBaseUtil == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     hBaseUtil = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HBaseUtil();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hBaseUtil;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * 初始化Configuration与Connection
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(String zkAddress) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         config =&lt;span&gt; HBaseConfiguration.create();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        config.set(HConstants.ZOOKEEPER_QUORUM, zkAddress);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             connection =&lt;span&gt; ConnectionFactory.createConnection(config);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             System.exit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;     * 创建table
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; createTable(String tableName, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[]... columnFamilies) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HBase创建表的时候必须创建指定列族&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (columnFamilies == &lt;span&gt;null&lt;/span&gt; || columnFamilies.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         
&lt;span&gt;54&lt;/span&gt;         TableDescriptorBuilder tableDescriptorBuilder =&lt;span&gt; TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] columnFamily : columnFamilies) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            tableDescriptorBuilder.setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(columnFamily).build());
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             Admin admin =&lt;span&gt; connection.getAdmin();
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            admin.createTable(tableDescriptorBuilder.build());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个Table连接存入内存中&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            tableMap.put(tableName, connection.getTable(TableName.valueOf(tableName)));
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             System.exit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Table getTable(String tableName) {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         Table table =&lt;span&gt; tableMap.get(tableName);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (table != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         
&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             table =&lt;span&gt; connection.getTable(TableName.valueOf(tableName));
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (table != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; table对象存入内存&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;                tableMap.put(tableName, table);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             
&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;     
&lt;span&gt;91&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，HBase中的数据一切皆二进制，因此从上面代码到后面代码，字符串全部都转换成了二进制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着定义一个BaseHBaseUtilTest类，把一些基本的定义放在里面，保持主测试类清晰：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 五月的仓颉https://www.cnblogs.com/xrq730/p/11134806.html
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseHBaseUtilTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TABLE_NAME = &quot;student&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_FAMILY_PERSONAL_INFO = &quot;personalInfo&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_FAMILY_FAMILY_INFO = &quot;familyInfo&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_NAME = &quot;name&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_AGE = &quot;age&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_PHONE = &quot;phone&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_FATHER = &quot;father&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] COLUMN_MOTHER = &quot;mother&quot;&lt;span&gt;.getBytes();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; HBaseUtil hBaseUtil;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一件事情，创建Table，注意前面说的，HBase必须Table和列族一起创建：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 五月的仓颉https://www.cnblogs.com/xrq730/p/11134806.html
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HBaseUtilTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseHBaseUtilTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         hBaseUtil =&lt;span&gt; HBaseUtil.getInstance();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         hBaseUtil.init(&quot;xxx&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 创建表
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCreateTable() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        hBaseUtil.createTable(TABLE_NAME, COLUMN_FAMILY_PERSONAL_INFO, COLUMN_FAMILY_FAMILY_INFO);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我自己申请的HBase，zk地址就不给大家看啦，如果同样申请了的，替换一下就好了。testCreateTable方法运行一下，就创建好了student表。接着利用put创建四条数据，多创建几条，等下scan可以测试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 添加数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testPut() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Table table =&lt;span&gt; hBaseUtil.getTable(TABLE_NAME);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户1，用户id：12345&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     Put put1 = &lt;span&gt;new&lt;/span&gt; Put(&quot;12345&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     put1.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_NAME, &quot;Lucy&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     put1.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE, &quot;18&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     put1.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_PHONE, &quot;13511112222&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     put1.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_FATHER, &quot;LucyFather&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     put1.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_MOTHER, &quot;LucyMother&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户2，用户id：12346&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     Put put2 = &lt;span&gt;new&lt;/span&gt; Put(&quot;12346&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_NAME, &quot;Lily&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE, &quot;19&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_PHONE, &quot;13522223333&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_FATHER, &quot;LilyFather&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_MOTHER, &quot;LilyMother&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户3，用户id：12347&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     Put put3 = &lt;span&gt;new&lt;/span&gt; Put(&quot;12347&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     put3.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_NAME, &quot;James&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     put3.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE, &quot;22&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     put3.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_FATHER, &quot;JamesFather&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     put3.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_MOTHER, &quot;JamesMother&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户4，用户id：12447&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     Put put4 = &lt;span&gt;new&lt;/span&gt; Put(&quot;12447&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     put4.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_NAME, &quot;Micheal&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     put4.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE, &quot;22&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     put2.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_PHONE, &quot;13533334444&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     put4.addColumn(COLUMN_FAMILY_FAMILY_INFO, COLUMN_MOTHER, &quot;MichealMother&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    table.put(Lists.newArrayList(put1, put2, put3, put4));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样的，运行一下testPut方法，四条数据就创建完毕了。注意为了提升处理效率，HBase的get、put这些API都提供的批量处理方式，这样一次提交可以提交多条数据，发起一次请求即可，不用发起请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看一下利用Get API查询数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 获取数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testGet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Table table =&lt;span&gt; hBaseUtil.getTable(TABLE_NAME);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get1，拿到全部数据&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     Get get1 = &lt;span&gt;new&lt;/span&gt; Get(&quot;12345&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get2，只拿personalInfo数据&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Get get2 = &lt;span&gt;new&lt;/span&gt; Get(&quot;12346&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    get2.addFamily(COLUMN_FAMILY_PERSONAL_INFO);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;     Result[] results =&lt;span&gt; table.get(Lists.newArrayList(get1, get2));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (results == &lt;span&gt;null&lt;/span&gt; || results.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Result result : results) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        printResult(result);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printResult(Result result) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     System.out.println(&quot;====================分隔符====================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    printBytes(result.getValue(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_NAME));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    printBytes(result.getValue(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    printBytes(result.getValue(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_PHONE));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    printBytes(result.getValue(COLUMN_FAMILY_FAMILY_INFO, COLUMN_FATHER));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    printBytes(result.getValue(COLUMN_FAMILY_FAMILY_INFO, COLUMN_MOTHER));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printBytes(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bytes != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; bytes.length != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(bytes));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;HBase查询数据比较灵活的是，可以查询RowKey下对应的所有数据、可以按照RowKey-Column Family的维度查询数据、可以按照RowKey-Column Family-Column的维度查询数据，也可以按照RowKey-Column Family-Column-Timestamp的维度查询数据，可以查询Timestamp区间内的数据，也可以查询RowKey-Column Family-Column下所有Timestamp数据。上面的代码执行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
====================分隔符====================&lt;span&gt;
Lucy
&lt;/span&gt;18
13511112222&lt;span&gt;
LucyFather
LucyMother
&lt;/span&gt;====================分隔符====================&lt;span&gt;
Lily
&lt;/span&gt;19
13533334444
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;和我们的预期相符，即&quot;12345&quot;这个RowKey查询出了所有数据，&quot;12346&quot;这个RowKey只查了personalInfo这个列族的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后这一部分我们看一下更新，更新的API和新增的API都是一样的，都是Put：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testUpdate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    Table table &lt;/span&gt;=&lt;span&gt; hBaseUtil.getTable(TABLE_NAME);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户1，用户id：12345&lt;/span&gt;
    Put put = &lt;span&gt;new&lt;/span&gt; Put(&quot;12346&quot;&lt;span&gt;.getBytes());
    put.addColumn(COLUMN_FAMILY_PERSONAL_INFO, COLUMN_AGE, &lt;/span&gt;1, &quot;22&quot;&lt;span&gt;.getBytes());
    table.put(put);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Get看一下执行12346这条数据的值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Lily
&lt;/span&gt;19
13533334444&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到12346对应的数据，原本Age是19，更新到22，依然是19，这就是一个值得注意的点了。&lt;span&gt;&lt;strong&gt;HBase的更新其实是往Table里面新增一条记录，按照Timestamp进行排序，最新的数据在前面，每次Get的时候将第一条数据取出来&lt;/strong&gt;&lt;/span&gt;。在这里我们指定的Timestamp=1，这个值落后于先前插入的Timestamp，自然就排在后面，因此读取出来的Age依然是原值19，这个细节特别注意一下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的Scan&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感觉前面篇幅有点大，所以这里专门抽一个篇幅出来写一下Scan，Scan是HBase扫描数据的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先可以看一下最基本的Scan：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 扫描
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testScan() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Table table =&lt;span&gt; hBaseUtil.getTable(TABLE_NAME);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     Scan scan = &lt;span&gt;new&lt;/span&gt; Scan().withStartRow(&quot;12345&quot;.getBytes(), &lt;span&gt;true&lt;/span&gt;).withStopRow(&quot;12347&quot;.getBytes(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;     ResultScanner rs =&lt;span&gt; table.getScanner(scan);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Result result : rs) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            printResult(result);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
====================分隔符====================&lt;span&gt;
Lucy
&lt;/span&gt;19
13511112222&lt;span&gt;
LucyFather
LucyMother
&lt;/span&gt;====================分隔符====================&lt;span&gt;
Lily
&lt;/span&gt;19
13533334444&lt;span&gt;
LilyFather
LilyMother
&lt;/span&gt;====================分隔符====================&lt;span&gt;
James
&lt;/span&gt;22&lt;span&gt;
JamesFather
JamesMother&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表示查询12345~12347这个范围内的所有RowKey，withStartRow的第二个参数true表示包含，如果为false那么12345这个RowKey就查不出来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进阶的，HBase为我们提供了带过滤器的Scan，一共有十来种，我这边只演示两种以及组合的情况，其他的查询一下HBase API文档即可，2.1版本的API文档地址为&lt;a href=&quot;http://hbase.apache.org/2.1/apidocs/index.html&quot;&gt;http://hbase.apache.org/2.1/apidocs/index.html&lt;/a&gt;。演示代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testScanFilter() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Table table =&lt;span&gt; hBaseUtil.getTable(TABLE_NAME);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;     System.out.println(&quot;********************RowFilter测试********************&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Scan scan0 = &lt;span&gt;new&lt;/span&gt; Scan().withStartRow(&quot;12345&quot;.getBytes(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     scan0.setFilter(&lt;span&gt;new&lt;/span&gt; RowFilter(CompareOperator.EQUAL, &lt;span&gt;new&lt;/span&gt; BinaryComparator(&quot;12346&quot;&lt;span&gt;.getBytes())));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ResultScanner rs0 =&lt;span&gt; table.getScanner(scan0);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    printResultScanner(rs0);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;     System.out.println(&quot;********************PrefixFilter测试********************&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Scan scan1 = &lt;span&gt;new&lt;/span&gt; Scan().withStartRow(&quot;12345&quot;.getBytes(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     scan1.setFilter(&lt;span&gt;new&lt;/span&gt; PrefixFilter(&quot;124&quot;&lt;span&gt;.getBytes()));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     ResultScanner rs1 =&lt;span&gt; table.getScanner(scan1);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    printResultScanner(rs1);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;     System.out.println(&quot;********************两种Filter同时满足测试********************&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     Scan scan2 = &lt;span&gt;new&lt;/span&gt; Scan().withStartRow(&quot;12345&quot;.getBytes(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     Filter filter0 = &lt;span&gt;new&lt;/span&gt; RowFilter(CompareOperator.EQUAL, &lt;span&gt;new&lt;/span&gt; BinaryComparator(&quot;12447&quot;&lt;span&gt;.getBytes()));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     Filter filter1 = &lt;span&gt;new&lt;/span&gt; PrefixFilter(&quot;124&quot;&lt;span&gt;.getBytes());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     FilterList filterList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterList(FilterList.Operator.MUST_PASS_ALL, filter0, filter1);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    scan2.setFilter(filterList);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     ResultScanner rs2 =&lt;span&gt; table.getScanner(scan2);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    printResultScanner(rs2);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
********************RowFilter测试********************
====================分隔符====================&lt;span&gt;
Lily
&lt;/span&gt;19
13533334444&lt;span&gt;
LilyFather
LilyMother
&lt;/span&gt;********************PrefixFilter测试********************
====================分隔符====================&lt;span&gt;
Micheal
&lt;/span&gt;22&lt;span&gt;
MichealMother
&lt;/span&gt;********************两种Filter同时满足测试********************
====================分隔符====================&lt;span&gt;
Micheal
&lt;/span&gt;22&lt;span&gt;
MichealMother&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;总的来说，HBase本质上是KV型NoSql，根据Key查询Value是最高效的，Scan这个API还是慎用，范围里面的数据量小倒无所谓，一旦RowKey设计不合理，StartRow和EndRow没有指定好，可能会造成大范围的扫描，降低HBase整体能力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase和KV型缓存的区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看了上面的代码演示，不知道大家有没有和我一开始有一样的疑问：HBase看上去也是K-V形式的，那么它和支持KV型数据的缓存（例如Redis、MemCache、Tair）有什么区别？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我用一张表格总结一下二者的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190714001500783-1329018107.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;195&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，同样作为数据库的NoSql替代方案，HBase更加适合用于海量数据的持久化场景，KV型缓存更加适合用于对数据的高性能读写上。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase的Region分裂及会导致的热点问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经典问题，首先看一下什么是Region分裂，只把Region分裂讲清楚，不讲具体Region分裂的实现方式，理由也很简单，Region分裂细节学得再清楚，对工作中的帮助也不大，没必要太过于追根究底。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Region分裂是HBase能够拥有良好扩张性的最重要因素之一，也必然是所有分布式系统追求无限扩展性的一副良药。通过前面的部分我们知道&lt;span&gt;&lt;strong&gt;HBase的数据以行为单位存储在HBase表中&lt;/strong&gt;&lt;/span&gt;，HBase表按照多行被分割为多个Region，这个Region分布在HBase集群中，并且由Region Server进程负责讲这些Region提供给Client访问。一个Region中，RowKey是一个连续的范围，也就是说表中的记录在Region中是按照startKey到endKey的范围为RowKey进行排序存储的。通常一个表由多个Region构成，这些Region分布在多个Region Server上，也就是说，Region是在Region Server中插入和查询数据时负载均衡的物理机制。一张HBase表在刚刚创建的时候默认只有一个Region，所以关于这张表的请求都被路由到同一个Region Server，无论集群中有多少Region Server，而一旦某个Region的大小达到一定值，就会自动分裂为两个Region，这也就是为什么HBase表在刚刚创建的阶段不能充分利用整个集群吞吐量的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在HBase管理界面可以查看每个Region，startKey与endKey的范围，例如（图片来自网络）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190708002412833-654924747.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;246&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里特别注意一个点，&lt;span&gt;&lt;strong&gt;RowKey是按照Key的字符自然顺序进行排序的，因此RowKey=9的Key，会落在最后一个Region Server中而不是第一个Region Server中&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么什么是热点问题应该也很好理解了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801753/201907/801753-20190708003153565-422208453.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;269&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然HBase的单机读写性能强劲，但是当集群中成千上万的请求RowKey都落在aaaaa-ddddd之间，那么这成千上万请求最终落到Region Server1这台服务器上，一旦超出服务器自身承受能力，那么必然导致服务器不可用甚至宕机。因此我们说设计RowKey的时候千万把时间戳或者id自增的方式作为RowKey方案就是这个道理，时间戳或者id自增的方式，虽然最终可以让RowKey落到不同的Region中，但是在当下或者当下往后的一段时间内，RowKey一定是会落到同一个Region中的，数据热点问题将严重影响HBase集群能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决热点问题通常有两个方案，最初级的方案是设置预分区，即在Table创建的时候就先设置几个Region，为每个Region划分不同的startKey与endKey，但这么做有以下两个缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;高度依赖RowKey，必须事先知道插入数据的RowKey的分布&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;即使事先知道插入数据的RowKey分布，但是如果数据分布不均匀或者存在热点行，依然无法均匀分摊负载&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;但是无论如何，设置预分区依然是一种解决热点问题的方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个解决方案是一劳永逸的解决方案也是使用HBase最核心的一个点：&lt;span&gt;&lt;strong&gt;合理设计RowKey&lt;/strong&gt;&lt;/span&gt;。即让RowKey均匀分布在Region中，大致有以下几个方案可供参考：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;倒序。例如手机号码135ABCD、135EFGH、135IJKL这种，前缀没有区分度，非常容易落到相同的Region中，此时做倒序即DCBA531、HGFE531、LKJI531，将有区分度的部分放在前面，就非常容易将数据散落在不同的Region中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;原数据加密。例如做MD5，因为MD5的随机性是非常强的，因此做了MD5后，数据将会非常分散&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;加随机前缀。例如ASCII码中随机选5位作为数据前缀，同样可以达到分散RowKey的效果，但是缺点是必须记住每个原数据对应的前缀&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;无论如何，还是那句话，合理设计RowKey是HBase使用的核心。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;WAL机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后讲一下前面提到的WAL机制，WAL的全称为Write Ahead Log，它是HBase的RegionServer在处理数据插入和删除的过程中用来记录操作内容的一种日志，是用来做&lt;span&gt;&lt;strong&gt;灾难恢复&lt;/strong&gt;&lt;/span&gt;的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实WAL并不是什么新鲜思想，在数据库领域很常见：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;mysql有binlog，记录每一次数据变更&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;redis有aof，在开启aof的情况下，每隔短暂时间，将这段时间产生的操作记录文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其核心都是，&lt;span&gt;&lt;strong&gt;变更数据前先写磁盘日志文件，在系统发生异常的时候，重放日志文件对数据进行恢复&lt;/strong&gt;&lt;/span&gt;，HBase的WAL机制也是一样的思想，数据变更步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先从之前的图上可以看到有HLog，HLog是实现WAL的类，一个RegionServer对应一个HLog，多个Region共享一个HLog，不过从HBase1.0版本开始可以定义多个HLog以提高吞吐量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端的一次数据提交先写HLog，这个是告知客户端数据提交成功的前提&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HLog写入成功后写入MemStore&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当MemStore的值达到一定程度后，flush到hdfs，形成一个一个的StoreFile（HFile）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flush过后，HLog中对应的数据就没用了，删除&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因为有了HLog，即使在MemStore中的数据还没有flush到hdfs的时候系统发生了宕机或者重启，数据都不会出现丢失。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jul 2019 15:29:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<og:description>HBase是什么 最近学习了HBase，正常来说写这篇文章，应该从DB有什么缺点，HBase如何弥补DB的缺点开始讲会更有体感，但是本文这些暂时不讲，只讲HBase，把HBase相关原理和使用讲清楚，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xrq730/p/11134806.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第28期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11186170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11186170.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;FableConf门票开始贩售&quot; &quot;Bolero的HTML模板支持热加载&quot; &quot;Bolero从v0.4到v0.5的升级指南&quot; &quot;完整的SAFE Chat迁移至了Fable 2&quot; &quot;为纯函数式3D图形生成领域专用语言&quot; &quot;使用Roslyn分析器更快捷地写出更好的代码&quot; 视频及幻灯片 &quot;介绍用F </description>
<pubDate>Sun, 14 Jul 2019 15:12:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'FableConf门票开始贩售' 'Bolero的HTML模板支持热加载' 'Bolero从v0.4到v0.5的升级指南' '完整的SAFE Chat迁移至了Fable 2' '为纯函数式3D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11186170.html</dc:identifier>
</item>
</channel>
</rss>