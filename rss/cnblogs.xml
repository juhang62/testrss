<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小书MybatisPlus第8篇-逻辑删除实现及API细节精讲 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13375459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13375459.html</guid>
<description>&lt;p&gt;本文为Mybatis Plus系列文章的第8篇，前7篇访问地址如下：&lt;/p&gt;
&lt;h2 id=&quot;一、物理删除与逻辑删除&quot;&gt;一、物理删除与逻辑删除&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;物理删除：指文件存储所用到的磁存储区域被真正的擦除或清零，这样删除的文件是不可以恢复的，物理删除是计算机处理数据时的一个概念。如果在数据库中直接使用delete、drop删除了表数据，如果没有备份的话，数据就很难恢复了。&lt;/li&gt;
&lt;li&gt;逻辑删除（软删除）：逻辑删除就是对要被删除的数据打上一个删除标记，通常使用一个deleted字段标示行记录是不是被删除，比如该数据有一个字段deleted，当其值为0表示未删除，值为1表示删除。那么逻辑删除就是将0变成1。在逻辑上是数据是被删除的，但数据本身是依然存在的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者的优劣：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;物理删除一定程度上删除了“无用”的数据，降低了表的数据量，对性能肯定是有好处的；但是如果没有备份的话，数据很难恢复。也无法对历史数据进行数据分析。&lt;/li&gt;
&lt;li&gt;逻辑删除恢复的话只要修改ideleted等类似的状态标示字段就可以了，但是表的数据量肯定会比物理删除增加了，并且查询时经常要考虑到deleted字段，对索引都会有影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以一张表的数据是否采用逻辑删除，还要根据数据的重要性、数据量、查询性能以及业务需求等因素综合判断。&lt;/p&gt;
&lt;h2 id=&quot;二、逻辑删除实现&quot;&gt;二、逻辑删除实现&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先为需要逻辑删除的表增加一个deleted字段作为逻辑删除字段，并且设置其默认值为0，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;CREATE TABLE `user` (
        `id` BIGINT(20) NOT NULL COMMENT '主键ID',
        `name` VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',
        `age` INT(11) NULL DEFAULT NULL COMMENT '年龄',
        `email` VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',
        `deleted` TINYINT(4) NOT NULL DEFAULT '0' COMMENT '逻辑删除标记',
        PRIMARY KEY (`id`)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;给数据库表对应的实体类字段上加上@TableLogic注解：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200725081719855-1531666038.png&quot; alt=&quot;mybatisplus-logicdelete&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、api使用方法&quot;&gt;三、API使用方法&lt;/h2&gt;
&lt;h3 id=&quot;31插入一条数据&quot;&gt;3.1.插入一条数据&lt;/h3&gt;
&lt;p&gt;插入数据的时候，不需要为deleted字段赋值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testInsert() {
  User user = new User();
  user.setName(&quot;字母哥&quot;);
  user.setAge(18);

  int row = userMapper.insert(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;deleted采用默认值0（未删除），新插入的数据都是未删除的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200725081720150-401122221.png&quot; alt=&quot;mybatisplus-logicdelete-1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32删除一条记录：&quot;&gt;3.2.删除一条记录：&lt;/h3&gt;
&lt;p&gt;执行如下Mybatis Plus API删除操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;userMapper.deleteById(1286797255805796354L);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200725081720375-1402103508.png&quot; alt=&quot;mybatisplus-logicdelete-2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看数据库可以发现这条数据仍然存在，只不过逻辑删除字段值被设置为1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE user SET deleted=1 WHERE id=? AND deleted=0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33查询一条记录&quot;&gt;3.3.查询一条记录&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当我们使用MP逻辑删除的功能之后，比如执行查询、修改的方法，MP会为我们自动加上未删除的条件。是不会查到被逻辑删除的记录：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;userMapper.selectList(null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会自动添加过滤条件&lt;code&gt;WHERE deleted=0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email,deleted
FROM user 
WHERE deleted=0 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当我们查询数据时，查询结果不希望包含逻辑删除字段，可以加如下的注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@TableLogic
@TableField(select = false)
private Integer deleted;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的SQL如下（注意查询结果不包含deleted字段）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email 
FROM user 
WHERE deleted=0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、全局配置参数&quot;&gt;四、全局配置参数&lt;/h2&gt;
&lt;p&gt;通常在一个比较正规的管理项目中，逻辑删除字段不允许随意命名，所有表的逻辑删除字段使用相同的名称（比如：deleted）。我们可以在application.yml中添加全局配置，这样就不需要在每一个实体类上面都添加 @TableLogic注解了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：当全局配置和&lt;code&gt;@TableLogic&lt;/code&gt;局部配置同时存在，则以实体上注解为准，优先级更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#全局逻辑删除字段值
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，逻辑已删除值为1，逻辑未删除值为0。我们也可以在application.yml中进行修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#逻辑已删除值(默认为 1)
#逻辑未删除值(默认为 0)
mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 1
      logic-not-delete-value: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jul 2020 00:17:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文为Mybatis Plus系列文章的第8篇，前7篇访问地址如下： 小书MybatisPlus第1篇-整合SpringBoot快速开始增删改查 小书MybatisPlus第2篇-条件构造器的应用及总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13375459.html</dc:identifier>
</item>
<item>
<title>博客部署设计和构建 - 吴楠予</title>
<link>http://www.cnblogs.com/Narule/p/13375431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Narule/p/13375431.html</guid>
<description>[unable to retrieve full-text content]将markdown笔记文件转为博客，且能够自动更新博客信息，Convert markdown note files to blogs, and automatically update blog information</description>
<pubDate>Fri, 24 Jul 2020 23:40:00 +0000</pubDate>
<dc:creator>吴楠予</dc:creator>
<dc:identifier>https://www.cnblogs.com/Narule/p/13375431.html</dc:identifier>
</item>
<item>
<title>字符串学习笔记二 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13375406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13375406.html</guid>
<description>&lt;p&gt;&lt;strong&gt;配合上一篇效果更佳---&amp;gt;&lt;a href=&quot;https://www.cnblogs.com/liuchanglc/p/13364158.html&quot;&gt;字符串学习笔记一&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;40-四、字典树&quot;&gt;4.0 四、字典树&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;从百度百科瞟的图&lt;/s&gt;&lt;br/&gt;&lt;img src=&quot;https://bkimg.cdn.bcebos.com/pic/d62a6059252dd42a745cc2c2033b5bb5c9eab806?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;字典树一般用一个二维数组定义，&lt;span class=&quot;math inline&quot;&gt;\(tr[now][t]\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(now\)&lt;/span&gt;节点的字符为&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;的儿子的编号&lt;br/&gt;同时我们还要开一个数组&lt;span class=&quot;math inline&quot;&gt;\(cnt[now][t]\)&lt;/span&gt;表示该节点的个数&lt;br/&gt;在某些情况下，我们还要记录有几个字符串在该节点终结、该节点属于第几个字符串等等&lt;br/&gt;一般来说，字典树支持两种操作：插入和查询&lt;br/&gt;假如要插入某个单词&lt;br/&gt;一开始我们位于根节点，也就是&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;号节点&lt;br/&gt;接下来我们判断根节点是否有某一个儿子&lt;span class=&quot;math inline&quot;&gt;\(ch\)&lt;/span&gt;&lt;br/&gt;即&lt;span class=&quot;math inline&quot;&gt;\(tr[now][ch]\)&lt;/span&gt;是否等于&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;&lt;br/&gt;如果等于&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，那我们再新开一个节点，否则把该节点的个数加一&lt;br/&gt;查询操作也是如此，我们就从根节点一路走下去&lt;br/&gt;如果可以走完，说明该单词存在，否则该单词不存在&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;以洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P2922&quot;&gt;P2922&lt;/a&gt;为例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=2e7+5;
char c[maxn];
int tr[maxn][3],cnt[maxn][3],tot,ed[maxn][3];
void ad(char s[]){
    int len=strlen(s);
    int now=0;
    for(int i=0;i&amp;lt;len;i++){
        int t=s[i]-'0';
        if(tr[now][t]){
            cnt[now][t]++;
        } else {
            tr[now][t]=++tot;
            cnt[now][t]=1;
        }
        if(i==len-1) ed[now][t]++;
        now=tr[now][t];
    }
}
int cx(char s[]){
    int len=strlen(s);
    int now=0,ans=0,js=0,jud=0,t;
    for(int i=0;i&amp;lt;len;i++){
        t=s[i]-'0';
        if(tr[now][t]){
            js+=ed[now][t];
            if(i!=len-1)now=tr[now][t];
        } else {
            jud=1;
            break;
        }
    }
    if(jud) return js;
    else return js-ed[now][t]+cnt[now][t];
}
char s[maxn];
int main(){
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=n;i++){
        int t;
        scanf(&quot;%d&quot;,&amp;amp;t);
        int aa;
        for(int j=1;j&amp;lt;=t;j++){
            scanf(&quot;%d&quot;,&amp;amp;aa);
            s[j-1]=aa+'0';
        }
        s[t]='\0';
        ad(s);
    }
    for(int i=1;i&amp;lt;=m;i++){
        int t;
        scanf(&quot;%d&quot;,&amp;amp;t);
        int aa;
        for(int j=1;j&amp;lt;=t;j++){
            scanf(&quot;%d&quot;,&amp;amp;aa);
            s[j-1]=aa+'0';
        }
        s[t]='\0';
        printf(&quot;%d\n&quot;,cx(s));
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;50-五、习题总结&quot;&gt;5.0 五、习题总结&lt;/h2&gt;
&lt;h3 id=&quot;洛谷-p1659-国家集训队拉拉队排练&quot;&gt;洛谷 P1659 [国家集训队]拉拉队排练&lt;/h3&gt;
&lt;h4 id=&quot;题目描述&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202007/1996139-20200725060750857-1953793037.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;
&lt;p&gt;这一道题的大致意思就是让你求出一个字符串中所有的奇回文串，并把它们的长度连乘&lt;br/&gt;考虑到求回文串，我们要使用&lt;span class=&quot;math inline&quot;&gt;\(manacher\)&lt;/span&gt;算法&lt;br/&gt;因为题目中只让你求出奇回文串的个数，因此我们不用在原来的字符之间再插入特殊字符&lt;br/&gt;在进行求解的时候，我们要使用一个&lt;span class=&quot;math inline&quot;&gt;\(p[i]\)&lt;/span&gt;数组记录以&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;为中心的最大回文半径的长度&lt;br/&gt;而对于一个位置&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;，如果向两边扩展&lt;span class=&quot;math inline&quot;&gt;\(p[i]\)&lt;/span&gt;是一个回文串，那么向两边扩展&lt;span class=&quot;math inline&quot;&gt;\(p[i]-k(p[i]-k\geq 1)\)&lt;/span&gt;也是一个回文串&lt;br/&gt;因此，我们就可以求出以&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;为中心的所有回文半径的长度&lt;br/&gt;但是，如果我们使用&lt;span class=&quot;math inline&quot;&gt;\(for\)&lt;/span&gt;循环直接遍历，必定会超时&lt;br/&gt;因此，我们可以使用差分数组解决这一个问题，即在&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的位置加一，在&lt;span class=&quot;math inline&quot;&gt;\(2 \times p[i] -1\)&lt;/span&gt;的位置减一&lt;br/&gt;最后&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;扫一遍即可&lt;br/&gt;还有要注意的一点是，在进行乘法的时候，因为&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的范围很大，所以要使用快速幂&lt;/p&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define int long long
const int maxn=1e6+5;
char s[maxn];
int p[maxn],k,len,cf[maxn];
const int mod=19930726;
int ksm(int ds,int zs){
    int ans=1;
    while(zs){
        if(zs&amp;amp;1) ans=ans*ds%mod;
        ds=ds*ds%mod;
        zs&amp;gt;&amp;gt;=1;
    }
    return ans;
}
signed main(){
    scanf(&quot;%lld%lld&quot;,&amp;amp;len,&amp;amp;k);
    scanf(&quot;%s&quot;,s+1);
    s[0]='$';
    for(int i=1,r=0,mids=0;i&amp;lt;=len;i++){
        if(i&amp;lt;=r) p[i]=min(p[2*mids-i],r-i+1);
        while(s[i-p[i]]==s[i+p[i]]) p[i]++;
        if(p[i]+i&amp;gt;r) r=p[i]+i-1,mids=i;
        cf[1]++,cf[p[i]*2]--;
    }
    for(int i=1;i&amp;lt;=len;i++){
        cf[i]=cf[i-1]+cf[i];
    }
    int mans=1,tot=len;
    if(tot%2==0) tot--;
    while(k&amp;gt;0 &amp;amp;&amp;amp; tot&amp;gt;0){
        mans=mans*ksm(tot,min(cf[tot],k))%mod;
        k-=cf[tot];
        tot-=2;
    }
    if(k&amp;gt;0) printf(&quot;-1\n&quot;);
    else printf(&quot;%lld\n&quot;,mans);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sp15569-stc02---antisymmetry&quot;&gt;SP15569 STC02 - Antisymmetry&lt;/h3&gt;
&lt;h4 id=&quot;题目描述-2&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202007/1996139-20200725063940872-1169328618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析-2&quot;&gt;分析&lt;/h4&gt;
&lt;p&gt;题意：对于一个只含有&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的字符串，求出其在异或意义下的回文字串的数量&lt;br/&gt;比较裸的&lt;span class=&quot;math inline&quot;&gt;\(manacher\)&lt;/span&gt;，将判断的条件稍微改一下即可&lt;/p&gt;
&lt;h4 id=&quot;代码-2&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=1e6+5;
char s1[maxn],s[maxn];
int f[maxn];
int main(){
    int n;
    scanf(&quot;%d&quot;,&amp;amp;n);
    scanf(&quot;%s&quot;,s1+1);
    s[0]='*';
    int cnt=2*n+1;
    for(int i=1;i&amp;lt;=cnt;i++){
        if(i&amp;amp;1) s[i]='%';
        else s[i]=s1[i/2];
    }
    int ans=0,mids=0,r=0;
    for(int i=1;i&amp;lt;=cnt;i++){
        if(i&amp;lt;=r) f[i]=min(f[2*mids-i],r-i+1);
        while( ( (i-f[i])%2==0 &amp;amp;&amp;amp; ( ((s[i+f[i]]-'0')^(s[i-f[i]]-'0')==1) ) )|| (  (i-f[i])%2==1 &amp;amp;&amp;amp; (s[i-f[i]]==s[i+f[i]]) )  ) f[i]++;
        if(i+f[i]&amp;gt;r) r=i+f[i]-1,mids=i; 
        if(i%2==1)ans+=((f[i]-1)/2);
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shoi2011双倍回文&quot;&gt;[SHOI2011]双倍回文&lt;/h3&gt;
&lt;h4 id=&quot;题目描述-3&quot;&gt;题目描述&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202007/1996139-20200725064817879-41488634.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析-3&quot;&gt;分析&lt;/h4&gt;
&lt;p&gt;巧妙地利用了&lt;span class=&quot;math inline&quot;&gt;\(manacher\)&lt;/span&gt;算法的性质，即通过对称性查找回文字串&lt;/p&gt;
&lt;h4 id=&quot;代码-3&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=2e6+15;
char s1[maxn],s[maxn];
int f[maxn];
int main(){
    int n;
    scanf(&quot;%d&quot;,&amp;amp;n);
    scanf(&quot;%s&quot;,s1+1);
    s[0]='*';
    int cnt=2*n+1;
    for(int i=1;i&amp;lt;=cnt;i++){
        if(i&amp;amp;1) s[i]='%';
        else s[i]=s1[i/2];
    }
    int ans=0,mids=0,r=0;
    for(int i=1;i&amp;lt;=cnt;i+=2){
        if(i&amp;lt;=r) f[i]=min(f[2*mids-i],r-i+1);
        while(s[i+f[i]]==s[i-f[i]]) f[i]++;
        if(i+f[i]-1&amp;gt;r) r=i+f[i]-1,mids=i; 
        if(i&amp;lt;r &amp;amp;&amp;amp; i-f[i]&amp;lt;mids) ans=max(ans,2*(i-mids));
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Jul 2020 22:51:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>配合上一篇效果更佳 &amp;amp;gt;字符串学习笔记一 4.0 四、字典树 定义 字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13375406.html</dc:identifier>
</item>
<item>
<title>一分钟速学 | NMS, IOU 与 SoftMax - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13358417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13358417.html</guid>
<description>&lt;p&gt;NMS的英文是Non-maximum suppression的缩写。&lt;/p&gt;
&lt;p&gt;简单的说，就是模型给出了多个重叠在一起的候选框，我们只需要保留一个就可以了。其他的重叠的候选框就删掉了，效果可见下图：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_9274344d84cf00d9f11ffd3a3c94af99.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IoU的英文全称Intersection over Union，就是两个候选框区域的交集面积比上并集的面积，用下图可以理解：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_86065b4c2eb63d5718ed7e1a5fc0bc92.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;hard-nms其实就是经典版本的NMS的方法。就是根据模型给出每个box的置信度从大到小进行排序，然后保留最大的，删除所以与这个最大置信度的候选框的IoU大于阈值的其他候选框。&lt;/p&gt;
&lt;p&gt;举个例子吧，现在有4个候选框：&lt;br/&gt;(box1,0.8),(box2,0.9),&lt;br/&gt;(box3,0.7),(box4,0.5)&lt;/p&gt;
&lt;p&gt;我们把这四个候选框按照置信度从大到小排序：&lt;br/&gt;box2&amp;gt;box1&amp;gt;box3&amp;gt;box4&lt;/p&gt;
&lt;p&gt;现在我们保留置信度最大的候选框box2,然后计算剩下三个box与box2之间的IoU，如果IoU大于一个事先设置的阈值，那么就删除这个box。假设,阈值是0.5:&lt;br/&gt;IoU(box1,box2)=0.1&amp;lt;0.5，保留；IoU(box3,box2)=0.7&amp;lt;0.5，删除；IoU(box4,box2)=0.2&amp;lt;0.5，保留；&lt;/p&gt;
&lt;p&gt;现在还有box1和box4，然后再重复上面的过程，排序，然后删除。&lt;/p&gt;
&lt;p&gt;下面是python实现的hard-NMS：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def hard_nms(box_scores, iou_threshold, top_k=-1, candidate_size=200):
    &quot;&quot;&quot;
    Args:
        box_scores (N, 5): box的集合，N为框的数量，5即4(位置信息)+1(可能为物体的概率)
        iou_threshold: 我们用IOU标准去除多余检测框的阈值
        top_k: 保留多少个计算后留下来的候选框，如果为-1则全保留
        candidate_size: 参与计算的boxes数量
    Returns:
         picked: 经过nms计算后保留下来的box
    &quot;&quot;&quot;
    scores = box_scores[:, -1]                # 首先我们取出box中的最后一个元素也就是当前box检测到物体的概率
    boxes = box_scores[:, :-1]                # 取出box中的四个坐标(左上、右下)
    picked = []  
    _, indexes = scores.sort(descending=True) # 按照降序排列所有的物体的概率，得到排序后在原数组中的索引信息 indexes
    indexes = indexes[:candidate_size]        # 只保留前 candidate_size 个 boxes 其余的不考虑了
    while len(indexes) &amp;gt; 0:
        current = indexes[0]                  # 每次取出当前在 indexes 中 检测到物体概率最大的一个 
        picked.append(current.item())         # 将这个最大的存在结果中
        if 0 &amp;lt; top_k == len(picked) or len(indexes) == 1:
            break
        current_box = boxes[current, :]       # 当前第一个也就是最高概率的box
        indexes = indexes[1:]                
        rest_boxes = boxes[indexes, :]        # 剩下其余的box
        iou = iou_of(                         # 将当前的box与剩下其余的boxes用IOU标准进行筛选
            rest_boxes,
            current_box.unsqueeze(0),
        )
        indexes = indexes[iou &amp;lt;= iou_threshold]# 保留与当前box的IOU小于一定阈值的boxes，

    return box_scores[picked, :]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何计算iou的面积呢？实现方法在下面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def area_of(left_top, right_bottom) -&amp;gt; torch.Tensor:
    &quot;&quot;&quot;Compute the areas of rectangles given two corners.

    Args:
        left_top (N, 2): left top corner.
        right_bottom (N, 2): right bottom corner.

    Returns:
        area (N): return the area.
    &quot;&quot;&quot;
    hw = torch.clamp(right_bottom - left_top, min=0.0)
    return hw[..., 0] * hw[..., 1]


def iou_of(boxes0, boxes1, eps=1e-5):
    &quot;&quot;&quot;Return intersection-over-union (Jaccard index) of boxes.

    Args:
        boxes0 (N, 4): ground truth boxes.
        boxes1 (N or 1, 4): predicted boxes.
        eps: a small number to avoid 0 as denominator.
    Returns:
        iou (N): IoU values.
    &quot;&quot;&quot;
    overlap_left_top = torch.max(boxes0[..., :2], boxes1[..., :2])
    overlap_right_bottom = torch.min(boxes0[..., 2:], boxes1[..., 2:])

    overlap_area = area_of(overlap_left_top, overlap_right_bottom)
    area0 = area_of(boxes0[..., :2], boxes0[..., 2:])
    area1 = area_of(boxes1[..., :2], boxes1[..., 2:])
    return overlap_area / (area0 + area1 - overlap_area + eps)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在密集目标检测任务中，hard-NMS会有一些问题，看下面的例子：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_f3ad9791fece7fa9e429a3dd0cae7aca.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;两个物体重叠起来了，但是根据hard-NMS绿色的框会被掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Soft-NMS就改动了一个地方。&lt;/strong&gt; 在判断最高的置信度的box和其他box的IoU的时候增加了一个系数，可以更好的选择哪些才是多余的box。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于hard-NMS来说，&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(iou(M,b_i)&amp;lt;N_t\)&lt;/span&gt;的时候，保留，大于等于的时候删除，&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;表示置信度：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_29712d9ac1bd65fd0b4e8b3e45ae3abf.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于soft-NMS来说，&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(iou(M,b_i)&amp;lt;N_t\)&lt;/span&gt;的时候，保留，大于的时候削减：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_23e64aa8fd9e1a7e161baa7a341382a4.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来，hard-NMS对于IoU大于阈值的候选框，直接把其置信度变成0，这样就相当于删除了这个box；但是soft-NMS的会根据IoU的大小，去适当的削减置信度，从而留下一些余地。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【如何削减】&lt;/strong&gt;&lt;br/&gt;这里有两种方法来降低重叠候选框的置信度：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(s=s(1-iou(M,b))\)&lt;/span&gt;简单的线性衰减；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(s = se^{-\frac{iou(M,b)^2}{\sigma}}\)&lt;/span&gt;指数衰减。其中sigma是常数，一般是0.5.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二种方法更为常见。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面是python来实现的soft-NMS，其实跟hard-NMS相比，就多了一行代码罢了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def soft_nms(box_scores, score_threshold, sigma=0.5, top_k=-1):
    &quot;&quot;&quot;Soft NMS implementation.

    References:
        https://arxiv.org/abs/1704.04503
        https://github.com/facebookresearch/Detectron/blob/master/detectron/utils/cython_nms.pyx

    Args:
        box_scores (N, 5): boxes in corner-form and probabilities.
        score_threshold: boxes with scores less than value are not considered.
        sigma: the parameter in score re-computation.
            scores[i] = scores[i] * exp(-(iou_i)^2 / simga)
        top_k: keep top_k results. If k &amp;lt;= 0, keep all the results.
    Returns:
         picked_box_scores (K, 5): results of NMS.
    &quot;&quot;&quot;
    picked_box_scores = []
    while box_scores.size(0) &amp;gt; 0:
        max_score_index = torch.argmax(box_scores[:, 4])
        cur_box_prob = torch.tensor(box_scores[max_score_index, :])
        picked_box_scores.append(cur_box_prob)
        if len(picked_box_scores) == top_k &amp;gt; 0 or box_scores.size(0) == 1:
            break
        cur_box = cur_box_prob[:-1]
        box_scores[max_score_index, :] = box_scores[-1, :]
        box_scores = box_scores[:-1, :]
        ious = iou_of(cur_box.unsqueeze(0), box_scores[:, :-1])

        # 以下这句是新加的，如果没有这句就是Hard-NMS了
        box_scores[:, -1] = box_scores[:, -1] * torch.exp(-(ious * ious) / sigma) 

        box_scores = box_scores[box_scores[:, -1] &amp;gt; score_threshold, :]
    if len(picked_box_scores) &amp;gt; 0:
        return torch.stack(picked_box_scores)
    else:
        return torch.tensor([])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlQTAlODclRTklQTIlOThfJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUJBJUJGXzIwMjAtMDctMjAtMC5naWY&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy93cF9lZGl0b3JfbWRfMzEyZGQyZDliYmNmZmNiZDk0Y2YwODlkYTE4YzVjNGEuanBn?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlOTYlODclRTQlQkIlQjYxNTk1MjUxNjIxMTEyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 18:57:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>非极大抑制 NMS的英文是Non-maximum suppression的缩写。 简单的说，就是模型给出了多个重叠在一起的候选框，我们只需要保留一个就可以了。其他的重叠的候选框就删掉了，效果可见下图：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13358417.html</dc:identifier>
</item>
<item>
<title>Qt-绘制图表 - zhengcixi</title>
<link>http://www.cnblogs.com/mrlayfolk/p/13375358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrlayfolk/p/13375358.html</guid>
<description>&lt;h3&gt;1  简介&lt;/h3&gt;
&lt;p&gt;使用Qt的charts模块来绘制图表，案例来自Qt自带的demo。&lt;/p&gt;
&lt;p&gt;charts模块简介：Qt Chars模块提供了一系列容易使用的图表组件。需要使用charts组件时，需要导入Qt Charts模块，通过如下方式：&lt;span&gt;QT += charts&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在安装Qt Creator的时候，需要勾选上这个模块，不然是不能使用的。&lt;/p&gt;
&lt;h3&gt;2  Qt Charts总览&lt;/h3&gt;
&lt;p&gt;Qt Chars支持绘制：坐标图、柱状图、折线图、饼图、曲线图、散点图等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200724225801687-10823261.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;480&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3  测试及说明&lt;/h3&gt;
&lt;p&gt;首先创建一个工程，继承至MainWindow组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200724232242831-1971414477.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;297&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）绘制折线图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;折线图通过线段展示一系列相关联的点。&lt;/p&gt;
&lt;p&gt;使用的类：QLineSeries&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; MainWindow::MainWindow(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::MainWindow)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * LineChart Example
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QLineSeries实例&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     QLineSeries *lineseries = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加数据（点），有两种方式&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数分别为横纵坐标&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     *lineseries &amp;lt;&amp;lt; QPointF(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;13&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;17&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QChart实例，为了展示数据&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;hide();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏图例&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(lineseries);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple line chart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QChartView图例&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     chartView-&amp;gt;setRenderHint(QPainter::Antialiasing);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现方式
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725014626016-529218416.png&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;319&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）绘制曲线图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的类：QSplineSeries&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     QSplineSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QSplineSeries();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     series-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;hide();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple spline chart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     chart-&amp;gt;axisY()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;show();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725015226856-167605022.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;334&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）绘制面积图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的类：LineChart&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     QLineSeries *series0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     QLineSeries *series1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     *series0 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;              &amp;lt;&amp;lt; QPointF(&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     *series1 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;              &amp;lt;&amp;lt; QPointF(&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     QAreaSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QAreaSeries(series0, series1);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     series-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Batman&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     QPen pen(&lt;span&gt;0x059605&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     pen.setWidth(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     series-&amp;gt;&lt;span&gt;setPen(pen);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple areachart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     chart-&amp;gt;axisX()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     chart-&amp;gt;axisY()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;show();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725015857818-653577086.png&quot; alt=&quot;&quot; width=&quot;397&quot; height=&quot;329&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）绘制散点图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的类： QScatterSeries&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     QScatterSeries *series0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     series0-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     series0-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeCircle);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     series0-&amp;gt;setMarkerSize(&lt;span&gt;5.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     QScatterSeries *series1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     series1-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     series1-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeRectangle);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     series1-&amp;gt;setMarkerSize(&lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     QScatterSeries *series2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     series2-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     series2-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeRectangle);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     series2-&amp;gt;setMarkerSize(&lt;span&gt;15.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     *series1 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     *series2 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series0);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series1);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series2);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple scatterchart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     chart-&amp;gt;setDropShadowEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;show();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725021539772-595950728.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;339&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）绘制柱状图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的类：QBarSeries&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     QBarSet *set0 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     QBarSet *set1 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     QBarSet *set2 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Axel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     QBarSet *set3 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     QBarSet *set4 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Samantha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     *set0 &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     *set1 &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     *set2 &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;13&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     *set3 &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;6&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     *set4 &amp;lt;&amp;lt; &lt;span&gt;9&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     QBarSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QBarSeries();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set0);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set1);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set2);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set3);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set4);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple barchart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;setAnimationOptions(QChart::SeriesAnimations);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    QStringList categories;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     categories &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     QBarCategoryAxis *axis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QBarCategoryAxis();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     axis-&amp;gt;&lt;span&gt;append(categories);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;setAxisX(axis, series);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;setVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;setAlignment(Qt::AlignBottom);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;show();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725022015808-152518914.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;352&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （6）绘制饼图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用的类：QPieSeries&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     QPieSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QPieSeries();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Joe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Andy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Barbara&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Axel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     QPieSlice *slice = series-&amp;gt;slices().at(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setExploded();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setLabelVisible();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     slice-&amp;gt;setPen(QPen(Qt::darkGreen, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setBrush(Qt::green);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple piechart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;hide();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;show();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078885/202007/1078885-20200725022709787-2007802683.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;328&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整的测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('efa92cde-9f5c-4c8c-8649-5de9c67a364b')&quot; readability=&quot;62.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_efa92cde-9f5c-4c8c-8649-5de9c67a364b&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_efa92cde-9f5c-4c8c-8649-5de9c67a364b&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_efa92cde-9f5c-4c8c-8649-5de9c67a364b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;120&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mainwindow.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_mainwindow.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;QtCharts&amp;gt;
&lt;span&gt;  4&lt;/span&gt; #include &amp;lt;QPainter&amp;gt;
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;QPainterPath&amp;gt;
&lt;span&gt;  6&lt;/span&gt; #include &amp;lt;QtMath&amp;gt;
&lt;span&gt;  7&lt;/span&gt; #include &amp;lt;QImage&amp;gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; MainWindow::MainWindow(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::MainWindow)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;     * LineChart Example
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QLineSeries实例&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     QLineSeries *lineseries = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加数据（点），有两种方式&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数分别为横纵坐标&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     lineseries-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     *lineseries &amp;lt;&amp;lt; QPointF(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;13&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;17&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QChart实例，为了展示数据&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;hide();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏图例&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(lineseries);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple line chart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个QChartView图例&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     chartView-&amp;gt;setRenderHint(QPainter::Antialiasing);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现方式
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;     * SplineChart Example
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     QSplineSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QSplineSeries();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     series-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;hide();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple spline chart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     chart-&amp;gt;axisY()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    * AreaChart Example
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     QLineSeries *series0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     QLineSeries *series1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QLineSeries();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     *series0 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;              &amp;lt;&amp;lt; QPointF(&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     *series1 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;              &amp;lt;&amp;lt; QPointF(&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;18&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     QAreaSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QAreaSeries(series0, series1);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     series-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Batman&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     QPen pen(&lt;span&gt;0x059605&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     pen.setWidth(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     series-&amp;gt;&lt;span&gt;setPen(pen);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple areachart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     chart-&amp;gt;axisX()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     chart-&amp;gt;axisY()-&amp;gt;setRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    * QScatterChart Example
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     QScatterSeries *series0 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     series0-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     series0-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeCircle);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     series0-&amp;gt;setMarkerSize(&lt;span&gt;5.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;     QScatterSeries *series1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     series1-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     series1-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeRectangle);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     series1-&amp;gt;setMarkerSize(&lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;     QScatterSeries *series2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QScatterSeries();
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     series2-&amp;gt;setName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scatter3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     series2-&amp;gt;&lt;span&gt;setMarkerShape(QScatterSeries::MarkerShapeRectangle);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     series2-&amp;gt;setMarkerSize(&lt;span&gt;15.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     series0-&amp;gt;append(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     *series1 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     *series2 &amp;lt;&amp;lt; QPointF(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; QPointF(&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series0);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series1);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series2);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple scatterchart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     chart-&amp;gt;setDropShadowEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt;148&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    * BarChart Example
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;     QBarSet *set0 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     QBarSet *set1 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     QBarSet *set2 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Axel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     QBarSet *set3 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     QBarSet *set4 = &lt;span&gt;new&lt;/span&gt; QBarSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Samantha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;     *set0 &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;     *set1 &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;     *set2 &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;13&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     *set3 &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;6&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;     *set4 &amp;lt;&amp;lt; &lt;span&gt;9&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     QBarSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QBarSeries();
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set0);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set1);
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set2);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set3);
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     series-&amp;gt;&lt;span&gt;append(set4);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple barchart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;setAnimationOptions(QChart::SeriesAnimations);
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt; &lt;span&gt;    QStringList categories;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;     categories &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;May&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;     QBarCategoryAxis *axis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QBarCategoryAxis();
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;     axis-&amp;gt;&lt;span&gt;append(categories);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;createDefaultAxes();
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;setAxisX(axis, series);
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;setVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;setAlignment(Qt::AlignBottom);
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; 
&lt;span&gt;185&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; 0
&lt;span&gt;194&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;    * Piechart Example
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;     QPieSeries *series = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QPieSeries();
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Joe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Andy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Barbara&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     series-&amp;gt;append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Axel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; 
&lt;span&gt;204&lt;/span&gt;     QPieSlice *slice = series-&amp;gt;slices().at(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setExploded();
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setLabelVisible();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     slice-&amp;gt;setPen(QPen(Qt::darkGreen, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     slice-&amp;gt;&lt;span&gt;setBrush(Qt::green);
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; 
&lt;span&gt;210&lt;/span&gt;     QChart *chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChart();
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     chart-&amp;gt;&lt;span&gt;addSeries(series);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;     chart-&amp;gt;setTitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Simple piechart example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     chart-&amp;gt;legend()-&amp;gt;&lt;span&gt;hide();
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; 
&lt;span&gt;215&lt;/span&gt;     QChartView *chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QChartView(chart);
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;     chartView-&amp;gt;&lt;span&gt;setRenderHint(QPainter::Antialiasing);
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;setCentralWidget(chartView);
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;resize(&lt;span&gt;400&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;show();
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; 
&lt;span&gt;224&lt;/span&gt; MainWindow::~&lt;span&gt;MainWindow()
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;还有一些图形及主题等设置，后续待补充。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 18:29:00 +0000</pubDate>
<dc:creator>zhengcixi</dc:creator>
<og:description>1 简介 使用Qt的charts模块来绘制图表，案例来自Qt自带的demo。 charts模块简介：Qt Chars模块提供了一系列容易使用的图表组件。需要使用charts组件时，需要导入Qt Cha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrlayfolk/p/13375358.html</dc:identifier>
</item>
<item>
<title>Python后端日常操作之在Django中「强行」使用MVVM设计模式 - 画星星高手</title>
<link>http://www.cnblogs.com/deali/p/13375304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deali/p/13375304.html</guid>
<description>&lt;h2 id=&quot;扫盲&quot;&gt;扫盲&lt;/h2&gt;
&lt;p&gt;首先带大家了解一下什么是MVVM模式：&lt;/p&gt;
&lt;blockquote readability=&quot;14.94495412844&quot;&gt;
&lt;p&gt;什么是MVVM？&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel&quot;&gt;MVVM&lt;/a&gt;是Model-View-ViewModel的缩写。&lt;/p&gt;
&lt;p&gt;MVVM是MVC的增强版，实质上和MVC没有本质区别，只是代码的位置变动而已&lt;br/&gt;从名字上看，MVVM比MVC架构中多了一个ViewModel，没错，就是这个ViewModel，他是MVVM相对于MVC改进的核心思想。在开发过程中，由于需求的变更或添加，项目的复杂度越来越高，代码量越来越大，此时我们会发现MVC维护起来有些吃力，首先被人吐槽的最多的就是MVC的简写变成了Massive-View-Controller（意为沉重的Controller）&lt;/p&gt;
&lt;p&gt;由于Controller主要用来处理各种逻辑和数据转化，复杂业务逻辑界面的Controller非常庞大，维护困难，所以有人想到把Controller的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是ViewModel，是Model和Controller之间的一座桥梁。当人们去尝试这种方式时，发现Controller中的代码变得非常少，变得易于测试和维护，只需要Controller和ViewModel做数据绑定即可，这也就催生了MVVM的热潮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;大家都知道Django是MVT模式，Model就是View和Template/Interface之间的数据传递的「信使」，这种模式存在一个问题，就是当我们的业务不断扩大之后需要在接口返回出model里不包含的数据时该怎么办？例如一个商店，我们要动态计算它距离我们当前位置有多远，那么这个距离肯定是不包含在Model里面的，数据库也不可能实时存储这类数据。&lt;/p&gt;
&lt;p&gt;那么这时候我们就需要在Model上，再加上一层ViewModel，顾名思义，视图模型，是用来在视图里传递和处理数据的模型。&lt;/p&gt;
&lt;h2 id=&quot;简单实现&quot;&gt;简单实现&lt;/h2&gt;
&lt;p&gt;在App包下面创建一个&lt;code&gt;view_models&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from rest_framework.request import Request
from core.models import Store
from core.serializers import StoreSerializer

class StoreViewModel:
    def __init__(self, store: Store, distance=0.0, request: Request = None):
        self.store = store
        self.distance = distance
        self.request = request

    @property
    def serialize_data(self):
        return StoreSerializer(self.store, context={
            'distance': self.distance,
            'request': self.request,
        }).data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码定义了一个商店的视图模型，构造方法中除了我们的Model对象，还有Model中不包括的distance参数，还有一个request用来传递请求的context，这个在Drf中是很重要的，如果不处理好context的传递，会导致Drf在序列化一些文件或者链接类字段的时候丢失前半部分的域名。&lt;/p&gt;
&lt;p&gt;接下来看看&lt;code&gt;serialize_data&lt;/code&gt;这个属性，它做的工作很简单，就是把Model对象传给序列化器，然后在context中存入我们的额外参数distance和request。&lt;/p&gt;
&lt;p&gt;再来看看序列化器要如何改造以适应ViewModel模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class StoreSerializer(serializers.ModelSerializer):
    distance = serializers.SerializerMethodField()

    class Meta:
        model = models.Store
        fields = '__all__'

    def get_distance(self, obj: models.Store):
        return self.context.get('distance', 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到序列化器中，我是把额外的distance字段处理成&lt;code&gt;SerializerMethodField&lt;/code&gt;，然后在&lt;code&gt;get_distance&lt;/code&gt;方法中实现，通过&lt;code&gt;self.context&lt;/code&gt;属性可以获取到我们在ViewModel中传入的context，这样就实现额外参数的序列化。&lt;/p&gt;
&lt;p&gt;最后我们在看看在View，也就是控制器，看看如何将ViewModel和原本的分页，权限各类功能结合在一起。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class StoreViewSet(viewsets.ReadOnlyModelViewSet):
    &quot;&quot;&quot;商家相关功能&quot;&quot;&quot;
    serializer_class = serializers.StoreSerializer
    queryset = models.Store.objects.all()

    @action(detail=False)
    def location(self, request):
        &quot;&quot;&quot;根据地理位置筛选商家&quot;&quot;&quot;
        city = request.GET.get('city')
        town = request.GET.get('town')
        lat = request.GET.get('lat')
        lng = request.GET.get('lng')
        
        # 根据城市、区镇筛选商店
        queryset = models.Store.objects.filter(city=city, town=town)
        
        # 调用接口计算所有商店距离当前位置的距离，该接口返回ViewModel
        store_view_models = tencent_map.stores_distance(from_lat=lat, from_lng=lng, queryset=queryset, request=request)

        # 对ViewModelSet进行排序，按照距离
        store_view_models.sort(key=lambda store_view_model: store_view_model.distance)
        
        # 使用列表生成器，对每个ViewModel进行序列化
        stores_data = [store_vm.serialize_data for store_vm in store_view_models]
        
        # 对结果数据进行分页
        page = self.paginate_queryset(stores_data)
        return self.get_paginated_response(page)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码目前在开发环境运行良好，我已经写了详细的注释了，可以看到用ViewModel模式是可以和原本的ViewSet很好的结合在一起的，包括分页这些功能都可以正常使用。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;标题中我用了「强行」这个词，就是觉得我这样实现好像很不优雅，但又不至于hack，因为这个需求很简单，只要实现了就行，我也还没有去搜索其他的解决方案，在本文中提出了我的ViewModel与Django结合解决方案，如果大家有更好的解决方案可以留言一起探讨~&lt;/p&gt;
&lt;h2 id=&quot;欢迎交流&quot;&gt;欢迎交流&lt;/h2&gt;
&lt;p&gt;我整理了一系列的技术文章和资料，在公众号「程序设计实验室」后台回复 linux、flutter、c#、netcore、android、java、python 等可获取相关技术文章和资料，同时有任何问题都可以在公众号后台留言~&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 17:08:00 +0000</pubDate>
<dc:creator>画星星高手</dc:creator>
<og:description>扫盲 首先带大家了解一下什么是MVVM模式： 什么是MVVM？MVVM是Model-View-ViewModel的缩写。 MVVM是MVC的增强版，实质上和MVC没有本质区别，只是代码的位置变动而已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deali/p/13375304.html</dc:identifier>
</item>
<item>
<title>并发系列（二）——FutureTask类源码简析 - 王大咩的图书馆</title>
<link>http://www.cnblogs.com/love-yh/p/13375236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-yh/p/13375236.html</guid>
<description>&lt;p&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本文基于JDK 11，主要介绍FutureTask类中的run()、get()和cancel() 方法，没有过多解析相应interface中的注释，但阅读源码时建议先阅读注释，明白方法的主要的功能，再去看源码会更快。&lt;/p&gt;
&lt;p&gt;　　文中若有不正确的地方欢迎大伙留言指出，谢谢了！&lt;/p&gt;

&lt;h2&gt;　　&lt;span&gt;1.1 FutureTask简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　FutureTask类图如下（使用IDEA生成）。如图所示，FutureTask实现了Future接口的所有方法，并且实现了Runnable接口，其中，Runnable接口的现实类用于被线程执行，而Future代表的是异步计算的结果。因此，FutureTask类可以理解为，执行run()（实现Runnable接口中的方法），通过Future的get()方法获取结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1168728/202007/1168728-20200724222856570-652023410.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;390&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　&lt;span&gt;1.2 FutureTask的属性&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务线程总共有七中状态如下：&lt;/span&gt;
    *&lt;span&gt; Possible state transitions:
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; NORMAL
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; EXCEPTIONAL
     &lt;/span&gt;* NEW -&amp;gt;&lt;span&gt; CANCELLED
     &lt;/span&gt;* NEW -&amp;gt; INTERRUPTING -&amp;gt;&lt;span&gt; INTERRUPTED
     &lt;/span&gt;*/
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NEW          = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COMPLETING   = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORMAL       = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCEPTIONAL  = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED    = 4&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTING = 5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTED  = 6&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The underlying callable; nulled out after running &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在run()方法中调用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; callable;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The result to return or exception to throw from get() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务执行结果，callable.call()正常执行的返回值&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Object outcome; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; non-volatile, protected by state reads/writes&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The thread running the callable; CASed during run() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务线程&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Thread runner;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Treiber stack of waiting threads &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待任务结果的线程组成的节点，放在链表对列中&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; WaitNode waiters;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　&lt;span&gt;2.1 run()方法&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、若是任务的状态不是NEW，且使用CAS将runner置为当前线程则直接返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (state != NEW ||
            !RUNNER.compareAndSet(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Thread.currentThread()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Callable&lt;/span&gt;&amp;lt;V&amp;gt; c =&lt;span&gt; callable;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、任务不为null，且state的状态为NEW的情况下才执行任务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state ==&lt;span&gt; NEW) {
                V result;
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; ran;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行任务并接收执行结果&lt;/span&gt;
                    result =&lt;span&gt; c.call();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常执行结果则将标识置为true&lt;/span&gt;
                    ran = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、任务发生异常，执行或cancel()，则结果置为null，并记录异常信息&lt;/span&gt;
                    result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    ran &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    setException(ex);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、任务正常结束，则设置返回结果&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ran)
                    set(result);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runner must be non-null until state is settled to
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prevent concurrent calls to run()&lt;/span&gt;
            runner = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state must be re-read after nulling runner to prevent
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaked interrupts&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、若是异常导致，走另一个流程&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1）若任务的状态不是NEW，或者使用CAS将runner置为当前线程失败，则直接返回的原因是防止多线程调用；&lt;/p&gt;
&lt;p&gt;　　2）再度确认任务执行的前置条件；&lt;/p&gt;
&lt;p&gt;　　3）任务执行异常，将result置为null，并记录异常，setException()源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setException(Throwable t) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用CAS将状态置为中间态COMPLETING&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (STATE.compareAndSet(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, NEW, COMPLETING)) {
            outcome &lt;/span&gt;=&lt;span&gt; t;
            STATE.setRelease(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, EXCEPTIONAL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; final state
            &lt;/span&gt;&lt;span&gt;//任务处于结束态时，遍历&lt;/span&gt;&lt;span&gt;唤醒等待result的线程&lt;/span&gt;
&lt;span&gt;            finishCompletion();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　任务的状态变化为NEW  - &amp;gt;  COMPLETING  -&amp;gt;  EXCEPTIONAL&lt;/p&gt;
&lt;p&gt;　　4）任务正常结果则会设置result之后，唤醒waitNode的链表对列中等待任务结果的线程；&lt;/p&gt;
&lt;p&gt;　　5）异常后的调用逻辑如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证调用cancel在run方法返回之前中断执行任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handlePossibleCancellationInterrupt(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It is possible for our interrupter to stall before getting a
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chance to interrupt us.  Let's spin-wait patiently.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; INTERRUPTING)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自旋等待&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (state ==&lt;span&gt; INTERRUPTING)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程让出CPU执行权&lt;/span&gt;
                Thread.yield(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait out pending interrupt&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 　&lt;span&gt;　2.2  get()方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　源码分析如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; V get() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;lt;=&lt;span&gt; COMPLETING)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待任务完成&lt;/span&gt;
            s = awaitDone(&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回结果&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; report(s);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，等待过程分析如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(&lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The code below is very delicate, to achieve these goals:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - call nanoTime exactly once for each call to park
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - if nanos &amp;lt;= 0L, return promptly without allocation or nanoTime
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - if nanos == Long.MIN_VALUE, don't underflow
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   and we suffer a spurious wakeup, we will do no worse than
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   to park-spin for a while&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; startTime = 0L;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Special value 0L means not yet parked&lt;/span&gt;
        WaitNode q = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; queued = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、任务的状态已经处于最终的状态，则将任务线程的引用置为null，直接返回状态&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; COMPLETING) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、任务的状态为COMPLETING说明任务已经接近完成，则当前线程让出CPU权限以便任务执行线程获取到CPU执行权&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; COMPLETING)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We may have already promised (via isDone) that we are done
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; so never return empty-handed or throw InterruptedException&lt;/span&gt;
&lt;span&gt;                Thread.yield();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、当前线程被中断，则将当前线程从等待任务结果的对列中移除，并抛出异常&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
                removeWaiter(q);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、任务线程的状态小于COMPLETING，则将当前调用get()方法的线程新建一个Node&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0L&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
                q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitNode();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、若由当前线程构成的Node未加入链表中，则加入&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;queued)
                queued &lt;/span&gt;= WAITERS.weakCompareAndSet(&lt;span&gt;this&lt;/span&gt;, q.next =&lt;span&gt; waiters, q);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、是否开启了超时获取结果&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; parkNanos;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (startTime == 0L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; first time&lt;/span&gt;
                    startTime =&lt;span&gt; System.nanoTime();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (startTime == 0L&lt;span&gt;)
                        startTime &lt;/span&gt;= 1L&lt;span&gt;;
                    parkNanos &lt;/span&gt;=&lt;span&gt; nanos;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; elapsed = System.nanoTime() -&lt;span&gt; startTime;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、超时则从栈中移除当前线程&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (elapsed &amp;gt;=&lt;span&gt; nanos) {
                        removeWaiter(q);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
                    }
                    parkNanos &lt;/span&gt;= nanos -&lt;span&gt; elapsed;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; nanoTime may be slow; recheck before parking
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程挂起&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (state &amp;lt;&lt;span&gt; COMPLETING)
                    LockSupport.parkNanos(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, parkNanos);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取到返回的状态值后，根据其状态值判断是返回结果还是抛出异常。&lt;/p&gt;
&lt;h2&gt;　&lt;span&gt;　2.2 cancel()方法&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cancel(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mayInterruptIfRunning) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、若任务线程的状态为NEW，则将其状态从NEW置为INTERRUPTING、CANCELLED&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!(state == NEW &amp;amp;&amp;amp;&lt;span&gt; STATE.compareAndSet
              (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, NEW, mayInterruptIfRunning ?&lt;span&gt; INTERRUPTING : CANCELLED)))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS改变任务线程的状态失败，则直接返回false，表示cancel失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; in case call to interrupt throws exception
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、改变任务线程的状态成功后，根据是否中断running的任务线程的标识位，决定是否中断正在运行的任务线程&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mayInterruptIfRunning) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread t &lt;/span&gt;=&lt;span&gt; runner;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务线程不为null，则使用interrupt()中断&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        t.interrupt();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; final state
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置状态&lt;/span&gt;
                    STATE.setRelease(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, INTERRUPTED);
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、清理等待任务结果的等待线程&lt;/span&gt;
&lt;span&gt;            finishCompletion();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1）执行run()方法，是在调用在Callable的call()方法，其实在初始化时被指定；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2）调用get()方法，若是任务线程还在执行，则会把调用get的线程封装成waitNode塞入到FutureTask类内部的阻塞链表对列中，可以有多个线程同时调用get()方法；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3）cancel()方法是通过对任务线程调用interrupt()实现；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 16:37:00 +0000</pubDate>
<dc:creator>王大咩的图书馆</dc:creator>
<og:description>背景 本文基于JDK 11，主要介绍FutureTask类中的run()、get()和cancel() 方法，没有过多解析相应interface中的注释，但阅读源码时建议先阅读注释，明白方法的主要的功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/love-yh/p/13375236.html</dc:identifier>
</item>
<item>
<title>依赖倒置、依赖注入和控制反转傻傻分不清楚？ - AD_milk</title>
<link>http://www.cnblogs.com/AD-milk/p/13375178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AD-milk/p/13375178.html</guid>
<description>&lt;h2 id=&quot;依赖倒置&quot;&gt;依赖倒置&lt;/h2&gt;
&lt;p&gt;啥是依赖倒置？依赖倒置是SOLID原则之一，词的字面意思就是将依赖关系的倒置。&lt;/p&gt;
&lt;p&gt;其实依赖倒置大家早就会了，这个实际上就是面向接口编程。举个例子，现在电子产品更新换代快，可能没过多久咱们就想换一台电脑玩玩。即使电脑的品牌不同，但我们还是可以正常使用，总不会换个牌子就不会用了吧。&lt;/p&gt;
&lt;p&gt;所以如果用代码表示的话，我们用接口&lt;code&gt;IPC&lt;/code&gt;来代替具体的类，然后各个类去实现它的&lt;code&gt;programming&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IPC{
    void programming();
}

public class User {
    private IPC pc;
        //如果写成private Dell dell;
    //那我们换成联想的电脑就麻烦了
    public User(IPC pc) {
        this.pc = pc;
    }
    public void usePC(){
        pc.programming();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为啥叫它倒置呢，因为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202007/1932912-20200724235333305-33080803.png&quot; alt=&quot;依赖倒置1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202007/1932912-20200724235349831-1916967353.png&quot; alt=&quot;依赖倒置2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是箭头倒过来了呢😁&lt;/p&gt;
&lt;h2 id=&quot;依赖注入与控制反转&quot;&gt;依赖注入与控制反转&lt;/h2&gt;
&lt;p&gt;依赖注入是实现控制反转的具体手段，这俩听起来高大上，其实...&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
    public static void main(String[] args) {
        //创建对象
        Dell dell=new Dell();
        //依赖注入
        User user=new User(dell);
        user.usePC();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖注入指的是不在类内部使用new来创建依赖对象，而是将其在外部创建好后，通过构造函数或者赋值函数注入进类中，也就是当参数传进去。&lt;/p&gt;
&lt;p&gt;而控制反转就是依赖注入中说的，将依赖类实例化的控制权交给外部逻辑处理。我不心系你这东西的创建，我只关心你提供的功能，一切都按我的标准指定好，拿来用就行。&lt;/p&gt;
&lt;p&gt;比如我们笔记本电脑的各个部分是不同厂家生产的，笔记本电脑厂商只需把标准给各个零件生产商，让他们按要求生产，自己最后组装拿来用就好了。这样我们就达到了解耦的目的。&lt;/p&gt;
&lt;h2 id=&quot;控制反转容器&quot;&gt;控制反转容器&lt;/h2&gt;
&lt;p&gt;因为我们在程序设计时采用了依赖注入，那么不可避免的，我们要在程序里写大量的new。但对象的创建与依赖注入跟具体的业务并无关系，我们可不可以将其抽象成框架呢？&lt;/p&gt;
&lt;p&gt;于是我们就有了IOC容器或者说依赖注入框架，只需要简单配置一下就可以由框架自动创建对象、管理对象以及依赖注入这些原本需要我们自己来做的事情。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 15:54:00 +0000</pubDate>
<dc:creator>AD_milk</dc:creator>
<og:description>依赖倒置 啥是依赖倒置？依赖倒置是SOLID原则之一，词的字面意思就是将依赖关系的倒置。 其实依赖倒置大家早就会了，这个实际上就是面向接口编程。举个例子，现在电子产品更新换代快，可能没过多久咱们就想换</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AD-milk/p/13375178.html</dc:identifier>
</item>
<item>
<title>The option-critic architecture - 米么裤</title>
<link>http://www.cnblogs.com/codonU/p/13375109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codonU/p/13375109.html</guid>
<description>&lt;p&gt;时间抽象是强化学习中扩大学习和规划的关键。虽然计划与时间扩展的行动是众所周知的，但从数据中自主地创建这样的抽象仍然具有挑战性。我们在option框架内解决这个问题[Sutton，Precup&amp;amp;Singh，1999；Precup，2000]。我们推导了option的策略梯度定理，并提出了一种新的 &lt;span class=&quot;math inline&quot;&gt;\(opiton\text{-}critic\)&lt;/span&gt; 体系结构，它&lt;mark&gt;能够同时学习 option 的内部策略和终止条件，并且不需要提供任何额外的奖励或子目标&lt;/mark&gt;。在离散和连续环境下的实验结果表明了该框架的灵活性和高效性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Temporal abstraction：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时间抽象允许表示发生在不同时间尺度上的行为过程的知识。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;How to understand? Option?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在强化学习中，option（Sutton、Precup和Singh 1999；Precup 2000）为定义此类行动方案以及与之无缝地学习和规划提供了框架。在过去的15年里，&lt;strong&gt;自主地发现时间抽象一直是广泛研究的主题&lt;/strong&gt;（McGovern和Barto 2001；Stolle和Precup 2002；Menache、Mannor和Shimkin 2002；S¸ims¸ek和Barto 2009；Silver和Ciosek 2012），但是可以自然地与连续状态和/或动作空间一起使用的方法直到最近才开始变得可行（Konidaris等人。2011年；Niekum 2013年；Mann、Mannor和Precup 2015年；Mankowitz、Mann和Mannor 2016年；Kulkarni等人。2016年；V ezhnevets等人。2016年；Daniel等人。2016年）。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;现有的大部分工作都集中在寻找子目标（代理应该达到的有用状态）以及随后学习实现这些目标的策略。&lt;/mark&gt;这一想法导致了有趣的方法，但因为他们的 &quot;combinatorial&quot; flavor 也很难扩大规模，。此外，与子目标相关的策略学习在数据和计算时间方面可能代价很大；在最坏的情况下，它可能与解决整个任务一样昂贵。&lt;/p&gt;
&lt;p&gt;我们提出了另一种观点，它模糊了发现option问题和学习option问题之间的界限。基于policy gradient 定理（Sutton等人。2000年），我们得到了一些新的结果，这些结果使得 &lt;span class=&quot;math inline&quot;&gt;\(intra-option\)&lt;/span&gt; 政策和终止函数的逐步学习过程能够与对它们的策略同时进行。在离散或连续的状态空间和动作空间下，这种方法可以自然地处理线性和非线性函数逼近器。当从单个任务中学习时，现有的学习option方法要慢得多：在类似的任务中重复使用已学习的选项，这是很大的好处。相比之下，我们证明了我们的方法能够在单个任务中成功地学习选项，而不会导致任何减速，同时仍然为转移学习提供好处。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们首先回顾与我们工作的两个主要组成部分相关的背景：policy gradient method 和 option。&lt;/li&gt;
&lt;li&gt;然后我们描述了我们方法的核心思想：the intra-option policy 和 termination gradient theorems。附加技术细节见附录。&lt;/li&gt;
&lt;li&gt;实验结果表明，我们的方法能够有效地学习有意义的时间扩展行为。与其他方法不同，我们只需要指定所需选项的数量；不需要有子目标、额外奖励、描述&lt;strong&gt;demonstrations&lt;/strong&gt;、多重问题或任何其他特殊调整（但是，如果需要，该方法可以利用伪奖励函数）。据我们所知，这是第一个端到端的学习方法，可以以相当的效率扩展到非常大的领域。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个马尔可夫决策过程包括：&lt;/p&gt;
&lt;p&gt;\[状态空间：\mathcal{S} \\ 动作空间：\mathcal{A} \\ 转移函数P：\mathcal{S}\times\mathcal{A}\to \mathbb{R} \]&lt;/p&gt;
&lt;p&gt;为了方便起见，我们发展了假设离散状态和作用集的思想。然而，我们的结果扩展到连续空间使用通常的测量理论假设（我们的一些经验结果是在连续任务）。A (Markov Stationary) &lt;span class=&quot;math inline&quot;&gt;\(policy\)&lt;/span&gt; 是以状态为条件在动作上的概率分布：$$\pi:\mathcal{S}\times\mathcal{A}\to[0,1]$$&lt;/p&gt;
&lt;p&gt;在discount probelem中，策略&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的值函数定义为期望：&lt;/p&gt;
&lt;p&gt;\[V_\pi(s)=\mathbb{E}_\pi[\sum_{t=0}^\infty \gamma^tr_{t+1}|s_0=s] \]&lt;/p&gt;
&lt;p&gt;其动作值函数为：&lt;/p&gt;
&lt;p&gt;\[Q_\pi(s,a)=\mathbb{E}_\pi[\sum_{t=0}^\infty \gamma^tr_{t+1}|s_0=s, a_0=a] \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\gamma\in[0,1)\)&lt;/span&gt;，为折扣因子。&lt;/p&gt;
&lt;p&gt;一个策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt; 对给定的动作值函数 &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; 是贪婪的，如果&lt;span class=&quot;math inline&quot;&gt;\(\pi(s,a)&amp;gt;0\)&lt;/span&gt;当且仅当&lt;span class=&quot;math inline&quot;&gt;\(a=\mathop{\arg\min}_{a'}Q(s,a')\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在离散MDP中，至少有一个最优策略对其自身的作用值函数是贪婪的。&lt;/p&gt;
&lt;h2 id=&quot;policy-gradient-methods&quot;&gt;Policy gradient methods&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;policy gradient&lt;/strong&gt; 方法（Sutton等人。2000；Konda和Tsitsiklis 2000）通过执行随机梯度下降来优化给定参数化随机策略族 &lt;span class=&quot;math inline&quot;&gt;\(\pi_\theta\)&lt;/span&gt; 的性能目标，来解决寻找一个好策略的问题。&lt;mark&gt;&lt;strong&gt;policy gradient&lt;/strong&gt; 定理&lt;/mark&gt;（Sutton等人。2000）提供了平均奖励和折扣奖励目标相对于θ的梯度的表达式。&lt;/p&gt;
&lt;p&gt;在discounted 的设置下，目标是根据指定的开始状态（或分布）来定义的：&lt;/p&gt;
&lt;p&gt;\[s_0:\rho(\theta,s_0)=\mathbb{E}_{\pi\theta}[\sum_{t=0}^{\infty}\gamma^tr_{t+1}|s_0]\tag{a-1} \]&lt;/p&gt;
&lt;p&gt;Policy gradient 定理表明：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial\rho(\theta,s_0)}{\partial\theta}=\sum_s\mu_{\pi\theta}(s|s_0)\sum_a\frac{\partial\pi_{\theta}(a|s)}{\partial\theta}Q_{\pi\theta}(s,a) \]&lt;/p&gt;
&lt;p&gt;\[\mu_{\pi\theta}(s|s_0)=\sum_{t=0}^{\infty}\gamma^tP(s_t=s|s_0) \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mu_{\pi\theta}(s|s_0)\)&lt;/span&gt; 是从 &lt;span class=&quot;math inline&quot;&gt;\(s_0\)&lt;/span&gt; 开始沿轨道的状态的折扣权重。&lt;/p&gt;
&lt;p&gt;在实际应用中，政策梯度是沿着 on-policy 上的平稳分布从样本中估计出来的。（Thomas 2014）表明，忽略此平稳分布中的折扣因子会使通常的政策梯度估计有偏差。然而，纠正这种差异也会降低数据效率。为了简单起见，我们建立在（Sutton et al并根据（Thomas 2014）讨论如何扩展我们的结果。&lt;/p&gt;
&lt;h2 id=&quot;the-options-framework&quot;&gt;The options framework&lt;/h2&gt;
&lt;p&gt;The options framework（Sutton、Precup和Singh 1999；Precup 2000）将时间扩展行动的概念正式化。&lt;/p&gt;
&lt;p&gt;\[\text{Markov option }\omega\in\Omega \ is\ (\mathcal{I}_\omega,\pi_\omega,\beta_\omega)= \begin{cases} \mathcal{I}_\omega \subseteq\mathcal{S}\\ \pi_\omega:intra\text{-}option \text{ policy}\\ \beta_\omega \end{cases} \]&lt;/p&gt;
&lt;p&gt;我们同时假设所有的options在任何地方都可以使用，即 &lt;span class=&quot;math inline&quot;&gt;\(\forall s\in\mathcal{S},\forall \omega\in\Omega:s\in\mathcal{I}_\omega\)&lt;/span&gt; ，&lt;mark&gt;这是大多数option发现算法中的一种假设。我们将在最后一节讨论如何消除这种假设。&lt;/mark&gt;（Sutton，Precup，and Singh 1999；Precup 2000）表明，赋予一组option的MDP成为一个半马尔可夫决策过程（Puterman 1994，第11章），它在 &lt;span class=&quot;math inline&quot;&gt;\(V_\Omega(s)\)&lt;/span&gt; 和 option-value function &lt;span class=&quot;math inline&quot;&gt;\(Q_\Omega(s,\omega)\)&lt;/span&gt; 上具有对应的最优值函数。mdp的学习和规划算法在这种情况下有对应的算法。然而，底层MDP的存在提供了并行学习许多不同选项的可能性：这就是 &lt;span class=&quot;math inline&quot;&gt;\(intra\text{-}option\ learning\)&lt;/span&gt; 的思想，我们在工作中利用了这种思想。&lt;/p&gt;

&lt;p&gt;我们对学习选择问题采取了持续的观点。在任何时候，我们都希望将所有可用的经验提炼到我们系统的每个组成部分：value function, policy over options, intra-option policies and termination functions 价值函数和期权政策、期权内政策和终止函数。为了实现这一目标，我们&lt;mark&gt;&lt;strong&gt;重点学习期权策略和终止函数&lt;/strong&gt;，假设它们是用可微参数化函数逼近器表示的。&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;differentiable parameterized function approximators 可微参数化函数逼近器:&lt;/p&gt;
&lt;p&gt;有很多 differentiable function approximators，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线性模型（Linear combinations of features）&lt;/li&gt;
&lt;li&gt;神经网路（Neural network）&lt;/li&gt;
&lt;li&gt;决策树（Decision tree）&lt;/li&gt;
&lt;li&gt;最近邻（Nearest neighbour）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我们考虑了 &lt;span class=&quot;math inline&quot;&gt;\(call-and-return\)&lt;/span&gt; 执行模型，在该模型中，agent根据其在 &lt;span class=&quot;math inline&quot;&gt;\(\pi_\Omega\)&lt;/span&gt; 的策略选择option &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; ，然后遵循其 &lt;span class=&quot;math inline&quot;&gt;\(intra-option\)&lt;/span&gt; policy &lt;span class=&quot;math inline&quot;&gt;\(\pi_\omega\)&lt;/span&gt;直到终止（由 &lt;span class=&quot;math inline&quot;&gt;\(\beta_\omega\)&lt;/span&gt; 决定），此时该过程重复进行。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(\pi_{\omega,\theta}\)&lt;/span&gt; 表示由θ参数化的option ω的intra-option policy，&lt;span class=&quot;math inline&quot;&gt;\(\beta_{\omega,\vartheta}\)&lt;/span&gt; 是由ϑ参数化的ω的终止函数。&lt;/mark&gt;我们提出了两个新的学习option的结果，得到了作为蓝图的政策梯度定理（萨顿等人。2000年）。&lt;mark&gt;这两个结果都是在假设目标是学习使当前任务的预期收益最大化的option的前提下得出的。&lt;/mark&gt;然而，如果要在目标函数中添加额外的信息，只要它以加性可微函数的形式出现，就可以很容易地做到这一点功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;additive differentiable function：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设我们的目标是优化在&lt;mark&gt;所有&lt;/mark&gt;从指定状态 &lt;span class=&quot;math inline&quot;&gt;\(s_0\)&lt;/span&gt; 和option &lt;span class=&quot;math inline&quot;&gt;\(\omega_0\)&lt;/span&gt; 的轨迹上期望的discounted return，然后&lt;/p&gt;
&lt;p&gt;\[\rho(\Omega,\theta,\vartheta,s_0,\omega_0)=\mathbb{E}_{\Omega,\theta,\omega}[\sum_{t=0}^{\infty}\gamma^tr_{t+1}|s_0,\omega_0] \]&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;7.24：此公式相对于式（a-1）同为 &lt;span class=&quot;math inline&quot;&gt;\(\rho()\)&lt;/span&gt; ，应该同样理解为&lt;span class=&quot;math inline&quot;&gt;\(s_0\)&lt;/span&gt; 的分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意，此return取决于policy over options，以及option policies和termination函数的参数。我们将取这个目标相对于θ和ϑ的梯度。为了做到这一点，我们将使用类似于 &lt;span class=&quot;math inline&quot;&gt;\(intra-option\)&lt;/span&gt; 学习中使用的方程（Sutton，Precup，and Singh 1999，第8节）。具体来说，option-value 函数的&lt;mark&gt;定义&lt;/mark&gt;可以写成：&lt;/p&gt;
&lt;p&gt;\[Q_\Omega(s,\omega)=\sum_a\pi_{\omega,\theta}(a|s)Q_U(s,\omega,a)\tag{1} \]&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先可以很直观地看出此方法不是将option视为不可观察的黑盒，而是可以观察其内部更基础的action。基于此上式便可以理解为，option-value function就是基于状态s，option内策略得到值的期望，所以 &lt;span class=&quot;math inline&quot;&gt;\(Q_U()\)&lt;/span&gt; 从这个表达式推断，就可以推测是用来描述option内的state-action值函数，相当于是option的qlearning过程的值函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Q_U:\mathcal{S}\times\Omega\times\mathcal{A}\to\mathbb{R}\)&lt;/span&gt;是在state-option对的环境中中执行action的值:&lt;/p&gt;
&lt;p&gt;\[Q_U(s,\omega,a)=r(s,a)+\gamma\sum_{s'}P(s'|s,a)U(\omega,s')\tag{2} \]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过文章内的描述可以得知之前的推断是正确的，但是完全理解为option内的q-learning还是不妥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，&lt;span class=&quot;math inline&quot;&gt;\(（s，ω）\)&lt;/span&gt;对导致了一个扩大的状态空间，参见（Levy和Shimkin 2011）。但是，我们不会显式地处理这个空间；它只用于简化推导。函数&lt;span class=&quot;math inline&quot;&gt;\(U:\Omega\times\mathcal{S}\to\mathbb{R}\)&lt;/span&gt;称为到达时的option-value函数（Sutton、Precup和Singh 1999，方程20）。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;进入状态 &lt;span class=&quot;math inline&quot;&gt;\(s'\)&lt;/span&gt; 时执行 &lt;span class=&quot;math inline&quot;&gt;\(ω\)&lt;/span&gt; 的值&lt;/mark&gt;由下式给出:&lt;/p&gt;
&lt;p&gt;\[U(\omega,s')=(1-\beta_{\omega,\vartheta}(s'))Q_\Omega(s',\omega)+\beta_{\omega,\vartheta}(s')V_\Omega(s')\tag{3} \]&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;Between MDPs and semi-MDP中的表达式为：&lt;span class=&quot;math inline&quot;&gt;\(U(s,o)=(1-\beta(s))Q(s,o)+\beta(s)\mathop{\max}_{o'\in\mathcal{O'}}Q(s,o')\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(U(\omega,s')\)&lt;/span&gt; 的含义也即高亮——进入状态 &lt;span class=&quot;math inline&quot;&gt;\(s'\)&lt;/span&gt; 时执行 &lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt; 的值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(s'|s,a)\)&lt;/span&gt; 指（s，a）时s'的概率，所以&lt;span class=&quot;math inline&quot;&gt;\(\sum_{s'}P(s'|s,a)U(\omega,s')\)&lt;/span&gt;即 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}[\omega|s,a]\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意， &lt;span class=&quot;math inline&quot;&gt;\(Q_U\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt; 都依赖于θ和ϑ，但为了清楚起见，我们不在符号中包含它们。导出策略梯度所需的最后一个要素是Markov链，沿着该链可以估计性能度量。自然的方法是考虑在增广状态空间中定义的链，因为state-option对现在在通常的Markov链中扮演regular state的角色。如果option &lt;span class=&quot;math inline&quot;&gt;\(\omega_t\)&lt;/span&gt; 已经启动或在状态st的时间t执行，则&lt;mark&gt;一步中转换到 &lt;span class=&quot;math inline&quot;&gt;\((s_{t+1}，ω_{t+1})\)&lt;/span&gt; 的概率&lt;/mark&gt;为：&lt;/p&gt;
&lt;p&gt;\[P(s_{t+1},\omega_{t+1}|s_t,\omega_t)=\sum_a\pi_{\omega_t,\theta}(a|s_t)P(s_{t+1},a)((1-\beta_{\omega,\vartheta}(s_{t+1}))\mathbb{1}_{\omega_t=\omega_{t+1}}+\beta_{\omega,\vartheta}(s_{t+1})\pi_\Omega(w_{t+1}|s_{t+1}))\tag{4} \]&lt;/p&gt;
&lt;p&gt;显然，（4）给出的过程是均匀的。在温和的条件下，且期权无处不在，它实际上是遍历的，并且在state-option对上存在唯一的稳态分布（stationary distribution）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{1}_{\omega_t=\omega_{t+1}}\)&lt;/span&gt; 的含义：&lt;/p&gt;
&lt;p&gt;稳态分布：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设期权内政策的参数θ是随机可微的，我们现在将计算预期折现收益率的梯度。&lt;/p&gt;
&lt;p&gt;从式（1，2）可以得到：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial Q_\Omega(s,\omega)}{\partial\theta}=\left(\sum_a\frac{\partial\pi_{\omega,\theta}(a|s)}{\partial\theta}Q_U(s,\omega,a)\right) + \sum_a\pi_{\omega,\theta}(a|s)\sum_{s'}\gamma P(s'|s,a)\frac{\partial U(\omega,s')}{\partial\theta} \]&lt;/p&gt;
&lt;p&gt;我们可以用（3）和（4）进一步展开右手边，得到以下定理：&lt;/p&gt;
&lt;h2 id=&quot;intra-option-policy-gradient-theorem&quot;&gt;Intra-Option Policy Gradient Theorem&lt;/h2&gt;
&lt;p&gt;**Theorem 1 (Intra-Option Policy Gradient Theorem). **&lt;/p&gt;
&lt;p&gt;给定一组参数θ可微的随机内期权策略的Markov期权，其期望折现收益率相对于θ和初始条件（s0，ω0）的梯度为：&lt;/p&gt;
&lt;p&gt;\[\sum_{s,\omega}\mu_\Omega(s,\omega|s_0,\omega_0)\sum_a\frac{\partial \pi_{\omega,\theta}(a|s)}{\partial\theta}Q_U(s,\omega,a) \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\mu_\Omega(s,\omega|s_0,\omega_0)\)&lt;/span&gt; 是状态选项对沿着从（s0）开始的轨迹的贴现加权，&lt;/p&gt;
&lt;p&gt;\[\mu_\Omega(s,\omega|s_0,\omega_0)=\sum_{t=0}^{\infty}\gamma^tP(s_t=s,\omega_t=\omega|s_0,\omega_0) \]&lt;/p&gt;
&lt;p&gt;证明在附录中。这个梯度描述了原始水平上局部变化对全局期望折现收益的影响。相反，子目标或伪奖励方法假设期权的目标仅仅是优化其自身的奖励函数，而忽略了提议的变更如何在总体目标中传播。&lt;/p&gt;
&lt;p&gt;现在我们将注意力转向计算终止函数的梯度，这次假设是随机的，并且在ϑ中是可微的。&lt;/p&gt;
&lt;p&gt;从（1，2，3）可以得到：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial Q_\Omega(s,\omega)}{\partial\vartheta}=\sum_a\pi_{\omega,\theta}(a|s)\sum_{s'}\gamma P(s'|s,a)\frac{\partial U(\omega,s')}{\partial\vartheta} \]&lt;/p&gt;
&lt;p&gt;因此，关键量是U的梯度。这是调用和返回执行的自然结果，其中终止函数的“善”只能在进入下一个状态时评估。相关梯度可进一步扩展为:&lt;/p&gt;
&lt;p&gt;\[\frac{\partial U(\omega,s')}{\partial\vartheta}=-\frac{\partial\beta_{\omega,\vartheta}(s')}{\partial\vartheta}A_\Omega(s',\omega)+\gamma\sum_{\omega'}\sum_{s''}P(s'',\omega')\frac{\partial U(\omega',s'')}{\partial\vartheta}\tag{5} \]&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(A_\Omega\)&lt;/span&gt; 是advantage function（Baird，1993），&lt;span class=&quot;math inline&quot;&gt;\(A_\Omega(s',\omega)=Q_\Omega(s',\omega)-V_\Omega(s')\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;递归地展开 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial U(\omega',s'')}{\partial\vartheta}\)&lt;/span&gt; 得到了与定理（1）相似的形式，但其中状态-选项对的权重现在是根据移动一个时间步的马尔可夫链：&lt;span class=&quot;math inline&quot;&gt;\(\mu_\Omega(s_{t+1},\omega_t|s_t,\omega_{t+1})\)&lt;/span&gt;（详见附录）。&lt;/p&gt;
&lt;h2 id=&quot;termination-gradient-theorem&quot;&gt;Termination Gradient Theorem&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Theorem 2 (Termination Gradient Theorem).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出一组随机终止函数在其参数ϑ上可微的Markov期权，期望折现收益目标相对于ϑ和初始条件（s1，ω0）的梯度为：&lt;/p&gt;
&lt;p&gt;\[-\sum_{s',\omega}\mu_\Omega(s',\omega|s_1,\omega_0)\frac{\partial \beta_{\omega,\vartheta}(s')}{\partial\vartheta}A_\Omega(s',\omega) \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\mu_\omega(s',\omega|s_1,\omega_0)\)&lt;/span&gt; （s1，ω0）中状态选项对的贴现权重:&lt;/p&gt;
&lt;p&gt;\[\mu_\Omega(s,\omega|s_1,\omega_0)=\sum_{t=0}^\infty\gamma^tP(s_{t+1}=s,\omega+t=\omega|s_1,\omega_0) \]&lt;/p&gt;
&lt;p&gt;优势函数经常出现在政策梯度方法中（Sutton等人。2000年）在形成基线以减少梯度估计的方差时。它在这种情况下的出现主要与算法设计有关。有趣的是，在我们的例子中，它是推导的直接结果，并且给了定理一个直观的解释：当期权选择相对于所有期权的期望值是次优时，优势函数是负的，它推动梯度修正上升，这增加了终止的几率。终止后，代理有机会使用πΩ选择更好的选项。类似的想法也构成了期权的中断执行模型（Sutton，Precup，and Singh 1999），在该模型中，只要QΩ（s？，ω）对于电流选项ω小于VΩ（s？）。（Mann、Mankowitz和Mannor 2014）最近在数值迭代设置下，通过打断Bellman算子的镜头研究了中断选项。终止梯度定理可以解释为提供了一个基于梯度的中断Bellman算子。&lt;/p&gt;

&lt;p&gt;基于定理1和定理2，我们现在可以设计一个学习选项的随机梯度下降算法。利用双时间尺度框架（Konda和Tsitsiklis 2000），我们建议在快速的时间尺度上学习值，同时以较慢的速度更新内部期权策略和终止函数。&lt;/p&gt;
&lt;p&gt;我们将产生的系统称为一个选项批评家架构，参考actor-critical架构（Sutton 1984）。期权内策略、终止函数和期权上的策略属于系统的参与者部分，而批评家则由量子和AΩ组成。期权批评家体系结构没有规定如何获得πΩ，因为现有的各种方法都可以应用：在SMDP级别使用策略梯度方法，在期权模型上使用规划器，或者使用时间差分更新。如果πΩ是贪婪策略对期权，则由（2）得到相应的一步策略更新目标g（1）t为：&lt;/p&gt;
&lt;p&gt;\[g_t^{(1)}=r_{t+1}+\gamma\left( (1-\beta_{\omega_t,\vartheta}(s_{t+1}))\sum_a\pi_{\omega_t,\theta}(a|s_{t+1})Q_U(s_{t+1},\omega_t,a)\\ +\beta_{\omega_t,\vartheta}(s_{t+1})\mathop{\max}_\omega\sum_a\pi_{\omega_t,\theta}(a|s_{t+1})Q_U(s_{t+1},\omega,a)\right) \]&lt;/p&gt;
&lt;p&gt;这也是Sutton，Precup和Singh 1999的intra-option Q-learning算法的更新目标。算法1给出了一个使用选项内Q学习的option critic的原型实现。表格设置仅为清晰呈现而设。我们分别给出了批评家、期权内策略和终止函数的学习率的α、αθ和αϑ。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;image-20200724144437753&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学习QΩ的QUin加法在计算上浪费了大量的参数和样本。一个实际的解决方案是只学习QΩ并从中得到qu的估计值。因为屈是对下一个国家的期望， &lt;span class=&quot;math inline&quot;&gt;\(Q_U(s,\omega,a)=\mathbb{E}_{s'\sim P}[r(s,a)+\gamma U(\omega,s')|s,\omega,a]\)&lt;/span&gt; ，结果表明g（1）t是一个合适的估计量。我们选择这种方法作为我们在街机学习环境中使用深度神经网络的实验。&lt;/p&gt;

&lt;p&gt;我们首先考虑四个房间域中的导航任务（Sutton、Precup和Singh 1999）。我们的目标是评估一组完全自主学习的选项从环境的突然变化中恢复过来的能力。（Sutton，Precup，and Singh 1999）对一组预先指定的选项提出了一个类似的实验；我们的结果中的选项并不是事先指定的。&lt;/p&gt;
&lt;p&gt;最初目标位于东门，初始状态从所有其他单元统一绘制。1000集之后，目标移动到右下角房间的一个随机位置。原始移动可能以1/3的概率失败，在这种情况下，代理会随机过渡到一个空的相邻单元。折扣系数为0.99，进球时奖励为+1，否则奖励为0。我们选择用Boltzmann分布参数化期权内策略，用sigmoid函数参数化终止策略。利用期权内Q学习方法学习了期权优先策略。我们还使用Boltzmann策略实现了原始的actor-critic（表示为AC-PG）。我们还比较了期权评论家和原始的萨尔萨代理使用玻尔兹曼勘探和没有资格痕迹。对于所有的Boltzmann策略，我们将温度参数设置为0.001。所有的权重都被初始化为零。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;image-20200724150424942&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图2所示，当目标突然改变时，OptionCritic代理恢复得更快。此外，初始的选项集是从零开始学习的速度可与原始方法相媲美。尽管这个领域很简单，但我们还没有发现其他方法可以在不产生比单独使用原始操作时更大的成本的情况下解决这个任务（McGovern和Barto 2001；S¸ims¸ek和Barto 2009）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;image-20200724150457309&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在有4个选项和8个选项的两个临时扩展设置中，终止事件更可能发生在门口附近（图3），这与直觉一致，即它们是好的子目标。与（Sutton，Precup，and Singh 1999）相反，我们自己并没有对这些知识进行编码，而是让代理找到能够最大化预期贴现回报的选项。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47051292&quot;&gt;知乎 【强化学习算法20】option-critic&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Jul 2020 15:34:00 +0000</pubDate>
<dc:creator>米么裤</dc:creator>
<og:description>The option-critic architecture论文翻译与理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codonU/p/13375109.html</dc:identifier>
</item>
<item>
<title>全栈的自我修养: 0005 Java 包扫描实现和应用(Jar篇) - zyndev</title>
<link>http://www.cnblogs.com/zyndev/p/13374811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyndev/p/13374811.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;It's not the altitude, it's the attitude.&lt;/p&gt;&lt;p&gt;决定一切的不是高度而是态度。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246875/202007/1246875-20200724221028563-62249441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你曾经使用过 &lt;code&gt;Spring&lt;/code&gt;, 那你已经配过 包扫描路径吧，那包扫描是怎么实现的呢？让我们自己写个包扫描&lt;/p&gt;
&lt;p&gt;上篇文章中介绍了使用 &lt;code&gt;File&lt;/code&gt; 遍历的方式去进行包扫描，这篇主要补充一下&lt;code&gt;jar&lt;/code&gt;包的扫描方式，在我们的项目中一般都会去依赖一些其他&lt;code&gt;jar&lt;/code&gt; 包，&lt;/p&gt;
&lt;p&gt;比如添加 guava 依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;28.2-jre&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次运行上次的测试用例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testGetPackageAllClasses() throws IOException, ClassNotFoundException {
    ClassScanner scanner = new ClassScanner(&quot;com.google.common.cache&quot;, true, null, null);
    Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; packageAllClasses = scanner.doScanAllClasses();
    packageAllClasses.forEach(it -&amp;gt; {
        System.out.println(it.getName());
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么都没有输出&lt;/p&gt;

&lt;p&gt;基于&lt;code&gt;Java&lt;/code&gt; 的反射机制，我们很容易根据 &lt;code&gt;class&lt;/code&gt; 去创建一个实例对象，但如果我们根本不知道某个包下有多少对象时，我们应该怎么做呢？&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;Spring&lt;/code&gt;框架时，会根据包扫描路径来找到所有的 &lt;code&gt;class&lt;/code&gt;, 并将其实例化后存入容器中。&lt;/p&gt;
&lt;p&gt;在我们的项目中也会遇到这样的场景，比如某个包为 &lt;code&gt;org.example.plugins&lt;/code&gt;, 这个里面放着所有的插件，为了不每次增减插件都要手动修改代码，我们可能会想到用扫描的方式去动态获知 &lt;code&gt;org.example.plugins&lt;/code&gt; 到底有多少 class, 当然应用场景很有很多&lt;/p&gt;

&lt;p&gt;既然知道是采用了 &lt;code&gt;jar&lt;/code&gt; , 那我们使用遍历 jar 的方式去处理一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
JarFile jar = ((JarURLConnection) url.openConnection()).getJarFile();
// 遍历jar包中的元素
Enumeration&amp;lt;JarEntry&amp;gt; entries = jar.entries();

while (entries.hasMoreElements()) {
  JarEntry entry = entries.nextElement();
  String name = entry.getName();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里获取的name 格式为 &lt;code&gt;com/google/common/cache/Cache.class&lt;/code&gt; 是不是和上篇的文件路径很像呀, 这里可以通过对 &lt;code&gt;name&lt;/code&gt; 进行操作获取&lt;code&gt;包名&lt;/code&gt;和 &lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 获取包名
String jarPackageName = name.substring(0, name.lastIndexOf('/')).replace(&quot;/&quot;, &quot;.&quot;);

// 获取 class 路径, 这样就能通过类加载进行加载了
String className = name.replace('/', '.');
className = className.substring(0, className.length() - 6);
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doScanPackageClassesByJar(String basePackage, URL url, Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes)
    throws IOException, ClassNotFoundException {
  // 包名
  String packageName = basePackage;
  // 获取文件路径
  String basePackageFilePath = packageName.replace('.', '/');
  // 转为jar包
  JarFile jar = ((JarURLConnection) url.openConnection()).getJarFile();
  // 遍历jar包中的元素
  Enumeration&amp;lt;JarEntry&amp;gt; entries = jar.entries();
  while (entries.hasMoreElements()) {
    JarEntry entry = entries.nextElement();
    String name = entry.getName();
    // 如果路径不一致，或者是目录，则继续
    if (!name.startsWith(basePackageFilePath) || entry.isDirectory()) {
      continue;
    }
    // 判断是否递归搜索子包
    if (!recursive &amp;amp;&amp;amp; name.lastIndexOf('/') != basePackageFilePath.length()) {
      continue;
    }

    if (packagePredicate != null) {
      String jarPackageName = name.substring(0, name.lastIndexOf('/')).replace(&quot;/&quot;, &quot;.&quot;);
      if (!packagePredicate.test(jarPackageName)) {
        continue;
      }
    }

    // 判定是否符合过滤条件
    String className = name.replace('/', '.');
    className = className.substring(0, className.length() - 6);
    // 用当前线程的类加载器加载类
    Class&amp;lt;?&amp;gt; loadClass = Thread.currentThread().getContextClassLoader().loadClass(className);
    if (classPredicate == null || classPredicate.test(loadClass)) {
      classes.add(loadClass);
    }

  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在结合上篇中 &lt;code&gt;File&lt;/code&gt; 扫描方式就是完成的代码了&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.example;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Enumeration;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.function.Predicate;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * class 扫描器
 *
 * @author zhangyunan
 */
public class ClassScanner {

  private final String basePackage;
  private final boolean recursive;
  private final Predicate&amp;lt;String&amp;gt; packagePredicate;
  private final Predicate&amp;lt;Class&amp;gt; classPredicate;


  /**
   * Instantiates a new Class scanner.
   *
   * @param basePackage      the base package
   * @param recursive        是否递归扫描
   * @param packagePredicate the package predicate
   * @param classPredicate   the class predicate
   */
  public ClassScanner(String basePackage, boolean recursive, Predicate&amp;lt;String&amp;gt; packagePredicate,
    Predicate&amp;lt;Class&amp;gt; classPredicate) {
    this.basePackage = basePackage;
    this.recursive = recursive;
    this.packagePredicate = packagePredicate;
    this.classPredicate = classPredicate;
  }

  /**
   * Do scan all classes set.
   *
   * @return the set
   * @throws IOException            the io exception
   * @throws ClassNotFoundException the class not found exception
   */
  public Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; doScanAllClasses() throws IOException, ClassNotFoundException {

    Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = new LinkedHashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();

    String packageName = basePackage;

    // 如果最后一个字符是“.”，则去掉
    if (packageName.endsWith(&quot;.&quot;)) {
      packageName = packageName.substring(0, packageName.lastIndexOf('.'));
    }

    // 将包名中的“.”换成系统文件夹的“/”
    String basePackageFilePath = packageName.replace('.', '/');

    Enumeration&amp;lt;URL&amp;gt; resources = Thread.currentThread().getContextClassLoader().getResources(basePackageFilePath);
    while (resources.hasMoreElements()) {
      URL resource = resources.nextElement();
      String protocol = resource.getProtocol();
      if (&quot;file&quot;.equals(protocol)) {
        String filePath = URLDecoder.decode(resource.getFile(), &quot;UTF-8&quot;);
        // 扫描文件夹中的包和类
        doScanPackageClassesByFile(classes, packageName, filePath);
      } else if (&quot;jar&quot;.equals(protocol)) {
        doScanPackageClassesByJar(packageName, resource, classes);
      }
    }

    return classes;
  }

  private void doScanPackageClassesByJar(String basePackage, URL url, Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes)
    throws IOException, ClassNotFoundException {
    // 包名
    String packageName = basePackage;
    // 获取文件路径
    String basePackageFilePath = packageName.replace('.', '/');
    // 转为jar包
    JarFile jar = ((JarURLConnection) url.openConnection()).getJarFile();
    // 遍历jar包中的元素
    Enumeration&amp;lt;JarEntry&amp;gt; entries = jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry = entries.nextElement();
      String name = entry.getName();
      // 如果路径不一致，或者是目录，则继续
      if (!name.startsWith(basePackageFilePath) || entry.isDirectory()) {
        continue;
      }
      // 判断是否递归搜索子包
      if (!recursive &amp;amp;&amp;amp; name.lastIndexOf('/') != basePackageFilePath.length()) {
        continue;
      }

      if (packagePredicate != null) {
        String jarPackageName = name.substring(0, name.lastIndexOf('/')).replace(&quot;/&quot;, &quot;.&quot;);
        if (!packagePredicate.test(jarPackageName)) {
          continue;
        }
      }

      // 判定是否符合过滤条件
      String className = name.replace('/', '.');
      className = className.substring(0, className.length() - 6);
      // 用当前线程的类加载器加载类
      Class&amp;lt;?&amp;gt; loadClass = Thread.currentThread().getContextClassLoader().loadClass(className);
      if (classPredicate == null || classPredicate.test(loadClass)) {
        classes.add(loadClass);
      }

    }
  }

  /**
   * 在文件夹中扫描包和类
   */
  private void doScanPackageClassesByFile(Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes, String packageName, String packagePath)
    throws ClassNotFoundException {
    // 转为文件
    File dir = new File(packagePath);
    if (!dir.exists() || !dir.isDirectory()) {
      return;
    }
    // 列出文件，进行过滤
    // 自定义文件过滤规则
    File[] dirFiles = dir.listFiles((FileFilter) file -&amp;gt; {
      String filename = file.getName();

      if (file.isDirectory()) {
        if (!recursive) {
          return false;
        }

        if (packagePredicate != null) {
          return packagePredicate.test(packageName + &quot;.&quot; + filename);
        }
        return true;
      }

      return filename.endsWith(&quot;.class&quot;);
    });

    if (null == dirFiles) {
      return;
    }

    for (File file : dirFiles) {
      if (file.isDirectory()) {
        // 如果是目录，则递归
        doScanPackageClassesByFile(classes, packageName + &quot;.&quot; + file.getName(), file.getAbsolutePath());
      } else {
        // 用当前类加载器加载 去除 fileName 的 .class 6 位
        String className = file.getName().substring(0, file.getName().length() - 6);
        Class&amp;lt;?&amp;gt; loadClass = Thread.currentThread().getContextClassLoader().loadClass(packageName + '.' + className);
        if (classPredicate == null || classPredicate.test(loadClass)) {
          classes.add(loadClass);
        }
      }
    }
  }
}

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Jul 2020 14:11:00 +0000</pubDate>
<dc:creator>zyndev</dc:creator>
<og:description>全栈的自我修养: 0005 Java 包扫描实现和应用(Jar篇) It&amp;amp;#39;s not the altitude, it&amp;amp;#39;s the attitude. 决定一切的不是高</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyndev/p/13374811.html</dc:identifier>
</item>
</channel>
</rss>