<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>LFU五种实现方式，从简单到复杂 - 烟雨星空</title>
<link>http://www.cnblogs.com/starry-skys/p/12651282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starry-skys/p/12651282.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近刷力扣题，对于我这种 0 基础来说，真的是脑壳疼啊。这个月我估计都是中等和困难题，没有简单题了。&lt;/p&gt;
&lt;p&gt;幸好，力扣上有各种大牛给写题解。看着他们行云流水的代码，真的是羡慕不已。让我印象最深刻的就是人称 “甜姨” 的知心姐姐，还有名叫威哥的大哥。几乎每天他们的题解我都是必看的。&lt;/p&gt;
&lt;p&gt;甜姨的题解，虽然姿势很帅，但是对于我这种新手来说，感觉不是太友好，因为思路写的太少，不是很详细。所以，每次我看不明白的时候，都得反复看好几遍，才能想明白她代码中的思路。&lt;/p&gt;
&lt;p&gt;上个周末的一道题是，让实现一个 LFU 缓存算法。经过我几个小时的研究（其实，应该有8个小时以上了，没得办法啊，菜就得多勤奋咯），终于把甜姨的思路整明白了。为了便于以后自己复习，就把整个思路记下来了，并配上图示和大量代码注释，我相信对于跟我一样的新手来说，是非常友好的。&lt;/p&gt;
&lt;p&gt;经过甜姨同意，参考来源我也会贴出来：&lt;a href=&quot;https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/&quot;&gt;https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然，力扣要求是用时间复杂度 O(1) 来解，但是其它方式我感觉也有必要了解，毕竟是一个由浅到深的过程，自己实现一遍总归是好的。因此，我就把五种求解方式，从简单到复杂，都讲一遍。&lt;/p&gt;
&lt;h2 id=&quot;lfu实现&quot;&gt;LFU实现&lt;/h2&gt;
&lt;p&gt;力扣原题描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。

get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。
「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

示例：

LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回 1
cache.put(3, 3);    // 去除 key 2
cache.get(2);       // 返回 -1 (未找到key 2)
cache.get(3);       // 返回 3
cache.put(4, 4);    // 去除 key 1
cache.get(1);       // 返回 -1 (未找到 key 1)
cache.get(3);       // 返回 3
cache.get(4);       // 返回 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lfu-cache
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是要求我们设计一个 LFU 算法，根据访问次数（访问频次）大小来判断应该删除哪个元素，get和put操作都会增加访问频次。当访问频次相等时，就判断哪个元素是最久未使用过的，把它删除。&lt;/p&gt;
&lt;p&gt;因此，这道题需要考虑两个方面，一个是访问频次，一个是访问时间的先后顺序。&lt;/p&gt;
&lt;h3 id=&quot;方案一：使用优先队列&quot;&gt;方案一：使用优先队列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用JDK提供的优先队列 PriorityQueue 来实现 。 因为优先队列内部维护了一个二叉堆，即可以保证每次 poll 元素的时候，都可以根据我们的要求，取出当前所有元素的最大值或是最小值。只需要我们的实体类实现 Comparable 接口就可以了。&lt;/p&gt;
&lt;p&gt;因此，我们需要定义一个 Node 来保存当前元素的访问频次 freq，全局的自增的 index，用于比较大小。然后定义一个 Map&amp;lt;Integer,Node&amp;gt; cache ，用于存放元素的信息。&lt;/p&gt;
&lt;p&gt;当 cache 容量不足时，根据访问频次 freq 的大小来删除最小的 freq 。若相等，则删除 index 最小的，因为index是自增的，越大说明越是最近访问过的，越小说明越是很长时间没访问过的元素。&lt;/p&gt;
&lt;p&gt;因本质是用二叉堆实现，故时间复杂度为O(logn)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LFUCache4 {

    public static void main(String[] args) {
        LFUCache4 cache = new LFUCache4(2);
        cache.put(1, 1);
        cache.put(2, 2);
        // 返回 1
        System.out.println(cache.get(1));
        cache.put(3, 3);    // 去除 key 2
        // 返回 -1 (未找到key 2)
        System.out.println(cache.get(2));
        // 返回 3
        System.out.println(cache.get(3));
        cache.put(4, 4);    // 去除 key 1
        // 返回 -1 (未找到 key 1)
        System.out.println(cache.get(1));
        // 返回 3
        System.out.println(cache.get(3));
        // 返回 4
        System.out.println(cache.get(4));
    }

    //缓存了所有元素的node
    Map&amp;lt;Integer,Node&amp;gt; cache;
    //优先队列
    Queue&amp;lt;Node&amp;gt; queue;
    //缓存cache 的容量
    int capacity;
    //当前缓存的元素个数
    int size;
    //全局自增
    int index = 0;

    //初始化
    public LFUCache4(int capacity){
        this.capacity = capacity;
        if(capacity &amp;gt; 0){
            queue = new PriorityQueue&amp;lt;&amp;gt;(capacity);
        }
        cache = new HashMap&amp;lt;&amp;gt;();
    }

    public int get(int key){
        Node node = cache.get(key);
        // node不存在，则返回 -1
        if(node == null) return -1;
        //每访问一次，频次和全局index都自增 1
        node.freq++;
        node.index = index++;
        // 每次都重新remove，再offer是为了让优先队列能够对当前Node重排序
        //不然的话，比较的 freq 和 index 就是不准确的
        queue.remove(node);
        queue.offer(node);
        return node.value;
    }

    public void put(int key, int value){
        //容量0，则直接返回
        if(capacity == 0) return;
        Node node = cache.get(key);
        //如果node存在，则更新它的value值
        if(node != null){
            node.value = value;
            node.freq++;
            node.index = index++;
            queue.remove(node);
            queue.offer(node);
        }else {
            //如果cache满了，则从优先队列中取出一个元素，这个元素一定是频次最小，最久未访问过的元素
            if(size == capacity){
                cache.remove(queue.poll().key);
                //取出元素后，size减 1
                size--;
            }
            //否则，说明可以添加元素，于是创建一个新的node，添加到优先队列中
            Node newNode = new Node(key, value, index++);
            queue.offer(newNode);
            cache.put(key,newNode);
            //同时，size加 1
            size++;
        }
    }


    //必须实现 Comparable 接口才可用于排序
    private class Node implements Comparable&amp;lt;Node&amp;gt;{
        int key;
        int value;
        int freq = 1;
        int index;

        public Node(){

        }

        public Node(int key, int value, int index){
            this.key = key;
            this.value = value;
            this.index = index;
        }

        @Override
        public int compareTo(Node o) {
            //优先比较频次 freq，频次相同再比较index
            int minus = this.freq - o.freq;
            return minus == 0? this.index - o.index : minus;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方案二：使用一条双向链表&quot;&gt;方案二：使用一条双向链表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只用一条双向链表，来维护频次和时间先后顺序。那么，可以这样想。把频次 freq 小的放前面，频次大的放后面。如果频次相等，就从当前节点往后遍历，直到找到第一个频次比它大的元素，并插入到它前面。（当然，如果遍历到了tail，则插入到tail前面）这样可以保证同频次的元素，最近访问的总是在最后边。&lt;/p&gt;
&lt;p&gt;因此，总的来说，最低频次，并且最久未访问的元素肯定就是链表中最前面的那一个了。这样的话，当 cache容量满的时候，直接把头结点删除掉就可以了。但是，我们这里为了方便链表的插入和删除操作，用了两个哨兵节点，来表示头节点 head和尾结点tail。因此，删除头结点就相当于删除 head.next。&lt;/p&gt;
&lt;p&gt;PS：哨兵节点只是为了占位，实际并不存储有效数据，只是为了链表插入和删除时，不用再判断当前节点的位置。不然的话，若当前节点占据了头结点或尾结点的位置，还需要重新赋值头尾节点元素，较麻烦。&lt;/p&gt;
&lt;p&gt;为了便于理解新节点如何插入到链表中合适的位置，作图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1714084/202004/1714084-20200407083819984-537781974.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LFUCache {

    public static void main(String[] args) {
        LFUCache cache = new LFUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        // 返回 1
        System.out.println(cache.get(1));
        cache.put(3, 3);    // 去除 key 2
        // 返回 -1 (未找到key 2)
        System.out.println(cache.get(2));
        // 返回 3
        System.out.println(cache.get(3));
        cache.put(4, 4);    // 去除 key 1
        // 返回 -1 (未找到 key 1)
        System.out.println(cache.get(1));
        // 返回 3
        System.out.println(cache.get(3));
        // 返回 4
        System.out.println(cache.get(4));

    }

    private Map&amp;lt;Integer,Node&amp;gt; cache;
    private Node head;
    private Node tail;
    private int capacity;
    private int size;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap&amp;lt;&amp;gt;();
        /**
         * 初始化头结点和尾结点，并作为哨兵节点
         */
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if(node == null) return -1;
        node.freq++;
        moveToPostion(node);
        return node.value;
    }

    public void put(int key, int value) {
        if(capacity == 0) return;
        Node node = cache.get(key);
        if(node != null){
            node.value = value;
            node.freq++;
            moveToPostion(node);
        }else{
            //如果元素满了
            if(size == capacity){
                //直接移除最前面的元素，因为这个节点就是频次最小，且最久未访问的节点
                cache.remove(head.next.key);
                removeNode(head.next);
                size--;
            }
            Node newNode = new Node(key, value);
            //把新元素添加进来
            addNode(newNode);
            cache.put(key,newNode);
            size++;
        }
    }

    //只要当前 node 的频次大于等于它后边的节点，就一直向后找，
    // 直到找到第一个比当前node频次大的节点，或者tail节点，然后插入到它前面
    private void moveToPostion(Node node){
        Node nextNode = node.next;
        //先把当前元素删除
        removeNode(node);
        //遍历到符合要求的节点
        while (node.freq &amp;gt;= nextNode.freq &amp;amp;&amp;amp; nextNode != tail){
            nextNode = nextNode.next;
        }
        //把当前元素插入到nextNode前面
        node.pre = nextNode.pre;
        node.next = nextNode;
        nextNode.pre.next = node;
        nextNode.pre = node;

    }

    //添加元素（头插法），并移动到合适的位置
    private void addNode(Node node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
        moveToPostion(node);
    }

    //移除元素
    private void removeNode(Node node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    class Node {
        int key;
        int value;
        int freq = 1;
        //当前节点的前一个节点
        Node pre;
        //当前节点的后一个节点
        Node next;

        public Node(){

        }

        public Node(int key ,int value){
            this.key = key;
            this.value = value;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到不管是插入元素还是删除元素时，都不需要额外的判断，这就是设置哨兵节点的好处。&lt;/p&gt;
&lt;p&gt;由于每次访问元素的时候，都需要按一定的规则把元素放置到合适的位置，因此，元素需要从前往后一直遍历。所以，时间复杂度 O(n)。&lt;/p&gt;
&lt;h3 id=&quot;方案三：用-linkedhashset维护频次链表&quot;&gt;方案三：用 LinkedHashSet维护频次链表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们不再使用一条链表，同时维护频次和访问时间了。此处，换为用 map 键值对来维护，用频次作为键，用当前频次对应的一条具有先后访问顺序的链表来作为值。它的结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Map&amp;lt;Integer, LinkedHashSet&amp;lt;Node&amp;gt;&amp;gt; freqMap
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1714084/202004/1714084-20200407083820343-396598353.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于LinkedHashSet 的 iterator迭代方法是按插入顺序的，因此迭代到的第一个元素肯定是当前频次下，最久未访问的元素。这样的话，当缓存 cache满的时候，直接删除迭代到的第一个元素就可以了。&lt;/p&gt;
&lt;p&gt;另外 freqMap，也需要在每次访问元素的时候，重新维护关系。从当前元素的频次对应的双向链表中移除当前元素，并加入到高频次的链表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LFUCache1 {

    public static void main(String[] args) {
        LFUCache1 cache = new LFUCache1(2);
        cache.put(1, 1);
        cache.put(2, 2);
        // 返回 1
        System.out.println(cache.get(1));
        cache.put(3, 3);    // 去除 key 2
        // 返回 -1 (未找到key 2)
        System.out.println(cache.get(2));
        // 返回 3
        System.out.println(cache.get(3));
        cache.put(4, 4);    // 去除 key 1
        // 返回 -1 (未找到 key 1)
        System.out.println(cache.get(1));
        // 返回 3
        System.out.println(cache.get(3));
        // 返回 4
        System.out.println(cache.get(4));
    }

    //缓存 cache
    private Map&amp;lt;Integer,Node&amp;gt; cache;
    //存储频次和对应双向链表关系的map
    private Map&amp;lt;Integer, LinkedHashSet&amp;lt;Node&amp;gt;&amp;gt; freqMap;
    private int capacity;
    private int size;
    //存储最小频次值
    private int min;

    public LFUCache1(int capacity) {
        this.capacity = capacity;
        cache = new HashMap&amp;lt;&amp;gt;();
        freqMap = new HashMap&amp;lt;&amp;gt;();
    }

    public int get(int key) {
        Node node = cache.get(key);
        if(node == null) return -1;
        //若找到当前元素，则频次加1
        freqInc(node);
        return node.value;
    }

    public void put(int key, int value) {
        if(capacity == 0) return;
        Node node = cache.get(key);
        if(node != null){
            node.value = value;
            freqInc(node);
        }else{
            if(size == capacity){
                Node deadNode = removeNode();
                cache.remove(deadNode.key);
                size --;
            }
            Node newNode = new Node(key,value);
            cache.put(key,newNode);
            addNode(newNode);
            size++;
        }
    }

    //处理频次map
    private void freqInc(Node node){
        //从原来的频次对应的链表中删除当前node
        LinkedHashSet&amp;lt;Node&amp;gt; set = freqMap.get(node.freq);
        if(set != null)
            set.remove(node);
        //如果当前频次是最小频次，并且移除元素后，链表为空，则更新min值
        if(node.freq == min &amp;amp;&amp;amp; set.size() == 0){
            min = node.freq + 1;
        }
        //添加到新的频次对应的链表
        node.freq ++;
        LinkedHashSet&amp;lt;Node&amp;gt; newSet = freqMap.get(node.freq);
        //如果高频次链表还未存在，则初始化一条
        if(newSet == null){
            newSet = new LinkedHashSet&amp;lt;Node&amp;gt;();
            freqMap.put(node.freq,newSet);
        }
        newSet.add(node);
    }

    //添加元素，更新频次
    private void addNode(Node node){
        //添加新元素，肯定是需要加入到频次为1的链表中的
        LinkedHashSet&amp;lt;Node&amp;gt; set = freqMap.get(1);
        if(set == null){
            set = new LinkedHashSet&amp;lt;&amp;gt;();
            freqMap.put(1,set);
        }
        set.add(node);
        //更新最小频次为1
        min = 1;
    }

    //删除频次最小，最久未访问的元素
    private Node removeNode(){
        //找到最小频次对应的 LinkedHashSet
        LinkedHashSet&amp;lt;Node&amp;gt; set = freqMap.get(min);
        //迭代到的第一个元素就是最久未访问的元素，移除之
        Node node = set.iterator().next();
        set.remove(node);
        //如果当前node的频次等于最小频次，并且移除元素之后，set为空，则 min 加1
        if(node.freq == min &amp;amp;&amp;amp; set.size() == 0){
            min ++;
        }
        return node;
    }

    private class Node {
        int key;
        int value;
        int freq = 1;

        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }

        public Node(){

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方案四：手动实现一个频次链表&quot;&gt;方案四：手动实现一个频次链表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于方案三用的是JDK自带的 LinkedHashSet ，其是实现了哈希表和双向链表的一个类，因此为了减少哈希相关的计算，提高效率，我们自己实现一条双向链表来替代它。&lt;/p&gt;
&lt;p&gt;那么，这条双向链表，就需要维护当前频次下的所有元素的先后访问顺序。我们采用头插法，把新加入的元素添加到链表头部，这样的话，最久未访问的元素就在链表的尾部。&lt;/p&gt;
&lt;p&gt;同样的，我们也用两个哨兵节点来代表头尾节点，以方便链表的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1714084/202004/1714084-20200407083820772-837972702.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LFUCache2 {

    public static void main(String[] args) {
        LFUCache2 cache = new LFUCache2(2);
        cache.put(1, 1);
        cache.put(2, 2);
        // 返回 1
        System.out.println(cache.get(1));
        cache.put(3, 3);    // 去除 key 2
        // 返回 -1 (未找到key 2)
        System.out.println(cache.get(2));
        // 返回 3
        System.out.println(cache.get(3));
        cache.put(4, 4);    // 去除 key 1
        // 返回 -1 (未找到 key 1)
        System.out.println(cache.get(1));
        // 返回 3
        System.out.println(cache.get(3));
        // 返回 4
        System.out.println(cache.get(4));
    }

    private Map&amp;lt;Integer,Node&amp;gt; cache;
    private Map&amp;lt;Integer,DoubleLinkedList&amp;gt; freqMap;
    private int capacity;
    private int size;
    private int min;

    public LFUCache2(int capacity){
        this.capacity = capacity;
        cache = new HashMap&amp;lt;&amp;gt;();
        freqMap = new HashMap&amp;lt;&amp;gt;();
    }

    public int get(int key){
        Node node = cache.get(key);
        if(node == null) return -1;
        freqInc(node);
        return node.value;
    }

    public void put(int key, int value){
        if(capacity == 0) return;
        Node node = cache.get(key);
        if(node != null){
            node.value = value; //更新value值
            freqInc(node);
        }else{
            //若size达到最大值，则移除频次最小，最久未访问的元素
            if(size == capacity){
                //因链表是头插法，所以尾结点的前一个节点就是最久未访问的元素
                DoubleLinkedList list = freqMap.get(min);
                //需要移除的节点
                Node deadNode = list.tail.pre;
                cache.remove(deadNode.key);
                list.removeNode(deadNode);
                size--;
            }
            //新建一个node，并把node放到频次为 1 的 list 里面
            Node newNode = new Node(key,value);
            DoubleLinkedList newList = freqMap.get(1);
            if(newList == null){
                newList = new DoubleLinkedList();
                freqMap.put(1,newList);
            }
            newList.addNode(newNode);
            cache.put(key,newNode);
            size++;
            min = 1;//此时需要把min值重新设置为1
        }

    }

    //修改频次
    private void freqInc(Node node){
        //先删除node对应的频次list
        DoubleLinkedList list = freqMap.get(node.freq);
        if(list != null){
            list.removeNode(node);
        }
        //判断min是否等于当前node的频次，且当前频次的list为空，是的话更新min值
        if(min == node.freq &amp;amp;&amp;amp; list.isEmpty()){
            min ++;
        }
        //然后把node频次加 1，并把它放到高频次list
        node.freq ++;
        DoubleLinkedList newList = freqMap.get(node.freq);
        if(newList == null){
            newList = new DoubleLinkedList();
            freqMap.put(node.freq, newList);
        }
        newList.addNode(node);
    }


    private class Node {
        int key;
        int value;
        int freq = 1;
        Node pre;
        Node next;

        public Node(){

        }

        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }

    //自实现的一个双向链表
    private class DoubleLinkedList {
        Node head;
        Node tail;

        // 设置两个哨兵节点，作为头、尾节点便于插入和删除操作
        public DoubleLinkedList(){
            head = new Node();
            tail = new Node();
            head.next = tail;
            tail.pre = head;
        }

        //采用头插法，每次都插入到链表的最前面，即 head 节点后边
        public void addNode(Node node){
            node.pre = head;
            node.next = head.next;
            //注意先把head的后节点的前节点设置为node
            head.next.pre = node;
            head.next = node;
        }

        //删除元素
        public void removeNode(Node node){
            node.pre.next = node.next;
            node.next.pre = node.pre;
        }

        //判断是否为空，即是否存在除了哨兵节点外的有效节点
        public boolean isEmpty(){
            //判断头结点的下一个节点是否是尾结点，是的话即为空
            return head.next == tail;
        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方案五：用双向链表嵌套&quot;&gt;方案五：用双向链表嵌套&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以发现方案三和方案四，都是用 freqmap 来存储频次和它对应的链表之间的关系，它本身也是一个哈希表。这次，我们完全用自己实现的双向链表来代替 freqMap，进一步提高效率。&lt;/p&gt;
&lt;p&gt;但是，结构有些复杂，它是一个双向链表中，每个元素又是双向链表。为了便于理解，我把它的结构作图如下：（为了方便，分别叫做外层链表，内层链表）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1714084/202004/1714084-20200407083821279-1969086043.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把整体看成一个由 DoubleLinkedList组成的双向链表，然后，每一个 DoubleLinkedList 对象中又是一个由 Node 组成的双向链表。像极了 HashMap 数组加链表的形式。&lt;/p&gt;
&lt;p&gt;但是，我们这里没有数组，也就不存在哈希碰撞的问题。并且都是双向链表，都有哨兵存在，便于灵活的从链表头部或者尾部开始操作元素。&lt;/p&gt;
&lt;p&gt;这里，firstLinkedList 和 lastLinkedList 分别代表外层链表的头尾结点。链表中的元素 DoubleLinkedList 有一个字段 freq 记录了频次，并且按照前大后小的顺序组成外层链表，即图中的 DoubleLinkedList1.freq 大于它后面的 DoubleLinkedList2.freq。&lt;/p&gt;
&lt;p&gt;每当有新频次的 DoubleLinkedList 需要添加进来的时候，直接插入到 lastLinkedList 这个哨兵前面，因此 lastLinkedList.pre 就是一个最小频次的内部链表。&lt;/p&gt;
&lt;p&gt;内部链表中是由 Node组成的双向链表，也有两个哨兵代表头尾节点，并采用头插法。其实，可以看到内部链表和方案四，图中所示的双向链表结构是一样的，不用多说了。&lt;/p&gt;
&lt;p&gt;这样的话，我们就可以找到频次最小，并且最久未访问的元素，即&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//频次最小，最久未访问的元素，cache满时需要删除
lastLinkedList.pre.tail.pre
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，代码就好理解了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LFUCache3 {

    public static void main(String[] args) {
        LFUCache3 cache = new LFUCache3(2);
        cache.put(1, 1);
        cache.put(2, 2);
        // 返回 1
        System.out.println(cache.get(1));
        cache.put(3, 3);    // 去除 key 2
        // 返回 -1 (未找到key 2)
        System.out.println(cache.get(2));
        // 返回 3
        System.out.println(cache.get(3));
        cache.put(4, 4);    // 去除 key 1
        // 返回 -1 (未找到 key 1)
        System.out.println(cache.get(1));
        // 返回 3
        System.out.println(cache.get(3));
        // 返回 4
        System.out.println(cache.get(4));
    }

    Map&amp;lt;Integer,Node&amp;gt; cache;
    /**
     * 这两个代表的是以 DoubleLinkedList 连接成的双向链表的头尾节点，
     * 且为哨兵节点。每个list中，又包含一个由 node 组成的一个双向链表。
     * 最外层双向链表中，freq 频次较大的 list 在前面，较小的 list 在后面
     */
    DoubleLinkedList firstLinkedList, lastLinkedList;
    int capacity;
    int size;

    public LFUCache3(int capacity){
        this.capacity = capacity;
        cache = new HashMap&amp;lt;&amp;gt;();
        //初始化外层链表的头尾节点，作为哨兵节点
        firstLinkedList = new DoubleLinkedList();
        lastLinkedList = new DoubleLinkedList();
        firstLinkedList.next = lastLinkedList;
        lastLinkedList.pre = firstLinkedList;
    }

    //存储具体键值对信息的node
    private class Node {
        int key;
        int value;
        int freq = 1;
        Node pre;
        Node next;
        DoubleLinkedList doubleLinkedList;

        public Node(){

        }

        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }

    public int get(int key){
        Node node = cache.get(key);
        if(node == null) return -1;
        freqInc(node);
        return node.value;
    }

    public void put(int key, int value){
        if(capacity == 0) return;
        Node node = cache.get(key);
        if(node != null){
            node.value = value;
            freqInc(node);
        }else{
            if(size == capacity){
                /**
                 * 如果满了，则需要把频次最小的，且最久未访问的节点删除
                 * 由于list组成的链表频次从前往后依次减小，故最小的频次list是 lastLinkedList.pre
                 * list中的双向node链表采用的是头插法，因此最久未访问的元素是 lastLinkedList.pre.tail.pre
                 */
                //最小频次list
                DoubleLinkedList list = lastLinkedList.pre;
                //最久未访问的元素，需要删除
                Node deadNode = list.tail.pre;
                cache.remove(deadNode.key);
                list.removeNode(deadNode);
                size--;
                //如果删除deadNode之后，此list中的双向链表空了，则删除此list
                if(list.isEmpty()){
                    removeDoubleLinkedList(list);
                }
            }
            //没有满，则新建一个node
            Node newNode = new Node(key, value);
            cache.put(key,newNode);
            //判断频次为1的list是否存在，不存在则新建
            DoubleLinkedList list = lastLinkedList.pre;
            if(list.freq != 1){
                DoubleLinkedList newList = new DoubleLinkedList(1);
                addDoubleLinkedList(newList,list);
                newList.addNode(newNode);
            }else{
                list.addNode(newNode);
            }
            size++;
        }
    }

    //修改频次
    private void freqInc(Node node){
        //从当前频次的list中移除当前 node
        DoubleLinkedList list = node.doubleLinkedList;
        if(list != null){
            list.removeNode(node);
        }
        //如果当前list中的双向node链表空，则删除此list
        if(list.isEmpty()){
            removeDoubleLinkedList(list);
        }
        //当前node频次加1
        node.freq++;
        //找到当前list前面的list，并把当前node加入进去
        DoubleLinkedList preList = list.pre;
        //如果前面的list不存在，则新建一个，并插入到由list组成的双向链表中
        //前list的频次不等于当前node频次，则说明不存在
        if(preList.freq != node.freq){
            DoubleLinkedList newList = new DoubleLinkedList(node.freq);
            addDoubleLinkedList(newList,preList);
            newList.addNode(node);
        }else{
            preList.addNode(node);
        }

    }

    //从外层双向链表中删除当前list节点
    public void removeDoubleLinkedList(DoubleLinkedList list){
        list.pre.next = list.next;
        list.next.pre = list.pre;
    }

    //知道了它的前节点，即可把新的list节点插入到其后面
    public void addDoubleLinkedList(DoubleLinkedList newList, DoubleLinkedList preList){
        newList.pre = preList;
        newList.next = preList.next;
        preList.next.pre = newList;
        preList.next = newList;
    }

    //维护一个双向DoubleLinkedList链表 + 双向Node链表的结构
    private class DoubleLinkedList {
        //当前list中的双向Node链表所有频次都相同
        int freq;
        //当前list中的双向Node链表的头结点
        Node head;
        //当前list中的双向Node链表的尾结点
        Node tail;
        //当前list的前一个list
        DoubleLinkedList pre;
        //当前list的后一个list
        DoubleLinkedList next;

        public DoubleLinkedList(){
            //初始化内部链表的头尾节点，并作为哨兵节点
            head = new Node();
            tail = new Node();
            head.next = tail;
            tail.pre = head;
        }

        public DoubleLinkedList(int freq){
            head = new Node();
            tail = new Node();
            head.next = tail;
            tail.pre = head;
            this.freq = freq;
        }

        //删除当前list中的某个node节点
        public void removeNode(Node node){
            node.pre.next = node.next;
            node.next.pre = node.pre;
        }

        //头插法将新的node插入到当前list，并在新node中记录当前list的引用
        public void addNode(Node node){
            node.pre = head;
            node.next = head.next;
            head.next.pre = node;
            head.next = node;
            node.doubleLinkedList = this;
        }

        //当前list中的双向node链表是否存在有效节点
        public boolean isEmpty(){
            //只有头尾哨兵节点，则说明为空
            return head.next == tail;
        }
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于，此方案全是链表的增删操作，因此时间复杂度可到 O(1)。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;终于总结完了，其实，感觉思想搞明白了，代码实现起来就相对容易一些。但是，还是需要多写，多实践。过段时间再来回顾一下~&lt;/p&gt;
</description>
<pubDate>Tue, 07 Apr 2020 00:38:00 +0000</pubDate>
<dc:creator>烟雨星空</dc:creator>
<og:description>前言 最近刷力扣题，对于我这种 0 基础来说，真的是脑壳疼啊。这个月我估计都是中等和困难题，没有简单题了。 幸好，力扣上有各种大牛给写题解。看着他们行云流水的代码，真的是羡慕不已。让我印象最深刻的就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/starry-skys/p/12651282.html</dc:identifier>
</item>
<item>
<title>从火车站车次公示栏来学Java读写锁 - kaizi1992</title>
<link>http://www.cnblogs.com/kaigejava/p/12651268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaigejava/p/12651268.html</guid>
<description>&lt;p&gt;Java多线程并发之读写锁&lt;/p&gt;
&lt;p&gt;本文主要内容：读写锁的理论；通过生活中例子来理解读写锁；读写锁的代码演示；读写锁总结。通过理论(总结)-例子-代码-然后再次总结，这四个步骤来让大家对读写锁的深刻理解。&lt;/p&gt;
&lt;p&gt;本篇是《凯哥(凯哥Java:kagejava)并发编程学习》系列之《Lock系列》教程的第七篇：《Java并发包下锁学习第七篇：读写锁》。&lt;/p&gt;

&lt;h2&gt;什么是读写锁？&lt;/h2&gt;
&lt;p&gt;多个线程同时读一个资源类是没有任何问题的，所以为了满足在并发的情况下，读取共享资源应该是可以同时进行的；但是，如果一个线程想要去写共享资源，就不应该再有其他线程可以对该共享资源进行读或者是写操作了。&lt;/p&gt;
&lt;p&gt;即读写锁在同一时刻可以允许多个多线程访问，但是在写线程访问的时候，所有的读线程和其他写线程都会被阻塞。读写锁实际维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得其并发性比独占式锁(排他锁)有了很大的提升。&lt;/p&gt;
&lt;h2&gt;为什么需要读写锁？&lt;/h2&gt;
&lt;p&gt;通过前面文章的学习，我们知道了ReentrantLock(下文简称：RLock)对象了。Rlock比起synchronized(下文简称Sync)来说有三个优点：RLock可以被中断；RLock可以有公平锁；RLock可以绑定多个条件。那么既然RLock比Sync有这么多优点，为什么还需要读写锁呢？&lt;/p&gt;
&lt;p&gt;那是因为RLock是独占式(排他) 锁，即当线程1获取到资源的时候，其他线程不能再来操作共享资源了。就算是RLock的操作是读取的时候，其他线程也不能读取共享资源的操作。这在现实生活中是不符合逻辑的(在下文神话中读写锁的例子中我们就能体会到为什么不符合逻辑的)，而且性能也比较慢。所以就有了读写锁的出现。&lt;/p&gt;

&lt;h2&gt;生活中读写锁的例子&lt;/h2&gt;
&lt;p&gt;例子一：我们大家去火车站乘车的时候，有个大大的公示屏幕，会告诉大家当前车次是否晚点。显示屏是给给所有乘客看的，如果火车晚点，对应车次后面就会被修改成晚点大约xxx分钟。这个修改的动作只能是火车站内部人员来操作的，我们乘客是不能操作的。这个过程，站在并发角度来分析的的话：电子屏幕是共享数据；千千万万的乘客是不同的线程；火车站内部工作人员也是不同的线程；乘客是读资源的线程，当一个线程来读取的时候，其他线程也可以读取操作的；火车站内部工作人员修改火车信息的时候，同时只能有一个工作人员来修改，不能两个都来修改。如果两个都来修改的话，上一秒显示晚点1min，下一秒显示正常。这个是不行的，乘客有可能会错过乘车的。所以修改的时候同时只能由一个工作人员来修改。&lt;/p&gt;
&lt;p&gt;例子二：我们在玩王者荣耀的时候，有时候会遇到停服更新的。在不更新前，所有玩家都可以玩，当停服更新的时候，所有玩家就不能玩了。这个操作在并发角度来说：千千万万的玩家是读共享资源的；游戏维护者是写操作的。当停服更新的时候，读操作就被阻塞了，只能等写操作，也就是更新完成后，才可以接着玩。&lt;/p&gt;
&lt;p&gt;通过上面两个例子我们可以分析到读写锁的三个参与者：共享资源;读对象;写对象。而且读和写一般是分离的。&lt;/p&gt;

&lt;p&gt;我们就用火车站进站案例来模拟：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAgzLcES&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;未使用锁的时候&lt;/p&gt;
&lt;p&gt;先来看看屏幕对象：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAhLGfvU&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再来看看多个工作人员更新操作及多个乘客获取操作：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAhq5rLU&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAiDUzk8&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从运行结果中，我们可以发现当工号未13的还没有更新完车次信息的时候，工号12和14的员工也来更新了。这种操作是不允许的。因为写操作要原子性，要独占。当工作人员甲在修改的时候车次信息的时候，其他工作人员不能同时修改同一个车次信息了。而且从乘客获取车次信息的数据来看，获取到的只是工号是13的。这个时候获取到的数据不一定是正确的了。所以，不使用锁是不行的。&lt;/p&gt;
&lt;p&gt;使用排他锁&lt;/p&gt;
&lt;p&gt;如果使用独占式做的话，我们查看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAilq2k4&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从运行结果来看，再读取的时候，需要一个一个读取的。当16号乘客查看的时候，17号乘客是不能查看的。这个是不符合实际业务逻辑的。所以，独占式(排他锁)RLock在这里不适合。我们再来看看读写锁：&lt;/p&gt;
&lt;p&gt;使用读写锁&lt;/p&gt;
&lt;p&gt;先来看看使用读写锁的屏幕对象&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAjSRyNs&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再来看看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAjzfCVc&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从运行结果中，我们可以看到，工作人员是一个一个的操作完成的。当14号操作完成之后，13号和12号才可以操作的。这个符号我们正常的业务。乘客读取的时候，读取到的都是最后一次更新，这个也符合我们的业务。所以，通过读写锁来操作车站屏幕是可以的。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAkI7yHA&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;4.1：wrLock类对象&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAm1H8xE&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同样包含了公平锁和非公平锁。&lt;/p&gt;
&lt;p&gt;其中ReadLock是读锁对象；WriteLock是写锁对象。&lt;/p&gt;
&lt;h2&gt;4.2：使用语法&lt;/h2&gt;
&lt;p&gt;读操作使用ReadLock&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAmRfldg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编辑&lt;/p&gt;
&lt;p&gt;写操作的时候，使用WriteLock对象：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://si1.go2yd.com//get-image/0fiRAnIS67M&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.3:总结&lt;/h2&gt;
&lt;p&gt;读写锁(ReentrantReadWriteLock),凯哥就简写rwLock。也可以实现公平和非公平的。其内部维护了一对锁：一个读锁(ReadLock对象)，一个写锁(writeLock对象)，通过读写分离的方式来提高并发性能。读写锁也叫共享锁。其共享是在读数据的时候，可以让多个线程同时进行读操作的。在写的时候具有排他性，其他读或者写操作都要被阻塞。&lt;/p&gt;
&lt;p&gt;一般情况下，读写锁的性能都会比排他锁性能好，那是因为，大多数场景读操作多于写操作的。在读多与写的场景下，读写锁能够提供比排他锁更好的并性能和吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kaigejava.com/gwjeesns/res/new20190908ui/images/wx.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​    ​欢迎来聊~&lt;/p&gt;

</description>
<pubDate>Tue, 07 Apr 2020 00:34:00 +0000</pubDate>
<dc:creator>kaizi1992</dc:creator>
<og:description>Java多线程并发之读写锁 本文主要内容：读写锁的理论；通过生活中例子来理解读写锁；读写锁的代码演示；读写锁总结。通过理论(总结)-例子-代码-然后再次总结，这四个步骤来让大家对读写锁的深刻理解。 本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kaigejava/p/12651268.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（2）——伪类和伪元素 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12519389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12519389.html</guid>
<description>&lt;p&gt;　　伪选择器弥补了常规选择器的不足，能够实现一些特殊情况下的样式，例如在鼠标悬停时或只给字符串中的第一个字符指定样式。与类选择器类似，可以从HTML元素的class属性中查看到，但伪选择器不会出现在HTML文档中（有几个例外,如:lang、::placeholder等）。并且它的关键字大小写不敏感，也就是说empty和EMPTY完全相同。伪选择器分为两种：伪类选择器和伪元素选择器。注意，伪选择器会以一个或两个冒号（:）开头，并且如果要与其它选择器组合使用，那么只能与类型选择器（即元素名）搭配。&lt;/p&gt;
&lt;p&gt;　　本节要介绍的是伪选择器的第一种：伪类选择器（pseudo-class selector），它用于描述元素的动态特征，再根据元素的特殊状态来选择元素，常用的有结构、链接和表单等伪类。注意，伪类只对它依附的元素起作用，并且多个伪类可拼接在一起。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）结构伪类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CSS3新增了许多与结构相关的伪类，例如:root和:empty。:root会匹配文档的根元素，而在HTML文档中，根元素是html。&lt;/p&gt;
&lt;p&gt;　　:empty匹配没有子元素的元素，包括文本节点，但不包括注释。下面三个p元素，只有第一个和第三个符合:empty的匹配条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;注释&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:first-child匹配一组兄弟元素中的第一个元素，而:last-child可匹配其中的最后一个。:first-of-type匹配一组兄弟元素中的某种类型的第一个元素，而:last-of-type可匹配其中的最后一个。&lt;/p&gt;
&lt;p&gt;　　以下面的HTML结构为例，p是三个元素中的第一个，因此可以使用p:first-child；而div并不在第一的位置上，因此div:first-child无效；但是div是该类型的第一个元素，因此可用:first-of-type匹配。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p:first-child &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  div:first-child &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  div:first-of-type &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #666&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:only-child匹配没有兄弟的元素，即该元素是另一个元素的唯一子元素。例如下面有两个p元素，采用:only-child伪类时，只有第一个符合匹配条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p:only-child &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，将:first-child和:last-child两个伪类拼接，其效果相当于:only-child。&lt;/p&gt;
&lt;p&gt;　　:only-of-type匹配没有相同类型的兄弟元素，如果将:only-of-type依附到上面HTML结构中的p元素上，那么两个p元素都能匹配。&lt;/p&gt;
&lt;p&gt;　　:nth-child()会找出该元素的所有兄弟元素，然后按照位置匹配。它类似于一个函数，可接收整数和表达式，并将计算结果作为元素所处的位置。下面有3个li元素，:nth-child(1)匹配第一个元素，相当于:first-child；第二个:nth-child()伪类接收一个2n表达式，其中n的取值从0开始，一直到无穷大，2n表示取偶数位置的li元素，下面的li元素只有第二个符合条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  li:nth-child(1) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #666&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  li:nth-child(2n) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:nth-last-child()的功能与:nth-child()类似，只是地从后往前匹配。&lt;/p&gt;
&lt;p&gt;　　:nth-of-type()的功能与:nth-child()相似，但需要限制元素类型（即匹配相同类型的元素），它可接收的参数与:nth-child()相同。以下面的HTML结构为例，p:nth-of-type(2n)会先过滤出p元素，然后再匹配偶数位置的p元素。虽然第一个p元素在HTML结构中所处的是偶数位置，但是在同类型的兄弟元素中所处的却是奇数位置，因此无法匹配。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p:nth-of-type(2n) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　与:nth-of-type()对应的是:nth-last-of-type()，需要从后往前匹配。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）链接伪类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在链接元素中，常用的4个伪类有未访问（:link）、已访问（:visited）、激活（:active）和悬停（:hover），分别表示4种状态。它们的声明顺序推荐使用LVHA，通常这4个伪类会使用同一个源声明，4个伪类的特殊性（将在第二章讲解）也相同，如下代码所示，因此影响权重的只有在样式表中所处的位置了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;a:link &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
}&lt;span&gt;
a:visited &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
}&lt;span&gt;
a:hover &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; green&lt;/span&gt;;
}&lt;span&gt;
a:active &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当鼠标悬浮在未访问或已访问链接的时候，都会同时存在两种状态，:link与:hover或:visited与:hover。如果:hover声明在:link或:visited之前，那么就会被覆盖掉。当鼠标点中链接的时候，会同时存在两种状态，:active与:hover。如果:active声明在:hover之前，那么会被覆盖掉。因此:hover与:active必须在:link与:visited之后，而:active必须在:hover之后，至于:link与:visited，它们两个的顺序可以互换。将LVHA记成两个单词的组合，love和hate，能更易于记忆。&lt;/p&gt;
&lt;p&gt;　　还有一种:focus伪类更多地用于表单元素，可在元素聚焦时生效，例如为文本框添加:focus，如下所示。在下图中，右边是获得输入焦点时文本框的样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input:focus &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318185219026-1044089923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）表单伪类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这种伪类专门服务于表单控件，根据用户与表单控件的交互，来反映其某种状态。&lt;/p&gt;
&lt;p&gt;　　:enabled和:disabled分别应用于控件的启用和禁用状态，如下代码所示，文本框默认是启用状态，第二个文本框设置了disabled属性，变成禁用状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input:enabled &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  input:disabled &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; disabled&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:checked应用于单选框或复选框的选中状态。:required和:optional应用于控件的必选和可选状态，即前者可匹配带有required属性的控件，而后者正好相反。&lt;/p&gt;
&lt;p&gt;　　:valid和:invalid用于验证文本框中的数据是否有效，前者是有效，后者是无效，例如将文本框的格式限制为电子邮件，当格式不正确时，修改文本框的背景，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input[type=email]:invalid &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:read-write和:read-only应用于文本框的读写和只读状态，如下代码所示，文本框默认是读写状态，第二个文本框设置了readonly属性，变成只读状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input:read-write &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  input:read-only &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; readonly&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:in-range和:out-of-range应用于数值类型的文本框，如果当前值处于min和max两个属性限定的范围之内，那么可使用:in-range装饰，否则使用:out-of-range。在下面的示例中，当输入0或6时，文本框的背景就会改变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input[type=number]:out-of-range &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;number&quot;&lt;/span&gt;&lt;span&gt; min&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; max&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）其它伪类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　URL的锚点指向的目标元素可以用:target装饰，例如有一个h3元素（如下所示），其id属性的值为title，当URL是http://www.pwstrick.com#title时，就会改变h3元素的字体颜色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  h3:target &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3 &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;:target&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:lang()会基于语言来匹配元素，在HTML中，语言可以通过lang属性、meta元素或协议的信息来确定（例如HTTP首部）。下面两个p元素，只有用英语编写的元素才会被加粗。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p:lang(en) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    font-weight&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bold&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;fr&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　:not()是一种反选伪类，它能接收一个简单的选择器，例如类型、属性、通配等，不能接收伪类、伪元素和群组选择器。在下面的示例中，会为非p元素改变字体颜色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  :not(p) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，:not()伪类不能嵌套，但是能串联，如下代码所示，其中:not(p):not(span)表示一种或的关系，即匹配的元素即不能是p，也不能是span。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 正确 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
:not(p):not(span) &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #FC0&lt;/span&gt;;
}
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 错误 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
:not(p, span) &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #FC0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　伪元素选择器（pseudo-element selector）用于处理文档内容，可指定某处的内容（即过滤内容）或添加内容。早期的时候，伪元素和伪类都使用单冒号（:）。但最新的CSS3规定伪元素得使用双冒号（::），伪类用单冒号，这样两者的区分能更明显。注意，伪元素只能出现在选择器的最后位置，并且不能同时定义多个伪元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）过滤内容的伪元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　::first-letter会匹配块级元素内容的第一行的首字符，下面的p元素包含一段文本，首字母“s”的字体会扩大一倍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p::first-letter &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当::first-letter依附的元素同时还指定了::before时，它会匹配content属性中的首字符，如下所示，被扩大的不是“s”而是“i”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  div::first-letter &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  div::before &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;is&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;strick&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若要匹配块级元素内容的第一行，可以使用::first-line，例如将第一行加粗，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p::first-line &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    font-weight&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bold&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.I am from China.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　::first-letter和::first-line对可使用的属性也做了限制，例如字体、背景等属性允许使用。&lt;/p&gt;
&lt;p&gt;　　其它常用的伪元素还有::placeholder和::selection，前者可自定义表单控件占位文本的样式，后者可装饰选中内容（即被用户高亮的部分）。下面文本框定义了placeholder属性并声明了::placeholder伪元素，占位文本会变成红色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  input::placeholder &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）添加内容的伪元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　::before可在元素之前插入修饰性的内容，::after可在元素之后插入修饰性的内容，两个伪元素创建出的虚拟元素默认为行内元素。下面的p元素声明了::before和::after，经过拼接后，在页面上显示的文本为“I am Strick”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p::before &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;I &quot;
  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  p::after &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot; Strick&quot;
  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;am&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，::before 和::after不能应用于替换元素，例如img、input等。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Apr 2020 23:35:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、伪类选择器 伪选择器弥补了常规选择器的不足，能够实现一些特殊情况下的样式，例如在鼠标悬停时或只给字符串中的第一个字符指定样式。与类选择器类似，可以从HTML元素的class属性中查看到，但伪选择器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12519389.html</dc:identifier>
</item>
<item>
<title>写给小白看的入门级 Java 基本语法，强烈推荐 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12651189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12651189.html</guid>
<description>&lt;p&gt;之前写的一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/fbTzH5B7mSr5v0tQ8mV2wA&quot;&gt;我去&lt;/a&gt;阅读量非常不错，但有一句留言深深地刺痛了我：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;培训班学习半年，工作半年，我现在都看不懂你这篇文章，甚至看不下去，对于我来说有点深。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从表面上看，这句话有点讽刺我的文章写得不够通俗易懂的意味，但我心胸一直如大海一般开阔，你了解的。所以，我回他，“你还不如把培训费给我，哈哈。”怎么样，你也能体会到我的幽默，以及无情吧？当然了，是时候写一篇文章（也许是一个系列哦）照顾一下顾小白群体的情绪了，帮他们入入门或者回炉再造下。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-rumen-01.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;众所周知，Java 是一门面向对象的编程语言。它最牛逼的地方就在于它是跨平台的，你可以在 Windows 操作系统上编写 Java 源代码，然后在 Linux 操作系统上执行编译后的字节码，而无需对源代码做任何的修改。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01、数据类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。&lt;/p&gt;
&lt;p&gt;基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。&lt;/p&gt;
&lt;p&gt;不同的基本数据类型，有不同的默认值和大小，来个表格感受下。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;1比特&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;'\u0000'&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;0L&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;0.0f&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 &lt;code&gt;String cmower = &quot;沉默王二&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02、声明变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;br/&gt;String name;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SyntaxLocalVariable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;br/&gt;String name;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;SyntaxLocalVariable syntax = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SyntaxLocalVariable();&lt;br/&gt;System.out.println(syntax.age); &lt;br/&gt;System.out.println(syntax.name);  &lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在声明一个变量后使用“=”操作符进行赋值，就像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age = &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;;&lt;br/&gt;String name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。&lt;/p&gt;
&lt;p&gt;每行代码后面都跟了一个“;”，表示当前语句结束了。&lt;/p&gt;
&lt;p&gt;在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以字母、下划线（_）或者美元符号（$）开头&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不能使用 Java 的保留字，比如说 int 不能作为变量名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、数组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。&lt;/p&gt;
&lt;p&gt;声明数组的一般语法如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;type[] identiier = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; type[length];&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ArraysDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; [] nums = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];&lt;br/&gt;nums[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;;&lt;br/&gt;nums[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;;&lt;br/&gt;System.out.println(nums[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。&lt;/p&gt;
&lt;p&gt;通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、关键字&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。&lt;/p&gt;
&lt;ol readability=&quot;52.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;abstract：&lt;/strong&gt; abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;boolean：&lt;/strong&gt; boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;break：&lt;/strong&gt; break 关键字用于中断循环或 switch 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;byte：&lt;/strong&gt; byte 关键字用于声明一个可以容纳 8 个比特的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;case：&lt;/strong&gt; case 关键字用于在 switch 语句中标记条件的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;catch：&lt;/strong&gt; catch 关键字用于捕获 try 语句中的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;char：&lt;/strong&gt; char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;class：&lt;/strong&gt; class 关键字用于声明一个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;continue：&lt;/strong&gt; continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;default：&lt;/strong&gt; default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;do：&lt;/strong&gt; do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;double：&lt;/strong&gt; double 关键字用于声明一个可以容纳 64 位浮点数的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;else：&lt;/strong&gt; else 关键字用于指示 if 语句中的备用分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;enum：&lt;/strong&gt; enum（枚举）关键字用于定义一组固定的常量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;extends：&lt;/strong&gt; extends 关键字用于指示一个类是从另一个类或接口继承的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;final：&lt;/strong&gt; final 关键字用于指示该变量是不可更改的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;finally：&lt;/strong&gt; finally 关键字和 &lt;code&gt;try-catch&lt;/code&gt; 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;float：&lt;/strong&gt; float 关键字用于声明一个可以容纳 32 位浮点数的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;for：&lt;/strong&gt; for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;if：&lt;/strong&gt; if 关键字用于指定条件，如果条件为真，则执行对应代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;implements：&lt;/strong&gt; implements 关键字用于实现接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;import：&lt;/strong&gt; import 关键字用于导入对应的类或者接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;instanceof：&lt;/strong&gt; instanceof 关键字用于判断对象是否属于某个类型（class）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;int：&lt;/strong&gt; int 关键字用于声明一个可以容纳 32 位带符号的整数变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;interface：&lt;/strong&gt; interface 关键字用于声明接口——只能具有抽象方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;long：&lt;/strong&gt; long 关键字用于声明一个可以容纳 64 位整数的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;native：&lt;/strong&gt; native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;new：&lt;/strong&gt; new 关键字用于创建一个新的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;null：&lt;/strong&gt; 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;package：&lt;/strong&gt; package 关键字用于声明类所在的包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;private：&lt;/strong&gt; private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;protected：&lt;/strong&gt; protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;public：&lt;/strong&gt; public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。&lt;code&gt;main()&lt;/code&gt; 方法必须声明为 public。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;return：&lt;/strong&gt; return 关键字用于在代码执行完成后返回（一个值）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;short：&lt;/strong&gt; short 关键字用于声明一个可以容纳 16 位整数的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;static：&lt;/strong&gt; static 关键字表示该变量或方法是静态变量或静态方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;strictfp：&lt;/strong&gt; strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;super：&lt;/strong&gt; super 关键字可用于调用父类的方法或者变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;switch：&lt;/strong&gt; switch 关键字通常用于三个（以上）的条件判断。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;synchronized：&lt;/strong&gt; synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;this：&lt;/strong&gt; this 关键字可用于在方法或构造函数中引用当前对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;throw：&lt;/strong&gt; throw 关键字主动抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;throws：&lt;/strong&gt; throws 关键字用于声明异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;transient：&lt;/strong&gt; transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;try：&lt;/strong&gt; try 关键字用于包裹要捕获异常的代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;void：&lt;/strong&gt; void 关键字用于指定方法没有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile：&lt;/strong&gt; volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;while：&lt;/strong&gt; 如果循环次数不固定，建议使用 while 循环。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-rumen-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h05&quot;&gt;&lt;span&gt;05、操作符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;除去“=”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。&lt;/p&gt;
&lt;p&gt;①、算术运算符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;+（加号）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;–（减号）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;*（乘号）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;/（除号）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;％（取余）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看一个例子：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ArithmeticOperator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;p&gt;System.out.println(a + b);&lt;br/&gt;System.out.println(a - b);&lt;br/&gt;System.out.println(a * b);&lt;br/&gt;System.out.println(a / b);&lt;br/&gt;System.out.println(a % b);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“+”号比较特殊，还可以用于字符串拼接，来看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String result = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-string&quot;&gt;&quot;一枚有趣的程序员&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;②、逻辑运算符&lt;/p&gt;
&lt;p&gt;逻辑运算符通常用于布尔表达式，常见的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;amp;&amp;amp;（AND）多个条件中只要有一个为 false 结果就为 false&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;||（OR）多个条件只要有一个为 true 结果就为 true&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LogicalOperator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; c=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;&lt;br/&gt;System.out.println(a&amp;lt;b&amp;amp;&amp;amp;a&amp;lt;c);&lt;br/&gt;System.out.println(a&amp;gt;b||a&amp;lt;c);&lt;br/&gt;System.out.println(!(a&amp;lt;b)); &lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;③、比较运算符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;amp;lt;&lt;/code&gt; (小于)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;lt;=&lt;/code&gt; (小于或者等于)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;gt;&lt;/code&gt; (大于)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;gt;=&lt;/code&gt; (大于或者等于)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; (相等)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt; (不等)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、程序结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。&lt;/p&gt;
&lt;p&gt;如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StructureProgram&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;没有成员变量，只有一个 main 方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;类名叫做 StructureProgram，在它里面，只有一个 main 方法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; 之间的代码称之为代码块。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;以上源代码将会保存在一个后缀名为 java 的文件中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h07&quot;&gt;&lt;span&gt;07、编译然后执行代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 &lt;code&gt;javac&lt;/code&gt; 命令将源代码编译成字节码文件，然后再执行 &lt;code&gt;java&lt;/code&gt; 命令指定代码。&lt;/p&gt;
&lt;p&gt;但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。&lt;/p&gt;
&lt;p&gt;好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。&lt;/p&gt;
&lt;p&gt;安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-rumen-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;想查看反编译后的字节码的话，可以在 src 的同级目录 target/classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。&lt;/p&gt;
&lt;p&gt;可以双击打开它。&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;7&quot;&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.cmower.baeldung.basic;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StructureProgram&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StructureProgram&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;没有成员变量，只有一个 main 方法&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;8&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;cmower&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;baeldung&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;basic&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;StructureProgram&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &amp;lt;init&amp;gt;()V&lt;br/&gt;L0&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; L0&lt;br/&gt;ALOAD &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;INVOKESPECIAL java/lang/Object.&amp;lt;init&amp;gt; ()V&lt;br/&gt;RETURN&lt;br/&gt;L1&lt;br/&gt;LOCALVARIABLE &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;MAXSTACK = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;MAXLOCALS = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;([Ljava/lang/String;)&lt;/span&gt;V&lt;br/&gt;L0&lt;br/&gt;LINENUMBER 5 L0&lt;br/&gt;GETSTATIC java/lang/System.out : Ljava/io/PrintStream&lt;/span&gt;;&lt;br/&gt;LDC &lt;span class=&quot;hljs-string&quot;&gt;&quot;\u6ca1\u6709\u6210\u5458\u53d8\u91cf\uff0c\u53ea\u6709\u4e00\u4e2a main \u65b9\u6cd5&quot;&lt;/span&gt;&lt;br/&gt;INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V&lt;br/&gt;L1&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; L1&lt;br/&gt;RETURN&lt;br/&gt;L2&lt;br/&gt;LOCALVARIABLE args [Ljava/lang/String; L0 L2 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;MAXSTACK = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;MAXLOCALS = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新手看起来还是有些懵逼的，建议过过眼瘾就行了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-rumen-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;好了，我亲爱的读者朋友，以上就是本文的全部内容了，源代码已上传到码云，点击阅读原文就可以跳转过去了。学任何一门编程语言，在我看来，方法都是一样的，那就是不停地去实践，别觉得浅显易懂就不肯动手去尝试——你的左手和右手就是你最好的老师。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;觉得有点用记得给我点赞哦！😎&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;简单介绍一下。10 年前，当我上大学的时候，专业被调剂到了计算机网络，主要学的是 Java 编程语言，但当时没怎么好好学，每年都要挂科两三门；因此工作后吃了不少亏。但是最近几年，情况发生了很大改变，你应该也能看得到我这种变化。通过坚持不懈地学习，持续不断地输出，我的编程基本功算得上是突飞猛进。&lt;/p&gt;
&lt;p&gt;为了帮助更多的程序员，我在博客园创建了“&lt;strong&gt;沉默王二&lt;/strong&gt;”这个 ID，专注于分享有趣的 Java 技术编程和有益的程序人生。一开始，阅读量寥寥无几，关注人数更是少得可怜。但随着影响力的逐步扩大，阅读量和关注人都在猛烈攀升。&lt;/p&gt;
&lt;p&gt;如果你也喜欢我的文章，请记得微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」关注我的原创公众号，回复“&lt;strong&gt;1024&lt;/strong&gt;”更有美团技术大佬整理的 Java 面试攻略相送，还有架构师的面试视频哦。&lt;/p&gt;
&lt;p&gt;绝对不容错过，期待与你的不期而遇。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_6.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Mon, 06 Apr 2020 23:29:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>之前写的一篇我去阅读量非常不错，但有一句留言深深地刺痛了我： 培训班学习半年，工作半年，我现在都看不懂你这篇文章，甚至看不下去，对于我来说有点深。 从表面上看，这句话有点讽刺我的文章写得不够通俗易懂的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12651189.html</dc:identifier>
</item>
<item>
<title>家乐的深度学习笔记「5」 - 多层感知机 - Licsber</title>
<link>http://www.cnblogs.com/licsber/p/MXNet-5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/licsber/p/MXNet-5.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;由于前文提到的包括线性回归和softmax回归在内的单层神经网络均只能解决线性分类问题，一个常见的反例就是异或（XOR）问题，假设坐标轴上有四个点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/737845/1586137647223-5d4b0e29-d8e6-4213-9fc9-e37ca3ddd1c2.png#align=left&amp;amp;display=inline&amp;amp;height=273&amp;amp;name=image.png&amp;amp;originHeight=273&amp;amp;originWidth=382&amp;amp;size=14310&amp;amp;status=done&amp;amp;style=none&amp;amp;width=382&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的四个点，在平面上划一条直线（线性分类模型），是无论如何都没有办法将圆形和三角形分开的。这个问题从直观上很好理解，要证明这一点首先需要一个概念，即数据集的线性可分性：&lt;/p&gt;
&lt;p&gt;给定一个数据集：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/98f904b7e9d0e564997c182a0967090c.svg#card=math&amp;amp;code=T%20%3D%20%5C%7B%28x_1%2C%20y_1%29%2C%20%28x_2%2C%20y_2%29%2C%20...%2C%20%28x_N%2C%20y_N%29%5C%7D%EF%BC%8C&amp;amp;height=24&amp;amp;width=280&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/6d859c6fbde591024cf6e66a59dd3a6b.svg#card=math&amp;amp;code=x_i%20%5Cin%20%5Cchi%20%3D%20R%5E%7B%5C%20n%7D%2C%20%5C%20y_i%20%5Cin%20%5Cgamma%20%3D%20%7B%2B1%2C%20-1%7D%2C%20%5C%20i%20%3D%201%2C%202%2C%20...%2C%20N&amp;amp;height=21&amp;amp;width=347&quot; alt=&quot;&quot;/&gt;，如果存在某个超平面&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5dbc98dcc983a70728bd082d1a47546e.svg#card=math&amp;amp;code=S&amp;amp;height=16&amp;amp;width=11&quot; alt=&quot;&quot;/&gt;：使得&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/b8f595166d6ee159dd2d8f22f875c639.svg#card=math&amp;amp;code=w%20%5Ccdot%20x%20%2B%20b%20%3D%200&amp;amp;height=17&amp;amp;width=93&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，则称数据集&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/b9ece18c950afbfa6b0fdbfa4ff731d3.svg#card=math&amp;amp;code=T&amp;amp;height=16&amp;amp;width=12&quot; alt=&quot;&quot;/&gt;为线性可分数据集。&lt;/p&gt;
&lt;p&gt;由此，我们可以证明以下定理，其中凸壳即凸包，是实数向量空间中，对于给定集合，所有包含X的凸集的交集，通俗理解为一条刚好包着所有点的橡皮圈，其求取算法在文章下的参考资料里有说明（格雷哈姆算法）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样本集线性可分的充分必要条件是正实例点集所构成的凸壳与负实例点所构成的凸壳互不相交。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里引用一段别人的证明，自己实在写不出充分性的证明文字：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;必要性&lt;/strong&gt;： 假设样本集T线性可分，则存在一个超平面  将数据集的正实例点和负实例点完全正确地划分到  的两侧。显然两侧的点分别构成的凸壳不相交； &lt;br/&gt;&lt;strong&gt;充分性&lt;/strong&gt;： 假设存在两个凸壳A、B相交，且存在超平面  将A和B线性分割。令A在B的凸壳内部的点为a，因为线性可分，则A中不存在两点之间的连线与超平面  相交，而凸壳B中任意一点与A中的点的连线均与超平面  相交，则B内部的点a也与A中任一点之间的连线不与  相交，与A中不存在两点之间的连线与超平面小脚矛盾。故只有正负实例点所构成的两个凸壳不相交时样本集才线性可分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是一大票工程师就傻了，最简单的异或问题都解决不了，而生活中到处常见此类问题，这还学什么神经网络，赶紧扔掉，这样神经网络就被搁置了一段时间，直到多层感知机的提出，至于其他问题都是后话了，详见文章下的参考资料（历史部分），本文主要介绍多层感知机的由来、原理以及实现，常见的激活函数等内容。&lt;/p&gt;
&lt;h2 id=&quot;多层感知机&quot;&gt;多层感知机&lt;/h2&gt;
&lt;p&gt;多层感知机（MLP），也叫前馈神经网络（FNN），是人工智能领域中最早发明的简单人工神经网络类型，FNN由一个输入层、一个（浅层网络）或多个（深层网络，因此叫作深度学习）隐藏层，和一个输出层构成。每个层（除输出层以外）与下一层连接。这种连接是 FNN 架构的关键，具有两个主要特征：加权平均值和激活函数。&lt;/p&gt;
&lt;p&gt;MLP是一种前向结构的人工神经网络，可以被看作是一个有向图，由多个的节点层所组成，每一层都全连接到下一层。除了输入节点，每个节点都是一个带有非线性激活函数的神经元（或称处理单元），是单层感知器的推广，克服了感知器不能对线性不可分数据进行识别的弱点。&lt;/p&gt;
&lt;h2 id=&quot;加权平均值&quot;&gt;加权平均值&lt;/h2&gt;
&lt;p&gt;因为MLP的每一层都是全连接层（除了输入层），所以每一层节点值的计算除了计算自己的权重之外，还需要根据前一层所有节点的加权总和激活，即每个连接点的权重乘以该节点的激活函数的总和。每个节点仅从前一层获取输入值，因此权重是同一层中节点的唯一区分依据。&lt;/p&gt;
&lt;h2 id=&quot;激活函数&quot;&gt;激活函数&lt;/h2&gt;
&lt;h3 id=&quot;背景导入&quot;&gt;背景导入&lt;/h3&gt;
&lt;p&gt;为了理解激活函数的意义，先让我们简单构建一个隐藏层也是全连接层的神经网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586139608048-0e1250a1-fe5d-4278-9745-1aaec09e5e2b.svg#align=left&amp;amp;display=inline&amp;amp;height=200&amp;amp;name=mlp.svg&amp;amp;originHeight=200&amp;amp;originWidth=352&amp;amp;size=44451&amp;amp;status=done&amp;amp;style=none&amp;amp;width=352&quot; alt=&quot;mlp.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体来说，给定一个小批量样本&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/28621943d2e6aae4de940f7b0b6a2de5.svg#card=math&amp;amp;code=%5Cboldsymbol%7BX%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20d%7D&amp;amp;height=20&amp;amp;width=75&quot; alt=&quot;&quot;/&gt;，其批量大小为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7b8b965ad4bca0e41ab51de7b31363a1.svg#card=math&amp;amp;code=n&amp;amp;height=13&amp;amp;width=11&quot; alt=&quot;&quot;/&gt;，输入个数为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/8277e0910d750195b448797616e091ad.svg#card=math&amp;amp;code=d&amp;amp;height=16&amp;amp;width=9&quot; alt=&quot;&quot;/&gt;。假设多层感知机只有一个隐藏层，其中隐藏单元个数为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/2510c39011c5be704182423e3a695e91.svg#card=math&amp;amp;code=h&amp;amp;height=16&amp;amp;width=10&quot; alt=&quot;&quot;/&gt;。记隐藏层的输出（也称为隐藏层变量或隐藏变量）为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/02671c279eaa829844940979442a7893.svg#card=math&amp;amp;code=%5Cboldsymbol%7BH%7D&amp;amp;height=16&amp;amp;width=18&quot; alt=&quot;&quot;/&gt;，有&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/363f6b5584146e07a48e05ddd771efc1.svg#card=math&amp;amp;code=%5Cboldsymbol%7BH%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20h%7D&amp;amp;height=20&amp;amp;width=77&quot; alt=&quot;&quot;/&gt;。因为隐藏层和输出层均是全连接层，可以设隐藏层的权重参数和偏差参数分别为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/60b47aca142e21746de8572454dab563.svg#card=math&amp;amp;code=%5Cboldsymbol%7BW%7D_h%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd%20%5Ctimes%20h%7D&amp;amp;height=22&amp;amp;width=84&quot; alt=&quot;&quot;/&gt;和&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4fe5f611f0b3167fd2e469fc5298de44.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bb%7D_h%20%5Cin%20%5Cmathbb%7BR%7D%5E%7B1%20%5Ctimes%20h%7D&amp;amp;height=22&amp;amp;width=74&quot; alt=&quot;&quot;/&gt;，输出层的权重和偏差参数分别为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/c1dd62d75a00c30fc9bce3c9a76017e9.svg#card=math&amp;amp;code=%5Cboldsymbol%7BW%7D_o%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bh%20%5Ctimes%20q%7D&amp;amp;height=22&amp;amp;width=83&quot; alt=&quot;&quot;/&gt;和&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/29909b61373a5372cf4a003e711906d4.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bb%7D_o%20%5Cin%20%5Cmathbb%7BR%7D%5E%7B1%20%5Ctimes%20q%7D&amp;amp;height=22&amp;amp;width=72&quot; alt=&quot;&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;我们先来看一种含单隐藏层的多层感知机的设计。其输出&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7778fe44e9d3df83051904c3f76061ba.svg#card=math&amp;amp;code=%5Cboldsymbol%7BO%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20q%7D&amp;amp;height=17&amp;amp;width=71&quot; alt=&quot;&quot;/&gt;的计算为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/d79e980677f105fdfcf8af5d056db704.svg#card=math&amp;amp;code=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BH%7D%20%26%3D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BW%7D_h%20%2B%20%5Cboldsymbol%7Bb%7D_h%5C%5C%0A%5Cboldsymbol%7BO%7D%20%26%3D%20%5Cboldsymbol%7BH%7D%20%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_o%0A%5Cend%7Baligned%7D&amp;amp;height=42&amp;amp;width=125&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是将隐藏层的输出直接作为输出层的输入。如果将以上两个式子联立起来，可以得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/6ab7e8c199c83e0af3b82f6cb0523d01.svg#card=math&amp;amp;code=%5Cboldsymbol%7BO%7D%20%3D%20%28%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BW%7D_h%20%2B%20%5Cboldsymbol%7Bb%7D_h%29%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_o%20%3D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BW%7D_h%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_h%20%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_o&amp;amp;height=21&amp;amp;width=393&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从联立后的式子可以看出，虽然神经网络引入了隐藏层，却依然等价于一个单层神经网络：其中输出层权重参数为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/fd6827838f5d362e2b24c66b4df1c02a.svg#card=math&amp;amp;code=%5Cboldsymbol%7BW%7D_h%5Cboldsymbol%7BW%7D_o&amp;amp;height=18&amp;amp;width=52&quot; alt=&quot;&quot;/&gt;，偏差参数为&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/8d903f28b25e90e00ab151db50050956.svg#card=math&amp;amp;code=%5Cboldsymbol%7Bb%7D_h%20%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_o&amp;amp;height=18&amp;amp;width=79&quot; alt=&quot;&quot;/&gt;。不难发现，即便再添加更多的隐藏层，以上设计依然只能与仅含输出层的单层神经网络等价。&lt;/p&gt;
&lt;p&gt;那咋办呢？隐藏层是不是没用呢？徒增了计算，结果还和原来的网络等价？&lt;/p&gt;
&lt;p&gt;上面的问题根源就是每层依然是全连接，而全连接层只是对数据做仿射变换，多个仿射变换的叠加仍然是一个仿射变换。解决问题的一个方法就是引入非线性变换，例如对隐藏变量使用按元素运算的非线性函数进行变换，然后再作为下一个全连接层的输入。这个非线性函数就是本节要讲的激活函数：&lt;/p&gt;
&lt;h3 id=&quot;relu函数&quot;&gt;ReLU函数&lt;/h3&gt;
&lt;p&gt;ReLU（rectified linear unit）函数提供了一个很简单的非线性变换。给定元素&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/9dd4e461268c8034f5c8564e155c67a6.svg#card=math&amp;amp;code=x&amp;amp;height=13&amp;amp;width=10&quot; alt=&quot;&quot;/&gt;，该函数定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/db387556be9cb71a63cc71a5cc0ef39c.svg#card=math&amp;amp;code=%5Ctext%7BReLU%7D%28x%29%20%3D%20%5Cmax%28x%2C%200%29&amp;amp;height=21&amp;amp;width=161&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，ReLU函数只保留正数元素，并将负数元素清零，其函数图像如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586140288376-8ef84d82-5260-4aa9-b0cc-ed1a259079c7.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_3_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=432&amp;amp;size=15604&amp;amp;status=done&amp;amp;style=none&amp;amp;width=432&quot; alt=&quot;output_3_0.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，当输入为负数时，ReLU函数的导数为0；当输入为正数时，ReLU函数的导数为1。尽管输入为0时ReLU函数不可导，但可以取此处的导数为0，画出其导数图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586140352455-3d6b24df-42ea-484b-833a-eaaa8cc6d8e5.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_5_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=445&amp;amp;size=21605&amp;amp;status=done&amp;amp;style=none&amp;amp;width=445&quot; alt=&quot;output_5_0.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sigmoid函数&quot;&gt;sigmoid函数&lt;/h3&gt;
&lt;p&gt;这个函数就是高中生物说的S型函数了，是不是有种似曾相识的感觉。它有着良好的性质：单增且反函数单增、平滑易于求导；在神经网络中常作为隐层的激活函数，可以将实数映射到&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/4dabab2d922d2e80fc4d8be85a41ff51.svg#card=math&amp;amp;code=%280%2C%201%29&amp;amp;height=21&amp;amp;width=38&quot; alt=&quot;&quot;/&gt;区间上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/053e4af87f96f60169ca81bf93ec5793.svg#card=math&amp;amp;code=%5Ctext%7Bsigmoid%7D%28x%29%20%3D%20%5Cfrac%7B1%7D%7B1%20%2B%20%5Cexp%28-x%29%7D&amp;amp;height=44&amp;amp;width=200&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;S函数在早起的神经网络中较为普遍，但是逐渐被更简单的ReLU函数取代。利用它的值域在0到1之间这一特性可以控制信息在神经网络中的流动。当输入接近0时，S函数接近线性变换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586163405397-8fc9e1c8-cd73-46c9-8022-821950ffcd13.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_7_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=445&amp;amp;size=21045&amp;amp;status=done&amp;amp;style=none&amp;amp;width=445&quot; alt=&quot;output_7_0.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依据链式法则，S函数的导数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/8ebc34d2cf7a008fb7ce05001e109ea9.svg#card=math&amp;amp;code=%5Ctext%7Bsigmoid%7D%27%28x%29%20%3D%20%5Ctext%7Bsigmoid%7D%28x%29%5Cleft%281-%5Ctext%7Bsigmoid%7D%28x%29%5Cright%29&amp;amp;height=22&amp;amp;width=312&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当输入为0时，S函数的导数达到最大值0.25，当输入越偏离0时，S函数的导数越接近0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586195291777-b8916f12-5c81-4b58-9e0d-ae68116cf141.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_9_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=454&amp;amp;size=25152&amp;amp;status=done&amp;amp;style=none&amp;amp;width=454&quot; alt=&quot;output_9_0.svg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tanh函数&quot;&gt;tanh函数&lt;/h3&gt;
&lt;p&gt;tanh（双曲正切）函数可以将元素的值变换到-1和1之间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/63612ad4c74f9aab2ea77b36aa3f6bb2.svg#card=math&amp;amp;code=%5Ctext%7Btanh%7D%28x%29%20%3D%20%5Cfrac%7B1%20-%20%5Cexp%28-2x%29%7D%7B1%20%2B%20%5Cexp%28-2x%29%7D&amp;amp;height=47&amp;amp;width=183&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当输入接近0时，tanh也接近线性变换，虽然这个函数和S函数的形状很像，但是它在坐标系的原点上对称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586163687497-4069ab63-de2a-4fce-85f9-16b277ca09d7.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_11_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=456&amp;amp;size=19180&amp;amp;status=done&amp;amp;style=none&amp;amp;width=456&quot; alt=&quot;output_11_0.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据链式法则，tanh函数的导数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/7cf7fe617641fd2760a1a802769eb1ff.svg#card=math&amp;amp;code=%5Ctext%7Btanh%7D%27%28x%29%20%3D%201%20-%20%5Ctext%7Btanh%7D%5E2%28x%29&amp;amp;height=23&amp;amp;width=177&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当输入为0时，tanh函数的导数达到最大值1；当输入越偏离0是，tanh函数的导数越接近0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/svg/737845/1586164309147-d35676be-9a14-4b84-a7bc-43569cdc9abd.svg#align=left&amp;amp;display=inline&amp;amp;height=246&amp;amp;name=output_13_0.svg&amp;amp;originHeight=246&amp;amp;originWidth=445&amp;amp;size=23057&amp;amp;status=done&amp;amp;style=none&amp;amp;width=445&quot; alt=&quot;output_13_0.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当隐藏层使用非线性的激活函数时，其按照以下方式输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/1ce72e5d6a7561340e84b8285b392991.svg#card=math&amp;amp;code=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BH%7D%20%26%3D%20%5Cphi%28%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BW%7D_h%20%2B%20%5Cboldsymbol%7Bb%7D_h%29%5C%5C%0A%5Cboldsymbol%7BO%7D%20%26%3D%20%5Cboldsymbol%7BH%7D%20%5Cboldsymbol%7BW%7D_o%20%2B%20%5Cboldsymbol%7Bb%7D_o%0A%5Cend%7Baligned%7D&amp;amp;height=42&amp;amp;width=148&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/1ed346930917426bc46d41e22cc525ec.svg#card=math&amp;amp;code=%5Cphi&amp;amp;height=18&amp;amp;width=10&quot; alt=&quot;&quot;/&gt;表示激活函数。在分类问题中，可以对输出&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5c94215746bf778c39002c52ad1e4391.svg#card=math&amp;amp;code=%5Cboldsymbol%7BO%7D&amp;amp;height=16&amp;amp;width=14&quot; alt=&quot;&quot;/&gt;做softmax运算，并使用softmax回归中的交叉熵损失函数；在回归问题中，可以将输出层的输出个数设为1，并将输出&lt;img src=&quot;https://cdn.nlark.com/yuque/__latex/5c94215746bf778c39002c52ad1e4391.svg#card=math&amp;amp;code=%5Cboldsymbol%7BO%7D&amp;amp;height=16&amp;amp;width=14&quot; alt=&quot;&quot;/&gt;直接提供给线性回归中使用的平方损失函数。&lt;/p&gt;
&lt;p&gt;有了激活函数的定义以后，MLP的定义就可以更近一步的理解：MLP在输出层与输入层之间加入了一个或多个隐藏层，并通过激活函数对隐藏层输出进行变换。&lt;/p&gt;
&lt;h2 id=&quot;通用近似定理&quot;&gt;通用近似定理&lt;/h2&gt;
&lt;p&gt;通用近似定理，又名万能逼近定理，即含有大于等于一个隐藏层的神经网络理论上就可以拟合所有函数，又因为多个隐藏层在训练时易发生梯度消失的情况，所以大多数情况下MLP的实现只需要一个隐藏层即可。在下面的简洁实现中可以看到增加或减少隐藏层节点数，以及增大隐藏层层数的效果。&lt;/p&gt;
&lt;h2 id=&quot;多层感知机的从零实现&quot;&gt;多层感知机的从零实现&lt;/h2&gt;
&lt;h3 id=&quot;导入需要的库&quot;&gt;导入需要的库&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mxnet.gluon import loss as gloss
from mxnet import autograd, gpu, nd
import d2lzh as d2l
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;指定gpu&quot;&gt;指定GPU&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ctx = gpu(3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加载数据集&quot;&gt;加载数据集&lt;/h3&gt;
&lt;p&gt;这部分在前文已经有了详细的叙述。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;batch_size = 256
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义模型参数&quot;&gt;定义模型参数&lt;/h3&gt;
&lt;p&gt;这里注意每一层输入与输出的关系，从这里看每个神经元和之前也没有什么区别，事实上本来也没有什么区别，都是全连接层，区别仅在计算方法上由简单的线性加和变成了非线性的激活函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_inputs, num_outputs, num_hiddens = 28 * 28, 10, 256

W1 = nd.random.normal(scale=0.01, shape=(num_inputs, num_hiddens), ctx=ctx)
b1 = nd.zeros(num_hiddens, ctx=ctx)
W2 = nd.random.normal(scale=0.01, shape=(num_hiddens, num_outputs), ctx=ctx)
b2 = nd.zeros(num_outputs, ctx=ctx)
params = [W1, b1, W2, b2]

for param in params:
    param.attach_grad()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;激活函数-2&quot;&gt;激活函数&lt;/h3&gt;
&lt;p&gt;使用常见的ReLU函数作为隐藏层的激活函数，具体函数已经在上面说过了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def relu(X):
    return nd.maximum(X, 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义模型&quot;&gt;定义模型&lt;/h3&gt;
&lt;p&gt;同样将输入图像展开为一个直向量，使用激活函数来计算隐藏层结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def net(X):
    X = X.reshape((-1, num_inputs))
    H = relu(nd.dot(X, W1) + b1)
    return nd.dot(H, W2) + b2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义损失函数&quot;&gt;定义损失函数&lt;/h3&gt;
&lt;p&gt;前文说过直接采用gluon提供的这个函数具有更好的数值稳定性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;loss = gloss.SoftmaxCrossEntropyLoss()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计算准确性&quot;&gt;计算准确性&lt;/h3&gt;
&lt;p&gt;这是前文函数的稍微改进版，具体最终版在下面的简洁实现里介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def evaluate_accuracy(data_iter, net, ctx):
    acc_sum, n = nd.array([0], ctx=ctx), 0
    for X, y in data_iter:
        X = X.as_in_context(ctx)
        y = y.as_in_context(ctx)
        y = y.astype('float32')
        acc_sum += (net(X).argmax(axis=1) == y).sum()
        n += y.size
        acc_sum.wait_to_read()
    return acc_sum.asscalar() / n
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优化算法&quot;&gt;优化算法&lt;/h3&gt;
&lt;p&gt;依然是sgd（随机小批量）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def sgd(params, lr, batch_size):
    for param in params:
        param[:] = param - lr * param.grad / batch_size
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练模型&quot;&gt;训练模型&lt;/h3&gt;
&lt;p&gt;定义好超参数，就可以开始炼丹了（误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_epochs, lr = 10, 0.5

def train(net, train_iter, test_iter, loss, num_epochs, batch_size, params, lr):
    for epoch in range(num_epochs):
        train_l_sum, train_acc_sum, n = 0.0, 0.0, 0
        for X, y in train_iter:
            X = X.as_in_context(ctx)
            y = y.as_in_context(ctx)
            with autograd.record():
                y_hat = net(X)
                l = loss(y_hat, y).sum()
            l.backward()
            sgd(params, lr, batch_size)
            y = y.astype('float32')
            train_l_sum += l.asscalar()
            train_acc_sum += (y_hat.argmax(axis=1) == y).sum().asscalar()
            n += y.size
        test_acc = evaluate_accuracy(test_iter, net, ctx)
        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f'
              % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))
        
train(net, train_iter, test_iter, loss, num_epochs, batch_size, params, lr)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以和上文softmax回归对比一下，效果比其稍微好了这么一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;epoch 1, loss 0.7850, train acc 0.707, test acc 0.811
epoch 2, loss 0.4918, train acc 0.818, test acc 0.847
epoch 3, loss 0.4290, train acc 0.842, test acc 0.859
epoch 4, loss 0.3929, train acc 0.854, test acc 0.865
epoch 5, loss 0.3704, train acc 0.864, test acc 0.865
epoch 6, loss 0.3503, train acc 0.871, test acc 0.874
epoch 7, loss 0.3393, train acc 0.875, test acc 0.879
epoch 8, loss 0.3234, train acc 0.881, test acc 0.870
epoch 9, loss 0.3150, train acc 0.885, test acc 0.879
epoch 10, loss 0.3081, train acc 0.886, test acc 0.880
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全部代码&quot;&gt;全部代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/737845/1586195418815-5875d2c5-ee4c-42ca-bf76-9d38a5170ef9.html?_lake_card=%7B%22uid%22%3A%221586195418651-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F737845%2F1586195418815-5875d2c5-ee4c-42ca-bf76-9d38a5170ef9.html%22%2C%22name%22%3A%22%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%9A%84%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0.html%22%2C%22size%22%3A289046%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22hHbGu%22%2C%22card%22%3A%22file%22%7D&quot;&gt;多层感知机的从零实现.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;多层感知机的简洁实现&quot;&gt;多层感知机的简洁实现&lt;/h2&gt;
&lt;h3 id=&quot;导入需要的库-2&quot;&gt;导入需要的库&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mxnet.gluon import loss as gloss, utils as gutils, nn
from mxnet import autograd, gluon, init, nd
import mxnet as mx
import time
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多gpu训练&quot;&gt;多GPU训练&lt;/h3&gt;
&lt;p&gt;这个就是寻找GPU函数的最终版本了，可以直接用在其他炼丹项目中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# [Cell可独立] 多GPU训练第一步：找到你的GPU
def try_all_gpus():
    import mxnet as mx

    ctxes = []
    try:
        for i in range(16):
            ctx = mx.gpu(i)
            _ = mx.nd.array([0], ctx=ctx)
            ctxes.append(ctx)
    except mx.base.MXNetError:
        pass
    if not ctxes:
        ctxes = [mx.cpu()]
    return ctxes

ctx = try_all_gpus()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加载数据集-2&quot;&gt;加载数据集&lt;/h3&gt;
&lt;p&gt;这里去掉了d2lzh库的依赖，改为自己加载，以后做的模型也会慢慢去掉d2lzh这个依赖，更多的尝试自己构建出一个适合自己的工具包。另外这个函数为了可以独立于使用，把部分import写在了里面，因为不需要循环执行，所以对性能的影响基本上可以忽略，主要是为了防自己没导入，浪费重新调整的时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# [Cell可独立] 加载Fashion_MNIST数据集
def get_fashion_mnist(batch_size=256, num_workers=40):
    from mxnet.gluon import data as gdata
    
    mnist_train = gdata.vision.FashionMNIST(train=True)
    mnist_test = gdata.vision.FashionMNIST(train=False)

    transformer = gdata.vision.transforms.ToTensor()

    import sys
    if sys.platform.startswith('win'):
        num_workers = 0

    train_iter = gdata.DataLoader(mnist_train.transform_first(transformer),
                                 batch_size=batch_size, shuffle=True,
                                 num_workers=num_workers)
    test_iter = gdata.DataLoader(mnist_test.transform_first(transformer),
                                batch_size=batch_size, shuffle=False,
                                num_workers=num_workers)
    return train_iter, test_iter

train_iter, test_iter = get_fashion_mnist()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义模型-2&quot;&gt;定义模型&lt;/h3&gt;
&lt;p&gt;有了gluon，定义模型就变的很简单了，想加多少层加多少层，改改参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;net = nn.Sequential()
net.add(nn.Dense(256, activation='relu'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义损失函数及优化算法&quot;&gt;定义损失函数及优化算法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;loss = gloss.SoftmaxCrossEntropyLoss()
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拆分特征和标签到多gpu上&quot;&gt;拆分特征和标签到多GPU上&lt;/h3&gt;
&lt;p&gt;为了多GPU评测作准备。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def _get_batch(batch, ctx):
    features, labels = batch
    if labels.dtype != features.dtype:
        labels = labels.astype(features.dtype)
    return (gutils.split_and_load(features, ctx),
            gutils.split_and_load(labels, ctx), features.shape[0])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在多gpu上同时评测模型&quot;&gt;在多GPU上同时评测模型&lt;/h3&gt;
&lt;p&gt;加速评测，GPU都利用起来，实测每个显存占用还不到1G。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def evaluate_accuracy(data_iter, net, ctx=[mx.cpu()]):
    if isinstance(ctx, mx.Context):
        ctx = [ctx]
    acc_sum, n = nd.array([0]), 0
    for batch in data_iter:
        features, labels, _ = _get_batch(batch, ctx)
        for X, y in zip(features, labels):
            y = y.astype('float32')
            acc_sum += (net(X).argmax(axis=1) == y).sum().copyto(mx.cpu())
            n += y.size
        acc_sum.wait_to_read()
    return acc_sum.asscalar() / n
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练模型-2&quot;&gt;训练模型&lt;/h3&gt;
&lt;p&gt;铺垫了这么多，终于可以开始炼丹了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_epochs = 5

def train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs):
    print('training on', ctx)
    if isinstance(ctx, mx.Context):
        ctx = [ctx]
    for epoch in range(num_epochs):
        train_l_sum, train_acc_sum, n, m, start = 0.0, 0.0, 0, 0, time.time()
        for i, batch in enumerate(train_iter):
            Xs, ys, batch_size = _get_batch(batch, ctx)
            with autograd.record():
                y_hats = [net(X) for X in Xs]
                ls = [loss(y_hat, y) for y_hat, y in zip(y_hats, ys)]
            for l in ls:
                l.backward()
            trainer.step(batch_size)
            train_l_sum += sum([l.sum().asscalar() for l in ls])
            n += sum([l.size for l in ls])
            train_acc_sum += sum([(y_hat.argmax(axis=1) == y).sum().asscalar()
                                 for y_hat, y in zip(y_hats, ys)])
            m += sum([y.size for y in ys])
        test_acc = evaluate_accuracy(test_iter, net, ctx)
        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f, '
              'time %.1f sec'
              % (epoch + 1, train_l_sum / n, train_acc_sum / m, test_acc,
                 time.time() - start))

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四个GPU的情况下，一轮大概是4秒左右，可以看到loss还是挺大的，仍有不少训练空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 0.7741, train acc 0.712, test acc 0.811, time 3.6 sec
epoch 2, loss 0.4870, train acc 0.819, test acc 0.839, time 3.7 sec
epoch 3, loss 0.4293, train acc 0.840, test acc 0.826, time 3.8 sec
epoch 4, loss 0.3955, train acc 0.853, test acc 0.847, time 3.6 sec
epoch 5, loss 0.3738, train acc 0.861, test acc 0.855, time 3.8 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全部代码-2&quot;&gt;全部代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/html/737845/1586195442025-5605c4dc-9115-4216-aa04-6a69b8b7926e.html?_lake_card=%7B%22uid%22%3A%221586195441842-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fhtml%2F737845%2F1586195442025-5605c4dc-9115-4216-aa04-6a69b8b7926e.html%22%2C%22name%22%3A%22%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0.html%22%2C%22size%22%3A314979%2C%22type%22%3A%22text%2Fhtml%22%2C%22ext%22%3A%22html%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22yZqs6%22%2C%22card%22%3A%22file%22%7D&quot;&gt;多层感知机的简洁实现.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;书后练习&quot;&gt;书后练习&lt;/h3&gt;
&lt;h4 id=&quot;增大隐层的神经元数量&quot;&gt;增大隐层的神经元数量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 增大隐层的神经元数量
net = nn.Sequential()
net.add(nn.Dense(1024, activation='relu'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，训练速度稍微变慢了一点，整体效果和原来差不多。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 0.7801, train acc 0.709, test acc 0.771, time 3.7 sec
epoch 2, loss 0.4785, train acc 0.822, test acc 0.829, time 3.9 sec
epoch 3, loss 0.4256, train acc 0.843, test acc 0.824, time 5.2 sec
epoch 4, loss 0.3848, train acc 0.859, test acc 0.855, time 3.8 sec
epoch 5, loss 0.3629, train acc 0.866, test acc 0.855, time 3.8 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;减少隐层的神经元数量&quot;&gt;减少隐层的神经元数量&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 减少隐层的神经元数量
net = nn.Sequential()
net.add(nn.Dense(128, activation='relu'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
num_epochs = 5
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，模型收敛速度明显更慢了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 0.7997, train acc 0.699, test acc 0.786, time 3.5 sec
epoch 2, loss 0.4947, train acc 0.817, test acc 0.834, time 3.4 sec
epoch 3, loss 0.4321, train acc 0.840, test acc 0.749, time 3.4 sec
epoch 4, loss 0.4024, train acc 0.851, test acc 0.859, time 3.5 sec
epoch 5, loss 0.3773, train acc 0.860, test acc 0.837, time 3.5 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;增大隐层的层数&quot;&gt;增大隐层的层数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 增大隐层的层数
net = nn.Sequential()
net.add(nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，训练时间明显增加了，模型收敛的也更慢。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 1.8822, train acc 0.244, test acc 0.401, time 4.3 sec
epoch 2, loss 0.8444, train acc 0.661, test acc 0.575, time 4.3 sec
epoch 3, loss 0.6710, train acc 0.740, test acc 0.777, time 4.2 sec
epoch 4, loss 0.5123, train acc 0.810, test acc 0.804, time 4.3 sec
epoch 5, loss 0.4501, train acc 0.833, test acc 0.853, time 4.3 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;再增大隐层的层数&quot;&gt;再增大隐层的层数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 再增大隐层的层数
net = nn.Sequential()
net.add(nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
        nn.Dense(256, activation='relu'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，模型梯度消失了，压根不收敛，直接爆炸了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 2.3031, train acc 0.098, test acc 0.100, time 5.2 sec
epoch 2, loss 2.3031, train acc 0.100, test acc 0.100, time 5.3 sec
epoch 3, loss 2.3030, train acc 0.100, test acc 0.100, time 5.3 sec
epoch 4, loss 2.3031, train acc 0.100, test acc 0.100, time 5.3 sec
epoch 5, loss 2.3030, train acc 0.101, test acc 0.100, time 5.2 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;试一下sigmoid激活函数&quot;&gt;试一下sigmoid激活函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 试一下sigmoid激活函数
net = nn.Sequential()
net.add(nn.Dense(256, activation='sigmoid'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同激活函数的效果其实具有一定的随机性，现在的我还解释不过来。至少多次运行之后，结果会有挺大的差异。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 1.0438, train acc 0.616, test acc 0.761, time 3.6 sec
epoch 2, loss 0.5768, train acc 0.784, test acc 0.779, time 3.5 sec
epoch 3, loss 0.5045, train acc 0.816, test acc 0.823, time 3.7 sec
epoch 4, loss 0.4708, train acc 0.828, test acc 0.817, time 3.6 sec
epoch 5, loss 0.4476, train acc 0.838, test acc 0.847, time 3.4 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;试一下tanh激活函数&quot;&gt;试一下tanh激活函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 试一下tanh激活函数
net = nn.Sequential()
net.add(nn.Dense(256, activation='tanh'),
       nn.Dense(10))
net.initialize(init.Normal(sigma=0.01), ctx=ctx)
trainer = gluon.Trainer(net.collect_params(), 'sgd', {
    'learning_rate': 0.5,
})

train(train_iter, test_iter, net, loss, trainer, ctx, num_epochs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同激活函数的效果其实具有一定的随机性，现在的我还解释不过来。至少多次运行之后，结果会有挺大的差异。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;training on [gpu(0), gpu(1), gpu(2), gpu(3)]
epoch 1, loss 4.2582, train acc 0.561, test acc 0.706, time 3.4 sec
epoch 2, loss 1.2286, train acc 0.734, test acc 0.754, time 3.5 sec
epoch 3, loss 0.8186, train acc 0.779, test acc 0.798, time 3.5 sec
epoch 4, loss 0.6507, train acc 0.804, test acc 0.798, time 3.5 sec
epoch 5, loss 0.5751, train acc 0.818, test acc 0.754, time 3.5 sec
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jiqizhixin.com/graph/technologies/bdf1ccff-fee9-40a5-9c69-76d2483d12d3&quot;&gt;前馈神经网络｜机器之心&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.kesci.com/home/project/5cf72e57e727f8002c1627b3&quot;&gt;12. 深度学习（1）：多层感知机&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zybuluo.com/ArrowLLL/note/827264&quot;&gt;统计学习方法 —— 感知机&lt;/a&gt;（异或问题的证明）&lt;br/&gt;机器学习-白板推导系列(二十三)-前馈神经网络（Feedforward Neural Network）：&lt;br/&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Tt411s7fK&quot;&gt;https://www.bilibili.com/video/BV1Tt411s7fK&lt;/a&gt;&lt;br/&gt;二维凸包的格雷哈姆扫描算法（Graham）：&lt;br/&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1v741197YM&quot;&gt;https://www.bilibili.com/video/BV1v741197YM&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Apr 2020 18:00:00 +0000</pubDate>
<dc:creator>Licsber</dc:creator>
<og:description>多层感知机的由来、原理以及实现，常见的激活函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/licsber/p/MXNet-5.html</dc:identifier>
</item>
<item>
<title>不可被忽视的操作系统（ FreeRTOS ）【2】 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/12640208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/12640208.html</guid>
<description>&lt;p&gt;本文章总结基于官方FreeRTOS手册，测试系统为ESP32的IDF 4.0&lt;/p&gt;
&lt;p&gt;本篇续上一篇《不可被忽视的操作系统（ FreeRTOS ）【1】》&lt;/p&gt;
&lt;p&gt;其中上一篇主要内容为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FreeRTOS介绍&lt;/li&gt;
&lt;li&gt;FreeRTOS在ESP32中的特殊性&lt;/li&gt;
&lt;li&gt;任务相关函数&lt;/li&gt;
&lt;li&gt;队列相关函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇内容主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;信号量相关函数&lt;/li&gt;
&lt;li&gt;计时器相关函数&lt;/li&gt;
&lt;li&gt;事件组相关函数&lt;/li&gt;
&lt;li&gt;任务通知相关函数&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;信号量&lt;/h2&gt;
&lt;p&gt;reertos / include / freertos / semphr.h&lt;/p&gt;
&lt;p&gt;信号量是操作系统中重要的一部分,信号量一般用来进行资源管理和任务同步, FreeRTOS中信号量又分为&lt;/p&gt;
&lt;p&gt;l  二值信号量、&lt;/p&gt;
&lt;p&gt;l  计数型信号量、&lt;/p&gt;
&lt;p&gt;l  互斥信号量、&lt;/p&gt;
&lt;p&gt;l  递归互斥信号量&lt;/p&gt;
&lt;p&gt;不同的信号量其应用场景不同,但有些应用场景是可以互换着使用的&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;创建二值信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;创建一个新的二进制信号量（二值信号量）实例，并返回一个句柄，通过该句柄可以引用新的信号量。&lt;/p&gt;
&lt;p&gt;通过使用现有队列机制创建信号量的函数。队列长度为1，因为它是二进制信号量。数据大小为0，因为实际上没有任何存储-重要的是队列是否为空或已满（二进制信号量是否可用）。&lt;/p&gt;
&lt;p&gt;这种信号量可用于任务之间或中断与任务之间的纯同步。信号量不必一经获得就退还，因此一个任务/中断可以连续地“提供”该信号量，而另一任务/中断则可以连续地“获取”该信号量。因此，这种信号量不使用优先级继承机制。有关不使用优先级继承的替代方法，请参见xSemaphoreCreateMutex（）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;东小东使用说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二值信号量即可以实现事件的计数，通过xSemaphoreGive（）相关函数释放信号量也就是将计数值加一，当前其最大值为1，通过xSemaphoreTake（）相关函数获取信号量也就是将计数值减一，当xSemaphoreTake（）最终将计数值减到0时，将会触发xSemaphoreTake（）参数的超时等待。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SemaphoreHandle_t xSemaphoreCreateBinary ()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;创建计数型信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;创建一个新的计数信号量实例，并返回一个句柄，通过该句柄可以引用新的计数信号量。&lt;/p&gt;
&lt;p&gt;计数信号量通常用于两件事：&lt;/p&gt;
&lt;p&gt;1）计数事件。&lt;/p&gt;
&lt;p&gt;在这种使用情况下，事件处理程序将在每次事件发生时“给出”信号量（增加信号量计数值），而处理程序任务将在每次处理事件时“获得”信号量（减少信号量计数值）。因此，计数值是已发生的事件数与已处理的事件数之间的差。在这种情况下，期望初始计数值为零。&lt;/p&gt;
&lt;p&gt;2）资源管理。&lt;/p&gt;
&lt;p&gt;在这种使用情况下，计数值指示可用资源的数量。为了获得对资源的控制，任务必须首先获得一个信号量-减少信号量计数值。当计数值达到零时，将没有可用资源。当任务使用资源完成时，它将“给予”信号量-增加信号量计数值。在这种情况下，期望初始计数值等于最大计数值，指示所有资源都是空闲的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;东小东使用说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数型信号量即可以实现事件的计数，通过xSemaphoreGive（）相关函数释放信号量也就是将计数值加一，其最大值为创建时设置的uxMaxCount，通过xSemaphoreTake（）相关函数获取信号量也就是将计数值减一，当xSemaphoreTake（）最终将计数值减到0时，将会触发xSemaphoreTake（）参数的超时等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uxMaxCount：可以达到的最大计数值。当信号量达到此值时，就不能再“给予”它了。&lt;/p&gt;
&lt;p&gt;uxInitialCount：初值，创建信号时分配给信号量的计数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数型信号量句柄，失败则返回null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SemaphoreHandle_t  xSemaphoreCreateCounting（ uxMaxCount，uxInitialCount ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取计数型信号量的当前计数值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果该信号量是一个计数信号量，则uxSemaphoreGetCount（）返回其当前计数值。如果该信号量是二进制信号量，那么如果该信号量可用，则uxSemaphoreGetCount（）返回1；如果该信号量不可用，则返回0。&lt;/p&gt;
&lt;p&gt;参数：信号量句柄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t  uxSemaphoreGetCount（ xSemaphore ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用于二值信号量、计数型信号量、互斥信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;宏获取信号量。信号量必须事先通过调用vSemaphoreCreateBinary（），xSemaphoreCreateMutex（）或xSemaphoreCreateCounting（）来创建&lt;/p&gt;
&lt;p&gt;通过xSemaphoreGive释放后才有效，才能获取为pdTRUE&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xSemaphore：获取信号量的句柄-创建信号量时获得。&lt;/p&gt;
&lt;p&gt;xBlockTime：等待信号量可用的时间（以毫秒为单位）。宏端口TICK_PERIOD_MS可用于将其转换为实时。零的阻止时间可用于轮询信号量。portMAX_DELAY的阻塞时间可以无限期地阻塞（在FreeRTOSConfig.h中将INCLUDE_vTaskSuspend设置为1）。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果获得了信号量，则为pdTRUE。如果xBlockTime到期而信号灯不可用，则为pdFALSE。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xSemaphoreTake（ xSemaphore，xBlockTime ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务函数中获取信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用于二值信号量、计数型信号量、互斥信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于从ISR获取信号量的宏。信号量必须事先通过调用vSemaphoreCreateBinary（）或xSemaphoreCreateCounting（）来创建。&lt;/p&gt;
&lt;p&gt;互斥类型信号量（通过调用xSemaphoreCreateMutex（）创建的信号量）不得与此宏一起使用。&lt;/p&gt;
&lt;p&gt;可以从ISR使用此宏，但是从ISR获取信号量并不常见。仅当中断从资源池中获取对象时（当信号量指示可用资源的数量时），才使用计数信号量。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xSemaphore：正在使用的信号量的句柄。这是创建信号量时返回的句柄。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：如果采用信号量导致任务取消阻止，并且未阻止任务的优先级高于当前运行的任务，则xSemaphoreTakeFromISR（）会将* pxHigherPriorityTaskWoken设置为pdTRUE。如果xSemaphoreTakeFromISR（）将此值设置为pdTRUE，则应在退出中断之前请求上下文切换。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果成功获取了信号，则为pdTRUE，否则为pdFALSE&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xSemaphoreTakeFromISR（ xSemaphore，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;释放信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用于二值信号量、计数型信号量、互斥信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;释放信号量的宏。信号量必须事先通过调用vSemaphoreCreateBinary（），xSemaphoreCreateMutex（）或xSemaphoreCreateCounting（）来创建。并使用sSemaphoreTake（）获得。&lt;/p&gt;
&lt;p&gt;不得从ISR使用此宏。有关可以从ISR使用的替代方法，请参见xSemaphoreGiveFromISR（）。&lt;/p&gt;
&lt;p&gt;此宏也不得用于使用xSemaphoreCreateRecursiveMutex（）创建的信号量。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xSemaphore：释放信号量的句柄。这是创建信号量时返回的句柄。&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果已释放信号，则为pdTRUE。如果发生错误，则为pdFALSE。信号量是使用队列实现的。如果队列上没有空间可发布消息，则可能会发生错误-指示未正确正确获取信号量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xSemaphoreGive（ xSemaphore）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务函数中释放信号量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用于二值信号量、计数型信号量、互斥信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;释放信号量的宏。信号量必须事先通过调用vSemaphoreCreateBinary（）或xSemaphoreCreateCounting（）来创建。&lt;/p&gt;
&lt;p&gt;互斥类型信号量（通过调用xSemaphoreCreateMutex（）创建的信号量）不得与此宏一起使用。&lt;/p&gt;
&lt;p&gt;可以从ISR使用此宏。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xSemaphore：释放信号量的句柄。这是创建信号量时返回的句柄。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：如果提供信号量导致任务取消阻止，并且未阻止的任务的优先级高于当前运行的任务，则xSemaphoreGiveFromISR（）会将* pxHigherPriorityTaskWoken设置为pdTRUE。如果xSemaphoreGiveFromISR（）将此值设置为pdTRUE，则应在退出中断之前请求上下文切换。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果成功提供了信号量，则为pdTRUE，否则为errQUEUE_FULL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xSemaphoreGiveFromISR（ xSemaphore，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀之二值信号量任务同步测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;输出效果为3S间隔输出两条，分别为1条释放，1条获取，实现任务间的运行同步&lt;/p&gt;
&lt;p&gt;必须先释放才能获取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406001637776-1268123350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二值信号量句柄&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; SemaphoreHandle_t xSemaphore =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建二值信号量来保护共享资源。&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dong_creat_binary()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用创建函数，二进制值信号量&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      xSemaphore =&lt;span&gt; xSemaphoreCreateBinary ();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(xSemaphore !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;信号量 xSemaphore 创建成功了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      uint32_t num=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;           num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死等获取二值信号量&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          xSemaphoreTake(xSemaphore,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】二值信号量获取成功啦,触发次数：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建二值信号量&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    dong_creat_binary();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;          xSemaphoreGive(xSemaphore);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】释放一次二值信号量，获取将立即执行一次\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀之二值信号量任务共享资源保护&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;测试公共资源访问&lt;/p&gt;
&lt;p&gt;测试可见，公共资源在什么任务里开始，必须在当前任务里接收后才能被其它任务开始，起到资源保护作用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406001722958-1811332278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二值信号量句柄&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; SemaphoreHandle_t xSemaphore =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建二值信号量来保护共享资源。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dong_creat_binary()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用创建函数，二进制值信号量&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;      xSemaphore =&lt;span&gt; xSemaphoreCreateBinary ();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;(xSemaphore !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;信号量 xSemaphore 创建成功了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S，延时的时候将会使得低优先级main获取CPU&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】开始信号量等待---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死等获取二值信号量&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;          xSemaphoreTake(xSemaphore,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】*****公共资源开始*****-----\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;           vTaskDelay(&lt;span&gt;6000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】*****公共资源结束*****------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;           xSemaphoreGive(xSemaphore);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放信号量&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】结束信号量等待---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;           taskYIELD();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在超时之处尽量调用任务切换检查&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建二值信号量&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    dong_creat_binary();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     xSemaphoreGive(xSemaphore);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放信号量,刚启动是必须释放一次才能获取
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】开始信号量等待//////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死等获取二值信号量&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;          xSemaphoreTake(xSemaphore,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】*****公共资源开始*****//////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;           vTaskDelay(&lt;span&gt;6000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】*****公共资源结束*****//////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;           xSemaphoreGive(xSemaphore);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放信号量&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】结束信号量等待//////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;计时器&lt;/h2&gt;
&lt;p&gt;freertos / include / freertos / timers.h&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的一些宏&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; configUSE_TIMERS                  1
&lt;span&gt;#define&lt;/span&gt; configTIMER_TASK_PRIORITY         1
&lt;span&gt;#define&lt;/span&gt; configTIMER_QUEUE_LENGTH          10
&lt;span&gt;#define&lt;/span&gt; configTIMER_TASK_STACK_DEPTH      2048&lt;span&gt;
第一个：表示是否启动计时器
第二个：表示计时器任务的优先级
第三个：表示计时器队列长度
第四个：定时器堆栈，2048个字节&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;硬件定时器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU内部自带的定时器模块,通过初始化、配置可以实现定时,定时时间到以后就会执行相应的定时器中断处理函数。硬件定时器一般都带有其它功能,比如PWM输出、输入捕获等等功能。但是缺点是硬件定时器数量少!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件定时器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件定时器允许设置一段时间,当设置的时间到达之后就执行指定的功能函数,被定时器调用的这个功能函数叫做定时器的回调函数。回调函数的两次执行间隔叫做定时器的定时周期,简而言之,当定时器的定时周期到了以后就会执行回调函数。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;创建计时器实例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;创建一个新的软件计时器实例，并返回一个句柄，通过该句柄可以引用创建的软件计时器。&lt;/p&gt;
&lt;p&gt;在FreeRTOS的内部实现中，软件计时器使用一块内存，其中存储着计时器数据结构。如果使用xTimerCreate（）创建软件计时器，则所需的内存将自动在xTimerCreate（）函数内部动态分配。&lt;/p&gt;
&lt;p&gt;创建后计时器处于休眠状态。xTimerStart（），xTimerReset（），xTimerStartFromISR（），xTimerResetFromISR（），xTimerChangePeriod（）和xTimerChangePeriodFromISR（）API函数均可用于将计时器转换为活动状态。&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;pcTimerName：分配给计时器的文本名称。这样做纯粹是为了协助调试。内核本身仅通过其句柄引用计时器，而从未通过其名称引用计时器。&lt;/p&gt;
&lt;p&gt;xTimerPeriodInTicks：计时器时间段。时间以滴答周期定义，因此常数portTICK_PERIOD_MS可用于转换以毫秒为单位指定的时间。例如，如果计时器必须在100个滴答之后过期，则xTimerPeriodInTicks应该设置为100。或者，如果计时器必须在500ms之后过期，则可以将xPeriod设置为（500 / portTICK_PERIOD_MS），前提是configTICK_RATE_HZ小于或等于1000。&lt;/p&gt;
&lt;p&gt;uxAutoReload：如果将uxAutoReload设置为pdTRUE，则计时器将以xTimerPeriodInTicks参数设置的频率重复终止。如果将uxAutoReload设置为pdFALSE，则该计时器将是单次计时器，并在其到期后进入休眠状态。&lt;/p&gt;
&lt;p&gt;pvTimerID：分配给正在创建的计时器的标识符。通常，在将同一回调函数分配给多个计时器时，将在计时器回调函数中使用它来标识哪个计时器到期。&lt;/p&gt;
&lt;p&gt;pxCallbackFunction：计时器到期时要调用的函数。回调函数必须具有由TimerCallbackFunction_t定义的原型，即“ void vCallbackFunction（TimerHandle_t xTimer）;”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
TimerHandle_t xTimerCreate（&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; * &lt;span&gt;const&lt;/span&gt; pcTimerName，&lt;span&gt;const&lt;/span&gt; TickType_t xTimerPeriodInTicks，&lt;span&gt;const&lt;/span&gt; UBaseType_t uxAutoReload，&lt;span&gt;void&lt;/span&gt; * &lt;span&gt;const&lt;/span&gt; pvTimerID，TimerCallbackFunction_t pxCallbackFunction ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取计时器的ID&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;使用用于创建计时器的xTimerCreated（）调用的pvTimerID参数将ID分配给计时器。&lt;/p&gt;
&lt;p&gt;如果将同一个回调函数分配给多个计时器，则可以在回调函数中使用计时器ID来标识实际终止了哪个计时器。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：计时器句柄&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;查询的计时器的ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; *pvTimerGetTimerID( &lt;span&gt;const&lt;/span&gt; TimerHandle_t xTimer )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;设置计时器ID&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设置分配给计时器的ID。&lt;/p&gt;
&lt;p&gt;使用用于创建计时器的xTimerCreated（）调用的pvTimerID参数将ID分配给计时器。&lt;/p&gt;
&lt;p&gt;如果将相同的回调函数分配给多个计时器，则计时器ID可用作特定时间（本地计时器）的存储。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：计时器句柄&lt;/p&gt;
&lt;p&gt;pvNewID：分配给计时器的ID。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTimerSetTimerID( TimerHandle_t xTimer, &lt;span&gt;void&lt;/span&gt; *pvNewID )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;启动计时器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将configUSE_TIMERS配置常量设置为1，xTimerStart（）才可用。&lt;/p&gt;
&lt;p&gt;xTimerStart（）启动一个计时器，该计时器先前是使用xTimerCreate（）API函数创建的。如果计时器已经启动并且已经处于活动状态，则xTimerStart（）具有与xTimerReset（）API函数等效的功能。&lt;/p&gt;
&lt;p&gt;启动计时器可确保计时器处于活动状态。如果同时没有停止，删除或重置计时器，则在调用xTimerStart（）之后，与计时器关联的回调函数将被称为“ n”滴答，其中“ n”是计时器定义的时间段。&lt;/p&gt;
&lt;p&gt;在启动调度程序之前调用xTimerStart（）是有效的，但是完成此操作后，计时器将不会真正启动，直到启动调度程序为止，并且计时器的到期时间将与启动调度程序有关，而不是与启动调度程序有关当xTimerStart（）被调用时。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：正在启动/重新启动的计时器的句柄。&lt;/p&gt;
&lt;p&gt;xTicksToWait：指定在调用xTimerStart（）时，如果队列已满，则调用任务应保持在Blocked状态的时间，以等待启动命令成功发送到计时器命令队列的时间（以秒为单位）。如果在调度程序启动之前调用了xTimerStart（），则xTicksToWait将被忽略，该参数的值请参考队列&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果即使经过xTicksToWait滴答声后仍无法将启动命令发送到计时器命令队列，则将返回pdFAIL。如果命令已成功发送到计时器命令队列，则将返回pdPASS。实际处理命令的时间将取决于计时器服务/守护程序任务相对于系统中其他任务的优先级，尽管计时器的到期时间与实际调用xTimerStart（）有关。计时器服务/守护程序任务优先级由configTIMER_TASK_PRIORITY配置常量设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
BaseType_t xTimerStart( xTimer, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;停止计时器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将configUSE_TIMERS配置常量设置为1，xTimerStop（）才可用。&lt;/p&gt;
&lt;p&gt;xTimerStop（）停止使用xTimerStart（），xTimerReset（），xTimerStartFromISR（），xTimerResetFromISR（），xTimerChangePeriod（）或xTimerChangePeriodFromISR（）API函数之一启动的计时器。&lt;/p&gt;
&lt;p&gt;停止计时器可确保计时器未处于活动状态。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：定时器的句柄正在停止。&lt;/p&gt;
&lt;p&gt;xTicksToWait：指定在调用xTimerStop（）时，如果队列已满，则调用任务应保持在Blocked状态的时间，以等待stop命令成功发送到计时器命令队列。如果在调度程序启动之前调用了xTimerStop（），则xTicksToWait将被忽略。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果即使经过xTicksToWait滴答声也无法将stop命令发送到计时器命令队列，则将返回pdFAIL。如果命令已成功发送到计时器命令队列，则将返回pdPASS。实际处理命令的时间将取决于计时器服务/守护程序任务相对于系统中其他任务的优先级。计时器服务/守护程序任务优先级由configTIMER_TASK_PRIORITY配置常量设置。该参数的值请参考队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xTimerStop（ xTimer，xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;重置计时器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将configUSE_TIMERS配置常量设置为1，xTimerReset（）才可用&lt;/p&gt;
&lt;p&gt;xTimerReset（）重新启动以前使用xTimerCreate（）API函数创建的计时器。如果计时器已经启动并且已经处于活动状态，则xTimerReset（）将使计时器重新评估其到期时间，以使其与调用xTimerReset（）的时间有关。如果计时器处于休眠状态，则xTimerReset（）具有与xTimerStart（）API函数等效的功能。&lt;/p&gt;
&lt;p&gt;重置计时器可确保计时器处于活动状态。如果同时没有停止，删除或重置计时器，则在调用xTimerReset（）之后，与计时器关联的回调函数将被称为“ n”滴答，其中“ n”是计时器定义的时间段。&lt;/p&gt;
&lt;p&gt;在启动调度程序之前调用xTimerReset（）是有效的，但是完成此操作后，计时器将不会真正启动，直到启动调度程序为止，并且计时器的到期时间将与启动调度程序的时间有关，而不是相对于启动调度程序的时间当xTimerReset（）被调用时。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xTimer：正在重置/启动/重新启动的计时器的句柄。&lt;/p&gt;
&lt;p&gt;xTicksToWait：指定在调用xTimerReset（）时，如果队列已满，则调用任务应保持在Blocked状态的时间，以等待重置命令成功发送到计时器命令队列的时间（以秒为单位）。如果在调度程序启动之前调用了xTimerReset（），则xTicksToWait将被忽略。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果即使经过xTicksToWait滴答声后仍无法将重置命令发送到计时器命令队列，则将返回pdFAIL。如果命令已成功发送到计时器命令队列，则将返回pdPASS。实际处理命令的时间将取决于计时器服务/守护程序任务相对于系统中其他任务的优先级，尽管计时器的到期时间与实际调用xTimerStart（）有关。计时器服务/守护程序任务优先级由configTIMER_TASK_PRIORITY配置常量设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xTimerReset（ xTimer，xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;删除计时器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将configUSE_TIMERS配置常量设置为1，xTimerDelete（）才可用。&lt;/p&gt;
&lt;p&gt;xTimerDelete（）删除以前使用xTimerCreate（）API函数创建的计时器。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：定时器的句柄被删除。&lt;/p&gt;
&lt;p&gt;xTicksToWait：指定在调用xTimerDelete（）时，如果队列已满，则调用任务应保持在Blocked状态的时间，以等待删除命令成功发送到计时器命令队列。如果在启动调度程序之前调用了xTimerDelete（），则xTicksToWait将被忽略。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果即使经过xTicksToWait滴答声后仍无法将删除命令发送到计时器命令队列，则将返回pdFAIL。如果命令已成功发送到计时器命令队列，则将返回pdPASS。实际处理命令的时间将取决于计时器服务/守护程序任务相对于系统中其他任务的优先级。计时器服务/守护程序任务优先级由configTIMER_TASK_PRIORITY配置常量设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xTimerDelete（ xTimer，xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;查看计时器的状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;计时器处于休眠状态。xTimerStart（），xTimerReset（），xTimerStartFromISR（），xTimerResetFromISR（），xTimerChangePeriod（）和xTimerChangePeriodFromISR（）API函数均可用于将计时器转换为活动状态。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：计时器句柄&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果计时器处于休眠状态，则将返回pdFALSE。如果计时器处于活动状态，则将返回pdFALSE以外的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xTimerIsTimerActive（TimerHandle_t xTimer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;更改计时器周期&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将configUSE_TIMERS配置常量设置为1，xTimerChangePeriod（）才可用&lt;/p&gt;
&lt;p&gt;xTimerChangePeriod（）更改以前使用xTimerCreate（）API函数创建的计时器的周期。&lt;/p&gt;
&lt;p&gt;可以调用xTimerChangePeriod（）来更改活动或休眠状态计时器的周期。&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;xTimer：正在更改其周期的计时器的句柄。&lt;/p&gt;
&lt;p&gt;xNewPeriod：xTimer的新时期。计时器周期以滴答周期指定，因此常数portTICK_PERIOD_MS可用于转换以毫秒为单位指定的时间。例如，如果计时器必须在100个滴答之后过期，则xNewPeriod应该设置为100。或者，如果计时器必须在500ms之后过期，那么可以将xNewPeriod设置为（500 / portTICK_PERIOD_MS），前提是configTICK_RATE_HZ小于或等于1000。 。&lt;/p&gt;
&lt;p&gt;xTicksToWait：指定在调用xTimerChangePeriod（）时队列已满的情况下，调用任务应保持在“阻塞”状态，等待更改周期命令成功发送到计时器命令队列的时间（以滴答为单位）。如果在调度程序启动之前调用了xTimerChangePeriod（），则xTicksToWait将被忽略。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果即使经过xTicksToWait滴答声之后仍无法将更改周期命令发送到计时器命令队列，则将返回pdFAIL。如果命令已成功发送到计时器命令队列，则将返回pdPASS。实际处理命令的时间将取决于计时器服务/守护程序任务相对于系统中其他任务的优先级。计时器服务/守护程序任务优先级由configTIMER_TASK_PRIORITY配置常量设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xTimerChangePeriod（ xTimer，xNewPeriod，xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取定时器周期（嘀嗒数）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：计时器句柄&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;计时器的周期，以滴答为单位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t xTimerGetPeriod（TimerHandle_t xTimer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取定时器周期（秒）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;以秒为单位返回计时器将到期的时间。如果小于当前滴答计数，则到期时间从当前时间开始溢出。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xTimer：计时器句柄&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果计时器正在运行，则将返回计时器下一次到期的时间（以秒为单位）。如果计时器未运行，则返回值不确定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t xTimerGetExpiryTime（TimerHandle_t xTimer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;获取计时器名称&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回创建计时器时分配给计时器的名称。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参量&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xTimer&lt;/span&gt;：计时器句柄&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;分配给&lt;span lang=&quot;EN-US&quot;&gt;xTimer&lt;/span&gt;参数指定的计时器的名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; * pcTimerGetTimerName（TimerHandle_t xTimer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;计时器启动&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;停止&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;重置对应的中断函数有&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参数&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xTimer&lt;/span&gt;：正在启动&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;重新启动的计时器的句柄。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;pxHigherPriorityTaskWoken&lt;/span&gt;：计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务的大部分时间都处于&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;阻塞&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态，等待消息到达计时器命令队列。调用&lt;span lang=&quot;EN-US&quot;&gt;xTimerStartFromISR&lt;/span&gt;（）会将消息写入计时器命令队列，因此有可能将计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务转换为&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;已阻止&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态。如果调用&lt;span lang=&quot;EN-US&quot;&gt;xTimerStartFromISR&lt;/span&gt;（）导致计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务退出&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;阻塞&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态，并且计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务的优先级等于或大于当前正在执行的任务（被中断的任务），则&lt;span lang=&quot;EN-US&quot;&gt;* pxHigherPriorityTaskWoken&lt;/span&gt;将获得在&lt;span lang=&quot;EN-US&quot;&gt;xTimerStartFromISR&lt;/span&gt;（）函数内部将其设置为&lt;span lang=&quot;EN-US&quot;&gt;pdTRUE&lt;/span&gt;。如果&lt;span lang=&quot;EN-US&quot;&gt;xTimerStartFromISR&lt;/span&gt;（）将此值设置为&lt;span lang=&quot;EN-US&quot;&gt;pdTRUE&lt;/span&gt;，则应在中断退出之前执行上下文切换。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;如果无法将启动命令发送到计时器命令队列，则将返回&lt;span lang=&quot;EN-US&quot;&gt;pdFAIL&lt;/span&gt;。如果命令已成功发送到计时器命令队列，则将返回&lt;span lang=&quot;EN-US&quot;&gt;pdPASS&lt;/span&gt;。实际处理命令的时间将取决于计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务相对于系统中其他任务的优先级，尽管计时器的到期时间与实际调用&lt;span lang=&quot;EN-US&quot;&gt;xTimerStartFromISR&lt;/span&gt;（）的时间有关。计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务优先级由&lt;span lang=&quot;EN-US&quot;&gt;configTIMER_TASK_PRIORITY&lt;/span&gt;配置常量设置&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;启动计时器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t  xTimerStartFromISR（ xTimer，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;停止计时器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t xTimerStopFromISR（ xTimer，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;重置计时器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t xTimerResetFromISR（ xTimer，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;计时器设置周期中断使用函数&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参量&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xTimer&lt;/span&gt;：正在更改其周期的计时器的句柄。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xNewPeriod&lt;/span&gt;：&lt;span lang=&quot;EN-US&quot;&gt;xTimer&lt;/span&gt;的新时期。计时器周期以滴答周期指定，因此常数&lt;span lang=&quot;EN-US&quot;&gt;portTICK_PERIOD_MS&lt;/span&gt;可用于转换以毫秒为单位指定的时间。例如，如果计时器必须在&lt;span lang=&quot;EN-US&quot;&gt;100&lt;/span&gt;个滴答之后过期，则&lt;span lang=&quot;EN-US&quot;&gt;xNewPeriod&lt;/span&gt;应该设置为&lt;span lang=&quot;EN-US&quot;&gt;100&lt;/span&gt;。或者，如果计时器必须在&lt;span lang=&quot;EN-US&quot;&gt;500ms&lt;/span&gt;之后过期，那么可以将&lt;span lang=&quot;EN-US&quot;&gt;xNewPeriod&lt;/span&gt;设置为（&lt;span lang=&quot;EN-US&quot;&gt;500 / portTICK_PERIOD_MS&lt;/span&gt;），前提是&lt;span lang=&quot;EN-US&quot;&gt;configTICK_RATE_HZ&lt;/span&gt;小于或等于&lt;span lang=&quot;EN-US&quot;&gt;1000&lt;/span&gt;。 。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;pxHigherPriorityTaskWoken&lt;/span&gt;：计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务的大部分时间都处于&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;阻塞&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态，等待消息到达计时器命令队列。调用&lt;span lang=&quot;EN-US&quot;&gt;xTimerChangePeriodFromISR&lt;/span&gt;（）会将消息写入计时器命令队列，因此有可能将计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务从&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;阻塞&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态转换出来。如果调用&lt;span lang=&quot;EN-US&quot;&gt;xTimerChangePeriodFromISR&lt;/span&gt;（）导致计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务退出&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;阻塞&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;状态，并且计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务的优先级等于或大于当前正在执行的任务（被中断的任务），则&lt;span lang=&quot;EN-US&quot;&gt;* pxHigherPriorityTaskWoken&lt;/span&gt;将获得在&lt;span lang=&quot;EN-US&quot;&gt;xTimerChangePeriodFromISR&lt;/span&gt;（）函数内部将其设置为&lt;span lang=&quot;EN-US&quot;&gt;pdTRUE&lt;/span&gt;。如果&lt;span lang=&quot;EN-US&quot;&gt;xTimerChangePeriodFromISR&lt;/span&gt;（）将此值设置为&lt;span lang=&quot;EN-US&quot;&gt;pdTRUE&lt;/span&gt;，则应在中断退出之前执行上下文切换。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;如果无法将更改计时器周期的命令发送到计时器命令队列，则将返回&lt;span lang=&quot;EN-US&quot;&gt;pdFAIL&lt;/span&gt;。如果命令已成功发送到计时器命令队列，则将返回&lt;span lang=&quot;EN-US&quot;&gt;pdPASS&lt;/span&gt;。实际处理命令的时间将取决于计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务相对于系统中其他任务的优先级。计时器服务&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;守护程序任务优先级由&lt;span lang=&quot;EN-US&quot;&gt;configTIMER_TASK_PRIORITY&lt;/span&gt;配置常量设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TickType_t xTimerChangePeriodFromISR（ xTimer，xNewPeriod，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;小试牛刀&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406002617764-331070291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/timers.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计时器器句柄&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; TimerHandle_t onetimer =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; TimerHandle_t cirtimer =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计时器回调函数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; oneTimerCallback( TimerHandle_t pxTimer )
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     uint32_t timerid=(uint32_t)pvTimerGetTimerID(pxTimer);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取ID&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】 回调函数触发,ID为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,timerid);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( xTimerReset( pxTimer, &lt;span&gt;100&lt;/span&gt; ) ==&lt;span&gt; pdPASS )
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】 重置成功*****\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计时器回调函数&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cirTimerCallback( TimerHandle_t pxTimer )
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【循环计时任务 cirtimer】 回调函数触发\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dong_create_timer()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个一次性计时任务&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     onetimer = xTimerCreate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong_onetimer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一个名词，便于调试&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                                     ( &lt;span&gt;2000&lt;/span&gt; / portTICK_PERIOD_MS), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时周期&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                                     pdFALSE,                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pdFALSE为单次，pdTRUE为循环&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                                     (&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;100&lt;/span&gt;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置一个ID用于标识&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                                     oneTimerCallback     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                                  );
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( onetimer !=&lt;span&gt; NULL )
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;          printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】 创建成功\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;          xTimerStart( onetimer, &lt;span&gt;10&lt;/span&gt; );&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启计数器&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个循环计时任务&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     cirtimer = xTimerCreate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong_cirtimer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置一个名词，便于调试&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                                     ( &lt;span&gt;4000&lt;/span&gt; / portTICK_PERIOD_MS), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时周期&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                                     pdTRUE,                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pdFALSE为单次，pdTRUE为循环&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                                     (&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;11&lt;/span&gt;,                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置一个ID用于标识&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;                                     cirTimerCallback     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                                  );
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( cirtimer !=&lt;span&gt; NULL )
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;          printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【循环计时任务 cirtimer】 创建成功\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;          xTimerStart( cirtimer, &lt;span&gt;10&lt;/span&gt; );&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启计时器&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建并开始计时器&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    dong_create_timer();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;taskYIELD();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务调度&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;          vTaskDelay(&lt;span&gt;10&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还是的用延时函数进行任务调度&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;在上述例程中添加延时函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计时器回调函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; oneTimerCallback( TimerHandle_t pxTimer )
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     uint32_t timerid=(uint32_t)pvTimerGetTimerID(pxTimer);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取ID&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】 回调函数触发,ID为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,timerid);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】10///秒延时开始啦\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     vTaskDelay(&lt;span&gt;10000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】10///秒延时结束啦\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( xTimerReset( pxTimer, &lt;span&gt;100&lt;/span&gt; ) ==&lt;span&gt; pdPASS )
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【单次计时任务 onetimer】 重置成功*****\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;输出：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406002721666-1595049853.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 可见：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;延时函数将阻塞定时任务，会影响到其它定时任务功能，所以定时回调函数中操作尽量少&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;事件组&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;freertos / include / freertos / event_groups.h&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;以数据位标志事件&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;创建事件组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;尽管事件组与滴答无关，但出于内部实现的原因，事件组中可使用的位数取决于FreeRTOSConfig.h中的configUSE_16_BIT_TICKS设置。如果configUSE_16_BIT_TICKS为1，则每个事件组包含8个可用位（位0至位7）。如果configUSE_16_BIT_TICKS设置为0，则每个事件组都有24个可用位（位0到位23）。EventBits_t类型用于在事件组中存储事件位。&lt;/p&gt;
&lt;p&gt;返回：事件组句柄，创建失败为NULL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventGroupHandle_t xEventGroupCreate（）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;等待事件位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;[可能]阻止等待先前创建的事件组中的一个或多个位设置。&lt;/p&gt;
&lt;p&gt;不能从中断中调用此函数&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xEventGroup：事件组句柄。事件组必须先前已通过调用xEventGroupCreate（）创建&lt;/p&gt;
&lt;p&gt;uxBitsToWaitFor：按位的值，指示事件组中要测试的一位或多位。例如，要等待位0和/或位2，请将uxBitsToWaitFor设置为0x05。要等待位0和/或位1和/或位2，请将uxBitsToWaitFor设置为0x07。等等&lt;/p&gt;
&lt;p&gt;xClearOnExit：如果xClearOnExit设置为pdTRUE，则如果满足等待条件（如果函数由于超时以外的原因返回），则在xEventGroupWaitBits（）返回之前，将清除事件组中设置的uxBitsToWaitFor中的任何位。如果xClearOnExit设置为pdFALSE，则在对xEventGroupWaitBits（）的调用返回时，事件组中设置的位不会更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xWaitForAllBits：&lt;/strong&gt;如果xWaitForAllBits设置为pdTRUE，则当uxBitsToWaitFor中的所有位都已设置或指定的块时间到期时，xEventGroupWaitBits（）将返回。如果将xWaitForAllBits设置为pdFALSE，则当设置uxBitsToWaitFor中设置的任何一位或指定的块时间到期时，xEventGroupWaitBits（）将返回。阻止时间由xTicksToWait参数指定&lt;/p&gt;
&lt;p&gt;xTicksToWait：等待设置uxBitsToWaitFor指定的位中的一个/全部（取决于xWaitForAllBits值）的最长时间（以“ ticks”指定），与其它设置等待时间一致，可以立即、一段、永远。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;在等待位被置位或块时间到期时事件组的值。测试返回值以了解设置了哪些位。如果xEventGroupWaitBits（）由于其超时到期而返回，则不会设置所有等待的位。如果由于设置了xEventGroupWaitBits（）而等待的位而返回，则在xClearOnExit参数设置为pdTRUE的情况下，返回值是在自动清除任何位之前的事件组值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
EventBits_t xEventGroupWaitBits（EventGroupHandle_t xEventGroup，&lt;span&gt;const&lt;/span&gt; EventBits_t uxBitsToWaitFor，&lt;span&gt;const&lt;/span&gt; BaseType_t xClearOnExit，&lt;span&gt;const&lt;/span&gt; BaseType_t xWaitForAllBits，TickType_t xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取事件组中当前值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;返回事件组中位的当前值。不能从中断使用此功能。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xEventGroup：正在查询的事件组&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;调用xEventGroupGetBits（）时的事件组位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventBits_t  xEventGroupGetBits（ xEventGroup ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;清除事件组中的位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;清除事件组中的位。不能从中断中调用此函数。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xEventGroup：事件组句柄，其中的位将被清除&lt;/p&gt;
&lt;p&gt;uxBitsToClear：按位表示在事件组中要清除的一个或多个位。例如，仅清除位3，将uxBitsToClear设置为0x08。要清除位3和位0，请将uxBitsToClear设置为0x09。&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;清除指定位之前的事件组的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
EventBits_t xEventGroupClearBits（EventGroupHandle_t xEventGroup，&lt;span&gt;const&lt;/span&gt; EventBits_t uxBitsToClear ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;设置事件组中的位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设置事件组中的位。不能从中断中调用此函数。xEventGroupSetBitsFromISR（）是可以从中断中调用的版本。&lt;/p&gt;
&lt;p&gt;在事件组中设置位将自动解除阻止等待这些位的任务。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xEventGroup：要设置位的事件组。&lt;/p&gt;
&lt;p&gt;uxBitsToSet：按位的值，指示要设置的一个或多个位。例如，要仅设置位3，请将uxBitsToSet设置为0x08。要设置位3和位0，请将uxBitsToSet设置为0x09。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;返回xEventGroupSetBits（）调用时事件组的值。返回值可能清除了uxBitsToSet参数指定的位有两个原因。首先，如果设置一个位导致正在等待该位离开阻塞状态的任务，则有可能该位将被自动清除（请参阅xEventGroupWaitBits（）的xClearBitOnExit参数）。其次，任何优先级高于被称为xEventGroupSetBits（）的任务的无阻塞（或就绪状态）任务都将执行，并且可能会在调用xEventGroupSetBits（）返回之前更改事件组的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventBits_t xEventGroupSetBits（EventGroupHandle_t xEventGroup，&lt;span&gt;const&lt;/span&gt; EventBits_t uxBitsToSet ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;删除事件组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;删除以前通过调用xEventGroupCreate（）创建的事件组。在事件组上被阻止的任务将被取消阻止，并获得0作为事件组的值。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xEventGroup事件组句柄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Void vEventGroupDelete（EventGroupHandle_t xEventGroup ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断中获取事件组的位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以从ISR调用的xEventGroupGetBits（）版本&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xEventGroup：正在查询的事件组&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;调用xEventGroupGetBitsFromISR（）时的事件组位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventBits_t xEventGroupGetBitsFromISR（EventGroupHandle_t xEventGroup ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断中清除数据组的位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以从中断中调用的xEventGroupClearBits（）版本。&lt;/p&gt;
&lt;p&gt;在事件组中设置位不是确定性操作，因为可能有未知数量的任务正在等待设置一个或多个位。FreeRTOS不允许在禁用中断时执行不确定的操作，因此通过挂起调度程序而不是禁用中断来保护从任务访问的事件组。结果，不能从中断服务程序直接访问事件组。因此，xEventGroupClearBitsFromISR（）向计时器任务发送一条消息，以在计时器任务的上下文中执行清除操作。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xEventGroup：事件组，其中的位将被清除。&lt;/p&gt;
&lt;p&gt;uxBitsToClear：按位的值，指示要清除的一个或多个位。例如，仅清除位3，将uxBitsToClear设置为0x08。要清除位3和位0，请将uxBitsToClear设置为0x09&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果成功执行了执行功能的请求，则返回pdPASS，否则返回pdFALSE。如果计时器服务队列已满，则将返回pdFALSE&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xEventGroupClearBitsFromISR（ xEventGroup，uxBitsToClear ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断中设置事件组的位&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以从中断中调用的xEventGroupSetBits（）版本。&lt;/p&gt;
&lt;p&gt;在事件组中设置位不是确定性操作，因为可能有未知数量的任务正在等待设置一个或多个位。FreeRTOS不允许在中断或关键部分执行不确定的操作。因此，xEventGroupSetBitFromISR（）向计时器任务发送一条消息，以在计时器任务的上下文中执行设置操作-在该上下文中，使用调度程序锁来代替关键节。&lt;/p&gt;
&lt;p&gt;参量&lt;/p&gt;
&lt;p&gt;xEventGroup：要设置位的事件组。&lt;/p&gt;
&lt;p&gt;uxBitsToSet：按位的值，指示要设置的一个或多个位。例如，要仅设置位3，请将uxBitsToSet设置为0x08。要设置位3和位0，请将uxBitsToSet设置为0x09。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：如上所述，调用此函数将导致消息发送到计时器守护程序任务。如果计时器守护程序任务的优先级高于当前正在运行的任务（中断被中断的任务）的优先级，则xEventGroupSetBitsFromISR（）将* pxHigherPriorityTaskWoken设置为pdTRUE，指示应在中断退出之前请求上下文切换。因此，必须将* pxHigherPriorityTaskWoken初始化为pdFALSE。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果成功执行了执行功能的请求，则返回pdPASS，否则返回pdFALSE。如果计时器服务队列已满，则将返回pdFALSE。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xEventGroupSetBitsFromISR（ xEventGroup，uxBitsToSet，pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406003630963-1648707813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/event_groups.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件组句柄&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; EventGroupHandle_t eventgroup=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;管理的位，&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BIT_0    (1 &amp;lt;&amp;lt; 0)
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BIT_5    (1 &amp;lt;&amp;lt; 5)
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】事件标志组等待开始---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     xEventGroupWaitBits(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                  eventgroup,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件标志组句柄&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                  BIT_0 | BIT_5, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间标志位&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                  pdTRUE,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pdTRUE为满足条件则清除返回，pdFALSE为不清除返回&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                  pdTRUE,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pdTRUE为所有标志位满足才有效，pdFALSE为部分满足有效&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                  portMAX_DELAY); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待时间，portMAX_DELAY为一直等待，0为立即返回，其它为节拍数&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】事件标志组等待结束---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】开始动作啦---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】.......................---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】结束动作啦---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建时间组&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     eventgroup=&lt;span&gt;xEventGroupCreate();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】///////开始设置位//////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】设置位：BIT_0\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;          xEventGroupSetBits(eventgroup, BIT_0);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;           vTaskDelay(&lt;span&gt;2000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】设置位：BIT_5\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;          xEventGroupSetBits(eventgroup, BIT_5);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】设置位：BIT_5|BIT_0 \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;           xEventGroupSetBits(eventgroup, BIT_5|&lt;span&gt;BIT_0);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; /&lt;span&gt; portTICK_PERIOD_MS);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;任务通知&lt;/h2&gt;
&lt;p&gt;任务通知在FreeRTOS中是一个可选的功能,要使用任务通知的话就需要将宏contfigUSE TASK NOTIFICATIONS定义为1&lt;/p&gt;
&lt;p&gt;FreeRTOS的每个任务都有一个32位的通知值,任务控制块中的成员变量ulNotifiedValue就是这个通知值。任务通知是一个事件,假如某个任务通知的接收任务因为等待任务通知而阻塞的话,向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态。也可以更新接收任务的任务通知值,任务通知可以通过如下方法更新接收任务的通知值:&lt;/p&gt;
&lt;p&gt;不覆盖接收任务的通知值(如果上次发送给接收任务的通知还没被处理)。&lt;/p&gt;
&lt;p&gt;覆盖接收任务的通知值。&lt;/p&gt;
&lt;p&gt;更新接收任务通知值的一个或多个bit.增加接收任务的通知值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合理、灵活的使用上面这些更改任务通知值的方法可以在一些场合中替代队列、二值信号·量、计数型信号量和事件标志组。使用任务通知来实现二值信号量功能的时候,解除任务阻塞的时间比直接使用二值信号量要快45%(FreeRTOS官方测试结果,使用v8.1.2版本中的二值信号量, GCC编译器,-02优化的条件下测试的,没有使能断言函数configASSERTO),并且使用的RAM更少!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;任务通知的发送使用函数xTaskNotify)或者xTaskNotifyGive)(还有此函数的中断版本)来完成,这个通知值会一直被保存着,直到接收任务调用函数xTaskNotifyWait)或者ulTaskNotifyTake)来获取这个通知值。假如接收任务因为等待任务通知而阻塞的话那么在接收到任务通知以后就会解除阻塞态。任务通知虽然可以提高速度,并且减少RAM的使用,但是任务通知也是有使用限制的:&lt;/p&gt;
&lt;p&gt;FreeRTOS的任务通知只能有一个接收任务,其实大多数的应用都是这种情况。&lt;/p&gt;
&lt;p&gt;接收任务可以因为接收任务通知而进入阻塞态,但是发送任务不会因为任务通知发送失败而阻塞&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;发送任务通知&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;configUSE_TASK_NOTIFICATIONS必须未定义或定义为1才能使此功能可用。&lt;/p&gt;
&lt;p&gt;将configUSE_TASK_NOTIFICATIONS设置为1时，每个任务都有其自己的专用“通知值”，该值是32位无符号整数（uint32_t）。&lt;/p&gt;
&lt;p&gt;可以使用中介对象将事件发送到任务。此类对象的示例是队列，信号量，互斥对象和事件组。任务通知是一种将事件直接发送到任务而无需此类中介对象的方法。&lt;/p&gt;
&lt;p&gt;发送给任务的通知可以选择执行某项操作，例如更新，覆盖或增加任务的通知值。这样，任务通知可用于将数据发送到任务，或用作轻量级和快速二进制或计数信号量。&lt;/p&gt;
&lt;p&gt;发送给任务的通知将保持待处理状态，直到任务调用xTaskNotifyWait（）或ulTask​​NotifyTake（）将其清除为止。如果通知到达时任务已经处于“阻止”状态以等待通知，则该任务将自动从“阻止”状态中删除（取消阻止），并清除通知。&lt;/p&gt;
&lt;p&gt;任务可以使用xTaskNotifyWait（）来[可选地]阻塞以等待通知挂起，或者使用ulTask​​NotifyTake（）来[可选地]阻塞以等待其通知值具有非零值。处于“阻塞”状态时，该任务不会消耗任何CPU时间。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xTaskToNotify：通知任务的句柄。可以从用于创建任务的xTaskCreate（）API函数返回任务的句柄，并且可以通过调用xTaskGetCurrentTaskHandle（）获得当前正在运行的任务的句柄。&lt;/p&gt;
&lt;p&gt;ulValue：可以随通知一起发送的数据。数据的使用方式取决于eAction参数的值。&lt;/p&gt;
&lt;p&gt;eAction：指定通知如何更新任务的通知值（如果有的话）。eAction的有效值如下：&lt;/p&gt;
&lt;p&gt;eNoAction = 0，无动作，通知任务而不更新其通知值。始终返回pdPASS。&lt;/p&gt;
&lt;p&gt;eSetBits, 任务的通知值与ulValue按位或，始终返回pdPASS。&lt;/p&gt;
&lt;p&gt;eIncrement, 任务的通知值增加1，始终返回pdPASS。&lt;/p&gt;
&lt;p&gt;eSetValueWithOverwrite, 复写方式更新通知值，不管任务是否读取该值，都将更新通知值，始终返回pdPASS&lt;/p&gt;
&lt;p&gt;esetvaluewithoutoverwrite果任务已经读取了之前的值，则设置任务的通知值。如果被通知的任务尚未有待处理的通知，则该任务的通知值将设置为ulValue，xTaskNotify（）将返回pdPASS。如果要通知的任务已经有待处理的通知，则不执行任何操作，并返回pdFAIL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xTaskNotify（TaskHandle_t xTaskToNotify，uint32_t ulValue，eNotifyAction eAction ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;ISR发送任务通知&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;configUSE_TASK_NOTIFICATIONS必须未定义或定义为1才能使此功能可用。&lt;/p&gt;
&lt;p&gt;相较于xTaskNotify多了如下参数：&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：如果发送通知导致发送通知的任务离开阻塞状态，并且未阻塞任务的优先级高于当前运行的任务，则xTaskNotifyFromISR（）会将* pxHigherPriorityTaskWoken设置为pdTRUE。如果xTaskNotifyFromISR（）将此值设置为pdTRUE，则应在退出中断之前请求上下文切换。从ISR请求上下文切换的方式取决于端口-有关正在使用的端口，请参阅文档页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
BaseType_t xTaskNotifyFromISR（TaskHandle_t xTaskToNotify，uint32_t ulValue，eNotifyAction eAction，BaseType_t * pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;等待任务通知&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;configUSE_TASK_NOTIFICATIONS必须未定义或定义为1才能使此功能可用。&lt;/p&gt;
&lt;p&gt;任务可以使用xTaskNotifyWait（）来[可选地]阻塞以等待通知挂起，或者使用ulTask​​NotifyTake（）来[可选地]阻塞以等待其通知值具有非零值。处于“阻塞”状态时，该任务不会消耗任何CPU时间。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;l  ulBitsToClearOnEntry注意：等待前的清除，在检查任务是否有待处理的通知之前，将在调用任务的通知值中清除ulBitsToClearOnEntry值中设置的位，如果没有待处理的通知，则将阻塞该任务。将ulBitsToClearOnEntry设置为ULONG_MAX（如果包括limits.h）或0xffffffffUL（如果不包括limits.h）将具有将任务的通知值重置为0的作用。将ulBitsToClearOnEntry设置为0将使任务的通知值保持不变。&lt;/p&gt;
&lt;p&gt;l  ulBitsToClearOnExit：退出等待的清除，如果在调用任务退出xTaskNotifyWait（）函数之前有待处理或已收到通知，则使用pulNotificationValue参数传递任务的通知值（请参阅xTaskNotify（）API函数）。然后，将在任务的通知值中清除在ulBitsToClearOnExit中设置的所有位（请注意，在清除任何位之前已设置* pulNotificationValue）。将ulBitsToClearOnExit设置为ULONG_MAX（如果包括limits.h）或0xffffffffUL（如果不包括limits.h）将在功能退出之前将任务的通知值重置为0。将ulBitsToClearOnExit设置为0将在函数退出时使任务的通知值保持不变（在这种情况下，在pulNotificationValue中传递的值将与任务的通知值匹配）。&lt;/p&gt;
&lt;p&gt;l  pulNotificationValue：用于将任务的通知值传递出函数。注意，由于ulBitsToClearOnExit非零而导致清除任何位，不会影响传递的值。&lt;/p&gt;
&lt;p&gt;l  xTicksToWait：如果在调用xTaskNotifyWait（）时通知尚未挂起，则任务在“已阻止”状态下等待接收通知的最长时间。处于“阻塞”状态时，该任务不会消耗任何处理时间。这是在内核滴答中指定的，宏pdMS_TO_TICSK（value_in_ms）可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;如果收到通知（包括调用xTaskNotifyWait时已待处理的通知），则返回pdPASS。否则，返回pdFAIL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
BaseType_t xTaskNotifyWait（ uint32_t ulBitsToClearOnEntry，uint32_t ulBitsToClearOnExit，uint32_t * pulNotificationValue，TickType_t xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;简化的通知&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;适用于模拟任务对任务的二值信号量和计数型信号量功能&lt;/p&gt;
&lt;p&gt;参数：接收的任务句柄&lt;/p&gt;
&lt;p&gt;返回：始终返回pdPASS&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xTaskNotifyGive（ xTaskToNotify ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;p&gt;可见，其功能是给eAction参数的值进行加一操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;简化的接收&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;适用于模拟任务对任务的二值信号量和计数型信号量功能&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xClearCountOnExit：如果xClearCountOnExit为pdFALSE，则函数退出时任务的通知值将减小。这样，通知值就像计数信号量一样。如果xClearCountOnExit不是pdFALSE，则函数退出时，任务的通知值将清除为零。这样，通知值的作用就像一个二进制信号量。&lt;/p&gt;
&lt;p&gt;xTicksToWait：如果在调用ulTask​​NotifyTake（）时计数尚未大于零，则任务应在“阻塞”状态下等待的最大时间，以使该任务的通知值大于零。处于“阻塞”状态时，该任务不会消耗任何处理时间。这是在内核滴答中指定的，宏pdMS_TO_TICSK（value_in_ms）可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;任务的通知计数在清零或递减之前（请参阅xClearCountOnExit参数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
uint32_t ulTaskNotifyTake（ BaseType_t xClearCountOnExit，TickType_t xTicksToWait ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其功能是给eAction参数的值进行减一或清零操作&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀(任务同步效果)&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406004118536-185548738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务句柄&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; TaskHandle_t TaskH_0=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      uint32_t Noti_vlaue=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          参数1：进入时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;          参数2：退出时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;          参数3：通知值获取
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          参数4：等待时间
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;           xTaskNotifyWait(ULONG_MAX,ULONG_MAX,&amp;amp;&lt;span&gt;Noti_vlaue,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】接收到通知，其值为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,Noti_vlaue);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;,&amp;amp;&lt;span&gt;TaskH_0);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】即将发送一次通知\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;          参数1：任务句柄
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;          参数2：通知值
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;          参数3：
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;               eNoAction = 0，无动作，通知任务而不更新其通知值
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;               eSetBits, 任务的通知值与ulValue按位或
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;               eIncrement, 任务的通知值增加1
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;               eSetValueWithOverwrite, 复写方式更新通知值，不管任务是否读取该值，都将更新通知值
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;               eSetValueWithoutOverwrite 果任务已经读取了之前的值，则设置任务的通知值
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;           xTaskNotify(TaskH_0,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,eNoAction); 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀(任务同步与值传递效果)&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406004200372-1541656862.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务句柄&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; TaskHandle_t TaskH_0=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      uint32_t Noti_vlaue=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          参数1：进入时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;          参数2：退出时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;          参数3：通知值获取
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          参数4：等待时间
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;           xTaskNotifyWait(ULONG_MAX,ULONG_MAX,&amp;amp;&lt;span&gt;Noti_vlaue,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】接收到通知，其值为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,Noti_vlaue);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;,&amp;amp;&lt;span&gt;TaskH_0);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     uint32_t num=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】即将发送一次通知\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;           num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;          参数1：任务句柄
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;          参数2：通知值
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;          参数3：
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;               eNoAction = 0，无动作，通知任务而不更新其通知值
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;               eSetBits, 任务的通知值与ulValue按位或
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;               eIncrement, 任务的通知值增加1
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;               eSetValueWithOverwrite, 复写方式更新通知值，不管任务是否读取该值，都将更新通知值
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;               eSetValueWithoutOverwrite 如果任务已经读取了之前的值，则设置任务的通知值
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;          xTaskNotify(TaskH_0,num,eSetValueWithoutOverwrite); 
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;小试牛刀(任务同步与自动加一效果)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200406004236716-139388529.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/semphr.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务句柄&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; TaskHandle_t TaskH_0=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      uint32_t Noti_vlaue=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          参数1：进入时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;          参数2：退出时，传递的参数取反后按位与来设定任务通知初值（ULONG_MAX表示清零，0表示值不变，其他值按规则）
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;          参数3：通知值获取
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          参数4：等待时间
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;           xTaskNotifyWait(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&amp;amp;&lt;span&gt;Noti_vlaue,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【task 0】接收到通知，其值为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,Noti_vlaue);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;,&amp;amp;&lt;span&gt;TaskH_0);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】DONG 即将发送一次通知\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;          参数1：任务句柄
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;          参数2：通知值
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;          参数3：
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;               eNoAction = 0，无动作，通知任务而不更新其通知值
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;               eSetBits, 任务的通知值与ulValue按位或
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;               eIncrement, 任务的通知值增加1
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;               eSetValueWithOverwrite, 复写方式更新通知值，不管任务是否读取该值，都将更新通知值
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;               eSetValueWithoutOverwrite 如果任务已经读取了之前的值，则设置任务的通知值
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;           xTaskNotify(TaskH_0,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,eIncrement); 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhidao.baidu.com/question/7412988.html&quot;&gt;https://zhidao.baidu.com/question/7412988.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.freertos.org/&quot;&gt;https://www.freertos.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ESP32文档：&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/v4.0/api-reference/system/freertos.html&quot;&gt;https://docs.espressif.com/projects/esp-idf/en/v4.0/api-reference/system/freertos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正点原子&lt;/p&gt;
</description>
<pubDate>Mon, 06 Apr 2020 16:44:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>本文章总结基于官方FreeRTOS手册，测试系统为ESP32的IDF 4.0 本篇续上一篇《不可被忽视的操作系统（ FreeRTOS ）【1】》 其中上一篇主要内容为： FreeRTOS介绍 Free</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/12640208.html</dc:identifier>
</item>
<item>
<title>Netty为什么不直接用AtomicXXX，而要用AtomicXXXFieldUpdater去更新变量呢？ - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/12650686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/12650686.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/682679/202004/682679-20200407000000154-628901431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PN8ICUJ8dHDmRjLkPglhLXZzdq024mCyxgorqM7Lq8R2TTiaSGicpaSamSW4V63XOwUMHJtKVZtgO2t4ef8kEfGw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;45&quot;/&gt;更多技术分享可关注我&lt;/p&gt;

&lt;p&gt;如果仔细阅读过Netty的线程调度模型的源码，或者NIO线程对象及其线程池的创建源码，那么肯定会遇到类似“AtomicIntegerFieldUpdater”的身影，不禁想知道——Netty为何不直接使用原子类包装普通的比如计数的变量？&lt;/p&gt;
&lt;p&gt;下面带着这个疑问，深入Netty以及JDK源码去窥探一二，顺便学习先进的用法。原文：​&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NzI3OQ==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=8343bd6fa644e52904eb7cc9a807a48d&amp;amp;chksm=fbc09259ccb71b4fc3ce267731f9d28f2e0c140e152e1a5968408f25845bde83115a5855b47e#rd&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot;&gt;Netty为什么不直接用AtomicXXX，而要用AtomicXXXFieldUpdater去更新变量呢？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在JDK里，Atomic 开头的原子操作类有很多，涉及到 Java 常用的数字类型的，基本都有相应的 Atomic 原子操作类，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PN8ICUJ8dHDhyBSspiaxDfZrwzzNtYuauRNfAY6WHicmGNHyfBeDw7Ot4ibQBuak7CGJsmoVp1gBK17ft0x6UuRRg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6719101123595506&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1335&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原子操作类都是线程安全的，编码时可以放心大胆的使用。下面以其中常用的AtomicInteger原子类为例子，分析这些原子类的底层实现机制，辅助理解Netty为何没有直接使用原子类。具体使用的demo就不写了，想必Javaer都多少用过或者见过，直接看AtomicInteger类核心源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简化了部分非核心源码&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;​
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化，简化了部分非核心源码&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; AtomicInteger(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialValue) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     value =&lt;span&gt; initialValue;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; get() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自增 1，并返回自增之前的值    &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndIncrement() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自减 1，并返回自增之前的值    &lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndDecrement() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, -1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上，AtomicInteger可以对int类型的值进行线程安全的自增或者自减等操作。从源码中可以看到，线程安全的操作方法底层都是使用unsafe方法实现，这是一个JDK的魔法类，能实现很多贴近底层的功能，所以并不是Java的实现的，但是能保证底层的这些getAndXXX操作都是线程安全的，关于unsafe具体的用法和细节，可以参考这篇文章Java魔法类：Unsafe应用解析(https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html，可能无法直接打开，复制黏贴到浏览器即可)&lt;/p&gt;
&lt;p&gt;题外话：如果AtomicXXX的对象是自定义类型呢？不要慌，Java 也提供了自定义类型的原子操作类——AtomicReference，它操作的对象是个泛型对象，故能支持自定义的类型，其底层是没有自增方法的，操作的方法可以作为函数入参传递，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 x 执行 accumulatorFunction 操作
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; accumulatorFunction 是个函数，可以自定义想做的事情
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回老值&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V getAndAccumulate(V x,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                                 BinaryOperator&amp;lt;V&amp;gt;&lt;span&gt; accumulatorFunction) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; prev 是老值，next 是新值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    V prev, next;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋 + CAS 保证一定可以替换老值&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         prev =&lt;span&gt; get();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行自定义操作&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         next =&lt;span&gt; accumulatorFunction.apply(prev, x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;compareAndSet(prev, next));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; prev;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Java5中，JDK就开始提供原子类了，当然也包括原子的更新器——即后缀为FieldUpdater的类，如下Integer、Long，还有一个自定义类型的原子更新器，共三类：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PN8ICUJ8dHDhyBSspiaxDfZrwzzNtYuaujpTkymIPSN0BSnic5wib4MpZfkPia9eZwmoS98Y4OUI8NlNEQYsxwlUjA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.1388888888888889&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些原子更新器常见于各种优秀的开源框架里，而很少被普通的业务程序员直接使用，其实这些原子更新器也可以被用来包装共享变量（必须是volatile修饰的对象属性），来为这些共享变量实现原子更新的功能。这些被包装的共享变量可以是原生类型，也可以是引用类型，那么不禁要问：已经有了原子类，为啥还额外提供一套原子更新器呢？ &lt;/p&gt;
&lt;p&gt;简单的说有两个原因，以int变量为例，基于AtomicIntegerFieldUpdater实现的原子计数器，比单纯的直接用AtomicInteger包装int变量的花销要小，因为前者只需要一个全局的静态变量AtomicIntegerFieldUpdater即可包装volatile修饰的非静态共享变量，然后配合CAS就能实现原子更新，而这样做，使得后续同一个类的每个对象中只需要共享这个静态的原子更新器即可为对象计数器实现原子更新，而原子类是为同一个类的每个对象中都创建了一个计数器 + AtomicInteger对象，这种开销显然就比较大了。&lt;/p&gt;
&lt;p&gt;下面看一个JDK使用原子更新器的例子，即JDK的BufferedInputStream，如下是源码的片段节选：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BufferedInputStream &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; FilterInputStream {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_BUFFER_SIZE = 8192&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; buf[];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * Atomic updater to provide compareAndSet for buf. This is
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * necessary because closes can be asynchronous. We use nullness
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * of buf[] as primary indicator that this stream is closed. (The
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &quot;in&quot; field is also nulled out on close.)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         AtomicReferenceFieldUpdater&amp;lt;BufferedInputStream, &lt;span&gt;byte&lt;/span&gt;[]&amp;gt; bufUpdater =
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        AtomicReferenceFieldUpdater.newUpdater
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         (BufferedInputStream.&lt;span&gt;class&lt;/span&gt;,  &lt;span&gt;byte&lt;/span&gt;[].&lt;span&gt;class&lt;/span&gt;, &quot;buf&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，每个BufferedInputStream对象都包含了一个buf属性，该属性是对象属性，且被volition修饰，并被原子更新器AtomicReferenceFieldUpdater包装，注意这个引用类型的原子更新器是静态类型的，这意味着不论用户创建了多少个BufferedInputStream对象，在全局都只有这一个原子更新器被创建，这里之所以不用原子类AtomicReference直接包装buf属性，是因为buf是一个byte数组，通常会是一个比较大的对象，如果用原子类直接包装，那么后续每个BufferedInputStream对象都会额外创建一个原子类的对象，会消耗更多的内存，负担较重，因此JDK直接使用了原子更新器代替了原子类，Netty源码中的类似使用也是如出一辙。&lt;/p&gt;
&lt;p&gt;另外一个重要原因是使用原子更新器，不会破坏共享变量原来的结构，回到上述JDK的例子，buf对外仍然可以保留buf对象的原生数组属性，只不过多了一个volatile修饰，外界可以直接获取到这个byte数组实现一些业务逻辑，而且在必要的时候也能使用原子更新器实现原子更新，可谓两头不耽误，灵活性较强！&lt;/p&gt;
&lt;p&gt;还有一个可能的疑问点需要理解，即原子更新器虽然是静态的，但是其修饰的共享变量确仍然是类的对象属性，即每个类的对象仍然是只包含自己那独一份的共享变量，不会因为原子更新器是静态的，而受到任何影响。&lt;/p&gt;
&lt;p&gt;结论：实现原子更新最佳的方式是直接使用原子更新器实现。一方面是更节省内存，另一方面是不破坏原始的共享变量，使用起来更灵活。当然如果是时延要求没有那么高的场景，那么就不需要这么严苛，直接使用原子类就OK，毕竟原子类的编码简单，开发效率高，不易出错。&lt;/p&gt;

&lt;p&gt;前面说了很多理论，下面看一段Netty源码，看Netty是如何优雅的使用原子更新器的。下面是Netty的NIO线程实现类——SingleThreadEventExecutor的部分源码，省略了很多和本次分析无关的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Abstract base class for {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; OrderedEventExecutor}'s that execute all its submitted tasks in a single thread.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SingleThreadEventExecutor &lt;span&gt;extends&lt;/span&gt; AbstractScheduledEventExecutor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OrderedEventExecutor {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ST_NOT_STARTED = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ST_STARTED = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ST_SHUTTING_DOWN = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ST_SHUTDOWN = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ST_TERMINATED = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;​
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicIntegerFieldUpdater&amp;lt;SingleThreadEventExecutor&amp;gt;&lt;span&gt; STATE_UPDATER;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicReferenceFieldUpdater&amp;lt;SingleThreadEventExecutor, ThreadProperties&amp;gt;&lt;span&gt; PROPERTIES_UPDATER;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;​
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         AtomicIntegerFieldUpdater&amp;lt;SingleThreadEventExecutor&amp;gt; updater =
&lt;span&gt;17&lt;/span&gt;                 PlatformDependent.newAtomicIntegerFieldUpdater(SingleThreadEventExecutor.&lt;span&gt;class&lt;/span&gt;, &quot;state&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (updater == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             updater = AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.&lt;span&gt;class&lt;/span&gt;, &quot;state&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         STATE_UPDATER =&lt;span&gt; updater;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;​
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Queue&amp;lt;Runnable&amp;gt;&lt;span&gt; taskQueue;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Executor executor;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Thread thread;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state = ST_NOT_STARTED;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上截取了一小片段，并删除了注释，可以清晰的看到Netty封装了JDK的Thread对象，一些标识线程状态的静态常量，线程执行器，异步任务队列，以及标识线程状态的属性state等，其中重点关注state，这个属性是普通的共享变量，由volatile修饰，并且被静态的原子更新器STATE_UPDATER包装。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;下面看NIO线程的启动源码：&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * NioEventLoop线程启动方法, 这里会判断本NIO线程是否已经启动
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startThread() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (STATE_UPDATER.get(&lt;span&gt;this&lt;/span&gt;) ==&lt;span&gt; ST_NOT_STARTED) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (STATE_UPDATER.compareAndSet(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, ST_NOT_STARTED, ST_STARTED)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                doStartThread();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注释写到了，启动NIO线程之前会做一次是否已经启动的判断，避免重复启动，这个判断逻辑就是前面提到的原子更新器实现的，当本NIO线程实例没有启动时，会做一次CAS计算，注意CAS对应操作系统的一个指令，是原子操作，如果是多个外部线程在启动NIO线程，那么同时只有一个外部线程能启动成功一次，后续的线程不会重复启动这个NIO线程。保证在NIO线程的一次生命周期内，外部线程只能调用一次doStartThread()方法，这样可以实现无锁更新，且没有自旋，性能较好，这里之所以不需要自旋，是因为启动线程就应该是一锤子买卖，启动不成功，就说明是已经启动了，直接跳过，无需重试。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在看一个自旋的用法：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PN8ICUJ8dHDhyBSspiaxDfZrwzzNtYuauKwUorCsiaGIaj3f9kpu4Yve26nRicW4UcoXRxAfZrIFWOpFOxzL2HGgg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.39644218551461247&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在NIO线程被优雅（也可能异常）关闭时，会在死循环里，结合CAS算法，原子更新当前NIO线程的状态为关闭中。。。这里有两个注意事项：&lt;/p&gt;
&lt;p&gt;1、和线程安全的启动NIO线程的逻辑不一样，更新线程状态必须成功，不是一锤子买卖，所以需要自旋重试，直到CAS操作成功&lt;/p&gt;
&lt;p&gt;2、需要使用局部变量缓存外部的共享变量的旧值，保证CAS操作执行期间该共享变量的旧值不被外部线程修改&lt;/p&gt;
&lt;p&gt;3、同样的，每次执行CAS操作之前，必须判断一次旧值，只有符合更新条件，才真的执行CAS操作，否则说明已经被外界线程更新成功，无需重复操作，以提升性能。&lt;/p&gt;

&lt;p&gt;Netty这样做也侧面反映Nerty的源码确实很优秀，平时的业务开发，如果有类似场景，那么可以参考学习这两类用法。&lt;/p&gt;

&lt;p&gt;总结使用原子更新器的注意事项：&lt;/p&gt;
&lt;p&gt;1、包装的必须是被volatile修饰的共享变量&lt;/p&gt;
&lt;p&gt;2、包装的必须是非静态的共享变量&lt;/p&gt;
&lt;p&gt;3、必须搭配CAS的套路自行实现比较并交换的逻辑&lt;/p&gt;
&lt;p&gt;4、自行实现比较并交换的逻辑时需要注意：如果是非一锤子买卖的原子更新操作，那么必须用局部变量缓存外部的共享变量的旧值，具体原因可以参考：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjY0NzI3OQ==&amp;amp;mid=2247484215&amp;amp;idx=1&amp;amp;sn=44ab21f20726699a33f519c80704fc60&amp;amp;chksm=fbc09537ccb71c213063f5873171d6f86dce8a193be5981c2c9a3ec4f80b55971fe63e226241&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Netty的线程调度模型分析（10）&lt;/a&gt;《多线程环境下，实例变量转为局部变量的程序设计技巧》，且放在一个循环里操作，以保证最终一致性。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;dashuai的博客是终身学习践行者，大厂程序员，且专注于工作经验、学习笔记的分享和日常吐槽，包括但不限于互联网行业，附带分享一些PDF电子书，资料，帮忙内推，欢迎拍砖！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201907/682679-20190713011215841-1668438366.png&quot; alt=&quot;&quot; width=&quot;1005&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Apr 2020 16:10:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>更多技术分享可关注我 前言 如果仔细阅读过Netty的线程调度模型的源码，或者NIO线程对象及其线程池的创建源码，那么肯定会遇到类似“AtomicIntegerFieldUpdater”的身影，不禁想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kubixuesheng/p/12650686.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的楼宇智能化集成系统（一） - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12650621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12650621.html</guid>
<description>&lt;p&gt;      界面通过 2D 图纸叠加在3D 场景上来实现 2D 界面 与 3D 场景的融合，2D 界面通过自动布局的机制实现了手机端与电脑端的响应式呈现。&lt;/p&gt;&lt;p&gt;      通过 2D 视图的组件 &lt;strong&gt;ht.graph.&lt;/strong&gt;&lt;span id=&quot;anchor_8&quot;&gt;&lt;strong&gt;GraphView&lt;/strong&gt; 和 3D 视图的组件 &lt;strong&gt;ht.graph3d.&lt;/strong&gt;&lt;span id=&quot;anchor_8&quot;&gt;&lt;strong&gt;Graph3dView&lt;/strong&gt; 创建出呈现 2D 视图的组件类 g2d 以及呈现 3D 视图的组件类 g3d，在分别获取各自的数据模型 DataModel，来对图纸场景做一些数据可视化的操作，这里值得一提的是，我对于 2D 界面和 3D 场景的融合，是通过把 getView() 获取到 g3d 拓扑组件的根层 div，然后 addToDOM() 将 g2d 组件加入到指定的 DOM 元素底下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;144.63223630569&quot;&gt;

&lt;p&gt;3D 场景加载主视图为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200220212404928-750312682.png&quot; alt=&quot;&quot; width=&quot;985&quot; height=&quot;554&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      首先我搭建了一个 3D 的场景用来放置我们的 json 场景数据，利用 &lt;strong&gt;ht.Default.xhrLoad&lt;/strong&gt; 函数解析 json 场景数据，并通过 deserialize 将反序列化的对象加入DataModel来显示加载 3D 场景，有兴趣的可以通过&lt;a title=&quot;HT的序列化手册&quot; href=&quot;https://www.hightopo.com/guide2/ht/guide/core/serialization/ht-serialization-guide.html&quot; target=&quot;_blank&quot;&gt;&amp;lt;HT的序列化手册&amp;gt;&lt;/a&gt;来了解这一机制的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
ht.Default.xhrLoad('scenes/demo.json', (json) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;if (!json) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
    g3dDm.deserialize(json);

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置三维视图的中心点和相机位置
    g3d.setCenter([-342, -64, 389&lt;span data-mce-=&quot;&quot;&gt;]);
    g3d.setEye([-355, 10833, 2642&lt;span data-mce-=&quot;&quot;&gt;]);

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置最远距离
    g3d.setFar(1000000&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取球图标，设置为天空球
    let skybox = g3dDm.getDataByTag('skyBox'&lt;span data-mce-=&quot;&quot;&gt;);
    g3d.setSkyBox(skybox);

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 模型加载完后执行动画
    const modelList =&lt;span data-mce-=&quot;&quot;&gt; [];
    g3dDm.each(d =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        const shape3d = d.s('shape3d'&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;if (!shape3d || !shape3d.endsWith('.json')) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;if (ht.Default.getShape3dModel(shape3d)) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        modelList.push(shape3d);
    });
    ht.Default.handleModelLoaded = (name, model) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        const index =&lt;span data-mce-=&quot;&quot;&gt; modelList.indexOf(name);
        &lt;span data-mce-=&quot;&quot;&gt;if (index &amp;lt; 0) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        modelList.splice(index, 1&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;if (modelList.length &amp;gt; 91) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        ht.Default.handleModelLoaded = () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        };

        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 模型加载完侯，默认执行场景切换动画
        g3d.moveCamera([257, 713, 1485], [7, 40, 144&lt;span data-mce-=&quot;&quot;&gt;], {
            duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
            finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.load2D();
            }
        });
    };
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2D 面板加载视图为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200220212650241-1122491087.png&quot; alt=&quot;&quot; width=&quot;1087&quot; height=&quot;611&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      同样，我搭建了一个 2D 的场景用来放置我们的 json 矢量图，利用 &lt;strong&gt;ht.Default.xhrLoad&lt;/strong&gt; 函数将 json 矢量背景图反序列化显示在 2D 面板数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ht.Default.xhrLoad('displays/demo.json', (json) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;if (!json) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
    g2dDm.deserialize(json);

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 面板动画入口
    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.tittleAnim();
    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.panelTime();

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 2D图纸加载完后执行事件处理
    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.loaded2DHandler();
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;二、3D 动画效果以及切换漫游&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      对于 3D 建模下的楼宇建筑，加上场景的全方位漫游，可使用户达到一种沉浸式的体验，更加直观地去感受这个楼宇下各个场景的联系，依次地介绍了冷站、智慧末端以及热站的位置以及功能运作的动画 。主要运用的方法是通过借助 &lt;strong&gt;HT&lt;/strong&gt; 提供的 &lt;strong&gt;ht.Shape&lt;/strong&gt; 图元类型，可以在 &lt;strong&gt;GraphView&lt;/strong&gt; 和 &lt;strong&gt;Graph3dView&lt;/strong&gt; 组件上展示出各种二维和三维的形状效果，而漫游的管道路线就是由其扩展子类 &lt;strong&gt;ht.Polyline&lt;/strong&gt; 去绘制实现一条三维的管道，然后用这条绘制的管道加上漫游的时间去调用这个漫游的方法，其本质上是围绕着中心点，然后根据管道去不断地改变视角下的 &lt;strong&gt;eye&lt;/strong&gt; 和 &lt;strong&gt;center&lt;/strong&gt; 的数值，达到环视这个建筑的整体视角。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406222724773-1219355409.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      这里可以了解一下关于空间轨道的绘制，详见&lt;a title=&quot;HT的形状手册&quot; href=&quot;https://www.hightopo.com/guide2/ht/guide/core/shape/ht-shape-guide.html#ref_polyline&quot; target=&quot;_blank&quot;&gt;&amp;lt;HT的形状手册&amp;gt;&lt;/a&gt;的空间管线章节。&lt;/p&gt;
&lt;p&gt;      以下是环视漫游动画的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;polyLineRoam(polyLine, time) {
    const g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d;
    const g3dDm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3dDm;
    &lt;span data-mce-=&quot;&quot;&gt;this.roamButton.a('active', &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;this.roamAnim =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim({
        duration: time,
        easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t,
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            let length = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.main.g3d.getLineLength(polyLine),
            offset = &lt;span data-mce-=&quot;&quot;&gt;this.main.g3d.getLineOffset(polyLine, length *&lt;span data-mce-=&quot;&quot;&gt; v),
            point =&lt;span data-mce-=&quot;&quot;&gt; offset.point,
            px =&lt;span data-mce-=&quot;&quot;&gt; point.x,
            py =&lt;span data-mce-=&quot;&quot;&gt; point.y,
            pz =&lt;span data-mce-=&quot;&quot;&gt; point.z;

            g3d.setEye(px, py, pz);
            g3d.setCenter(7, 40, 144&lt;span data-mce-=&quot;&quot;&gt;);
        },
        finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.roam1();
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      在整体建筑的环视漫游完后，我们可以通过拉近各个场景的视角，来依次巡视各个场景所执行的动画。在根据管道改变 &lt;strong&gt;eye &lt;/strong&gt;和 &lt;strong&gt;center&lt;/strong&gt; 环视漫游方法结束后，用动画的结束回调 &lt;strong&gt;finishFunc&lt;/strong&gt; 去调用下一个动画的执行，而巡视漫游就在这里去调用，以下我们以巡视冷站的漫游动画为例去介绍实现的方法。&lt;/p&gt;
&lt;p&gt;      巡视漫游的主要实现方法是通过 &lt;strong&gt;HT&lt;/strong&gt; 核心包的相机移动 &lt;strong&gt;moveCamera&lt;/strong&gt; 来实现的， 通过参数 (eye, center, animation) 来调用这个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;eye&lt;/strong&gt;：新的相机位置，形如[-291, -8, 283]，如果为 null 则使用当前相机的位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;center&lt;/strong&gt;：新的目标中心点位置（相机看向的位置），形如[148, -400, 171]，如果为 null 则使用当前中心点位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;animation&lt;/strong&gt;：默认 false，是否启用动画，可以设置为 true 或者 flase 或者 animation 动画对象；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      每次执行完一个场景的视角移动后，再通过相机移动动画的结束回调 finishFunc 调用下一个相机移动的动画，达到巡视漫游的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 切换到冷站视角
&lt;span data-mce-=&quot;&quot;&gt;roam1() {
    const g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d;
    const g3dDm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3dDm;
    &lt;span data-mce-=&quot;&quot;&gt;this.roamAnim = g3d.moveCamera([-291, -8, 283], [148, -400, 171&lt;span data-mce-=&quot;&quot;&gt;], {
        duration: 500&lt;span data-mce-=&quot;&quot;&gt;,
        easing: t =&amp;gt; t *&lt;span data-mce-=&quot;&quot;&gt; t,
        finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.roam2();
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      在环视漫游和巡视漫游的执行下，我们也可以触发 2D 图纸右面板下的按钮面板去观看我们想要浏览的指定场景，这时候就会关闭当前在执行的环视漫游或者巡视漫游，再次点击改按钮则返回场景的主视角，或者点击左上角漫游按钮又可以进入环视漫游，这样的交互体验，可以方便用户即使地查看想要浏览的场景，而不用依靠等待逐一漫游下去查看，也不会干扰到漫游的整体体验。相应地通过介绍冷站按钮的点击触发介绍一下实现的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406223113387-1609822143.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      一般的交互方式存在三种事件交互的方法，包括事件通知管理器 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=Notifier&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_2&quot; target=&quot;_blank&quot;&gt;ht.Notifier&lt;/a&gt; 类，内置的 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=%E5%86%85%E7%BD%AE%E7%9A%84Interactor%E5%9C%A8%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E4%BC%9A%E6%B4%BE%E5%8F%91%E5%87%BA%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%8F%AF%E9%80%9A%E8%BF%87Gr&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;Interator&lt;/a&gt; 在交互过程会派发出事件和数据绑定的监听来实现，而这里使用的是第三种交互方式。&lt;/p&gt;
&lt;p&gt;      通过数据绑定监听到 onDown 执行按下的事件后，通过改变按下和再次按下的按钮状态 active 来分别执行相机移动去切换视角，主要实现的伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置图元可交互
&lt;span data-mce-=&quot;&quot;&gt;this.coolingCentralStationButton.s('interactive', &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过数据绑定监听到onDown执行按下的事件
&lt;span data-mce-=&quot;&quot;&gt;this.coolingCentralStationButton.s('onDown', () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 切换到冷站时，2d面板所执行的切换动画
&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.switchToColdStation();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 按钮初始化
&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.buttonTearDown();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 按钮按下效果的状态
    let active = &lt;span data-mce-=&quot;&quot;&gt;this.coolingCentralStationButton.a('active'&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; button为按钮集合数组，当按下电梯按钮，其他按钮默认false
    button.forEach(btn =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        btn.a('active', &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 冷站按钮的状态切换
    &lt;span data-mce-=&quot;&quot;&gt;this.coolingCentralStationButton.a('active', !&lt;span data-mce-=&quot;&quot;&gt;active);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 根据冷站按钮的状态执行切换到冷站或者切换回主视角
    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (active) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 相机移动切换到主视角
        moveCamera(g3d, [257, 713, 1485], [7, 40, 144&lt;span data-mce-=&quot;&quot;&gt;], {
            duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: t =&amp;gt; t *&lt;span data-mce-=&quot;&quot;&gt; t
        });
    } &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 漫游动画对象如果不为空，则暂停漫游动画对象并且设置为空
        &lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.roamAnim !== &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.roamAnim.pause();
            &lt;span data-mce-=&quot;&quot;&gt;this.roamAnim = &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;;
        }
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 相机移动切换到冷站视角
        coolingCentralStationAnimation = moveCamera(g3d, [-291, -8, 283], [148, -400, 171&lt;span data-mce-=&quot;&quot;&gt;], {
            duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: t =&amp;gt; t *&lt;span data-mce-=&quot;&quot;&gt; t
        });
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      当然，在 3D 场景下还有一些很有趣的动画效果，比如车流效果、飞光效果和圆环扩散效果。车流效果主要通过采用了贴图的 uv 的偏移来实现达到车流穿梭的科技感效果；而飞光效果则是采用调度动画的方法来间隔设置飞光的高度，达到最高点则消失然后重新轮回动画展示；圆环扩散效果则是同样采用调度动画的方法来间隔设置圆环的缩放值和透明度，来达到扩散消失的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406221245931-2050879216.gif&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      对于间隔的调度动画，为了实现动画的流畅性，这里调度使用的 loop 是运用到自己封装 &lt;strong&gt;HT&lt;/strong&gt; 的动画 &lt;strong&gt;ht.Default.startAnim&lt;/strong&gt; 的一个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;frames &lt;/strong&gt;动画帧数，这里不锁定帧数，可以适应本身动画的帧数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interval &lt;/strong&gt;动画间隔，单位ms，默认设置20ms。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
loop(action, interval = 20&lt;span data-mce-=&quot;&quot;&gt;) {
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim({
        frames: Infinity,
        interval: interval,
        action: action
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;      然后通过调用这个 loop 的间隔动画方法，我们来实现车流效果、飞光效果和圆环扩散效果，实现的参考伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 车流图元的初始化
let traffic = g3dDm.getDataByTag('traffic'&lt;span data-mce-=&quot;&quot;&gt;);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 圆环扩散图元的初始化
let lightRing = &lt;span data-mce-=&quot;&quot;&gt;this.lightRing = g3dDm.getDataByTag('lightRing'&lt;span data-mce-=&quot;&quot;&gt;);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 飞光图元设置三种透明状态数组集合flyMap的初始化
[1, 2, 3].forEach(i =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    const data = flyMap['fly' + i] = g3dDm.getDataByTag('fly' +&lt;span data-mce-=&quot;&quot;&gt; i);
    data.eachChild(d =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        d.s({
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 打开透明度
            'shape3d.transparent': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 根据不同的数组集合设置不同的透明度
            'shape3d.opacity': i === 3 ? 0.5 : 0.7&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置沿着y轴自动旋转
            'shape3d.autorotate': 'y'&lt;span data-mce-=&quot;&quot;&gt;
        });
    });
});

&lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.flyAnim) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
&lt;span data-mce-=&quot;&quot;&gt;this.flyAnim = loop(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 飞光根据间隔设置高度来达到上升的效果
    &lt;span data-mce-=&quot;&quot;&gt;for (let k &lt;span data-mce-=&quot;&quot;&gt;in&lt;span data-mce-=&quot;&quot;&gt; flyMap) {
        const data =&lt;span data-mce-=&quot;&quot;&gt; flyMap[k];
        let e = data.getElevation() +&lt;span data-mce-=&quot;&quot;&gt; flyDltMap[k];
        &lt;span data-mce-=&quot;&quot;&gt;if (e &amp;gt;= 500) e = -400&lt;span data-mce-=&quot;&quot;&gt;;
        data.setElevation(e);
    }

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 车流根据设置间隔增长uv偏移量来实现穿梭的效果
    traffic.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.s('all.uv.offset', [location, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    });
    location -= 0.03&lt;span data-mce-=&quot;&quot;&gt;;

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 旋转震荡波透明度渐降
    let percent = lightRing.a('percent') || 0&lt;span data-mce-=&quot;&quot;&gt;,
        scale = 15 * percent + 0.5&lt;span data-mce-=&quot;&quot;&gt;;
    lightRing.setScale3d([scale + 1, scale, scale + 1&lt;span data-mce-=&quot;&quot;&gt;]);
    lightRing.s('shape3d.opacity', (1 - percent) * 0.5&lt;span data-mce-=&quot;&quot;&gt;);
    percent += 0.01&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;if (percent &amp;gt;= 1&lt;span data-mce-=&quot;&quot;&gt;) {
        percent = 0&lt;span data-mce-=&quot;&quot;&gt;;
    }
    lightRing.a('percent'&lt;span data-mce-=&quot;&quot;&gt;, percent);
}, 50);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;三、冷站场景和热站场景的动画实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      场景动画中机组的风扇、集水器的蓄满以及水的流动效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406221013712-1564093786.gif&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      动画的实现主要还是通过 &lt;strong&gt;HT&lt;/strong&gt; 自带的 &lt;strong&gt;ht.Default.startAnim&lt;/strong&gt; &lt;code&gt;动画&lt;/code&gt;函数，支持 Frame-Based 和 Time-Based 两种方式的动画。同样的，我们这里使用的是 Frame-Based 来封装一个 loop 函数来执行每一帧间隔的动画。&lt;/p&gt;
&lt;p&gt;      一般来说，动画可通过自行配置来达到自己想要实现的方法，这里可以了解&lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=startAnim&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;&amp;lt; HT 的入门手册&amp;gt;&lt;/a&gt;关于&lt;code&gt;动画&lt;/code&gt;函数的介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.stationAnim) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
&lt;span data-mce-=&quot;&quot;&gt;this.stationAnim = loop(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 冷站水管流动
    coldFlow_blue.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.s('shape3d.uv.offset', [-location, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    });
    coldFlow_yellow.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.s('shape3d.uv.offset', [location, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    });

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 热站水管流动
    heatFlow_blue.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.s('shape3d.uv.offset', [-location, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    });
    heatFlow_yellow.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.s('shape3d.uv.offset', [location, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    });

    location -= 0.03&lt;span data-mce-=&quot;&quot;&gt;;

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 冷站风扇旋转
    cold_fan.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.setRotation3d(c.r3()[0], c.r3()[1] + (Math.PI / 10), c.r3()[2&lt;span data-mce-=&quot;&quot;&gt;]);
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 热站风扇旋转
    heat_fan.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        c.setRotation3d(c.r3()[0], c.r3()[1] + (Math.PI / 10), c.r3()[2&lt;span data-mce-=&quot;&quot;&gt;]);
    });

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 集水器水位变化
    HotWaterTankTall += 0.25&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;if (HotWaterTankTall &amp;gt; 15&lt;span data-mce-=&quot;&quot;&gt;) {
        HotWaterTankTall = 0&lt;span data-mce-=&quot;&quot;&gt;;
    }
    coldWaterTankTall1 += 0.25&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;if (coldWaterTankTall1 &amp;gt; 20&lt;span data-mce-=&quot;&quot;&gt;) {
        coldWaterTankTall1 = 0&lt;span data-mce-=&quot;&quot;&gt;;
    }
    coldWaterTankTall2 += 0.25&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;if (coldWaterTankTall2 &amp;gt; 20&lt;span data-mce-=&quot;&quot;&gt;) {
        coldWaterTankTall2 = 0&lt;span data-mce-=&quot;&quot;&gt;;
    }
    hotWaterTank.setTall(HotWaterTankTall);
    coldWaterTank1.setTall(coldWaterTankTall1);
    coldWaterTank2.setTall(coldWaterTankTall2);
}, 50);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div readability=&quot;39.57253384913&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;四、中央空调末端智慧群控系统场景效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      这里采用了模拟数据的方式来体现末端智能节能控制的效果。应用于真实项目的时候，可以采用数据接口的方式来实时对接真实数据，可以达到实时监控的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406220400372-1396060721.gif&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      我使用了自己 mock 的末端群控的数据参数，格式如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;var boxData =&lt;span data-mce-=&quot;&quot;&gt;
    [
        [{
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设备编号
            id: 'box1'&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设备的温度
            temperature: 23.8&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设备的频率
            frequency: 45.8&lt;span data-mce-=&quot;&quot;&gt;
        }, ...]
        ...
    ];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;      这里的实现也是通过 loop 循环执行数据的读取，当数组指标 index 读取到最后一个数据时，立即关闭循环并清空 loop调度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
boxAnimation = loop(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;for (let i = 0, l = 16; i &amp;lt;= l-1; i++&lt;span data-mce-=&quot;&quot;&gt;) {
            let roomTag, roomBox, tag;
            tag = i+1&lt;span data-mce-=&quot;&quot;&gt;;
            roomTag = 'boxPanel' +&lt;span data-mce-=&quot;&quot;&gt; tag;
            roomBox = 'box' +&lt;span data-mce-=&quot;&quot;&gt; tag;

            let panel =&lt;span data-mce-=&quot;&quot;&gt; g3dDm.getDataByTag(roomTag);
            let box =&lt;span data-mce-=&quot;&quot;&gt; g3dDm.getDataByTag(roomBox);
            &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (panel) {
                panel.a('valueT', boxData[index][i].temperature + '℃'&lt;span data-mce-=&quot;&quot;&gt;);
                panel.a('valueK', boxData[index][i].frequency + 'Hz'&lt;span data-mce-=&quot;&quot;&gt;);
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 手动更新缓存的面板信息
&lt;span data-mce-=&quot;&quot;&gt;                g3d.invalidateShape3dCachedImage(panel);
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 根据温度判断设备的颜色
                &lt;span data-mce-=&quot;&quot;&gt;if (box &amp;amp;&amp;amp; parseFloat(panel.a('valueT')) &amp;lt; 26&lt;span data-mce-=&quot;&quot;&gt;) {
                    box.s('shape3d.blend', 'rgb(4,67,176)'&lt;span data-mce-=&quot;&quot;&gt;);
                    box.s('wf.color', 'rgb(4,67,176)'&lt;span data-mce-=&quot;&quot;&gt;);
                } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (box &amp;amp;&amp;amp; parseFloat(panel.a('valueT')) &amp;gt;= 26 &amp;amp;&amp;amp; parseFloat(panel.a('valueT')) &amp;lt;= 28&lt;span data-mce-=&quot;&quot;&gt;) {
                    box.s('shape3d.blend', 'rgb(28,189,87)'&lt;span data-mce-=&quot;&quot;&gt;);
                    box.s('wf.color', 'rgb(28,189,87)'&lt;span data-mce-=&quot;&quot;&gt;);
                } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (box &amp;amp;&amp;amp; parseFloat(panel.a('valueT')) &amp;gt; 28&lt;span data-mce-=&quot;&quot;&gt;) {
                    box.s('shape3d.blend', 'rgb(181,43,43)'&lt;span data-mce-=&quot;&quot;&gt;);
                    box.s('wf.color', 'rgb(181,43,43)'&lt;span data-mce-=&quot;&quot;&gt;);
                }
            }
        }
        index++&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;if (index &amp;gt;= 10&lt;span data-mce-=&quot;&quot;&gt;) {
            boxAnimation.pause();
            boxAnimation = &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;;
        }
    }, 500);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      IBMS 智能化集成系统管理对于建筑园区管理的重要性日趋上升，在信息时代里不仅可以很好地体现出信息数据管理的明确性，也体现了智慧管理的便利有效性。通过 3D 场景楼宇园区的动画加上环视漫游和巡视漫游的配合，充分体现了 3D 场景的拟真优点，但是如何实现场景动画的触发实现呢？这里当然必不可少了 2D 面板上的交互和动画，在下期我们会为大家介绍一些 2D 面板的交互和动画实现，带您解读不一样的 2D/3D 融合。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200225200053329-1065733339.jpg&quot; alt=&quot;&quot; width=&quot;1533&quot; height=&quot;862&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 06 Apr 2020 16:04:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着现代通信技术、计算机技术、控制技术的飞速发展，智能建筑已经成为现代建筑发展的主流。智能建筑是以建筑物为平台，兼备信息设施系统、信息化应用系统、建筑设备管理系统、公共安全系统等。集结构、系统、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12650621.html</dc:identifier>
</item>
<item>
<title>Java是未来的第一编程语言吗？ - 黄钰朝</title>
<link>http://www.cnblogs.com/misterchaos/p/12650643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/misterchaos/p/12650643.html</guid>
<description>&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;Java语言长期以来一直霸占多数热门编程语言榜单的榜首，可见这是一个备受程序员热捧的编程语言。Java语言具有什么魅力？想必这都是已经为大多数人们所熟知的了，不值得过多赘述。而Java语言发展至今，面对发展势头迅猛又十分简单易学的python，以及各种层出不穷的高级语言，Java程序员的份额已经逐步下降，&lt;strong&gt;那它是否还能在未来保持领先的优势呢？本文就主要从Java语言所不擅长的领域，以及它在自己的领土内受到的对手入手，聊一聊Java语言在未来所面临的挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、java帝国的今天&quot;&gt;二、Java帝国的今天&lt;/h2&gt;
&lt;h3 id=&quot;21-依然霸占tiobe热门编程语言的榜首&quot;&gt;2.1 依然霸占TIOBE热门编程语言的榜首&lt;/h3&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406175535.png&quot;/&gt;&lt;p&gt;这是来自权威开发语言排行榜TIOBE的最新数据（截止到2020年4月），可以看到&lt;strong&gt;Java语言依然在语言排行榜霸占第一的位置！&lt;/strong&gt;虽然下面Python小老弟近几年搭上大数据的热潮，发展实为迅猛，在其他一些排行榜上面甚至超越大哥，但是&lt;strong&gt;在TIOBE这样权威的排行榜上面，Python依旧是小老弟！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-曾经想扼杀java的微软宣布加入openjdk&quot;&gt;2.2 曾经想扼杀Java的微软宣布加入OpenJDK&lt;/h3&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406180632.png&quot;/&gt;&lt;p&gt;这又是一个IT界的真香现场，Sun 公司曾以“歧视使用 Java 软件”为由起诉微软。而微软在2001年推出新版操作系统 Windows XP 时，故意不安装 Java 软件，并且推出高仿 Java 的语言 C# 和 .net 框架。在现在，&lt;strong&gt;微软却宣布加入OpenJDK，拥抱Java技术&lt;/strong&gt;。微软的宇宙第一 IDE Visual Studio也开始支持Java开发。&lt;/p&gt;
&lt;h3 id=&quot;23-oracle发布开源全栈虚拟机graalvm&quot;&gt;2.3 Oracle发布开源全栈虚拟机GraalVM&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406201418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是大名鼎鼎的Oracle公司搞出来的开源产品，从官网“Run Programs Faster Anywhere”这句口号和产品的命名GraalVM就可以看出，&lt;strong&gt;GraalVM是升级版的JVM。&lt;/strong&gt;在GraalVM上面执行Java程序的效率更高（得益于其中的JIT编译器技术）。最牛逼的地方在于，&lt;strong&gt;GraalVM支持多语言应用！&lt;/strong&gt;在GraalVM里面，多种不同的语言可以互相传递数据，支持Java、Python、Ruby、R、Scala、Kotlin，JavaScript等多种语言。&lt;/p&gt;
&lt;h2 id=&quot;三、java帝国受到的挑战&quot;&gt;三、Java帝国受到的挑战&lt;/h2&gt;
&lt;h3 id=&quot;31-后端服务器开发&quot;&gt;3.1 后端服务器开发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/misterchaos/img/master/image/20200406204314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;J2EE作为Java平台的重要组成部分，现在广泛应用于Web后台服务器开发领域，在这个领域，Java拥有很多好朋友，比如Spring框架，Mybatis和Hibernate等，使得开发者可以快速构建Web应用程序。这是Java帝国一块重要的领土，但也有很多挑战。&lt;strong&gt;下面就是几个强大的竞争者&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;311-python-的竞争&quot;&gt;3.1.1 Python 的竞争&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406213753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python语言和Java相比，具有下面这些优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法简单直观，这意味着开发速度快&lt;/li&gt;
&lt;li&gt;第三方库强大，可以写复杂的逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然Python和Java相比执行效率上肯定是更低了，因此&lt;strong&gt;主要应用于小型的网站后台&lt;/strong&gt;，像阿里这样的大厂就是拥抱Java后台的了。&lt;/p&gt;
&lt;h4 id=&quot;312-c-的竞争&quot;&gt;3.1.2 C++ 的竞争&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406214253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;C++语言和Java相比，具有以下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行效率高&lt;/li&gt;
&lt;li&gt;对内存管理自由，而Java由GC来管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++&lt;strong&gt;适合大型高性能的服务器开发&lt;/strong&gt;。腾讯更多的就是使用C++进行开发，这点和阿里不同。当然C++相比Java，学习和开发的难度更高。&lt;/p&gt;
&lt;h4 id=&quot;313-nodejs-的竞争&quot;&gt;3.1.3 node.js 的竞争&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406214653.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;node.js的出现大概是前端程序员最高兴的事情了，因为node.js可以让他们写的JavaScript代码运行在服务端，这样就可以使得前端不用学Java也能自己写后台，摆脱后台爸爸的束缚(误)。得益于node.js的事件驱动机制，node.js&lt;strong&gt;具有很高的并发性能，可以应对大规模的http请求&lt;/strong&gt;。但也有缺点，因为js只支持单核，因此没法充分利用服务器的性能，它不适合CPU密集型应用。&lt;/p&gt;
&lt;h4 id=&quot;314-go-的竞争&quot;&gt;3.1.4 Go 的竞争&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406214928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Go语言是最近很火的开发语言，适合用于开发高性能分布式系统。这是一个十分强大的竞争对手，&lt;strong&gt;被认为是未来的服务端语言&lt;/strong&gt;。它具有下面这些优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习难度低，容易上手，易于维护&lt;/li&gt;
&lt;li&gt;得益于协程，并发性能优越&lt;/li&gt;
&lt;li&gt;编译型语言，执行效率高&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;315-小结&quot;&gt;3.1.5 小结&lt;/h4&gt;
&lt;p&gt;可以看到，在后端服务器开发领域，Java在不同方面受到多种语言的竞争，轻量小型的服务器，人们可以选择Python，node.js或者PHP。而大型高性能服务器，人们可以选择C++。Go语言就更强大，兼具了比Java更简单的语法和更高的并发性能，背后又是Google爸爸。因此，在这一领域，Java面临巨大的竞争压力。&lt;/p&gt;
&lt;h3 id=&quot;32-安卓系统应用开发&quot;&gt;3.2 安卓系统应用开发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406215209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java用于安卓应用程序开发已经是很成熟的方案了，目前绝大多数的安卓应用都是用Java写的。很多安卓程序员也都是学Java过来的。但是随着新语言不断推出，和安卓应用开发方式的演变，Java慢慢不再是安卓开发的首选。比如下面这些语言，就是比较热门的选择。&lt;/p&gt;
&lt;h4 id=&quot;321--kotlin-成为-android-开发的首选语言&quot;&gt;3.2.1 Kotlin 成为 Android 开发的首选语言&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406220958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在2019年的Google I/O 大会上，Google 官方正式宣布，&lt;strong&gt;Kotlin 编程语言现在是 Android 应用程序开发人员的首选语言&lt;/strong&gt;。Java 占据 Android 开发绝对统治的时代一去不复返了。Kotlin 可以编译成Java字节码，可以在JVM上面运行，也可以编译成JavaScript，在没有JVM的机器上运行。Kotlin语言比Java更安全，更简洁，随着谷歌爸爸推崇，将来的发展前景可期。&lt;/p&gt;
&lt;h4 id=&quot;322--flutter-框架和-dart-语言&quot;&gt;3.2.2 Flutter 框架和 Dart 语言&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406223907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个都是谷歌最近推出的东西，&lt;strong&gt;Flutter是一款用于帮助开发者在iOS和Android两个平台构建高质量原生应用的全新移动UI框架，Dart是由Google开发的一门全新的计算机编程语言，而Flutter使用Dart语言开发&lt;/strong&gt;。Fuchsia是谷歌开发的一款全新的操作系统，Flutter 是 Fuchsia 的开发框架。Flutter编写的代码可以同时生成IOS和Android两个平台下的应用程序，因此Flutter框架逐渐热门。&lt;/p&gt;
&lt;h4 id=&quot;323-大前端时代下的h5应用&quot;&gt;3.2.3 大前端时代下的H5应用&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406223806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着时代发展，现在的前端不再只是写web网页，而是逐渐发展为大前端，web，Android，IOS通吃，H5应用的流行就是一个例子，大家应该都发现，手机上开始出现快应用，小程序这些使用前端语言进行开发的app，这些应用使用HTML，JS和CSS进行开发，无需使用Java。相比之下，&lt;strong&gt;H5应用轻量级，启动快，跨平台，用户体验方面也逐渐开始接近原生应用的流畅度&lt;/strong&gt;。因此大有流行的趋势。&lt;/p&gt;
&lt;h4 id=&quot;324-小结&quot;&gt;3.2.4 小结&lt;/h4&gt;
&lt;p&gt;这一小节介绍了安卓开发的现状，Java作为曾经的安卓开发第一首选语言，正在面临诸如Kotlin语言，Flutter和Dart语言等新的开发语言的挑战，同时，随着安卓应用开发逐渐出现H5应用的趋势，前端语言也逐渐开始来到Java的地盘。&lt;/p&gt;
&lt;h2 id=&quot;四、java不擅长的领域&quot;&gt;四、Java不擅长的领域&lt;/h2&gt;
&lt;h3 id=&quot;41-前后端分离和jsp的没落&quot;&gt;4.1 前后端分离和JSP的没落&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406225406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JSP是一度火爆的技术，Java曾对其寄予厚望，希望通过JSP技术占领web应用程序领域。然而，&lt;strong&gt;随着网页开发越来越复杂，用JSP开发网页变得很麻烦，前端和后端混杂在一起，开发效率很低。&lt;/strong&gt;因此前后端开始分离，而JSP这种运行于服务器端的网页程序也就慢慢退出了舞台。&lt;/p&gt;
&lt;h3 id=&quot;42-c和net抢占桌面程序地盘&quot;&gt;4.2 C#和.NET抢占桌面程序地盘&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406230706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java曾经也被广泛用于开发桌面客户端，其中Swing框架就是一个有名的GUI框架。然而，曾经想要扼杀Java的微软，开发了C#语言。C#成为Java的竞争对手，C#编写运行于Windows系统的桌面应用程序上具有优势，Java写的桌面应用，虽然可以跨平台到处运行，这对于程序员当然是好事，但是对于用户来说，在Windows上运行个Java程序还得安装JRE，显得十分麻烦。而且，Java桌面程序运行起来比C#程序慢。因此，&lt;strong&gt;C#和.NET逐渐占领了桌面应用程序的市场。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;43-cc活跃的嵌入式系统领域&quot;&gt;4.3 C/C++活跃的嵌入式系统领域&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/misterchaos/img/image/20200406232936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java曾经是为了嵌入式系统开发而设计的。然而，&lt;strong&gt;Java程序员并不能直接操作硬件，并且，Java是相对教重的语言，对内存等硬件资源不友好，执行效率也相对较低。&lt;/strong&gt;而在嵌入式系统中，往往只有很少的内存空间，却对运行效率有很高的要求。因此，在嵌入式领域，更多的是C语言和C++甚至是汇编语言的天下。&lt;/p&gt;
&lt;h3 id=&quot;44-小结&quot;&gt;4.4 小结&lt;/h3&gt;
&lt;p&gt;这一小节主要针对Java所不擅长的领域来讨论。可以看到，Java最为有名的特性“&lt;strong&gt;Write once, run anywhere&lt;/strong&gt;”，也成了它最大的缺陷：在执行效率上做不到卓越。因此，在桌面应用程序和嵌入式系统两个领域Java不是王者。而随着时代发展，前后端分离，JSP也被时代所抛弃。&lt;/p&gt;
&lt;h2 id=&quot;五、总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;综上所述，相信大家对于Java语言有了更全面的了解，看到了Java背后的芸芸众生，各种层出不穷的高级语言和新技术，和Java相爱相杀。&lt;strong&gt;Java作为现在世界上最热门的编程语言，依然在各个不同的领域具有重要的地位 ，Java的强大之处在于，它十分全能，几乎没有什么是Java不能做的，但它并不都是做得最好的，我们也可以看到许许多多的竞争者在不同方面比Java语言更加优越。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，我写这篇文章的目的，不在于比较各个语言的优劣，各种语言都有自己的优点和缺点，我们也不必因为某种语言更好就着急转语言。&lt;strong&gt;总而言之，语言只是工具，各种语言之间，语法的差别都不是特别大，背后的原理也是大同小异，往往只是多了几个新特性，而语言背后的编程思维才是最重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、参考资料&quot;&gt;六、参考资料&lt;/h2&gt;
</description>
<pubDate>Mon, 06 Apr 2020 15:57:00 +0000</pubDate>
<dc:creator>黄钰朝</dc:creator>
<og:description>[TOC] 一、前言 Java语言长期以来一直霸占多数热门编程语言榜单的榜首，可见这是一个备受程序员热捧的编程语言。Java语言具有什么魅力？想必这都是已经为大多数人们所熟知的了，不值得过多赘述。而J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/misterchaos/p/12650643.html</dc:identifier>
</item>
<item>
<title>WEB缓存系统之varnish状态引擎 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12643549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12643549.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227045908varnish.png&quot; class=&quot;desc_img&quot;/&gt; varnish的状态引擎分前端工作线程或者客户端状态引擎和后端工作线程或者服务端状态引擎；客户端状态引擎，主要处理客户端请求和响应相关的处理，比如是否可查缓存，是否命中，是否修剪缓存，是否识别用户请求的方法有或者直接交给vcl_pass，又或者说怎样响应客户端等等，可以看到客户端状态引擎vcl_pass，是一个额外处理机制，不管是否可查缓存，是否命中，都可以交给它处理；对于服务端状态引擎主要是处理和后端服务器请求和响应相关操作，比如怎样去后端服务器取资源，对服务器的响应报文是否可缓存，怎么缓存，对后端服务器的响应报文错误怎么处理等；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;158.3793816011&quot;&gt;
&lt;p&gt;　　前文我们聊了下varnish的VCL配置以及语法特点，怎样去编译加载varnish的vcl配置，以及命令行管理工具varnishadm怎么去连接varnish管理接口进行管理varnish，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12626134.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12626134.html&lt;/a&gt;；今天我们来说一下varnish的状态引擎；首先我们来回顾下iptables报文的走向，在iptables里报文的走向有三种，第一种是从别的主机发送过来的报文，首先它会到达网卡，然后进入prerouting链，然后经过路由决策后，如果是发往本机的，则就走input链，从而把报文送给本机上的应用程序；第二种是从prerouting链通过路由决策后，不是发往本机的报文而是发往其他主机，通过本机转发的，它会从prerouting链到forward链，然后从postrouting链把报文发送给其他主机；第三种是从本机发往其他主机的报文，它的报文走向是从output链到postrouting链，然后从网卡发送出去；我们说iptables的原因是类比varnish的状态引擎；varnish的状态引擎就类似iptables里的这5链；我们写的vcl配置就相当于iptables里的规则；他俩有个共同点就是在每个链上的规则只对当前链上的表或者被自定义链引用才会生效，而varnish里的状态引擎也是同样的逻辑，我们写的vcl配置只对当前状态引擎生效，不同的状态引擎处有着不同的意义，对其他状态引擎互不干扰；这样描述相信大家对varnish的状态引擎有了初步的概念，这也是我们在上一篇文中说到的，发送给客户端的响应报文，为什么要配置在vcl_deliver里，而不是其他位置；接下来我们看看varnish的状态引擎；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406171628502-596955004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上这张图上varnish4.0的状态引擎图，每个状态引擎彼此的关系，以及varnish内部缓存处理逻辑；首先当varnish服务器收到来自客户端的请求报文，最先到达的状态引擎是vcl_recv，我们可以在vcl_recv里面对客户端的请求报文做修改，或者其他操作，然后交给vcl_hash这个状态引擎，这个状态引擎主要是看是否可查缓存，如果可以查缓存，会判断是否命中，命中就交给vcl_hit处理，vcl_hit处理后，就直接交给vcl_deliver处理，最后响应给客户端，当然缓存命中后也可以将请求交给vcl_pass处理；如果vcl_hash处理后不能查缓存，就把报文发送给vcl_miss处理，意思是不能查缓存，或者缓存未能命中；当然我们也可以直接把报文交给vcl_pass处理；即便它可以被缓存命中，我们也是可以强行让该请求不查缓存，直接交给vcl_pass处理或者vcl_miss直接交给vcl_backend_fatch处理；vcl_backend_fetch就是去后端真正的服务器上取对应资源，然后它会对后端服务器的响应报文头部进行读的操作，如果没有什么错误，就把响应报文发送给vcl_backend_response，vcl_backend_response在处理响应报文时，会判断是否可缓存，如果可以缓存，就在本地缓存一份，然后通过vcl_deliver响应给客户端，如果不可缓存，在本地就不缓存，直接将响应报文发送给vcl_deliver响应给客户端；如果vcl_backend_fetch读后端服务器发来的响应报文是错误响应（或者vcl_backend_fatch未取到对应资源，或者后端主机宕机等等），它就会把该处理逻辑交给vcl_backend_error处理；如果用户的请求经过vcl_hash处理后，发现缓存内容变了或者说缓存过期了需要修剪缓存，它会把请求发往vcl_purge，vcl_purge主要处理缓存修剪相关的操作，然后把请求报文发送给vcl_synth处理，合成一响应发送给客户端；如果通过vcl_hash处理后发现用户请求的方法我们压根就不认识，这个时候会将请求报文交给vcl_pipe处理；&lt;/p&gt;
&lt;p&gt;　　从上面的图来看，我们大概可以总结为两点，varnish的状态引擎分前端工作线程或者客户端状态引擎和后端工作线程或者服务端状态引擎；客户端状态引擎，主要处理客户端请求和响应相关的处理，比如是否可查缓存，是否命中，是否修剪缓存，是否识别用户请求的方法有或者直接交给vcl_pass，又或者说怎样响应客户端等等，可以看到客户端状态引擎vcl_pass，是一个额外处理机制，不管是否可查缓存，是否命中，都可以交给它处理；对于服务端状态引擎主要是处理和后端服务器请求和响应相关操作，比如怎样去后端服务器取资源，对服务器的响应报文是否可缓存，怎么缓存，对后端服务器的响应报文错误怎么处理等；&lt;/p&gt;
&lt;p&gt;　　varnish的前端状态引擎有vcl_recv,vcl_pass, vcl_hit, vcl_miss, vcl_pipe, vcl_purge, vcl_synth, vcl_deliver;vcl_recv处理后可以通过return来指定下一跳处理的状态引擎是那个，如果是return（hash）就表示交给vcl_hash处理；return（pass）就表示交给vcl_pass处理；return（pipe）就表示交给vcl_pipe处理；return(synth)就表示交给vcl_synth处理；return(purge)就表示交给vcl_purge处理；对于vcl_hash来说，return（hit）就表示缓存命中交给vcl_hit处理，return（miss）表示缓存未能命中交给vcl_miss处理，return（pass）或者return(hit_for_pass)就表示即便缓存命中也交给vcl_pass处理，return（purge）就表示交给vcl_purge处理；&lt;/p&gt;
&lt;p&gt;　　varnish的后端状态引擎有vcl_backend_fetch, vcl_backend_response, vcl_backend_error；vcl_backend_fetch处理去后端取资源的操作，vcl_backend_response处理后端服务器响应回来的报文，vcl_backend_error处理后端服务器错误；除此以外varinsh4.0还有两个特殊的状态引擎，分别是vcl_init和vcl_fini；vcl_init：在处理任何请求之前要执行的vcl代码：主要用于初始化VMODs；vcl_fini：所有的请求都已经结束，在vcl配置被丢弃时调用；主要用于清理VMODs；&lt;/p&gt;
&lt;p&gt;　　了解了上面的状态引擎，我们在说一说varnish的变量，在前文我们大概说了下varnish的变量大概可以分5类，一类是客户端请求报文相关的，req.*；一类是varnish服务器请求后端服务器报文，bereq.*；一类是后端服务器响应varnish服务器的beresp.*；一类是varnish服务器响应客户端的resp.*；还有一类是obj.*，这类变量主要是储存缓存空间中的缓存对象的属性；结合上面说的状态引擎，不难里接在不同的状态引擎里，对应变量是有限的，比如bereq.*这类变量就不能用于vcl_recv，因为vcl_recv是接收用户请求相关的，而bereq.* 是varnish请求后端服务器的变量，这两者很明显是不再一个级别的，所以通常不同类的变量对应能够用于哪些状态引擎中是有限制的；而对应变量的属性也是有要求的，比如obj.hit这个变量是存储缓存项命中次数的，通常可用在vcl_hit和vcl_deliver状态引擎中，表示应用缓存命中次数，相对于这个变量来说，我们是不能修改的，所以obj.hits这个变量在vcl_hit和vcl_deliver状态引擎中只可读，不可修改；而对于obj.ttl这个值就不一样了；obj.ttl记录缓存项可缓存的时间；很显然obj.ttl这个变量只能用于可缓存的状态引擎上，比如vcl_hit，对于告诉客户端可缓存的时间，很明显它不能是一个不可修改的值；所以对于obj.ttl这个变量在vcl_hit状态引擎中就具有可读可写权限（即我们可以修改该变量的值）；说这么多无外乎就是表达一个意思，不同类型的变量受限状态引擎，不同变量在不同的状态引擎上不是都可读可写，有的变量只可读；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406191516987-1850119775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：以上这张表就是对于不同类型的变量对应varnish的状态引擎是否可读写的，没有读写就表示该类型变量不能用于对应状态引擎中；比如resp.*只能在error和deliver状态引擎中使用；beresp.*这类变量只能用于后端主机响应varnish服务器的过程中使用，比如fetch这个状态引擎就是处理后端服务器响应varnish服务器请求的；所以beresp.*这类变量只能用于fetch;当然这里的fetch是早期状态引擎的名称。在varnish4.0它不叫fetch，而叫vcl_backend_fatch；&lt;/p&gt;
&lt;p&gt;　　了解了以上内容，我们接下来看几个示例&lt;/p&gt;
&lt;p&gt;　　示例：强制对某类资源的请求不检查缓存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406205212693-1168841394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示对客户端请求的url进行判断，如果能够被.jpg、.jpeg、.png、.gif、.js、.css、.html匹配到，那么就把用户请求交给pass状态引擎处理；pass状态引擎处理就是不查缓存；所以对于客户端请求.jpg的资源，其对应obj.hits的值会一直为0；因为我们明确指定了不查缓存；&lt;/p&gt;
&lt;p&gt;　　测试：用浏览器访问服务器上的.jpg资源，看看响应报文中我们自定义的X-Cache 首部是否是 miss via 192.168.0.99；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406210850048-156346008.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到我们访问/day.jpg这个资源时，不管怎么刷新浏览器，对应响应首部X-Cache的值都是 miss via 192.168.0.99，说明我们请求.jpg的资源的确没有查缓存；&lt;/p&gt;
&lt;p&gt;　　示例：把客户端IP传到后端服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406214455222-1925497741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上vcl表示判断客户端请求首部X-Forwarded-For是否为空，如果不为空就把它的值在原有的值的基础上和客户端ip地址做字符串连接，并用逗号隔开；如果该首部为空或者没有这个首部就把这个首部的值设置成客户端ip地址；&lt;/p&gt;
&lt;p&gt;　　更改后端web 服务的日志格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406214836676-587543661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示在日志格式中应用X-Forwarded-For这个首部的值；&lt;/p&gt;
&lt;p&gt;　　测试：重新编译加载vcl，然后用浏览器访问，看看是否能够把浏览器所在主机的ip地址传到后端httpd服务器日志中做记录？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406221150122-901957951.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：从上面的日志结果看，我们分别用不同的浏览器去访问，在日志中可以看到不同浏览器所在主机的IP地址，说明我们通过判断用户请求报文X-Forwarded-For首部是否为空，从而实现对于非空和空值对应设置该首部值，继而实现把对应请求首部值记录到后端服务器日志中的目的；&lt;/p&gt;
&lt;p&gt;　　示例：对于特定类型的资源，例如公开的图片等，取消其私有标识，并强行设定其可以由varnish缓存的时长；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406221927742-1753883110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：首先我们要清楚在那个位置去对报文操作，取消私有标识，是需要在后端服务器响应varnish这个过程中把对应响应首部的值给撤销了；所以我们需要在vcl_backend_response这个状态引擎中来设置，取消set-cookie首部，这个首部主要是给对应客户端设置一个cookie;以上配置表示判断后端服务器响应varnish服务器的响应报文首部cache-control的值是否匹配“s-maxage”，如果不匹配说明该资源不允许被共有缓存系统所缓存，如果匹配，则说明该资源允许被公有缓存系统所缓存；如果不匹配再继续判断varnish向后端请求的首部url的值是否匹配.jpg|jpeg|png|gif|css|js结尾的资源，如果匹配则取消后端服务器响应varnish服务器的响应首部set-cookie的值，并设置后端服务器响应varnish的资源缓存时长为1小时；简单讲就是判断后端服务器响应首部的cache-control的值是否匹配到“s-maxage”，如果不能匹配到在判断向后端服务器请求的首部url是否是匹配指定结尾的资源，如果是，就取消后端服务器响应首部set-cookie这个首部，同时把后端服务器响应资源的缓存时长设定为1小时；&lt;/p&gt;
&lt;p&gt;　　测试：为了验证以上vcl配置正确性，我们把beresp.ttl的值通过cache-control这个首部传递到浏览器响应首部，从而来判断set-cookie首部是被撤销了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406230453653-1655516069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：在上面的配置中加入了set beresp.http.cache-control = beresp.ttl;表示把后端响应给varnish的响应首部beresp.ttl的值 通过beresp.http.cache-control首部保存；这样客户端访问.jpg的资源就会在响应首部中把cache-control的值给显示出来，如果该值是我们设置的3600s，就说明我们撤销set-cookie这个首部的vcl语句是生效的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406230833315-1489845161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：从上面的结果看，cache-control的值为3600是我们设置beresp.ttl的值；说明撤销set-cookie的vcl配置生效了；同时这也告诉我们如果后端服务器响应varnish的报文中没有的首部，在varnish响应客户端中就没有；简单说就是varnish会把后端服务器响应给varnish中首部的值通过响应客户端首部传递出来；比如我在后端响应报文中自定义一个aaa的报文首部，其值为bbb，那么在客户端的响应报文首部中就会有对应aaa首部和对应的值；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406231419243-743170290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200406231624918-1441698301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：做以上测试需要考虑varnish上的缓存，如果你始终访问同一个url可能会看到对应首部的值不会发生变化，需要重启varnish或者换个其他符合vcl定义的url去访问试试看；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 06 Apr 2020 15:37:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下varnish的VCL配置以及语法特点，怎样去编译加载varnish的vcl配置，以及命令行管理工具varnishadm怎么去连接varnish管理接口进行管理varnish，回顾请参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12643549.html</dc:identifier>
</item>
</channel>
</rss>