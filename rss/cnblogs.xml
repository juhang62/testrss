<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#插件式开发 - ゞ七情</title>
<link>http://www.cnblogs.com/smallshu/p/12536435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallshu/p/12536435.html</guid>
<description>&lt;p&gt;　　记录一下C#插件式开发。&lt;/p&gt;
&lt;p&gt;　　原理：主要模块【运行DLL（共享DLL）】、【界面主程序】、【插件DLL】&lt;/p&gt;
&lt;p&gt;　　原理没时间写太详细，以后有机会再补充吧，先上传代码。&lt;/p&gt;
&lt;p&gt;以下是C#DLL程序集代码，命名为【Runtime】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Runtime
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAdd
    {
&lt;/span&gt;        &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是C#DLL程序集代码，命名为【Plugin】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Runtime;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Plugin
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation : IAdd
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是C#Console程序集代码，命名为为【Main】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Runtime;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Reflection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Main
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] files = Directory.GetFiles(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的dll文件，可以自己规定插件名称（比如“*.plugin.dll” = &quot;&lt;span&gt;123.plugin.dll&lt;/span&gt;&quot;）  进行过滤&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; fn &lt;span&gt;in&lt;/span&gt;&lt;span&gt; files)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取程序集&lt;/span&gt;
                Assembly ass =&lt;span&gt; Assembly.LoadFrom(fn);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有类，但是此处并没有被实例化。&lt;/span&gt;
                &lt;span&gt;foreach&lt;/span&gt; (Type pClass &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ass.GetTypes())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断该类是否是实现了接口&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (pClass.GetInterface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IAdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == (&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IAdd)))
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建实例类&lt;/span&gt;
                        &lt;span&gt;object&lt;/span&gt; obj =&lt;span&gt; ass.CreateInstance(pClass.FullName);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取类方法&lt;/span&gt;
                        MethodInfo fun = pClass.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行类方法&lt;/span&gt;
                        &lt;span&gt;object&lt;/span&gt; result = (&lt;span&gt;int&lt;/span&gt;)fun.Invoke(obj, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;&lt;span&gt; });
                        Console.WriteLine(result);
                    }
                }
            }
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 21 Mar 2020 00:18:00 +0000</pubDate>
<dc:creator>ゞ七情</dc:creator>
<og:description>记录一下C#插件式开发。 原理：主要模块【运行DLL（共享DLL）】、【界面主程序】、【插件DLL】 原理没时间写太详细，以后有机会再补充吧，先上传代码。 以下是C#DLL程序集代码，命名为【Runt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smallshu/p/12536435.html</dc:identifier>
</item>
<item>
<title>【JAVA进阶架构师指南】之二：JVM篇 - 悟空不败</title>
<link>http://www.cnblogs.com/wukongbubai/p/12536309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wukongbubai/p/12536309.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  谈到JAVA,就不得不提JVM---JAVA程序员绕不开的话题.也许有童鞋会说,我不懂JVM,但是我一样可以写出JAVA代码,我相信说这种话的童鞋,往往是只有1-3年的初级开发人员,对JAVA理解还不深,不明白JVM的重要性,那接下来我们来说说,为什么要学习JVM?&lt;br/&gt;  1.理解JVM,才能帮助我们写出更好,更健壮的代码.举个例子,以下代码的执行结果会是什么呢?很多童鞋肯定会说:嗯?当我傻吗?两个不都是true吗?这有啥好说的,真的是这样吗?感兴趣的童鞋可以自己下来试一试,至于为什么是这样的结果,在下文会解释清楚.&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1924225/202003/1924225-20200321025231753-1400154703.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  2.理解JVM,可以帮助我们提升JAVA程序的性能,排除问题.&lt;br/&gt;  3.也是最重要的一点,面试必问!&lt;/p&gt;
&lt;h2 id=&quot;虚拟机的种类&quot;&gt;虚拟机的种类&lt;/h2&gt;
&lt;p&gt;  我们知道,目前使用范围最广的虚拟机是sun公司的HotSpot VM,在这之前,sun公司发布的第一款虚拟机是Sun Classic/Exact VM,这是世界上第一款商用虚拟机.另外其他公司也有自己的虚拟机,比如IBM J9 VM,Google Android Dalvik VM,Apache Harmony,Microsoft VM等待,但是使用范围最广的还是HotSpot.&lt;/p&gt;
&lt;h2 id=&quot;jvm内存划分&quot;&gt;JVM内存划分&lt;/h2&gt;
&lt;p&gt;  引用一张图来说明:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1924225/202003/1924225-20200321025232074-211311758.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  可以看到,JVM主要由方法区/堆区/虚拟机栈/本地方法栈/程序计数器五个部分组成,从线程的角度来看,分为线程公有的部分(方发区/java堆)和线程私有的部分(虚拟机栈/本地方法栈/程序计数器).&lt;/p&gt;
&lt;h2 id=&quot;方法区&quot;&gt;方法区&lt;/h2&gt;
&lt;p&gt;  存放已经被虚拟机加载的[类信息/常量/静态变量/即时编译后的代码]等,有些文章也称方法区为永久代,主要发生的异常是内存溢出:OutOfMemoryError.另外在JDK1.6版本中,常量池(这里特指运行时常量池,我们一般说的常量池也都是指的运行时常量池)是存放于方法区中的(因此方法区可能会经常内存溢出),JDK1.7的时候常量池移到了JAVA堆(Heap)中,在JDK1.8的时候,已经没有方法区了,取而代之的是一块叫元数据(metaSpace)的空间.&lt;/p&gt;
&lt;h2 id=&quot;java堆&quot;&gt;java堆&lt;/h2&gt;
&lt;p&gt;  java堆主要存放的是对象实例以及数组等信息,主要发生的异常仍然是内存溢出:OutOfMemoryError.并且java堆区是GC重点关注的区域.另外,我们常说,几乎所有的对象分配内存都是在java堆中进行,而不是说所有对象100%都在java堆中分配内存,是因为有两种例外情况不会在java堆中分配内存,第一种是TLAB(线程本机分配缓存),另一种是栈上分配,既然想成为一名架构师,童鞋们应该要弄明白什么是TLAB和栈上分配,发挥你们的能力,尽情Google吧.&lt;/p&gt;
&lt;h2 id=&quot;虚拟机栈&quot;&gt;虚拟机栈&lt;/h2&gt;
&lt;p&gt;  java方法执行的内存模型,每个方法在执行的时候会封装成一个栈帧,存放[局部变量表/操作数栈/动态链表/方法出口]等信息,方法的执行对应栈帧入栈和出栈的过程.栈的深度是有大小的,默认情况下栈的内存为1M,因此虚拟机栈除了发生内存溢出异常,还有可能发生StackOverFlowError异常.&lt;/p&gt;
&lt;h2 id=&quot;本机方法栈&quot;&gt;本机方法栈&lt;/h2&gt;
&lt;p&gt;  和虚拟机栈作用类似,区别在于本地方法栈保存的是native方法的信息.&lt;/p&gt;
&lt;h2 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h2&gt;
&lt;p&gt;  当前线程执行的字节码行号指示器,是JVM中唯一一块没有内存溢出异常的区域.&lt;/p&gt;
&lt;h2 id=&quot;常量池&quot;&gt;常量池&lt;/h2&gt;
&lt;p&gt;  接下来我们再倒回来看看,文章开头的代码,执行结果会是什么:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1924225/202003/1924225-20200321025232347-154678034.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  127返回的是true,128返回的确是false.为什么?&lt;br/&gt;  首先我们知道,在java语言中 == 比较的是两个对象的内存地址,只有equals方法才是比较两个对象是否相等,执行结果告诉我们,值都为127的Integer a和b内存地址是相同的,他们是同一个对象,而值为128的Integer c和d的内存地址不同,他们是不同的两个对象,那为什么127就是相同的对象,128就是不同的对象呢?还记得上文中,我们说方法区中有一块区域叫运行时常量池,存放的是各种常量,java语言对byte/short/char/int/string设置了常量池,比如我们查看Integer的源码:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1924225/202003/1924225-20200321025232620-2034723576.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  可以发现,Integer的常量池范围是-128~127,在该范围内的Integer对象都会复用常量池中的值,因此a和b是相同对象,而超过该范围,会重新new一个新的对象,因此c和d都是重新new出来的,地址当然不同,因此是false.另外String类型的常量池和前面四种类型不一样,String类型的常量池是通过final来实现的.而float/double没有常量池的概念,因为float和double本身都是科学技术法表示近似数,无法精确计算,存在精度丢失的情况,因此没法为float和double创建常量池.&lt;/p&gt;
&lt;p&gt;  本文我们了解了JVM的内存区域,下一篇文章,让我们来学习类加载机制,敬请期待!&lt;/p&gt;
&lt;p&gt;  如果觉得博主写的不错,欢迎关注博主微信公众号,博主会不定期分享技术干货!&lt;br/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/other/1924225/202003/1924225-20200321025233044-395423174.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 20 Mar 2020 18:53:00 +0000</pubDate>
<dc:creator>悟空不败</dc:creator>
<og:description>前言 谈到JAVA,就不得不提JVM JAVA程序员绕不开的话题.也许有童鞋会说,我不懂JVM,但是我一样可以写出JAVA代码,我相信说这种话的童鞋,往往是只有1 3年的初级开发人员,对JAVA理解还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wukongbubai/p/12536309.html</dc:identifier>
</item>
<item>
<title>Excel表格转Json数据结构 - 落单的毛毛虫</title>
<link>http://www.cnblogs.com/mmc1206x/p/12536306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmc1206x/p/12536306.html</guid>
<description>&lt;p&gt;辗转了好几个项目，每个项目的导表工具都巨难用，速度慢，潜规则多，扩展性差，不易于调试。Sqlite，Json，Lua，Xml各种格式都用过。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;大多数导表工具不支持文本数组的解析，因为它们对数组的解析算法异常粗暴，无非就是一个Split(value, &quot;,&quot;)，当你的文本数组没有逗号时，一切都OK，一旦出现逗号，解析结果错误，但程序依旧正常运行，直到游戏中读取错误时，你才能意识到出问题了。&lt;/p&gt;
&lt;p&gt;不能类型组合，通常这些导表工具都不支持类型之间的组合，例如整数数组，哈希数组等等。有的支持整数数组，但它并不是把整数和数组两个类型结合，而是单独定义了一个&lt;strong&gt;整数数组&lt;/strong&gt;的类型，当需要稍微复杂一点的结构时，则不支持甚至完全不能实现，比如数组嵌套数组。&lt;/p&gt;
&lt;p&gt;错误无法定位，输出的错误信息几乎没有看不懂，策划更是束手无策。&lt;/p&gt;
&lt;p&gt;没有类型安全，当配置表的某个字段名被修改时，程序可能完全不知道，直到游戏中读取配置错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;在数据结构上我个人最理想的数据格式是Json。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Sqlite&lt;/em&gt; 对客户端不友善，大多数客户端对SQL语句并不熟悉。作为配置数据而言，关系数据库的优势并不明显，如果数据查询需要复杂的SQL语句，这个数据结构设计本身就是错误的，如果仅使用简单的SQL语句查询，那为什么不直接用Key-Value数据结构？此外，Sqlite需要用专门的数据库软件浏览，而不能直接在IDE或者文本编辑器中查看。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Lua&lt;/em&gt; 结构跟Json类似，但它有两个问题，1. 不容易区分数组和哈希，2. 作为数据结构而言，应用范围比较狭窄，Json比Lua出名太多，Json第三方解析库比Lua多太多，以至于大家更容易接受Json而非Lua。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Xml&lt;/em&gt; 太多额外数据，阅读相对于Json不直观。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Json&lt;/em&gt; 结构简洁，大多数文本编辑器可高亮内容，第三方解析库众多，流行范围广，前后端都容易接受。&lt;/p&gt;
&lt;h3 id=&quot;易用性&quot;&gt;易用性&lt;/h3&gt;
&lt;p&gt;我见过一次导表开销花掉1小时的，以至于没有人敢轻易尝试导出Excel，这个情况持续了1年，终结这个情况的并不是项目凉了，而是我重新实现了一个工具且完全它的解析格式，新的解析程序导出全部Excel只需10秒。&lt;/p&gt;
&lt;p&gt;我见过Excel配置非常繁琐，众多潜规则，当你新建一份配置表时，你必须参考一份旧表，要不然你根本不知道该怎么填。&lt;/p&gt;
&lt;h3 id=&quot;一个好用的导表工具&quot;&gt;一个好用的导表工具&lt;/h3&gt;
&lt;p&gt;由于最近重返手游行业，于是想实现一个效率，扩展性，易用性，安全性都比较OK的导表工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式&lt;/strong&gt; &lt;em&gt;(详情请看Demo)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//  已支持的格式
bool        布尔值
number      数值
string      字符串
list        数组
dict        哈希
type        自定义结构

//  格式定义
bool b;
number n;
string s;
[number] n_list;                            //  数值数组    list&amp;lt;number&amp;gt; n_list;
{number} n_dict;                            //  数组哈希    dict&amp;lt;number&amp;gt; d_dict;
&amp;lt;number n, string s&amp;gt; type;                  //  自定义结构  struct {
                                            //                  number n;
                                            //                  string s;
                                            //              } type;

//  类型组合
[[number]]  n_n_list;                       //  数组嵌套数组
{[number]}  n_n_dict;                       //  哈希嵌套数组
&amp;lt;[number] n_list, {number} n_dict&amp;gt; type;    //  数据格式如下:
                                            //  struct {
                                            //      list&amp;lt;number&amp;gt; n_list;
                                            //      dict&amp;lt;number&amp;gt; n_dict;
                                            //  } type;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;错误定位&lt;/strong&gt; &lt;em&gt;(详情请看Demo)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//  打印错误文件，行，列，出错原因
C:\Github\xlsx2json&amp;gt;export.py
&amp;gt; 异常: C:\Github\xlsx2json/in/cfg_2.xlsx | 5:2 | [bool]值错误 &quot;
&amp;gt; ---Export End---&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt; &lt;em&gt;(详情请看Demo)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//  输出指定语言的数据结构(当前只支持C++和C#)
//  可通过Json库解析到对应的数据结构
var test = Json.From&amp;lt;config.Test&amp;gt;(&quot;test.json&quot;);
var n = test.n;
var s = test.s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束&quot;&gt;结束&lt;/h3&gt;
&lt;p&gt;执行文件：export.py&lt;/p&gt;
&lt;p&gt;运行环境：Python3.0&lt;/p&gt;
&lt;p&gt;运行依赖：openpyxl&lt;/p&gt;
&lt;p&gt;导表配置 (export.py文件)：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#   Json输入目录
JSON_I = os.getcwd() + &quot;/in/&quot;
#   Json输出目录
JSON_O = os.getcwd() + &quot;/out/&quot;
#   结构化输出目录
STRUCT_O = os.getcwd() + &quot;/out/config.cs&quot;
#   命名空间
NAMESPACE = &quot;config&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mmc1993/xlsx2json&quot;&gt;Github传送门&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 18:50:00 +0000</pubDate>
<dc:creator>落单的毛毛虫</dc:creator>
<og:description>Excel表格转Json数据结构 辗转了好几个项目，每个项目的导表工具都巨难用，速度慢，潜规则多，扩展性差，不易于调试。Sqlite，Json，Lua，Xml各种格式都用过。 举个例子： 大多数导表工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmc1206x/p/12536306.html</dc:identifier>
</item>
<item>
<title>Linux 中useradd命令的使用 - Hackerman</title>
<link>http://www.cnblogs.com/Hackerman/p/12535719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hackerman/p/12535719.html</guid>
<description>&lt;p&gt;     Linux 系统中通常都是root用户具有超级权限，超级用户root一般是不需要创建的，然而很多时候root用户不是任何人都可以使用的，毕竟最高权限的用户，任意使用的话，会对系统造成很多不必要的破坏。那么就需要创建给不同人创建用户进行Linux系统的访问，或者针对不同的应用程序使用不同的用户。这时候有人会说，创建用户很简单啦，不就直接使用useradd 或者adduser就完事啦，确实是这样的，但是就这么简单的一个命令，却有不同的使用方式或者有不同的方法来创建用户。下面通过15个案例来看一这个useradd或者adduser的不同使用方式。&lt;/p&gt;
&lt;p&gt;   由于Linux系统的版本以及操作系统类型不大一样，不同版本的以及不同类型的操作系统的命令具体还要参照对应的文档，这里只是简单的使用centos来进行举例。&lt;/p&gt;
&lt;p&gt;   在Linux系统中执行‘useradd’命令，主要就是完成以下三个过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为新创建的用户帐户编辑/etc/passwd、/etc/shadow、/etc/group和/etc/gshadow文件。&lt;/li&gt;
&lt;li&gt;为新用户创建用户主目录（home目录）。&lt;/li&gt;
&lt;li&gt;设置用户主目录（home目录）的权限和所有权.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建用户命令的基本语法是:&lt;/p&gt;
&lt;p&gt;useradd [options] username&lt;/p&gt;
&lt;p&gt; 在本文中，我们将向您展示在Linux中最常用的15个useradd命令及其实际例子。我们把这一节从基本用法到高级用法分为两部分&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一部分：主要通过10个例子来展示useradd的基本用法&lt;/li&gt;
&lt;li&gt;第二部分:：通过5个例子来展示useradd的高级用户&lt;/li&gt;
&lt;/ol&gt;&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;第一部分：useradd命令的10个基本用法&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;1，如何增加一个用户在Linux中&lt;/p&gt;
&lt;p&gt;在Linux系统中新增一个用户，可以使用useradd或者adduser命令后面加上一个用户名来进行新增。这个用户名是用于系统登录的，因此这个用户名必须是唯一的，如果系统中已经有用户了，就不能进行创建了。&lt;/p&gt;
&lt;p&gt;例如，增加一个新的用户test1，使用以下命令。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd test1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320211201546-872378516.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们创建完test1用户之后，这个时候用test1用户来进行登录，登录不了的，由于该用户我们不知道用户的密码，登录不了的，那如何给用户添加密码呢？通过下面命令进行添加。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# passwd test1&lt;br/&gt;Changing password for user test1.&lt;br/&gt;New password:&lt;br/&gt;BAD PASSWORD: The password is shorter than 8 characters&lt;br/&gt;Retype new password:&lt;br/&gt;passwd: all authentication tokens updated successfully.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320212416338-312676175.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户创建之后默认会把用户自动添加到/etc/passwd文件中, 这个文件用来存储用户的信息。&lt;/p&gt;
&lt;p&gt;test1:x:1002:1002::/home/test1:/bin/bash&lt;/p&gt;
&lt;p&gt;上面的条目包含一组由7个冒号分隔的字段，每个字段都有自己的含义。让我们看看这些字段是什么:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户名:用于登录系统的用户登录名。长度应该在1到32字符之间。&lt;/li&gt;
&lt;li&gt;密码:以加密格式存储在/etc/shadow文件中的用户密码(或x字符)。&lt;/li&gt;
&lt;li&gt;用户ID (UID):每个用户必须有一个用户ID (UID)用户标识号。默认情况下，UID 0保留给根用户，1-99之间的UID保留给其他预定义帐户。此外，UID的范围从100-999保留系统帐户和组。&lt;/li&gt;
&lt;li&gt;组ID (GID):存储在/etc/group文件中的主组ID (GID)组标识号。&lt;/li&gt;
&lt;li&gt;用户信息:该字段是可选的，允许您定义关于用户的额外信息。例如，用户全名。该字段由' finger '命令填充。&lt;/li&gt;
&lt;li&gt;主目录:用户的主目录的绝对位置。&lt;/li&gt;
&lt;li&gt;Shell:用户Shell的绝对位置，即/bin/bash。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2，创建一个具有不同主目录的用户&lt;/p&gt;
&lt;p&gt;通常情况下，在Linux操作系统中创建一个用户默认创建用户的目录在home目录下，就比如上面创建的用户主目录就默认就是/home/test1目录。&lt;/p&gt;
&lt;p&gt;但是可以使用“-d” 可选参数来改变用户的主目录的位置，例如创建一个test2用户在/tempfile/user1.首先这个/tempfile/user1必须是已经在系统创建好的目录也可以是其它目录。&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -d /tempfile/user1/ test2&lt;/p&gt;
&lt;p&gt;这个时候命令执行成功之后，我们在回去看一下/etc/passwd 中的目录&lt;/p&gt;
&lt;p&gt;[root@localhost /]# cat /etc/passwd | grep test2&lt;br/&gt;test2:x:1003:1003::/tempfile/user1/:/bin/bash&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320215156847-1578992584.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3，创建一个具有不同用户ID的用户&lt;/p&gt;
&lt;p&gt;在Linux中，每个用户都有自己的UID(惟一标识号)。默认情况下，每当我们在Linux中创建一个新用户帐户时，它都会分配用户500、501、502等等。。。&lt;/p&gt;
&lt;p&gt;但是，我们可以创建用户的自定义用户id与' -u '选项。例如，下面的命令将创建一个用户' test3'与自定义用户id '996 '。&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -u 996 test3&lt;/p&gt;
&lt;pre&gt;
接下来让我们来验证一下，该命令执行成功是否创建了用户id为996的用户test3.
&lt;/pre&gt;
&lt;p&gt;root@localhost /]# cat /etc/passwd |grep test3&lt;br/&gt;test3:x:996:1005::/home/test3:/bin/bash&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320220107050-855349635.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意:确保用户ID的值必须与系统中任何其他已创建的用户唯一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4，创建具有特定组ID的用户&lt;/p&gt;
&lt;p&gt;类似地，每个用户都有自己的GID(组标识号)。我们还可以使用-g选项创建具有特定组ID的用户。&lt;/p&gt;
&lt;p&gt;在本例中，我们将在“-u”和“-g”选项的帮助下同时添加具有特定UID(不存在的用户id)和GID(必须存在的组)的用户“test4”。&lt;/p&gt;
&lt;p&gt;[root@localhost~]# useradd -u 1005 -g 1000 test4&lt;/p&gt;
&lt;p&gt;执行完之后, 我们来验证一下，通过查看/etc/passwd文件。&lt;/p&gt;
&lt;p&gt;[root@localhost~]# cat /etc/passwd | grep test4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320221027564-1609894014.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5，将一个用户添加到多个组&lt;/p&gt;
&lt;p&gt;使用useradd命令加上“-G”选项将用户添加到其他组。每个组名由逗号分隔，中间没有空格。&lt;/p&gt;
&lt;p&gt;在本例中，我们将用户“test5”添加到多个组中，如管理员、webadmin和开发人员。&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -G webadmin,devloper,dba test5&lt;/p&gt;
&lt;p&gt;接下来，使用id命令验证分配给用户的多个组&lt;/p&gt;
&lt;p&gt;[root@localhost /]# id test5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320221753952-55390983.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6，添加一个没有主目录的用户&lt;/p&gt;
&lt;p&gt;在某些情况下，由于一些安全原因，我们不希望为用户分配主目录。在这种情况下，当用户登录到刚刚重新启动的系统时，其主目录将是根目录。当该用户使用su命令时，其登录目录将是以前的用户主目录。&lt;/p&gt;
&lt;p&gt;若要创建没有主目录的用户目录，则使用' -M '。例如，下面的命令将创建一个没有主目录的用户' test6'。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd -M test6&lt;/p&gt;
&lt;p&gt;接下来我们使用ls命令来验证一下用户test6是否有主目录。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# ls -l /home/test6&lt;br/&gt;ls: cannot access /home/test6: No such file or directory&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320222512298-894039639.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7，创建一个具有过期时间的用户&lt;/p&gt;
&lt;p&gt;默认情况下，当我们添加用户使用’ useradd‘命令时，用户帐户永远不会有过期时间。它们的有效日期被设定为0(意思是从未过期)。&lt;/p&gt;
&lt;p&gt;不过，我们可以用“e”来设置有效期。选项，它将日期设置为yyyy-mm-ddd格式。这有助于为特定时间段创建临时帐户。&lt;/p&gt;
&lt;p&gt;在这个例子中，我们创建了一个用户‘test7‘用户到期日为2020年3月21日，格式为yyyy-mm-ddd。&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -e 2020-03-21 test7&lt;/p&gt;
&lt;pre&gt;
其次，在设置帐户到期日期后，使用“chage”命令为用户“test7”验证帐户和密码的年龄。
&lt;/pre&gt;
&lt;p&gt;[root@localhost /]# chage -l test7&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320223507099-1590352440.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8，创建一个具有密码过期时间的用户&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;useradd命令的‘-f‘参数用于定义密码过期后的天数。当密码过期时，用户帐户立即停止活动。默认情况下，将密码过期值设置为-1意味着永不过期。.&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在本例中，我们将为用户设置一个帐户密码到期日期，即45天。使用’-e‘和’-f‘选项&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -e 2020-03-20 -f 45 test8&lt;/p&gt;
&lt;p&gt;9，创建一个自定义注释的用户&lt;/p&gt;
&lt;p&gt;useradd命令的‘-c‘选项允许您添加自定义注释，如用户全名、电话号码等到/etc/ passwd;)文件中。可以将注释添加为不带空格的单行&lt;/p&gt;
&lt;p&gt;例如，下面的命令将添加一个用户test9‘并将该用户的全名test9 devloper插入到评论字段中。&lt;/p&gt;
&lt;p&gt;[root@localhost~]# useradd -c &quot;test9 devloper&quot; test9&lt;/p&gt;
&lt;p&gt;你可以在/etc/passwd‘ /etc/passwd‘文件在评论部分。&lt;/p&gt;
&lt;p&gt;[root@localhost~]# tail -1 /etc/passwd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320224922181-355489874.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10，更改用户登录Shell&lt;/p&gt;
&lt;p&gt;有时，我们添加与登录shell无关的用户，有时我们需要为用户分配不同的shell。我们可以为每个用户分配不同的登录shell选项&lt;/p&gt;
&lt;p&gt;在本例中，将添加一个用户没有登录shell，即‘/sbin/nologin‘shell.&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd -s /sbin/nologin test10&lt;/p&gt;
&lt;p&gt;您可以检查分配给用户的shell在‘/etc/passwd‘文件&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# tail -1 /etc/passwd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320225345786-232229676.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;第二部分：useradd命令的5个高级用法&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;11，添加一个具有特定主目录、默认Shell和自定义注释的用户&lt;/p&gt;
&lt;pre&gt;
下面的命令将创建一个用户'test11 '与主目录' /tempfile/user11'，默认shell为/bin/bash，并添加额外的信息用户。
&lt;/pre&gt;
&lt;p&gt;[root@localhost ~]# useradd -m -d /tempfile/user11 -s /bin/bash -c &quot;dba Owner&quot; -U test11&lt;/p&gt;
&lt;p&gt;在上面的命令中，' -m -d '选项创建一个具有指定主目录的用户，' -s '选项设置用户的默认shell，即/bin/bash.“-c”选项添加关于用户和“-U”参数的额外信息创建/添加与用户同名的组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320230105543-1650499121.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12，添加具有主目录、自定义Shell、自定义注释和UID/GID的用户&lt;/p&gt;
&lt;p&gt;该命令与上面的命令非常相似，但是这里我们将shell定义为' /bin/zsh '，并将自定义UID和GID定义为用户' test '的用户id和用户组id。其中“-u”定义新用户的UID(即1204)，而“-g”定义GID(即1000)。&lt;/p&gt;
&lt;p&gt;[root@localhost /]# useradd -m -d /tempfile/user12 -s /bin/zsh -c &quot;devloper owner&quot; -u 1204 -g 1000 test12&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320230819074-1166162148.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13，添加一个具有主目录、没有Shell、自定义注释和用户ID的用户&lt;/p&gt;
&lt;p&gt;下面的命令与上面的两个命令非常相似，唯一的区别是这里，我们禁用登录shell到一个名为' test13 '的用户自定义用户ID(即1026)。&lt;/p&gt;
&lt;p&gt;这里' -s '选项添加了默认的shell /bin/bash，但在本例中，我们将login设置为' /usr/sbin/nologin '。这意味着用户' test13 '将无法登录到系统。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd -m -d /tempfile/user13 -s /usr/sbin/nologin -c &quot;dba enginer&quot; -u 1026 test13&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320231145444-773344037.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;14，添加具有主目录、Shell、自定义Skell/注释和用户ID的用户&lt;/p&gt;
&lt;p&gt;这个命令中唯一的变化是，我们使用' -k '选项来设置自定义框架目录，即/etc/custom.skell，不是默认的 /etc/skel。我们还使用了' -s '选项来定义不同的shell，即/bin/tcsh来定义用户' test14 '。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd -m -d /tempfile/user14 -k /etc/custom.skell -s /bin/tcsh -c &quot;No Active Member of test14&quot; -u 1212 test14&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320231805196-20442883.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15，添加一个没有主目录、没有Shell、没有组和自定义注释的用户&lt;/p&gt;
&lt;p&gt;下面的命令与上面介绍的其他命令非常不同。这里我们使用' -M '选项来创建没有用户主目录的用户，并使用' -N '参数来告诉系统只创建用户名(没有组)。' -r '参数用于创建系统用户。&lt;/p&gt;
&lt;p&gt;[root@localhost ~]# useradd -M -N -r -s /bin/false -c &quot;Disabled test15 Member&quot; test15&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/566138/202003/566138-20200320232116332-367237164.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，今天的分享就到这，小弟不才，望大家有什么讲解不到位或者有问题的，请多指教，欢迎留言区评论。有喜欢的朋友记得收藏或者点赞哦，最后很多知识分享到微信公众号井壹数码，希望感兴趣的朋友关注一下。多谢各位。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 15:24:00 +0000</pubDate>
<dc:creator>Hackerman</dc:creator>
<og:description>Linux 系统中通常都是root用户具有超级权限，超级用户root一般是不需要创建的，然而很多时候root用户不是任何人都可以使用的，毕竟最高权限的用户，任意使用的话，会对系统造成很多不必要的破坏。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Hackerman/p/12535719.html</dc:identifier>
</item>
<item>
<title>webpack，Babel，babel-loader的关系 - whosmeya</title>
<link>http://www.cnblogs.com/whosMeya/p/12535654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whosMeya/p/12535654.html</guid>
<description>&lt;p&gt;本文将要介绍 webpack，Babel，babel-loader 的关系。理清楚他们各自做了什么事情。&lt;/p&gt;
&lt;p&gt;通常我们新建一个项目，会先配置webpack，然后配置babel；babel是一个编译工具，实际上，babel也是可以单独使用的。&lt;/p&gt;
&lt;p&gt;下面我们从Babel出发，简单配置一个react项目，来清晰认识一下webpack和babel的关系。&lt;/p&gt;
&lt;h2 id=&quot;babel-和-webpack-简介&quot;&gt;Babel 和 Webpack 简介&lt;/h2&gt;
&lt;p&gt;Babel 是一个 JavaScript 编译器。（把浏览器不认识的语法，编译成浏览器认识的语法。）&lt;/p&gt;
&lt;p&gt;webpack 是一个现代 JavaScript 应用程序的静态模块打包器。（项目打包）&lt;/p&gt;
&lt;p&gt;下面会用到的：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@babel/cli&lt;/td&gt;
&lt;td&gt;Babel附带了一个内置的CLI，可用于从命令行编译文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@babel/core&lt;/td&gt;
&lt;td&gt;使用本地配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@babel/preset-env&lt;/td&gt;
&lt;td&gt;编译最新版本JavaScript&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@babel/preset-react&lt;/td&gt;
&lt;td&gt;编译react&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@babel/polyfill&lt;/td&gt;
&lt;td&gt;通过 Polyfill 方式在目标环境中添加缺失的特性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@babel/plugin-proposal-class-properties&lt;/td&gt;
&lt;td&gt;编译 class&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;开始配置&quot;&gt;开始配置&lt;/h2&gt;
&lt;p&gt;新建项目&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir babel-in-webpack&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入项目&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd babel-in-webpack/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化 npm&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不用管提示，一顿回车键。然后会生成一个文件 &lt;code&gt;package.json&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-babel&quot;&gt;配置 Babel&lt;/h3&gt;
&lt;p&gt;安装 Babel 相关依赖&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install --save-dev @babel/cli @babel/core @babel/preset-env @babel/polyfill&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建文件 &lt;code&gt;babel.config.json&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;
  ],
  &quot;plugins&quot;: []
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建文件夹 &lt;code&gt;src&lt;/code&gt;，&lt;code&gt;src&lt;/code&gt; 内新建文件 &lt;code&gt;test.js&lt;/code&gt;，随便写点啥es6语法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320211647973-443876499.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用下面命令编译&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./node_modules/.bin/babel src --out-dir lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320212204224-399315473.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译完会新增目录&lt;code&gt;lib&lt;/code&gt;, 里面放着编译好的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320211752862-186141817.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-react&quot;&gt;配置 React&lt;/h3&gt;
&lt;p&gt;安装 &lt;code&gt;Babel&lt;/code&gt; 编译 &lt;code&gt;React&lt;/code&gt; 的依赖&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install --save-dev @babel/preset-react @babel/plugin-proposal-class-properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;babel.config.json&lt;/code&gt; 添加 &lt;code&gt;React&lt;/code&gt; 相关配置&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-react&quot;
  ],
  &quot;plugins&quot;: [
    &quot;@babel/plugin-proposal-class-properties&quot;
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 &lt;code&gt;React&lt;/code&gt; 相关依赖&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install --save react react-dom&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt; 下新增 &lt;code&gt;react&lt;/code&gt; 文件 &lt;code&gt;main.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  render() {
    return (
      &amp;lt;div&amp;gt;Hello World!&amp;lt;/div&amp;gt;
    )
  }
}

ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById('root'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令编译&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./node_modules/.bin/babel src --out-dir lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译完成后 &lt;code&gt;lib&lt;/code&gt; 下多了一个 &lt;code&gt;main.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320213132647-847838181.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来编译很成功, 我们在 &lt;code&gt;lib&lt;/code&gt; 下面新建一个 html 引入 &lt;code&gt;main.js&lt;/code&gt; 看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320174059014-369351006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报错，浏览器不认识require，继续往下看。&lt;/p&gt;
&lt;h3 id=&quot;配置-webpack&quot;&gt;配置 webpack&lt;/h3&gt;
&lt;p&gt;安装 &lt;code&gt;webpack&lt;/code&gt; 依赖&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install --save-dev webpack webpack-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根目录新建文件 &lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const path = require('path');

module.exports = {
  entry: './src/main.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;scripts&lt;/code&gt; 中加入命令&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;&quot;build&quot;: &quot;webpack --mode development&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320215050350-389680613.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 不认识 &lt;code&gt;react&lt;/code&gt; 语法，在 &lt;code&gt;webpack.config.js&lt;/code&gt; 中加入 &lt;code&gt;babel-loader&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const path = require('path');

module.exports = {
  entry: './src/main.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [
      { test: /\.js$/, use: 'babel-loader' }
    ]
  },
  plugins: []
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装依赖 &lt;code&gt;babel-loader&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install --save-dev babel-loader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320221633584-77810522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会看到 &lt;code&gt;dist/main.js&lt;/code&gt;, 写个html引入试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202003/1141466-20200320222151486-254242323.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;两种编译结果对比&quot;&gt;两种编译结果对比&lt;/h3&gt;
&lt;p&gt;我们来看 &lt;code&gt;Babel&lt;/code&gt; 编译结果 &lt;code&gt;lib/main.js&lt;/code&gt; 和 &lt;code&gt;webpack&lt;/code&gt; 编译结果 &lt;code&gt;dist/main.js&lt;/code&gt;，发现 &lt;code&gt;Babel&lt;/code&gt; 仅仅是将 &lt;code&gt;src/main.js&lt;/code&gt; 的react语法编译成了js语法，而 &lt;code&gt;webpack&lt;/code&gt; 将 &lt;code&gt;src/main.js&lt;/code&gt; 和引入的 &lt;code&gt;node_modules&lt;/code&gt; 融合后用 &lt;code&gt;Babel&lt;/code&gt; 编译。&lt;/p&gt;
&lt;p&gt;浏览器不认识 &lt;code&gt;require&lt;/code&gt;，&lt;code&gt;webpack&lt;/code&gt; 实现了一套浏览器认识的 &lt;code&gt;require&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Babel&lt;/code&gt; 是编译工具，把高版本语法编译成低版本语法，或者将文件按照自定义规则转换成js语法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 是打包工具，定义入口文件，将所有模块引入整理后，通过loader和plugin处理后，打包输出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 通过 &lt;code&gt;babel-loader&lt;/code&gt; 使用 &lt;code&gt;Babel&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/whosMeya/babel-in-webpack&quot;&gt;代码地址：GitHub&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Mar 2020 15:11:00 +0000</pubDate>
<dc:creator>whosmeya</dc:creator>
<og:description>本文将要介绍 webpack，Babel，babel loader 的关系。理清楚他们各自做了什么事情。 通常我们新建一个项目，会先配置webpack，然后配置babel；babel是一个编译工具，实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whosMeya/p/12535654.html</dc:identifier>
</item>
<item>
<title>阿里云加Picgo或MPic搭建最豪横的图床 - 不愿透露姓名的高杨</title>
<link>http://www.cnblogs.com/thecatcher/p/12535322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thecatcher/p/12535322.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释一下什么是图床，图床其实就是提供图片存储的服务器。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于自建博客来说，由于各种原因的限制（比如穷。。。）可能无法购买存储空间比较大的VPS。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于markdown来说，因为markdown源文件是纯文本的。 所以无法存储图片类的多媒体文件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然像印象笔记等是支持本地图片存储的，这个就另说了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了解决文章中图片存储的问题，我们可以考虑使用图床的方式，将图片保存在存储服务器上，而在我们的文章中引用图片链接就可以了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用图床的优点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;方便，简洁&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;markdown源文件“可移植性”更好&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;选择优质的图床可以加快文章的加载速度&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然使用图床也有一定的风险和缺点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;图片不是保存在本地，万一图床服务器挂了，所有图片都无法正常显示&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;速度慢的图床可能会导致图片加载缓慢甚至加载异常&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;微信公众号对图床的支持存在一些诡异的问题&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;公共图床的图片存在被泄露的风险，不建议在公共图床中上传涉及个人隐私及商业机密的图片&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信如果大家看过某新晋作者的公众号&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;吾码2016&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的文章的话，应该会发现，某些时候，文章内的图片好像出了一些问题。虽然无伤大雅，但是作为一个自我要求极其严格的作者，该公众号作者正在想尽一切办法解决这个问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以是使用图床，还是手工排版图片，这个需要大家仔细斟酌。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你选择使用图床的话，那么就请继续往下看。 如果你出于安全考虑，选择手工图片排版，那么请点击左上角的叉叉，然后继续阅读下一篇文章《比海飞丝还顺滑的写作体验---幕布+typora》&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;图床的选择&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前网络上开放的公共图床很多我曾经用过的有一下几个：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里着重说一下图壳，上一篇文章中介绍的公众号编辑神器markdown nice编辑器默认支持的就是图壳图床。 可以直接将图片粘贴到编辑器中，编辑器会自动上传到图壳。所以要说推荐的话，出于对markdown nice 作者大神的崇拜，我推荐图壳。并且表示不接受反驳。。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果对于公共图床不够放心或者使用上不够顺手的话，这里介绍两个自建图床的方法：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;使用Github搭建自己的图床，具体方法请点击上方的叉叉，在历史文章中找到《好记性不如烂笔头-打造隔热知识库》一文，在该文最后有介绍具体操作教程&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;斥巨资购买阿里云OSS服务搭建个人图床&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，作为一个至今仍然无法靠写作赚到一毛钱但仍然嘴硬表示&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;自己并不差钱&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的作者，这里就教大家如何使用阿里云OSS存储服务搭建个人图床。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;阿里云OSS搭建个人图床&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要说明一下为什么选择阿里云。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我喜欢...你管我...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你不喜欢阿里云的话，可以选择腾讯云。但是千万不要选择百度云，没有为什么，看百度不爽而已...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1.首先打开阿里云主页：https://cn.aliyun.com/&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200318233232.png&quot; alt=&quot;阿里云主页&quot;/&gt;阿里云主页
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一股熟悉的气息铺面而来，不知道是阿里的UI偷懒还是为了让云计算服务更加亲民化，为什么主页设计的跟你家淘宝一个德行...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击右上角的登录按钮（是的，绝大部分人不需要注册，因为即使没有淘宝账号，你也会有支付宝账号的。。。）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后选择支付宝快捷登录或者直接使用淘宝账号登录就可以了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2.跳转回主页之后点击右上角的控制台，一次选择左上角的菜单，对象存储OSS&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200318233804.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step3.点击Bucket列表---创建Bucket&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200318234005.png&quot; alt=&quot;创建Bucket&quot;/&gt;创建Bucket
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step4.按照下图进行配置：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Bucket名称：全局唯一标识&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;区域：看着选，有很多地方。因为考虑到未来的我的目标读者可能会遍布大江南北，所以我选择的算是比较靠近中部的杭州。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;存储类型：标准存储就可以了&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;同城冗余：关闭，当然如果你资金充裕的话，可以考虑打开。这样的话你的存储会启用灾备，即使某个区域的服务器挂掉了，其他区域依旧可以提供服务&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;读写权限：这里要注意，一定是公共读！不然外网访问不了图片。。。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;加密，日志，备份：通通关闭，原因只有一个字：穷！&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200318234421.png&quot; alt=&quot;。。。&quot;/&gt;。。。
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击确定之后，很快就可以进入到我们刚刚创建好的Bucket了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在到了最肉疼的时候了，那就是去付费购买存储包。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;购买存储包并充值&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击资源包管理-购买资源包&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319000656.png&quot; alt=&quot;购买资源包&quot;/&gt;购买资源包
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后按照下图进行选择，具体我就不解释了，详细解释的话太复杂，时间的话建议一年起购，当然时间越久越便宜&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319000851.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看到，1年40G的标准存储要耗费七块两毛钱的巨额资金！！！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的大手笔，你怕了吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要说一下，存储包指的是我们购买的阿里云OSS的存储空间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下行流量指的是，外网请求我们图片的时候所消耗的流量。 这两个是分开计费的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来还打算买个流量包，但是看了一眼价格...再想到我的博客和公众号可怜的访问量...我觉得我可能用不上...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在我的使用了将近一个月之后的某一天，我突然收到这么一条短信，吓得我赶紧斥巨资给阿里云交钱。&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/4b2ffa878b71c970f5752dae894f84b.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，上面说的可能有点夸张。根据我这一个多月的使用情况来看，关于费用方面我总结了以下几点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;存储包是必须要购买的。40G对于图片存储是足够用的。一年7块两毛钱不算贵&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;流量的计费会根据图片请求次数和请求流量来计费，一般个人使用不需要太过担心&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在访问流量不大的情况下，几乎可以忽略不计，我充值了10块钱，到目前为止只用了两毛七&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;用户和权限配置&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1.在对象存储-概览这里，右上方，有快捷入口，选择访问控制RAM&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319105005.png&quot; alt=&quot;访问控制RAM&quot;/&gt;访问控制RAM
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2.选择用户-新建用户&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319105133.png&quot; alt=&quot;新建用户&quot;/&gt;新建用户
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step3.依次填写登录名称，显示名称。这里需要注意的是一定要勾选编程访问！！！&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319105236.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step4.用户创建成功之后一定要妥善保存AccessKeyID和AccessKeySecret&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319105804.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step5.保存好这两个值之后，返回用户列表，选择添加权限&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319105904.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step6.这里我们选择AliyunOSSFullAccess&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319110004.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，阿里云的配置至此完成。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;相关工具的配置和使用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们配置好了图床，但是如果每次都通过后台上传的话，非常的不方便。 这里推荐两个图床工具：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;a href=&quot;http://mpic.lzhaofu.cn/&quot;&gt;MPic&lt;/a&gt;：界面比较简单，但是上传速度很快&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot;&gt;PicGo&lt;/a&gt;：支持的图床多，可以自定义插件，开发团队解决bug的速度很快&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;MPic的配置和使用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MPic是绿色版软件，不需要安装，下载解压后可以直接运行。 软件体积很小，上传速度相当快，而且会自动根据日期建立文件夹分类。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有个缺点就是MPic会一直检测剪贴板，而且是自动上传。 所以只要截了图它就会biu~的一下以迅雷不及掩耳盗铃响叮当仁不让之势给你上传上去。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议作者加个快捷键会更好一点。让用户需要上传的时候再上传。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1.在主面板-设置账号&lt;/p&gt;
&lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319/113520939.png&quot; alt=&quot;设置账号&quot;/&gt;设置账号
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2.填写以下相关信息：&lt;/p&gt;
&lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319/113441449.png&quot; alt=&quot;mark&quot;/&gt;mark
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Endpoint信息可以在阿里云控制台，概览页面中看到：&lt;/p&gt;
&lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319/114120527.png&quot; alt=&quot;Endpoint信息&quot;/&gt;Endpoint信息
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AccessKeyID和AccessKeySecret就是前面要求大家保存的内容。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bucket是我们创建的Bucket名程。最后一个空，大家可以理解为需要上传到的文件夹。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置好之后，我们正常截图或者复制附图片到剪贴板，MPic就会自动上传，返回的结果是图片的Markdown格式的链接，可以直接插入到Markdown笔记中去。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;PicGo的配置和使用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PicGo相对MPic来说，支持的图床更多，而且支持自定义插件的形式新建图床上传接口（前提是你会写Node.js。）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载链接已经放在前面了，这里只说一下配置&lt;/p&gt;
&lt;img src=&quot;http://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200319/163806925.png&quot; alt=&quot;PicGo配置&quot;/&gt;PicGo配置
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，我们需要写的是存储区域，并不是EndPoint，这个跟MPic是不一样的。可以在阿里云OSS存储的概览界面查看。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外就是快捷键的设置，&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200320204835.png&quot; alt=&quot;设置快捷键&quot;/&gt;设置快捷键
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了按照这个配置好了之后，就可以使用了。 和MPic一样，上传图片后会自动返回Markdown链接&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Picgo好用的一点在于，不会自动上传，减少了误触发。 这点比较好。但是速度和稳定性上，好像比MPic差一点。不过能忍。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;阿里云OSS browser&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这玩意儿就是个文件管理器，用处不太大。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过如果需要进行文件管理的时候，又不喜欢登后台的...可以下一个玩玩。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正是绿色版的。不用的时候就丢在那儿。&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200320210218.png&quot; alt=&quot;阿里云OSS Browser登录&quot;/&gt;阿里云OSS Browser登录
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20200320211852.png&quot; alt=&quot;OSSBrowser管理界面&quot;/&gt;OSSBrowser管理界面
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;划重点！5秒钟学会使用图床&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能上面自建图床的方式对于非技术类作者有点太复杂了。那么请看这里，5秒钟（正负3秒，取决于你的网络速度，电脑性能和手速）学会使用图床。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来，跟着我做！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1.打开浏览器，输入&lt;code&gt;https://mdnice.com/&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2：正常写作，然后光标定位到在需要插入图片的地方，右键-图片-上传图片（截图请右键直接粘贴）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step3：点击确定&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step4：屏气凝神，等待图片上传完成。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step5：深藏功与名&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Markdown nice集成了图壳图床， 无论是对于微信公众号还是国内的博客都比较友好，很少出现博文中图片加载失败的情况。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实测可以放心使用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;P.S. 我和Markdown Nice团队没有利益相关，只是觉得这玩意儿太好用了。友情推荐，可能推荐的力度有点大...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果你细心的注意到了就会发现。对于整个写作系统的介绍，我提供了技术流喜欢的技术方案，也提供了很多非技术人员或者不喜欢折腾的童鞋的“一键操作”方式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Markdown Nice绝对是这种“一键”操作中的佼佼者。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有无论是哪种方式，自己写的开心就好，如果因为我们的分享能给别人带来新的思路和体验，那就是最好不过的事情了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卧槽，是不是又煲了个鸡汤。。。&lt;/p&gt;
&lt;p id=&quot;nice-suffix-juejin-container&quot; class=&quot;nice-suffix-juejin-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;本文使用 &lt;a href=&quot;https://mdnice.com&quot;&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 14:19:00 +0000</pubDate>
<dc:creator>不愿透露姓名的高杨</dc:creator>
<og:description>阿里云加Picgo或MPic搭建最豪横的图床 首先解释一下什么是图床，图床其实就是提供图片存储的服务器。 对于自建博客来说，由于各种原因的限制（比如穷。。。）可能无法购买存储空间比较大的VPS。 而对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thecatcher/p/12535322.html</dc:identifier>
</item>
<item>
<title>五分钟学Java：如何学习Java面试必考的网络编程 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/12535287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/12535287.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81NDQ3NjYwLTE1ODYzOTE2NWVlMWY5NmUuanBn?x-oss-process=image/format,png&quot; alt=&quot;副本_未命名.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原创声明&quot;&gt;原创声明&lt;/h2&gt;
&lt;p&gt;本文作者：黄小斜&lt;/p&gt;
&lt;p&gt;转载请务必在文章开头注明出处和作者。&lt;/p&gt;
&lt;h2 id=&quot;本文思维导图&quot;&gt;本文思维导图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200320215332444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Java作为一门后端语言，对于网络编程的支持是必不可少的，但是，作为一个经常CRUD的Java工程师，很多时候都不需要接触到网络编程，自然而然地对这个东西不那么重视了，毕竟，即使像是JVM虚拟机，Java多线程，在平时工作的时候还会用到一些，但是对于网络编程，除非你做的东西确实是需要自己写通讯服务代码的，比如网络游戏，以及偏向中间件方向的开发， 可能会接触到一些网络编程的实践，要不然在平时的开发工作中确实不多见。&lt;/p&gt;
&lt;p&gt;让我们看下网络编程在百度百科上的定义：网络编程最主要的工作就是在发送端把信息通过规定好的协议进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。&lt;/p&gt;
&lt;p&gt;那么，为什么网络编程重要呢，简单来说，计算机之间之所以能够通信，靠的就是网络编程，只不过平时这些代码不需要我们自己来写罢了，TCP/IP的协议代码已经封装在了Linux内核中 ，而Tomcat里的代码则负责处理一个个网络请求，返回请求方需要的数据。再比如像netty这样的网络编程框架，也会把复杂的NIO处理逻辑封装成简单的API，即使如此，需要使用netty来做服务端开发的工程师仍然不多。&lt;/p&gt;
&lt;p&gt;Java网络编程对于Java工程师来说是很重要的能力，这也是我在接触了一系列相关面试题，以及Tomcat和netty实现之后才逐渐意识到的，想要了解这两个东西的实现原理，就必须要会网络编程的知识，当然了，这一切的基础就是你要首先懂得计算机网络，这部分内容也可以参考我关于计算机网络的一篇文章。&lt;/p&gt;
&lt;h2 id=&quot;本文思维导图-1&quot;&gt;本文思维导图&lt;/h2&gt;
&lt;h2 id=&quot;java网络编程该怎么学&quot;&gt;Java网络编程该怎么学&lt;/h2&gt;
&lt;h3 id=&quot;计算机网络和java网络编程的关系&quot;&gt;计算机网络和Java网络编程的关系&lt;/h3&gt;
&lt;p&gt;计算机网络之于Java网络编程，好比数据结构之于算法，前者是后者的基础，没有前者的支撑，直接学习后者，是没有意义的。&lt;/p&gt;
&lt;p&gt;之前我也写了一篇关于计算机网络该怎么学的文章，可以先看看。总体来看，计算机网络告诉我们的是，两台计算机想要进行通信，它们需要约定一种传输协议和编码解码的标准，因此计算机网络通常分为5层，而其中一些标准就包括TCP和IP，HTTP等等，这些协议都是为了更好地实现网络数据传输而产生的。&lt;/p&gt;
&lt;p&gt;但是，这些协议只是协议而已，要真正在Java代码里实现网络传输，就需要让代码实现协议，当然了，像TCP/IP这样通用的协议栈。还轮不到Java应用程序自己来实现，否则也太麻烦了，Linux的内核里已经对其进行了封装，并且会向上提供API，所以Java应用程序只需要调用Linux内核提供的即可。&lt;/p&gt;
&lt;p&gt;而再往上，也就是HTTP这类应用层协议，Java代码是可以直接进行解析或者组装的，毕竟HTTP的报文比较简单，我们可以直接通过Java提供的API进行操作，大家也都知道，Java里有一些网络编程的包，提供了一些常用于网络通讯的类，比如Socket可以用来建立网络连接，IO流则可以用来处理网络传输的IO输入和输出。&lt;/p&gt;
&lt;p&gt;换言之，网络编程的实质就是先进行网络连接，然后进行IO传输，而网络IO这个东西里又大有门道，这部分内容我们在下一节里继续分享。&lt;/p&gt;
&lt;h3 id=&quot;网络编程里bionio和aio&quot;&gt;网络编程里BIO、NIO和AIO&lt;/h3&gt;
&lt;p&gt;说到这三个东西，相比学过Java的朋友都不会陌生，毕竟面试题也经常考，背也都背下来了。&lt;br/&gt;但是这几个东西为什么会有这样的区别呢，不妨一起来探究一下。&lt;br/&gt;BIO是最原始的Java IO模式，也叫阻塞式IO，多个BIO处理必须要串行执行，因为IO此时被阻塞了。&lt;br/&gt;而NIO则是相对较新的一种模式，它基于Linux的epoll来进行实现，通过一个线程对多个连接进行处理，当发现有活跃的连接时进行对应的IO处理，本质上是IO多路复用的一种实现。&lt;/p&gt;
&lt;p&gt;而AIO和上面两者不太一样，它强调的不是阻塞非阻塞，而是对IO的处理是异步化的，通常来说就是建立连接，然后提供一个处理完IO的回调接口，然后就可以扔在一边不管了，等待IO处理结束后回调相应的接口。值得一提的是，AIO需要底层操作系统的支持。&lt;/p&gt;
&lt;h3 id=&quot;通信框架netty&quot;&gt;通信框架netty&lt;/h3&gt;
&lt;p&gt;了解了BIO、NIO和AIO之后，你对于网络编程中的几个核心概念你应该已经有所了解了，接下来就不得不看看Java网络编程中最牛掰的一个框架：netty了。比起NIO和BIO，了解netty的人应该更少了，其实，netty就是基于NIO实现的异步网络编程框架，既有了NIO的高性能IO处理方式，又通过异步化编程使得netty的编程方式更加简单高效。&lt;/p&gt;
&lt;p&gt;我当时接触netty的时候，还是在学习RPC和分布式服务的时候，我发现每当有RPC出现的地方，也总有网络编程框架的身影，好比netty这样的通讯框架常常会被提到，我当时并不太理解通讯框架是干嘛用的，以至于我对RPC是什么东西都不太理解。&lt;/p&gt;
&lt;p&gt;当我现在搞懂了RPC之后，再去研究网络编程框架就有了新的感觉，其实，不管是RPC还是HTTP，都需要通信框架的支持，只不过支持HTTP的服务器已经有很多了，比如Tomcat，比如Nginx，这些服务器完全可以cover掉网络框架，后面我们也会再来聊一下Tomcat这个神奇的服务器。&lt;/p&gt;
&lt;h3 id=&quot;tomcat这个神奇的服务器&quot;&gt;Tomcat这个神奇的服务器&lt;/h3&gt;
&lt;p&gt;Tomcat这个服务器我们Java工程师一直在用，但是很多朋友对它其实知之甚少，只知道它可以运行JavaWeb应用。&lt;/p&gt;
&lt;p&gt;其实Tomcat这个服务器，也是基于NIO实现的一个服务器，不妨把Tomcat分为两个部分来看，一部分是connector，负责网络连接，接受请求和处理请求，另一部分是container，也就是容器，Tomcat本质上是一个servlet容器，这一部分负责的就是编排一系列容器里的处理器、调用链以及层级结构，比如engine的下一层是host，host的下一层是context。&lt;/p&gt;
&lt;p&gt;当一个网络请求到达Tomcat时，connector先负责处理这个请求，再扔到container跑一遍拿到结果，但在生产环境中，connector一次性要处理的请求就多的去了，因此就必须要支持高并发以及IO多路复用，因此Tomcat也采用了NIO的IO处理方式，同时通过多线程进行请求处理，总体来说已经达到了非常不错的性能了。&lt;/p&gt;
&lt;h3 id=&quot;面向面试复习&quot;&gt;面向面试复习&lt;/h3&gt;
&lt;p&gt;一个小小的Java网络编程，居然一下子牵扯出这么多复杂的知识点出来，先是计算机网络，再到Java网络编程API，再到BIO、NIO和AIO，然后又谈到了Tomcat和netty。&lt;/p&gt;
&lt;p&gt;其实，网络编程的内容可能还不止这些，比如NIO的底层实现是基于Linux的epoll来完成了，而Linux的网络IO模型有select、poll和epoll等方式，要真正搞懂NIO，你还需要搞懂epoll。&lt;/p&gt;
&lt;p&gt;其实一开始我对于Java网络编程也没有什么概念，只不过在看了很多面试题之后，才逐渐发现问题所在，比如BIO和NIO的区别，背了好几次面试答案仍然不解其意，要是再问到epoll、poll和select的区别，更是完全不得要领，究其原因还是不知道这些东西到底是什么，有什么用，以及它们和一些实际场景间的关系。&lt;/p&gt;
&lt;p&gt;因此，我觉得，网络编程方向的面试题重在理解概念，对于计算机网络、IO模型，以及网络编程框架要能够真正理解了这些东西之后，你才能够对面试题游刃有余，否则，这类面试题再怎么背都不会有什么效果，正如计算机网络这种纯理论的课程一样，在不理解的情况下，分析问题和回答问题肯定是难以达到面试官要求的。&lt;/p&gt;
&lt;p&gt;所以，请按照这样的一个顺序进行复习和实践，相信这对于你学习网络编程会有所帮助。&lt;br/&gt;1、计算机网络知识&lt;br/&gt;2、Java网络编程基础&lt;br/&gt;3、NIO、BIO、AIO&lt;br/&gt;4、Linux的网络IO模型：epoll、select和poll&lt;br/&gt;5、netty网络编程框架&lt;br/&gt;6、Tomcat服务器&lt;/p&gt;
&lt;h2 id=&quot;推荐资源&quot;&gt;推荐资源&lt;/h2&gt;
&lt;p&gt;这方面能推荐的资源就非常多了，我尽量按照先易后难的顺序为大家推荐资源&lt;/p&gt;
&lt;h3 id=&quot;书籍&quot;&gt;书籍&lt;/h3&gt;
&lt;p&gt;《Java网络编程》&lt;br/&gt;《netty权威指南》&lt;br/&gt;《How Tomcat Work》&lt;br/&gt;《Tomcat架构解析》&lt;/p&gt;
&lt;h3 id=&quot;视频&quot;&gt;视频&lt;/h3&gt;
&lt;p&gt;我整理一些Java网络编程复习的视频资源，习惯看视频的朋友可以了解一下。&lt;/p&gt;
&lt;h3 id=&quot;博客&quot;&gt;博客&lt;/h3&gt;
&lt;p&gt;Java技术仓库《Java程序员复习指南》&lt;br/&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; class=&quot;uri&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;br/&gt;整合全网优质Java学习内容，帮助你从基础到进阶系统化复习Java。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;关于如何学习Java网络编程，并且搞定相关面试题，我们今天就讲到这里了，如果还有什么疑问也可以到我公众号里找我探讨，后续会有更多的文章推出，包括如何系统性地学习JavaWeb，以及如何系统性地学习后端技术。敬请期待。&lt;/p&gt;
&lt;p&gt;对了，你想问我文章里提到的资源去哪找？我已经给你准备好了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文中提到的资源都可以免费领取，在我的公众号【程序员黄小斜】回复“Java网络编程“即可免费领取对应的资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;如果觉得本文对你有帮助的话，请你也不要吝啬你的“好看”哈，转发朋友圈就是对我最大的支持啦，你们的支持是对我最大的鼓励。&lt;/p&gt;
&lt;p&gt;对本系列文章有什么建议和意见，也欢迎留言告诉我，期待你的回馈。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;微信公众号：程序员黄小斜
知乎：黄小斜
B站：黄小斜&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Mar 2020 14:14:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>原创声明 本文作者：黄小斜 转载请务必在文章开头注明出处和作者。 本文思维导图 简介 Java作为一门后端语言，对于网络编程的支持是必不可少的，但是，作为一个经常CRUD的Java工程师，很多时候都不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/12535287.html</dc:identifier>
</item>
<item>
<title>曹工说Spring Boot源码（23）-- ASM又立功了，Spring原来是这么递归获取注解的元注解的 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12535152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12535152.html</guid>
<description>&lt;p&gt;相关背景及资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12044199.html&quot;&gt;曹工说Spring Boot源码（1）-- Bean Definition到底是什么，附spring思维导图分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12051957.html&quot;&gt;曹工说Spring Boot源码（2）-- Bean Definition到底是什么，咱们对着接口，逐个方法讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12070377.html&quot;&gt;曹工说Spring Boot源码（3）-- 手动注册Bean Definition不比游戏好玩吗，我们来试一下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12078673.html&quot;&gt;曹工说Spring Boot源码（4）-- 我是怎么自定义ApplicationContext，从json文件读取bean definition的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12093929.html&quot;&gt;曹工说Spring Boot源码（5）-- 怎么从properties文件读取bean&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12114604.html&quot;&gt;曹工说Spring Boot源码（6）-- Spring怎么从xml文件里解析bean的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12151809.html&quot;&gt;曹工说Spring Boot源码（7）-- Spring解析xml文件，到底从中得到了什么（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12158935.html&quot;&gt;曹工说Spring Boot源码（8）-- Spring解析xml文件，到底从中得到了什么（util命名空间）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12189842.html&quot;&gt;曹工说Spring Boot源码（9）-- Spring解析xml文件，到底从中得到了什么（context命名空间上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12199334.html&quot;&gt;曹工说Spring Boot源码（10）-- Spring解析xml文件，到底从中得到了什么（context:annotation-config 解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12203743.html&quot;&gt;曹工说Spring Boot源码（11）-- context:component-scan，你真的会用吗（这次来说说它的奇技淫巧）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12214408.html&quot;&gt;曹工说Spring Boot源码（12）-- Spring解析xml文件，到底从中得到了什么（context:component-scan完整解析)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12228958.html&quot;&gt;曹工说Spring Boot源码（13）-- AspectJ的运行时织入（Load-Time-Weaving），基本内容是讲清楚了（附源码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12283544.html&quot;&gt;曹工说Spring Boot源码（14）-- AspectJ的Load-Time-Weaving的两种实现方式细细讲解，以及怎么和Spring Instrumentation集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12288391.html&quot;&gt;曹工说Spring Boot源码（15）-- Spring从xml文件里到底得到了什么（context：load-time-weaver 完整解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12314954.html&quot;&gt;曹工说Spring Boot源码（16）-- Spring从xml文件里到底得到了什么（aop：config完整解析【上】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12317612.html&quot;&gt;曹工说Spring Boot源码（17）-- Spring从xml文件里到底得到了什么（aop：config完整解析【中】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12322587.html&quot;&gt;曹工说Spring Boot源码（18）-- Spring AOP源码分析三部曲，终于快讲完了 (aop：config完整解析【下】)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12359963.html&quot;&gt;曹工说Spring Boot源码（19）-- Spring 带给我们的工具利器，创建代理不用愁（ProxyFactory）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12375656.html&quot;&gt;曹工说Spring Boot源码（20）-- 码网恢恢，疏而不漏，如何记录Spring RedisTemplate每次操作日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12384356.html&quot;&gt;曹工说Spring Boot源码（21）-- 为了让大家理解Spring Aop利器ProxyFactory，我已经拼了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12418425.html&quot;&gt;曹工说Spring Boot源码（22）-- 你说我Spring Aop依赖AspectJ，我依赖它什么了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/spring-boot-first-version-learn&quot;&gt;工程代码地址&lt;/a&gt; &lt;a href=&quot;https://www.processon.com/view/link/5deeefdee4b0e2c298aa5596&quot;&gt;思维导图地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工程结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191215144930717-1919774390.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;spring boot源码系列，离上一篇，快有2周时间了，这两周，本来是打算继续写这个系列的；结果中间脑热，就去实践了一把动态代理，实现了一个mini-dubbo这样一个rpc框架，扩展性还是相当好的，今天看了下spring mvc的设计，思路差不多，都是框架提供默认的组件（比如handlermapping），然后程序里自定义了的话，就覆盖默认组件。&lt;/p&gt;
&lt;p&gt;然后，因为mini-dubbo实现过程中的一些其他问题，以及工作上的需要，写了netty实现的http 连接池，这个系列还没讲完，留着后边再补，不然我们的源码系列就耽搁太久了，今天我们还是接着回来弄源码系列。&lt;/p&gt;
&lt;p&gt;今天这讲，主题是：给你一个class，怎么读取其上的注解，需要考虑注解的元注解（可以理解注解上的注解）&lt;/p&gt;

&lt;h2 id=&quot;常规做法&quot;&gt;常规做法&lt;/h2&gt;
&lt;p&gt;我们的Class类，就有很多获取annotation的方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320163124744-226295968.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这个有一个问题是，无法递归获取。&lt;/p&gt;
&lt;p&gt;比如，大家使用spring的，都知道，controller这个注解上，是注解了component的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320163448356-2079088874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你在一个标注了@controller注解的类的class上，去获取注解，是拿不到Component这一层的。&lt;/p&gt;
&lt;p&gt;为啥要拿Component这一层呢？你可以想一下，最开始写spring的作者，是只定义了Component这个注解的，业务逻辑也只能处理Component这个注解；后来呢，又多定义了@controller，@service这几个，但是，难道要把所有业务逻辑的地方都去改一改？很明显，你不会，大佬更不会，直接解析@controller注解，看看它的元注解有没有@component就行了，有的话，直接复用之前的逻辑。&lt;/p&gt;
&lt;p&gt;那么，如何进行递归解析呢？&lt;/p&gt;
&lt;h2 id=&quot;递归解析类上注解--方法1&quot;&gt;递归解析类上注解--方法1&lt;/h2&gt;
&lt;p&gt;我们要获取的class，长这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package org.springframework.test;

@CustomController
public class TestController {
}


@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Controller
public @interface CustomController {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法，是从spring 源码里摘抄的，在内部实现中，基本就这个样子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;我这个版本是4.0，在：org.springframework.bootstrap.sample.Test#recusivelyCollectMetaAnnotations

public static void getAnnotationByClass(String className) throws ClassNotFoundException {
    Class&amp;lt;?&amp;gt; clazz = Class.forName(className);
    Set&amp;lt;String&amp;gt; metaAnnotationTypeNames = new LinkedHashSet&amp;lt;String&amp;gt;();
    for (Annotation metaAnnotation : clazz.getAnnotations()) {
        recusivelyCollectMetaAnnotations(metaAnnotationTypeNames, metaAnnotation);
    }
}


private static void recusivelyCollectMetaAnnotations(Set&amp;lt;String&amp;gt; visited, Annotation annotation) {
    if (visited.add(annotation.annotationType().getName())) {
        for (Annotation metaMetaAnnotation : annotation.annotationType().getAnnotations()) {
            //递归
            recusivelyCollectMetaAnnotations(visited, metaMetaAnnotation);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我试了下，这个方法在新版本里，方法名变了，核心还是差不多，spring 5.1.9可以看这个类：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.core.type.classreading.AnnotationAttributesReadingVisitor#recursivelyCollectMetaAnnotations&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;java.lang.annotation.Documented&lt;br/&gt;java.lang.annotation.Retention&lt;br/&gt;java.lang.annotation.Target&lt;br/&gt;org.springframework.stereotype.Controller&lt;br/&gt;org.springframework.stereotype.Component&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;递归解析类上注解--方法2&quot;&gt;递归解析类上注解--方法2&lt;/h2&gt;
&lt;p&gt;这个是我自己实现的，要复杂一些，当然，是有理由的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.core.type.AnnotationMetadata;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.SimpleMetadataReaderFactory;

public static void main(String[] args) throws IOException, ClassNotFoundException {
        SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory();
        LinkedHashSet&amp;lt;String&amp;gt; result = new LinkedHashSet&amp;lt;&amp;gt;();

        getAnnotationSet(result, &quot;org.springframework.test.TestController&quot;, simpleMetadataReaderFactory);
    }

    public static void getAnnotationSet(LinkedHashSet&amp;lt;String&amp;gt; result, String className, SimpleMetadataReaderFactory simpleMetadataReaderFactory) throws IOException {
        boolean contains = result.add(className);
        if (!contains) {
            return;
        }

        MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(className);
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
        Set&amp;lt;String&amp;gt; annotationTypes = annotationMetadata.getAnnotationTypes();

        if (!CollectionUtils.isEmpty(annotationTypes)) {
            for (String annotationType : annotationTypes) {
                // 递归
                getAnnotationSet(result, annotationType, simpleMetadataReaderFactory);
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;估计有的同学要骂人了，取个注解，搞一堆莫名其妙的工具类干嘛？因为，spring就是这么玩的啊，方法1，是spring的实现，不假。但是，那个已经是最内层了，人家外边还封装了一堆，封装出来，基本就是方法2看到的那几个类。&lt;/p&gt;
&lt;h2 id=&quot;spring抽象出的注解获取的核心接口&quot;&gt;spring抽象出的注解获取的核心接口&lt;/h2&gt;
&lt;p&gt;大家看看，就是下面这个，类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320165610310-64308328.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其大致的功能，看下图就知道了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320170055124-1512350821.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个接口，一共2个实现，简单来说，一个是通过传统的反射方式来获取这些信息，一个是通过asm的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320170448159-272719534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两者的优劣呢，大家可以看看小马哥的书，里面提到的是，asm方式的性能，远高于反射实现，因为无需加载class，直接解析class文件的字节码。&lt;/p&gt;
&lt;p&gt;我们这里也是主要讲asm方式的实现，大家看到了上面这个asm实现的类，叫：AnnotationMetadataReadingVisitor，它的类结构，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320170936749-1906693547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以大致知道，其继承了ClassMetadataReadingVisitor，这个类，负责去实现ClassMetaData接口；它自己呢，就自己负责实现AnnotationMetadata接口。&lt;/p&gt;
&lt;p&gt;我们呢，不是很关心类的相关信息，只聚焦注解的获取。&lt;/p&gt;

&lt;p&gt;AnnotationMetadata接口，我们最关注的就是下面这2个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // 获取直接注解在当前class上的注解
   Set&amp;lt;String&amp;gt; getAnnotationTypes();

   // 获取某个直接注解的元注解，比如你这里传个controller进去，就能给你拿到controller这个注解的元注解
   Set&amp;lt;String&amp;gt; getMetaAnnotationTypes(String annotationType);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以看到，它呢，给了2个方法，而不是一个方法来获取所有，可能有其他考虑吧，我们接着看。&lt;/p&gt;
&lt;h3 id=&quot;getannotationtypes的实现&quot;&gt;getAnnotationTypes的实现&lt;/h3&gt;
&lt;p&gt;这个方法，获取直接注解在target class上的注解。&lt;/p&gt;
&lt;p&gt;那看看这个方法在AnnotationMetadataReadingVisitor的实现吧：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Set&amp;lt;String&amp;gt; getAnnotationTypes() {
    return this.annotationSet;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尴尬，看看啥时候给它赋值的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {
    String className = Type.getType(desc).getClassName();
    this.annotationSet.add(className);
    return new AnnotationAttributesReadingVisitor(className, this.attributeMap,
                                                  this.metaAnnotationMap, this.classLoader, this.logger);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法名字，见名猜意思，：visit注解，可能还使用了visitor设计模式，但是这个方法又是什么时候被调用的呢&lt;/p&gt;
&lt;h3 id=&quot;asm简介&quot;&gt;asm简介&lt;/h3&gt;
&lt;p&gt;简单介绍下asm框架，官网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://asm.ow2.io/&quot; class=&quot;uri&quot;&gt;https://asm.ow2.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://asm.ow2.io/asm4-guide.pdf&quot; class=&quot;uri&quot;&gt;https://asm.ow2.io/asm4-guide.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网说明如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12.815249266862&quot;&gt;
&lt;p&gt;&lt;strong&gt;ASM&lt;/strong&gt; is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form. ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. ASM offers similar functionality as other Java bytecode frameworks, but is focused on &lt;a href=&quot;https://asm.ow2.io/performance.html&quot;&gt;performance&lt;/a&gt;. Because it was designed and implemented to be as small and as fast as possible, it is well suited for use in dynamic systems (but can of course be used in a static way too, e.g. in compilers).&lt;/p&gt;
&lt;p&gt;ASM is used in many projects, including:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，就是：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;asm是一个字节码操作和分析的框架，能够用来修改已存在的class，或者动态生成class，直接以二进制的形式。ASM提供一些通用的字节码转换和分析算法，通过这些算法，可以构建复杂的字节码转换和代码分析工具。ASM提供和其他字节码框架类似的功能，但是其专注于性能。因为它被设计和实现为，尽可能的小，尽可能的快。&lt;/p&gt;
&lt;p&gt;ASM被用在很多项目，包括：&lt;/p&gt;
&lt;p&gt;OpenJDK，生成lambda调用；&lt;/p&gt;
&lt;p&gt;Groovy和Kotlin的编译器&lt;/p&gt;
&lt;p&gt;Cobertura和Jacoco，通过探针，检测代码覆盖率&lt;/p&gt;
&lt;p&gt;CGLIB，动态生成代理类，也用在Mockito和EasyMock中&lt;/p&gt;
&lt;p&gt;Gradle，运行时动态生成类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里补充一句，ASM为啥说它专注于性能，因为，要动态生成类、动态进行字节码转换，如果性能太差的话，还有人用吗？ 为啥要足够小，足够小因为它也希望自己用在一些内存受限的环境中。&lt;/p&gt;
&lt;p&gt;查看了asm的官方文档，发现一个有趣的知识，asm这个名字，来源于c语言里面的&lt;code&gt;__asm__&lt;/code&gt;关键字，这个关键字可以在c语言里用汇编来实现某些功能。&lt;/p&gt;
&lt;p&gt;另外，其官方文档里提到，解析class文件的过程，有两种模型，一种是基于事件的，一种是基于对象的，可以类比xml解析中的sax和dom模型，sax就是基于事件的，同样也是和asm一样，使用visitor模式。&lt;/p&gt;
&lt;p&gt;visitor模式呢，我的简单理解，就是主程序定义好了一切流程，比如我会按照顺序来访问一个class，先是class name，就去调用visitor的对应方法，此时，visitor可以做些处理；我访问到field时，也会调用visitor的对应方法...以此类推。&lt;/p&gt;
&lt;h3 id=&quot;asm怎么读取class&quot;&gt;asm怎么读取class&lt;/h3&gt;
&lt;p&gt;针对每个class，asm是把它当作一个Resource，其大概的解析步骤如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.asm.ClassReader;
import org.springframework.core.NestedIOException;
import org.springframework.core.io.Resource;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.core.type.ClassMetadata;

SimpleMetadataReader(Resource resource, ClassLoader classLoader, MetadataReaderLog logger) throws IOException {
        // 1.
        InputStream is = new BufferedInputStream(resource.getInputStream());
        ClassReader classReader = new ClassReader(is);
        // 2.
        AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader, logger);
        // 3.
        classReader.accept(visitor, ClassReader.SKIP_DEBUG);

        this.annotationMetadata = visitor;
        // (since AnnotationMetadataReader extends ClassMetadataReadingVisitor)
        this.classMetadata = visitor;
        this.resource = resource;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各讲解点：&lt;/p&gt;
&lt;ol readability=&quot;33.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;读取class resource为输入流，作为构造器参数，new一个asm的ClassReader出来；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;66&quot;&gt;
&lt;p&gt;新建一个AnnotationMetadataReadingVisitor类的实例，这个继承了ClassVisitor抽象类，这个visitor里面定义了一堆的回调方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class ClassVisitor {
 public ClassVisitor(int api);

 public ClassVisitor(int api, ClassVisitor cv);

 public void visit(int version, int access, String name,
 String signature, String superName, String[] interfaces);

 public void visitSource(String source, String debug);

 public void visitOuterClass(String owner, String name, String desc);
    // 解析到class文件中的注解时回调本方法
 AnnotationVisitor visitAnnotation(String desc, boolean visible);

 public void visitAttribute(Attribute attr);

 public void visitInnerClass(String name, String outerName,String innerName,int access);
    // 解析到field时回调
 public FieldVisitor visitField(int access, String name, String desc,String signature, Object value);

    // 解析到method时回调
 public MethodVisitor visitMethod(int access, String name, String desc,
 String signature, String[] exceptions);

 void visitEnd();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这其中，方法的访问顺序如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;visit visitSource? visitOuterClass? ( visitAnnotation | visitAttribute )*
( visitInnerClass | visitField | visitMethod )*
visitEnd

代表：
visit必须最先访问；
接着是最多一次的visitSource，再接着是最多一次的visitOuterClass；
接着是任意多次的visitAnnotation | visitAttribute ，这两个，顺序随意；
再接着是，任意多次的visitInnerClass | visitField | visitMethod ，顺序随意
最后，visitEnd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个顺序的? * () 等符号，其实类似于正则表达式的语法，对吧，还是比较好理解的。&lt;/p&gt;
&lt;p&gt;然后呢，我对visitor的理解，现在感觉类似于spring里面的event listener机制，比如，spring的生命周期中，发布的事件，有如下几个，其实也是有顺序的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320213833325-507465411.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还有官网提供的一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClassPrinter extends ClassVisitor {
    public ClassPrinter() {
        super(ASM4);
    }
    public void visit(int version, int access, String name,
     String signature, String superName, String[] interfaces) {
     System.out.println(name + &quot; extends &quot; + superName + &quot; {&quot;);
    }
    public void visitSource(String source, String debug) {
    }
    public void visitOuterClass(String owner, String name, String desc) {
    }
    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
     return null;
    }
    public void visitAttribute(Attribute attr) {
    }
    public void visitInnerClass(String name, String outerName,String innerName, int access)  {
    }
    public FieldVisitor visitField(int access, String name, String desc,String signature, Object value) {
     System.out.println(&quot; &quot; + desc + &quot; &quot; + name);
     return null;
    }
    public MethodVisitor visitMethod(int access, String name,String desc, String signature, String[] exceptions) {
     System.out.println(&quot; &quot; + name + desc);
     return null;
    }
    public void visitEnd() {
     System.out.println(&quot;}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将第二步的visitor策略，传递给classReader，classReader开始进行解析&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;getannotationtypes的回调处理&quot;&gt;getAnnotationTypes的回调处理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320180210678-1630463533.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320175913871-245817836.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接着回到getAnnotationTypes的实现，大家看了上面2个图，应该大致知道visitAnnotation的实现了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {
        String className = Type.getType(desc).getClassName();
        this.annotationSet.add(className);
        return new AnnotationAttributesReadingVisitor(className, this.attributeMap,
                this.metaAnnotationMap, this.classLoader, this.logger);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里每访问到一个注解，就会加入到field: &lt;code&gt;annotationSet&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&quot;注解上的元注解如何读取&quot;&gt;注解上的元注解，如何读取&lt;/h3&gt;
&lt;p&gt;大家再看看上面的代码，我们返回了一个AnnotationAttributesReadingVisitor，这个visitor会在：asm访问注解的具体属性时，其中的如下方法被回调。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void doVisitEnd(Class&amp;lt;?&amp;gt; annotationClass) {
        super.doVisitEnd(annotationClass);
        List&amp;lt;AnnotationAttributes&amp;gt; attributes = this.attributesMap.get(this.annotationType);
        if(attributes == null) {
            this.attributesMap.add(this.annotationType, this.attributes);
        } else {
            attributes.add(0, this.attributes);
        }
        Set&amp;lt;String&amp;gt; metaAnnotationTypeNames = new LinkedHashSet&amp;lt;String&amp;gt;();
        // 1 
        for (Annotation metaAnnotation : annotationClass.getAnnotations()) {
            // 2
            recusivelyCollectMetaAnnotations(metaAnnotationTypeNames, metaAnnotation);
        }
        if (this.metaAnnotationMap != null) {
            this.metaAnnotationMap.put(annotationClass.getName(), metaAnnotationTypeNames);
        }
    }
    // 3 
    private void recusivelyCollectMetaAnnotations(Set&amp;lt;String&amp;gt; visited, Annotation annotation) {
        if(visited.add(annotation.annotationType().getName())) {
            this.attributesMap.add(annotation.annotationType().getName(),
                    AnnotationUtils.getAnnotationAttributes(annotation, true, true));
            // 获取本注解上的元注解
            for (Annotation metaMetaAnnotation : annotation.annotationType().getAnnotations())             {    // 4 递归调用自己
                recusivelyCollectMetaAnnotations(visited, metaMetaAnnotation);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;获取注解的元注解，比如，获取controller注解上的注解;这里就能取到Target、Retention、Documented、Component&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;循环处理这些元注解，因为这些元注解上，可能还有元注解，比如，在处理Target时，发现其上还有Documented、Retention、Target几个注解，看到了吧，target注解还注解了target，在这块的递归处理时，很容易栈溢出。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;递归处理上面的这些注解&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体的处理，基本就是这样。文章开头的递归，就是摘抄的这里的代码。&lt;/p&gt;
&lt;p&gt;经过最终的处理后，可以看看最后的效果，这里截取的就是AnnotationMetadataReadingVisitor这个对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200320214500391-1729886720.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个就是spring 注解驱动的基石，实际上，spring不是一开始就这么完备的，在之前的版本，并不支持递归获取，spring也是慢慢一步一步发展壮大的。&lt;/p&gt;
&lt;p&gt;感谢spring赏饭吃！&lt;/p&gt;
&lt;p&gt;下一讲，会讲解component-scan扫描bean时，怎么扫描类上的注解的。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 13:53:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>写在前面的话 相关背景及资源： &amp;quot;曹工说Spring Boot源码（1） Bean Definition到底是什么，附spring思维导图分享&amp;quot; &amp;quot;曹工说Spring B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12535152.html</dc:identifier>
</item>
<item>
<title>互联网协议入门 - DeppWXQ</title>
<link>http://www.cnblogs.com/deppwang/p/12535144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deppwang/p/12535144.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://depp.wang&quot;&gt;DeppWang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;互联网上的数据能从一台设备发送到另一台设备，整个过程由&lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F&quot;&gt;互联网协议&lt;/a&gt;（ Internet Protocol Suite）实现的。&lt;/p&gt;
&lt;p&gt;对于互联网协议，一直一知半解。知道会分为几层，但为什么分层，分层有什么好处，都不甚理解。通过&lt;a href=&quot;https://www.cnblogs.com/deppwang/p/www.ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;的这两篇文章，大概有了一个初步认识，下面是我对互联网协议的理解。&lt;/p&gt;
&lt;h2 id=&quot;一五层模型&quot;&gt;一、五层模型&lt;/h2&gt;
&lt;p&gt;我也认为将互联网协议分为五层，可以更好的去理解它，从上往下分别是：应用层、传输层、网络层、（数据）链路层（链接层）和物理层（实体层）。如果死记硬背，往往过几天就忘了，所以需要了解其原理，当我们理解了全文，让我们去说文章的名字，那还不是轻而易举吗！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214828685-911694039.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大多数文章或书籍都是从上往下来讲解互联网协议，但是个人感觉总是没有深入其理，阮一峰&lt;strong&gt;自下而上&lt;/strong&gt;的讲解每一层的功能，让人记忆深刻。我也依葫芦画瓢，先自下而上分析一下每一层的功能，再结合 &lt;a href=&quot;https://www.wireshark.org/&quot;&gt;Wireshark&lt;/a&gt; 抓包工具，来稍稍看看互联网协议的真面目。&lt;/p&gt;
&lt;h3 id=&quot;层与协议&quot;&gt;1.1 层与协议&lt;/h3&gt;
&lt;p&gt;为什么叫某某层？为什么要分层？层是什么？&lt;/p&gt;
&lt;p&gt;我觉得层这个叫法很形象，一层一层，好像平行，各自独立。维基百科的解释是：「&lt;strong&gt;整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=Layer&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;layer&lt;/a&gt;）&lt;/strong&gt;」，我们可以理解为，每一层是实现了一个功能，有不同的分工。就跟写代码一样，如果把所有功能放一起，改一行代码就可能影响全部，所以根据不同功能拆成不同的方法。我觉得叫什么不重要，可以叫应用块、应用组，等等。&lt;strong&gt;主要知道，每一层是为了完成一个功能就行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，每一层都有自己对应的协议（Protocol），比如，网络层有 IP 协议。那何为协议？跟这个层又有什么关联？维基百科上有这么一句话：「网络层功能由 IP 协议规定和实现，故又称 IP 层」。我们可以看出，每一层的功能其实是协议来规定和实现的。所以，协议可以理解为，&lt;strong&gt;有大家都遵守的规则（规定），并负责去实现这个规则。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二物理层physcial-layer&quot;&gt;二、物理层（Physcial Layer）&lt;/h2&gt;
&lt;p&gt;我们电脑现在不用插网线就能上网（连 WIFI），但是路由器插网线了，在家里，路由器一般又需要通过一根网线连接入户光纤盒（又称为光猫），光纤盒又需要通过一根光纤连接到其他设备。电脑连接 WiFi，电脑的数据发送到路由器，是通过无线电波。所以传输数据需要物理载体，类似网线、光纤、无线电波。&lt;strong&gt;我们将传输数据的物理载体称为物理层（Physcial Layer）&lt;/strong&gt;。为什么我们访问美国的网站就慢一些，因为美国网站的服务器在美国，数据通过海底光缆传输，耗时会久一些。这也是为什么很多公司要在不同城市部署服务器的原因之一吧。&lt;/p&gt;
&lt;p&gt;数据在物理载体中传输，传输的是什么呢？&lt;strong&gt;是 0 和 1 组成的电信号&lt;/strong&gt;，为什么是 0 和 1 组成的电信号呢？这个吧，姑且通过类比的方式来解释，因为计算机只能识别 0 1 二进制，所以要传输 0 和 1 组成的电信号吧。&lt;/p&gt;
&lt;h2 id=&quot;三链路层link-layer&quot;&gt;三、链路层（Link Layer）&lt;/h2&gt;
&lt;p&gt;物理层只是一个传输载体，没有「自主意识」， 我们需要借助物理层上的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&quot;&gt;链路层&lt;/a&gt;（Link Layer），&lt;strong&gt;链路层的功能：将数据从一处发送到另一处&lt;/strong&gt;，链路层在发送方和接收方都有，在发送方：链路层将数据转换为电信号，并将其发送出去；在接收方：链路层收到电信号，并将电信号转换为数据。链路层和物理层之间的关系可以这样表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214829090-1430205152.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91&quot;&gt;局域网&lt;/a&gt;内，将数据从一处发送到另一处需要使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91&quot;&gt;以太网&lt;/a&gt;（Ethernet）。&lt;strong&gt;局域网的通俗理解，连接同一个 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Wi-Fi&quot;&gt;WiFi&lt;/a&gt; （路由器 Router）的设备在同一个局域网内。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;以太网&quot;&gt;3.1 以太网&lt;/h3&gt;
&lt;p&gt;以太网是一种局域网技术，它可以实现局域网内的设备通信，我们现在电脑一般连 WiFi，WiFi 可以认为是「无线以太网」。&lt;/p&gt;
&lt;p&gt;我们可以理解为，&lt;strong&gt;在局域网内，链路层的功能其实是由以太网实现的&lt;/strong&gt;（局域网外的链路层比较复杂，本文不讨论）。 局域网内的链路层和以太网的关系可以这样表示（物理层作为以太网的传输载体）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214829375-1480032275.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网需要规定电信号的格式，以便双方解读&lt;/strong&gt;。以太网规定一组电信号为一个数据包，叫帧（Frame），帧包含两部分，标头（Head）和数据（Data），标头包含发送方地址、接收方地址等信息，数据则是数据包的具体内容。我们一般将帧称为以太网数据包，或者&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F&quot;&gt;以太帧&lt;/a&gt;，以太帧格式类似下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214829629-1979511199.png&quot; alt=&quot;以太帧，图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每台网络设备都有自己的网卡，&lt;strong&gt;以太网是将数据从一块&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E5%8D%A1&quot;&gt;网卡&lt;/a&gt;发送到另一块网卡&lt;/strong&gt;，每块网卡需要有自己的「身份证号」，叫 &lt;a href=&quot;https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80&quot;&gt;MAC 地址&lt;/a&gt;（iPhone 手机的 MAC 地址叫无线局域网地址），由 12 个十六进制数表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2020-03-20-121841.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;MAC地址：（&lt;strong&gt;M&lt;/strong&gt;edia &lt;strong&gt;A&lt;/strong&gt;ccess &lt;strong&gt;C&lt;/strong&gt;ontrol Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），&lt;strong&gt;以太网地址&lt;/strong&gt;（Ethernet Address）或&lt;strong&gt;物理地址&lt;/strong&gt;（Physical Address），它是一个用来确认网络设备位置的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以以太网发送前需要知道接收方网卡的 MAC 地址，即标头的接收方地址，但正常情况下，不知道接收方 MAC 地址，需要使用 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE&quot;&gt;ARP 协议&lt;/a&gt;得到（这个本文后面解释）&lt;/p&gt;
&lt;p&gt;假设已经知道了 MAC 地址，那么在局域网内，以太网可以根据 MAC 地址，将数据发送给对方。但如果对方没有在一个局域网内，如何发送给对方呢？此时，就需要&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82&quot;&gt;网络层&lt;/a&gt;（Network Layer）出马了！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以太网在 Windows 中的体现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214829934-8129566.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 macOS 的体现： &lt;a href=&quot;https://zh.wikipedia.org/wiki/PPPoE&quot;&gt;PPPoE&lt;/a&gt;（英语：&lt;strong&gt;P&lt;/strong&gt;oint-to-&lt;strong&gt;P&lt;/strong&gt;oint &lt;strong&gt;P&lt;/strong&gt;rotocol &lt;strong&gt;o&lt;/strong&gt;ver &lt;strong&gt;E&lt;/strong&gt;thernet），以太网上的点对点协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214830682-1383140791.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四网络层network-layer&quot;&gt;四、网络层（Network Layer）&lt;/h2&gt;
&lt;p&gt;首先，我们要区分接收方是否在一个局域网，使用 MAC 地址不能区分，需要设备有另外一个地址，能代表它所处的具体是哪个网络（局域网），我们称这个地址为「&lt;strong&gt;网络地址&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层的作用，就是根据网络地址找到目的主机处于哪一个局域网&lt;/strong&gt;。实现这一功能的协议称为网络协议，即 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&quot;&gt;IP 协议&lt;/a&gt; 。网络地址用于 IP 协议，所以网络地址也可以叫它 IP 地址。&lt;strong&gt;注意&lt;/strong&gt;：我们叫 IP 协议，是一种习惯，其实 IP(&lt;strong&gt;I&lt;/strong&gt;nternet &lt;strong&gt;P&lt;/strong&gt;rotocol) 本身就有协议的意思。&lt;/p&gt;
&lt;p&gt;如果设备连 WiFi，路由器会为设备分配一个 IP 地址。&lt;/p&gt;
&lt;h3 id=&quot;ip-协议&quot;&gt;4.1 IP 协议&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;IP&lt;/strong&gt; 协议：英语全称为：&lt;strong&gt;I&lt;/strong&gt;nternet &lt;strong&gt;P&lt;/strong&gt;rotocol，即&lt;strong&gt;网络协议&lt;/strong&gt;，也称&lt;strong&gt;网际协议&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在大部分使用的还是 IP 协议第四版，简称 IPv4，IP 地址为 32 位（4*8，二进制）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214830990-1191090675.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了 IP 地址，网络层可以通过 IP 地址来区分是否处于一个局域网。如何根据 IP 地址判断设备是否处于同一个局域网？答案是利用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%90%E7%BD%91#%E7%BD%91%E7%BB%9C%E6%8E%A9%E7%A0%81&quot;&gt;子网掩码&lt;/a&gt;。IP 地址分为两部分，网络部分和主机部分，如果子网掩码为 &lt;code&gt;255.255.255.0&lt;/code&gt;（二进制表示：&lt;code&gt;11111111.11111111.11111111.00000000&lt;/code&gt;），表示前 24 位代表网络部分，如果两个 IP 地址前 24 位相同，则代表是在同一个局域网中。&lt;/p&gt;
&lt;h3 id=&quot;ip-数据包&quot;&gt;4.2 IP 数据包&lt;/h3&gt;
&lt;p&gt;数据经过网络层，IP 协议为数据加上包含发送方 IP 地址和接收方 IP 地址的标头，包装为 IP 数据包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214831186-1023728486.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IP 数据包到达链路层时，直接作为作为以太帧的数据部分，嵌入以太帧。此时的以太帧的格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214831331-14202241.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果通过子网掩码判断接收方在一个局域网，就通过以太网发送，此时需要得到其 MAC 地址，前面说，需要 ARP 协议得到其 MAC 地址，何为 ARP 协议？&lt;/p&gt;
&lt;h3 id=&quot;arp-协议&quot;&gt;4.3 ARP 协议&lt;/h3&gt;
&lt;p&gt;ARP 协议，英语全称为：&lt;strong&gt;A&lt;/strong&gt;ddress &lt;strong&gt;R&lt;/strong&gt;esolution &lt;strong&gt;P&lt;/strong&gt;rotocol，即地址解析协议，是一种通过 IP 地址得到 MAC 地址的协议。默认情况，发送方知道接收方的 IP 地址（通过 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F&quot;&gt;DNS&lt;/a&gt; 得到，这个又后面解释），所以发送方使用「广播」（broadcasting）的方式给当前局域网所有主机发送一个以太帧，包含对方的 IP 地址，对方 MAC 地址设为 &lt;code&gt;ff:ff:ff:ff:ff:ff&lt;/code&gt;，接收方根据接收者 IP 地址判断自己是否为接收者，是，就发送一个数据包告诉对方自己的 MAC 地址，不是，就丢弃这个包。&lt;/p&gt;
&lt;p&gt;通过这种方式，发送方就可以通过接收方的 IP 地址得到 MAC 地址。&lt;/p&gt;
&lt;p&gt;如果通过子网掩码判断接收方不在一个局域网，通过 APR 协议就得不到对方的 MAC 地址，那就要使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1&quot;&gt;路由&lt;/a&gt;（Route）的方式发送了。&lt;/p&gt;
&lt;h3 id=&quot;路由&quot;&gt;4.4 路由&lt;/h3&gt;
&lt;p&gt;路由，简单来说，就是得到路由器的 MAC 地址，数据先发送到&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8&quot;&gt;路由器&lt;/a&gt;（Router），由路由器来发送下一个路由器，通过一系列路由中转，最后发给目标主机。&lt;/p&gt;
&lt;p&gt;其实就像发送快递一样，在快递上写上收件人的地址，由快递点发送给下一个中转站，再中转，最后收件人收到快递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214831869-1091316330.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个简单的路由器，需要实现 IP 协议和链路层协议。&lt;/p&gt;
&lt;p&gt;如果把上面的过程说的仔细一点，以太网是将以太帧发送给路由器链路层，路由器链路层将数据包发送给路由器网络层，路由器有一个路由表，网络层在路由表找到跟当前路由器相连的、离目的主机最近的路由器，路由器通过 ARP 协议，得到下一个路由器的 MAC 地址，让路由器链路层根据 MAC 地址，发送给下一个路由器。通过一系列中转，来到目的主机所在的路由器。使用同样的方式，通过以太网将以太帧发送给目的主机。整个过程大概是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214832421-1655798048.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们常说，网络层负责寻址和路由，寻址就是寻找最近的 IP 地址，路由就是找到最近的路由 MAC 地址（我这么理解，不一定正确）。我们可以理解为：整个通信过程中的网络层负责寻址和路由，发送方的网络层其实负责它自己的寻址和路由。&lt;/p&gt;
&lt;h2 id=&quot;五传输层transport-layer&quot;&gt;五、传输层（Transport Layer）&lt;/h2&gt;
&lt;p&gt;网络层和链路层实现了互联网任意两台主机之间的网络通信，此时还有两个问题，&lt;strong&gt;1、设备不止一个程序，具体发送给哪一个程序？2、没有保证数据包能发送成功。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时候就需要&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82&quot;&gt;传输层&lt;/a&gt;（Transport Layer），&lt;strong&gt;传输层的功能是保证数据能可靠传输到对方主机的应用程序上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用是进程，&lt;strong&gt;每个进程使用网卡时，需要有一个编号，这个编号就是端口&lt;/strong&gt;。系统默认占用 0 到 1023 的端口，系统会为软件随机分配 1024 到 65535 之间的端口。 常见术语套接字（Socket）就是 IP 地址 + 端口的组合称谓。&lt;/p&gt;
&lt;p&gt;传输层要为发送的数据包中增加发送方和接收方的端口号。&lt;/p&gt;
&lt;p&gt;传输层功能实现一般有两种协议，1 是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE&quot;&gt;TCP 协议&lt;/a&gt;，2 是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE&quot;&gt;UDP 协议&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;tcp-协议&quot;&gt;5.1 TCP 协议&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt; 协议，英语全称为：&lt;strong&gt;T&lt;/strong&gt;ransmission &lt;strong&gt;C&lt;/strong&gt;ontrol &lt;strong&gt;P&lt;/strong&gt;rotocol，即，&lt;strong&gt;传输控制协议&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP 协议使用用三次握手来保证线路的可靠，失败后，有失败重传机制，它是一个很复杂的协议，传输层的称谓，也是来源于 TCP 这个 &lt;strong&gt;传输控制协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP 协议发送的数据包叫 TCP 数据包，它的标头包含发送方端口和接收方端口，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214832604-1262352156.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它发送数据包给网络层，网络层将 TCP 数据包作为 IP 数据包的数据部分，再发给链路层。此时以太帧格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214832760-724275638.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为以太帧有长度限制，TCP 协议没有规定数据的长度，所以当 TCP 数据包过长时，以太帧装不下，此时 TCP 数据包需要切分为多个 TCP 数据包。我们常常看到有的书籍说：传输层负责「请求报文」的分割。这就是传输层为什么要分割「请求报文」的缘故。&lt;/p&gt;
&lt;p&gt;传输层保证数据的「可靠传输」，这句话常常被我们误解为，是由传输层传输数据，现在我们知道，传输数据的其实是链路层，传输层其实只是失败重传（当然不止这一个功能，这里这么说是为了方便理解）。所以这句话的重点在于&lt;strong&gt;可靠&lt;/strong&gt;，不在传输。&lt;/p&gt;
&lt;h3 id=&quot;udp-协议&quot;&gt;5.2 UDP 协议&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;UDP 协议&lt;/strong&gt;，英语全称为： &lt;strong&gt;U&lt;/strong&gt;ser &lt;strong&gt;D&lt;/strong&gt;atagram &lt;strong&gt;P&lt;/strong&gt;rotocol，即&lt;strong&gt;用户数据包协议&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传输层有一种简单的协议，叫 UDP 协议，UDP 协议只是为数据简单的加上包含发送方端口和接收方端口的标头，就将 UDP 数据包扔给网络层，它不保证是否能成功的发送给接收方，它是一种不可靠的传输协议。因为简单，减少了时间开销，常用于对时间有较高要求的应用程序。&lt;/p&gt;
&lt;h2 id=&quot;六应用层application-layer&quot;&gt;六、应用层（Application Layer）&lt;/h2&gt;
&lt;p&gt;链路层、网络层、传输层实现了数据包能从主机应用发送到目的主机应用。正常情况下，网络上主要传输的数据是应用产生的。传输的数据各种各样，有网络请求，有电子邮件等等。数据需要由&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82&quot;&gt;应用层&lt;/a&gt;（Application Layer）封装，即规定数据的格式。&lt;/p&gt;
&lt;p&gt;规定「网络请求数据」格式的是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot;&gt;HTTP 协议&lt;/a&gt;。可以说，HTTP 协议是应用层的一种实现。&lt;/p&gt;
&lt;h3 id=&quot;http-协议&quot;&gt;6.1 HTTP 协议&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;HTTP 协议&lt;/strong&gt;：英文全称为：H&lt;strong&gt;yper&lt;/strong&gt;T&lt;strong&gt;ext&lt;/strong&gt; T&lt;strong&gt;ransfer&lt;/strong&gt; P**rotocol，即超文本转移（传输）协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们打开百度首页时，输入的就是一个网址 &lt;code&gt;www.baidu.com&lt;/code&gt;，这是一个 GET 请求，HTTP 协议将请求封装为应用层数据包。这样，百度的服务器应用层就可以根据 HTTP 协议来解析数据包。&lt;/p&gt;
&lt;p&gt;HTTP 请求的数据包一般称为请求报文，分为报文首部和报文主题，报文首部即为请求头，请求头格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214832995-1906529284.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包含的应用层数据包的以太帧格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214833157-647488711.png&quot; alt=&quot;图片来自阮一峰博客&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dns&quot;&gt;6.2 DNS&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;：英语全称为： &lt;strong&gt;D&lt;/strong&gt;omain &lt;strong&gt;N&lt;/strong&gt;ame &lt;strong&gt;S&lt;/strong&gt;ystem，即&lt;strong&gt;域名系统&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似 &lt;code&gt;www.baidu.com&lt;/code&gt; 这样的网址域名，是为了用户方便记忆，网络通信时，需要将域名转换为 IP 地址，这是由 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F&quot;&gt;DNS&lt;/a&gt; 负责的，它也属于应用层。&lt;/p&gt;
&lt;h2 id=&quot;七wireshark-抓包分析&quot;&gt;七、WireShark 抓包分析&lt;/h2&gt;
&lt;p&gt;当 Mac 连 WIFI 后，可以在「设置-&amp;gt;网络」中看见下面这些内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214833698-1942929917.jpg&quot; alt=&quot;TCP/IP&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214833982-767638251.jpg&quot; alt=&quot;MAC 地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214834199-934769607.jpg&quot; alt=&quot;DNS 地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时电脑，有自己的 IP 地址、MAC 地址、还知道路由器的 IP 地址、DNS 服务器地址（由路由器负责域名解析，所以 DNS 地址其实就是 IP 地址）和当前的子网掩码。还可以看出，路由器动态分配 IP 地址是由 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE&quot;&gt;DHCP&lt;/a&gt; 实现的。&lt;/p&gt;
&lt;p&gt;通过打开百度首页，结合抓包工具 Wireshark 来看看网络通信过程中的数据包的内容。&lt;/p&gt;
&lt;p&gt;关于如何使用 Wireshark，请看 &lt;a href=&quot;https://juejin.im/post/5c87059ae51d452f3f64b110&quot;&gt;使用 wireshark 学习网络协议&lt;/a&gt;。通过 &lt;code&gt;ping www.baidu.com&lt;/code&gt; 得到百度的 IP 地址为 &lt;code&gt;61.135.169.121&lt;/code&gt;，在 Wireshark 中配置过滤条件后，通过使用命令 &lt;code&gt;curl www.baidu.com&lt;/code&gt; 来模拟打开百度首页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214836386-362365619.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时在 Wireshark 中可以看出，TCP 协议发送了以太帧，以太帧的格式是：Ethernet II 标头 + IP 4 标头 + TCP 标头 + TCP 数据，TCP 标头显示源端口为 53732，目的地端口为 80；IP 标头显示源 IP 地址为 &lt;code&gt;192.168.31.206&lt;/code&gt;，目的地 IP 地址为 &lt;code&gt;61.135.169.121&lt;/code&gt;；以太网标头显示源 MAC 地址为 &lt;code&gt;f0:18:98:46:bf:65&lt;/code&gt;，目的地 MAC 地址为 &lt;code&gt;28:6c:07:9d:e2:8e&lt;/code&gt;（小米路由器地址）。帧的长度为 78 字节，TCP 数据包的长度为 44 个字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214837504-1197393727.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这与我们前面说的相符合，目的主机不在同一个局域网，通过以太网发送以太帧给路由器，再由路由器负责路由发送。&lt;/p&gt;
&lt;p&gt;前三个数据包为 TCP 的 3 次握手，接着发送了 HTTP 数据包，HTTP 数据包包含了请求的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214838262-144315251.jpg&quot;/&gt;整个过程：先使用 TCP 协议完成了 3 次握手，然后使用 HTTP 协议发送了 GET 请求，接收到了百度的 HTTP 响应，最后使用 TCP 协议完成了 4 次挥手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214838775-1240222390.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;八总结&quot;&gt;八、总结&lt;/h2&gt;
&lt;p&gt;互联网协议整个网络通信过程可以用下面这张图描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214839313-942015146.png&quot; alt=&quot;图片来自 Wiki&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于发送方的数据处理，&lt;strong&gt;这个过程像是一个俄罗斯套娃的过程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214839930-702484959.png&quot; alt=&quot;图片来自 Wiki&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果用发快递来类比一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 应用层：将物体打包为快递  
       |
 传输层：为快递填上收件人门牌号；如果快递丢失重新发送
       |
 网络层：为快递填上收件人小区地址；并根据收件人小区地址，找到下一个快递中转站的地址，最终找到整个线路
       |
 链路层：为快递填上下一个中转地地址；并负责将快递发往到下一个中转站
       |
 物理层：运快递的车&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在互联网协议中，因为 TCP/IP 协议最重要，所以互联网协议也可以叫做 「&lt;strong&gt;TCP/IP 协议族&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;此文只是个人对互联网协议的浅显理解，毕竟没有深入研究，可能有诸多不当处，欢迎留言指出。&lt;/p&gt;
&lt;p&gt;最后我想说一句，阮一峰牛逼。有的知识点是知道怎么回事，就是不能正确的表达出来，遣词排句真的很需要功力，真的需要常年累月的积累。&lt;/p&gt;
&lt;h2 id=&quot;九延伸阅读&quot;&gt;九、延伸阅读&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1191638/202003/1191638-20200320214840913-1274635722.png&quot; alt=&quot;个人公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 13:49:00 +0000</pubDate>
<dc:creator>DeppWXQ</dc:creator>
<og:description>作者： &amp;quot;DeppWang&amp;quot; 互联网上的数据能从一台设备发送到另一台设备，整个过程由 &amp;quot;互联网协议&amp;quot; （ Internet Protocol Suite）实现的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deppwang/p/12535144.html</dc:identifier>
</item>
<item>
<title>AVR单片机教程——走向高层 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12482580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12482580.html</guid>
<description>&lt;p&gt;本文隶属于&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/avr_tutorial.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程&lt;/a&gt;系列。&lt;/p&gt;

&lt;p&gt;在系列教程的最后一篇中，我将向你推荐3个可以深造的方向：RTOS、C++、事件驱动。掌握这些技术可以帮助你更快、更好地开发更大的项目。&lt;/p&gt;
&lt;p&gt;本文涉及到许多概念性的内容，如果你有不同意见，欢迎讨论。&lt;/p&gt;
&lt;h3 id=&quot;关于高层&quot;&gt;关于高层&lt;/h3&gt;
&lt;p&gt;这一篇教程叫作“走向高层”。什么是高层？&lt;/p&gt;
&lt;p&gt;我认为，如果寥寥几行代码就能实现一个复杂功能，或者一行代码可以对应到几百句汇编，那么你就站在高层。高层与底层是相对的概念，没有绝对的界限。&lt;/p&gt;
&lt;p&gt;站得高，看得远，这同样适用于编程，我们要走向高层。高层是对底层的封装，是对现实的抽象，高层相比于底层更加贴近应用。站在高层，你可以看到很多底层看不到的东西，主要有编程工具和思路。合理利用工具，可以简化代码，降低工作量；用合适的思路编程，更可以事半功倍。&lt;/p&gt;
&lt;p&gt;但是，掌握高层并不意味着忽视甚至鄙视底层，高层建立在底层基础之上。其一，有些高层出现的诡异现象可以追溯到底层，这样的debug任务只有通晓底层与高层的开发者才能胜任；其二，为了让高层实现复杂功能的同时获得可接受的运行效率，底层必须设计地更加精致，这就对底层提出了更高的要求。&lt;/p&gt;
&lt;p&gt;相信你经过一期和二期的教程，已经相当熟悉AVR编程的底层了。跟我一起走上高层吧！&lt;/p&gt;
&lt;h3 id=&quot;rtos&quot;&gt;RTOS&lt;/h3&gt;
&lt;p&gt;实时操作系统（RTOS）是一类操作系统。带有操作系统的计算机系统相比不带有的，最显著的特点是支持多任务。我们之前写的程序，在监控按键的同时，开了一个定时器中断用于数码管动态扫描，两个任务同时进行，是多任务吗？不完全是。监控按键与动态扫描两个任务只有一个可以占据&lt;code&gt;main&lt;/code&gt;函数，另一个必须放在中断里，中断里的任务不能执行太长时间，否则就会干扰&lt;code&gt;main&lt;/code&gt;函数的运行。而操作系统中的任务调度器可以给每个任务分配一定的运行时间，CPU一会执行这个，一会执行那个，每个任务都好像独占了CPU连续执行一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232344729-1683014067.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RTOS与其他操作系统的主要区别在于任务调度器的设计。在RTOS中，所有任务都有优先级，优先级高的被调度器保证优先执行，以获得最短的响应时间。在与现实世界打交道的嵌入式系统中，这样的功能往往是必要的。&lt;/p&gt;
&lt;p&gt;操作系统通常需要中档的硬件，8位的AVR稍差了一点，主频和存储容量达不到一些操作系统的要求，不过还是有可选项的。我们来试着在开发板上运行&lt;a href=&quot;https://www.freertos.org/&quot; target=&quot;_blank&quot;&gt;FreeRTOS&lt;/a&gt;。FreeRTOS是一个免费的、为单片机设计的RTOS，是目前嵌入式市场占有率第二的操作系统，仅次于Linux。&lt;/p&gt;
&lt;p&gt;首先去官网下载代码。下载的是一个&lt;code&gt;.zip&lt;/code&gt;压缩包，找到&lt;code&gt;FreeRTOS&lt;/code&gt;文件夹，目录下&lt;code&gt;Demo&lt;/code&gt;和&lt;code&gt;Source&lt;/code&gt;中的部分代码是需要使用的。作为一个跨平台的系统，大多数代码平台无关，只存一份，其他平台相关的代码，每个平台都有独立的实现，源码是demo都是如此，这使得代码组织有些复杂，你可以参考&lt;a href=&quot;https://www.freertos.org/a00017.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;官方提供了ATmega323单片机的demo，为了在开发板上运行，需要做一些修改。demo基于WinAVR平台，它与Atmel Studio一样，都是基于avr-gcc的。如果你有WinAVR的话，直接用&lt;code&gt;makefile&lt;/code&gt;就可以编译；Atmel Studio虽然也提供了&lt;code&gt;make&lt;/code&gt;，但有些微区别，没法直接用&lt;code&gt;makefile&lt;/code&gt;，因此我们自己建立项目来编译。&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建项目，然后在Solution Explorer中建3个文件夹：&lt;code&gt;source&lt;/code&gt;、&lt;code&gt;port&lt;/code&gt;和&lt;code&gt;demo&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;拷贝一些文件到这些目录下：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt;：&lt;code&gt;\Source\include\&lt;/code&gt;所有文件、&lt;code&gt;\Source\&lt;/code&gt;下的&lt;code&gt;tasks.c&lt;/code&gt;、&lt;code&gt;queue.c&lt;/code&gt;、&lt;code&gt;list.c&lt;/code&gt;和&lt;code&gt;croutine.c&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;port&lt;/code&gt;：&lt;code&gt;\Source\portable\GCC\ATmega323\&lt;/code&gt;所有文件和\Source\portable\MemMang`下的&lt;code&gt;heap_1.c&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;demo&lt;/code&gt;：&lt;code&gt;\Demo\Common\include\&lt;/code&gt;所有文件、&lt;code&gt;\Demo\Common\Minimal\&lt;/code&gt;下的&lt;code&gt;crflash.c&lt;/code&gt;、&lt;code&gt;integer.c&lt;/code&gt;、&lt;code&gt;PollQ.c&lt;/code&gt;和&lt;code&gt;comtest.c&lt;/code&gt;、&lt;code&gt;\Demo\AVR_ATMega323_WinAVR\&lt;/code&gt;除&lt;code&gt;makefile&lt;/code&gt;以外的所有文件，再把&lt;code&gt;ParTest.c&lt;/code&gt;和&lt;code&gt;serial.c&lt;/code&gt;拎出来，&lt;code&gt;main.c&lt;/code&gt;拎到外面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我是怎么知道的呢？我参考了官方文档和&lt;code&gt;makefile&lt;/code&gt;文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在Solution Explorer中Add Existing Item，在项目属性-&amp;gt;Toolchain-&amp;gt;AVR/GNU C Compiler-&amp;gt;Directories中添加这三个目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;修改代码，使之适用于我们的开发板：&lt;/p&gt;
&lt;p&gt;修改的理由有以下几种：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ATmega323和ATmega324的寄存器略有不同；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WinAVR和Atmel Studio提供的工具链中的一些定义方式不同；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;硬件配置与连接不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以需要做以下修改：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;port.c&lt;/code&gt;中：&lt;code&gt;TIMSK&lt;/code&gt;改为&lt;code&gt;TIMSK1&lt;/code&gt;；&lt;code&gt;SIG_OUTPUT_COMPARE1A&lt;/code&gt;改为&lt;code&gt;TIMER1_COMPA_vect&lt;/code&gt;；54行改为&lt;code&gt;0x02&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;FreeRTOSConfig.h&lt;/code&gt;中：48行改为&lt;code&gt;25000000&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;serial.c&lt;/code&gt;中：&lt;code&gt;UDR&lt;/code&gt;、&lt;code&gt;UCSRB&lt;/code&gt;、&lt;code&gt;UCSRC&lt;/code&gt;、&lt;code&gt;UBRRL&lt;/code&gt;、&lt;code&gt;UBRRH&lt;/code&gt;分别改为&lt;code&gt;UDR0&lt;/code&gt;、&lt;code&gt;UCSR0B&lt;/code&gt;、&lt;code&gt;UCSR0C&lt;/code&gt;、&lt;code&gt;UBRR0L&lt;/code&gt;、&lt;code&gt;UBRR0H&lt;/code&gt;；67行改为&lt;code&gt;0x00&lt;/code&gt;；188行改为&lt;code&gt;ISR(USART0_RX_vect)&lt;/code&gt;；207行改为&lt;code&gt;ISR(USART0_UDRE_vect)&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;comtest.c&lt;/code&gt;中：71行改为&lt;code&gt;4&lt;/code&gt;；72行改为&lt;code&gt;2&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ParTest.c&lt;/code&gt;中：&lt;code&gt;DDRB&lt;/code&gt;改为&lt;code&gt;DDRC&lt;/code&gt;；&lt;code&gt;PORTB&lt;/code&gt;改为&lt;code&gt;PORTC&lt;/code&gt;；49行改为&lt;code&gt;0x00&lt;/code&gt;；50行改为&lt;code&gt;3&lt;/code&gt;；72和99行把&lt;code&gt;uxLED&lt;/code&gt;改为&lt;code&gt;(4 + uxLED)&lt;/code&gt;；76行把&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;else&lt;/code&gt;的大括号中的语句对调；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;main.c&lt;/code&gt;中：删除81和84行；111行改为&lt;code&gt;0&lt;/code&gt;；117行改为&lt;code&gt;3&lt;/code&gt;；127行改为&lt;code&gt;2&lt;/code&gt;；153行返回类型改为&lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不出意外的话，现在代码可以通过编译了（我这里有3个warning）。下载到单片机上，连接&lt;code&gt;TX&lt;/code&gt;和&lt;code&gt;RX&lt;/code&gt;，你会发现红灯和黄灯分别以300ms和400ms为周期闪烁，绿灯和串口黄灯一起闪烁，蓝灯不亮。&lt;/p&gt;
&lt;p&gt;实际上，程序创建了1个整数计算、2个串口收发、2个队列收发、2个寄存器测试、1个错误检查和1个空闲共9个任务，以及2个LED闪烁协程。每过一毫秒，定时器产生一次中断，任务调度器暂停当前任务，换一个任务开始运行。为了理解这个过程，我们先介绍上下文这个概念。&lt;/p&gt;
&lt;p&gt;一个任务在执行的过程中，需要一些临时变量，它们有的保存在栈上（栈是内存中的一块区域，寄存器&lt;code&gt;SP&lt;/code&gt;指向栈顶），有的在寄存器中；此外，条件分支语句还要用到寄存器&lt;code&gt;SREG&lt;/code&gt;中的位，这些位在之前的语句中被置位或清零；还有记录当前程序执行到哪的程序计数器。这些一起构成了任务执行的上下文：寄存器&lt;code&gt;r0&lt;/code&gt;到&lt;code&gt;r31&lt;/code&gt;、&lt;code&gt;SREG&lt;/code&gt;、&lt;code&gt;SP&lt;/code&gt;和&lt;code&gt;PC&lt;/code&gt;。不同任务的上下文是不共享的，但它们却要占用相同的位置，为此，在切换任务时需要把前一个上下文保存起来，并恢复要切换到的任务的上下文，这个过程称为上下文切换，然后才能继续这个任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232359446-144587912.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来结合代码分析一下这个过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
void TIMER1_COMPA_vect( void )
{
    vPortYieldFromTick();
    asm volatile ( &quot;reti&quot; );
}

void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    if( xTaskIncrementTick() != pdFALSE )
    {
        vTaskSwitchContext();
    }
    portRESTORE_CONTEXT();
    asm volatile ( &quot;ret&quot; );
}

typedef void TCB_t;
extern volatile TCB_t * volatile pxCurrentTCB;

#define portSAVE_CONTEXT()                                  \
    asm volatile (  &quot;push   r0                      \n\t&quot;   \
                    &quot;in     r0, __SREG__            \n\t&quot;   \
                    &quot;cli                            \n\t&quot;   \
                    &quot;push   r0                      \n\t&quot;   \
                    &quot;push   r1                      \n\t&quot;   \
                    &quot;clr    r1                      \n\t&quot;   \
                    &quot;push   r2                      \n\t&quot;   \
                    &quot;push   r3                      \n\t&quot;   \
                    &quot;push   r4                      \n\t&quot;   \
                    &quot;push   r5                      \n\t&quot;   \
                    &quot;push   r6                      \n\t&quot;   \
                    &quot;push   r7                      \n\t&quot;   \
                    &quot;push   r8                      \n\t&quot;   \
                    &quot;push   r9                      \n\t&quot;   \
                    &quot;push   r10                     \n\t&quot;   \
                    &quot;push   r11                     \n\t&quot;   \
                    &quot;push   r12                     \n\t&quot;   \
                    &quot;push   r13                     \n\t&quot;   \
                    &quot;push   r14                     \n\t&quot;   \
                    &quot;push   r15                     \n\t&quot;   \
                    &quot;push   r16                     \n\t&quot;   \
                    &quot;push   r17                     \n\t&quot;   \
                    &quot;push   r18                     \n\t&quot;   \
                    &quot;push   r19                     \n\t&quot;   \
                    &quot;push   r20                     \n\t&quot;   \
                    &quot;push   r21                     \n\t&quot;   \
                    &quot;push   r22                     \n\t&quot;   \
                    &quot;push   r23                     \n\t&quot;   \
                    &quot;push   r24                     \n\t&quot;   \
                    &quot;push   r25                     \n\t&quot;   \
                    &quot;push   r26                     \n\t&quot;   \
                    &quot;push   r27                     \n\t&quot;   \
                    &quot;push   r28                     \n\t&quot;   \
                    &quot;push   r29                     \n\t&quot;   \
                    &quot;push   r30                     \n\t&quot;   \
                    &quot;push   r31                     \n\t&quot;   \
                    &quot;lds    r26, pxCurrentTCB       \n\t&quot;   \
                    &quot;lds    r27, pxCurrentTCB + 1   \n\t&quot;   \
                    &quot;in     r0, 0x3d                \n\t&quot;   \
                    &quot;st     x+, r0                  \n\t&quot;   \
                    &quot;in     r0, 0x3e                \n\t&quot;   \
                    &quot;st     x+, r0                  \n\t&quot;   \
                );

#define portRESTORE_CONTEXT()                               \
    asm volatile (  &quot;lds    r26, pxCurrentTCB       \n\t&quot;   \
                    &quot;lds    r27, pxCurrentTCB + 1   \n\t&quot;   \
                    &quot;ld     r28, x+                 \n\t&quot;   \
                    &quot;out    __SP_L__, r28           \n\t&quot;   \
                    &quot;ld     r29, x+                 \n\t&quot;   \
                    &quot;out    __SP_H__, r29           \n\t&quot;   \
                    &quot;pop    r31                     \n\t&quot;   \
                    &quot;pop    r30                     \n\t&quot;   \
                    &quot;pop    r29                     \n\t&quot;   \
                    &quot;pop    r28                     \n\t&quot;   \
                    &quot;pop    r27                     \n\t&quot;   \
                    &quot;pop    r26                     \n\t&quot;   \
                    &quot;pop    r25                     \n\t&quot;   \
                    &quot;pop    r24                     \n\t&quot;   \
                    &quot;pop    r23                     \n\t&quot;   \
                    &quot;pop    r22                     \n\t&quot;   \
                    &quot;pop    r21                     \n\t&quot;   \
                    &quot;pop    r20                     \n\t&quot;   \
                    &quot;pop    r19                     \n\t&quot;   \
                    &quot;pop    r18                     \n\t&quot;   \
                    &quot;pop    r17                     \n\t&quot;   \
                    &quot;pop    r16                     \n\t&quot;   \
                    &quot;pop    r15                     \n\t&quot;   \
                    &quot;pop    r14                     \n\t&quot;   \
                    &quot;pop    r13                     \n\t&quot;   \
                    &quot;pop    r12                     \n\t&quot;   \
                    &quot;pop    r11                     \n\t&quot;   \
                    &quot;pop    r10                     \n\t&quot;   \
                    &quot;pop    r9                      \n\t&quot;   \
                    &quot;pop    r8                      \n\t&quot;   \
                    &quot;pop    r7                      \n\t&quot;   \
                    &quot;pop    r6                      \n\t&quot;   \
                    &quot;pop    r5                      \n\t&quot;   \
                    &quot;pop    r4                      \n\t&quot;   \
                    &quot;pop    r3                      \n\t&quot;   \
                    &quot;pop    r2                      \n\t&quot;   \
                    &quot;pop    r1                      \n\t&quot;   \
                    &quot;pop    r0                      \n\t&quot;   \
                    &quot;out    __SREG__, r0            \n\t&quot;   \
                    &quot;pop    r0                      \n\t&quot;   \
                );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在定时器中断&lt;code&gt;TIMER1_COMPA_vect&lt;/code&gt;中，&lt;code&gt;vPortYieldFromTick&lt;/code&gt;被调用，其中依次调用&lt;code&gt;portSAVE_CONTEXT&lt;/code&gt;、&lt;code&gt;xTaskIncrementTick&lt;/code&gt;、&lt;code&gt;vTaskSwitchContext&lt;/code&gt;（可能不调用）和&lt;code&gt;portRESTORE_CONTEXT&lt;/code&gt;，执行汇编语句&lt;code&gt;ret&lt;/code&gt;；最后执行&lt;code&gt;reti&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在介绍中断的时候，我们提到过编译器添加的额外代码，把用到的寄存器都push进栈。但是，编译器只会保护该中断用到的寄存器，而上下文包括所有寄存器，需要手动地编写代码，那么也就无需编译器添加多余的代码了。函数&lt;code&gt;TIMER1_COMPA_vect&lt;/code&gt;被添加attribute&lt;code&gt;naked&lt;/code&gt;，表示无需添加任何代码，把用户编写的原原本本地编进去就够了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232406284-1631079568.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入中断时，&lt;code&gt;PC&lt;/code&gt;被push进栈（这是硬件做的），&lt;code&gt;PC&lt;/code&gt;内容变为&lt;code&gt;TIMER1_COMPA_vect&lt;/code&gt;的地址，随后开始执行，&lt;code&gt;PC&lt;/code&gt;再次push进栈（没有在图片中表示出来），开始执行&lt;code&gt;portSAVE_CONTEXT&lt;/code&gt;保存上下文。由于它是宏，就没有&lt;code&gt;PC&lt;/code&gt;进栈的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232415684-1901545555.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，&lt;code&gt;r0&lt;/code&gt;、&lt;code&gt;SREG&lt;/code&gt;、&lt;code&gt;r1&lt;/code&gt;到&lt;code&gt;r31&lt;/code&gt;依次进栈，上下文的内容保存完成，其位置还需要另存。&lt;code&gt;SP&lt;/code&gt;指向栈顶，代表着上下文的位置，它被复制到&lt;code&gt;pxCurrentTCB&lt;/code&gt;所指的位置中。&lt;code&gt;pxCurrentTCB&lt;/code&gt;实际上是结构体&lt;code&gt;TCB_t&lt;/code&gt;指针，该结构体保存着当前执行的任务的信息，前两个字节保存栈指针。这样，上下文就保存完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232422754-285707224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xTaskIncrementTick&lt;/code&gt;把软件计数器加1，并检查是否需要任务切换。为了讲解，我们假定它需要，那么&lt;code&gt;vTaskSwitchContext&lt;/code&gt;就会被调用，&lt;code&gt;pxCurrentTCB&lt;/code&gt;指向另一个&lt;code&gt;TCB_t&lt;/code&gt;变量，那里保存着另一个任务的上下文，我们要恢复它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202003/1734552-20200314232428084-1864117395.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恢复过程是，先用&lt;code&gt;pxCurrentTCB&lt;/code&gt;取出&lt;code&gt;SP&lt;/code&gt;，再按相反的顺序出栈，上下文中就只剩&lt;code&gt;PC&lt;/code&gt;没有恢复了（&lt;code&gt;ret&lt;/code&gt;和&lt;code&gt;vPortYieldFromTick&lt;/code&gt;的调用抵消，一起忽略）。最后执行&lt;code&gt;reti&lt;/code&gt;，该汇编语句从栈顶取两个字节放进&lt;code&gt;PC&lt;/code&gt;，并跳转到其位置继续执行。此时，&lt;code&gt;PC&lt;/code&gt;的内容就是该任务之前被中断时执行到的位置，现在从&lt;code&gt;PC&lt;/code&gt;开始继续执行，也就是继续执行该任务。上下文切换完成。&lt;/p&gt;
&lt;p&gt;在对FreeRTOS稍有了解后，我们动手写一个基于FreeRTOS的程序。在学习数码管的时候，你很可能考虑过，在后台创建一个任务，执行数码管的扫描。现在，FreeRTOS给了你这个机会。我们创建两个任务，一个每一毫秒显示数码管的一位，另一个每200毫秒更新显示的数字。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &quot;FreeRTOS.h&quot;
#include &quot;task.h&quot;
#include &quot;semphr.h&quot;
#include &amp;lt;ee2/segment.h&amp;gt;

SemaphoreHandle_t mutex;

portTASK_FUNCTION(segment_scan, pvParameters)
{
    while (1)
    {
        static uint8_t digit = 0;
        xSemaphoreTake(mutex, 1000);
        segment_display(digit);
        xSemaphoreGive(mutex);
        if (++digit == 2)
            digit = 0;
        vTaskDelay(1);
    }
}

portTASK_FUNCTION(segment_set, pvParameters)
{
    while (1)
    {
        static uint8_t number = 0;
        xSemaphoreTake(mutex, 1000);
        segment_dec(number);
        xSemaphoreGive(mutex);
        if (++number == 100)
            number = 0;
        vTaskDelay(200);
    }
}

int main()
{
    segment_init(PIN_8, PIN_9);
    mutex = xSemaphoreCreateMutex();
    xTaskCreate(segment_scan, &quot;scan&quot;, configMINIMAL_STACK_SIZE, NULL, 1, NULL);
    xTaskCreate(segment_set, &quot;set&quot;, configMINIMAL_STACK_SIZE, NULL, 2, NULL);
    vTaskStartScheduler();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个任务都需要使用数码管这一资源。如果一个任务正在调用&lt;code&gt;segment_dec&lt;/code&gt;，还没返回时，定时器中断发生，切换到另一个任务，其中调用了&lt;code&gt;segment_display&lt;/code&gt;，就会发生冲突。我们用一个互斥量&lt;code&gt;mutex&lt;/code&gt;来解决。当一个任务调用了&lt;code&gt;xSemaphoreTake&lt;/code&gt;后，在它调用&lt;code&gt;xSemaphoreGive&lt;/code&gt;前，&lt;code&gt;mutex&lt;/code&gt;会进入锁定状态，如果另一个任务试图调用&lt;code&gt;xSemaphoreTake&lt;/code&gt;，则会阻塞住，切换到另一个任务。这样就保证两个任务不会冲突。资源共享是并行程序要着重处理的问题之一。&lt;/p&gt;
&lt;p&gt;FreeRTOS还有很多功能等待你去发掘，RTOS就更多了。最后，我们来谈谈RTOS的长处和短处。&lt;/p&gt;
&lt;p&gt;RTOS是多任务的，这是对代码顺序执行的编程模型的颠覆，使程序可以实现更多功能，比如两个连续的（不调用&lt;code&gt;delay&lt;/code&gt;之类的函数的）任务同时执行。即使是大多数情况下中断可以解决的问题，RTOS的引入也能让你更快地实现相同功能，这既体现在编程思路的改进，还有现成API可供使用，提高开发效率。如果涉及到程序在平台间的移植，RTOS能提供的帮助就更多了。&lt;/p&gt;
&lt;p&gt;RTOS是事件驱动的，尽管表面上不太看得出来。这也能带来一些收益，我们将在本文最后一节进行分析。&lt;/p&gt;
&lt;p&gt;然而，RTOS的运行负担较大，包括时间和空间，比如在AVR平台上，一次任务调度至少需要100多个指令周期。在应用本身不太复杂的情况下，这一点尤为严重，需要根据应用决定是否使用。我把RTOS安排到了最后一篇，显然是建议在AVR单片机开发中，尽可能不要使用RTOS。&lt;/p&gt;
&lt;p&gt;最后，RTOS对个人发展是有好处的。Linux尽管不是RTOS，作为安装量最大的操作系统内核，是嵌入式开发者必须精通的。各种RTOS与Linux一样都是操作系统，无非是调度策略不同（Linux也有实时的），很多内容都是相通的。学习RTOS对学习Linux有很大帮助，这对你的嵌入式道路是有益无害的。&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C++&lt;/h3&gt;
&lt;p&gt;未完待续……&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 13:18:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>本文隶属于AVR单片机教程系列。 在系列教程的最后一篇中，我将向你推荐3个可以深造的方向：RTOS、C++、事件驱动。掌握这些技术可以帮助你更快、更好地开发更大的项目。 本文涉及到许多概念性的内容，如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12482580.html</dc:identifier>
</item>
</channel>
</rss>