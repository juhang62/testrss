<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Node.js + MySQL 实现数据的增删改查 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/nodejs_crud.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/nodejs_crud.html</guid>
<description>&lt;p&gt;通过完成一个 todo 应用展示 Node.js + MySQL 增删改查的功能。这里后台使用 &lt;a href=&quot;https://koajs.com&quot; rel=&quot;nofollow&quot;&gt;Koa&lt;/a&gt; 及其相应的一些中间件作为 server 提供服务。&lt;/p&gt;
&lt;h2&gt;初始化项目&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mkdir node-crud &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;$_&lt;/span&gt;
$ yarn init -y &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; npx gitignore node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的命令创建了一个空文件夹 &lt;code&gt;node-crud&lt;/code&gt;，进入之后初始化一个 &lt;code&gt;package.json&lt;/code&gt; 以及创建 &lt;code&gt;.gitignore&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;安装 Koa 并创建 &lt;code&gt;app.js&lt;/code&gt; 以启动一个简单的 server：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ yarn add koa
$ touch app.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Koa&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;koa&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Koa&lt;/span&gt;();

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello world!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
});

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3000&lt;/span&gt;);
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;server started at http://localhost:3000&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 node 启动服务后即可通过访问 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt; 查看到页面。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ node app.js
server started at http://localhost:3000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将启动服务的命令添加到 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;scripts&lt;/code&gt; 后，可通过 yarn 方便地调用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;package.json&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;scripts&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;start&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;node app.js&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
  },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以这样来启动服务：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ yarn start
server started at http://localhost:3000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812291-29970d80-686d-11e9-9482-00ab31d2effe.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812291-29970d80-686d-11e9-9482-00ab31d2effe.png&quot; alt=&quot;hello world 页面&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;hello world 页面&lt;/p&gt;
&lt;h2&gt;添加视图&lt;/h2&gt;
&lt;p&gt;现在页面还只能呈现简单的文本，通过让请求返回 HTML 文件，可渲染更加复杂的页面。比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&amp;lt;h1&amp;gt;hello world!&amp;lt;/h1&amp;gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但手动拼接 HTML 不是很方便，可通添加相应 Koa 中间件使得请求可从预先写好的模板文件返回 HTML 到页面。&lt;/p&gt;
&lt;p&gt;安装 &lt;a href=&quot;https://github.com/queckezz/koa-views#readme&quot;&gt;koa-views&lt;/a&gt; 并使用它来返回视图（view）。&lt;code&gt;koa-views&lt;/code&gt; 需要配合另外的模板引擎来展示数据，这里使用 &lt;a href=&quot;https://github.com/mozilla/nunjucks#readme&quot;&gt;&lt;code&gt;nunjucks&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ yarn add koa-views nunjucks
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码中使用上面两个 npm 模块来返回页面：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 配置模板路径及所使用的模板引擎&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-en&quot;&gt;views&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/views&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
    map&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      html&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;nunjucks&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    }
  })
);

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;form&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
    todo&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {}
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后创建 &lt;code&gt;views&lt;/code&gt; 目录并在其中放置视图文件，比如创建一个 &lt;code&gt;form.html&lt;/code&gt; 并在其中编辑一个 HTML 表单，后续使用它来提交数据。&lt;/p&gt;
&lt;details readability=&quot;3&quot;&gt;views/form.html
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;en&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;UTF-8&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;viewport&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;width=device-width, initial-scale=1.0&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;http-equiv&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;X-UA-Compatible&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ie=edge&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;title&lt;/span&gt;&amp;gt;todo crud - add todo&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;title&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;head&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/edit&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;POST&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;fieldset&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;legend&lt;/span&gt;&amp;gt;add todo&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;legend&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;hidden&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;{{ todo.id }}&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;form-row&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
          &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;for&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
            todo content: &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;placeholder&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;todo content...&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;{{ todo.content }}&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
            /&amp;gt;
          &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;label&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;form-row&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
          &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;for&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;is_done&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
            is complete:
            &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;input&lt;/span&gt;
              &lt;span class=&quot;pl-e&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;is_done&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
              &lt;span class=&quot;pl-e&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;checkbox&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
              &lt;span class=&quot;pl-e&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;is_done&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
              &lt;span class=&quot;pl-e&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
              &lt;span class=&quot;pl-e&quot;&gt;{%if&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;todo.is_done&lt;/span&gt;==&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;0&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-e&quot;&gt;%}checked{%endif%}&lt;/span&gt;
            /&amp;gt;
          &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;label&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;submit&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;submit&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;button&lt;/span&gt;&amp;gt;
      &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;fieldset&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;form&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;其中 &lt;code&gt;{%...%}&lt;/code&gt; 为 nunjucks 的模板语法，更多可查看其&lt;a href=&quot;https://mozilla.github.io/nunjucks/&quot; rel=&quot;nofollow&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;再次启动服务器后，可看到如下的页面，包含一个表单以&lt;strong&gt;创建&lt;/strong&gt;一个 todo。同时如果我们在渲染这个页面时，提供了 todo 数据，相应的数据会自动填充到表单中，此时该表单可用来&lt;strong&gt;编辑&lt;/strong&gt;一个 todo。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812330-3a478380-686d-11e9-86f7-152bbf9e5972.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812330-3a478380-686d-11e9-86f7-152bbf9e5972.png&quot; alt=&quot;表单页面&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;表单页面&lt;/p&gt;
&lt;h2&gt;添加路由&lt;/h2&gt;
&lt;p&gt;除了这个表单页，应用中还会有一个展示所有 todo 的列表页。需要添加路由来分别展示这两个页面。同样是通过相应的 Koa 中间件来实现。这里不需要太复杂的功能，所以使用 &lt;a href=&quot;https://github.com/koajs/route#readme&quot;&gt;&lt;code&gt;koa-route&lt;/code&gt;&lt;/a&gt; 就能满足需求。&lt;/p&gt;
&lt;p&gt;安装 &lt;code&gt;koa-route&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
$ yarn add koa&lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt;route
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 views 目录下再创建一个 HTML 文件并写入列表页的代码：&lt;/p&gt;
&lt;details readability=&quot;3&quot;&gt;views/list.html
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;en&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;UTF-8&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;viewport&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;width=device-width, initial-scale=1.0&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;http-equiv&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;X-UA-Compatible&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ie=edge&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;title&lt;/span&gt;&amp;gt;todo crud - todo list&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;title&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;style&lt;/span&gt;&amp;gt;
&lt;span class=&quot;pl-s1&quot;&gt;      &lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;{&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;        &lt;span class=&quot;pl-c1&quot;&gt;&lt;span class=&quot;pl-c1&quot;&gt;padding&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;5&lt;span class=&quot;pl-k&quot;&gt;px&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      }&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;    &lt;/span&gt;&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;style&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;head&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/add&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;add&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
      {% for item in list%}
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;todo-item&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;
          &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;#{{ loop.index }}[{%if item.is_done==0%}⏳{%else%}✅{%endif%}] {{ item.content }}&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;div&lt;/span&gt;&amp;gt;
      &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
      {% else %}
      &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;nothing yet. &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/add&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;add&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt;&amp;gt; some.&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;li&lt;/span&gt;&amp;gt;
      {%endfor%}
    &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;ul&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/add&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&amp;gt;add&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;a&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;列表页中，通过 nunjucks 的 &lt;code&gt;{% for item in list%}&lt;/code&gt; 语句遍历数据生成列表，需要展示的列表数据会在页面渲染时通过前面添加的 &lt;code&gt;koa-view&lt;/code&gt; 来传递。&lt;/p&gt;
&lt;p&gt;然后更新 app.js，添加路由逻辑以展示列表页和表单页。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;koa-route&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-en&quot;&gt;views&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/views&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
    map&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
      html&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;nunjucks&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
    }
  })
);

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-smi&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;todos&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;getAll&lt;/span&gt;();
    &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;list&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
      list&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; todos
    });
  })
);

&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-smi&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/add&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;form&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, { todo&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {} });
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 Koa 中间件是有顺序的。其中 views 的配置需要在路由之前，即 &lt;code&gt;_.get&lt;/code&gt; 部分，这样后续中间件在路由分发时才能正确地设置上视图。&lt;/p&gt;
&lt;p&gt;重新启动服务器，访问 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt; 便能看到列表页。点击页面中 &lt;code&gt;add&lt;/code&gt; 链接跳转到表单页以添加或编辑 todo。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812350-49c6cc80-686d-11e9-9dc1-966cb24c23a4.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812350-49c6cc80-686d-11e9-9dc1-966cb24c23a4.png&quot; alt=&quot;列表页&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;列表页&lt;/p&gt;
&lt;p&gt;现在我们有了可以提交数据的表单，也有了可以展示数据的列表页。接下来就是实现接收表单提交过来的数据并存入数据库。&lt;/p&gt;
&lt;h2&gt;表单数据的接收&lt;/h2&gt;
&lt;p&gt;通过添加相应的 Koa 中间件，以在代码中获取到页面提交过来的表单数据。&lt;/p&gt;
&lt;p&gt;安装 &lt;a href=&quot;https://github.com/koajs/body-parser&quot;&gt;&lt;code&gt;koa-bodyparser&lt;/code&gt;&lt;/a&gt; 并在代码中启用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ yarn add koa-bodyparser
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;bodyParser&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;koa-bodyparser&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(&lt;span class=&quot;pl-en&quot;&gt;bodyParser&lt;/span&gt;());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;form 表单中，表单元素的 &lt;code&gt;name&lt;/code&gt; 属性在数据提交时便是后端拿到的字段名，元素身上的 &lt;code&gt;value&lt;/code&gt; 属性便是该字段的值。比如上面表单中 &lt;code&gt;&amp;lt;input name=&quot;content&quot; type=&quot;text&quot; placeholder=&quot;todo content...&quot; id=&quot;content&quot; value=&quot;{{ todo.content }}&quot;/&amp;gt;&lt;/code&gt; 在提交后会得到 &lt;code&gt;{content:'...'}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加新的路由以提供 POST 类型的接口来接收表单数据，因为该接口接收来的表单数据有可能是创建，有可能是编辑，这里取名 &lt;code&gt;/edit&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-smi&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;post&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/edit&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt;;
      &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; TODO: 保存到数据库&lt;/span&gt;
      &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;redirect&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (error) {
      &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stack&lt;/span&gt;;
    }
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;ctx.request.body&lt;/code&gt; 便是 &lt;code&gt;koa-bodyparser&lt;/code&gt; 中间件解析数据后添加到 &lt;code&gt;ctx.request&lt;/code&gt; 上的表单数据，等待被保存到数据库。&lt;/p&gt;
&lt;p&gt;接下来便是数据库部分。&lt;/p&gt;
&lt;h2&gt;准备数据库&lt;/h2&gt;
&lt;p&gt;假设本地已经安装并正确配置了 MySQL，如果没有，可参考 &lt;a href=&quot;https://www.cnblogs.com/Wayou/p/quick_start_for_mysql.html&quot; rel=&quot;nofollow&quot;&gt;MySQL 上手教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;登录 MySQL 创建名为 &lt;code&gt;todo&lt;/code&gt; 的数据库：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ mysql -u wayou -p
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; 输入密码...&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; CREATE DATABASE todo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切换到刚刚创建的数据库：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; use todo&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以下脚本创建名为 todo 的表：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
CREATE TABLE &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;todo&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; (
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; int(10) unsigned NOT NULL AUTO_INCREMENT,
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;content&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; varchar(500) COLLATE utf8mb4_general_ci DEFAULT NULL,
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;is_done&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; int(11) DEFAULT &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;0&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;date&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt; date NOT NULL,
  PRIMARY KEY (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;id&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;数据库连接&lt;/h2&gt;
&lt;p&gt;在服务端代码中，同样，这里需要一个相应的 Koa 中间件来连接到数据库以进行相应的操作。&lt;/p&gt;
&lt;p&gt;正常来讲，使用 &lt;a href=&quot;https://www.npmjs.com/package/mysql&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/a&gt; 即可，但它不提供 Promise 方式的接口调用，还是 callback 的方式，写起来有点不方便。所以这里使用另外一个 npm 模块 &lt;a href=&quot;https://github.com/lukeb-uk/node-promise-mysql#readme&quot;&gt;promise-mysql&lt;/a&gt;，是对它的 Promise 改装。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ yarn add promise-mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以愉快地使用 &lt;code&gt;async/await&lt;/code&gt; 进行相关调用了。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;db.js&lt;/code&gt; 文件来专门处理数据库相关的操作，比如连接，数据的增删等，这样 app.js 中路由对应的 controller 只需要调用即可，不用掺杂数据库相关的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;promise-mysql&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;sql&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;mysql&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createConnection&lt;/span&gt;({
    host&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    user&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;wayou&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    password&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;xxx&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    database&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;todo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
  });
  &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(sql);
    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;end&lt;/span&gt;();
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result;
  } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (error) {
    &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码创建了一个接收 SQL 语句的方法，执行并返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小贴士&lt;/strong&gt;：如果上面代码在后续测试执行时发现报如下的错误：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; consider upgrading MySQL client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多半是用来连接的帐户没有相应从程序进行连接的权限，可通过如下命令来配置 MySQL。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ALTER USER &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;wayou&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;@&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;localhost&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; IDENTIFIED WITH mysql_native_password BY &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;your_new_password&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.01 sec)
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; FLUSH PRIVILEGES&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/native-pluggable-authentication.html&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;mysql_native_password&lt;/code&gt;&lt;/a&gt; 可到&lt;a href=&quot;https://dba.stackexchange.com/questions/209514/what-is-mysql-native-password?newreg=862807d825ce4a878805620eca2ea85e&quot; rel=&quot;nofollow&quot;&gt;这里&lt;/a&gt;了解更多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FLUSH PRIVILEGES&lt;/code&gt; 用于刷新配置使其立即生效。&lt;/p&gt;
&lt;h2&gt;记录的插入&lt;/h2&gt;
&lt;p&gt;数据库连接准备好之后，就可以将接收到的表单数据插入到数据库中了。&lt;/p&gt;
&lt;p&gt;在 db.js 中添加插入数据的方法：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;) {
  &lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;is_done&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;is_done&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;is_done&lt;/span&gt;;

  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;assign&lt;/span&gt;(&lt;span class=&quot;pl-en&quot;&gt;getTodoById&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;), todo);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    UPDATE todo&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    SET content='&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;',is_done='&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;is_done&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;'&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    WHERE todo.id=&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Date&lt;/span&gt;().&lt;span class=&quot;pl-en&quot;&gt;toJSON&lt;/span&gt;().&lt;span class=&quot;pl-c1&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    INSERT INTO todo (content,date,is_done) &lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    VALUES ('&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;','&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;','&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;todo&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;is_done&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;')&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;    &lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法用于更新已有的记录或添加新的记录，这一点是通过判断传来的表单数据中是否有 id 字段，如果有，说明是编辑已有的数据，那么执行更新操作，如果没有 id 字段，则说明是新增一个 todo。&lt;/p&gt;
&lt;p&gt;这里的 id 字段在 form 表单中是不展示的，参见上面表单页面的代码，但为了在表单提交时能够带上 id 字段，所以在表单中放置了一个隐藏的 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 来标识。&lt;/p&gt;
&lt;p&gt;需要注意的是，HTML 中 form 表单中的 checkbox，其只在被勾选时才会被提交，未勾选时不会被提交到后台。所以这里对 &lt;code&gt;is_done&lt;/code&gt; 进行一下兼容处理。&lt;/p&gt;
&lt;p&gt;更新路由部分的代码，调用这里的 &lt;code&gt;update&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; const db = require(&quot;./db&quot;);&lt;/span&gt;

app.use(
  _.post(&quot;/edit&quot;, async function(ctx) {
    try {
      const todo = ctx.request.body;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;     // TODO: 保存到数据库&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;     await db.update(todo);&lt;/span&gt;
      ctx.redirect(&quot;/&quot;);
    } catch (error) {
      ctx.body = error.stack;
    }
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启服务器访问 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:3000/add&quot;&gt;http://localhost:3000/add&lt;/a&gt; 以提交表单来创建一条数据到数据库。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812394-5e0ac980-686d-11e9-8711-43c1fd1e31aa.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812394-5e0ac980-686d-11e9-8711-43c1fd1e31aa.gif&quot; alt=&quot;提交表单创建一条 todo&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;提交表单创建一条 todo&lt;/p&gt;
&lt;p&gt;因为我们还没有将数据库中的列表展示到首页，所以这里提交成功后，跳回到首页时，数据没展现。不过我们可以去数据库查询刚刚创建的结果。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM todo&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+----+---------+---------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; content &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; is_done &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; date       &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+---------+---------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 买菜    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;       0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2019-04-26 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+---------+---------+------------+
1 row &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;查询并展示数据到页面&lt;/h2&gt;
&lt;p&gt;刚刚已经写入了一条数据到数据库，现在可以通过 &lt;code&gt;SELECT&lt;/code&gt; 语句将它查询出来并展示到首页的列表中。&lt;/p&gt;
&lt;p&gt;添加相应的查询方法到 &lt;code&gt;db.js&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getAll&lt;/span&gt;() {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;select * from todo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后更新列表页的 controller，调用该方法获取数据并返回到页面。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
app.use(
  _.get(&quot;/&quot;, async function(ctx) {
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;   // TODO: 从数据库获取数据&lt;/span&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;   const todos = [];&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;   const todos = await db.getAll();&lt;/span&gt;
    await ctx.render(&quot;list&quot;, {
      list: todos
    });
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新启动服务后，如果一切顺利，访问首页可看到刚刚添加的 todo 展示了出来。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812429-711d9980-686d-11e9-8363-8e7f593aa74f.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812429-711d9980-686d-11e9-8363-8e7f593aa74f.png&quot; alt=&quot;列表中展示来自数据库的数据&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;列表中展示来自数据库的数据&lt;/p&gt;
&lt;h2&gt;数据更新&lt;/h2&gt;
&lt;p&gt;下面为列表页中每条 todo 添加一个编辑按钮，点击后可跳转编辑页，同时跳转时连接上带上 todo 的 id。这样编辑页可从 url 中获取 id 并从数据库中将该 id 对应的数据取出来渲染到编辑页。&lt;/p&gt;
&lt;p&gt;还需要添加一个新路由 &lt;code&gt;/edit&lt;/code&gt; 展示和前面创建时一样的表单页，将根据 id 获取到的数据塞入表单提供编辑。&lt;/p&gt;
&lt;p&gt;更新列表页 HTML 添加编辑按钮：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;views/list.html&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;todo-item&quot;&amp;gt;
  &amp;lt;div class=&quot;content&quot;&amp;gt;#{{ loop.index }}[{%if item.is_done==0%}⏳{%else%}✅{%endif%}] {{ item.content }}&amp;lt;/div&amp;gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  &amp;lt;div class=&quot;action&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    &amp;lt;a href=&quot;/edit?id={{ item.id }}&quot;&amp;gt;edit&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  &amp;lt;/div&amp;gt;&lt;/span&gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加编辑页的路由并返回这个表单：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-smi&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/edit&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;query&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;id) {
      &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;id is missing&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    }
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;db&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getTodoById&lt;/span&gt;(id);
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;todo) {
      &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;item not found!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
      &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;form&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
        todo
      });
    }
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为参数是通过拼接到 url 传递而来，所以这里通过 query 部分来获取这个 id 参数。拿到之后调用了一个方法根据 id 获取数据。&lt;/p&gt;
&lt;p&gt;更新 &lt;code&gt;db.js&lt;/code&gt; 添加这个获取数据的方法：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getTodoById&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;id&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;SELECT * FROM todo WHERE todo.id='&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;id&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;'&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (result[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;]) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result[&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;];
  }
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启后打开首页，可以看到新增的编辑按钮，点击后跳转到了新增的编辑页面，在这里可以对已经添加的条目进行更新。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812459-81357900-686d-11e9-8689-e8a9013d30b5.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812459-81357900-686d-11e9-8689-e8a9013d30b5.gif&quot; alt=&quot;数据的更新&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;数据的更新&lt;/p&gt;
&lt;h2&gt;记录的删除&lt;/h2&gt;
&lt;p&gt;添加新的路由 '/remove' 提供删除操作的接口。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;app.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;use&lt;/span&gt;(
  &lt;span class=&quot;pl-smi&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;post&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/remove&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;remove entry &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;id&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;db&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;remove&lt;/span&gt;(id);
      &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
        status&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;,
        error_message&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
      };
    } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (error) {
      &lt;span class=&quot;pl-smi&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stack&lt;/span&gt;;
    }
  })
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;/remove&lt;/code&gt; 是个 POST 类型的接口，前台页面会将需要删除的条目 id 通过异步调用该接口传递过来。这里 POST 数据的获取也通过 &lt;code&gt;koa-bodyparser&lt;/code&gt; 来获取，即 &lt;code&gt;ctx.request.body&lt;/code&gt; 上面。&lt;/p&gt;
&lt;p&gt;更新 &lt;code&gt;db,js&lt;/code&gt; 添加从数据库删除条目的方法：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;id&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;DELETE FROM todo WHERE todo.id='&lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;id&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;'&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;万事具备，只差前台页面了。&lt;/p&gt;
&lt;p&gt;更新列表页的模板，在刚刚添加编辑按钮的地方，添加一个删除按钮。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;views/list.html&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;todo-item&quot;&amp;gt;
  &amp;lt;div class=&quot;content&quot;&amp;gt;#{{ loop.index }}[{%if item.is_done==0%}⏳{%else%}✅{%endif%}] {{ item.content }}&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;action&quot;&amp;gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    &amp;lt;button onclick=&quot;remove({{ item.id }})&quot;&amp;gt;remove&amp;lt;/button&amp;gt;&lt;/span&gt;
    &amp;lt;a href=&quot;/edit?id={{ item.id }}&quot;&amp;gt;edit&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时添加相应 JavaScript 代码发起删除的请求，调用上面添加的 POST 接口。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;views/list.html&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;script&lt;/span&gt;&amp;gt;
&lt;span class=&quot;pl-s1&quot;&gt;  &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;id&lt;/span&gt;) {&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;    &lt;span class=&quot;pl-en&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/remove&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      method&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;post&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      headers&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;{&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;        &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Content-Type&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;application/json&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      },&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      body&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;JSON&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;stringify&lt;/span&gt;({ id })&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;    })&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;json&lt;/span&gt;())&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      .&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;status&lt;/span&gt;) {&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;          &lt;span class=&quot;pl-en&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;error_message&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;        } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;          &lt;span class=&quot;pl-en&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;removed succussfully!&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;          &lt;span class=&quot;pl-smi&quot;&gt;location&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;reload&lt;/span&gt;();&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;        }&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      })&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;      .&lt;span class=&quot;pl-c1&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;alert&lt;/span&gt;(error));&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;  }&lt;/span&gt;
&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;script&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前台在使用 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt; PSOT 数据时，需要指定正确的 &lt;code&gt;Content-Type&lt;/code&gt;，否则后台 &lt;a href=&quot;https://github.com/koajs/bodyparser&quot;&gt;&lt;code&gt;koa-bodyparser&lt;/code&gt;&lt;/a&gt; 无法解析。&lt;/p&gt;
&lt;p&gt;重启后即可进行删除操作，成功后会提示并刷新页面。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/56812484-90b4c200-686d-11e9-841a-62b98386fd8f.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/56812484-90b4c200-686d-11e9-841a-62b98386fd8f.gif&quot; alt=&quot;remove&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;数据的删除操作&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;完成本文的流程，实现了数据的增删改查等基本操作。其中包含表单数据的提交与接收，Koa 中间件的使用以及数据库连接，还有 SQL 语句的执行等。&lt;/p&gt;
&lt;p&gt;本文中完整的示例代码可在 &lt;a href=&quot;https://github.com/wayou/node-crud&quot;&gt;wayou/node-crud&lt;/a&gt; 仓库中找到。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Fri, 26 Apr 2019 15:20:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>通过完成一个 todo 应用展示 Node.js + MySQL 增删改查的功能。这里后台使用 Koa 及其相应的一些中间件作为 server 提供服务。 初始化项目 $ mkdir node cru</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/nodejs_crud.html</dc:identifier>
</item>
<item>
<title>WebGL three.js学习笔记 使用粒子系统模拟时空隧道（虫洞） - nsytsqdtn</title>
<link>http://www.cnblogs.com/nsytsqdtn/p/10777195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nsytsqdtn/p/10777195.html</guid>
<description>&lt;h2 id=&quot;webgl-three.js学习笔记-使用粒子系统模拟时空隧道&quot;&gt;WebGL three.js学习笔记 使用粒子系统模拟时空隧道&lt;/h2&gt;
&lt;p&gt;本例的运行结果如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426222855492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;时空隧道&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;three.js的粒子系统&quot;&gt;three.js的粒子系统&lt;/h2&gt;
&lt;p&gt;three.js的粒子系统主要是依靠精灵体来创建的，要实现three.js中的粒子系统创建，一般有两种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种&lt;/strong&gt;是在场景中使用很多歌THREE.Sprite创建单个的精灵，这样创建的每一个精灵体，我们都可以单独对它们进行操作，同时我们也可以用一个THREE.Group把他们放在一起，整合起来一起操作。具有很高的自主性。但同时也是需要大量的性能支持与开发上的不便利性，所以这里我选择了第二种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种&lt;/strong&gt;创建粒子系统是依靠点云的方式，点云就是很多很多点组成的一个东西，点云里面的每一个顶点都可以看做一个粒子，而这个粒子我们就可以使用纹理去对它美化,或者是使用坐标变化来变化出好看的粒子系统，这种创建方式的缺点是不能对每一个粒子单独进行操作，但是相比第一种却给我们提供了更多的方便。&lt;/p&gt;
&lt;h2 id=&quot;搭建场景&quot;&gt;搭建场景&lt;/h2&gt;
&lt;p&gt;点云的创建方法和普通的几何体差不多，首先需要一个材质THREE.PointsMaterial，可以设置每个粒子的大小size，颜色color，透明transparent等等属性。然后再用THREE.Points(geometry, material)这个方法就可以创建出点云了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let cloud = new THREE.Points(geom, material);//创建点云&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们给了Points()，geometry这个参数，这个点云会按照我们定义好的几何体的顶点去创建粒子。&lt;br/&gt;,比如geometry是一个Box，那么这个点云就会有8粒子，分别分布在正方体的8个顶点上。如果我们不用geometry，我们就需要手动给点云创建很多的顶点，包括定义它们的坐标，这里我们也是用一个定义好的几何体去创建粒子。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//创建点云
    function createPointCloud(geom,color) {
        let material = new THREE.PointsMaterial({
            color: color,
            size: 3,
            transparent: true,
            blending: THREE.AdditiveBlending,//混合的模式，可以让很多的粒子的背景得到很好的融合，而不是互相干扰
            map: generateSprite()//取得渐变的canvas纹理
        });
        let cloud = new THREE.Points(geom, material);//创建点云
        cloud.sortParticles = true;//可以让所有粒子的Z轴得到正确摆放，不会互相遮挡
        return cloud;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数形参传过来的geom，我们使用的一个类似于管道的几何体TorusGeometry&lt;br/&gt;TorusGeometry的构造函数如下：&lt;br/&gt;THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)&lt;br/&gt;　　　　&lt;strong&gt;radius：圆环半径&lt;br/&gt;　　　　tube：管道半径&lt;br/&gt;　　　　radialSegments：径向的分段数&lt;br/&gt;　　　　tubularSegments：管的分段数&lt;br/&gt;　　　　arc：圆环面的弧度，缺省值为Math.PI * 2&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let geom = new THREE.TorusGeometry(
controls.radius, controls.tube,
 Math.round(controls.radialSegments), 
 Math.round(controls.tubularSegments)
 );//TorusGeometry几何体，管道状的几何体，里面的参数设置都是菜单面板上面的参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的参数主要就是我们要在菜单面板中去更改的值，&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;controls = new function () {
            this.radius = 100;//整个大圆隧道的半径
            this.tube = 10;//管道的半径
            this.radialSegments = 40;//管道的段数，值越大，创造的物体更精细，也更消耗性能
            this.tubularSegments = 200;//整个大圆隧道的段数，值越大，创造的物体更精细，也更消耗性能
            this.useParticle = true;//是否使用粒子系统创造几何体
            this.rotationSpeed = 0.003;//摄像机的速度
            this.color = 0xffffff;//此颜色会与材质中纹理本身的颜色做乘法，最后的结果就是渲染出来的颜色
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们要想创建一个好看的时空隧道还需要它的map属性，去赋给它一个纹理，这样每一个粒子都会比纯色更美观。纹理的话使用图片也是可以的，在这里我选择了制作一个渐变的画布来当做纹理，即generateSprite()这个函数的返回值。&lt;br/&gt;generateSprite函数代码（主要用到的是canvas的绘图函数，js的基础部分）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function generateSprite() {
        let canvas = document.createElement(&quot;canvas&quot;);
        canvas.width = 16;
        canvas.height = 16;
        let context = canvas.getContext(&quot;2d&quot;);//得到canvas的绘图上下文
        let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);//颜色渐变图形
        gradient.addColorStop(0, 'rgba(255,255,255,1)');//从内向外的第一渐变颜色，设置为白色
        gradient.addColorStop(0.2, 'rgba(0,125,125,1)');//从内向外的第二渐变颜色，设置为浅蓝色
        gradient.addColorStop(0.5, 'rgba(0,64,0,1)');//从内向外的第三渐变颜色，设置为绿色
        gradient.addColorStop(1, 'rgba(0,0,0,0.1)');//最外层的渐变颜色，为背景色
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

        let texture = new THREE.Texture(canvas);//将得到的画好的canvas作为纹理图片
        texture.needsUpdate = true;//需要设置更新，否则会没有效果
        return texture;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意texture.needsUpdate = true这句话，否则是渲染不出来的。&lt;/strong&gt;&lt;br/&gt;到此，我们就可以开始绘制场景&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;this.draw = function () {
                cameraInit = true;//调用此函数后，对摄像机进行一次初始化
                if (obj) scene.remove(obj);//如果场景的隧道已经存在，先移除
                let geom = new THREE.TorusGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments));//TorusGeometry几何体，管道状的几何体，里面的参数设置都是菜单面板上面的参数
                //使用粒子系统渲染几何体
                if (controls.useParticle) {
                    obj = createPointCloud(geom,controls.color);
                    obj.rotation.x = Math.PI/2;//旋转90度以后，更加方便观测
                } else {//使用普通材质系统渲染几何体
                    obj = createMesh(geom);
                    obj.rotation.x = Math.PI/2;
                }
                scene.add(obj);
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景有了以后，摄像机还是不会动，没有一种在时空隧道的感觉，所以这里想办法让摄像机在这个隧道的中间，沿着这个几何体的形状去移动。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426231210715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;圆&quot;/&gt;&lt;br/&gt;因为管道不看y轴的话，其实还是一个圆形，所以可以使用圆形的参数方程来让摄像机沿着这个函数去运动。让y轴始终不变就可以。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let angle = 0;//初始角度
angle = angle + controls.rotationSpeed;//相机移动的速度
camera.position.set(controls.radius*Math.sin(angle),0,
controls.radius*Math.cos(angle));//让相机按照一个圆形轨迹运动
//可以理解为圆形的参数方程x=rsinα，y=rcosα，&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;即设置相机的x为rsinα，z为rcosα，y轴是一直都为0的。这里的r为整个隧道的半径，α就是当前移动的角度。&lt;/strong&gt;&lt;br/&gt;虽然这样可以让相机开始移动了，但是相机的目标我们还没有设置，我们需要让相机在移动的过程中，始终看向前方，这样才有一种在时空隧道中漫游的感觉。但是three.js的相机运动轨迹插件似乎在这里不好用，所以就想到了用其他方式实现。&lt;/p&gt;
&lt;p&gt;我们既然已经用相机运动的圆的轨迹方程，也能很容易想到相机lookAt的方向其实就是沿着圆运动的切线方向。所以只需要求摄像机运动的当前位置的切线就可以了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426230335701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;向量&quot;/&gt;&lt;br/&gt;这里用到的是向量的点乘，坐标的&lt;strong&gt;点乘公式x1&lt;em&gt;y2+x2&lt;/em&gt;y1&lt;/strong&gt;，如果结果为0，就可以得到这个向量的垂直向量，我们要求的切线肯定就是垂直于半径的。因为我们的y轴一直不变的，所以点乘公式的y我们变为z。我们首先是让相机的位置减去隧道的中心（0，0，0），得到指向中心的向量，也就是半径，然后再用一个向量与它点乘为0，这个向量方向就是垂直于半径的了，也就是切线的方向。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function look(){
        let view = new THREE.Vector3(camera.position.x, 
        camera.position.y, 
        camera.position.z);//计算当前摄像机位置点到世界中心点的向量
        let vertical = (new THREE.Vector3(view.z, 0, 
        -1.0 * view.x)).normalize();
        //两个向量的点积如果为0，则两个向量垂直，公式为x1*y2+x2*y1=0，
        //这里的Y轴用Z轴代替。计算出垂直向量以后用normalize（）化成单位向量
        camera.lookAt(camera.position.x+vertical.x,0,
        camera.position.z+vertical.z);//camera.lookAt的值设置为 刚刚的单位向量加在当前摄像机的位置
        //这样就实现了在摄像机在旋转时，一直朝前看。

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后得到的这个单位向量我们再加上当前相机的位置，就可以设置为相机lookAt的值。&lt;br/&gt;&lt;strong&gt;注意我们在每次渲染的时候都要去改变这个值，因为相机的位置一直都在变化的&lt;/strong&gt;，所以我们要把它封装成一个函数，方便在渲染的时候调用。&lt;/p&gt;
&lt;p&gt;其他的，相机，场景的初始化代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function initThree() {
        //渲染器初始化
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement);//将渲染添加到div中
        //初始化摄像机，这里使用透视投影摄像机
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.x = 0;//设置摄像机的上方向为哪个方向，这里定义摄像的上方为Y轴正方向
        camera.up.y = 1;
        camera.up.z = 0;
        look();//计算摄像机在当前位置应该对准的目标点，即camera.lookAt的设置

        //初始化场景
        scene = new THREE.Scene();

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，场景基本已经构建完成了。&lt;/p&gt;
&lt;h2 id=&quot;完整的代码如下&quot;&gt;完整的代码如下：&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Sprite Tunnel&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;../../import/three.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../import/stats.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../import/Setting.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../import/dat.gui.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div#WebGL-output {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 850px;
            background-color: #000000;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;Start()&quot;&amp;gt;
&amp;lt;div id=&quot;WebGL-output&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let camera, renderer, scene;
    let controls;

    function initThree() {
        //渲染器初始化
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement);//将渲染添加到div中
        //初始化摄像机，这里使用透视投影摄像机
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.x = 0;//设置摄像机的上方向为哪个方向，这里定义摄像的上方为Y轴正方向
        camera.up.y = 1;
        camera.up.z = 0;
        look();//计算摄像机在当前位置应该对准的目标点，即camera.lookAt的设置

        //初始化场景
        scene = new THREE.Scene();

    }
    //计算摄像机在当前位置应该对准的目标点
    function look(){
        let view = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);//计算当前摄像机位置点到世界中心点的向量
        let vertical = (new THREE.Vector3(view.z, 0, -1.0 * view.x)).normalize();//两个向量的点积如果为0，则两个向量垂直，公式为x1*y2+x2*y1=0，这里的Y轴用Z轴代替。计算出垂直向量以后用normalize（）化成单位向量
        camera.lookAt(camera.position.x+vertical.x,0,camera.position.z+vertical.z);//camera.lookAt的值设置为 刚刚的单位向量加在当前摄像机的位置，这样就实现了在摄像机在旋转时，一直朝前看。

    }
    //
    let obj;
    let cameraInit = false;//改动隧道的半径后，需要让摄像机重新初始化，当cameraInit为true时进行初始化，先定义为false
    //初始化菜单面板
    function initDatGUI() {
        //设置菜单中需要的参数
        controls = new function () {
            this.radius = 100;//整个大圆隧道的半径
            this.tube = 10;//管道的半径
            this.radialSegments = 40;//管道的段数，值越大，创造的物体更精细，也更消耗性能
            this.tubularSegments = 200;//整个大圆隧道的段数，值越大，创造的物体更精细，也更消耗性能
            this.useParticle = true;//是否使用粒子系统创造几何体
            this.rotationSpeed = 0.003;//摄像机的速度
            this.color = 0xffffff;//此颜色会与材质中纹理本身的颜色做乘法，最后的结果就是渲染出来的颜色
            //初始化渲染场景中的隧道以及粒子系统的函数
            this.draw = function () {
                cameraInit = true;//调用此函数后，对摄像机进行一次初始化
                if (obj) scene.remove(obj);//如果场景的隧道已经存在，先移除
                let geom = new THREE.TorusGeometry(controls.radius, controls.tube, Math.round(controls.radialSegments), Math.round(controls.tubularSegments));//TorusGeometry几何体，管道状的几何体，里面的参数设置都是菜单面板上面的参数
                //使用粒子系统渲染几何体
                if (controls.useParticle) {
                    obj = createPointCloud(geom,controls.color);
                    obj.rotation.x = Math.PI/2;//旋转90度以后，更加方便观测
                } else {//使用普通材质系统渲染几何体
                    obj = createMesh(geom);
                    obj.rotation.x = Math.PI/2;
                }
                scene.add(obj);
            }
        };
        let gui = new dat.GUI();
        //将刚刚设置的参数添加到菜单中
        gui.add(controls, &quot;radius&quot;, 50, 200).onChange(controls.draw);
        gui.add(controls, &quot;rotationSpeed&quot;, 0, 0.02);
        gui.add(controls, &quot;tube&quot;, 5, 30).onChange(controls.draw);
        gui.add(controls, &quot;radialSegments&quot;, 20, 100).step(1).onChange(controls.draw);
        gui.add(controls, &quot;tubularSegments&quot;, 50, 300).step(1).onChange(controls.draw);
        gui.addColor(controls, &quot;color&quot;).onChange(controls.draw);
        gui.add(controls, &quot;useParticle&quot;).onChange(controls.draw);

        //这里需要先调用一次draw()函数，否则刚开始的时候会没有东西背渲染出来
        controls.draw();
    }
    //精灵贴图的制作，场景的粒子系统的每一个粒子都用这里制作的贴图来模拟
    function generateSprite() {
        let canvas = document.createElement(&quot;canvas&quot;);
        canvas.width = 16;
        canvas.height = 16;
        let context = canvas.getContext(&quot;2d&quot;);//得到canvas的绘图上下文
        let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);//颜色渐变图形
        gradient.addColorStop(0, 'rgba(255,255,255,1)');//从内向外的第一渐变颜色，设置为白色
        gradient.addColorStop(0.2, 'rgba(0,125,125,1)');//从内向外的第二渐变颜色，设置为浅蓝色
        gradient.addColorStop(0.5, 'rgba(0,64,0,1)');//从内向外的第三渐变颜色，设置为绿色
        gradient.addColorStop(1, 'rgba(0,0,0,0.1)');//最外层的渐变颜色，为背景色
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

        let texture = new THREE.Texture(canvas);//将得到的画好的canvas作为纹理图片
        texture.needsUpdate = true;//需要设置更新，否则会没有效果
        return texture;
    }
    //创建点云
    function createPointCloud(geom,color) {
        let material = new THREE.PointsMaterial({
            color: color,
            size: 3,
            transparent: true,
            blending: THREE.AdditiveBlending,//混合的模式，可以让很多的粒子的背景得到很好的融合，而不是互相干扰
            map: generateSprite()//取得渐变的canvas纹理
        });
        let cloud = new THREE.Points(geom, material);//创建点云
        cloud.sortParticles = true;//可以让所有粒子的Z轴得到正确摆放，不会互相遮挡
        return cloud;
    }
    //创建普通的管道几何体
    function createMesh(geom) {
        let material = new THREE.MeshNormalMaterial();
        material.side = THREE.DoubleSide;//双边渲染
        let mesh = new THREE.Mesh(geom, material);
        return mesh;
    }

    let angle = 0;//初始角度
    //渲染函数
    function render() {
        if(cameraInit){//每次重新渲染场景的时候，重新设置相机的位置与角度
            angle = 0;
            camera.position.set(controls.radius,0,0);
            cameraInit=false;
        }
        angle = angle + controls.rotationSpeed;//相机移动的速度
        camera.position.set(controls.radius*Math.sin(angle),0,controls.radius*Math.cos(angle));//让相机按照一个圆形轨迹运动，可以理解为圆形的参数方程x=rsinα，y=rcosα，
        look();
        stats.update();
        renderer.clear();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

    //功能函数
    function setting() {
        loadFullScreen();
        loadAutoScreen(camera, renderer);
        loadStats();
    }

    //运行主函数
    function Start() {
        initThree();
        initDatGUI();
        setting();
        render();
    }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 26 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>nsytsqdtn</dc:creator>
<og:description>WebGL three.js学习笔记 使用粒子系统模拟时空隧道（虫洞）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nsytsqdtn/p/10777195.html</dc:identifier>
</item>
<item>
<title>深度探索C++对象模型 - coding-for-self</title>
<link>http://www.cnblogs.com/longjiang-uestc/p/10777128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longjiang-uestc/p/10777128.html</guid>
<description>[unable to retrieve full-text content]深度探索C++对象模型 什么是C++对象模型: 语言中直接支持面向对象程序设计的部分. 对于各个支持的底层实现机制. 抽象性与实际性之间找出平衡点, 需要知识, 经验以及许多思考. 导读 这本书是C++第一套编译器cfront的设计者所写. 了解C++对象模型, 有助于在语言本身以及面向对象观念两方</description>
<pubDate>Fri, 26 Apr 2019 14:56:00 +0000</pubDate>
<dc:creator>coding-for-self</dc:creator>
<og:description>深度探索C++对象模型 什么是C++对象模型: 语言中直接支持面向对象程序设计的部分. 对于各个支持的底层实现机制. 抽象性与实际性之间找出平衡点, 需要知识, 经验以及许多思考. 导读 这本书是C+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longjiang-uestc/p/10777128.html</dc:identifier>
</item>
<item>
<title>DDD「领域驱动设计」分层架构初探 - AMortal</title>
<link>http://www.cnblogs.com/AMortal/p/10777050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AMortal/p/10777050.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;基于 DDD 传统分层架构实现。 项目 github地址：&lt;a href=&quot;https://github.com/WuMortal/DDDSample&quot; target=&quot;_blank&quot;&gt;https://github.com/WuMortal/DDDSamp&lt;/a&gt;le&lt;/p&gt;
&lt;p&gt;这个分层架构是工作中项目正在使用的分层架构，使用了一段时间发现受益匪浅，所以整理好我对该分层架构的一些理解分享给大家，我对于该分层架构还处于学习阶段理解有误的地方请指出。本次会以一个案例来说明各个分层的作用以及他们之间的调用关系，还有本次的重点不在于&lt;code&gt;DDD&lt;/code&gt;，因为这个我还未能完全理解，当然避免不了中间会涉及&lt;code&gt;DDD&lt;/code&gt;的一些概念。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DDD&lt;/code&gt; 什么？为什么使用 &lt;code&gt;DDD&lt;/code&gt; ？&lt;/p&gt;
&lt;p&gt;关于这个问题有兴趣的可以自行百度，我相信网络上已经有大量的文章来说明这几个问题。我目前的理解是“业务”，是为了应对现在复杂和多变的业务，是一种开发理念。&lt;/p&gt;
&lt;p&gt;这里我就以一个小故事描述吧，有一天你接到任务要实现一个修改用户的功能，非常简单。使用传统三层架构我们会怎么写？&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先在 &lt;code&gt;DAL&lt;/code&gt; 层添加 &lt;code&gt;UserDAL&lt;/code&gt; 然后实现一个 &lt;code&gt;Update(UserEntity user)&lt;/code&gt; 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接着在 &lt;code&gt;BLL&lt;/code&gt; 中添加一个 &lt;code&gt;UserBLL&lt;/code&gt; 在实现一个 &lt;code&gt;Update(string email,string pwd ...)&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;UI&lt;/code&gt; 层在调用，OK 完成任务下班回家。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接着你接到一个新的需求就是：需要增加用户修改信息的记录。&lt;/p&gt;
&lt;p&gt;你立马在 &lt;code&gt;BLL&lt;/code&gt;的 &lt;code&gt;Update&lt;/code&gt; 的方法里增加的用户修改信息的操作记录，完成需求。&lt;/p&gt;
&lt;p&gt;过了一段时间又来了一个需求：用户改了信息需要通知到管理员，并且用户每天只能修改 3 次信息。&lt;/p&gt;
&lt;p&gt;好了之后又经历了几波需求，你的代码也在不断的增加和变化，有一天你接收新的项目或者离开了，那么接收你项目的人完全不清楚这里的业务情况。因为 &lt;code&gt;Update&lt;/code&gt; 方法并没有直接的反应出里的业务情况，代码目的不明确。代码变得难以维护。&lt;/p&gt;
&lt;p&gt;那么在 &lt;code&gt;DDD&lt;/code&gt; 里这些应该怎么做呢？&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先在方法的命名上做出更改既然业务是修改信息那么命名应该是 &lt;code&gt;Modify(string email,string pwd ...)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将用户修改信息的记录代码放在 &lt;code&gt;DomainService&lt;/code&gt;（领域服务） 中，当然这里的类、方法命名要直接的反应出业务情况，如：&lt;code&gt;RecordUserModifyDomainService&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对应的通知管理员的代码也应该放入 &lt;code&gt;DomainService&lt;/code&gt; 中，&lt;code&gt;DomainService&lt;/code&gt; 应该尽量简单一般只做一件事情。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/WuMortal/DDDSamp/master/doc/images/DDD_1.png&quot; alt=&quot;DDD 流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是关于 DDD 分层的一些描述，摘抄至之前看过的一片文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Presentation 为表示层，负责向用户显示信息和解释用户命令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Application 为应用层，定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Domain 为领域层（或模型层），负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，领域模型位于这一层。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Infrastructure 层为基础实施层，向其他层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持四个层次间的交互模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;如上图每个层中其实对应着具体的项，下面将对每个项进行说明。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Domain&lt;/code&gt; 层分为：&lt;code&gt;Domain&lt;/code&gt; 、&lt;code&gt;DomainService&lt;/code&gt; 和 &lt;code&gt;IDomainService&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先 &lt;code&gt;Domain&lt;/code&gt; 中包含有 &lt;code&gt;Entity&lt;/code&gt; 和 &lt;code&gt;IRepository&lt;/code&gt; ，&lt;code&gt;Entity&lt;/code&gt; 是你的实体一般对于数据库表但是在某些情况下你也可以冗余一些字段。&lt;code&gt;IRepository&lt;/code&gt; 仓储的方法的定义，该层不会有具体的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DomainService&lt;/code&gt; 和 &lt;code&gt;IDomainService&lt;/code&gt;，&lt;code&gt;IDomainService&lt;/code&gt; 只是负责表达业务的概念，&lt;code&gt;DomainService&lt;/code&gt; 里才是具体业务逻辑代码。在这一层的代码命名上需要注意，我们的命名一般要能直接描述出该代码业务的功能。这里可以参考 &lt;code&gt;DDD&lt;/code&gt; 的几个概念：通用语言、领域。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Infrastructure&lt;/code&gt; 层分为：&lt;code&gt;Repository&lt;/code&gt; 和 &lt;code&gt;CrossCutting&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Repository&lt;/code&gt; 里面就是 &lt;code&gt;Domain&lt;/code&gt; 里 &lt;code&gt;IRepository&lt;/code&gt; 的具体实现。项目中 RepositoryExtensions.cs 是一个扩展类，将所有的仓储注入容器中，方便我们在项目中使用 &lt;code&gt;DI&lt;/code&gt;（依赖注入）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CrossCutting&lt;/code&gt; 主要是提供一些各个层通用的东西，如一些枚举、扩展方法、工具类等等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Application&lt;/code&gt; 层分为：&lt;code&gt;Application&lt;/code&gt; 和 &lt;code&gt;ApplicationContract&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ApplicationContract&lt;/code&gt; 里主要包含 &lt;code&gt;DTO&lt;/code&gt;、&lt;code&gt;ViewModel&lt;/code&gt;、&lt;code&gt;IXXXService&lt;/code&gt;。&lt;code&gt;DTO&lt;/code&gt; 是数据传输对象，主要负责给展现层提供展示数据，&lt;code&gt;DTO&lt;/code&gt; 里应该只有值类型存在，当然根据具体情况也可存在其他的 &lt;code&gt;DTO&lt;/code&gt; 。&lt;code&gt;ViewModel&lt;/code&gt; 用于展现层传入的模型，简单的说 &lt;code&gt;DTO&lt;/code&gt; 输出，&lt;code&gt;ViewModel&lt;/code&gt; 输入。&lt;code&gt;IXXXService&lt;/code&gt; 就是应用层的方法定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Application&lt;/code&gt; 里面主要是用于 实现 &lt;code&gt;ApplicationContract&lt;/code&gt; 里的 &lt;code&gt;IXXXService&lt;/code&gt;，还有 &lt;code&gt;Entity&lt;/code&gt; 和 &lt;code&gt;DTO&lt;/code&gt; 的映射也属于该层的工作。ApplicationExtensions.cs 扩展方法是用于实现 &lt;code&gt;DI&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Presentation&lt;/code&gt; 层里目前只有一个 WebAPI。展现层的代码一般有：对传入模型的校验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本次以一个用户注册的流程为案例，来简单说明如何使用该分层架构进行项目开发。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先在 &lt;code&gt;Domain&lt;/code&gt; 中建一个 UserEntity，有 Id、Mobile、Name、Age、RegisterDateTime 属性。接着建立 IUserRepository，编写需要定义的方法，这里我定义了一个 GetByMobile(string mobile) 方法。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  [Table(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)] 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserEntity 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [Column(IsIdentity = &lt;span&gt;true&lt;/span&gt;)] &lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Mobile { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; DateTime RegisterDateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } =&lt;span&gt; DateTime.Now;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IUserRepository : IBasicRepository&amp;lt;UserEntity, Guid&amp;gt; { Task GetByMobileAsync(&lt;span&gt;string&lt;/span&gt; mobile); }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IBasicRepository 是使用了 &lt;a href=&quot;https://github.com/2881099/FreeSql&quot;&gt;FreeSql&lt;/a&gt;，你们可以自己实现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;然后在 Repository 中建 UserRepository 类，该类继承 IUserRepository 并且实现该接口的所有方法。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserRepository : GuidRepository, IUserRepository { &lt;span&gt;public&lt;/span&gt; UserRepository(IFreeSql freeSql) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(freeSql) { }

&lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Implementation of IUserRepository

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;UserEntity&amp;gt; GetByMobileAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; mobile)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.Where(u =&amp;gt; u.Mobile ==&lt;span&gt; mobile).FirstAsync();
}

&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;仓储基本好了后就是 &lt;code&gt;Application&lt;/code&gt; ，首先需要在 ApplicationContract 中建 UsesDTO，根据业务情况你也可以建 UserSimpleDTO 、UserDetailDTO。&lt;code&gt;DTO&lt;/code&gt; 里包含你需要返回的数据，我这里有 Id、Name、Mobile、Age、ProfilePhotoSrc（头像地址根据 Id 拼接，这里我用 imgage/Id.png 的格式）。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDTO { 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Mobile { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ProfilePhotoSrc { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;添加好 UserDTO 后，然后添加 IUserService.cs 接口，接着在 Application 的 Service 中添加对应的 UserService，并且 UserService 继承 IUserService。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService

{

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;

&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户注册 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;

&lt;span&gt;///&lt;/span&gt;&lt;span&gt;用户名

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;手机号

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;年龄 &lt;/span&gt;&lt;span&gt;///
&lt;/span&gt;&lt;span&gt;
Task Register(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt; mobile, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age);

List&lt;/span&gt;&amp;lt;UserDTO&amp;gt;&lt;span&gt; GetList();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserService : IUserService { &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUserRepository _userRepository;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserService(IUserRepository userRepository)
{
    _userRepository &lt;/span&gt;=&lt;span&gt; userRepository;
}

&lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Implementation of IUserService

&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户注册
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;userName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mobile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;手机&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;age&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; Register(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt; mobile, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userEnity = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userRepository.GetByMobileAsync(mobile);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userEnity != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addUserEntity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserEntity
    {
        Id &lt;/span&gt;=&lt;span&gt; Guid.NewGuid(),
        Age &lt;/span&gt;=&lt;span&gt; age,
        Name &lt;/span&gt;=&lt;span&gt; userName,
        Mobile &lt;/span&gt;=&lt;span&gt; mobile
    };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; _userRepository.InsertAsync(addUserEntity) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;UserDTO&amp;gt;&lt;span&gt; GetList()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _userRepository.Select
        .ToList().ToDTOList();
}

&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;UserServcie 是对应展现层的控制器 UserController ---&amp;gt; IUserService。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后展现层的 WebAPI 只需要注入 IUserService，就可以开心的使用了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[HttpPost] &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Post() 
{ 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; second = DateTime.Now.Second.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;bool&lt;/span&gt; isSuccess = &lt;span&gt;await&lt;/span&gt; _userService.Register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wigor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;188888888{second}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(isSuccess);
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就这样这个简单的案例就完成了，你可以参考着上面 说明 对比着去看看，当然这里有一些东西并没有体现，如 DomainServie，如果按照 DDD 来说还有 值对象、聚合、通用语言……，对于「通用语言」的话其实上面的小故事就体现出了一点。&lt;/p&gt;

&lt;p&gt;就 DDD 而言我这里还有很多东西都没有交代，今后有时间的话会慢慢的写出来。还有我也是在学习 DDD 所以有错的地方请指出，望多多包涵。&lt;/p&gt;
&lt;p&gt;在使用这套分层架构的时候碰到了许多问题，这里还要感谢老大的指导，为我解答疑问。&lt;/p&gt;
&lt;p&gt;最后附上&lt;a href=&quot;https://book.douban.com/subject/25844633/&quot;&gt;《实现领域驱动设计》&lt;/a&gt;中的一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我认为不管使用什么技术，我们的目的都是提供业务价值。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 26 Apr 2019 14:34:00 +0000</pubDate>
<dc:creator>AMortal</dc:creator>
<og:description>前言 基于 DDD 传统分层架构实现。 项目 github地址：https://github.com/WuMortal/DDDSample 这个分层架构是工作中项目正在使用的分层架构，使用了一段时间发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AMortal/p/10777050.html</dc:identifier>
</item>
<item>
<title>golang从简单的即时聊天来看架构演变 - LinkinStar</title>
<link>http://www.cnblogs.com/linkstar/p/10776994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linkstar/p/10776994.html</guid>
<description>&lt;h2 id=&quot;toc_0&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;俗话说的好，架构从来都不是一蹴而就的，没有什么架构一开始设计就是最终版本，其中需要经过很多步骤的变化，今天我们就从一个最简单的例子来看看，究竟架构这个东西是怎么变的。&lt;br/&gt;我将从一个最简单的聊天室的功能来实现，看看这样一个说起来好像很简单但的功能，我们需要考虑哪些问题。&lt;/p&gt;
&lt;p&gt;我使用golang实现，从0开始实现，需要借助的是websocket来实现即时，基础知识自己补一下，这里不做过多赘述。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;功能描述&lt;/h2&gt;
&lt;p&gt;即时聊天室包含功能（这里写出的功能假设就是产品经理告诉我们的）：&lt;br/&gt;1、所用用户能连接聊天室&lt;br/&gt;2、连接成功的用户能向聊天室发送消息&lt;br/&gt;3、所有成功连接的用户能收到聊天室的消息&lt;/p&gt;
&lt;p&gt;为了简化，我们暂定只有一个房间，因为即使要求需要多个房间和一个房间差不多；然后我们简化消息存储，我们默认也不持久化消息，因为消息的持久化就会涉及各种数据库操作还有分页查询，这里暂时不做考虑。&lt;/p&gt;
&lt;p&gt;那么你一定奇怪了，这些都没了，那整个实现还有啥难度？你大可以自己先想一想如果是你，你会怎么样去实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下文中我会用C代表客户端，S代表服务端&lt;/strong&gt;&lt;br/&gt;（本文为了展示架构的演变，如果你能想到更好的架构或者一开始就直接想到最终版本，那么证明你已经有很多的经验积累了，给大佬递茶）&lt;/p&gt;

&lt;p&gt;各个版本和测试客户端所有的代码都已经上传github，如果有需要请查看，&lt;a href=&quot;https://github.com/LinkinStars/simple-chatroom&quot; target=&quot;_blank&quot;&gt;https://github.com/LinkinStars/simple-chatroom&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;版本1&lt;/h2&gt;
&lt;p&gt;第一个版本肯定是最简单的版本，我们就笔直朝着目标走。&lt;br/&gt;我们知道websocket能实现最基本的通信。&lt;br/&gt;客户端发送消息，服务端接收消息，C -&amp;gt; S&lt;br/&gt;服务端发送消息，客户端接收消息，S -&amp;gt; C&lt;/p&gt;
&lt;p&gt;那么聊天室就是：很多C发消息给S&lt;br/&gt;S将所有收到的消息发给&lt;strong&gt;每一个&lt;/strong&gt;C&lt;br/&gt;那么我们的第一个架构就很容易想到是这样子的：&lt;/p&gt;
&lt;p&gt;我们在服务端维护一个连接池，连接池中保存了连接的用户，每当服务端收到一个消息之后，就遍历一遍连接池，将这个消息发送给所有连接池中的人。流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239460-1573879184.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;那么下面，我们用代码来实现一下&lt;br/&gt;首先定义Room里面有一个连接池&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239483-1682285957.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后我们写一个处理websocket的方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239469-1800626398.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;最后写一个群发消息，遍历连接池，发送消息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239464-1461429055.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;补全其他部分，就完成了，这就是我们第一个版本，然后我们用一个测试的html测试一下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239507-694475520.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;334&quot;/&gt;￼&lt;br/&gt;嗯，完成啦~我真棒，真简单&lt;/p&gt;
&lt;p&gt;当然不可能那么简单！！！还有很多问题！&lt;br/&gt;针对于第一个版本，那么存在的问题还有&lt;br/&gt;1、我们发现，当用户断开连接的时候，连接池里面这个连接没有被移除，所以消息发送的时候会报错，而且连接池会一直变大。&lt;br/&gt;2、用户很多，遍历发送消息是一个耗时的操作，不应该被阻塞&lt;/p&gt;
&lt;p&gt;针对这两个问题改动如下：&lt;br/&gt;1、当发送消息失败，证明连接已经断开，所以从连接池中移除连接&lt;br/&gt;2、群发消息改为gorutinue&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;版本1.1&lt;/h2&gt;
&lt;p&gt;所以V1.1修改如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239487-261955423.jpg&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;185&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239766-258414409.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;到此为止，第一个版本就到这里了，因为聪明的你应该已经发现这样设计的架构存在一个巨大的问题...&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;版本2&lt;/h2&gt;
&lt;p&gt;如果你有一定的并发编程的经验就会发现，上面版本有一个很危险的并发操作，那就是连接池。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接池的并发操作： 新的用户进来需要添加入连接池 如果用户断开连接需要移出连接池 每次发送消息需要遍历连接池&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们假设一种情况，当一个协程正在遍历连接池发送消息的时候，另外一个协程把其中一些连接删除了，还有一个协程把新的连接加进去了，这样的操作就是传说中的并发问题。&lt;/p&gt;
&lt;p&gt;而且对于websocket来说还有一个问题，就是如果并发去对同一个连接发送消息的话就会出现panic: concurrent write to websocket connection这样的异常，因为是panic所以问题就非常大了。&lt;/p&gt;
&lt;p&gt;并发问题怎么解决？很多人会说，简单，加锁就完事了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239797-1463541695.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239796-1930513782.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239823-561461111.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;加完了，搞定，这下没问题了吧。这就是版本2。因为加入了锁机制，所以并发安全保证了，但是&lt;/p&gt;
&lt;p&gt;新的问题又出现了，我们如果我们在发送消息的方法中加入延时，模拟出发送消息网络不正常的情况&lt;br/&gt;time.Sleep(time.Second * 2)&lt;br/&gt;那么你就会发现，当新的用户加入的时候，因为当前还有消息正在发送，所以导致新加入的用户没有办法获取到锁，也就无法发送消息&lt;br/&gt;那怎么办呢？&lt;/p&gt;
&lt;p&gt;然后顺便说一下，因为锁的是room在一定并发的程度上还是有可能出现异常&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239890-207689074.jpg&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;版本3&lt;/h2&gt;
&lt;p&gt;我在开发golang的时候有这样一个信念，有锁的地方一定能用channel优化，从而面向并发编程，虽然并非绝对，但是golang提供的channel很多情况下都能将锁给替换掉，从而换取出性能的提升，具体怎么做呢？&lt;br/&gt;首先我们想一下有哪些地方可以利用channel进行解耦&lt;br/&gt;1、第一次连接，我们将连接扔进一个信道中去&lt;br/&gt;2、断开连接，我们将要删除的连接扔进一个信道中去&lt;br/&gt;3、发送消息，我们每个连接对象都有一个信道，只需要将消息写入这个信道就能发送消息&lt;/p&gt;
&lt;p&gt;所以我们重新调整一下架构，图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239871-188431433.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后我们看看代码上面如何实现：&lt;/p&gt;
&lt;p&gt;首先定义一个客户端&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222239955-323723321.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;包含一个连接和一个发送消息的专用信道&lt;br/&gt;然后定义客户端的两个方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240035-1684591778.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;当从websocket中获取到信息的时候，将消息丢到chatRoom的总发送信道中去，由chatRoom去群发。&lt;br/&gt;当自己的send信道中有消息时，将消息通过websocket发送给客户端。&lt;br/&gt;同时当发送或者接收消息出现异常，将自己发送给取消注册的信道，由chatRoom去移除注册信息。&lt;/p&gt;
&lt;p&gt;然后定义聊天室&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240047-466235799.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;register用于处理注册&lt;br/&gt;unregister用于处理移除注册&lt;br/&gt;clientsPool这里更换为map，方便移除&lt;br/&gt;send是总发送消息信道，用于群发消息&lt;/p&gt;
&lt;p&gt;然后定义处理websocket方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240027-440796033.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;当前第一次来的时候就创建客户端，然后启动客户端的读取和发送方法，并且将自己发给注册信道&lt;/p&gt;
&lt;p&gt;最后最重要的就是如何去调度处理chatRoom中所有的管道，我们使用select&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240137-1368072579.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;当有注册的时候就注册，当有离开的时候就删除，当需要发送消息的时候，消息会发送给每一个client各自的send信道由它们自己发送。&lt;br/&gt;这样就成功实现了使用channel代替了原来的锁&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240162-218201191.jpg&quot; alt=&quot;&quot; width=&quot;1005&quot; height=&quot;377&quot;/&gt;￼&lt;br/&gt;当前群发消息和客户的加入退出就基本不受到影响了，随时可以加入和退出，一旦加入就会收到消息。&lt;br/&gt;一切看似很完美吧，其实还有些bug，我们创建一些客户端进行压测试试看。&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;版本3.1&lt;/h2&gt;
&lt;p&gt;编写压测代码如下，因为压测就是创建很多客户端发送消息，这里就不多做赘述了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240231-220114762.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240214-1172306722.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后会发现，测试的过程中，如果你启动一个网页版本的客户端发现，你的消息发不出去了。这是为什么呢？&lt;br/&gt;原来我们之前在处理所有管道中任务的时候当处理发送消息的时候有问题，虽然send是一个有缓冲的通道，但是当缓冲满的时候，那么就会阻塞，无法向里面再发送消息，需要等待send里面的消息被消费，但是如果send里面的消息要被消费，前提就是要轮到这个消息被发送，于是造成了循环等待，一定意义上的死锁。（有点绕，你需要理一理）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240267-770877270.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;所以我们需要修改一下代码，修复这个bug，当消息无法写入send信道的时候，那就直接将这个消息抛弃（虽然这样处理好像不太科学），因为要不就是这个用户已经断开连接，要不就是这个用户的缓冲信道已经占满了。如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240253-279504137.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;版本3.2&lt;/h2&gt;
&lt;p&gt;其实在做的过程中就发现了一些问题，一个问题同一个用户如果不停的发送消息，那么一方面是会对服务器造成压力，另一方面对于别的用户来说这是一种骚扰，所以我们需要限制用户发送消息的频率。这里为了测试方便，针对于同一个用户1秒内只能发送一条消息，这样从一定程度上也减少了并发问题的出现。&lt;/p&gt;
&lt;p&gt;改动非常简单，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899548/201904/899548-20190426222240398-1582676274.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;我们启动多个客户端定时的发送一些消息进行测试，5个客户端下每1ms发送一条消息，本机测试下来没有问题。（当然这个版本）&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;后续版本&lt;/h2&gt;
&lt;p&gt;那么到现在我们已经实际了聊天室的基本功能，对于一个最简单的聊天来说已经足够了，但是因为我们简化了很多细节，所以存在很多优化的地方，下面列举几个地方可以做后续的优化和升级。&lt;/p&gt;
&lt;p&gt;1、消息持久化，当前消息发送之后如果当时用户不在线就无法收到，这样对于用户来说其实是很难受的，所以消息需要进行持久化，而持久化就会有很多方案，保存消息的方式，以及保存消息的时间，不能因为保存消息而影响即时性。以及用户再次登录之后需要将之后保存的消息返回给用户。&lt;/p&gt;
&lt;p&gt;2、消息id，我们现在发送消息的时候是不带消息id的，但是其实作为消息本身，消息的发送需要保证幂等性，相同的消息（消息id相同）不应该发送多次，所以消息id的生成，如何保证消息不重复也是需要考虑的。&lt;/p&gt;
&lt;p&gt;3、消息不丢失，消息持久化，网络异常都有可能导致消息丢失，如何保证消息不丢失呢？&lt;/p&gt;
&lt;p&gt;4、密集型消息分发，当用户人数很多，当前会创建很多的协程去分发消息，人一多肯定就不行了，而且人一多，一台机器肯定不够，那么分布式维护连接池等等架构的调整就需要进行了。&lt;/p&gt;
&lt;p&gt;5、心跳保活，连接一段时间之后，由于网络的原因或者别的原因，可能会导致连接中断的情况出现，所以经过一段时间就需要发送一些消息保持连接。类似PING\PONG&lt;/p&gt;
&lt;p&gt;6、鉴权，这个简单，当前任何用户连上就能发送消息，理论上来说，其实需要经过鉴权之后才能发送消息。&lt;/p&gt;
&lt;p&gt;7、消息加密，现在消息都是明文传输的，这样传递消息其实是不安全的，所以加密传输消息也是后期可以考虑的，同时消息的压缩也是。&lt;/p&gt;
&lt;p&gt;这些后续的扩展就要你来思考一下了，如何去实现。设计的时候你也可以参考很多现实中已经存在的一些例子来帮助你思考。在我们实现的时候也没有借助任何的中间件，所以你可以后期考虑使用一些中间件来完成分布式等要求，如mq等。&lt;/p&gt;
&lt;p&gt;是不是看到这里发现只是简单的一个即时聊天后面的架构扩展都是非常可怕的，如果真的要做到像微信或者qq那样随意的单聊和群聊，并且解决各种并发问题还有很多路要走。&lt;/p&gt;
&lt;p&gt;如果你有一些自己的想法，也欢迎在下面留言讨论。&lt;/p&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这里其实想说明的并不是如何去设计一个IM，想要真正说明的是一个架构师如何进行演变的，其中需要考虑到哪些问题，这些问题又是如何被解决的。其中需要经历不断的测试，调整，测试，调整。还想说明的是，架构没有好和坏，只有适合与否，对于一个小的项目来说就没有必要用大架构，合适的才是最好的。&lt;/p&gt;
&lt;p&gt;最后，也肯定有人想了解一些大型的聊天im的架构，这里有几篇博客我认为写的很不错，可以参考一下。&lt;/p&gt;
&lt;p&gt;下面这两篇是对一些大型架构的说明&lt;br/&gt;&lt;a href=&quot;https://alexstocks.github.io/html/pubsub.html&quot; target=&quot;_blank&quot;&gt;https://alexstocks.github.io/html/pubsub.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://alexstocks.github.io/html/im.html&quot; target=&quot;_blank&quot;&gt;https://alexstocks.github.io/html/im.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是一些github上的项目&lt;br/&gt;&lt;a href=&quot;https://github.com/alberliu/goim&quot; target=&quot;_blank&quot;&gt;https://github.com/alberliu/goim&lt;/a&gt;&lt;br/&gt;这个项目比较简单，容易理解，文档介绍详细解释了很多概念，具体使用nsq来实现消息的转发&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Terry-Mao/goim&quot; target=&quot;_blank&quot;&gt;https://github.com/Terry-Mao/goim&lt;/a&gt;&lt;br/&gt;这个项目相对复杂，运用到的东西就比较多，需要一定的理解，同时扩展性就相对不错&lt;/p&gt;


&lt;p&gt;作者：LinkinStar&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: golang从简单的即时聊天来看架构演变&quot; href=&quot;https://www.cnblogs.com/linkstar/p/10776994.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linkstar/p/10776994.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 14:23:00 +0000</pubDate>
<dc:creator>LinkinStar</dc:creator>
<og:description>前言 俗话说的好，架构从来都不是一蹴而就的，没有什么架构一开始设计就是最终版本，其中需要经过很多步骤的变化，今天我们就从一个最简单的例子来看看，究竟架构这个东西是怎么变的。 我将从一个最简单的聊天室的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linkstar/p/10776994.html</dc:identifier>
</item>
<item>
<title>浅析 .Net Core中Json配置的自动更新 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10776845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10776845.html</guid>
<description>&lt;h2 id=&quot;pre&quot;&gt;Pre&lt;/h2&gt;
&lt;p&gt;很早在看 Jesse 的&lt;a href=&quot;http://video.jessetalk.cn/course/4&quot;&gt;Asp.net Core快速入门&lt;/a&gt;的课程的时候就了解到了在Asp .net core中,如果添加的Json配置被更改了,是支持自动重载配置的,作为一名有着严重&quot;造轮子&quot;情节的程序员,最近在折腾一个博客系统,也想造出一个这样能自动更新以Mysql为数据源的ConfigureSource,于是点开了AddJsonFile这个拓展函数的源码,发现别有洞天,蛮有意思,本篇文章就简单地聊一聊Json config的ReloadOnChange是如何实现的,在学习ReloadOnChange的过程中,我们会把Configuration也顺带撩一把😁,希望对小伙伴们有所帮助.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
                .ConfigureAppConfiguration(option =&amp;gt;
                    {
                        option.AddJsonFile(&quot;appsettings.json&quot;,optional:true,reloadOnChange:true);
                    })
                .UseStartup&amp;lt;Startup&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Asp .net core中如果配置了json数据源,把reloadOnChange属性设置为true即可实现当文件变更时自动更新配置,这篇博客我们首先从它的源码简单看一下,看完你可能还是会有点懵的,别慌,我会对这些代码进行精简,做个简单的小例子,希望能对你有所帮助.&lt;/p&gt;
&lt;h2 id=&quot;一窥源码&quot;&gt;一窥源码&lt;/h2&gt;
&lt;h3 id=&quot;addjson&quot;&gt;AddJson&lt;/h3&gt;
&lt;p&gt;首先,我们当然是从这个我们耳熟能详的扩展函数开始,它经历的演变过程如下.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder,string path,bool optional,bool reloadOnChange)
    {
      return builder.AddJsonFile((IFileProvider) null, path, optional, reloadOnChange);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传递一个null的FileProvider给另外一个重载Addjson函数.&lt;br/&gt;敲黑板,Null的FileProvider很重要,后面要考😄.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder,IFileProvider provider,string path,bool optional,bool reloadOnChange)
    {
      return builder.AddJsonFile((Action&amp;lt;JsonConfigurationSource&amp;gt;) (s =&amp;gt;
      {
        s.FileProvider = provider;
        s.Path = path;
        s.Optional = optional;
        s.ReloadOnChange = reloadOnChange;
        s.ResolveFileProvider();
      }));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把传入的参数演变成一个Action委托给&lt;code&gt;JsonConfigurationSource&lt;/code&gt;的属性赋值.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action&amp;lt;JsonConfigurationSource&amp;gt; configureSource)
    {
      return builder.Add&amp;lt;JsonConfigurationSource&amp;gt;(configureSource);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用的builder.add(action)方法.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static IConfigurationBuilder Add&amp;lt;TSource&amp;gt;(this IConfigurationBuilder builder,Action&amp;lt;TSource&amp;gt; configureSource)where TSource : IConfigurationSource, new()
    {
      TSource source = new TSource();
      if (configureSource != null)
        configureSource(source);
      return builder.Add((IConfigurationSource) source);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Add方法里,创建了一个Source实例,也就是JsonConfigurationSource实例,然后把这个实例传为刚刚的委托,这样一来,我们在最外面传入的&lt;code&gt;&quot;appsettings.json&quot;,optional:true,reloadOnChange:true&lt;/code&gt;参数就作用到这个示例上了.&lt;br/&gt;最终,这个实例添加到builder中.那么builder又是什么?它能干什么?&lt;/p&gt;
&lt;h3 id=&quot;configurationbuild&quot;&gt;ConfigurationBuild&lt;/h3&gt;
&lt;p&gt;前面提及的builder默认情况下是&lt;code&gt;ConfigurationBuilder&lt;/code&gt;,我对它的进行了简化,关键代码如下.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ConfigurationBuilder : IConfigurationBuilder
    {
        public IList&amp;lt;IConfigurationSource&amp;gt; Sources { get; } = new List&amp;lt;IConfigurationSource&amp;gt;();

        public IConfigurationBuilder Add(IConfigurationSource source)
        {
            Sources.Add(source);
            return this;
        }

        public IConfigurationRoot Build()
        {
            var providers = new List&amp;lt;IConfigurationProvider&amp;gt;();
            foreach (var source in Sources)
            {
                var provider = source.Build(this);
                providers.Add(provider);
            }
            return new ConfigurationRoot(providers);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,这个builder中有个集合类型的Sources,这个Sources可以保存任何实现了&lt;code&gt;IConfigurationSource&lt;/code&gt;的Source,前面聊到的&lt;code&gt;JsonConfigurationSource&lt;/code&gt;就是实现了这个接口,常用的还有&lt;code&gt;MemoryConfigurationSource&lt;/code&gt;,&lt;code&gt;XmlConfigureSource&lt;/code&gt;,&lt;code&gt;CommandLineConfigurationSource&lt;/code&gt;等.&lt;/p&gt;
&lt;p&gt;另外,它有一个很重要的build方法,这个build方法在&lt;code&gt;WebHostBuilder&lt;/code&gt;方法执行&lt;code&gt;build&lt;/code&gt;的时候也被调用,不要问我&lt;code&gt;WebHostBuilder.builder&lt;/code&gt;方法什么执行的😂.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ConfigureBuilder的方法里面就调用了每个Source的Builder方法,我们刚刚传入的是一个&lt;code&gt;JsonConfigurationSource&lt;/code&gt;,所以我们有必要看看JsonSource的builder做了什么.&lt;br/&gt;这里是不是被这些builder绕哭了? 别慌,下一篇文章中我会讲解如何自定义一个ConfigureSoure,会把Congigure系列类UML类图整理一下,应该会清晰很多.&lt;/p&gt;
&lt;h3 id=&quot;jsonconfigurationsource&quot;&gt;JsonConfigurationSource&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class JsonConfigurationSource : FileConfigurationSource
    {
        public override IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            EnsureDefaults(builder);
            return new JsonConfigurationProvider(this);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是&lt;code&gt;JsonConfigurationSource&lt;/code&gt;的所有代码,未精简,它只实现了一个Build方法,在Build内,EnsureDefaults被调用,可别小看它,之前那个空的FileProvider在这里被赋值了.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public void EnsureDefaults(IConfigurationBuilder builder)
        {
            FileProvider = FileProvider ?? builder.GetFileProvider();
        }
        public static IFileProvider GetFileProvider(this IConfigurationBuilder builder)
        {
            return new PhysicalFileProvider(AppContext.BaseDirectory ?? string.Empty);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这个FileProvider默认情况下就是&lt;code&gt;PhysicalFileProvider&lt;/code&gt;,为什么对这个&lt;code&gt;FileProvider&lt;/code&gt;如此宠幸让我花如此大的伏笔要强调它呢?往下看.&lt;/p&gt;
&lt;h3 id=&quot;jsonconfigurationprovider-fileconfigurationprovider&quot;&gt;JsonConfigurationProvider &amp;amp;&amp;amp; FileConfigurationProvider&lt;/h3&gt;
&lt;p&gt;在JsonConfigurationSource的build方法内,返回的是一个JsonConfigurationProvider实例,所以直觉告诉我,在它的构造函数内必有猫腻😕.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class JsonConfigurationProvider : FileConfigurationProvider
    {
       
        public JsonConfigurationProvider(JsonConfigurationSource source) : base(source) { }

      
        public override void Load(Stream stream)
        {
            try {
                Data = JsonConfigurationFileParser.Parse(stream);
            } catch (JsonReaderException e)
            {
                throw new FormatException(Resources.Error_JSONParseError, e);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看不出什么的代码,事出反常必有妖~~&lt;br/&gt;看看base的构造函数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public FileConfigurationProvider(FileConfigurationSource source)
        {
            Source = source;

            if (Source.ReloadOnChange &amp;amp;&amp;amp; Source.FileProvider != null)
            {
                _changeTokenRegistration = ChangeToken.OnChange(
                    () =&amp;gt; Source.FileProvider.Watch(Source.Path),
                    () =&amp;gt; {
                        Thread.Sleep(Source.ReloadDelay);
                        Load(reload: true);
                    });
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真是个天才,问题就在这个构造函数里,它构造函数调用了一个&lt;code&gt;ChangeToken.OnChange&lt;/code&gt;方法,这是实现ReloadOnChange的关键,如果你点到这里还没有关掉,恭喜,好戏开始了.&lt;/p&gt;
&lt;h2 id=&quot;reloadonchange&quot;&gt;ReloadOnChange&lt;/h2&gt;
&lt;p&gt;Talk is cheap. Show me the code (屁话少说,放&lt;code&gt;码&lt;/code&gt;过来).&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static class ChangeToken
    {
        public static ChangeTokenRegistration&amp;lt;Action&amp;gt; OnChange(Func&amp;lt;IChangeToken&amp;gt; changeTokenProducer, Action changeTokenConsumer)
        {
            return new ChangeTokenRegistration&amp;lt;Action&amp;gt;(changeTokenProducer, callback =&amp;gt; callback(), changeTokenConsumer);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OnChange方法里,先不管什么func,action,就看看这两个参数的名称,producer,consumer,生产者,消费者,不知道看到这个关键词想到的是什么,反正我想到的是小学时学习食物链时的🐍与🐀.&lt;/p&gt;
&lt;p&gt;那么我们来看看这里的🐍是什么,🐀又是什么,还得回到&lt;code&gt;FileConfigurationProvider&lt;/code&gt;的构造函数.&lt;/p&gt;
&lt;p&gt;可以看到生产者🐀是:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;() =&amp;gt; Source.FileProvider.Watch(Source.Path)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者🐍是:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
() =&amp;gt; {
    Thread.Sleep(Source.ReloadDelay);
    Load(reload: true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想一下,一旦有一条🐀跑出来,就立马被🐍吃了,&lt;/p&gt;
&lt;p&gt;那我们这里也一样,一旦有FileProvider.Watch返回了什么东西,就会发生Load()事件来重新加载数据.&lt;/p&gt;
&lt;p&gt;🐍与🐀好理解,可是代码就没那么好理解了,我们通过&lt;code&gt;OnChange&lt;/code&gt;的第一个参数&lt;code&gt;Func&amp;lt;IChangeToken&amp;gt; changeTokenProducer&lt;/code&gt;方法知道,这里的🐀,其实是&lt;code&gt;IChangeToken&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;ichangetoken&quot;&gt;IChangeToken&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IChangeToken
    {
        bool HasChanged { get; }

        bool ActiveChangeCallbacks { get; }

        IDisposable RegisterChangeCallback(Action&amp;lt;object&amp;gt; callback, object state);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IChangeToken的重点在于里面有个RegisterChangeCallback方法,🐍吃🐀的这件事,就发生在这回调方法里面.&lt;br/&gt;我们来做个🐍吃🐀的实验.&lt;/p&gt;
&lt;h2 id=&quot;实验1&quot;&gt;实验1&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static void Main()
        {
            //定义一个C:\Users\liuzh\MyBox\TestSpace目录的FileProvider
            var phyFileProvider = new PhysicalFileProvider(&quot;C:\\Users\\liuzh\\MyBox\\TestSpace&quot;);

            //让这个Provider开始监听这个目录下的所有文件
            var changeToken = phyFileProvider.Watch(&quot;*.*&quot;);

            //注册🐍吃🐀这件事到回调函数
            changeToken.RegisterChangeCallback(_=&amp;gt; { Console.WriteLine(&quot;老鼠被蛇吃&quot;); }, new object());

            //添加一个文件到目录
            AddFileToPath();

            Console.ReadKey();

        }

        static void AddFileToPath()
        {
            Console.WriteLine(&quot;老鼠出洞了&quot;);
            File.Create(&quot;C:\\Users\\liuzh\\MyBox\\TestSpace\\老鼠出洞了.txt&quot;).Dispose();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是运行结果&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/MiniConfiguration/master/Pic/test1.gif&quot; alt=&quot;Result&quot;/&gt;&lt;br/&gt;可以看到,一旦在监听的目录下创建文件,立即触发了执行回调函数,但是如果我们继续手动地更改(复制)监听目录中的文件,回调函数就不再执行了.&lt;/p&gt;
&lt;p&gt;这是因为changeToken监听到文件变更并触发回调函数后,这个changeToken的使命也就完成了,要想保持一直监听,那么我们就在在回调函数中重新获取token,并给新的token的回调函数注册通用的事件,这样就能保持一直监听下去了.&lt;br/&gt;这也就是ChangeToken.Onchange所作的事情,我们看一下源码.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;   public static class ChangeToken
    {
        public static ChangeTokenRegistration&amp;lt;Action&amp;gt; OnChange(Func&amp;lt;IChangeToken&amp;gt; changeTokenProducer, Action changeTokenConsumer)
        {
            return new ChangeTokenRegistration&amp;lt;Action&amp;gt;(changeTokenProducer, callback =&amp;gt; callback(), changeTokenConsumer);
        }
    }
    public class ChangeTokenRegistration&amp;lt;TAction&amp;gt;
    {
        private readonly Func&amp;lt;IChangeToken&amp;gt; _changeTokenProducer;
        private readonly Action&amp;lt;TAction&amp;gt; _changeTokenConsumer;
        private readonly TAction _state;

        public ChangeTokenRegistration(Func&amp;lt;IChangeToken&amp;gt; changeTokenProducer, Action&amp;lt;TAction&amp;gt; changeTokenConsumer, TAction state)
        {
            _changeTokenProducer = changeTokenProducer;
            _changeTokenConsumer = changeTokenConsumer;
            _state = state;

            var token = changeTokenProducer();

            RegisterChangeTokenCallback(token);
        }

        private void RegisterChangeTokenCallback(IChangeToken token)
        {
            token.RegisterChangeCallback(_ =&amp;gt; OnChangeTokenFired(), this);
        }

        private void OnChangeTokenFired()
        {
            var token = _changeTokenProducer();

            try
            {
                _changeTokenConsumer(_state);
            }
            finally
            {
                // We always want to ensure the callback is registered
                RegisterChangeTokenCallback(token);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说,就是给token注册了一个&lt;code&gt;OnChangeTokenFired&lt;/code&gt;的回调函数,仔细看看&lt;code&gt;OnChangeTokenFired&lt;/code&gt;里做了什么,总体来说三步.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取一个新的token.&lt;/li&gt;
&lt;li&gt;调用消费者进行消费.&lt;/li&gt;
&lt;li&gt;给新获取的token再次注册一个&lt;code&gt;OnChangeTokenFired&lt;/code&gt;的回调函数.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此周而复始~~&lt;/p&gt;
&lt;h3 id=&quot;实验2&quot;&gt;实验2&lt;/h3&gt;
&lt;p&gt;既然知道了OnChange的工作方式,那么我们把实验1的代码修改一下.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        static void Main()
        {
            var phyFileProvider = new PhysicalFileProvider(&quot;C:\\Users\\liuzh\\MyBox\\TestSpace&quot;);
            ChangeToken.OnChange(() =&amp;gt; phyFileProvider.Watch(&quot;*.*&quot;),
                () =&amp;gt; { Console.WriteLine(&quot;老鼠被蛇吃&quot;); });
            Console.ReadKey();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/MiniConfiguration/master/Pic/test2.gif&quot; alt=&quot;Result&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,只要被监控的目录发生了文件变化,不管是新建文件,还是修改了文件内的内容,都会触发回调函数,其实JsonConfig中,这个回调函数就是Load(),它负责重新加载数据,可也就是为什么Asp .net core中如果把ReloadOnchang设置为true后,Json的配置一旦更新,配置就会自动重载.&lt;/p&gt;
&lt;h2 id=&quot;physicalfileswatcher&quot;&gt;PhysicalFilesWatcher&lt;/h2&gt;
&lt;p&gt;那么,为什么文件一旦变化,就会触发ChangeToken的回调函数呢? 其实&lt;code&gt;PhysicalFileProvider&lt;/code&gt;中调用了&lt;code&gt;PhysicalFilesWatcher&lt;/code&gt;对文件系统进行监视,观察PhysicalFilesWatcher的构造函数,可以看到&lt;code&gt;PhysicalFilesWatcher&lt;/code&gt;需要传入&lt;code&gt;FileSystemWatcher&lt;/code&gt;,&lt;code&gt;FileSystemWatcher&lt;/code&gt;是&lt;code&gt;system.io&lt;/code&gt;下的底层IO类,在构造函数中给这个Watcher的Created,Changed,Renamed,Deleted注册EventHandler事件,最终,在这些EventHandler中会调用ChangToken的回调函数,所以文件系统一旦发生变更就会触发回调函数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public PhysicalFilesWatcher(string root,FileSystemWatcher fileSystemWatcher,bool pollForChanges,ExclusionFilters filters)
    {
      this._root = root;
      this._fileWatcher = fileSystemWatcher;
      this._fileWatcher.IncludeSubdirectories = true;
      this._fileWatcher.Created += new FileSystemEventHandler(this.OnChanged);
      this._fileWatcher.Changed += new FileSystemEventHandler(this.OnChanged);
      this._fileWatcher.Renamed += new RenamedEventHandler(this.OnRenamed);
      this._fileWatcher.Deleted += new FileSystemEventHandler(this.OnChanged);
      this._fileWatcher.Error += new ErrorEventHandler(this.OnError);
      this.PollForChanges = pollForChanges;
      this._filters = filters;
      this.PollingChangeTokens = new ConcurrentDictionary&amp;lt;IPollingChangeToken, IPollingChangeToken&amp;gt;();
      this._timerFactory = (Func&amp;lt;Timer&amp;gt;) (() =&amp;gt; NonCapturingTimer.Create(new TimerCallback(PhysicalFilesWatcher.RaiseChangeEvents), (object) this.PollingChangeTokens, TimeSpan.Zero, PhysicalFilesWatcher.DefaultPollingInterval));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;蒋金楠老师有一篇优秀的文章介绍&lt;code&gt;FileProvider&lt;/code&gt;,有兴趣的可以看一下&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-file-provider-02.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/artech/p/net-core-file-provider-02.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;如果你和我一样,对源码感兴趣,可以从官方的&lt;code&gt;aspnet/Extensions&lt;/code&gt;中下载源码研究:&lt;a href=&quot;https://github.com/aspnet/Extensions&quot; class=&quot;uri&quot;&gt;https://github.com/aspnet/Extensions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在下一篇文章中,我会讲解如何自定义一个以Mysql为数据源的ConfigureSoure,并实现自动更新功能,同时还会整理Configure相关类的UML类图,有兴趣的可以关注我以便第一时间收到下篇文章.&lt;br/&gt;本文章涉及的代码地址:&lt;a href=&quot;https://github.com/liuzhenyulive/MiniConfiguration&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/MiniConfiguration&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 13:52:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>Pre 很早在看 Jesse 的 'Asp.net Core快速入门' 的课程的时候就了解到了在Asp .net core中,如果添加的Json配置被更改了,是支持自动重载配置的,作为一名有着严重'造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10776845.html</dc:identifier>
</item>
<item>
<title>聚焦“云开发圆桌论坛”，大前端Serverless大佬们释放了这些讯号！ - 腾讯云开发TCB</title>
<link>http://www.cnblogs.com/CloudBase/p/10776728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudBase/p/10776728.html</guid>
<description>&lt;p&gt;&lt;strong&gt;4月14日，由云加社区举办的TVP&amp;amp;腾讯云技术交流日云开发专场，暨&quot;腾讯云-云开发圆桌论坛&quot;在北京、深圳两地同步举行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当天下午，一场主题为&quot;&lt;strong&gt;基于大前端和node开发模式下的Serverless发展前景探讨&lt;/strong&gt;&quot;的高峰对话成为全场焦点，包括猫眼娱乐商业平台前端负责人王克淼、京东Taro团队负责人李伟涛、转转前端公共支撑负责人王澍、Laybox合伙人李明、Node js CTC成员张秋怡等26位前端领域大佬参与交流，北京和深圳两地的主持人则分别由云开发高级产品经理王斌、云开发高级工程师李成熙担任。&lt;/p&gt;
&lt;p&gt;在会议中，各位技术领域的专业人士围绕&lt;strong&gt;大前端ser&lt;/strong&gt;&lt;strong&gt;verless的技术价值&lt;/strong&gt;，&lt;strong&gt;传统模式向Serverless模式的转变阻力&lt;/strong&gt;，以及Serverless技术趋势下对人及技术管理的新诉求，进行了深刻的讨论和探究。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c890218d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c890218d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;strong&gt;『 Serverless对大前端技术演进价值巨大，助力前端向全栈高效开发转变 』&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;前端的技术近几年发展非常迅速。我们可以从两个维度去看前端技术的发展——&lt;strong&gt;一个是前端复杂度，一个应用的广度&lt;/strong&gt;。单看复杂度，从HTML、JS、CSS的阶段向DOM操作框架，从DOM到MVC，再到MVVM框架，再到现在assembly技术标准的出现，让前端工程师开发复杂度应用的能力不断提高。而从广度来看，前端也一直在拓展，从浏览器到服务器端，再到移动端，小程序，前端边界在不断扩大。然而在这个发展的过程中，有一个很深的隔离，这个隔离本质上就是物理隔离，比如前端和后端，存在手机和服务器之间的物理隔离。而serverless，函数即服务对前端来说，后端服务是一个函数，函数就是前端代码的一部分，后端服务和前端完全融合在一种代码体系里去。从这个层面来说，&lt;strong&gt;severless打破了&lt;/strong&gt;&lt;strong&gt;物理隔离，帮助前端真正&lt;/strong&gt;&lt;strong&gt;做到了全栈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云开发，是腾讯云和微信团队联合开发的，集成于小程序开发者工具（IDE）的原生serverless云服务。&lt;/strong&gt;它进一步降低小程序开发门槛，让前端可以包办小程序开发，提升开发效率，像调用API一样便捷，用户其实完全不用担心哪些是服务器的逻辑，他们都去向了哪里，只需要像前端函数一样去理解就可以。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88d34ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88d34ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;411&quot;/&gt;&lt;/p&gt;
&lt;p&gt;腾讯云TVP、Layabox合伙人李明同时也提到，&lt;strong&gt;在传统开发模式下前后端、运营沟通成本非常高，Serverless确实是未来研发团队都应该考虑的一个新的选择方向&lt;/strong&gt;。但自行探索或许成本比较高。因为如果把这个事情交给前端开发，对于他们来说有学习运维和后端的成本；若交给后端开发，对于他们来说其实又没有任何关系。如果交给云厂商呢？这或许是一个不错的选择。因为这样的话，大家都可以专注于自己的业务，也不需要花费大量时间和精力学习额外知识，从而提高产品研发团队的整体效率。&lt;/p&gt;
&lt;p&gt;猫眼资深工程师高英健认为，&lt;strong&gt;Serverless的支持对于前端日常业务的开发已非常重要，让前端开发可以独立去支持一些业务需求&lt;/strong&gt;。比如猫眼在运营工具的实际开发过程中，由于项目主要用于配置日常运营活动，与后端核心逻辑没有任何关系，后端也不想主动配合。这种情况下借助腾讯云推出的大前端Serverless产品——云开发，让前端通过调用API的方式实现后端业务逻辑，对于前端开发效率有很大的改善，逻辑、数据、资源均由前端工程师包办，大大降低了项目的开发门槛，提升开发效率。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88e0b3eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88e0b3eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;577&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大前端Serverless，让前端开发者可以更轻量地做后端的事情，大大提升开发效率，这无论是对企业，还是对市场，都是一件好事。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;&lt;strong&gt;『 从传统模式到Serverless模式，目前仍存在难点 』&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;腾讯云TVP、友浩达科技CTO张善友认为，&lt;strong&gt;Serverless需要统一的行业标准&lt;/strong&gt;。目前Serverless服务厂商众多，但各自都是独立的玩法，目前若想从A服务商迁移到B服务商，成本高、难度大。若一套Serverless代码能够在腾讯、阿里、微软、亚马逊等云服务上都能运行，足以降低迁移成本，有效降低客户使用Serverless服务前的顾虑。&lt;/p&gt;
&lt;p&gt;腾讯云TVP、北京竹间科技技术负责人朱峰认为，从重构的角度来看，Serverless无法做到真正的技术重构，后端仍然是冗杂的面向过程函数不便于管理。&lt;strong&gt;如果能解决重构的问题，才能真正地降低使用门槛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88eb506c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c88eb506c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;数据安全&lt;/strong&gt;仍然是大部分嘉宾的一个主要关注点，而这个问题的本质是公有云数据安全的问题。有意思的是，&lt;strong&gt;云开发模式下，每个用户的环境资源是独立的，也即是私有的，并且云开发提供与自有数据库打通的能力&lt;/strong&gt;。这样，用户的数据都存在用户自己的云开发环境资源下面，一定层面保障了用户的数据安全与稳定性。&lt;/p&gt;
&lt;p&gt;此外，从传统模式到Serverless模式的转变，阻力还有错误排查问题，无法跨云等问题，这也导致很多业务无法直接从传统模式向serverless模式迁移。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-2&quot;&gt;&lt;strong&gt;『 serverless开发模式下，我们开发者或者开发团队要做什么样的改变？&lt;/strong&gt; &lt;strong&gt;』&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;即速应用后台开发工程师提到，在Serverless下，前端和后台结合的话，他们操作后台给出的数据，包括创造数据，改数据等，这完全是数据层面的操作，而不仅仅是UI层面，不只是UI的性能问题；同时还要考虑后端的一些数据的性能问题，还有特殊的后端需要使用的模式，比如队列、定制任务。这就有可能分化成两个后台，有的做serverless服务，有的做serverless工具和技术建设。&lt;/p&gt;
&lt;p&gt;Node js核心成员张秋怡说到，&lt;strong&gt;未来&lt;/strong&gt;&lt;strong&gt;前后端将趋近于系统化、全栈式，按照这种发展模式势必会带来思维的转变，前端需要考虑后端，后端需要考虑前端，慢慢形成一个完整的产品开发模式&lt;/strong&gt;，Serverless的出现则很好的顺应了这种新开发模式的发展，我们需要做好准备迎接这一大趋势。&lt;/p&gt;
&lt;p&gt;凹凸实验室核心成员马剑从团队分工角度提到，这些年在组建团队的时候，我们前端做一些事，后端用node来解决很笼统的场景。但是再往后发展，我们发现过去前端同学做node，或者node的同学做前端，其实都是不专业的。所以发展到今天，我们团队内部也是细分了UI开发的一波人，专业做后端服务的一波人，顺着这个思路往下发展，大前端Serverless一定也是会继续拆分的，即使Serverless做得再好，一定会拆分出来一波人专业在搞，可能另外一波人还是搞业务开发了。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c89101ea3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a2a90c89101ea3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1080&quot; data-height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整整一个下午，30多位嘉宾围绕大前端Serverless各抒己见，同时也为腾讯云【云开发】提出丰富的产品优化建议。&lt;strong&gt;在未来，腾讯云-云开发团队将与大家一起，共同探索和推进大前端Serverless的发展，为大家提供更简便，更好用的开发工具。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 13:28:00 +0000</pubDate>
<dc:creator>腾讯云开发TCB</dc:creator>
<og:description>4月14日，由云加社区举办的TVP&amp;腾讯云技术交流日云开发专场，暨&quot;腾讯云-云开发圆桌论坛&quot;在北京、深圳两地同步举行。 当天下午，一场主题为&quot;基于大前端和node</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudBase/p/10776728.html</dc:identifier>
</item>
<item>
<title>.NET Core 迁移躺坑记续集--Win下莫名其妙的超时 - LeoLaw</title>
<link>http://www.cnblogs.com/leolaw/p/10776451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolaw/p/10776451.html</guid>
<description>&lt;p&gt;继&lt;a href=&quot;https://www.cnblogs.com/leolaw/p/10740678.html&quot; target=&quot;_blank&quot;&gt;上一集&lt;/a&gt;里说到遇到的各种问题并且弄了n个解决方案之后，特别是对于问题4的解决方案对于切换了HttpClientFactory&lt;/p&gt;
&lt;p&gt;我用了你家netcore 2.1下专门解决之前HttpClient口病已久的灵丹妙药了，信心满满的上线…..然后挂了，该超时的继续超&lt;/p&gt;

&lt;p&gt;其中这个问题比较诡异在于超时的主要集中在两台机器上（俗称两兄弟了）&lt;/p&gt;
&lt;p&gt;由于不明真相到底是什么导致的，而且接下来又要到五一了，为了欢度五一这么一个伟大艰巨的任务，为了证明迁移core的伟大光荣正确，怎么也要解决掉这个问题&lt;/p&gt;

&lt;h2&gt;步骤一，先确认问题的复现&lt;/h2&gt;
&lt;p&gt;首先直接放弃在任何测试环境复现的想法，因为之前在测试HttpClientFactory的时候已经在测试环境里进行过多批次各种场景的压测，无论是长时低压，长时高压，短时高压都进行过都没发生过&lt;/p&gt;
&lt;p&gt;而且就算是线上也就2台机器有问题&lt;/p&gt;
&lt;p&gt;所以让运维提供ip，指向到这台服务器后，使用superbenchmarker对其进行压测&lt;/p&gt;
&lt;p&gt;压测中发现这个….很稳定&lt;/p&gt;
&lt;p&gt;稳定5分钟，挂个2分钟&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203853538-638162057.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203853976-475635554.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;422&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;绿色线为RPS每秒请求数，紫色是请求响应时间，发现绿色线稳定5分钟后，会突然没有了（请求卡住了），等个2分钟后突然紫色线突然冒个刺（等待已久的请求终于响应了）然后绿色线又起来了（请求恢复正常）&lt;/p&gt;

&lt;h2&gt;步骤二，确认超时的时候发生了什么&lt;/h2&gt;
&lt;p&gt;第二天，开好压测，因为确认了每5分钟后会超时2分钟这个时间，等着个四分钟左右跑到运维那坐着，看下超时期间到底发生了什么。&lt;/p&gt;
&lt;p&gt;然后我就绝望了。&lt;/p&gt;
&lt;p&gt;常规的比如CPU/内存之类一切正常，考虑到HttpClient有过的历史缺陷比如 &lt;a href=&quot;https://www.infoq.cn/article/2016/09/HttpClient&quot; target=&quot;_blank&quot;&gt;.NET HttpClient 的缺陷和文档错误让开发人员倍感沮丧&lt;/a&gt; 也特意关注过端口号之类的，也一切正常。&lt;/p&gt;

&lt;h2&gt;步骤三，迁移前的Framework怎么没有问题，是Core的锅吗&lt;/h2&gt;
&lt;p&gt;为了证明这个事情，准备了2个console&lt;/p&gt;
&lt;p&gt;一个Framework下使用静态的HttpClient每100ms调用某外部接口&lt;/p&gt;
&lt;p&gt;一个Core下使用HttpClientFactory也是每100ms调用某外部接口&lt;/p&gt;
&lt;p&gt;这个结果让我绝望的平方&lt;/p&gt;
&lt;p&gt;结果显示Framework下一切正常，只有Core有问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203854274-783580644.png&quot;&gt;&lt;img title=&quot;企业微信截图_15562571114243&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203854572-1359104045.png&quot; alt=&quot;企业微信截图_15562571114243&quot; width=&quot;403&quot; height=&quot;57&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后续在补充了几个不同姿势的Core版本的console来测试&lt;/p&gt;
&lt;p&gt;包括&lt;/p&gt;
&lt;p&gt;  &lt;em&gt;1.将SetHandlerLifetime设置为InfiniteTimeSpan&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2.不用HttpClientFactory直接new一个静态HttpClient（和Framework一摸一样的姿势）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;依然都会又超时的问题&lt;/p&gt;

&lt;p&gt;由于网上google翻了个遍没找到类似的说法&lt;/p&gt;
&lt;p&gt;此时的内心想法:难道我要开历史的倒车了么（难道只有我有问题么？还是说我哪里姿势有问题？别人怎么都好好的？难道别人都是假的？网上吹的那么厉害全都是瞎BB？….各种草泥马奔腾而过）&lt;/p&gt;

&lt;h2&gt;柳暗花明，绝望的时候找下组织吧&lt;/h2&gt;
&lt;p&gt;然后就在某微信群里发出求救信号&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203854888-458443713.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203855365-1548833670.png&quot; alt=&quot;image&quot; width=&quot;335&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后得到一个看起来有点靠谱的方案&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203856161-61085579.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203856371-1329109110.png&quot; alt=&quot;image&quot; width=&quot;327&quot; height=&quot;192&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（截图里的内容,）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203856597-1515605439.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203856809-211023402.png&quot; alt=&quot;image&quot; width=&quot;446&quot; height=&quot;130&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文字版描述：创建HttpClient的时候设置UseProxy为false,此值默认值是true&lt;/p&gt;

&lt;p&gt;然后使用这个改造后在打包一个console进行测试，这次结果终于看到了希望的曙光了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203857001-261002852.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203857373-1465636189.png&quot; alt=&quot;image&quot; width=&quot;351&quot; height=&quot;397&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于根据之前的规律每5分钟之后会挂2分钟，能活个10分钟基本证明修改有效&lt;/p&gt;

&lt;p&gt;跟着这个将站点都修改了UseProxy=false打包上去，进行压测&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203857623-516693707.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203858049-239769613.png&quot; alt=&quot;image&quot; width=&quot;503&quot; height=&quot;237&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;跑了好几个小时，目前为止并没有发生再超时的问题了，现在基本实锤问题解决了&lt;/p&gt;

&lt;h2&gt;最后总结&lt;/h2&gt;
&lt;p&gt;无论你是new一个静态HttpClient还是通过HttpClientFactory去创建HttpClient,记得要将&lt;span&gt;&lt;strong&gt;UseProxy=false&lt;/strong&gt;&lt;/span&gt;（当然，除非你要用proxy那就没辙）&lt;/p&gt;

&lt;p&gt;当然，最后有几个疑点我也不是太清楚&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;p&gt;为什么线上就2台机器恒定有问题？&lt;/p&gt;
&lt;p&gt;而其他机器则比较稳定（实际线上服务器接近30台）？&lt;/p&gt;
&lt;p&gt;为什么是稳5分钟后超时2分钟（这个5和这个2是哪里设置的）？&lt;/p&gt;
&lt;p&gt;UseProxy在这里又是起到了什么样的作用？&lt;/p&gt;

&lt;p&gt;群里小伙伴给了这么一个解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203858284-1730748826.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203858478-1778949742.png&quot; alt=&quot;image&quot; width=&quot;367&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然而我依然不是太理解T-T&lt;/p&gt;
&lt;p&gt;.Net世界真是博大精深…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203858787-2072759475.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/658343/201904/658343-20190426203859288-1672952215.png&quot; alt=&quot;image&quot; width=&quot;133&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 12:39:00 +0000</pubDate>
<dc:creator>LeoLaw</dc:creator>
<og:description>继上一集里说到遇到的各种问题并且弄了n个解决方案之后，特别是对于问题4的解决方案对于切换了HttpClientFactory 我用了你家netcore 2.1下专门解决之前HttpClient口病已久</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolaw/p/10776451.html</dc:identifier>
</item>
<item>
<title>我的创业故事（一）团队成立 - kurryluo</title>
<link>http://www.cnblogs.com/kurryluo/p/10776347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kurryluo/p/10776347.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5164161-a3f96cd6753fb8ed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;团队&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天是 4 月 25 日，对我来说比较重要。&lt;/p&gt;
&lt;p&gt;我是一个比较有仪式感的人，每到一个时间节点，总要总结一些什么。&lt;/p&gt;
&lt;p&gt;于是把之前想做的一个事情：「好好思考，仔细总结」，提上日程。&lt;/p&gt;
&lt;p&gt;2016 年 4 月 25 日，是我和麦，还有飞、蓥、胜、泉、臻、皇、强、凯、从，总共 11 个人成立创业团队的日子。&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;01&lt;/h3&gt;
&lt;p&gt;到现在已经整整三年时间了，记忆还是那么鲜活。&lt;/p&gt;
&lt;p&gt;2016 年 3 月初的厦门，天气有些许凉意。我那年初找了一个做义工换食宿的工作。&lt;/p&gt;
&lt;p&gt;正在哈尔滨一家为政府做管理系统的公司工作的麦给远在厦门的我打了一通电话。&lt;/p&gt;
&lt;p&gt;麦是我参加数学建模比赛的时候认识的，因为这个比赛需要三天三夜的持续奋战，很多同学坚持不下来，或者用现在的话来说，比较佛系。有一天晚上，只有我跟麦还在埋头苦干，所以对彼此的印象比较深刻。&lt;/p&gt;
&lt;p&gt;打建模比赛认识后，经常在图书馆，食堂都能碰到身材矮小，行为稍许怪异的麦，说实话，一开始我并不欣赏他。&lt;/p&gt;
&lt;p&gt;直到又一次比赛，我找不到队友，想拉麦一起参加。他考虑再三后，答应我一起参加。但是在这种情况下，他把题目看得很认真，是一个负责的队员，连我这个队长都有些自愧不如。&lt;/p&gt;
&lt;p&gt;虽然那个比赛中途放弃了，在后来的交流中，我发现麦这个人经常说一些大话，但踏实肯干，是一个值得深交的朋友。&lt;/p&gt;
&lt;p&gt;“我最近发现大数据很火，特别是信息挖掘，比如大数据魔镜，他们做了一个帮助人们分析数据并且把结果可视化的东西，不用下载软件，在线就能用”，麦激动地说。&lt;/p&gt;
&lt;p&gt;一个月的时间在厦门玩得很开心，接到麦的电话有些意外。经过长达一个小时的沟通，我大致明白他想表达的。他想让我参与创业项目，但具体做什么当时还没有一个准确的目标。&lt;/p&gt;
&lt;p&gt;因为麦之前考清华没有考上，在获取信息方面遭遇了一些困难。于是想做一个考研信息服务平台，具体做什么，怎么做，我们谁都不知道。&lt;/p&gt;
&lt;p&gt;「创业」 二字是我带给麦的礼物。在 15 年冬天的一次朋友聚会上，二两二锅头下肚后，我和麦煮酒论剑，挥斥方遒，谈论着未来。&lt;/p&gt;
&lt;p&gt;“我会创业，时间大概会在我正式毕业两三年后，如果有机会我想试试”，我说。&lt;/p&gt;
&lt;p&gt;麦当时对创业没有什么概念，他的梦想是从政，北京正是一个政治中心，考去北京是他的一个梦想。&lt;/p&gt;
&lt;p&gt;我想创业的目的很简单，想挣钱，给家里减轻负担，实现阶级的跃升。&lt;/p&gt;
&lt;p&gt;创业很难，风险也很高，但是初生牛犊不怕虎，光脚的不怕穿鞋的，所以当时的我充满理想（现在也是，哈哈）。&lt;/p&gt;
&lt;p&gt;吃完饭后，麦和我站在学校 10 号宿舍楼下，旁边站着的是他在考研期间谈的对象——泉。&lt;/p&gt;
&lt;p&gt;漆黑的夜色中，我们三个吐着白气，做了一个小小的约定：未来有机会要凑到一起做点事情。&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;02&lt;/h3&gt;
&lt;p&gt;没有想到过了半年，麦和泉的公众号做起来了，名字很长很长，叫做：「环球数据英汉互译中心」。&lt;/p&gt;
&lt;p&gt;因为他们双双考过研，之前看过一些盗版视频，包括我给麦的考研数学老师 zhangyu 的视频，所以他们在公众号上分享市面上各大机构的视频。&lt;/p&gt;
&lt;p&gt;他们免费分享给学生，没有靠这个牟利，一时间没有收到各大机构的警告，反而吸引了一大批种子用户。&lt;/p&gt;
&lt;p&gt;我在这期间准备毕业论文，顺便在肯德基打工，还在外面接了两个家教。&lt;/p&gt;
&lt;p&gt;每个月的收入超过了 3000，没有再让父母给过生活费，也算是完成了自己小小的一个心愿：在大学里不再依赖父母。&lt;/p&gt;
&lt;p&gt;有人可能会问我为什么对父母的支持那么排斥？我并不是排斥，接受也是完全可以的，因为这是他们表达爱的方式之一。&lt;/p&gt;
&lt;p&gt;但我看到过一些美国和日本电影，里面的大学生甚至高中生，一边上学一遍攒学费，父母没有给过生活费。我也想试试自己到底行不行，能不能靠自己生存下来。最后证明我只要勤快一点，是可以的，完全没有问题。&lt;/p&gt;
&lt;p&gt;这是题外话。我写的这个系列故事可能会经常岔开，请大家见谅。继续说创业的事儿。&lt;/p&gt;
&lt;p&gt;麦这个人特别能聊，他还有个绰号，叫 “夸夸”，取自成语夸夸其谈。这个绰号不是我给他的，是强，一个木讷踏实的男孩子。&lt;/p&gt;
&lt;p&gt;在麦的一遍遍游说下，我们一个个地被他聚在一起。我们聚在一起后，他对我们说：“我的好朋友都在这里了”。其实还有一个同学，他没有游说成功，这个同学当官的想法更强烈，我们也没有再拉他入伙。&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;03&lt;/h3&gt;
&lt;p&gt;经过前期的组织和联系，我们建立了联络群。4 月 25 日那天，我跑到学校图书馆，租了一间会议室准备开会。&lt;/p&gt;
&lt;p&gt;因为我们所有创始人都是在校的学生，有的在国外读研，有的在江西读大一，所以我们用 QQ 群视频的功能筹备了创业动员会。&lt;/p&gt;
&lt;p&gt;网络延迟，偶尔卡顿，会议进行得磕磕绊绊，但丝毫没有影响到我们创业的热情。&lt;/p&gt;
&lt;p&gt;还记得我们一个个轮流自我介绍的时候，不叫自我介绍，叫做 “上台”。因为 QQ 群只允许三个人在线开启摄像头。每喊一个人上台，除了上台的那个人稍许紧张，大家都会开怀大笑。&lt;/p&gt;
&lt;p&gt;“我们要做一个世界性的公司，颠覆人们使用电脑的使用方式，以后的电脑将只有一个浏览器就够了”，麦对着调研资料慷慨激昂。&lt;/p&gt;
&lt;p&gt;这里说的划时代、具有颠覆性的东西，在我后来的了解中，有个专有的名词叫做互联网软件，保罗 • 格雷厄姆的《黑客与画家》中有详细的描述。&lt;/p&gt;
&lt;p&gt;但我们那时候都不知道具体是什么东西，只是有种感觉，随着未来信息传输速度的增加，很多在电脑本地运行的软件都会被搬到浏览器里面。&lt;/p&gt;
&lt;p&gt;我起初也不以为然，毕竟我们习惯了安装本地软件再使用电脑，后来我发现了在线 PS 软件，微软的 Office365，再到现在的腾讯文档，有道云笔记，都是在云化。&lt;/p&gt;
&lt;p&gt;最近，我还发现在浏览器中运行的 CAD 软件，随着 5G 时代的降临，我们当初的设想越来越逼近现实。&lt;/p&gt;
&lt;p&gt;即便理想看起来很伟大，我们还是打算从小事做起来，分享考研资料就是其中一件小事。&lt;/p&gt;
&lt;p&gt;“我们未来的第一批用户是经受过高等教育的人，帮助我们实现这个伟大梦想的人也必然是从受过高等教育的人中挑选”，麦解释道，“所以，我们现在分享考研资料，以后不断迭代产品，潜移默化地向他们传递我们的产品信息”。&lt;/p&gt;
&lt;p&gt;我们那时候完全不知道怎么做一个产品，我现在也不能说自己完全懂产品。现在回想起来，那时候我们是在培养用户，而不是解决用户的痛点。&lt;/p&gt;
&lt;p&gt;而创业最重要的是找到用户真正的痛点，解决了之后形成垄断才能培养（教育）用户，这也是一件危险的事情，目前微信做得最好。&lt;/p&gt;
&lt;p&gt;说干就干，我们开完会就确定了基本制度，每个人都有权力参与创业团队的建设，以后成立公司了，所有决策也是一人一票制。&lt;/p&gt;
&lt;p&gt;4 月 25 日，那天会议开得很成功，每个人都带着些许稚气，带着实现理想的渴望，带着对团队的信任，期待着未来能够给我们答案。&lt;/p&gt;
&lt;p&gt;殊不知，这样的制度，对于麦来说留下了隐患，对于我们联合创始人来说埋下了失望的种子。&lt;/p&gt;
&lt;p&gt;第二篇，《我的创业故事（二）成立公司》会偏重分享一家公司成立的过程，让大家了解一下公司的各种条款，期待的在右下点个在看支持一下吧。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎大家关注微信公众号：&lt;strong&gt;可视化技术（ visteacher ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不仅有前端和可视化，还有算法、源码分析、书籍相送&lt;/p&gt;
&lt;p&gt;个人网站：&lt;a href=&quot;http://blog.kurryluo.com/&quot; class=&quot;uri&quot;&gt;http://blog.kurryluo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各个分享平台的 KurryLuo 都是在下。&lt;/p&gt;
&lt;p&gt;用心学习，认真生活，努力工作！&lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 12:13:00 +0000</pubDate>
<dc:creator>kurryluo</dc:creator>
<og:description>今天是 4 月 25 日，对我来说比较重要。 我是一个比较有仪式感的人，每到一个时间节点，总要总结一些什么。 于是把之前想做的一个事情：「好好思考，仔细总结」，提上日程。 2016 年 4 月 25</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kurryluo/p/10776347.html</dc:identifier>
</item>
<item>
<title>机器学习中的矩阵向量求导(二) 矩阵向量求导之定义法 - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/10773942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/10773942.html</guid>
<description>&lt;p&gt;　　　　在&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/10750718.html&quot;&gt;机器学习中的矩阵向量求导(一) 求导定义与求导布局&lt;/a&gt;中，我们讨论了向量矩阵求导的9种定义与求导布局的概念。今天我们就讨论下其中的标量对向量求导，标量对矩阵求导, 以及向量对向量求导这三种场景的基本求解思路。&lt;/p&gt;
&lt;p&gt;　　　　对于本文中的标量对向量或矩阵求导这两种情况，如前文所说，以分母布局为默认布局。向量对向量求导，以分子布局为默认布局。如遇到其他文章中的求导结果和本文不同，请先确认使用的求导布局是否一样。另外，由于机器学习中向量或矩阵对标量求导的场景很少见，本系列不会单独讨论这两种求导过程。&lt;/p&gt;

&lt;p&gt;　　　　标量对向量求导，严格来说是实值函数对向量的求导。即定义实值函数$f: R^{n} \to R$,自变量$\mathbf{x}$是n维向量，而输出$y$是标量。对于一个给定的实值函数，如何求解$\frac{\partial y}{\partial \mathbf{x}}$呢？&lt;/p&gt;
&lt;p&gt;　　　　首先我们想到的是基于矩阵求导的定义来做，由于所谓标量对向量的求导，其实就是标量对向量里的每个分量分别求导，最后把求导的结果排列在一起，按一个向量表示而已。那么我们可以将实值函数对向量的每一个分量来求导，最后找到规律，得到求导的结果向量。&lt;/p&gt;
&lt;p&gt;　　　　首先我们来看一个简单的例子：$y=\mathbf{a}^T\mathbf{x}$,求解$\frac{\partial \mathbf{a}^T\mathbf{x}}{\partial \mathbf{x}}$&lt;/p&gt;
&lt;p&gt;　　　　根据定义，我们先对$\mathbf{x}$的第i个分量进行求导，这是一个标量对标量的求导，如下：&lt;/p&gt;
&lt;p&gt;$$\frac{\partial \mathbf{a}^T\mathbf{x}}{\partial x_i} = \frac{\partial \sum\limits_{j=1}^n a_jx_j}{\partial x_i} = \frac{\partial a_ix_i}{\partial x_i} =a_i$$&lt;/p&gt;
&lt;p&gt;　　　　可见，对向量的第i个分量的求导结果就等于向量$\mathbf{a}$的第i个分量。由于我们是分子布局，最后所有求导结果的分量组成的是一个n维向量。那么其实就是向量$\mathbf{a}$。也就是说：$$\frac{\partial \mathbf{a}^T\mathbf{x}}{\partial \mathbf{x}} = \mathbf{a}$$&lt;/p&gt;
&lt;p&gt;　　　　同样的思路，我们也可以直接得到：$$\frac{\partial \mathbf{x}^T\mathbf{a}}{\partial \mathbf{x}} = \mathbf{a}$$&lt;/p&gt;
&lt;p&gt;　　　　给一个简单的测试，大家看看自己能不能按定义法推导出:$$\frac{\partial \mathbf{x}^T\mathbf{x}}{\partial \mathbf{x}} =2\mathbf{x}$$&lt;/p&gt;
&lt;p&gt;　　　　再来看一个复杂一点点的例子：$y=\mathbf{x}^T\mathbf{A}\mathbf{x}$,求解$\frac{\partial \mathbf{x}^T\mathbf{A}\mathbf{x}}{\partial \mathbf{x}}$&lt;/p&gt;
&lt;p&gt;　　　　我们对$\mathbf{x}$的第k个分量进行求导如下：&lt;/p&gt;
&lt;p&gt;$$\frac{\partial \mathbf{x}^T\mathbf{A}\mathbf{x}}{\partial x_k} = \frac{\partial \sum\limits_{i=1}^n\sum\limits_{j=1}^n x_iA_{ij}x_j}{\partial x_k} = \sum\limits_{i=1}^n A_{ik}x_i + \sum\limits_{j=1}^n A_{kj}x_j $$&lt;/p&gt;
&lt;p&gt;　　　　这个第k个分量的求导结果稍微复杂些了，仔细观察一下，第一部分是矩阵$\mathbf{A}$的第k列转置后和$x$相乘得到，第二部分是矩阵$\mathbf{A}$的第k行和$x$相乘得到，排列好就是: $$\frac{\partial \mathbf{x}^T\mathbf{A}\mathbf{x}}{\partial \mathbf{x}} = \mathbf{A}^T\mathbf{x} + \mathbf{A}\mathbf{x}$$&lt;/p&gt;
&lt;p&gt;　　　　从上面可以看出，定义法求导对于简单的实值函数是很容易的，但是复杂的实值函数就算求出了任意一个分量的导数，要排列出最终的求导结果还挺麻烦的，因此我们需要找到其他的简便一些的方法来整体求导，而不是每次都先去针对任意一个分量，再进行排列。&lt;/p&gt;

&lt;p&gt;　　　　在我们寻找一些简单的方法前，我们简单看下标量对向量求导的一些基本法则，这些法则和标量对标量求导的过程类似。&lt;/p&gt;
&lt;p&gt;　　　　1） 常量对向量的求导结果为0。&lt;/p&gt;
&lt;p&gt;　　　　2）线性法则：如果$f,g$都是实值函数，$c_1,c_2$为常数，则：$$\frac{\partial (c_1f(\mathbf{x})+c_2g(\mathbf{x})}{\partial \mathbf{x}} = c_1\frac{\partial f(\mathbf{x})}{\partial \mathbf{x}} +c_2\frac{\partial g(\mathbf{x})}{\partial \mathbf{x}} $$&lt;/p&gt;
&lt;p&gt;　　　　3) 乘法法则：如果$f,g$都是实值函数，则：$$\frac{\partial f(\mathbf{x})g(\mathbf{x})}{\partial \mathbf{x}} = f(\mathbf{x})\frac{\partial g(\mathbf{x})}{\partial \mathbf{x}} +\frac{\partial f(\mathbf{x})}{\partial \mathbf{x}} g(\mathbf{x}) $$&lt;/p&gt;
&lt;p&gt;　　　　要注意的是如果不是实值函数，则不能这么使用乘法法则。&lt;/p&gt;
&lt;p&gt;　　　　4) 除法法则：如果$f,g$都是实值函数，且$g(\mathbf{x}) \neq 0$，则：$$\frac{\partial f(\mathbf{x})/g(\mathbf{x})}{\partial \mathbf{x}} = \frac{1}{g^2(\mathbf{x})}(g(\mathbf{x})\frac{\partial f(\mathbf{x})}{\partial \mathbf{x}} - f(\mathbf{x})\frac{\partial g(\mathbf{x})}{\partial \mathbf{x}})$$&lt;/p&gt;

&lt;p&gt; 　　　　现在我们来看看定义法如何解决标量对矩阵的求导问题。其实思路和第一节的标量对向量的求导是类似的,只是最后的结果是一个和自变量同型的矩阵。&lt;/p&gt;
&lt;p&gt;　　　　我们还是以一个例子来说明。$y=\mathbf{a}^T\mathbf{X}\mathbf{b}$,求解$\frac{\partial \mathbf{a}^T\mathbf{X}\mathbf{b}}{\partial \mathbf{X}}$&lt;/p&gt;
&lt;p&gt;　　　　其中, $\mathbf{a}$是m维向量,$\mathbf{b}$是n维向量,  $\mathbf{X}$是$m \times n$的矩阵。&lt;/p&gt;
&lt;p&gt;　　　　我们对矩阵$\mathbf{X}$的任意一个位置的$X_{ij}$求导，如下：$$\frac{\partial \mathbf{a}^T\mathbf{X}\mathbf{b}}{\partial X_{ij}} =  \frac{\partial \sum\limits_{p=1}^n\sum\limits_{q=1}^n a_pA_{pq}b_q}{\partial X_{ij}} =  \frac{\partial  a_iA_{ij}b_j}{\partial X_{ij}} = a_ib_j$$&lt;/p&gt;
&lt;p&gt;　　　　即求导结果在$(i.j)$位置的求导结果是$\mathbf{a}$向量第i个分量和$\mathbf{b}$第j个分量的乘积，将所有的位置的求导结果排列成一个$m \times n$的矩阵，即为$ab^T$,这样最后的求导结果为：$$\frac{\partial \mathbf{a}^T\mathbf{X}\mathbf{b}}{\partial \mathbf{X}} = ab^T$$&lt;/p&gt;
&lt;p&gt;　　　　简单的求导的确不难，但是如果是比较复杂的标量对矩阵求导，比如$y=\mathbf{a}^Texp(\mathbf{X}\mathbf{b})$,对任意标量求导容易，排列起来还是蛮麻烦的，也就是我们遇到了和标量对向量求导一样的问题，定义法比较适合解决简单的问题，复杂的求导需要更简便的方法。这个方法我们在下一篇来讲。&lt;/p&gt;
&lt;p&gt;　　　　同时，标量对矩阵求导也有和第二节对向量求导类似的基本法则，这里就不累述了。&lt;/p&gt;

&lt;p&gt;　　　　这里我们也同样给出向量对向量求导的定义法的具体例子。&lt;/p&gt;
&lt;p&gt;　　　　先来一个简单的例子: $\mathbf{y} = \mathbf{A} \mathbf{x} $,其中$ \mathbf{A}$为$n \times m$的矩阵。$\mathbf{x}, \mathbf{y}$分别为$m,n$维向量。需要求导$\frac{\partial \mathbf{A}\mathbf{x}}{\partial \mathbf{x}}$,根据定义，结果应该是一个$n \times m$的矩阵&lt;/p&gt;
&lt;p&gt;　　　　先求矩阵的第i行和向量的内积对向量的第j分量求导，用定义法求解过程如下：$$\frac{\partial \mathbf{A_i}\mathbf{x}}{\partial \mathbf{x_j}} = \frac{\partial A_{ij}x_j}{\partial \mathbf{x_j}}= A_{ij}$$&lt;/p&gt;
&lt;p&gt;　　　　可见矩阵 $\mathbf{A}$的第i行和向量的内积对向量的第j分量求导的结果就是矩阵 $\mathbf{A}$的$(i,j)$位置的值。排列起来就是一个矩阵了，由于我们分子布局，所以排列出的结果是$ \mathbf{A}$,而不是 $\mathbf{A}^T$&lt;/p&gt;

&lt;p&gt;　　　　使用定义法虽然已经求出一些简单的向量矩阵求导的结果，但是对于复杂的求导式子，则中间运算会很复杂，同时求导出的结果排列也是很头痛的。下一篇我们讨论使使用矩阵微分和迹函数的方法来求解矩阵向量求导。　　　　&lt;/p&gt;

&lt;p&gt;（欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com） &lt;/p&gt;
</description>
<pubDate>Fri, 26 Apr 2019 10:42:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<og:description>在机器学习中的矩阵向量求导(一) 求导定义与求导布局中，我们讨论了向量矩阵求导的9种定义与求导布局的概念。今天我们就讨论下其中的标量对向量求导，标量对矩阵求导, 以及向量对向量求导这三种场景的基本求解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/10773942.html</dc:identifier>
</item>
</channel>
</rss>