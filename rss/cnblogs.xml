<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>017.Python函数匿名函数 - 梦中泪</title>
<link>http://www.cnblogs.com/zyxnhr/p/12285686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyxnhr/p/12285686.html</guid>
<description>&lt;p&gt;匿名函数&lt;/p&gt;
&lt;p&gt;lambda表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;lambda表达式 : 用一句话来表达只具有返回值的函数,简单,方便,直截了当
# 语法:
lambda 参数 :  返回值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无参数的lambda 表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; func():
        return &quot;断剑重铸之日，骑士归来之时&quot;&lt;span&gt;

func = lambda : &quot;断剑重铸之日，骑士归来之时&quot;&lt;span&gt;
res =&lt;span&gt; func()
print(res)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@node10 python]# python3 test.py
断剑重铸之日，骑士归来之时
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有参数的lambda 表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; func(n):
        return&lt;span&gt; type(n)

func = lambda&lt;span&gt; n : type(n)
print(   func(10)   ) #print(   type(n)   )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@node10 python]# python3 test.py
&amp;lt;class 'int'&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;带有条件判断的lambda 表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; func(n):
    if n % 2 ==&lt;span&gt; 0:
        return &quot;偶数&quot;
    else&lt;span&gt;:
        return &quot;奇数&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 改为lamdba表达式&lt;/p&gt;
&lt;p&gt;三目运算符: 同一时间可以操作三个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真区间 if 条件表达式 else 假区间&lt;/li&gt;
&lt;li&gt;如果条件表达式成立 走真区间里面的内容&lt;/li&gt;
&lt;li&gt;如果条件表达式不成立 走假区间里面的内容&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
func  =   &lt;span&gt;lambda&lt;/span&gt; n   :    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;偶数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; n % 2 == 0 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;奇数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
res &lt;/span&gt;= func(16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(res)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回较大值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(n,m):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n&amp;gt;&lt;span&gt;m:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m

func &lt;/span&gt;= &lt;span&gt;lambda&lt;/span&gt; n,m : n  &lt;span&gt;if&lt;/span&gt; n&amp;gt;m &lt;span&gt;else&lt;/span&gt;&lt;span&gt;  m
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(   func(40,50)  )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@node10 python]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python3 test.py&lt;/span&gt;
&lt;span&gt;偶数
&lt;/span&gt;50
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 09 Feb 2020 00:40:00 +0000</pubDate>
<dc:creator>梦中泪</dc:creator>
<og:description>匿名函数 lambda表达式 lambda表达式 : 用一句话来表达只具有返回值的函数,简单,方便,直截了当 # 语法: lambda 参数 : 返回值 无参数的lambda 表达式 def func</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyxnhr/p/12285686.html</dc:identifier>
</item>
<item>
<title>看一遍就理解，图解单链表反转 - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/12286133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/12286133.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;反转链表是程序员必备的基本素养，经常在面试、笔试的过程中出现。一直觉得反转链表实现代码不是很好理解，决定搬leetcode那道经典反转链表题出来，用十多张图去解析它，希望加深大家对链表反转的理解，谢谢阅读。&lt;/p&gt;
&lt;h3 id=&quot;leetcode的反转链表原题答案&quot;&gt;leetcode的反转链表原题&amp;amp;答案&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt; 反转一个单链表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。&lt;/p&gt;
&lt;p&gt;在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ListNode reverseList(ListNode head) {  
    ListNode prev = null;   
    ListNode curr = head;   
    while (curr != null) {  
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;图解链表反转代码的实现&quot;&gt;图解链表反转代码的实现&lt;/h3&gt;
&lt;p&gt;接下来，我们图解以上代码实现，先对以上实现代码加上行号，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ListNode reverseList(ListNode head) {  //1
    ListNode prev = null;   // 2
    ListNode curr = head;   // 3
    while (curr != null) {   //4
        ListNode nextTemp = curr.next; //5
        curr.next = prev;  // 6 
        prev = curr;  //7
        curr = nextTemp; //8
    } 
    return prev;  //9
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第一行代码图解&quot;&gt;第一行代码图解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public ListNode reverseList(ListNode head) {  //1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们顺着题目描述意思，假设链表就有1、2、3个元素吧，后面还跟着一个null，又因为输入是ListNode head，所以这个即将要反转的链表如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fbe941179b51?w=909&amp;amp;h=245&amp;amp;f=png&amp;amp;s=21126&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二行代码图解&quot;&gt;第二行代码图解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ListNode prev = null;   // 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将null赋值给prev，即prev指向null，可得图如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701f9da5c94b500?w=216&amp;amp;h=210&amp;amp;f=png&amp;amp;s=7193&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第三行代码图解&quot;&gt;第三行代码图解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ListNode curr = head;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将链表head赋值给curr，即curr指向head链表，可得图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fbfcaab4dd99?w=870&amp;amp;h=243&amp;amp;f=png&amp;amp;s=20089&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;循环部分代码图解&quot;&gt;循环部分代码图解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt; while (curr != null) {   //4
        ListNode nextTemp = curr.next; //5
        curr.next = prev;  // 6 
        prev = curr;  //7
        curr = nextTemp; //8
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环部分是&lt;strong&gt;链表反转的核心&lt;/strong&gt;部分，我们先走一遍循环，图解分析一波。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;curr指向了head&lt;/strong&gt;，&lt;strong&gt;head不为null&lt;/strong&gt;，所以进入循环。&lt;strong&gt;先来看第5行：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ListNode nextTemp = curr.next; //5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把curr.next 赋值给nextTemp变量，即nextTemp 指向curr的下一节点（即节点2），可得图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701ff3466fffa10?w=833&amp;amp;h=240&amp;amp;f=png&amp;amp;s=21780&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再执行到第6行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curr.next = prev;  // 6 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把prev赋值给curr.next,因为prev初始化化指向null，即curr(节点1)指向了null，链表图解成这样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fbd124bde1f2?w=1068&amp;amp;h=263&amp;amp;f=png&amp;amp;s=27349&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们看执行到第7行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; prev = curr;  //7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把curr赋值给prev，prev指向curr，图解如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fc2fc9a7ba5c?w=1091&amp;amp;h=347&amp;amp;f=png&amp;amp;s=35650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们执行到第8行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curr = nextTemp; //8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把nextTemp赋值给curr，即curr指向nextTemp，图解如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fc5ceadd3e2f?w=1042&amp;amp;h=364&amp;amp;f=png&amp;amp;s=35340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，第一遍循环执行结束啦，回到循环条件，&lt;strong&gt;curr依旧不为null&lt;/strong&gt;，我们继续图解完它。&lt;/p&gt;
&lt;p&gt;5-8行代码又执行一遍，依次可得图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        ListNode nextTemp = curr.next; //5
        curr.next = prev;  // 6 
        prev = curr;  //7
        curr = nextTemp; //8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完&lt;code&gt;ListNode nextTemp = curr.next;&lt;/code&gt;后：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fceea65ac66e?w=1011&amp;amp;h=360&amp;amp;f=png&amp;amp;s=34547&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完&lt;code&gt;curr.next = prev;&lt;/code&gt;后：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fd391ef75c17?w=1108&amp;amp;h=339&amp;amp;f=png&amp;amp;s=35342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完&lt;code&gt;prev = curr;&lt;/code&gt;后：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fd5ad58277e1?w=1091&amp;amp;h=359&amp;amp;f=png&amp;amp;s=36280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完&lt;code&gt;curr = nextTemp;&lt;/code&gt;后：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fd73f53f1a2b?w=1103&amp;amp;h=346&amp;amp;f=png&amp;amp;s=35454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到这里，发现curr还是不为null，再回到while循环，再执行一遍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        ListNode nextTemp = curr.next; //5
        curr.next = prev;  // 6 
        prev = curr;  //7
        curr = nextTemp; //8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次可得图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fdf5b6532ed5?w=1130&amp;amp;h=340&amp;amp;f=png&amp;amp;s=35491&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1702007c264eddd4?w=1077&amp;amp;h=320&amp;amp;f=png&amp;amp;s=32820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fe5ac9b9d1d8?w=1135&amp;amp;h=330&amp;amp;f=png&amp;amp;s=34388&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701fe66d7971447?w=1137&amp;amp;h=330&amp;amp;f=png&amp;amp;s=34740&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到这里，我们发现curr已经为null了，可以跳出循环了。这时候prev指向的就是链表的反转呀，所以第9行执行完，反转链表功能实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; return prev;  //9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考与感谢&quot;&gt;参考与感谢&lt;/h3&gt;
&lt;h3 id=&quot;个人公众号&quot;&gt;个人公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/28/16c381c89b127bbb?w=344&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=8943&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你是个爱学习的好孩子，可以关注我公众号，一起学习讨论。&lt;/li&gt;
&lt;li&gt;如果你觉得本文有哪些不正确的地方，可以评论，也可以关注我公众号，私聊我，大家一起学习进步哈。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 09 Feb 2020 00:11:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 反转链表是程序员必备的基本素养，经常在面试、笔试的过程中出现。一直觉得反转链表实现代码不是很好理解，决定搬leetcode那道经典反转链表题出来，用十多张图去解析它，希望加深大家对链表反转的理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/12286133.html</dc:identifier>
</item>
<item>
<title>生命之树常青，英雄之魂永不朽 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12286020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12286020.html</guid>
<description>&lt;p&gt;一&lt;/p&gt;
&lt;p&gt;上一个被世人铭记的庚子年是1900年，它使得一群普通人被世人铭记，那些英勇抗击八国联军侵华的普通百姓，他们用自己的拳脚功夫和冷兵器和西方列强斗争，旨在争取民族自强，然而却被清政府和八国联军联合绞杀下最终失败。&lt;/p&gt;
&lt;p&gt;那是一群英雄，一群普通人，他们抛弃头颅洒下的点滴热血，迄今仍然在中华大地上荡起了慷慨悲歌。&lt;/p&gt;
&lt;p&gt;今年这个庚子年同样是一个值得铭记的时间。在武汉地区首先开始蔓延的武汉新冠病毒，使得全国人民都沉浸在一片人人自危的气氛中，连一贯年味十足的湖南农村地区，今年甚至都不允许拜年、走亲戚、串门。不仅如此，还有许多地区相继开始了六级隔断，从省级干道开始，到市级道路，县级道路，村级道路，有的地区甚至户与户之间都被硬性隔断，尽量避免人与人的接触。&lt;/p&gt;
&lt;p&gt;前几天我的表弟从岳阳地区回到长沙时，一路经过了四级关卡，每级关卡都要求进行体温检测、佩戴口罩、填表、多级签名才能放行，原本1个小时的流程，耗费了半天才能抵达。我的同事他们家是新化地区，甚至连户与户之间都被隔离开来，居家买菜都成为困难的事情。&lt;/p&gt;
&lt;p&gt;二&lt;/p&gt;
&lt;p&gt;这是一个前所未有的疫情，或许已经远远超出了有关部门的预料范围。虽然当武汉地区刚刚出现疫情时，在12月28日、28日，湖北省中西医结合医院呼吸内科主任张继先医生发现疫情向有关部门报告后，却依然没有获得有关部门的足够重视。&lt;/p&gt;
&lt;p&gt;而随后李文亮医生发现事情不对劲后，也处于职业道德在他的同学群中进行分享，提醒大家注意进行防护，其发布的聊天消息被人分享到公开群中，使得更大范围的网友都及时了解了消息，如果当时采取了措施，大概疫情就不会扩散了。然而，有关部门不仅没有及时的公开消息，反而把他列入制造谣言的名单，使得他受到了训诫。&lt;/p&gt;
&lt;p&gt;直到后来疫情大规模蔓延，那些提前通过网络发出预警消息的人，他们被尊称为“八君子”，后来也被最高法称赞，说他们的行为某种意义上对疫情的提前控制，起到了非常一定作用。而那些真正制造谣言呢，真真假假，看不清楚。&lt;/p&gt;
&lt;p&gt;甚至于到现在，疫情已经蔓延了将近一个多月，事态依然看似一片混沌，各地的隔断没有解除。会不会有多少人囤积了数年都用不完的医疗物资？大概过几年就会像2003年的非典囤积盐、醋、板蓝根一样成为笑话吧。&lt;/p&gt;
&lt;p&gt;我始终相信，中华民族无坚不摧，从来就不会就此屈服，经历这一波，我们的民族也将更加坚强。&lt;/p&gt;
&lt;p&gt;三&lt;/p&gt;
&lt;p&gt;然而，那位提前向公众发出预警的吹哨人，李文亮君，却已经身患新冠肺炎，提前离世，他究竟是如何如此奇怪的逝去，我想多少人跟我一样，昨天晚上都度过了一个不眠之夜。&lt;/p&gt;
&lt;p&gt;他在31日说：“我只是个普通人，不是什么英雄。”&lt;/p&gt;
&lt;p&gt;他的微信签名：理论是灰色的，生命之树常青。&lt;/p&gt;
&lt;p&gt;30日，他还在微信上说，病好之后就回一线，疫情还在扩散，不想当逃兵。&lt;/p&gt;
&lt;p&gt;31日，他说：最挂念我的家人，我的父母还在住院，我的爱人现在怀着孕。现在什么都不重要，希望大家能好好的。”&lt;/p&gt;
&lt;p&gt;许多人都说他死因不明，但现在说什么都已经来不及了，他已经从此离开喧杂的人世，不用在理会是是非非，也不用“下班四顾心茫然，回家被堵小区外”，更不用费劲力气救人活命，却被人用利刃割喉而死。我相信他能在天堂安睡，在那璀璨的星空，无穷小行星中，也定有他的那一颗。他将庇佑生者远离病痛的困扰，庇佑死者的英魂永远安息。&lt;/p&gt;
&lt;p&gt;李医生和众多奋战在前线的医务工作者，执勤民警，军人，检测站的工作人员一样，大家都是凡人。不管你是有关部门工作人员、还是公司高管、抑或是更普通的普罗大众。哪怕是身居高官厚禄，金钱满满，你的生命都只有一条，区区若干年，不管你生前多么荣耀，死后都只有一杯黄土。&lt;/p&gt;
&lt;p&gt;没人想成为英雄，也没人想唱起慷慨激昂的赞歌，歌颂那些为了抗击病魔而壮烈奉献的医生们。但是当瘟疫蔓延时，是他们凭借自己单薄的身躯英勇的奋战在第一线，是他们始终相信，只要自己努力一点点，就能保护更多的平凡人。他们也有自己的家庭，也有自己的青葱岁月，但是他们把自己的家庭抛弃了、把青葱岁月埋葬了，甚至有的如李文亮君一般，还把自己的生命给牺牲了。&lt;/p&gt;
&lt;p&gt;长歌不止，青松永不倒，鲜血永远灿烂，我们的民族将更加强大，而英雄的壮烈凯歌也将始终在世间奏响。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Feb 2020 17:35:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一 上一个被世人铭记的庚子年是1900年，它使得一群普通人被世人铭记，那些英勇抗击八国联军侵华的普通百姓，他们用自己的拳脚功夫和冷兵器和西方列强斗争，旨在争取民族自强，然而却被清政府和八国联军联合绞杀</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12286020.html</dc:identifier>
</item>
<item>
<title>图像边缘检测 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12285708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12285708.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;图像的边缘是图像的基本特征，边缘点是灰度阶跃变化的像素点，即灰度值的导数较大或极大的地方，边缘检测是图像识别的第一步。&lt;/p&gt;
&lt;p&gt;用图像的一阶微分和二阶微分来增强图像，本质上计算的就是灰度的变化情况，而边缘也就是灰度变化的地方。因此，这些传统的一阶微分算子如Robert、Sobel、prewitt等，以及二阶微分算子Laplacian等等本质上都是可以用于检测边缘的。这些算子都可以称为边缘检测算子。&lt;/p&gt;
&lt;p&gt;边缘检测可以大幅度的减少数据量，剔除那些不相关的信息，保留图像重要的结构属性，一般的边缘检测的步骤有：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;原始图像&lt;/strong&gt;&lt;strong&gt;--&amp;gt;&lt;/strong&gt;&lt;strong&gt;平滑图像&lt;/strong&gt;--&amp;gt;&lt;strong&gt;锐化图像&lt;/strong&gt;--&amp;gt;&lt;strong&gt;边缘判定&lt;/strong&gt;--&amp;gt;&lt;strong&gt;二值化&lt;/strong&gt;--&amp;gt;&lt;strong&gt;边缘连接&lt;/strong&gt;--&amp;gt;&lt;strong&gt;边缘图像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)     平滑滤波：因为梯度计算容易受噪声影响，所以先使用滤波平滑图像去除噪声。&lt;/p&gt;
&lt;p&gt;2)     锐化滤波：为了检测边界，需要确定邻域中灰度变换，锐化突出了回答变换的区域。&lt;/p&gt;
&lt;p&gt;3)     边缘判定：通过阈值或灰度变换，剔除某些处理点，查找边缘点。&lt;/p&gt;
&lt;p&gt;4)     边缘连接：将间断的边缘连接成有意义的完整边缘，同时去除假边缘。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、边缘检测算子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1梯度算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Robert算子利用局部差分算子寻找边缘，边缘定位精度较高但容易丢失一部分边缘，同时由于没有对图像进行平滑处理因此不具备抑制噪声的能力。该算子对边缘陡峭且噪声较少的图像效果较好。&lt;/p&gt;
&lt;p&gt;Sobel算子和prewitt算子都考虑了邻域信息，相当于对图像先做加权平滑处理，然后再做微分运算，所以对噪声有一定的抑制能力，但不排除检测结果中出现虚假边缘，并且容易出现多像素宽度的边缘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2高斯-拉普拉斯算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拉普拉斯算子是二阶微分算子，对噪声敏感，Laplace算子对孤立象素的响应要比对边缘或线的响应要更强烈，因此只适用于无噪声图象。存在噪声情况下，使用Laplacian算子检测边缘之前需要先进行低通滤波。高斯-拉普拉斯算子，又称LoG算子，就是为了补充这种缺陷被创立的，它先进行高斯低通滤波，然后再进行拉普拉斯二阶微分锐化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 Canny边缘检测算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在图像边缘检测中，抑制噪声和边缘精准定位是无法同时满足的，一些边缘检测算法通过平滑滤波去除噪声的同时，也增加了边缘检测的不确定性，而提高边缘检测算子对边缘的敏感性的同时，也提高了对噪声的敏感性。Canny算子力图在抗噪声干扰和精准定位之间寻求最佳折中方案。&lt;/p&gt;
&lt;p&gt;Canny算法主要有4个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用高斯滤波器来平滑图像；&lt;/li&gt;
&lt;li&gt;用一介偏导的有限差分来计算梯度的幅值和方向；&lt;/li&gt;
&lt;li&gt;对梯度进行非极大值抑制，保留极大值，抑制其他值；&lt;/li&gt;
&lt;li&gt;用双阈值算法检测和连接边缘。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、边缘检测示例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;基于梯度的算子边缘检测：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;BW=edge(img, type, thresh, direction, ‘nothinning’)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;img：输入图像&lt;/p&gt;
&lt;p&gt;type：算子类型，有sobel，Prwitt，roberts，log， canny&lt;/p&gt;
&lt;p&gt;thresh：敏感度阈值，灰度低于此阈值的边缘不会被检测到，默认是空矩阵，自动计算阈值。&lt;/p&gt;
&lt;p&gt;direction：指定感兴趣的边缘方向，horizontal，vertical，both&lt;/p&gt;
&lt;p&gt;最后一个可选参数，thinning会进行边缘细化，不填就会跳过该步骤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
imgPath = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\opencv_pic\src_pic\pic7.bmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
img &lt;/span&gt;=&lt;span&gt; imread(imgPath);
Img&lt;/span&gt;=&lt;span&gt;rgb2gray(img);
 
Img_canny &lt;/span&gt;= edge(Img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;canny&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);  %&lt;span&gt;canny
Img_roberts &lt;/span&gt;= edge(Img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;roberts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);  %&lt;span&gt;reberts
Img_prewitt &lt;/span&gt;= edge(Img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;prewitt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);  %&lt;span&gt;prewitt
Img_sobel&lt;/span&gt;=edge(Img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sobel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);  %&lt;span&gt;sobel
Img_log&lt;/span&gt;=edge(Img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);  %&lt;span&gt;log
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),imshow(Img), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;原始图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),imshow(Img_canny), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Img canny&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),imshow(Img_roberts),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Img roberts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;),imshow(Img_prewitt),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Img prewitt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;),imshow(Img_sobel),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Img sobel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;),imshow(Img_log),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Img LoG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200208233114809-1962939130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放大观察，candy效果最优，Log次之。Log算子检测边缘的结果要比roberts和sobel算子好些，边缘比较完整，抗噪能力较好。roberts、pewitt、sobel算子模板相对较大、抑制了噪声，但也去掉了部分边缘，导致定位精度不高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200208233127874-486406466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果图形有噪声,img = imnoise(img,'salt &amp;amp; pepper', 0.03),对原始图上添加些椒盐噪声。再次计算结果如下，只有canny和LoG算法因为先做了低通滤波可以得到比较清晰的边缘。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200208233143011-1644799475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4、参考文档&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1、边缘检测&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pacino12134/p/11340947.html&quot;&gt;https://www.cnblogs.com/pacino12134/p/11340947.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、图像边缘检测——二阶微分算子（上）Laplace算子、LOG算子、DOG算子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u014485485/article/details/78364573&quot;&gt;https://blog.csdn.net/u014485485/article/details/78364573&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;3.5368421052632&quot;&gt;
&lt;p&gt; 尊重原创技术文章，转载请注明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12285708.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12285708.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 08 Feb 2020 15:36:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>图像边缘检测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12285708.html</dc:identifier>
</item>
<item>
<title>JVM性能优化系列-(3) 虚拟机执行子系统 - 后端精进之路</title>
<link>http://www.cnblogs.com/way2backend/p/12285711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/way2backend/p/12285711.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1gam0dn947ej20zk0k0wfo.jpg&quot; alt=&quot;JVM.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;虚拟机执行子系统&quot;&gt;3. 虚拟机执行子系统&lt;/h2&gt;
&lt;h3 id=&quot;java跨平台的基础&quot;&gt;3.1 Java跨平台的基础&lt;/h3&gt;
&lt;p&gt;Java刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere），其中字节码是构成平台无关的基石，也是语言无关性的基础。&lt;/p&gt;
&lt;p&gt;Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga5lbyhpfqj20wm0hg0yp.jpg&quot; alt=&quot;Screen Shot 2019-12-22 at 4.41.27 PM.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;class类的文件结构&quot;&gt;3.2 Class类的文件结构&lt;/h3&gt;
&lt;p&gt;任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class文件是一组以8位字节为基础单位的二进制流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。&lt;br/&gt;Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：&lt;strong&gt;无符号数和表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无符号数&lt;/strong&gt;属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表&lt;/strong&gt;是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。&lt;/p&gt;
&lt;p&gt;整个class类的文件结构如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;占用大小&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;td&gt;数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u4&lt;/td&gt;
&lt;td&gt;magic：魔数，用于标识文件类型，对于java来说是0xCAFEBABE&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;minor_version：次版本号&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;major_version：主版本号&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;constant_pool_count：常量池大小，从1开始而不是0。当这个值为0时，表示后面没有常量&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cp_info&lt;/td&gt;
&lt;td&gt;constant_pool：#常量池&lt;/td&gt;
&lt;td&gt;constant_pool_count-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;access_flags：访问标志，标识这个class是类还是接口、public、abstract、final等&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;this_class：类索引 #类索引查找全限定名的过程&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;super_class：父类索引&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;interfaces_count：接口计数器&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;interfaces：接口索引集合&lt;/td&gt;
&lt;td&gt;interfaces_count&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;fields_count：字段的数量&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;field_info&lt;/td&gt;
&lt;td&gt;fields：#字段表&lt;/td&gt;
&lt;td&gt;fields_count&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;methods_count：方法数量&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;method_info&lt;/td&gt;
&lt;td&gt;methods：#方法表&lt;/td&gt;
&lt;td&gt;methods_count&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;attributes_count：属性数量&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;attribute_info&lt;/td&gt;
&lt;td&gt;attrbutes：#属性表&lt;/td&gt;
&lt;td&gt;attributes_count&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以使用javap -verbose输出class文件的字节码内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面按顺序对这些字段进行介绍。&lt;/p&gt;
&lt;h4 id=&quot;魔数与class文件的版本&quot;&gt;魔数与Class文件的版本&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件&lt;/strong&gt;。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）&lt;/strong&gt;。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。&lt;/p&gt;
&lt;h4 id=&quot;常量池&quot;&gt;常量池&lt;/h4&gt;
&lt;p&gt;常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。&lt;/p&gt;
&lt;p&gt;常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字面量&lt;/strong&gt;：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用&lt;/strong&gt;：则属于编译原理方面的概念，包括了下面三类常量：&lt;br/&gt;类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;访问标志&quot;&gt;访问标志&lt;/h4&gt;
&lt;p&gt;用于识别一些类或者接口层次的访问信息，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个Class是类还是接口；&lt;/li&gt;
&lt;li&gt;是否定义为public类型；&lt;/li&gt;
&lt;li&gt;是否定义为abstract类型；&lt;/li&gt;
&lt;li&gt;如果是类的话，是否被声明为final等&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;类索引父类索引与接口索引集合&quot;&gt;类索引、父类索引与接口索引集合&lt;/h4&gt;
&lt;p&gt;这三项数据来确定这个类的继承关系。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。&lt;/li&gt;
&lt;li&gt;由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。&lt;/li&gt;
&lt;li&gt;接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;字段表集合&quot;&gt;字段表集合&lt;/h4&gt;
&lt;p&gt;描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。&lt;br/&gt;而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;方法表集合&quot;&gt;方法表集合&lt;/h4&gt;
&lt;p&gt;描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。&lt;/p&gt;
&lt;p&gt;与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”&lt;/p&gt;
&lt;h4 id=&quot;属性表集合&quot;&gt;属性表集合&lt;/h4&gt;
&lt;p&gt;存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。&lt;/p&gt;
&lt;h3 id=&quot;字节码指令&quot;&gt;3.3 字节码指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多数的指令都包含了其操作所对应的数据类型信息。例如：&lt;br/&gt;iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;l代表long&lt;/li&gt;
&lt;li&gt;s代表short&lt;/li&gt;
&lt;li&gt;b代表byte&lt;/li&gt;
&lt;li&gt;c代表char&lt;/li&gt;
&lt;li&gt;f代表float&lt;/li&gt;
&lt;li&gt;d代表double&lt;/li&gt;
&lt;li&gt;a代表reference&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。&lt;strong&gt;不是每种数据类型和每一种操作都有对应的指令，有一些单独的指令可以在必要的时候用在将一些不支持的类型转换为可被支持的类型&lt;/strong&gt;。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。&lt;/p&gt;
&lt;h4 id=&quot;加载和存储命令&quot;&gt;加载和存储命令&lt;/h4&gt;
&lt;p&gt;加载和存储指令用于将数据在帧栈中的局部变量表和操作数栈之间来回传递。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将一个局部变量加载到操作栈：iload、iload_&amp;lt;\n&amp;gt;、lload、lload_&amp;lt;\n&amp;gt;、fload、fload_&amp;lt;\n&amp;gt;、dload、dload_&amp;lt;\n&amp;gt;、aload、aload_&amp;lt;\n&amp;gt;&lt;/li&gt;
&lt;li&gt;将一个数值从操作数栈存储到局部变量表：istore、istore_&amp;lt;\n&amp;gt;、lstore、lstore_&amp;lt;\n&amp;gt;、fstore、fstore_&amp;lt;\n&amp;gt;、dstore、dstore_&amp;lt;\n&amp;gt;、astore、astore_&amp;lt;\n&amp;gt;&lt;/li&gt;
&lt;li&gt;将一个参数加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&amp;lt;\i&amp;gt;、lconst_、fconst_&amp;lt;\f&amp;gt;、dconst_&amp;lt;\d&amp;gt;&lt;/li&gt;
&lt;li&gt;扩充局部变量表的访问索引的指令：wide&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面带尖括号的指令实际上是代表的一组指令，如iload_0、iload_1、iload_2和iload_3。这些指令把操作数隐含在名称内，不需要进行取操作数的动作。&lt;/p&gt;
&lt;h4 id=&quot;运算指令&quot;&gt;运算指令&lt;/h4&gt;
&lt;p&gt;运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶，可分为整型数据和浮点型数据指令。byte、short、char和boolean类型的算术指令使用int类型的指令代替。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加法指令：iadd、ladd、fadd、dadd&lt;/li&gt;
&lt;li&gt;减法指令：isub、lsub、fsub、dsub&lt;/li&gt;
&lt;li&gt;乘法指令：imul、lmul、fmul、dmul&lt;/li&gt;
&lt;li&gt;除法指令：idiv、ldiv、fdiv、ddiv&lt;/li&gt;
&lt;li&gt;求余指令：irem、lrem、frem、drem&lt;/li&gt;
&lt;li&gt;取反指令：ineg、lneg、fneg、dneg&lt;/li&gt;
&lt;li&gt;位移指令：ishl、ishr、iushr、lshl、lshr、lushr&lt;/li&gt;
&lt;li&gt;或指令：ior、lor&lt;/li&gt;
&lt;li&gt;与指令：iand、land&lt;/li&gt;
&lt;li&gt;异或指令：ixor、lxor&lt;/li&gt;
&lt;li&gt;局部变量自增指令：iinc&lt;/li&gt;
&lt;li&gt;比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;类型转换指令&quot;&gt;类型转换指令&lt;/h4&gt;
&lt;p&gt;可以将两种不同的数值类型进行相互转换，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;int类型到long、float或者double类型。&lt;/li&gt;
&lt;li&gt;long类型到float、double类型。&lt;/li&gt;
&lt;li&gt;float类型到double类型。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;对象创建与访问指令&quot;&gt;对象创建与访问指令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;创建类实例的指令：new&lt;/li&gt;
&lt;li&gt;创建数组的指令：newarray、anewarray、multianewarray&lt;/li&gt;
&lt;li&gt;访问类字段和实例字段的实例：getfield、putfield、getstatic、putstatic&lt;/li&gt;
&lt;li&gt;把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload&lt;/li&gt;
&lt;li&gt;将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fasotre、dastore、aastore&lt;/li&gt;
&lt;li&gt;取数组长度的指令：arraylength&lt;/li&gt;
&lt;li&gt;检查类实例类型的指令：instanceof、checkcast&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;操作数栈管理指令&quot;&gt;操作数栈管理指令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;将操作数栈的栈顶一个或两个元素出栈：pop、pop2&lt;/li&gt;
&lt;li&gt;复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2&lt;/li&gt;
&lt;li&gt;将栈最顶端的两个数值互换：swap&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;控制转移指令&quot;&gt;控制转移指令&lt;/h4&gt;
&lt;p&gt;控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。&lt;/li&gt;
&lt;li&gt;复合条件分支：tableswitch、lookupswitch。&lt;/li&gt;
&lt;li&gt;无条件分支：goto、goto_w、jsr、jsr_w、ret。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;方法调用指令&quot;&gt;方法调用指令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。&lt;/li&gt;
&lt;li&gt;invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。&lt;/li&gt;
&lt;li&gt;invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。&lt;/li&gt;
&lt;li&gt;invokestatic指令用于调用类方法（static方法）。&lt;/li&gt;
&lt;li&gt;invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。&lt;/li&gt;
&lt;li&gt;方法调用指令与数据类型无关。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;方法返回指令&quot;&gt;方法返回指令&lt;/h4&gt;
&lt;p&gt;是根据返回值的类型区分的，包括&lt;strong&gt;ireturn（当返回值是boolean、byte、char、short和int类型时使用）&lt;/strong&gt;、&lt;strong&gt;lreturn&lt;/strong&gt;、&lt;strong&gt;freturn&lt;/strong&gt;、&lt;strong&gt;dreturn和areturn&lt;/strong&gt;，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。&lt;/p&gt;
&lt;h4 id=&quot;异常处理指令&quot;&gt;异常处理指令&lt;/h4&gt;
&lt;p&gt;在java程序中，&lt;strong&gt;显式抛出异常的操作都由athrow指令来实现&lt;/strong&gt;。而在java虚拟机中，处理异常不是由字节码指令来实现的，而是采用异常表来完成的&lt;/p&gt;
&lt;h4 id=&quot;同步指令&quot;&gt;同步指令&lt;/h4&gt;
&lt;p&gt;java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。方法级的同步是隐式的，利用方法表结构中的ACC_SYNCHRONIZED访问标志得知。&lt;strong&gt;指令序列的同步是由monitorenter和monitorexit两条指令支持。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;类加载机制&quot;&gt;3.4 类加载机制&lt;/h3&gt;
&lt;h4 id=&quot;典型面试题类加载过程什么是双亲委派&quot;&gt;典型面试题：类加载过程？什么是双亲委派？&lt;/h4&gt;
&lt;p&gt;这是一个非常典型的面试题，标准回答如下：&lt;/p&gt;
&lt;p&gt;一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 加载（Loading）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此阶段中Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。 加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 链接（Linking）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。&lt;/li&gt;
&lt;li&gt;准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。&lt;/li&gt;
&lt;li&gt;解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3. 初始化（initialization）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，&lt;strong&gt;父类型的初始化逻辑优先于当前类型的逻辑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双亲委派模型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。&lt;/p&gt;
&lt;h4 id=&quot;概述&quot;&gt;概述&lt;/h4&gt;
&lt;p&gt;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：&lt;strong&gt;加载&lt;/strong&gt;（Loading）、&lt;strong&gt;验证&lt;/strong&gt;（Verificatio）、&lt;strong&gt;准备&lt;/strong&gt;（Preparation）、&lt;strong&gt;解析&lt;/strong&gt;（Resolution）、&lt;strong&gt;初始化&lt;/strong&gt;（Initialization）、&lt;strong&gt;使用&lt;/strong&gt;（Using）和&lt;strong&gt;卸载&lt;/strong&gt;（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga5tgvosk4j20r80bnjs5.jpg&quot; alt=&quot;class lifeCycle.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;遇到&lt;strong&gt;new、getstatic、putstatic或invokestatic&lt;/strong&gt;这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;java.lang.reflect&lt;/strong&gt;包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。&lt;/li&gt;
&lt;li&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。&lt;/li&gt;
&lt;li&gt;当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关于静态变量的初始化，必须要注意以下三种情况下是不会触发类的初始化的：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。&lt;/li&gt;
&lt;li&gt;通过数组定义来引用类，不会触发此类的初始化。&lt;/li&gt;
&lt;li&gt;常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是测试程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SuperClass {
    static {
        System.out.println(&quot;SuperClass init!&quot;);
    }
    
    public static int value = 123;
}

public class SubClass extends SuperClass {
    static {
        System.out.println(&quot;Subclass init!&quot;);
    }
}

public class ConstClass {
    static {
        System.out.println(&quot;ConstClass init!&quot;);
    }
    
    public static final String HELLOWORLD_STRING = &quot;hello world&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是对三种情况的测试程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        // 1. 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
        // Result: SuperClass init! 123
        System.out.println(SubClass.value);
        
        // 2. 通过数组定义来引用类，不会触发此类的初始化
        SuperClass[] superClasses = new SubClass[10];
        
        // 3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
        // Result: hello world
        System.out.println(ConstClass.HELLOWORLD_STRING);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;加载&quot;&gt;加载&lt;/h4&gt;
&lt;p&gt;在加载阶段，虚拟机需要完成下列3件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;验证&quot;&gt;验证&lt;/h4&gt;
&lt;p&gt;验证是连接阶段的第一步，这一阶段的目的是为了&lt;strong&gt;确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全&lt;/strong&gt;。验证阶段大致上会完成下面4个阶段的检验动作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;：第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要目的是保证输入的字节流能正确解析并存储于方法区内，格式上符合描述一个java类型信息的要求。这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会存储到方法区中，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。主要目的是对元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt;：最后一个阶段的验证发生在虚拟机符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段中发生，可以看做是对类自身以外的信息进行匹配性校验。目的是确保解析动作能正常执行&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;准备阶段&quot;&gt;准备阶段&lt;/h4&gt;
&lt;p&gt;是正式为&lt;strong&gt;类变量&lt;/strong&gt;分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：&lt;/p&gt;
&lt;p&gt;public static int value=123；&lt;/p&gt;
&lt;p&gt;那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。&lt;/p&gt;
&lt;p&gt;表7-1列出了Java中所有基本数据类型的零值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga5vypztacj215c0iqq7k.jpg&quot; alt=&quot;Java的数据类型.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设上面类变量value的定义变为：public static final int value=123；&lt;br/&gt;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。&lt;/p&gt;
&lt;h4 id=&quot;解析阶段&quot;&gt;解析阶段&lt;/h4&gt;
&lt;p&gt;是虚拟机将常量池内的符号引用替换为直接引用的过程。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;符号引用（Symbolic References）&lt;/strong&gt;：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用是能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受地符号引用必须是一致的，因为符号引用地字面量形式明确定义在java虚拟机规范地Class文件格式中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;直接引用（Direct References）&lt;/strong&gt;：直接引用可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;p&gt;类初始化是类加载过程的最后一步，在这个阶段才真正开始执行类中的字节码。初始化阶段是执行类构造器&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法与类的构造函数（&lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;方法）不同，它不需要显式调用父类构造器，虚拟机会保证在子类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法执行之前，父类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法已经执行完毕。&lt;/li&gt;
&lt;li&gt;由于父类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法先执行，因此父类中定义的静态语句块要先于子类执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量赋值操作，那么编译器可以不为这个类生成&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;接口中不能使用静态语句块，但仍然由变量初始化的赋值操作，因此接口与类一样都会生成&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法，但与类不同的是，执行接口的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法不需要先执行父接口的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类加载器&quot;&gt;3.5 类加载器&lt;/h3&gt;
&lt;h4 id=&quot;类与类加载器&quot;&gt;类与类加载器&lt;/h4&gt;
&lt;p&gt;类加载器虽然只用于实现类的加载动作，但在java程序中起到的作用却远不止类加载阶段。&lt;/p&gt;
&lt;p&gt;对于任意一个类，都需要由加载它的&lt;strong&gt;类加载器和这个类本身一同确立其在java虚拟机中的唯一性&lt;/strong&gt;，每个类加载器，都拥有一个独立的类命名空间。当一个Class文件被不同的类加载器加载时，加载生成的两个类必定不相等（equals()、isAssignableFrom()、isInstance()、instanceof关键字的结果为false）。&lt;/p&gt;
&lt;h4 id=&quot;双亲委派机制&quot;&gt;双亲委派机制&lt;/h4&gt;
&lt;p&gt;从java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用c++实现，是虚拟机的一部分；另一种是所有其他的类加载器，这些类加载器都由java实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。java提供的类加载器主要分以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;启动类加载器&lt;/strong&gt;（Bootstrap ClassLoader）：这个类负责将存放在\lib目录中，或者被-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展类加载器&lt;/strong&gt;（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\lib\ext目录中或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序类加载器&lt;/strong&gt;（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称为系统类加载器，负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6e534965j20qy0igtft.jpg&quot; alt=&quot;Screen Shot 2019-12-23 at 9.18.17 AM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是&lt;strong&gt;把这个请求委派给父类加载器去完成&lt;/strong&gt;，每一个层次的类加载器都是如此，因此&lt;strong&gt;所有的加载请求最终都应该传送到顶层的启动类加载器中&lt;/strong&gt;，只有当&lt;strong&gt;父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;自定义类加载器&quot;&gt;自定义类加载器&lt;/h4&gt;
&lt;p&gt;首先看一下实现双亲委派模型的代码，逻辑就是先检查类是否已经被加载，如果没有则调用父加载器的loadClass（）方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException
  {
      synchronized (getClassLoadingLock(name)) {
          // 先从缓存查找该class对象，找到就不用重新加载
          Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
          if (c == null) {
              try {
                  if (parent != null) {
                      //如果找不到，则委托给父类加载器去加载
                      c = parent.loadClass(name, false);
                  } else {
                  //如果没有父类，则委托给启动加载器去加载
                      c = findBootstrapClassOrNull(name);
                  }
              } catch (ClassNotFoundException e) {
                  // ClassNotFoundException thrown if class not found
                  // from the non-null parent class loader
              }

              if (c == null) {
                  // If still not found, then invoke findClass in order
                  // 如果都没有找到，则通过自定义实现的findClass去查找并加载
                  c = findClass(name);
              }
          }
          if (resolve) {//是否需要在加载时进行解析
              resolveClass(c);
          }
          return c;
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实现自己的类加载器时，通常有两种做法，一种是重写loadClass方法，另一种是重写findClass方法。其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是最好不要直接修改loadClass的内部逻辑，以免破坏双亲委派的逻辑。推荐的做法是只在findClass里重写自定义类的加载方法。&lt;/p&gt;
&lt;p&gt;下面例子实现了文件系统类加载器，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FileSystemClassLoader extends ClassLoader { 
 
   private String rootDir; 
 
   public FileSystemClassLoader(String rootDir) { 
       this.rootDir = rootDir; 
   } 
 
   protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException { 
       byte[] classData = getClassData(name); 
       if (classData == null) { 
           throw new ClassNotFoundException(); 
       } 
       else { 
           return defineClass(name, classData, 0, classData.length); 
       } 
   } 
 
   private byte[] getClassData(String className) { 
       String path = classNameToPath(className); 
       try { 
           InputStream ins = new FileInputStream(path); 
           ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
           int bufferSize = 4096; 
           byte[] buffer = new byte[bufferSize]; 
           int bytesNumRead = 0; 
           while ((bytesNumRead = ins.read(buffer)) != -1) { 
               baos.write(buffer, 0, bytesNumRead); 
           } 
           return baos.toByteArray(); 
       } catch (IOException e) { 
           e.printStackTrace(); 
       } 
       return null; 
   } 
 
   private String classNameToPath(String className) { 
       return rootDir + File.separatorChar 
               + className.replace('.', File.separatorChar) + &quot;.class&quot;; 
   } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;class.forname和classloader.loadclass&quot;&gt;Class.forName和ClassLoader.loadClass&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Class.forName是Class类的方法public static Class&amp;lt;?&amp;gt; forName(String className) throws ClassNotFoundException&lt;/p&gt;
&lt;p&gt;ClassLoader.loadClass是ClassLoader类的方法public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Class.forName和ClassLoader.loadClass都可以用来进行类型加载，而在Java进行类型加载的时刻，一般会有多个ClassLoader可以使用，并可以使用多种方式进行类型加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class A {
    public void m() {
        A.class.getClassLoader().loadClass(“B”);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;A.class.getClassLoader().loadClass(“B”)&lt;/code&gt;;代码执行B的加载过程时，一般会有三个概念上的ClassLoader提供使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CurrentClassLoader&lt;/strong&gt;，称之为当前类加载器，简称CCL，在代码中对应的就是类型A的类加载器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpecificClassLoader&lt;/strong&gt;，称之为指定类加载器，简称SCL，在代码中对应的是 A.class.getClassLoader()，如果使用任意的ClassLoader进行加载，这个ClassLoader都可以称之为SCL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ThreadContextClassLoader&lt;/strong&gt;，称之为线程上下文类加载器，简称TCCL，每个线程都会拥有一个ClassLoader引用，而且可以通过Thread.currentThread().setContextClassLoader(ClassLoader classLoader)进行切换。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;SCL和TCCL可以理解为在代码中使用ClassLoader的引用进行类加载，而CCL却无法获取到其引用，虽然在代码中CCL == A.class.getClassLoader() == SCL。CCL的加载过程是由JVM运行时来控制的，是无法通过Java编程来更改的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;双亲委派机制的破坏&quot;&gt;双亲委派机制的破坏&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为什么需要破坏双亲委派？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。&lt;/p&gt;
&lt;p&gt;Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何破坏？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK1.2之前，classLoader类中没有定义findClass，当用户继承该类并且修改loadClass的实现时，就可能破坏双亲委派。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程上下文类加载器&lt;/strong&gt;（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。&lt;/li&gt;
&lt;li&gt;为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。OSGI实现模块化热部署的关键则是它自定义类加载器机制的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;tomcat类加载器&quot;&gt;Tomcat类加载器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Tomcat是个web容器， 那么它要解决什么问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。&lt;/li&gt;
&lt;li&gt;部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。&lt;/li&gt;
&lt;li&gt;web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。&lt;/li&gt;
&lt;li&gt;web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Tomcat 如果使用默认的类加载机制行不行&lt;/strong&gt; ？&lt;/p&gt;
&lt;p&gt;答案是不行的。为什么？&lt;/p&gt;
&lt;p&gt;第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。&lt;br/&gt;第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。&lt;br/&gt;第三个问题和第一个问题一样。&lt;br/&gt;第四个问题，我们要怎么实现jsp文件的热修改（楼主起的名字），jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tomcat 如何实现自己独特的类加载机制？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6hoxhz5wj20o6100gqa.jpg&quot; alt=&quot;Screen Shot 2019-12-23 at 11.21.18 AM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面3个类加载和默认的一致，&lt;strong&gt;CommonClassLoader&lt;/strong&gt;、&lt;strong&gt;CatalinaClassLoader&lt;/strong&gt;、&lt;strong&gt;SharedClassLoader&lt;/strong&gt;和&lt;strong&gt;WebappClassLoader&lt;/strong&gt;则是Tomcat自己定义的类加载器，它们分别加载&lt;code&gt;/common/*&lt;/code&gt;、&lt;code&gt;/server/*&lt;/code&gt;、&lt;code&gt;/shared/*&lt;/code&gt;（在tomcat 6之后已经合并到根目录下的lib目录下）和&lt;code&gt;/WebApp/WEB-INF/*&lt;/code&gt;中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；&lt;/li&gt;
&lt;li&gt;catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；&lt;/li&gt;
&lt;li&gt;sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；&lt;/li&gt;
&lt;li&gt;WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从图中的委派关系中可以看出：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。&lt;/p&gt;
&lt;p&gt;WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。&lt;/p&gt;
&lt;p&gt;而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图展示了Tomcat的类加载流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6hwg43vlj21040s6qhu.jpg&quot; alt=&quot;Screen Shot 2019-12-23 at 11.28.25 AM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当tomcat启动时，会创建几种类加载器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Bootstrap 引导类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载JVM启动所需的类，以及标准扩展类（位于jre/lib/ext下）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. System 系统类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Common 通用类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME/lib下，比如servlet-api.jar&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. webapp 应用类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib下的jar文件中的class 和 WEB-INF/classes下的class文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;典型面试题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tomcat 违背了java 推荐的双亲委派模型了吗？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;违背了，双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;h3 id=&quot;运行时栈帧结构&quot;&gt;3.6 运行时栈帧结构&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;栈帧&lt;/strong&gt;（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。典型栈帧结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6iirpn08j20pi0qe466.jpg&quot; alt=&quot;Screen Shot 2019-12-23 at 11.49.57 AM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面对各个部分进行仔细介绍：&lt;/p&gt;
&lt;h4 id=&quot;局部变量表&quot;&gt;局部变量表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以&lt;strong&gt;变量槽&lt;/strong&gt;（Variable Slot）为最小单位，虚拟机规范中并没有明确指定一个Slot应占用的内存空间大小，只是规定每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这样可以屏蔽32位跟64位虚拟机在内存空间上的差异。&lt;/p&gt;
&lt;p&gt;虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0到最大Slot数量，索引n对应第n个Slot。局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，即this。&lt;/p&gt;
&lt;p&gt;为了尽可能的节省栈帧空间，局部变量表中的Slot是&lt;strong&gt;可以重用&lt;/strong&gt;的，同时这也影响了垃圾收集行为。即对已使用完毕的变量，局部变量表仍持有该对象的引用，导致对象无法被GC回收，占用大量内存。这也是“&lt;strong&gt;不使用的对象应手动赋值为null&lt;/strong&gt;”这条推荐编码规则的原因。不过从执行角度使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上，代码在经过编译器优化后才是虚拟机真正需要执行的代码，这时赋null值会被消除掉，因此更优雅的解决办法是以恰当的变量作用域来控制变量回收时间。&lt;/p&gt;
&lt;h4 id=&quot;操作数栈&quot;&gt;操作数栈&lt;/h4&gt;
&lt;p&gt;操作数栈（Operand Stack）也常称操作栈，它是一个后入先出（Last In First Out,LIFO）栈。方法在执行过程中，通过各种字节码指令对栈进行操作，出栈/入栈。java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。&lt;/p&gt;
&lt;h4 id=&quot;动态连接&quot;&gt;动态连接&lt;/h4&gt;
&lt;p&gt;每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用时为了执行方法调用过程中的动态连接（Dynamic Linking）。&lt;/p&gt;
&lt;h4 id=&quot;方法返回地址&quot;&gt;方法返回地址&lt;/h4&gt;
&lt;p&gt;当一个方法开始执行后，只有两种方式可以退出这个方法：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行引擎遇到任意一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），这种退出方式称为正常完成出口（Normal Method Invocation Completion）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是java虚拟机内部产生的异常，还是代码使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口（Abrupt Method Invocation Completion），这时不会给它的上层调用者产生任何返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;恢复上层方法的局部变量表和操作数栈。&lt;/li&gt;
&lt;li&gt;把返回值（如果有）压入调用者栈帧的操作数栈。&lt;/li&gt;
&lt;li&gt;调整PC计数器的值以指向方法调用指令后面的一条指定等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;附加信息&quot;&gt;附加信息&lt;/h4&gt;
&lt;p&gt;虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，称之为栈帧信息。&lt;/p&gt;
&lt;h3 id=&quot;方法调用&quot;&gt;3.7 方法调用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方法调用并不等同于方法执行&lt;/strong&gt;，方法调用阶段的&lt;strong&gt;唯一任务就是确定被调用方法的版本&lt;/strong&gt;，即调用哪一个方法，暂时还不涉及方法内部的具体运行过程，就是类加载过程中的类方法解析。&lt;/p&gt;
&lt;h4 id=&quot;解析&quot;&gt;解析&lt;/h4&gt;
&lt;p&gt;解析就是将Class的常量池中的符号引用转化为直接引用（内存布局中的入口地址）。&lt;/p&gt;
&lt;p&gt;在java虚拟机中提供了5条方法调用字节码指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;invokestatic&lt;/strong&gt;：调用静态方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;System.exit(1);
==&amp;gt;编译
iconst_1    ;将1放入栈内
            ;执行System.exit()
invokestatic java/lang/System/exit(I)V&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;invokespecial&lt;/strong&gt;：调用实例构造器方法、私有方法和父类方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//&amp;lt;init&amp;gt;方法
new StringBuffer()
==&amp;gt;编译
new java/lang/StringBuffer    ;创建一个StringBuffer对象
dup                           ;将对象弹出栈顶
                              ;执行&amp;lt;init&amp;gt;()来初始化对象
invokespecial java/lang/StringBuffer/&amp;lt;init&amp;gt;()V

//父类方法
super.equals(x);
==&amp;gt;编译
aload_0   ;将this入栈
aload_1   ;将第一个参数入栈
          ;执行Object的equals()方法
invokespecial java/lang/Object/equals(Ljava/lang/Object;)Z

//私有方法
与父类方法类似&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;invokevirtual&lt;/strong&gt;：调用所有的虚方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;X x;
...
x.equals(&quot;abc&quot;);
==&amp;gt;编译
aload_1   ;将x入栈
ldc &quot;abc&quot;   ;将“abc”入栈
          ;执行equals()方法
invokevirtual X/equals(Ljava/lang/Object;)Z&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;invokeinterface&lt;/strong&gt;：调用接口方法，会在运行时再确定一个实现此接口的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;List x;
...
x.toString();
==&amp;gt;编译
aload_1   ;将x入栈
          ;执行toString()方法
invokeinterface java/util/List/toString()Z&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;invokedynamic&lt;/strong&gt;：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在编译阶段就可以确定唯一调用版本的方法有：&lt;strong&gt;静态方法（类名）&lt;/strong&gt;、&lt;strong&gt;私有方法&lt;/strong&gt;、&lt;strong&gt;实例构造器（）&lt;/strong&gt;、&lt;strong&gt;父类方法(super)&lt;/strong&gt;、&lt;strong&gt;final方法&lt;/strong&gt;。其它统称为虚方法，在编译阶段无法确定调用版本，需要在运行期通过分派将符号引用转变为直接引用。&lt;/p&gt;
&lt;h3 id=&quot;分派&quot;&gt;3.8 分派&lt;/h3&gt;
&lt;h4 id=&quot;静态分派&quot;&gt;静态分派&lt;/h4&gt;
&lt;p&gt;指在运行时对类内相同名称的方法根据描述符来确定执行版本的分派，&lt;strong&gt;多见于方法的重载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的例子中，输出结果均为&lt;code&gt;hello guy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。&lt;/p&gt;
&lt;p&gt;代码中定义了两个静态类型相同但实际类型不同的变量，但&lt;strong&gt;虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的&lt;/strong&gt;，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。&lt;strong&gt;静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6jh205cej20jd0d9n1o.jpg&quot; alt=&quot;Picture1.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;动态分派&quot;&gt;动态分派&lt;/h4&gt;
&lt;p&gt;指对于相同方法签名的方法根据实际执行对象来确定执行版本的分派。编译器是根据引用类型来判断方法是否可执行，真正执行的是实际对象方法。&lt;strong&gt;多见于类多态的实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态分配的实现，最常用的手段就是为类在方法区中建立一个虚方法表。虚方法表中存放着各个方法的实际入口地址。&lt;strong&gt;如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址&lt;/strong&gt;。PPT图中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1ga6jmoexhdj211o0q0dud.jpg&quot; alt=&quot;Screen Shot 2019-12-23 at 12.28.21 PM.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于栈的字节码解释执行引擎&quot;&gt;3.9 基于栈的字节码解释执行引擎&lt;/h3&gt;
&lt;p&gt;Java语言经常被人们定位为“解释执行”语言，在Java初生的JDK1.0时代，这种定义还比较准确的，但当主流的虚拟机中都包含了即时编译后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出来了直接生成本地代码的编译器[如何GCJ（GNU Compiler for the Java）]，而C/C++也出现了通过解释器执行的版本（如CINT），这时候再笼统的说“解释执行”，对于整个Java语言来说就成了几乎没有任何意义的概念。&lt;/p&gt;
&lt;h4 id=&quot;基于栈的指令集与基于寄存器的指令集&quot;&gt;基于栈的指令集与基于寄存器的指令集&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基于栈的指令集&lt;/strong&gt;：指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于寄存器的指令集&lt;/strong&gt;：最典型的就是X86的地址指令集，通俗一点，就是现在我们主流的PC机中直接支持的指令集架构，这些指令集依赖寄存器工作。&lt;/p&gt;
&lt;p&gt;举个简单例子，分别使用这两种指令计算1+1的结果，基于栈的指令集会是这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iconst_1
iconst_1
iadd
istore_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后将结果放回栈顶，最后istore_0把栈顶的值放到局部变量表中的第0个Slot中。&lt;/p&gt;
&lt;p&gt;如果基于寄存器的指令集，那程序可能会是这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mov eax, 1
add eax, 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mov指令把EAX寄存器的值设置为1，然后add指令再把这个值加1，将结果就保存在EAX寄存器里面。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于栈的指令集：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：可移植、代码相对更紧凑、编译器实现更简单等&lt;br/&gt;缺点：执行速度慢、完成相同功能的指令数量更多、栈位于内存中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于寄存器的指令集：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：速度快&lt;br/&gt;缺点：与硬件结合紧密&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;参考链接：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文由『后端精进之路』原创，首发于博客 &lt;a href=&quot;http://teckee.github.io/&quot; class=&quot;uri&quot;&gt;http://teckee.github.io/&lt;/a&gt; , 转载请注明出处&lt;/p&gt;
&lt;p&gt;搜索『后端精进之路』关注公众号，立刻获取最新文章和&lt;strong&gt;价值2000元的BATJ精品面试课程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/a18449c6gy1g9v9luujswj21n10l9jux.jpg&quot; alt=&quot;后端精进之路.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Feb 2020 15:33:00 +0000</pubDate>
<dc:creator>后端精进之路</dc:creator>
<og:description>3. 虚拟机执行子系统 3.1 Java跨平台的基础 Java刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere），其中字节码是构成平台无关的基石，也是语言无关性的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/way2backend/p/12285711.html</dc:identifier>
</item>
<item>
<title>我也写了个疫情传播仿真程序 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20200207-2019-ncov-simulation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20200207-2019-ncov-simulation.html</guid>
<description>&lt;p&gt;前一阵子看到有人制作了《疫情传播仿真程序》，是用&lt;code&gt;Java&lt;/code&gt;做的。里面根据多种实际情况，如居民移动意愿、医护能力、病毒传播能力，来模拟疫情的发展。看完之后，我暗暗称奇，特别是结合一些视频和照片，确实做得非常好。&lt;/p&gt;
&lt;p&gt;后来过了几天，这个视频还上了&lt;code&gt;人民日报&lt;/code&gt;的微信公众号，这时我们&lt;code&gt;.NET&lt;/code&gt;社区就开始骚动了起来😂😂，咱们&lt;code&gt;.NET&lt;/code&gt;能不能也做一个？&lt;/p&gt;
&lt;p&gt;既然有需要，&lt;code&gt;2月6号&lt;/code&gt;那天晚上我决定说干就干，经过两个晚上的思考与编码，已经有了初步效果……运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221610206-549817479.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个效果可以这样解读，如果不加以任何控制，疫情会很快蔓延到整个城市，只有&lt;code&gt;8:1000&lt;/code&gt;床位的城市，将很快失去控制，一年后运行效果如下（非常惨烈）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221624467-48805885.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码中实际有很多参数可以操作：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static double MoveWilling = 0.90f; // 移动意愿，0-1
static bool WearMask = false; // 是否戴口罩
static int HospitalBeds = 40; // 床位数

const float InffectRate = 0.8f; // 靠得够近时，被携带者感染的机率
const float SecondsPerDay = 0.3f; // 模拟器的秒数，对应真实一天
const float MovingDistancePerDay = 10.0f; // 每天移动距离
const int InitialInfectorCount = 5; // 最初感染者数
const double DeathRate = 0.021; // 死亡率

// 要靠多近，才会触发感染验证
static float SafeDistance() =&amp;gt; WearMask ? 1.5f : 3.5f;

// 住院治愈时间，最短5天，最长12.75天，平均约7天
static float GenerateCureDays() =&amp;gt; random.NextFloat(5, 12.75f);
// 潜伏期，1-14天
static float GenerateShadowDays() =&amp;gt; random.Next(1, 14);
// 发病后，就医时间，0-3天
static float GenerateToHospitalDays() =&amp;gt; random.Next(0, 3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于参数太多，很难在&lt;strong&gt;运行时&lt;/strong&gt;全部都做调整，我选取了&lt;strong&gt;是否戴口罩&lt;/strong&gt;、&lt;strong&gt;移动意愿&lt;/strong&gt;、&lt;strong&gt;医院床数&lt;/strong&gt;作为参数，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override void OnKeyPress(KeyPressEventArgs e)
{
    switch (e.KeyChar)
    {
        case '1': MoveWilling = 0.10f; break;
        case '2': MoveWilling = 0.50f; break;
        case '3': MoveWilling = 0.90f; break;
        case 'M': WearMask = !WearMask; break;
        case 'A': HospitalBeds += 40; break;
        case 'D': HospitalBeds -= 40; break;
        case 'R':
            {
                if (MessageBox.Show(&quot;要重来吗？&quot;, &quot;确认&quot;, MessageBoxButtons.YesNo) == DialogResult.Yes)
                {
                    City = City.Create();
                }
                break;
            }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，按数字键&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;可以指定不同的&lt;strong&gt;移动意愿&lt;/strong&gt;，其中&lt;code&gt;1&lt;/code&gt;表示居民最不愿意出门，&lt;code&gt;3&lt;/code&gt;表示最愿意，按&lt;code&gt;M&lt;/code&gt;可以控制居民是否能戴上口罩，按&lt;code&gt;A&lt;/code&gt;可以添加医院可接纳病人数。&lt;/p&gt;

&lt;h2 id=&quot;超多床位&quot;&gt;超多床位&lt;/h2&gt;
&lt;p&gt;这里我将床位调成&lt;code&gt;240&lt;/code&gt;个（比例为&lt;code&gt;48&lt;/code&gt;:&lt;code&gt;1000&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static int HospitalBeds = 240; // 床位数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以运行时增加床位，按键盘&lt;code&gt;A&lt;/code&gt;即可（不用改代码），运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221642188-997008855.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见床位变多后，死亡率会降低，治愈人数大大提高，但仍然无法控制住疫情的发展。&lt;/p&gt;
&lt;h2 id=&quot;理想情况1没有潜伏期&quot;&gt;“理想”情况1·没有潜伏期&lt;/h2&gt;
&lt;p&gt;可以这样配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 0潜伏期
static float GenerateShadowDays() =&amp;gt; 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221716297-834273502.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见就算潜伏期为&lt;code&gt;0&lt;/code&gt;，由于没有及时就医，疫情仍会失去控制。&lt;/p&gt;
&lt;h2 id=&quot;理想情况2没有潜伏期且立刻隔离就医&quot;&gt;“理想”情况2·没有潜伏期、且立刻隔离就医&lt;/h2&gt;
&lt;p&gt;像那个&lt;code&gt;Java&lt;/code&gt;版中，会先介绍一个“理想”情况，即感染即发病，发病即就就医。此种模型的参数，可以这样配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 0潜伏期
static float GenerateShadowDays() =&amp;gt; 0;
// 发病后，立即就医。
static float GenerateToHospitalDays() =&amp;gt; 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这种情况下，运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221721763-560200188.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，由最初的&lt;code&gt;5&lt;/code&gt;人，最终只感染了&lt;code&gt;6&lt;/code&gt;人，理想情况下局势很快就被控制。当然这种情况是不存在的。&lt;/p&gt;
&lt;h2 id=&quot;戴口罩出门&quot;&gt;戴口罩出门&lt;/h2&gt;
&lt;p&gt;假如居民都戴口罩出门，可以用如下配置（也可以运行时按下&lt;code&gt;M&lt;/code&gt;键）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static bool WearMask = true; // 一定戴口罩&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221809192-1240220558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;坚持了&lt;code&gt;107&lt;/code&gt;天，疫情发展速度大大降低，但由于医疗资源的匮乏，死亡率仍然居高不下，最终仍会失去控制。&lt;/p&gt;
&lt;h2 id=&quot;居民呆在家中不出门且戴口罩&quot;&gt;居民呆在家中不出门，且戴口罩&lt;/h2&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static bool WearMask = true; // 一定戴口罩
static double MoveWilling = 0.10f; // 每天只有10%的人愿意出门&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221819181-968434339.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;病毒在最初的&lt;code&gt;5&lt;/code&gt;人身上，只感染了&lt;code&gt;2&lt;/code&gt;人。效率可谓惊人。&lt;/p&gt;

&lt;p&gt;我想贴近现实，模拟一些现实情况，然后看看效果如何，我的脚本如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前&lt;code&gt;20&lt;/code&gt;天，不作任何控制&lt;/li&gt;
&lt;li&gt;第&lt;code&gt;20&lt;/code&gt;天，全民戴口罩，移动意愿降低至&lt;code&gt;50%&lt;/code&gt;，床位增加&lt;code&gt;40&lt;/code&gt;个（模拟进入&lt;strong&gt;重大突发公共卫生事件Ⅰ级响应&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;第&lt;code&gt;25&lt;/code&gt;天，移动愿意降低至&lt;code&gt;10%&lt;/code&gt;，床位增加&lt;code&gt;80&lt;/code&gt;个（模拟火神山医院）&lt;/li&gt;
&lt;li&gt;第&lt;code&gt;30&lt;/code&gt;天，床位再增加&lt;code&gt;80&lt;/code&gt;个，共&lt;code&gt;240&lt;/code&gt;个（模拟雷神山医院）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了尽可能短地截取&lt;code&gt;gif&lt;/code&gt;，我将时间缩短了，真实时间可能会和这个比例为&lt;code&gt;1:2&lt;/code&gt;（也就是相当于前&lt;code&gt;40&lt;/code&gt;天不作任何控制），脚本如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;void StepDay()
{
    if (day &amp;lt; 20)
    {
        WearMask = false;
        MoveWilling = 0.9;
        HospitalBeds = 40;
    }
    if (day &amp;gt;= 20)
    {
        WearMask = true;
        MoveWilling = 0.5;
        HospitalBeds = 80;
    }
    if (day &amp;gt;= 25)
    {
        MoveWilling = 0.1;
        HospitalBeds = 160;
    }
    if (day &amp;gt;= 30)
    {
        HospitalBeds = 240;
    }

    // 其它代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/202002/233608-20200208221830038-842412086.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见这真是与病毒的一部史诗级斗争。&lt;/p&gt;
&lt;p&gt;前&lt;code&gt;20&lt;/code&gt;天，没有任何控制，病毒疯狂肆虐，前期只花了&lt;code&gt;9&lt;/code&gt;天，就把医院给挤满了；&lt;/p&gt;
&lt;p&gt;第&lt;code&gt;20&lt;/code&gt;之后，居民带上口罩，传播进度迅速下降，但由于潜伏期较长，发病人数仍然持续上升；&lt;/p&gt;
&lt;p&gt;第&lt;code&gt;30&lt;/code&gt;天之后，由于&lt;code&gt;5&lt;/code&gt;天前床位（医护资源）的跟进，发病人数增速降低；&lt;/p&gt;
&lt;p&gt;第&lt;code&gt;35&lt;/code&gt;天后，发病人数开始下降；&lt;/p&gt;
&lt;p&gt;第&lt;code&gt;68&lt;/code&gt;天后，除了医院中的病人，城市中已经没有病人；&lt;/p&gt;
&lt;p&gt;第&lt;code&gt;78&lt;/code&gt;天，已经没有被病毒感染的人了。&lt;/p&gt;

&lt;p&gt;所有这些代码，我都上传到了我的博客数据网站，各们可以下载代码，通过&lt;code&gt;LINQPad 6&lt;/code&gt;直接模拟运行，或者拷到&lt;code&gt;Visual Studio&lt;/code&gt;中亦可。各位也可以或者提出您的想法，&lt;code&gt;Github&lt;/code&gt;链接如下：&lt;br/&gt;&lt;a href=&quot;https://github.com/sdcb/blog-data/tree/master/2020/20200207-2019-ncov-simulate&quot; class=&quot;uri&quot;&gt;https://github.com/sdcb/blog-data/tree/master/2020/20200207-2019-ncov-simulate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写完这个东西，给我最大的感受就是震撼，模拟起来就是一些数据而已，但背后是千千万万有血有肉的病人和医务工作者，向那些伟大的“逆行者”们致敬！&lt;/p&gt;
&lt;p&gt;从上面的数据也可以看出，任何单项指标做好，都是不能完全阻止疫情的。我们要相互信任，做好自己。我们能做的有：尽可能呆在家，别出门，就&lt;strong&gt;真&lt;/strong&gt;是对国家最好的贡献；出门一定要戴口罩，这样可以明显降低感染率。&lt;/p&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，在新的一年里，祝大家阖家欢乐，鼠年大吉！&lt;/p&gt;
</description>
<pubDate>Sat, 08 Feb 2020 14:53:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>用代码仿真疫情传播，有那么难嘛？我用.NET也写了一个。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20200207-2019-ncov-simulation.html</dc:identifier>
</item>
<item>
<title>TS 原理详细解读(5)语法2-语法解析 - xuld</title>
<link>http://www.cnblogs.com/xuld/p/12266985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuld/p/12266985.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuld/p/12238167.html&quot; target=&quot;_blank&quot;&gt;上一节&lt;/a&gt;介绍了语法树的结构，本节则介绍如何解析标记组成语法树。&lt;/p&gt;
&lt;p&gt;对应的源码位于 src/compiler/parser.ts。&lt;/p&gt;

&lt;h2&gt;入口函数&lt;/h2&gt;
&lt;p&gt;要解析一份源码，输入当然是源码内容（字符串），同时还提供路径（用于报错）、语言版本（比如ES3 和 ES5 在有些细节不同）。&lt;/p&gt;
&lt;p&gt;createSourceFile 是负责将源码解析为语法树的入口函数，用户可以直接调用：比如 ts.createSourceFile(‘&amp;lt;stdio&amp;gt;’, 'var xld;')。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
export function createSourceFile(fileName: &lt;span&gt;string&lt;/span&gt;, sourceText: &lt;span&gt;string&lt;/span&gt;, languageVersion: ScriptTarget, setParentNodes = &lt;span&gt;false&lt;/span&gt;, scriptKind?&lt;span&gt;: ScriptKind): SourceFile {
        performance.mark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beforeParse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        let result: SourceFile;

        perfLogger.logStartParseSourceFile(fileName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (languageVersion ===&lt;span&gt; ScriptTarget.JSON) {
            result &lt;/span&gt;= Parser.parseSourceFile(fileName, sourceText, languageVersion, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;syntaxCursor&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; undefined, setParentNodes, ScriptKind.JSON);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;= Parser.parseSourceFile(fileName, sourceText, languageVersion, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;syntaxCursor&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; undefined, setParentNodes, scriptKind);
        }
        perfLogger.logStopParseSourceFile();

        performance.mark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;afterParse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        performance.measure(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beforeParse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;afterParse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;入口函数内部除了某些性能测试代码，主要是调用 Parser.parseSourceFile 完成解析。&lt;/p&gt;
&lt;h2&gt;解析源文件对象&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt; parseSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, syntaxCursor: IncrementalParser.SyntaxCursor | undefined, setParentNodes = &lt;span&gt;false&lt;/span&gt;, scriptKind?&lt;span&gt;: ScriptKind): SourceFile {
    scriptKind &lt;/span&gt;=&lt;span&gt; ensureScriptKind(fileName, scriptKind);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ...(略)... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    initializeState(sourceText, languageVersion, syntaxCursor, scriptKind);

    const result &lt;/span&gt;=&lt;span&gt; parseSourceFileWorker(fileName, languageVersion, setParentNodes, scriptKind);

    clearState();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; initializeState(_sourceText: string, languageVersion: ScriptTarget, _syntaxCursor: IncrementalParser.SyntaxCursor |&lt;span&gt; undefined, scriptKind: ScriptKind) {
    NodeConstructor &lt;/span&gt;=&lt;span&gt; objectAllocator.getNodeConstructor();
    TokenConstructor &lt;/span&gt;=&lt;span&gt; objectAllocator.getTokenConstructor();
    IdentifierConstructor &lt;/span&gt;=&lt;span&gt; objectAllocator.getIdentifierConstructor();
    SourceFileConstructor &lt;/span&gt;=&lt;span&gt; objectAllocator.getSourceFileConstructor();

    sourceText &lt;/span&gt;=&lt;span&gt; _sourceText;
    syntaxCursor &lt;/span&gt;=&lt;span&gt; _syntaxCursor;

    parseDiagnostics &lt;/span&gt;=&lt;span&gt; [];
    parsingContext &lt;/span&gt;= 0&lt;span&gt;;
    identifiers &lt;/span&gt;= createMap&amp;lt;string&amp;gt;&lt;span&gt;();
    identifierCount &lt;/span&gt;= 0&lt;span&gt;;
    nodeCount &lt;/span&gt;= 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (scriptKind) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ScriptKind.JS:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ScriptKind.JSX:
            contextFlags &lt;/span&gt;=&lt;span&gt; NodeFlags.JavaScriptFile;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ScriptKind.JSON:
            contextFlags &lt;/span&gt;= NodeFlags.JavaScriptFile |&lt;span&gt; NodeFlags.JsonFile;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            contextFlags &lt;/span&gt;=&lt;span&gt; NodeFlags.None;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    parseErrorBeforeNextFinishedNode &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize and prime the scanner before parsing the source elements.&lt;/span&gt;
&lt;span&gt;    scanner.setText(sourceText);
    scanner.setOnError(scanError);
    scanner.setScriptTarget(languageVersion);
    scanner.setLanguageVariant(getLanguageVariant(scriptKind));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你仔细读了这段代码，你可能会有这些疑问：&lt;/p&gt;
&lt;h4&gt;1. NodeConstructor 等是什么&lt;/h4&gt;
&lt;p&gt;你可以直接将它看成 Node 类的构造函数，new NodeConstructor 和 new Node 是一回事。那为什么不直接用 new Node? 这是一种性能优化手段。TS 设计的目的是用于任何 JS 引擎，包括浏览器、Node.js、微软自己的 JS 引擎，而 Node 代表语法树节点，数目会非常多，TS 允许针对不同的环境使用不同的 Node 类型，以达到最节约内存的效果。&lt;/p&gt;
&lt;h4&gt;2. syntaxCursor 是什么&lt;/h4&gt;
&lt;p&gt;这是用于增量解析的对象，如果不执行增量解析，它是空的。增量解析是指如果之前已解析过一次源码，第二次解析时可以复用上次解析的结果，主要在编译器场景使用：编辑完源码后，源码要重新解析为语法树，如果通过增量解析，可以大幅减少解析次数。增量解析将在下一节中详细介绍。&lt;/p&gt;
&lt;h4&gt;3. identifiers 是什么&lt;/h4&gt;
&lt;p&gt;一般地，我们认为：源码中的单词都会用两次以上（变量名总会有定义和使用的时候，这里就有两次），如果将相同内容的字符串共用相同的引用，可以节约内存。identifiers 就保存了每个字符串内存的唯一引用。&lt;/p&gt;
&lt;h4&gt;4. parsingContext 是什么&lt;/h4&gt;
&lt;p&gt;用于指代当前解析所在的标记位，比如当前函数是否有 async，这样可以判断 await 是否合法。&lt;/p&gt;
&lt;h4&gt;5. parseErrorBeforeNextFinishedNode 是什么&lt;/h4&gt;
&lt;p&gt;每个语法树节点，都通过 createNode 创建，然后结束时会调用 finishNode，如果在解析一个语法树节点时出现错误（可能是词法扫描错误、也可能是语法错误），都会把 parseErrorBeforeNextFinishedNode 改成 true，在 finishNode 中会判断这个变量，然后标记这个语法树节点存在语法错误。TypeScript 比其它语法解析器强大的地方在于碰到语法错误后并不会终止解析，而是尝试修复源码。（因为在编辑器环境，不可能因为存在错误就停止自动补全）。这里标记节点语法错误，是为了下次增量解析时禁止重用此节点。&lt;/p&gt;
&lt;h2&gt;解析过程&lt;/h2&gt;
&lt;p&gt;虽然这篇文章叫 TypeScript 源码解读，但其实主要是介绍编译器的实现原理，知道了这些原理，无论什么语言的编译器你都能弄明白，反过来如果你之前没有什么基础想要自己读懂 TypeScript，那是很难的。源码就像水果，你需要自己剥；这篇文章就像果汁，营养吸收地更快。插图是展示原理的最好方式，因此文中会包含大量的插图，如果你现在读的这个网页是纯文字，一张插图都没有，那么这个网站就是盗版侵权的，请重新百度。原版都是有插图的，插图可以让你快速理解原理！这类文章目前不止中文版的稀缺，英文版的同样稀缺，毕竟了解编译原理、且真正能开发出语言的人是非常少的。有兴趣读这些文章的也绝不是只知道搬砖赚钱的菜鸟，请支持原版！&lt;/p&gt;

&lt;p&gt;解析器每次读取一个标记，并根据这个标记判断接下来是什么语法，比如碰到 if 就知道是 if 语句，碰到 var 知道是变量声明。&lt;/p&gt;
&lt;p&gt;当发现 if 之后，根据 if 语句的定义，接下来会强制读取一个 “(” 标记，如果读不到就报错：语法错误，缺少“(”。读完 “(” 后解析一个表达式，然后再解析一个“)”，然后再解析一个语句，如果这时接下来发现一个 else，就继续读一个语句，否则直接终止，然后重新判断下一个标记的语法。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/158732/202002/158732-20200208212256029-1239221510.png&quot; alt=&quot;&quot; width=&quot;856&quot; height=&quot;809&quot;/&gt;&lt;/p&gt;



&lt;p&gt;if 语句的语法定义是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IfStatement:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( Expression ) Statement
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( Expression ) Statement &lt;span&gt;else&lt;/span&gt; Statement
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个定义的意思是：if 语句(IfStatement)有两种语法，当然无论哪种，开头都是 if ( Expression ) Statement&lt;/p&gt;
&lt;p&gt;为什么是这样定义的呢，这是因为JS是遵守ECMA-262规范的，而ECMA-262规范就像一种协议，规定了 if 语句要怎么定义。&lt;/p&gt;
&lt;p&gt;ECMA-262 规范也有很多版本，熟悉的ES3,ES5,ES6 这些其实就是这个规范的版本。ES10的版本可以在这里查看：&lt;a href=&quot;http://www.ecma-international.org/ecma-262/10.0/index.html#sec-grammar-summary&quot;&gt;http://www.ecma-international.org/ecma-262/10.0/index.html#sec-grammar-summary&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;p&gt;源文件由语句组成，首先读取下一个标记（nextToken）；然后解析语句列表（parseList, parseStatement）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; parseSourceFileWorker(fileName: string, languageVersion: ScriptTarget, setParentNodes: &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;, scriptKind: ScriptKind): SourceFile {
    const isDeclarationFile &lt;/span&gt;=&lt;span&gt; isDeclarationFileName(fileName);

    sourceFile &lt;/span&gt;=&lt;span&gt; createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile);
    sourceFile.flags &lt;/span&gt;=&lt;span&gt; contextFlags;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Prime the scanner.&lt;/span&gt;
&lt;span&gt;    nextToken();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A member of ReadonlyArray&amp;lt;T&amp;gt; isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future&lt;/span&gt;
&lt;span&gt;    processCommentPragmas(sourceFile as {} as PragmaContext, sourceText);
    processPragmasIntoFields(sourceFile as {} as PragmaContext, reportPragmaDiagnostic);

    sourceFile.statements &lt;/span&gt;=&lt;span&gt; parseList(ParsingContext.SourceElements, parseStatement);
    Debug.assert(token() &lt;/span&gt;===&lt;span&gt; SyntaxKind.EndOfFileToken);
    sourceFile.endOfFileToken &lt;/span&gt;=&lt;span&gt; addJSDocComment(parseTokenNode());

    setExternalModuleIndicator(sourceFile);

    sourceFile.nodeCount &lt;/span&gt;=&lt;span&gt; nodeCount;
    sourceFile.identifierCount &lt;/span&gt;=&lt;span&gt; identifierCount;
    sourceFile.identifiers &lt;/span&gt;=&lt;span&gt; identifiers;
    sourceFile.parseDiagnostics &lt;/span&gt;=&lt;span&gt; parseDiagnostics;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setParentNodes) {
        fixupParentReferences(sourceFile);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sourceFile;

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reportPragmaDiagnostic(pos: number, end: number, diagnostic: DiagnosticMessage) {
        parseDiagnostics.push(createFileDiagnostic(sourceFile, pos, end, diagnostic));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析一个语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseStatement(): Statement {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (token()) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SyntaxKind.SemicolonToken:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parseEmptyStatement();
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SyntaxKind.OpenBraceToken:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; parseBlock(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;ignoreMissingOpenBrace&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SyntaxKind.VarKeyword:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; parseVariableStatement(&amp;lt;VariableStatement&amp;gt;&lt;span&gt;createNodeWithJSDoc(SyntaxKind.VariableDeclaration));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...(略)&lt;/span&gt;
&lt;span&gt;    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;规则很简单：&lt;/p&gt;
&lt;p&gt;先看现在标记是什么，比如是 var，说明是一个 var 语句，那就继续解析 var 语句:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseVariableStatement(node: VariableStatement): VariableStatement {
    node.kind &lt;/span&gt;=&lt;span&gt; SyntaxKind.VariableStatement;
    node.declarationList &lt;/span&gt;= parseVariableDeclarationList(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;inForStatementInitializer&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    parseSemicolon();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; finishNode(node);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;var 语句的解析过程为先解析一个声明列表，然后解析分号（parseSemicolon）&lt;/p&gt;

&lt;p&gt;再看一个 while 语句的解析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseWhileStatement(): WhileStatement {
    const node &lt;/span&gt;= &amp;lt;WhileStatement&amp;gt;&lt;span&gt;createNode(SyntaxKind.WhileStatement);
    parseExpected(SyntaxKind.WhileKeyword);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; while&lt;/span&gt;
    parseExpected(SyntaxKind.OpenParenToken); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;
    node.expression = allowInAnd(parseExpression); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; *Expession*&lt;/span&gt;
    parseExpected(SyntaxKind.CloseParenToken); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; )&lt;/span&gt;
    node.statement = parseStatement(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; *Statement*&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; finishNode(node);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所谓语法解析，就是把每个不同的语法都这样解析一次，然后得到语法树。&lt;/p&gt;

&lt;p&gt;其中，最复杂的应该是解析列表（parseList）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parses a list of elements&lt;/span&gt;
 &lt;span&gt;function&lt;/span&gt; parseList&amp;lt;T extends Node&amp;gt;(kind: ParsingContext, parseElement: () =&amp;gt; T): NodeArray&amp;lt;T&amp;gt;&lt;span&gt; {
    const saveParsingContext &lt;/span&gt;=&lt;span&gt; parsingContext;
    parsingContext &lt;/span&gt;|= 1 &amp;lt;&amp;lt;&lt;span&gt; kind;
    const list &lt;/span&gt;=&lt;span&gt; [];
    const listPos &lt;/span&gt;=&lt;span&gt; getNodePos();

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;isListTerminator(kind)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isListElement(kind, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;inErrorRecovery&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) {
            const element &lt;/span&gt;=&lt;span&gt; parseListElement(kind, parseElement);
            list.push(element);

            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (abortParsingListOrMoveToNextToken(kind)) {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    parsingContext &lt;/span&gt;=&lt;span&gt; saveParsingContext;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createNodeArray(list, listPos);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parseList 的核心就是一个循环，只要列表没有结束，就一直解析同一种语法。&lt;/p&gt;
&lt;p&gt;比如解析参数列表，碰到“)”表示列表结束，否则一直解析“参数”；比如解析数组表达式，碰到“]”结束。&lt;/p&gt;
&lt;p&gt;如果理论接下来应该解析参数时，但下一个标记又不是参数，则会出现语法错误，但接下来应该解析解析参数，还是不再继续参数列表，这时候用 abortParsingListOrMoveToNextToken 判断。&lt;/p&gt;

&lt;p&gt;其中，kind: ParsingContext 用于区分不同的列表（是参数，还是数组？或者别的？）&lt;/p&gt;

&lt;h3&gt;列表结束&lt;/h3&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
// True if positioned at a list terminator
function isListTerminator(kind: ParsingContext): boolean&lt;span&gt; {
    if (token() ===&lt;span&gt; SyntaxKind.EndOfFileToken) {
        // Being at the end of the file ends all lists.
        return true&lt;span&gt;;
    }

    switch&lt;span&gt; (kind) {
        case&lt;span&gt; ParsingContext.BlockStatements:
        case&lt;span&gt; ParsingContext.SwitchClauses:
        case&lt;span&gt; ParsingContext.TypeMembers:
            return token() ===&lt;span&gt; SyntaxKind.CloseBraceToken;
        // ...(略)
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：对于有括号的标记，只有碰到右半括号，才能停止解析，其它的比如继承列表(extends A, B, C) 碰到 “{” 就结束。&lt;/p&gt;

&lt;h3&gt;解析元素&lt;/h3&gt;
&lt;/div&gt;
&lt;div readability=&quot;131&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; parseListElement&amp;lt;T extends Node&amp;gt;(parsingContext: ParsingContext, parseElement: () =&amp;gt;&lt;span&gt; T): T {
    const node &lt;/span&gt;=&lt;span&gt; currentNode(parsingContext);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt;consumeNode(node);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parseElement();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里本质是使用了 parseElement，其它代码是为了增量解析（后面详解）&lt;/p&gt;

&lt;h3&gt;继续列表？&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; abortParsingListOrMoveToNextToken(kind: ParsingContext) {
    parseErrorAtCurrentToken(parsingContextErrors(kind));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isInSomeParsingContext()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    nextToken();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; True if positioned at element or terminator of the current list or any enclosing list&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; isInSomeParsingContext(): &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let kind = 0; kind &amp;lt; ParsingContext.Count; kind++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parsingContext &amp;amp; (1 &amp;lt;&amp;lt; kind)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要是任意一种上下文&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (isListElement(kind, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;inErrorRecovery&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;) ||&lt;span&gt; isListTerminator(kind)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：如果接下来的标记是合法的元素，就继续解析，此时解析器认为用户只是忘打逗号之类的分隔符。如果不是说明这个列表根本就是有问题的，不再继续犯错。&lt;/p&gt;

&lt;p&gt;上面重点介绍了 if 的语法，其它都大同小异，就不再介绍。&lt;/p&gt;
&lt;p&gt;现在你应该知道语法树产生的大致过程了，如果仍不懂的，可在此处停顿往回复习，并对照源码，加以理解。&lt;/p&gt;

&lt;h2&gt;语法上下文&lt;/h2&gt;
&lt;p&gt;有些语法的使用是有要求的，比如 await 只在 async 函数内部才作关键字。&lt;/p&gt;
&lt;p&gt;源码中用闭包内全局的变量存储这些信息。思路是：先设置允许 await 标记位，然后解析表达式（这时标记位已设置成允许 await），解析完成则清除标记位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; doInAwaitContext&amp;lt;T&amp;gt;(func: () =&amp;gt;&lt;span&gt; T): T {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doInsideOfContext(NodeFlags.AwaitContext, func);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; doInsideOfContext&amp;lt;T&amp;gt;(context: NodeFlags, func: () =&amp;gt;&lt;span&gt; T): T {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contextFlagsToSet will contain only the context flags that&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; are not currently set that we need to temporarily enable.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We don't just blindly reset to the previous flags to ensure&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; that we do not mutate cached flags for the incremental&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HasAggregatedChildData).&lt;/span&gt;
    const contextFlagsToSet = context &amp;amp; ~&lt;span&gt;contextFlags;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (contextFlagsToSet) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set the requested context flags&lt;/span&gt;
        setContextFlag(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, contextFlagsToSet);
        const result &lt;/span&gt;=&lt;span&gt; func();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reset the context flags we just set&lt;/span&gt;
        setContextFlag(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, contextFlagsToSet);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no need to do anything special as we are already in all of the requested contexts&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; func();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这也是为什么规范中每个语法名称后面都带了一个小括号的原因：表示此处的表达式是否包括 await 这样的意义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IfStatement&lt;sub&gt;[Yield, Await, Return]&lt;/sub&gt;:
   &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?&lt;span&gt;Return]
   &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，+In 表示允许 in 标记，?yield 表示 yield 标记保持不变，- in 表示禁止 in 标记。&lt;/p&gt;

&lt;p&gt;通过上下文语法，下面这样的代码是不允许的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; x = key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; item; x; ) {
      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(虽然 in 是本身也是可以直接使用的运算符，但不能用于 for 的初始值，否则按 for..in 解析。）&lt;/p&gt;

&lt;h2&gt;后瞻（lookahead)&lt;/h2&gt;
&lt;p&gt;上面举的例子，都是可以通过第一个标记就可以确定后面的语法（比如碰到 if 就按 if 语句处理）。那有没可能只看第一个标记无法确定之后的语法呢？&lt;/p&gt;
&lt;p&gt;早期的 JS 版本是没有的（毕竟这样编译器做起来简单），但随着 JS 功能不断增加，就出现了这样的情况。&lt;/p&gt;
&lt;p&gt;比如直接 x 是变量，如果后面有箭头， x =&amp;gt;，就成了参数。&lt;/p&gt;
&lt;p&gt;这时需要用到语法后瞻，所谓的后瞻就是提前看一下后面的标记，然后决定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Invokes the provided callback then unconditionally restores the parser to the state it
 * was in immediately prior to invoking the callback.  The result of invoking the callback
 * is returned from this function.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; lookAhead&amp;lt;T&amp;gt;(callback: () =&amp;gt;&lt;span&gt; T): T {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; speculationHelper(callback, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;isLookAhead&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; speculationHelper&amp;lt;T&amp;gt;(callback: () =&amp;gt; T, isLookAhead: &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;): T {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Keep track of the state we'll need to rollback to if lookahead fails (or if the&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; caller asked us to always reset our state).&lt;/span&gt;
    const saveToken =&lt;span&gt; currentToken;
    const saveParseDiagnosticsLength &lt;/span&gt;=&lt;span&gt; parseDiagnostics.length;
    const saveParseErrorBeforeNextFinishedNode &lt;/span&gt;=&lt;span&gt; parseErrorBeforeNextFinishedNode;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: it is not actually necessary to save/restore the context flags here.  That's&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; because the saving/restoring of these flags happens naturally through the recursive&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; descent nature of our parser.  However, we still store this here just so we can&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert that invariant holds.&lt;/span&gt;
    const saveContextFlags =&lt;span&gt; contextFlags;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we're only looking ahead, then tell the scanner to only lookahead as well.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise, if we're actually speculatively parsing, then tell the scanner to do the&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; same.&lt;/span&gt;
    const result =&lt;span&gt; isLookAhead
        &lt;/span&gt;?&lt;span&gt; scanner.lookAhead(callback)
        : scanner.tryScan(callback);

    Debug.assert(saveContextFlags &lt;/span&gt;===&lt;span&gt; contextFlags);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If our callback returned something 'falsy' or we're just looking ahead,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; then unconditionally restore us to where we were.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!result ||&lt;span&gt; isLookAhead) {
        currentToken &lt;/span&gt;=&lt;span&gt; saveToken;
        parseDiagnostics.length &lt;/span&gt;=&lt;span&gt; saveParseDiagnosticsLength;
        parseErrorBeforeNextFinishedNode &lt;/span&gt;=&lt;span&gt; saveParseErrorBeforeNextFinishedNode;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说的比较简单，具体实现稍微麻烦：如果预览的时候发现标记错误咋办？所以需要先记住当前的错误信息，然后使用扫描器的预览功能读取之后的标记，之后完全恢复到之前的状态。&lt;/p&gt;

&lt;p&gt;TypeScript 中有哪些语法要后瞻呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;T&amp;gt; 可能是类型转换（&amp;lt;any&amp;gt;x）、箭头函数( &amp;lt;T&amp;gt; x =&amp;gt; {}）或 JSX （&amp;lt;T&amp;gt;X&amp;lt;/T&amp;gt;）&lt;/li&gt;
&lt;li&gt;public 可能是修饰符(public class A {})，或变量（public++）&lt;/li&gt;
&lt;li&gt;type 在后面跟标识符时才是别名类型，否则作变量&lt;/li&gt;
&lt;li&gt;let 只有在后面跟标识符时才是变量声明，否则是变量，但 let let = 1 是不对的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到语法后瞻增加了编译器的复杂度，也浪费了一些性能。&lt;/p&gt;
&lt;p&gt;虽然语法设计者尽量避免出现这样的后瞻，但还是有一些地方，因为兼容问题不得不采用这个方案。&lt;/p&gt;

&lt;h2&gt;语法歧义&lt;/h2&gt;
&lt;h3&gt;/ 的歧义&lt;/h3&gt;
&lt;p&gt;之前提到的 / 可能是除号或正则表达式，在词法阶段还无法分析，但在语法解析阶段，因为已知道现在需要什么语法，可以正确地处理这个符号。&lt;/p&gt;
&lt;p&gt;比如需要表达式的时候，碰到 /，因为 / 不能是表达式的开头，只能把 / 重新按正则表达式标记解析。如果在表达式后面碰到 /，那就作除号。&lt;/p&gt;

&lt;p&gt;但也有些歧义是语法解析阶段都很难处理的。&lt;/p&gt;
&lt;h3&gt;&amp;lt; 的歧义&lt;/h3&gt;
&lt;p&gt;比如 call&amp;lt;number,  any&amp;gt;(x)，你可能觉得是调用 call 泛型函数（参数  x），但它也可以理解成： (call &amp;lt; number) , (any &amp;gt; (x))&lt;/p&gt;
&lt;p&gt;所有支持泛型的C风格语言都有类似的问题，多数编译器的做法是：和你想的一样，按泛型看，毕竟一般人很少在 &amp;gt; 后面写括号。&lt;/p&gt;

&lt;p&gt;在 TS 设计之初，&amp;lt;T&amp;gt;x 是表示类型转换的，这个设计源于 C。但后来为了支持 JSX，这个语法就和 JSX 彻底冲突了。&lt;/p&gt;
&lt;p&gt;因此 TS 选择的方案是：引入 as 语法，&amp;lt;T&amp;gt;x 和 x as T 完全相同。同时引入 tsx 扩展名，在 tsx 中，&amp;lt;T&amp;gt; 当 JSX，在普通 ts，&amp;lt;T&amp;gt; 依然是类型转换（为兼容）。&lt;/p&gt;

&lt;h2&gt;插入分号&lt;/h2&gt;
&lt;p&gt;JS 一向允许省略分号，在需要解析分号的地方判断后面的标记是否是“}”，或包含空行。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; canParseSemicolon() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If there's a real semicolon, then we can always parse it out.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (token() ===&lt;span&gt; SyntaxKind.SemicolonToken) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We can parse out an optional semicolon in ASI cases in the following cases.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; token() === SyntaxKind.CloseBraceToken || token() === SyntaxKind.EndOfFileToken ||&lt;span&gt; scanner.hasPrecedingLineBreak();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JSDoc&lt;/h2&gt;
&lt;p&gt;TS 为了尽可能兼容 JS，允许用户直接使用 JS + JSDoc 的方式备注类型，所以 JS 里的 JSDoc 注释也按源码的一部分解析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* @type {string} &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; x = 120
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt; parseIsolatedJSDocComment(content: string, start: number | undefined, length: number | undefined): { jsDoc: JSDoc, diagnostics: Diagnostic[] } |&lt;span&gt; undefined {
    initializeState(content, ScriptTarget.Latest, &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;_syntaxCursor:&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; undefined, ScriptKind.JS);
    sourceFile &lt;/span&gt;= &amp;lt;SourceFile&amp;gt;&lt;span&gt;{ languageVariant: LanguageVariant.Standard, text: content };
    const jsDoc &lt;/span&gt;= doInsideOfContext(NodeFlags.None, () =&amp;gt;&lt;span&gt; parseJSDocCommentWorker(start, length));
    const diagnostics &lt;/span&gt;=&lt;span&gt; parseDiagnostics;
    clearState();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; jsDoc ?&lt;span&gt; { jsDoc, diagnostics } : undefined;
}

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; parseJSDocComment(parent: HasJSDoc, start: number, length: number): JSDoc |&lt;span&gt; undefined {
    const saveToken &lt;/span&gt;=&lt;span&gt; currentToken;
    const saveParseDiagnosticsLength &lt;/span&gt;=&lt;span&gt; parseDiagnostics.length;
    const saveParseErrorBeforeNextFinishedNode &lt;/span&gt;=&lt;span&gt; parseErrorBeforeNextFinishedNode;

    const comment &lt;/span&gt;= doInsideOfContext(NodeFlags.None, () =&amp;gt;&lt;span&gt; parseJSDocCommentWorker(start, length));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (comment) {
        comment.parent &lt;/span&gt;=&lt;span&gt; parent;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contextFlags &amp;amp;&lt;span&gt; NodeFlags.JavaScriptFile) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;sourceFile.jsDocDiagnostics) {
            sourceFile.jsDocDiagnostics &lt;/span&gt;=&lt;span&gt; [];
        }
        sourceFile.jsDocDiagnostics.push(...parseDiagnostics);
    }
    currentToken &lt;/span&gt;=&lt;span&gt; saveToken;
    parseDiagnostics.length &lt;/span&gt;=&lt;span&gt; saveParseDiagnosticsLength;
    parseErrorBeforeNextFinishedNode &lt;/span&gt;=&lt;span&gt; saveParseErrorBeforeNextFinishedNode;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; comment;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本节介绍了语法解析，并提到了 TS 如何在碰到错误后继续解析。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下节将重点介绍增量解析。 #不定时更新#&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;时间有限，文章未校验，如果发现错误请指出。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 08 Feb 2020 14:50:00 +0000</pubDate>
<dc:creator>xuld</dc:creator>
<og:description>在上一节介绍了语法树的结构，本节则介绍如何解析标记组成语法树。 对应的源码位于 src/compiler/parser.ts。 入口函数 要解析一份源码，输入当然是源码内容（字符串），同时还提供路径（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuld/p/12266985.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 1 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12285491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12285491.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是农历庚子鼠年正月十五，传统元宵佳节，但因为 2019-nCoV 肺炎疫情不减，节日气氛平淡了些。&lt;/p&gt;
&lt;p&gt;原计划这个半月刊能按二十四节气交节之日准时发布，但这第一期就没能准时，离立春已经过去4天了，也罢，规矩一开始就破了，底下发布时间压力上也就小了。&lt;/p&gt;
&lt;p&gt;大家都知道痞子衡东家是飞思卡尔/恩智浦半导体，所以这第一期咱偏袒一下东家，多给恩智浦相关产品一些特写。&lt;/p&gt;
&lt;p&gt;本期共收录 3条资讯、3个项目、2个工具，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;划时代-1ghz-主频-mcu-恩智浦-i.mxrt1170-有望-2020-年下半年面市&quot;&gt;&lt;span&gt;1、划时代 1GHz 主频 MCU 恩智浦 i.MXRT1170 有望 2020 年下半年面市&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;2019年10月2日恩智浦半导体隆重发布了 i.MXRT1170，这是一款划时代的 MCU。因为它，单片机首次迈入 1GHz 主频大关，这对于嵌入式从业人员来说，是个值得铭记的时刻。&lt;/p&gt;
&lt;p&gt;这款性能炸裂的 MCU 大家都非常期待，在各大嵌入式技术交流群里，它也被频繁提及和讨论，它什么时候能供货是大家最关心的问题。据目前进展来看，i.MXRT1170 有望今年下半年开始供货，所谓好货不怕晚，它绝对值得等待。还有大家比较关心的价格，i.MXRT1170 其实会是一个系列(从 RT1171 到 RT1176 )的方式推出，预计入门级起价在 5$ 的样子。&lt;/p&gt;
&lt;p&gt;让我们再来回顾一下 i.MXRT1170 的厉害之处。i.MX RT系列从 RT1170 开始首次引入了双核，Cortex-M4 的引入可不仅仅是刷新 CoreMark 总分那么简单（当然6468的跑分确实挺震撼），有了这颗 Cortex-M4，一些相对简单的键盘响应、传感器采集、电机控制等任务便可以交给它来做，而超强的 Cortex-M7 则可以专注在音视频识别与处理、千兆以太网通讯控制等复杂任务上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/i.MX-RT1170-DualCore-Task.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多 i.MXRT1170 的细节，详见痞子衡之前写的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/11624973.html&quot;&gt;《终于可以放开聊一聊i.MXRT1170这颗划时代MCU了》&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;硬禾学堂正在推出高质量技术直播视频其中半导体产业前沿技术讲座栏目将会有-100-期&quot;&gt;&lt;span&gt;2、硬禾学堂正在推出高质量技术直播视频，其中&quot;半导体产业前沿技术讲座&quot;栏目将会有 100 期&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;鼠年春节假期，电子行业前辈苏公雨老师可没闲着，他创办的专注于“实战技能培训”的“硬禾学堂”在1月30日启动了第一场在线技术直播。&lt;/p&gt;
&lt;p&gt;这个技术盛宴现在正以每天3-4场、每场平均两个小时的节奏为全国的电子技术爱好者、工程师、高校师生等提供着高效、高质量技术学习的渠道。&lt;/p&gt;
&lt;p&gt;更有来自英国、美国和法国的多位资深工程师受邀为大家奉上更精彩的前沿技术讲座；NXP（是的，痞子衡的两位大牛同事已经分享过人工智能方面的经验）、Lattice、Cypress、ADI的市场和AE团队也已经向全国的工程师朋友分享过了他们的技术、产品和个人成长心得。&lt;/p&gt;
&lt;blockquote readability=&quot;2.5&quot;&gt;
&lt;p&gt;视频直播/回看入口： &lt;a href=&quot;https://class.eetree.cn/index&quot; class=&quot;uri&quot;&gt;https://class.eetree.cn/index&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/eetree_tech_class.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;硬禾学堂计划在2月17 - 5月31日之间开设 100 期”半导体产业前沿技术大讲堂”的栏目，帮助半导体行业的朋友们以技术直播、系列讲座、短平快教程的方式高效、快速地开展线上市场营销业务，硬禾学堂会提供全方位的平台支撑和宣传推广服务。&lt;/p&gt;
&lt;h3 id=&quot;翼辉全新设计了一款面向未来物联网需求的新一代小型操作系统-ms-rtos&quot;&gt;&lt;span&gt;3、翼辉全新设计了一款面向未来物联网需求的新一代小型操作系统 MS-RTOS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;2019年11月26日翼辉信息（就是推出知名大型操作系统 SylixOS 的公司）发布了一款面向未来物联网需求的新一代小型操作系统，即 MS-RTOS，这是一个商业级的 RTOS。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1805555555556&quot;&gt;
&lt;p&gt;MS-RTOS主页： &lt;a href=&quot;http://www.acoinfo.com/html/product_list/product16.html&quot; class=&quot;uri&quot;&gt;http://www.acoinfo.com/html/product_list/product16.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MS-RTOS 最大的特点是开创性地在没有 MMU 和资源极其稀少的 MCU（如Cortex-M3）上也能支持多进程与动态装载技术，使得应用与系统能分离开发、独立升级。&lt;/p&gt;
&lt;p&gt;MS-RTOS 支持内核空间内存保护（应用程序通过 syscall 访问内核），使得内核有着非常高的安全性。MS-RTOS 在提供足够丰富功能的同时，保持了高效简洁的实现，对 ROM、RAM 消耗极低，特别适用于对硬件成本敏感、安全性要求特别高的产品。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://henjay724.com/image/biweekly/MS-RTOS-arch-diagram.webp&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;openmv-rt---基于恩智浦-i.mxrt-系列的开源机器视觉ai模块&quot;&gt;&lt;span&gt;1、OpenMV-RT - 基于恩智浦 i.MXRT 系列的开源机器视觉AI模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;OpenMV-RT 是一款基于恩智浦最近主打的 i.MXRT 超高性能系列 MCU 的视觉模块，模块设计者是恩智浦大牛工程师宋岩（对，就是 ARM Cortex-M3 权威指南中文版作者）。&lt;/p&gt;
&lt;blockquote readability=&quot;0.94444444444444&quot;&gt;
&lt;p&gt;模块源代码: &lt;a href=&quot;https://github.com/RockySong/micropython-rocky/tree/omv_initial_integrate&quot; class=&quot;uri&quot;&gt;https://github.com/RockySong/micropython-rocky/tree/omv_initial_integrate&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这款模块设计得非常简洁，除了 MCU 最小系统之外，仅包含四大部件：640x480 数字摄像头传感器、九轴姿态传感器、串行 SPI Flash （存放代码）、SD 卡槽（文件系统）。模块还提供了标准 OpenMV 接口，可在 OpenMV 项目生态里任意扩展其他功能模块。&lt;/p&gt;
&lt;p&gt;大牛宋岩为这个模块编写了很多 AI 方面的应用实例，如人脸识别、物体识别、性别识别等，这些实例还在持续增长中，所以这可不是一个简单的硬件模块，而是你入门 AI 的极佳机会。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://henjay724.com/image/biweekly/OpenMV-RT-1060.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多 OpenMV-RT 的特点，可参看作者写的文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/JkB6K0IcMDRzcHINopxLyA&quot;&gt;《基于i.MX RT1060的可编程视觉模块》&lt;/a&gt; 和我写的上手实践 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/11965518.html&quot;&gt;《OpenMV-RT模块初体验》&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;thealgorithmsc---各种基础算法数据结构的-c-语言实现&quot;&gt;&lt;span&gt;2、TheAlgorithms/C - 各种基础算法、数据结构的 C 语言实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;知名开源组织 TheAlgorithms 维护的 C 语言实现的各种基础算法、数据结构示例。所有算法列表详见 &lt;a href=&quot;https://github.com/TheAlgorithms/C/blob/master/DIRECTORY.md&quot;&gt;DIRECTORY.md&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;项目地址： &lt;a href=&quot;https://github.com/TheAlgorithms/C&quot; class=&quot;uri&quot;&gt;https://github.com/TheAlgorithms/C&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有人说，程序其实就是数据结构和算法的集合。只要一个人精通数据结构和算法，那这个人必然也是编程大牛。&lt;/p&gt;
&lt;p&gt;这个项目基本涵盖了常见数据结构和算法，而且代码非常简洁，一点都不晦涩，全部理解并手敲一遍，必然让你编程技巧更上一层楼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/TheAlgorithms_lang_list.JPG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;arminksfud---一款基于jedec-sfdp标准的串行-spi-flash-通用驱动库&quot;&gt;&lt;span&gt;3、armink/SFUD - 一款基于JEDEC SFDP标准的串行 (SPI) Flash 通用驱动库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;SFUD 是一款开源的串行 SPI Flash 通用驱动库，作者是上海睿赛德(RT-Thread)公司技术总监朱天龙大神。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7391304347826&quot;&gt;
&lt;p&gt;项目地址： &lt;a href=&quot;https://github.com/armink/SFUD&quot; class=&quot;uri&quot;&gt;https://github.com/armink/SFUD&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于现有市面的串行 Flash 种类居多，各个 Flash 的规格及命令存在差异， SFUD 就是为了解决这些 Flash 的差异现状而设计，让我们的产品能够支持不同品牌及规格的 Flash，提高了涉及到 Flash 功能的软件的可重用性及可扩展性，同时也可以规避 Flash 缺货或停产给产品所带来的风险。&lt;/p&gt;
&lt;p&gt;SFUD 主要特点是支持 SPI/QSPI 接口、面向对象（同时支持多个 Flash 对象）、可灵活裁剪、扩展性强、支持 4 字节地址。标准资源占用：RAM:0.2KB ROM:5.5KB，最小资源占用：RAM:0.1KB ROM:3.6KB。&lt;/p&gt;
&lt;p&gt;SFUD 目前主要提供的 Demo 平台是STM32，但良好的代码结构也很方便移植到其他MCU，下表为所有已在 Demo 平台上进行过真机测试过的 Flash。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/SFDP_flash_list.JPG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;mcuxpresso-secure-provisioning-tool-v1.0---恩智浦官方mcu一站式安全启动下载工具&quot;&gt;&lt;span&gt;1、MCUXpresso Secure Provisioning Tool v1.0 - 恩智浦官方MCU一站式安全启动/下载工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;恩智浦半导体自 2017 年开始推出 i.MXRT 系列 MCU 以来，让广大嵌入式从业者既爱又恨，爱的是这颗 MCU 的超高性能，恨的是入门较难，配套启动下载工具使用太复杂。如今，千呼万唤的官方一站式启动工具 MCUXpresso Secure Provisioning Tool 终于推出了。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6326530612245&quot;&gt;
&lt;p&gt;工具主页： &lt;a href=&quot;https://nxp.com/mcuxpresso/secure&quot; class=&quot;uri&quot;&gt;https://nxp.com/mcuxpresso/secure&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用过 i.MXRT 芯片的朋友应该都知道痞子衡也设计过一个一站式安全启动工具 &lt;a href=&quot;https://github.com/JayHeng/NXP-MCUBootUtility&quot;&gt;NXP-MCUBootUtility&lt;/a&gt;，代码开源在github上，有近 100 star了，这个工具 2018 年底发布的 v1.0，承担了部分 i.MXRT 客户支持工作。&lt;/p&gt;
&lt;p&gt;如今终于等来了官方正式版 MCUXpresso Secure Provisioning Tool，从设计原理上来说，MCUXpresso Secure Provisioning Tool 跟 NXP-MCUBootUtility 其实是类似的，不过 MCUXpresso Secure Provisioning Tool 计划支持所有系统（Windows/Linux/macOS），并且还提供命令行接口，方便自动化测试和批量生产。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/MCUXpresso_Secure_Provisioning_Tool.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MCUXpresso Secure Provisioning Tool v1.0 界面设计得非常清爽，目前仅支持 i.MXRT1050 和 i.MXRT1060，操作上也是足够简单。还不快赶紧下载试用？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/MCUXpresso_Secure_Provisioning_Tool_GUI.JPG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h7-tool---专为单片机工程师设计的一款实用的多功能开发调试工具&quot;&gt;&lt;span&gt;2、H7-TOOL - 专为单片机工程师设计的一款实用的多功能开发调试工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;H7-TOOL是一个专为单片机工程师设计的实用的多功能开发调试工具，工具作者是安富莱电子大牛硬汉哥，而且原理图和所有代码全部开源。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2837837837838&quot;&gt;
&lt;p&gt;资源汇总贴： &lt;a href=&quot;http://www.armbbs.cn/forum.php?mod=viewthread&amp;amp;tid=89934&quot; class=&quot;uri&quot;&gt;http://www.armbbs.cn/forum.php?mod=viewthread&amp;amp;tid=89934&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信很多人有带板子回家调试、或带板子出差调试的情况。因为产品问题是无法预知的，多半情况不可能带齐全套测试工具的。经常遇到手边缺万用表、缺示波器、缺串口线、缺逻辑分析仪而导致工作很难继续。&lt;/p&gt;
&lt;p&gt;这时候你就需要一个 H7-TOOL，有了H7-TOOL就等于随时携带了一个小型实验室，各种常用仪器全都齐活了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/H7-TOOL.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来看看 H7-TOOL 这个“小型实验室”里都有哪些仪器吧，是不是叹为观止？&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;1、脱机烧录器
2、双通道虚拟示波器（支持以太网和USB两种方式）
3、8 通道逻辑分析仪
4、USB-RS485 转换器
5、USB-RS232 转换器
6、USB-TTL 串口转换器
7、USB-CAN 转换器 (未完成)
8、DAP-Link 仿真器 / 下载器 (未完成)
9、I2C 控制器 (未完成)
10、SPI 控制器 (未完成)
11、GPIO 输入输出控制器
12、信号发生器 &amp;amp; 0-20mA电流输出
13、PWM 发生器 (未完成)
14、脉冲计数器
15、频率计
16、负载电流电压示波器
17、高侧电流表 &amp;amp; 电池放电容量测量
18、双通道电压表
19、电阻测量 通断蜂鸣
20、温度测量
21、二极管测量
22、微型数控电源&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而且 H7-TOOL 配套上位机工具也非常漂亮易用哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/H7-TOOL-GUI.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Feb 2020 14:35:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12285491.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第三十二章 执行命令 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12274329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12274329.html</guid>
<description>&lt;p&gt;　　前面章节已经对命令进行了深入分析，分析了基类和接口以及WPF提供的命令库。但尚未例举任何使用这些命令的例子。&lt;/p&gt;
&lt;p&gt;　　如前所述，RoutedUICommand类没有任何硬编码的功能，而是只表达命令，为触发命令，需要有命令源（也可使用代码）。为响应命令，需要有命令绑定，命令绑定将执行转发给普遍的事件处理程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、命令源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　命令库中的命令始终可用。触发他们的最简单的方法是将它们关联到实现了ICommandSource接口的控件，其中包括继承自ButtonBase类的控件（Button和CheckBox等）、单独的ListBoxItem对象、HyperLink以及MenuItem。&lt;/p&gt;
&lt;p&gt;　　ICommandSource接口定义了三个属性，如下表所示。&lt;/p&gt;
&lt;p&gt;表 ICommandSource接口的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200207200043617-634512418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　例如，下面的按钮使用Command属性连接到ApplicationCommands.New命令：&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;ApplicationCommands.New&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;New&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　WPF的智能程度足够高，它能查找前面介绍的所有5个命令容器类，这意味着可使用下面的缩写的形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;New&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;New&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而，由于没有指明包含命令的类，这种语法不够明确、不够清晰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、命令绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当将命令关联到命令源时，会看到一些有趣的现象。命令源将会被自动禁用。&lt;/p&gt;
&lt;p&gt;　　例如，如果创建上一节提到的New按钮，该按钮的颜色就会变浅并且不能被单击，就像将IsEnabled属性设置为false那样（如下图所示）。这是因为按钮已经查询了命令的状态，而且由于命令还没有与其关联的绑定，所以按钮被认为是禁用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200208160604014-1404051332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　为改变这种状态，需要为命令创建绑定以明确以下三件事：&lt;/p&gt;
&lt;p&gt;　　当命令被触发时执行什么操作。&lt;/p&gt;
&lt;p&gt;　　如何确定命令是否能够被执行（这是可选的。如果未提供这一细节，只要提供了关联的事件处理程序，命令总是可用）。&lt;/p&gt;
&lt;p&gt;　　命令在何处起作用。例如，命令可被限制在单个按钮中使用，或在整个窗口中使用（这种情况更常见）。&lt;/p&gt;
&lt;p&gt;　　下面的代码片段为New命令创建绑定。可将这些代码添加到窗口的构造函数中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Create the binding&lt;/span&gt;
CommandBinding binding=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommandBinding(ApplicationCommands.New);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Attach the event handler&lt;/span&gt;
binding.Executed+=&lt;span&gt;NewCommand_Executed;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Register the binding&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.CommandBinding.Add(binding);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，上面创建的CommandBinding对象呗添加到包含窗口的CommandBindings集合中，这通过事件冒泡进行工作。实际上，当单击按钮时，CommandBinding.Executed事件从按钮冒泡到包含元素。&lt;/p&gt;
&lt;p&gt;　　尽管习惯上为窗口添加所有绑定，但CommandBindings属性实际是在UIElement基类中定义的。这意味着任何元素都支持该属性。例如，如果将命令绑定直接添加到使用它的按钮中，这个示例仍工作的很好（尽管不能在将该绑定重用与其他高级元素）。为得到最大的灵活性，命令绑定通常被添加到顶级窗口。如果希望在多个窗口中使用相同相同的命令，需要在这些窗口中分别创建命令绑定。&lt;/p&gt;
&lt;p&gt;　　上面的代码假定在同一个类中已有名为NewCommand_Executed的事件处理程序，该处理程序已经准备好接收命令。下面是一个示例，该例包含一些显示命令源的简单代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; NewCommand_Executed(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ExecutedRoutedEventArgs e)
        {
            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New command triggered by &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Source.ToString());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在，如果允许应用成功需，按钮处于启用状态。如果单击按钮，就会触发Executed事件，该事件冒泡至窗口，并被上面给出的NewCommand_Executed()事件处理程序程序处理。这是，WPF会告知事件源(按钮)。通过ExecutedRoutedEventArgs对象还可获得被调用的命令的引用（ExecutedRoutedEventArgs.Command)，以及所有同时传递的额外数据（ExecutedRoutedEventArgs.Parameter)。在该例中，因为没有传递任何额外的数据，所以参数为null(如果希望传递附加数据，赢设置命令源的CommandParameter属性；并且如果希望传递一些来自另一个控件的信息，还需要使用数据绑定表达式设置CommandParameter属性)。&lt;/p&gt;
&lt;p&gt;　　在上面的示例中，使用代码生成了命令绑定。然而，如果希望精简代码隐藏文件，使用XAML以生命方式关联命令同样容易。下面是所需的标记：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;Commands.TestNewCommand&quot;&lt;/span&gt;&lt;span&gt;
        xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
        xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
        Title&lt;/span&gt;&lt;span&gt;=&quot;TestNewCommand&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window.CommandBindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CommandBinding &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;ApplicationCommands.New&quot;&lt;/span&gt;&lt;span&gt; Executed&lt;/span&gt;&lt;span&gt;=&quot;NewCommand&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CommandBinding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window.CommandBindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Command&lt;/span&gt;&lt;span&gt;=&quot;ApplicationCommands.New&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;New&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用Visual Studio没有为定义命令绑定提供任何设计时支持。对连接控件和命令的支持也较弱。可使用Properties窗口设置控件的Command属性，但需要输入正确的命令名称——由于并未提供包含命令的下拉列表，因此不能方便地从列表中选择命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、使用多命令源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上面示例中触发普通事件的方式看起来不那么直接。然而，当添加使用相同命令的更多控件时，额外命令层的意义就提现出出来了。例如，可添加如下也使用New命令的菜单项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Menu &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MenuItem &lt;/span&gt;&lt;span&gt;Header&lt;/span&gt;&lt;span&gt;=&quot;File&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MenuItem &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;New&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MenuItem&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MenuItem&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Menu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，New命令的这个MenuItem对象没有设置Header属性。这是因为MenuItem类足够智能，如果没有设置Header属性，它将从命令中提取文本（Button控件不具有这一特性）。虽然该特性带带来的便利看起来不大，但如果计划使用不同的语言本地化应用程序，这一特性就很重要了。在这种情况下，只需要在一个地方修改文本即可（通过设置命令的Text属性）。这比在整个窗口中进行跟踪更容易。&lt;/p&gt;
&lt;p&gt;　　MenuItem类还有一项功能：能自动提取Command.InputBinding集合中的第一个快捷键（如果存在的话）。对于ApplicationCommands.New命令对象，这意味着在菜单文本的旁边会显示Ctrl+N快捷键(如下图所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200208184328621-166517402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 四、微调命令文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　既然菜单具有自动提取命令项文本的功能，肯恩改回好奇其他ICommandSource类是否也具有类似功能，如Button控件。&lt;/p&gt;
&lt;p&gt;　　可以使用两种技术重用命令文本。一种选择是直接从静态命令对象中提取文本。XAML可使用Static标记扩展完成这一任务。下面的示例获取命令名New，并将它作为按钮的文本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Command&lt;/span&gt;&lt;span&gt;=&quot;New&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Static ApplicationCommands.New}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法的问题在于，它指示调用命令对象命令对象的ToString()方法。因此，得到的是命令名，而不是命令的文本（对于哪些名称中包含多个单词的命令，使用命令文本更好些，因为命令文本包含空格）。虽然解决这一问题，但需要完成更多工作。这种方法还存在一个问题，一个按钮将同一个命令使用两次，可能会无意间从错误的命令获取文本）。&lt;/p&gt;
&lt;p&gt;　　更好的解决方案是使用数据绑定表达式。在此使用的数据绑定有些不寻常，因为他绑定到当前元素吗，获取正在使用的Command对象，并提取Text属性。下面是非常复杂的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Command&lt;/span&gt;&lt;span&gt;=&quot;New&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding RelativeSource={RelativeSource Self},Path=Command.Text}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可通过另一种更具想象力的方式使用该技术。例如，可使用一幅小图像设置按钮的内容，而在按钮的工具提示中使用数据绑定表达式显示命令名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Command&lt;/span&gt;&lt;span&gt;=&quot;ApplicationCommands.New&quot;&lt;/span&gt;&lt;span&gt; ToolTip&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding RelativeSource={RelativeSource Self},Path=Command.Text}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;=&quot;redx.jpg&quot;&lt;/span&gt;&lt;span&gt;  Stretch&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　按钮的内容可以是形状，也可以是显示为缩略图的位图。&lt;/p&gt;
&lt;p&gt;　　显然，这种方法比直接在标记中放置命令文本更麻烦些。然而，如果准备使用不同的语言本地化应用程序，使用这个方法是值得的。当应用程序启动时，只需要为所有命令设置命令文本即可（如果在创建了命令绑定后改变命令文本，不会产生任何效果。因为Text属性不是依赖项属性，所以没有自动的更改通知来更新用户界面）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、直接调用命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　并非只能使用实现了ICommandSource接口的类来触发希望执行的命令。也可以用Execute()方法直接调用来自任何事件处理程序的方法。这时需要传递参数值(或null引用）和对目标元素的引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ApplicationCommands.New.Execute(&lt;span&gt;null&lt;/span&gt;,targetElement);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　目标元素是WPF开始查找命令绑定的地方。可使用包含窗口（具有命令绑定）或嵌套的元素（例如，实际引发事件的元素）。&lt;/p&gt;
&lt;p&gt;　　也可在关联的CommandBinding对象中调用Execute()方法。在这种情况下，不需要提供目标元素，因为会自动将公开正在使用的CommandBindings集合的元素设置为目标元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.CommandBindings[&lt;span&gt;0&lt;/span&gt;].Command.Execute(&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种方法只使用了半个命令模型。虽然也触发命令，但不能响应命令的状态变化。如果希望实现该特性，当命令变为启用或禁用时，也可能希望处理RoutedCommand.CanExecuteChanged事件进行响应。当引发CanExecuteChanged事件时，需要调用RoutedCommand.CanExecute()方法检查命令是否处于可用状态。如果命令不可用。可禁用或改变用户界面中的部分内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、禁用命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果想要创建状态在启用和禁用之间变化的命令，你将体会到命令模型的真正优势。例如，分析下图中显示的单窗口应用程序，它是有菜单、工具栏以及大文本框构成的简单文本编辑器。该应用程序可以打开文件，创建新的（空白）文档，以及保存所执行的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200208213428449-300910564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　在该应用程序中，保持New、Open、Save、SaveAs以及Close命令一直可用是非常合理的。但还有一种设计，只有当某些操作使文本相对于原来的文件发生了变化时才启用Save命令。根据约定，可在代码中使用简单的Boolean值来跟踪这一细节：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isDirty = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后当文本发生变化时设置该标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; txt_TextChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            isDirty &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在需要从窗口命令绑定传递信息，使链接的控件可根据需要进行更新。技巧是处理命令绑定的CanExecute事件。可通过下面的代码为该事件关联事件处理程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
CommandBinding binding = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommandBinding(ApplicationCommands.Save);
            binding.Executed &lt;/span&gt;+=&lt;span&gt; SaveCommand_Executed;
            binding.CanExecute &lt;/span&gt;+=&lt;span&gt; SaveCommand_CanExecute;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CommandBindings.Add(binding);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或使用声明方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window.CommandBindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CommandBinding &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;ApplicationCommands.Save&quot;&lt;/span&gt;&lt;span&gt; 
                        Executed&lt;/span&gt;&lt;span&gt;=&quot;SaveCommand_Executed&quot;&lt;/span&gt;&lt;span&gt; 
                        CanExecute&lt;/span&gt;&lt;span&gt;=&quot;SaveCommand_CanExecute&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CommandBinding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window.CommandBindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在事件处理程序中，只需要检查isDirty变量，并相应地设置CanExecuteRoutedEventArgs.CanExecute属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private void SaveCommand_CanExecute(object sender, CanExecuteRoutedEventArgs e)
        {
            e.CanExecute = isDirty;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果isDirty的值时false，就禁用命令。如果isDirty的值为true，就启用命令（如果没有设置CanExecute标志，就会保持最近的值）。&lt;/p&gt;
&lt;p&gt;　　当使用CanExecute事件时，还需要理解一个问题，由WPF负责调用RoutedCommand.CanExecute（）方法来触发事件处理程序，并确定命令的状态。当WPF命令管理器探测到某个确信十分重要的变化——例如，当焦点从一个控件移到另一个控件上时，或执行了某个命令后，WPF命令管理器就会完成该工作。控件还能引发CanExecuteChanged事件以通知WPF重新评估命令——例如，当用户在文本框中按下一个键时会发生该事件。总之，CanExecute事件会被频繁地触发，并且不应在该事件的处理程序中使用耗时的代码。&lt;/p&gt;
&lt;p&gt;　　然而，其他因素可能影响命令状态。在当前示例中，为响应其他操作，可能会修改isDirty标志。如果发现命令状态未在正确的时间被更新，可强制WPF为所有正在使用的命令调用CanExecute()方法。通过调用静态方法CommandManager.InvalidateRequerySuggested()完成该工作。然后命令管理器触发RequerySuggested事件，通知窗口中的命令源（按钮、菜单项等）。此后命令源会重新查询它们链接的命令并相应地更新它们的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、具有内置命令的控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个输入控件可自行处理命令事件。例如，TextBox类处理Cut、Copy以及Paste命令（还有Undo、Redo命令，以及一些来自EditingCommd类的用于选择文本以及将光标移到不同位置的命令）。&lt;/p&gt;
&lt;p&gt;　　当控件具有自己的硬编码命令逻辑时，为使命令工作不需要做其他任何事情。例如，对于上节示例的简单编辑器，添加如下工具栏按钮，就会自动获取对剪切、复制和粘贴文本的支持：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToolBar&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Cut&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Cut&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Copy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Copy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Paste&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Paste&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToolBar&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在淡季这些按钮中的任意一个（当文本框具有焦点时），就可以复制、剪切或从剪贴板粘贴文本。有趣的是，文本框还处理CanExecute事件。如果当前未在文本框中选中任何内容，就会禁用剪切和复制命令。当焦点移到其他不支持这些命令的控件时，会自动禁用所有这三个命令（除非关联自己的CanExecute事件处理程序以启动这些命令）。&lt;/p&gt;
&lt;p&gt;　　该例有一个有趣的细节。Cut、Copy和Paste命令被具有焦点的文本框处理。然而，由工具栏上的按钮触发的命令时完全独立的元素。在该例中，这个过程之所以能够无缝工作，是因为按钮被放到工具栏上，ToolBar类提供了一些内置逻辑，可将其子元素的CommandTarget属性动态设置为当前具有焦点的控件（从技术角度看，ToolBar控件一直在关注着其父元素，即窗口，并在上下文中查找最近具有焦点的控件，即文本框。ToolBar控件有单独的焦点范围（focus scope），并且在其上下文中按钮是具有焦点的）。&lt;/p&gt;
&lt;p&gt;如果在不同容器（不是ToolBar或Menu控件）中放置按钮，就不会获得这些优势。这意味着除非手动设置CommanTarget属性，否则按钮不能工作。为此，必须使用命令目标元素的绑定的表达式。例如，如果文本框被命名为txtDocument，就应该像下面这样定义按钮：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Cut&quot;&lt;/span&gt;&lt;span&gt; CommandTarget&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=txtDocument}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Cut&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Copy&quot;&lt;/span&gt;&lt;span&gt; CommandTarget&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=txtDocument}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Copy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Paste&quot;&lt;/span&gt;&lt;span&gt; CommandTarget&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=txtDocument}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Paste&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另一个较简单的选择是使用附加属性FocusManager.IsFocusScope创建新的焦点范围。当触发命令时，该焦点范围会通知WPF在父元素的焦点范围内查找元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;FocusManager.IsFocusScope&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Cut&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Cut&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Copy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Copy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Command&lt;/span&gt;&lt;span&gt;=&quot;Paste&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Paste&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法还有一个附加优点，即相同的命令可应用于多个控件，不像上个示例那样对CommandTarget进行硬编码。此外，Menu和ToolBar控件默认将FocusManager.IsFocusScope属性设置为true，但如果希望简化命令路由行为，不在父元素上下文中查找具有焦点的元素，也可将该属性设为false。&lt;/p&gt;
&lt;p&gt;　　在极少数情况下，你可能发现控件支持内置命令，而你并不想启用它。在这种情况下，可以采用三种方法禁用命令。&lt;/p&gt;
&lt;p&gt;　　理想情况下，控件提供用于关闭命令支持的属性，从而确保控件移除这些特性并连贯地调整自身。例如，TextBox控件提供了IsUndoEnabled属性，为阻止Undo特性，可将该属性设置为false(如果IsUndoEnabled属性为true，Ctrl+Z组合键将触发Undo命令)。&lt;/p&gt;
&lt;p&gt;　　如果这种做法行不通，可为希望禁用的命令添加新的命令绑定。然后该命令绑定可提供新的CanExecute事件处理程序，并总是响应false。下面举一个使用该技术删除文本框Cut特性支持的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
CommandBinding commandBinding=&lt;span&gt;new&lt;/span&gt; CommandBinding(ApplicationCommands.Cut,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,SuppressCommand);
txt.CommandBindings.Add(commandBinding);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而且该事件处理程序设置CanExecute状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SupressCommand(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender,CanExecuteRoutedEventArgs e)
{
  e.CanExecute&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  e.Handled&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，上面的代码设置了Handled标志以阻止文本框自我执行计算，而文本框可能将CanExecute属性设置为true。&lt;/p&gt;
&lt;p&gt;　　该方法并不完美。它可成功地为文本框禁用Cut快捷键（Ctrl+X）和上下文菜单中的Cut命令。然而，仍会在上下文菜单中显示处理禁用状态的该选项。&lt;/p&gt;
&lt;p&gt;　　最后一种选择是，使用InputBinding集合删除触发命令的输入。例如，可使用带阿妈禁用触发TextBox控件中的Copy命令的Ctrl+C组合键，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
KeyBinding keyBinding=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyBinding(ApplicationCommands.NotACommand,Key.C,ModifierKeys.Control);
txt.InputBinding.Add(keyBinding);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　技巧是使用特定的ApplicationCommands.NotACommand值，该命令什么都不做，它专门用于禁用输入绑定。&lt;/p&gt;
&lt;p&gt;　　当使用这种方法时，仍启用Copy命令。可通过自己创建的按钮触发该命令（或使用文本框的上下文菜单触发命令，除非也通过将ContextMenu属性设置为null删除了上下文菜单）。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Feb 2020 14:29:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>前面章节已经对命令进行了深入分析，分析了基类和接口以及WPF提供的命令库。但尚未例举任何使用这些命令的例子。 如前所述，RoutedUICommand类没有任何硬编码的功能，而是只表达命令，为触发命令</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12274329.html</dc:identifier>
</item>
<item>
<title>BaseAdapter的三种表达式分析，startActivityForResult的使用 - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/12285448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/12285448.html</guid>
<description>&lt;p&gt;&lt;span&gt;（一）BaseAdapter的三种表达式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①逗比式&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; View getView(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position, View convertView, ViewGroup parent) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逗比式&lt;/span&gt;
        View view=minflater.inflate(R.layout.item,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        ImageView imageView&lt;/span&gt;=&lt;span&gt;(ImageView) view.findViewById(R.id.iv_image);
        TextView title&lt;/span&gt;=&lt;span&gt;(TextView) view.findViewById(R.id.tv_title);
        TextView content&lt;/span&gt;=&lt;span&gt;(TextView) view.findViewById(R.id.tv_content);
        ItemBean bean&lt;/span&gt;=&lt;span&gt;mlist.get(position);
        imageView.setImageResource(bean.imageid);
        title.setText(bean.title);
        content.setText(bean.content);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; view;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;每进行一次getView就要利用inflater对象去创建一个新的view，并在View中找到相应的控件并给他设置相应的值，这样完全没有利用到ListView的缓存机制，因此称为“逗比式”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②普通式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然“逗比式”没有利用到缓存机制，那么我们的普通式就要好好利用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何利用？我们需要判断一下convertview是否已经缓存过，如果没有缓存过就创建一个view。如下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通式&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;(convertView==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            convertView&lt;/span&gt;=minflater.inflate(R.layout.item,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        ImageView imageView&lt;/span&gt;=&lt;span&gt;(ImageView) convertView.findViewById(R.id.iv_image);
        TextView title&lt;/span&gt;=&lt;span&gt;(TextView) convertView.findViewById(R.id.tv_title);
        TextView content&lt;/span&gt;=&lt;span&gt;(TextView) convertView.findViewById(R.id.tv_content);
        ItemBean bean&lt;/span&gt;=&lt;span&gt;mlist.get(position);
        imageView.setImageResource(bean.imageid);
        title.setText(bean.title);
        content.setText(bean.content);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertView;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;他虽然对缓存资源进行了合理的利用，但是还是存在一些问题，不够优化，每次都要去布局中需找部件，findviewbyid是很耗费时间的，这样在小程序中可能体现不出什么，但是总归是耗费时间的，因此我们要对其进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③文艺式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在文艺式中我们需要为findviewbyid进行优化，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文艺式&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;利用ViewHolder优化BaseAdapter思路：
        1.创建Bean对象，用于封装数据
        2.在构造方法中初始化用于映射的数据List
        3.创建ViewHolder类，创建布局映射关系
        4.判断convertView，为空则创建，并设置tag；否则通过tag来取出viewholder
        5.给viewholder中的空间设置数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

        ViewHolder viewHolder;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(convertView==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            convertView&lt;/span&gt;=minflater.inflate(R.layout.item,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            viewHolder&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewHolder();
            viewHolder.imageView&lt;/span&gt;=&lt;span&gt;(ImageView)convertView.findViewById(R.id.iv_image);
            viewHolder.title&lt;/span&gt;=&lt;span&gt;(TextView)convertView.findViewById(R.id.tv_title);
            viewHolder.content&lt;/span&gt;=&lt;span&gt;(TextView)convertView.findViewById(R.id.tv_content);
            convertView.setTag(viewHolder);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            viewHolder&lt;/span&gt;=&lt;span&gt;(ViewHolder) convertView.getTag();
        }
        ItemBean bean&lt;/span&gt;=&lt;span&gt;mlist.get(position);
        viewHolder.imageView.setImageResource(bean.imageid);
        viewHolder.title.setText(bean.title);
        viewHolder.content.setText(bean.content);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertView;
    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewHolder{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ImageView imageView;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextView title;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextView content;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（二）startActivityForResult的应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;startActivityForResult startActivityForResult(Intent intent, int requestCode)。这个方法我一般用来在ActivityA中启动另个activityB。当返回的时候需要携带来自B的数据。ActivityA更新界面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.首先要在activityA中启动startActivityForResult(Intent intent, int requestCode)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
btn.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
                Intent intent&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Intent(MainActivity.&lt;span&gt;this&lt;/span&gt;,HeadActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                startActivityForResult(intent,&lt;/span&gt;0x11&lt;span&gt;);
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参数1.就是一个intent 你可以携带一些数据。当然也可以不携带&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数2.requescode，你自定义的一个int类型的数值（一般&amp;gt;0）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.还有一个方法。这个方法是在ActivityB中使用的，主要一定要在finish（）之前调用该方法，不然不起作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;setResult(int resultCode, Intent data)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 gridView.setOnItemClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdapterView.OnItemClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, &lt;span&gt;int&lt;/span&gt; position, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
                Intent intent&lt;/span&gt;=&lt;span&gt;getIntent();
                Bundle bundle&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bundle();
                bundle.putInt(&lt;/span&gt;&quot;imageId&quot;&lt;span&gt;,imageId[position]);
                intent.putExtras(bundle);
                setResult(&lt;/span&gt;0x11&lt;span&gt;,intent);
                finish();
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样还是两个参数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数1：resultcode，先说作用。这个参数有两个作用。第一个可以用来判断有没有返回成功。还有一个作用同样可以判断是从哪个activity返回来的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 为什么呢。这个参数可以自定义。如果返回成功了，当时你在activityB中定义的什么，那么 在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;onActivityResult(int requestCode, int resultCode, Intent data)这个方法中就会接收到什么。所以可以用来判断来这哪个activity。 如果失败了（比如你在ActivityB中直接按了返回键。什么都没有操作），这种情况在ActivityA中接收到的requestcode 就是0. 所以这个参数我一般用来判断是否返回成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.最后在ActivityA中onActivityResult(int requestCode, int resultCode, Intent data)中接收数据，并判断requestCode和resultCode是不是你想要的，然后进行取值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一个案例：进行头像的切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200208222147908-1070410495.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 点击切换头像，到另一个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200208222238409-1543871081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 选好后，就会自动回到上个页面并且头像切换成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200208222314371-771196166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; activity_main.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
    &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:background&lt;/span&gt;&lt;span&gt;=&quot;@drawable/beijing&quot;&lt;/span&gt;&lt;span&gt;
    android:paddingTop&lt;/span&gt;&lt;span&gt;=&quot;40dp&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ImageView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/t_image&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt;&lt;span&gt;
        android:src&lt;/span&gt;&lt;span&gt;=&quot;@drawable/touxiang&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/btn&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;40dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;选择头像&quot;&lt;/span&gt;
        &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;activity_head.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout
    &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.HeadActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GridView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/gridView&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_marginTop&lt;/span&gt;&lt;span&gt;=&quot;10dp&quot;&lt;/span&gt;&lt;span&gt;
        android:horizontalSpacing&lt;/span&gt;&lt;span&gt;=&quot;3dp&quot;&lt;/span&gt;&lt;span&gt;
        android:verticalSpacing&lt;/span&gt;&lt;span&gt;=&quot;3dp&quot;&lt;/span&gt;&lt;span&gt;
        android:numColumns&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GridView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MainActivity.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.startactivityforresult;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.annotation.Nullable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.appcompat.app.AppCompatActivity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.ImageView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
    ImageView imageView;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button btn&lt;/span&gt;=&lt;span&gt;(Button)findViewById(R.id.btn);

        btn.setOnClickListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
                Intent intent&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Intent(MainActivity.&lt;span&gt;this&lt;/span&gt;,HeadActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                startActivityForResult(intent,&lt;/span&gt;0x11&lt;span&gt;);
            }
        });
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode,  Intent data) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityResult(requestCode, resultCode, data);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requestCode==0x11 &amp;amp;&amp;amp; resultCode==0x11&lt;span&gt;)
        {
            Bundle bundle&lt;/span&gt;=&lt;span&gt;data.getExtras();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; image=bundle.getInt(&quot;imageId&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k=bundle.getInt(&quot;word&quot;&lt;span&gt;);
            imageView&lt;/span&gt;=&lt;span&gt;(ImageView)findViewById(R.id.t_image);
            imageView.setImageResource(image);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HeadActivity.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.startactivityforresult;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.appcompat.app.AppCompatActivity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.ViewGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.AdapterView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.BaseAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.GridView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.ImageView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HeadActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] imageId = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]{R.drawable.touxiang1, R.drawable.touxiang2,
            R.drawable.touxiang3, R.drawable.touxiang4, R.drawable.touxiang5
    };   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义并初始化保存头像id的数组&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_head);
        GridView gridView&lt;/span&gt;=&lt;span&gt;(GridView)findViewById(R.id.gridView);
        BaseAdapter baseAdapter&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseAdapter() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imageId.length;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object getItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; position;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getItemId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; position;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; View getView(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position, View convertView, ViewGroup parent) {
                ImageView imageView;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(convertView==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    imageView&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ImageView(HeadActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                    imageView.setAdjustViewBounds(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    imageView.setMaxHeight(&lt;/span&gt;158&lt;span&gt;);
                    imageView.setMaxWidth(&lt;/span&gt;150&lt;span&gt;);
                    imageView.setPadding(&lt;/span&gt;5, 5, 5, 5&lt;span&gt;);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    imageView&lt;/span&gt;=&lt;span&gt;(ImageView)convertView;
                }
                imageView.setImageResource(imageId[position]);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imageView;
            }
        };
        gridView.setAdapter(baseAdapter);
        gridView.setOnItemClickListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdapterView.OnItemClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, &lt;span&gt;int&lt;/span&gt; position, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
                Intent intent&lt;/span&gt;=&lt;span&gt;getIntent();
                Bundle bundle&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bundle();
                bundle.putInt(&lt;/span&gt;&quot;imageId&quot;&lt;span&gt;,imageId[position]);
                intent.putExtras(bundle);
                setResult(&lt;/span&gt;0x11&lt;span&gt;,intent);
                finish();
            }
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 08 Feb 2020 14:25:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>（一）BaseAdapter的三种表达式： ①逗比式： public View getView(int position, View convertView, ViewGroup parent) {</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/12285448.html</dc:identifier>
</item>
</channel>
</rss>