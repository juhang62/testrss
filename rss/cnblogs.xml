<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式—门面模式 - muggle1</title>
<link>http://www.cnblogs.com/muggle0/p/12617518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muggle0/p/12617518.html</guid>
<description>&lt;p&gt;门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。&lt;/p&gt;
&lt;p&gt;门面模式又被称作外观模式，这个模式特点很鲜明，在生活中我们就能找到不少例子。比如110，我们生活中遇到困难或者危险等一系列问题，我们都是直接打110找警察同志，然后由公安局统一处理，对应不同的情况再细化到公安的各个部门去处理。&lt;/p&gt;
&lt;h2 id=&quot;模式结构&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;门面模式是“迪米特法则”的应用，它的优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。&lt;/li&gt;
&lt;li&gt;对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。&lt;/li&gt;
&lt;li&gt;降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;门面模式的缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不能很好地限制客户使用子系统类。&lt;/li&gt;
&lt;li&gt;增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它的结构如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;外观（Facade）角色：为多个子系统对外提供一个共同的接口。&lt;/li&gt;
&lt;li&gt;子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。&lt;/li&gt;
&lt;li&gt;客户端：通过一个外观角色访问各个子系统的功能。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;源码导读&quot;&gt;源码导读&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;servlet&lt;/code&gt; 中 &lt;code&gt;httprequest&lt;/code&gt; 使用的便是门面模式；我们想要 获得请求信息或者是使用请求的一些功能的时候，我们只需要找&lt;code&gt;HttpServletRequest&lt;/code&gt; 这个接口就行，这个接口提供了获取请求头信息，请求方式，Context等信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface HttpServletRequest extends ServletRequest {
    String BASIC_AUTH = &quot;BASIC&quot;;
    String FORM_AUTH = &quot;FORM&quot;;
    String CLIENT_CERT_AUTH = &quot;CLIENT_CERT&quot;;
    String DIGEST_AUTH = &quot;DIGEST&quot;;

    String getAuthType();

    Cookie[] getCookies();

    long getDateHeader(String var1);

    String getHeader(String var1);

    Enumeration getHeaders(String var1);

    Enumeration getHeaderNames();

    int getIntHeader(String var1);

    String getMethod();

    String getPathInfo();

    String getPathTranslated();

    String getContextPath();

    String getQueryString();

    String getRemoteUser();

    boolean isUserInRole(String var1);

    Principal getUserPrincipal();

    String getRequestedSessionId();

    String getRequestURI();

    StringBuffer getRequestURL();

    String getServletPath();

    HttpSession getSession(boolean var1);

    HttpSession getSession();

    boolean isRequestedSessionIdValid();

    boolean isRequestedSessionIdFromCookie();

    boolean isRequestedSessionIdFromURL();

    /** @deprecated */
    boolean isRequestedSessionIdFromUrl();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而其实现类 &lt;code&gt;RequestFacade&lt;/code&gt; 就是web封装的门面实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RequestFacade implements HttpServletRequest {
     protected Request request = null;
    protected static final StringManager sm = StringManager.getManager(RequestFacade.class);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们想要请求信息的时候就不必在取找其他类，第一时间想到的是从 &lt;code&gt;HttpServletRequest&lt;/code&gt; 中获取。&lt;/p&gt;
&lt;p&gt;门面模式的使用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。&lt;/li&gt;
&lt;li&gt;外观模式可以屏蔽系统的复杂性，对外提供统一接口。&lt;/li&gt;
&lt;li&gt;当客户端依赖多个子系统时，提供一个门面可分离这种依赖性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://muggle.javaboy.org/2019/03/20/home/&quot;&gt;点击关注我的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Apr 2020 00:58:00 +0000</pubDate>
<dc:creator>muggle1</dc:creator>
<og:description>门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/muggle0/p/12617518.html</dc:identifier>
</item>
<item>
<title>2020年了，跨平台开发框架现在怎样了？ - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/12617362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/12617362.html</guid>
<description>&lt;blockquote readability=&quot;7.4713656387665&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;p&gt;原文出处：https://dzone.com/articles/cross-platform-mobile-development-2020-trends-and&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;ij&quot;&gt;多年来，跨平台移动开发已经获得了最流行软件开发趋势之一的声誉。这并不令人意外，因为采用跨平台开发技术使得软件工程师使用同一代码就能为不同平台构建应用程序，从而节省时间、金钱以及不必要的工作。&lt;/p&gt;
&lt;h2&gt;移动市场的现状&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;截至2019年12月，全球活跃网民已超45亿。他们每人平均上网时间为6小时42分钟，相当于每年上网超过100天。&lt;br/&gt;再加上人们越来越渴望从掌上设备中获取海量的信息，也就为之所以移动应用程序会如此受到欢迎提供了合理的解释。截至 2019 年，全球移动应用收入达 4610 亿美元，预计到 2023 年，付费下载和应用内广告的收入预计将超过 9350 亿美元。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h2&gt;移动开发的技术选型&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;十年前，老板们必须决定他们的产品将涵盖哪些移动操作系统：Android、iOS、微软、RIM或Symbian。而今天，初创公司的创始人正面临着一个不同的两难抉择，由于Android和iOS占据了移动操作系统市场份额的98%，很显然这两个系统不容忽视，覆盖什么平台不再是问题。但问题是，构建一个在两个平台上都可以使用的应用程序应该采用什么方法？&lt;/p&gt;
&lt;h3&gt;每个操作系统对应一种开发环境&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;顾名思义，用于开发Android用的是Java或Kotlin，用于开发iOS则是Objective-C或SWIFT。作为开发不同应用而使用不同的开发语言，对开发者而言并不是一个好消息。&lt;br/&gt;虽然特定的开发环境对特定的操作系统拥有对资源更高效的调配效率，可防止发生性能问题。但缺点也很显而易见，你的开发人员需要使用不同的开发语言构建两个独立的应用程序，这需要付出更多的时间、金钱和精力。&lt;/p&gt;
&lt;h3&gt;渐进式Web应用程序（PWA）&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;其中一个能解决问题的例子是&lt;a href=&quot;https://www.merixstudio.com/blog/progressive-apps-taking-over-mobile-industry/&quot; target=&quot;_blank&quot;&gt;渐进式 Web 应用&lt;/a&gt;（PWA），它基本上是模仿原生应用程序行为的一个网站（例如，在发送推送通知、脱机工作，或者只是添加到移动设备的主屏幕上)。然而，就像任何其他选项一样，PWA也不是完美无缺的，因为它们消耗更多的电池，并且不能授予应用使用设备的所有功能。&lt;/p&gt;
&lt;h3&gt;跨平台应用程序开发&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;但还好我们还有一个跨平台开发的选项，它允许用一段代码同时为两个操作系统开发应用。它并不固定使用某一种平台的编程语言编写代码。而且，由于直接使用了系统原生控件来呈现界面，它能为用户提供近乎原生平台应用的使用体验。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h2&gt;我要不要使用跨平台开发这项技术？&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;下面，我会通过一系列维度来帮助你去评估你是否应该采用跨平台开发这种形式来适配你的业务。&lt;/p&gt;
&lt;h3&gt;平台&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;首先，也是最重要的，您需要决定您的应用程序是需要在一个还是多个操作系统上可用。如果您的目标群是由不同平台的用户组成的，那么跨平台开发将是首选的解决方案。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;另一方面，如果你的用户群体只是Android或iOS的某一支，那么用原生解决方案来开发是你的首选。&lt;/p&gt;
&lt;h3&gt;复杂性&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;此标准涉及你希望与产品走多远。解决此问题的一种方法是你的目标是使用MVP测试你的愿景，或是你准备使用成熟的应用程序开始运行。您需要回答的另一个问题是产品的功能(例如，访问移动设备的硬件或特定于平台的功能)。&lt;/p&gt;
&lt;h3&gt;原生体验&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;你的用户是否需要使用原生或近似原生的体验。使用Material Design(Android)或Human Interface Guidance(iOS)来设计的移动应用程序是移动产品对用户直观且友好的原因所在。在设计移动应用程序时应要考虑这些，但是，你可以使用跨平台框架来实现类似的效果。&lt;/p&gt;
&lt;h3&gt;时间和成本&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;有一点是肯定的，原生开发成本不低、效率也不高。为不同的平台构建不同的应用程序需要雇佣更多的开发人员，这可能会导致初创公司在项目初期就超出紧张的项目预算。同时，如果采用跨平台的方法，你可以将项目外包给一个规模较小但同样专业的团队，这既是一个省时的解决方案，也是一个具有成本效益的解决方案。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h2&gt;跨平台移动应用开发的优点（和缺点）&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;假设你已经得出结论，你更倾向于跨平台的移动应用程序开发，但是在下决心之前，你需要对此解决方案的优缺点进行彻底的了解，没关系，下面我逐一为你列举。&lt;/p&gt;
&lt;h3&gt;跨平台移动应用程序开发的好处&lt;/h3&gt;
&lt;h4&gt;更广泛的市场覆盖范围&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;虽然我们每个人都有自己喜欢的移动操作系统，但个人喜好不会妨碍你业务的成功。让Android和iOS用户同时可以使用您的移动应用，能在未来提升更高的收录打下基础。&lt;/p&gt;
&lt;h4&gt;一套代码&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;跨平台开发允许您同时编写包含多个操作系统的代码（有时也会有处理平台差异）。尽管如此，一套代码肯定会影响软件开发过程中的所有阶段，因为它可能为你节省通常花在修复和升级两组独立代码上的成本。&lt;/p&gt;
&lt;h4&gt;更高效的发布流程&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;尽管只需要一套代码，但跨平台应用程序开发仍然需要开发人员考虑处理系统差异的方法，例如发布应用到平台商店的过程。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;这种方法将缩短从设计到发布的时间。换句话讲，这可以为你节省很大一笔初始项目预算。&lt;/p&gt;
&lt;h4&gt;平台一致性&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;毫无疑问，Android和iOS在用户体验和用户界面方面都有很大的不同，这些差异中的大多数部分都能通过跨平台开发框架帮你默认处理，这使得设计和实际表现不一致的情况发生的可能性进一步降低。&lt;/p&gt;
&lt;h3&gt;有什么缺点？&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;尽管有上述各种优点，但它也绝不是一点缺点没有，它的主要缺点包括性能可能较低及略差的用户体验和用户界面等。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h2&gt;2020年还有哪些跨平台移动开发框架值得考虑&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;虽然跨平台的移动APP开发有利有弊。但从业务初创的角度来看，优点应该是大于缺点的。而且，随着对跨平台移动应用需求的不断增长，现在可用的工具和框架数量也已经很可观了。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;但选择过多会令人头疼，这就是为什么我们只关注最突出的跨平台移动开发框架的原因：React Native, Flutter, NativeScript, 和Xamarin。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;为了让你更深入地了解是什么使这些工具成为2020年软件开发的可选选项，我们将根据以下标准对它们进行打分：社区支持、基于的编程语言、代码可重用性、性能、界面以及使用它们构建的重要应用程序。&lt;/p&gt;
&lt;h3&gt;React Native&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202004/139239-20200402082149983-88438791.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Reaction Native是Facebook于2015年发布的开源、跨平台的应用开发框架。作为2013年举办的一场内部黑客马拉松的产物，它已经成为最受欢迎的原生App开发替代方案之一，拥有2043名GitHub贡献者，获得了超过82900 GitHub标星。不断增长的社区认知度使得找到一支可靠且经验丰富的开发团队来承接你的项目变得相对容易。&lt;/p&gt;
&lt;h4&gt;Learn Once and Write Anywhere&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;基于React.JS，React Native利用JavaScript(根据2019年Stack Overflow的调查，JavaScript成为了最受欢迎的编程语言)，为Android和iOS用户提供真正原生的应用外观和体验。另外，使该框架脱颖而出的是，如果你需要，React Native允许你使用Java、Objective-C或SWIFT编写部分原生模块来顺利处理复杂的操作，如视频播放或图像编辑。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;虽然这些组件不能在不同的平台之间共享，并且需要开发人员做更多的工作，但多达90%的React Native代码是可以重用的。很好地表明该框架的座右铭不是“Write Once, Use Anywhere”，而是“learn once, write anywhere”。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;就GUI而言，React Native可以提供接近原生的用户体验，这要归功于它使用了Android和iOS的本地控制器。它还使用带有UI元素的ReactJS库，这有助于加快UI设计过程。在开发移动应用程序时，使此框架值得考虑的另一个原因是，它可用在不丢失应用程序状态的情况下对UI进行更改。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;另一个使React Native成为2020年跨平台移动开发框架的首选之一，是因为持续的更新，例如近期的版本 0.60 和 0.61 ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多项辅助功能改进。&lt;/li&gt;
&lt;li&gt;更清晰、更人性化的开始屏幕。&lt;/li&gt;
&lt;li&gt;快速刷新，融合了实时和热重新加载，从而显著加快了开发进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ij&quot;&gt;如上的Release Note只是React Native适应不断变化的需求其中一个很小的样本。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h3&gt;Flutter&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202004/139239-20200402082250710-460218848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;2020年值得考虑的第二个框架是Flutter。它在Google I/O 2017上宣布，并于2018年发布，对于跨平台的世界来说，它现在仍然是一个“新人”。但尽管如此，它已经获得了超过80500 GitHub星标和绝大多数工程师将其称为2019年Stack Overflow调查中最受欢迎的三个框架之一，Flutter无疑是一股不可忽视的力量。&lt;/p&gt;
&lt;h4&gt;Dart是如何使Flutter变得独一无二的&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;Flutter 背后的编程语言是 Dart，谷歌称之为&quot;客户端优化&quot;，适合在任何平台上&quot;快速构建应用程序&quot;。它于 2011 年推出，是一种响应式面向对象的语言，被开发者认为相对容易学习，其中原因有二：第一，语法上它借鉴了C/C++ 和 Java; 第二，在&lt;a href=&quot;https://dart.dev/guides&quot; target=&quot;_blank&quot;&gt;官方网站上&lt;/a&gt;，您可以找到内容广泛且相当简单的文档。值得一提的是，Dart 附带了大量&lt;a href=&quot;https://pub.dev/flutter/packages&quot; target=&quot;_blank&quot;&gt;Flutter 兼容软件包&lt;/a&gt;的软件包，允许您使应用程序更加复杂。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Flutter的一个主要优势是，它的性能比本文提到的任何其他跨平台移动开发框架都要好。这归功于Dart的编译器和Flutter拥有自己的一套小部件。结果是它能更快、更直接地与平台直接通信，而不需要JavaScript桥(例如，Reaction Native就是这种情况)。说到小部件：通过Flutter的“UI-as-a-code”方法，它们只用DART编写，这就提高了代码的可重用性。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;效率与用户体验和界面密不可分。如前所述，Flutter不依赖于一组原生组件，而是利用可视化、结构化、平台性和交互式小部件进行UI的设计，所有这些都由框架的图形引擎呈现。更重要的是，Flutter留下了很大的定制空间，如果你想要设计一个很完美的UI，它是个很好的选择。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;说到Flutter的更新，最新的稳定版本是在12月12日发布的，根据官方发布说明，它合并了来自188个贡献者的近2000个pull。例如，版本1.12.13中包括的改进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重大的API变动。&lt;/li&gt;
&lt;li&gt;新功能，例如SliverOpacity小部件和SliverAnimatedList。&lt;/li&gt;
&lt;li&gt;修复了崩溃和性能问题。&lt;/li&gt;
&lt;li&gt;Beta版中的Web支持。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ij&quot;&gt;这不是一个完整的清单，因为Flutter的目标是让每年发布的四个版本中的每一个版本都能为框架的可用性提升一个台阶。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Flutter是一个年轻的跨平台移动应用程序开发框架，所以它没有像React Native受到众多的大公司青睐也是不足为奇的。然而，这并不意味着它不好，截至2019年12月，它也为阿里巴巴、谷歌广告、Groupon等众多公司和业务所采用。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h3&gt;NativeScript&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202004/139239-20200402082321570-557175060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;如果你要开始开发你的产品，“React Native”和“Flutter”绝不是唯一的解决方案。在 2020 年初，适合您的企业的替代框架也可能是 NativeScript。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;这个开源框架于2015年3月公开发布，并迅速成为广受欢迎的解决方案。例如，在发布后的短短两个月内，它就获得了3000颗GitHub星标，并在Twitter上吸引了1500多名粉丝的关注。到今天为止，市场上已有超过700个插件可供选择。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;在使用NativeScript构建跨平台应用程序时，开发人员首先用JavaScript及其超集TypeScript编写代码。然后，将代码库编译成各自平台原生的编程语言。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;另外值得一提的是，使用 NativeScript 的开发人员也可以使用第三方库（CocoaPods 和 Android SDK），而无需包装。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;与React Native类似，NativeScript允许访问Android和iOS原生API，这对跨平台应用程序有明显的积极影响。然而，不同之处在于，前者需要构建桥接API，而后者（用Progress首席开发者倡导者TJ VanToll的话说是“将所有iOS和Android API注入JavaScript虚拟机”）。与Facebook框架的另一个相似之处在于代码重用，在这两种情况下都可以达到90%。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;Xamarin&lt;/h3&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202004/139239-20200402082434086-13913983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Xamarin开源框架创建于2011年，这使它成为了这个列表中最“古老“的框架，但直到五年前它被微软收购时，它才获得了发展势头。截至今天，它号称拥有超过6万名贡献者的社区。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;从技术上讲，要用Xamarin构建跨平台的移动应用，需要很好地掌握.NET和C#两种技术，前者是使用多种语言(包括C#编程语言)、编辑器和库的开发平台。Xamarin用一组工具补充了上述平台，这些工具有助于构建跨平台应用程序，例如库、编辑器扩展和XAML。第二种技术是C#，这是一种面向对象的编程语言，它被认为比JavaScript学习起来稍难。Xamarin利用这种编程语言编写整个应用程序，从后端到原生API，再到业务逻辑。&lt;/p&gt;
&lt;h4&gt;Xamarin.Native和Xamarin.Forms&lt;/h4&gt;
&lt;p class=&quot;ij&quot;&gt;Xamarin与其他框架的不同之处在于，它提供了两种编译跨平台移动应用的方式：Xamarin Native(也称为Xamarin.Android/iOS)和Xamarin.Forms。前一种方法优先考虑共享业务逻辑，并通过使用本机接口控件实现近乎本机的性能。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;后者侧重于共享代码，而不是业务原理，这一方面会导致代码重用比例增加(使用Xamarin，开发人员可以重用高达96%的C#代码)，但另一方面这样会降低代码性能。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;您可能已经注意到，跨平台移动应用程序的性能和GUI密切相关，所以如果我说Xamarin构建应用程序的两种方法对界面的最终外观有很大影响，我可能不会感到惊讶。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Xamarin.Android/iOS允许开发人员使用原生控件和布局，而Xamarin.Forms基于标准UI元素，允许从单个API设计应用程序，但如果你需要更完美的原生UI，则可能还不够。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;2020年跨平台应用程序开发还值得考虑吗？&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;不论如何，跨平台确实是一个值得考虑和极具前景的方向，特别是我们上面提到的 “React Native”和“Flutter”。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;前者是一个成熟而稳定的框架，利用了最流行的编程语言之一，并拥有成熟的大型开发人员社区。后者是一个快速发展的技术，尽管它比React Native年轻的多，它也已经赢得了世界各地许多开发人员的青睐。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;但无论您选择的是“React Native”、“Flutter”还是任何其他框架，跨平台方法都一定会为您节省时间和金钱，同时能为你最大限度地扩大市场覆盖范围。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;最后，值不值得考虑，最终还是取决于你的业务目标、预算和时限。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 原文出处：https://dzone.com/articles/cross-platform-mobile-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/12617362.html</dc:identifier>
</item>
<item>
<title>GitLab → 搭建中常遇的问题与日常维护 - 青石路</title>
<link>http://www.cnblogs.com/youzhibing/p/12572598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/12572598.html</guid>
<description>&lt;h2&gt;开心一刻&lt;/h2&gt;
&lt;p&gt;　　隔壁有一个80多岁的老大爷，昨天在小区的一棵树下发现一条黑色的蛇，冻僵了，大爷善心大发，就把蛇揣在了怀里，想给它一点温暖。&lt;/p&gt;
&lt;p&gt;　　今天一大早看到大爷在树上挂了一个牌子，写到：不准随地大小便！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331093757990-134065675.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;搭建中遇到的问题&lt;/h2&gt;
&lt;p&gt;　　楼主的搭建过程算比较顺利（&lt;a href=&quot;https://www.cnblogs.com/youzhibing/p/12487043.html&quot; target=&quot;_blank&quot;&gt;GitLab → 搭建私有的版本控制的托管服务平台&lt;/a&gt;），没有遇到太多问题，只遇到了如下两个问题&lt;/p&gt;
&lt;h3&gt;　　安装卡住&lt;/h3&gt;
&lt;p&gt;　　　　这基本是内存不足导致&lt;/p&gt;
&lt;p&gt;　　　　楼主一开始比较任性，没按官方的推荐（内存最少 4G）来，弄了个 2G 内存，一顿操作猛如虎，定睛一看原地杵，特么的竟然像泰山一样稳，进度在那一动不动&lt;/p&gt;
&lt;p&gt;　　　　直接卡住是比较烦的，因为不能直观地看出是否真的是卡住了，还是在安装中，只能凭感觉、经验来判断；如果出现如下类似错误信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
* execute[&lt;span&gt;clear&lt;/span&gt; the gitlab-&lt;span&gt;rails cache] action run
&lt;/span&gt;================================================================================&lt;span&gt;
Error executing action `run` on resource &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;execute[clear the gitlab-rails cache]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
================================================================================
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这也是内存不足所致&lt;/p&gt;
&lt;h3&gt;　　502&lt;/h3&gt;
&lt;p&gt;　　　　当我们成功安装、配置 GitLab 后，不一定就万事大吉了，访问 GitLab 的时候可能会出现如下错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331095715919-1960232494.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　GitLab 所需内存最低为 4G，若服务器配置太低会出现 502 错误&lt;/p&gt;
&lt;h3&gt;　　GitLab 新装或重启后，需要等待 1 分钟才能使用&lt;/h3&gt;
&lt;p&gt;　　　　对于单核 CPU 的服务器，Unicorn and Sidekiq 服务启动最少需要一分钟&lt;/p&gt;
&lt;p&gt;　　　　这个问题楼主没有遇到，因为开始的时候，楼主就给虚拟机分了 4 核 CPU&lt;/p&gt;
&lt;p&gt;那么说白了，只要我们的虚拟机（或真实机器）环境足够干净，硬件资源（内存和 CPU）足够好，就不太会出现如上的错误&lt;/p&gt;
&lt;h2&gt;日常维护&lt;/h2&gt;
&lt;h3&gt;　　重置管理员的密码&lt;/h3&gt;
&lt;p&gt;　　由于 root 账户用的很少，所以我们容易忘记它的密码，但不代表它不重要，类似 linux 的 root 账户；一旦我们忘记了 root 账号的密码，我们需要知道重置的方法，方法如下 &lt;/p&gt;
&lt;p&gt;　　1、进入 GitLab 控制台&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# gitlab-rails console -e production
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　GitLab 版本不同，命令会有所不同（网上说的而基本都是 &lt;span class=&quot;cnblogs_code&quot;&gt;gitlab-rails console production&lt;/span&gt; ），推荐大家直接上 GitLab 官网去找对应版本的命令&lt;/p&gt;
&lt;p&gt;　　　　当出现如下信息表示我们成功登入控制台&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# gitlab-rails console -&lt;span&gt;e production
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
 GitLab:       &lt;/span&gt;&lt;span&gt;12.8&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt; (b679f55a199) FOSS
 GitLab Shell: &lt;/span&gt;&lt;span&gt;11.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 PostgreSQL:   &lt;/span&gt;&lt;span&gt;10.12&lt;/span&gt;
--------------------------------------------------------------------------------&lt;span&gt;
Loading production environment (Rails &lt;/span&gt;&lt;span&gt;6.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
irb(main)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　执行命令： &lt;span class=&quot;cnblogs_code&quot;&gt;user = User.where(&lt;span&gt;id&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;).first&lt;/span&gt; ，此 user 则表示 root 用户&lt;/p&gt;
&lt;p&gt;　　3、修改密码&lt;/p&gt;
&lt;p&gt;　　　　执行命令： &lt;span class=&quot;cnblogs_code&quot;&gt;user.password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;secret_pass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 修改密码， &lt;span class=&quot;cnblogs_code&quot;&gt;user.password_confirmation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;secret_pass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 确认密码&lt;/p&gt;
&lt;p&gt;　　4、保存密码&lt;/p&gt;
&lt;p&gt;　　　　执行命令： &lt;span class=&quot;cnblogs_code&quot;&gt;user.save!&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　5、退出控制台&lt;/p&gt;
&lt;p&gt;　　　　执行命令： &lt;span class=&quot;cnblogs_code&quot;&gt;exit&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　完整过程类似如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331145416998-1805746637.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　官方示例：&lt;a href=&quot;https://docs.gitlab.com/ee/security/reset_root_password.html#how-to-reset-your-root-password&quot; target=&quot;_blank&quot;&gt;How to reset your root password&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　重置成功后，我们就可以用新密码来登录 root 账号了&lt;/p&gt;
&lt;h3&gt;　　偏好设置&lt;/h3&gt;
&lt;p&gt;　　GitLab 提供了很多的设置，楼主这里偷个懒，只教大家如何设置语言（虽然楼主知道大家的英语都很棒，但我相信大家的中文更棒），当语言变成我们最擅长的中文时，相信大家都能很好的进行偏好设置了；语言设置过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331151822566-1032089514.gif&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看着熟悉的中文，倍感亲切，但是要注意： &lt;span class=&quot;cnblogs_code&quot;&gt;此功能当初处于实验阶段，翻译尚未全部完成&lt;/span&gt; ，也就是说语言功能尚未全部完成&lt;/p&gt;
&lt;h3&gt;　　批量添加账号&lt;/h3&gt;
&lt;p&gt;　　我们用 SVN 或 Git 的时候，账号往往不是自己注册的，而是统一分配的；而我们搭建的又是私服，不对外提供服务，所以无需注册功能，那么我们用 root 账号来关闭注册功能，很简单，流程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331155042148-657835205.gif&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　取消 &lt;span class=&quot;cnblogs_code&quot;&gt;Sign-up enabled&lt;/span&gt; 前的复选框勾选，保存就好了&lt;/p&gt;
&lt;p&gt;　　退出登录后可以发现，登录页的注册功能没了，既然不能注册了，那么就需要通过 root 用户来添加账号了&lt;/p&gt;
&lt;p&gt;　　添加单个账号的话，可以直接通过管理中心来添加，具体如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202003/747662-20200331195733039-1163471913.gif&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　单个账号的添加还可以通过 api 来实现，具体可查看：&lt;a href=&quot;https://s0docs0gitlab0com.icopy.site/ee/api/users.html&quot; target=&quot;_blank&quot;&gt;Users API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果账号少的话，通过单个添加的方式来添加是可以的，如果账号特别多的话，那就有点费时了，所以需要通过脚本的方式来批量添加账号了，具体我们往下看&lt;/p&gt;
&lt;p&gt;　　1、创建账户文本&lt;/p&gt;
&lt;p&gt;　　　　在 &lt;span class=&quot;cnblogs_code&quot;&gt;/opt&lt;/span&gt; 目录下创建 &lt;span class=&quot;cnblogs_code&quot;&gt;account_info.txt&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt; youzhibing2094@sina.com yzb2094 青石路&lt;br/&gt;&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt; test1@qq.com test1 测试账号1
&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt; test2@qq.com test2 测试账号2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　4 列分别代表：登录密码　　邮箱　　用户名　　别名&lt;/p&gt;
&lt;p&gt;　　　　一行代表一个账户&lt;/p&gt;
&lt;p&gt;　　2、获取 root 用户的 private_token&lt;/p&gt;
&lt;p&gt;　　　　获取方式比较简单，如下图所示&lt;/p&gt;
&lt;p&gt;　　　　如果访问令牌已经存在，则不需要新建；示例中的令牌： &lt;span class=&quot;cnblogs_code&quot;&gt;cwUxu3-2kiamVyKJQpW5&lt;/span&gt;  &lt;/p&gt;
&lt;p&gt;　　3、创建执行脚本&lt;/p&gt;
&lt;p&gt;　　　　在 &lt;span class=&quot;cnblogs_code&quot;&gt;/opt&lt;/span&gt; 目录下创建 &lt;span class=&quot;cnblogs_code&quot;&gt;batch_add_account.&lt;span&gt;sh&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
#gitlab用户文本
accountinfo&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;account_info.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; read line 
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    password&lt;/span&gt;=`&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
    mail&lt;/span&gt;=`&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $2}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
    username&lt;/span&gt;=`&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $3}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
    name&lt;/span&gt;=`&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $4}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
    curl &lt;/span&gt;-d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password=$password&amp;amp;email=$mail&amp;amp;username=$username&amp;amp;name=$name&amp;amp;private_token=cwUxu3-2kiamVyKJQpW5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.0.115/api/v4/users&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
done &amp;lt; $accountinfo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　private_token 的值就是上面 root 的访问令牌&lt;/p&gt;
&lt;p&gt;　　4、执行脚本&lt;/p&gt;
&lt;p&gt;　　　　赋予 batch_add_account.sh 可执行权限： &lt;span class=&quot;cnblogs_code&quot;&gt;[root@localhost opt]# &lt;span&gt;chmod&lt;/span&gt; +x /opt/batch_add_account.&lt;span&gt;sh&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　　　再执行 batch_add_account.sh： &lt;span class=&quot;cnblogs_code&quot;&gt;[root@localhost opt]# &lt;span&gt;sh&lt;/span&gt; /opt/batch_add_account.&lt;span&gt;sh&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　　　然后我们就可以在用户列表界面看到我们刚刚添加的账户了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202004/747662-20200401134912537-928294041.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　批量创建用户，还是通过 Users API 来完成的，也会是说底层还是一个一个添加的&lt;/p&gt;
&lt;p&gt;　　5、新账户登录&lt;/p&gt;
&lt;p&gt;　　　　我们用账号：yzb2094 登录下，发现登录不了，提示：  &lt;span class=&quot;cnblogs_code&quot;&gt;You have to confirm your email address before continuing.&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　　　提示需要邮箱验证，登录下邮箱，还真有一封验证邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202004/747662-20200401140625627-1203166463.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　我们点击下其中的链接，完成验证之后就可以正常登录了，然后我们就可以在 GitLab 创建工程了， 后续操作就与 GitHub、Gitee 一样了&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.gitlab.com/ee/README.html&quot; target=&quot;_blank&quot;&gt;GitLab Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/5985918.html&quot; target=&quot;_blank&quot;&gt;Gitlab快速部署及日常维护（社区版RPM包方式安装）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Apr 2020 00:23:00 +0000</pubDate>
<dc:creator>青石路</dc:creator>
<og:description>开心一刻 隔壁有一个80多岁的老大爷，昨天在小区的一棵树下发现一条黑色的蛇，冻僵了，大爷善心大发，就把蛇揣在了怀里，想给它一点温暖。 今天一大早看到大爷在树上挂了一个牌子，写到：不准随地大小便！ 搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youzhibing/p/12572598.html</dc:identifier>
</item>
<item>
<title>超参数、验证集和K-折交叉验证 - renyuzhuo</title>
<link>http://www.cnblogs.com/renyuzhuo/p/12617224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renyuzhuo/p/12617224.html</guid>
<description>&lt;ul&gt;&lt;li&gt;本文首发自公众号：&lt;a href=&quot;https://ai.renyuzhuo.cn/img/wechat_ercode.png&quot;&gt;RAIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;前言&quot;&gt;​前言&lt;/h2&gt;
&lt;p&gt;本系列文章为 《Deep Learning》 读书笔记，可以参看原书一起阅读，效果更佳。&lt;/p&gt;
&lt;h2 id=&quot;超参数&quot;&gt;超参数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;参数：网络模型在训练过程中不断学习自动调节的变量，比如网络的权重和偏差；&lt;/li&gt;
&lt;li&gt;超参数：控制模型、算法的参数，是架构层面的参数，一般不是通过算法学习出来的，比如学习率、迭代次数、激活函数和层数等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与超参数对比的概念是参数,我们平时训练网络所说的调参，指的是调节 &lt;strong&gt;超参数&lt;/strong&gt;。超参数的确定方法一般是凭借经验，或者类似问题的参数迁移。&lt;/p&gt;
&lt;p&gt;问题来了，为啥超参数不通过学习确定？这是因为这个参数不那么好优化，并且稍不留神通过学习方法去优化就可能导致过拟合。你可能认为模拟人的调参过程，进行超参数的调节不就好了，当然这是可以的，超参数也不是完全不可以用程序优化的，但是现有的理论还不成熟，还没有理论去有效的指导实践，这还是一个新兴领域，因此还有许多工作要做，很多情况下是凭经验，凭直觉进行优化的，算法表现并不好。&lt;/p&gt;
&lt;p&gt;我们知道，更高次的多项式和权重衰减参数设定 λ=0 总是能更好的拟合，会过拟合，对于这个问题，我们会考虑用验证集的方法，验证集在我们前文&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MzQzMDE0NQ==&amp;amp;mid=2247483867&amp;amp;idx=1&amp;amp;sn=b464f72d3f369233b919a0041a952063&amp;amp;chksm=e9d5d135dea25823f232fd5419a553eb0b17ce2faeb80f121ea27510cc4ba8ffd79f15f2b7f5&amp;amp;scene=21#wechat_redirect&quot;&gt;《人工智能二分类问题》&lt;/a&gt;中提到过。&lt;/p&gt;
&lt;h2 id=&quot;验证集&quot;&gt;验证集&lt;/h2&gt;
&lt;p&gt;验证集是用来训练超参数的，是用来给网络提供反馈的。我们用训练集去训练一个网络模型，训练出的参数固定下来，然后将验证集的数据应用到这个模型上，会得到偏差，我们根据这个偏差，调整超参数，然后重新去训练网络，重复迭代一定的次数，会调节出一个超参数还不错的网络，基于这个超参数训练出的模型，可以最终到测试集合上验证，最终确定在测试集上表现如何。下面举个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LWU4OTZmN2YxM2ExNGY4ZGQ?x-oss-process=image/format,png&quot; alt=&quot;训练和验证损失&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是之前在&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MzQzMDE0NQ==&amp;amp;mid=2247483867&amp;amp;idx=1&amp;amp;sn=b464f72d3f369233b919a0041a952063&amp;amp;chksm=e9d5d135dea25823f232fd5419a553eb0b17ce2faeb80f121ea27510cc4ba8ffd79f15f2b7f5&amp;amp;scene=21#wechat_redirect&quot;&gt;《人工智能二分类问题》&lt;/a&gt;中的一张图，我们看到验证损失在迭代 4 次之后大幅上升，这就是由于我们训练次数迭代过多导致的，迭代次数这个超参数设置的不合理，因此我们更改迭代次数为 4 次。这就是根据验证集调节超参数的一个例子。&lt;/p&gt;
&lt;p&gt;数据量小，训练集:验证集:测试集=6:2:2，数据量足够大，训练集:验证集:测试集=98:1:1。这算是一个经验值吧。&lt;/p&gt;
&lt;h2 id=&quot;k-折交叉验证&quot;&gt;K-折交叉验证&lt;/h2&gt;
&lt;p&gt;我们在之前的 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MzQzMDE0NQ==&amp;amp;mid=2247483888&amp;amp;idx=1&amp;amp;sn=edd87db473abc2622a9fd5dff7a9744e&amp;amp;chksm=e9d5d11edea25808b69581d7dd981e50410a0e054c2a6f3a33fb819605f522c36eb4ca439eb9&amp;amp;scene=21#wechat_redirect&quot;&gt;《预测房价》&lt;/a&gt; 问题中有提到过交叉验证这个方法，这个方法用于解决的问题就是数据量太小的问题，而导致的对网络测试误差估计不准的问题，&lt;strong&gt;K-折交叉验证&lt;/strong&gt; 是其中最常见的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDIzNTY5LTA5MmYzMWJlNmNjYmEyODI?x-oss-process=image/format,png&quot; alt=&quot;K-折交叉验证&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中，我们可以清楚的看到K-折交叉验证的方法具体是怎么做的。由于数据量不够大，因此我们把数据分为 K 份，循环 K 次，每次分别选取其中的一份作为测试集，这样根据我们训练出的网络，我们可以分别求出每一次的测试误差，用这 K 个测试误差求其平均值，我们就估计其为这个网络的测试误差。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们本篇文章介绍了参数和超参数的区别，调参指的是调节超参数，并且介绍了在数据量较小的情况下如何如何去估计测试误差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2023569-cc40fe10d568aa89?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;RAIS&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文首发自公众号：&lt;a href=&quot;https://ai.renyuzhuo.cn/img/wechat_ercode.png&quot;&gt;RAIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 02 Apr 2020 00:21:00 +0000</pubDate>
<dc:creator>renyuzhuo</dc:creator>
<og:description>本文首发自公众号： &amp;quot;RAIS&amp;quot; ​前言 本系列文章为 《Deep Learning》 读书笔记，可以参看原书一起阅读，效果更佳。 超参数 参数：网络模型在训练过程中不断学习自动调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/renyuzhuo/p/12617224.html</dc:identifier>
</item>
<item>
<title>程序员如何利用技术变现？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12617327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12617327.html</guid>
<description>&lt;p&gt;程序员用自己的技术变现，是一件天经地义的事情，完全没必要红着脸在那不好意思。因为写作，我认识了不少读者，他们当中有很大一部分不够自信，迷茫和彷徨，就不知道自己该学些什么，往哪个方向发展，也不知道该怎么通过技术变现。我就来结合自己的一些亲身经历和你聊聊，虽然不一定适合你，但肯定具有参考价值。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/jishu-bianxian-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01、大学时期&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我大学就有幸学了 Java，但那时候傻乎乎地根本就不懂互联网，更不知道这是一门极具价值的编程语言。班里有好几个同学都拼命地往电力专业转，因为“电力”是学校的立命之本，毕业后如果能够顺利进入国家电网的相关单位，算是铁饭碗了。但从现在的结果来看，这些转专业的同学的选择都很坏，毕竟饭碗就那么多，但挤进来的人却越来越多，想往高层挤，只有熬，于是大部分都只能做个小职员。&lt;/p&gt;
&lt;p&gt;那时候，同学们唯一能变现的渠道就是打零工，我也跟着好兄弟一块发过一次传单，但最后我没坚持下去，把一大叠的传单扔进了垃圾桶，并且是在一个偏僻不容易被发现的地方。想想也是残忍，对于那些传单来说，竟然不明不白地被宣判了死刑。&lt;/p&gt;
&lt;p&gt;通过写作，我认识了好多优秀的年轻人，他们令我感到由衷地钦佩，和同时期的我完全不同，有着质的差别。&lt;/p&gt;
&lt;p&gt;小美，据她说，老师的一个汽车轮子是她贡献的，当然不是造出来的，用她写的代码换来的。虽然老师支付给她的报酬远远够不上买一个车轮子的钱。但毕竟能贴补点生活费，有点总比没有强。&lt;/p&gt;
&lt;p&gt;是的，大学的老师手里头不缺项目，尤其是对于那些没有完全把心思扑到教学上面的年轻老师来说。因为往上升的路子几乎是被堵死的，不想想其他的渠道，确实过得很糟心，也怨不得他们。&lt;/p&gt;
&lt;p&gt;如果你和老师的关系走得比较近，赢得了老师的信任（前提条件是技术实力过关），那么他很乐意分你一杯羹喝喝。现在的企业很看重项目经验，如果你刚好是一名大学生，可以趁机锻炼一下。至于报酬啥的，能给老师多要点就多要点呗，毕竟是自己付出的血汗钱，没必要不好意思要。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02、初入职场&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我刚参加工作那会虽然很拼，但现在想想，远没到特别拼的地步（我可不建议为福报拼）。这是因为在没有班加的那些日子里，几乎全靠打游戏而不是学习度过的。比如说极品飞车、三国群英传、NBA 2006、火炬之光这些单机游戏，真的是刷完一遍又一遍。就连望而生畏的手操型游戏 Dota，也被几个同事带上了道，每逢周末，杀的是昏天暗地。&lt;/p&gt;
&lt;p&gt;身边的同事几乎都这样过，除此之外，谈情说爱，体育锻炼恐怕是最积极的 2 件事了。现在想想，那些日子过得实在是够奢侈的。&lt;/p&gt;
&lt;p&gt;小南，是我去年认识的一个读者，今年是他工作的第三年，但前前后后已经承接过 10 个外包项目了。目前已经有了自己的小团队，他只负责和客户对接（需求沟通，业务分析，价格洽谈），已经不需要亲自编写代码了。虽然项目总额没多少，大概一个在 2 万到 3 万之间，但每个项目至少能够抽 30% 以上的佣金。&lt;/p&gt;
&lt;p&gt;交付的产品质量也都赢得了客户的信任，渐渐地，圈子就攒了起来。&lt;/p&gt;
&lt;p&gt;我知道，外包被很多很多大佬唾弃，但说句实在话，现实是很骨干的。在你没有更多生存技能之前，活着永远都应该放在第一位。况且，做外包和打游戏比起来，显然价值更大。&lt;/p&gt;
&lt;p&gt;不要反驳我，说“做外包很累，没有资源，没有时间”。我有一个大学同学，做汽车销售的，平常很累的，晚上 9 点以后下班是很正常的一件事。但就算这样 ，每次下班后，总要和几名同事凑在一起打上至少 5 把王者荣耀。我是怎么知道的？我家的车就是通过他买的，平常没少见面。&lt;/p&gt;
&lt;p&gt;我一直提醒他，要不要做直播，你的口音很标准，销售能力又这么牛，关键是长得也不赖，做直播肯定赚钱。但他求我放过，说“兄弟，别这样，我做销售很累了，况且挣钱也不比你少；打打游戏是放松心情，每个人都有自己的生活方式，万事不能强求。”&lt;/p&gt;
&lt;p&gt;他说的有道理的。但如果你初入职场，不喜欢打游戏，也还有一定的时间，外包就是一种最直接的技术变现方式，看不起的另说。怎么开展业务呢？同学、同事、领导，总有人做的。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、新的机遇&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我是在 2014 年 2 月份从苏州回洛阳的，这意味着我在日企的职业生涯也就此终结了。回来之前刚刚涨了工资，签订了新的三年合同。但合同就生效了一个月，我就趁着过年这个节点离职了，有太多的不舍。&lt;/p&gt;
&lt;p&gt;舍不得那些相处了三年多的同事，舍不得气候宜人的苏州（治好了我的青春痘，真的特别神奇），舍不得处于上升期的工作。但我必须做出决断，因为洛阳有一个更重要的人等着我。回来后，莫名其妙地就开始了写作，一直写到现在，未来还会继续写。&lt;/p&gt;
&lt;p&gt;微笑哥，是我接触的最多的一个大佬，由衷地佩服，目前已经成为一名自由职业者，他的经历真可谓励志的最好榜样。&lt;/p&gt;
&lt;p&gt;他之前在北京一家第三方支付公司，做到副总的级别，薪资待遇非常不错。闲暇之余，就开始在博客园上写作，他更新的 Springboot 系列文章广受欢迎，在很短的时间里就积累了一大批忠实的读者。2017 年 4 月 25 号，开始正式运营“纯洁的微笑”公号，2017 年 11 月 18 号突破了 1 万读者。目前应该至少 25 万了。&lt;/p&gt;
&lt;p&gt;在我运营“沉默王二”公号的初期，微笑哥给予了我很大的鼓励和帮助，在他的公号上帮我免费推广了很多次，帮助我快速度过了冷启动的困难阶段。&lt;/p&gt;
&lt;p&gt;最近一个月的时间，我开始日更，阅读量、在看数、留言数，更是节节攀升，微笑哥说 2020 年是我“将要爆发”的一年，不留情面地夸啊。&lt;/p&gt;
&lt;p&gt;对于我一个热爱写作的人来说，公号是技术变现的最好渠道。为什么这么说呢？&lt;/p&gt;
&lt;p&gt;你看，我经过 10 多年的技术积累，经验是有了，再加上文章写得有趣，就更容易把知识传播给更多需要帮助的年轻人。这么一来，广告主就会找到我，让我帮他们推广课程，我也就恰饭成功了，写作的动力也就更足了，共赢的局面——独乐乐不如众乐乐，很完美的节奏。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、最后&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面就是这 10 多年来我的亲身经历，也许这些经历你也有过，或者以后要经历。不管它好与坏，都会从正面或者反面给你提供一些参考的价值。如果要我从新从头来一遍的话，我肯定会做得更好。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/jishu-bianxian-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;比如说，上大学的时候，就深入一些计算机的原理、内存的原理，如果实在学不会的话，也没关系，把学不会的心得体会写成文章分享出来，做一个反面的教材，从而积累一些初期的影响力。&lt;/p&gt;
&lt;p&gt;等到初入职场，就绞尽脑汁想尽办法去研究公司那些难的核心技术，成为团队的领头人，提升自己在职场上的价值。&lt;/p&gt;
&lt;p&gt;如果在职场上遇到瓶颈了，也没关系。开始利用经验输出正确的人生观、以及有趣的技术理解，从而帮助更多的年轻人，筑起自己的护城河。&lt;/p&gt;
&lt;h3 id=&quot;h05&quot;&gt;&lt;span&gt;05、最近，有不少读者私信让我帮他审查简历&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;但说句实在话，我的时间和精力确实有限，一对多这种服务我有点应付不过来，于是我就琢磨，有没有其他更好的解决方案。问了不少身边的朋友，其中一个刚入职阿里的读者给了我一份简历模板，我看了看，觉得确实牛逼，就专门总结了一篇博文，你可以点击下面这个链接跳转过去看看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qing_gee/article/details/104839150&quot;&gt;我入职阿里后，才知道原来简历这么写&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得麻烦的话，你还可以在我的原创微信公众号『沉默王二』回复『&lt;strong&gt;简历&lt;/strong&gt;』获取我自己整理的一份简历模板，很多读者看完后都发私信给我说，超值，赚了，妈妈再也不用担心我的简历问题了。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;有收获？希望老铁们来个三连击，给更多的同学看到这篇文章&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、老铁们，关注我的原创微信公众号「沉默王二」，专注于有趣有益的程序人生，保证你看完有所收获，不信你打我。&lt;/p&gt;
&lt;p&gt;2、给二哥点个赞呗，可以让更多的人看到这篇文章，顺便激励下我，嘻嘻。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者info&lt;br/&gt;作者：沉默王二，《Web全栈开发进阶之路》作者&lt;br/&gt;原创公众号：『沉默王二』，已写了 250 多篇文章，专注于有趣的 Java 技术和有益的程序人生，期待你的关注。&lt;br/&gt;转载说明：务必注明来源（注明：来源于公众号：沉默王二， 作者：沉默王二）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>程序员用自己的技术变现，是一件天经地义的事情，完全没必要红着脸在那不好意思。因为写作，我认识了不少读者，他们当中有很大一部分不够自信，迷茫和彷徨，就不知道自己该学些什么，往哪个方向发展，也不知道该怎么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12617327.html</dc:identifier>
</item>
<item>
<title>从JSON中自动生成对应的对象模型 - 琴水玉</title>
<link>http://www.cnblogs.com/lovesqcc/p/12617323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesqcc/p/12617323.html</guid>
<description>&lt;p&gt;通过编写程序，从 JSON 串中自动生成对应的对象模型，使得这个过程自动化，让类似事情的效率成倍的增长了。让效率成倍增长的有效之法就是提升代码和方案的复用性，自动化手工处理。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;192&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;编程的乐趣和挑战之一，就是将体力活自动化，使效率成十倍百倍的增长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;
&lt;p&gt;做一个项目，需要返回一个很大的 JSON 串，有很多很多很多字段，有好几层嵌套。前端同学给了一个 JSON 串，需要从这个 JSON 串建立对应的对象模型。&lt;br/&gt;比如，给定 JSON 串：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{&quot;error&quot;:0,&quot;status&quot;:&quot;success&quot;,&quot;date&quot;:&quot;2014-05-10&quot;,&quot;extra&quot;:{&quot;rain&quot;:3,&quot;sunny&quot;:2},&quot;recorder&quot;:{&quot;name&quot;:&quot;qin&quot;,&quot;time&quot;:&quot;2014-05-10 22:00&quot;,&quot;mood&quot;:&quot;good&quot;,&quot;address&quot;:{&quot;provice&quot;:&quot;ZJ&quot;,&quot;city&quot;:&quot;nanjing&quot;}},&quot;results&quot;:[{&quot;currentCity&quot;:&quot;南京&quot;,&quot;weather_data&quot;:[{&quot;date&quot;:&quot;周六今天,实时19&quot;,&quot;dayPictureUrl&quot;:&quot;http://api.map.baidu.com/images/weather/day/dayu.png&quot;,&quot;nightPictureUrl&quot;:&quot;http://api.map.baidu.com/images/weather/night/dayu.png&quot;,&quot;weather&quot;:&quot;大雨&quot;,&quot;wind&quot;:&quot;东南风5-6级&quot;,&quot;temperature&quot;:&quot;18&quot;},{&quot;date&quot;:&quot;周日&quot;,&quot;dayPictureUrl&quot;:&quot;http://api.map.baidu.com/images/weather/day/zhenyu.png&quot;,&quot;nightPictureUrl&quot;:&quot;http://api.map.baidu.com/images/weather/night/duoyun.png&quot;,&quot;weather&quot;:&quot;阵雨转多云&quot;,&quot;wind&quot;:&quot;西北风4-5级&quot;,&quot;temperature&quot;:&quot;21~14&quot;}]}]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析出对应的对象模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Domain implements Serializable {
    private Integer error;
    private String status;
    private String date;
    private List&amp;lt;Result&amp;gt; Results;
    private Extra extra
}

        
public class Extra implements Serializable {
    private Integer rain;
    private Integer sunny;
}

        

public class Recorder implements Serializable {
    private String name;
    private String time;
    private String mood;
    private Address address
}

        
public class Address implements Serializable {
    private String provice;
    private String city;
}

        

public class Result implements Serializable {
    private String currentCity;
    private List&amp;lt;Weather_data&amp;gt; Weather_datas;

}

        
public class Weather_data implements Serializable {
    private String date;
    private String dayPictureUrl;
    private String nightPictureUrl;
    private String weather;
    private String wind;
    private String temperature;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么办呢 ？ 那么复杂的 JSON 串，手写的话，估计得写两个小时吧，又枯燥又容易出错。能否自动生成呢 ？&lt;/p&gt;
&lt;h2 id=&quot;算法分析&quot;&gt;算法分析&lt;/h2&gt;
&lt;p&gt;显然，需要遍历这个 JSON ，分三种情形处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;值为基本类型： 解析出对应的类型 type 和 字段名 name&lt;/li&gt;
&lt;li&gt;值为 JSON 串： 需要递归处理这个 JSON 串&lt;/li&gt;
&lt;li&gt;值为 List : 简单起见，取第一个元素，如果是基本类型，按基本类型处理，类型为 List[Type] ；如果是 JSON ，则类型为 List[ClassName]，然后再递归处理这个 JSON。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一个代码实现&quot;&gt;一个代码实现&lt;/h3&gt;
&lt;p&gt;第一版程序如下，简单直接。这里用到了一些知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串中的变量引用和方法调用： &lt;code&gt;&quot;${indent()}private ${getType(v)} $k;\n&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最简单的模板引擎： SimpleTemplateEngine&lt;/li&gt;
&lt;li&gt;函数式编程： 在 parseMap 方法中传入 keyConverter 是为了处理下划线转驼峰。不传则默认不转换。&lt;/li&gt;
&lt;li&gt;JSON 转换为对象： jsonSlurper.parseText(json)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JsonParser.groovy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;package cc.lovesq.study.json

import groovy.json.JsonSlurper
import static cc.lovesq.study.json.Common.*

class JsonParser {

    def jsonSlurper = new JsonSlurper()

    def parse(json) {
        def obj = jsonSlurper.parseText(json)
        Map map = (Map) obj
        parseMap(map, 'Domain', Common.&amp;amp;underscoreToCamelCase)
    }

    def parseMap(Map map, String namespace, keyConverter) {
        def classTpl = classTpl()
        def fields = &quot;&quot;
        map.each {
            k, v -&amp;gt;
                if (!(v instanceof Map) &amp;amp;&amp;amp; !(v instanceof List)) {
                    fields += &quot;${indent()}private ${getType(v)} $k;\n&quot;
                }
                else {

                    if (v instanceof Map) {
                        def className = getClsName(k)
                        fields += &quot;${indent()}private $className $k;\n&quot;
                        parseMap(v, convert(className, keyConverter), keyConverter)
                    }

                    if (v instanceof List) {
                        def obj = v.get(0)
                        if (!(obj instanceof Map) &amp;amp;&amp;amp; !(obj instanceof List)) {
                            def type = getType(obj)
                            fields += &quot;${indent()}private List&amp;lt;$type&amp;gt; ${type}s;\n&quot;
                        }
                        if (obj instanceof Map) {
                            def cls = getClsName(k)
                            if (cls.endsWith('s')) {
                                cls = cls[0..-2]
                            }
                            fields += &quot;${indent()}private List&amp;lt;${convert(cls,keyConverter)}&amp;gt; ${cls}s;\n&quot;
                            parseMap(obj, convert(cls, keyConverter), keyConverter)
                        }
                    }
                }
        }
        print getString(classTpl, [&quot;Namespace&quot;: namespace, &quot;fieldsContent&quot; : fields])
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Common.groovy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;package cc.lovesq.study.json

class Common {

    def static getType(v) {
        if (v instanceof String) {
            return &quot;String&quot;
        }
        if (v instanceof Integer) {
            return &quot;Integer&quot;
        }
        if (v instanceof Boolean) {
            return &quot;Boolean&quot;
        }
        if (v instanceof Long) {
            return &quot;Long&quot;
        }
        if (v instanceof BigDecimal) {
            return &quot;Double&quot;
        }

        &quot;String&quot;
    }

    def static getClsName(String str) {
        capitalize(str)
    }

    def static capitalize(String str) {
        str[0].toUpperCase() + (str.length() &amp;gt;= 2 ? str[1..-1] : &quot;&quot;)
    }

    def static uncapitalize(String str) {
        str[0].toLowerCase() + (str.length() &amp;gt;= 2 ? str[1..-1] : &quot;&quot;)
    }

    def static classTpl() {
        '''
public class $Namespace implements Serializable {
$fieldsContent
}

        '''
    }

    def static indent() {
        ' '
    }

    def static getString(tplText, binding) {
        def engine = new groovy.text.SimpleTemplateEngine()
        return engine.createTemplate(tplText).make(binding).toString()
    }

    def static convert(key, convertFunc) {
        convertFunc == null ? key : convertFunc(key)
    }

    def static underscoreToCamelCase(String underscore){
        String[] ss = underscore.split(&quot;_&quot;)
        if(ss.length ==1){
            return underscore
        }

        return ss[0] + ss.collect { capitalize(it) }.join(&quot;&quot;)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;构建与表示分离&quot;&gt;构建与表示分离&lt;/h2&gt;
&lt;p&gt;第一版的程序简单直接，但总感觉有点粗糙。整个处理混在一起，后续要修改恐怕比较困难。能不能更清晰一些呢 ？&lt;/p&gt;
&lt;p&gt;可以考虑将构建与表示分离开。&lt;/p&gt;
&lt;h3 id=&quot;表示&quot;&gt;表示&lt;/h3&gt;
&lt;p&gt;仔细再看下对象模型，可以归结出三个要素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个类有一个名字空间 namespace ；&lt;/li&gt;
&lt;li&gt;有一系列属性，每个属性有属性名与属性值，可称为 LeafNode；&lt;/li&gt;
&lt;li&gt;有一系列 子节点类 ClassNode，子节点类可以递归处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际上，对象模型符合树形结构。可以定义一个对象模型的表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;package cc.lovesq.study.json

import org.apache.commons.collections.CollectionUtils

import static cc.lovesq.study.json.Common.*

class ClassNode implements Node {

    String className = &quot;&quot;
    List&amp;lt;LeafNode&amp;gt; leafNodes = []
    List&amp;lt;ClassNode&amp;gt; classNodes = []
    Boolean isInList = false

    @Override
    String desc() {
        def clsTpl = Common.classTpl()

        def fields = &quot;&quot;
        fields += leafNodes.collect { indent() + it.desc() }.join(&quot;\n&quot;)
        def classDef = getString(clsTpl, [&quot;Namespace&quot;: className, &quot;fieldsContent&quot; : fields])
        if (CollectionUtils.isEmpty(classNodes)) {
            return classDef
        }

        fields += &quot;\n&quot; + classNodes.find { it.isInList == false }.collect { &quot;${indent()}private ${it.className} ${uncapitalize(it.className)}&quot; }.join(&quot;\n&quot;)
        def resultstr = getString(clsTpl, [&quot;Namespace&quot;: className, &quot;fieldsContent&quot; : fields])
        resultstr += classNodes.collect { it.desc() }.join(&quot;\n&quot;)
        return resultstr
    }

    boolean addNode(LeafNode node) {
        leafNodes.add(node)
        true
    }

    boolean addNode(ClassNode classNode) {
        classNodes.add(classNode)
        true
    }
}

class LeafNode implements Node {

    String type
    String name
    Boolean isList = false

    @Override
    String desc() {
        isList ? Common.getString(&quot;private List&amp;lt;$type&amp;gt; $name;&quot;, [&quot;type&quot;: type, &quot;name&quot;: name]) :
                Common.getString(&quot;private $type $name;&quot;, [&quot;type&quot;: type, &quot;name&quot;: name])
    }

}

interface Node {
   String desc()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Node 定义了一个描述自己的方法 desc ， LeafNode 和 ClassNode 分别实现自己的 desc 。这样，就完成了对象模型的表示。&lt;/p&gt;
&lt;p&gt;接下来，需要完成 ClassNode 的构建。这个过程与第一版的基本类似，只是从直接打印信息变成了添加节点。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;构建&quot;&gt;构建&lt;/h3&gt;
&lt;p&gt;构建 ClassNode 的实现如下。有几点值得提一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;策略模式。分离了三种情况（基本类型、Map, List）的处理。当有多重 if-else 语句，且每个分支都有大段代码达到同一个目标时，就可以考虑策略模式处理了。&lt;/li&gt;
&lt;li&gt;构建器。将 ClassNode 的构建单独分离到 ClassNodeBuilder 。&lt;/li&gt;
&lt;li&gt;组合模式。树形结构的处理，特别适合组合模式。&lt;/li&gt;
&lt;li&gt;命名构造。使用命名构造器，从而免写了一些构造器。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ClassNodeBuilder.groovy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;package cc.lovesq.study.json

import groovy.json.JsonSlurper

import static cc.lovesq.study.json.Common.*

class ClassNodeBuilder {

    def jsonSlurper = new JsonSlurper()

    def build(json) {
        def obj = jsonSlurper.parseText(json)
        Map map = (Map) obj
        return parseMap(map, 'Domain')
    }

    def static parseMap(Map map, String namespace) {
        ClassNode classNode = new ClassNode(className: namespace)
        map.each {
            k, v -&amp;gt;
                getStratgey(v).add(classNode, k, v)
        }
        classNode
    }

    def static plainStrategy = new AddLeafNodeStrategy()
    def static mapStrategy = new AddMapNodeStrategy()
    def static listStrategy = new AddListNodeStrategy()

    def static getStratgey(Object v) {
        if (v instanceof Map) {
            return mapStrategy
        }

        if (v instanceof List) {
            return listStrategy
        }
        return plainStrategy
    }

    interface AddNodeStrategy {
        def add(ClassNode classNode, k, v)
    }

    static class AddLeafNodeStrategy implements AddNodeStrategy {

        @Override
        def add(ClassNode classNode, Object k, Object v) {
            classNode.addNode(new LeafNode(type: getType(v), name: k))
        }
    }

    static class AddMapNodeStrategy implements AddNodeStrategy {

        @Override
        def add(ClassNode classNode, Object k, Object v) {
            v = (Map)v
            def className = getClsName(k)
            classNode.addNode(parseMap(v, className))
        }
    }

    static class AddListNodeStrategy implements AddNodeStrategy {

        @Override
        def add(ClassNode classNode, Object k, Object v) {
            v = (List)v
            def obj = v.get(0)
            if (!(obj instanceof Map) &amp;amp;&amp;amp; !(obj instanceof List)) {
                def type = getType(obj)
                classNode.addNode(new LeafNode(type: &quot;$type&quot;, name: &quot;${type}s&quot;, isList: true))
            }
            if (obj instanceof Map) {
                def cls = getClsName(k)
                if (cls.endsWith('s')) {
                    cls = cls[0..-2]
                }
                classNode.addNode(new LeafNode(type: &quot;${cls}&quot;, name: &quot;${cls}s&quot;, isList:  true))

                def subClassNode = parseMap(obj, cls)
                subClassNode.isInList = true
                classNode.addNode(subClassNode)
            }
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;通过编写程序，从 JSON 串中自动生成对应的对象模型，使得这个过程自动化，让类似事情的效率成倍的增长了。原来可能要花费几十分钟甚至一个小时之多，现在不到三秒。&lt;/p&gt;
&lt;p&gt;让效率成倍增长的有效之法就是提升代码和方案的复用性，自动化手工处理。在日常工作中，是否可以想到办法，让手头事情的处理效率能够十倍百倍的增长呢 ？ 这个想法看似有点疯狂，实际上，更多的原因是人们没有这么思考过吧。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 01 Apr 2020 23:50:00 +0000</pubDate>
<dc:creator>琴水玉</dc:creator>
<og:description>通过编写程序，从 JSON 串中自动生成对应的对象模型，使得这个过程自动化，让类似事情的效率成倍的增长了。让效率成倍增长的有效之法就是提升代码和方案的复用性，自动化手工处理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lovesqcc/p/12617323.html</dc:identifier>
</item>
<item>
<title>微服务交付至kubernetes流程 - jasonminghao</title>
<link>http://www.cnblogs.com/jasonminghao/p/12617313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jasonminghao/p/12617313.html</guid>
<description>&lt;p&gt;&lt;strong&gt;微服务优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务组件化&lt;br/&gt;每个服务独立开发、部署，有效避免一个服务的修改引起整个系统重新部署&lt;/li&gt;
&lt;li&gt;技术栈灵活&lt;br/&gt;约定通信方式，是得服务本身功能实现对技术要求不再那么铭感&lt;/li&gt;
&lt;li&gt;独立部署&lt;br/&gt;每个微服务独立部署，加快部署速度，方便扩展&lt;/li&gt;
&lt;li&gt;扩展性强&lt;br/&gt;每个微服务可以部署多个，并且有负载均衡能力&lt;/li&gt;
&lt;li&gt;独立数据&lt;br/&gt;每个微服务有独立的基本组件，例如数据库、缓存等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;微服务缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;沟通成本&lt;/li&gt;
&lt;li&gt;数据一致性&lt;/li&gt;
&lt;li&gt;运维成本&lt;/li&gt;
&lt;li&gt;内部架构复杂性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;微服务和单体应用&lt;/strong&gt;&lt;br/&gt;单体应用，易于部署、测试，但是会使得代码膨胀，难以维护，构建和部署成本大，新人上手难&lt;/p&gt;
&lt;p&gt;适用于微服务的框架：Spring Boots、Spring Cloud、Dubbo、Go-micro .....&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务架构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1679739/202004/1679739-20200402070638566-968510048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/view/5b179d12e4b06350d454c168?fromnew=1&quot;&gt;微服务流程图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务间如何通信？&lt;/strong&gt;&lt;br/&gt;REST API、RPC、MQ（后两者主流）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务如何发现彼此？&lt;/strong&gt;&lt;br/&gt;通过注册中心进行服务的注册与发现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件之间怎么个调用关系？&lt;/strong&gt;&lt;br/&gt;微服务内部处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那个服务作为整个网站入口？&lt;/strong&gt;&lt;br/&gt;网关，即gateway（也是单独的一个微服务）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那些微服务需要对外访问？&lt;/strong&gt;&lt;br/&gt;只需要网关gateway入口对外即可，&lt;br/&gt;一般都是先为gateway创建svc，然后由Ingress指定到该svc。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务怎么部署？更新？扩容？&lt;/strong&gt;&lt;br/&gt;基于Kubernetes就可以轻易实现，&lt;br/&gt;Kubernetes生来就是为了这些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何区分有状态应用和无状态应用？&lt;/strong&gt;&lt;br/&gt;无状态应用：不考虑存储，不维护有状态信息，也不考虑和其它服务副本是否有关系。&lt;br/&gt;有状态应用：有固定存储，维护集群状态信息，例如：mysql、mongodb，有状态应用不建议部署到kubernetes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要用注册中心？&lt;/strong&gt;&lt;br/&gt;微服务太多面临的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;怎么记录一个微服务多个副本接口地址？&lt;/li&gt;
&lt;li&gt;怎么实现一个微服务多个副本负载均衡？&lt;/li&gt;
&lt;li&gt;怎么判断一个微服务副本是否可用？&lt;br/&gt;主流注册中心：Eureka，Nacos，Etcd；&lt;br/&gt;注册中心可基于statefulset部署到k8s集群中，也可以部署在集群外。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不同环境如何区分配置文件？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;configmap：通过不同的环境去挂载不同的配置文件&lt;/li&gt;
&lt;li&gt;entrypoint.sh：通过启动脚本区分&lt;/li&gt;
&lt;li&gt;java -jar --spring.profiles.active=dev xxx.jar：基于启动命令区分&lt;/li&gt;
&lt;li&gt;统一配置中心，例如：Apollo，Disconf&lt;/li&gt;
&lt;/ul&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;制作镜像（应用程序、运行环境、文件系统）&lt;br/&gt;基础镜像：Debian 或 应用程序的运行环境镜像&lt;br/&gt;应用程序：Go，Java，Python ....&lt;br/&gt;运行环境：不同的语言都需要有特定的运行环境（例如java需要jdk）&lt;br/&gt;文件系统：忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;控制器管理Pod&lt;br/&gt;Deployment：无状态部署&lt;br/&gt;StatefulSet：有状态部署（MySQL、Mongodb、Redis ...）&lt;br/&gt;DaemonSet：守护进程部署&lt;br/&gt;Job &amp;amp; CronJob：批处理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;暴露应用&lt;br/&gt;Service定义了Pod的逻辑集合和访问这个集合的策略，&lt;br/&gt;Service引入为了解决Pod的动态变化，提供服务发现和负载均衡，&lt;br/&gt;支持Cluster IP，NodePort以及LocalBalancer三种类型，&lt;br/&gt;Service的底层实现主要实现有iptables和ipvs两种网络模式，推荐ipvs，&lt;br/&gt;使用CoreDNS解析Service名称，&lt;br/&gt;通过Label关联Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对外发布应用（ingress）&lt;br/&gt;通过Service关联Pod，&lt;br/&gt;基于域名访问，&lt;br/&gt;通过Ingress Controller实现Pod的负载均衡（支持TCP/UDP 4层和HTTP 7层）。&lt;br/&gt;最后在Ingress前面部署外网用户统一入口实现七层代理/四层转发（Nginx、HaProxy...）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;日志采集&lt;br/&gt;Pod在运行的时候会产生应用日志，需要将其日志文件信息采集到统一的数据库中存储，然后从一个平台中展示&lt;br/&gt;易给开发查阅日志信息和错误日志信息，易于排查问题&lt;br/&gt;主流方案：FileBeat + ELK（高性能和解耦：+kafka）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;监控&lt;br/&gt;不管是k8s集群Master还是Node，以及Pod，我们需要知道它们运行的具体状况，&lt;br/&gt;占用多少资源，剩余多少资源，就得通过监控的方式去实现。&lt;br/&gt;主流方案：Prometheus + Grafana + ...Export&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 01 Apr 2020 23:07:00 +0000</pubDate>
<dc:creator>jasonminghao</dc:creator>
<og:description>[TOC] 1、微服务简介 微服务优点 服务组件化 每个服务独立开发、部署，有效避免一个服务的修改引起整个系统重新部署 技术栈灵活 约定通信方式，是得服务本身功能实现对技术要求不再那么铭感 独立部署</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jasonminghao/p/12617313.html</dc:identifier>
</item>
<item>
<title>Redis系列(一)：小试牛刀 - 爱在846</title>
<link>http://www.cnblogs.com/aizai846/p/12617254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aizai846/p/12617254.html</guid>
<description>&lt;p&gt;随着互联网的高速发展，传统的关系数据库(如MySQL、Microsoft SQL Server等)已不能满足日益增长的业务需求，如商品秒杀、抢购等及时性非常强的功能，随着应用高并发的访问，会造成系统数据库崩溃，为了解决此种情况，需要引用一个缓存中间件，市面上比较常用的缓存中间件有Redis 和 Memcached，他们各自有自己的优缺点，但一般互联网公司大都采用MySQL + Redis的方式进行架构，本文主要介绍Redis的概念及安装配置。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;109.02444494281&quot;&gt;
&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;随着互联网的高速发展，传统的关系数据库(如MySQL、Microsoft SQL Server等)已不能满足日益增长的业务需求，如商品秒杀、抢购等及时性非常强的功能，随着应用高并发的访问，会造成系统数据库崩溃，为了解决此种情况，需要引用一个缓存中间件，市面上比较常用的缓存中间件有Redis 和 Memcached，他们各自有自己的优缺点，但一般互联网公司大都采用MySQL + Redis的方式进行架构，本文主要介绍Redis的概念及安装配置。&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;h4&gt;概念&lt;/h4&gt;
&lt;p&gt;Redis（Remote Dictionary Server ) 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库。&lt;/p&gt;
&lt;p&gt;传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 CAP 定理。&lt;/p&gt;
&lt;p&gt;它和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步，redis在3.0版本推出集群模式。&lt;/p&gt;
&lt;p&gt;Github 源码：&lt;a href=&quot;https://github.com/antirez/redis&quot; target=&quot;_blank&quot;&gt;https://github.com/antirez/redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 官网：&lt;a href=&quot;https://redis.io/&quot; target=&quot;_blank&quot;&gt;https://redis.io/&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;特点、优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;k、v键值存储以及数据结构存储（如列表、字典）&lt;/li&gt;
&lt;li&gt;所有数据(包括数据的存储)操作均在内存中完成&lt;/li&gt;
&lt;li&gt;单线程服务(这意味着会有较多的阻塞情况)，采用epoll模型进行请求响应，对比nginx&lt;/li&gt;
&lt;li&gt;支持主从复制模式，更提供高可用主从复制模式（哨兵）&lt;/li&gt;
&lt;li&gt;去中心化分布式集群&lt;/li&gt;
&lt;li&gt;丰富的编程接口支持，如Python、Golang、Java、php、Ruby、Lua、Node.js &lt;/li&gt;
&lt;li&gt;功能丰富，除了支持多种数据结构之外，还支持事务、发布/订阅、消息队列等功能&lt;/li&gt;
&lt;li&gt;支持数据持久化(AOF、RDB)&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;对比memcache&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;memcache是一个分布式的内存对象缓存系统，并不提供持久存储功能，而redis拥有持久化功能&lt;/li&gt;
&lt;li&gt;memcache数据存储基于LRU(简单说：最近、最少使用key会被剔除)，而redis则可以永久保存(服务一直运行情况下)&lt;/li&gt;
&lt;li&gt;memcache是多线程的（这是memcache优势之一），也就意味着阻塞情况少，而redis是单线程的，阻塞情况相对较多&lt;/li&gt;
&lt;li&gt;两者性能上相差不大&lt;/li&gt;
&lt;li&gt;memcache只支持简单的k、v数据存储，而redis支持多种数据格式存储。&lt;/li&gt;
&lt;li&gt;memcache是多线程、非阻塞IO复用网络模型，而redis是单线程IO复用模型&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;安装Windows版本&lt;/h3&gt;
&lt;p&gt;Redis的windoms版下载地址：&lt;a href=&quot;https://github.com/microsoftarchive/redis/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/microsoftarchive/redis/releases&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下载自己需要的版本，如下图（msi是安装版本，zip是解压版）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402004942684-1450554221.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载zip到本地解压（笔者解压目录为D:\Program Files\Redis），目录如下：&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402012950165-1225140418.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;298&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;开启服务，运行CMD，切换到解压目录，执行如下命令（并设置最大内存）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-server.exe redis.windows.conf --maxmemory 200M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402014252439-733529619.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启命令行客户端，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
redis-cli.exe
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加和查询Key-Value，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#设置键值
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; key value 
#获取键值
&lt;/span&gt;&lt;span&gt;get&lt;/span&gt; key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询和设置密码，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#查询密码
config &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; requirepass
#设置密码
config &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; requirepass 密码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入密码，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
auth 密码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上几个命令，演示如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402020729656-2112224048.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 注册和卸载服务，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#注册安装服务
redis&lt;/span&gt;-server --service-install redis.windows.conf --&lt;span&gt;loglevel verbose
#卸载服务
#redis&lt;/span&gt;-server --service-uninstall
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行效果，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402021641638-1836061991.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 注册完成后，可以在计算机服务中看到该服务，如下图所示。&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200402021823168-1792900783.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 开启服务后，可以直接用命令行客户端进行连接。&lt;/p&gt;
&lt;h3&gt; 总结&lt;/h3&gt;
&lt;p&gt;本文简单的介绍了Redis的背景、概念及Windows版本的安装及测试，在后续博文中，将继续讲解Redis的相关内容，如果本文对你有所帮助，就是我写作的动力！&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;4e19d-158&quot;&gt;感兴趣的朋友可以加关注，欢迎留言交流！ &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 01 Apr 2020 18:39:00 +0000</pubDate>
<dc:creator>爱在846</dc:creator>
<og:description>随着互联网的高速发展，传统的关系数据库(如MySQL、Microsoft SQL Server等)已不能满足日益增长的业务需求，如商品秒杀、抢购等及时性非常强的功能，随着应用高并发的访问，会造成系统数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aizai846/p/12617254.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Authentication and Authorization - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/auth-in-aspnetcore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/auth-in-aspnetcore.html</guid>
<description>&lt;p&gt;最近把一个Asp .net core 2.0的项目迁移到Asp .net core 3.1，项目启动的时候直接报错:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InvalidOperationException: Endpoint CoreAuthorization.Controllers.HomeController.Index (CoreAuthorization) contains authorization metadata, but a middleware was not found that supports authorization.
Configure your application startup by adding app.UseAuthorization() inside the call to Configure(..) in the application startup code. The call to app.UseAuthorization() must appear between app.UseRouting() and app.UseEndpoints(...).
Microsoft.AspNetCore.Routing.EndpointMiddleware.ThrowMissingAuthMiddlewareException(Endpoint endpoint)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看意思是缺少了一个authorization的中间件，这个项目在Asp.net core 2.0上是没问题的。&lt;br/&gt;startup是这样注册的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie(options =&amp;gt;
            {
                options.LoginPath = &quot;/account/Login&quot;;
            });
            
            services.AddControllersWithViews();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler(&quot;/Home/Error&quot;);
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            //app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthentication();

            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查了文档后发现3.0的示例代码多了一个UseAuthorization，改成这样就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; app.UseRouting();
 app.UseAuthentication();
 //use授权中间件
 app.UseAuthorization();

 app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看来Asp .net Core 3.1的认证跟授权又不太一样了，只能继续看文档学习了。&lt;/p&gt;
&lt;h2 id=&quot;useauthentication-and-useauthorization&quot;&gt;UseAuthentication and UseAuthorization&lt;/h2&gt;
&lt;p&gt;先说一下Authentication跟Authorization的区别。这两个单词长的十分相似，而且还经常一起出现，很多时候容易搞混了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Authentication是认证，明确是你谁，确认是不是合法用户。常用的认证方式有用户名密码认证。&lt;/li&gt;
&lt;li&gt;Authorization是授权，明确你是否有某个权限。当用户需要使用某个功能的时候，系统需要校验用户是否需要这个功能的权限。&lt;br/&gt;所以这两个单词是不同的概念，不同层次的东西。UseAuthorization在asp.net core 2.0中是没有的。在3.0之后微软明确的把授权功能提取到了Authorization中间件里，所以我们需要在UseAuthentication之后再次UseAuthorization。否则，当你使用授权功能比如使用[Authorize]属性的时候系统就会报错。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;authentication（认证）&quot;&gt;Authentication（认证）&lt;/h2&gt;
&lt;p&gt;认证的方案有很多，最常用的就是用户名密码认证，下面演示下基于用户名密码的认证。新建一个MVC项目，添加AccountController：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [HttpPost]
        public async Task&amp;lt;IActionResult&amp;gt; Login(
            [FromForm]string userName, [FromForm]string password
           )
        {
            //validate username password
            ...
            var claims = new List&amp;lt;Claim&amp;gt;
                {
                  new Claim(ClaimTypes.Name, userName),
                  new Claim(ClaimTypes.Role, &quot;老师&quot;)
                };

            var claimsIdentity = new ClaimsIdentity(
                claims, CookieAuthenticationDefaults.AuthenticationScheme);

            await HttpContext.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                new ClaimsPrincipal(claimsIdentity));

            return Redirect(&quot;/&quot;);
        }
         public async Task&amp;lt;IActionResult&amp;gt; Logoff()
        {
            await HttpContext.SignOutAsync();

            return Redirect(&quot;Login&quot;);
        }

        public IActionResult AccessDenied()
        {
            return Content(&quot;AccessDenied&quot;);
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改login.cshtml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Login Page&quot;;
}

    &amp;lt;h1&amp;gt;
        Login Page
    &amp;lt;/h1&amp;gt;

    &amp;lt;form method=&quot;post&quot;&amp;gt;
        &amp;lt;p&amp;gt;
            用户名: &amp;lt;input name=&quot;userName&quot; value=&quot;administrator&quot; /&amp;gt;
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;
            密码: &amp;lt;input name=&quot;password&quot; value=&quot;123&quot; /&amp;gt;
        &amp;lt;/p&amp;gt;
       
        &amp;lt;p&amp;gt;
            &amp;lt;button&amp;gt;登录&amp;lt;/button&amp;gt;
        &amp;lt;/p&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从前台传入用户名密码后进行用户名密码校验（示例代码省略了密码校验）。如果合法，则把用户的基本信息存到一个claim list里，并且指定cookie-base的认证存储方案。最后调用SignInAsync把认证信息写到cookie中。根据cookie的特性，接来下所有的http请求都会携带cookie，所以系统可以对接来下用户发起的所有请求进行认证校验。Claim有很多翻译，个人觉得叫“声明”比较好。一单认证成功，用户的认证信息里就会携带一串Claim，其实就是用户的一些信息，你可以存任何你觉得跟用户相关的东西，比如用户名，角色等，当然是常用的信息，不常用的信息建议在需要的时候查库。调用HttpContext.SignOutAsync()方法清除用户登认证信息。&lt;br/&gt;Claims信息我们可以方便的获取到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;
}

    &amp;lt;h2&amp;gt;
        CoreAuthorization
    &amp;lt;/h2&amp;gt;

&amp;lt;p&amp;gt;
    @Context.User.FindFirst(System.Security.Claims.ClaimTypes.Name)?.Value
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    角色:
    @foreach (var claims in Context.User.Claims.Where(c =&amp;gt; c.Type == System.Security.Claims.ClaimTypes.Role))
    {
        &amp;lt;span&amp;gt; @claims.Value &amp;lt;/span&amp;gt;
    }
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/Student/index&quot;&amp;gt;/Student/index&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/Teacher/index&quot;&amp;gt;/Teacher/Index&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/Teacher/Edit&quot;&amp;gt;/Student/Edit&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/Account/Logoff&quot;&amp;gt;退出&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改一下home/Index页面的html，把这些claim信息展示出来。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/01/G3c7uR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;以上就是一个基于用户名密码以及cookie的认证方案。&lt;/p&gt;
&lt;h2 id=&quot;authorization（授权）&quot;&gt;Authorization（授权）&lt;/h2&gt;
&lt;p&gt;有了认证我们还需要授权。刚才我们实现了用户名密码登录认证，但是系统还是没有任何管控，用户可以随意查库任意页面。现实中的系统往往都是某些页面可以随意查看，有些页面则需要认证授权后才可以访问。&lt;/p&gt;
&lt;h3 id=&quot;authorizeattribute&quot;&gt;AuthorizeAttribute&lt;/h3&gt;
&lt;p&gt;当我们希望一个页面只有认证后才可以访问，我们可以在相应的Controller或者Action上打上AuthorizeAttribute这个属性。修改HomeController：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Authorize]
    public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动网站，如果没有登录，访问home/index的时候网站会跳转到/account/AccessDenied。如果登录后则可以正常访问。AuthorizeAttribute默认授权校验其实是把认证跟授权合为一体了，只要认证过，就认为有授权，这是也是最最简单的授权模式。&lt;/p&gt;
&lt;h2 id=&quot;基于角色的授权策略&quot;&gt;基于角色的授权策略&lt;/h2&gt;
&lt;p&gt;显然上面默认的授权并不能满足我们开发系统的需要。AuthorizeAttribute还内置了基于Role（角色）的授权策略。&lt;br/&gt;登录的时候给认证信息加上角色的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [HttpPost]
        public async Task&amp;lt;IActionResult&amp;gt; Login(
            [FromForm]string userName, 
            [FromForm]string password
            )
        {
            //validate username password

            var claims = new List&amp;lt;Claim&amp;gt;
                {
                  new Claim(ClaimTypes.Name, userName),
                  new Claim(ClaimTypes.Role, &quot;老师&quot;),
                };

            var claimsIdentity = new ClaimsIdentity(
                claims, CookieAuthenticationDefaults.AuthenticationScheme);

            await HttpContext.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                new ClaimsPrincipal(claimsIdentity));

            return Redirect(&quot;/&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个TeacherController：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Authorize(Roles = &quot;老师&quot;)]
    public class TeacherController : Controller
    {
        public IActionResult Index()
        {
            return Content(&quot;Teacher index&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给AuthorizeAttribute的属性设置Roles=老师，表示只有老师角色的用户才可以访问。如果某个功能可以给多个角色访问那么可以给Roles设置多个角色，使用逗号进行分割。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [Authorize(Roles = &quot;老师,校长&quot;)]
    public class TeacherController : Controller
    {
        public IActionResult Index()
        {
            return Content(&quot;Teacher index&quot;);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样认证的用户只要具有老师或者校长其中一个角色就可以访问。&lt;/p&gt;
&lt;h2 id=&quot;基于策略的授权&quot;&gt;基于策略的授权&lt;/h2&gt;
&lt;p&gt;上面介绍了内置的基于角色的授权策略。如果现实中需要更复杂的授权方案，我们还可以自定义策略来支持。比如我们下面定义一个策略：编辑功能只能姓王的老师可以访问。&lt;br/&gt;定义一个要求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class LastNamRequirement : IAuthorizationRequirement
    {
        public string LastName { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IAuthorizationRequirement其实是一个空接口，仅仅用来标记，继承这个接口就是一个要求。这是空接口，所以要求的定义比较宽松，想怎么定义都可以，一般都是根据具体的需求设置一些属性。比如上面的需求，本质上是根据老师的姓来决定是否授权通过，所以把姓作为一个属性暴露出去，以便可以配置不同的姓。&lt;br/&gt;除了要求，我们还需要实现一个AuthorizationHandler：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class LastNameHandler : AuthorizationHandler&amp;lt;IAuthorizationRequirement&amp;gt;
    {
        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, IAuthorizationRequirement requirement)
        {
            var lastNameRequirement = requirement as LastNamRequirement;
            if (lastNameRequirement == null)
            {
                return Task.CompletedTask;
            }

            var isTeacher = context.User.HasClaim((c) =&amp;gt;
            {
                return c.Type == System.Security.Claims.ClaimTypes.Role &amp;amp;&amp;amp; c.Value == &quot;老师&quot;;
            });
            var isWang = context.User.HasClaim((c) =&amp;gt;
            {
                return c.Type == &quot;LastName&quot; &amp;amp;&amp;amp; c.Value == lastNameRequirement.LastName;
            });

            if (isTeacher &amp;amp;&amp;amp; isWang)
            {
                context.Succeed(requirement);
            }

            return Task.CompletedTask;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthorizationHandler是一个抽象类，继承它后需要重写其中的HandleRequirementAsync方法。这里才是真正判断是否授权成功的地方。要求（Requirement）跟用户的声明（Claim）信息会被传到这方法里，然后我们根据这些信息进行判断，如果符合授权就调用context.Succeed方法。这里注意&lt;strong&gt;如果不符合请谨慎调用context.Failed方法，因为策略之间一般是OR的关系，这个策略不通过，可能有其他策略通过&lt;/strong&gt;。&lt;br/&gt;在ConfigureServices方法中添加策略跟注册AuthorizationHandler到DI容器中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IAuthorizationHandler, LastNameHandler&amp;gt;();
services.AddAuthorization(options =&amp;gt;
     {
        options.AddPolicy(&quot;王老师&quot;, policy =&amp;gt;
            policy.AddRequirements(new LastNamRequirement { LastName = &quot;王&quot; })
        );
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用AddSingleton生命周期来注册LastNameHandler，这个生命周期并不一定要单例，看情况而定。在AddAuthorization中添加一个策略叫&quot;王老师&quot;。这里有个个人认为比较怪的地方，为什么AuthorizationHandler不是在AddAuthorization方法中配置？而是仅仅注册到容器中就可以开始工作了。如果有一个需求，仅仅是需要自己调用一下自定义的AuthorizationHandler，而并不想它真正参与授权。这样的话就不能使用DI的方式来获取实例了，因为一注册进去就会参与授权的校验了。&lt;br/&gt;在TeacherController下添加一个 Edit Action：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [Authorize(Policy=&quot;王老师&quot;)]
public IActionResult Edit()
{
    return Content(&quot;Edit success&quot;);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给AuthorizeAttribute的Policy设置为“王老师”。&lt;br/&gt;修改Login方法添加一个姓的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [HttpPost]
        public async Task&amp;lt;IActionResult&amp;gt; Login(
            [FromForm]string userName, 
            [FromForm]string password
            )
        {
            //validate username password

            var claims = new List&amp;lt;Claim&amp;gt;
                {
                  new Claim(ClaimTypes.Name, userName),
                  new Claim(ClaimTypes.Role, &quot;老师&quot;),
                   new Claim(&quot;LastName&quot;, &quot;王&quot;),
                };

            var claimsIdentity = new ClaimsIdentity(
                claims, CookieAuthenticationDefaults.AuthenticationScheme);

            await HttpContext.SignInAsync(
                CookieAuthenticationDefaults.AuthenticationScheme,
                new ClaimsPrincipal(claimsIdentity));

            return Redirect(&quot;/&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下程序，访问一下/teacher/edit，可以看到访问成功了。如果修改Login方法，修改LastName的声明为其他值，则访问会拒绝。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/01/G8HMB8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用泛型func方法配置策略&quot;&gt;使用泛型Func方法配置策略&lt;/h3&gt;
&lt;p&gt;如果你的策略比较简单，其实还有个更简单的方法来配置，就是在AddAuthorization方法内直接使用一个Func来配置策略。&lt;br/&gt;使用Func来配置一个女老师的策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; options.AddPolicy(&quot;女老师&quot;, policy =&amp;gt;
    policy.RequireAssertion((context) =&amp;gt;
        {
            var isTeacher = context.User.HasClaim((c) =&amp;gt;
            {
                return c.Type == System.Security.Claims.ClaimTypes.Role &amp;amp;&amp;amp; c.Value == &quot;老师&quot;;
            });
            var isFemale = context.User.HasClaim((c) =&amp;gt;
            {
                return c.Type == &quot;Sex&quot; &amp;amp;&amp;amp; c.Value == &quot;女&quot;;
            });

                return isTeacher &amp;amp;&amp;amp; isFemale;
        }
    )
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Authentication跟Authorization是两个不同的概念。Authentication是指认证，认证用户的身份；Authorization是授权，判断是否有某个功能的权限。&lt;/li&gt;
&lt;li&gt;Authorization内置了基于角色的授权策略。&lt;/li&gt;
&lt;li&gt;可以使用自定义AuthorizationHandler跟Func的方式来实现自定义策略。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;吐槽&quot;&gt;吐槽&lt;/h2&gt;
&lt;p&gt;关于认证跟授权微软为我们考虑了很多很多，包括identityserver，基本上能想到的都有了，什么oauth，openid，jwt等等。其实本人是不太喜欢用的。虽然微软都给你写好了，考虑很周到，但是学习跟Trouble shooting都是要成本的。其实使用中间件、过滤器再配合redis等组件，很容易自己实现一套授权认证方案，自由度也更高，有问题修起来也更快。自己实现一下也可以更深入的了解某项的技术，比如jwt是如果工作的，oauth是如何工作的，这样其实更有意义。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Apr 2020 16:44:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>最近把一个Asp .net core 2.0的项目迁移到Asp .net core 3.1，项目启动的时候直接报错: 看意思是缺少了一个authorization的中间件，这个项目在Asp.net c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/auth-in-aspnetcore.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的故宫人流量动态监控系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12616772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12616772.html</guid>
<description>&lt;p&gt;在当代社会，故宫已经成为一个具有多元意义的文化符号，在历史、艺术、文化等不同领域发挥着重要的作用，在国际上也成为能够代表中国文化甚至中国形象的国际符号。近几年故宫的观众接待量逐年递增，年接待量已突破千万，根据故宫的文物特点与开放模式，必须及时建立一套完整的集监控与防患应急于一体的现代化监控系统。&lt;/p&gt;
&lt;p&gt;故宫人流量动态监控系统采用 Hightopo 的  &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt;  产品来构造 故宫 3D 动态可视化场景，通过将现场部署的传感器、监控设备等装置与智能联网设备集成到互联网上，对故宫当前的人流状态、人流拥挤度进行实时监测，并生成人流量热力图直观的展示现场人流数据，以预防拥挤、踩踏等意外事故的发生。&lt;/p&gt;
&lt;p&gt;预览地址：&lt;a href=&quot;https://hightopo.com/demo/TheForbiddenCity/&quot; target=&quot;_blank&quot;&gt;故宫人流量动态监控系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整体预览图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327093342037-1377090739.png&quot; alt=&quot;&quot; width=&quot;996&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全景图预览：&lt;/p&gt;



&lt;h2&gt;创建场景&lt;/h2&gt;
&lt;p&gt;项目目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205090747714-1847803997.png&quot; alt=&quot;&quot; width=&quot;146&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt; index.js 是 src 下的入口文件，创建了一个 由 main.js 中导出的 Main 类，Main 类中创建 3D 组件和 2D 组件，利用 g2d.deserialize() 方法将 json 矢量背景图反序列化显示在 2D 组件上并利用 this.load() 方法进行 3D 场景的加载工作，在 Main 类中使用了 HT 自带的事件派发器，this.event.fire() 和 this.event.add() 分别是派发事件和订阅事件，在本示例中通过事件订阅与派发完成3D场景的切换效果，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import util &lt;span data-mce-=&quot;&quot;&gt;from &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;../util/util&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;;
import forbiddenCity &lt;span data-mce-=&quot;&quot;&gt;from &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;./forbiddenCity.js&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;
import heatMap &lt;span data-mce-=&quot;&quot;&gt;from &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;./heatMap.js&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;
import loadScene &lt;span data-mce-=&quot;&quot;&gt;from &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;./loadScene.js&lt;span data-mce-=&quot;&quot;&gt;'
&lt;span data-mce-=&quot;&quot;&gt;class&lt;span data-mce-=&quot;&quot;&gt; Main {
    constructor() {
        let g3d = (&lt;span data-mce-=&quot;&quot;&gt;this.g3d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph3d.Graph3dView());
        &lt;span data-mce-=&quot;&quot;&gt;this.g3dDm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d.dm();
        let g2d = (&lt;span data-mce-=&quot;&quot;&gt;this.g2d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph.GraphView());
        &lt;span data-mce-=&quot;&quot;&gt;this.g2dDm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g2d.dm();
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;将 3D 组件加入到 body 下
&lt;span data-mce-=&quot;&quot;&gt;        g3d.addToDOM();
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 2D 组件加入到 3D 组件的根 div 下，父子 DOM 事件会冒泡，这样不会影响 3D 场景的交互
&lt;span data-mce-=&quot;&quot;&gt;        g2d.addToDOM(g3d.getView());
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 初始化场景
        &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.init();
    }
    init() {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 2D面板加载
        &lt;span data-mce-=&quot;&quot;&gt;this.g2d.deserialize(&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;displays/htproject_2019_q4/故宫/首页.json&lt;span data-mce-=&quot;&quot;&gt;', (json, dm, g2d, datas) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {&lt;br/&gt;　　　　　　　
        });
        &lt;span data-mce-=&quot;&quot;&gt;this.forbiddenCity = &lt;span data-mce-=&quot;&quot;&gt;new forbiddenCity(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;this.heatMap = &lt;span data-mce-=&quot;&quot;&gt;new heatMap(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 首页3D场景加载
        &lt;span data-mce-=&quot;&quot;&gt;this.load(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.forbiddenCity);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 订阅事件
        &lt;span data-mce-=&quot;&quot;&gt;this.addListener(e =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;if (e.type === &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;loadforbiddenCity&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;) {
                &lt;span data-mce-=&quot;&quot;&gt;this.load(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.forbiddenCity);
            } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (e.type === &lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;loadheatMap&lt;span data-mce-=&quot;&quot;&gt;'&lt;span data-mce-=&quot;&quot;&gt;) {
                &lt;span data-mce-=&quot;&quot;&gt;this.load(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.heatMap);
            }
        });
    }
    load(scene) {
        let old = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.activeScene;
        &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (old) {
            old.tearDown();
        }
        &lt;span data-mce-=&quot;&quot;&gt;this.activeScene =&lt;span data-mce-=&quot;&quot;&gt; scene;
        scene.setUp();
    }
    fire(e) {
        &lt;span data-mce-=&quot;&quot;&gt;this.&lt;span data-mce-=&quot;&quot;&gt;event&lt;span data-mce-=&quot;&quot;&gt;.fire(e);
    }
    addListener(cb, scope) {
        &lt;span data-mce-=&quot;&quot;&gt;this.&lt;span data-mce-=&quot;&quot;&gt;event&lt;span data-mce-=&quot;&quot;&gt;.add(cb, scope);
    }
    
}
export &lt;span data-mce-=&quot;&quot;&gt;default Main;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由上可以看出在 Main 类中我们通过订阅事件提供了场景切换的代码，即通过调用两个场景文件中的 setUp() 方法来完成 3D 场景的切换让我们来看下在 forbiddenCity.js 与 heatMap.js 中是如何进行场景切换的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;setUp() {
    let g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;,
        dm3d =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm();
    super.setUp();
    util.setSceneLevel('forbiddenCity'&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 清空数据容器
&lt;span data-mce-=&quot;&quot;&gt;    dm3d.clear();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 反序列化 3D 图纸
    g3d.deserialize('scenes/htdesign/city/故宫/故宫.json', (json, dm, g3d, datas) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {

    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;setUp() {
    let g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;,
        dm3d =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm();
    super.setUp();
    util.setSceneLevel('heatMap'&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 清空数据容器
&lt;span data-mce-=&quot;&quot;&gt;    dm3d.clear();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 反序列化 3D 图纸
    g3d.deserialize('scenes/htdesign/city/故宫/热力图.json', (json, dm, g3d, datas) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {

    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上代码可以看出我们在每次切换场景时都会调用数据容器的 clear() 方法来清空数据然后再调用 g3d.deserialize() 方法反序列化加载新场景图纸，从而完成新旧场景的加载和清空。&lt;/p&gt;
&lt;h2&gt;投影实现&lt;/h2&gt;
&lt;p&gt;为增强 3D 场景的立体感，在最新版本的 HT 核心包中新增了场景投影效果配置函数，用户通过调用 enableShadow() 和 disableShadow() 方法可以实现开启关闭 3D 投影效果，此外还可以通过设置 node.s('shadow.cast', false) 对部分不需要投影的模型进行投影关闭处理，投影关键代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import util from '../util/util'&lt;span data-mce-=&quot;&quot;&gt;;
const loadScene =&lt;span data-mce-=&quot;&quot;&gt; {
    shadow(g3d) {
        &lt;span data-mce-=&quot;&quot;&gt;var ssc = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(filter) {
            &lt;span data-mce-=&quot;&quot;&gt;var nodes =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm().toDatas(filter);
            &lt;span data-mce-=&quot;&quot;&gt;if (!&lt;span data-mce-=&quot;&quot;&gt;nodes.length) {
                &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
            };
            nodes.each(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(node) {
                node.s('shadow.cast', &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
            });
        }
        &lt;span data-mce-=&quot;&quot;&gt;var nameFilter = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(name) {
            &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(node) {
                &lt;span data-mce-=&quot;&quot;&gt;return node.getDisplayName() ===&lt;span data-mce-=&quot;&quot;&gt; name;
            }
        }
        &lt;span data-mce-=&quot;&quot;&gt;var typeFilter = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(type) {
            &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(node) {
                &lt;span data-mce-=&quot;&quot;&gt;return node.s('shape3d') ===&lt;span data-mce-=&quot;&quot;&gt; type;
            }
        }
        ssc(nameFilter('路线'&lt;span data-mce-=&quot;&quot;&gt;));
        ssc(nameFilter('布景'&lt;span data-mce-=&quot;&quot;&gt;));
        ssc(nameFilter('灯光'&lt;span data-mce-=&quot;&quot;&gt;));
        ssc(typeFilter('models/医疗/阴影_1.json'&lt;span data-mce-=&quot;&quot;&gt;));
        ssc(typeFilter('models/医疗/地面.json'&lt;span data-mce-=&quot;&quot;&gt;));
        ssc(typeFilter('models/htdesign/Identification/point/riangle_01.json'&lt;span data-mce-=&quot;&quot;&gt;))
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 为了编组用的 box
        ssc(typeFilter('box'&lt;span data-mce-=&quot;&quot;&gt;));
        &lt;span data-mce-=&quot;&quot;&gt;if (util.getSceneLevel() === 'forbiddenCity'&lt;span data-mce-=&quot;&quot;&gt;) {
            g3d.enableShadow({
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 投影 x 轴角度
                degreeX: 55&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 投影 z 轴角度
                degreeZ: -35&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; low / medium / high / ultra / 4096数值
                quality: 4096&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 深度浮点偏差补足
                bias: -0.0003&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; none / hard / soft
                type: 'soft'&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; type 为 hard / soft 时，补充的边缘厚度，用来提供更柔和的边缘
                radius: 1.0&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 阴影强度， 1 为黑色
                intensity: 0.45&lt;span data-mce-=&quot;&quot;&gt;
            });
            g3d.iv();
        }

    }
}
export &lt;span data-mce-=&quot;&quot;&gt;default loadScene&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;动画实现&lt;/h2&gt;
&lt;h3&gt;飞鸟动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327101257050-381718819.gif&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;飞鸟动画可以拆分为两个步骤：1.飞鸟沿固定路线环绕故宫的飞行动作以及上下位置变化动作，2.飞鸟自身的翅膀扇动动作。我们使用 HT 自带的 ht.Default.startAnim 函数让飞鸟模型沿着三维空间管道做周期运动，在动画中定义了一个变量 count 每次动画都递增，通过 Math.cos(count % 36 * 10 * Math.PI / 180) 函数使值在 1 和 -1 之间做周期变化，配合 setRotationZ() 方法改变翅膀在 3D 拓扑中沿 z 轴的旋转角度从而达到飞鸟翅膀上下扇动，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 飞鸟动画
&lt;span data-mce-=&quot;&quot;&gt;flyerAnim(g3d) {
    const dm3d =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm();
    let polyline = dm3d.getDataByTag('polyline'&lt;span data-mce-=&quot;&quot;&gt;);
    let flyers = dm3d.getDataByTag('flyers'&lt;span data-mce-=&quot;&quot;&gt;);
    let count = 0&lt;span data-mce-=&quot;&quot;&gt;;
    let radomArr = [&lt;span data-mce-=&quot;&quot;&gt;this.random(20, 80&lt;span data-mce-=&quot;&quot;&gt;),
        &lt;span data-mce-=&quot;&quot;&gt;this.random(30, 100&lt;span data-mce-=&quot;&quot;&gt;),
        &lt;span data-mce-=&quot;&quot;&gt;this.random(10, 60&lt;span data-mce-=&quot;&quot;&gt;),
        &lt;span data-mce-=&quot;&quot;&gt;this.random(10, 50&lt;span data-mce-=&quot;&quot;&gt;),
        &lt;span data-mce-=&quot;&quot;&gt;this.random(5, 20&lt;span data-mce-=&quot;&quot;&gt;),
        &lt;span data-mce-=&quot;&quot;&gt;this.random(20, 70&lt;span data-mce-=&quot;&quot;&gt;)
    ];
    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (polyline) {

        let anim =&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画周期毫秒数
            duration: 40000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(t) {
                &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; t;
            },
            action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;if (util.getSceneLevel() !== 'heatMap' &amp;amp;&amp;amp;&lt;span data-mce-=&quot;&quot;&gt; polyline) {
                    let length =&lt;span data-mce-=&quot;&quot;&gt; g3d.getLineLength(polyline);
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取三维空间管道坐标
                    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (length) {
                        let offset = g3d.getLineOffset(polyline, length *&lt;span data-mce-=&quot;&quot;&gt; v),
                            point =&lt;span data-mce-=&quot;&quot;&gt; offset.point,
                            tangent =&lt;span data-mce-=&quot;&quot;&gt; offset.tangent,
                            px =&lt;span data-mce-=&quot;&quot;&gt; point.x,
                            py =&lt;span data-mce-=&quot;&quot;&gt; point.y,
                            pz =&lt;span data-mce-=&quot;&quot;&gt; point.z,
                            tx =&lt;span data-mce-=&quot;&quot;&gt; tangent.x,
                            ty =&lt;span data-mce-=&quot;&quot;&gt; tangent.y,
                            tz =&lt;span data-mce-=&quot;&quot;&gt; tangent.z;
                        flyers.eachChild((bird, index) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                            let ty = bird.getTag().split('_')[1&lt;span data-mce-=&quot;&quot;&gt;];
                            let positionZ = pz + index * 50 + radomArr[index] / 3&lt;span data-mce-=&quot;&quot;&gt;,
                                positionX = px + (index - 3) * 50 + radomArr[index] / 3&lt;span data-mce-=&quot;&quot;&gt;,
                                positionY = py + radomArr[index] / 5&lt;span data-mce-=&quot;&quot;&gt;;
                            &lt;span data-mce-=&quot;&quot;&gt;if (index &amp;gt; 2) positionZ = pz - (index - 6) * 50 + radomArr[index] / 3&lt;span data-mce-=&quot;&quot;&gt;;
                            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置飞鸟翅膀扇动动画
                            const pos = count +&lt;span data-mce-=&quot;&quot;&gt; index,
                                pos2 = count - index * 6&lt;span data-mce-=&quot;&quot;&gt;;
                            &lt;span data-mce-=&quot;&quot;&gt;if (pos2 &amp;gt; 0&lt;span data-mce-=&quot;&quot;&gt;) {
                                &lt;span data-mce-=&quot;&quot;&gt;if (!bird._posId) bird._posId =&lt;span data-mce-=&quot;&quot;&gt; pos2;
                                bird._posId++&lt;span data-mce-=&quot;&quot;&gt;;
                                &lt;span data-mce-=&quot;&quot;&gt;if (bird._posId &amp;gt; index * 100 + 500 &amp;amp;&amp;amp; bird._posId &amp;lt; index * 100 + 600&lt;span data-mce-=&quot;&quot;&gt;) {
                                    bird.eachChild((child) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                                        &lt;span data-mce-=&quot;&quot;&gt;if (child.getTag() === 'wingLeft'&lt;span data-mce-=&quot;&quot;&gt;) {
                                            child.setRotationZ(0&lt;span data-mce-=&quot;&quot;&gt;);
                                        } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (child.getTag() === 'wingRight'&lt;span data-mce-=&quot;&quot;&gt;) {
                                            child.setRotationZ(0&lt;span data-mce-=&quot;&quot;&gt;);
                                        }
                                    });
                                    &lt;span data-mce-=&quot;&quot;&gt;if (bird._posId === index * 100 + 599) bird._posId = 1&lt;span data-mce-=&quot;&quot;&gt;;
                                } &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
                                    bird.eachChild((child) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                                        &lt;span data-mce-=&quot;&quot;&gt;if (child.getTag() === 'wingLeft'&lt;span data-mce-=&quot;&quot;&gt;) {
                                            child.setRotationZ(child.r3()[2] + Math.cos(bird._posId % 36 * 10 * Math.PI / 180) * 4 * 0.03&lt;span data-mce-=&quot;&quot;&gt;);
                                        } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (child.getTag() === 'wingRight'&lt;span data-mce-=&quot;&quot;&gt;) {
                                            child.setRotationZ(child.r3()[2] - Math.cos(bird._posId % 36 * 10 * Math.PI / 180) * 4 * 0.03&lt;span data-mce-=&quot;&quot;&gt;);
                                        }
                                    });
                                }
                            }
                            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置飞鸟飞行轨道动画
                            bird.p3(positionX + radomArr[index] * v, positionY + radomArr[index] * v + Math.cos(count % 36 * 10 *&lt;span data-mce-=&quot;&quot;&gt; Math
                                    .PI / 180) * ty * 5, positionZ + radomArr[index] *&lt;span data-mce-=&quot;&quot;&gt;
                                v);
                            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置飞鸟朝向位置
                            bird.lookAt([positionX + radomArr[index] * v + tx, positionY + ty + radomArr[index] * v, positionZ +&lt;span data-mce-=&quot;&quot;&gt;
                                radomArr[index] * v +&lt;span data-mce-=&quot;&quot;&gt; tz
                            ]);
                        })
                        count++&lt;span data-mce-=&quot;&quot;&gt;;
                    }

                }
            },
            finishFunc: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 继续执行飞鸟管道动画
                &lt;span data-mce-=&quot;&quot;&gt;this.birdAnim =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim(anim);
            }
        };
        &lt;span data-mce-=&quot;&quot;&gt;if (util.getSceneLevel() === 'forbiddenCity'&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 执行飞鸟管道动画
            &lt;span data-mce-=&quot;&quot;&gt;this.birdAnim =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim(anim);
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;鸟瞰漫游动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327101111295-551760976.gif&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在飞鸟动画实现的前提下，接下来我们可以进一步以飞鸟模型为中心来生成鸟瞰漫游动画。首先使用 ht.Default.startAnim 函数实时调用飞鸟所在位置，通过 setEye() 和 setCenter() 方法动态设置场景的中心点和相机位置，以此达到从飞鸟的视角俯瞰整个故宫场景的动画效果。关键代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 鸟瞰漫游动画
&lt;span data-mce-=&quot;&quot;&gt;roamingAnim() {
    const g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d;
    let flyers = g3d.dm().getDataByTag('flyers'&lt;span data-mce-=&quot;&quot;&gt;);
    let anim =&lt;span data-mce-=&quot;&quot;&gt; {
        duration: 60000, &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画周期毫秒数
        easing: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (t) {
            &lt;span data-mce-=&quot;&quot;&gt;return t *&lt;span data-mce-=&quot;&quot;&gt; t;
        },
        action: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (v, t) {
            let flyersP =&lt;span data-mce-=&quot;&quot;&gt; flyers.p3();
            let px = flyersP[0&lt;span data-mce-=&quot;&quot;&gt;];
            let py = flyersP[1&lt;span data-mce-=&quot;&quot;&gt;];
            let pz = flyersP[2&lt;span data-mce-=&quot;&quot;&gt;];
            g3d.setEye(px, py + 50, pz - 400&lt;span data-mce-=&quot;&quot;&gt;);
            g3d.setCenter(px, py, pz);
        }
    }
    &lt;span data-mce-=&quot;&quot;&gt;this.roaming =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim(anim);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;景深动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327101822959-1267168536.gif&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt; 中为 3D 组件提供了 enablePostProcessing() 方法，使用者可以通过调用该方法手动开启 3D 场景的景深模糊效果，另外还可以通过设置 aperture 属性改变景深模糊度，在本示例中通过动态改变 aperture 属性形成淡入淡出效果以减少场景切换时的突兀感，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 景深动画
depthAnim(g3d, x = 0&lt;span data-mce-=&quot;&quot;&gt;) {
    let dof = g3d.getPostProcessingModule('Dof'&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 景深开启
    g3d.enablePostProcessing('Dof', &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;new Promise((resolve, reject) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        let anim =&lt;span data-mce-=&quot;&quot;&gt; {
            duration: 1000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: (t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;return t *&lt;span data-mce-=&quot;&quot;&gt; t;
            },
            action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动态设置景深阈值
                dof.aperture = x - v * 0.02
                &lt;span data-mce-=&quot;&quot;&gt;if (v == 1) resolve('end'&lt;span data-mce-=&quot;&quot;&gt;);
            }
        }
        ht.Default.startAnim(anim);
    })
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 主要功能&lt;/h2&gt;
&lt;h3&gt;人流量热力图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327103129197-965774007.gif&quot; alt=&quot;&quot; width=&quot;896&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;

&lt;p&gt;热力图以特殊高亮的形式显示游客所在的地理区域的图示，可以非常直观的展示人流量密度信息。本示例中使用 HT 封装的 ht.thermodynamic.Thermodynamic3d() 方法动态生成热力图，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;createHeatMap(heatMapName, num) {
    const g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d;
    const dm3d =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm();
    let room =&lt;span data-mce-=&quot;&quot;&gt; dm3d.getDataByTag(heatMapName);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取要生成热力图的矩形区域
    let heatRect =&lt;span data-mce-=&quot;&quot;&gt; room.getRect();
    let Vector3 =&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3;
    let tall = 30&lt;span data-mce-=&quot;&quot;&gt;
    let {
        x,
        y,
        width,
        height
    } =&lt;span data-mce-=&quot;&quot;&gt; heatRect;
    &lt;span data-mce-=&quot;&quot;&gt;if (width === 0 || height === 0) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;
    let templateList =&lt;span data-mce-=&quot;&quot;&gt; [];
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 在热力图区域随机生成 num 个热力点位
    &lt;span data-mce-=&quot;&quot;&gt;for (let index = 0; index &amp;lt; num; index++&lt;span data-mce-=&quot;&quot;&gt;) {
        templateList.push({
            position: {
                x: &lt;span data-mce-=&quot;&quot;&gt;this.random(0&lt;span data-mce-=&quot;&quot;&gt;, heatRect.width),
                y: &lt;span data-mce-=&quot;&quot;&gt;this.random(0&lt;span data-mce-=&quot;&quot;&gt;, heatRect.height),
                z: tall
            },
            temperature: {
                value: 30 + &lt;span data-mce-=&quot;&quot;&gt;this.random(0, 20&lt;span data-mce-=&quot;&quot;&gt;),
                radius: 90&lt;span data-mce-=&quot;&quot;&gt;
            },
        })
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 热力图初始化
    let thd = window.thd = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.thermodynamic.Thermodynamic3d(g3d, {
        box: &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; Vector3(width, height, tall),
        min: 15&lt;span data-mce-=&quot;&quot;&gt;,
        max: 55&lt;span data-mce-=&quot;&quot;&gt;,
        interval: 200&lt;span data-mce-=&quot;&quot;&gt;,
        remainMax: &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        opacity: 0.1&lt;span data-mce-=&quot;&quot;&gt;,
        colorStopFn: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (v, step) {
            &lt;span data-mce-=&quot;&quot;&gt;return v * step *&lt;span data-mce-=&quot;&quot;&gt; step
        },
        gradient: {
            0: 'rgba(0,162,255,0.14)'&lt;span data-mce-=&quot;&quot;&gt;,
            0.2: 'rgba(48,255,183,0.3)'&lt;span data-mce-=&quot;&quot;&gt;,
            0.4: 'rgba(255,245,48,0.5)'&lt;span data-mce-=&quot;&quot;&gt;,
            0.6: 'rgba(255,73,18,0.9)'&lt;span data-mce-=&quot;&quot;&gt;,
            0.8: 'rgba(217,22,0,0.95)'&lt;span data-mce-=&quot;&quot;&gt;,
            1: 'rgb(179,0,0)'&lt;span data-mce-=&quot;&quot;&gt;,
        }
    });
    thd.setData(templateList);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 创建热力图
    let node = thd.createThermodynamicNode(2, 2, 50&lt;span data-mce-=&quot;&quot;&gt;);
    node.setAnchorElevation(0&lt;span data-mce-=&quot;&quot;&gt;);
    node.setTag('test'&lt;span data-mce-=&quot;&quot;&gt;);
    node.p3(room.p3());
    node.s({
        '3d.selectable': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        '3d.movable': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        'wf.visible': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        'shape3d.transparent': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    });
    dm3d.add(node);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 这里简单的描述下热力图生成步骤：1.首先确定热力图生成区域，在该区域内获取传感器位置和热力信息，并将这些信息存储在 templateList 数组中。2.将数组传入 Thermodynamic3d() 方法中并配置渐变颜色、透明度等相关信息生成热力图渲染数据。3.使用 createThermodynamicNode() 方法按照热力图渲染数据创建热力图。4.将热力图添加到数据容器中。&lt;/p&gt;
&lt;h3&gt;视频监控&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202003/1496396-20200327103740266-780226095.gif&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过 addInteractorListener 交互监听器为场景中摄像头模型绑定点击事件，每个摄像头都对应一个监控视频画面，通过点击弹出或关闭，并对窗口中显示的监控画面数量进行了限制，不得超过 4 个否则将不会继续弹出监控画面，避免显示多个画面造成场景遮挡，关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;videoVisible(videoName) {
    let g2d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g2d,
        dm2d =&lt;span data-mce-=&quot;&quot;&gt; g2d.dm();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 当前选中监控画面
    const video =&lt;span data-mce-=&quot;&quot;&gt; dm2d.getDataByTag(videoName);
    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (video) {
        const videoList =&lt;span data-mce-=&quot;&quot;&gt; video.getParent();
        const videoRect =&lt;span data-mce-=&quot;&quot;&gt; video.getRect();
        const visible =&lt;span data-mce-=&quot;&quot;&gt; g2d.isVisible(video);
        &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (visible) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 隐藏选中监控画面，并重新排列监控画面
            &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.hideVideo(videoList, video, videoRect);
        } &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 显示选中监控画面，并重新排列监控画面
&lt;span data-mce-=&quot;&quot;&gt;
            let showVideos =&lt;span data-mce-=&quot;&quot;&gt; [];
            videoList.eachChild(child =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                g2d.isVisible(child) &amp;amp;&amp;amp; child !== video &amp;amp;&amp;amp;&lt;span data-mce-=&quot;&quot;&gt; showVideos.push(child)
            })
            &lt;span data-mce-=&quot;&quot;&gt;if (showVideos.length &amp;lt; 5&lt;span data-mce-=&quot;&quot;&gt;) {
                video.s('2d.visible', &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
                video.setY(util.getVideoListRect().y + (videoRect.height + 5) *&lt;span data-mce-=&quot;&quot;&gt; showVideos.length);
            }
        }
    }
}

hideVideo(parent, video, videoRect) {
    parent.eachChild(node =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        const nodeRect =&lt;span data-mce-=&quot;&quot;&gt; node.getRect();
        &lt;span data-mce-=&quot;&quot;&gt;if (nodeRect.y &amp;gt;&lt;span data-mce-=&quot;&quot;&gt; videoRect.y) {
            node.setY(nodeRect.y -&lt;span data-mce-=&quot;&quot;&gt; nodeRect.height)
        }
    })
    video.s('2d.visible', &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;)
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt; 现如今，伴随国民经济的持续高速增长，旅游行业迎来了健康发展的阶段，各大景区每年接待的游客人数都在不断增长，如果不对人流量进行控制的话将会出现许多隐患。本次示例效果均采用 HT 提供的 api 进行代码开发，旨在定制一套以人流量监测为中心的集监控与防患应急于一体的景点 3D 实时监控系统，也欢迎对 HT 感兴趣的伙伴给我留言，或者直接访问 &lt;a href=&quot;https://hightopo.com/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt; 查询相关的资料。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Apr 2020 16:02:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在当代社会，故宫已经成为一个具有多元意义的文化符号，在历史、艺术、文化等不同领域发挥着重要的作用，在国际上也成为能够代表中国文化甚至中国形象的国际符号。近几年故宫的观众接待量逐年递增，年接待量已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12616772.html</dc:identifier>
</item>
</channel>
</rss>