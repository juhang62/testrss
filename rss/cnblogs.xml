<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式之迭代器模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/iterator-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/iterator-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;迭代器模式，提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。&lt;/p&gt;
&lt;p&gt;迭代器模式是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式。&lt;/p&gt;
&lt;p&gt;当你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;如果要自己实现需要有下面几个类：&lt;/p&gt;
&lt;p&gt;一个迭代器抽象类（或接口）&lt;/p&gt;
&lt;p&gt;一个聚集抽象类（或接口）&lt;/p&gt;
&lt;p&gt;具体实现的迭代器类&lt;/p&gt;
&lt;p&gt;具体实现的聚集类&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public abstract class Iterator
{
    public abstract object First();

    public abstract object Next();

    public abstract bool IsDone();

    public abstract object CurrentItem();
}

public class ConcreteIterator : Iterator
{
    private readonly ConcreteAggregate _aggregate;
    private int _current = 0;

    public ConcreteIterator(ConcreteAggregate aggregate) =&amp;gt; _aggregate = aggregate;

    public override object First()
    {
        return _aggregate[0];
    }

    public override object Next()
    {
        _current++;
        return _current &amp;gt;= _aggregate.TotalCount ? null : _aggregate[_current];
    }

    public override bool IsDone() =&amp;gt; _current &amp;gt;= _aggregate.TotalCount;

    public override object CurrentItem() =&amp;gt; _aggregate[_current];
}

public abstract class Aggregate
{
    /// &amp;lt;summary&amp;gt;
    /// 创建迭代器
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public abstract Iterator CreateIterator();
}

public class ConcreteAggregate : Aggregate
{
    private readonly IList&amp;lt;object&amp;gt; _items = new List&amp;lt;object&amp;gt;();

    public override Iterator CreateIterator()
    {
        return new ConcreteIterator(this);
    }

    public int TotalCount =&amp;gt; _items.Count;

    public object this[int index]
    {
        get =&amp;gt; _items[index];
        set =&amp;gt; _items.Insert(index, value);
    }
}


var aggregate = new ConcreteAggregate
{
    [0] = &quot;大鸟&quot;,
    [1] = &quot;小菜&quot;,
    [2] = &quot;行李&quot;,
    [3] = &quot;老外&quot;,
    [4] = &quot;公交员工&quot;,
    [5] = &quot;小偷&quot;
};

Iterator iterator = new ConcreteIterator(aggregate);
do
{
    Console.WriteLine($&quot;{iterator.CurrentItem()} 请买车票&quot;);
    iterator.Next();
} while (!iterator.IsDone());

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;需要注意的是，使用迭代器模式遍历集合时，不要对集合进行增加元素或者删除元素操作&lt;/p&gt;
&lt;p&gt;在 C# 中实现 &lt;code&gt;IEnumerable&lt;/code&gt; 接口就可以比较方便的实现一个迭代器，&lt;code&gt;foreach&lt;/code&gt; 就是迭代器的一个语法糖&lt;/p&gt;
&lt;p&gt;来看一下 &lt;code&gt;IEnumerabe&lt;/code&gt; 的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// 聚集抽象
public interface IEnumerable
{
    /// &amp;lt;summary&amp;gt;Returns an enumerator that iterates through a collection.&amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;An &amp;lt;see cref=&quot;T:System.Collections.IEnumerator&quot; /&amp;gt; object that can be used to iterate through the collection.&amp;lt;/returns&amp;gt;
    IEnumerator GetEnumerator();
}

// 迭代器抽象
public interface IEnumerator
{
    /// &amp;lt;summary&amp;gt;Advances the enumerator to the next element of the collection.&amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;
    /// &amp;lt;see langword=&quot;true&quot; /&amp;gt; if the enumerator was successfully advanced to the next element; &amp;lt;see langword=&quot;false&quot; /&amp;gt; if the enumerator has passed the end of the collection.&amp;lt;/returns&amp;gt;
    /// &amp;lt;exception cref=&quot;T:System.InvalidOperationException&quot;&amp;gt;The collection was modified after the enumerator was created.&amp;lt;/exception&amp;gt;
    bool MoveNext();

    /// &amp;lt;summary&amp;gt;Gets the element in the collection at the current position of the enumerator.&amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;The element in the collection at the current position of the enumerator.&amp;lt;/returns&amp;gt;
    object Current { get; }

    /// &amp;lt;summary&amp;gt;Sets the enumerator to its initial position, which is before the first element in the collection.&amp;lt;/summary&amp;gt;
    /// &amp;lt;exception cref=&quot;T:System.InvalidOperationException&quot;&amp;gt;The collection was modified after the enumerator was created.&amp;lt;/exception&amp;gt;
    void Reset();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后留个思考题给你，List 在 &lt;code&gt;foreach&lt;/code&gt; 的时候如果删除一个元素会发生什么？内部是怎么样实现的呢？ 可以自己实践一下&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 07 Aug 2020 17:18:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>迭代器模式 Iterator Intro 迭代器模式，提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 迭代器模式是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/iterator-pattern.html</dc:identifier>
</item>
<item>
<title>一篇文章快速搞懂什么是GitHub - Coding十日谈</title>
<link>http://www.cnblogs.com/jfzhu/p/13456119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/13456119.html</guid>
<description>
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808005729035-647508903.jpg&quot; alt=&quot;&quot; width=&quot;493&quot; height=&quot;164&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导读：什么是GitHub？Git与GitHub之间是什么关系？我们为什么需要版本控制系统？GitHub如何使用？本文将带你一探究竟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文字数：1710，阅读时长大约：13分钟&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、什么是版本控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;按照百度百科的说法：“版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的核心词是对“文件变更的管理”，其实不管是写代码还是写文档，当文件发生变更时都会有两个绕不开的问题：一个是文件版本的管理，另一个是团队如何协作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808005802460-1551447034.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;446&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如当你在做一份报告时，每一次比较大的改动可能都会做一个副本，以备后面有改回来的需要。每一个副本文件名都加一些不同的后缀，比如数字、字母、日期等等。不过可能时间一长，你自己也不记得每个副本都做过的哪些修改，甚至找不到最后一个版本是哪份文件了。又比如当一个团队需要去修改一份数据文件，小明、小红、小刚等人都在同时修改，每个人的修改是否都能被包含在数据文件里，最终的文件以哪一份为准？在这些场景中，我们都需要一个文件版本控制系统来帮助我们解决文件的版本问题以及团队协作的问题。&lt;/p&gt;

&lt;p&gt;版本控制系统可以帮助我们记录文件的变更，包括在什么时间、被什么人、修改了哪些内容。这样我们就不用在自己的电脑里保存那么多份文件副本了，只需要将每一次的修改提交到版本控制系统中去。如果未来需要文件回溯，可以直接在系统中选择历史版本，非常简单方便。另外在软件开发中往往是一个团队共同进行，版本控制系统可以支持并行开发，能够通过分支、合并等方式有效地解决修改冲突。&lt;/p&gt;

&lt;p&gt;版本控制系统有很多，除了我们今天要介绍的 Git，比较常用的还有 Subversion, CVS,和 Mercurial。 &lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、什么是 Git&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Git，最初是由 Linux之父 Linus Torvalds在2005年开发出来的一款开源的版本控制系统。和其他版本控制系统一样，它最核心的一个概念就是仓库（repository）。仓库其实就是在电脑中开启了Git记录的一个文件夹/目录。仓库中可以包含多个文件以及子文件夹。Git中的仓库是存储在本地电脑上的，不像其他的版本控制系统（比如Subversion）将仓库存储在服务器当中。这就意味着Git允许你在电脑不联网的情况下也可以正常工作，你可以修改文件、提交、查看修改历史、分支、合并等等。&lt;/p&gt;

&lt;p&gt;Git最初只有命令行，后来也开发出了桌面版GUI的程序，不过桌面版GUI功能有限，想要使用最完整的功能，还是建议使用命令行。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、什么是 GitHub&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Git虽然是一个很好的版本管理系统，但是只通过命令行的方式来使用还是有一些不方便。于是在2008年，开源社区开发了一个叫GitHub的网站。它可以存储所有的Git仓库，并且提升了开发者们之间的协作体验。GitHub迅速成为了开源社区的宠儿，大量开源项目纷纷落户，使用它来做版本控制以及沟通协作。现在有成千上万的公司也加入了进来，使用GitHub作为公司内部的版本控制系统。&lt;/p&gt;

&lt;p&gt;时至今日，GitHub已经不再单单是一个版本管理的网站，它更像是一个开源社区的社交工具。很多开发者们都会在上面去逛，看看有哪些好玩的、自己感兴趣的项目。我们也可以看到其他开发者们参与过哪些项目，每个人都好像有一张自己的名片。当你想要参与到某个项目中去时，项目管理者也可以根据你的记录来选择是否接受。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、Git的安装与使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;了解了Git与GitHub的原理之后，我们来看一下如何使用GitHub创建一个新的或者使用一个项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）打开GitHub的网站&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;www.github.com&lt;/p&gt;
&lt;p&gt;如果还没有账户，可以按照提示注册一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808005958077-1207198772.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;382&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）创建一个新的仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击创建仓库（Create repository）按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010010360-448260953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;填写仓库（项目）名称，设置成公共/私有仓库，同时可以初始化一个README文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010204018-1046880548.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010237729-266139902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; data-ratio=&quot;1&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Gr3LEhZkSDRIpiaib9Ibv3k3ibyxOEmTLH7iaGfzsxexLGF2X1I77DnQgibv4rsTPTs1RNJKicnbyPJtg8IEVGCU4f8A/640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; data-ratio=&quot;1&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Gr3LEhZkSDRIpiaib9Ibv3k3ibyxOEmTLH7u6icBykhtrWe3ZvpHr0bATYibpurqx6JgblibpyqiaoK35zHtIny21HnWA/640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）在本地电脑安装Git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 CentOS为例，使用 yum install -y git 命令安装；其他操作系统可以参考Git官方网站的安装手册 &lt;/p&gt;
&lt;p&gt;https://git-scm.com/downloads&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010301194-647391912.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好后不要忘了配置 Git账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010306765-970114324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）将GitHub的仓库复制到本地&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击Code按钮，将仓库的URL复制下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010325760-1070671599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 git clone + url 的命令将仓库复制到本地&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010335178-1091242905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）在本地添加一个新文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入github-test文件夹，添加一个hello.c的文件。&lt;/p&gt;
&lt;p&gt;使用 git status 命令查看当前状态，系统提示有一个未跟踪的文件hello.c，建议使用git add命令来包含要提交的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010343587-752580958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 git add 命令添加要提交的文件&lt;/p&gt;
&lt;p&gt;使用 git commit -m &quot;comments&quot; 来提交修改；注意，这里的提交只是提交到了本地的 Git仓库，如果想同步到 GitHub还需要使用到 git push命令&lt;/p&gt;
&lt;p&gt;使用 git push 命令将修改同步到 GitHub&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010352151-172526655.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到GitHub，可以看到新的文件被添加进来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010402846-1661003608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;获取知识干货、增加面试经验、了解职场人生&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200808010440308-881523032.jpg&quot; alt=&quot;&quot; width=&quot;205&quot; height=&quot;205&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 17:07:00 +0000</pubDate>
<dc:creator>Coding十日谈</dc:creator>
<og:description>导读：什么是GitHub？Git与GitHub之间是什么关系？我们为什么需要版本控制系统？GitHub如何使用？本文将带你一探究竟。 本文字数：1710，阅读时长大约：13分钟 一、什么是版本控制 按</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/13456119.html</dc:identifier>
</item>
<item>
<title>来自灵魂的拷问——知道什么是SQL执行计划吗？ - 牧小农的夏天</title>
<link>http://www.cnblogs.com/mingyueyy/p/13455863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingyueyy/p/13455863.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200804232611392.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官说：工作这么久了，应该知道sql执行计划吧，讲讲Sql的执行计划吧！&lt;br/&gt;看了看面试官手臂上纹的大花臂和一串看不懂的韩文，吞了吞口水，暗示自己镇定点，整理了一下思绪缓缓的对面试官说：我不会&lt;br/&gt;面试官：。。。。，回去等通知吧&lt;br/&gt;我：%^&lt;em&gt;&amp;amp;&lt;/em&gt;%$&lt;em&gt;!@#&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;当我们工作到了一定的年限之后，一些应该掌握的知识点，我们是必须需要去了解的，比如今天面试官问的SQL执行计划&lt;br/&gt;当我们执行一条SQL的时候，可以直接对应的结果，但是你并不晓得，它会经历多深远黑暗的隧道，通过连接器、查询缓存、分析器、优化器、执行器重重筛选，才有可能展示到我们面前，有时候当你等待N长时间，但是展现的却是 timeout，这个时候想砸电脑的心都有了，不过当你看了今天的SQL执行计划后，你再也不用砸电脑了，看懂了这篇文章你就会知道这都不是事，让我们一起来揭晓这里面的奥妙&lt;/p&gt;
&lt;p&gt;在实际的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。&lt;br/&gt;通常会使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官网地址：&lt;/strong&gt; &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/explain-output.html&quot;&gt;https://dev.mysql.com/doc/refman/5.5/en/explain-output.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我们来下面的一条sql语句，其中会有&lt;code&gt;id、select_type 、table 等等&lt;/code&gt;这些列，这些就是我们执行计划中所包含的信息，我们要弄明白的就是这些列是用来干嘛的，以及每个列可能存在多少个值。&lt;br/&gt;&lt;code&gt;explain select * from emp;&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231253977.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、执行计划中包含的信息&quot;&gt;二、执行计划中包含的信息&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;列(Column)&lt;/th&gt;
&lt;th&gt;含义(Meaning)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;The &lt;code&gt;SELECT&lt;/code&gt; identifier（&lt;strong&gt;每个select子句的标识id&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;select_type&lt;/td&gt;
&lt;td&gt;The &lt;code&gt;SELECT&lt;/code&gt; type（&lt;strong&gt;select语句的类型&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;The table for the output row（&lt;strong&gt;当前表名&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;The matching partitions （&lt;strong&gt;显示查询将访问的分区，如果你的查询是基于分区表&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;The join type（&lt;strong&gt;当前表内访问方式&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;The possible indexes to choose（&lt;strong&gt;可能使用到的索引&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;The index actually chosen（&lt;strong&gt;经过优化器评估最终使用的索引&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;key_len&lt;/td&gt;
&lt;td&gt;The length of the chosen key （&lt;strong&gt;使用到的索引长度&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;The columns compared to the index（&lt;strong&gt;引用到的上一个表的列&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;Estimate of rows to be examined （&lt;strong&gt;要得到最终记录索要扫描经过的记录数&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;Percentage of rows filtered by table condition（&lt;strong&gt;存储引擎返回的数据在server层过滤后，剩下满足查询的记录数量的比例&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;extra&lt;/td&gt;
&lt;td&gt;Additional information （&lt;strong&gt;额外的信息说明&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;贴心的小农已经把sql复制出来了，只需要放到数据库中执行即可，方便简单快捷 

                                                                                                                 ——牧小农
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;建表语句：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SET FOREIGN_KEY_CHECKS=0;
DROP TABLE IF EXISTS `dept`;
CREATE TABLE `dept` (
  `DEPTNO` int NOT NULL,
  `DNAME` varchar(14) DEFAULT NULL,
  `LOC` varchar(13) DEFAULT NULL,
  PRIMARY KEY (`DEPTNO`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `dept` VALUES ('10', 'ACCOUNTING', 'NEW YORK');
INSERT INTO `dept` VALUES ('20', 'RESEARCH', 'DALLAS');
INSERT INTO `dept` VALUES ('30', 'SALES', 'CHICAGO');
INSERT INTO `dept` VALUES ('40', 'OPERATIONS', 'BOSTON');

DROP TABLE IF EXISTS `emp`;
CREATE TABLE `emp` (
  `EMPNO` int NOT NULL,
  `ENAME` varchar(10) DEFAULT NULL,
  `JOB` varchar(9) DEFAULT NULL,
  `MGR` int DEFAULT NULL,
  `HIREDATE` date DEFAULT NULL,
  `SAL` double(7,2) DEFAULT NULL,
  `COMM` double(7,2) DEFAULT NULL,
  `DEPTNO` int DEFAULT NULL,
  PRIMARY KEY (`EMPNO`),
  KEY `idx_job` (`JOB`),
  KEY `jdx_mgr` (`MGR`),
  KEY `jdx_3` (`DEPTNO`),
  KEY `idx_3` (`DEPTNO`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `emp` VALUES ('7369', 'SMITH', 'CLERK', '7902', '1980-12-17', '800.00', null, '20');
INSERT INTO `emp` VALUES ('7499', 'ALLEN', 'SALESMAN', '7698', '1981-02-20', '1600.00', '300.00', '30');
INSERT INTO `emp` VALUES ('7521', 'WARD', 'SALESMAN', '7698', '1981-02-22', '1250.00', '500.00', '30');
INSERT INTO `emp` VALUES ('7566', 'JONES', 'MANAGER', '7839', '1981-02-02', '2975.00', null, '20');
INSERT INTO `emp` VALUES ('7654', 'MARTIN', 'SALESMAN', '7698', '1981-09-28', '1250.00', '1400.00', '30');
INSERT INTO `emp` VALUES ('7698', 'BLAKE', 'MANAGER', '7839', '1981-01-05', '2850.00', null, '30');
INSERT INTO `emp` VALUES ('7782', 'CLARK', 'MANAGER', '7839', '1981-09-06', '2450.00', null, '10');
INSERT INTO `emp` VALUES ('7839', 'KING', 'PRESIDENT', null, '1981-11-17', '5000.00', null, '10');
INSERT INTO `emp` VALUES ('7844', 'TURNER', 'SALESMAN', '7698', '1981-09-08', '1500.00', '0.00', '30');
INSERT INTO `emp` VALUES ('7900', 'JAMES', 'CLERK', '7698', '1981-12-03', '950.00', null, '30');
INSERT INTO `emp` VALUES ('7902', 'FORD', 'ANALYST', '7566', '1981-12-03', '3000.00', null, '20');
INSERT INTO `emp` VALUES ('7934', 'MILLER', 'CLERK', '7782', '1982-01-23', '1300.00', null, '10');

DROP TABLE IF EXISTS `emp2`;
CREATE TABLE `emp2` (
  `id` int NOT NULL AUTO_INCREMENT,
  `empno` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
INSERT INTO `emp2` VALUES ('1', '111');
INSERT INTO `emp2` VALUES ('2', '222');

DROP TABLE IF EXISTS `salgrade`;
CREATE TABLE `salgrade` (
  `GRADE` int NOT NULL,
  `LOSAL` double DEFAULT NULL,
  `HISAL` double DEFAULT NULL,
  PRIMARY KEY (`GRADE`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `salgrade` VALUES ('1', '700', '1200');
INSERT INTO `salgrade` VALUES ('2', '1201', '1400');
INSERT INTO `salgrade` VALUES ('3', '1401', '2000');
INSERT INTO `salgrade` VALUES ('4', '2001', '3000');
INSERT INTO `salgrade` VALUES ('5', '3001', '9999');

DROP TABLE IF EXISTS `t_job`;
CREATE TABLE `t_job` (
  `id` int NOT NULL AUTO_INCREMENT,
  `job` varchar(9) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `j` (`job`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;21-id&quot;&gt;2.1 id&lt;/h3&gt;
&lt;p&gt;select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序&lt;/p&gt;
&lt;p&gt;id号分为三种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;​ 1、如果id相同，那么执行顺序从上到下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- 左关联
explain select * from emp e left  join dept d on e.deptno = d.deptno;
-- 右关联
explain select * from emp e right join dept d on e.deptno = d.deptno;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过left join 和 right join 验证；id一样（注意执行计划的table列），left join 先扫描e表，再扫描d表；right join 先扫描d表，再扫描e表&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231330571.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;​ 2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp e where e.deptno = (select d.deptno from dept d where d.dname = 'SALES');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下面的表中回先查询 id 为 2的数据 也就是我们的 d表（&lt;strong&gt;注意：我们可以看到d表中select_type为 SUBQUERY 也就是子查询的 意思&lt;/strong&gt;），然后根据d表中的deptno去查询 e表中的数据&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231352842.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp e join dept d on e.deptno = d.deptno join salgrade sg on e.sal between sg.losal and sg.hisal where e.deptno = (select d.deptno from dept d where d.dname = 'SALES');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里先从id为2的执行，如果id是一样的，就按照顺序执行&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231416429.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-select_type&quot;&gt;2.2 select_type&lt;/h3&gt;
&lt;p&gt;主要用来分辨查询的类型，是普通查询还是联合查询还是子查询&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;select_type 值&lt;/th&gt;
&lt;th&gt;含义(Meaning）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;SIMPLE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;简单的查询不包含 UNION 和 subqueries&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;PRIMARY&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查询中若包含任何复杂的子查询，最外层查询则被标记为Primary&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;UNION&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;若第二个select出现在union之后，则被标记为union&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;DEPENDENT UNION&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNION RESULT&lt;/td&gt;
&lt;td&gt;从union表获取结果的select&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;SUBQUERY&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在select或者where列表中包含子查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;DEPENDENT SUBQUERY&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;subquery的子查询要受到外部表查询的影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;DERIVED&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;from子句中出现的子查询，也叫做派生类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNCACHEABLE SUBQUERY&lt;/td&gt;
&lt;td&gt;表示使用子查询的结果不能被缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNCACHEABLE UNION&lt;/td&gt;
&lt;td&gt;表示union的查询结果不能被缓存&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--simple:简单的查询，不包含子查询和union
explain select * from emp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231534225.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary
explain select * from emp e where e.deptno = (select d.deptno from dept d where d.dname = 'SALES');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231501422.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--union:若第二个select出现在union之后，则被标记为union
explain select * from emp where deptno = 10 union select * from emp where sal &amp;gt;2000;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020080623161130.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响
explain select * from emp e where e.empno  in ( select empno from emp where deptno = 10 union select empno from emp where sal &amp;gt;2000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231628920.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--union result:从union表获取结果的select
explain select * from emp where deptno = 10 union select * from emp where sal &amp;gt;2000;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231652413.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--subquery:在select或者where列表中包含子查询
explain select * from emp where sal &amp;gt; (select avg(sal) from emp) ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231709459.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--dependent subquery:subquery的子查询要受到外部表查询的影响
explain select * from emp e where e.deptno = (select distinct deptno from dept where deptno = e.deptno);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231736639.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--DERIVED: from子句中出现的子查询，也叫做派生类，
explain select * from (select ename staname,mgr from emp where ename = 'W' union select ename,mgr from emp where ename = 'E') a;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231925627.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存
 explain select * from emp where empno = (select empno from emp where deptno=@@sort_buffer_size);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806231947552.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--uncacheable union:表示union的查询结果不能被缓存
explain select * from emp where exists (select 1 from dept where  emp.deptno = dept.deptno union select 1 from dept where  deptno = 10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806232009596.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-table&quot;&gt;2.3 table&lt;/h3&gt;
&lt;p&gt;对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集&lt;br/&gt;1、如果是具体的表名，则表明从实际的物理表中获取数据，也可以是表的别名&lt;br/&gt;&lt;code&gt;explain select * from emp where sal &amp;gt; (select avg(sal) from emp) ;&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806232029251.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表&lt;br/&gt;&lt;code&gt;explain select * from (select ename staname,mgr from emp where ename = 'WARD' union select ename staname,mgr from emp where ename = 'SMITH') a;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;derived2 ：&lt;/strong&gt; 表明我们需要从衍生表2中取数据&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020080623205478.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id&lt;br/&gt;&lt;code&gt;explain select * from emp where deptno = 10 union select * from emp where sal &amp;gt;2000;&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806232116267.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-type&quot;&gt;2.4 type&lt;/h3&gt;
&lt;p&gt;type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：&lt;/p&gt;
&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; fulltext &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/p&gt;
&lt;p&gt;一般情况下，得保证查询至少达到range级别，最好能达到ref&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。
explain select * from emp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806223336331.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序
explain  select empno from emp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806223316544.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &amp;lt;&amp;gt;, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, IS NULL, BETWEEN, LIKE, or IN() 
explain select * from emp where empno between 7000 and 7500;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806223355230.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--index_subquery：利用索引来关联子查询，不再扫描全表
explain select * from emp where emp.job in (select job from t_job);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引
 explain select * from emp e where e.deptno in (select distinct deptno from dept);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式
explain select * from emp e where  e.mgr is null or e.mgr=7369;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230426480.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--ref：使用了非唯一性索引进行数据的查找
 create index idx_3 on emp(deptno);
 explain select * from emp e,dept d where e.deptno =d.deptno;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230407828.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--eq_ref ：使用唯一性索引进行数据查找
explain select * from emp,emp2 where emp.empno = emp2.empno;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230344111.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--const：这个表至多有一个匹配行，
explain select * from emp where empno = 7369;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230323477.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-possible_keys&quot;&gt;2.5 possible_keys&lt;/h3&gt;
&lt;p&gt;​ 显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230300531.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-key&quot;&gt;2.6 key&lt;/h3&gt;
&lt;p&gt;​ 实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230451962.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-key_len&quot;&gt;2.7 key_len&lt;/h3&gt;
&lt;p&gt;表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。&lt;br/&gt;1、一般地，key_len 等于索引列类型字节长度，例如int类型为4 bytes，bigint为8 bytes；&lt;br/&gt;2、如果是字符串类型，还需要同时考虑字符集因素，例如utf8字符集1个字符占3个字节，gbk字符集1个字符占2个字节&lt;br/&gt;3、若该列类型定义时允许NULL，其key_len还需要再加 1 bytes&lt;br/&gt;4、若该列类型为变长类型，例如 VARCHAR（TEXT\BLOB不允许整列创建索引，如果创建部分索引也被视为动态列类型），其key_len还需要再加 2 bytes&lt;br/&gt;字符集会影响索引长度、数据的存储空间，为列选择合适的字符集；变长字段需要额外的2个字节，固定长度字段不需要额外的字节。而null都需要1个字节的额外空间，所以以前有个说法：索引字段最好不要为NULL，因为NULL让统计更加复杂，并且需要额外一个字节的存储空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-- key_len的长度计算公式：

-- varchar(len)变长字段且允许NULL      : len*(Character Set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)
-- varchar(len)变长字段且不允许NULL    : len*(Character Set：utf8=3,gbk=2,latin1=1)+2(变长字段)

-- char(len)固定字段且允许NULL         : len*(Character Set：utf8=3,gbk=2,latin1=1)+1(NULL)
-- char(len)固定字段且不允许NULL       : len*(Character Set：utf8=3,gbk=2,latin1=1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230509373.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;28-ref&quot;&gt;2.8 ref&lt;/h3&gt;
&lt;p&gt;显示索引的哪一列被使用了，如果可能的话，是一个常数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230528190.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;29-rows&quot;&gt;2.9 rows&lt;/h3&gt;
&lt;p&gt;根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;explain select * from emp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230543796.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;包含额外的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置
explain select * from emp order by sal;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230606790.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除
explain select ename,count(*) from emp where deptno = 10 group by ename;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230645216.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找
explain select deptno,count(*) from emp group by deptno limit 10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230701458.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--using where:使用where进行条件过滤
explain select * from emp2 where empno = 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200806230858622.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-总结&quot;&gt;三 总结&lt;/h2&gt;
&lt;p&gt;到这里执行计划就讲完了，sql的执行计划并不是很难，主要是记住每个列代表的意思和如何进行优化，这个是需要大量的训练和实操实现的， 有兴趣的小伙伴可以自行去试试，还是很有趣的，本文只是简单介绍一下MySQL执行计划，想全面深入了解MySQL,可优先阅读&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/explain-output.html&quot;&gt;MySQL官方手册&lt;/a&gt;，大家加油~&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 15:15:00 +0000</pubDate>
<dc:creator>牧小农的夏天</dc:creator>
<og:description>面试官说：工作这么久了，应该知道sql执行计划吧，讲讲Sql的执行计划吧！ 看了看面试官手臂上纹的大花臂和一串看不懂的韩文，吞了吞口水，暗示自己镇定点，整理了一下思绪缓缓的对面试官说：我不会 面试官：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mingyueyy/p/13455863.html</dc:identifier>
</item>
<item>
<title>树莓派4B的CPU系统里查到为BCM2835而非BCM2711 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/13455849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/13455849.html</guid>
<description>&lt;div class=&quot;document&quot; readability=&quot;13.690902169775&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;树莓派4B采用四核64位的ARM Cortex-A72架构CPU，型号为博通BCM2711 SoC。2711是个64位的四核，而2835是多年前的32位单核CPU。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span class=&quot;image-wrapper&quot;&gt;&lt;img src=&quot;https://qqadapt.qpic.cn/txdocpic/0/e15674be894b6c06f5567d48df754aa5/0?w=998&amp;amp;h=620&quot; width=&quot;601&quot; height=&quot;373&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;查看当前芯片版本，显示为4核心，但是芯片名字却是BCM2835，这是一个很老的芯片。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;在树莓派zero和1上使用的，新的树莓派4B是BCM2711，拿起板子我能明显看到 芯片上的丝印字，为什么cpuinfo命令查出来的是错误的呢？&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div class=&quot;document&quot; readability=&quot;27&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;pi@raspberrypi:/proc/cpu $ cat /proc/cpuinfo&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;processor : 0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;model name : ARMv7 Processor rev 3 (v7l)&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;BogoMIPS : 108.00&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU implementer : 0x41&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU architecture: 7&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU variant : 0x0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU part : 0xd08&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU revision : 3&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;processor : 1&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;model name : ARMv7 Processor rev 3 (v7l)&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;BogoMIPS : 108.00&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU implementer : 0x41&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU architecture: 7&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU variant : 0x0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU part : 0xd08&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU revision : 3&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;processor : 2&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;model name : ARMv7 Processor rev 3 (v7l)&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;BogoMIPS : 108.00&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU implementer : 0x41&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU architecture: 7&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU variant : 0x0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU part : 0xd08&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU revision : 3&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;processor : 3&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;model name : ARMv7 Processor rev 3 (v7l)&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;BogoMIPS : 108.00&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU implementer : 0x41&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU architecture: 7&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU variant : 0x0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU part : 0xd08&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;CPU revision : 3&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Hardware : BCM2835&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Revision : b03111&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Serial : 10000000eb0168e0&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;Model : Raspberry Pi 4 Model B Rev 1.1&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;7.0482866043614&quot;&gt;
&lt;div class=&quot;document&quot; readability=&quot;10.33748701973&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;Gordon大佬回复如下，大意是内核只许设置1个值，如果设置不同的值就要改代码，这会导致上游集成更加麻烦。建议查版本用cat /proc/device-tree/model来看。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;Gordon Hollingworth PhD&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.3 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;Raspberry Pi - Director of Software Engineering&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.raspberrypi.org/forums/viewtopic.php?p=1190349&quot;&gt;https://www.raspberrypi.org/forums/viewtopic.php?p=1190349&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.75 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt; &lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;document&quot; readability=&quot;19&quot;&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.33 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;this, as 6by9 indicated, is due to the fact that the upstream ARM kernel only allows us to set a single value for our devices.&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.33 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;If we wanted to have multiple different values it would require that we edit the code (which in general we prefer not to do because is causes problems for us wen integrating changes from upstream).i've asked Phil to change this to instead return &quot;BCM28xx&quot; to indicate that the kernel is specifically for the BCM2805/6/7 silicon.if you'd like to find out the model of the computer you should use the device tree instead a la:&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.33 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;pi@raspberrypi:~ $ cat /proc/device-tree/model&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;paragraph text-align-type-left pap-line-1.33 pap-line-rule-auto pap-spacing-before-0pt pap-spacing-after-6pt&quot;&gt;&lt;span&gt;Raspberry Pi 3 Model B Rev 1.2&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 07 Aug 2020 15:15:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>树莓派4B采用四核64位的ARM Cortex-A72架构CPU，型号为博通BCM2711 SoC。2711是个64位的四核，而2835是多年前的32位单核CPU。 查看当前芯片版本，显示为4核心，但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/13455849.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】使用@PropertySource加载配置文件，我只看这一篇！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13455820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13455820.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;9.1709844559585&quot;&gt;
&lt;p&gt;很多小伙伴都在问：冰河，你的Spring专题更新完了吗？怎么感觉像是写了一半啊？我：没有更新完呀，整个专题预计会有70多篇。那怎么更新了一半就去写别的了呢？那是因为有很多其他的小伙伴在后台留言说：急需学习一些其他的技术，所以，临时调整的。放心，Spring专题会持续更新的！这不，今天，我们就继续更新Spring专题。不出意外的话，会一直持续更新完！！&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;propertysource注解概述&quot;&gt;@PropertySource注解概述&lt;/h2&gt;
&lt;p&gt;@PropertySource注解是Spring 3.1开始引入的配置类注解。通过@PropertySource注解将properties配置文件中的值存储到Spring的 Environment中，Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。也可以使用@Value 注解用${}占位符注入属性。&lt;/p&gt;
&lt;p&gt;@PropertySource注解的源代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.context.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.io.support.PropertySourceFactory;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {
        String name() default &quot;&quot;;
        String[] value();
        boolean ignoreResourceNotFound() default false;
        String encoding() default &quot;&quot;;
        Class&amp;lt;? extends PropertySourceFactory&amp;gt; factory() default PropertySourceFactory.class;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从@PropertySource的源码可以看出，我们可以通过@PropertySource注解指定多个properties文件，可以使用如下形式进行指定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PropertySource(value={&quot;classpath:xxx.properties&quot;, &quot;classpath:yyy.properties&quot;})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的读者可以看到，在@PropertySource注解类的上面标注了如下的注解信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Repeatable(PropertySources.class)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，小伙伴们是不是有种恍然大悟的感觉呢？没错，我们也可以使用@PropertySources注解来指定properties配置文件。&lt;/p&gt;
&lt;h2 id=&quot;propertysources注解&quot;&gt;@PropertySources注解&lt;/h2&gt;
&lt;p&gt;首先，我们也是看下@PropertySources注解的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PropertySources {
        PropertySource[] value();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@PropertySources注解的源码比较简单，只有一个PropertySource[]数组类型的属性value，那我们如何使用@PropertySources注解指定配置文件呢？其实也很简单，就是使用如下所示的方式就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PropertySources(value={
    @PropertySource(value={&quot;classpath:xxx.properties&quot;}),
    @PropertySource(value={&quot;classpath:yyy.properties&quot;}),
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单呢？接下来，我们就以一个小案例来说明@PropertySource注解的用法。&lt;/p&gt;
&lt;h2 id=&quot;案例准备&quot;&gt;案例准备&lt;/h2&gt;
&lt;p&gt;首先，我们在工程的src/main/resources目录下创建一个配置文件person.properties文件，文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;person.nickName=zhangsan
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在Person类中新增一个字段nickName，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.springframework.beans.factory.annotation.Value;
import java.io.Serializable;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试实体类
 */
@Data
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Person implements Serializable {
    private static final long serialVersionUID = 7387479910468805194L;
    @Value(&quot;binghe&quot;)
    private String name;
    @Value(&quot;#{20-2}&quot;)
    private Integer age;
    private String nickName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前，我们并没有为Person类的nickName字段赋值，所以，此时Person类的nickName字段的值为空。我们运行下PropertyValueTest类的testPropertyValue01()方法来看下输出结果，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
propertyValueConfig
person
================================
Person(name=binghe, age=18, nickName=null)
Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，Person类的nickName字段的值确实输出了null。&lt;/p&gt;
&lt;h2 id=&quot;使用xml文件方式获取值&quot;&gt;使用xml文件方式获取值&lt;/h2&gt;
&lt;p&gt;如果我们需要在xml文件中获取person.properties文件中的值，则我们首先需要在Spring的xml文件中引入context名称空间，并且使用context命名空间导入person.properties文件，之后在bean的属性字段中使用如下方式将person.properties文件中的值注入到Person类的nickName字段上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;context:property-placeholder location=&quot;classpath:person.properties&quot; /&amp;gt;
&amp;lt;bean id = &quot;person&quot; class=&quot;io.mykit.spring.plugins.register.bean.Person&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;binghe&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;nickName&quot; value=&quot;${person.nickName}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个bean.xml文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/context/spring-context.xsd &quot;&amp;gt;
    
    &amp;lt;context:property-placeholder location=&quot;classpath:person.properties&quot;/&amp;gt;
    &amp;lt;bean id = &quot;person&quot; class=&quot;io.mykit.spring.plugins.register.bean.Person&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;binghe&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;nickName&quot; value=&quot;${person.nickName}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以将person.properties文件中的值注入到Person的nickName字段上。接下来，我们在PropertyValueTest类中创建testPropertyValue02()测试方法，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testPropertyValue02(){
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:beans.xml&quot;);
    Person person = (Person) context.getBean(&quot;person&quot;);
    System.out.println(person);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行PropertyValueTest类中创建的testPropertyValue02()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Person(name=binghe, age=18, nickName=zhangsan)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用注解方式获取值&quot;&gt;使用注解方式获取值&lt;/h2&gt;
&lt;p&gt;如果我们使用注解的方式该如何做呢？首先，我们需要在PropertyValueConfig配置类上添加@PropertySource注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.config;
import io.mykit.spring.plugins.register.bean.Person;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试属性赋值
 */
@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Configuration
public class PropertyValueConfig {
    @Bean
    public Person person(){
        return new Person();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用的&lt;code&gt;@PropertySource(value = {&quot;classpath:person.properties&quot;})&lt;/code&gt;就相当于xml文件中使用的&lt;code&gt;&amp;lt;context:property-placeholder location=&quot;classpath:person.properties&quot;/&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来，我们就可以在Person类的nickName字段上使用@Value注解来获取person.properties文件中的值了，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${person.nickName}&quot;)
private String nickName;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，我们再次运行PropertyValueTest类的testPropertyValue01()方法来看下输出结果，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
propertyValueConfig
person
================================
Person(name=binghe, age=18, nickName=zhangsan)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时Person类的nickName字段已经注入了“zhangsan”这个值。&lt;/p&gt;
&lt;h2 id=&quot;使用environment获取值&quot;&gt;使用Environment获取值&lt;/h2&gt;
&lt;p&gt;这里，我们在PropertyValueTest类中创建testPropertyValue03()方法，来使用Environment获取person.properties中的值，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testPropertyValue03(){
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PropertyValueConfig.class);
    Environment environment = context.getEnvironment();
    String nickName = environment.getProperty(&quot;person.nickName&quot;);
    System.out.println(nickName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行PropertyValueTest类中的testPropertyValue03()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;zhangsan
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，使用Environment确实能够获取到person.properties中的值。&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 15:08:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 很多小伙伴都在问：冰河，你的Spring专题更新完了吗？怎么感觉像是写了一半啊？我：没有更新完呀，整个专题预计会有70多篇。那怎么更新了一半就去写别的了呢？那是因为有很多其他的小伙伴在后台留</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13455820.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 13 期  - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13455615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13455615.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149.23047251688&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13363449.html&quot;&gt;《痞子衡嵌入式半月刊： 第 12 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是立秋，立秋并不代表酷热天气就此结束，初秋期间天气仍然很热。&lt;/p&gt;
&lt;p&gt;最近有一位主打嵌入式培训的名为&quot;硬件家x&quot;的公众号主受到我们圈内的广泛关注，起因在于他以免费实战项目教学为名，逐渐向粉丝收取小额费用以维持平台运营，最终不知什么原因得罪了一些人，他的公众号遭到报复性举报，影响了正常运营。这个人的公众号应该是今年年初才开通，很早我就关注到了他，并且也看到他为了快速扩大粉丝群做了很多努力，其实这个人技术水平很不错，但是全职在做公众号，难免在挣钱目的性上明显了些，人急起来做事情难免考虑不周到，容易得罪人。&lt;/p&gt;
&lt;p&gt;我个人觉得做技术这行，尤其是个人创业者，你必须得在向大家充分证明了你的能力，并且赢得不错的口碑之后，再去自然地做一些挣钱的生意，那样才会相对容易一些，也更容易得到别人(尤其是同行)的理解和认可。总之，挣钱的日子很长，铺垫到位，厚积薄发，才能走得更远更稳。众勉之，也祝他成功。&lt;/p&gt;
&lt;p&gt;本期共收录 2条资讯、3个项目、2个工具，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;1、全志将基于平头哥玄铁平台开发risc-v芯片&quot;&gt;&lt;span&gt;1、全志将基于平头哥玄铁平台开发RISC-V芯片&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;2018年阿里宣布成立平头哥半导体正式进军芯片设计领域。2019年7月，阿里正式推出了玄铁910处理器内核，号称业界最强RISC-V处理器，并对外开放授权。近日，全志科技宣布与阿里平头哥达成合作协议，将基于玄铁平台开发通用算力芯片。&lt;/p&gt;
&lt;p&gt;全志和平头哥双方首款合作产品已经开始研发，即全志基于平头哥玄铁 902 处理器开发通用算力芯片，量产周期可进一步缩短，并且有望在功耗上实现新的突破，该芯片可应用于智能家居、工业控制及消费电子领域，预计3年出货5000万颗。未来，全志还将推出更多基于玄铁系列处理器的芯片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/t-head_E902_block_diagram.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、兆易创新发布中国首款cortex-m33内核gd32e5系列mcu&quot;&gt;&lt;span&gt;2、兆易创新发布中国首款Cortex-M33内核GD32E5系列MCU&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;兆易创新GigaDevice 近日正式发布基于全新Arm® Cortex®-M33内核的GD32E5系列高性能微控制器。&lt;/p&gt;
&lt;p&gt;作为中国第一个Arm® Cortex®-M33内核通用MCU，GD32E5系列为数据密集、算法密集、传输密集的高精度工控和消费类应用，提供了高性价比的解决方案。并将以持续拓展的GD32生态系统为服务支撑，深耕市场行业需求，提升用户开发体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/GD32E5_Series.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GD32E5产品组合提供了3个通用系列和1个专用系列，4种封装类型23个型号选择，目前已经开始提供样片和开发板卡，并将于下个月正式投入量产。&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;1、airbit---用microbit制作的无人机&quot;&gt;&lt;span&gt;1、Air:bit - 用Micro:bit制作的无人机&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Air:bit是挪威的一个团队在Kickstarter上众筹的一个无人机，机身用Micro:bit制作，遥控器也通过Micro:bit板实现。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1940298507463&quot;&gt;
&lt;p&gt;众筹主页： &lt;a href=&quot;https://www.kickstarter.com/projects/makekit/airbit&quot;&gt;https://www.kickstarter.com/projects/makekit/airbit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/air-bit.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/air-bit-control.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、nr_micro_shell---适用资源较少的mcu的基本命令行工具&quot;&gt;&lt;span&gt;2、nr_micro_shell - 适用资源较少的MCU的基本命令行工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在进行调试和维护时，常常需要与单片机进行交互，获取、设置某些参数或执行某些操作，nr_micro_shell正是为满足这一需求，针对资源较少的MCU编写的基本命令行工具。虽然RT_Thread组件中已经提供了强大的finsh命令行交互工具，但对于ROM、RAM资源较少的单片机，finsh还是略显的庞大，在这些平台上，若仍想保留基本的命令行交互功能，nr_micro_shell是一个不错的选择。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4035087719298&quot;&gt;
&lt;p&gt;项目主页： &lt;a href=&quot;https://github.com/Nrusher/nr_micro_shell&quot;&gt;https://github.com/Nrusher/nr_micro_shell&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;nr_micro_shell具有以下优点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1.占用资源少，使用简单，灵活方便。使用过程只涉及两个shell_init()和shell()两个函数，无论是使用RTOS还是裸机都可以方便的应用该工具，不需要额外的编码工作。
2.交互体验好。完全类似于linux shell命令行，当串口终端支持ANSI（如Hypertrm终端）时，其不仅支持基本的命令行交互，还提供Tab键命令补全，查询历史命令，方向键移动光标修改功能。
3.扩展性好。nr_micro_shell为用户提供自定义命令的标准函数原型，只需要按照命令编写命令函数，并注册命令函数，即可使用命令。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、cmbacktrace---arm-cortex-m系列mcu错误追踪库&quot;&gt;&lt;span&gt;3、CmBacktrace - ARM Cortex-M系列MCU错误追踪库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;CmBacktrace是RT-Thread技术总监朱天龙大神开发维护的一款针对 ARM Cortex-M 系列 MCU 的错误代码自动追踪、定位，错误原因自动分析的开源库。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5094339622642&quot;&gt;
&lt;p&gt;项目主页： &lt;a href=&quot;https://github.com/armink/CmBacktrace&quot;&gt;https://github.com/armink/CmBacktrace&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CmBacktrace主要特性如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1.支持的错误包括：断言（assert）、故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault）
2.故障原因自动诊断 ：可在故障发生时，自动分析出故障的原因，定位发生故障的代码位置，而无需再手动分析繁杂的故障寄存器；
3.输出错误现场的 函数调用栈（需配合 addr2line 工具进行精确定位），还原发生错误时的现场信息，定位问题代码位置、逻辑更加快捷、精准。也可以在正常状态下使用该库，获取当前的函数调用栈；
4.支持 裸机 及以下操作系统平台：RT-Thread、UCOS、FreeRTOS（需修改源码）
5.根据错误现场状态，输出对应的 线程栈 或 C 主栈；
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;1、vspd---超级好用的虚拟串口软件&quot;&gt;&lt;span&gt;1、VSPD - 超级好用的虚拟串口软件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为解决计算机的物理串口个数的限制，在进行串口调试实验时，应尽可能采用虚拟串口软件。VSPD（Virtual Serial Ports Driver）虚拟串口软件是由Eltima软件公司设计的虚拟串口软件，使用方便且稳定。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5384615384615&quot;&gt;
&lt;p&gt;软件官网： &lt;a href=&quot;https://www.virtual-serial-port.org/&quot;&gt;https://www.virtual-serial-port.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用虚拟串口也是规避风险的好办法，尤其对新手而言，应该先在虚拟串口环境下调试自己的代码，成功之后再连接物理串口，链接物理串口之前一定要检查连线是否正确，并用万能表检测是否有短路断路情况发生，否则极易烧毁串口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Virtual_Serial_Port_Driver.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、everything---非常优秀的文件搜索软件&quot;&gt;&lt;span&gt;2、Everything - 非常优秀的文件搜索软件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Everything是voidtools开发的一款文件搜索工具，官网描述为“基于名称实时定位文件和目录”。它体积小巧，界面简洁易用，快速建立索引，快速搜索，同时占用极低的系统资源，实时跟踪文件变化，并且还可以通过http或ftp形式分享搜索。&lt;/p&gt;
&lt;blockquote readability=&quot;1.9047619047619&quot;&gt;
&lt;p&gt;软件官网： &lt;a href=&quot;https://www.voidtools.com/&quot;&gt;https://www.voidtools.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Everything可以说是速度最快的文件名搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引，文件名搜索瞬间呈现结果。小巧免费，支持中文，支持正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Everything.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 07 Aug 2020 14:30:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13455615.html</dc:identifier>
</item>
<item>
<title>5.深入k8s：StatefulSet控制器 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/13455528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/13455528.html</guid>
<description>&lt;blockquote readability=&quot;3.6842105263158&quot;&gt;
&lt;p&gt;转载请声明出处哦~，本篇文章发布于luozhiyun的博客：&lt;a href=&quot;https://www.luozhiyun.com&quot;&gt;https://www.luozhiyun.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20200807220926.png&quot; alt=&quot;image-20200807220814361&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上一篇中，讲解了容器持久化存储，从中我们知道什么是PV和PVC，这一篇我们讲通过StatefulSet来使用它们。如果觉得我讲的不错的，可以发个邮件鼓励一下我噢~&lt;/p&gt;
&lt;p&gt;我们在第三篇讲的Deployment控制器是应用于无状态的应用的，所有的Pod启动之间没有顺序，Deployment可以任意的kill一个Pod不会影响到业务数据，但是这到了有状态的应用中就不管用了。&lt;/p&gt;
&lt;p&gt;而StatefulSet就是用来对有状态应用提供支持的控制器。&lt;/p&gt;
&lt;p&gt;StatefulSet把真实世界里的应用状态，抽象为了两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拓扑状态。应用的多个实例之间不是完全对等的关系。这些应用实例，必须按照某些顺序启动，比如应用的主节点 A 要先于从节点 B 启动。并且，新创建出来的 Pod，必须和原来 Pod 的网络标识一样。&lt;/li&gt;
&lt;li&gt;存储状态。应用的多个实例分别绑定了不同的存储数据，对于这些应用实例来说，Pod A 第一次读取到的数据，和隔了十分钟之后再次读取到的数据，应该是同一份，哪怕在此期间 Pod A 被重新创建过。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;StatefulSet 的核心功能，就是通过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。&lt;/p&gt;
&lt;h3 id=&quot;拓扑状态&quot;&gt;拓扑状态&lt;/h3&gt;
&lt;p&gt;在k8s中，Service是用来将一组 Pod 暴露给外界访问的一种机制。Service可以通过DNS的方式，代理到某一个Pod，然后通过DNS记录的方式解析出被代理 Pod 的 IP 地址。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Service会通过Label Selector选择所有携带了 app=nginx 标签的 Pod，都会被这个 Service 代理起来。&lt;/p&gt;
&lt;p&gt;它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;pod-name&amp;gt;.&amp;lt;svc-name&amp;gt;.&amp;lt;namespace&amp;gt;.svc.cluster.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以通过这个DNS记录，StatefulSet就可以使用到DNS 记录来维持 Pod 的拓扑状态。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: &quot;nginx&quot;
  replicas: 2  # by default is 1
  selector:
    matchLabels:
      app: nginx  # has to match .spec.template.metadata.labels
  template:
    metadata:
      labels:
        app: nginx # has to match .spec.selector.matchLabels
    spec:
      containers:
      - name: nginx
        image: nginx:1.9.1
        ports:
        - containerPort: 80
          name: web
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了serviceName=nginx，表明StatefulSet 控制器会使用nginx 这个Service来进行网络代理。&lt;/p&gt;
&lt;p&gt;我们可以如下创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl create -f svc.yaml
$ kubectl get service nginx
NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
nginx     ClusterIP    None         &amp;lt;none&amp;gt;        80/TCP    10s

$ kubectl create -f statefulset.yaml
$ kubectl get statefulset web
NAME      DESIRED   CURRENT   AGE
web       2         1         19s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以观察pod的创建情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get pods -w -l app=nginx

NAME    READY   STATUS    RESTARTS   AGE
web-0   1/1     Running   0          76m
web-1   1/1     Running   0          76m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过-w命令可以看到pod创建情况，StatefulSet所创建的pod编号都是从0开始累加，在 web-0 进入到 Running 状态、并且细分状态（Conditions）成为 Ready 之前，web-1 会一直处于 Pending 状态。&lt;/p&gt;
&lt;p&gt;然后我们使用exec查看pod的hostname：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec web-0 -- sh -c 'hostname'
web-0
$ kubectl exec web-1 -- sh -c 'hostname'
web-1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以启动一个一次性的pod用 nslookup 命令，解析一下 Pod 对应的 Headless Service：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh
$ nslookup web-0.nginx
Server:    10.68.0.2
Address 1: 10.68.0.2 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 172.20.0.56 web-0.nginx.default.svc.cluster.local

$ nslookup web-1.nginx
Server:    10.68.0.2
Address 1: 10.68.0.2 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 172.20.0.57 web-1.nginx.default.svc.cluster.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们删除了这两个pod，然后观察pod情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete pod -l app=nginx

$ kubectl get pod -w -l app=nginx
web-0   1/1     Terminating   0          83m
web-1   1/1     Terminating   0          83m
web-0   0/1     Pending       0          0s
web-1   0/1     Terminating   0          83m
web-0   0/1     ContainerCreating   0          0s
web-0   1/1     Running             0          1s
web-1   0/1     Pending             0          0s
web-1   0/1     ContainerCreating   0          0s
web-1   1/1     Running             0          1s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们把这两个 Pod 删除之后，Kubernetes 会按照原先编号的顺序，创建出了两个新的 Pod。并且，Kubernetes 依然为它们分配了与原来相同的“网络身份”：web-0.nginx 和 web-1.nginx。&lt;/p&gt;
&lt;p&gt;但是网络结构虽然没变，但是pod对应的ip是改变了的，我们再进入到pod进行DNS解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ nslookup web-0.nginx
Server:    10.68.0.2
Address 1: 10.68.0.2 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 172.20.0.59 web-0.nginx.default.svc.cluster.local

$ nslookup web-1.nginx
Server:    10.68.0.2
Address 1: 10.68.0.2 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 172.20.0.60 web-1.nginx.default.svc.cluster.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;存储状态&quot;&gt;存储状态&lt;/h3&gt;
&lt;p&gt;在讲存储状态的时候，需要大家掌握上一节有关pv和pvc的知识才好往下继续，建议大家看完再来看本节。&lt;/p&gt;
&lt;p&gt;在上一节中，我们了解到Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。而 PVC、PV 的设计，也使得 StatefulSet 对存储状态的管理成为了可能。&lt;/p&gt;
&lt;p&gt;比如我们声明一个如下的StatefulSet：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: &quot;nginx&quot;
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.9.1
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: local-volume-a
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: local-volume-a
    spec:
      accessModes:
      - ReadWriteMany
      storageClassName: &quot;local-volume&quot;
      resources:
        requests:
          storage: 512Mi
      selector:
        matchLabels:
          key: local-volume-a-0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个StatefulSet中添加了volumeClaimTemplates字段，用来声明对应的PVC的定义；也就是说这个PVC中使用的storageClass必须是local-volume，需要的存储空间是512Mi，并且这个pvc对应的pv的标签必须是key: local-volume-a-0。&lt;/p&gt;
&lt;p&gt;然后我们准备一个PV：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-volume-pv-0
  labels:
    key: local-volume-a-0
spec:
  capacity:
    storage: 0.5Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-volume
  local:
    path: /mnt/disks/vol1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我把这个PV创建在node1节点上，并且将本地磁盘挂载声明为PV。&lt;/p&gt;
&lt;p&gt;然后我们创建这个PV：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f local-pv-web-0.yaml

$ kubectl get pv
NAME                CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM
               STORAGECLASS   REASON   AGE
local-volume-pv-0   512Mi      RWX            Retain           Available       default/local-vo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在创建这个StatefulSet的时候，会自动创建PVC：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl apply -f statefulset2.yaml

$ kubectl get pvc
NAME                   STATUS   VOLUME              CAPACITY   ACCESS MODES   STORAGECLASS   AGE
local-volume-a-web-0   Bound    local-volume-pv-0   512Mi      RWX            local-volume   15m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建的PVC名字都是由：&amp;lt;PVC 名字 &amp;gt;-&amp;lt;StatefulSet 名字 &amp;gt;-&amp;lt; 编号 &amp;gt;构成，编号从0开始，并且我们可以看到上面的PV已经处于Bound&lt;strong&gt;状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个时候我们进入到Pod中，写入一个文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl exec -it web-0  -- /bin/bash

$ echo helloword &amp;gt;/usr/share/nginx/html/index.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就会在Pod 的 Volume 目录里写入一个文件，如果我们把这个Pod删除，那么在被删除之后这个Pod还是会被创建出来，并且还会再和原来的PV：local-volume-pv-0绑定起来。&lt;/p&gt;
&lt;p&gt;也就是说当StatefulSet 控制器发现一个名叫 web-0 的 Pod 消失了的时候，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。并且删除Pod时并不会删除这个 Pod 对应的 PVC 和 PV。需要注意的是，在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作local-volume-a-web-0。&lt;/p&gt;
&lt;p&gt;通过这种方式，Kubernetes 的 StatefulSet 就实现了对应用存储状态的管理。&lt;/p&gt;
&lt;h3 id=&quot;更新策略&quot;&gt;更新策略&lt;/h3&gt;
&lt;p&gt;在 Kubernetes 1.7 及之后的版本中，可以为 StatefulSet 设定 &lt;code&gt;.spec.updateStrategy&lt;/code&gt; 字段。&lt;/p&gt;
&lt;h4 id=&quot;ondelete&quot;&gt;OnDelete&lt;/h4&gt;
&lt;p&gt;如果 StatefulSet 的 &lt;code&gt;.spec.updateStrategy.type&lt;/code&gt; 字段被设置为 OnDelete，当您修改 &lt;code&gt;.spec.template&lt;/code&gt; 的内容时，StatefulSet Controller 将不会自动更新其 Pod。您必须手工删除 Pod，此时 StatefulSet Controller 在重新创建 Pod 时，使用修改过的 &lt;code&gt;.spec.template&lt;/code&gt; 的内容创建新 Pod。&lt;/p&gt;
&lt;p&gt;例如我们执行下面的语句更新上面例子中创建的web：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl set image statefulset web nginx=nginx:1.18.0

$ kubectl describe pod web-0
....
Containers:
  nginx:
    Container ID:   docker://7e45cd509db74a96b4f6ca4d9f7424b3c4794f56e28bfc3fbf615525cd2ecadb
    Image:          nginx:1.9.1
....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们发现pod的nginx版本并没有发生改变，需要我们手动删除pod之后才能生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl delete pod web-0
pod &quot;web-0&quot; deleted

$ kubectl describe pod web-0
...
Containers:
  nginx:
    Container ID:   docker://0f58b112601a39f3186480aa97e72767b05fdfa6f9ca02182d3fb3b75c159ec0
    Image:          nginx:1.18.0
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;rolling-updates&quot;&gt;Rolling Updates&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;.spec.updateStrategy.type&lt;/code&gt; 字段的默认值是 RollingUpdate，该策略为 StatefulSet 实现了 Pod 的自动滚动更新。在更新完&lt;code&gt;.spec.tempalte&lt;/code&gt; 字段后StatefulSet Controller 将自动地删除并重建 StatefulSet 中的每一个 Pod。&lt;/p&gt;
&lt;p&gt;删除和重建的顺序也是有讲究的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除的时候从序号最大的开始删，每删除一个会更新一个。&lt;/li&gt;
&lt;li&gt;只有更新完的pod已经是ready状态了才往下继续更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;为-rollingupdate-进行分区&quot;&gt;为 RollingUpdate 进行分区&lt;/h4&gt;
&lt;p&gt;当为StatefulSet 的 &lt;code&gt;RollingUpdate&lt;/code&gt; 字段的指定 &lt;code&gt;partition&lt;/code&gt; 字段的时候，则所有序号大于或等于 &lt;code&gt;partition&lt;/code&gt; 值的 Pod 都会更新。序号小于 &lt;code&gt;partition&lt;/code&gt; 值的所有 Pod 都不会更新，即使它们被删除，在重新创建时也会使用以前的版本。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;partition&lt;/code&gt; 值大于其 &lt;code&gt;replicas&lt;/code&gt; 数，则更新不会传播到其 Pod。这样可以实现金丝雀发布Canary Deploy或者灰度发布。&lt;/p&gt;
&lt;p&gt;如下，因为我们的web是2个pod组成，所以可以将&lt;code&gt;partition&lt;/code&gt;设置为1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl patch statefulset web -p '{&quot;spec&quot;:{&quot;updateStrategy&quot;:{&quot;type&quot;:&quot;RollingUpdate&quot;,&quot;rollingUpdate&quot;:{&quot;partition&quot;:1}}}}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我使用了 kubectl patch 命令。它的意思是，以“补丁”的方式（JSON 格式的）修改一个 API 对象的指定字段。&lt;/p&gt;
&lt;p&gt;下面我们执行更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl set image statefulset  web nginx=nginx:1.19.1
statefulset.apps/web image updated
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在另一个终端中watch pod的变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ kubectl get pods -l app=nginx -w
NAME    READY   STATUS    RESTARTS   AGE
web-0   1/1     Running   0          13m
web-1   1/1     Running   0          93s
web-1   0/1     Terminating   0          2m16s
web-1   0/1     Pending       0          0s
web-1   0/1     ContainerCreating   0          0s
web-1   1/1     Running             0          16s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见上面只有一个web-1进行了版本的发布。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;StatefulSet把有状态的应用抽象为两种情况：拓扑状态和存储状态。&lt;/p&gt;
&lt;p&gt;拓扑状态指的是应用的多个实例之间不是完全对等的关系，包含启动的顺序、创建之后的网络标识等必须保证。&lt;/p&gt;
&lt;p&gt;存储状态指的是不同的实例绑定了不同的存储，如Pod A在它的生命周期中读取的数据必须是一致的，哪怕是重启之后还是需要读取到同一个存储。&lt;/p&gt;
&lt;p&gt;然后讲解了一下StatefulSet发布更新该如何做，&lt;code&gt;updateStrategy&lt;/code&gt;策略以及通过&lt;code&gt;partition&lt;/code&gt;如果实现金丝雀发布等。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 14:14:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>转载请声明出处哦~，本篇文章发布于luozhiyun的博客：https://www.luozhiyun.com 在上一篇中，讲解了容器持久化存储，从中我们知道什么是PV和PVC，这一篇我们讲通过Sta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/13455528.html</dc:identifier>
</item>
<item>
<title>Kubeflow实战: 入门介绍与部署实践 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/13455513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/13455513.html</guid>
<description>&lt;blockquote readability=&quot;2.906976744186&quot;&gt;
&lt;p&gt;更多内容关注专辑:&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU1NjY0NTQxNw==&amp;amp;action=getalbum&amp;amp;album_id=1461769020725985283&amp;amp;subscene=159&amp;amp;subscene=21&amp;amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU1NjY0NTQxNw%3D%3D%26mid%3D2247484864%26idx%3D1%26sn%3Dc92d1a457f22c2d422e1f0f82c70e6d7%26chksm%3Dfbc0a886ccb7219078a7845d59fa414bf64149edd4f6b46e79181c8e888c8339155a65dcc369%26scene%3D21%23wechat_redirect#wechat_redirect&quot;&gt;机器学习实战&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kubeflow是在k8s平台之上针对机器学习的开发、训练、优化、部署、管理的工具集合，内部集成的方式融合机器学习中的很多领域的开源项目，比如Jupyter、tfserving、Katib、Fairing、Argo等。可以针对机器学习的不同阶段：数据预处理、模型训练、模型预测、服务管理等进行管理。只要安装了k8s，可以在本地、机房、云环境中部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220412127-172022411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;机器学习的目标最终还是为了在生产环境或者业务场景中使用，但这个过程却是很复杂的，需要进行数据加载、切分、预处理、特征工程、模型训练、验证、超参数调优、模型部署等等；为了正常使用模型，还需要在模型上线后，持续不断的输入数据才能得到预测的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220521499-1108546346.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人工构建整个过程并进行维护是很复杂的，使用Kubeflow可以节省很多成本。比如在构建模型时，可以选择你喜欢的算法框架进行模型开发，试验阶段可以通过Jupyter进行交互式的编程，基于Pipeline构建整个训练过程的工作流实现各种处理逻辑，基于Katib进行超参数的自动优化；生产环境中，可以使用TFJob等进行分布式训练，基于KFServing等进行在线模型的服务，基于Metadata或TensorBoard进行模型的监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220537431-1319765050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;扩展性：Kf基于k8s可以达到可扩展、可移植、分布式ML平台， 通过Kf你可以轻松管理整个AI生命周期，比如在模型部署的时候自动进行扩容、在试验阶段自由创建笔记本。由于底层基于K8s来提供一致性与高可靠，使用者可以更聚焦于上层的算法模型设计，而不用过多的关注底层构建。&lt;/p&gt;
&lt;p&gt;迭代性：构建高质量的机器学习模型可能需要快速的迭代，Kf提供友好的UI界面支持快速追踪对比实验结果，你可以很方便的决定哪个模型训练效果更好。Kf内部提供Jupyter笔记本，支持如Tensorflow、Pytorch等流行的深度学习框架。模型训练配置简单，方便进行分布式训练、部署，提升端到端的开发过程。&lt;/p&gt;
&lt;p&gt;混合性：机器学习模型的训练可能涉及多个团队、多个集群和云环境的共享，Kf支持主流的云平台，提供各个环境之间的移植性。你可以在本地开发模型、在集群的GPU上进行训练、最后部署到云环境中，快速的开发模式和高效的部署使得整个过程就像单机操作一样。&lt;/p&gt;
&lt;p&gt;超参调优：在模型训练中，超参数调优是很关键也很复杂的过程，对模型最终的准确度和性能有很大的影响，手动尝试各种超参数的组合非常浪费时间。Kf通过Katib来支持自动超参数优化，这种自动优化会节省大量的计算时间，提高模型优化的效率。&lt;/p&gt;
&lt;p&gt;持续集成：Kf目前并没有这个方面成型的产品，但是可以通过Pipeline组件来实现。Pipeline支持创建可重复的工作流，可以自动触发整个工作流的重跑以及模型的训练。&lt;/p&gt;

&lt;p&gt;Kubeflow的部署其实很简单，主要是依赖的镜像大多出自Google因此会遇到很多网络问题。解决办法推荐是通过阿里云镜像手动下载docker镜像，然后tag成目标镜像；或者直接修改kustomize中的镜像地址。&lt;/p&gt;
&lt;p&gt;安装时需要下载kfctl并按照文档配置环境变量，比如我试过Ubuntu 18，可以参考下面的文档：&lt;a href=&quot;https://www.kubeflow.org/docs/started/k8s/kfctl-k8s-istio/%EF%BC%8C%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A&quot;&gt;https://www.kubeflow.org/docs/started/k8s/kfctl-k8s-istio/，大致流程如下：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 到地址中下载对应的kfctl，darwin为mac，linux为其他，不支持windows
https://github.com/kubeflow/kfctl/releases/tag/v1.0.2

2 压缩包解压缩
tar -xvf kfctl_v1.0.2_&amp;lt;platform&amp;gt;.tar.gz

3 配置环境变量 vi /etc/profile
export PATH=$PATH:&quot;&amp;lt;path-to-kfctl&amp;gt;&quot;
export KF_NAME=&amp;lt;自定义名称&amp;gt;
export BASE_DIR=&amp;lt;path to a base directory&amp;gt;
export KF_DIR=${BASE_DIR}/${KF_NAME}
export CONFIG_URI=&quot;https://raw.githubusercontent.com/kubeflow/manifests/v1.0-branch/kfdef/kfctl_k8s_istio.v1.0.2.yaml&quot;

4 更新环境变量
source /etc/profile

5 执行命令
mkdir -p ${KF_DIR}
cd ${KF_DIR}
kfctl apply -V -f ${CONFIG_URI}

6 查看安装服务
kubectl -n kubeflow get all
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个安装过程很缓慢，尤其是前期需要安装cert-manager进行权限控制，需要等服务正常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220714804-1803233305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间会有大量的镜像报错ImagePullBackOff，这表示镜像拉取失败。解决办法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 查看具体pod的详情
kubectl describe pod admission-webhook-bootstrap-stateful-set-0 -n kubeflow

2 去阿里云镜像站搜索镜像
docker pull registry.cn-hangzhou.aliyuncs.com/pigeonw/ingress-setup

3 重命名
sudo docker tag registry.cn-hangzhou.aliyuncs.com/pigeonw/ingress-setup:latest gcr.io/kubeflow-images-public/ingress-setup:latest

4 修改kustomize中的配置
cd ./kustomize/webhook/base
sudo vim deployment.yaml
修改镜像拉取策略
imagePullPolicy: IfNotPresent
原来如果是Always表示总是会去拉取远程镜像，IfNotPresent表示本地不存在时才会拉取

5 修改完成后等待一会，如果状态还没有变成Running，可以执行
kfctl apply -f kfctlxxx.yaml 重新创建
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都部署成功后，大致可以看到如下的运行状态，仅供参考：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220811110-290595824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220819028-1664814615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220829144-1299678228.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;部署成功后，通过端口映射可以支持在外部访问：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export NAMESPACE=istio-system
kubectl port-forward --address 0.0.0.0 -n ${NAMESPACE} svc/istio-ingressgateway 8080:80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后访问目标地址即可，如localhost:8080，自定义namespace后可以看到如下画面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/449064/202008/449064-20200807220745379-343858210.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面将会分享Notebook、Pipeline、Katib等的使用，感谢关注。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 14:10:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<og:description>更多内容关注专辑: 机器学习实战 1 介绍 Kubeflow是在k8s平台之上针对机器学习的开发、训练、优化、部署、管理的工具集合，内部集成的方式融合机器学习中的很多领域的开源项目，比如Jupyter</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xing901022/p/13455513.html</dc:identifier>
</item>
<item>
<title>Web测试转App测试不看不知道 - 东方er</title>
<link>http://www.cnblogs.com/df888/p/13455464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13455464.html</guid>
<description>&lt;p&gt;Web通常指的是互联网应用系统，比如税务电子化征管档案系统、金融数据平台、餐饮商家管理后台等等，其实质是C/S的程序。&lt;/p&gt;
&lt;p&gt;C是Client——客户端，S是Server——服务器。&lt;/p&gt;
&lt;p&gt;Web中的客户端一般指的是Browser——浏览器，也就是B/S。&lt;/p&gt;
&lt;p&gt;Web系统有三层结构 == 表示层 + 业务层 + 数据层。&lt;/p&gt;
&lt;p&gt;MVC软件设计模式也是三层 == 模型 + 视图 + 控制器。&lt;/p&gt;
&lt;p&gt;它们的对应关系如下，不完全准确，简单意会意会即可，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202008/1629545-20200807215913903-1526355188.jpg&quot; alt=&quot;1593469587793_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试的一个重要思路是，了解被测对象的架构，Web系统典型架构如图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202008/1629545-20200807215914255-1744798062.jpg&quot; alt=&quot;1593470884765_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图很重要，多看几秒！想想这些问题，&lt;/p&gt;
&lt;p&gt;我测试覆盖的是哪些地方？&lt;/p&gt;
&lt;p&gt;有哪些环节是漏掉的？&lt;/p&gt;
&lt;p&gt;浏览器从请求到响应，这个过程是怎样一个链路？&lt;/p&gt;
&lt;h2 id=&quot;测试难点&quot;&gt;测试难点&lt;/h2&gt;
&lt;p&gt;Web测试，不仅仅是页面的点点点。&lt;/p&gt;
&lt;p&gt;面对这样复杂的系统，如何保障质量，使系统健康的、长期的、稳定的运行，是测试的难点。&lt;/p&gt;
&lt;p&gt;业务复杂度本身就是难点，而且这是测试核心中的核心。&lt;/p&gt;
&lt;p&gt;安全、性能的评估，也是一个棘手的难点。&lt;/p&gt;
&lt;p&gt;网站用户的能力，包括浏览器、操作系统、设备、网络带宽都可能是参差不齐。&lt;/p&gt;
&lt;p&gt;网络中断，或弱网情况下，网站的表现。&lt;/p&gt;
&lt;p&gt;网站本身的应用日志、系统资源、冷热数据。&lt;/p&gt;
&lt;p&gt;引入的第三方程序的质量，虽然可以直接用，但仍需做黑盒测试。&lt;/p&gt;
&lt;p&gt;国际化差异，如语言、时差、货币兑换。&lt;/p&gt;
&lt;p&gt;你要考虑的不是一个点，也不是一个面，而是一个整体。&lt;/p&gt;
&lt;h2 id=&quot;表示层&quot;&gt;表示层&lt;/h2&gt;
&lt;p&gt;表示层的测试对象包括了，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UI（User Interface）用户界面&lt;/li&gt;
&lt;li&gt;UE（User Experience）用户体验&lt;/li&gt;
&lt;li&gt;UED（User-Experience Design）用户体验设计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简而言之就是，系统的外观和感觉。&lt;/p&gt;
&lt;p&gt;更专业具体点，就是整体审美、字体、链接跳转、图形分辨率和大小、色彩、拼写检查、文字语法和风格、光标位置、选中默认按钮、交互操作体验友好、商业特定术语和风格、确认框、浏览器版本、操作系统配置等。&lt;/p&gt;
&lt;p&gt;表示层的测试主要以人工为主，部分测试也可以通过工具完成，如无效链接检测。&lt;/p&gt;
&lt;h2 id=&quot;业务层&quot;&gt;业务层&lt;/h2&gt;
&lt;p&gt;业务层包括内部业务和外部服务，内部业务和外部服务都需要经过测试。&lt;/p&gt;
&lt;p&gt;内部业务就是实实在在的业务，每个公司的业务都有差异。&lt;/p&gt;
&lt;p&gt;业务测试是贯穿于测试周期自始始终的。&lt;/p&gt;
&lt;p&gt;最开始测试考虑的是业务，测试结束考虑的也还是业务。&lt;/p&gt;
&lt;p&gt;业务层测试是用到测试用例设计方法最多的，包括等价类划分、边界值、判定表、因果分析、场景法等。&lt;/p&gt;
&lt;p&gt;同时也需要做性能测试，考察响应时间、吞吐率等性能指标。&lt;/p&gt;
&lt;p&gt;毫不夸张的说，无业务，不测试！&lt;/p&gt;
&lt;h2 id=&quot;数据层&quot;&gt;数据层&lt;/h2&gt;
&lt;p&gt;数据层主要干的事就是读写数据。&lt;/p&gt;
&lt;p&gt;数据层的数据既包括系统自产的，也包括从用户收集来的数据。&lt;/p&gt;
&lt;p&gt;数据是存放在数据库服务器里边的，包括RDBMS、NoSQL。&lt;/p&gt;
&lt;p&gt;数据模型定义了数据层接口和数据存储方式。&lt;/p&gt;
&lt;p&gt;数据可以直接使用，但往往是经过了ETL对数据进行加工。&lt;/p&gt;
&lt;p&gt;数据层的测试是有一些门槛的，但一些隐藏的bug就藏在这一层。&lt;/p&gt;
&lt;p&gt;首先需要测试的是数据存储的正确，其次需要测试冗余数据的清理，还有数据状态的变化。&lt;/p&gt;
&lt;p&gt;数据库的性能，sql的耗时，数据量大小，数据冷热。&lt;/p&gt;
&lt;p&gt;数据库的数据类型，长度、精度、字符集、日期时间格式、时区等。&lt;/p&gt;
&lt;p&gt;数据库的安全，数据加密和安全性。&lt;/p&gt;
&lt;p&gt;还有数据库的鲁棒性，故障处理，备份恢复能力，最大化MTBF，最小化MTTR。&lt;/p&gt;

&lt;h2 id=&quot;网络&quot;&gt;网络&lt;/h2&gt;
&lt;p&gt;App测试还是从架构入手，先看看App的典型的无线运营商网络架构，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202008/1629545-20200807215914588-588552643.png&quot; alt=&quot;2020-07-28_211128_副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;移动网络，是App区别于Web应用的重要差异。&lt;/p&gt;
&lt;p&gt;移动网络的通信协议并不是基于IP的，而通常是一种基于射频的协议。&lt;/p&gt;
&lt;p&gt;如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CDMA（Code Division Multiple Access）码分多址&lt;/li&gt;
&lt;li&gt;TDMA（Time Division Multiple Access）时分多址&lt;/li&gt;
&lt;li&gt;GSM（Global System for Mobile）全球移动通信系统&lt;/li&gt;
&lt;li&gt;4G （the 4th generation mobile communication technology）第四代移动通信技术&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多运营商都使用某种代码转换器或Web代理来进行移动设备与互联网的通信。但是因为竞争的关系，运营商一般不会披露这些细节。他们可能会“偷偷”干这些事，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将数据转换成WAP或HTTP支持的格式&lt;/li&gt;
&lt;li&gt;压缩数据为了更快地传输和提高吞吐量&lt;/li&gt;
&lt;li&gt;数据传输加密和隐私保护&lt;/li&gt;
&lt;li&gt;屏蔽一些占用过高带宽的站点&lt;/li&gt;
&lt;li&gt;从网页中抽取HTML头信息和其他元数据以供程序使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;WAP，是指Wireless Application Protocal，无线应用协议，已经过时。&lt;/p&gt;
&lt;p&gt;现在大多数都使用HTTP协议了。&lt;/p&gt;
&lt;p&gt;正是由于移动网络的存在，以及不同使用场景下网络状态的不稳定，在测App时，需要做弱网测试。&lt;/p&gt;
&lt;p&gt;弱网包括无网（断网）、弱网（2G 3G 4G）、网络切换。&lt;/p&gt;
&lt;h2 id=&quot;设备&quot;&gt;设备&lt;/h2&gt;
&lt;p&gt;App测试和Web测试，另外一个明显的区别就是，移动设备非常丰富。&lt;/p&gt;
&lt;p&gt;不同的机型。不同的屏幕。不同的版本。不同的系统。不同的CPU内存。不同的浏览器。不同的配置。&lt;/p&gt;
&lt;p&gt;App是To C的，也就意味着使用环境无法统一控制，是千差万别的。&lt;/p&gt;
&lt;p&gt;这对测试来说是很大的挑战，以至于有漫画调侃，高级测试工程师，可以转行卖手机了！&lt;/p&gt;
&lt;p&gt;不过好在有模拟器，有云测平台，减少了测试设备兼容性的成本。&lt;/p&gt;
&lt;p&gt;模拟器也不是银弹，不能替代真机，所以App必须在真机上面跑过才算ok。&lt;/p&gt;
&lt;p&gt;真机和模拟器，各有利弊，需要做必要的权衡。&lt;/p&gt;
&lt;p&gt;可以先用模拟器完成大量测试，最后使用真机做验收。&lt;/p&gt;
&lt;p&gt;用真机测试还需要注意的一个小问题就是，测试用例设计的尽量有效，不然每一次重复测试，就很可能在燃烧你的经费。&lt;/p&gt;
&lt;h2 id=&quot;测试方法&quot;&gt;测试方法&lt;/h2&gt;
&lt;p&gt;App测试和Web测试有很多共同的地方，尤其是业务层和数据层。&lt;/p&gt;
&lt;p&gt;不过由于网络和设备等因素，让App测试也有一些特殊的场景，&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;测试分类&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;安装/卸载&lt;/td&gt;
&lt;td&gt;确保用户可以正确的安装应用程序&lt;br/&gt;确保用户可以完全卸载应用程序&lt;br/&gt;测试安装中断后能否恢复正常&lt;br/&gt;测试卸载能否中断&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;网络基础设施&lt;/td&gt;
&lt;td&gt;证实应用程序在网络丢失的情况能够正确响应&lt;br/&gt;证实应用程序能够正确响应网络回复的情况&lt;br/&gt;证实应用程序能够在网络信号差的情况下正确响应&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;来电和短信处理&lt;/td&gt;
&lt;td&gt;测试用户能够在应用程序运行的情况下接电话以及回短信&lt;br/&gt;测试用户能够在处理完来电和短信之后能否返回应用程序&lt;br/&gt;测试用户能否在不中断应用的情况下取消来电和短信&lt;br/&gt;测试用户能否在不退出应用程序的条件下拨打电话和短信&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;内存不足&lt;/td&gt;
&lt;td&gt;确保应用程序在设备内存不足的情况下仍然能够稳定工作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;按键&lt;/td&gt;
&lt;td&gt;测试所有的热键按照产品规格书实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;退出&lt;/td&gt;
&lt;td&gt;检查程序能够正常退出（通过按键合屏或滑块锁屏）&lt;br/&gt;确保在机器关闭的情况下应用程序的行为和设计规格说明书上一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;充电&lt;/td&gt;
&lt;td&gt;确保程序在切换到充电模式时工作正常&lt;br/&gt;确保程序能够在充电状态下正常工作&lt;br/&gt;确保程序在退出充电模式时不会发生异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;电量&lt;/td&gt;
&lt;td&gt;测试在电量不足的情况下应用程序的行为表现&lt;br/&gt;计算应用程序将用多长时间耗尽电量&lt;br/&gt;确保在电池突然拔出的情况下应用程序的反应和说明书一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;硬件资源&lt;/td&gt;
&lt;td&gt;确保应用程序没有过度占用CPU&lt;br/&gt;确保应用程序不消耗过多的内存资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;升级&lt;/td&gt;
&lt;td&gt;确保静默升级、提示升级、强制升级情况下升级成功&lt;br/&gt;确保补丁包、全量包升级成功&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;B2B、B2C、C2C、O2O是电子商务的4种模式。&lt;/p&gt;
&lt;p&gt;B2B，Business to Business，企业对企业，如经销商销货给超市。&lt;/p&gt;
&lt;p&gt;B2C，Business to Customer，企业对个人，如超市卖东西。&lt;/p&gt;
&lt;p&gt;C2C，Customer to Customer，个人对个人，如摆地摊。&lt;/p&gt;
&lt;p&gt;O2O，Online to Offline，线上到线下，如网上点个豆浆早餐到肯德基取。&lt;/p&gt;
&lt;p&gt;B端--&amp;gt;企业端。&lt;/p&gt;
&lt;p&gt;C端--&amp;gt;个人端。&lt;/p&gt;
&lt;p&gt;G端--&amp;gt;政府端。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考资料&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;——《软件测试的艺术》&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;专注测试，坚持原创，只做精品。欢迎关注公众号『东方er』&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：本文为博主原创文章，转载请保留原文链接及作者。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Aug 2020 14:01:00 +0000</pubDate>
<dc:creator>东方er</dc:creator>
<og:description>Web测试 Web通常指的是互联网应用系统，比如税务电子化征管档案系统、金融数据平台、餐饮商家管理后台等等，其实质是C/S的程序。 C是Client——客户端，S是Server——服务器。 Web中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13455464.html</dc:identifier>
</item>
<item>
<title>基于Asp.net Core 3.1实现的Redis及MemoryCache缓存助手CacheHelper - 菜工</title>
<link>http://www.cnblogs.com/caijt/p/13455471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caijt/p/13455471.html</guid>
<description>&lt;p&gt;这几天在面试，这个关于Redis缓存的博客一直没空写，今天总算有点时间了。&lt;/p&gt;

&lt;p&gt;从很久很久之前，我就一直想学Redis了，反正看到各大招聘网上都要求Redis，不学就太落后了。&lt;/p&gt;
&lt;p&gt;一开始我是按&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed?view=aspnetcore-3.1&quot; target=&quot;_blank&quot;&gt;微软官网文档&lt;/a&gt;那样配置的，然后发现这也太简单了，不止配置简单，连使用都这么简单，简单得有点过分。如下图所示，它是基于IDistributedCache接口注入的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/648126/202008/648126-20200807211055727-899949258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么简单，怎么玩，我连判断某个key值存不存在都没办法。&lt;/p&gt;

&lt;p&gt;当然了。绝对不是这么简单的。更高级的用法如下，要引入Microsoft.Extensions.Caching.StackExchangeRedis包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ConnectionMultiplexer connection =&lt;span&gt; ConnectionMultiplexer.Connect(&lt;span&gt;&quot;&lt;span&gt;&lt;span&gt;127.0.0.1:6379&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;);
IDatabase&lt;/span&gt; cache = connection.GetDatabase(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
cache.HashSet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hashKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
cache.SetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那要怎么用在系统里呢，当然直接使用IDatabase也可以，但不够优雅，而且我还想通过配置文件，来决定是否启用Redis，如果不启用的话，就使用MemoryCache。非常好。想法有了。&lt;/p&gt;
&lt;p&gt;先定义一个接口ICacheHelper，这是用来注入的接口，我暂时只定义了string类型跟hash类型的缓存方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICacheHelper
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Exists(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Set&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, T value);

    T Get&lt;/span&gt;&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);


    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, DateTime dateTime);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, TimeSpan timeSpan);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; HashSet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt; hashKey, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; hashValue);
    T HashGet&lt;/span&gt;&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey);

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; HashExists(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; HashDelete(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后用Redis实现这个接口，RedisCacheHelper类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Redis助手
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCacheHelper : ICacheHelper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IDatabase _cache;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ConnectionMultiplexer _connection;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _instance;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisCacheHelper(RedisCacheOptions options, &lt;span&gt;int&lt;/span&gt; database = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        _connection &lt;/span&gt;=&lt;span&gt; ConnectionMultiplexer.Connect(options.Configuration);
        _cache &lt;/span&gt;=&lt;span&gt; _connection.GetDatabase(database);
        _instance &lt;/span&gt;=&lt;span&gt; options.InstanceName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exists(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.KeyExists(_instance +&lt;span&gt; key);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, T value)
    {
        _cache.StringSet(_instance &lt;/span&gt;+&lt;span&gt; key, CommonHelper.ObjectToJsonString(value));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CommonHelper.JsonStringToObject&amp;lt;T&amp;gt;(_cache.StringGet(_instance +&lt;span&gt; key));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        _cache.KeyDelete(_instance &lt;/span&gt;+&lt;span&gt; key);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, DateTime dateTime)
    {
        _cache.KeyExpire(_instance &lt;/span&gt;+&lt;span&gt; key, dateTime);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, TimeSpan timeSpan)
    {
        _cache.KeyExpire(_instance &lt;/span&gt;+&lt;span&gt; key, timeSpan);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HashSet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt; hashKey, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; hashValue)
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; value =&lt;span&gt; CommonHelper.ObjectToJsonString(hashValue);
        _cache.HashSet(_instance &lt;/span&gt;+&lt;span&gt; key, hashKey, value);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T HashGet&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = _cache.HashGet(_instance +&lt;span&gt; key, hashKey);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CommonHelper.JsonStringToObject&amp;lt;T&amp;gt;&lt;span&gt;(value);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; HashGet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey, Type type)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = _cache.HashGet(_instance +&lt;span&gt; key, hashKey);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CommonHelper.JsonStringToObject(value, type);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HashExists(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.HashExists(_instance +&lt;span&gt; key, hashKey);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HashDelete(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        _cache.HashDelete(_instance &lt;/span&gt;+&lt;span&gt; key, hashKey);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再用MemoryCache实现接口，MemoryCacheHelper类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓存助手
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MemoryCacheHelper : ICacheHelper
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IMemoryCache _cache;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MemoryCacheHelper(IMemoryCache cache)
    {
        _cache &lt;/span&gt;=&lt;span&gt; cache;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exists(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; _);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.Get&amp;lt;T&amp;gt;&lt;span&gt;(key);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        _cache.Remove(key);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, T value)
    {
        _cache.Set(key, value);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, DateTime dateTime)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; _cache.Get(key);
        _cache.Set(key, value, dateTime);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Expire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, TimeSpan timeSpan)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; _cache.Get(key);
        _cache.Set(key, value, timeSpan);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HashSet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt; hashKey, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; hashValue)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hash = _cache.Get&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hash.ContainsKey(hashKey))
        {
            hash[key] &lt;/span&gt;=&lt;span&gt; hashValue;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            hash.Add(hashKey, hashValue);
        }
        _cache.Set&lt;/span&gt;&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(key, hash);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T HashGet&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hash = _cache.Get&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hash.ContainsKey(hashKey))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T)hash[hashKey];
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HashExists(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hash = _cache.Get&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hash.ContainsKey(hashKey);
    }



    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HashDelete(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; hashKey)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hash = _cache.Get&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hash.ContainsKey(hashKey))
        {
            hash.Remove(hashKey);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现类都有了，那现在就来实现根据配置值来决定是否使用Redis还是MemoryCache，先在appsettings.json里添加这个配置值，当Enable为false时，就不启用Redis，使用MemoryCache，Connection是Redis的连接字符串，InstanceName是缓存的前缀，Database是使用哪个数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InstanceName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LessSharp:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再定义一个选项类 RedisOption&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisOption
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Enable { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Connection { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; InstanceName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Database { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在Startup.cs类里的ConfigureServices里根据配置值进行注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; RedisConfiguration = Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
services.Configure&lt;/span&gt;&amp;lt;RedisOption&amp;gt;&lt;span&gt;(RedisConfiguration);
RedisOption redisOption &lt;/span&gt;= RedisConfiguration.Get&amp;lt;RedisOption&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (redisOption != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; redisOption.Enable)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisCacheOptions
    {
        InstanceName &lt;/span&gt;=&lt;span&gt; redisOption.InstanceName,
        Configuration &lt;/span&gt;=&lt;span&gt; redisOption.Connection
     };
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisCacheHelper(options, redisOption.Database);
     services.AddSingleton(redis);
     services.AddSingleton&lt;/span&gt;&amp;lt;ICacheHelper&amp;gt;&lt;span&gt;(redis);
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
{
      services.AddMemoryCache();
      services.AddScoped&lt;/span&gt;&amp;lt;ICacheHelper, MemoryCacheHelper&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，测试后完美&lt;/p&gt;

</description>
<pubDate>Fri, 07 Aug 2020 14:01:00 +0000</pubDate>
<dc:creator>菜工</dc:creator>
<og:description>这几天在面试，这个关于Redis缓存的博客一直没空写，今天总算有点时间了。 从很久很久之前，我就一直想学Redis了，反正看到各大招聘网上都要求Redis，不学就太落后了。 一开始我是按微软官网文档那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/caijt/p/13455471.html</dc:identifier>
</item>
</channel>
</rss>