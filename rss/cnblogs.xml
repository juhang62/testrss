<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud Alibaba | 微服务分布式事务之Seata - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11504210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11504210.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;本篇实战所使用Spring有关版本：&lt;/p&gt;
&lt;p&gt;SpringBoot:2.1.7.RELEASE&lt;/p&gt;
&lt;p&gt;Spring Cloud:Greenwich.SR2&lt;/p&gt;
&lt;p&gt;Spring CLoud Alibaba:2.1.0.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;在构建微服务的过程中，不管是使用什么框架、组件来构建，都绕不开一个问题，跨服务的业务操作如何保持数据一致性。&lt;/p&gt;
&lt;h2 id=&quot;什么是分布式事务&quot;&gt;2. 什么是分布式事务？&lt;/h2&gt;
&lt;p&gt;首先，设想一个传统的单体应用，无论多少内部调用，最后终归是在同一个数据库上进行操作来完成一向业务操作，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083359133-818142336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着业务量的发展，业务需求和架构发生了巨大的变化，整体架构由原来的单体应用逐渐拆分成为了微服务，原来的3个服务被从一个单体架构上拆开了，成为了3个独立的服务，分别使用独立的数据源，也不在之前共享同一个数据源了，具体的业务将由三个服务的调用来完成，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083359484-1763272904.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，每一个服务的内部数据一致性仍然有本地事务来保证。但是面对整个业务流程上的事务应该如何保证呢？这就是在微服务架构下面临的挑战，如何保证在微服务中的数据一致性。&lt;/p&gt;
&lt;h2 id=&quot;常见的分布式事务解决方案&quot;&gt;3. 常见的分布式事务解决方案&lt;/h2&gt;
&lt;h3 id=&quot;两阶段提交方案xa方案&quot;&gt;3.1 两阶段提交方案/XA方案&lt;/h3&gt;
&lt;p&gt;所谓的 XA 方案，即两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。&lt;/p&gt;
&lt;p&gt;分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有节点不会永久性损坏，即使损坏后仍然可以恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083359767-2126039707.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083400246-1474521639.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcc-方案&quot;&gt;3.2 TCC 方案&lt;/h3&gt;
&lt;p&gt;TCC的全称是：Try、Confirm、Cancel。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。&lt;/li&gt;
&lt;li&gt;Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。&lt;/li&gt;
&lt;li&gt;Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大。&lt;/p&gt;
&lt;p&gt;TCC的理论有点抽象，下面我们借助一个账务拆分这个实际业务场景对TCC事务的流程做一个描述，希望对理解TCC有所帮助。&lt;/p&gt;
&lt;p&gt;业务流程：分别位于三个不同分库的帐户A、B、C，A和B一起向C转帐共80元：&lt;/p&gt;
&lt;p&gt;Try：尝试执行业务。&lt;/p&gt;
&lt;p&gt;完成所有业务检查(一致性)：检查A、B、C的帐户状态是否正常，帐户A的余额是否不少于30元，帐户B的余额是否不少于50元。&lt;/p&gt;
&lt;p&gt;预留必须业务资源(准隔离性)：帐户A的冻结金额增加30元，帐户B的冻结金额增加50元，这样就保证不会出现其他并发进程扣减了这两个帐户的余额而导致在后续的真正转帐操作过程中，帐户A和B的可用余额不够的情况。&lt;/p&gt;
&lt;p&gt;Confirm：确认执行业务。&lt;/p&gt;
&lt;p&gt;真正执行业务：如果Try阶段帐户A、B、C状态正常，且帐户A、B余额够用，则执行帐户A给账户C转账30元、帐户B给账户C转账50元的转帐操作。&lt;/p&gt;
&lt;p&gt;不做任何业务检查：这时已经不需要做业务检查，Try阶段已经完成了业务检查。&lt;/p&gt;
&lt;p&gt;只使用Try阶段预留的业务资源：只需要使用Try阶段帐户A和帐户B冻结的金额即可。&lt;/p&gt;
&lt;p&gt;Cancel：取消执行业务。&lt;/p&gt;
&lt;p&gt;释放Try阶段预留的业务资源：如果Try阶段部分成功，比如帐户A的余额够用，且冻结相应金额成功，帐户B的余额不够而冻结失败，则需要对帐户A做Cancel操作，将帐户A被冻结的金额解冻掉。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-alibaba-seata&quot;&gt;4. Spring Cloud Alibaba Seata&lt;/h2&gt;
&lt;p&gt;Seata 的方案其实一个 XA 两阶段提交的改进版，具体区别如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构的层面&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083400403-33335338.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;XA 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身（通过提供支持 XA 的驱动程序来供应用使用）。&lt;/p&gt;
&lt;p&gt;而 Seata 的 RM 是以二方包的形式作为中间件层部署在应用程序这一侧的，不依赖与数据库本身对协议的支持，当然也不需要数据库支持 XA 协议。这点对于微服务化的架构来说是非常重要的：应用层不需要为本地事务和分布式事务两类不同场景来适配两套不同的数据库驱动。&lt;/p&gt;
&lt;p&gt;这个设计，剥离了分布式事务方案对数据库在 协议支持 上的要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶段提交&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083400605-546849836.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论 Phase2 的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。&lt;/p&gt;
&lt;p&gt;设想一个正常运行的业务，大概率是 90% 以上的事务最终应该是成功提交的，我们是否可以在 Phase1 就将本地事务提交呢？这样 90% 以上的情况下，可以省去 Phase2 持锁的时间，整体提高效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083400739-1619917819.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分支事务中数据的 本地锁 由本地事务管理，在分支事务 Phase1 结束时释放。&lt;/li&gt;
&lt;li&gt;同时，随着本地事务结束，连接 也得以释放。&lt;/li&gt;
&lt;li&gt;分支事务中数据的 全局锁 在事务协调器侧管理，在决议 Phase2 全局提交时，全局锁马上可以释放。只有在决议全局回滚的情况下，全局锁 才被持有至分支的 Phase2 结束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个设计，极大地减少了分支事务对资源（数据和连接）的锁定时间，给整体并发和吞吐的提升提供了基础。&lt;/p&gt;
&lt;h2 id=&quot;seata实战案例&quot;&gt;5. Seata实战案例&lt;/h2&gt;
&lt;h3 id=&quot;目标介绍&quot;&gt;5.1 目标介绍&lt;/h3&gt;
&lt;p&gt;在本节，我们将通过一个实战案例来具体介绍Seata的使用方式，我们将模拟一个简单的用户购买商品下单场景，创建3个子工程，分别是 order-server （下单服务）、storage-server（库存服务）和 pay-server （支付服务），具体流程图如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083400943-1606086432.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;5.2 环境准备&lt;/h3&gt;
&lt;p&gt;在本次实战中，我们使用Nacos做为服务中心和配置中心，Nacos部署请参考本书的第十一章，这里不再赘述。&lt;/p&gt;
&lt;p&gt;接下来我们需要部署Seata的Server端，下载地址为：https://github.com/seata/seata/releases ，建议选择最新版本下载，目前笔者看到的最新版本为 v0.8.0 ，下载 seata-server-0.8.0.tar.gz 解压后，打开 conf 文件夹，我们需对其中的一些配置做出修改。&lt;/p&gt;
&lt;h4 id=&quot;registry.conf-文件修改如下&quot;&gt;5.2.1 registry.conf 文件修改，如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;registry {
    type = &quot;nacos&quot;
    nacos {
    serverAddr = &quot;192.168.0.128&quot;
    namespace = &quot;public&quot;
    cluster = &quot;default&quot;
    }
}

config {
    type = &quot;nacos&quot;
    nacos {
    serverAddr = &quot;192.168.0.128&quot;
    namespace = &quot;public&quot;
    cluster = &quot;default&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们选择使用Nacos作为服务中心和配置中心，这里做出对应的配置，同时可以看到Seata的注册服务支持：file 、nacos 、eureka、redis、zk、consul、etcd3、sofa等方式，配置支持：file、nacos 、apollo、zk、consul、etcd3等方式。&lt;/p&gt;
&lt;h4 id=&quot;file.conf-文件修改&quot;&gt;5.2.2 file.conf 文件修改&lt;/h4&gt;
&lt;p&gt;这里我们需要其中配置的数据库相关配置，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## database store
db {
    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.
    datasource = &quot;dbcp&quot;
    ## mysql/oracle/h2/oceanbase etc.
    db-type = &quot;mysql&quot;
    driver-class-name = &quot;com.mysql.jdbc.Driver&quot;
    url = &quot;jdbc:mysql://192.168.0.128:3306/seata&quot;
    user = &quot;root&quot;
    password = &quot;123456&quot;
    min-conn = 1
    max-conn = 3
    global.table = &quot;global_table&quot;
    branch.table = &quot;branch_table&quot;
    lock-table = &quot;lock_table&quot;
    query-limit = 100
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里数据库默认是使用mysql，需要配置对应的数据库连接、用户名和密码等。&lt;/p&gt;
&lt;h4 id=&quot;nacos-config.txt-文件修改具体如下&quot;&gt;5.2.3 nacos-config.txt 文件修改，具体如下：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;service.vgroup_mapping.spring-cloud-pay-server=default
service.vgroup_mapping.spring-cloud-order-server=default
service.vgroup_mapping.spring-cloud-storage-server=default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的语法为：&lt;code&gt;service.vgroup_mapping.${your-service-gruop}=default&lt;/code&gt; ，中间的&lt;code&gt;${your-service-gruop}&lt;/code&gt;为自己定义的服务组名称，这里需要我们在程序的配置文件中配置，笔者这里直接使用程序的&lt;code&gt;spring.application.name&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;数据库初始化&quot;&gt;5.2.4 数据库初始化&lt;/h4&gt;
&lt;p&gt;需要在刚才配置的数据库中执行数据初始脚本 db_store.sql ，这个是全局事务控制的表，需要提前初始化。&lt;/p&gt;
&lt;p&gt;这里我们只是做演示，理论上上面三个业务服务应该分属不同的数据库，这里我们只是在同一台数据库下面创建三个 Schema ，分别为 db_account 、 db_order 和 db_storage ，具体如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083401231-2121501463.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;服务启动&quot;&gt;5.2.5 服务启动&lt;/h4&gt;
&lt;p&gt;因为我们是使用的Nacos作为配置中心，所以这里需要先执行脚本来初始化Nacos的相关配置，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd conf
sh nacos-config.sh 192.168.0.128&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功后可以打开Nacos的控制台，在配置列表中，可以看到初始化了很多 Group 为 SEATA_GROUP 的配置，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083401419-5130321.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化成功后，可以使用下面的命令启动Seata的Server端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd bin
sh seata-server.sh -p 8091 -m file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后在 Nacos 的服务列表下面可以看到一个名为 serverAddr 的服务&lt;/p&gt;
&lt;p&gt;到这里，我们的环境准备工作就做完了，接下来开始代码实战。&lt;/p&gt;
&lt;h4 id=&quot;代码实战&quot;&gt;5.3 代码实战&lt;/h4&gt;
&lt;p&gt;由于本示例代码偏多，这里仅介绍核心代码和一些需要注意的代码，其余代码各位读者可以访问本书配套的代码仓库获取。&lt;/p&gt;
&lt;p&gt;子工程common用来放置一些公共类，主要包含视图 VO 类和响应类 OperationResponse.java。&lt;/p&gt;
&lt;h4 id=&quot;父工程-seata-nacos-jpa-依赖-pom.xml-文件&quot;&gt;5.3.1 父工程 seata-nacos-jpa 依赖 pom.xml 文件&lt;/h4&gt;
&lt;p&gt;代码清单：Alibaba/seata-nacos-jpa/pom.xml&lt;/p&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring Cloud Nacos Service Discovery --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Spring Cloud Nacos Config --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Spring Cloud Seata --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-seata&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;

&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-cloud-alibaba.version}&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：本示例是使用 JPA 作为数据库访问 ORM 层， Mysql 作为数据库，需引入 JPA 和 Mysql 相关依赖， &lt;code&gt;spring-cloud-alibaba-dependencies&lt;/code&gt; 的版本是 2.1.0.RELEASE ， 其中有关Seata的组件版本为 v0.7.1 ，虽然和服务端版本不符，经简单测试，未发现问题。&lt;/p&gt;
&lt;h4 id=&quot;数据源配置&quot;&gt;5.3.2 数据源配置&lt;/h4&gt;
&lt;p&gt;Seata 是通过代理数据源实现事务分支，所以需要配置 io.seata.rm.datasource.DataSourceProxy 的 Bean，且是 @Primary默认的数据源，否则事务不会回滚，无法实现分布式事务，数据源配置类DataSourceProxyConfig.java如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/seata-nacos-jpa/order-server/src/main/java/com/springcloud/orderserver/config/DataSourceProxyConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class DataSourceProxyConfig {
    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    public DruidDataSource druidDataSource() {
        return new DruidDataSource();
    }

    @Primary
    @Bean
    public DataSourceProxy dataSource(DruidDataSource druidDataSource) {
        return new DataSourceProxy(druidDataSource);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;开启全局事务&quot;&gt;5.3.3 开启全局事务&lt;/h4&gt;
&lt;p&gt;我们在order-server服务中开始整个业务流程，需要在这里的方法上增加全局事务的注解&lt;code&gt;@GlobalTransactional&lt;/code&gt;，具体代码如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/seata-nacos-jpa/order-server/src/main/java/com/springcloud/orderserver/service/impl/OrderServiceImpl.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
@Slf4j
public class OrderServiceImpl implements OrderService {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private OrderDao orderDao;

    private final String STORAGE_SERVICE_HOST = &quot;http://spring-cloud-storage-server/storage&quot;;
    private final String PAY_SERVICE_HOST = &quot;http://spring-cloud-pay-server/pay&quot;;

    @Override
    @GlobalTransactional
    public OperationResponse placeOrder(PlaceOrderRequestVO placeOrderRequestVO) {
        Integer amount = 1;
        Integer price = placeOrderRequestVO.getPrice();

        Order order = Order.builder()
                .userId(placeOrderRequestVO.getUserId())
                .productId(placeOrderRequestVO.getProductId())
                .status(OrderStatus.INIT)
                .payAmount(price)
                .build();

        order = orderDao.save(order);

        log.info(&quot;保存订单{}&quot;, order.getId() != null ? &quot;成功&quot; : &quot;失败&quot;);
        log.info(&quot;当前 XID: {}&quot;, RootContext.getXID());

        // 扣减库存
        log.info(&quot;开始扣减库存&quot;);
        ReduceStockRequestVO reduceStockRequestVO = ReduceStockRequestVO.builder()
                .productId(placeOrderRequestVO.getProductId())
                .amount(amount)
                .build();
        String storageReduceUrl = String.format(&quot;%s/reduceStock&quot;, STORAGE_SERVICE_HOST);
        OperationResponse storageOperationResponse = restTemplate.postForObject(storageReduceUrl, reduceStockRequestVO, OperationResponse.class);
        log.info(&quot;扣减库存结果:{}&quot;, storageOperationResponse);

        // 扣减余额
        log.info(&quot;开始扣减余额&quot;);
        ReduceBalanceRequestVO reduceBalanceRequestVO = ReduceBalanceRequestVO.builder()
                .userId(placeOrderRequestVO.getUserId())
                .price(price)
                .build();

        String reduceBalanceUrl = String.format(&quot;%s/reduceBalance&quot;, PAY_SERVICE_HOST);
        OperationResponse balanceOperationResponse = restTemplate.postForObject(reduceBalanceUrl, reduceBalanceRequestVO, OperationResponse.class);
        log.info(&quot;扣减余额结果:{}&quot;, balanceOperationResponse);

        Integer updateOrderRecord = orderDao.updateOrder(order.getId(), OrderStatus.SUCCESS);
        log.info(&quot;更新订单:{} {}&quot;, order.getId(), updateOrderRecord &amp;gt; 0 ? &quot;成功&quot; : &quot;失败&quot;);

        return OperationResponse.builder()
                .success(balanceOperationResponse.isSuccess() &amp;amp;&amp;amp; storageOperationResponse.isSuccess())
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，我们需要在另外两个服务的方法中增加注解&lt;code&gt;@Transactional&lt;/code&gt;，表示开启事务。&lt;/p&gt;
&lt;p&gt;这里的远端服务调用是通过 &lt;code&gt;RestTemplate&lt;/code&gt; ，需要在工程启动时将 &lt;code&gt;RestTemplate&lt;/code&gt; 注入 Spring 容器中管理。&lt;/p&gt;
&lt;h4 id=&quot;配置文件&quot;&gt;5.3.4 配置文件&lt;/h4&gt;
&lt;p&gt;工程中需在 resources 目录下增加有关Seata的配置文件 registry.conf ，如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/seata-nacos-jpa/order-server/src/main/resources/registry.conf&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registry {
  type = &quot;nacos&quot;
  nacos {
    serverAddr = &quot;192.168.0.128&quot;
    namespace = &quot;public&quot;
    cluster = &quot;default&quot;
  }
}

config {
  type = &quot;nacos&quot;
  nacos {
    serverAddr = &quot;192.168.0.128&quot;
    namespace = &quot;public&quot;
    cluster = &quot;default&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 bootstrap.yml 中的配置如下：&lt;/p&gt;
&lt;p&gt;代码清单：Alibaba/seata-nacos-jpa/order-server/src/main/resources/bootstrap.yml&lt;/p&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;spring:
  application:
    name: spring-cloud-order-server
  cloud:
    nacos:
      # nacos config
      config:
        server-addr: 192.168.0.128
        namespace: public
        group: SEATA_GROUP
      # nacos discovery
      discovery:
        server-addr: 192.168.0.128
        namespace: public
        enabled: true
    alibaba:
      seata:
        tx-service-group: ${spring.application.name}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;spring.cloud.nacos.config.group ：这里的 Group 是 SEATA_GROUP ，也就是我们前面在使用 nacos-config.sh 生成 Nacos 的配置时生成的配置，它的 Group 是 SEATA_GROUP。&lt;/li&gt;
&lt;li&gt;spring.cloud.alibaba.seata.tx-service-group ：这里是我们之前在修改 Seata Server 端配置文件 nacos-config.txt 时里面配置的 &lt;code&gt;service.vgroup_mapping.${your-service-gruop}=default&lt;/code&gt; 中间的 &lt;code&gt;${your-service-gruop}&lt;/code&gt; 。这两处配置请务必一致，否则在启动工程后会一直报错 &lt;code&gt;no available server to connect&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;业务数据库初始化&quot;&gt;5.3.5 业务数据库初始化&lt;/h4&gt;
&lt;p&gt;数据库初始脚本位于：Alibaba/seata-nacos-jpa/sql ，请分别在三个不同的 Schema 中执行。&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;5.3.6 测试&lt;/h4&gt;
&lt;p&gt;测试工具我们选择使用 PostMan ，启动三个服务，顺序无关 order-server、pay-server 和 storage-server 。&lt;/p&gt;
&lt;p&gt;使用 PostMan 发送测试请求，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083401660-37314168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库初始化余额为 10 ，这里每次下单将会消耗 5 ，我们可以正常下单两次，第三次应该下单失败，并且回滚 db_order 中的数据。数据库中数据如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083401791-2106526350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们进行第三次下单操作，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083402319-342517503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里看到直接报错500，查看数据库 db_order 中的数据，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190911083401791-2106526350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这里的数据并未增加，我们看下子工程_rder-server的控制台打印：&lt;/p&gt;
&lt;p&gt;日志已经过简化处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hibernate: insert into orders (pay_amount, product_id, status, user_id) values (?, ?, ?, ?)
c.s.b.c.service.impl.OrderServiceImpl    : 保存订单成功
c.s.b.c.service.impl.OrderServiceImpl    : 当前 XID: 192.168.0.102:8091:2021674307
c.s.b.c.service.impl.OrderServiceImpl    : 开始扣减库存
c.s.b.c.service.impl.OrderServiceImpl    : 扣减库存结果:OperationResponse(success=true, message=操作成功, data=null)
c.s.b.c.service.impl.OrderServiceImpl    : 开始扣减余额
i.s.core.rpc.netty.RmMessageListener     : onMessage:xid=192.168.0.102:8091:2021674307,branchId=2021674308,branchType=AT,resourceId=jdbc:mysql://192.168.0.128:3306/db_order,applicationData=null
io.seata.rm.AbstractRMHandler            : Branch Rollbacking: 192.168.0.102:8091:2021674307 2021674308 jdbc:mysql://192.168.0.128:3306/db_order
i.s.rm.datasource.undo.UndoLogManager    : xid 192.168.0.102:8091:2021674307 branch 2021674308, undo_log deleted with GlobalFinished
io.seata.rm.AbstractRMHandler            : Branch Rollbacked result: PhaseTwo_Rollbacked
i.seata.tm.api.DefaultGlobalTransaction  : [192.168.0.102:8091:2021674307] rollback status:Rollbacked&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志中没有可以清楚的看到，在服务order-server是先执行了订单写入操作，并且调用扣减库存的接口，通过查看storage-server的日志也可以发现，一样是先执行了库存修改操作，直到扣减余额的时候发现余额不足，开始对 xid 为 &lt;code&gt;192.168.0.102:8091:2021674307&lt;/code&gt; 执行回滚操作，并且这个操作是全局回滚。&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;6. 注意&lt;/h2&gt;
&lt;p&gt;目前在 Seata v0.8.0 的版本中，Server端尚未支持集群部署，不建议应用于生产环境，并且开源团队计划在 v1.0.0 版本的时候可以使用与生产环境，各位读者可以持续关注这个开源项目。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;7. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/Alibaba/seata-nacos-jpa&quot;&gt;Github-示例代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/SpringCloudLearning/tree/master/Alibaba/seata-nacos-jpa&quot;&gt;Gitee-示例代码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.34375&quot;&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/seata/seata/wiki&quot;&gt;Seata官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 11 Sep 2019 00:34:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>Spring Cloud Alibaba | 微服务分布式事务之Seata 本篇实战所使用Spring有关版本： SpringBoot:2.1.7.RELEASE Spring Cloud:Green</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11504210.html</dc:identifier>
</item>
<item>
<title>讲解开源项目：用 Python 生成有“灵魂”的二维码 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11503244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11503244.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215250922-702159829.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;本文作者：HelloGitHub-&lt;strong&gt;LITTLECHIEH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是 HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列，今天给大家推荐一个 Python 开源生成二维码的项目——qrcode&lt;/p&gt;
&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;
&lt;h3 id=&quot;二维码&quot;&gt;1.1 二维码&lt;/h3&gt;
&lt;p&gt;二维码又称二维条码，常见的二维码为 QR Code，QR 全称 Quick Response。是一个近几年来移动设备上超流行的一种编码方式，在现在的生活中二维码随处可见。我们可以用它支付、浏览网站等，为什么他会这么流行？下面说几个特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可存储的信息量大：可容纳多达 1850 个大写字母或 2710 个数字或 1108 个字节或 500 多个汉字。&lt;/li&gt;
&lt;li&gt;容错能力强：具有纠错功能，这使得二维条码因穿孔、污损等引起局部损坏时，照样可以正确得到识读，损毁面积达 30% 仍可恢复信息。&lt;/li&gt;
&lt;li&gt;译码可靠性高：它比普通条码译码错误率百万分之二要低得多，误码率不超过千万分之一。&lt;/li&gt;
&lt;li&gt;激光可识别。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如我们现在常见的公众号二维码，他就利用了二维码容错能力强的特点，在二维码中间加入了公众号的图标。虽然中间的图片遮盖了一部分二维码的真实数据，但因为其强大的容错能力，所以并没有影响二维码要传递的数据。&lt;/p&gt;
&lt;h3 id=&quot;二维码的组成&quot;&gt;1.2 二维码的组成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215314081-1629647708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一图胜千言，好了这里二维码的基本知识就介绍完成了。&lt;/p&gt;
&lt;h3 id=&quot;生成二维码库&quot;&gt;1.3 生成二维码库&lt;/h3&gt;
&lt;p&gt;二维码是一个很方便的传递信息的载体，但是像上面黑白的二维码感觉非常缺少‘灵魂’。下面就介绍今天的主角：qrcode&lt;/p&gt;
&lt;p&gt;这是一个由 Python 编写的二维码生成器，支持生成 GIF 动态、图片二维码，让你的二维码变得有趣起来。&lt;/p&gt;
&lt;blockquote readability=&quot;1.530612244898&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/sylnsfar/qrcode&quot; class=&quot;uri&quot;&gt;https://github.com/sylnsfar/qrcode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二qrcode-库的优点&quot;&gt;二、qrcode 库的优点&lt;/h2&gt;
&lt;p&gt;为什么需要使用到这个二维码生成器来生成二维码呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用简单：快速上手，仅需 2 行代码，即可开始使用！&lt;/li&gt;
&lt;li&gt;在二维码中增加图片：可以让用户通过二维码中的图片，初步了解该二维码是和什么东西有关。（该二维码加入了 HG 的 logo）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215330765-1030952045.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在二维码中增加动图：通过动图，让二维码活过来。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215348623-1289988426.gif&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用方式多样：有以下的 3 种使用方式
&lt;/li&gt;
&lt;li&gt;用就对了：我不要你觉得，我要我觉得 &lt;del&gt;滑稽&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三快速上手&quot;&gt;三、快速上手&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;演示环境&lt;/p&gt;
&lt;p&gt;操作系统：Windows | Python 版本：3.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装&quot;&gt;3.1 安装&lt;/h3&gt;
&lt;p&gt;我们通过 Python 的 pip 包管理工具进行安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;pip install myqr&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：此处可能需要升级 pip，升级命令 &lt;code&gt;pip install --upgrade pip&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完成之后，就可以直接在命令行中使用了！下面逐一讲解各种二维码的生成方法&lt;/p&gt;
&lt;h3 id=&quot;普通二维码&quot;&gt;3.2 普通二维码&lt;/h3&gt;
&lt;p&gt;首先生成一个普通二维码&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;打开 cmd&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输入命令&lt;br/&gt;&lt;code&gt;bash myqr https://github.com -n helloword.png&lt;/code&gt;&lt;br/&gt;参数 &lt;code&gt;-n&lt;/code&gt;：生成二维码的文件名&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样就会得到一个二维码图片，生成的图片保存在了当前目录，后面可以通过传入参数修改默认目录。&lt;/p&gt;
&lt;h3 id=&quot;彩色二维码&quot;&gt;3.3 彩色二维码&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先准备一张图片放在目录下（&lt;strong&gt;方形&lt;/strong&gt;的图片效果最好）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215407477-71298917.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将图片名称修改为 github.jpg（后缀根据自己的照片格式而定）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在命令行中输入：&lt;br/&gt;&lt;code&gt;bash myqr https://github.com -n mypicture.png -p github.jpg -c&lt;/code&gt;&lt;br/&gt;参数：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;：生成二维码的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：二维码加入的图片，支持 jpg、gif、png 格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;：选择是否生成彩色二维码，如果不设置默认为黑白&lt;/li&gt;
&lt;li&gt;更多参数请看下面附录部分&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;动态二维码&quot;&gt;3.4 动态二维码&lt;/h3&gt;
&lt;p&gt;步骤和彩色二维码的方法一致，但是需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增加图片为 gif&lt;/li&gt;
&lt;li&gt;修改生成二维码的后缀为 gif&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四附录&quot;&gt;四、附录&lt;/h2&gt;
&lt;h3 id=&quot;myqr-参数&quot;&gt;4.1 MyQR 参数&lt;/h3&gt;
&lt;p&gt;从官方文档整理的常用参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;：生成二维码的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：二维码加入的图片，支持&lt;code&gt;.jpg&lt;/code&gt;、&lt;code&gt;.gif&lt;/code&gt;、&lt;code&gt;.png&lt;/code&gt;、&lt;code&gt;.bmp&lt;/code&gt; 格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;：选择是否生成彩色二维码，如果不设置默认为黑白&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;：控制边长，范围是 1 至 40，数字越大边长越大&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;：控制纠错水平，范围是 L、M、Q、H 从左到右依次升高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;：控制输出二维码的存储位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-con&lt;/code&gt;：用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-bri&lt;/code&gt;：用来调节图片的亮度，其余用法和取值与 &lt;code&gt;-con&lt;/code&gt; 相同&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cmd-切换盘符&quot;&gt;4.2 cmd 切换盘符&lt;/h3&gt;
&lt;p&gt;打开命令行有个小技巧，可以将 cmd 迅速切换到想要的目录，避免了切换盘符的麻烦：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;利用文件管理，找到目标文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;顶部地址栏输入 cmd，然后‘回车‘&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215422276-707618205.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;切换盘符的坑：直接切换盘符会失败&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215437701-1121848840.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二维码分类介绍&quot;&gt;4.3 二维码分类介绍&lt;/h3&gt;
&lt;p&gt;二维码有以下几种分类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;黑白和彩色码
&lt;ul&gt;&lt;li&gt;黑白码&lt;/li&gt;
&lt;li&gt;彩色码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;融合和视觉码
&lt;ul&gt;&lt;li&gt;融合码：就是将内容与二维码融合使它们成为一个整体，图片由二维码组成，二维码就是图片的一部分。这种比较适合使用构造简单的图片或者文字做美化主体内容&lt;/li&gt;
&lt;li&gt;视觉码：以图片为背景，再在图片上构建很多特殊的点，这些点不会影响背景的视觉效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215618561-1371192193.gif&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;艺术码
&lt;ul&gt;&lt;li&gt;艺术二维码，就是将二维码进行的各个“码眼”按照设计师的构思进行分析、拆解、合并，再在那些“码眼”区域填充上一些小素材元素，最后形成一个别具特色二维码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201909/759200-20190910215633704-2020753456.gif&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;以上就是本篇文章的全部内容了，相信你对二维码更加了解了。并且对 qrcode 库的常用参数有了一定了解，那就快去生成一个有趣、有‘灵魂’的二维码吧！&lt;/p&gt;
&lt;p&gt;有好玩的库，但不会用，看着干着急？欢迎告诉我们，同时也欢迎加入我们。我们的愿景：&lt;br/&gt;“让对开源感兴趣的人不再畏惧，开源项目的发起者不再孤单。”&lt;/p&gt;
&lt;h2 id=&quot;六参考资料&quot;&gt;六、参考资料&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Wed, 11 Sep 2019 00:33:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文作者：HelloGitHub LITTLECHIEH 这是 HelloGitHub 推出的 '《讲解开源项目》' 系列，今天给大家推荐一个 Python 开源生成二维码的项目——qrcode 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11503244.html</dc:identifier>
</item>
<item>
<title>Linux入门基础之 上 - duncan1863</title>
<link>http://www.cnblogs.com/duncan1863/p/11503763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duncan1863/p/11503763.html</guid>
<description>&lt;h2 id=&quot;一linux-系统安装&quot;&gt;一、Linux 系统安装&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;安装方法网上很多，请自行百度&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二linux-基本操作&quot;&gt;二、Linux 基本操作&lt;/h2&gt;
&lt;h3 id=&quot;gnome图形界面基本操作&quot;&gt;2.1、GNOME图形界面基本操作&lt;/h3&gt;
&lt;ul readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;操作类似于Windows系统操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;打开每一个文件夹都会打开一个新的窗口，这可以修改
&lt;ul&gt;&lt;li&gt;打开文件夹-Edit-Preference-Behavior，勾选上 Always open in browser windows ，关闭该文件夹后重新打开文件夹，文件夹的操作就跟Windows一样了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bash基本操作&quot;&gt;2.2、Bash基本操作&lt;/h3&gt;
&lt;h4 id=&quot;shell-的概念&quot;&gt;2.2.1 SHELL 的概念&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Shell 叫做 壳 ，Linux操作系统底层是有一个内核（Kernel），内核用来去实现一些上层服务、上层命令、上层应用所需要的基本功能，比如说底层磁盘的读写，网络的连接，网络的通信，键盘驱动、鼠标驱动、进程调度、内存管理、图形页面等等都是由操作系统的 Kernel 去完成的。Kernel 我们是没有办法直接去对它进行控制的，因为一些安全问题，一些权限问题，用户是不允许直接去操控 Kernel 的，这个时候就需要一个 Shell 程序。Shell 的功能就是把我们用户的一些指令去传递给 Kernel ，翻译成 Kernel 可以理解的信息。&lt;br/&gt;所以我们所有当前的操作都是由一个 Shell 传递给 Kernel 的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell分为 CLI 与 GUI 两种&lt;/strong&gt;&lt;br/&gt;- &lt;strong&gt;CLI:&lt;/strong&gt; Command Line Interface 命令行界面Shell&lt;br/&gt;- BASH&lt;br/&gt;- &lt;strong&gt;GUI:&lt;/strong&gt; Graphical User Interface 图形界面Shell&lt;br/&gt;- GNOME&lt;/li&gt;
&lt;li&gt;在 Linux 系统里面，命令行操作是 Linux 主要管理方式，图形界面能完成的命令行基本都难完成，命令行能完成的图形界面不一定能完成。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;bash-命令行操作&quot;&gt;2.2.2 BASH 命令行操作&lt;/h4&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;提示符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;# : 代表当前是以根用户也就是 root 用户身份登录
&lt;ul&gt;&lt;li&gt;表示拥有最高的管理员权限，也就是当前是操作都很危险，可以破坏系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;$ : 代表当前是普通用户身份登录
&lt;ul&gt;&lt;li&gt;输入：“ su - ” 后提示输入密码，输入密码后就是 root 用户身份登录了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命令一般由三部分组成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令&lt;/li&gt;
&lt;li&gt;选项&lt;/li&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本命令&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;hostname : 查看当前主机名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ls : list 的缩写，列出当前目录下的所有文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;uname: 显示当前系统的基本信息（底层内核的信息）&lt;/p&gt;
&lt;p&gt;这是不带任何参数的命令，但是几乎所有的命令都可以带参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;uname -r : 不带参数的命令返回信息有点少，加上 -r 参数后返回信息变成了内核版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;uname -a : 显示所有信息&lt;/p&gt;
&lt;p&gt;命令后接一个 - 和一个字母，这是单字符参数，也可以写成两个 - 和一个单词，如：&lt;/p&gt;
&lt;p&gt;uname --all ，这个命令和上面的 uname -a 功能是一样的。&lt;/p&gt;
&lt;p&gt;一般都使用单字符参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;firefox : 表示打开火狐浏览器，输入程序的命令就是打开该程序&lt;/p&gt;
&lt;p&gt;火狐浏览器打开后再返回命令行界面时没有返回提示符，按 Ctrl + C 可以终止当前命令，退出到提示符下，可以在输入命令时在后面加入参数让程序在后台运行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;firefox &amp;amp; ：任何命令后加 &amp;amp; 表示将该命令放到后台运行，不会干扰当前命令行。（命令行是多进程多任务终端）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clear ： 清除屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;使用 Tab 键来简化命令输入&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动补全命令&lt;/li&gt;
&lt;li&gt;自动补全文件名&lt;/li&gt;
&lt;li&gt;无法自动补全参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Linux 命令或者文件名有很多前几个字母是相同的，输入的字母只要能和其他命令或文件名区分开，按 Tab 键就能自动补全，不能区分开时按两下 Tab 键就会显示所有以输入的字母开头的命令或文件名。&lt;/p&gt;
&lt;p&gt;不输入命令直接按两下 Tab 键会提示是否列出所有的命令&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;​ $unam&amp;lt;tab&amp;gt;&lt;/p&gt;
&lt;p&gt;​ $uname&lt;/p&gt;
&lt;p&gt;​ $ls Dow&amp;lt;tab&amp;gt;&lt;/p&gt;
&lt;p&gt;​ $ls Downloads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史记录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bash 会保存你输入命令的历史记录，可以通过键盘的上下按键查看上一条或下一条命令，也可以使用 history 命令来查看操作过的所有命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过历史记录简化操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;!! : 重复前一个命令&lt;/li&gt;
&lt;li&gt;!字符 : 重复前一个以“ 字符 ”开头的命令&lt;/li&gt;
&lt;li&gt;!num : 按照历史记录的序号执行命令&lt;/li&gt;
&lt;li&gt;!?abc : 重复之前包含 abc 的命令&lt;/li&gt;
&lt;li&gt;!-n : 重复 n 个命令之前的那个命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索命令历史记录&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以通过 Ctrl + r 来在历史记录中搜索命令&lt;/p&gt;
&lt;p&gt;(reverse-i-search) '':&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重新调用前一个命令中的参数&lt;/p&gt;
&lt;p&gt;esc键 + . : 输入命令后按 esc 键，然后按 .&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行通配符&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Bash Shell 支持以下通配符：&lt;/p&gt;
&lt;p&gt;* : 匹配零个或多个&lt;/p&gt;
&lt;p&gt;? : 匹配任意一个字符&lt;/p&gt;
&lt;p&gt;[0-9] : 匹配一个数字范围&lt;/p&gt;
&lt;p&gt;[abc] : 匹配列表里任何字符&lt;/p&gt;
&lt;p&gt;[^abc] : 匹配列表以外字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换用户&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 CLI 中，通过 su 命令切换用户
&lt;ul&gt;&lt;li&gt;su - : 切换到 root 用户并使用一个新的运行环境，输入 exit 退出
&lt;ul&gt;&lt;li&gt;su 后加 - 和不加 - 的区别就是是否创建一个新的环境，一般使用都加 -&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sudo : 使用管理员用户身份运行命令（非 root 用户）
&lt;ul&gt;&lt;li&gt;sudo 命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;显示当前用户信息
&lt;ul&gt;&lt;li&gt;id&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修改当前用户密码
&lt;ul&gt;&lt;li&gt;passwd&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BASH 作业管理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在后台运行进程
&lt;ul&gt;&lt;li&gt;在命令后添加一个 &amp;amp;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;暂停某个程序
&lt;ul&gt;&lt;li&gt;通过 Ctrl + z 或者发送信号 17&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;管理后台作业
&lt;ul&gt;&lt;li&gt;jobs : 查看后台运行的进程是否在运行&lt;/li&gt;
&lt;li&gt;bg : 后面加进程编号，控制一个进程继续在后台运行&lt;/li&gt;
&lt;li&gt;fg : 后面加进程编号，将后台运行的进程拉回到前台来运行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux-文件系统结构&quot;&gt;2.3、Linux 文件系统结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201909/1690689-20190910231623057-327731063.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Linux 文件系统为一个倒转的单根树状结构&lt;/li&gt;
&lt;li&gt;文件系统的根为 &quot; / &quot;&lt;/li&gt;
&lt;li&gt;文件系统严格区分大小写&lt;/li&gt;
&lt;li&gt;路径使用 &quot; / &quot; 分隔，（Windows 中使用 &quot;  &quot;）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;当前工作目录&quot;&gt;2.3.1 当前工作目录&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每一个 shell 或系统进程都有一个当前工作目录&lt;/li&gt;
&lt;li&gt;使用 pwd 命令可以显示当前的工作目录&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;文件名称&quot;&gt;2.3.2 文件名称&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;文件的名称大小写敏感&lt;/li&gt;
&lt;li&gt;名称最多可以为 255 个字符&lt;/li&gt;
&lt;li&gt;除了 &quot;  &quot; 外，都是有效字符（文件的命名最好体现文件的功能，尽量不要使用特殊字符）&lt;/li&gt;
&lt;li&gt;通过 touch 命令可以创建一个空白文件或者更新已有文件的时间&lt;/li&gt;
&lt;li&gt;以 &quot; . &quot; 开头的文件为隐藏文件，ls -a 命令中会显示很多以 . 开头的文件，隐藏文件大多数都是配置文件，轻易不要去动。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;列出目录内容&quot;&gt;2.3.3 列出目录内容&lt;/h4&gt;
&lt;p&gt;​ &quot; ls &quot; 命令用来列出目录内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相关参数
&lt;ul&gt;&lt;li&gt;ls -a : 显示所有文件（包括隐藏文件）&lt;/li&gt;
&lt;li&gt;ls -l : 显示详细信息&lt;/li&gt;
&lt;li&gt;ls -R : 递归显示子目录结构&lt;/li&gt;
&lt;li&gt;ls -ld : 显示目录和链接信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查看文件类型&quot;&gt;2.3.4 查看文件类型&lt;/h4&gt;
&lt;p&gt;​ 通过 file 命令可以查看文件的类型&lt;/p&gt;
&lt;h4 id=&quot;绝对路径与相对路径&quot;&gt;2.3.5 绝对路径与相对路径&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;绝对路径：以 &quot; / &quot; 开头，递归每级目录直到目标的路径。不受当前所在工作目录限制
&lt;ul&gt;&lt;li&gt;​&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;相对路径：以当前目录为起点，到的目标的路径。受当前所在目录限制
&lt;ul&gt;&lt;li&gt;cd 命令可以用来切换目录
&lt;ul&gt;&lt;li&gt;上一级目录：&quot; .. &quot;&lt;/li&gt;
&lt;li&gt;当前目录：&quot; . &quot;&lt;/li&gt;
&lt;li&gt;用户家目录：&quot; ~ &quot; ，在任何目录下输入 cd 直接按 Enter 也是回到家目录&lt;/li&gt;
&lt;li&gt;上一个工作目录：&quot; - &quot;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1690689/201909/1690689-20190910231642115-675331760.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;图中当前目录是 linuxcast ，目标目录是 sa ，从 linuxcast 目录到 sa 目录分别使用绝对路径和相对路径如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绝对路径：/var/log/sa&lt;/li&gt;
&lt;li&gt;相对路径：../../var/log/sa&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以后写程序或写脚本的时候一般使用绝对路径！&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux-文件基本操作&quot;&gt;2.4、Linux 文件基本操作&lt;/h3&gt;
&lt;h4 id=&quot;创建和删除文件&quot;&gt;2.4.1 创建和删除文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;通过 touch 命令可以创建一个空文件或更新文件时间&lt;/li&gt;
&lt;li&gt;通过 rm 命令可以删除文件或目录，常用参数：
&lt;ul&gt;&lt;li&gt;-i : 交互式&lt;/li&gt;
&lt;li&gt;-r : 递归的删除包括目录中的所有内容&lt;/li&gt;
&lt;li&gt;-f :强制删除，&lt;strong&gt;没有警告提示（使用时需十分谨慎）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建和删除目录&quot;&gt;2.4.2 创建和删除目录&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;通过 mkdir 命令创建一个目录&lt;/li&gt;
&lt;li&gt;通过 rmdir 命令删除一个空目录&lt;/li&gt;
&lt;li&gt;通过 rm -f (-f) 命令删除一个非空目录&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;复制文件目录&quot;&gt;2.4.3 复制文件、目录&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用 cp 命令复制文件或目录
&lt;ul&gt;&lt;li&gt;cp 源文件（文件夹） 目标文件（文件夹）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;touch linuxcast
cp linuxcast linuxcast2    复制到当前文件夹并重命名为 linuxcast2
cp linuxcast linuxcast.net      复制到别的文件夹下,文件名还是 linuxcast&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;常用参数：&lt;/p&gt;
&lt;ul readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;-r : 递归复制整个目录树&lt;/p&gt;
&lt;p&gt;不加参数的 cp 命令只能复制文件，如果要复制一个文件夹需要加 -r 的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-v : 显示详细信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;移动重命名文件或目录&quot;&gt;2.4.4 移动、重命名文件或目录&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过命令 mv 命令移动或者重命名文件或目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mv 文件 目标目录&lt;/li&gt;
&lt;li&gt;如果指定文件名，则可以重命名文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mv linuxcast2 linuxcast.net/cast    将文件 linuxcast2 移动到 linuxcast.net 文件夹下并重命名为cast 

touch abc     新建文件abc
mv abc hello     在当前目录下将文件 abc 重命名为 hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linux-系统常用命令&quot;&gt;2.5、Linux 系统常用命令&lt;/h3&gt;
&lt;h4 id=&quot;日期时间&quot;&gt;2.5.1 日期时间&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 date 用以查看、设置当前系统时间：
&lt;ul&gt;&lt;li&gt;date -u : 查看 UTC 时间&lt;/li&gt;
&lt;li&gt;格式化显示时间：+%Y--%m--%d&lt;/li&gt;
&lt;li&gt;date -s &quot;20:20:20&quot; : 修改当前时间为 20:20:20&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 hwclock （clock） 用以显示硬件时钟时间&lt;/li&gt;
&lt;li&gt;命令 cal 用以查看日历&lt;/li&gt;
&lt;li&gt;命令 uptime 用以查看系统运行时间，有几个用户登录，及系统平均负载&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;输出和查看命令&quot;&gt;2.5.2 输出和查看命令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 echo 用以显示输入的内容&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo 'hello word'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;命令 cat 用以显示文件内容
&lt;ul&gt;&lt;li&gt;如果文件中内容很长，前面的内容会略过，直接显示最后几行，不太方便&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 head 用以显示文件的头几行（默认10行）
&lt;ul&gt;&lt;li&gt;-n 指定显示的行数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 tail 用以显示文件的末尾几行（默认10行）
&lt;ul&gt;&lt;li&gt;-n 指定显示的行数&lt;/li&gt;
&lt;li&gt;-f 追踪显示文件更新（一般用于查看日志，命令不会退出，而是持续显示加入的内容）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 more 用于翻页显示文件内容（只能向下翻页）&lt;/li&gt;
&lt;li&gt;命令 less 用于翻页显示文件内容（带上下翻页）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查看硬件信息&quot;&gt;2.5.3 查看硬件信息&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 lspci 用以查看 PCI 设备
&lt;ul&gt;&lt;li&gt;-v : 查看详细信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 lsusb 用以查看 USB 设备
&lt;ul&gt;&lt;li&gt;-v : 查看详细信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 lsmod 用以查看加载的模块（驱动）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;关机重启&quot;&gt;2.5.4 关机、重启&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 shutdown 用以关闭、重启计算机
&lt;ul&gt;&lt;li&gt;shutdown [ 关机、重启] 时间&lt;/li&gt;
&lt;li&gt;-h 关闭计算机&lt;/li&gt;
&lt;li&gt;-r 重新启动&lt;/li&gt;
&lt;li&gt;如：
&lt;ul&gt;&lt;li&gt;立即关机： shutdown -h now&lt;/li&gt;
&lt;li&gt;10分钟后关机： shutdown -h +10&lt;/li&gt;
&lt;li&gt;23:30分关机： shotdown -h 23:30&lt;/li&gt;
&lt;li&gt;立即重启： shotdown -r now&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 poweroff 用以立即关闭计算机&lt;/li&gt;
&lt;li&gt;命令 reboot 用以立即重启计算机&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;归档压缩&quot;&gt;2.5.5 归档、压缩&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 zip 用以压缩文件
&lt;ul&gt;&lt;li&gt;zip linuxcast.zip myfile&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 unzip 用以解压缩 zip 文件
&lt;ul&gt;&lt;li&gt;unzip linuxcast.zip&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 gzip 用以压缩文件
&lt;ul&gt;&lt;li&gt;gzip linuxcast.net&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令 tar 用以归档文件 （ tar 是归档命令，不是压缩命令）
&lt;ul&gt;&lt;li&gt;tar -cvf out.tar linuxcast&lt;/li&gt;
&lt;li&gt;tar -xvf linuxcast.tar 打开或释放归档（打开在当前目录下）&lt;/li&gt;
&lt;li&gt;tar -cvzf backup.tar.gz /etc 归档并压缩，最常用的归档压缩命令
&lt;ul&gt;&lt;li&gt;-z 参数将归档后的归档文件进行 gzip 压缩以减少大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查找&quot;&gt;2.5.6 查找&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 locate 用以快速查找文件、文件夹
&lt;ul&gt;&lt;li&gt;locate keyword&lt;/li&gt;
&lt;li&gt;此命令需要预先建立数据库，数据库默认每天更新一次，所以优点查找非常快，缺点是新加进来的数据，数据库没有更新的话会找不到文件，可用 updatedb 命令手工建立、更新数据库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;touch aabbcc    新建文件aabbcc
locate aabbcc    找不到文件
updatedb          手工更新数据库，相当于扫描整个操作系统
locate aabbcc    此时就能找到文件&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命令 find 用以高级查找文件、文件夹&lt;/p&gt;
&lt;ul readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;find 查找位置 查找参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;find . -name *linuxcast* 在当前目录下查找文件名包含 linuxcast 的所有文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;find / -name *.conf 在根目录下（也可以说整个操作系统或硬盘）查找所有以 .conf 结尾的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;find / -perm 777 在硬盘中查找所有权限是 777 的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;find / type d 在硬盘中查找所有文件类型是目录的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;find . -name &quot;a*&quot; -exec ls -l {} ; 查找后的结果再执行命令&lt;/p&gt;
&lt;p&gt;find . -name &quot;a*&quot; 是查找所有以 a 开头的文件；-exec 是执行的意思；&quot; -exec &quot; 和 &quot; {} ; &quot; 是固定格式，整个的意思就是：把以 a 开头的文件找到后作为参数传递给 &quot; -exec &quot; 和 &quot; {} ; &quot; 之间的命令（这里是 ls -l ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;find 支持很多种的查找条件，常用的如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-name 文件名&lt;/li&gt;
&lt;li&gt;-perm 权限&lt;/li&gt;
&lt;li&gt;-user 查找全部属于某个特定用户的文件&lt;/li&gt;
&lt;li&gt;-group 查找全部属于某个特定组的文件&lt;/li&gt;
&lt;li&gt;-ctime 基于文件修改时间的查找&lt;/li&gt;
&lt;li&gt;-type 文件类型&lt;/li&gt;
&lt;li&gt;-size 基于文件大小的查找&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vi-文本编辑器&quot;&gt;2.6、Vi 文本编辑器&lt;/h3&gt;
&lt;h4 id=&quot;vi-和-vim&quot;&gt;2.6.1 VI 和 VIM&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;vi 是一个命令行界面下的文本编辑工具，最早在 1976 年由 Bill Joy 开发，当时名字叫 ex。&lt;/li&gt;
&lt;li&gt;vi 支持绝大多数操作系统（最早在 BSD 上发布），并且功能已经十分强大。&lt;/li&gt;
&lt;li&gt;1991 年 Bram Moolenaar 基于 vi 进行了改进，发布了 vim，加入了对 GUI 的支持、&lt;/li&gt;
&lt;li&gt;vim 已经不仅仅是普通意义上的文本编辑器（如 Windows 上的记事本），而是被广泛的作为在文本编辑、文本处理、代码开发等等用途。&lt;/li&gt;
&lt;li&gt;Linux 中知名的文本编辑器还有 emacs ，它的功能比 vim 还要强大。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;vim&quot;&gt;2.6.2 VIM&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;绝大多数 Linux 系统上均安装有 vim ，vim 比 vi 的功能更为强大，所以建议大家使用 vim 而非 vi ，两者使用方法相同。&lt;/li&gt;
&lt;li&gt;命令 vim 可以启动 vim 编辑器&lt;/li&gt;
&lt;li&gt;一般通过 vim + 目标文件路径 的形式使用 vim&lt;/li&gt;
&lt;li&gt;如果目标文件已存在，则 vim 打开该文件&lt;/li&gt;
&lt;li&gt;如果目标文件不存在，则 vim 新建并打开该文件&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;vim-的三种工作模式&quot;&gt;2.6.3 VIM 的三种工作模式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令模式（常规模式）
&lt;ul&gt;&lt;li&gt;vim 启动后，默认进入命令模式，任何模式都可以通过按 esc 键回到命令模式（可以多按几次）。&lt;/li&gt;
&lt;li&gt;命令模式下可以通过键入不同的命令完成定位、选择、复制、翻页、粘贴、删除、撤销等等操作&lt;/li&gt;
&lt;li&gt;常用命令：
&lt;ul&gt;&lt;li&gt;i 在光标前插入文本&lt;/li&gt;
&lt;li&gt;o 在当前行的下面插入新行&lt;/li&gt;
&lt;li&gt;dd 删除整行&lt;/li&gt;
&lt;li&gt;yy 将当前行的内容放入缓冲区 （复制当前行）&lt;/li&gt;
&lt;li&gt;n+yy 将 n 行的内容放入缓冲区 （复制 n 行）&lt;/li&gt;
&lt;li&gt;p 将缓冲区的文本放入光标后（粘贴）&lt;/li&gt;
&lt;li&gt;u 撤销上一个操作&lt;/li&gt;
&lt;li&gt;r 替换当前字符&lt;/li&gt;
&lt;li&gt;/ 查找关键字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编辑模式（插入模式）
&lt;ul&gt;&lt;li&gt;在命令模式中按 &quot; i &quot; 键，即可进入编辑模式，在编辑模式可以输入编辑文本内容，使用 esc 键可以返回到命令模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;末行模式（ex 模式）
&lt;ul&gt;&lt;li&gt;在命令模式中按 &quot; : &quot; 键可以进入末行模式，光标会移动到底部左下角，在这里可以保存修改或退出 vim&lt;/li&gt;
&lt;li&gt;常用命令如下：
&lt;ul&gt;&lt;li&gt;:w 保存当前修改&lt;/li&gt;
&lt;li&gt;:q 退出&lt;/li&gt;
&lt;li&gt;:wq 保存并退出&lt;/li&gt;
&lt;li&gt;:q! 强制退出，不保存修改&lt;/li&gt;
&lt;li&gt;:x 保存并退出，相当于 :wq&lt;/li&gt;
&lt;li&gt;:set number 显示行号&lt;/li&gt;
&lt;li&gt;:! 系统命令 执行一个系统命令并显示结果 如 :! who&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;:sh 切换到命令行，使用 Ctrl + d 切换回 vim&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三磁盘基本概念&quot;&gt;三、磁盘基本概念&lt;/h2&gt;
&lt;h3 id=&quot;磁盘基本概念&quot;&gt;3.1、磁盘基本概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;cylinder - 柱面&lt;/li&gt;
&lt;li&gt;sector - 扇区&lt;/li&gt;
&lt;li&gt;head - 磁头&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;磁盘在-linux-中的表示&quot;&gt;3.2、磁盘在 Linux 中的表示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Linux 所有设备都被抽象为一个文件，保存在 /dev 目录下&lt;/li&gt;
&lt;li&gt;设备名称一般为 hd[a-z] 或 sd[a-z] ( [a-z]为分区号 )，如：hda、hdb、sda、sdb&lt;/li&gt;
&lt;li&gt;IDE 设备的名称为 hd[a-z] ，SATA、SCSI、USB 等设备的名称为 sd[a-z]&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分区概念&quot;&gt;3.3、分区概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将一个磁盘逻辑的分为几个区，每个区当做独立磁盘，以方便使用管理
&lt;ul&gt;&lt;li&gt;不同分区用：设备名称+分区号 方式来表示，如：sda1、sda2&lt;/li&gt;
&lt;li&gt;主流的分区机制分为 MBR 和 GPT 两种&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mbr&quot;&gt;3.4、MBR&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MBR （Master Boot Record）是传统的分区机制，应用于绝大多数使用 BIOS 的 PC 设备
&lt;ul&gt;&lt;li&gt;MBR 支持 32bit 和 64bit 系统&lt;/li&gt;
&lt;li&gt;MBR 支持分区数量有限&lt;/li&gt;
&lt;li&gt;MBR 只支持不超过 2T 的硬盘，超过 2T 的硬盘将只能使用 2T 空间（有第三方解决方法）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MBR 分区
&lt;ul&gt;&lt;li&gt;主分区
&lt;ul&gt;&lt;li&gt;最多只能创建4个主分区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;扩展分区
&lt;ul&gt;&lt;li&gt;一个扩展分区会占用一个主分区位置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逻辑分区
&lt;ul&gt;&lt;li&gt;Linux 最多支持63个 IDE 分区和15个 SCSI 分区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;gpt&quot;&gt;3.5、GPT&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GPT （GUID Partition Table）是一个较新的分区机制，解决了 MBR 的很多缺点
&lt;ul&gt;&lt;li&gt;支持超过 2T 的磁盘&lt;/li&gt;
&lt;li&gt;向后兼容 MBR&lt;/li&gt;
&lt;li&gt;必须在支持 UEFI 的硬件上才能使用&lt;/li&gt;
&lt;li&gt;必须使用64bit 系统&lt;/li&gt;
&lt;li&gt;Mac、Linux 系统都能支持 GPT 分区格式&lt;/li&gt;
&lt;li&gt;Windows7 64bit、WindowsServer2008 64bit 支持 GPT&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;fdisk-分区工具&quot;&gt;3.6、FDISK 分区工具&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;fdisk 是来自 IBM 的老牌分区工具，支持绝大多数操作系统，几乎所有的 Linux 的发行版本都装有 fdisk ，包括在 Linux 的 rescue 模式下依然能够使用。&lt;/li&gt;
&lt;li&gt;fdisk 是一个基于 MBR 的分区工具，所以如果需要使用 GPT ，则无法使用 fdisk 进行分区&lt;/li&gt;
&lt;li&gt;FDISK 操作
&lt;ul&gt;&lt;li&gt;fdisk 命令只有具有超级用户权限才能够运行&lt;/li&gt;
&lt;li&gt;使用 fdisk -l 可以列出所有安装的磁盘及其分区信息&lt;/li&gt;
&lt;li&gt;使用 fdisk /dev/sda 可以对目标磁盘进行分区操作&lt;/li&gt;
&lt;li&gt;分区之后需要使用 partprobe 命令让内核更新分区信息，否则需要重启才能识别新的分区&lt;/li&gt;
&lt;li&gt;/proc/partitions 文件也可用来查看分区信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四linux-文件系统&quot;&gt;四、Linux 文件系统&lt;/h2&gt;
&lt;h3 id=&quot;文件系统简介&quot;&gt;4.1、文件系统简介&lt;/h3&gt;
&lt;h4 id=&quot;文件系统简介-1&quot;&gt;4.1.1 文件系统简介&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;操作系统通过文件系统管理文件及数据，磁盘或分区需要创建文件系统之后才能够为操作系统使用，创建文件系统的过程又称之为格式化。
&lt;ul&gt;&lt;li&gt;没有文件系统的设备又称之为裸（raw）设备&lt;/li&gt;
&lt;li&gt;常见的文件系统有：fat32 、NTFS、ext2 、ext3、ext4、ext6、HFS 等&lt;/li&gt;
&lt;li&gt;文件系统之间的区别：日志、支持的分区大小、支持的单个文件大小、性能等&lt;/li&gt;
&lt;li&gt;Windows 下的主流文件系统是：NTFS ， Linux 下的主流文件系统是：Ext3、Ext4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux 支持的文件系统
&lt;ul&gt;&lt;li&gt;ext2&lt;/li&gt;
&lt;li&gt;ext3&lt;/li&gt;
&lt;li&gt;ext4&lt;/li&gt;
&lt;li&gt;fat ( msdos )&lt;/li&gt;
&lt;li&gt;vfat&lt;/li&gt;
&lt;li&gt;nfs&lt;/li&gt;
&lt;li&gt;iso9660&lt;/li&gt;
&lt;li&gt;proc&lt;/li&gt;
&lt;li&gt;gfs&lt;/li&gt;
&lt;li&gt;jfs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mke2fs-创建文件系统&quot;&gt;4.1.2、MKE2FS 创建文件系统&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 mke2fs 用来创建文件系统
&lt;ul&gt;&lt;li&gt;mke2fs -t ext4 /dev/sda3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;常用参数
&lt;ul&gt;&lt;li&gt;-t 指定要创建的文件类型&lt;/li&gt;
&lt;li&gt;-b blocksize 指定文件系统块大小&lt;/li&gt;
&lt;li&gt;-c 建立文件系统时检查坏损块&lt;/li&gt;
&lt;li&gt;-L label 指定卷标&lt;/li&gt;
&lt;li&gt;-j 建立文件系统日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mkfs&quot;&gt;4.1.3、MKFS&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 mkfs 也可用于创建文件系统，相较于 mke2fs 简单，但是支持的参数较少，不能进行精细化的控制
&lt;ul&gt;&lt;li&gt;mkfs.ext3 /dev/sda3&lt;/li&gt;
&lt;li&gt;mkfs.ext4 /dev/sda3&lt;/li&gt;
&lt;li&gt;mkfs.vfat /dev/sda3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dumpe2fs-查看文件系统&quot;&gt;4.1.4、DUMPE2FS 查看文件系统&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 dumpe2fs 可以用来查看分区的文件系统信息
&lt;ul&gt;&lt;li&gt;dumpe2fs /dev/sda2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;journal-日志&quot;&gt;4.1.5、JOURNAL 日志&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;带日志的文件系统（ext3、ext4）拥有较强的稳定性，在出现错误时可以进行恢复。&lt;/li&gt;
&lt;li&gt;使用带日志的文件系统，文件系统会使用一个叫做 “两阶段提交” 的方式进行磁盘操作，当进行磁盘操作时，文件系统进行以下操作：
&lt;ul&gt;&lt;li&gt;文件系统将准备执行的事务的具体内容写入日志&lt;/li&gt;
&lt;li&gt;文件系统进行操作&lt;/li&gt;
&lt;li&gt;操作成功后，将事务的具体内容从日志中删除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;这样做的好处是，当事务执行的时候如果出现意外（如断电或磁盘故障），可以通过查询日志进行恢复操作。缺点是会丧失一定的性能（额外的日志读写操作）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;e2label-添加标签&quot;&gt;4.1.6、E2LABEL 添加标签&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 e2label 可以用来为文件系统添加标签（标签建议大小）
&lt;ul&gt;&lt;li&gt;e2label /dev/sda2 显示 sda2 的系统标签&lt;/li&gt;
&lt;li&gt;e2label /dev/sda2 LINUXCAST 将 sda2 的系统标签设置为 LINUXCAST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;fsck-检查并修复&quot;&gt;4.1.7、FSCK 检查并修复&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 fsck 用来检查并修复损坏的文件系统
&lt;ul&gt;&lt;li&gt;fsck /dev/sda2&lt;/li&gt;
&lt;li&gt;使用 -y 参数不提示而直接进行修复&lt;/li&gt;
&lt;li&gt;默认 fsck 会自动判断文件系统类型，如果文件系统损坏较为严重，请使用 -t 参数指定文件系统类型&lt;/li&gt;
&lt;li&gt;对于识别为文件的损坏数据（文件系统无记录），fsck 会将该文件放入 lost+found 目录&lt;/li&gt;
&lt;li&gt;系统启动时会对磁盘进行 fsck 操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件系统挂载及使用&quot;&gt;4.2、文件系统挂载及使用&lt;/h3&gt;
&lt;h4 id=&quot;挂载操作&quot;&gt;4.2.1 挂载操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;磁盘或分区创建好文件系统后，需要挂载到一个目录才能够使用&lt;/li&gt;
&lt;li&gt;Windows 或 Mac 系统会进行自动挂载，一旦创建好文件系统后会自动挂载到系统上，Windows 上称之为 C 盘、D 盘等&lt;/li&gt;
&lt;li&gt;Linux 需要手工进行挂载操作或配置系统进行自动挂载&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mount-挂载命令&quot;&gt;4.2.2 MOUNT 挂载命令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在 Linux 中，我们通过 mount 命令将格式化好的磁盘或分区挂载到一个目录上
&lt;ul&gt;&lt;li&gt;mount /dev/sda3(要挂载的分区) /mnt(挂载点)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;常用参数：
&lt;ul&gt;&lt;li&gt;不带参数的 mount 命令会显示所有已挂载的文件系统&lt;/li&gt;
&lt;li&gt;-t 指定文件系统的类型&lt;/li&gt;
&lt;li&gt;-o 指定挂载选项 （如：mount -o remount,ro /dev/sdb1 /mnt/）
&lt;ul&gt;&lt;li&gt;ro, rw 以只读或读写形式挂载，默认是 rw&lt;/li&gt;
&lt;li&gt;sync 代表不使用缓存，而是对所有操作直接写入磁盘&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;async 代表使用缓存，默认是 async&lt;/li&gt;
&lt;li&gt;noatime 代表每次访问文件时不更新文件的访问时间&lt;/li&gt;
&lt;li&gt;atime 代表每次访问文件时更新文件的访问时间&lt;/li&gt;
&lt;li&gt;remount 重新挂载文件系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;umount-卸载挂载&quot;&gt;4.2.3 UMOUNT 卸载挂载&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;命令 umount 用来卸载已挂载的文件系统，相当于 Windows 中的弹出
&lt;ul&gt;&lt;li&gt;umount 文件系统/挂载点&lt;/li&gt;
&lt;li&gt;umount /dev/sda3&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;umount /mnt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果出现 device is busy 报错，则表示该文件系统正在被使用，无法卸载，可以使用以下命令查看使用文件系统的进程：
&lt;ul&gt;&lt;li&gt;fuser -m/mnt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;也可使用命令 lsof 查看正在被使用的文件
&lt;ul&gt;&lt;li&gt;lsof /mnt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自动挂载&quot;&gt;4.2.4 自动挂载&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;配置文件 /etc/fstab 用来定义需要自动挂载的文件系统，fstab 中每一行代表一个挂载配置，格式如下：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr class=&quot;header&quot;&gt;&lt;th&gt;/dev/sda3&lt;/th&gt;
&lt;th&gt;/mnt&lt;/th&gt;
&lt;th&gt;ext4&lt;/th&gt;
&lt;th&gt;defaults&lt;/th&gt;
&lt;th&gt;0 0&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;需要挂载的设备&lt;/td&gt;
&lt;td&gt;挂载点&lt;/td&gt;
&lt;td&gt;文件系统&lt;/td&gt;
&lt;td&gt;挂载选项&lt;/td&gt;
&lt;td&gt;dump、fsck相关选项&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;要挂载的设备也可以使用 LABEL 进行识别，使用 LABEL = LINUXCAST 取代 /dev/sda3&lt;/li&gt;
&lt;li&gt;mount -a 命令会挂载所有 fstab 中定义的自动挂载项&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 10 Sep 2019 15:18:00 +0000</pubDate>
<dc:creator>duncan1863</dc:creator>
<og:description>Linux 入门基础 一、Linux 系统安装 安装方法网上很多，请自行百度 二、Linux 基本操作 2.1、GNOME图形界面基本操作 操作类似于Windows系统操作 打开每一个文件夹都会打开一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duncan1863/p/11503763.html</dc:identifier>
</item>
<item>
<title>深入理解 ThreadLocal - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11503601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11503601.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上篇文章 &lt;a href=&quot;https://juejin.im/post/5d712cedf265da03ea5a9ecf&quot;&gt;深入理解 Handler 消息机制&lt;/a&gt; 中提到了获取线程的 Looper 是通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 来实现的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个线程都有自己的 Looper，它们之间不应该有任何交集，互不干扰，我们把这种变量称为 &lt;strong&gt;线程局部变量&lt;/strong&gt; 。而 &lt;code&gt;ThreadLocal&lt;/code&gt; 的作用正是存储线程局部变量，每个线程中存储的都是独立存在的数据副本。如果你还是不太理解，看一下下面这个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {

    ThreadLocal&amp;lt;Boolean&amp;gt; threadLocal = new ThreadLocal&amp;lt;Boolean&amp;gt;();
    threadLocal.set(true);

    Thread t1 = new Thread(() -&amp;gt; {
        threadLocal.set(false);
        System.out.println(threadLocal.get());
    });

    Thread t2 = new Thread(() -&amp;gt; {
        System.out.println(threadLocal.get());
    });

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println(threadLocal.get());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;false
null
true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们在不同的线程中调用同一个 ThreadLocal 的 get() 方法，获得的值是不同的，看起来就像 ThreadLocal 为每个线程分别存储了不同的值。那么这到底是如何实现的呢？一起来看看源码吧。&lt;/p&gt;
&lt;p&gt;以下源码基于 &lt;a href=&quot;https://github.com/lulululbj/jdk8u&quot;&gt;JDK 1.8&lt;/a&gt; , 相关文件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/jdk8u/blob/master/jdk/src/share/classes/java/lang/Thread.java&quot;&gt;Thread.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/jdk8u/blob/master/jdk/src/share/classes/java/lang/ThreadLocal.java&quot;&gt;ThreadLocal.java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;threadlocal&quot;&gt;ThreadLocal&lt;/h2&gt;
&lt;p&gt;首先 ThreadLocal 是一个泛型类，&lt;code&gt;public class ThreadLocal&amp;lt;T&amp;gt;&lt;/code&gt;，支持存储各种数据类型。它对外暴露的方法很少，基本就 &lt;code&gt;get()&lt;/code&gt; 、&lt;code&gt;set()&lt;/code&gt; 、&lt;code&gt;remove()&lt;/code&gt; 这三个。下面依次来看一下。&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;set()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t); // 获取当前线程的 ThreadLocalMap
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value); // 创建 ThreadLocalMap
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里出现了一个新东西 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，暂且就把他当做一个普通的 Map。从 &lt;code&gt;map.set(this, value)&lt;/code&gt; 可以看出来这个 map 的键是 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象，值是要存储的 &lt;code&gt;value&lt;/code&gt; 对象。其实看到这，ThreadLocal 的原理你应该基本都明白了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每一个 &lt;code&gt;Thread&lt;/code&gt; 都有一个 &lt;code&gt;ThreadLocalMap&lt;/code&gt; ，这个 Map 以 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象为键，以要保存的线程局部变量为值。这样就做到了为每个线程保存不同的副本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先通过 &lt;code&gt;getMap()&lt;/code&gt; 函数获取当前线程的 ThreadLocalMap ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来 Thread 还有这么一个变量 &lt;code&gt;threadLocals&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class.
*
* 存储线程私有变量，由 ThreadLocal 进行管理
*/
ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认为 &lt;code&gt;null&lt;/code&gt;，所以第一次调用时返回 null ，调用 &lt;code&gt;createMap(t, value)&lt;/code&gt; 进行初始化：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get&quot;&gt;get()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;set()&lt;/code&gt; 方法是向 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 中插值，那么 &lt;code&gt;get()&lt;/code&gt; 就是在 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 中取值了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t); // 获取当前线程的 ThreadLocalMap
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result; // 找到值，直接返回
        }
    }
    return setInitialValue(); // 设置初始值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取 ThreadLocalMap，在 Map 中寻找当前 ThreadLocal 对应的 value 值。如果 Map 为空，或者没有找到 value，则通过 &lt;code&gt;setInitialValue()&lt;/code&gt; 函数设置初始值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private T setInitialValue() {
    T value = initialValue(); // 为 null
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

protected T initialValue() {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setInitialValue()&lt;/code&gt; 和 &lt;code&gt;set()&lt;/code&gt; 逻辑基本一致，只不过 value 是 &lt;code&gt;null&lt;/code&gt; 而已。这也解释了文章开头的例子会输出 null。当然，在 ThreadLocal 的子类中，我们可以通过重写 &lt;code&gt;setInitialValue()&lt;/code&gt; 来提供其他默认值。&lt;/p&gt;
&lt;h3 id=&quot;remove&quot;&gt;remove()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;remove()&lt;/code&gt; 就更简单了，根据键直接移除对应条目。&lt;/p&gt;
&lt;p&gt;看到这里，&lt;code&gt;ThreadLocal&lt;/code&gt; 的原理好像就说完了，其实不然。&lt;code&gt;ThreadLocalMap&lt;/code&gt; 是什么样的一个哈希表呢？它是如何解决哈希冲突的？它是如何添加，获取和删除元素的？可能会导致内存泄露吗？&lt;/p&gt;
&lt;p&gt;其实 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 才是 &lt;code&gt;ThreadLocal&lt;/code&gt; 的核心。ThreadLocal 仅仅只是提供给开发者的一个工具而已，就像 Handler 一样。带着上面的问题，来阅读 ThreadLocalMap 的源码，体会 JDK 工程师的鬼斧神工。&lt;/p&gt;
&lt;h2 id=&quot;threadlocalmap&quot;&gt;ThreadLocalMap&lt;/h2&gt;
&lt;h3 id=&quot;entry&quot;&gt;Entry&lt;/h3&gt;
&lt;p&gt;ThreadLocalMap 是 ThreadLocal 的静态内部类，它没有直接使用 HashMap，而是一个自定义的哈希表，使用数组实现，数组元素是 &lt;code&gt;Entry&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
        super(k);
        value = v;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Entry&lt;/code&gt; 类继承了 &lt;code&gt;WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt;，我们可以把它看成是一个键值对。键是当前的 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象，值是存储的对象。注意 ThreadLocal 对象的引用是弱引用，值对象 value 的引用是强引用。ThreadLocal 使用弱引用其实很好理解，源码注释中也告诉了我们答案：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Thread&lt;/code&gt; 持有 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的强引用，&lt;code&gt;ThreadLocalMap&lt;/code&gt; 中的 &lt;code&gt;Entry&lt;/code&gt; 的键是 &lt;code&gt;ThreadLocal&lt;/code&gt; 引用。如果线程长期存活或者使用了线程池，而 &lt;code&gt;ThreadLocal&lt;/code&gt; 在外部又没有任何强引用了，这种情况下如果 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的键仍然使用强引用 &lt;code&gt;ThreadLocal&lt;/code&gt;，就会导致 ThreadLocal 永远无法被垃圾回收，造成内存泄露。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190910224403456-1542199275.webp&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;图片来源：https://www.jianshu.com/p/a1cd61fa22da&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，使用弱引用是不是就万无一失了呢？答案也是否定的。同样是上面说到使用情况，线程长期存活，由于 Entry 的 key 使用了弱引用，当 ThreadLocal 不存在外部强引用时，可以在 GC 中被回收。但是根据可达性分析算法，仍然存在着这么一个引用链：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Current Thread -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;key 已经被回收了，此时 &lt;code&gt;key == null&lt;/code&gt;。那么，&lt;code&gt;value&lt;/code&gt; 呢？如果线程长期存在，这个针对 value 的强引用也会一直存在，外部是否对 value 指向的对象还存在其他强引用也不得而知。所以这里还是有几率发生内存泄漏的。就算我们不知道外部的引用情况，但至少在这里应该是可以切断 &lt;code&gt;value&lt;/code&gt; 引用的。&lt;/p&gt;
&lt;p&gt;所以，为了解决可能存在的内存泄露问题，我们有必要对于这种 key 已经被 GC 的过期 Entry 进行处理，手动释放 value 引用。当然，JDK 中已经为我们处理了，而且处理的十分巧妙。下面就来看看 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的源码。&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;table&lt;/code&gt; 是存储 Entry 的数组，初始容量 &lt;code&gt;INITIAL_CAPACITY&lt;/code&gt; 是 16。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1)&lt;/code&gt; 是 ThreadLocalMap 计算哈希的方式。&lt;code&gt;&amp;amp;(2^n-1)&lt;/code&gt; 其实等同于 &lt;code&gt;% 2^n&lt;/code&gt;，位运算效率更高。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;threadLocalHashCode&lt;/code&gt; 是如何计算的呢？看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final int HASH_INCREMENT = 0x61c88647;

private static AtomicInteger nextHashCode = new AtomicInteger();

private final int threadLocalHashCode = nextHashCode();

private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0x61c88647&lt;/code&gt; 是一个增量，每次取哈希都要再加上这个数字。又是一个神奇的数字，让我想到了 &lt;code&gt;Integer&lt;/code&gt; 源码中的 &lt;code&gt;52429&lt;/code&gt; 这个数字，见 &lt;a href=&quot;https://juejin.im/post/5c76ad1ae51d4572c95835d0#heading-11&quot;&gt;走进 JDK 之 Integer&lt;/a&gt; 。&lt;code&gt;0x61c88647&lt;/code&gt; 背后肯定也有它的数学原理，总之肯定是为了效率。&lt;/p&gt;
&lt;p&gt;原理就不去探究了，其实我也不知道是啥原理。不过我们可以试用一下，看看效果如何。按照上面的方式来计算连续几个元素的哈希值，也就是在 Entry 数组中的位置。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {

    private static final int INITIAL_CAPACITY = 16;
    private static final int HASH_INCREMENT = 0x61c88647;
    private static AtomicInteger nextHashCode = new AtomicInteger();

    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }

    private static int hash() {
        return nextHashCode() &amp;amp; (INITIAL_CAPACITY - 1);
    }

    public static void main(String[] args) {

        for (int i = 0; i &amp;lt; 8; i++) {
            System.out.println(hash());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运算结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0
7
14
5
12
3
10
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算结果分布还是比较均匀的。既然是哈希表，肯定就会存在哈希冲突的情况。那么，ThreadLocalMap 是如何解决哈希冲突呢？很简单，看一下 &lt;code&gt;nextIndex()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static int nextIndex(int i, int len) {
    return ((i + 1 &amp;lt; len) ? i + 1 : 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在不超过 &lt;code&gt;len&lt;/code&gt; 的情况下直接加 1，否则置 0。其实这样又可以看成一个环形数组。&lt;/p&gt;
&lt;p&gt;接下来看看 ThreadLocalMap 的数据是如何存储的。&lt;/p&gt;
&lt;h3 id=&quot;set-1&quot;&gt;set()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1); // 当前 key 的哈希，即在数组 table 中的位置

    for (Entry e = tab[i];
        e != null; // 循环直到碰到空 Entry
        e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();

        if (k == key) { // 更新 key 对应的值
            e.value = value;
            return;
        }

        if (k == null) { // 替代过期 entry
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;通过 &lt;code&gt;key.threadLocalHashCode &amp;amp; (len-1)&lt;/code&gt; 计算出初始的哈希值&lt;/li&gt;
&lt;li&gt;不断调用 &lt;code&gt;nextIndex()&lt;/code&gt; 直到找到空 Entry&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在第二步遍历过程中的每个元素，要处理两种情况：&lt;/p&gt;
&lt;p&gt;(1). &lt;code&gt;k == key&lt;/code&gt;，说明当前 key 已存在，直接更新值即可，直接返回&lt;/p&gt;
(2). &lt;code&gt;k == null&lt;/code&gt;, 注意这里的前置条件是 &lt;code&gt;entry != null&lt;/code&gt;。说明遇到过期 Entry，直接替换&lt;/li&gt;
&lt;li&gt;不属于 3 中的两种情况，则将参数中的键值对插入空 Entry 处&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;cleanSomeSlots()/rehash()&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先来看看第三步中的第二种特殊情况。&lt;code&gt;Entry&lt;/code&gt; 不为空，但其中的 &lt;code&gt;key&lt;/code&gt; 为空，什么时候会发生这种情况呢？对，就是前面说到内存泄漏时提到的 &lt;strong&gt;过期 Entry&lt;/strong&gt;。我们都知道 Entry 的 key 是弱引用的 &lt;code&gt;ThreadLocal&lt;/code&gt;，当外部没有它的任何强引用时，下次 GC 时就会将其回收。所以这时候的 Entry 理论上也是无效的了。&lt;/p&gt;
&lt;p&gt;由于这里是在 set() 方法插入元素的过程中发现了过期 Entry，所以只要将要插入的 Entry 直接替换这个 &lt;code&gt;key==null&lt;/code&gt; 的 Entry 就可以了，这就是 &lt;code&gt;replaceStaleEntry()&lt;/code&gt; 的核心逻辑。&lt;/p&gt;
&lt;h3 id=&quot;replacestaleentry&quot;&gt;replaceStaleEntry()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void replaceStaleEntry(ThreadLocal&amp;lt;?&amp;gt; key, Object value, int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;
    Entry e;

    // Back up to check for prior stale entry in current run.
    // We clean out whole runs at a time to avoid continual
    // incremental rehashing due to garbage collector freeing
    // up refs in bunches (i.e., whenever the collector runs).
    // 向前找到第一个过期条目
    int slotToExpunge = staleSlot;
    for (int i = prevIndex(staleSlot, len);
        (e = tab[i]) != null;
        i = prevIndex(i, len))
        if (e.get() == null)
            slotToExpunge = i; // 记录前一个过期条目的位置

    // Find either the key or trailing null slot of run, whichever occurs first
    // 向后查找，直到找到 key 或者 空 Entry
    for (int i = nextIndex(staleSlot, len);
        (e = tab[i]) != null;
        i = nextIndex(i, len)) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();

        // If we find key, then we need to swap it
        // with the stale entry to maintain hash table order.
        // The newly stale slot, or any other stale slot
        // encountered above it, can then be sent to expungeStaleEntry
        // to remove or rehash all of the other entries in run.
        if (k == key) {

            // 如果在向后查找过程中发现 key 相同的 entry 就覆盖并且和过期 entry 进行交换
            e.value = value;

            tab[i] = tab[staleSlot];
            tab[staleSlot] = e;

            // Start expunge at preceding stale entry if it exists
            // 如果在查找过程中还未发现过期 entry，那么就以当前位置作为 cleanSomeSlots 的起点
            if (slotToExpunge == staleSlot)
                slotToExpunge = i;
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }

        // If we didn't find stale entry on backward scan, the
        // first stale entry seen while scanning for key is the
        // first still present in the run.
        // 如果向前未搜索到过期 entry，而在向后查找过程遇到过期 entry 的话，后面就以此时这个位置
        // 作为起点执行 cleanSomeSlots
        if (k == null &amp;amp;&amp;amp; slotToExpunge == staleSlot)
            slotToExpunge = i;
    }

    // If key not found, put new entry in stale slot
    // 如果在查找过程中没有找到可以覆盖的 entry，则将新的 entry 插入在过期 entry
    tab[staleSlot].value = null;
    tab[staleSlot] = new Entry(key, value);

    // If there are any other stale entries in run, expunge them
    // 在上面的代码运行过程中，找到了其他的过期条目
    if (slotToExpunge != staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来挺累人的。在我理解，&lt;code&gt;replaceStaleEntry&lt;/code&gt; 只是做一个标记的作用，在各种情况下最后都会调用 &lt;code&gt;cleanSomeSlots&lt;/code&gt; 来真正的清理过期条目。&lt;/p&gt;
&lt;p&gt;你可以看到 ``&lt;/p&gt;
&lt;h3 id=&quot;cleansomeslots&quot;&gt;cleanSomeSlots()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null &amp;amp;&amp;amp; e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i); // 需要清理的 Entry
        }
    } while ( (n &amp;gt;&amp;gt;&amp;gt;= 1) != 0);
    return removed;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数 &lt;code&gt;n&lt;/code&gt; 表示扫描控制。初始情况下扫描 &lt;code&gt;log2(n)&lt;/code&gt; 次，如果遇到过期条目，会再扫描 &lt;code&gt;log2(table.length)-1&lt;/code&gt; 次。在 &lt;code&gt;set()&lt;/code&gt; 方法中调用，参数 &lt;code&gt;n&lt;/code&gt; 表示元素的个数。在 &lt;code&gt;replaceStaleEntry&lt;/code&gt; 中调用，参数 &lt;code&gt;n&lt;/code&gt; 表示的是数组 &lt;code&gt;table&lt;/code&gt; 的长度。&lt;/p&gt;
&lt;p&gt;注意 do 循环里面的判断条件：&lt;code&gt;e != null &amp;amp;&amp;amp; e.get() == null&lt;/code&gt; ，还是那些 Entry 不为空，key 为空的过期条目。发现过期条目之后，调用 &lt;code&gt;expungeStaleEntry()&lt;/code&gt; 去清理。&lt;/p&gt;
&lt;h3 id=&quot;expungestaleentry&quot;&gt;expungeStaleEntry()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private int expungeStaleEntry(int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;

    // expunge entry at staleSlot
    // 清空 staleSlot 处的 过期 entry
    // 将 value 置空，保证不会因为这里的强引用造成 memory leak
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    size--;

    // Rehash until we encounter null
    // 继续搜索直到遇到 tab 中的空 entry
    Entry e;
    int i;
    for (i = nextIndex(staleSlot, len);
        (e = tab[i]) != null;
        i = nextIndex(i, len)) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();
        if (k == null) { // 搜索过程中遇到过期条目，直接清理
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            // key 还没有被回收
            int h = k.threadLocalHashCode &amp;amp; (len - 1);
            if (h != i) {
                tab[i] = null;

                // Unlike Knuth 6.4 Algorithm R, we must scan until
                // null because multiple entries could have been stale.
                while (tab[h] != null)
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i; // 此时从 staleSlot 到 i 之间不存在过期条目
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接将 &lt;code&gt;entry.value&lt;/code&gt; 和 &lt;code&gt;entry&lt;/code&gt; 都置空，消除内存泄露的隐患。注意这里仅仅只是置空，并不是回收对象。因为你不知道 &lt;code&gt;value&lt;/code&gt; 在外部的引用情况，只需要管好自己的引用就可以了。&lt;/p&gt;
&lt;p&gt;除此之外，不甘寂寞的 &lt;code&gt;expungeStaleEntry()&lt;/code&gt; 又发起了一次扫描，直到碰到空 Entry未知。期间遇到的过期 Entry 要置空。&lt;/p&gt;
&lt;p&gt;整个 &lt;code&gt;set()&lt;/code&gt; 方法就看完了，原理很简单，但是其中关于内存泄漏的预防处理十分复杂，看的我一度放弃了，也让我对源码阅读产生了一些疑问。有些时候是不是没有必要逐行去玩去完全理解？比如这一系列关于内存泄露的处理，核心思想就是清理 Entry 不为 null 但 key 为 null 的过期条目。理解了核心思想，对于其中复杂的细节处理是不是没有必要去深究？不知道你怎么看，欢迎在评论区写下你的看法。&lt;/p&gt;
&lt;p&gt;下面来看一看 &lt;code&gt;getgetEntry&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;getentry&quot;&gt;getEntry()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Entry getEntry(ThreadLocal&amp;lt;?&amp;gt; key) {
    int i = key.threadLocalHashCode &amp;amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;amp;&amp;amp; e.get() == key) // 直接命中
        return e;
    else
        // 未直接命中，线性探测，继续往后找
        return getEntryAfterMiss(key, i, e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getEntry()&lt;/code&gt; 比较粗暴，上来直接根据哈希值查找 table 数组，如果直接命中，就返回。未直接命中，调用 &lt;code&gt;getEntryAfterMiss()&lt;/code&gt; 继续查找。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Entry getEntryAfterMiss(ThreadLocal&amp;lt;?&amp;gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    // 向后查找直到遇到空 entry
    while (e != null) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();
        if (k == key) // get it
            return e;
        if (k == null) // key 等于 null，清理过期 entry
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len); // 继续向后查找
        e = tab[i];
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;nextIndex()&lt;/code&gt; 向后查找，直到遇到 空 Entry，也就是队尾：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;k==key&lt;/code&gt;，说明找到了对应 Entry&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k==null&lt;/code&gt;，说明遇到了过期 Entry，调用 &lt;code&gt;expungeStaleEntry()&lt;/code&gt; 处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对过期 Entry 的处理真的是无处不在，就是为了最大程度的降低内存泄漏发生的几率。那么有没有什么一劳永逸的办法呢？那就是 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的 &lt;code&gt;remove()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;remove-1&quot;&gt;remove()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void remove(ThreadLocal&amp;lt;?&amp;gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1);
    for (Entry e = tab[i];
        e != null;
        e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接清除当前 ThreadLocal 对应的 Entry，根本上避免了发生内存泄露。所以，当我们不再需要使用 ThreadLocal 中的相应数据时，调用一下 &lt;code&gt;remove()&lt;/code&gt; 方法肯定是个好习惯。&lt;/p&gt;
&lt;p&gt;虽然在长期存活的线程（例如线程池）中使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 并发生内存泄漏是一个小概率事件，但 JDK 开发者却为此多写了很多代码。我们在使用中也要多加注意，仔细考虑是否会涉及到内存泄露的问题。&lt;/p&gt;
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;
&lt;p&gt;最后说说在网上看到的一个观点，&lt;strong&gt;ThreadLocal 比 Synchronized 更适合解决线程同步问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先这个问题本身就不是那么严谨。&lt;code&gt;ThreadLocal&lt;/code&gt; 是用来解决线程同步问题的吗？表面上看，&lt;code&gt;ThreadLocal&lt;/code&gt; 的机制的确是线程安全的，但它并不是为了解决多线程访问同一个变量的竞争问题，而是给每一个线程都提供单独的变量，有些文章称之为 &lt;strong&gt;数据备份&lt;/strong&gt;，但它们并不是备份，每一个都是独立存在的，互不干扰，并不存在什么同步问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 和 &lt;code&gt;Synchronized&lt;/code&gt; 的应用场景也是千差万别的。例如银行的转账场景，涉及多个账户同时转账的多线程同步问题，&lt;code&gt;ThreadLocal&lt;/code&gt; 根本就没法解决，即使每个线程都单独保存着用户的余额也没法解决并发问题。&lt;code&gt;ThreadLocal&lt;/code&gt; 在 Android 中的典型应用就是 &lt;code&gt;Looper&lt;/code&gt;，每个线程都有自己的 &lt;code&gt;Looper&lt;/code&gt; 对象，它们都是独立工作，互不干扰的。&lt;/p&gt;
&lt;p&gt;关于 ThreadLocal 就说到这里了。后续分享的方向主要集中在两块，一方面是 AOSP 源码的阅读和解析，另一方面是 Kotlin 和 Java 相关特性的对比，敬请期待！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190910224404807-1607361594.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 14:44:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>前言 上篇文章 '深入理解 Handler 消息机制' 中提到了获取线程的 Looper 是通过 来实现的： 每个线程都有自己的 Looper，它们之间不应该有任何交集，互不干扰，我们把这种变量称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11503601.html</dc:identifier>
</item>
<item>
<title>04 python之函数详解 - Tammy~</title>
<link>http://www.cnblogs.com/Summer-skr--blog/p/11498293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer-skr--blog/p/11498293.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、函数初识&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;函数的产生：函数就是封装一个功能的代码片段。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
li = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autumn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function():
    count &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li:
        count &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
function()　　　　　　　　# 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;def 关键字,定义一个函数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;function 函数名的书写规则与变量一样。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;括号是用来传参的。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;函数体,就是函数里面的逻辑代码&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;代码从上至下执行，执行到def function() 时, 将function这个变量名&lt;strong&gt;加载到临时内存中，但它不执行&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数的执行：函数名 + () &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;__name_&lt;/strong&gt;&lt;strong&gt;_方法获取&lt;/strong&gt;函数名 ，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;__doc___&lt;/strong&gt;&lt;strong&gt;方法获取&lt;/strong&gt;函数的解释  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    此函数是完成登陆的功能，参数分别是...作用。
    return: 返回值是登陆成功与否（True，False）
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__name__&lt;/span&gt;)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取函数名&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__doc__&lt;/span&gt;)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取函数名注释说明 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666&lt;span&gt;
func1
此函数是完成登陆的功能，参数分别是...作用。
return: 返回值是登陆成功与否（True，False）&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这个有什么用呢？比如日志功能，需要打印出谁在什么时间，调用了什么函数，函数是干啥的，花费了多次时间，这个时&lt;/span&gt;&lt;span&gt;候，就需要获取函数的有用信息了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. &lt;strong&gt;函数返回值&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写函数，不要在函数中写print()&lt;/strong&gt;&lt;strong&gt;,  &lt;/strong&gt;&lt;strong&gt;函数是以功能为导向的，除非测试的时候，才可以写print()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;在函数中，遇到return结束函数&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(111&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(444&lt;span&gt;)
fun() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：111&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;将值返回给函数的调用者&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    a &lt;/span&gt;= 134
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(fun()) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：123&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;1）&lt;strong&gt;无 return&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(fun()) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：&lt;span&gt;&lt;strong&gt;None&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）&lt;strong&gt;return 1个值&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;该值是什么，就直接返回给函数的调用者，函数名()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(fun()) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;3）&lt;strong&gt;return 多个值&lt;/strong&gt; 将多个值&lt;strong&gt;放到一个&lt;span&gt;元组&lt;/span&gt;里&lt;/strong&gt;，返回给函数的调用者。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1,2,[33,44],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(fun()) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
(1, 2, [33, 44], 'abc')&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;2. &lt;strong&gt;函数的传参&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;实参：&lt;/span&gt;在函数执行者里面的参数叫实参&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①&lt;strong&gt;位置参数：按顺序&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;一一对应&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(a,b,c):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

func(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fdsafdas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3,4&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
fdsafdas
3
4&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果少一个参数呢?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(a,b,c):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

func(&lt;/span&gt;3,4&lt;span&gt;) &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行报错：TypeError: func() missing 1 required positional argument: 'c'&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;必须是一一对应的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; compare(x,y):
    ret &lt;/span&gt;=&lt;span&gt;&lt;strong&gt; x if x &amp;gt; y else y   #三元运算，针对简单的if else才能使用&lt;/strong&gt;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(compare(123,122334))        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 122334&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②&lt;strong&gt;关键字参数：可以不按顺序，但是必须一一对应&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; compare(x,y):
    ret &lt;/span&gt;= &lt;strong&gt;x &lt;span&gt;if&lt;/span&gt; x &amp;gt; y &lt;span&gt;else&lt;/span&gt;&lt;span&gt; y
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(compare(y=13,x=1&lt;span&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行结果：13&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;③&lt;strong&gt;混合参数：关键字参数一定要在位置参数后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(a,b,c,d,e):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)

func1(&lt;/span&gt;1,4,d=2,c=3,e=5&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
1
4
3
2
5&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2） 形参：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①&lt;strong&gt;位置参数：按顺序和实参一一对应，位置参数必须传值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(a,b,c):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

func(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fdsafdas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3,4&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
fdsafdas
3
4&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;②&lt;strong&gt;默认参数：传参则覆盖，不传则默认，默认参数永远在位置参数后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(a,b=666&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a,b)
func(&lt;/span&gt;1,2&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：1 2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(a,b=666&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a,b)
func(&lt;/span&gt;1&lt;span&gt;) 

执行输出：&lt;/span&gt;1 666
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;举一个场景：班主任录入员工信息表，&lt;/span&gt;&lt;span&gt;有2个问题：&lt;/span&gt;&lt;span&gt;第一，男生居多；&lt;/span&gt;&lt;span&gt;第二，完成函数功能 &lt;span&gt;&lt;strong&gt;*****&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;  Infor(username,sex=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;strong&gt;&lt;span&gt;mode='a'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;) as f1:
        f1.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}\t{}\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(username,sex))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    username &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入姓名(男生以1开头)：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; username:
        username &lt;/span&gt;= username[1:]        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去除1&lt;/span&gt;
&lt;span&gt;        Infor(username)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        Infor(username,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;③动态参数&lt;/strong&gt;：&lt;strong&gt;当函数的&lt;em&gt;&lt;span&gt;形参数量不一定时&lt;/span&gt;&lt;/em&gt;，可以使用动态参数。用*args和**kwargs接收，args是&lt;span&gt;元组&lt;/span&gt;类型，接收除键值对以外的参数（接收位置参数），kwargs是&lt;span&gt;字典&lt;/span&gt;类型，接收键值对(关键字参数)&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;并保存在字典中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args,type(args))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs,type(kwargs))

func(&lt;/span&gt;1,2,3,4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;输出结果是：
(1, 2, 3, 4, 'alex') &amp;lt;class 'tuple'&amp;gt;&lt;span&gt;
{'name': 'alex'} &amp;lt;class 'dict'&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“ * &quot;的魔性作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）在函数定义时：*位置参数和**关键字参数代表聚合&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将所有实参的位置参数聚合到一个元组中，并将这个元组赋值给args。在关键参数前加“ ** ”代表将实参的关键字参数聚合到一个字典中，并将这个字典赋值给kwargs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;将2个列表的所有元素赋值给args&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(*&lt;span&gt;args):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)

l1 &lt;/span&gt;= [1,2,30&lt;span&gt;]
l2 &lt;/span&gt;= [1,2,33,21,45,66&lt;span&gt;]
func(&lt;/span&gt;*&lt;span&gt;l1)
func(&lt;/span&gt;*l1,*&lt;span&gt;l2) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
(1, 2, 30&lt;span&gt;)
(1, 2, 30, 1, 2, 33, 21, 45, 66)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;传两个字典给**kwargs&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)

dic1 &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:22&lt;span&gt;}
dic2 &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rose&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:21&lt;span&gt;}
func(&lt;/span&gt;**dic1,**&lt;span&gt;dic2) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
{'name': 'jack', 'age': 22, 'name1': 'rose', 'age1': 21}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;args,&lt;span&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)

func(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;[1,2,3], &lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;[4,5,6], &lt;span&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/span&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},&lt;strong&gt;&lt;span&gt; **&lt;/span&gt;&lt;/strong&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:18})  　&lt;strong&gt;　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于func([1,2,3,4,5,6], {'name':'alex','age':18&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;})&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）在函数的调用执行时，&lt;/strong&gt;&lt;strong&gt;打散&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　*可迭代对象，代表打散(list,tuple,str,dict(键))将元素一一添加到args。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 **字典，代表打散，将所有键值对放到一个kwargs字典里。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;args,&lt;strong&gt;&lt;span&gt;**&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;print&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;(args,kwargs)&lt;/strong&gt;

dic1 &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:22&lt;span&gt;}
dic2 &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rose&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:21&lt;span&gt;}

func(&lt;/span&gt;*[1,2,3,4],&lt;span&gt;&lt;strong&gt;*&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;asdk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;strong&gt;&lt;span&gt;**&lt;/span&gt;&lt;/strong&gt;dic1,&lt;span&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;dic2) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：(1, 2, 3, 4, 'a', 's', 'd', 'k') {'age1': 21, 'name': 'jack', 'age': 22, 'name1': 'rose'}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;形参的顺序：&lt;/strong&gt;&lt;strong&gt;位置参数 ----&amp;gt; *args -----&amp;gt;关键字参数&lt;/strong&gt;&lt;strong&gt;--------&amp;gt;默认参数&lt;/strong&gt;&lt;strong&gt; -------&amp;gt;**kwargs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;*args参数，可以不传，默认为空()，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;**kwargs 动态传参，他将所有的关键字参数(未定义的)放到一个字典中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func(a,b,c,d,*args,e=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;(a,b,c,d,args,e,kwargs)&lt;/strong&gt;&lt;/span&gt;

func(&lt;/span&gt;1,2,3,4,5,6,7,v=3,m=7,h=9,e=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：&lt;span&gt;&lt;strong&gt;1 2 3 4 (5, 6, 7) 女 {'v': 3, 'h': 9, 'm': 7}&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
def func(a,b,&lt;strong&gt;&lt;span&gt;c&lt;/span&gt;&lt;/strong&gt;,**&lt;span&gt;kwargs):
    print&lt;span&gt;(kwargs)
func(1,2,r=4,b1=5,c1=6&lt;span&gt;,c=7&lt;/span&gt;&lt;span&gt;) 

执行输出：{'r': 4, 'c1': 6, 'b1': 5}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行没有报错，是因为函数接收参数后，它会从左边到右找，最后找到了c，c=7参数，&lt;strong&gt;在a,b,c里面已经定义好了，所以在输出的字典中，并未出现。因为kwargs返回的是未定义的关键字参数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果函数含有多个未知参数，一般使用如下格式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; func1(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
func1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;strong&gt;命名空间和作用域&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　当执行函数的时候，他会在内存中开辟一个临时名称空间，存放函数体内的所有变量与值的关系，随着函数的执行完毕，临时空间自动关闭。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数里面的变量，在函数外面能直接引用么？&lt;/strong&gt;&lt;strong&gt;不能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    m &lt;/span&gt;= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(m)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(m)                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; NameError: name 'm' is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面为什么会报错呢？现在我们来分析一下python内部的原理是怎么样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们首先回忆一下Python代码运行的时候遇到函数是怎么做的，从Python解释器开始执行之后，就在内存中开辟里一个空间，每当遇到一个变量的时候，就把变量名和值之间对应的关系记录下来，但是当遇到函数定义的时候，&lt;strong&gt;解释器只是象征性的将函数名读入内存，表示知道这个函数存在了，至于函数内部的变量和逻辑，解释器根本不关心。等执行到函数调用的时候，Python解释器会再开辟一块内存来储存这个函数里面的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量会储存在新开辟出来的内存中，函数中的变量只能在函数内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. &lt;strong&gt;命名空间和作用域&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命名空间：存放”名字与值关系的空间“&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①全局命名空间：代码在运行时，创建的存储”变量名与值的关系“的内存空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②局部命名空间：在函数调用时临时开辟出来的空间，会随着函数的执行完毕而被清空&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③内置命名空间：存放了python解释器为我们提供的名字：input,print,str,list,tuple...它们都是我们熟悉 的，拿过来就可以用的方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用域&lt;/strong&gt;：就是作用范围&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①全局作用域：全局命名空间、内置命名空间。在整个文件的任意位置都能被引用、全局有效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②局部作用域：局部命名空间，只能在局部范围内生效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;加载顺序：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内置命名空间（程序运行前加载）-----&amp;gt;   全局命名空间（程序运行中从上至下加载） -----&amp;gt; 局部命名空间（程序运行中：调用时才加载)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;取值顺序：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在局部调用：局部命名空间-&amp;gt;全局命名空间-&amp;gt;内置命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在全局调用：全局命名空间-&amp;gt;内置命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上所述，&lt;strong&gt;在找寻变量时，从小范围，一层一层到大范围去找寻。取值顺序：就近原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;局部变量举例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
func1()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：spring&lt;br/&gt;&lt;span&gt;取值是从内到外&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
func1() &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;执行输出：老男孩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码从上至下依次执行， 调用函数：函数里面从上至下依次执行。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(111&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(333&lt;span&gt;)
    func2()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(444&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(555&lt;span&gt;)
    func2()

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(222&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
111
333
444
666
222&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f2():
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3():
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in f3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in f2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        f3()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in f1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    f2()
f1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
in f1
in f2
in f3&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;2. &lt;strong&gt;globals和locals方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(globals())  　　　　   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;全局名称空间所有变量，字典&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(locals())  　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;局部名称空间所有变量，字典 （当前）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;globals()和locals()一般很少用，在函数逻辑比较复杂的情况下，可能会用到。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
li = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autumn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    a &lt;/span&gt;= 1&lt;span&gt;
    b &lt;/span&gt;= 2
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, globals())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, locals())

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
        c &lt;/span&gt;= 3&lt;span&gt;
        d &lt;/span&gt;= 4
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, globals())
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, locals())

    func1()

func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
func {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x011CC410&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__annotations__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/Administrator/houseinfo/test.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__cached__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autumn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function func at 0x03542E40&amp;gt;&lt;span&gt;}
func {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;}
func1 {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x011CC410&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__annotations__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/Administrator/houseinfo/test.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__cached__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autumn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function func at 0x03542E40&amp;gt;&lt;span&gt;}
func1 {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;span&gt;（1）global：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;①在局部命名空间&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;声明&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;&lt;strong&gt;global&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; name&lt;/strong&gt;&lt;/span&gt;
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

func2()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行结果：summer&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;②在局部命名空间对全局变量进行&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;修改&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;(限于字符串，数字)。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;count = 1&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;global&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; count&lt;/span&gt;&lt;/strong&gt;
    count &lt;/span&gt;= count + 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行结果：&lt;br/&gt;2 &lt;br/&gt;2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;因为全局变量count被函数体的global count 覆盖了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）nonlocal&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;strong&gt;子函数对父函数的变量进行修改，&lt;span&gt;此变量不能是全局变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a = 4
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    nonlocal a
    a &lt;/span&gt;= 5             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改全局变量&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(name)&lt;/span&gt;
&lt;span&gt;func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：SyntaxError: no binding for nonlocal 'a'&lt;span&gt; found&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;②&lt;/strong&gt;&lt;strong&gt;在局部作用域中，对父级作用域的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    b &lt;/span&gt;= 6
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
        b &lt;/span&gt;= 666
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    func2()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;父级不受影响&lt;/span&gt;
&lt;span&gt;func1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666
6&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    b &lt;/span&gt;= 6
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
&lt;span&gt;&lt;strong&gt;        nonlocal b          &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;#表示可以影响父级，也就是func1()&lt;/strong&gt;&lt;/span&gt;
        b = 666             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;重新赋值&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    func2()    
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个时候，影响了b的值，输出666&lt;/span&gt;
&lt;span&gt;func1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666
666&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;******&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; aa():                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不受ccl影响&lt;/span&gt;
    b = 42
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; bb():
        b &lt;/span&gt;= 10                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;影响子级函数，b都是10&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cc():
            nonlocal b             &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只能影响父级，也就是bb()&lt;/span&gt;
            b = b + 20             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;b=10+20 也就是30&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
        cc()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    bb()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
aa()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
10
30
30
42&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a = 5
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    a &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
func1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行报错。&lt;/span&gt;&lt;span&gt;这里函数对全局变量做了改变，是不允许操作的。函数内部可以引用全局变量，不能修改。如果要修改，必须要global一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a = 5
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    a &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)

func1()     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;三、装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;函数名应用&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;函数名是什么？函数名是函数的名字，本质：变量，特殊的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;函数名就是函数的内存地址，直接打印函数名，就是打印内存地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(123&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1) 　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;function func1 at 0x0000029042E02E18&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;函数名可以作为变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(111&lt;span&gt;)

f &lt;/span&gt;=&lt;span&gt; func1
f()       　　　　　　　　　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; f() 就是func1()    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;函数名可以作为函数的参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(111&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(x):
    x()

func2(func1) 　　　　　　　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;func1作为func2的参数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;函数名可以作为函数的返回值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner
f &lt;/span&gt;=&lt;span&gt; wrapper()
f()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;函数名可以作为容器类类型的元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;使用for循环批量执行函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

l1 &lt;/span&gt;=&lt;span&gt; [func1,func2,func3]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l1:
    i()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;像上面函数名这种，叫做第一类对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一类对象( first-class object)&lt;/strong&gt;指：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.可在运行期创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.可用作函数参数或返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.可存入变量的实体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*不明白？那就记住一句话，就当普通变量用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;闭包&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、什么是闭包：&lt;span&gt;&lt;strong&gt;内层函数对外层函数变量（非全局变量）的引用，并返回内层函数名，就形成了闭包&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、闭包的作用：爬虫、装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序执行遇到函数执行时，会在内存空间开辟局部命名空间，当函数执行完毕，该命名空间会被销毁。但是如果这个函 数内部形成闭包，则该内存空间不会随着函数执行完而消失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、如何判断是否是闭包：print(函数名.__closure__) 结果是&lt;strong&gt;cell&lt;/strong&gt;说明是闭包，结果是&lt;strong&gt;None&lt;/strong&gt;说明不是闭包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包函数&lt;/strong&gt;：内部函数包含对外部作用域而非全剧作用域变量的引用，该内部函数称为闭包函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包举例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper():
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
    inner()

wrapper()     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; summer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何判断它是否是一个闭包函数呢？ 内层函数名.__closure__  cell 就是=闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper():
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
    inner()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(inner.&lt;span&gt;__closure__&lt;/span&gt;&lt;span&gt;)

wrapper()     &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
&lt;span&gt;summer
(&amp;lt;cell at 0x0000017FC9C90B58: str object at 0x0000017FCA349AD0&amp;gt;,)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
    inner()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(inner.&lt;span&gt;__closure__&lt;/span&gt;&lt;span&gt;)

wrapper() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;结果输出：
summer
None&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;返回值为None 表示它不是闭包，因为name是一个全局变量，如果函数调用了外层变量而非全局变量，那么它就是闭包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper2():
    name1 &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name1)
    inner()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(inner.&lt;span&gt;__closure__&lt;/span&gt;&lt;span&gt;)

wrapper2()&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;结果输出：
summer
spring
(&amp;lt;cell at 0x030B7310: str object at 0x03043680&amp;gt;,)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;只要引用了外层变量至少一次，非全局的，它就是闭包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;4：判断&lt;/strong&gt;&lt;strong&gt;下面的函数，是一个闭包吗？&lt;/strong&gt;&lt;strong&gt;******&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wraaper2(n):　　　　　　　　&lt;strong&gt;#相当于n &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　def&lt;/span&gt;&lt;span&gt; inner():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
    inner()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(inner.&lt;span&gt;__closure__&lt;/span&gt;&lt;span&gt;)  

wraaper2(name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;结果输出：
summer
(&amp;lt;cell at 0x03867350: str object at 0x037F3680&amp;gt;,)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;它也是一个闭包. 虽然wraaper2传了一个全局变量，但是在函数wraaper2内部，inner引用了外层变量，相当于在函数inner外层定义了 n = 'summer'，所以inner是一个闭包函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包的好处&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;strong&gt;当函数开始执行时，如果遇到了闭包，他有一个机制，他会永远开辟一个内存空间，将闭包中的变量等值放入其中，不会随着函数的执行完毕而消失。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 举一个例子：爬3次，内存开了3次，很占用内存&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; urllib.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlopen
content1 &lt;/span&gt;= urlopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
content2 &lt;/span&gt;= urlopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
content3 &lt;/span&gt;= urlopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;把它封装成闭包&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; urllib.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlopen

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get():
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; urlopen(url).read()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; get　　　　　　　　#return的是get，就是一个函数名

cnblog &lt;/span&gt;=&lt;span&gt; index()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(cnblog)               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;function index.&amp;lt;locals&amp;gt;.get at 0x02F46978&amp;gt;&lt;/span&gt;
content =&lt;span&gt; cnblog()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(content)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面源码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子，只有第一遍，是从网站抓取的。之后的执行，直接从内存中加载，节省内存空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. &lt;strong&gt;装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;3.1 装饰器初识&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰器本质&lt;/strong&gt;：&lt;strong&gt;就是一个python函数，他可以让其他函数&lt;span&gt;在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰器的应用场景：&lt;/strong&gt;比如插入日志，性能测试，事务处理，缓存等等场景。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; timmer(f):                     　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  2接收参数 f = func1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner():
        start_time &lt;/span&gt;= time.time()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.进入inner函数&lt;/span&gt;
        f()                         　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.执行f(),也就是原来的func1函数。虽然func1被覆盖了,但是之前的值还存在。                            请参考上面a,b赋值的例子&lt;/span&gt;
        end_time = time.time()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 10 获取当前时间&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行时间为{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(end_time - start_time))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 11.输出差值&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; inner                     　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.将inner函数返回给函数调用者timmer(func1),此时程序结束，继续执行func1()&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; func1():                         　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7.进入函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)         　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  8.打印输出&lt;/span&gt;
    time.sleep(1)              　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  9.等待1秒&lt;/span&gt;
&lt;span&gt;
func1 &lt;/span&gt;= timmer(func1)         　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.等式计算右边的，将func1函数传给timmer函数,此时func1被覆盖了,原来func1的不存在了。&lt;br/&gt;print(func1)&lt;br/&gt;&lt;/span&gt;func1()                 　　　　　　　　　　&lt;span&gt;&lt;strong&gt;# 4.这里的func1是全新的func1，就是上面的赋值，此时相当于执行 inner函数&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;输出结果：
&amp;lt;function timmer.&amp;lt;locals&amp;gt;.inner at 0x03822DF8&amp;gt;
in&lt;span&gt; func1
此函数的执行时间为1.0003533363342285&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;代码从上至下执行&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;语法糖：&lt;/strong&gt;想测试谁，前面加@装饰器函数，即可。&lt;strong&gt;写装饰器，约定俗成，函数名为wrapper&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;被装饰函数之前&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ret &lt;/span&gt;= func(*args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;被装饰函数之后&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args,kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 666

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(func())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;输出结果：
() {}
666&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;装饰器利用return制造了一个假象，func()执行，其实是执行inner()&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;func()把原来的func()给覆盖了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;3.2 装饰器传参&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;1：&lt;/strong&gt;&lt;strong&gt;上面装饰器的例子，func1，要传2个参数a,b&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timmer(f):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner(&lt;span&gt;&lt;strong&gt;a,b&lt;/strong&gt;&lt;/span&gt;):
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        f(a,b)
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行时间为{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(end_time -&lt;span&gt; start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@timmer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(a,b):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in func1 {}{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(a,b))
    time.sleep(&lt;/span&gt;1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟程序逻辑&lt;/span&gt;
&lt;span&gt;
func1(&lt;/span&gt;1,2&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
in func1 12
此函数的执行时间为1.0006024837493896&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;2：&lt;/strong&gt;&lt;strong&gt;如果有多个参数呢？改成动态参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timmer(f):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        f(&lt;/span&gt;*args,**&lt;span&gt;kwargs)
        end_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行时间为{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(end_time -&lt;span&gt; start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@timmer
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func1(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in func1 {}{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(args,kwargs))
    time.sleep(&lt;/span&gt;1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟程序逻辑&lt;/span&gt;
&lt;span&gt;
func1(&lt;/span&gt;1,2,a=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,b=4&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
in func1 (1, 2){'b': 4, 'a': '3'&lt;span&gt;}
此函数的执行时间为1.000101089477539&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数的执行时，*打散&lt;/strong&gt;&lt;strong&gt;;&lt;/strong&gt; &lt;strong&gt;函数的定义时，*聚合。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(f):                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f = func1&lt;/span&gt;
&lt;span&gt;
    @wraps(f)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**kwargs):         　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;聚合，args （1,2,3）&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之前的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ret &lt;/span&gt;= f(*args,**kwargs)          　　　　 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打散 1,2,3&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之后的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; func1 = wrapper(func1)  func1 = inner&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; func1(*args):                     　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;args (1,2,3) 聚合&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; args

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1(*[1,2,3&lt;span&gt;]))  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666&lt;span&gt;
(1, 2, 3)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;*****&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.加载模块&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; timmer(*args,**kwargs):                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.加载变量  5.接收参数True,2,3&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; wrapper(f):                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;6.加载变量  8.f = func1&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(args, kwargs)                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;9.接收timmer函数的值True,2,3&lt;/span&gt;

        &lt;span&gt;def&lt;/span&gt; inner(*args,**kwargs):                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;10.加载变量. 13.执行函数inner&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; flag:                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;14 flag = True&lt;/span&gt;
                start_time = time.time()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;15 获取当前时间&lt;/span&gt;
                ret = f(*args,**kwargs)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;16 执行func1&lt;/span&gt;
                time.sleep(0.3)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;19 等待0.3秒&lt;/span&gt;
                end_time = time.time()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;20 获取当前时间&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行效率%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (end_time-start_time)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;21 打印差值&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                ret &lt;/span&gt;= f(*args, **&lt;span&gt;kwargs)

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ret                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;22 返回给函数调用者func1()&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; inner                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;11 返回给函数调用者wrapper&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; wrapper                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7.返回给函数调用timmer(flag,2,3)&lt;/span&gt;
&lt;span&gt;
flag &lt;/span&gt;= True                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 加载变量&lt;/span&gt;
@timmer(flag,2,3)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.执行函数timmer(flag,2,3) 17.执行函数func1 两步：1，timmer(flag,2,3) 相当于执行wrapper                                                     2.@wrapper 装饰器 func1 = wrapper(func1)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; func1(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 666                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;18 返回给函数调用者f(*args,**kwargs)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(func1())                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;12 执行函数 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;4：&lt;/strong&gt;&lt;strong&gt;假定现在有100个函数，都加上了装饰器，增加了显示函数执行时间的功能，现在需要去掉！直接在装饰器函数加一个参数即可。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('58f40310-1e1f-4f90-9a2c-a2e5821fbd62')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_58f40310-1e1f-4f90-9a2c-a2e5821fbd62&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58f40310-1e1f-4f90-9a2c-a2e5821fbd62&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('58f40310-1e1f-4f90-9a2c-a2e5821fbd62',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58f40310-1e1f-4f90-9a2c-a2e5821fbd62&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
flag &lt;/span&gt;=&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper(f):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
            start_time &lt;/span&gt;=&lt;span&gt; time.time()
            ret &lt;/span&gt;= f(*args,**&lt;span&gt;kwargs)
            time.sleep(&lt;/span&gt;0.3&lt;span&gt;)
            end_time &lt;/span&gt;=&lt;span&gt; time.time()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行效率%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (end_time-&lt;span&gt;start_time))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            ret &lt;/span&gt;= f(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func1(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args,kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 666

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(func1()) 

执行输出：
此函数的执行效率0.&lt;/span&gt;300431
666
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;strong&gt;5：&lt;/strong&gt;&lt;strong&gt;现在需要关闭显示执行时间&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;直接将flag改成false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('25b69add-47af-4633-9ee0-1e5bbb5b97e6')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_25b69add-47af-4633-9ee0-1e5bbb5b97e6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_25b69add-47af-4633-9ee0-1e5bbb5b97e6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('25b69add-47af-4633-9ee0-1e5bbb5b97e6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_25b69add-47af-4633-9ee0-1e5bbb5b97e6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
flag &lt;/span&gt;=&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper(f):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; flag:
            start_time &lt;/span&gt;=&lt;span&gt; time.time()
            ret &lt;/span&gt;= f(*args,**&lt;span&gt;kwargs)
            time.sleep(&lt;/span&gt;0.3&lt;span&gt;)
            end_time &lt;/span&gt;=&lt;span&gt; time.time()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此函数的执行效率%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (end_time-&lt;span&gt;start_time))
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            ret &lt;/span&gt;= f(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func1(*args,**&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args,kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 666

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(func1()) 

执行输出：
() {}
&lt;/span&gt;666
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样，所有调用的地方，就全部关闭了，非常方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;写装饰器，一般嵌套3层就可以了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;3.3&lt;/strong&gt; &lt;strong&gt;多个装饰器，装饰一个函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; wrapper1(func):                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; func ==  f函数名&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner1():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wrapper1 ,before func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;        func()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wrapper1 ,after func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner1

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper2(func):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; func == inner1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inner2():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wrapper2 ,before func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;        func()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wrapper2 ,after func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner2

@wrapper2                      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  f = wrapper2(f)  里面的f==inner1  外面的f == inner2&lt;/span&gt;
@wrapper1                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  f = wrapper1(f)   里面的f==函数名f  外面的f == inner1&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; f():                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

f()                              &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; inner2() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
wrapper2 ,before func
wrapper1 ,before func
in f
wrapper1 ,after func
wrapper2 ,after func&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;哪个离函数近，哪个先计算&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;最底下的先执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行顺序如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1518468/201909/1518468-20190910210843673-1576155199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;多个装饰器，都是按照上图的顺序来的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. &lt;/span&gt;&lt;strong&gt;装饰器的&lt;/strong&gt;&lt;strong&gt;__name__&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;strong&gt;__doc___&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;__name__：函数名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;__doc___：函数的解释  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;普通函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    此函数是完成登陆的功能，参数分别是...作用。
    return: 返回值是登陆成功与否（True，False）
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__name__&lt;/span&gt;)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取函数名&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__doc__&lt;/span&gt;)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取函数名注释说明 &lt;/span&gt;
&lt;span&gt;
执行输出：
&lt;/span&gt;666&lt;span&gt;
func1
此函数是完成登陆的功能，参数分别是...作用。
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;: 返回值是登陆成功与否（True，False）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个有什么用呢？比如日志功能，需要打印出谁在什么时间，调用了什么函数，函数是干啥的，花费了多次时间，这个时&lt;/span&gt;&lt;span&gt;候，就需要获取函数的有用信息了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;带装饰器的函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; wrapper(f):      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f = func1&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; inner(*args,**kwargs):             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;聚合, args （1,2,3）&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之前的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ret &lt;/span&gt;= f(*args,**kwargs)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打散 1,2,3&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之后的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    此函数是完成登陆的功能，参数分别是...作用。
    return: 返回值是登陆成功与否（True，False）
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666&lt;span&gt;
inner
执行函数之前的相关操作&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;咦？为什么输出了inner，我要的是func1啊。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;因为函数装饰之后，相当于执行了inner函数，所以输出inner&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这个问题，需要&lt;strong&gt;调用一个模块wraps&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wraps将 被修饰的函数(wrapped) 的一些属性值赋值给修饰器函数(wrapper) ，最终让属性的显示更符合我们的直觉&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(f):                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; f = func1&lt;/span&gt;
    &lt;span&gt;&lt;strong&gt;@wraps(f)                 #f是被装饰的函数&lt;/strong&gt;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; inner(*args,**kwargs):         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;聚合args （1,2,3）&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之前的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        ret &lt;/span&gt;= f(*args,**kwargs)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打散 1,2,3&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;执行函数之后的相关操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@wrapper
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    此函数是完成登陆的功能，参数分别是...作用。
    return: 返回值是登陆成功与否（True，False）
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(666&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func1.&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
666&lt;span&gt;
func1
此函数是完成登陆的功能，参数分别是...作用。
return: 返回值是登陆成功与否（True，False）&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;python 一切皆对象, 能被for循环的对象就是可迭代对象。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器： f1文件句柄&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dir打印该对象的所有操作方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(dir(s))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__contains__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dir__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__format__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ge__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getattribute__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getnewargs__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__gt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__hash__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__le__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__lt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__mod__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__mul__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ne__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce_ex__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__rmod__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__rmul__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__sizeof__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__subclasshook__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;capitalize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;casefold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;encode&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;endswith&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;expandtabs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;find&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;format_map&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isalnum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isalpha&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isdecimal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isdigit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isidentifier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;islower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isnumeric&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isprintable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isspace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;istitle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;isupper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ljust&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lower&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstrip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;maketrans&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;partition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;replace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rfind&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rindex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rjust&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rpartition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rsplit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rstrip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;split&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;splitlines&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;startswith&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;strip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;swapcase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;translate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;upper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zfill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;可迭代对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对象内部含有&lt;strong&gt;__iter__&lt;/strong&gt;方法就是可迭代对象，例如 str、list、dict、tuple、set、range()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 查看某个对象是否是可迭代对象，有2种方式&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　print('__iter__' in dir(对象))&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　from collections import Iterable&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　       print(&lt;strong&gt;isinstance(对象,Interable)&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dir(s))&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：True&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二种：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable

l &lt;/span&gt;= [1, 2, 3, 4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(l, Iterable)) 　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对象内部含有&lt;strong&gt;__iter__&lt;/strong&gt;和&lt;strong&gt;__next__&lt;/strong&gt;方法就是迭代器，文件句柄就是迭代器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1)可迭代对象转化成迭代器：可迭代对象.__iter__() ---&amp;gt;迭代器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
l1 = [1,2,3&lt;span&gt;]
l1_obj &lt;/span&gt;= l1.&lt;span&gt;__iter__&lt;/span&gt;()   　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代器&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(l1_obj) &amp;lt;list_iterator object at 0x000001987D5EB668&amp;gt;　　　　　　　　　　　　# 表示它是一个列表迭代器对象
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;(2)判断方法是否是迭代器的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①print('__iter__' in dir(对象))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  print('__next__' in dir(对象))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个都必须是True, 这种方法居多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② from collection import Iterator&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    print(&lt;strong&gt;isinstance(对象,&lt;/strong&gt;&lt;strong&gt;Iterator&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f1:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; dir(f1))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in&lt;/span&gt; dir(f1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方法2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance(f1,Iterator)) 　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
l1 = [1,2,3&lt;span&gt;]
l1_obj &lt;/span&gt;= l1.&lt;span&gt;__iter__&lt;/span&gt;()              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换为迭代器&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;  dir(l1_obj))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否含有__iter__方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;  dir(l1))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否含有__next__方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;  dir(l1_obj)) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：从结果中，可以看出l1_obj是同时含有__iter__和__next__的对象，所以它是迭代器
True
False
True &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）迭代器使用__next__获取一个值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
l1 = [1,2,3&lt;span&gt;]
l1_obj &lt;/span&gt;= l1.&lt;span&gt;__iter__&lt;/span&gt;()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代器&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(l1_obj.&lt;span&gt;__next__&lt;/span&gt;())         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取一个元素&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(l1_obj.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l1_obj.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l1_obj.&lt;span&gt;__next__&lt;/span&gt;())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;多取了一个，就会报错，因为列表只有3个元素&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sadda&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ite1 &lt;/span&gt;=&lt;span&gt; iter(s1)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ite1.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())

    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用while循环，指定用__next__方法遍历列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
l2 = [1, 2, 3, 4, 5, 6, 7, 8&lt;span&gt;]
l2_obj &lt;/span&gt;= l2.&lt;span&gt;__iter__&lt;/span&gt;()                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.将可迭代对象转化成迭代器&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        i &lt;/span&gt;= l2_obj.&lt;span&gt;__next__&lt;/span&gt;()                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部使用__next__方法取值&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt; Exception:                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运用了异常处理去处理报错&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;try里面的代码，出现报错，不会提示红色文字。&lt;/span&gt;&lt;span&gt;Exception 可以接收所有报错，表示报错的时候，该怎么处理，这里直接使用breck跳出循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;面试题：使用whlie循环去遍历一个有限对象，&lt;/span&gt;&lt;span&gt;直接使用上述代码即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for循环的内部运行机制&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 将可迭代对象转化为迭代器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 调用__next__方法取值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 利用异常处理机制停止报错&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
l1 = [1,2,3&lt;span&gt;]
l1_obj &lt;/span&gt;= l1.&lt;span&gt;__iter__&lt;/span&gt;()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换为迭代器&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l1_obj:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i) &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;执行输出：for循环的内部机制，就是用__next__方法执行的。为什么没有报错呢？它内部有异常处理机制
1
2
3&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3.迭代器的好处&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）&lt;em&gt;节省内存空间。迭代器最大的好处&lt;/em&gt;&lt;em&gt;。&lt;/em&gt;好的程序员，会在内存优化方面考虑，比如迭代器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）满足惰性机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）不能反复取值，不可逆。&lt;em&gt;不可逆，表示，已经取过的值，不能再次取，它只能取下一个。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;仅含有__iter__方法的，就是可迭代对象&lt;/strong&gt;&lt;strong&gt;；&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;包含__iter__和__next__方法的，就是迭代器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.什么是可迭代对象，什么是迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内部含有__iter__方法的对象就叫做可迭代对象&lt;/p&gt;
&lt;p&gt;内部必须有__iter__方法和__next__方法的对象，叫做迭代器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.可迭代对象如何转化成迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;转化成迭代器：&lt;strong&gt;可迭代对象.__iter__()&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;l1 = [1,2,3]&lt;/p&gt;
&lt;p&gt;l1_obj = l1.__iter__()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.迭代器如何取值&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;迭代器使用__next__()方法&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;五、 &lt;/strong&gt;&lt;strong&gt;生成器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;生成器本质上是迭代器，包含__iter__和__next__功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成器的产生方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，生成器函数构造。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，生成器推导式构造。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，数据类型的转化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过构造生成器函数，就是将函数&lt;/strong&gt;&lt;strong&gt;中&lt;/strong&gt;&lt;strong&gt;的&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;return变为yield&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(x):
    x &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(111&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; x

    x &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(222&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; x

func2(&lt;/span&gt;2)            　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;函数不会执行&lt;/span&gt;
g_obj  =func2(3)        　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将func2(3)赋值给g_obj，g_obj是个迭代器&lt;/span&gt;
g_obj.&lt;span&gt;__next__&lt;/span&gt;()        　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果是111，一个next对一个一个yield，只有遇到next，函数才会执行&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(g_obj.&lt;span&gt;__next__&lt;/span&gt;())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果是222   \n    5&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(g_obj.&lt;span&gt;__next__&lt;/span&gt;())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超出，将报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; i

g&lt;/span&gt;=&lt;span&gt;func1()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(g.&lt;span&gt;__next__&lt;/span&gt;())         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印0-9，一行一个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;return 与 yield的区别&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 自定制的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 内存级别的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     迭代器是需要可迭代对象进行转化，可迭代对象非常占内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     生成器是直接转化，从本质上节省内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; next 和send 功能一样，都是执行一次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;send 与 next 的区别&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① send 与 next 一样，也是对生成器进行取值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② send 可以给上一个yield 传值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;③ 第一次取值只能用next&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 最后一个yield永远得不到send传的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(1&lt;span&gt;)
    count &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(2&lt;span&gt;)
    count2 &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 2
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count2)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(3&lt;span&gt;)
    count3 &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 3&lt;span&gt;

g&lt;/span&gt;=func1()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; g称作生成器对象。&lt;/span&gt;
g.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
g.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
g.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;输出结果：
1&lt;span&gt;
alex
2&lt;span&gt;
hello
3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;例2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; generator():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(123&lt;span&gt;)
    content &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=======&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,content)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(456&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;

g &lt;/span&gt;=&lt;span&gt; generator()
ret &lt;/span&gt;= g.&lt;span&gt;__next__&lt;/span&gt;()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 123&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ret)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; *** 1&lt;/span&gt;
ret = g.send(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;send的效果和next一样   ======= hello        \n    456&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ret)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; *** None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
123
*** 1
=======&lt;span&gt; hello
456
*** None&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;send 获取下一个值的效果和next基本一致, 只是在获取下一个值时，给上一yield的位置传递一个数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用send的注意事项:&lt;/span&gt;&lt;span&gt;第一次使用生成器的时候 是用next获取下一个值。&lt;/span&gt;&lt;span&gt;最后一个yield不能接受外部的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;比如生产10000套服装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;一个厂商直接生产出10000套了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,10001&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ARMAIN服装%d套&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
func1() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
...

ARMAIN服装9998套
ARMAIN服装9999套
ARMAIN服装10000套&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二个厂商，先生产出50套，给老板看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,10001&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ARMAIN服装%d套&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i

g &lt;/span&gt;=&lt;span&gt; func1()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,51&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(g.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：
...
ARMAIN服装48套
ARMAIN服装49套
ARMAIN服装50套&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最终老板只要200套&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;先50套，再150套&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,10001&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ARMAIN服装%d套&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i

g &lt;/span&gt;=&lt;span&gt; func1()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,51&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(g.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())

&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;再执行150次，注意，它是从51开始的&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(150&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(g.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()) 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;对于列表而言，for循环是从&lt;/strong&gt;&lt;strong&gt;头&lt;/strong&gt;&lt;strong&gt;开始&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;对于生成器而言，它是有指针的，__next__一次，指针向前一次。它不能从头开始。必须依次执行&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;生成器和迭代器的区别&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　迭代器： 有内置方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　生成器： 开发者自定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题：什么是生成器？如何写一个生成器？生成器怎么取值？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成器，即生成一个容器。在Python中，&lt;strong&gt;一边循环，一边计算的机制，称为生成器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成器示例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生成器使用__next__()方法取值，或者for循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;六&lt;/strong&gt;&lt;strong&gt;、三元运算&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;三元运算符就是在赋值变量的时候，可以直接加判断，然后赋值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式：&lt;strong&gt;[on_true] if [expression] else [on_false]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三元运算只适用于简单的if else判断，再多一层if判断就不适用了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例说明：比大小，大者返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一个函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; max_min(a,b):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; int(a) &amp;gt;&lt;span&gt; int(b):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(max_min(1,3)) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三元运算&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; max_min(a,b):
    z &lt;/span&gt;= a &lt;span&gt;if&lt;/span&gt; a &amp;gt; b &lt;span&gt;else&lt;/span&gt;&lt;span&gt; b
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; z 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再进一步简写&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; max_min(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a &lt;span&gt;if&lt;/span&gt; a &amp;gt; b &lt;span&gt;else&lt;/span&gt; b 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;七&lt;/strong&gt;&lt;strong&gt;、列表生成式&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;优点：一行代码几乎可以搞定所需要的任何列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：容易着迷，不易排错，不能超过三个循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;用列表推导式能构建的任何列表，用别的都可以构建，比如for循环&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;列表推导式，最多不超过3个for循环。判断只能用一个&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 循环模式：&lt;/strong&gt;&lt;strong&gt;模板：&lt;/strong&gt;&lt;strong&gt;[经过加工的i for i in 可迭代对象]&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用for循环方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
li =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,4&lt;span&gt;):
    li.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;还珠格格第&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+str(i)+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li)                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['还珠格格第1部', '还珠格格第2部', '还珠格格第3部']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种写法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
li =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,4&lt;span&gt;):
    li.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;还珠格格第%s部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的代码，可以一行搞定&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;用列表推导式就可以了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
li = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;还珠格格第%s部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,4&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;例：求&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;1～10平方结果&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
li = [i ** 2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,11&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(li) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 筛选模式：[经过加工的i for i in 可迭代对象 if 条件 筛选]　&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;30以内所有能被3整除的数&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
l3 = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,31) &lt;span&gt;if&lt;/span&gt; i % 3 ==&lt;span&gt; 0]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l3)                         　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;30以内所有能被3整除的数的平方&lt;/strong&gt;&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
li = [i**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,31) &lt;span&gt;if&lt;/span&gt; i % 3 ==&lt;span&gt; 0]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li)                         　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [9, 36, 81, 144, 225, 324, 441, 576, 729, 900]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;找到嵌套列表中名字含有两个'e'的所有名字&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
names = [[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Billy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jefferson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Andrew&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wesley&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Steven&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Joe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wendy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jennifer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sherry&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]
l4 &lt;/span&gt;= [name &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; names &lt;span&gt;for&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; i &lt;span&gt;if&lt;/span&gt; name.count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == 2&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l4)                         　　　　　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ['Jefferson', 'Wesley', 'Steven', 'Jennifer']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用的是列表推导式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;字典推导式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;将一个字典的key和value对调&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dict = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 10, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 34&lt;span&gt;}
dict_frequency &lt;/span&gt;= {dict[k]: k &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mcase}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dict_frequency) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：{10: 'a', 34: 'b'}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;相当于&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
dict = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 10, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 34&lt;span&gt;}
dict_frequency &lt;/span&gt;=&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dict:
    dict_frequency[k]&lt;/span&gt;=&lt;span&gt;dict[k]

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dict_frequency) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;如果Key和value是一样的，不适合上面的代码&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合推导式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算列表中每个值的平方，自带去重功能&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
squared = {x**2 &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; [1, -1, 2&lt;span&gt;]}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(squared)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：{1, 4}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
a = {1,1,4&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(a)) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;执行输出：&amp;lt;class 'set'&amp;gt;　　&lt;span&gt;结果是一个集合，它也是用{}表示的。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合和字典是有区别的：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有键值对的，是字典，比如{'k1':1,'k1':2}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　没有键值对的，是集合，比如{1,2,3,4}&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;八、&lt;/strong&gt;&lt;strong&gt;生成器表达式&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;与列表推导式相同，只是将[ ]改为( )&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
l_obj = &lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;还珠格格第%s部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,4&lt;span&gt;)&lt;strong&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(l_obj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;结果是一个生成器对象：&lt;span&gt;&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x000002DDBEBADE60&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;取值使用__next__方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
l_obj = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;还珠格格第%s部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,4&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l_obj.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l_obj.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(l_obj.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;输出结果：
还珠格格第1部
还珠格格第2部
还珠格格第3部&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;列表推导式：一目了然，占内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;生成器表达式： 不便看出，节省内存。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;九&lt;/strong&gt;&lt;strong&gt;、递归函数&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;递归函数：在一个函数中，调用这个函数本身。递归的默认最大深度为998。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;它是执行到多少次时，报错呢&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;？&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;加一个计数器。默认递归深度为998&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; count
    count &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
    func1()

func1()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;递归深度是可以改的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
sys.setrecursionlimit(&lt;/span&gt;100000)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;更改默认递归深度&lt;/span&gt;
count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; count
    count &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
    func1() 

func1()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问年龄&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 18
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(n-1) +2

&lt;span&gt;print&lt;/span&gt;(func(4))                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;十、匿名函数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;匿名函数：lambda 表达式。普通函数&lt;strong&gt;有且只有返回值的函数才能用匿名函数进行简化成一行函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;匿名函数不单独&lt;/strong&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;，一般和内置函数结合使用。&lt;/strong&gt;内置函数中，可加入函数的有min、max、sorted、map、filter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于匿名函数格式的说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;函数名 = lambda 参数 ：返回值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　参数可以有多个，用逗号隔开&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　返回值和正常的函数一样可以是任意数据类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;span&gt;1.简单使用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回一个数的平方&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;使用函数方式
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x ** 2&lt;span&gt;&lt;strong&gt; 

使用匿名函数一行搞定&lt;/strong&gt;
func &lt;/span&gt;= &lt;span&gt;lambda&lt;/span&gt; x:x ** 2
&lt;span&gt;print&lt;/span&gt;(func(5))         　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 25　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;x+y&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;使用函数方式
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(x,y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y 

改成匿名函数
fun &lt;/span&gt;= &lt;span&gt;lambda&lt;/span&gt; x,y:x+&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fun(1,3))         　　　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. lambda 函数与内置函数的结合。sorted，map，fiter，max，min，reversed&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较字典值的大小，并输出key的值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dic={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 10, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 30&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(max(dic, key=&lt;span&gt;lambda&lt;/span&gt; x: dic[x]))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; k2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
res = map(&lt;span&gt;lambda&lt;/span&gt; x:x**2,[1,5,7,4,8&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打印出大于10的元素&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
l1 = [1,2,3,11,12,40,20,50,79&lt;span&gt;]
ret &lt;/span&gt;= filter(&lt;span&gt;lambda&lt;/span&gt; x:x &amp;gt; 10&lt;span&gt;,l1)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ret:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果l1列表的数据，有上百万，不能使用列表推导式，非常占用内存。建议使用lamdba，它只占用一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 14:42:00 +0000</pubDate>
<dc:creator>Tammy~</dc:creator>
<og:description>一、函数初识 函数的产生：函数就是封装一个功能的代码片段。 def 关键字,定义一个函数 function 函数名的书写规则与变量一样。 括号是用来传参的。 函数体,就是函数里面的逻辑代码 代码从上至</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Summer-skr--blog/p/11498293.html</dc:identifier>
</item>
<item>
<title>微服务之集成(四)下 - Vincent-yuan</title>
<link>http://www.cnblogs.com/Vincent-yuan/p/11495172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vincent-yuan/p/11495172.html</guid>
<description>&lt;p&gt;&lt;strong&gt;8. 实现基于事件的异步协作方式&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;前面讲了一些与请求/响应模式相关的技术。那么基于事件的异步通信呢？&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;8.1 技术选择&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;主要有两个部分需要考虑：微服务发布事件机制和消费者接收事件机制。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;方法一：使用消息代理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;传统上来说，像RabbitMQ这样的消息代理能够处理上述两个方面的问题。生产者(producer)使用API向代理发布事件，代理也可以向消费者提供订阅服务，并且在时间发生时通知消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;不过需要注意的是，消息代理仅仅是中间件世界中的一个小部分而是。有一个原则需要谨记：尽量让中间件保持简单，而把业务逻辑放在自己的服务中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;方法二：使用HTTP来传播事件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ATOM是一个符合REST规范的协议，可以通过它提供资源聚合(feed)的发布服务，而且有很多现成的客户端可以用来消费该聚合。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果你已经有了一个好的，具有弹性的消息代理的话，就用它来处理事件的订阅和发布吧。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;8.2 异步架构的复杂性&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;事件驱动的系统看起来耦合度非常低，而且伸缩性很好。但是这种编程风格也会带来一定的复杂性，这种复杂性并不仅仅包括对消息的发布订阅操作。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;当我们的系统因为代码中bug，工作者崩溃时，我们需要有&lt;span&gt;灾难故障转移&lt;/span&gt;(catastrophic failover)。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;而且，&lt;span&gt;我们最好设置一个作业最大重试次数&lt;/span&gt;。但是我们还需要有一种方式来查看甚至重发这些有问题的消息。所以最后实现了一个消息医院(或者叫死信队列&lt;span&gt;)&lt;/span&gt;，所有失败的消息都会被发送到这里。我们还可以创建一个界面来显示这些消息，如果需要的话还可以触发一个重试。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;事件驱动架构和异步编程会带来一定的复杂性，所以通常需要谨慎的选用。你需要确保各个流程有很好的监控机制，并考虑使用关联ID,这种机制可以帮助你对跨进程的请求进行跟踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.服务即状态&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;前面已经提到过，服务应该根据限界上下文进行划分。我们的客户端微服务应该拥有与这个上下文中行为相关的所有逻辑。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;把关键领域的生命周期显示建模出来非常有用。我们不但可以在唯一的一个地方处理状态冲突(比如，尝试更新已经被移除的用户&lt;span&gt;)&lt;/span&gt;，而且可以在这些状态变化的基础上封装一些行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10.响应式扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;响应式扩展(Reactive extensions, Rx)提供了一种机制，在此之上，你可以把多个调用结果组装起来并在此基础上执行操作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;很多Rx实现都在分布式系统中找到了归宿。因为调用的细节被屏蔽了，所以事情也更容易处理。我们可以简单的对下游服务调用的结果进行观察，而不需要关心它是阻塞的还是非阻塞的，唯一需要做的就是等待结果并作出响应。其漂亮之处在于，我们可以把多个不同的调用组合起来，这样就可以更容易对下游服务的并发调用做处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11.微服务世界中的DRY和代码重用的危险&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;DRY, Don’t Repeat Yourself。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用DRY可以得到重用性比较好的代码。把重复代码抽取出来，然后就可以在多个地方进行调用。比如说可以创建一个随处可用的共享库。但是这个方法在微服务的架构中可能是危险的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;我们想要避免微服务和消费者之间的过度耦合，否则对微服务任何小的改动都会引起消费方的改动。而共享代码就有可能导致这种耦合。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;跨服务共用代码很有可能会引入耦合。但是使用像日志库这样的公共代码就没什么问题，因为它们对外是不可见的。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;推荐的做法：在微服务内部不要违反DRY,但在跨服务的情况下可以适当违反&lt;span&gt;DRY&lt;/span&gt;。服务之间引入大量的耦合会比重复代码带来更糟糕的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;客户端库&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;很多团队坚持在最开始的时候为服务开发一个客户端库。原因在于，这样不仅能简化对服务的使用，还能避免不同消费者之间存在重复的与服务交互的代码。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;但是如果开发服务端API和客户端&lt;span&gt;API&lt;/span&gt;的是同一批人，那么服务端的逻辑很有可能泄露到客户端中。潜入客户端库的逻辑越多，内聚性就越差，然后你必须在修复一个服务端问题的同时，也需对多个客户端进行修改。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如果你想要使用客户端库，一定要保证其中只包含处理底层传输协议的代码，比如服务发现和故障处理等。千万不要把与目标服务相关的逻辑放到客户端库中。想清楚你是否要坚持使用客户端库，或者你是否允许别人使用不同的技术栈来对底层API进行调用。最后，确保由客户端来负责何时进行客户端库的升级，这样才能保证每个服务可以独立于其他服务进行发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12.按引用访问&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如何传递领域实体的相关信息是一个值得讨论的话题&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;很重要的一个想法，微服务应该包含核心领域实体(比如客户&lt;span&gt;)&lt;/span&gt;全生命周期的相关操作。在这种设计下，如果想要做任何与客户相关的改动，就必须向客户服务发起请求。它遵守了一个原则，即客户服务应该是关于客户信息的唯一可靠来源。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;想象这样一个场景，你从客户服务获取了一个客户资源，那么就能看到该资源在你发起请求那一刻的样子。但是有可能在你发送了请求之后，其他人对该资源进行了修改，所以你所持有的其实是该客户资源曾经的样子。你持有这个资源的时间越久，其内容失效的可能性就越高。当然，避免不必要的数据请求可以让系统更高效。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;有时候使用本地副本没什么问题，但在其他场景下你需要知道该副本是否已经失效。所以，当你持有一个本地副本时，请确保同时持有一个指向原始资源的引用，这样在你需要的时候就可以对本地副本进行更新。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;当然在使用引用时也需要做一些取舍。如果总是从客户服务去查询给定客户的相关信息，那么客户服务的负载就会过大。如果在获取资源的同时，可以得到资源的有效性时限(即该资源再什么时间之前是有效的&lt;span&gt;)&lt;/span&gt;信息的话，就可以进行相应的缓存，从而减小服务的负载。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;另一个问题是，有些服务可能不需要知道整个客户资源，所以坚持进行查询这种方式会引入潜在的耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原则上讲，应该在不确定数据是否能保持有效的情况下，谨慎的进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13.版本管理&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;13.1 尽可能推迟破坏性修改&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;首先，减小破坏性修改影响的最好办法就是尽量不要做这样的修改。&lt;/span&gt;比如在很多的集成技术中，你可以通过选择正确的技术来做到这一点。比如数据库集成很容易引入破坏性的修改；而REST就好很多，因为内部的修改不太容易引起外部服务接口的变化。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;另一个延迟破坏性修改的关键是鼓励客户端的正确行为，避免过早的将客户端和服务端紧密的绑定起来&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;客户端尽可能灵活的消费服务响应这一点符合Postel法则(也叫做&lt;span&gt;鲁棒性原则&lt;/span&gt;)，&lt;span&gt;该法则认为，系统中的每个模块都应该“宽进严出”，即对自己发送的东西要严格，对接收的东西则要宽容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;13.2 及早发现破坏性修改&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这里强烈&lt;span&gt;建议使用消费者驱动的契约来及早定位这些问题&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如果你支持多种不同的客户端库，那么最好针对最新的服务对所有的客户端运行测试。一旦发现，你可能会对某个消费者造成破坏，那么可以选择要么尽量避免破坏性修改，要么接受它，并跟维护这些服务的人员好好聊一聊。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;13.3 使用语义化的版本管理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果一个客户端能够仅仅通过查看服务的版本号，就知道它能否与之进行集成，那就太好了&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语义化版本管理就是一种能够支持这种方式的规格说明。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;语义化版本管理&lt;/span&gt;的每一个版本号都&lt;span&gt;遵循这样的格式&lt;/span&gt;：&lt;span&gt;MAJOR.MINOR.PATCH&lt;/span&gt;。其中&lt;span&gt;MAJOR的改变意味着其中包含向后不兼容的修改&lt;/span&gt;；&lt;span&gt;MINOR的改变意味着有新功能的增加&lt;/span&gt;，&lt;span&gt;但应该是向后兼容的&lt;/span&gt;；最后，&lt;span&gt;PATCH的改变代表对已有功能的缺陷修复&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;13.4 不同的接口共存&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;我们可以在同一个服务上使新接口和老接口同时存在&lt;/span&gt;。所以，在发布一个破坏性修改时，可以部署一个同时包含新老接口的版本。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这可以帮助我们尽快发布新版本的微服务，其中包含了新的接口，同时也给了消费者时间做迁移。一旦消费者不再访问老的接口，就可以删除掉该接口及相关的代码。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910222529325-1689777315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这其实就是一个扩展/收缩的实例&lt;/span&gt;，&lt;span&gt;它允许我们对破坏性修改进行平滑的过度&lt;/span&gt;。首先扩张服务的能力，对新老两种服务都进行支持。然后等到老的消费者都采用了新的方式，再通过收缩&lt;span&gt;API&lt;/span&gt;去掉就的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;13.5 同时使用多个版本的服务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;另一种经常被提起的版本管理的方法是，同时运行不同版本的服务，然后把老用户路由到老版本的服务，而新用户可以看到新版本的服务。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910222711545-513546111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14.用户界面&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;最重要的其实是，考虑该界面是否能够很好的支持服务之间的集成。毕竟用户界面是连接各个微服务的工具，而只有把各个微服务集成起来才能真正的为客户创造价值。&lt;/p&gt;
&lt;p&gt;14.1 走向数字化&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;我们不应该对网页端和移动端区别对待，相反应该对数字化策略做全局考虑，即如何让客户更好的使用我们的服务。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;通过把服务的功能进行不同的组合，可以为桌面应用程序、移动端设备、可穿戴设备的客户提供不同的体验。&lt;/p&gt;
&lt;p&gt;14.2 约束&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;在用户与系统之间，需要考虑不同的交互形式中存在的一些约束。比如在桌面Web应用中，需要考虑与用户浏览器及屏幕解析度相关的约束。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14.3 API组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假设我们的服务彼此之间已经通过XML或者&lt;span&gt;JSON&lt;/span&gt;通信了，那么可以让用户界面直接与这个&lt;span&gt;API&lt;/span&gt;进行交互。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910222906432-288690471.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图4-7&lt;span&gt;：使用多个&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;来表示用户界面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种方式有一些问题。首先，很难为不同的设备定制不同的响应。另一个问题是，谁来创建用户界面？维护服务的人往往不是服务的使用者。&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;API入口&lt;span&gt;(gateway)&lt;/span&gt;&lt;/span&gt;可以很好的缓解这一问题，在这种模式下多个底层的调用会被聚合成为一个调用，当然它也有一定的局限性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14.4 UI片段的组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相比UI主动访问所有的&lt;span&gt;API,&lt;/span&gt;然后再将状态同步到&lt;span&gt;UI&lt;/span&gt;控件，另一种选择是让服务直接暴露出一部分&lt;span&gt;UI,&lt;/span&gt;然后只需要简单的把这些片段组合在一起就可以创建出整体&lt;span&gt;UI&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910223044817-1235868608.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14.5 为前端服务的后端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对与前端交互比较频繁的界面及需要给不同设备提供不同内容的界面来说，一个常见的解决方案是，使用服务端的聚合接口或API入口&lt;/span&gt;。&lt;span&gt;该入口可以对多个后端调用进行编排，并为不同的设备提供定制化的内容&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910223138501-1343946362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;4-9 &lt;span&gt;使用单块入口来处理与&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;之间的交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样做会得到一个聚合所有服务的巨大层。由于所有的东西都被放在了一起，也就失去了不同用户界面之间的隔离性，从而限制了独立于彼此进行发布的能力。&lt;/p&gt;
&lt;p&gt;还有一种模式，保证一个后端服务只为一个应用或者用户界面服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201909/1182288-20190910223220818-1535659569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种模式有时也叫做&lt;span&gt;BFF（Backends For Frontends,为前端服务的后端）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;API认证和授权层可以处在BFF和UI之间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与任何一种聚合层类似，使用这种方法的风险在于包含不该包含的逻辑。业务逻辑应该处在服务中，而不应该泄露到这一层。&lt;span&gt;这些BFF应该仅仅包含与实现某种特定的用户体验相关的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14.6 一种混合方式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;前面提到的那些选择各自都有其使用的范围。一个组织会选择基于片段组装的方式来构建网站，但对于移动端应用来说，BFF可能是更好的方式&lt;/span&gt;。&lt;span&gt;关键是要保持底层服务能力的内聚性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;15. 小结&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;前面了解了很多不同的集成选择，也谈了什么样的选择能够最大程度的保证微服务之间的低耦合：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无论如何，避免数据库集成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;理解REST和RPC之间的取舍，但总是使用REST作为请求/响应模式的起点&lt;/li&gt;
&lt;li&gt;相比编排，优先选择协同&lt;/li&gt;
&lt;li&gt;避免破坏性修改、理解Postel法则、使用容错性读取器&lt;/li&gt;
&lt;li&gt;将用户界面视为一个组合层&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 14:36:00 +0000</pubDate>
<dc:creator>Vincent-yuan</dc:creator>
<og:description>8. 实现基于事件的异步协作方式 前面讲了一些与请求/响应模式相关的技术。那么基于事件的异步通信呢？ 8.1&amp;#160;技术选择 主要有两个部分需要考虑：微服务发布事件机制和消费者接收事件机制。 方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Vincent-yuan/p/11495172.html</dc:identifier>
</item>
<item>
<title>Kafka源码分析及图解原理之Producer端 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/11354987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/11354987.html</guid>
<description>&lt;h2&gt;一.前言&lt;/h2&gt;
&lt;p&gt;　　任何消息队列都是万变不离其宗都是3部分，消息生产者（Producer）、消息消费者（Consumer）和服务载体（在Kafka中用Broker指代）。那么本篇主要讲解Producer端，会有适当的图解帮助理解底层原理。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190814221347628-1306873745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一.开发应用&lt;/h2&gt;
&lt;p&gt;　　首先介绍一下开发应用，如何构建一个KafkaProducer及使用，还有一些重要参数的简介。&lt;/p&gt;
&lt;h3&gt;1.1 一个栗子&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Kafka Producer Demo实例类。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; GrimMjx
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerDemo {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Properties prop = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         prop.put(&quot;client.id&quot;, &quot;DemoProducer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下三个参数必须指定
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于创建与Kafka broker服务器的连接，集群的话则用逗号分隔&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         prop.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息的key序列化方式&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         prop.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息的value序列化方式&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         prop.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下参数为可配置选项&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         prop.put(&quot;acks&quot;, &quot;-1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         prop.put(&quot;retries&quot;, &quot;3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         prop.put(&quot;batch.size&quot;, &quot;323840&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         prop.put(&quot;linger.ms&quot;, &quot;10&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         prop.put(&quot;buffer.memory&quot;, &quot;33554432&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         prop.put(&quot;max.block.ms&quot;, &quot;3000&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         KafkaProducer&amp;lt;String, String&amp;gt; producer = &lt;span&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;&lt;span&gt;(prop);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步发送，继续发送消息不用等待。当有结果返回时，callback会被通知执行&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             producer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&quot;test&quot;, &quot;key1&quot;, &quot;value1&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callback() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果RecordMetadata记录元数据包括了which partition的which offset&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCompletion(RecordMetadata metadata, Exception e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送成功&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 System.out.println(&quot;The offset of the record we just sent is: &quot; +&lt;span&gt; metadata.offset());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送失败&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RetriableException) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理可重试的异常，比如分区leader副本不可用
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一般用retries参数来设置重置，毕竟这里也没有什么其他能做的，也是同样的重试发送消息&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理不可重试异常&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步发送，send方法返回Future，然后get。在没有返回结果一直阻塞&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             producer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&quot;test&quot;, &quot;key1&quot;, &quot;value1&quot;&lt;span&gt;)).get();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; producer运行的时候占用系统额外资源，最后一定要关闭&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            producer.close();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注释已经写得十分详细了，参数的下面会说，这里就只说一下异步发送和同步发送。我们先看下KafkaProducer.send方法，&lt;span&gt;可以看到返回的是一个Future&lt;/span&gt;，那么如何实现同步阻塞和异步非阻塞呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190814210448418-1688532322.png&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;130&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;同步阻塞：send方法返回Future，然后get。在没有返回结果一直阻塞，无限等待&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;异步非阻塞：send方法提供callback，调用send方法后可以继续发送消息不用等待。当有结果返回时，callback会被通知执行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201908/1465200-20190814210810280-1385588991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2 重要参数&lt;/h3&gt;
&lt;p&gt;　　这里分析一下broker端的重要参数，前3个是必要参数。Kafka的文档真的很吊，可以看这个类，每个参数和注释都解释的十分详细：&lt;span&gt;org.apache.kafka.clients.producer.ProducerConfig&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.server（必要）：broker服务器列表，如果集群的机器很多，&lt;span&gt;不用全配，producer可以发现集群中所有broker&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;key.serializer/value.serializer（必要）：key和value的序列化方式。这两个参数都必须是全限定类名，可以自定义拓展。&lt;/li&gt;
&lt;li&gt;acks：有3个值，0、1和all（-1）
&lt;ul&gt;&lt;li&gt;0：produce不关心broker端的处理结果，吞吐量最高&lt;/li&gt;
&lt;li&gt;1：produce发送消息给leader broker端，broker端写入本地日志返回结果，折中方案&lt;/li&gt;
&lt;li&gt;all(-1)：&lt;strong&gt;&lt;span&gt;配合min.insync.replicas使用&lt;/span&gt;&lt;/strong&gt;，控制写入isr中的多少副本才算成功
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;buffer.memory：producer启动会创建一个内存缓冲区保存待发送的消息，这部分的内存大小就是这个参数来控制的&lt;/li&gt;
&lt;li&gt;commpression.type：压缩算法的选择，目前有GZIP、Snappy和LZ4。&lt;span&gt;目前结合LZ4性能最好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;retries：重试次数，0.11.0.0版本之前可能导致消息重发&lt;/li&gt;
&lt;li&gt;batch.size：相同分区多条消息集合叫batch，当batch满了则发送给broker&lt;/li&gt;
&lt;li&gt;linger.ms：难道batch没满就不发了么？当然不是，不满则等linger.ms时间再发。延时权衡行为&lt;/li&gt;
&lt;li&gt;max.request.size：控制发送请求的大小&lt;/li&gt;
&lt;li&gt;request.timeout.ms：超过时间则会在回调函数抛出TimeoutException异常&lt;/li&gt;
&lt;li&gt;partitioner.class：分区机制，可自定义，&lt;span&gt;默认分区器的处理是：有key则用murmur2算法计算key的哈希值，对总分区取模算出分区号，无key则轮询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;enable.idempotence：Apache Kafka 0.11.0.0版本用于实现EOS的利器&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二.源码分析及图解原理&lt;/h2&gt;
&lt;h3&gt;2.1 RecordAccumulator&lt;/h3&gt;
&lt;p&gt;　　上面介绍的参数中buffer.memory是缓冲区的大小，RecordAccmulator就是承担了缓冲区的角色。&lt;span&gt;默认是32MB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　还有上面介绍的参数中batch.size提到了batch的概念，在kafka producer中，消息不是一条一条发给broker的，而是多条消息组成一个ProducerBatch，然后由Sender一次性发出去，这里的batch.size并不是消息的条数（凑满多少条即发送），而是一个大小。&lt;span&gt;默认是16KB，可以根据具体情况来进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在RecordAccumulator中，最核心的参数就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;TopicPartition, Deque&amp;lt;ProducerBatch&amp;gt;&amp;gt; batches;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它是一个ConcurrentMap，key是TopicPartition类，代表一个topic的一个partition。value是一个包含ProducerBatch的双端队列。等待Sender线程发送给broker。画张图来看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201909/1465200-20190909222253010-1291102426.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;462&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再从源码角度来看如何添加到缓冲区队列里的，主要看这个方法：org.apache.kafka.clients.producer.internals.RecordAccumulator#append：&lt;/p&gt;
&lt;p&gt;　　注释写的十分详细了，&lt;span&gt;这里需要思考一点，为什么分配内存的代码没有放在synchronized同步块里？看起来这里很多余，导致下面的synchronized同步块中还要tryAppend一下，因为这时候可能其他线程已经创建好RecordBatch了。造成多余的内存申请。但是仔细想想，如果把分配内存放在synchronized同步块会有什么问题？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内存申请不到线程会一直等待，如果放在同步块中会造成一直不释放Deque队列的锁，那其他线程将无法对Deque队列进行线程安全的同步操作。那不是走远了？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Add a record to the accumulator, return the append result
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * The append result will contain the future metadata, and flag for whether the appended batch is full or a new batch is created
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; tp The topic/partition to which this record is being sent
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; timestamp The timestamp of the record
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key The key for the record
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value The value for the record
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; headers the Headers for the record
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; callback The user-supplied callback to execute when the request is complete
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxTimeToBlock The maximum time in milliseconds to block for buffer memory to be available
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RecordAppendResult append(TopicPartition tp,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                                  &lt;span&gt;long&lt;/span&gt;&lt;span&gt; timestamp,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                  &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] key,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                                  &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] value,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                                 Header[] headers,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                                 Callback callback,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                                  &lt;span&gt;long&lt;/span&gt; maxTimeToBlock) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We keep track of the number of appending thread to make sure we do not miss batches in
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; abortIncompleteBatches().&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    appendsInProgress.incrementAndGet();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     ByteBuffer buffer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (headers == &lt;span&gt;null&lt;/span&gt;) headers =&lt;span&gt; Record.EMPTY_HEADERS;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; check if we have an in-progress batch
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实就是一个putIfAbsent操作的方法，不展开分析&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         Deque&amp;lt;ProducerBatch&amp;gt; dq =&lt;span&gt; getOrCreateDeque(tp);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batches是线程安全的，但是Deque不是线程安全的
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已有在处理中的batch&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (dq) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closed)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Cannot send after the producer is closed.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             RecordAppendResult appendResult =&lt;span&gt;&lt;span&gt; tryAppend&lt;/span&gt;(timestamp, key, value, headers, callback, dq);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (appendResult != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; appendResult;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; we don't have an in-progress record batch try to allocate a new batch
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个新的ProducerBatch&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt; maxUsableMagic =&lt;span&gt; apiVersions.maxUsableProduceMagic();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配一个内存&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; size = Math.max(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         log.trace(&quot;Allocating a new {} byte message buffer for topic {} partition {}&quot;&lt;span&gt;, size, tp.topic(), tp.partition());
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 申请不到内存&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         buffer =&lt;span&gt; free.allocate(size, maxTimeToBlock);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (dq) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Need to check if producer is closed again after grabbing the dequeue lock.&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closed)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Cannot send after the producer is closed.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次尝试添加，因为分配内存的那段代码并不在synchronized块中
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有可能这时候其他线程已经创建好RecordBatch了，finally会把分配好的内存还回去&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             RecordAppendResult appendResult =&lt;span&gt;&lt;span&gt; tryAppend&lt;/span&gt;(timestamp, key, value, headers, callback, dq);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (appendResult != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 作者自己都说了，希望不要总是发生，多个线程都去申请内存，到时候还不是要还回去？
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Somebody else found us a batch, return the one we waited for! Hopefully this doesn't happen often...&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; appendResult;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建ProducerBatch&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;             MemoryRecordsBuilder recordsBuilder =&lt;span&gt; recordsBuilder(buffer, maxUsableMagic);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             ProducerBatch batch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProducerBatch(tp, recordsBuilder, time.milliseconds());
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             FutureRecordMetadata future =&lt;span&gt; Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            dq.addLast(batch);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; incomplete是一个Set集合，存放不完整的batch&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            incomplete.add(batch);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't deallocate this buffer in the finally block as it's being used in the record batch&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;             buffer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回记录添加结果类&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RecordAppendResult(future, dq.size() &amp;gt; 1 || batch.isFull(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放要还的内存&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (buffer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            free.deallocate(buffer);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        appendsInProgress.decrementAndGet();
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　附加tryAppend()方法，不多说，都在代码注释里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; *  Try to append to a ProducerBatch.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *  If it is full, we return null and a new batch is created. We also close the batch for record appends to free up
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *  resources like compression buffers. The batch will be fully closed (ie. the record batch headers will be written
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *  and memory records built) in one of the following cases (whichever comes first): right before send,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *  if it is expired, or when the producer is closed.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; RecordAppendResult tryAppend(&lt;span&gt;long&lt;/span&gt; timestamp, &lt;span&gt;byte&lt;/span&gt;[] key, &lt;span&gt;byte&lt;/span&gt;[] value, Header[] headers, Callback callback, Deque&amp;lt;ProducerBatch&amp;gt;&lt;span&gt; deque) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取最新加入的ProducerBatch&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ProducerBatch last =&lt;span&gt; deque.peekLast();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (last != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         FutureRecordMetadata future =&lt;span&gt; last.tryAppend(timestamp, key, value, headers, callback, time.milliseconds());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (future == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            last.closeForRecordAppends();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录添加结果类包含future、batch是否已满的标记、是否是新batch创建的标记&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RecordAppendResult(future, deque.size() &amp;gt; 1 || last.isFull(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这个Deque没有ProducerBatch元素，或者已经满了不足以加入本条消息则返回null&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　以上代码见图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201909/1465200-20190910145036444-1215527333.png&quot; alt=&quot;&quot; width=&quot;881&quot; height=&quot;777&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;2.2 Sender&lt;/h3&gt;
&lt;p&gt;　　Sender里最重要的方法莫过于run()方法，其中比较核心的方法是org.apache.kafka.clients.producer.internals.Sender#sendProducerData&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;其中pollTimeout需要认真读注释，意思是最长阻塞到至少有一个通道在你注册的事件就绪了。返回0则表示走起发车了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; sendProducerData(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; now) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前集群的所有信息&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Cluster cluster =&lt;span&gt; metadata.fetch();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the list of partitions with data ready to send
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @return ReadyCheckResult类的三个变量解释
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.Set&amp;lt;Node&amp;gt; readyNodes 准备好发送的节点
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.long nextReadyCheckDelayMs 下次检查节点的延迟时间
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.Set&amp;lt;String&amp;gt; unknownLeaderTopics 哪些topic找不到leader节点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     RecordAccumulator.ReadyCheckResult result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accumulator.ready(cluster, now);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if there are any partitions whose leaders are not known yet, force metadata update
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有些topic不知道leader信息，更新metadata&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result.unknownLeaderTopics.isEmpty()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The set of topics with unknown leader contains topics with leader election pending as well as
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; topics which may have expired. Add the topic again to metadata to ensure it is included
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; and request metadata update, since there are messages to send to the topic.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String topic : result.unknownLeaderTopics)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.metadata.add(topic);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.metadata.requestUpdate();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去除不能发送信息的节点
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove any nodes we aren't ready to send to&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     Iterator&amp;lt;Node&amp;gt; iter =&lt;span&gt; result.readyNodes.iterator();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; notReadyTimeout =&lt;span&gt; Long.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter.hasNext()) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Node node =&lt;span&gt; iter.next();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.ready(node, now)) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            iter.remove();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             notReadyTimeout = Math.min(notReadyTimeout, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.connectionDelay(node, now));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取将要发送的消息
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create produce requests&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     Map&amp;lt;Integer, List&amp;lt;ProducerBatch&amp;gt;&amp;gt; batches = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accumulator.drain(cluster, result.readyNodes,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.maxRequestSize, now);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证发送消息的顺序&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (guaranteeMessageOrder) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mute all the partitions drained&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (List&amp;lt;ProducerBatch&amp;gt;&lt;span&gt; batchList : batches.values()) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ProducerBatch batch : batchList)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accumulator.mutePartition(batch.topicPartition);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过期的batch&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     List&amp;lt;ProducerBatch&amp;gt; expiredBatches = &lt;span&gt;this&lt;/span&gt;.accumulator.expiredBatches(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestTimeout, now);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; needsTransactionStateReset = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset the producer id if an expired batch has previously been sent to the broker. Also update the metrics
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for expired batches. see the documentation of @TransactionState.resetProducerId to understand why
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; we need to reset the producer id here.&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;expiredBatches.isEmpty())
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         log.trace(&quot;Expired {} batches in accumulator&quot;&lt;span&gt;, expiredBatches.size());
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ProducerBatch expiredBatch : expiredBatches) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         failBatch(expiredBatch, -1&lt;span&gt;, NO_TIMESTAMP, expiredBatch.timeoutException());
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (transactionManager != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; expiredBatch.inRetry()) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             needsTransactionStateReset = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (needsTransactionStateReset) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        transactionManager.resetProducerId();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    sensors.updateProduceRequestMetrics(batches);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; that isn't yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; with sendable data that aren't ready to send since they would cause busy looping.
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到底返回的这个pollTimeout是啥，我觉得用英文的注释解释比较清楚
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.The amount of time to block if there is nothing to do
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.waiting for a channel to become ready; if zero, block indefinitely;&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; pollTimeout =&lt;span&gt; Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result.readyNodes.isEmpty()) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         log.trace(&quot;Nodes with data ready to send: {}&quot;&lt;span&gt;, result.readyNodes);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if some partitions are already ready to be sent, the select time would be 0;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise if some partition already has some data accumulated but not ready yet,
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the select time will be the time difference between now and its linger expiry time;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise the select time will be the time difference between now and the metadata expiry time;&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         pollTimeout = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后调用client.send()&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    sendProduceRequests(batches, now);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pollTimeout;
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中也需要了解这个方法：org.apache.kafka.clients.producer.internals.RecordAccumulator#ready。返回的类中3个关键参数的解释都在注释里。烦请看注释，我解释不好的地方可以看英文，原汁原味最好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Get a list of nodes whose partitions are ready to be sent, and the earliest time at which any non-sendable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * partition will be ready; Also return the flag for whether there are any unknown leaders for the accumulated
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * partition batches.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * A destination node is ready to send data if:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &amp;lt;ol&amp;gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &amp;lt;li&amp;gt;There is at least one partition that is not backing off its send
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;and&amp;lt;/b&amp;gt; those partitions are not muted (to prevent reordering if
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *   {&lt;/span&gt;&lt;span&gt;@value&lt;/span&gt;&lt;span&gt; org.apache.kafka.clients.producer.ProducerConfig#MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; *   is set to one)&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;and &amp;lt;i&amp;gt;any&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt; of the following are true&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * &amp;lt;ul&amp;gt;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *     &amp;lt;li&amp;gt;The record set is full&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *     &amp;lt;li&amp;gt;The record set has sat in the accumulator for at least lingerMs milliseconds&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *     &amp;lt;li&amp;gt;The accumulator is out of memory and threads are blocking waiting for data (in this case all partitions
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; *     are immediately considered ready).&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; *     &amp;lt;li&amp;gt;The accumulator has been closed&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; * &amp;lt;/ul&amp;gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * &amp;lt;/ol&amp;gt;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; ReadyCheckResult类的三个变量解释
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt; * 1.Set&amp;lt;Node&amp;gt; readyNodes 准备好发送的节点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt; * 2.long nextReadyCheckDelayMs 下次检查节点的延迟时间
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt; * 3.Set&amp;lt;String&amp;gt; unknownLeaderTopics 哪些topic找不到leader节点
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt; * 一个节点满足以下任一条件则表示可以发送数据 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt; * 1.batch满了
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt; * 2.batch没满，但是等了lingerMs的时间
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt; * 3.accumulator满了
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt; * 4.accumulator关了
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ReadyCheckResult ready(Cluster cluster, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nowMs) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     Set&amp;lt;Node&amp;gt; readyNodes = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; nextReadyCheckDelayMs =&lt;span&gt; Long.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     Set&amp;lt;String&amp;gt; unknownLeaderTopics = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; exhausted = &lt;span&gt;this&lt;/span&gt;.free.queued() &amp;gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;TopicPartition, Deque&amp;lt;ProducerBatch&amp;gt;&amp;gt; entry : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.batches.entrySet()) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         TopicPartition part =&lt;span&gt; entry.getKey();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         Deque&amp;lt;ProducerBatch&amp;gt; deque =&lt;span&gt; entry.getValue();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         Node leader =&lt;span&gt; cluster.leaderFor(part);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (deque) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; leader没有且队列非空则添加unknownLeaderTopics&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (leader == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;deque.isEmpty()) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is a partition for which leader is not known, but messages are available to send.
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note that entries are currently not removed from batches when deque is empty.&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                unknownLeaderTopics.add(part.topic());
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果readyNodes不包含leader且muted不包含part
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mute这个变量跟producer端的一个配置有关系：max.in.flight.requests.per.connection=1
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主要防止topic同分区下的消息乱序问题，限制了producer在单个broker连接上能够发送的未响应请求的数量
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置为1，则producer在收到响应之前无法再给该broker发送该topic的PRODUCE请求&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!readyNodes.contains(leader) &amp;amp;&amp;amp; !&lt;span&gt;muted.contains(part)) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 ProducerBatch batch =&lt;span&gt; deque.peekFirst();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (batch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; waitedTimeMs =&lt;span&gt; batch.waitedTimeMs(nowMs);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; backingOff = batch.attempts() &amp;gt; 0 &amp;amp;&amp;amp; waitedTimeMs &amp;lt;&lt;span&gt; retryBackoffMs;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待时间&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; timeToWaitMs = backingOff ?&lt;span&gt; retryBackoffMs : lingerMs;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch满了&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; full = deque.size() &amp;gt; 1 ||&lt;span&gt; batch.isFull();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch过期&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; expired = waitedTimeMs &amp;gt;=&lt;span&gt; timeToWaitMs;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; sendable = full || expired || exhausted || closed ||&lt;span&gt; flushInProgress();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (sendable &amp;amp;&amp;amp; !&lt;span&gt;backingOff) {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                        readyNodes.add(leader);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                         &lt;span&gt;long&lt;/span&gt; timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note that this results in a conservative estimate since an un-sendable partition may have
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a leader that will later be found to have sendable data. However, this is good enough
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; since we'll just wake up and then sleep again for the remaining time.
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目前还没有leader，下次重试&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;                         nextReadyCheckDelayMs =&lt;span&gt; Math.min(timeLeftMs, nextReadyCheckDelayMs);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　还有一个方法就是org.apache.kafka.clients.producer.internals.RecordAccumulator#drain，从accumulator缓冲区获取要发送的数据，最大一次性发max.request.size大小的数据（最上面的配置参数里有）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt; * Drain all the data for the given nodes and collate them into a list of batches that will fit within the specified
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt; * size on a per-node basis. This method attempts to avoid choosing the same topic-node over and over.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cluster The current cluster metadata
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; nodes The list of node to drain
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxSize The maximum number of bytes to drain
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt; * maxSize也就是producer端配置参数max.request.size来控制的，一次最多发多少
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; now The current unix time in milliseconds
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; A list of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ProducerBatch} for each node specified with total size less than the requested maxSize.
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Map&amp;lt;Integer, List&amp;lt;ProducerBatch&amp;gt;&amp;gt; drain(Cluster cluster, Set&amp;lt;Node&amp;gt; nodes, &lt;span&gt;int&lt;/span&gt; maxSize, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; now) {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nodes.isEmpty())
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyMap();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     Map&amp;lt;Integer, List&amp;lt;ProducerBatch&amp;gt;&amp;gt; batches = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Node node : nodes) {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for循环获取要发的batch&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;         List&amp;lt;ProducerBatch&amp;gt; ready =&lt;span&gt; drainBatchesForOneNode(cluster, node, maxSize, now);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        batches.put(node.id(), ready);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; batches;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;ProducerBatch&amp;gt; drainBatchesForOneNode(Cluster cluster, Node node, &lt;span&gt;int&lt;/span&gt; maxSize, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; now) {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取node的partition&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     List&amp;lt;PartitionInfo&amp;gt; parts =&lt;span&gt; cluster.partitionsForNode(node.id());
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     List&amp;lt;ProducerBatch&amp;gt; ready = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; to make starvation less likely this loop doesn't start at 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 避免每次都从一个partition取，要雨露均沾&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; start = drainIndex = drainIndex %&lt;span&gt; parts.size();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         PartitionInfo part =&lt;span&gt; parts.get(drainIndex);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         TopicPartition tp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TopicPartition(part.topic(), part.partition());
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.drainIndex = (&lt;span&gt;this&lt;/span&gt;.drainIndex + 1) %&lt;span&gt; parts.size();
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only proceed if the partition has no in-flight batches.&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMuted(tp, now))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         Deque&amp;lt;ProducerBatch&amp;gt; deque =&lt;span&gt; getDeque(tp);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (deque == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加锁，不用说了吧&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (deque) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; invariant: !isMuted(tp,now) &amp;amp;&amp;amp; deque != null&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;             ProducerBatch first =&lt;span&gt; deque.peekFirst();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; first != null
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看是否在backoff期间&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; backoff = first.attempts() &amp;gt; 0 &amp;amp;&amp;amp; first.waitedTimeMs(now) &amp;lt;&lt;span&gt; retryBackoffMs;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only drain the batch if it is not during backoff period.&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (backoff)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超过maxSize且ready里有东西&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (size + first.estimatedSizeInBytes() &amp;gt; maxSize &amp;amp;&amp;amp; !&lt;span&gt;ready.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; there is a rare case that a single batch size is larger than the request size due to
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; compression; in this case we will still eventually send this batch in a single request
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有一种特殊的情况，batch的大小超过了maxSize，且batch是空的。也就是一个batch大小直接大于一次发送的maxSize
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种情况下最终还是会发送这个batch在一次请求&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldStopDrainBatchesForPartition(first, tp))
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这块配置下面会讲&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; isTransactional = transactionManager != &lt;span&gt;null&lt;/span&gt; ? transactionManager.isTransactional() : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 ProducerIdAndEpoch producerIdAndEpoch =
&lt;span&gt; 73&lt;/span&gt;                     transactionManager != &lt;span&gt;null&lt;/span&gt; ? transactionManager.producerIdAndEpoch() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 ProducerBatch batch =&lt;span&gt; deque.pollFirst();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (producerIdAndEpoch != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;batch.hasSequence()) {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the batch already has an assigned sequence, then we should not change the producer id and
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; sequence number, since this may introduce duplicates. In particular, the previous attempt
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; may actually have been accepted, and if we change the producer id and sequence here, this
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; attempt will also be accepted, causing a duplicate.
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Additionally, we update the next sequence number bound for the partition, and also have
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the transaction manager track the batch so as to ensure that sequence ordering is maintained
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; even if we receive out of order responses.&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    batch.setProducerState(producerIdAndEpoch, transactionManager.sequenceNumber(batch.topicPartition), isTransactional);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                    transactionManager.incrementSequenceNumber(batch.topicPartition, batch.recordCount);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                     log.debug(&quot;Assigned producerId {} and producerEpoch {} to batch with base sequence &quot; +
&lt;span&gt; 87&lt;/span&gt;                             &quot;{} being sent to partition {}&quot;&lt;span&gt;, producerIdAndEpoch.producerId,
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                        producerIdAndEpoch.epoch, batch.baseSequence(), tp);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                    transactionManager.addInFlightBatch(batch);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加batch，并且close&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                batch.close();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 size +=&lt;span&gt; batch.records().sizeInBytes();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                ready.add(batch);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                batch.drained(now);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; (start !=&lt;span&gt; drainIndex);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ready;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三.幂等性producer&lt;/h2&gt;
&lt;p&gt;　　上面说到一个参数，enable.idempotence。0.11.0.0版本引入的幂等性producer表示它的发送操作是幂等的，也就是说，不会存在各种错误导致的重复消息。（比如说瞬时的发送错误可能导致producer端出现重试，同一个消息可能发送多次）&lt;/p&gt;
&lt;p&gt;　　producer发送到broker端的每批消息都会有一个序列号（用于去重），Kakfa会把这个序列号存在底层日志，保存序列号只需要几个字节，开销很小。producer端会分配一个PID，对于PID、分区和序列号的关系，可以想象成一个哈希表，key就是（PID，分区），value就是序列号。比如第一次给broker发送((PID=1，分区=1),序列号=2)，第二次发送的value比2小或者等于2，则broker会拒绝PRODUCE请求，实现去重。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个只能保证单个producer实例的EOS语义&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 13:57:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>一.前言 任何消息队列都是万变不离其宗都是3部分，消息生产者（Producer）、消息消费者（Consumer）和服务载体（在Kafka中用Broker指代）。那么本篇主要讲解Producer端，会有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GrimMjx/p/11354987.html</dc:identifier>
</item>
<item>
<title>java 代理模式-静态代理与动态代理 - Arebirth</title>
<link>http://www.cnblogs.com/arebirth/p/javaproxyschema.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arebirth/p/javaproxyschema.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;最近在研究SpringAOP，当然要学习AOP就要知道这么健硕、强大的功能的背后究竟隐藏着怎样不可告人的“秘密&lt;/strong&gt;”？？&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;接下来就是查阅了许多资料详细的研究了一下Java的代理模式，感觉还是非常非常重要的，&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;我们作为一个有“内涵的”程序员就更应该掌握啦！（本文需要细心、带有审视的目光来甄别其中的内容）&lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;在学习代理模式的时候我首先要提出几个问题，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、什么是代理模式？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　举个例子吧：我们生活中的租房问题。假如我们去租个房子，我们大多数情况下是不会知道房主（就是真正租房，一手货源）的，我们是不是都是先去某些租房平台，或者去找当地的中介去询问何时的房子。我们通过九牛二虎之力在中介那里找到了个物美价廉的房子后，你的租金是不是交给了中介，中介还会收取一些额外的推荐费啦，押金啦、手续费等之类的，那么好，这样的一小段，就已经出来了其中两大核心对象了。&lt;/p&gt;
&lt;p&gt;　　　　房主（把房子交给中介的人）：被代理对象&lt;/p&gt;
&lt;p&gt;　　　　中介（租给你房子的人）：代理对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2、代理模式有哪些作用？ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.可以隐藏目标的的具体实现（还是拿上面租房的例子来说，房主把房子交给了中介，并和中介谈好了价格我 7你3啊。然后当我们去租房子的时候，是中介正面把房子租给了我们，而真正背后卖房子的并未出面，这样就隐藏了背后人的信息和提高了背后人的安全）&lt;/p&gt;
&lt;p&gt;　　　　2.可以在不修改目标类代码的情况下，对其增加新的功能。（上面例子来说：房东把房子交给中介的时候价格可能只有1000，但是房东可以卖到5000，然后卖出去后在把1000给房东，自己收入4000，这样原房东不但收到了应由的钱，中介还收入了更多的额外费用）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3、代理模式有哪几种？分别都有什么不同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　在我们Java程序中代理模式分为：静态代理和动态代理（动态代理又分为：JDK动态代理和CGLIB动态代理）&lt;/p&gt;
&lt;p&gt;　　　　至于什么不同，接下来正式我们着重要学习的内容&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;&lt;strong&gt;静态代理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是静态代理呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顾名思义，就是静态的，死的，一旦创建了就不允许修改了或者说很难修改（指的是程序运行期间）&lt;/li&gt;
&lt;li&gt;专业一些的解释
&lt;ul&gt;&lt;li&gt;如若代理类在程序运行之前就已经存在，那么这种代理方式被称为静态代理。这种情况下的代理类通常都是我们在Java代码中定义的。&lt;/li&gt;
&lt;li&gt;通常情况下静态代理类和目标类通常都会实现同一个接口或者派生自同一父类　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;具体实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被代理类与代理类共同实现的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 需要实现的共同接口&lt;br/&gt;* 因为要保证代理类要不改变被代理类原来功能的基础上增加新的功能
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RentalHouse {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 出租房子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被代理类（房东）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 房东（目标类、被代理类）
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Host &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;我是房东，出租500平米的大房子&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理类（中介）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 静态代理类（中介、代理类）
 * 注意：需要被代理类实现相同的接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StaticProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RentalHouse rentalHouse;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StaticProxy(RentalHouse rentalHouse) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rentalHouse =&lt;span&gt; rentalHouse;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;我是中介，收你500推荐费&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用被代理类的租房方法&lt;/span&gt;
&lt;span&gt;        rentalHouse.rent();
        System.out.println(&lt;/span&gt;&quot;我是中介，我又想收你1000块钱！&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建被代理度下行&lt;/span&gt;
        Host host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Host();
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 创建代理对象，并把被代理对象传递给代理对象，
         * 因为他们都实现相同的接口，实现了相同的方法，这样的话传递的对象可以是房东1 房东2 ...
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        StaticProxy proxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticProxy(host);
        proxy.rent();
    }
}


输出结果：
    我是中介，收你500推荐费    
    我是房东，出租500平米的大房子
    我是中介，我又想收你1000块钱！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;试想一下，如果有两个房东，三个，四个，甚至更多个房东的话，我们怎么写？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;被代理类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 房东1（目标类、被代理类）
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Host1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;我是房东1，出租500平米的大房子&quot;&lt;span&gt;);
    }
}


&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 房东2（目标类、被代理类）
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Host2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;我是房东2，出租500平米的大房子&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代理类（中介）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.staticproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 静态代理类（中介、代理类）
 * 注意：需要被代理类实现相同的接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StaticProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;什么价位的房子&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; moneuy;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Agent(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; moneuy) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.moneuy =&lt;span&gt; moneuy;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; renting() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出租房东的租房
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中介调用的租房方法仍然是房东的租房方法&lt;/span&gt;
        System.out.println(&quot;收取50元推荐费&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (moneuy &amp;lt;= 800) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;金额小于等于800的时候&lt;/span&gt;
            Host1 host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Host1();
            host.rent();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Host2 host &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Host2();
            host.rent();
        }

        System.out.println(&lt;/span&gt;&quot;收取500元押金费用&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        StaticProxy proxy&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StaticProxy(1000&lt;span&gt;);
        proxy.renting();
    }
}


输出结果：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
   我是房东2，出租500平米的大房子
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;静态代理的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们仔细来观察下，随着我们的被代理对象的增多，也是就是房东越来越多，那我们的被代理类就会越来越冗余，中介的压力也就会越来越大。&lt;/p&gt;

&lt;hr/&gt;
&lt;h3&gt;&lt;strong&gt;动态代理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;常用的动态代理又分为JDK动态代理和CGLIB动态代理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么两者的使用场景又是什么呢？？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果目标对象实现了接口，就是上面我们举到的例子，房东和中介共同实现的接口类似，这样的话就采用JDK动态代理&lt;/p&gt;
&lt;p&gt;　　如果目标对象没有实现接口，必须采用CGLIB动态代理&lt;/p&gt;

&lt;p&gt;具体实现：&lt;/p&gt;

&lt;p&gt;要实现的共同接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.jdkproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 需要实现的共同接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RentalHouse {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 出租房子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;房东（被代理对象）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.jdkproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 房东（目标类、被代理类）
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Host &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;我是房东，出租500平米的大房子&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心来了！（JDK动态代理实现类）&lt;span&gt;package&lt;/span&gt; &lt;span&gt;cn.arebirth.jdkproxy;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * JDK动态代理类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JdkProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {&lt;br/&gt;　　//接收要被代理的类
    RentalHouse rentalHouse;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdkProxy(RentalHouse rentalHouse) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rentalHouse =&lt;span&gt; rentalHouse;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 执行该方法就会产生代理类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy() {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Proxy.getProxyInstance(param1,param2,para3);
         * 参数一：传入一个classLoader()对象
         * 参数二：传入被代理类所实现的接口的数组，因为代理类底层要根据接口产生
         * 参数三：参数类型是InvocationHandler即可，this即当前类，我们当前类实现了此接口
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Object proxy &lt;/span&gt;= Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.getClass().getClassLoader(), &lt;span&gt;new&lt;/span&gt; Class[]{RentalHouse.&lt;span&gt;class&lt;/span&gt;}, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 这个方法类似于上面我所讲述的静态代理模式里面的中介类的rent()方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; proxy  代理对象--中介
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method 代理对象中的方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args   代理对象方法中的参数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Throwable
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;我是中介，收你500推荐费&quot;&lt;span&gt;);
        Object invoke &lt;/span&gt;=&lt;span&gt; method.invoke(rentalHouse, args);
        System.out.println(&lt;/span&gt;&quot;我是中介，我又想收你1000块钱！&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回执行方法后的返回值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; invoke;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.jdkproxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建JdkProxy动态代理对象类，并把需要被代理的对象传递进去&lt;/span&gt;
        JdkProxy jdkProxy = &lt;span&gt;new&lt;/span&gt; JdkProxy(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Host());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得代理类 这里一定要写他们共同实现的接口  利用java多态的特性，如果直接写真实类型是会报错的&lt;/span&gt;
        RentalHouse  proxy=&lt;span readability=&quot;3&quot;&gt; (RentalHouse)jdkProxy.getProxy();
        proxy.rent();
    }
}&lt;p&gt;输出结果：&lt;br/&gt;　　我是中介，收你500推荐费
　　我是房东，出租500平米的大房子
　　我是中介，我又想收你1000块钱！&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;我想当你看到这里一定会感到困惑，为什么我们获取到了代理对象后执行的执行代理对象的方法，明明是房东的方法，怎么显示的好像是JDK动态代理类里面的invoke()方法？？或许还有其他的困惑，我们将在下边一一讲解如何实现的原理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;既然想知道如何实现的，那么我们就要从底层出发，来看看，底层的Proxy代理到底帮我们生成了一个怎样的代理类。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;再开始之前我希望接下来的代码与操作你是跟着我同步进行的，这样子才会更深刻有更好的理解，当然不排除你是个人脑机器模拟器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;开始吧！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们想要看底层如何实现的，那么我们首先就要获得代理类的class文件&lt;/p&gt;
&lt;p&gt;下面是我写的一个获取JDKProxy动态代理所生成的代理文件的工具类&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.jdkproxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sun.misc.ProxyGenerator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyUtil {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; proxyName  生成文件代理类的名字
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; interClass 代理类所实现的接口的class数组形式
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; path       写出路径
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeProxyClassToHardDisk(String proxyName, Class[] interClass, String path) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes =&lt;span&gt; ProxyGenerator.generateProxyClass(proxyName, interClass);

        FileOutputStream out &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(path + File.separator + proxyName+&quot;.class&quot;&lt;span&gt;);
            out.write(bytes);
            out.flush();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (out != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    out.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在测试类里面使用它&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.jdkproxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建JdkProxy动态代理对象类，并把需要被代理的对象传递进去&lt;/span&gt;
        JdkProxy jdkProxy = &lt;span&gt;new&lt;/span&gt; JdkProxy(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Host());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得代理类&lt;/span&gt;
        RentalHouse proxy =&lt;span&gt; (RentalHouse) jdkProxy.getProxy();
        proxy.rent();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入JDK动态代理生成的代理类&lt;/span&gt;
        ProxyUtil.writeProxyClassToHardDisk(proxy.getClass().getSimpleName(), proxy.getClass().getInterfaces(), &quot;F:\\Tools\\DevelopmentTools&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后生成出来的代理类是一个class字节码文件，我们需要使用反编译工具来查看，我使用的是Luten（这个工具打开方式特殊，百度自行查找）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; cn.arebirth.jdkproxy.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; $Proxy0 &lt;span&gt;extends&lt;/span&gt; Proxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RentalHouse
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m3;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m2;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m0;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; $Proxy0(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; InvocationHandler invocationHandler) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(invocationHandler);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; equals(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object o) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;boolean&lt;/span&gt;)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, $Proxy0.m1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { o });
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error |&lt;span&gt; RuntimeException error) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(t);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {//这个就是编译器自动为我们实现了的接口中的方法
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, $Proxy0.m3, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;); //并调用了invoke
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error |&lt;span&gt; RuntimeException error) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(t);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, $Proxy0.m2, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error |&lt;span&gt; RuntimeException error) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(t);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, $Proxy0.m0, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error |&lt;span&gt; RuntimeException error) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(t);
        }
    }
    &lt;br/&gt;//在类第一次加载的时候，给全局变量进行初始化，看看里面有没有我们稍微眼熟的东西
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            $Proxy0.m1 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;));
            $Proxy0.m3 &lt;/span&gt;= Class.forName(&quot;cn.arebirth.jdkproxy.RentalHouse&quot;).getMethod(&quot;rent&quot;, (Class&amp;lt;?&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);//这里就是我们所实现的接口中的方法
            $Proxy0.m2 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, (Class&amp;lt;?&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
            $Proxy0.m0 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, (Class&amp;lt;?&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodError(ex.getMessage());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoClassDefFoundError(ex2.getMessage());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在看到这里的时候，我们大概能了解到，原来我们在使用我们代理类调用租房的方法的时候，它里面并没有我们写的代码而是执行了一个&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; super.h.invoke(this, $Proxy0.m3, null&lt;span&gt;)；&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;那么super是谁？就是它自动继承的Proxy类&lt;/p&gt;
&lt;p&gt;那么h是什么？就是Proxy类的InvocationHandler&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1760573/201909/1760573-20190910085818972-742154696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 那么我们看这个InvocationHandler类是不是感觉有那么一丢丢的眼熟啊，回过头看，这就是我们在写JDK动态代理类的时候实现的那个接口。&lt;/p&gt;
&lt;p&gt;!!!!!!!!!!!!!&lt;/p&gt;
&lt;p&gt;然后它又调用了invoke(this, $Proxy0.m3, null);&lt;/p&gt;
&lt;p&gt;第一个参数：代理类对象&lt;/p&gt;
&lt;p&gt;第二个参数：要执行的代理类对象的方  Method对象，这个Method对象的值已经由我们的编译器帮我们构建好了，我们只需要第一个次加载这个类的时候他就会自动赋值了（static代码块）&lt;/p&gt;
&lt;p&gt;第三个参数：方法里面的参数，当没有参数的时候就是NULL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1760573/201909/1760573-20190910090018068-499110217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;带着你的疑惑，从头在开始好好敲一遍代码，捋一遍，相信我，你将有更大的收货！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面是简略画的思路图，试着用画图来画出你的思维&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1760573/201909/1760573-20190910211214639-1634548267.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;那么说完了这个JDK动态代理，我们有没有发现什么缺点？？找茬时间开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;是不是这个JDK动态代理必须要依赖接口才能实现，如果没有接口的话，那么JDK动态代理也就凉凉了对吧，！&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;那么好，接下来我们将说一种更加强大的动态代理方式CGLIB,它的实现原理只要我们懂了JDK动态代理，那么下面的就是小儿科啦哈哈~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CGLIB的代理将不再需要接口也可以生成代理类，但是它需要导包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1760573/201909/1760573-20190910204206595-1889847710.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 当然，你也可以选择其他版本的JAR包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;===&lt;/p&gt;
&lt;p&gt;开始&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;被代理类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.cglibproxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 被代理类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Host {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rent() {
        System.out.println(&lt;/span&gt;&quot;Host：rental house&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;生成代理对象的cglib类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.cglibproxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodProxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取代理类
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy() {
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置被代理对象&lt;/span&gt;
        enhancer.setSuperclass(Host.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调方法  当前对象&lt;/span&gt;
        enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理对象&lt;/span&gt;
        Object o =&lt;span&gt; enhancer.create();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o           被代理对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; method      被代理对象方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; objects     被代理对象方法中的参数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; methodProxy 代理类中的方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Throwable
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;中介收取手续费&quot;&lt;span&gt;);
        Object o1 &lt;/span&gt;=&lt;span&gt; methodProxy.invokeSuper(o, objects);
        System.out.println(&lt;/span&gt;&quot;中介收取中介费&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.arebirth.cglibproxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        CglibProxy cglibProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CglibProxy();
        Host proxy &lt;/span&gt;= (Host) cglibProxy.getProxy();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换为我们的房主&lt;/span&gt;
&lt;span&gt;        proxy.rent();
    }
}

输出结果：
　　中介收取手续费
　　Host：rental house
　　中介收取中介费&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;我们动态代理的最大好处就是，可以在没有接口的情况下，只有一个类，我们就可以动态的代理，在程序运行的时候动态的为他创建代理类&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;最后让我们大概的总结下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代理模式：&lt;/strong&gt;&lt;br/&gt;静态代理&lt;br/&gt;动态代理：JDK动态代理 CGLIB动态代理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式的三个要素&lt;/strong&gt;&lt;br/&gt;A.抽象的类或接口 完成一件怎样的事情&lt;br/&gt;B 被代理对象 事情操作具体内容&lt;br/&gt;C 代理对象 帮助我们完成事情的同时 可以增加其他的东西&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体的列子：我们找中介租房子&lt;/strong&gt;&lt;br/&gt;A 抽象的类或者接口 租房子&lt;br/&gt;B 被代理对象 房东&lt;br/&gt;C 代理对象 中介&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式的好处&lt;/strong&gt;&lt;br/&gt;A 房东可以安心的做自己的事情 （被代理对象可以做自己的事情）&lt;br/&gt;B 我们有了问题可以直接找中介 （被代理对象变得比较安全）&lt;br/&gt;C 可以增强代码的扩展性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK动态代理和CGLIB动态代理的使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以这样记一下，只要被代理类没有实现接口，我们就必须使用CGLIB动态代理&lt;/p&gt;

</description>
<pubDate>Tue, 10 Sep 2019 13:52:00 +0000</pubDate>
<dc:creator>Arebirth</dc:creator>
<og:description>java 代理模式 --静态代理与动态代理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/arebirth/p/javaproxyschema.html</dc:identifier>
</item>
<item>
<title>Springboot源码分析之代理对象内嵌调用 - TheGir1</title>
<link>http://www.cnblogs.com/qinzj/p/11503175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinzj/p/11503175.html</guid>
<description>&lt;h4 id=&quot;摘要&quot;&gt;摘要：&lt;/h4&gt;
&lt;p&gt;关于这个话题可能最多的是&lt;code&gt;@Async&lt;/code&gt;和&lt;code&gt;@Transactional&lt;/code&gt;一起混用，我先解释一下什么是代理对象内嵌调用，指的是一个代理方法调用了同类的另一个代理方法。首先在这儿我要声明事务直接的嵌套调用除外，至于为什么，是它已经将信息保存在线程级别了，是不是又点儿抽象，感觉吃力，可以看看我前面关于事务的介绍。&lt;/p&gt;
&lt;h4 id=&quot;async和transactional共存&quot;&gt;@Async和@Transactional共存&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Component
    public class AsyncWithTransactional {
        
        @Async
        @Transactional
        public void test() {
            
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一段代码会发生什么？熟悉的人都会感觉疑惑，都有效果么？谁先被代理增强？&lt;/p&gt;
&lt;p&gt;自动代理创建器&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;它实际也是个&lt;code&gt;BeanPostProcessor&lt;/code&gt;，所以它们的执行顺序很重要~~~&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public abstract class AbstractAdvisingBeanPostProcessor extends ProxyProcessorSupport implements BeanPostProcessor {
        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) {
            if (bean instanceof Advised) {
                advised.addAdvisor(this.advisor);
                return bean;
            }
            // 上面没有return，这里会继续判断自己去创建代理~
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;默认值也同上。但是在把自动代理创建器添加进容器的时候有这么一句代码：&lt;code&gt;beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);&lt;/code&gt;自动代理创建器这个处理器是最高优先级&lt;/li&gt;
&lt;li&gt;由上可知因为标注有&lt;code&gt;@Transactional&lt;/code&gt;，所以自动代理会生效，因此它会先交给&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;把代理对象生成好了，再交给后面的处理器执行&lt;br/&gt;由于&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;先执行，所以&lt;code&gt;AsyncAnnotationBeanPostProcessor&lt;/code&gt;执行的时候此时&lt;code&gt;Bean&lt;/code&gt;已经是代理对象了，此时它会沿用这个代理，只需要把切面添加进去即可~&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;方法调用顺序影响&quot;&gt;方法调用顺序影响&lt;/h4&gt;
&lt;p&gt;想必大家都知道一点就是同类的方法调用只有入口方法被代理才会被增强，这是由于源码级别只处理入口方法调用，是你的话你也这样设计，不然方法栈那么深，你管得了那么多吗？既然知道了这个原因，那么我们接下来在看一下后面的列子。&lt;/p&gt;
&lt;h4 id=&quot;沿用代理对象&quot;&gt;沿用代理对象&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     java.lang.IllegalStateException: Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.
        at org.springframework.aop.framework.AopContext.currentProxy(AopContext.java:69)
        at com.fsx.dependency.B.funTemp(B.java:14)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:343)
        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:206)
        at com.sun.proxy.$Proxy44.funTemp(Unknown Source)
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个异常在上述情况最容易出现，然而解决的方法都是&lt;code&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;咦，是不是我们可以从容器中获取代理对象呢？没有错，从容器获取代理对象也是一种沿用代理对象来调用方法链的手段，但是你会用么？依赖于代理的具体实现而书写代码，这样移植性会非常差的。&lt;/p&gt;
&lt;h4 id=&quot;揭秘enableaspectjautoproxyexposeproxy-true&quot;&gt;揭秘@EnableAspectJAutoProxy(exposeProxy = true)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;内建的类且都是代理类的处理类：&lt;code&gt;CglibAopProxy&lt;/code&gt;和&lt;code&gt;JdkDynamicAopProxy&lt;/code&gt;两者很类似，在处理这个逻辑上。所以此处只以&lt;code&gt;JdkDynamicAopProxy&lt;/code&gt;作为代表进行说明即可。&lt;/p&gt;
&lt;p&gt;我们知道在执行代理对象的目标方法的时候，都会交给&lt;code&gt;InvocationHandler&lt;/code&gt;处理，因此做事情的在&lt;code&gt;invoke()&lt;/code&gt;方法里：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {
        ...
        @Override
        @Nullable
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            ...
                if (this.advised.exposeProxy) {
                    // Make invocation available if necessary.
                    oldProxy = AopContext.setCurrentProxy(proxy);
                    setProxyContext = true;
                }
            ...
            finally {
                if (setProxyContext) {
                    // Restore old proxy.
                    AopContext.setCurrentProxy(oldProxy);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终决定是否会调用&lt;code&gt;set&lt;/code&gt;方法是由&lt;code&gt;this.advised.exposeProxy&lt;/code&gt;这个值决定的，因此下面我们只需要关心&lt;code&gt;ProxyConfig.exposeProxy&lt;/code&gt;这个属性值什么时候被赋值为&lt;code&gt;true&lt;/code&gt;的就可以了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ProxyConfig.exposeProxy&lt;/code&gt;这个属性的默认值是&lt;code&gt;false&lt;/code&gt;。其实最终调用设置值的是同名方法&lt;code&gt;Advised.setExposeProxy()&lt;/code&gt;方法，而且是通过反射调用的,再次强调 看清楚后置处理器，&lt;code&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/code&gt;作用的范围在&lt;code&gt;AbstractAutoProxyCreator&lt;/code&gt;创建器，异步注解和缓存注解等就不行了，怎么解决后面在分析。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
        AspectJAutoProxyRegistrar() {
        }
    
        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
            AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
            AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
            if (enableAspectJAutoProxy != null) {
                if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
                    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
                }
              //处理是否设置了该属性
                if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
                    AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
                }
            }
    
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下是如何设置属性值的，我们后面可以采用这样的方式来设置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {
            if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
                BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
                definition.getPropertyValues().add(&quot;exposeProxy&quot;, Boolean.TRUE);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么时候使用的呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281920/201909/1281920-20190910214608665-525283460.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AopContext.setCurrentProxy(@Nullable Object proxy)&lt;/code&gt;在&lt;code&gt;CglibAopProxy&lt;/code&gt;和&lt;code&gt;JdkDynamicAopProxy&lt;/code&gt;代理都有使用。&lt;/p&gt;
&lt;h4 id=&quot;案例分析&quot;&gt;案例分析&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Component
    public class AsyncWithTransactional {
      //入口方法
        @Transactional
        public void transactional() {
          //不使用代理对象调用的话，后续方法不会被增强
            AsyncWithTransactional asyncWithTransactional = AsyncWithTransactional.class.cast(AopContext.currentProxy());
            asyncWithTransactional.async();
            
        }
        @Async
        public void async() {
    
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样都完全ok的，但是如果换一下呢就会跑出异常。&lt;/p&gt;
&lt;h4 id=&quot;子线程引起的问题&quot;&gt;子线程引起的问题&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        @Transactional//@Transactional有此注解和没有毫无关系
        @Async
        public void transactional() {
            AsyncWithTransactional asyncWithTransactional = AsyncWithTransactional.class.cast(AopContext.currentProxy());
            asyncWithTransactional.async();
        }
    public void async() {
    
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根本原因就是关键节点的执行时机问题。在执行代理对象&lt;code&gt;transactional&lt;/code&gt;方法的时候，先执行绑定动作&lt;code&gt;AopContext.setCurrentProxy(proxy);&lt;/code&gt;然后目标方法执行（包括增强器的执行）&lt;code&gt;invocation.proceed()&lt;/code&gt;。其实在执行绑定的还是在主线程里而并非是新的异步线程，所以在你在方法体内（已经属于异步线程了）执行&lt;code&gt;AopContext.currentProxy()&lt;/code&gt;那可不就报错了嘛~&lt;/p&gt;
&lt;p&gt;所以入口方法用了类似&lt;code&gt;@Async&lt;/code&gt;的效果注解都会导致代理对象绑定不对，继而导致调用错误。&lt;/p&gt;
&lt;h4 id=&quot;如何解决类似子线程引起的问题呢&quot;&gt;如何解决类似子线程引起的问题呢？&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Component
    public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
        @Override
        public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME);
            beanDefinition.getPropertyValues().add(&quot;exposeProxy&quot;, true);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样解决了&lt;code&gt;@Async&lt;/code&gt;的绑定问题，&lt;code&gt;@EnableCaching&lt;/code&gt;也可以基于这样的思想来解决，以上就是我的简单例子，但是配合我的文字说明，相信大家可以举一反三，随意玩弄它们之间的调用关系。&lt;br/&gt;其实如果Spring做出源码改变会更好的解决这个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Async&lt;/code&gt;的代理也交给自动代理创建器来完成(Spring做出源码改变)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAsync&lt;/code&gt;增加&lt;code&gt;exposeProxy&lt;/code&gt;属性，默认值给&lt;code&gt;false&lt;/code&gt;即可(Spring做出源码改变)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;总结&quot;&gt;总结：&lt;/h4&gt;
</description>
<pubDate>Tue, 10 Sep 2019 13:46:00 +0000</pubDate>
<dc:creator>TheGir1</dc:creator>
<og:description>Springboot源码分析之项目结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinzj/p/11503175.html</dc:identifier>
</item>
<item>
<title>如何在 Ubuntu 上安装 MongoDB - wefeng</title>
<link>http://www.cnblogs.com/wefeng/p/11503141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wefeng/p/11503141.html</guid>
<description>&lt;p&gt;&lt;a title=&quot;MongoDb中国网站&quot; href=&quot;https://www.mongochina.com/&quot; target=&quot;_blank&quot;&gt;MongoDB&lt;/a&gt; 是一个越来越流行的自由开源的 NoSQL 数据库，它将数据存储在类似 JSON 的灵活文档集中，这与 SQL 数据库中常见的表格形式形成对比。&lt;/p&gt;
&lt;p&gt;你很可能发现在现代 Web 应用中使用 MongoDB。它的文档模型使得使用各种编程语言能非常直观地访问和处理它。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;450&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/942697-eb8610625a4c111e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/942697-eb8610625a4c111e.jpg&quot; data-original-width=&quot;800&quot; data-original-height=&quot;450&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;17590&quot; data-image-index=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;mongodb Ubuntu&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在本文中，我将介绍两种在 Ubuntu 上安装 MongoDB 的方法。&lt;/p&gt;
&lt;p&gt;在基于 Ubuntu 的发行版上安装 MongoDB&lt;/p&gt;
&lt;p&gt;使用 Ubuntu 仓库安装 MongoDB。简单但不是最新版本的 MongoDB&lt;/p&gt;
&lt;p&gt;使用其官方仓库安装 MongoDB。稍微复杂，但你能得到最新版本的 MongoDB。&lt;/p&gt;
&lt;p&gt;第一种安装方法更容易，但如果你计划使用官方支持的最新版本，那么我建议使用第二种方法。&lt;/p&gt;
&lt;p&gt;有些人可能更喜欢使用 snap 包。Ubuntu 软件中心提供了 snap，但我不建议使用它们，因为他们现在已经过期了，因此我这里不会提到。&lt;/p&gt;
&lt;p&gt;方法 1：从 Ubuntu 仓库安装 MongoDB&lt;/p&gt;
&lt;p&gt;这是在系统中安装 MongoDB 的简便方法，你只需输入一个命令即可。&lt;/p&gt;
&lt;p&gt;安装 MongoDB&lt;/p&gt;
&lt;p&gt;首先，确保你的包是最新的。打开终端并输入：&lt;/p&gt;
&lt;p&gt;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y&lt;/p&gt;
&lt;p&gt;继续安装 MongoDB：&lt;/p&gt;
&lt;p&gt;sudo apt install mongodb&lt;/p&gt;
&lt;p&gt;这就完成了！MongoDB 现在安装到你的计算机上了。&lt;/p&gt;
&lt;p&gt;MongoDB 服务应该在安装时自动启动，但要检查服务状态：&lt;/p&gt;
&lt;p&gt;sudo systemctl status mongodb&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;574&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/942697-98b3ad02a8f4f0f3.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/942697-98b3ad02a8f4f0f3.jpg&quot; data-original-width=&quot;800&quot; data-original-height=&quot;574&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;47306&quot; data-image-index=&quot;1&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Check if the MongoDB service is running.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;你可以看到该服务是活动的。&lt;/p&gt;
&lt;p&gt;运行 MongoDB&lt;/p&gt;
&lt;p&gt;MongoDB 目前是一个 systemd 服务，因此我们使用 systemctl 来检查和修改它的状态，使用以下命令：&lt;/p&gt;
&lt;p&gt;sudo systemctl status mongodb &lt;/p&gt;
&lt;p&gt;sudo systemctl stop mongodb &lt;/p&gt;
&lt;p&gt;sudo systemctl start mongodb &lt;/p&gt;
&lt;p&gt;sudo systemctl restart mongodb&lt;/p&gt;
&lt;p&gt;你也可以修改 MongoDB 是否自动随系统启动（默认：启用）：&lt;/p&gt;
&lt;p&gt;sudo systemctl disable mongodb &lt;/p&gt;
&lt;p&gt;sudo systemctl enable mongodb&lt;/p&gt;
&lt;p&gt;要开始使用（创建和编辑）数据库，请输入：&lt;/p&gt;
&lt;p&gt;mongo&lt;/p&gt;
&lt;p&gt;这将启动 mongo shell。有关查询和选项的详细信息，请查看&lt;a title=&quot;MongoDb中国网站&quot; href=&quot;https://docs.mongochina.com/&quot; target=&quot;_blank&quot;&gt;手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意：根据你计划使用 MongoDB 的方式，你可能需要调整防火墙。不过这超出了本篇的内容，并且取决于你的配置。&lt;/p&gt;
&lt;p&gt;卸载 MongoDB&lt;/p&gt;
&lt;p&gt;如果你从 Ubuntu 仓库安装 MongoDB 并想要卸载它（可能要使用官方支持的方式安装），请输入：&lt;/p&gt;
&lt;p&gt;sudo systemctl stop mongodb &lt;/p&gt;
&lt;p&gt;sudo apt purge mongodb &lt;/p&gt;
&lt;p&gt;sudo apt autoremove&lt;/p&gt;
&lt;p&gt;这应该会完全卸载 MongoDB。确保备份你可能想要保留的任何集合或文档，因为它们将被删除！&lt;/p&gt;
&lt;p&gt;方法 2：在 Ubuntu 上安装 MongoDB 社区版&lt;/p&gt;
&lt;p&gt;这是推荐的安装 MongoDB 的方法，它使用包管理器。你需要多打几条命令，对于 Linux 新手而言，这可能会感到害怕。&lt;/p&gt;
&lt;p&gt;但没有什么可怕的！我们将一步步说明安装过程。&lt;/p&gt;
&lt;p&gt;安装 MongoDB&lt;/p&gt;
&lt;p&gt;由 MongoDB Inc. 维护的包称为 mongodb-org，而不是 mongodb（这是 Ubuntu 仓库中包的名称）。在开始之前，请确保系统上未安装 mongodb。因为包之间会发生冲突。让我们开始吧！&lt;/p&gt;
&lt;p&gt;首先，我们必须导入公钥：&lt;/p&gt;
&lt;p&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4&lt;/p&gt;
&lt;p&gt;现在，你需要在源列表中添加一个新的仓库，以便你可以安装 MongoDB 社区版并获得自动更新：&lt;/p&gt;
&lt;p&gt;echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu $(lsb_release -cs)/mongodb-org/4.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list&lt;/p&gt;
&lt;p&gt;要安装 mongodb-org，我们需要更新我们的包数据库，以便系统知道可用的新包：&lt;/p&gt;
&lt;p&gt;sudo apt update&lt;/p&gt;
&lt;p&gt;现在你可以安装最新稳定版的 MongoDB：&lt;/p&gt;
&lt;p&gt;sudo apt install -y mongodb-org&lt;/p&gt;
&lt;p&gt;或者某个特定版本（在 = 后面修改版本号）&lt;/p&gt;
&lt;p&gt;sudo apt install -y mongodb-org=4.0.6 mongodb-org-server=4.0.6 mongodb-org-shell=4.0.6 mongodb-org-mongos=4.0.6 mongodb-org-tools=4.0.6&lt;/p&gt;
&lt;p&gt;如果你选择安装特定版本，请确保在所有位置都修改了版本号。如果你修改了 mongodb-org=4.0.6，你将安装最新版本。&lt;/p&gt;
&lt;p&gt;默认情况下，使用包管理器（apt-get）更新时，MongoDB 将更新为最新的版本。要阻止这种情况发生（并冻结为已安装的版本），请使用：&lt;/p&gt;
&lt;p&gt;echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selections &lt;/p&gt;
&lt;p&gt;echo &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selections &lt;/p&gt;
&lt;p&gt;echo &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selections &lt;/p&gt;
&lt;p&gt;echo &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selections &lt;/p&gt;
&lt;p&gt;echo &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections&lt;/p&gt;
&lt;p&gt;你现在已经成功安装了 MongoDB！&lt;/p&gt;
&lt;p&gt;配置 MongoDB&lt;/p&gt;
&lt;p&gt;默认情况下，包管理器将创建 /var/lib/mongodb 和 /var/log/mongodb，MongoDB 将使用 mongodb 用户帐户运行。&lt;/p&gt;
&lt;p&gt;我不会去更改这些默认设置，因为这超出了本指南的范围。有关详细信息，请查看&lt;a title=&quot;MongoDb中国网站&quot; href=&quot;https://docs.mongochina.com/&quot; target=&quot;_blank&quot;&gt;手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;/etc/mongod.conf 中的设置在启动/重新启动 mongodb 服务实例时生效。&lt;/p&gt;
&lt;p&gt;运行 MongoDB&lt;/p&gt;
&lt;p&gt;要启动 mongodb 的守护进程 mongod，请输入：&lt;/p&gt;
&lt;p&gt;sudo service mongod start&lt;/p&gt;
&lt;p&gt;现在你应该验证 mongod 进程是否已成功启动。此信息（默认情况下）保存在 /var/log/mongodb/mongod.log 中。我们来看看文件的内容：&lt;/p&gt;
&lt;p&gt;sudo cat /var/log/mongodb/mongod.log&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;467&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/942697-6527fde7f076d153.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/942697-6527fde7f076d153.jpg&quot; data-original-width=&quot;800&quot; data-original-height=&quot;467&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;81698&quot; data-image-index=&quot;2&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Check MongoDB logs to see if the process is running properly.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只要你在某处看到：[initandlisten] waiting for connections on port 27017，就说明进程正常运行。&lt;/p&gt;
&lt;p&gt;注意：27017 是 mongod 的默认端口。&lt;/p&gt;
&lt;p&gt;要停止/重启 mongod，请输入：&lt;/p&gt;
&lt;p&gt;sudo service mongod stop &lt;/p&gt;
&lt;p&gt;sudo service mongod restart&lt;/p&gt;
&lt;p&gt;现在，你可以通过打开 mongo shell 来使用 MongoDB：&lt;/p&gt;
&lt;p&gt;mongo&lt;/p&gt;
&lt;p&gt;卸载 MongoDB&lt;/p&gt;
&lt;p&gt;运行以下命令：&lt;/p&gt;
&lt;p&gt;sudo service mongod stop &lt;/p&gt;
&lt;p&gt;sudo apt purge mongodb-org*&lt;/p&gt;
&lt;p&gt;要删除数据库和日志文件（确保备份你要保留的内容！）：&lt;/p&gt;
&lt;p&gt;sudo rm -r /var/log/mongodb &lt;/p&gt;
&lt;p&gt;sudo rm -r /var/lib/mongodb&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;MongoDB 是一个很棒的 NoSQL 数据库，它易于集成到现代项目中。我希望本教程能帮助你在 Ubuntu 上安装它！在下面的评论中告诉我们你计划如何使用 MongoDB。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Sep 2019 13:42:00 +0000</pubDate>
<dc:creator>wefeng</dc:creator>
<og:description>MongoDB 是一个越来越流行的自由开源的 NoSQL 数据库，它将数据存储在类似 JSON 的灵活文档集中，这与 SQL 数据库中常见的表格形式形成对比。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wefeng/p/11503141.html</dc:identifier>
</item>
</channel>
</rss>