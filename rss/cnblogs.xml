<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python基础 | 关于“循环”那些事 - dataxon</title>
<link>http://www.cnblogs.com/dataxon/p/12563843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dataxon/p/12563843.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Python中常见的循环有两类&lt;/strong&gt;：&lt;/p&gt;

&lt;h2 id=&quot;list&quot;&gt;list&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;是最常见的可迭代对象，其他可迭代的对象例如 &lt;code&gt;dict&lt;/code&gt;,&lt;code&gt;set&lt;/code&gt;,file lines,&lt;code&gt;string&lt;/code&gt;等&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in set((1,2,3)):
    print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import string

list_num = list(string.digits)

for i in list_num:
    # 输出偶数
    if int(i)%2 == 0:
        print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0&lt;br/&gt;2&lt;br/&gt;4&lt;br/&gt;6&lt;br/&gt;8&lt;/p&gt;
&lt;h2 id=&quot;range&quot;&gt;range&lt;/h2&gt;
&lt;p&gt;range &lt;code&gt;有头无尾&lt;/code&gt;，e.g. &lt;code&gt;range(1,3)&lt;/code&gt; 实际得到的序列是&lt;code&gt;(1,2)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(3):
    print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0&lt;br/&gt;1&lt;br/&gt;2&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(1,9):
    # 输出偶数
    if int(i)%2 == 0:
        print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;2&lt;br/&gt;4&lt;br/&gt;6&lt;br/&gt;8&lt;/p&gt;
&lt;h2 id=&quot;enumerate&quot;&gt;enumerate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;enumerate&lt;/code&gt;为循环的list加上index，这个index是编号是从0开始的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;list_val = [1,2,3,5,8]
for idx,val in enumerate(list_val):
    print(idx,val)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0 1&lt;br/&gt;1 2&lt;br/&gt;2 3&lt;br/&gt;3 5&lt;br/&gt;4 8&lt;/p&gt;
&lt;h2 id=&quot;zip&quot;&gt;zip&lt;/h2&gt;
&lt;p&gt;同时遍历两个以上的list，并按顺序打包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;list_1 = string.digits[:3]
list_2 = string.ascii_lowercase[:3]
list_3 = string.ascii_uppercase[:3]

print(list_1,list_2,list_3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;012 abc ABC&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;list_merge_1 = list(zip(list_1,list_2,list_3))
print(list_merge_1)

list_merge_2 = [i+j+k for (i,j,k) in zip(list_1,list_2,list_3)]
print(list_merge_2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;[('0', 'a', 'A'), ('1', 'b', 'B'), ('2', 'c', 'C')]&lt;br/&gt;['0aA', '1bB', '2cC']&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 元素组合
list_merge_3 = [i+j for i in list('123') for j in list('ABC')]

print(list_merge_3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;['1A', '1B', '1C', '2A', '2B', '2C', '3A', '3B', '3C']&lt;/p&gt;

&lt;p&gt;while相当于for和if的结合体。&lt;/p&gt;
&lt;p&gt;while不一定执行的是循环，有时候功能和if差不多，这个时候while的意义相当于&lt;code&gt;如果条件为真，那就执行如下操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;while更多扮演for和if联合的角色，相当于&lt;code&gt;重复执行如下操作，知道判断条件(会不断变化)不再成立为止&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;while相当于if时&quot;&gt;while相当于if时&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 需要break的配合
x = 2

while(x&amp;gt;1):
    print('这个值大于1')
    
    break
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;这个值大于1&lt;/p&gt;
&lt;h2 id=&quot;while充当for和if的混合体&quot;&gt;while充当for和if的混合体&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 需要自增的index来配合

idx = 1

while(idx &amp;lt; 5):
    print(idx)
    
    idx += 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;/p&gt;

&lt;p&gt;如果将&lt;strong&gt;循环&lt;/strong&gt;理解为按照顺序遍历一个序列。&lt;br/&gt;除了用for、while还可以用其他函数达到“遍历”的效果。&lt;/p&gt;
&lt;h2 id=&quot;列表解析&quot;&gt;列表解析&lt;/h2&gt;
&lt;p&gt;本质还是循环，常见的for循环在语句上的表现是多行，而&lt;code&gt;列表解析&lt;/code&gt;是一行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 筛选奇数
num_odd = [i for i in range(1,10) if i%2==1]

print(num_odd)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;[1, 3, 5, 7, 9]&lt;/p&gt;
&lt;h2 id=&quot;map&quot;&gt;map&lt;/h2&gt;
&lt;p&gt;对序列中多个对象执行相同操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;list(map(lambda x:x**2,range(4)))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;[0, 1, 4, 9]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;list_words = ['life','is','short','use','python']

list(map(lambda x:len(x),list_words))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;[4, 2, 5, 3, 6]&lt;/p&gt;
&lt;h2 id=&quot;迭代器&quot;&gt;迭代器&lt;/h2&gt;
&lt;p&gt;变种的for循环&lt;/p&gt;
&lt;p&gt;按顺序将序列值一次“弹出”，同时被”弹出“的值移出序列&lt;/p&gt;
&lt;p&gt;序列为空时，报错&lt;code&gt;StopIteration&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;vals_iter = iter(list(range(3)))

next(vals_iter)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0&lt;/p&gt;
&lt;p&gt;迭代器可以如上述举例一样是”有穷“的迭代，也可以是”无穷“的，比如自增序列(index为自然顺序)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 定义一个迭代器
class test_iter:
    def __init__(self):
        self.a = 1
        self.b = 1
        
    def __iter__(self):
        return self
 
    def __next__(self):
        x = self.a
        self.a, self.b = self.b, self.a+self.b
        return x
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;fb = test_iter()

for i in range(6):
    print(next(fb))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;1&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;5&lt;br/&gt;8&lt;/p&gt;
&lt;h2 id=&quot;生成器&quot;&gt;生成器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;生成器和迭代器的对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从执行的结果看都是基于一定的规则”迭代“产生序列(无论是“无穷”系列还是“有穷”系列)&lt;/li&gt;
&lt;li&gt;都支持iter,next方法&lt;/li&gt;
&lt;li&gt;“弹出”数值后，会清除已“弹出”的数值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器属于迭代器中的一种&lt;/li&gt;
&lt;li&gt;在定义的时候，定义&lt;code&gt;生成器&lt;/code&gt;就和定义函数一样自然(同时会自动产生iter和next方法)，而定义迭代器则主要通过iter,next来定义序列；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://data-flair.training/blogs/python-generator-vs-iterator/&quot;&gt;更多参考1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&quot;&gt;更多参考2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_even(x):
    while(x&amp;gt;0):
        if x%2 == 0:
            yield x
        x -= 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = num_even(9)

for i in x:
    print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;8&lt;br/&gt;6&lt;br/&gt;4&lt;br/&gt;2&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 是&lt;strong&gt;跳出循环&lt;/strong&gt;，也就是不再执行该循环的操作，如果是嵌套循环，那么上层的循环也终止&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; &lt;strong&gt;跳过当前的操作，进入下一轮循环&lt;/strong&gt;，对上层的循环没有影响&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pass&lt;/code&gt; 接着执行，用得很少，此处不讲&lt;/p&gt;
&lt;p&gt;break,continue之后的语句也不会执行，所以一定要注意这两个关键字放置的位置&lt;/p&gt;
&lt;h2 id=&quot;单层循环&quot;&gt;单层循环&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(5):
    print(i)
    
    if i == 2:
        break # 当i=2时，循环结束
        print('不会出现')   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0&lt;br/&gt;1&lt;br/&gt;2&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(5):
    
    if i == 2:
        continue # 跳过2这个值
        print('不会出现')   
    print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0&lt;br/&gt;1&lt;br/&gt;3&lt;br/&gt;4&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;i = 1
while(i&amp;lt;5):
    print(i)
    break # 执行一次就结束
    print('不会出现')   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;1&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;i = 1
while(i&amp;lt;5):
    print(i)
    
    i += 1
    if i == 2:
        continue
        print('不会出现')   
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;/p&gt;
&lt;p&gt;while中用continue要小心啊,比如如下代码是会一直执行的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;i = 1
while(i&amp;lt;5):
    print(i)
    
    if i == 2:
        continue
        print('不会出现') 
        
    i += 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;嵌套循环&quot;&gt;嵌套循环&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(3):
    for j in list('abc'):
        if j == 'b':
            break # 到b的时候就停止了
        print(i,j)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0 a&lt;br/&gt;1 a&lt;br/&gt;2 a&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for i in range(3):
    for j in list('abc'):
        if i == 1 or j=='b':
            continue
        print(i,j) #不会出现带1和b的输出值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;0 a&lt;br/&gt;0 c&lt;br/&gt;2 a&lt;br/&gt;2 c&lt;/p&gt;
</description>
<pubDate>Wed, 25 Mar 2020 00:29:00 +0000</pubDate>
<dc:creator>dataxon</dc:creator>
<og:description>Python中的循环/迭代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dataxon/p/12563843.html</dc:identifier>
</item>
<item>
<title>面试官再问我如何保证 RocketMQ 不丢失消息,这回我笑了！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12563813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12563813.html</guid>
<description>&lt;p&gt;最近看了 &lt;strong&gt;@JavaGuide&lt;/strong&gt; 发布的一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww&quot;&gt;『面试官问我如何保证Kafka不丢失消息?我哭了！』&lt;/a&gt;，这篇文章承接这个主题，来聊聊如何保证 RocketMQ 不丢失消息。&lt;/p&gt;
&lt;h2 id=&quot;0x00-消息的发送流程&quot;&gt;0x00. 消息的发送流程&lt;/h2&gt;
&lt;p&gt;一条消息从生产到被消费，将会经历三个阶段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081448146-1246887636.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生产阶段，Producer 新建消息，然后通过网络将消息投递给 MQ Broker&lt;/li&gt;
&lt;li&gt;存储阶段，消息将会存储在 Broker 端磁盘中&lt;/li&gt;
&lt;li&gt;消息阶段， Consumer 将会从 Broker 拉取消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上任一阶段都可能会丢失消息，我们只要找到这三个阶段丢失消息原因，采用合理的办法避免丢失，就可以彻底解决消息丢失的问题。&lt;/p&gt;
&lt;h2 id=&quot;0x01-生产阶段&quot;&gt;0x01. 生产阶段&lt;/h2&gt;
&lt;p&gt;生产者（Producer） 通过网络发送消息给 Broker，当 Broker 收到之后，将会返回确认响应信息给 Producer。所以生产者只要接收到返回的确认响应，就代表消息在生产阶段未丢失。&lt;/p&gt;
&lt;p&gt;RocketMQ 发送消息示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DefaultMQProducer mqProducer=new DefaultMQProducer(&quot;test&quot;);
// 设置 nameSpace 地址
mqProducer.setNamesrvAddr(&quot;namesrvAddr&quot;);
mqProducer.start();
Message msg = new Message(&quot;test_topic&quot; /* Topic */,
        &quot;Hello World&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
);
// 发送消息到一个Broker
try {
    SendResult sendResult = mqProducer.send(msg);
} catch (RemotingException e) {
    e.printStackTrace();
} catch (MQBrokerException e) {
    e.printStackTrace();
} catch (InterruptedException e) {
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;send&lt;/code&gt; 方法是一个同步操作，只要这个方法不抛出任何异常，就代表消息已经&lt;strong&gt;发送成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;消息发送成功仅代表消息已经到了 Broker 端，Broker 在不同配置下，可能会返回不同响应状态:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SendStatus.SEND_OK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SendStatus.FLUSH_DISK_TIMEOUT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SendStatus.FLUSH_SLAVE_TIMEOUT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SendStatus.SLAVE_NOT_AVAILABLE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引用官方状态说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081448381-295017799.jpg&quot; alt=&quot;image-20200319220927210&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上图中不同 broker 端配置将会在下文详细解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外 RocketMQ 还提供异步的发送的方式，适合于链路耗时较长，对响应时间较为敏感的业务场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DefaultMQProducer mqProducer = new DefaultMQProducer(&quot;test&quot;);
// 设置 nameSpace 地址
mqProducer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
mqProducer.setRetryTimesWhenSendFailed(5);
mqProducer.start();
Message msg = new Message(&quot;test_topic&quot; /* Topic */,
        &quot;Hello World&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
);

try {
    // 异步发送消息到，主线程不会被阻塞，立刻会返回
    mqProducer.send(msg, new SendCallback() {
        @Override
        public void onSuccess(SendResult sendResult) {
            // 消息发送成功，
        }

        @Override
        public void onException(Throwable e) {
            // 消息发送失败，可以持久化这条数据，后续进行补偿处理
        }
    });
} catch (RemotingException e) {
    e.printStackTrace();
} catch (InterruptedException e) {
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步发送消息一定要&lt;strong&gt;注意重写&lt;/strong&gt;回调方法，在回调方法中检查发送结果。&lt;/p&gt;
&lt;p&gt;不管是同步还是异步的方式，都会碰到网络问题导致发送失败的情况。针对这种情况，我们可以设置合理的重试次数，当出现网络问题，可以自动重试。设置方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 同步发送消息重试次数，默认为 2
mqProducer.setRetryTimesWhenSendFailed(3);
// 异步发送消息重试次数，默认为 2
mqProducer.setRetryTimesWhenSendAsyncFailed(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x02-broker-存储阶段&quot;&gt;0x02. Broker 存储阶段&lt;/h2&gt;
&lt;p&gt;默认情况下，消息只要到了 Broker 端，将会优先保存到内存中，然后立刻返回确认响应给生产者。随后 Broker 定期批量的将一组消息从内存异步刷入磁盘。&lt;/p&gt;
&lt;p&gt;这种方式减少 I/O 次数，可以取得更好的性能，但是如果发生机器掉电，异常宕机等情况，消息还未及时刷入磁盘，就会出现丢失消息的情况。&lt;/p&gt;
&lt;p&gt;若想保证 Broker 端不丢消息，保证消息的可靠性，我们需要将消息保存机制修改为同步刷盘方式，即消息&lt;strong&gt;存储磁盘成功&lt;/strong&gt;，才会返回响应。&lt;/p&gt;
&lt;p&gt;修改 Broker 端配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;## 默认情况为 ASYNC_FLUSH 
flushDiskType = SYNC_FLUSH 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若 Broker 未在同步刷盘时间内（&lt;strong&gt;默认为 5s&lt;/strong&gt;）完成刷盘，将会返回 &lt;code&gt;SendStatus.FLUSH_DISK_TIMEOUT&lt;/code&gt; 状态给生产者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了保证可用性，Broker 通常采用一主（&lt;strong&gt;master&lt;/strong&gt;）多从（&lt;strong&gt;slave&lt;/strong&gt;）部署方式。为了保证消息不丢失，消息还需要复制到 slave 节点。&lt;/p&gt;
&lt;p&gt;默认方式下，消息写入 &lt;strong&gt;master&lt;/strong&gt; 成功，就可以返回确认响应给生产者，接着消息将会异步复制到 &lt;strong&gt;slave&lt;/strong&gt; 节点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：master 配置：flushDiskType = SYNC_FLUSH&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时若 master 突然&lt;strong&gt;宕机且不可恢复&lt;/strong&gt;，那么还未复制到 &lt;strong&gt;slave&lt;/strong&gt; 的消息将会丢失。&lt;/p&gt;
&lt;p&gt;为了进一步提高消息的可靠性，我们可以采用同步的复制方式，&lt;strong&gt;master&lt;/strong&gt; 节点将会同步等待 &lt;strong&gt;slave&lt;/strong&gt; 节点复制完成，才会返回确认响应。&lt;/p&gt;
&lt;p&gt;异步复制与同步复制区别如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081448604-323331900.jpg&quot; alt=&quot;来源于网络&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注： 大家不要被上图误导，broker master 只能配置一种复制方式，上图只为解释同步复制的与异步复制的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Broker master 节点 同步复制配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;## 默认为 ASYNC_MASTER 
brokerRole=SYNC_MASTER
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;strong&gt;slave&lt;/strong&gt; 节点未在指定时间内同步返回响应，生产者将会收到 &lt;code&gt;SendStatus.FLUSH_SLAVE_TIMEOUT&lt;/code&gt; 返回状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合生产阶段与存储阶段，若需要&lt;strong&gt;严格保证消息不丢失&lt;/strong&gt;，broker 需要采用如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;## master 节点配置
flushDiskType = SYNC_FLUSH
brokerRole=SYNC_MASTER

## slave 节点配置
brokerRole=slave
flushDiskType = SYNC_FLUSH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时这个过程我们还需要生产者配合，判断返回状态是否是 &lt;code&gt;SendStatus.SEND_OK&lt;/code&gt;。若是其他状态，就需要考虑补偿重试。&lt;/p&gt;
&lt;p&gt;虽然上述配置提高消息的高可靠性，但是会&lt;strong&gt;降低性能&lt;/strong&gt;，生产实践中需要综合选择。&lt;/p&gt;
&lt;h2 id=&quot;0x03-消费阶段&quot;&gt;0x03. 消费阶段&lt;/h2&gt;
&lt;p&gt;消费者从 broker 拉取消息，然后执行相应的业务逻辑。一旦执行成功，将会返回 &lt;code&gt;ConsumeConcurrentlyStatus.CONSUME_SUCCESS&lt;/code&gt; 状态给 Broker。&lt;/p&gt;
&lt;p&gt;如果 Broker 未收到消费确认响应或收到其他状态，消费者下次还会再次拉取到该条消息，进行重试。这样的方式有效避免了消费者消费过程发生异常，或者消息在网络传输中丢失的情况。&lt;/p&gt;
&lt;p&gt;消息消费的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 实例化消费者
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;test_consumer&quot;);

// 设置NameServer的地址
consumer.setNamesrvAddr(&quot;namesrvAddr&quot;);

// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
consumer.subscribe(&quot;test_topic&quot;, &quot;*&quot;);
// 注册回调实现类来处理从broker拉取回来的消息
consumer.registerMessageListener(new MessageListenerConcurrently() {
    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&amp;lt;MessageExt&amp;gt; msgs, ConsumeConcurrentlyContext context) {
        // 执行业务逻辑
        // 标记该消息已经被成功消费
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
// 启动消费者实例
consumer.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上消费消息过程的，我们需要&lt;strong&gt;注意返回消息状态&lt;/strong&gt;。只有当业务逻辑真正执行成功，我们才能返回 &lt;code&gt;ConsumeConcurrentlyStatus.CONSUME_SUCCESS&lt;/code&gt;。否则我们需要返回 &lt;code&gt;ConsumeConcurrentlyStatus.RECONSUME_LATER&lt;/code&gt;，稍后再重试。&lt;/p&gt;
&lt;h2 id=&quot;0x04-总结&quot;&gt;0x04. 总结&lt;/h2&gt;
&lt;p&gt;看完 RocketMQ 不丢消息处理办法，回头再看这篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww&quot;&gt;kafka&lt;/a&gt;，有没有发现，两者解决思路是一样的，区别就是参数配置不一样而已。&lt;/p&gt;
&lt;p&gt;所以下一次，面试官再问你 XX 消息队列如何保证不丢消息？如果你没用过这个消息队列，也不要哭，微笑面对他，从容给他分析那几步会丢失，然后大致解决思路。&lt;/p&gt;
&lt;p&gt;最后我们还可以说出我们的思考，虽然提高消息可靠性，但是可能导致消息重发，重复消费。所以对于消费客户端，需要注意保证&lt;strong&gt;幂等性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081448713-2087017462.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是要注意了，这时面试官可能就会跟你的话题，让你来聊聊如何保证幂等性，一定先想好再说哦。&lt;/p&gt;
&lt;p&gt;什么?你还不知道如何实现幂等？那就赶紧关注**@程序通事&lt;strong&gt;，后面文章我们就来聊聊&lt;/strong&gt;幂等**这个话题。&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081448970-1413198393.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x05-reference&quot;&gt;0x05. Reference&lt;/h2&gt;
&lt;h2 id=&quot;最后说一句（求关注）&quot;&gt;最后说一句（求关注）&lt;/h2&gt;
&lt;p&gt;才疏学浅，难免会有纰漏，如果你发现了错误的地方，还请你留言给我指出来，我对其加以修改。&lt;/p&gt;
&lt;p&gt;再次感谢您的阅读，我是&lt;strong&gt;楼下小黑哥&lt;/strong&gt;，一位还未秃头的工具猿，下篇文章我们再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200325081449135-1355972796.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 25 Mar 2020 00:15:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>最近看了 @JavaGuide 发布的一篇 &amp;quot;『面试官问我如何保证Kafka不丢失消息?我哭了！』&amp;quot; ，这篇文章承接这个主题，来聊聊如何保证 RocketMQ 不丢失消息。 0x0</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12563813.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core Authorize你不知道的那些事（源码解读） - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12544205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12544205.html</guid>
<description>&lt;p&gt;AuthorizeAttribute 和AuthorizeFilter是怎么样的一个关系？他们跟中间件又是怎样协同工作的？本文一起来探索Asp.Net Core 3.x 的源代码，深入解读他们的关系和中间件之间的那些你不知道的事。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;226.35481370472&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IdentityServer4&lt;/code&gt;已经分享了一些应用实战的文章，从架构到授权中心的落地应用，也伴随着对&lt;code&gt;IdentityServer4&lt;/code&gt;掌握了一些使用规则，但是很多原理性东西还是一知半解，故我这里持续性来带大家一起来解读它的相关源代码，本文先来看看为什么&lt;code&gt;Controller&lt;/code&gt;或者&lt;code&gt;Action&lt;/code&gt;中添加&lt;code&gt;Authorize&lt;/code&gt;或者全局中添加&lt;code&gt;AuthorizeFilter&lt;/code&gt;过滤器就可以实现该资源受到保护，需要通过&lt;code&gt;access_token&lt;/code&gt;才能通过相关的授权呢？今天我带大家来了解&lt;code&gt;AuthorizeAttribute&lt;/code&gt;和&lt;code&gt;AuthorizeFilter&lt;/code&gt;的关系及代码解读。&lt;/p&gt;
&lt;h2 id=&quot;二、代码解读&quot;&gt;二、代码解读&lt;/h2&gt;
&lt;p&gt;解读之前我们先来看看下面两种标注授权方式的代码：&lt;/p&gt;
&lt;h5 id=&quot;标注方式&quot;&gt;标注方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; [Authorize]
 [HttpGet]
 public async Task&amp;lt;object&amp;gt; Get()
 {
      var userId = User.UserId();
      return new
      {
         name = User.Name(),
         userId = userId,
         displayName = User.DisplayName(),
         merchantId = User.MerchantId(),
      };
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过&lt;code&gt;[Authorize]&lt;/code&gt;标注来限制该api资源的访问&lt;/p&gt;
&lt;h5 id=&quot;全局方式&quot;&gt;全局方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
     //全局添加AuthorizeFilter 过滤器方式
     services.AddControllers(options=&amp;gt;options.Filters.Add(new AuthorizeFilter()));

     services.AddAuthorization();
     services.AddAuthentication(&quot;Bearer&quot;)
         .AddIdentityServerAuthentication(options =&amp;gt;
         {
             options.Authority = &quot;http://localhost:5000&quot;;    //配置Identityserver的授权地址
             options.RequireHttpsMetadata = false;           //不需要https    
             options.ApiName = OAuthConfig.UserApi.ApiName;  //api的name，需要和config的名称相同
         });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全局通过添加&lt;code&gt;AuthorizeFilter&lt;/code&gt;过滤器方式进行全局api资源的限制&lt;/p&gt;
&lt;h4 id=&quot;authorizeattribute&quot;&gt;&lt;code&gt;AuthorizeAttribute&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;先来看看&lt;code&gt;AuthorizeAttribute&lt;/code&gt;源代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public class AuthorizeAttribute : Attribute, IAuthorizeData
{
    /// &amp;lt;summary&amp;gt;
    /// Initializes a new instance of the &amp;lt;see cref=&quot;AuthorizeAttribute&quot;/&amp;gt; class. 
    /// &amp;lt;/summary&amp;gt;
    public AuthorizeAttribute() { }

    /// &amp;lt;summary&amp;gt;
    /// Initializes a new instance of the &amp;lt;see cref=&quot;AuthorizeAttribute&quot;/&amp;gt; class with the specified policy. 
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;policy&quot;&amp;gt;The name of the policy to require for authorization.&amp;lt;/param&amp;gt;
    public AuthorizeAttribute(string policy)
    {
       Policy = policy;
    }

    /// &amp;lt;summary&amp;gt;
    /// 收取策略
    /// &amp;lt;/summary&amp;gt;
    public string Policy { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 授权角色
    /// &amp;lt;/summary&amp;gt;
    public string Roles { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 授权Schemes
    /// &amp;lt;/summary&amp;gt;
    public string AuthenticationSchemes { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中可以看到&lt;code&gt;AuthorizeAttribute&lt;/code&gt;继承了&lt;code&gt;IAuthorizeData&lt;/code&gt;抽象接口，该接口主要是授权数据的约束定义，定义了三个数据属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Prolicy ：授权策略&lt;/li&gt;
&lt;li&gt;Roles : 授权角色&lt;/li&gt;
&lt;li&gt;AuthenticationSchemes ：授权Schemes 的支持&lt;br/&gt;Asp.Net Core 中的http中间件会根据&lt;code&gt;IAuthorizeData&lt;/code&gt;这个来获取有哪些授权过滤器，来实现过滤器的拦截并执行相关代码。&lt;br/&gt;我们看看&lt;code&gt;AuthorizeAttribute&lt;/code&gt;代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface IAuthorizeData
{
        /// &amp;lt;summary&amp;gt;
        /// Gets or sets the policy name that determines access to the resource.
        /// &amp;lt;/summary&amp;gt;
        string Policy { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// Gets or sets a comma delimited list of roles that are allowed to access the resource.
        /// &amp;lt;/summary&amp;gt;
        string Roles { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// Gets or sets a comma delimited list of schemes from which user information is constructed.
        /// &amp;lt;/summary&amp;gt;
        string AuthenticationSchemes { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看看&lt;code&gt;授权中间件&lt;/code&gt;（&lt;code&gt;UseAuthorization&lt;/code&gt;）的核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IApplicationBuilder UseAuthorization(this IApplicationBuilder app)
{
    if (app == null)
    {
        throw new ArgumentNullException(nameof(app));
    }

    VerifyServicesRegistered(app);

    return app.UseMiddleware&amp;lt;AuthorizationMiddleware&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中注册了&lt;code&gt;AuthorizationMiddleware&lt;/code&gt;这个中间件，&lt;code&gt;AuthorizationMiddleware&lt;/code&gt;中间件源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class AuthorizationMiddleware
 {
        // Property key is used by Endpoint routing to determine if Authorization has run
        private const string AuthorizationMiddlewareInvokedWithEndpointKey = &quot;__AuthorizationMiddlewareWithEndpointInvoked&quot;;
        private static readonly object AuthorizationMiddlewareWithEndpointInvokedValue = new object();

        private readonly RequestDelegate _next;
        private readonly IAuthorizationPolicyProvider _policyProvider;

        public AuthorizationMiddleware(RequestDelegate next, IAuthorizationPolicyProvider policyProvider)
        {
            _next = next ?? throw new ArgumentNullException(nameof(next));
            _policyProvider = policyProvider ?? throw new ArgumentNullException(nameof(policyProvider));
        }

        public async Task Invoke(HttpContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            var endpoint = context.GetEndpoint();

            if (endpoint != null)
            {
                // EndpointRoutingMiddleware uses this flag to check if the Authorization middleware processed auth metadata on the endpoint.
                // The Authorization middleware can only make this claim if it observes an actual endpoint.
                context.Items[AuthorizationMiddlewareInvokedWithEndpointKey] = AuthorizationMiddlewareWithEndpointInvokedValue;
            }

            // 通过终结点路由元素IAuthorizeData来获得对于的AuthorizeAttribute并关联到AuthorizeFilter中
            var authorizeData = endpoint?.Metadata.GetOrderedMetadata&amp;lt;IAuthorizeData&amp;gt;() ?? Array.Empty&amp;lt;IAuthorizeData&amp;gt;();
            var policy = await AuthorizationPolicy.CombineAsync(_policyProvider, authorizeData);
            if (policy == null)
            {
                await _next(context);
                return;
            }

            // Policy evaluator has transient lifetime so it fetched from request services instead of injecting in constructor
            var policyEvaluator = context.RequestServices.GetRequiredService&amp;lt;IPolicyEvaluator&amp;gt;();

            var authenticateResult = await policyEvaluator.AuthenticateAsync(policy, context);

            // Allow Anonymous skips all authorization
            if (endpoint?.Metadata.GetMetadata&amp;lt;IAllowAnonymous&amp;gt;() != null)
            {
                await _next(context);
                return;
            }

            // Note that the resource will be null if there is no matched endpoint
            var authorizeResult = await policyEvaluator.AuthorizeAsync(policy, authenticateResult, context, resource: endpoint);

            if (authorizeResult.Challenged)
            {
                if (policy.AuthenticationSchemes.Any())
                {
                    foreach (var scheme in policy.AuthenticationSchemes)
                    {
                        await context.ChallengeAsync(scheme);
                    }
                }
                else
                {
                    await context.ChallengeAsync();
                }

                return;
            }
            else if (authorizeResult.Forbidden)
            {
                if (policy.AuthenticationSchemes.Any())
                {
                    foreach (var scheme in policy.AuthenticationSchemes)
                    {
                        await context.ForbidAsync(scheme);
                    }
                }
                else
                {
                    await context.ForbidAsync();
                }

                return;
            }

            await _next(context);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中核心拦截并获得&lt;code&gt;AuthorizeFilter&lt;/code&gt;过滤器的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var authorizeData = endpoint?.Metadata.GetOrderedMetadata&amp;lt;IAuthorizeData&amp;gt;() ?? Array.Empty&amp;lt;IAuthorizeData&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面我分享过一篇关于 &lt;a href=&quot;https://www.cnblogs.com/jlion/p/12423301.html&quot;&gt;Asp.Net Core EndPoint 终结点路由工作原理解读&lt;/a&gt; 的文章里面讲解到通过&lt;code&gt;EndPoint&lt;/code&gt;终结点路由来获取&lt;code&gt;Controller&lt;/code&gt;和&lt;code&gt;Action&lt;/code&gt;中的&lt;code&gt;Attribute&lt;/code&gt;特性标注，这里也是通过该方法来拦截获取对于的&lt;code&gt;AuthorizeAttribute&lt;/code&gt;的.&lt;br/&gt;而获取到相关&lt;code&gt;authorizeData&lt;/code&gt;授权数据后，下面的一系列代码都是通过判断来进行&lt;code&gt;AuthorizeAsync&lt;/code&gt;授权执行的方法,这里就不详细分享它的授权认证的过程了。&lt;br/&gt;细心的同学应该已经发现上面的代码有一个比较特殊的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (endpoint?.Metadata.GetMetadata&amp;lt;IAllowAnonymous&amp;gt;() != null)
{
      await _next(context);
      return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过&lt;code&gt;endpoint&lt;/code&gt;终结点路由来获取是否标注有&lt;code&gt;AllowAnonymous&lt;/code&gt;的特性，如果有则直接执行下一个中间件，不进行下面的&lt;code&gt;AuthorizeAsync&lt;/code&gt;授权认证方法，&lt;br/&gt;这也是为什么&lt;code&gt;Controller&lt;/code&gt;和&lt;code&gt;Action&lt;/code&gt;上标注&lt;code&gt;AllowAnonymous&lt;/code&gt;可以跳过&lt;code&gt;授权认证&lt;/code&gt;的原因了。&lt;/p&gt;
&lt;h4 id=&quot;authorizefilter-源码&quot;&gt;AuthorizeFilter 源码&lt;/h4&gt;
&lt;p&gt;有的人会问&lt;code&gt;AuthorizeAttirbute&lt;/code&gt;和&lt;code&gt;AuthorizeFilter&lt;/code&gt;有什么关系呢？它们是一个东西吗？&lt;br/&gt;我们再来看看&lt;code&gt;AuthorizeFilter&lt;/code&gt;源代码，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuthorizeFilter : IAsyncAuthorizationFilter, IFilterFactory
{
        /// &amp;lt;summary&amp;gt;
        /// Initializes a new &amp;lt;see cref=&quot;AuthorizeFilter&quot;/&amp;gt; instance.
        /// &amp;lt;/summary&amp;gt;
        public AuthorizeFilter()
            : this(authorizeData: new[] { new AuthorizeAttribute() })
        {
        }

        /// &amp;lt;summary&amp;gt;
        /// Initialize a new &amp;lt;see cref=&quot;AuthorizeFilter&quot;/&amp;gt; instance.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;policy&quot;&amp;gt;Authorization policy to be used.&amp;lt;/param&amp;gt;
        public AuthorizeFilter(AuthorizationPolicy policy)
        {
            if (policy == null)
            {
                throw new ArgumentNullException(nameof(policy));
            }

            Policy = policy;
        }

        /// &amp;lt;summary&amp;gt;
        /// Initialize a new &amp;lt;see cref=&quot;AuthorizeFilter&quot;/&amp;gt; instance.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;policyProvider&quot;&amp;gt;The &amp;lt;see cref=&quot;IAuthorizationPolicyProvider&quot;/&amp;gt; to use to resolve policy names.&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;authorizeData&quot;&amp;gt;The &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt; to combine into an &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
        public AuthorizeFilter(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)
            : this(authorizeData)
        {
            if (policyProvider == null)
            {
                throw new ArgumentNullException(nameof(policyProvider));
            }

            PolicyProvider = policyProvider;
        }

        /// &amp;lt;summary&amp;gt;
        /// Initializes a new instance of &amp;lt;see cref=&quot;AuthorizeFilter&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;authorizeData&quot;&amp;gt;The &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt; to combine into an &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt;.&amp;lt;/param&amp;gt;
        public AuthorizeFilter(IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)
        {
            if (authorizeData == null)
            {
                throw new ArgumentNullException(nameof(authorizeData));
            }

            AuthorizeData = authorizeData;
        }

        /// &amp;lt;summary&amp;gt;
        /// Initializes a new instance of &amp;lt;see cref=&quot;AuthorizeFilter&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;policy&quot;&amp;gt;The name of the policy to require for authorization.&amp;lt;/param&amp;gt;
        public AuthorizeFilter(string policy)
            : this(new[] { new AuthorizeAttribute(policy) })
        {
        }

        /// &amp;lt;summary&amp;gt;
        /// The &amp;lt;see cref=&quot;IAuthorizationPolicyProvider&quot;/&amp;gt; to use to resolve policy names.
        /// &amp;lt;/summary&amp;gt;
        public IAuthorizationPolicyProvider PolicyProvider { get; }

        /// &amp;lt;summary&amp;gt;
        /// The &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt; to combine into an &amp;lt;see cref=&quot;IAuthorizeData&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        public IEnumerable&amp;lt;IAuthorizeData&amp;gt; AuthorizeData { get; }

        /// &amp;lt;summary&amp;gt;
        /// Gets the authorization policy to be used.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;remarks&amp;gt;
        /// If&amp;lt;c&amp;gt;null&amp;lt;/c&amp;gt;, the policy will be constructed using
        /// &amp;lt;see cref=&quot;AuthorizationPolicy.CombineAsync(IAuthorizationPolicyProvider, IEnumerable{IAuthorizeData})&quot;/&amp;gt;.
        /// &amp;lt;/remarks&amp;gt;
        public AuthorizationPolicy Policy { get; }

        bool IFilterFactory.IsReusable =&amp;gt; true;

        // Computes the actual policy for this filter using either Policy or PolicyProvider + AuthorizeData
        private Task&amp;lt;AuthorizationPolicy&amp;gt; ComputePolicyAsync()
        {
            if (Policy != null)
            {
                return Task.FromResult(Policy);
            }

            if (PolicyProvider == null)
            {
                throw new InvalidOperationException(
                    Resources.FormatAuthorizeFilter_AuthorizationPolicyCannotBeCreated(
                        nameof(AuthorizationPolicy),
                        nameof(IAuthorizationPolicyProvider)));
            }

            return AuthorizationPolicy.CombineAsync(PolicyProvider, AuthorizeData);
        }

        internal async Task&amp;lt;AuthorizationPolicy&amp;gt; GetEffectivePolicyAsync(AuthorizationFilterContext context)
        {
            // Combine all authorize filters into single effective policy that's only run on the closest filter
            var builder = new AuthorizationPolicyBuilder(await ComputePolicyAsync());
            for (var i = 0; i &amp;lt; context.Filters.Count; i++)
            {
                if (ReferenceEquals(this, context.Filters[i]))
                {
                    continue;
                }

                if (context.Filters[i] is AuthorizeFilter authorizeFilter)
                {
                    // Combine using the explicit policy, or the dynamic policy provider
                    builder.Combine(await authorizeFilter.ComputePolicyAsync());
                }
            }

            var endpoint = context.HttpContext.GetEndpoint();
            if (endpoint != null)
            {
                // When doing endpoint routing, MVC does not create filters for any authorization specific metadata i.e [Authorize] does not
                // get translated into AuthorizeFilter. Consequently, there are some rough edges when an application uses a mix of AuthorizeFilter
                // explicilty configured by the user (e.g. global auth filter), and uses endpoint metadata.
                // To keep the behavior of AuthFilter identical to pre-endpoint routing, we will gather auth data from endpoint metadata
                // and produce a policy using this. This would mean we would have effectively run some auth twice, but it maintains compat.
                var policyProvider = PolicyProvider ?? context.HttpContext.RequestServices.GetRequiredService&amp;lt;IAuthorizationPolicyProvider&amp;gt;();
                var endpointAuthorizeData = endpoint.Metadata.GetOrderedMetadata&amp;lt;IAuthorizeData&amp;gt;() ?? Array.Empty&amp;lt;IAuthorizeData&amp;gt;();

                var endpointPolicy = await AuthorizationPolicy.CombineAsync(policyProvider, endpointAuthorizeData);
                if (endpointPolicy != null)
                {
                    builder.Combine(endpointPolicy);
                }
            }

            return builder.Build();
        }

        /// &amp;lt;inheritdoc /&amp;gt;
        public virtual async Task OnAuthorizationAsync(AuthorizationFilterContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            if (!context.IsEffectivePolicy(this))
            {
                return;
            }

            // IMPORTANT: Changes to authorization logic should be mirrored in security's AuthorizationMiddleware
            var effectivePolicy = await GetEffectivePolicyAsync(context);
            if (effectivePolicy == null)
            {
                return;
            }

            var policyEvaluator = context.HttpContext.RequestServices.GetRequiredService&amp;lt;IPolicyEvaluator&amp;gt;();

            var authenticateResult = await policyEvaluator.AuthenticateAsync(effectivePolicy, context.HttpContext);

            // Allow Anonymous skips all authorization
            if (HasAllowAnonymous(context))
            {
                return;
            }

            var authorizeResult = await policyEvaluator.AuthorizeAsync(effectivePolicy, authenticateResult, context.HttpContext, context);

            if (authorizeResult.Challenged)
            {
                context.Result = new ChallengeResult(effectivePolicy.AuthenticationSchemes.ToArray());
            }
            else if (authorizeResult.Forbidden)
            {
                context.Result = new ForbidResult(effectivePolicy.AuthenticationSchemes.ToArray());
            }
        }

        IFilterMetadata IFilterFactory.CreateInstance(IServiceProvider serviceProvider)
        {
            if (Policy != null || PolicyProvider != null)
            {
                // The filter is fully constructed. Use the current instance to authorize.
                return this;
            }

            Debug.Assert(AuthorizeData != null);
            var policyProvider = serviceProvider.GetRequiredService&amp;lt;IAuthorizationPolicyProvider&amp;gt;();
            return AuthorizationApplicationModelProvider.GetFilter(policyProvider, AuthorizeData);
        }

        private static bool HasAllowAnonymous(AuthorizationFilterContext context)
        {
            var filters = context.Filters;
            for (var i = 0; i &amp;lt; filters.Count; i++)
            {
                if (filters[i] is IAllowAnonymousFilter)
                {
                    return true;
                }
            }

            // When doing endpoint routing, MVC does not add AllowAnonymousFilters for AllowAnonymousAttributes that
            // were discovered on controllers and actions. To maintain compat with 2.x,
            // we'll check for the presence of IAllowAnonymous in endpoint metadata.
            var endpoint = context.HttpContext.GetEndpoint();
            if (endpoint?.Metadata?.GetMetadata&amp;lt;IAllowAnonymous&amp;gt;() != null)
            {
                return true;
            }

            return false;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中继承了 &lt;code&gt;IAsyncAuthorizationFilter&lt;/code&gt;, &lt;code&gt;IFilterFactory&lt;/code&gt;两个抽象接口，分别来看看这两个抽象接口的源代码&lt;/p&gt;
&lt;h5 id=&quot;iasyncauthorizationfilter源代码如下：&quot;&gt;&lt;code&gt;IAsyncAuthorizationFilter&lt;/code&gt;源代码如下：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// A filter that asynchronously confirms request authorization.
/// &amp;lt;/summary&amp;gt;
public interface IAsyncAuthorizationFilter : IFilterMetadata
{
    ///定义了授权的方法
    Task OnAuthorizationAsync(AuthorizationFilterContext context);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IAsyncAuthorizationFilter&lt;/code&gt;代码中继承了&lt;code&gt;IFilterMetadata&lt;/code&gt;接口，同时定义了&lt;code&gt;OnAuthorizationAsync&lt;/code&gt;抽象方法,子类需要实现该方法，然而&lt;code&gt;AuthorizeFilter&lt;/code&gt;中也已经实现了该方法，稍后再来详细讲解该方法，我们再继续看看&lt;code&gt;IFilterFactory&lt;/code&gt;抽象接口,代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IFilterFactory : IFilterMetadata
 {
       
    bool IsReusable { get; }

    //创建IFilterMetadata 对象方法
    IFilterMetadata CreateInstance(IServiceProvider serviceProvider);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们回到&lt;code&gt;AuthorizeFilter&lt;/code&gt; 源代码中，该源代码中提供了四个构造初始化方法同时包含了&lt;code&gt;AuthorizeData&lt;/code&gt;、&lt;code&gt;Policy&lt;/code&gt;属性，我们看看它的默认构造方法代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AuthorizeFilter : IAsyncAuthorizationFilter, IFilterFactory
{
        public IEnumerable&amp;lt;IAuthorizeData&amp;gt; AuthorizeData { get; }

        //默认构造函数中默认创建了AuthorizeAttribute 对象
        public AuthorizeFilter()
            : this(authorizeData: new[] { new AuthorizeAttribute() })
        {
        }

        //赋值AuthorizeData
        public AuthorizeFilter(IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)
        {
            if (authorizeData == null)
            {
                throw new ArgumentNullException(nameof(authorizeData));
            }

            AuthorizeData = authorizeData;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中默认的构造函数默认给构建了一个&lt;code&gt;AuthorizeAttribute&lt;/code&gt;对象，并且赋值给了&lt;code&gt;IEnumerable&amp;lt;IAuthorizeData&amp;gt;&lt;/code&gt;的集合属性;&lt;br/&gt;好了，看到这里&lt;code&gt;AuthorizeFilter&lt;/code&gt;过滤器也是默认构造了一个&lt;code&gt;AuthorizeAttribute&lt;/code&gt;的对象，也就是构造了授权所需要的&lt;code&gt;IAuthorizeData&lt;/code&gt;信息.&lt;br/&gt;同时&lt;code&gt;AuthorizeFilter&lt;/code&gt;实现的&lt;code&gt;OnAuthorizationAsync&lt;/code&gt;方法中通过&lt;code&gt;GetEffectivePolicyAsync&lt;/code&gt;这个方法获得有效的授权策略，并且进行下面的授权&lt;code&gt;AuthenticateAsync&lt;/code&gt;的执行&lt;br/&gt;&lt;code&gt;AuthorizeFilter&lt;/code&gt;代码中提供了&lt;code&gt;HasAllowAnonymous&lt;/code&gt;方法来实现是否&lt;code&gt;Controller&lt;/code&gt;或者&lt;code&gt;Action&lt;/code&gt;上标注了&lt;code&gt;AllowAnonymous&lt;/code&gt;特性，用于跳过授权&lt;br/&gt;&lt;code&gt;HasAllowAnonymous&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static bool HasAllowAnonymous(AuthorizationFilterContext context)
{
     var filters = context.Filters;
     for (var i = 0; i &amp;lt; filters.Count; i++)
     {
        if (filters[i] is IAllowAnonymousFilter)
        {
           return true;
        }
     }
     //同样通过上下文的endpoint 来获取是否标注了AllowAnonymous特性
     var endpoint = context.HttpContext.GetEndpoint();
     if (endpoint?.Metadata?.GetMetadata&amp;lt;IAllowAnonymous&amp;gt;() != null)
     {
        return true;
     }

     return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里我们再回到全局添加过滤器的方式代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; services.AddControllers(options=&amp;gt;options.Filters.Add(new AuthorizeFilter()));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析到这里 ，我很是好奇，它是怎么全局添加进去的呢？我打开源代码看了下，源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MvcOptions : IEnumerable&amp;lt;ICompatibilitySwitch&amp;gt;
{

        public MvcOptions()
        {
            CacheProfiles = new Dictionary&amp;lt;string, CacheProfile&amp;gt;(StringComparer.OrdinalIgnoreCase);
            Conventions = new List&amp;lt;IApplicationModelConvention&amp;gt;();
            Filters = new FilterCollection();
            FormatterMappings = new FormatterMappings();
            InputFormatters = new FormatterCollection&amp;lt;IInputFormatter&amp;gt;();
            OutputFormatters = new FormatterCollection&amp;lt;IOutputFormatter&amp;gt;();
            ModelBinderProviders = new List&amp;lt;IModelBinderProvider&amp;gt;();
            ModelBindingMessageProvider = new DefaultModelBindingMessageProvider();
            ModelMetadataDetailsProviders = new List&amp;lt;IMetadataDetailsProvider&amp;gt;();
            ModelValidatorProviders = new List&amp;lt;IModelValidatorProvider&amp;gt;();
            ValueProviderFactories = new List&amp;lt;IValueProviderFactory&amp;gt;();
        }

        //过滤器集合
        public FilterCollection Filters { get; }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;FilterCollection&lt;/code&gt;相关核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FilterCollection : Collection&amp;lt;IFilterMetadata&amp;gt;
{
        
        public IFilterMetadata Add&amp;lt;TFilterType&amp;gt;() where TFilterType : IFilterMetadata
        {
            return Add(typeof(TFilterType));
        }

        //其他核心代码为贴出来
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中提供了&lt;code&gt;Add&lt;/code&gt;方法，约束了&lt;code&gt;IFilterMetadata&lt;/code&gt;类型的对象，这也是上面的过滤器中为什么都继承了&lt;code&gt;IFilterMetadata&lt;/code&gt;的原因。&lt;br/&gt;到这里代码解读和实现原理已经分析完了，如果有分析不到位之处还请多多指教！！！&lt;/p&gt;
&lt;p&gt;结论：授权中间件通过获取&lt;code&gt;IAuthorizeData&lt;/code&gt;来获取&lt;code&gt;AuthorizeAttribute&lt;/code&gt;对象相关的授权信息，并构造&lt;code&gt;授权策略&lt;/code&gt;对象进行授权认证的，而&lt;code&gt;AuthorizeFilter&lt;/code&gt;过滤器也会默认添加&lt;code&gt;AuthorizeAttribute&lt;/code&gt;的授权相关数据&lt;code&gt;IAuthorizeData&lt;/code&gt;并实现&lt;code&gt;OnAuthorizationAsync&lt;/code&gt;方法，同时中间件中通过授权策略提供者&lt;code&gt;IAuthorizationPolicyProvider&lt;/code&gt;来获得对于的授权策略进行授权认证.&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 23:08:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>AuthorizeAttribute 和AuthorizeFilter是怎么样的一个关系？他们跟中间件又是怎样协同工作的？本文一起来探索Asp.Net Core 3.x 的源代码，深入解读他们的关系和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12544205.html</dc:identifier>
</item>
<item>
<title>线程数，射多少更舒适？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/12563640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/12563640.html</guid>
<description>&lt;p&gt;我相信大家都用过线程池，但是线程池数量设置为多少比较合理呢？&lt;/p&gt;
&lt;p&gt;线程数的设置的最主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能，因此让我们一起去探索吧！&lt;/p&gt;
&lt;p&gt;首先要考虑到 CPU 核心数，那么在 Java 中如何获取核心线程数？&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;Runtime.getRuntime().availableProcessor()&lt;/code&gt; 方法来获取（可能不准确，作为参考）&lt;/p&gt;
&lt;p&gt;在确认了核心数后，再去判断是 CPU 密集型任务还是 IO 密集型任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 密集型任务：比如像加解密，压缩、计算等一系列需要大量耗费 CPU 资源的任务，&lt;strong&gt;大部分场景下都是纯 CPU 计算&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;IO 密集型任务：比如像 MySQL 数据库、文件的读写、网络通信等任务，这类任务&lt;strong&gt;不会特别消耗 CPU 资源，但是 IO 操作比较耗时，会占用比较多时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在知道如何判断任务的类别后，让我们分两个场景进行讨论：&lt;/p&gt;
&lt;h2 id=&quot;cpu-密集型任务&quot;&gt;CPU 密集型任务&lt;/h2&gt;
&lt;p&gt;对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 8 核的 CPU，每个核一个线程，理论上创建 8 个线程就可以了。&lt;/p&gt;
&lt;p&gt;如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍，因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。&lt;/p&gt;
&lt;p&gt;因此，对于 CPU 密集型的计算场景，理论上&lt;strong&gt;线程的数量 = CPU 核数&lt;/strong&gt;就是最合适的，不过通常把线程的数量设置为&lt;strong&gt;CPU 核数 +1&lt;/strong&gt;，会实现最优的利用率。即使当密集型的线程由于偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费，从而保证 CPU 的利用率。&lt;/p&gt;
&lt;p&gt;如下图就是在一个 8 核 CPU 的电脑上，通过修改线程数来测试对 CPU 密集型任务（素数计算）的性能影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032501592026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到线程数小于 8 时，性能是很差的，在线程数多于处理器核心数对性能的提升也很小，因此可以验证公式还是具有一定适用性的。&lt;/p&gt;
&lt;p&gt;除此之外，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。&lt;/p&gt;
&lt;h2 id=&quot;io-密集型任务&quot;&gt;IO 密集型任务&lt;/h2&gt;
&lt;p&gt;对于 IO 密集型任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。&lt;/p&gt;
&lt;p&gt;对于 IO 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 IO 操作的耗时比相关的，《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程数 = CPU 核心数 * (1 + IO 耗时/ CPU 耗时)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。可以采用 APM 工具统计到每个方法的耗时，便于计算 IO 耗时和 CPU 耗时。&lt;/p&gt;
&lt;p&gt;在这里引用Java并发编程实战中的图，方便大家更容易理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200325021549205.png&quot; alt=&quot;三线程执行示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一派的计算方式是《Java虚拟机并发编程》中提出的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程数 = CPU 核心数 / (1 - 阻塞系数)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中计算密集型阻塞系数为 0，IO 密集型阻塞系数接近 1，一般认为在 0.8 ~ 0.9 之间。比如 8 核 CPU，按照公式就是 2 / ( 1 - 0.9 ) = 20 个线程数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200325014855263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 IO 密集型任务的一个测试，是在双核处理器上开不同的线程数（从 1 到 40）来测试对程序性能的影响，可以看到线程池数量达到 20 之后，曲线逐渐水平，说明开再多的线程对程序的性能提升也毫无帮助。&lt;/p&gt;
&lt;p&gt;太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。&lt;/p&gt;
&lt;p&gt;同时，有很多线程池的应用，比如 Tomcat、Redis、Jdbc 等，每个应用设置的线程数也是不同的，比如 Tomcat 为流量入口，那么线程数的设置可能就要比其他应用要大。&lt;/p&gt;

&lt;p&gt;通过对线程数设置的探究，我们可以得知线程数的设置首先和 CPU 核心数有莫大关联，除此之外，我们需要根据任务类型的不同选择对应的策略，线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程；针对不同的程序，进行对应的实际测试就可以得到最合适的选择。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;《Java并发编程实战》&lt;/p&gt;
&lt;p&gt;《Java虚拟机并发编程》&lt;/p&gt;
&lt;p&gt;Java并发编程实战&lt;/p&gt;
&lt;p&gt;Java并发编程核心&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 24 Mar 2020 18:39:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>还在无脑使用“线程数 = 2 * 核心数 + 1”？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/12563640.html</dc:identifier>
</item>
<item>
<title>WEB应用之httpd基础入门（二） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12561236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12561236.html</guid>
<description>&lt;p&gt;　　前文我们聊了下httpd的一些基础设置，聊了下httpd的配置文件格式，长连接、mpm的配置以及访问控制基于文件路径和URL管控，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12551518.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12551518.html&lt;/a&gt;；今天我们继续来聊一聊余下的一些常用配置；&lt;/p&gt;
&lt;p&gt;　　1、定义路径别名:定义路径别名需要用到alias指令语法格式是alias /URL/ “PATH/TO/SOMEDIR/”;什么意思呢？通常情况用户访问/images/这个目录，对应文件系统路径应该是documentroot指令指定的路径下的images;如果使用了路径别名，用户访问/images这个URI就不一定是documentroot指令指定的路径下的images了；它相当于把文件系统上的一个路径映射成URL路径；该指令可以用在server配置块中，虚拟主机，和directory中；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324220554116-277897535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上示例表示把文件系统路径“/usr/local/apache/icons/” 映射成URL路径“/icons/”，同时明确授权允许所有人访问“/usr/local/apache/icons/”目录；也就是说用户访问/icons/目录就相当于访问文件系统路径“/usr/local/apache/icons/”目录；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324221811999-2081420922.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：这里需要注意一点的是如果我们映射的URL路径是以“/”结尾，那么对应文件系统路径也必须是“/”结尾，以上面的示例如果我们访问的URL是/icons将提示我们访问不到，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324222141282-845872410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：其实很好理解，上图的URL会去找documentroot指令指定的文件系统路径中找icons文件，如果能够找到就把对应文件内容响应给用户，如果是在documentroot指令指定的文件系统路径下icons是目录的话，我们访问/icons就会被/icons/匹配，从而访问到别名路径上去；因为我们访问目录默认会把目录下的文件给以索引的方式罗列出来，所以我们访问某个目录，其URL最后会填上一个“/”,这样一来就会被对应的别名路径匹配；&lt;/p&gt;
&lt;p&gt;　　2、设定默认字符集：AddDefaultCharset  charset   此指令表示添加默认字符集，可以用在server配置块中、虚拟主机、directory、和.htaccess中；默认是off的&lt;/p&gt;
&lt;p&gt;　　3、日志设定；web服务日志类型有两种类型，一种是访问日志，记录用户访问站点的日志，另一中类型就是错误日志，记录服务端程序出错等日志；&lt;/p&gt;
&lt;p&gt;　　errorlog：此指令表示定义错误日志存放路径及名称，该指令可以用在server配置段中，表示记录中心主机错误日志，同样也可以放在各虚拟主机中，表示记录各虚拟主机的错误日志；其语法格式为：errorlog file-path |syslog [:[facility] [:tag]]   ;从语法格式看我们就知道错误日志除了可以在本地指定文件来记录外还可以将其发送给syslog；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324230052150-620628099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示把错误日志存放在logs/error_log文件中，这里的相对路径是相对于serverroot指定的路径；&lt;/p&gt;
&lt;p&gt;　　loglevel ：此指令表示指定错误日志级别，我们知道日志是有级别的，这个指令的作用就是告诉服务器，什么级别或该级别以上的日志信息记录到错误日志中；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324230500017-289238459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上表示记录日志级别为warn以及以上级别的日志；&lt;/p&gt;
&lt;p&gt;　　访问日志：logformat：此指令表示指定访问日志格式，并给该格式取一名字，在后续的使用中可以通过customlog指令来调用该名字即可把访问日志格式记录成我们想要的格式；日志格式中有很多httpd内建的宏，每个宏都有不同的意义，我们定义访问日志格式也是通过组合这些宏来定义的；常见的宏以及对应的意思如下&lt;/p&gt;
&lt;p&gt;　　%h：客户端IP地址；&lt;/p&gt;
&lt;p&gt;　　%l：Remote User, 通常为一个减号（“-”）；该用户指identd方式认证的用户；&lt;/p&gt;
&lt;p&gt;　　%u：Remote user (from auth; may be bogus if return status (%s) is 401)；非为登录访问时，其为一个减号；该用户指authenticated认证的用户；&lt;/p&gt;
&lt;p&gt;　　%t：服务器收到请求时的时间；&lt;/p&gt;
&lt;p&gt;　　%r：First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本；&lt;/p&gt;
&lt;p&gt;　　%&amp;gt;s：响应状态码；记录最后一次响应状态码，如果没有&quot;&amp;gt;&quot;号就表示记录第一次状态码信息；如果在重定向中这种状态码就不是很准确了；&lt;/p&gt;
&lt;p&gt;　　%b：响应报文的大小，单位是字节；不包括响应报文的http首部；&lt;/p&gt;
&lt;p&gt;　　%{Referer}i：请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面的；&lt;/p&gt;
&lt;p&gt;　　%{User-Agent}i：请求报文中首部“User-Agent”的值；即发出请求的应用程序；&lt;/p&gt;
&lt;p&gt;更多宏指令说明，请参考官方文档&lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_log_config.html#logformat&quot; target=&quot;_blank&quot;&gt;http://httpd.apache.org/docs/2.4/mod/mod_log_config.html#logformat&lt;/a&gt;&lt;br/&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324232136187-1473549354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示定义了两个格式的日志格式，分别叫combined 和common&lt;/p&gt;
&lt;p&gt;　　customlog：此指令表示指定访问日志路径及名称以及日志格式名称&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324232352561-1572407315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示指定访问日志为logs/access_log，并且使用combined的格式记录访问日志；同样的这里的日志路径也是相对于serverroot指定的路径；我们定义的访问日志格式到底是什么样呢？如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200324232657885-733415490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　4、基于用户的访问控制&lt;/p&gt;
&lt;p&gt; 　　首先我们来了解下几个概念；&lt;/p&gt;
&lt;p&gt;　　认证质询：客户端访问服务端时，如果我们对客户端访问的资源提前配置了需要认证才可访问，这时客户端访问服务端对应资源时，服务端会向客户端响应一个状态码为401，响应首部叫www-authenticate，明确的拒绝客户端访问，并告诉客户端，访问此资源需要认证提供用户名和密码；这个过程叫认证质询，意思就是告诉客户端访问的资源需要提供用户名和密码；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325011248122-1271641972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　认证：当客户端收到服务端的认证质询响应后，此时浏览器上会有一个对话框，提示用户输入用户名和密码，用户把对应的用户名和密码输入到对话框中，点击确定，此时客户端的用户名和密码会通过authorization请求首部发送给服务端，服务端拿到客户端的用户名和密码，就会去比对客户端提供的用户名和密码是否正确，如果正确，则服务端把对应资源内容响应给客户端；这样的一个过程叫认证的过程，简单点说就是客户端提供用户名和密码，服务端进行验证是否正确，正确就响应对应资源内容，不正确就不响应；如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325011447195-2403439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安全域：所谓安全域就是用户访问的资源路径，我们需要明确的通过名称对其进行表示，以便明确告知用户认证的原因；&lt;/p&gt;
&lt;p&gt;　　了解了以上三个概念，我们不难理解，要想认证，首先得需要要用户名和密码，这个用户名和密码怎么存放？我们知道登录Linux系统时会提示我们输入用户名和密码，登录成功后我们就可以正常的输入命令操作Linux系统了，在Linux里我们把登录系统的用户名和密码信息存放在/etc/passwd和/etc/shadow文件中；但httpd认证的账号和密码怎么存放的呢？其实存放账号密码的工具有很多，我们可以存放在数据库中，也可以借鉴Linux系统账号密码的存放方式，把用户名和密码存放在文件中，只不过存放在数据库中，我们还需要考虑httpd怎么去数据库找对应的用户名和密码；通常情况下我们在登录某宝的网站，也是需要账号和密码的，这里的账号和密码不是通过这种方式验证的，像我们说的认证质询是http协议内部实现的访问控制机制，我们在登录某宝网站提供的用户名和密码认证的方式和这里说的认证不是一回事；通常情况下如果账号和密码的数量比较大时，我们通常会把账号密码信息存放在数据库里；如果用户名和密码的数量极少，我们用数据库存放账号和密码就显得不那么高效了；&lt;/p&gt;
&lt;p&gt;　　在httpd程序中，提供了一个工具就可以用来创建存放用户名和密码的文件的工具，它叫htpasswd；我们来了解下它的使用法吧；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test_node1-centos7 conf]# htpasswd --help
Usage:
        htpasswd [-cimBdpsDv] [-C cost] passwordfile username
        htpasswd -b[cmBdpsDv] [-C cost] passwordfile username password

        htpasswd -n[imBdps] [-C cost] username
        htpasswd -nb[mBdps] [-C cost] username password
 -c  Create a new file.
 -n  Don't update file; display results on stdout.
 -b  Use the password from the command line rather than prompting for it.
 -i  Read password from stdin without verification (for script usage).
 -m  Force MD5 encryption of the password (default).
 -B  Force bcrypt encryption of the password (very secure).
 -C  Set the computing time used for the bcrypt algorithm
     (higher is more secure but slower, default: 5, valid: 4 to 31).
 -d  Force CRYPT encryption of the password (8 chars max, insecure).
 -s  Force SHA encryption of the password (insecure).
 -p  Do not encrypt the password (plaintext, insecure).
 -D  Delete the specified user.
 -v  Verify password for the specified user.
On other systems than Windows and NetWare the '-p' flag will probably not work.
The SHA algorithm does not use a salt and is less secure than the MD5 algorithm.
[root@test_node1-centos7 conf]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：-c表示第一次创建存放用户名和密码的文件，-m表示使用md5方式加密存放密码（默认加密方式），-s表示使用sha方式加密密码，-B表示强制使用bcrypt方式加密密码，-p表示不加密密码，明文存放；-D表示删除一个用户和密码；-b表示使用模式，直接在命令行指定用户名和密码，直接创建，不需要手动输入密码；-i表示从标准输入获取密码通常用于脚本中；&lt;/p&gt;
&lt;p&gt;　　了解了htpasswd工具的选项后，我们再来说说认证方式，在httpd中基于用户的认证有两种，basic明文认证和digest消息摘要认证，通常basic认证是不安全的，很容易泄露用户名和密码，但是digest认证相对是比较安全的，但是需要客户端支持才行；了解了以上httpd的认证过程后，我们来看看httpd是怎么配置认证的；&lt;/p&gt;
&lt;p&gt;　　authtype：此指令表示指定认证类型；&lt;/p&gt;
&lt;p&gt;　　authname “string”：此指令表示告诉用户为什么认证，通常用于提示用户输入用户名和密码；&lt;/p&gt;
&lt;p&gt;　　authuserfile：指定存放用户名和密码的文件路径已经文件名称；&lt;/p&gt;
&lt;p&gt;　　require user：指定允许认证的用户，没有被指定的用户是不能够被认证的，即便authuserfile文件中存放的有对应用户名和密码；&lt;/p&gt;
&lt;p&gt;以上指令只能用于directory或.htaccess中使用，通常用于定义安全域；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　创建虚拟用户用于httpdbasic认证&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test_node1-centos7 conf]# htpasswd -c /etc/httpd/conf.d/.htpasswd tom
New password: 
Re-type new password: 
Adding password for user tom
[root@test_node1-centos7 conf]# htpasswd  /etc/httpd/conf.d/.htpasswd jerry
New password: 
Re-type new password: 
Adding password for user jerry
[root@test_node1-centos7 conf]# cat /etc/httpd/conf.d/.htpasswd 
tom:$apr1$xLIN6FgB$tQbKDzRRMyx/ahUGHhtN10
jerry:$apr1$5gjGaRfC$hK0MOgR6/dYpU5HBDH1nC/
[root@test_node1-centos7 conf]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们创建了/etc/httpd/conf.d/.htpasswd文件来存放用户名和密码；并创建了两个虚拟用户tom和jerry&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325004413222-1567017375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示用户访问根路径需要用户认证，认证用户是tom，认证类型是basic&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325004911394-1660536735.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到我们用tom用户数可以正常登录的，我们用jerry用户是否可以登录呢？如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325005742901-1024862562.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到没有写在require user 里的用户是不能登录的，即便是authuserfile里有的用户名和密码；&lt;/p&gt;
&lt;p&gt; 　　require valid-user：此指令表示允许authuserfile中的所有用户登录访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325010116040-366927312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示允许/etc/httpd/conf.d/.htpasswd文件中的所有用户可以登录访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325010932180-1276626309.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到authuserfile里的用户都可以登录访问&lt;/p&gt;
&lt;p&gt;以上是基于用户帐号进行认证的配置实例演示，接下来我们在来说说基于组账号认证&lt;/p&gt;
&lt;p&gt;　　authgroupfile：此指令表示指定组文件，这个文件的格式是组名：用户名1 用户名2……&lt;/p&gt;
&lt;p&gt;　　require group ：此指令表示指定允许认证的组名&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　首先创建一个authguoupfile&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test_node1-centos7 conf.d]# htpasswd /etc/httpd/conf.d/.htpasswd xiaoming
New password: 
Re-type new password: 
Adding password for user xiaoming
[root@test_node1-centos7 conf.d]# htpasswd /etc/httpd/conf.d/.htpasswd xiaohong
New password: 
Re-type new password: 
Adding password for user xiaohong
[root@test_node1-centos7 conf.d]# cat /etc/httpd/conf.d/.htpasswd 
tom:$apr1$xLIN6FgB$tQbKDzRRMyx/ahUGHhtN10
jerry:$apr1$5gjGaRfC$hK0MOgR6/dYpU5HBDH1nC/
xiaoming:$apr1$xA1lDL.b$frhycSz3Ainlm4kktPn5A1
xiaohong:$apr1$HhAZCYJE$C/75gZ0k9x/5cw47Udooz1
[root@test_node1-centos7 conf.d]# cat &amp;gt; /etc/httpd/conf.d/.htgroup &amp;lt;&amp;lt;EOF
&amp;gt; group1:xiaohong xiaoming
&amp;gt; group2:tom jerry
&amp;gt; EOF
[root@test_node1-centos7 conf.d]# cat /etc/httpd/conf.d/.htgroup 
group1:xiaohong xiaoming
group2:tom jerry
[root@test_node1-centos7 conf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上新增了两个用户小明和小红，然后在/etc/httpd/conf.d/创建了一个authgroupfile 名为.htgroup，并在组文件中明确定义了两个组group1里面有两个成员xiaoming和xiaohong ;group2中定义了两个成员tom和jerry，接下来我们配置只允许group1里的用户访问；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325013410809-2047580695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置表示group1组里的成员允许认证访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325013501044-1655179058.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到group1里的xiaoming和xiaohong用户都是可以正常的认证访问；那么对应的group2里的成员是否可以访问呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200325014358098-2094182820.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到没有被允许的组成员是不能够认证访问的&lt;/p&gt;
</description>
<pubDate>Tue, 24 Mar 2020 17:57:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下httpd的一些基础设置，聊了下httpd的配置文件格式，长连接、mpm的配置以及访问控制基于文件路径和URL管控，回顾请参考https://www.cnblogs.com/qiuhom</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12561236.html</dc:identifier>
</item>
<item>
<title>AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth - holdengong</title>
<link>http://www.cnblogs.com/holdengong/p/12563558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holdengong/p/12563558.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;title-aspnetcore31_secutiry源码解析_5_authentication_oauthdate-2020-03-24t2327450800draft-false&quot;&gt;title: &quot;AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth&quot;&lt;br/&gt;date: 2020-03-24T23:27:45+08:00&lt;br/&gt;draft: false&lt;/h2&gt;


&lt;p&gt;现在随便一个网站，不用注册，只用微信扫一扫，然后就可以自动登录，然后第三方网站右上角还出现了你的微信头像和昵称，怎么做到的？&lt;/p&gt;
&lt;p&gt;sequenceDiagram 用户-&amp;gt;&amp;gt;x站点: 请求微信登录 x站点-&amp;gt;&amp;gt;微信: 请求 oauth token 微信-&amp;gt;&amp;gt;用户: x站点请求基本资料权限,是否同意? 用户-&amp;gt;&amp;gt;微信: 同意 微信-&amp;gt;&amp;gt;x站点: token x站点-&amp;gt;&amp;gt;微信: 请求user基本资料(token) 微信-&amp;gt;微信: 校验token 微信-&amp;gt;&amp;gt;x站点: user基本资料&lt;/p&gt;
&lt;p&gt;大概就这么个意思，OAuth可以让第三方获取有限的授权去获取资源。&lt;/p&gt;
&lt;p&gt;入门的看博客&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linianhui/p/oauth2-authorization.html&quot;&gt;https://www.cnblogs.com/linianhui/p/oauth2-authorization.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;英文好有基础的直接看协议&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;https://tools.ietf.org/html/rfc6749&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置类：OAuthOptions&lt;br/&gt;处理器类： OAuthHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static class OAuthExtensions
{
    public static AuthenticationBuilder AddOAuth(this AuthenticationBuilder builder, string authenticationScheme, Action&amp;lt;OAuthOptions&amp;gt; configureOptions)
        =&amp;gt; builder.AddOAuth&amp;lt;OAuthOptions, OAuthHandler&amp;lt;OAuthOptions&amp;gt;&amp;gt;(authenticationScheme, configureOptions);

    public static AuthenticationBuilder AddOAuth(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&amp;lt;OAuthOptions&amp;gt; configureOptions)
        =&amp;gt; builder.AddOAuth&amp;lt;OAuthOptions, OAuthHandler&amp;lt;OAuthOptions&amp;gt;&amp;gt;(authenticationScheme, displayName, configureOptions);

    public static AuthenticationBuilder AddOAuth&amp;lt;TOptions, THandler&amp;gt;(this AuthenticationBuilder builder, string authenticationScheme, Action&amp;lt;TOptions&amp;gt; configureOptions)
        where TOptions : OAuthOptions, new()
        where THandler : OAuthHandler&amp;lt;TOptions&amp;gt;
        =&amp;gt; builder.AddOAuth&amp;lt;TOptions, THandler&amp;gt;(authenticationScheme, OAuthDefaults.DisplayName, configureOptions);

    public static AuthenticationBuilder AddOAuth&amp;lt;TOptions, THandler&amp;gt;(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&amp;lt;TOptions&amp;gt; configureOptions)
        where TOptions : OAuthOptions, new()
        where THandler : OAuthHandler&amp;lt;TOptions&amp;gt;
    {
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;, OAuthPostConfigureOptions&amp;lt;TOptions, THandler&amp;gt;&amp;gt;());
        return builder.AddRemoteScheme&amp;lt;TOptions, THandler&amp;gt;(authenticationScheme, displayName, configureOptions);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;oauthoptions---配置类&quot;&gt;OAuthOptions - 配置类&lt;/h2&gt;
&lt;p&gt;classDiagram class OAuthOptions{ ClientId ClientSecret AuthorizationEndpoint TokenEndPoint UserInformationEndPoint Scope Events ClaimActions StateDataFormat } class RemoteAuthenticationOptions{ BackchannelTimeout BackchannelHttpHandler Backchannel DataProtectionProvider CallbackPath AccessDeniedPath ReturnUrlParameter SignInScheme RemoteAuthenticationTimeout SaveTokens } class AuthenticationSchemeOptions{ } OAuthOptions--&amp;gt;RemoteAuthenticationOptions RemoteAuthenticationOptions--&amp;gt;AuthenticationSchemeOptions&lt;/p&gt;
&lt;p&gt;下面是校验逻辑，这些配置是必需的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public override void Validate()
{
    base.Validate();

    if (string.IsNullOrEmpty(ClientId))
    {
        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(ClientId)), nameof(ClientId));
    }

    if (string.IsNullOrEmpty(ClientSecret))
    {
        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(ClientSecret)), nameof(ClientSecret));
    }

    if (string.IsNullOrEmpty(AuthorizationEndpoint))
    {
        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(AuthorizationEndpoint)), nameof(AuthorizationEndpoint));
    }

    if (string.IsNullOrEmpty(TokenEndpoint))
    {
        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(TokenEndpoint)), nameof(TokenEndpoint));
    }

    if (!CallbackPath.HasValue)
    {
        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exception_OptionMustBeProvided, nameof(CallbackPath)), nameof(CallbackPath));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;oauthpostconfigureoptions---配置处理&quot;&gt;OAuthPostConfigureOptions - 配置处理&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;DataProtectionProvider没有配置的话则使用默认实现&lt;/li&gt;
&lt;li&gt;Backchannel没有配置的话则处理构造默认配置&lt;/li&gt;
&lt;li&gt;StateDataFormat没有配置的话则使用PropertiesDataFormat&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void PostConfigure(string name, TOptions options)
{
    options.DataProtectionProvider = options.DataProtectionProvider ?? _dp;
    if (options.Backchannel == null)
    {
        options.Backchannel = new HttpClient(options.BackchannelHttpHandler ?? new HttpClientHandler());
        options.Backchannel.DefaultRequestHeaders.UserAgent.ParseAdd(&quot;Microsoft ASP.NET Core OAuth handler&quot;);
        options.Backchannel.Timeout = options.BackchannelTimeout;
        options.Backchannel.MaxResponseContentBufferSize = 1024 * 1024 * 10; // 10 MB
    }

    if (options.StateDataFormat == null)
    {
        var dataProtector = options.DataProtectionProvider.CreateProtector(
            typeof(THandler).FullName, name, &quot;v1&quot;);
        options.StateDataFormat = new PropertiesDataFormat(dataProtector);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个StateDataFormat就是处理state字段的加密解密的，state在认证过程中用于防止跨站伪造攻击和存放一些状态信息，我们看一下协议的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; state
         RECOMMENDED.  An opaque value used by the client to maintain
         state between the request and callback.  The authorization
         server includes this value when redirecting the user-agent back
         to the client.  The parameter SHOULD be used for preventing
         cross-site request forgery as described in Section 10.12.

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如，认证之后的回跳地址就是存放在这里。所以如果希望从state字段中解密得到信息的话，就需要使用到PropertiesDataFormat。PropertiesDataFormat没有任何代码，继承自SecureDataFormat。 为什么这里介绍这么多呢，因为实际项目中用到过这个。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SecureDataFormat&amp;lt;TData&amp;gt; : ISecureDataFormat&amp;lt;TData&amp;gt;
{
    private readonly IDataSerializer&amp;lt;TData&amp;gt; _serializer;
    private readonly IDataProtector _protector;

    public SecureDataFormat(IDataSerializer&amp;lt;TData&amp;gt; serializer, IDataProtector protector)
    {
        _serializer = serializer;
        _protector = protector;
    }

    public string Protect(TData data)
    {
        return Protect(data, purpose: null);
    }

    public string Protect(TData data, string purpose)
    {
        var userData = _serializer.Serialize(data);

        var protector = _protector;
        if (!string.IsNullOrEmpty(purpose))
        {
            protector = protector.CreateProtector(purpose);
        }

        var protectedData = protector.Protect(userData);
        return Base64UrlTextEncoder.Encode(protectedData);
    }

    public TData Unprotect(string protectedText)
    {
        return Unprotect(protectedText, purpose: null);
    }

    public TData Unprotect(string protectedText, string purpose)
    {
        try
        {
            if (protectedText == null)
            {
                return default(TData);
            }

            var protectedData = Base64UrlTextEncoder.Decode(protectedText);
            if (protectedData == null)
            {
                return default(TData);
            }

            var protector = _protector;
            if (!string.IsNullOrEmpty(purpose))
            {
                protector = protector.CreateProtector(purpose);
            }

            var userData = protector.Unprotect(protectedData);
            if (userData == null)
            {
                return default(TData);
            }

            return _serializer.Deserialize(userData);
        }
        catch
        {
            // TODO trace exception, but do not leak other information
            return default(TData);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AddRemoteSchema和AddShema的差别就是做了下面的处理，确认始终有不是远程schema的SignInSchema&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private class EnsureSignInScheme&amp;lt;TOptions&amp;gt; : IPostConfigureOptions&amp;lt;TOptions&amp;gt; where TOptions : RemoteAuthenticationOptions
{
    private readonly AuthenticationOptions _authOptions;

    public EnsureSignInScheme(IOptions&amp;lt;AuthenticationOptions&amp;gt; authOptions)
    {
        _authOptions = authOptions.Value;
    }

    public void PostConfigure(string name, TOptions options)
    {
        options.SignInScheme = options.SignInScheme ?? _authOptions.DefaultSignInScheme ?? _authOptions.DefaultScheme;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;解密state&lt;/li&gt;
&lt;li&gt;校验CorrelationId，防跨站伪造攻击&lt;/li&gt;
&lt;li&gt;如果error不为空说明失败返回错误&lt;/li&gt;
&lt;li&gt;拿到授权码code，换取token&lt;/li&gt;
&lt;li&gt;如果SaveTokens设置为true，将access_token,refresh_token,token_type存放到properties中&lt;/li&gt;
&lt;li&gt;创建凭据，返回成功&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;  protected override async Task&amp;lt;HandleRequestResult&amp;gt; HandleRemoteAuthenticateAsync()
        {
            var query = Request.Query;

            var state = query[&quot;state&quot;];
            var properties = Options.StateDataFormat.Unprotect(state);

            if (properties == null)
            {
                return HandleRequestResult.Fail(&quot;The oauth state was missing or invalid.&quot;);
            }

            // OAuth2 10.12 CSRF
            if (!ValidateCorrelationId(properties))
            {
                return HandleRequestResult.Fail(&quot;Correlation failed.&quot;, properties);
            }

            var error = query[&quot;error&quot;];
            if (!StringValues.IsNullOrEmpty(error))
            {
                // Note: access_denied errors are special protocol errors indicating the user didn't
                // approve the authorization demand requested by the remote authorization server.
                // Since it's a frequent scenario (that is not caused by incorrect configuration),
                // denied errors are handled differently using HandleAccessDeniedErrorAsync().
                // Visit https://tools.ietf.org/html/rfc6749#section-4.1.2.1 for more information.
                if (StringValues.Equals(error, &quot;access_denied&quot;))
                {
                    return await HandleAccessDeniedErrorAsync(properties);
                }

                var failureMessage = new StringBuilder();
                failureMessage.Append(error);
                var errorDescription = query[&quot;error_description&quot;];
                if (!StringValues.IsNullOrEmpty(errorDescription))
                {
                    failureMessage.Append(&quot;;Description=&quot;).Append(errorDescription);
                }
                var errorUri = query[&quot;error_uri&quot;];
                if (!StringValues.IsNullOrEmpty(errorUri))
                {
                    failureMessage.Append(&quot;;Uri=&quot;).Append(errorUri);
                }

                return HandleRequestResult.Fail(failureMessage.ToString(), properties);
            }

            var code = query[&quot;code&quot;];

            if (StringValues.IsNullOrEmpty(code))
            {
                return HandleRequestResult.Fail(&quot;Code was not found.&quot;, properties);
            }

            var tokens = await ExchangeCodeAsync(code, BuildRedirectUri(Options.CallbackPath));

            if (tokens.Error != null)
            {
                return HandleRequestResult.Fail(tokens.Error, properties);
            }

            if (string.IsNullOrEmpty(tokens.AccessToken))
            {
                return HandleRequestResult.Fail(&quot;Failed to retrieve access token.&quot;, properties);
            }

            var identity = new ClaimsIdentity(ClaimsIssuer);

            if (Options.SaveTokens)
            {
                var authTokens = new List&amp;lt;AuthenticationToken&amp;gt;();

                authTokens.Add(new AuthenticationToken { Name = &quot;access_token&quot;, Value = tokens.AccessToken });
                if (!string.IsNullOrEmpty(tokens.RefreshToken))
                {
                    authTokens.Add(new AuthenticationToken { Name = &quot;refresh_token&quot;, Value = tokens.RefreshToken });
                }

                if (!string.IsNullOrEmpty(tokens.TokenType))
                {
                    authTokens.Add(new AuthenticationToken { Name = &quot;token_type&quot;, Value = tokens.TokenType });
                }

                if (!string.IsNullOrEmpty(tokens.ExpiresIn))
                {
                    int value;
                    if (int.TryParse(tokens.ExpiresIn, NumberStyles.Integer, CultureInfo.InvariantCulture, out value))
                    {
                        // https://www.w3.org/TR/xmlschema-2/#dateTime
                        // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx
                        var expiresAt = Clock.UtcNow + TimeSpan.FromSeconds(value);
                        authTokens.Add(new AuthenticationToken
                        {
                            Name = &quot;expires_at&quot;,
                            Value = expiresAt.ToString(&quot;o&quot;, CultureInfo.InvariantCulture)
                        });
                    }
                }

                properties.StoreTokens(authTokens);
            }

            var ticket = await CreateTicketAsync(identity, properties, tokens);
            if (ticket != null)
            {
                return HandleRequestResult.Success(ticket);
            }
            else
            {
                return HandleRequestResult.Fail(&quot;Failed to retrieve user information from remote server.&quot;, properties);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 24 Mar 2020 17:08:00 +0000</pubDate>
<dc:creator>holdengong</dc:creator>
<og:description>title: &amp;quot;AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth&amp;quot; date: 2020 03 24T23:27:45+08:00</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/holdengong/p/12563558.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core - 在ActionFilter中使用依赖注入 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/di-in-core-actionfilter.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/di-in-core-actionfilter.html</guid>
<description>&lt;p&gt;上次[ActionFilter引发的一个EF异常](https://www.cnblogs.com/kklldog/p/not-use-sync-in-actionfilter.html),本质上是对Core版本的ActionFilter的知识掌握不够牢固造成的，所以花了点时间仔细阅读了微软的官方文档。发现除了IActionFilter、IAsyncActionFilter的问题，还有一个就是依赖注入在ActionFilter上的使用也是需要注意的地方。 当我们的ActionFilter需要使用某个Service的时候，我们一般会通过构造函数注入。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149.1229535583&quot;&gt;
&lt;p&gt;上次&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/not-use-sync-in-actionfilter.html&quot;&gt;ActionFilter引发的一个EF异常&lt;/a&gt;,本质上是对Core版本的ActionFilter的知识掌握不够牢固造成的，所以花了点时间仔细阅读了微软的官方文档。发现除了IActionFilter、IAsyncActionFilter的问题，还有一个就是依赖注入在ActionFilter上的使用也是需要注意的地方。&lt;br/&gt;当我们的ActionFilter需要使用某个Service的时候，我们一般会通过构造函数注入。&lt;br/&gt;演示一下，首先自定义一个ActionFilter，通过构造函数注入IMyService：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public interface IMyService
    {
        string GetServiceName(); 
    }

    public class MyService : IMyService
    {
        public MyService ()
        {
            Console.WriteLine(&quot;Service {0} created .&quot;, GetServiceName());
        }

        public string GetServiceName()
        {
            return &quot;MyService&quot;;
        }
    }

    public class FilterInjectAttribute: ActionFilterAttribute
    {
        public FilterInjectAttribute(IMyService myService)
        {
            if (myService == null)
            {
                throw new ArgumentNullException(&quot;myService&quot;);
            }

            Console.WriteLine(&quot;Service {0} was injected .&quot;, myService.GetServiceName());
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们在使用Attribute的时候VS直接给出红色提示，需要传入构造函数的参数，否则无法编译过去。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/24/8HOaFA.md.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;当然我们可以直接new一个MyService来当做参数，但是很显然这样就失去了注入的那些好处了。&lt;/p&gt;
&lt;h2 id=&quot;在actionfilter中使用依赖注入&quot;&gt;在ActionFilter中使用依赖注入&lt;/h2&gt;
&lt;p&gt;在ASP.NET Core的ActionFilter中使用依赖注入主要有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ServiceFilterAttribute&lt;/li&gt;
&lt;li&gt;TypeFilterAttribute&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;servicefilterattribute&quot;&gt;ServiceFilterAttribute&lt;/h3&gt;
&lt;p&gt;使用ServiceFilterAttribute可以使你的ActionFilter完成依赖注入。其实就是把你要用的ActionFilter本身注册为一个Service注册到DI容器中。通过ServiceFilter从容器中检索你的ActionFilter，并且注入到需要的地方。所以第一步就是要注册你的ActionFilter:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddScoped&amp;lt;IMyService,MyService&amp;gt;();
            services.AddScoped(typeof(FilterInjectAttribute));

            services.AddControllers();
            services.AddRazorPages();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后新建一个Controller，在Action上使用ServiceFilter：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [ServiceFilter(typeof(FilterInjectAttribute))]
        public string DI()
        {
            Console.WriteLine(&quot;HomeController method DI running .&quot;);

            return &quot;DI&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，在浏览器里访问下对应的path，可以看到MyService已经注入到FilterInjectAttribute中：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/24/8HOsOS.md.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;servicefilterattribute的isreusable属性&quot;&gt;ServiceFilterAttribute的IsReusable属性:&lt;/h4&gt;
&lt;p&gt;ServiceFilter有一个属性叫IsReusable。从字面意思也很好理解，就是是否可重用的意思。显而易见如果这个属性设置为True，那么多个请求就会复用这个ActionFilter，这就有点像是单例的意思了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [ServiceFilter(typeof(FilterInjectAttribute), IsReusable = true)]
        public string DI()
        {
            Console.WriteLine(&quot;HomeController method DI running .&quot;);

            return &quot;DI&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，多次在浏览器中访问对应的action的path，可以看到FilterInjectAttribute的构造函数只会执行一次。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/24/8HOLk9.md.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里有一个重要提示， &lt;strong&gt;ASP.NET Core runtime 并不保证这个filter是真正的单例&lt;/strong&gt;。所以不要试图使用这个属性来实现单例，并且业务系统依赖这个单例。&lt;/p&gt;
&lt;h3 id=&quot;typefilterattribute&quot;&gt;TypeFilterAttribute&lt;/h3&gt;
&lt;p&gt;使用TypeFilterAttribute也可以使你的ActionFilter完成依赖注入。它跟ServiceFilterAttribute差不多，但是使用TypeFilterAttribute注入的ActionFilter并不从DI容器中查找，而是直接通过Microsoft.Extensions.DependencyInjection.ObjectFactory来实例化对象。所以我们的FilterInjectAttribute不需要提前注册到DI容器中。&lt;br/&gt;首先注释掉FilterInjectAttribute的注册代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddScoped&amp;lt;IMyService,MyService&amp;gt;();

            //services.AddScoped(typeof(FilterInjectAttribute));

            services.AddControllers();
            services.AddRazorPages();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改用TypeFilterAttribute：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [TypeFilter(typeof(FilterInjectAttribute))]
        public string DI()
        {
            Console.WriteLine(&quot;HomeController method DI running .&quot;);

            return &quot;DI&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，在浏览器里访问下对应的path，可以看到MyService已经注入到FilterInjectAttribute中：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/24/8HOsOS.md.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;typefilterattribute的isreusable属性&quot;&gt;TypeFilterAttribute的IsReusable属性:&lt;/h4&gt;
&lt;p&gt;跟上面的ServiceFilter一样，&lt;strong&gt;ASP.NET Core runtime 并不保证这个filter是真正的单例&lt;/strong&gt;，这里就不多啰嗦了。&lt;/p&gt;
&lt;h3 id=&quot;typefilterattribute的arguments属性&quot;&gt;TypeFilterAttribute的Arguments属性:&lt;/h3&gt;
&lt;p&gt;Arguments参数是TypeFilterAttribute跟ServiceFilterAttribute的一个重要区别，ServiceFilterAttribute并没有这属性。Arguments类型为object数组。通过TypeFilterAttribute实例化的ActionFilter，如果它的构造器中的参数类型在DI容器中找不到，会继续在Arguments参数列表里按顺序获取。&lt;br/&gt;改一下FilterInjectAttribute构造器多加入2个参数，并且保证这2个参数无法从DI中取到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class FilterInjectAttribute: ActionFilterAttribute
    {
        public FilterInjectAttribute(string arg1, IMyService myService, string arg2)
        {
            if (myService == null)
            {
                throw new ArgumentNullException(&quot;myService&quot;);
            }

            Console.WriteLine(&quot;Service {0} was injected .&quot;, myService.GetServiceName());
            Console.WriteLine(&quot;arg1 is {0} .&quot;, arg1);
            Console.WriteLine(&quot;arg2 is {0} .&quot;, arg2);

            Console.WriteLine(&quot;FilterInjectAttribute was created .&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用的时候传入两个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [TypeFilter(typeof(FilterInjectAttribute), Arguments  = new object[] { &quot;HAHA&quot;, &quot;HOHO&quot; })]
        public string DI()
        {
            Console.WriteLine(&quot;HomeController method DI running .&quot;);

            return &quot;DI&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下看到两个参数被传入了FilterInjectAttribute的构造器：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/24/8bRRVf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;ActionFilterAttribute的依赖注入可以通过ServiceFilterAttribute，TypeFilterAttribute来实现&lt;/li&gt;
&lt;li&gt;ServiceFilterAttribute是通过DI容器来管理ActionFilterAttribute；TypeFilterAttribute则是通过一个工厂直接实例化，所以使用前不需要注册到DI容器中。&lt;/li&gt;
&lt;li&gt;IsReusable属性可以实现类似单例的功能，但是运行时并不保证唯一单例。&lt;/li&gt;
&lt;li&gt;TypeFilterAttribute的Arguments属性可以作为参数列表。当实例化ActionFilterAttribute的时候如果构造器参数类型没有在DI容器中注册那么会尝试从Arguments列表中取。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 16:48:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>上次[ActionFilter引发的一个EF异常](https://www.cnblogs.com/kklldog/p/not-use-sync-in-actionfilter.html),本质上是对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/di-in-core-actionfilter.html</dc:identifier>
</item>
<item>
<title>【Springboot】用Prometheus+Grafana监控Springboot应用 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/12563497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/12563497.html</guid>
<description>&lt;p&gt;项目越做越发觉得，任何一个系统上线，运维监控都太重要了。关于Springboot微服务的监控，之前写过&lt;a href=&quot;https://mp.weixin.qq.com/s/cZ8PKDkjVTO8OkPfXWzlDQ&quot;&gt;【Springboot】用Springboot Admin监控你的微服务应用&lt;/a&gt;，这个方案可以实时监控并提供告警提醒功能，但不能记录历史数据，无法查看过去1小时或过去1天等运维情况。本文介绍Prometheus + Grafana的方法监控Springboot 2.X，实现美观漂亮的数据可视化。&lt;/p&gt;

&lt;p&gt;Prometheus是一套优秀的开源的监控、报警和时间序列数据库组合系统，在现在最常见的&lt;code&gt;Kubernetes&lt;/code&gt;容器管理系统中，通常会搭配&lt;code&gt;Prometheus&lt;/code&gt;进行监控。&lt;/p&gt;
&lt;h2 id=&quot;21-引入到springboot&quot;&gt;2.1 引入到Springboot&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;Prometheus&lt;/code&gt;引入依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于Springboot，要开启&lt;code&gt;Actuator&lt;/code&gt;，并打开对应的&lt;code&gt;Endpoint&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;management.endpoints.web.exposure.include=*
# 或者
management.endpoints.web.exposure.include=prometheus
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动&lt;code&gt;Springboot&lt;/code&gt;后，可以通过下面URL看能不能正确获取到监控数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localhost:8080/actuator/prometheus
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取数据成功，说明&lt;code&gt;Springboot&lt;/code&gt;能正常提供监控数据。&lt;/p&gt;
&lt;h2 id=&quot;22-docker方式使用&quot;&gt;2.2 Docker方式使用&lt;/h2&gt;
&lt;p&gt;为了方便，使用&lt;code&gt;Docker&lt;/code&gt;启动&lt;code&gt;Prometheus&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 拉取docker镜像
docker pull prom/prometheus
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准备配置文件&lt;code&gt;prometheus.yml&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;scrape_configs:
# 可随意指定
- job_name: 'spring'
  # 多久采集一次数据
  scrape_interval: 15s
  # 采集时的超时时间
  scrape_timeout: 10s
  # 采集的路径
  metrics_path: '/actuator/prometheus'
  # 采集服务的地址，设置成Springboot应用所在服务器的具体地址
  static_configs:
  - targets: ['hostname:9000','hostname:8080']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动docker实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 端口为9090，指定配置文件
docker run -d -p 9090:9090 -v ~/temp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus --config.file=/etc/prometheus/prometheus.yml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-测试与查看&quot;&gt;2.3 测试与查看&lt;/h2&gt;
&lt;p&gt;成功启动后，就可以打开网页查看了，并且能图形化展示，URL为http://localhost:9090/。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202003/946674-20200325004448805-27152134.jpg&quot; alt=&quot;Prometheus&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，打开网页后，随便选取一个对应的监控指标与参数，点击&lt;code&gt;Execute&lt;/code&gt;就可以查看了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Grafana&lt;/code&gt;是一个开源的度量分析与可视化套件，纯&lt;code&gt;JavaScript&lt;/code&gt;开发的前端工具，通过访问库（如&lt;code&gt;InfluxDB&lt;/code&gt;），展示自定义报表、显示图表等。它的UI十分灵活，有丰富的插件和模板，功能强大。一般用在时序数据的监控方面。&lt;/p&gt;
&lt;h2 id=&quot;31-docker安装与启动&quot;&gt;3.1 Docker安装与启动&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 拉取镜像
docker pull grafana/grafana
# 运行实例
docker run -d -p 3000:3000 grafana/grafana
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后，访问http://localhost:3000 检查是否成功，初始管理员账号密码为&lt;code&gt;admin/admin&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;32-配置数据源&quot;&gt;3.2 配置数据源&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Grafana&lt;/code&gt;展示数据，则需要配置对应的数据源，本文中配置之前安装启用的&lt;code&gt;Prometheus&lt;/code&gt;数据源，具体配置如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202003/946674-20200325004449242-1438487876.jpg&quot; alt=&quot;DataSource&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;code&gt;Access&lt;/code&gt;要选&lt;code&gt;Browser&lt;/code&gt;模式，否则无法正常获取数据。配置完成后，点击&lt;code&gt;Save &amp;amp; Test&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;33-模板套用&quot;&gt;3.3 模板套用&lt;/h2&gt;
&lt;p&gt;能够获取数据后，就可以自定义数据可视化展示了。但如果自己一条指标一条指标的加，就会很麻烦。实际上，&lt;code&gt;Grafana&lt;/code&gt;提供了许多优秀的模板，可以网页&lt;a href=&quot;https://grafana.com/grafana/dashboards&quot;&gt;https://grafana.com/grafana/dashboards&lt;/a&gt; 查找。&lt;/p&gt;
&lt;p&gt;本文使用&lt;a href=&quot;https://grafana.com/grafana/dashboards/10280&quot;&gt;&lt;em&gt;Spring Boot 2.1 Statistics&lt;/em&gt;&lt;/a&gt;模板，导入方法如下：&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;+&lt;/code&gt;号 --&amp;gt; &lt;code&gt;Import&lt;/code&gt; --&amp;gt; 输入模板链接或ID --&amp;gt; 点击Load。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202003/946674-20200325004449604-892260773.jpg&quot; alt=&quot;import&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功导入后，就能监控数据了，而且，界面真的很好看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202003/946674-20200325004449853-1141326252.jpg&quot; alt=&quot;view&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文介绍了如何使用Prometheus + Grafana监控Springboot应用，实际上，Prometheus + Grafana十分强大，值得花时间好好研究。&lt;/p&gt;
&lt;p&gt;本文例子中软件版本信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;springboot.version=2.2.5
micrometer-registry-prometheus=1.3.5
prometheus.version=2.16
grafana.version=6.7.0-beta1
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202003/946674-20200325004450091-2113306964.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Mar 2020 16:45:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 简介 项目越做越发觉得，任何一个系统上线，运维监控都太重要了。关于Springboot微服务的监控，之前写过 &amp;quot;【Springboot】用Springboot Admin监控你的微服务应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/12563497.html</dc:identifier>
</item>
<item>
<title>Nacos作为微服务注册中心，爱不释手的感觉 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12563434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12563434.html</guid>
<description>&lt;p&gt;在使用SpringCloud做分布式微服务架构时，注册中心是必不可少的一个组件。目前可以用的主要有：Eureka、Consul、Zookeeper。今天，我们就来说一下Alibaba的Nacos怎么样？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;124.54283039476&quot;&gt;

&lt;p&gt;在使用SpringCloud做分布式微服务架构时，注册中心是必不可少的一个组件。目前可以用的主要有：Eureka、Consul、Zookeeper。今天，我们就来说一下Alibaba的Nacos怎么样？&lt;/p&gt;
&lt;h2 id=&quot;下载与安装&quot;&gt;下载与安装&lt;/h2&gt;
&lt;ul readability=&quot;0.45764462809917&quot;&gt;&lt;li readability=&quot;-0.22641509433962&quot;&gt;
&lt;p&gt;下载地址&lt;a href=&quot;https://github.com/alibaba/nacos/releases&quot;&gt;https://github.com/alibaba/nacos/releases&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows 下载解压后（.zip)，直接点击bin/start.bat就可以了。&lt;/li&gt;
&lt;li&gt;Linux下载解压后(.tar.gz)，同样，也是运行 bin/start.sh 脚本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;打开控制台：&lt;/p&gt;
&lt;p&gt;Nacos提供了一个可视化的操作平台，安装好之后，在浏览器中输入&lt;code&gt;http://localhost:8848&lt;/code&gt;就可以访问了,默认的用户名和密码都是nacos(我使用的1.2.0版本。默认将密码验证给关了，这个选项后边会说)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324225122.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nacos简介&quot;&gt;Nacos简介&lt;/h2&gt;
&lt;p&gt;Nacos是由阿里巴巴开源的一个好东西，直接贴上它的官网，就不再这么累赘了，毕竟是国人开发的，是有中文文档的，上边写的很全面。&lt;a href=&quot;https://nacos.io/zh-cn/docs/quick-start.html&quot;&gt;https://nacos.io/zh-cn/docs/quick-start.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;nacos作为注册中心&quot;&gt;Nacos作为注册中心&lt;/h2&gt;
&lt;p&gt;​ 它和Eureka不一样，并不需要创建新的web项目，而是和Zookeeper和Consul一样，只需要下载安装启动后，将我们的微服务注册进去就可以了。&lt;/p&gt;
&lt;p&gt;​ 创建两个微服务，一个客户端（调用者）和一个服务端（提供者），&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引入依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在它们的配置文件中引入如下代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;spring:
  cloud:
    nacos:
      discovery:
      # Nacos的地址
        server-addr: localhost:8848
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;主启动类上添加(不管是哪种注册中心，这个一定要有)：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableDiscoveryClient
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当然，在客户端还是要添加ribbon的负载均衡的，但是不用额外添加依赖，nacos已经添加了&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class AppConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;好了，打开Nacos的控制台，然后就可以看到这两个微服务了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324224903.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nacos作为分布式配置中心&quot;&gt;Nacos作为分布式配置中心&lt;/h2&gt;
&lt;p&gt;之前我们是使用SpringCloudConfig从github等仓库上拉取的配置文件，但是用了Nacos后，我们就可以从Nacos中直接配置了，是不是很方便啊。新建了一个项目，&lt;code&gt;nacos-config-server-8002&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;pomxml引入下边依赖&quot;&gt;pom.xml引入下边依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--分布式配置中心--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;applicationyml中加入如下配置内容&quot;&gt;application.yml中加入如下配置内容&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-YAML&quot;&gt;spring:
  profiles:
    active: dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;添加一个bootstrapyml&quot;&gt;添加一个bootstrap.yml&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;server:
  port: 8002
spring:
  application:
    name: nacos-config-server-8002
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
#       配置文件类型，有yaml和properties ,注意一定是yaml,不是yml
        file-extension: yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;application.yml中的配置是什么意思？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;为什么要引入bootstrap.yml?&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;​ 简单来说，这个配置是和application.yml是一样的，不这它要比appliation.yml先加载&lt;/p&gt;
&lt;h4 id=&quot;controller中的接口&quot;&gt;Controller中的接口&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RefreshScope //这是一个SpingCloud的原生注解，可以实现配置的动态刷新
public class InfoController {
    /*
    这个中的 : 的意思就是说，如果配置文件中没有，就直接使用后边的那个字符串，我写的是nothing
    在本地项目中，我们并没有配置configInfo,
    所以如果这时候调用http://localhost:8002/info
    返回就是nothing
     */
    @Value(&quot;${configInfo}&quot;)
    private String configInfo;

    /**
     * 用做配置中心的演示
     *
     * @return
     */
    @GetMapping(&quot;info&quot;)
    public String getConfig() {
        return configInfo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;nacos中的几个空间概念：&quot;&gt;Nacos中的几个空间概念：&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;NameSpaces（命名空间）&lt;/p&gt;
&lt;p&gt;相当于我们一个项目中的包名，Nacos中可以新建多个命名空间。微服务注册的时候，可以通过配置&lt;code&gt;spring.cloud.nacos.discovery.namespace&lt;/code&gt;,当然，配置文件也可以配置namespace来指定对应的名称空间，如果不配置就是使用默认的public 空间。&lt;/p&gt;
&lt;p&gt;假如，你是好几个项目共用一个Nacos集群，就可以通过namespce来区分项目。&lt;/p&gt;
&lt;p&gt;在Nacos的控制台的最下边有一个命名空间，你可以新建一个试，建完再次点击服务列表和配置列表上边会出现你的命令空间选择（如下图，我新建了一个space1的空间，public是默认的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324232147.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Group（分组）&lt;/p&gt;
&lt;p&gt;相当于Java中的类名，同样，一个包下可以有多个类。不过这个只是相对于配置文件来说，对于服务注册没有这么一说。它有一个默认的分组就是DEFAULT_GROUP，在新建配置文件时就会有(如下图)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DataID&lt;/p&gt;
&lt;p&gt;这个就相当于类中的方法，同样，一个类中就会有多个方法名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324232340.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 我们的配置文件就是在上图中去添加的，下边是我截取了Nacos官方文档中对于DataID的说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324231217.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;新建一个配置文件试试&quot;&gt;新建一个配置文件试试&lt;/h4&gt;
&lt;p&gt;​ 在配置列表中新建一个配置文件，如果你有多个命名空间，注意选择你的项目中连接的那个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200324233920.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要点了右下角的发布，就会自动配置了，再次访问&lt;code&gt;http://localhost:8002/info&lt;/code&gt;，就会看到已经更改了，这个是实时更改的。&lt;/p&gt;
&lt;p&gt;这些都是很简单的操作，只要你自己做一次，就一定会使用了&lt;/p&gt;
&lt;h2 id=&quot;nacos的配置文件持久化&quot;&gt;Nacos的配置文件持久化&lt;/h2&gt;
&lt;p&gt;Nacos使用的是嵌入式数据库Derby，有关嵌入式数据库，可以参考&lt;a href=&quot;https://blog.csdn.net/weixin_43605736/article/details/104177910&quot;&gt;在Spring中使用嵌入式数据库-H2&lt;/a&gt;，虽然数据库不同，但是原理操作方法一致。但是，我们想换成我们的mysql用来存储nacos的数据，可否？&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;导入数据到你本地的Mysql库&lt;/p&gt;
&lt;p&gt;在Nacos安装包下的conf目录下有个nacos-mysql.sql文件，放到你的Mysql工具中执行一遍（它这个sql语句中建库，先建个库名叫nacos_config）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改conf下的application.properties文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-prop&quot;&gt;### 98行左右，这个设置为true就是开启nacos启动的登录验证，默认用户名和密码就是nacos
nacos.core.auth.enabled=true

### 在最后添加如下：
spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;amp;connectTimeout=1000&amp;amp;socketTimeout=3000&amp;amp;autoReconnect=true
db.user=root
db.password=123
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;​ 以上这些内容全都来自于Nacos官网&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200325001122.png&quot; alt=&quot;Nacos注册中心&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，再次启动后Nacos后，你之前的配置文件就全都不见了，因为你配置了Mysql库。这样，你每次修改后，就会进Mysql库，这个库很简单的，你大概看一下就能明白了。&lt;/p&gt;
&lt;p&gt;微信关注”小鱼与Java“，回复”SpingCloud“获取更多SpringCloud学习资料&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot; alt=&quot;Nacos&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 16:25:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>在使用SpringCloud做分布式微服务架构时，注册中心是必不可少的一个组件。目前可以用的主要有：Eureka、Consul、Zookeeper。今天，我们就来说一下Alibaba的Nacos怎么样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12563434.html</dc:identifier>
</item>
<item>
<title>Rust入坑指南：齐头并进（下） - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/12563384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/12563384.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1582962751/Blog/rust/ferris-ninja.png&quot; class=&quot;desc_img&quot;/&gt;前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;164.73209936678&quot;&gt;
&lt;p&gt;前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程，&lt;/p&gt;
&lt;h3 id=&quot;原子类型&quot;&gt;原子类型&lt;/h3&gt;
&lt;p&gt;许多编程语言都会提供原子类型，Rust也不例外，在前文中我们聊了Rust中锁的使用，有了锁，就要小心死锁的问题，Rust虽然声称是安全并发，但是仍然无法帮助我们解决死锁的问题。原子类型就是编程语言为我们提供的无锁并发编程的最佳手段。熟悉Java的同学应该知道，Java的编译器并不能保证代码的执行顺序，编译器会对我们的代码的执行顺序进行优化，这一操作成为指令重排。而Rust的多线程内存模型不会进行指令重排，它可以保证指令的执行顺序。&lt;/p&gt;
&lt;p&gt;通常来讲原子类型会提供以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Load：从原子类型读取值&lt;/li&gt;
&lt;li&gt;Store：为一个原子类型写入值&lt;/li&gt;
&lt;li&gt;CAS（Compare-And-Swap）：比较并交换&lt;/li&gt;
&lt;li&gt;Swap：交换&lt;/li&gt;
&lt;li&gt;Fetch-add（sub/and/or）：表示一系列的原子的加减或逻辑运算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ok，这些基础的概念聊完以后，我们就来看看Rust为我们提供了哪些原子类型。Rust的原子类型定义在标准库&lt;code&gt;std::sync::atomic&lt;/code&gt;中，目前它提供了12种原子类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1584877213/Blog/rust/13/rust13-1.png&quot; alt=&quot;原子类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面这段代码是Rust演示了如何用原子类型实现一个自旋锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-rust&quot;&gt;use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));
    let spinlock_clone = spinlock.clone();
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });
    while spinlock.load(Ordering::SeqCst) != 0 {}
    if let Err(panic) = thread.join() {
        println!(&quot;Thread had an error: {:?}&quot;, panic);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们利用AtomicUsize的store方法将它的值设置为0，然后用load方法获取到它的值，如果不是0，则程序一直空转。在store和load方法中，我们都用到了一个参数：&lt;code&gt;Ordering::SeqCst&lt;/code&gt;，在声明中能看出来它也是属于atomic包。&lt;/p&gt;
&lt;p&gt;我们在文档中发现它是一个枚举。其定义为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-rust&quot;&gt;pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的作用是将内存顺序的控制权交给开发者，我们可以自己定义底层的内存排序。下面我们一起来看一下这5种排序分别代表什么意思&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Relaxed：表示「没有顺序」，也就是开发者不会干预线程顺序，线程只进行原子操作&lt;/li&gt;
&lt;li&gt;Release：对于使用Release的store操作，在它之前所有使用Acquire的load操作都是可见的&lt;/li&gt;
&lt;li&gt;Acquire：对于使用Acquire的load操作，在它之前的所有使用Release的store操作也都是可见的&lt;/li&gt;
&lt;li&gt;AcqRel：它代表读时使用Acquire顺序的load操作，写时使用Release顺序的store操作&lt;/li&gt;
&lt;li&gt;SeqCst：使用了SeqCst的原子操作都必须先存储，再加载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下建议使用SeqCst，而不推荐使用Relaxed。&lt;/p&gt;
&lt;h3 id=&quot;线程间通信&quot;&gt;线程间通信&lt;/h3&gt;
&lt;p&gt;Go语言文档中有这样一句话：&lt;strong&gt;不要使用共享内存来通信，应该使用通信实现共享内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Rust标准库选择了CSP并发模型，也就是依赖channel来进行线程间的通信。它的定义是在标准库&lt;code&gt;std::sync::mpsc&lt;/code&gt;中，里面定义了三种类型的CSP进程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sender：发送异步消息&lt;/li&gt;
&lt;li&gt;SyncSender：发送同步消息&lt;/li&gt;
&lt;li&gt;Receiver：用于接收消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过一个栗子来看一下channel是如何创建并收发消息的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-rust&quot;&gt;use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，我们先是使用了&lt;code&gt;channel()&lt;/code&gt;函数来创建一个channel，它会返回一个（Sender, Receiver）元组。它的缓冲区是无界的。此外，我们还可以使用&lt;code&gt;sync_channel()&lt;/code&gt;来创建channel，它返回的则是（SyncSender, Receiver）元组，这样的channel发送消息是同步的，并且可以设置缓冲区大小。&lt;/p&gt;
&lt;p&gt;接着，在子线程中，我们定义了一个字符串变量，并使用&lt;code&gt;send()&lt;/code&gt;函数向channel中发送消息。这里send返回的是一个Result类型，所以使用unwrap来传播错误。&lt;/p&gt;
&lt;p&gt;在main函数最后，我们又用&lt;code&gt;recv()&lt;/code&gt;函数来接收消息。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，&lt;code&gt;send()&lt;/code&gt;函数会转移所有权，所以，如果你在发送消息之后再使用val变量时，程序就会报错。&lt;/p&gt;
&lt;p&gt;现在我们已经掌握了使用Channel进行线程间通信的方法了，这里还有一段代码，感兴趣的同学可以自己执行一下这段代码看是否能够顺利执行。如果不能，应该怎么修改这段代码呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-rust&quot;&gt;use std::thread;
use std::sync::mpsc;
fn main() {
    let (tx, rx) = mpsc::channel();
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            tx.send(i).unwrap();
        });
    }

    for rx in rx.iter() {
        println!(&quot;{:?}&quot;, j);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;线程池&quot;&gt;线程池&lt;/h3&gt;
&lt;p&gt;在实际工作中，如果每次都要创建新的线程，每次创建、销毁线程的开销就会变得非常可观，甚至会成为系统性能的瓶颈。对于这种问题，我们通常使用线程池来解决。&lt;/p&gt;
&lt;p&gt;Rust的标准库中没有现成的线程池给我们使用，不过还是有一些第三方库来支持的。这里我使用的是&lt;a href=&quot;https://crates.io/crates/threadpool&quot;&gt;threadpool&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先需要在Cargo.toml中增加依赖&lt;code&gt;threadpool = &quot;1.7.1&quot;&lt;/code&gt;。然后就可以使用&lt;code&gt;use threadpool::ThreadPool;&lt;/code&gt;将ThreadPool引入我们的程序中了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-rust&quot;&gt;use threadpool::ThreadPool;
use std::sync::mpsc::channel;

fn main() {
    let n_workers = 4;
    let n_jobs = 8;
    let pool = ThreadPool::new(n_workers);

    let (tx, rx) = channel();
    for _ in 0..n_jobs {
        let tx = tx.clone();
        pool.execute(move|| {
            tx.send(1).expect(&quot;channel will be there waiting for the pool&quot;);
        });
    }

    assert_eq!(rx.iter().take(n_jobs).fold(0, |a, b| a + b), 8);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用&lt;code&gt;ThreadPool::new()&lt;/code&gt;来创建一个线程池，初始化4个工作线程。使用时用&lt;code&gt;execute()&lt;/code&gt;方法就可以拿出一个线程来进行具体的工作。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;今天我们介绍了Rust并发编程的三种特性：原子类型、线程间通信和线程池的使用。&lt;/p&gt;
&lt;p&gt;原子类型是我们进行无锁并发的重要手段，线程间通信和线程池也都是工作中所必须使用的。当然并发编程的知识远不止于此，大家有兴趣的可以自行学习也可以与我交流讨论。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 24 Mar 2020 16:14:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>前文中我们聊了Rust如何管理线程以及如何利用Rust中的锁进行编程。今天我们继续学习并发编程， 原子类型 许多编程语言都会提供原子类型，Rust也不例外，在前文中我们聊了Rust中锁的使用，有了锁，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/12563384.html</dc:identifier>
</item>
</channel>
</rss>