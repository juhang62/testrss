<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>血的教训!千万别在生产使用这些 redis 指令 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13677162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13677162.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200916084957831-1618885897.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;哎，最近小黑哥又双叒叕犯事了。&lt;/p&gt;
&lt;p&gt;事情是这样的，前一段时间小黑哥公司生产交易偶发报错，一番排查下来最终原因是因为 Redis 命令执行超时。&lt;/p&gt;
&lt;p&gt;可是令人不解的是，生产交易仅仅使用 Redis set 这个简单命令，这个命令讲道理是不可能会执行这么慢。&lt;/p&gt;
&lt;p&gt;那到底是什么导致这个问题那？&lt;/p&gt;
&lt;p&gt;为了找出这个问题，我们查看分析了一下 Redis 最近的慢日志，最终发现耗时比较多命令为 &lt;code&gt;keys XX*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看到这个命令操作的键的前缀，小黑哥才发现这是自己负责的应用。可是小黑哥排查一下，虽然自己的代码并没有主动去使用 &lt;code&gt;keys&lt;/code&gt;命令，但是底层使用框架却在间接使用，于是就有了今天这个问题。&lt;/p&gt;
&lt;h2 id=&quot;问题原因&quot;&gt;问题原因&lt;/h2&gt;
&lt;p&gt;小黑哥负责的应用是一个管理后台应用，权限管理使用 Shiro 框架，由于存在多个节点，需要使用分布式 Session，于是这里使用 Redis 存储 Session 信息。&lt;/p&gt;
&lt;blockquote readability=&quot;2.941935483871&quot;&gt;
&lt;p&gt;画外音：不知道分布式 Session ，可以看看小黑哥之前写的 &lt;a href=&quot;https://studyidea.cn/session&quot;&gt;一口气说出 4 种分布式一致性 Session 实现方式，面试杠杠的~&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 Shiro 并没有直接提供 Redis 存储 Session 组件，小黑哥不得不使用 Github 一个开源组件 &lt;a href=&quot;https://github.com/alexxiyang/shiro-redis&quot;&gt;shiro-redis&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于 Shiro 框架需要定期验证 Session 是否有效，于是 Shiro 底层将会调用 &lt;code&gt;SessionDAO#getActiveSessions&lt;/code&gt; 获取所有的 Session 信息。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;shiro-redis&lt;/code&gt; 正好继承 &lt;code&gt;SessionDAO&lt;/code&gt; 这个接口，底层使用用 &lt;code&gt;keys&lt;/code&gt; 命令查找 Redis 所有存储的 &lt;code&gt;Session&lt;/code&gt; key。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Set&amp;lt;byte[]&amp;gt; keys(byte[] pattern){
    checkAndInit();
    Set&amp;lt;byte[]&amp;gt; keys = null;
    Jedis jedis = jedisPool.getResource();
    try{
        keys = jedis.keys(pattern);
    }finally{
        jedis.close();
    }
    return keys;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到问题原因，解决办法就比较简单了，github 上查找到解决方案，升级一下 &lt;code&gt;shiro-redis&lt;/code&gt; 到最新版本。&lt;/p&gt;
&lt;p&gt;在这个版本，&lt;code&gt;shiro-redis&lt;/code&gt; 采用 &lt;code&gt;scan&lt;/code&gt;命令代替 &lt;code&gt;keys&lt;/code&gt;,从而修复这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Set&amp;lt;byte[]&amp;gt; keys(byte[] pattern) {
    Set&amp;lt;byte[]&amp;gt; keys = null;
    Jedis jedis = jedisPool.getResource();

    try{
        keys = new HashSet&amp;lt;byte[]&amp;gt;();
        ScanParams params = new ScanParams();
        params.count(count);
        params.match(pattern);
        byte[] cursor = ScanParams.SCAN_POINTER_START_BINARY;
        ScanResult&amp;lt;byte[]&amp;gt; scanResult;
        do{
            scanResult = jedis.scan(cursor,params);
            keys.addAll(scanResult.getResult());
            cursor = scanResult.getCursorAsBytes();
        }while(scanResult.getStringCursor().compareTo(ScanParams.SCAN_POINTER_START) &amp;gt; 0);
    }finally{
        jedis.close();
    }
    return keys;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然问题成功解决了，但是小黑哥心里还是有点不解。&lt;/p&gt;
&lt;p&gt;为什么 &lt;code&gt;keys&lt;/code&gt; 指令会导致其他命令执行变慢？&lt;/p&gt;
&lt;p&gt;为什么 &lt;code&gt;Keys&lt;/code&gt; 指令查询会这么慢？&lt;/p&gt;
&lt;p&gt;为什么 &lt;code&gt;Scan&lt;/code&gt; 指令就没有问题？&lt;/p&gt;
&lt;h2 id=&quot;redis-执行命令的原理&quot;&gt;Redis 执行命令的原理&lt;/h2&gt;
&lt;p&gt;首先我们来看第一个问题，为什么 &lt;code&gt;keys&lt;/code&gt; 指令会导致其他命令执行变慢？&lt;/p&gt;
&lt;p&gt;回答这个问题，我们首先看下 Redis 客户端执行一条命令的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200916084958924-599232390.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;站在客户端的视角，执行一条命令分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;执行命令&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是这仅仅客户端自己以为的过程，但是实际上同一时刻，可能存在很多客户端发送命令给 Redis，而 Redis 我们都知道它采用的是单线程模型。&lt;/p&gt;
&lt;p&gt;为了处理同一时刻所有的客户端的请求命令，Redis 内部采用了队列的方式，排队执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200916084959401-1824030660.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是客户端执行一条命令实际需要四步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;命令排队&lt;/li&gt;
&lt;li&gt;执行命令&lt;/li&gt;
&lt;li&gt;返回结果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 Redis 单线程执行命令，只能顺序从队列取出任务开始执行。&lt;/p&gt;
&lt;p&gt;只要 3 这个过程执行命令速度过慢，队列其他任务不得不进行等待，这对外部客户端看来，Redis 好像就被阻塞一样，一直得不到响应。&lt;/p&gt;
&lt;p&gt;所以使用 Redis 过程切勿执行需要长时间运行的指令，这样可能导致 Redis 阻塞，影响执行其他指令。&lt;/p&gt;
&lt;h2 id=&quot;keys-原理&quot;&gt;KEYS 原理&lt;/h2&gt;
&lt;p&gt;接下来开始回答第二个问题，为什么 &lt;code&gt;Keys&lt;/code&gt; 指令查询会这么慢？&lt;/p&gt;
&lt;p&gt;回答这个问题之前，请大家回想一下 Redis 底层存储结构。&lt;/p&gt;
&lt;p&gt;不太清楚朋友的也没关系，大家可以回看一下小黑哥之前的文章「&lt;a href=&quot;https://studyidea.cn/redis-dict&quot;&gt;阿里面试官：HashMap 熟悉吧？好的，那就来聊聊 Redis 字典吧！&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;这里小黑哥复制之前文章内容，Redis 底层使用字典这种结构，这个结构与 Java HashMap 底层比较类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202009/1419561-20200916084959859-1436992673.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keys&lt;/code&gt;命令需要返回所有的符合给定模式 &lt;code&gt;pattern&lt;/code&gt; 的 Redis 中键，为了实现这个目的，Redis 不得不遍历字典中 &lt;code&gt;ht[0]&lt;/code&gt;哈希表底层数组，这个时间复杂度为 &lt;strong&gt;O(N)&lt;/strong&gt;（N 为 Redis 中 key 所有的数量）。&lt;/p&gt;
&lt;p&gt;如果 Redis 中 key 的数量很少，那么这个执行速度还是也会很快。等到 Redis key 的数量慢慢更加，上升到百万、千万、甚至上亿级别，那这个执行速度就会很慢很慢。&lt;/p&gt;
&lt;p&gt;下面是小黑哥本地做的一次实验，使用 lua 脚本往 Redis 中增加 10W 个 key，然后使用 &lt;code&gt;keys&lt;/code&gt; 查询所有键,这个查询大概会阻塞十几秒的时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;eval &quot;for i=1,100000  do redis.call('set',i,i+1) end&quot; 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里小黑哥使用 Docker 部署 Redis，性能可能会稍差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;scan-原理&quot;&gt;SCAN 原理&lt;/h2&gt;
&lt;p&gt;最后我们来看下第三个问题，为什么 &lt;code&gt;scan&lt;/code&gt; 指令就没有问题？&lt;/p&gt;
&lt;p&gt;这是因为 &lt;code&gt;scan&lt;/code&gt;命令采用一种黑科技-&lt;strong&gt;基于游标的迭代器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每次调用 &lt;code&gt;scan&lt;/code&gt; 命令，Redis 都会向用户返回一个新的游标以及一定数量的 key。下次再想继续获取剩余的 key，需要将这个游标传入 scan 命令， 以此来延续之前的迭代过程。&lt;/p&gt;
&lt;p&gt;简单来讲，&lt;code&gt;scan&lt;/code&gt; 命令使用分页查询 redis 。&lt;/p&gt;
&lt;p&gt;下面是一个 scan 命令的迭代过程示例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; 命令使用游标这种方式，巧妙将一次全量查询拆分成多次，降低查询复杂度。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;scan&lt;/code&gt; 命令时间复杂度与 &lt;code&gt;keys&lt;/code&gt;一样，都是 &lt;strong&gt;O(N)&lt;/strong&gt;，但是由于 &lt;code&gt;scan&lt;/code&gt; 命令只需要返回少量的 key，所以执行速度会很快。&lt;/p&gt;
&lt;p&gt;最后，虽然&lt;code&gt;scan&lt;/code&gt; 命令解决 &lt;code&gt;keys&lt;/code&gt;不足，但是同时也引入其他一些缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一个元素可能会被返回多次，这就需要我们应用程序增加处理重复元素功能。&lt;/li&gt;
&lt;li&gt;如果一个元素在迭代过程增加到 redis，或者说在迭代过程被删除，那个这个元素会被返回，也可能不会。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上这些缺陷，在我们开发中需要考虑这种情况。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;scan&lt;/code&gt;以外，redis 还有其他几个用于增量迭代命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sscan&lt;/code&gt;:用于迭代当前数据库中的数据库键，用于解决 &lt;code&gt;smembers&lt;/code&gt; 可能产生阻塞问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hscan&lt;/code&gt;命令用于迭代哈希键中的键值对，用于解决 &lt;code&gt;hgetall&lt;/code&gt; 可能产生阻塞问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zscan&lt;/code&gt;:命令用于迭代有序集合中的元素（包括元素成员和元素分值），用于产生 &lt;code&gt;zrange&lt;/code&gt; 可能产生阻塞问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Redis 使用单线程执行操作命令，所有客户端发送过来命令，Redis 都会现放入队列，然后从队列中顺序取出执行相应的命令。&lt;/p&gt;
&lt;p&gt;如果任一任务执行过慢，就会影响队列中其他任务的，这样在外部客户端看来，迟迟拿不到 Redis 的响应，看起来就很阻塞了一样。&lt;/p&gt;
&lt;p&gt;所以不要在生产执行 &lt;code&gt;keys&lt;/code&gt;、&lt;code&gt;smembers&lt;/code&gt;、&lt;code&gt;hgetall&lt;/code&gt;、&lt;code&gt;zrange&lt;/code&gt;这类可能造成阻塞的指令，如果真需要执行，可以使用相应的&lt;code&gt;scan&lt;/code&gt; 命令渐进式遍历，可以有效防止阻塞问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Sep 2020 00:50:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>哎，最近小黑哥又双叒叕犯事了。 事情是这样的，前一段时间小黑哥公司生产交易偶发报错，一番排查下来最终原因是因为 Redis 命令执行超时。 可是令人不解的是，生产交易仅仅使用 Redis set 这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13677162.html</dc:identifier>
</item>
<item>
<title>来说说缓存穿透、缓存击穿、缓存雪崩都是什么？怎么解决？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13677132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13677132.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;看到题目就知道了，这又是我在面试中遇到的，最近面试，把我的博文质量感觉都提上来了。面一次试感觉够我总结一周的，但还是每次都能遇到知识盲点，那以后就当面试总结是个扫盲的过程吧。&lt;/p&gt;
&lt;h2 id=&quot;缓存穿透&quot;&gt;缓存穿透&lt;/h2&gt;
&lt;p&gt;面试的时候就被问到了这个问题，具体描述就是，正常的请求都是先请求到缓存（就当我们的缓存是Redis吧），如果缓存中存在数据，就直接返回，如果缓存中不存在请求的数据，就查询数据库，然后将查询到的数据再放到缓存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么如果现在有一堆的请求，在缓存中没有，数据库中也没有，怎么办？这种垃圾请求还特别多，而且因为是在数据库没有查询到，所以也不会被放到缓存中，这就是缓存穿透的场景。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大量的这种请求，最终会导致数据库压力剧增，最终就会将数据打垮，若是这个数据库是核心数据库，那么其他所有依赖这个库的接口都会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200915225809858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;例如，每次请求的参数都是id，而id是我们数据库里的自增主键，但是请求过来的参数要么是-1这种，要么就是特别大的一个数，反正就是不存在的数据。&lt;/p&gt;
&lt;h3 id=&quot;解决缓存穿透&quot;&gt;解决缓存穿透&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;那么如何解决缓存穿透呢？&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先最基本的就是要做参数校验，非法的参数就直接return，连缓存层都到不了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当请求的数据在穿过Redis后，数据库也返回空，这样的数据也可以存入到缓存中，然后过期时间可以设置一个比较短的时间，这样能够在一定程度上保障后端数据库的安全。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以使用Redis的布隆过滤器，这个工具可以有效的防止缓存穿透的发生，我们可以将一个参数是否存在保存为一个boolean值，然后需要一个bit就可以存储，这样的数据压缩到一个数据结构中，就是布隆过滤器的原理&lt;/strong&gt;。即节省存储空间，又能达到效果。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缓存击穿&quot;&gt;缓存击穿&lt;/h2&gt;
&lt;p&gt;我们在Redis存储的数据，主要是缓存的效果，目的是为了解决DB的压力，所以一些热点数据，都是先从缓存中获取的，当缓存中不存在的时候再从DB中获取然后再存入缓存。&lt;/p&gt;
&lt;p&gt;但是如果一个高频的热点数据，在失效的一瞬间，它的大量请求就会直接打到DB上，这样在DB还没有返回数据给Redis的时候，DB承受了热点请求的压力，就好像缓存是一个水桶，然后突然水桶破了一个洞，直接冲垮了后面的堤坝（DB）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200915233606619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决缓存击穿&quot;&gt;解决缓存击穿&lt;/h3&gt;
&lt;p&gt;造成缓存击穿的原因是，在同一时刻从数据库中获取了大量数据，并且设置了相同的过期时间，这些缓存就会在同一时刻失效，这样就造成了缓存击穿的问题。&lt;br/&gt;&lt;mark&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一些热点的数据，我们可以设置永不过期；或者是在访问数据的时候延长过期时间&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;也可以用分布式锁，来锁住数据，保证同一时间只有一个线程能够获取数据，其他请求获取不到数据，只能等待，但是在高并发的场景下，这种方案，体验不太好，并且分布式锁的压力也会特别大&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缓存雪崩&quot;&gt;缓存雪崩&lt;/h2&gt;
&lt;p&gt;Redis中存储了很多的数据，但是有时候这些数据会出现，在同一个时刻批量过期的情况，因为有可能这些数据是批量插入的，所以他们的过期时间就会都在同一个时间。&lt;/p&gt;
&lt;p&gt;正好在这个批量数据过期的时间点，大量的请求过来了，因为缓存数据过期了，所以没有命中缓存，直接请求到了数据库中。数据库的压力突然剧增，甚至有可能直接撑不住挂掉。然后有可能DBA会紧急重启DB，但是刚一恢复，新的请求立马又把DB打垮了。&lt;/p&gt;
&lt;p&gt;也有可能就是Redis挂了，缓存都不能用了，请求也是直接打到了DB上，然后DB也是扛不住压力，直接挂掉。再恢复，再挂掉。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200916080720162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Redis中同一时刻大量的Key过期，那一瞬间和Redis不存在一样，还有Redis真的挂了的情况，这对服务和DB来说是灾难性的问题。&lt;/p&gt;
&lt;h3 id=&quot;解决缓存雪崩&quot;&gt;解决缓存雪崩&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;解决方案&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;批量存入缓存的数据，我们可以为这些数据分别配置比较合理的过期时间，即使是随机分配过期时间也可以，避免同一时间失效。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热点数据永不过期，更新操作时直接更新缓存，但是并不设置过期时间。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当数据库缓存出问题时，可以采用降级措施，虽然是用DB顶上了请求，但是可以通过降级方案，保证某些数据在同一时刻只能有一个线程在查询数据库和写缓存，这样不至于把数据库给搞崩了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;还有就是为了防止Redis挂了，导致的缓存雪崩，可以保证Redis的高可用，就是将Redis集群部署，然后将热点数据都分配到不同的节点上，这样就可以有效的防止雪崩的出现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当说到Redis高可用的时候，面试有可能会继续问，怎么保证Redis在高可用的情况下，也就是集群中的数据同步时，而数据不会丢失等情况。&lt;br/&gt;这个我准备下一篇来继续啃。&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 00:39:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 看到题目就知道了，这又是我在面试中遇到的，最近面试，把我的博文质量感觉都提上来了。面一次试感觉够我总结一周的，但还是每次都能遇到知识盲点，那以后就当面试总结是个扫盲的过程吧。 缓存穿透 面试的时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13677132.html</dc:identifier>
</item>
<item>
<title>Vue+SpringBoot项目实战(一) 搭建环境 - 东方er</title>
<link>http://www.cnblogs.com/df888/p/13677113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13677113.html</guid>
<description>&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082551549-1182591282.png&quot;/&gt;&lt;hr/&gt;&lt;p&gt;GitHub 地址：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dongfanger/sprint-backend&quot;&gt;https://github.com/dongfanger/sprint-backend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongfanger/sprint-frontend&quot;&gt;https://github.com/dongfanger/sprint-frontend&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;越往高级工程师发展，越明白开发能力的重要性。&lt;/p&gt;
&lt;p&gt;所以我决定开发一个项目，边学习边开发边记录成文，既加深理解，也能帮助大家学习。&lt;/p&gt;
&lt;p&gt;我的目标是做&lt;strong&gt;教程&lt;/strong&gt;，让刚接触Vue和SpringBoot的小伙伴们，能通过教程动手把项目做出来。&lt;/p&gt;
&lt;p&gt;若有疑问，欢迎评论。水平有限，若有纰漏，敬请谅解。&lt;/p&gt;

&lt;p&gt;项目中文名叫“冲刺”，英文名叫“Sprint”。&lt;/p&gt;
&lt;p&gt;熟悉Scrum敏捷开发的朋友，都知道，这是迭代的意思。&lt;/p&gt;
&lt;p&gt;本项目也是采用敏捷开发的方式（边学边写，不敏捷开发也不行呀），逐渐完善和扩充功能和技术。&lt;/p&gt;
&lt;p&gt;另外一个意思，就正如我特别喜欢的一句话，“Never too late to learn”（活到老学到老）。&lt;/p&gt;
&lt;p&gt;只管向前冲，不论结果如何，至少已经努力过。&lt;/p&gt;
&lt;p&gt;只要努力，永远不会太迟。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;User Story&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;初步计划是做CMS（内容管理系统），接着会做成平台化，如测试平台。&lt;/p&gt;
&lt;p&gt;我希望的是，能把这个项目做的个性化一些，不求牛逼，但求实用。&lt;/p&gt;
&lt;p&gt;更专业的可以看看开源电商项目mall。（&lt;a href=&quot;http://www.macrozheng.com/#/README%EF%BC%89&quot;&gt;http://www.macrozheng.com/#/README）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很棒！&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Spring Boot&lt;/td&gt;
&lt;td&gt;2.3.0&lt;/td&gt;
&lt;td&gt;容器+MVC框架&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Spring Security&lt;/td&gt;
&lt;td&gt;5.1.4&lt;/td&gt;
&lt;td&gt;认证和授权框架&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MyBatis&lt;/td&gt;
&lt;td&gt;3.4.6&lt;/td&gt;
&lt;td&gt;ORM框架&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MyBatisGenerator&lt;/td&gt;
&lt;td&gt;1.3.3&lt;/td&gt;
&lt;td&gt;数据层代码生成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PageHelper&lt;/td&gt;
&lt;td&gt;5.1.8&lt;/td&gt;
&lt;td&gt;MyBatis物理分页插件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Swagger-UI&lt;/td&gt;
&lt;td&gt;2.9.2&lt;/td&gt;
&lt;td&gt;文档生产工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Elasticsearch&lt;/td&gt;
&lt;td&gt;7.6.2&lt;/td&gt;
&lt;td&gt;搜索引擎&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RabbitMq&lt;/td&gt;
&lt;td&gt;3.7.14&lt;/td&gt;
&lt;td&gt;消息队列&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;分布式缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MongoDb&lt;/td&gt;
&lt;td&gt;4.2.5&lt;/td&gt;
&lt;td&gt;NoSql数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Docker&lt;/td&gt;
&lt;td&gt;18.09.0&lt;/td&gt;
&lt;td&gt;应用容器引擎&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Druid&lt;/td&gt;
&lt;td&gt;1.1.10&lt;/td&gt;
&lt;td&gt;数据库连接池&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OSS&lt;/td&gt;
&lt;td&gt;2.5.0&lt;/td&gt;
&lt;td&gt;对象存储&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JWT&lt;/td&gt;
&lt;td&gt;0.9.0&lt;/td&gt;
&lt;td&gt;JWT登录支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Lombok&lt;/td&gt;
&lt;td&gt;1.18.6&lt;/td&gt;
&lt;td&gt;简化对象封装工具&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;来源于mall项目。&lt;/p&gt;

&lt;p&gt;Node.js &lt;a href=&quot;https://nodejs.org/zh-cn/download/&quot;&gt;https://nodejs.org/zh-cn/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JDK &lt;a href=&quot;https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html&quot;&gt;https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download/#section=windows&quot;&gt;https://www.jetbrains.com/idea/download/#section=windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体安装步骤百度一大把。&lt;/p&gt;
&lt;p&gt;不需要安装WebStorm哦，直接用旗舰版IDEA（你懂的），同时做前端和后端。社区版对前端支持不够。&lt;/p&gt;

&lt;p&gt;首先设置npm淘宝镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm config set registry https://registry.npm.taobao.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装vue/cli3&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm install -g @vue/cli
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建sprint-frontend项目&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vue create sprint-frontend
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手动选择&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082552006-1123202801.png&quot;/&gt;&lt;p&gt;选择这6个&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082552186-8312367.png&quot;/&gt;&lt;p&gt;选择vue版本，3.x&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082552364-1013001907.png&quot;/&gt;&lt;p&gt;然后一路回车就好了。&lt;/p&gt;
&lt;p&gt;创建完成以后，到目录下执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm run serve
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082552550-1101030417.png&quot;/&gt;&lt;p&gt;前端项目就创建好了。可以访问 &lt;code&gt;http://localhost:8080/&lt;/code&gt; 看下效果。&lt;/p&gt;
&lt;p&gt;记得 &lt;code&gt;ctrl+c&lt;/code&gt; 结束哦，因为接下来要创建后端项目了，前端占用8080端口的话，后端启动会报错（后面会单独设置2个不一样的端口）。&lt;/p&gt;

&lt;p&gt;打开IDEA，New Project&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082552771-96769366.png&quot;/&gt;&lt;p&gt;设置项目信息&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082553013-1225424720.png&quot;/&gt;&lt;p&gt;选择组件，开发者工具，先无脑全选，肯定会用到，哈哈&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082553243-886493686.png&quot;/&gt;&lt;p&gt;Web选2个&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082553446-1134740734.png&quot;/&gt;&lt;p&gt;选择项目存放路径&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082553656-2130175926.png&quot;/&gt;&lt;p&gt;Finish，即可完成创建。&lt;/p&gt;
&lt;p&gt;然后就会看到这个讨厌的玩意，一直在那加载，从url看到是拉的apache.org&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082553955-748456386.png&quot;/&gt;&lt;p&gt;不慌，先等它浪一会。&lt;/p&gt;
&lt;p&gt;打开IDEA的maven目录，在安装路径下哦&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082554210-1699377159.png&quot;/&gt;&lt;p&gt;再到这个路径下，编辑&lt;code&gt;settings.xml&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082554444-1915292409.png&quot;/&gt;&lt;p&gt;找到&amp;lt;mirrors&amp;gt;标签，添加代码。&lt;/p&gt;
&lt;p&gt;这是新版的写法哦，官网https://maven.aliyun.com/mvn/guide有说明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt;
      &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
      &amp;lt;name&amp;gt;阿里云公共仓库&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
    &amp;lt;/mirror&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082554726-1114600528.png&quot;/&gt;&lt;p&gt;再回到IDEA，打开&lt;code&gt;pom.xml&lt;/code&gt;文件，添加一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;repositories&amp;gt;
        &amp;lt;repository&amp;gt;
            &amp;lt;id&amp;gt;public&amp;lt;/id&amp;gt;
            &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
        &amp;lt;/repository&amp;gt;
    &amp;lt;/repositories&amp;gt;

    &amp;lt;pluginRepositories&amp;gt;
        &amp;lt;pluginRepository&amp;gt;
            &amp;lt;id&amp;gt;public&amp;lt;/id&amp;gt;
            &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
        &amp;lt;/pluginRepository&amp;gt;
    &amp;lt;/pluginRepositories&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082555010-1379729033.png&quot;/&gt;&lt;p&gt;这样就把maven的中央仓库从apache替换成了阿里云中央仓库。&lt;/p&gt;
&lt;p&gt;关掉IDEA，再打开，reload maven&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082555333-1064782552.png&quot;/&gt;&lt;p&gt;刚才的Resolving咔嚓就跑完了，我都没来得及截图！&lt;/p&gt;
&lt;p&gt;pom.xml还有一个报错，spring-boot-maven-plugin not found，加上version就解决了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;version&amp;gt;2.3.3.RELEASE&amp;lt;/version&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082555545-301833746.png&quot;/&gt;&lt;p&gt;在src下找到SprintBackendApplication，运行&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082555762-553096664.png&quot;/&gt;&lt;p&gt;后端就启起来了。同样可以访问 &lt;code&gt;http://localhost:8080/&lt;/code&gt; 看下效果。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200916082556040-1374334027.png&quot;/&gt;&lt;p&gt;&lt;strong&gt;备注：其他环境如MySQL、Redis、Nginx等，随着sprint的进行，到了那里再讲哦。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git config --global user.name &quot;yourname&quot;
git config --global user.email &quot;youremail&quot;
cd existing-project
git init
git add --all
git commit -m &quot;Initial Commit&quot;
git remote add origin git@github.com:yourname/sprint-backend.git
git pull origin master --allow-unrelated-histories
git push -u origin master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一个sprint，&lt;strong&gt;计划把登录页面做出来，实现JWT鉴权&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;版权申明：本文为博主原创文章，转载请保留原文链接及作者。&lt;br/&gt;如果您喜欢我写的文章，请关注公众号支持一下，谢谢哈哈哈。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202009/1629545-20200905204716058-357815997.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 00:34:00 +0000</pubDate>
<dc:creator>东方er</dc:creator>
<og:description>GitHub 地址： https://github.com/dongfanger/sprint-backend https://github.com/dongfanger/sprint-fronten</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13677113.html</dc:identifier>
</item>
<item>
<title>使用阿里云OSS的服务端签名后直传功能 - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/13677099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/13677099.html</guid>
<description>&lt;p&gt;网站一般都会有上传功能，而对象存储服务oss是一个很好的选择。可以快速的搭建起自己的上传文件功能。&lt;br/&gt;该文章以使用阿里云的OSS功能为例，记录如何在客户端使用阿里云的对象存储服务。&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;采用JavaScript客户端直接签名（参见JavaScript客户端签名直传）时，AccessKey ID和AcessKey Secret会暴露在前端页面，因此存在严重的安全隐患。因此，OSS提供了服务端签名后直传的方案。&lt;/p&gt;
&lt;h2 id=&quot;流程介绍&quot;&gt;流程介绍&lt;/h2&gt;
&lt;p&gt;流程如下图所示：&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/080c5d0c-c226-4d93-a39a-c76bc52a02b8.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;本示例中，Web端向服务端请求签名，然后直接上传，不会对服务端产生压力，而且安全可靠。但本示例中的服务端无法实时了解用户上传了多少文件，上传了什么文件。如果想实时了解用户上传了什么文件，可以采用服务端签名直传并设置上传回调。&lt;/p&gt;

&lt;h2 id=&quot;1-创建bucket&quot;&gt;1. 创建bucket&lt;/h2&gt;
&lt;blockquote readability=&quot;1.4423076923077&quot;&gt;
&lt;p&gt;快捷入口：&lt;a href=&quot;https://oss.console.aliyun.com/bucket&quot;&gt;https://oss.console.aliyun.com/bucket&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;bucket读写权限为：公共读&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-添加子用户分配权限&quot;&gt;2. 添加子用户分配权限&lt;/h2&gt;
&lt;p&gt;鼠标移至右上角的用户头像当中，点击 &lt;strong&gt;添加AccessKey管理&lt;/strong&gt;, 然后选择使用子用户AccessKey，因为使用子用户可以只分配OSS的读写权限。这样比较安全。&lt;br/&gt;&lt;strong&gt;访问方式选择：编程访问&lt;/strong&gt;(即使用AccessKey ID 和 AccessKey Secret, 通过API或开发工具访问)&lt;/p&gt;
&lt;p&gt;然后点击子用户的添加权限操作。&lt;br/&gt;&lt;strong&gt;权限选择：AliyunOSSFullAccess&lt;/strong&gt;（管理对象存储服务（OSS）权限）&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/a91eb62a-6223-4a0f-b209-ad3cec118228.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3保存accesskey信息&quot;&gt;3.保存AccessKey信息&lt;/h2&gt;
&lt;p&gt;创建了用户后，会展示这么一个页面&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/bb06b199-cf41-48bd-b780-e50e54b5448f.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此时你需要&lt;strong&gt;保存好AccessKeyID和AccessSecret&lt;/strong&gt;，否则这个页面关闭后就找不到了。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-maven&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.aliyun.oss&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aliyun-sdk-oss&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.10.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最新版本可以看这里：&lt;a href=&quot;https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.807.39fb4c07GmTHoV&quot;&gt;https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.807.39fb4c07GmTHoV&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Endpoint以杭州为例，其它Region请按实际情况填写。
String endpoint = &quot;http://oss-cn-hangzhou.aliyuncs.com&quot;;
// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。
String accessKeyId = &quot;&amp;lt;yourAccessKeyId&amp;gt;&quot;;
String accessKeySecret = &quot;&amp;lt;yourAccessKeySecret&amp;gt;&quot;;

// 创建OSSClient实例。
OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

// 创建PutObjectRequest对象。
PutObjectRequest putObjectRequest = new PutObjectRequest(&quot;&amp;lt;yourBucketName&amp;gt;&quot;, &quot;test&quot;, new File(&quot;C:\Users\82131\Desktop\logo.jpg&quot;));

// 上传文件。
ossClient.putObject(putObjectRequest);

// 关闭OSSClient。
ossClient.shutdown();   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/25c9fbaf-2dc9-468c-bab5-d8dcff072d2e.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功后就可以看到test图片了,如图：&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/003d7e95-4592-48e1-89a7-f36902162748.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;修改cors&quot;&gt;修改CORS&lt;/h2&gt;
&lt;p&gt;客户端进行表单直传到OSS时，会从浏览器向OSS发送带有Origin的请求消息。OSS对带有Origin头的请求消息会进行跨域规则（CORS）的验证。因此需要为Bucket设置跨域规则以支持Post方法。&lt;br/&gt;进入bucket后，选择权限管理 -》跨域设置 -》创建规则&lt;br/&gt;&lt;img src=&quot;http://qiniublog.colablog.cn/8c6174a3-56ad-4fd0-9037-7940d07667a9.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端代码&quot;&gt;后端代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class OssController {

    @RequestMapping(&quot;/oss/policy&quot;)
    public Map&amp;lt;String, String&amp;gt; policy() {
        String accessId = &quot;&amp;lt;yourAccessKeyId&amp;gt;&quot;; // 请填写您的AccessKeyId。
        String accessKey = &quot;&amp;lt;yourAccessKeyId&amp;gt;&quot;; // 请填写您的AccessKeySecret。
        String endpoint = &quot;oss-cn-shenzhen.aliyuncs.com&quot;; // 请填写您的 endpoint。
        String bucket = &quot;bucket-name&quot;; // 请填写您的 bucketname 。
        String host = &quot;https://&quot; + bucket + &quot;.&quot; + endpoint; // host的格式为 bucketname.endpoint

        String format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date());
        String dir = format + &quot;/&quot;; // 用户上传文件时指定的前缀。

        Map&amp;lt;String, String&amp;gt; respMap = new LinkedHashMap&amp;lt;String, String&amp;gt;();
        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessId, accessKey);
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes(&quot;utf-8&quot;);
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap.put(&quot;accessid&quot;, accessId);
            respMap.put(&quot;policy&quot;, encodedPolicy);
            respMap.put(&quot;signature&quot;, postSignature);
            respMap.put(&quot;dir&quot;, dir);
            respMap.put(&quot;host&quot;, host);
            respMap.put(&quot;expire&quot;, String.valueOf(expireEndTime / 1000));

        } catch (Exception e) {
            // Assert.fail(e.getMessage());
            System.out.println(e.getMessage());
        } finally {
            ossClient.shutdown();
        }
        return respMap;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更详细的详细请查看这里：&lt;a href=&quot;https://help.aliyun.com/document_detail/91868.html?spm=a2c4g.11186623.2.15.a66e6e28WZXmSg#concept-ahk-rfz-2fb&quot;&gt;https://help.aliyun.com/document_detail/91868.html?spm=a2c4g.11186623.2.15.a66e6e28WZXmSg#concept-ahk-rfz-2fb&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前端代码&quot;&gt;前端代码&lt;/h2&gt;
&lt;p&gt;以element-ui组件为例，上传前BeforeUpload先调用后端的policy接口获取签名信息，然后带着签名等信息和图片直接上传到aliyun的OSS。&lt;br/&gt;上传组件singleUpload.vue，需要改动action的地址：bucket的外网域名（在bucket的概览里面可以看到）,该文件是谷粒商城项目的一个上传组件，我只是copy过来修改了一点点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;el-upload
      action=&quot;http://colablog.oss-cn-shenzhen.aliyuncs.com&quot;
      :data=&quot;dataObj&quot;
      list-type=&quot;picture&quot;
      :multiple=&quot;false&quot;
      :show-file-list=&quot;showFileList&quot;
      :file-list=&quot;fileList&quot;
      :before-upload=&quot;beforeUpload&quot;
      :on-remove=&quot;handleRemove&quot;
      :on-success=&quot;handleUploadSuccess&quot;
      :on-preview=&quot;handlePreview&quot;
    &amp;gt;
      &amp;lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&amp;gt;点击上传&amp;lt;/el-button&amp;gt;
      &amp;lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&amp;gt;只能上传jpg/png文件，且不超过10MB&amp;lt;/div&amp;gt;
    &amp;lt;/el-upload&amp;gt;
    &amp;lt;el-dialog :visible.sync=&quot;dialogVisible&quot;&amp;gt;
      &amp;lt;img width=&quot;100%&quot; :src=&quot;fileList[0].url&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;

export default {
  name: 'SingleUpload',
  props: {
    value: String
  },
  data() {
    return {
      dataObj: {
        policy: '',
        signature: '',
        key: '',
        ossaccessKeyId: '',
        dir: '',
        host: ''
        // callback:'',
      },
      dialogVisible: false
    }
  },
  computed: {
    imageUrl() {
      return this.value
    },
    imageName() {
      if (this.value != null &amp;amp;&amp;amp; this.value !== '') {
        return this.value.substr(this.value.lastIndexOf('/') + 1)
      } else {
        return null
      }
    },
    fileList() {
      return [{
        name: this.imageName,
        url: this.imageUrl
      }]
    },
    showFileList: {
      get: function() {
        return this.value !== null &amp;amp;&amp;amp; this.value !== '' &amp;amp;&amp;amp; this.value !== undefined
      },
      set: function(newValue) {
      }
    }
  },
  methods: {
    emitInput(val) {
      this.$emit('input', val)
    },
    handleRemove(file, fileList) {
      this.emitInput('')
    },
    handlePreview(file) {
      this.dialogVisible = true
    },
    getUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c =&amp;gt; {
        return (c === 'x' ? (Math.random() * 16 | 0) : ('r&amp;amp;0x3' | '0x8')).toString(16)
      })
    },
    beforeUpload(file) {
      const _self = this
      return new Promise((resolve, reject) =&amp;gt; {
        // 前后端提交post异步请求获取签名信息
        this.postRequest('/oss/policy')
          .then((response) =&amp;gt; {
            _self.dataObj.policy = response.policy
            _self.dataObj.signature = response.signature
            _self.dataObj.ossaccessKeyId = response.accessid
            _self.dataObj.key = response.dir + this.getUUID() + '_${filename}'
            _self.dataObj.dir = response.dir
            _self.dataObj.host = response.host
            resolve(true)
          }).catch(err =&amp;gt; {
            reject(false)
          })
      })
    },
    handleUploadSuccess(res, file) {
      console.log('上传成功...')
      this.showFileList = true
      this.fileList.pop()
      this.fileList.push({ name: file.name, url: this.dataObj.host + '/' + this.dataObj.key.replace('${filename}', file.name) })
      this.emitInput(this.fileList[0].url)
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引用SingleUpload组件的页面的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;el-form :model=&quot;admin&quot; label-width=&quot;60px&quot;&amp;gt;
      &amp;lt;el-form-item label=&quot;头像&quot;&amp;gt;
        &amp;lt;single-upload v-model=&quot;admin.userImg&quot; /&amp;gt;
      &amp;lt;/el-form-item&amp;gt;
    &amp;lt;/el-form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import singleUpload from '@/components/upload/singleUpload'
export default {
  components: {
    singleUpload
  },
  data() {
    return {
      admin: {
        userImg: ''
      }
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;该文主要由学习谷粒商城项目的实践过程，技术难度并不大，阿里云官网有文档可以查阅。&lt;br/&gt;快捷入口：&lt;a href=&quot;https://help.aliyun.com/product/31815.html?spm=a2c4g.11186623.6.540.28c66d39lLTogx&quot;&gt;https://help.aliyun.com/product/31815.html?spm=a2c4g.11186623.6.540.28c66d39lLTogx&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.6190476190476&quot;&gt;
&lt;p&gt;个人博客网址： &lt;a href=&quot;https://colablog.cn/&quot;&gt;https://colablog.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我的文章帮助到您，可以关注我的微信公众号，第一时间分享文章给您&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg&quot; alt=&quot;微信公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 Sep 2020 00:16:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<og:description>网站一般都会有上传功能，而对象存储服务oss是一个很好的选择。可以快速的搭建起自己的上传文件功能。 该文章以使用阿里云的OSS功能为例，记录如何在客户端使用阿里云的对象存储服务。 服务端签名后直传 背</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johnson-lin/p/13677099.html</dc:identifier>
</item>
<item>
<title>常见重构技巧 - 5种方式去除多余的if else - pdai</title>
<link>http://www.cnblogs.com/pengdai/p/13677095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengdai/p/13677095.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最为常见的是代码中使用很多的if/else，或者switch/case；如何重构呢？方法特别多，本文带你学习其中的技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;出现ifelse和switchcase的场景&quot;&gt;出现if/else和switch/case的场景&lt;/h2&gt;
&lt;p&gt;通常业务代码会包含这样的逻辑：每种条件下会有不同的处理逻辑。比如两个数a和b之间可以通过不同的操作符（+，-，*，/）进行计算，初学者通常会这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int calculate(int a, int b, String operator) {
    int result = Integer.MIN_VALUE;
 
    if (&quot;add&quot;.equals(operator)) {
        result = a + b;
    } else if (&quot;multiply&quot;.equals(operator)) {
        result = a * b;
    } else if (&quot;divide&quot;.equals(operator)) {
        result = a / b;
    } else if (&quot;subtract&quot;.equals(operator)) {
        result = a - b;
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者用switch/case：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int calculateUsingSwitch(int a, int b, String operator) {
    switch (operator) {
    case &quot;add&quot;:
        result = a + b;
        break;
    // other cases    
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种最基础的代码如何重构呢？&lt;/p&gt;
&lt;h2 id=&quot;重构思路&quot;&gt;重构思路&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;有非常多的重构方法来解决这个问题, 这里会列举很多方法，在实际应用中可能会根据场景进行一些调整；另外不要纠结这些例子中显而易见的缺陷（比如没用常量，没考虑多线程等等），而是把重心放在学习其中的思路上。@pdai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;方式一---工厂类&quot;&gt;方式一 - 工厂类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定义一个操作接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Operation {
    int apply(int a, int b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现操作， 这里只以add为例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Addition implements Operation {
    @Override
    public int apply(int a, int b) {
        return a + b;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现操作工厂&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class OperatorFactory {
    static Map&amp;lt;String, Operation&amp;gt; operationMap = new HashMap&amp;lt;&amp;gt;();
    static {
        operationMap.put(&quot;add&quot;, new Addition());
        operationMap.put(&quot;divide&quot;, new Division());
        // more operators
    }
 
    public static Optional&amp;lt;Operation&amp;gt; getOperation(String operator) {
        return Optional.ofNullable(operationMap.get(operator));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在Calculator中调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int calculateUsingFactory(int a, int b, String operator) {
    Operation targetOperation = OperatorFactory
      .getOperation(operator)
      .orElseThrow(() -&amp;gt; new IllegalArgumentException(&quot;Invalid Operator&quot;));
    return targetOperation.apply(a, b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面为什么方法名是&lt;code&gt;apply&lt;/code&gt;,&lt;code&gt;Optional&lt;/code&gt;怎么用? 请参考这篇：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.pdai.tech/md/java/java8/java8-stream.html&quot;&gt;Java 8 - 函数编程(lambda表达式)&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;Lambda 表达式的特点?&lt;/li&gt;
&lt;li&gt;Lambda 表达式使用和Stream下的接口?&lt;/li&gt;
&lt;li&gt;函数接口定义和使用，四大内置函数接口Consumer，Function，Supplier, Predicate.&lt;/li&gt;
&lt;li&gt;Comparator排序为例贯穿所有知识点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pdai.tech/md/java/java8/java8-optional.html&quot;&gt;Java 8 - Optional类深度解析&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;Optional类的意义?&lt;/li&gt;
&lt;li&gt;Optional类有哪些常用的方法?&lt;/li&gt;
&lt;li&gt;Optional举例贯穿所有知识点&lt;/li&gt;
&lt;li&gt;如何解决多重类嵌套Null值判断?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方式二---枚举&quot;&gt;方式二 - 枚举&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;枚举适合类型固定，可枚举的情况，比如这的操作符; 同时枚举中是可以提供方法实现的，这就是我们可以通过枚举进行重构的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;定义操作符枚举&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum Operator {
    ADD {
        @Override
        public int apply(int a, int b) {
            return a + b;
        }
    },
    // other operators
    
    public abstract int apply(int a, int b);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在Calculator中调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int calculate(int a, int b, Operator operator) {
    return operator.apply(a, b);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;写个测试用例测试下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenCalculateUsingEnumOperator_thenReturnCorrectResult() {
    Calculator calculator = new Calculator();
    int result = calculator.calculate(3, 4, Operator.valueOf(&quot;ADD&quot;));
    assertEquals(7, result);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看是否很简单?&lt;/p&gt;
&lt;h3 id=&quot;方法三---命令模式&quot;&gt;方法三 - 命令模式&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;命令模式也是非常常用的重构方式， 把每个操作符当作一个Command。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Command {
    Integer execute();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现Command&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddCommand implements Command {
    // Instance variables
 
    public AddCommand(int a, int b) {
        this.a = a;
        this.b = b;
    }
 
    @Override
    public Integer execute() {
        return a + b;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在Calculator中调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int calculate(Command command) {
    return command.execute();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试用例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenCalculateUsingCommand_thenReturnCorrectResult() {
    Calculator calculator = new Calculator();
    int result = calculator.calculate(new AddCommand(3, 7));
    assertEquals(10, result);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里&lt;code&gt;new AddCommand(3, 7)&lt;/code&gt;仍然没有解决动态获取操作符问题，所以通常来说可以结合简单工厂模式来调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.pdai.tech/md/dev-spec/pattern/3_simple_factory.html&quot;&gt;创建型 - 简单工厂(Simple Factory)&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;简单工厂(Simple Factory)，它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方法四---规则引擎&quot;&gt;方法四 - 规则引擎&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;规则引擎适合规则很多且可能动态变化的情况，在先要搞清楚一点Java OOP，即类的抽象：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Rule {
    boolean evaluate(Expression expression);
    Result getResult();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Add 规则&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddRule implements Rule {
    @Override
    public boolean evaluate(Expression expression) {
        boolean evalResult = false;
        if (expression.getOperator() == Operator.ADD) {
            this.result = expression.getX() + expression.getY();
            evalResult = true;
        }
        return evalResult;
    }    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Expression {
    private Integer x;
    private Integer y;
    private Operator operator;        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;规则引擎&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RuleEngine {
    private static List&amp;lt;Rule&amp;gt; rules = new ArrayList&amp;lt;&amp;gt;();
 
    static {
        rules.add(new AddRule());
    }
 
    public Result process(Expression expression) {
        Rule rule = rules
          .stream()
          .filter(r -&amp;gt; r.evaluate(expression))
          .findFirst()
          .orElseThrow(() -&amp;gt; new IllegalArgumentException(&quot;Expression does not matches any Rule&quot;));
        return rule.getResult();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试用例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenNumbersGivenToRuleEngine_thenReturnCorrectResult() {
    Expression expression = new Expression(5, 5, Operator.ADD);
    RuleEngine engine = new RuleEngine();
    Result result = engine.process(expression);
 
    assertNotNull(result);
    assertEquals(10, result.getValue());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法五---策略模式&quot;&gt;方法五 - 策略模式&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;策略模式比命令模式更为常用，而且在实际业务逻辑开发中需要注入一定的（比如通过Spring的&lt;code&gt;@Autowired&lt;/code&gt;来注入bean），这时通过策略模式可以巧妙的重构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果是在实现业务逻辑需要注入框架中资源呢？比如通过Spring的&lt;code&gt;@Autowired&lt;/code&gt;来注入bean。可以这样实现：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;操作 // 很巧妙&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Opt {
    int apply(int a, int b);
}

@Component(value = &quot;addOpt&quot;)
public class AddOpt implements Opt {
    @Autowired
    xxxAddResource resource; // 这里通过Spring框架注入了资源

    @Override
    public int apply(int a, int b) {
       return resource.process(a, b);
    }
}

@Component(value = &quot;devideOpt&quot;)
public class devideOpt implements Opt {
    @Autowired
    xxxDivResource resource; // 这里通过Spring框架注入了资源

    @Override
    public int apply(int a, int b) {
       return resource.process(a, b);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class OptStrategyContext{
 

    private Map&amp;lt;String, Opt&amp;gt; strategyMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
 
    @Autowired
    public OptStrategyContext(Map&amp;lt;String, TalkService&amp;gt; strategyMap) {
        this.strategyMap.clear();
        this.strategyMap.putAll(strategyMap);
    }
 
    public int apply(Sting opt, int a, int b) {
        return strategyMap.get(opt).apply(a, b);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码在实现中非常常见。&lt;/p&gt;
&lt;h2 id=&quot;一些反思&quot;&gt;一些反思&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最怕的是刚学会成语，就什么地方都想用成语。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;h2 id=&quot;更多内容&quot;&gt;更多内容&lt;/h2&gt;
&lt;blockquote readability=&quot;4.3421052631579&quot;&gt;
&lt;p&gt;&lt;span&gt;最全的Java后端知识体系&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;https://www.pdai.tech&quot;&gt;https://www.pdai.tech&lt;/a&gt;&lt;/span&gt;, &lt;span&gt;每天更新中...&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 Sep 2020 00:15:00 +0000</pubDate>
<dc:creator>pdai</dc:creator>
<og:description>常见重构技巧 - 去除多余的if else 最为常见的是代码中使用很多的if/else，或者switch/case；如何重构呢？方法特别多，本文带你学习其中的技巧。 常见重构技巧 - 去除多余的if</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengdai/p/13677095.html</dc:identifier>
</item>
<item>
<title>必考算法之 Top K 问题 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13677078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13677078.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，这里是《齐姐聊算法》系列之 Top K 问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Top K 问题是面试中非常常考的算法题。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1giqq88xyu6j31f80c00uj.jpg&quot; alt=&quot;8&quot;/&gt;8
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leetcode 上这两题大同小异，这里以第一题为例。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1giqqabh9eaj30u80u0agh.jpg&quot; alt=&quot;&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;题意：&lt;br/&gt;给一组词，统计出现频率最高的 k 个。&lt;br/&gt;比如说 “I love leetcode, I love coding” 中频率最高的 2 个就是 I 和 love 了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有同学觉得这题特别简单，但其实这题只是母题，它可以升级到&lt;span&gt;系统设计&lt;/span&gt;层面来问：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;在某电商网站上，过去的一小时内卖出的最多的 k 种货物。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看算法层面:&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统计下所有词的频率，然后按频率排序取最高的前 k 个呗。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;细节：&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 HashMap 存放单词的频率，用 minHeap/maxHeap 来取前 k 个。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;建一个 &lt;code&gt;HashMap &amp;lt;key = 单词，value = 出现频率&amp;gt;&lt;/code&gt;，遍历整个数组，相应的把这个单词的出现次数 + 1.&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步时间复杂度是 O(n).&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;用 size = k 的 minHeap 来存放结果，定义好题目中规定的比较顺序&lt;br/&gt;a. 首先按照出现的频率排序；&lt;br/&gt;b. 频率相同时，按字母顺序。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;遍历这个 map，如果&lt;br/&gt;a. minHeap 里面的单词数还不到 k 个的时候就加进去；&lt;br/&gt;b. 或者遇到更高频的单词就把它替换掉。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;时空复杂度分析：&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步是 O(n)，第三步是 nlog(k)，所以加在一起时间复杂度是 O(nlogk).&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用了一个额外的 heap 和 map，空间复杂度是 O(n).&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;11&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;16&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;topKFrequent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] words, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Map&amp;lt;String, Integer&amp;gt; map = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (String word : words) {&lt;br/&gt;Integer count = map.getOrDefault(word, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;count++;&lt;br/&gt;map.put(word, count);&lt;br/&gt;}&lt;p&gt;&lt;br/&gt;PriorityQueue&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt; minHeap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;(k+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Comparator&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Map.Entry&amp;lt;String, Integer&amp;gt; e1, Map.Entry&amp;lt;String, Integer&amp;gt; e2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(e1.getValue() == e2.getValue()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e2.getKey().compareTo(e1.getKey());&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; e1.getValue().compareTo(e2.getValue());&lt;br/&gt;}&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;&lt;br/&gt;List&amp;lt;String&amp;gt; res = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(Map.Entry&amp;lt;String, Integer&amp;gt; entry : map.entrySet()) {&lt;br/&gt;minHeap.offer(entry);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(minHeap.size() &amp;gt; k) {&lt;br/&gt;minHeap.poll();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!minHeap.isEmpty()) {&lt;br/&gt;res.add(minHeap.poll().getKey());&lt;br/&gt;}&lt;br/&gt;Collections.reverse(res);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多干货文章见我的 Github: https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 Sep 2020 23:45:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>大家好，这里是《齐姐聊算法》系列之 Top K 问题。 Top K 问题是面试中非常常考的算法题。 8 Leetcode 上这两题大同小异，这里以第一题为例。 题意： 给一组词，统计出现频率最高的 k</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13677078.html</dc:identifier>
</item>
<item>
<title>.NET 5.0 RC1 发布，离正式版发布仅剩两个版本 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13677079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13677079.html</guid>
<description>&lt;blockquote readability=&quot;7.5873925501433&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://dwz.win/Qf8&quot;&gt;http://dwz.win/Qf8&lt;/a&gt;&lt;br/&gt;作者：Richard&lt;br/&gt;翻译：精致码农-王亮&lt;br/&gt;说明：本文有不少超链接，由于微信公众号和头条平台外链会被剔除 URL 地址，所以原来本是超链接的内容会显示为纯文本，如果你需要这些信息可以移步到我的&lt;strong&gt;知乎&lt;/strong&gt;和&lt;strong&gt;博客园&lt;/strong&gt;阅读（搜索精致码农可找到我）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们发布了 &lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;.NET 5.0 Release Candidate 1 (RC1)&lt;/a&gt;。它是目前最接近 .NET 5.0 的一个版本，也是在 11 月正式发布之前的两个 RC 版本中的第一个 RC 版本。RC1 是一个“上线”版本，表示你可以在生产环境中使用它了。&lt;/p&gt;
&lt;p&gt;与此同时，我们一直在寻找最终正式版发布之前应该被修复的任何关键错误报告。我们需要你的反馈来帮助我们一起跨越 .NET 5.0 正式发布这道胜利的终点线。&lt;/p&gt;
&lt;p&gt;我们今天也发布了 &lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-release-candidate-1/&quot;&gt;ASP.NET Core&lt;/a&gt; 和 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-efcore-5-0-rc1/&quot;&gt;EF Core&lt;/a&gt; 的 RC1 版本。&lt;/p&gt;
&lt;p&gt;你可以&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;下载适用于 Windows、macOS 和 Linux 的 .NET 5.0 版本&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;你需要最新的预览版 Visual Studio (包括 Visual Studio for Mac) 才能使用 .NET 5.0。&lt;/p&gt;
&lt;p&gt;.NET 5.0 有&lt;a href=&quot;https://github.com/dotnet/runtime/issues/37269&quot;&gt;很多改进&lt;/a&gt;，特别是&lt;a href=&quot;https://github.com/dotnet/runtime/issues/36590&quot;&gt;单个文件应用程序&lt;/a&gt;、&lt;a href=&quot;https://github.com/dotnet/dotnet-docker/issues/1814#issuecomment-625294750&quot;&gt;更小的容器映像&lt;/a&gt;、&lt;a href=&quot;https://github.com/dotnet/runtime/issues/41313&quot;&gt;更强大的 JsonSerializer API&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/terrajobst/status/1296566363880742917&quot;&gt;完整的可空引用类型标注&lt;/a&gt;、新的&lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md&quot;&gt;目标 Framework 名称&lt;/a&gt;，以及对 &lt;a href=&quot;https://github.com/dotnet/runtime/issues/36699&quot;&gt;Windows ARM64&lt;/a&gt; 的支持。在网络库、GC 和 JIT 中性能得到了极大的提高。我们&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/arm64-performance-in-net-5/&quot;&gt;花了很大的工作在 ARM64 的性能上&lt;/a&gt;，它有了更好的吞吐量和更小的二进制文件。.NET 5.0 包含了新的语言版本：C# 9.0 和 F# 5.0。&lt;/p&gt;
&lt;p&gt;我们最近发布了一些关于 5.0 新功能深入介绍的文章，你可能想看一看这些文章：&lt;/p&gt;
&lt;p&gt;就像我在 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-8/&quot;&gt;.NET 5.0 预览 8&lt;/a&gt; 文中所做的一样，我选择了一些特性来进行更深入的介绍，并让你了解如何在实际使用中使用它们。这篇文章专门讨论 C# 9 中的 &lt;code&gt;System.Text.Json.JsonSerializer&lt;/code&gt; 和 &lt;code&gt;records&lt;/code&gt;(记录)。它们是独立的特性，但也是很好的组合，特别是如果你花费大量时间为反序列化的 JSON 对象创建 POCO 类型。&lt;/p&gt;
&lt;h2 id=&quot;c-9--记录&quot;&gt;C# 9 — 记录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;记录&lt;/strong&gt;（原文 Record）可能是 C# 9 中最重要的新特性。它们提供了广泛的特性集（对一种语言类型来说），其中一些需要 RC1 或更高版本（如 record.ToString()）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;译注：为了阅读更通顺，对 Record 的翻译，本译文根据语境的情况，有的地方用的是“Record”，有的地方用的是“记录”。因为在一些语境下把“Record”翻译成“记录”容易产生数据记录的错误联想。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最简单的理解，记录是不可变类型。在特性方面，它们最接近元组（Tuple），可以将它们视为具有属性且不可变的自定义元组。在如今使用元组的多数情况下，记录可以比元组提供更好更多的功能和使用场景。&lt;/p&gt;
&lt;p&gt;在使用 C# 时，如果你使用命名类型会使你得到最好的体验（相对于像元组这样的特性）。静态类型(static typing)是该语言的设计要点，记录使小型类型更容易使用，并在整个应用程序中可以保证类型安全。&lt;/p&gt;
&lt;h3 id=&quot;记录是不可变数据类型&quot;&gt;记录是不可变数据类型&lt;/h3&gt;
&lt;p&gt;记录使你能够创建不可变的数据类型，这对于定义存储少量数据的类型非常有用。&lt;/p&gt;
&lt;p&gt;下面是一个记录的例子，它存储登录用户信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginResource(string Username, string Password, bool RememberMe);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它在语义上与下面的类相似(几乎完全相同)，我即将介绍这些差异。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class LoginResource
{
    public LoginResource(string username, string password, bool rememberMe)
    {
        Username = username;
        Password = password;
        RememberMe = rememberMe;
    }

    public string Username { get; init; }
    public string Password { get; init; }
    public bool RememberMe { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 是一个新的关键字，它是 &lt;code&gt;set&lt;/code&gt; 的替代。&lt;code&gt;set&lt;/code&gt; 允许你在任何时候给属性分配值，&lt;code&gt;init&lt;/code&gt; 只允许在对象构造期间给属性赋值，它是记录不变性所依赖的基石。任何类型都可以使用 &lt;code&gt;init&lt;/code&gt;，正如你在前面的类定义中看到的那样，它并不局限于在记录中使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private set&lt;/code&gt; 看起来类似于 &lt;code&gt;init&lt;/code&gt;，&lt;code&gt;private set&lt;/code&gt; 防止其他代码（类型以外的代码）改变数据。当类型（在构造之后）意外地改变属性时，&lt;code&gt;init&lt;/code&gt; 将产生编译错误。&lt;code&gt;private set&lt;/code&gt; 不能使数据不可变，因此当类型在构造后改变属性值时，不会生成任何编译错误或警告。&lt;/p&gt;
&lt;h3 id=&quot;记录是特殊的类&quot;&gt;记录是特殊的类&lt;/h3&gt;
&lt;p&gt;正如我刚才提到的，&lt;code&gt;LoginResource&lt;/code&gt; 的记录变体和类变体几乎是相同的。类定义是记录的一个语义相同的子集，记录提供了更多特殊的行为。&lt;/p&gt;
&lt;p&gt;为了让我们的想法达成一致，如前所述，下面的比较是一个记录和一个使用 init 代替 set 修饰属性的类之间的区别。&lt;/p&gt;
&lt;p&gt;有哪些共同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;不变性&lt;/li&gt;
&lt;li&gt;复制语义(记录本质是类)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有哪些不同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记录相等是基于内容的，类相等是基于对象标识；&lt;/li&gt;
&lt;li&gt;记录提供了一个基于内容 GetHashCode() 实现；&lt;/li&gt;
&lt;li&gt;记录提供了一个&lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;的实现，它使用 &lt;code&gt;GetHashCode()&lt;/code&gt; 唯一性作为行为机制，为记录提供基于内容的相等语义；&lt;/li&gt;
&lt;li&gt;记录重写（override）了 &lt;code&gt;ToString()&lt;/code&gt;，打印的是记录的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;记录和（使用 init 的）类之间的差异可以在 &lt;code&gt;LoginResource&lt;/code&gt; 作为记录和 &lt;code&gt;LoginResource&lt;/code&gt; 作为类的反编译代码中可以看到。&lt;/p&gt;
&lt;p&gt;我将向你展示一些有差异的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Linq;
using static System.Console;

var user = &quot;Lion-O&quot;;
var password = &quot;jaga&quot;;
var rememberMe = true;
LoginResourceRecord lrr1 = new(user, password, rememberMe);
var lrr2 = new LoginResourceRecord(user, password, rememberMe);
var lrc1 = new LoginResourceClass(user, password, rememberMe);
var lrc2 = new LoginResourceClass(user, password, rememberMe);

WriteLine($&quot;Test record equality -- lrr1 == lrr2 : {lrr1 == lrr2}&quot;);
WriteLine($&quot;Test class equality  -- lrc1 == lrc2 : {lrc1 == lrc2}&quot;);
WriteLine($&quot;Print lrr1 hash code -- lrr1.GetHashCode(): {lrr1.GetHashCode()}&quot;);
WriteLine($&quot;Print lrr2 hash code -- lrr2.GetHashCode(): {lrr2.GetHashCode()}&quot;);
WriteLine($&quot;Print lrc1 hash code -- lrc1.GetHashCode(): {lrc1.GetHashCode()}&quot;);
WriteLine($&quot;Print lrc2 hash code -- lrc2.GetHashCode(): {lrc2.GetHashCode()}&quot;);
WriteLine($&quot;{nameof(LoginResourceRecord)} implements IEquatable&amp;lt;T&amp;gt;: {lrr1 is IEquatable&amp;lt;LoginResourceRecord&amp;gt;} &quot;);
WriteLine($&quot;{nameof(LoginResourceClass)}  implements IEquatable&amp;lt;T&amp;gt;: {lrr1 is IEquatable&amp;lt;LoginResourceClass&amp;gt;}&quot;);
WriteLine($&quot;Print {nameof(LoginResourceRecord)}.ToString -- lrr1.ToString(): {lrr1.ToString()}&quot;);
WriteLine($&quot;Print {nameof(LoginResourceClass)}.ToString  -- lrc1.ToString(): {lrc1.ToString()}&quot;);

public record LoginResourceRecord(string Username, string Password, bool RememberMe);

public class LoginResourceClass
{
    public LoginResourceClass(string username, string password, bool rememberMe)
    {
        Username = username;
        Password = password;
        RememberMe = rememberMe;
    }

    public string Username { get; init; }
    public string Password { get; init; }
    public bool RememberMe { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：你将注意到 &lt;code&gt;LoginResource&lt;/code&gt; 类型以 Record 和 Class 结束，该模式并不是新的命名约定，这样命名只是为了在样本中有相同类型的记录和类变体，请不要这样命名你的类。&lt;/p&gt;
&lt;p&gt;此代码的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;rich@thundera records % dotnet run
Test record equality -- lrr1 == lrr2 : True
Test class equality  -- lrc1 == lrc2 : False
Print lrr1 hash code -- lrr1.GetHashCode(): -542976961
Print lrr2 hash code -- lrr2.GetHashCode(): -542976961
Print lrc1 hash code -- lrc1.GetHashCode(): 54267293
Print lrc2 hash code -- lrc2.GetHashCode(): 18643596
LoginResourceRecord implements IEquatable&amp;lt;T&amp;gt;: True
LoginResourceClass  implements IEquatable&amp;lt;T&amp;gt;: False
Print LoginResourceRecord.ToString -- lrr1.ToString(): LoginResourceRecord { Username = Lion-O, Password = jaga, RememberMe = True }
Print LoginResourceClass.ToString -- lrc1.ToString(): LoginResourceClass
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;记录的语法&quot;&gt;记录的语法&lt;/h3&gt;
&lt;p&gt;有多种用于声明记录的模式，用于满足不同场景的使用。在玩过每个模式之后，你开始会对每种模式的好处有一个感性的认识。你还将看到，它们不是不同的语法，而是选项的连续体（continuum of options）。&lt;/p&gt;
&lt;p&gt;第一个模式是最简单的 —— 一行代码 —— 但是提供的灵活性最小，它适用于具有少量必需属性（必需属性，即初始化时必需给作为参数的属性传值）的记录。&lt;/p&gt;
&lt;p&gt;以下用前面展示的 &lt;code&gt;LoginResource&lt;/code&gt; 记录作为此模式的一个示例。就这么简单，一行代码就是整个定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginResource(string Username, string Password, bool RememberMe);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造遵循带参数的构造函数的要求(包括允许使用可选参数)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var login = new LoginResource(&quot;Lion-O&quot;, &quot;jaga&quot;, true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你喜欢，也可以用 target typing：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;LoginResource login = new(&quot;Lion-O&quot;, &quot;jaga&quot;, true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个语法使所有属性都是可选的，为记录提供了一个隐式无参数构造函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginResource
{
    public string Username {get; init;}
    public string Password {get; init;}
    public bool RememberMe {get; init;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用对象初始化构造，可以像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;LoginResource login = new()
{
    Username = &quot;Lion-O&quot;,
    TemperatureC = &quot;jaga&quot;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想让这两个属性成为必需的，而另一个属性是可选的，这最后一个模式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginResource(string Username, string Password)
{
    public bool RememberMe {get; init;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以像下面这样不指定 &lt;code&gt;RememberMe&lt;/code&gt; 构造：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;LoginResource login = new(&quot;Lion-O&quot;, &quot;jaga&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以指定 &lt;code&gt;RememberMe&lt;/code&gt; 构造：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;LoginResource login = new(&quot;Lion-O&quot;, &quot;jaga&quot;)
{
    RememberMe = true
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要认为记录只用于不可变数据。你可以置入公开可变属性，如下面的示例所示，该示例报告了关于电池的信息。&lt;code&gt;Model&lt;/code&gt; 和 &lt;code&gt;TotalCapacityAmpHours&lt;/code&gt; 属性是不可变的，而 &lt;code&gt;RemainingCapacityPercentange&lt;/code&gt; 是可变的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;

Battery battery = new Battery(&quot;CR2032&quot;, 0.235)
{
    RemainingCapacityPercentage = 100
};

Console.WriteLine (battery);

for (int i = battery.RemainingCapacityPercentage; i &amp;gt;= 0; i--)
{
    battery.RemainingCapacityPercentage = i;
}

Console.WriteLine (battery);

public record Battery(string Model, double TotalCapacityAmpHours)
{
    public int RemainingCapacityPercentage {get;set;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它输出如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera recordmutable % dotnet run
Battery { Model = CR2032, TotalCapacityAmpHours = 0.235, RemainingCapacityPercentage = 100 }
Battery { Model = CR2032, TotalCapacityAmpHours = 0.235, RemainingCapacityPercentage = 0 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;无损式记录修改&quot;&gt;无损式记录修改&lt;/h3&gt;
&lt;p&gt;不变性提供了显著的好处，但是您很快就会发现需要对记录进行改变的情况。你怎么能在不放弃不变性的前提下做到这一点呢？&lt;code&gt;with&lt;/code&gt; 表达式满足了这一需求。它支持根据相同类型的现有记录创建新记录。你可以指定你想要的不同的新值，并且从现有记录复制所有其他属性。&lt;/p&gt;
&lt;p&gt;让我们把用户名转换成小写，这是用户名在我们假定的一个用户数据库中的存储方式。但是，为了进行诊断，需要使用原始用户名大小写。假设以前面示例中的代码为例，它可能像下面这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;LoginResource login = new(&quot;Lion-O&quot;, &quot;jaga&quot;, true);
LoginResource loginLowercased = lrr1 with {Username = login.Username.ToLowerInvariant()};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;login&lt;/code&gt; 记录没有被更改，事实上这也是不允许的。转换只影响了 &lt;code&gt;loginLowercased&lt;/code&gt;，除了将小写转换为 loginLowercased 之外，其它与 &lt;code&gt;login&lt;/code&gt; 是相同的。&lt;/p&gt;
&lt;p&gt;我们可以使用内置的 &lt;code&gt;ToString()&lt;/code&gt; 检查 &lt;code&gt;width&lt;/code&gt; 是否完成了预期的工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(login);
Console.WriteLine(loginLowercased);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此代码输出如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;LoginResource { Username = Lion-O, Password = jaga, RememberMe = True }
LoginResource { Username = lion-o, Password = jaga, RememberMe = True }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以进一步了解 &lt;code&gt;with&lt;/code&gt; 是如何工作的，它将所有值从一条记录复制到另一条记录。这不是一个记录依赖于另一个记录的模型。事实上，&lt;code&gt;with&lt;/code&gt; 操作完成后，两个记录之间就没有关系了，只在对记录的构建时有意义。这意味着对于引用类型，副本只是引用的副本；对于值类型，是复制值。&lt;/p&gt;
&lt;p&gt;你可以在下面的代码中看到这种语义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine($&quot;Record equality: {login == loginLowercased}&quot;);
Console.WriteLine($&quot;Property equality: Username == {login.Username == loginLowercased.Username}; Password == {login.Password == loginLowercased.Password}; RememberMe == {login.RememberMe == loginLowercased.RememberMe}&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它输出如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Record equality: False
Property equality: Username == False; Password == True; RememberMe == True
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;记录的实例&quot;&gt;记录的实例&lt;/h3&gt;
&lt;p&gt;对记录进行扩展是很容易的。让我们假设一个新的 LastLoggedIn 属性，它可以直接添加到 LoginResource。那是个好的设想，记录不像传统的接口那样脆弱，除非你想让该新属性在创建时作为构造函数所必需的参数。&lt;/p&gt;
&lt;p&gt;在这个案例中，现在我想使 LastLoggedIn 是必需的。想象一下，代码库非常大，把这个修改反应到所有创建 LoginResource 的地方工作量是巨大的。相反，我们将用这个新属性创建一个扩展 LoginResource 的新 Record。现有代码将在 LoginResource 方面工作，新代码将在新 Record 上工作，然后可以假设 LastLoggedIn 属性已经赋值。根据常规继承规则，接受 LoginResource 的代码将同样轻松地接受新的 Record。&lt;/p&gt;
&lt;p&gt;这个新 Record 可以基于前面演示的任何 LoginResource 变体，它将基于以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginResource(string Username, string Password)
{
    public bool RememberMe {get; init;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的 Record 将是如下这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record LoginWithUserDataResource(string Username, string Password, DateTime LastLoggedIn) : LoginResource(Username, Password)
{
    public int DiscountTier {get; init};
    public bool FreeShipping {get; init};
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我将 LastLoggedIn 设置为一个必需的属性，并利用这个机会添加了附加的且可选的属性，这些属性可能设置也可能没有设置值。通过扩展 LoginResource 记录，还定义了可选的 RememberMe 属性。&lt;/p&gt;
&lt;h3 id=&quot;记录的构造辅助&quot;&gt;记录的构造辅助&lt;/h3&gt;
&lt;p&gt;其中一个不是很直观的模式是建模辅助(modeling helpers)，你希望使用它作为记录构造的一部分（译注：用来辅助创建记录实例）。让我们来换个体重测量的示例。体重的测量用的是一个联网的秤，重量以公斤为单位，但是在某些情况下，体重需要以磅作为单位显示。&lt;/p&gt;
&lt;p&gt;可以使用以下记录声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record WeightMeasurement(DateTime Date, int Kilograms)
{
    public int Pounds {get; init;}

    public static int GetPounds(int kilograms) =&amp;gt; kilograms * 2.20462262;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的构造是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var weight = 200;
WeightMeasurement measurement = new(DateTime.Now, weight)
{
    Pounds = WeightMeasurement.GetPounds(weight)
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本例中，需要说明的是 &lt;code&gt;weight&lt;/code&gt; 是本地变量，不可能在对象初始化器中访问 &lt;code&gt;Kilograms&lt;/code&gt; 属性。也有必要将 &lt;code&gt;GetPounds&lt;/code&gt; 定义为静态方法，因为不可能在对象初始化器中调用实例（它还未构造完成）方法。&lt;/p&gt;
&lt;h3 id=&quot;记录和可空性&quot;&gt;记录和可空性&lt;/h3&gt;
&lt;p&gt;语法上，记录是具有可空性（Nullability）的对吗？既然记录是不可变的，那 null 从何而来呢？如果初始值就是 null，那就一直是 null，这样的数据有什么意义呢？&lt;/p&gt;
&lt;p&gt;让我们来看一个没有使用可空性的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;

Author author = new(null, null);

Console.WriteLine(author.Name.ToString());

public record Author(string Name, List&amp;lt;Book&amp;gt; Books)
{
    public string Website {get; init;}
    public string Genre {get; init;}
    public List&amp;lt;Author&amp;gt; RelatedAuthors {get; init;}
}

public record Book(string name, int Published, Author author);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序编译时将抛出一个 NullReference 异常，因为 &lt;code&gt;author.Name&lt;/code&gt; 是 null（译者疑问：真的是编译时报错而不是运行时报错吗？期待大家亲测）。&lt;/p&gt;
&lt;p&gt;为了更进一步说明这一点，下面的代码无法编译通过，因为 &lt;code&gt;author.Name&lt;/code&gt; 初始值为 null，然后是不能更改的，因为属性是不可变的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Author author = new(null, null);
author.Name = &quot;Colin Meloy&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我要更新我的 project 文件，以启用可空性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;LangVersion&amp;gt;preview&amp;lt;/LangVersion&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我现在看到如下的一堆警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/Users/rich/recordsnullability/Program.cs(8,21): warning CS8618: Non-nullable property 'Website' \n
must contain a non-null value when exiting constructor. Consider declaring the property as \n
nullable. [/Users/rich/recordsnullability/recordsnullability.csproj]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我用我用可空修饰符更新了 &lt;code&gt;Author&lt;/code&gt; 记录，这些可空修饰符描述了我打算如何使用该记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public record Author(string Name, List&amp;lt;Book&amp;gt; Books)
{
    public string? Website {get; init;}
    public string? Genre {get; init;}
    public List&amp;lt;Author&amp;gt;? RelatedAuthors {get; init;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我仍然得到了关于 null 的警告，之前看到的 &lt;code&gt;Author&lt;/code&gt; 的 null 构造。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/Users/rich/recordsnullability/Program.cs(5,21): warning CS8625: Cannot convert null literal \n
to non-nullable reference type. [/Users/rich/recordsnullability/recordsnullability.csproj]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这很好，因为这是我想防止的情况。现在，我将向你展示这个程序的一个更新版本，它很好地利用了可空性的好处。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;


Author lord = new Author(&quot;Karen Lord&quot;)
{
    Website = &quot;https://karenlord.wordpress.com/&quot;,
    RelatedAuthors = new()
};

lord.Books.AddRange(
    new Book[]
    {
        new Book(&quot;The Best of All Possible Worlds&quot;, 2013, lord),
        new Book(&quot;The Galaxy Game&quot;, 2015, lord)
    }
);

lord.RelatedAuthors.AddRange(
    new Author[]
    {
        new (&quot;Nalo Hopkinson&quot;),
        new (&quot;Ursula K. Le Guin&quot;),
        new (&quot;Orson Scott Card&quot;),
        new (&quot;Patrick Rothfuss&quot;)
    }
);

Console.WriteLine($&quot;Author: {lord.Name}&quot;);
Console.WriteLine($&quot;Books: {lord.Books.Count}&quot;);
Console.WriteLine($&quot;Related authors: {lord.RelatedAuthors.Count}&quot;);


public record Author(string Name)
{
    private List&amp;lt;Book&amp;gt; _books = new();

    public List&amp;lt;Book&amp;gt; Books =&amp;gt; _books;

    public string? Website {get; init;}
    public string? Genre {get; init;}
    public List&amp;lt;Author&amp;gt;? RelatedAuthors {get; init;}
}

public record Book(string name, int Published, Author author);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序编译没有出现警告。&lt;/p&gt;
&lt;p&gt;你可能会对下面这句话感到疑惑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;lord.RelatedAuthors.AddRange(
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Author.RelatedAuthors&lt;/code&gt; 可以为空，编译器可以看到 RelatedAuthors 属性是在前面几行设置的，因此它知道 RelatedAuthors 引用是非空的。&lt;/p&gt;
&lt;p&gt;但是，想象一下如果这个程序是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Author GetAuthor()
{
    return new Author(&quot;Karen Lord&quot;)
    {
        Website = &quot;https://karenlord.wordpress.com/&quot;,
        RelatedAuthors = new()
    };
}

Author lord = GetAuthor();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当类型构造在一个单独的方法中时，编译器不能智能地知道 &lt;code&gt;RelatedAuthors&lt;/code&gt; 是非空的。在这种情况下，将需要以下两种模式之一：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;lord.RelatedAuthors!.AddRange(
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;if (lord.RelatedAuthors is object)
{
    lord.RelatedAuthors.AddRange( ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个关于记录可空性的冗长演示，只是想说明它不会改变使用可空引用类型的任何体验。&lt;/p&gt;
&lt;p&gt;另外，您可能已经注意到，我将 &lt;code&gt;Author&lt;/code&gt; 记录上的 &lt;code&gt;Books&lt;/code&gt; 属性改为一个初始化的 get-only 属性，而不是记录构造函数中的一个必需参数。这是因为 &lt;code&gt;Author&lt;/code&gt; 和 &lt;code&gt;Books&lt;/code&gt; 之间存在一种循环关系（译注：&lt;code&gt;Author&lt;/code&gt; 含有&lt;code&gt;List&amp;lt;Book&amp;gt;&lt;/code&gt;类型的导航属性，&lt;code&gt;Book&lt;/code&gt; 也包含 &lt;code&gt;Author&lt;/code&gt; 类型的导航属性）。不变性和循环引用可能会导致头痛。在本例中，这是可以的，只是意味着需要在 Book 对象之前创建所有 Author 对象。因此，不可能在 &lt;code&gt;Author&lt;/code&gt; 构造中提供一组完全初始化好的 Book 对象作为 &lt;code&gt;Author&lt;/code&gt; 构建的一部分，我们所能期待的最好结果就是一个空的 &lt;code&gt;List&amp;lt;Book&amp;gt;&lt;/code&gt;。因此，初始化一个作为 &lt;code&gt;Author&lt;/code&gt; 构建的一部分的空 &lt;code&gt;List&amp;lt;Book&amp;gt;&lt;/code&gt; 似乎是最好的选择。没有规则规定所有这些属性都必须是 &lt;code&gt;init&lt;/code&gt; 的形式，我（示例中）之所以这样做是为了示范。&lt;/p&gt;
&lt;p&gt;我们将转移到 JSON 序列化的话题。这个带有循环引用的示例与稍后将在 JSON 对象图部分中的保存引用有关。&lt;code&gt;JsonSerializer&lt;/code&gt; 支持循环引用的对象图，但不支持带有参数化构造函数的类型。你可以将 Author 对象序列化为 JSON，但不能将其反序列化为当前定义的 Author 对象。如果 Author 不是记录或者没有循环引用，那么序列化和反序列化都可以使用 JsonSerializer。&lt;/p&gt;
&lt;h2 id=&quot;systemtextjson&quot;&gt;System.Text.Json&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.Text.Json&lt;/code&gt; 在 .NET 5.0 中得到了显著的改进，提高了性能和可靠性，并使熟悉 &lt;code&gt;Newtonsoft.Json&lt;/code&gt; 的人更容易采用它。它还&lt;a href=&quot;https://github.com/dotnet/runtime/issues/38539&quot;&gt;支持将 JSON 对象反序列化为记录&lt;/a&gt;，这是本文之前的文章介绍过的 C# 新特性。&lt;/p&gt;
&lt;p&gt;如果你想将 &lt;code&gt;System.Text.Json&lt;/code&gt; 作为 &lt;code&gt;Newtonsoft.Json&lt;/code&gt; 的替代品，可以看这个 &lt;a href=&quot;https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to&quot;&gt;迁移指南&lt;/a&gt;，该指南阐明了这两者 API 之间的关系。&lt;code&gt;System.Text.Json&lt;/code&gt; 旨在涵盖与 &lt;code&gt;Newtonsoft.Json&lt;/code&gt; 相同的大多数场景，但是它并不是用来替代该流行的 Json 库的，也不是为了实现与流行的 Json 库相同的功能。我们试图在性能和可用性之间保持平衡，并在设计选择中偏向于性能。&lt;/p&gt;
&lt;h3 id=&quot;httpclient-扩展方法&quot;&gt;HttpClient 扩展方法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/issues/32937&quot;&gt;JsonSerializer 扩展方法&lt;/a&gt;现在公开到 HttpClient 上了，极大地简化了同时使用这两个 API。这些扩展方法消除了复杂性，并为你处理各种场景，包括处理内容流和验证内容媒体类型。Steve Gordon 很好地解释了&lt;a href=&quot;https://www.stevejgordon.co.uk/sending-and-receiving-json-using-httpclient-with-system-net-http-json&quot;&gt;使用基于 System.Net.Http.Json 的 HttpClient 发送和接收 JSON&lt;/a&gt; 的好处。&lt;/p&gt;
&lt;p&gt;下面的示例使用新的 &lt;code&gt;GetFromJsonAsync&amp;lt;T&amp;gt;()&lt;/code&gt; 扩展方法将天气预报的 JSON 数据反序列化为 &lt;code&gt;Forecast&lt;/code&gt; 记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Net.Http;
using System.Net.Http.Json;

string serviceURL = &quot;https://localhost:5001/WeatherForecast&quot;;
HttpClient client = new();
Forecast[] forecasts = await client.GetFromJsonAsync&amp;lt;Forecast[]&amp;gt;(serviceURL);

foreach(Forecast forecast in forecasts)
{
    Console.WriteLine($&quot;{forecast.Date}; {forecast.TemperatureC}C; {forecast.Summary}&quot;);
}

// {&quot;date&quot;:&quot;2020-09-06T11:31:01.923395-07:00&quot;,&quot;temperatureC&quot;:-1,&quot;temperatureF&quot;:31,&quot;summary&quot;:&quot;Scorching&quot;}
public record Forecast(DateTime Date, int TemperatureC, int TemperatureF, string Summary);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码非常紧凑！它依赖于来自 C# 9 的顶层程序和记录，以及新的 &lt;code&gt;GetFromJsonAsync&amp;lt;T&amp;gt;()&lt;/code&gt; 扩展方法。如此近距离使用 &lt;code&gt;foreach&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 可能会让你怀疑我们是否会&lt;a href=&quot;https://github.com/dotnet/runtime/issues/1570&quot;&gt;添加对 JSON 对象流的支持&lt;/a&gt;。是的，在未来的版本中。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译注：上面作者所说的“近距离”我觉得意思是指反序列化时就近声明需要的记录类型，比单独创建 Model 类放在单独的文件中“近”许多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以在你自己的机器上试试，下面的 .NET SDK 命令将使用 WebAPI 模板创建一个天气预报服务。默认情况下，它的服务 URL 地址是:&lt;a href=&quot;https://localhost:5001/WeatherForecast%EF%BC%8C%E4%B8%8E%E6%9C%AC%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84&quot;&gt;https://localhost:5001/WeatherForecast，与本示例中使用的&lt;/a&gt; URL 相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera ~ % dotnet new webapi -o webapi
rich@thundera ~ % cd webapi
rich@thundera webapi % dotnet run
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先确保你已经运行了 &lt;code&gt;dotnet dev-certs https --trust&lt;/code&gt;，否则客户端和服务器之间的将不能正常握手通讯。如果有问题，请参见 &lt;a href=&quot;https://docs.microsoft.com/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0&amp;amp;tabs=visual-studio#trust-the-aspnet-core-https-development-certificate-on-windows-and-macos&quot;&gt;Trust the ASP.NET Core HTTPS development certificate.&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后你可以运行前面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera ~ % git clone https://gist.github.com/3b41d7496f2d8533b2d88896bd31e764.git weather-forecast
rich@thundera ~ % cd weather-forecast
rich@thundera weather-forecast % dotnet run
9/9/2020 12:09:19 PM; 24C; Chilly
9/10/2020 12:09:19 PM; 54C; Mild
9/11/2020 12:09:19 PM; -2C; Hot
9/12/2020 12:09:19 PM; 24C; Cool
9/13/2020 12:09:19 PM; 45C; Balmy
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改进了对不可变类型的支持&quot;&gt;改进了对不可变类型的支持&lt;/h3&gt;
&lt;p&gt;定义不可变类型有多种模式，记录只是最新的一种（比如下文示例中的一个 Struct 类型），&lt;code&gt;JsonSerializer&lt;/code&gt; 现在支持不可变类型了。&lt;/p&gt;
&lt;p&gt;在本例中，你将看到使用不可变结构类型的序列化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text.Json;
using System.Text.Json.Serialization;

var json = &quot;{\&quot;date\&quot;:\&quot;2020-09-06T11:31:01.923395-07:00\&quot;,\&quot;temperatureC\&quot;:-1,\&quot;temperatureF\&quot;:31,\&quot;summary\&quot;:\&quot;Scorching\&quot;} &quot;;
var options = new JsonSerializerOptions()
{
    PropertyNameCaseInsensitive = true,
    IncludeFields = true,
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
};
var forecast = JsonSerializer.Deserialize&amp;lt;Forecast&amp;gt;(json, options);

Console.WriteLine(forecast.Date);
Console.WriteLine(forecast.TemperatureC);
Console.WriteLine(forecast.TemperatureF);
Console.WriteLine(forecast.Summary);

var roundTrippedJson = JsonSerializer.Serialize&amp;lt;Forecast&amp;gt;(forecast, options);

Console.WriteLine(roundTrippedJson);

public struct Forecast{
    public DateTime Date {get;}
    public int TemperatureC {get;}
    public int TemperatureF {get;}
    public string Summary {get;}
    [JsonConstructor]
    public Forecast(DateTime date, int temperatureC, int temperatureF, string summary) =&amp;gt; (Date, TemperatureC, TemperatureF, Summary) = (date, temperatureC, temperatureF, summary);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;JsonConstructor&lt;/code&gt; 特性需要指定与 struct 一起使用的构造函数。对于类，如果只有一个构造函数，那么该特性就不是必需的，记录也是如此。&lt;/p&gt;
&lt;p&gt;它的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;rich@thundera jsonserializerimmutabletypes % dotnet run
9/6/2020 11:31:01 AM
-1
31
Scorching
{&quot;date&quot;:&quot;2020-09-06T11:31:01.923395-07:00&quot;,&quot;temperatureC&quot;:-1,&quot;temperatureF&quot;:31,&quot;summary&quot;:&quot;Scorching&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支持记录&quot;&gt;支持记录&lt;/h3&gt;
&lt;p&gt;JsonSerializer 对记录的支持几乎与我刚才对不可变类型的支持相同。这里我想展示的不同之处是将一个 JSON 对象反序列化为一个记录，该记录公开一个参数化的构造函数和一个可选的 init 属性。&lt;/p&gt;
&lt;p&gt;下面是一个包含了该记录定义的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text.Json;

Forecast forecast = new(DateTime.Now, 40)
{
    Summary = &quot;Hot!&quot;
};

string forecastJson = JsonSerializer.Serialize&amp;lt;Forecast&amp;gt;(forecast);
Console.WriteLine(forecastJson);
Forecast? forecastObj = JsonSerializer.Deserialize&amp;lt;Forecast&amp;gt;(forecastJson);
Console.Write(forecastObj);

public record Forecast (DateTime Date, int TemperatureC)
{
    public string? Summary {get; init;}
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera jsonserializerrecords % dotnet run
{&quot;Date&quot;:&quot;2020-09-12T18:24:47.053821-07:00&quot;,&quot;TemperatureC&quot;:40,&quot;Summary&quot;:&quot;Hot!&quot;}
Forecast { Date = 9/12/2020 6:24:47 PM, TemperatureC = 40, Summary = Hot! }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改进了-dictionarykv-的支持&quot;&gt;改进了 Dictionary&amp;lt;K,V&amp;gt; 的支持&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;JsonSerializer&lt;/code&gt; 现在&lt;a href=&quot;https://github.com/dotnet/runtime/issues/30618&quot;&gt;支持具有非字符串键的字典&lt;/a&gt;。你可以在下面的示例中看到它的样子。在 .NET Core 3.0 中，这段代码可以编译，但会抛出 NotSupportedException 异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Text.Json;

Dictionary&amp;lt;int, string&amp;gt; numbers = new ()
{
    {0, &quot;zero&quot;},
    {1, &quot;one&quot;},
    {2, &quot;two&quot;},
    {3, &quot;three&quot;},
    {5, &quot;five&quot;},
    {8, &quot;eight&quot;},
    {13, &quot;thirteen&quot;},
    {21, &quot;twenty one&quot;},
    {34, &quot;thirty four&quot;},
    {55, &quot;fifty five&quot;},
};

var json = JsonSerializer.Serialize&amp;lt;Dictionary&amp;lt;int, string&amp;gt;&amp;gt;(numbers);

Console.WriteLine(json);

var dictionary = JsonSerializer.Deserialize&amp;lt;Dictionary&amp;lt;int, string&amp;gt;&amp;gt;(json);

Console.WriteLine(dictionary[55]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera jsondictionarykeys % dotnet run
{&quot;0&quot;:&quot;zero&quot;,&quot;1&quot;:&quot;one&quot;,&quot;2&quot;:&quot;two&quot;,&quot;3&quot;:&quot;three&quot;,&quot;5&quot;:&quot;five&quot;,&quot;8&quot;:&quot;eight&quot;,&quot;13&quot;:&quot;thirteen&quot;,&quot;21&quot;:&quot;twenty one&quot;,&quot;34&quot;:&quot;thirty four&quot;,&quot;55&quot;:&quot;fifty five&quot;}
fifty five
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支持字段&quot;&gt;支持字段&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;JsonSerializer&lt;/code&gt; 现在支持字段，这个变化是由 &lt;a href=&quot;https://github.com/YohDeadfall&quot;&gt;@YohDeadfall&lt;/a&gt; 贡献的，感谢他！&lt;/p&gt;
&lt;p&gt;你可以在下面的示例中看到它的样子，在 .NET Core 3.0 中，&lt;code&gt;JsonSerializer&lt;/code&gt; 无法对使用字段的类型进行序列化或反序列化。对于具有字段且无法更改的现有类型来说，这是个问题，有了这个变化，这个问题就解决了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text.Json;

var json = &quot;{\&quot;date\&quot;:\&quot;2020-09-06T11:31:01.923395-07:00\&quot;,\&quot;temperatureC\&quot;:-1,\&quot;temperatureF\&quot;:31,\&quot;summary\&quot;:\&quot;Scorching\&quot;} &quot;;
var options = new JsonSerializerOptions()
{
    PropertyNameCaseInsensitive = true,
    IncludeFields = true,
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
};
var forecast = JsonSerializer.Deserialize&amp;lt;Forecast&amp;gt;(json, options);

Console.WriteLine(forecast.Date);
Console.WriteLine(forecast.TemperatureC);
Console.WriteLine(forecast.TemperatureF);
Console.WriteLine(forecast.Summary);

var roundTrippedJson = JsonSerializer.Serialize&amp;lt;Forecast&amp;gt;(forecast, options);

Console.WriteLine(roundTrippedJson);

public class Forecast{
    public DateTime Date;
    public int TemperatureC;
    public int TemperatureF;
    public string Summary;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rich@thundera jsonserializerfields % dotnet run
9/6/2020 11:31:01 AM
-1
31
Scorching
{&quot;date&quot;:&quot;2020-09-06T11:31:01.923395-07:00&quot;,&quot;temperatureC&quot;:-1,&quot;temperatureF&quot;:31,&quot;summary&quot;:&quot;Scorching&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;保留-json-对象图中的引用&quot;&gt;保留 JSON 对象图中的引用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;JsonSerializer&lt;/code&gt; 增加了对在 JSON 对象图中保留(循环)引用的支持。它通过存储在将 JSON 字符串反序列化回对象时可以重新构建的 id 来实现这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

Employee janeEmployee = new()
{
    Name = &quot;Jane Doe&quot;,
    YearsEmployed = 10
};

Employee johnEmployee = new()
{
    Name = &quot;John Smith&quot;
};

janeEmployee.Reports = new List&amp;lt;Employee&amp;gt; { johnEmployee };
johnEmployee.Manager = janeEmployee;

JsonSerializerOptions options = new()
{
    // NEW: globally ignore default values when writing null or default
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,
    // NEW: globally allow reading and writing numbers as JSON strings
    NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString,
    // NEW: globally support preserving object references when (de)serializing
    ReferenceHandler = ReferenceHandler.Preserve,
    IncludeFields = true, // NEW: globally include fields for (de)serialization
    WriteIndented = true,};

string serialized = JsonSerializer.Serialize(janeEmployee, options);
Console.WriteLine($&quot;Jane serialized: {serialized}&quot;);

Employee janeDeserialized = JsonSerializer.Deserialize&amp;lt;Employee&amp;gt;(serialized, options);
Console.Write(&quot;Whether Jane's first report's manager is Jane: &quot;);
Console.WriteLine(janeDeserialized.Reports[0].Manager == janeDeserialized);

public class Employee
{
    // NEW: Allows use of non-public property accessor.
    // Can also be used to include fields &quot;per-field&quot;, rather than globally with JsonSerializerOptions.
    [JsonInclude]
    public string Name { get; internal set; }

    public Employee Manager { get; set; }

    public List&amp;lt;Employee&amp;gt; Reports;

    public int YearsEmployed { get; set; }

    // NEW: Always include when (de)serializing regardless of global options
    [JsonIgnore(Condition = JsonIgnoreCondition.Never)]
    public bool IsManager =&amp;gt; Reports?.Count &amp;gt; 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;JsonSerializer&lt;/code&gt; 的性能在 .NET 5.0 中得到了显著提高。Stephen Toub 在他的 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5&quot;&gt;.NET 5 的性能改进&lt;/a&gt; 一文中介绍了一些 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5&quot;&gt;JsonSerializer 的改进&lt;/a&gt;，我将在这里再介绍一些。&lt;/p&gt;
&lt;h4 id=&quot;集合的反序列化&quot;&gt;集合的(反)序列化&lt;/h4&gt;
&lt;p&gt;我们对大型集合做了显著的改进(反序列化时为 1.15x-1.5x，序列化时为 1.5x-2.4x+)。你可以在 &lt;a href=&quot;https://github.com/dotnet/runtime/pull/2259&quot;&gt;dotnet/runtime #2259&lt;/a&gt; 中更详细地看到这些改进。&lt;/p&gt;
&lt;p&gt;与 .NET 5.0 和 .NET Core 3.1 相比，&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; (反)序列化的改进特别令人印象深刻，这些变化将在高性能应用程序中体现出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202009/16001122&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;属性查找--命名约定&quot;&gt;属性查找 —— 命名约定&lt;/h4&gt;
&lt;p&gt;使用 JSON 最常见的问题之一是命名约定与 .NET 设计准则不匹配。JSON 属性通常是 camelCase，.NET 属性和字段通常是 PascalCase。你使用的 JSON 序列化器负责在命名约定之间架桥。这不是轻易就能做到的，至少对 .NET Core 3.1 来说不是。但在 .NET 5.0 中，这种实现成本现在可以忽略不计了。&lt;/p&gt;
&lt;p&gt;允许缺少属性和不区分大小写的代码在 .NET 5.0 中得到了极大的改进，&lt;a href=&quot;https://github.com/dotnet/runtime/pull/35848&quot;&gt;在某些情况下它要快 1.75 倍&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是一个简单的四属性测试类的基准测试，它的属性名为大于 7 字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;3.1 性能
|                            Method |       Mean |   Error |  StdDev |     Median |        Min |        Max |  Gen 0 | Gen 1 | Gen 2 | Allocated |
|---------------------------------- |-----------:|--------:|--------:|-----------:|-----------:|-----------:|-------:|------:|------:|----------:|
| CaseSensitive_Matching            |   844.2 ns | 4.25 ns | 3.55 ns |   844.2 ns |   838.6 ns |   850.6 ns | 0.0342 |     - |     - |     224 B |
| CaseInsensitive_Matching          |   833.3 ns | 3.84 ns | 3.40 ns |   832.6 ns |   829.4 ns |   841.1 ns | 0.0504 |     - |     - |     328 B |
| CaseSensitive_NotMatching(Missing)| 1,007.7 ns | 9.40 ns | 8.79 ns | 1,005.1 ns |   997.3 ns | 1,023.3 ns | 0.0722 |     - |     - |     464 B |
| CaseInsensitive_NotMatching       | 1,405.6 ns | 8.35 ns | 7.40 ns | 1,405.1 ns | 1,397.1 ns | 1,423.6 ns | 0.0626 |     - |     - |     408 B |

5.0 性能
|                            Method |     Mean |   Error |  StdDev |   Median |      Min |      Max |  Gen 0 | Gen 1 | Gen 2 | Allocated |
|---------------------------------- |---------:|--------:|--------:|---------:|---------:|---------:|-------:|------:|------:|----------:|
| CaseSensitive_Matching            | 799.2 ns | 4.59 ns | 4.29 ns | 801.0 ns | 790.5 ns | 803.9 ns | 0.0985 |     - |     - |     632 B |
| CaseInsensitive_Matching          | 789.2 ns | 6.62 ns | 5.53 ns | 790.3 ns | 776.0 ns | 794.4 ns | 0.1004 |     - |     - |     632 B |
| CaseSensitive_NotMatching(Missing)| 479.9 ns | 0.75 ns | 0.59 ns | 479.8 ns | 479.1 ns | 481.0 ns | 0.0059 |     - |     - |      40 B |
| CaseInsensitive_NotMatching       | 783.5 ns | 3.26 ns | 2.89 ns | 783.5 ns | 779.0 ns | 789.2 ns | 0.1004 |     - |     - |     632 B |
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;techempower-改进&quot;&gt;TechEmpower 改进&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;译注：TechEmpower 是一家主要做基准测试的公司，它会定期提供各种 Web 应用程序框架性能指标的测试和比较，覆盖了许多的语言框架，包括 C＃，Go，Python，Java，Ruby，PHP 等。测试基于云和物理硬件，测试的性能则包括纯文本响应、序列化 JSON 对象、单个/多个数据库查询、数据库更新、Fortunes 测试等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在 TechEmpower 基准测试中花费了大量的精力来改进 .NET 的性能。使用 TechEmpower JSON 基准来验证这些 &lt;code&gt;JsonSerializer&lt;/code&gt; 改进是有意义的。现在性能提高了约 19%，一旦我们将条目更新到 .NET 5.0 将提高 .NET 在基准测试中的排行位置。这个版本的目标是与 netty 相比更具竞争力，netty 是常见的 Java Webserver。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/dotnet/runtime/pull/37976&quot;&gt;dotnet/runtime #37976&lt;/a&gt; 中详细介绍了这些更改和性能度量。这里有两套基准，第一个是使用团队维护的 &lt;code&gt;JsonSerializer&lt;/code&gt; 性能基准测试来验证性能。观察到有约 8% 的改善；第二个是 TechEmpower 的，它测量了满足 TechEmpower JSON 基准测试要求的三种不同方法。我们在&lt;a href=&quot;https://github.com/aspnet/Benchmarks/blob/4e58073ac06642b34c25119c73ef22932c1ece64/src/BenchmarksApps/Kestrel/PlatformBenchmarks/BenchmarkApplication.Json.cs#L29-L33&quot;&gt;官方基准测试&lt;/a&gt;中使用的是&lt;code&gt;SerializeWithCachedBufferAndWriter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202009/16005120&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们看一下 Min 列，我们可以做一些简单的数学计算：&lt;code&gt;153.3/128.6 = ~1.19&lt;/code&gt;，有了 19% 的提升。&lt;/p&gt;
&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;我希望你喜欢本文对记录和 &lt;code&gt;JsonSerializer&lt;/code&gt; 的深入介绍，它们只是 .NET 5.0 众多改进中的两个。这篇&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-8/&quot;&gt;预览 8 的文章&lt;/a&gt;涵盖了更多的新特性，这为 5.0 的价值提供了更广阔的视角。&lt;/p&gt;
&lt;p&gt;正如你所知道的，我们目前阶段没有在 .NET 5.0 中继续添加新特性了。我利用后面的预览和 RC 版本发布的文章来涵盖我们已经添加的所有功能的介绍。你希望我在 RC2 发布的博客文章中介绍哪些内容？我想从你们那知道我应该关注什么。&lt;/p&gt;
&lt;p&gt;请在评论中分享你使用 RC1 的体验，感谢所有安装了 .NET 5.0 的人，我们感谢到目前为止我们收到的所有参与和反馈。&lt;/p&gt;
</description>
<pubDate>Tue, 15 Sep 2020 23:45:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>原文：http://dwz.win/Qf8 作者：Richard 翻译：精致码农-王亮 说明：本文有不少超链接，由于微信公众号和头条平台外链会被剔除 URL 地址，所以原来本是超链接的内容会显示为纯文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13677079.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】路由堆栈详解 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13677072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13677072.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073451063-89853048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：Flutter中路由是非常重要的部分，任何一个应用程序都离不开路由管理，此文讲解路由相关方法的使用和&lt;strong&gt;路由堆栈&lt;/strong&gt;的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flutter 路由管理中有两个非常重要的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Route&lt;/strong&gt;：路由是应用程序&lt;strong&gt;页面&lt;/strong&gt;的抽象，对应 Android 中 Activity 和 iOS 中的 ViewController，由 Navigator 管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Navigator&lt;/strong&gt;：Navigator 是一个组件，管理和维护一个基于&lt;strong&gt;堆栈&lt;/strong&gt;的历史记录，通过 push 和 pop 进行页面的跳转。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;push-和-pop&quot;&gt;push 和 pop&lt;/h4&gt;
&lt;p&gt;假设现在有2个页面 A 和 B，A中有一个按钮，点击跳转到 B 页面，A 页面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class APage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      child: RaisedButton(
        child: Text('A 页面'),
        onPressed: () {
          Navigator.of(context).push(MaterialPageRoute(builder: (context) {
            return BPage();
          }));
        },
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B 页面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class BPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        alignment: Alignment.center,
        child: RaisedButton(
          child: Text('B 页面'),
          onPressed: () {

          },
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073451506-810717733.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当应用程序位于A页面时，&lt;strong&gt;路由堆栈&lt;/strong&gt;中只有A，点击按钮跳转到B页面，路由堆栈中有 B 和 A，且 B 处于栈顶。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073451685-2025256525.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 B 页面的按钮返回到 A 页面，修改 B 页面按钮点击事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('B 页面'),
  onPressed: () {
    Navigator.of(context).pop();
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由堆栈的变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073451872-1533537610.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面案例的效果是从 B 页面跳转到 A 页面，那是否也可以使用 push 方法？修改 B 页面按钮点击事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('B 页面'),
  onPressed: () {
    Navigator.of(context).push(MaterialPageRoute(builder: (context) {
      return APage();
    }));
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从效果上看也可以跳转到 A 页面，路由堆栈：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452074-57038397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那是否可以使用 push 代替 pop 呢？&lt;/strong&gt; 答案肯定是不可以的，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;试想如下场景，进入购物App，展示购物列表，点击其中一个进入商品详细页面，使用 push 再次进入购物列表，然后在进入商品详细页面...，如此反复，路由堆栈中将会存放大量的购物列表和商品详细页面的路由，点击返回按钮，会将反复显示购物列表和商品详细页面。&lt;/li&gt;
&lt;li&gt;页面切换时路由动画 push 和 pop 是不同。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;maybepop-和-canpop&quot;&gt;maybePop 和 canPop&lt;/h4&gt;
&lt;p&gt;上面案例如果点击 A 页面按钮直接调用 pop 会如何？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('A 页面'),
  onPressed: () {
    Navigator.of(context).pop();
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 A 页面时路由堆栈中只有 A，调用 pop 后，路由堆栈变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452208-1992480782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时路由堆栈为空，没有可显示的页面，应用程序将会退出或者黑屏，好的用户体验不应如此，此时可以使用 maybePop，maybePop 只在路由堆栈有可弹出路由时才会弹出路由。&lt;/p&gt;
&lt;p&gt;上面的案例在 A 页面执行maybePop：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('A 页面'),
  onPressed: () {
    Navigator.of(context).maybePop();
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击后不会出现弹出路由，因为当前路由堆栈中只有 A，在 B页面执行maybePop，将会返回到 A 页面。&lt;/p&gt;
&lt;p&gt;也可以通过 canPop 判断当前是否可以 pop：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('B 页面'),
  onPressed: () {
    if(Navigator.of(context).canPop()){
      Navigator.of(context).pop();
    }
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pushnamed&quot;&gt;pushNamed&lt;/h4&gt;
&lt;p&gt;pushNamed 是命名路由的方式，需要在 MaterialApp 中配置路由名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
      title: 'Flutter Demo',
      routes: &amp;lt;String, WidgetBuilder&amp;gt;{
        '/A': (context) =&amp;gt; APage(),
        '/B': (context) =&amp;gt; BPage(),
      },
      home: Scaffold(
        body: APage(),
      ),
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 A 跳转到 B：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('A 页面'),
  onPressed: () {
    Navigator.of(context).pushNamed('/B');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pushreplacementnamed-和-popandpushnamed&quot;&gt;pushReplacementNamed 和 popAndPushNamed&lt;/h4&gt;
&lt;p&gt;有A、B、C 三个页面，A页面通过 pushNamed 跳转到 B：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('A 页面'),
  onPressed: () {
    Navigator.of(context).pushNamed('/B');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B 通过 pushReplacementNamed 跳转到 C：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('B 页面'),
  onPressed: () {
      Navigator.of(context).pushReplacementNamed('/C');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击 C 页面按钮执行 pop：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('C 页面'),
  onPressed: () {
    if(Navigator.of(context).canPop()){
      Navigator.of(context).pop();
    }
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452409-998482628.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 C 页面按钮直接返回到了 A 页面，而不是 B 页面，因为 B 页面使用 pushReplacementNamed 跳转，路由堆栈变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452595-1311629080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B 页面跳转到 C 页面，使用 popAndPushNamed：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('B 页面'),
  onPressed: () {
      Navigator.of(context).popAndPushNamed('/C');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;popAndPushNamed 路由堆栈和 pushReplacementNamed 是一样，唯一的区别就是 popAndPushNamed 有 B 页面退出动画。&lt;/p&gt;
&lt;p&gt;popAndPushNamed 和 pushReplacementNamed 使当前页面不在路由堆栈中，所以通过 pop 无法返回此页面。&lt;/p&gt;
&lt;p&gt;适用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;欢迎页面&lt;/strong&gt;：应用程序打开后首先进入欢迎界面，然后进入首页，进入首页后不应该再进入欢迎界面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;登录页面&lt;/strong&gt;：登录成功后进入相关页面，此时按返回按钮，不应再进入登录页面。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;pushnamedandremoveuntil&quot;&gt;pushNamedAndRemoveUntil&lt;/h4&gt;
&lt;p&gt;有如下场景，应用程序进入首页，点击登录进入登录页面，然后进入注册页面或者忘记密码页面...，登录成功后进入其他页面，此时不希望返回到登录相关页面，此场景可以使用 pushNamedAndRemoveUntil。&lt;/p&gt;
&lt;p&gt;有A、B、C、D 四个页面，A 通过push进入 B 页面，B 通过push进入 C 页面，C 通过 &lt;strong&gt;pushNamedAndRemoveUntil&lt;/strong&gt; 进入 D 页面同时删除路由堆栈中直到 /B 的路由，C 页面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('C 页面'),
  onPressed: () {
    Navigator.of(context).pushNamedAndRemoveUntil('/D', ModalRoute.withName('/B'));
  },
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;D 页面按钮执行 pop：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('D 页面'),
  onPressed: () {
    Navigator.of(context).pop();
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452816-259499635.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 C 页面跳转到 D 页面路由堆栈变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073452999-1468461008.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.of(context).pushNamedAndRemoveUntil('/D', ModalRoute.withName('/B'));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示跳转到 D 页面，同时删除D 到 B 直接所有的路由，如果删除所有路由，只保存 D：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.of(context).pushNamedAndRemoveUntil('/D', (Route route)=&amp;gt;false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由堆栈变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073453144-1283311345.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;popuntil&quot;&gt;popUntil&lt;/h4&gt;
&lt;p&gt;有如下场景，在入职新公司的时候，需要填写各种信息，这些信息分为不同部分，比如基本信息、工作信息、家庭信息等，这些不同模块在不同页面，填写信息时可以返回上一页，也可以取消，取消返回到首页，此场景可以使用 popUntil，一直 pop 到指定的页面。&lt;/p&gt;
&lt;p&gt;有A、B、C、D 四个页面，D 页面通过 popUntil 一直返回到 A 页面，D 页面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('D 页面'),
  onPressed: () {
    Navigator.of(context).popUntil(ModalRoute.withName('/A'));
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073453379-1160132852.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路由堆栈变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073453856-804663179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;传递数据&quot;&gt;传递数据&lt;/h4&gt;
&lt;p&gt;有如下场景，商品列表页面，点击跳转到商品详情页面，商品详情页面需要商品的唯一id或者商品详情数据，有两种方式传递数据：&lt;/p&gt;
&lt;p&gt;第一种：通过构造函数方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class ProductDetail extends StatelessWidget {
  final ProductInfo productInfo;

  const ProductDetail({Key key, this.productInfo}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跳转代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.of(context).push(MaterialPageRoute(builder: (context){
  return ProductDetail(productInfo: productInfo,);
}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此种方式无法用于命名路由的跳转方式。&lt;/p&gt;
&lt;p&gt;第二种：通过命名路由设置参数的方式：&lt;/p&gt;
&lt;p&gt;A 页面传递数据，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('A 页面'),
  onPressed: () {
    Navigator.of(context).pushNamed('/B',arguments: '来自A');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B 页面通过 &lt;code&gt;ModalRoute.of(context).settings.arguments&lt;/code&gt; 接收数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('${ModalRoute.of(context).settings.arguments}'),
  onPressed: () {
    Navigator.of(context).pushNamed('/C');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073454041-1053537826.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;返回数据&quot;&gt;返回数据&lt;/h4&gt;
&lt;p&gt;B 页面返回代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('${ModalRoute.of(context).settings.arguments}'),
  onPressed: () {
    Navigator.of(context).pop('从B返回');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A 页面接收返回的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class APage extends StatefulWidget {
  @override
  _APageState createState() =&amp;gt; _APageState();
}

class _APageState extends State&amp;lt;APage&amp;gt; {
  String _string = 'A 页面';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        alignment: Alignment.center,
        child: RaisedButton(
          child: Text(_string),
          onPressed: () async {
            var result =
                await Navigator.of(context).pushNamed('/B', arguments: '来自A');
            setState(() {
              _string = result;
            });
          },
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073454260-13846909.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;push 相关方法返回 Future 类型，使用 await 等待返回结果。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;h2 id=&quot;交流-2&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073454534-1852376129.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200916073455193-1584822587.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 15 Sep 2020 23:35:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Flutter中路由是非常重要的部分，任何一个应用程序都离不开路由管理，此文讲解路由相关方法的使用和路由堆栈的变化。 Flutter 路由管理中有两个非常重要的概念： Route：路由是应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13677072.html</dc:identifier>
</item>
<item>
<title>vue-element-admin实战 | 第二篇： 最小改动接入后台实现根据权限动态加载菜单 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/13676619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/13676619.html</guid>
<description>&lt;p&gt;本篇基于 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot;&gt;有来商城 youlai-mall&lt;/a&gt; 微服务项目,通过对vue-element-admin的权限菜单模块理解个性定制其后台接口，实现对vue-element-admin工程几乎不做改动的情况下，无缝接入后台接口实现动态权限菜单的加载。&lt;/p&gt;
&lt;p&gt;在进行接下来的工作前，我们需要对原生的vue-element-admin项目改造，移除mock连通后台接口，具体可参考我这篇文章 &lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13624548.html&quot;&gt;vue-element-admin实战 | 第一篇： 移除mock接入后台，搭建有来商城youlai-mall前后端分离管理平台&lt;/a&gt;，如果在过程中有遇到问题，欢迎下方留言。&lt;/p&gt;

&lt;p&gt;至于上文提到的对vue-element-admin几乎不做改动便可实现我们此篇文章的目的是不是我在扯，决定权给各位，我把对vue-element-admin项目改动的地方通过比对工具比对截图放上来。&lt;/p&gt;
&lt;p&gt;先声明vue-element-admin此次改动的地方除了一个获取权限菜单的接口之外，剩余的改动全在 src/store/modules/permission.js 文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/15/GMUZn5PeIcxAihT.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到了吗，可以说仅对vue-element-admin做两处改动，再加上对getRoutes调用后台接口返回的菜单数据的分析，就可以理解和实现动态权限菜单的加载了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改动代码片段 + 注释说明&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; import {list as getRoutes} from '@/api/admin/menu'
 import Layout from '@/layout'
   
 generateRoutes({commit}, roles) {
   return new Promise(resolve =&amp;gt; {
     // 请求后台数据替换src/router/index.js的asyncRoutes异步路由
     getRoutes({mode: 3}).then(response =&amp;gt; {
       // filterAsyncRoutes方法作权限过滤和数据转换，roles为登录用户角色ID集合，如：[1,2]
       let accessedRoutes = filterAsyncRoutes(response.data, roles)
       commit('SET_ROUTES', accessedRoutes)
       resolve(accessedRoutes)
     })
   })
 }
 
 // 递归权限过滤和数据转换
 export function filterAsyncRoutes(routes, roles) {
    const res = []
    routes.forEach(route =&amp;gt; {
      const tmp = {...route}
      if (hasPermission(roles, tmp)) {
        const component = tmp.component
        if (route.component) {
          if (component == 'Layout') {
            tmp.component = Layout
          } else {
            // 接口组件字符串转换成组件对象
            tmp.component = (resolve) =&amp;gt; require([`@/views/${component}`], resolve)
          }
          if (tmp.children) {
            tmp.children = filterAsyncRoutes(tmp.children, roles)
          }
        }
        res.push(tmp)
      }
    })
    return res
 } 
  
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-接口数据分析&quot;&gt;&lt;strong&gt;1. 接口数据分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;接下来通过后台接口替换配置在src/router/index.js文件中asyncRoutes异步路由。&lt;/p&gt;
&lt;p&gt;首先分析下异步路由的数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/15/dM98TmKostBf5zR.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对上图异步路由的数据观察和了解，得出以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;path在子路由中前面没有反斜杠'/'&lt;/li&gt;
&lt;li&gt;根菜单的alwaysShow为true&lt;/li&gt;
&lt;li&gt;component组件需通过import完成编译时导入，接口只能返回组件路径字符串，所以这里在接口请求完成后必须有一个组件路径字符串到组件对象的转换过程&lt;/li&gt;
&lt;li&gt;meta的roles属性对应的是有该路由访问权限角色唯一标识的集合，这里我使用的是角色ID&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-接口实现&quot;&gt;&lt;strong&gt;2. 接口实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;完成以上的数据分析，接下来就是接口的具体实现了，有关SQL和完整代码请点击 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot;&gt;有来商城 youlai-mall&lt;/a&gt; 拉取即可，以下仅仅贴出关键代码和分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SysMenuMapper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取菜单列表和对应访问权限的角色ID的集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/GVJ4n8rxIkWO3fi.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SysMenuServiceImpl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将菜单转换成路由，递归生成父子结构树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/GUJXr59iP7vOFzI.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SysMenuController&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;REST对外提供接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/JNP9wCUYb6yRF7k.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-接口测试&quot;&gt;&lt;strong&gt;3. 接口测试&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用接口测试工具测试， &lt;a href=&quot;http://localhost:9999/youlai-admin/menus?mode=3&quot;&gt;http://localhost:9999/youlai-admin/menus?mode=3&lt;/a&gt; ，这里通过网关方式访问，详情请知悉&lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot;&gt;有来商城 youlai-mall&lt;/a&gt; 项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/PYgeyuFOCpt9Kk2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整返回数据，看看是不是很匹配asyncRoutes异步路由的数据格式了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;code&quot;: &quot;00000&quot;,
    &quot;data&quot;: [{
        &quot;path&quot;: &quot;/admin&quot;,
        &quot;component&quot;: &quot;Layout&quot;,
        &quot;alwaysShow&quot;: true,
        &quot;name&quot;: &quot;系统管理&quot;,
        &quot;meta&quot;: {
            &quot;title&quot;: &quot;系统管理&quot;,
            &quot;icon&quot;: &quot;documentation&quot;,
            &quot;roles&quot;: [2, 1]
        },
        &quot;children&quot;: [{
            &quot;path&quot;: &quot;user&quot;,
            &quot;component&quot;: &quot;admin/user&quot;,
            &quot;alwaysShow&quot;: false,
            &quot;name&quot;: &quot;用户管理&quot;,
            &quot;meta&quot;: {
                &quot;title&quot;: &quot;用户管理&quot;,
                &quot;icon&quot;: &quot;user&quot;,
                &quot;roles&quot;: [1]
            }
        }, {
            &quot;path&quot;: &quot;role&quot;,
            &quot;component&quot;: &quot;admin/role&quot;,
            &quot;alwaysShow&quot;: false,
            &quot;name&quot;: &quot;角色管理&quot;,
            &quot;meta&quot;: {
                &quot;title&quot;: &quot;角色管理&quot;,
                &quot;icon&quot;: &quot;peoples&quot;,
                &quot;roles&quot;: [2, 1]
            }
        }, {
            &quot;path&quot;: &quot;dept&quot;,
            &quot;component&quot;: &quot;admin/dept&quot;,
            &quot;alwaysShow&quot;: false,
            &quot;name&quot;: &quot;部门管理&quot;,
            &quot;meta&quot;: {
                &quot;title&quot;: &quot;部门管理&quot;,
                &quot;icon&quot;: &quot;tree&quot;,
                &quot;roles&quot;: [1, 2]
            }
        }, {
            &quot;path&quot;: &quot;menu&quot;,
            &quot;component&quot;: &quot;admin/menu&quot;,
            &quot;alwaysShow&quot;: false,
            &quot;name&quot;: &quot;菜单管理&quot;,
            &quot;meta&quot;: {
                &quot;title&quot;: &quot;菜单管理&quot;,
                &quot;icon&quot;: &quot;tree-table&quot;,
                &quot;roles&quot;: [1, 2]
            }
        }, {
            &quot;path&quot;: &quot;dict&quot;,
            &quot;component&quot;: &quot;admin/dict&quot;,
            &quot;alwaysShow&quot;: false,
            &quot;name&quot;: &quot;字典管理&quot;,
            &quot;meta&quot;: {
                &quot;title&quot;: &quot;字典管理&quot;,
                &quot;icon&quot;: &quot;education&quot;,
                &quot;roles&quot;: [1, 2]
            }
        }]
    }],
    &quot;msg&quot;: &quot;一切ok&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后要做的就是将组件(component)路径字符串转换成组件对象即可，再次贴出在上文permission.js改造的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; if (component == 'Layout') {
    tmp.component = Layout
  } else {
    // 接口组件字符串转换成组件对象
    tmp.component = (resolve) =&amp;gt; require([`@/views/${component}`], resolve)
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一点需要注意的是上面组件动态导入不能使用import，如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; tmp.component = () =&amp;gt; import(`@/views/${component}`)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不然会报以下错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error: Cannot find module '@/views/***'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是webpack不支持import动态导入了，但是之前确实是可以的，所以有些让人想不通，这里使用require动态导入组件即可。&lt;/p&gt;
&lt;h3 id=&quot;4-菜单权限测试&quot;&gt;&lt;strong&gt;4. 菜单权限测试&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;参看当前用户拥有的角色ID为2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/yzKv1rpJGAORHte.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户管理要求只有角色ID为1才能有其访问权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/nXpj6TfF4zbBV9o.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试下用户登录控制台能否看到“用户管理”菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/09/16/pSB98iFPwD6tv3T.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么样，只拥有角色ID为2的角色是看不到需要角色ID为1才能访问的“用户管理”菜单的，也就证明了我们成功通过接入后台接口实现了权限菜单的动态加载的目的。&lt;/p&gt;

&lt;p&gt;其实有个问题值得去思考下的。为什么我们在从后台获取全部菜单列表的时候需要关联查询出有对应访问权限的角色ID的集合，而不是说动态传入当前登录用户的信息去查询该用户拥有的菜单集合呢？这其实是两种实现方式，区别在于第一种每个用户都要获取全部菜单数据，而第二种方式针对每个用户加载其拥有权限的菜单数据。单看的话第二种方式肯定优于第一种，但这里我们选用的是第一种加载全部菜单数据。如果你结合缓存去看的话自然就想的通了，所有用户共享缓存的同一份菜单数据，还是说缓存针对每个用户存放一份菜单缓存又或者用户每次都去请求数据库。后面计划把菜单数据存放到缓存Redis中然后做一个分析比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附完整代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;有来商城后端：youlai-mall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin-web.git&quot;&gt;有来商城前端：youlai-mall-admin-web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写了这么多其实也是想给自己的项目打个广告，更希望对大家有所帮助，对于技术人来说少走弯路真的很重要，喜欢的朋友给个star，对我来说这份帮助更是自己继续下去的动力，所以谢谢了。有啥问题下方留言，或直接联系我（微信号：haoxianrui）。&lt;/p&gt;
</description>
<pubDate>Tue, 15 Sep 2020 17:58:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>一. 前言 本篇基于 有来商城 youlai-mall 微服务项目,通过对vue-element-admin的权限菜单模块理解个性定制其后台接口，实现对vue-element-admin工程几乎不做改</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/13676619.html</dc:identifier>
</item>
<item>
<title>用价值链分析软件开发及杂感 - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13676593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13676593.html</guid>
<description>&lt;h2 id=&quot;一、波特价值链分析模型简介&quot;&gt;一、波特价值链分析模型简介&lt;/h2&gt;
&lt;p&gt;价值链模型是由美国战略学家&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E8%BF%88%E5%85%8B%E5%B0%94%C2%B7%E6%B3%A2%E7%89%B9&quot;&gt;迈克尔.波特&lt;/a&gt;提出的“&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E4%BB%B7%E5%80%BC%E9%93%BE%E5%88%86%E6%9E%90%E6%B3%95&quot;&gt;价值链分析法&lt;/a&gt;”，把企业内外价值增值的活动分为基本活动和支持性活动，基本活动涉及生成、销售、进料后勤、发货后勤、售后服务。支持性的活动涉及人事、财务、计划、研究与开发。采购等，基本活动和支持性活动构成了企业的价值链。&lt;br/&gt;不同的企业参与的价值活动中，并不是每个环节都创造价值，实际上只有某些特定的价值活动才真正创造价值，这些真正创造价值的经营活动，就是价值链上的“战略环节”。&lt;br/&gt;企业要保持的竞争优势，实际上就是企业在价值链某些特定的战略环节上的优势。所以运用价值链的分析方法来确定企业核心竞争力，就是要求企业密切关注组织的资源状态，要求企业特别关注和培养在价值链的关键环节上获得重要的核心竞争力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200916005941330-556666276.png&quot; alt=&quot;企业基本价值链图&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;企业基本价值链图&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;迈克尔.波特 著的 《竞争优势》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、需求产品研发价值链条&quot;&gt;二、需求产品研发价值链条&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200916010002553-636720045.png&quot; alt=&quot;需求产品研发价值链条图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需求产品研发价值链条图&lt;/p&gt;
&lt;p&gt;第一是洞悉市场需求，然后进行业务分析，需求分析&lt;br/&gt;第二需求分析之后，进行产品设计&lt;br/&gt;第三研发开发产品&lt;br/&gt;第四提供产品服务，同时运营，营销，销售，来满足用户需求。&lt;/p&gt;
&lt;p&gt;然后不断获取用户反馈，形成新的用户需求，根据需求进行产品迭代，研发进行开发，来不断的满足用户需求。&lt;br/&gt;这一过程，不断循环往复，只到产品衰落，新的产品诞生为止。&lt;/p&gt;
&lt;h2 id=&quot;三、研发&quot;&gt;三、研发&lt;/h2&gt;
&lt;p&gt;从上面的需求产品研发价值链条图来看，研发开发产品这个环节，只是整个产品价值链上的一个环节。它的前后还涉及多个环节。&lt;br/&gt;所以只有前后链相互协作，才能完成一个完整的产品。最后，要使产品产生商业价值，还需要营销，运营，销售，来配合，才能发挥产品的最大价值。&lt;/p&gt;
&lt;h2 id=&quot;四、创业&quot;&gt;四、创业&lt;/h2&gt;
&lt;p&gt;技术人员创业，最大的优势是技术，最大的劣势也往往只有技术。&lt;/p&gt;
&lt;p&gt;怎么理解？&lt;br/&gt;因为你是技术人，一直从事技术开发相关的工作，所以对技术比较熟悉。然后就想当然的认为，自己拥有技术，创业就可以“成功”。&lt;br/&gt;但是，现实往往是残酷的。你被技术蒙蔽了“双眼”，恰恰是技术限制了你的眼界，技术让你坐井观天。&lt;/p&gt;
&lt;p&gt;分析原因：&lt;br/&gt;从上面的产品开发价值链条图看，如果你是创业，为用户/客户做一款完整的产品，不单单只需要技术，至少还需要做到以下几点：&lt;/p&gt;
&lt;p&gt;1、你的产品是别人需要的吗？（市场和需求分析）&lt;br/&gt;2、产品卖给谁/给谁用？（用户/客户分析，他们在哪儿？）&lt;br/&gt;3、通过谁来卖？(销售或者其他方式)&lt;br/&gt;4、更多用户/客户了解产品的价值，进而获客（营销宣传）&lt;/p&gt;
&lt;p&gt;所以，创业，它是一个系统工程，不单单涉及技术这一件事儿，这是一个重要的认知。也是技术创业者一开始创业时最大的一个思维误区。&lt;/p&gt;
&lt;h2 id=&quot;五、技术赋能&quot;&gt;五、技术赋能&lt;/h2&gt;
&lt;p&gt;技术怎么赋能？&lt;br/&gt;可以从开发产品的上下价值链去找对应的链条，它的上游下游。&lt;br/&gt;比如上游，你去了解业务，产品，思考怎么用技术给他们提供最大价值。&lt;br/&gt;比如下游，营销，运营，怎么切入进去，从哪方面做？才能更好给他们提供服务。&lt;br/&gt;都是可以思考，研究。&lt;/p&gt;
&lt;h2 id=&quot;六、参考&quot;&gt;六、参考&lt;/h2&gt;
</description>
<pubDate>Tue, 15 Sep 2020 17:05:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>一、波特价值链分析模型简介 价值链模型是由美国战略学家迈克尔.波特提出的“价值链分析法”，把企业内外价值增值的活动分为基本活动和支持性活动，基本活动涉及生成、销售、进料后勤、发货后勤、售后服务。支持性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13676593.html</dc:identifier>
</item>
</channel>
</rss>