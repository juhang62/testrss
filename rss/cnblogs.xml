<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Scala 系列（十三）—— 隐式转换和隐式参数 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11565848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11565848.html</guid>
<description>&lt;h2 id=&quot;一隐式转换&quot;&gt;一、隐式转换&lt;/h2&gt;
&lt;h3 id=&quot;使用隐式转换&quot;&gt;1.1 使用隐式转换&lt;/h3&gt;
&lt;p&gt;隐式转换指的是以&lt;code&gt;implicit&lt;/code&gt;关键字声明带有单个参数的转换函数，它将值从一种类型转换为另一种类型，以便使用之前类型所没有的功能。示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 普通人
class Person(val name: String)

// 雷神
class Thor(val name: String) {
  // 正常情况下只有雷神才能举起雷神之锤
  def hammer(): Unit = {
    println(name + &quot;举起雷神之锤&quot;)
  }
}

object Thor extends App {
  // 定义隐式转换方法 将普通人转换为雷神 通常建议方法名使用source2Target,即：被转换对象To转换对象
  implicit def person2Thor(p: Person): Thor = new Thor(p.name)
  // 这样普通人也能举起雷神之锤
  new Person(&quot;普通人&quot;).hammer()
}

输出： 普通人举起雷神之锤&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;隐式转换规则&quot;&gt;1.2 隐式转换规则&lt;/h3&gt;
&lt;p&gt;并不是你使用&lt;code&gt;implicit&lt;/code&gt;转换后，隐式转换就一定会发生，比如上面如果不调用&lt;code&gt;hammer()&lt;/code&gt;方法的时候，普通人就还是普通人。通常程序会在以下情况下尝试执行隐式转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当对象访问一个不存在的成员时，即调用的方法不存在或者访问的成员变量不存在；&lt;/li&gt;
&lt;li&gt;当对象调用某个方法，该方法存在，但是方法的声明参数与传入参数不匹配时。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而在以下三种情况下编译器不会尝试执行隐式转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果代码能够在不使用隐式转换的前提下通过编译，则不会使用隐式转换；&lt;/li&gt;
&lt;li&gt;编译器不会尝试同时执行多个转换，比如&lt;code&gt;convert1(convert2(a))*b&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;转换存在二义性，也不会发生转换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里首先解释一下二义性，上面的代码进行如下修改，由于两个隐式转换都是生效的，所以就存在了二义性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//两个隐式转换都是有效的
implicit def person2Thor(p: Person): Thor = new Thor(p.name)
implicit def person2Thor2(p: Person): Thor = new Thor(p.name)
// 此时下面这段语句无法通过编译
new Person(&quot;普通人&quot;).hammer()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次再解释一下多个转换的问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ClassA {
  override def toString = &quot;This is Class A&quot;
}

class ClassB {
  override def toString = &quot;This is Class B&quot;
  def printB(b: ClassB): Unit = println(b)
}

class ClassC

class ClassD

object ImplicitTest extends App {
  implicit def A2B(a: ClassA): ClassB = {
    println(&quot;A2B&quot;)
    new ClassB
  }

  implicit def C2B(c: ClassC): ClassB = {
    println(&quot;C2B&quot;)
    new ClassB
  }

  implicit def D2C(d: ClassD): ClassC = {
    println(&quot;D2C&quot;)
    new ClassC
  }

  // 这行代码无法通过编译，因为要调用到printB方法，需要执行两次转换C2B(D2C(ClassD))
  new ClassD().printB(new ClassA)
    
  /*
   *  下面的这一行代码虽然也进行了两次隐式转换，但是两次的转换对象并不是一个对象,所以它是生效的:
   *  转换流程如下:
   *  1. ClassC中并没有printB方法,因此隐式转换为ClassB,然后调用printB方法;
   *  2. 但是printB参数类型为ClassB,然而传入的参数类型是ClassA,所以需要将参数ClassA转换为ClassB,这是第二次;
   *  即: C2B(ClassC) -&amp;gt; ClassB.printB(ClassA) -&amp;gt; ClassB.printB(A2B(ClassA)) -&amp;gt; ClassB.printB(ClassB)
   *  转换过程1的对象是ClassC,而转换过程2的转换对象是ClassA,所以虽然是一行代码两次转换，但是仍然是有效转换
   */
  new ClassC().printB(new ClassA)
}

// 输出：
C2B
A2B
This is Class B&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;引入隐式转换&quot;&gt;1.3 引入隐式转换&lt;/h3&gt;
&lt;p&gt;隐式转换的可以定义在以下三个地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义在原类型的伴生对象中；&lt;/li&gt;
&lt;li&gt;直接定义在执行代码的上下文作用域中；&lt;/li&gt;
&lt;li&gt;统一定义在一个文件中，在使用时候导入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面我们使用的方法相当于直接定义在执行代码的作用域中，下面分别给出其他两种定义的代码示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义在原类型的伴生对象中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Person(val name: String)
// 在伴生对象中定义隐式转换函数
object Person{
  implicit def person2Thor(p: Person): Thor = new Thor(p.name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Thor(val name: String) {
  def hammer(): Unit = {
    println(name + &quot;举起雷神之锤&quot;)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用示例
object ScalaApp extends App {
  new Person(&quot;普通人&quot;).hammer()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义在一个公共的对象中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object Convert {
  implicit def person2Thor(p: Person): Thor = new Thor(p.name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 导入Convert下所有的隐式转换函数
import com.heibaiying.Convert._

object ScalaApp extends App {
  new Person(&quot;普通人&quot;).hammer()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：Scala自身的隐式转换函数大部分定义在&lt;code&gt;Predef.scala&lt;/code&gt;中，你可以打开源文件查看，也可以在Scala交互式命令行中采用&lt;code&gt;:implicit -v&lt;/code&gt;查看全部隐式转换函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二隐式参数&quot;&gt;二、隐式参数&lt;/h2&gt;
&lt;h3 id=&quot;使用隐式参数&quot;&gt;2.1 使用隐式参数&lt;/h3&gt;
&lt;p&gt;在定义函数或方法时可以使用标记为&lt;code&gt;implicit&lt;/code&gt;的参数，这种情况下，编译器将会查找默认值，提供给函数调用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义分隔符类
class Delimiters(val left: String, val right: String)

object ScalaApp extends App {
  
    // 进行格式化输出
  def formatted(context: String)(implicit deli: Delimiters): Unit = {
    println(deli.left + context + deli.right)
  }
    
  // 定义一个隐式默认值 使用左右中括号作为分隔符
  implicit val bracket = new Delimiters(&quot;(&quot;, &quot;)&quot;)
  formatted(&quot;this is context&quot;) // 输出: (this is context)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于隐式参数，有两点需要注意：&lt;/p&gt;
&lt;p&gt;1.我们上面定义&lt;code&gt;formatted&lt;/code&gt;函数的时候使用了柯里化，如果你不使用柯里化表达式，按照通常习惯只有下面两种写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这种写法没有语法错误，但是无法通过编译
def formatted(implicit context: String, deli: Delimiters): Unit = {
  println(deli.left + context + deli.right)
} 
// 不存在这种写法，IDEA直接会直接提示语法错误
def formatted( context: String,  implicit deli: Delimiters): Unit = {
  println(deli.left + context + deli.right)
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面第一种写法编译的时候会出现下面所示&lt;code&gt;error&lt;/code&gt;信息,从中也可以看出&lt;code&gt;implicit&lt;/code&gt;是作用于参数列表中每个参数的，这显然不是我们想要到达的效果，所以上面的写法采用了柯里化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;not enough arguments for method formatted: 
(implicit context: String, implicit deli: com.heibaiying.Delimiters)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.第二个问题和隐式函数一样，隐式默认值不能存在二义性，否则无法通过编译，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;implicit val bracket = new Delimiters(&quot;(&quot;, &quot;)&quot;)
implicit val brace = new Delimiters(&quot;{&quot;, &quot;}&quot;)
formatted(&quot;this is context&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码无法通过编译，出现错误提示&lt;code&gt;ambiguous implicit values&lt;/code&gt;，即隐式值存在冲突。&lt;/p&gt;
&lt;h3 id=&quot;引入隐式参数&quot;&gt;2.2 引入隐式参数&lt;/h3&gt;
&lt;p&gt;引入隐式参数和引入隐式转换函数方法是一样的，有以下三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义在隐式参数对应类的伴生对象中；&lt;/li&gt;
&lt;li&gt;直接定义在执行代码的上下文作用域中；&lt;/li&gt;
&lt;li&gt;统一定义在一个文件中，在使用时候导入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们上面示例程序相当于直接定义执行代码的上下文作用域中，下面给出其他两种方式的示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义在隐式参数对应类的伴生对象中&lt;/strong&gt;；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Delimiters(val left: String, val right: String)

object Delimiters {
  implicit val bracket = new Delimiters(&quot;(&quot;, &quot;)&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 此时执行代码的上下文中不用定义
object ScalaApp extends App {

  def formatted(context: String)(implicit deli: Delimiters): Unit = {
    println(deli.left + context + deli.right)
  }
  formatted(&quot;this is context&quot;) 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;统一定义在一个文件中，在使用时候导入&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object Convert {
  implicit val bracket = new Delimiters(&quot;(&quot;, &quot;)&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在使用的时候导入
import com.heibaiying.Convert.bracket

object ScalaApp extends App {
  def formatted(context: String)(implicit deli: Delimiters): Unit = {
    println(deli.left + context + deli.right)
  }
  formatted(&quot;this is context&quot;) // 输出: (this is context)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;利用隐式参数进行隐式转换&quot;&gt;2.3 利用隐式参数进行隐式转换&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;def smaller[T] (a: T, b: T) = if (a &amp;lt; b) a else b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Scala中如果定义了一个如上所示的比较对象大小的泛型方法，你会发现无法通过编译。对于对象之间进行大小比较，Scala和Java一样，都要求被比较的对象需要实现java.lang.Comparable接口。在Scala中，直接继承Java中Comparable接口的是特质Ordered，它在继承compareTo方法的基础上，额外定义了关系符方法，源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;trait Ordered[A] extends Any with java.lang.Comparable[A] {
  def compare(that: A): Int
  def &amp;lt;  (that: A): Boolean = (this compare that) &amp;lt;  0
  def &amp;gt;  (that: A): Boolean = (this compare that) &amp;gt;  0
  def &amp;lt;= (that: A): Boolean = (this compare that) &amp;lt;= 0
  def &amp;gt;= (that: A): Boolean = (this compare that) &amp;gt;= 0
  def compareTo(that: A): Int = compare(that)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以要想在泛型中解决这个问题，有两种方法：&lt;/p&gt;
&lt;h4 id=&quot;使用视图界定&quot;&gt;1. 使用视图界定&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object Pair extends App {

 // 视图界定
  def smaller[T&amp;lt;% Ordered[T]](a: T, b: T) = if (a &amp;lt; b) a else b
 
  println(smaller(1,2)) //输出 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;视图限定限制了T可以通过隐式转换&lt;code&gt;Ordered[T]&lt;/code&gt;，即对象一定可以进行大小比较。在上面的代码中&lt;code&gt;smaller(1,2)&lt;/code&gt;中参数&lt;code&gt;1&lt;/code&gt;和&lt;code&gt;2&lt;/code&gt;实际上是通过定义在&lt;code&gt;Predef&lt;/code&gt;中的隐式转换方法&lt;code&gt;intWrapper&lt;/code&gt;转换为&lt;code&gt;RichInt&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Predef.scala
@inline implicit def intWrapper(x: Int)   = new runtime.RichInt(x)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要这么麻烦执行隐式转换，原因是Scala中的Int类型并不能直接进行比较，因为其没有实现&lt;code&gt;Ordered&lt;/code&gt;特质，真正实现&lt;code&gt;Ordered&lt;/code&gt;特质的是&lt;code&gt;RichInt&lt;/code&gt;。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/scala-richInt.png&quot;/&gt;&lt;/div&gt;
&lt;h4 id=&quot;利用隐式参数进行隐式转换-1&quot;&gt;2. 利用隐式参数进行隐式转换&lt;/h4&gt;
&lt;p&gt;Scala2.11+后，视图界定被标识为废弃，官方推荐使用类型限定来解决上面的问题，本质上就是使用隐式参数进行隐式转换。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object Pair extends App {

   // order既是一个隐式参数也是一个隐式转换，即如果a不存在 &amp;lt; 方法，则转换为order(a)&amp;lt;b
  def smaller[T](a: T, b: T)(implicit order: T =&amp;gt; Ordered[T]) = if (a &amp;lt; b) a else b

  println(smaller(1,2)) //输出 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Martin Odersky . Scala编程(第3版)[M] . 电子工业出版社 . 2018-1-1&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;凯.S.霍斯特曼 . 快学Scala(第2版)[M] . 电子工业出版社 . 2017-7&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.4848484848485&quot;&gt;
&lt;p&gt;更多大数据系列文章可以参见个人 GitHub 开源项目： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;程序员大数据入门指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Sep 2019 00:33:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、隐式转换 1.1 使用隐式转换 隐式转换指的是以 关键字声明带有单个参数的转换函数，它将值从一种类型转换为另一种类型，以便使用之前类型所没有的功能。示例如下： 1.2 隐式转换规则 并不是你使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11565848.html</dc:identifier>
</item>
<item>
<title>Spring Boot （三）： ORM 框架 JPA 与连接池 Hikari - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11565843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11565843.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083104667-668038538.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.3958944281525&quot;&gt;
&lt;p&gt;前面两篇文章我们介绍了如何快速创建一个 Spring Boot 工程&lt;a href=&quot;https://www.geekdigging.com/2019/09/11/2531363117/&quot;&gt;《Spring Boot（一）：快速开始》&lt;/a&gt;和在 Spring Boot 中如何使用模版引擎 Thymeleaf 渲染一个Web页面&lt;a href=&quot;https://www.geekdigging.com/2019/09/16/2755709569/&quot;&gt;《Spring Boot （二）：模版引擎 Thymeleaf 渲染 Web 页面》&lt;/a&gt;，本篇文章我们继续介绍在 Spring Boot 中如何使用数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;数据库方面我们选用 Mysql ， Spring Boot 提供了直接使用 JDBC 的方式连接数据库，毕竟使用 JDBC 并不是很方便，需要我们自己写更多的代码才能使用，一般而言在 Spring Boot 中我们常用的 ORM 框架有 JPA 和 Mybaties ，本篇文章我们要介绍的就是 JPA 的使用姿势。&lt;/p&gt;
&lt;p&gt;说道使用 ORM 框架，就不得不顺便聊一下连接池，市面上很多成熟的数据库连接池，如 C3P0 、 Tomcat 连接池、 BoneCP 等等很多产品，但是我们为什么要介绍 Hikari ？这个要从 BoneCP 说起。&lt;/p&gt;
&lt;p&gt;因为，传说中 BoneCP 在快速这个特点上做到了极致，官方数据是C3P0等的25倍左右。不相信？其实我也不怎么信。可是，有图有真相啊，传说图片来源于官网，然而笔者在官网并没有找到，大家看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083105150-612139675.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来是不是完全吊打，但是当 HikariCP 横空出世以后，这个局面就被完全改写了， BoneCP 被 HikariCP 完全吊打，看了一下 BoneCP Github 上面的版本更新，发现在2013年10月23日以后就再也没有更新过了，包括在仓库介绍上面都写着建议大家使用 HikariCP ，看来作者已经完全心灰意冷了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083106080-1063968457.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hikari 这个词来源于日文，是“光”的意思，估计作者的意思是这个连接池将会和光一样快，不知道作者是不是日本人。&lt;/p&gt;
&lt;p&gt;HikariCP 的口号是快速，简单，可靠。不知道是否真的如它自己宣传的一样，官方又提供了一张图，大家感受一下，这张图来源于：https://github.com/brettwooldridge/HikariCP 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083106552-1476312514.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多有关 HikariCP 的信息，大家可以访问官方的 Github 仓库了解：https://github.com/brettwooldridge/HikariCP ，笔者这里不多做介绍，毕竟我们更关注的如何使用。&lt;/p&gt;
&lt;h2 id=&quot;jpa-介绍&quot;&gt;2. JPA 介绍&lt;/h2&gt;
&lt;p&gt;JPA (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。&lt;/p&gt;
&lt;p&gt;值得注意的是，JPA 是在充分吸收了现有 Hibernate，TopLink，JDO 等 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看， JPA 受到了极大的支持和赞扬，其中就包括了 Spring 与 EJB3. 0的开发团队。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意: JPA 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 JPA 规范，那么我们就可以叫他们为 JPA 的实现产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Boot JPA 是 Spring 基于 ORM 框架、 JPA 规范的基础上封装的一套 JPA 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spring Boot JPA 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Boot JPA 帮我们定义了很多自定义的简单查询，并且可以根据方法名来自动生成 SQL ，主要的语法是 &lt;code&gt;findXXBy&lt;/code&gt; , &lt;code&gt;readAXXBy&lt;/code&gt; , &lt;code&gt;queryXXBy&lt;/code&gt; , &lt;code&gt;countXXBy&lt;/code&gt; , &lt;code&gt;getXXBy&lt;/code&gt; 后面跟属性名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserRepository extends JpaRepository&amp;lt;UserModel, Long&amp;gt; {
    UserModel getByIdIs(Long id);

    UserModel findByNickName(String nickName);

    int countByAge(int age);

    List&amp;lt;UserModel&amp;gt; findByNickNameLike(String nickName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的关键字，使用方法和生产成SQL如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;29&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;And&lt;/td&gt;
&lt;td&gt;findByLastnameAndFirstname&lt;/td&gt;
&lt;td&gt;… where x.lastname = ?1 and x.firstname = ?2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Or&lt;/td&gt;
&lt;td&gt;findByLastnameOrFirstname&lt;/td&gt;
&lt;td&gt;… where x.lastname = ?1 or x.firstname = ?2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Is,Equals&lt;/td&gt;
&lt;td&gt;findByFirstname,findByFirstnameIs,findByFirstnameEquals&lt;/td&gt;
&lt;td&gt;… where x.firstname = 1?&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Between&lt;/td&gt;
&lt;td&gt;findByStartDateBetween&lt;/td&gt;
&lt;td&gt;… where x.startDate between 1? and ?2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;LessThan&lt;/td&gt;
&lt;td&gt;findByAgeLessThan&lt;/td&gt;
&lt;td&gt;… where x.age &amp;lt; ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LessThanEqual&lt;/td&gt;
&lt;td&gt;findByAgeLessThanEqual&lt;/td&gt;
&lt;td&gt;… where x.age &amp;lt;= ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;GreaterThan&lt;/td&gt;
&lt;td&gt;findByAgeGreaterThan&lt;/td&gt;
&lt;td&gt;… where x.age &amp;gt; ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GreaterThanEqual&lt;/td&gt;
&lt;td&gt;findByAgeGreaterThanEqual&lt;/td&gt;
&lt;td&gt;… where x.age &amp;gt;= ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;After&lt;/td&gt;
&lt;td&gt;findByStartDateAfter&lt;/td&gt;
&lt;td&gt;… where x.startDate &amp;gt; ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Before&lt;/td&gt;
&lt;td&gt;findByStartDateBefore&lt;/td&gt;
&lt;td&gt;… where x.startDate &amp;lt; ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;IsNull&lt;/td&gt;
&lt;td&gt;findByAgeIsNull&lt;/td&gt;
&lt;td&gt;… where x.age is null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;IsNotNull,NotNull&lt;/td&gt;
&lt;td&gt;findByAge(Is)NotNull&lt;/td&gt;
&lt;td&gt;… where x.age not null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Like&lt;/td&gt;
&lt;td&gt;findByFirstnameLike&lt;/td&gt;
&lt;td&gt;… where x.firstname like ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NotLike&lt;/td&gt;
&lt;td&gt;findByFirstnameNotLike&lt;/td&gt;
&lt;td&gt;… where x.firstname not like ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;StartingWith&lt;/td&gt;
&lt;td&gt;findByFirstnameStartingWith&lt;/td&gt;
&lt;td&gt;… where x.firstname like ?1 (parameter bound with appended %)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;EndingWith&lt;/td&gt;
&lt;td&gt;findByFirstnameEndingWith&lt;/td&gt;
&lt;td&gt;… where x.firstname like ?1 (parameter bound with prepended %)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Containing&lt;/td&gt;
&lt;td&gt;findByFirstnameContaining&lt;/td&gt;
&lt;td&gt;… where x.firstname like ?1 (parameter bound wrapped in %)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;OrderBy&lt;/td&gt;
&lt;td&gt;findByAgeOrderByLastnameDesc&lt;/td&gt;
&lt;td&gt;… where x.age = ?1 order by x.lastname desc&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Not&lt;/td&gt;
&lt;td&gt;findByLastnameNot&lt;/td&gt;
&lt;td&gt;… where x.lastname &amp;lt;&amp;gt; ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;In&lt;/td&gt;
&lt;td&gt;findByAgeIn(Collection ages)&lt;/td&gt;
&lt;td&gt;… where x.age in ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;NotIn&lt;/td&gt;
&lt;td&gt;findByAgeNotIn(Collection age)&lt;/td&gt;
&lt;td&gt;… where x.age not in ?1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;findByActiveTrue()&lt;/td&gt;
&lt;td&gt;… where x.active = true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;findByActiveFalse()&lt;/td&gt;
&lt;td&gt;… where x.active = false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;IgnoreCase&lt;/td&gt;
&lt;td&gt;findByFirstnameIgnoreCase&lt;/td&gt;
&lt;td&gt;… where UPPER(x.firstame) = UPPER(?1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;工程实战&quot;&gt;3. 工程实战&lt;/h2&gt;
&lt;p&gt;这里我们创建工程 spring-boot-jpa-hikari 。&lt;/p&gt;
&lt;h3 id=&quot;工程依赖-pom.xml&quot;&gt;3.1 工程依赖 pom.xml&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-jpa-hikari/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.8.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.springboot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-jpa-hikari&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;spring-boot-jpa-hikari&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;spring-boot-jpa-hikari&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;mysql-connector-java：mysql连接驱动&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-jpa：jpa相关的依赖包，这个包里包含了很多内容，包括我们使用的连接池 HikariCP ，从 Spring Boot 2.x 开始， Spring Boot 默认的连接池更换成为 HikariCP ，在当前的 Spring Boot 2.1.8 RELEASE 版本中，所使用的 HikariCP 版本为 3.2.0 ，如图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083106981-915012671.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置文件-application.yml&quot;&gt;3.2 配置文件 application.yml&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-jpa-hikari/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080
spring:
  application:
    name: spring-boot-jpa-hikari
  jpa:
    database: mysql
    show-sql: true
    generate-ddl: true
    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
    hibernate:
      ddl-auto: update
  datasource:
    url: jdbc:mysql://192.168.0.128:3306/test?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      auto-commit: true
      minimum-idle: 2
      idle-timeout: 60000
      connection-timeout: 30000
      max-lifetime: 1800000
      pool-name: DatebookHikariCP
      maximum-pool-size: 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;有关 JPA 的配置有一点需要的， &lt;code&gt;spring.jpa.hibernate.ddl-auto&lt;/code&gt; ，这个属性需谨慎配置，它的几个值的含义对数据库来讲都是高危操作，笔者这里方便起见配置了 &lt;code&gt;update&lt;/code&gt; ，各位读者请根据具体使用场景配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;create ：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。&lt;/li&gt;
&lt;li&gt;create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。&lt;/li&gt;
&lt;li&gt;update ：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。&lt;/li&gt;
&lt;li&gt;validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。&lt;/li&gt;
&lt;li&gt;none ：不做任何操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有关 HikariCP 更多的配置可以参考源码类 &lt;code&gt;com.zaxxer.hikari.HikariConfig&lt;/code&gt; ，笔者这里仅简单配置了自动提交、超时时间、最大最小连接数等配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;映射实体类-usermodel.java&quot;&gt;3.3 映射实体类 UserModel.java&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-jpa-hikari/src/main/java/com/springboot/springbootjpahikari/model/UserModel.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Entity
@Data
@Table(name = &quot;user&quot;)
public class UserModel {
    @Id
    @GeneratedValue(generator = &quot;paymentableGenerator&quot;)
    @GenericGenerator(name = &quot;paymentableGenerator&quot;, strategy = &quot;uuid&quot;)
    @Column(name =&quot;ID&quot;,nullable=false,length=36)
    private String id;
    @Column(nullable = true, unique = true)
    private String nickName;
    @Column(nullable = false)
    private int age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;资源类-userrepository.java&quot;&gt;3.4 资源类 UserRepository.java&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-jpa-hikari/src/main/java/com/springboot/springbootjpahikari/repository/UserRepository.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserRepository extends JpaRepository&amp;lt;UserModel, Long&amp;gt; {
    UserModel getByIdIs(Long id);

    UserModel findByNickName(String nickName);

    int countByAge(int age);

    List&amp;lt;UserModel&amp;gt; findByNickNameLike(String nickName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接口测试类-usercontroller.java&quot;&gt;3.5 接口测试类 UserController.java&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-jpa-hikari/src/main/java/com/springboot/springbootjpahikari/controller/UserController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class UserController {

    @Autowired
    UserRepository userRepository;

    /**
     * 查询用户列表
     * @return
     */
    @GetMapping(&quot;/user&quot;)
    public List&amp;lt;UserModel&amp;gt; user() {
        return userRepository.findAll(Sort.by(&quot;id&quot;).descending());
    }

    /**
     * 新增或更新用户信息
     * @param user
     * @return
     */
    @PostMapping(&quot;/user&quot;)
    public UserModel user(UserModel user) {
        return userRepository.save(user);
    }

    /**
     * 根据id删除用户
     * @param id
     * @return
     */
    @DeleteMapping(&quot;/user&quot;)
    public String deleteUserById(Long id) {
        userRepository.deleteById(id);
        return &quot;success&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;4. 测试&lt;/h2&gt;
&lt;p&gt;测试我们借助工具 PostMan ，启动工程，首先我们新增一个用户信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083107188-304959459.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们参数中加入 id ，并且 id 的值和数据库中的 id 维持一致，这是会更新当前 id 的数据，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083107650-978099781.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们执行查询操作，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083108531-1368566500.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行删除操作，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190922083108702-1331251998.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，测试完成。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;5. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/spring-boot-examples/tree/master/spring-boot-jpa-hikari&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/spring-boot-examples/tree/master/spring-boot-jpa-hikari&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;https://github.com/brettwooldridge/HikariCP&lt;/p&gt;
&lt;p&gt;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/&lt;/p&gt;
&lt;p&gt;http://www.ityouknow.com/springboot/2016/08/20/spring-boot-jpa.html&lt;/p&gt;
</description>
<pubDate>Sun, 22 Sep 2019 00:31:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>前面两篇文章我们介绍了如何快速创建一个 Spring Boot 工程 '《Spring Boot（一）：快速开始》' 和在 Spring Boot 中如何使用模版引擎 Thymeleaf 渲染一个We</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11565843.html</dc:identifier>
</item>
<item>
<title>01.Django基础一之web框架的本质 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/11565833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/11565833.html</guid>
<description>&lt;h2 id=&quot;一-web框架的本质及自定义web框架&quot;&gt;一 web框架的本质及自定义web框架&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端，基于请求做出响应，客户都先请求，服务端做出对应的响应，按照http协议的请求协议发送请求，服务端按照http协议的响应协议来响应请求，这样的网络通信，我们就可以自己实现Web框架了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;通过对socket的学习，我们知道网络通信，我们完全可以自己写了，因为socket就是做网络通信用的，下面我们就基于socket来自己实现一个web框架，写一个web服务端，让浏览器来请求，并通过自己的服务端把页面返回给浏览器，浏览器渲染出我们想要的效果。在后面的学习中，大家提前准备一些文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;html文件内容如下，名称为test.html：&lt;/strong&gt;　　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;wechat.ico&quot;&amp;gt; 
    &amp;lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&amp;gt;
    &amp;lt;!--&amp;lt;style&amp;gt;--&amp;gt;
        &amp;lt;!--h1{--&amp;gt;
            &amp;lt;!--background-color: green;--&amp;gt;
            &amp;lt;!--color: white;--&amp;gt;
        &amp;lt;!--}--&amp;gt;
    &amp;lt;!--&amp;lt;/style&amp;gt;--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&amp;lt;/h1&amp;gt;
&amp;lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;!--&amp;lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1550395461724&amp;amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg&quot; alt=&quot;&quot;&amp;gt;--&amp;gt; &amp;lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&amp;gt;
&amp;lt;img src=&quot;meinv.png&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;100&quot;&amp;gt; &amp;lt;!--如果你是本地的图片想要返回给页面，你需要对页面上的关于这个图片的请求要自己做出响应，这个src就是来你本地请求这个图片，你只要将图片信息读取出来，返回给页面，页面拿到这个图片的数据，就能够渲染出来了，是不是很简单--&amp;gt;

&amp;lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;!--&amp;lt;script&amp;gt;--&amp;gt;
    &amp;lt;!--alert('这是我们第一个网页')--&amp;gt;
&amp;lt;!--&amp;lt;/script&amp;gt;--&amp;gt;

&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　css文件内容如下，名称为test.css：　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h1{
    background-color: green;
    color: white;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　js文件内容如下，名称为test.js：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alert('这是我们第一个网页');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　&lt;strong&gt;再准备一个图片，名称为meinv.jpg，再准备一个ico文件，名称为wechat.ico，其实就是个图片文件，微信官网打开之后，在浏览器最上面能够看到&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217161553642-1455488905.png&quot; alt=&quot;img&quot;/&gt;，把它保存下来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　上面的文件都准备好之后，你用pycharm新建一个项目，把文件都放到一个文件夹里面去，留着备用，像下面这个样子：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217161740583-1253868814.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后开始写我们的web框架，&lt;strong&gt;我们分这么几步来写：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;一简单的web框架&quot;&gt;&lt;strong&gt;一、简单的web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　&lt;strong&gt;创建一个python文件，内容如下，名称为test.py：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()
conn,addr = sk.accept()
from_b_msg = conn.recv(1024)
str_msg = from_b_msg.decode('utf-8')
#socket是应用层和传输层之间的抽象层，每次都有协议，协议就是消息格式，那么传输层的消息格式我们不用管，因为socket帮我们搞定了，但是应用层的协议还是需要咱们自己遵守的，所以再给浏览器发送消息的时候，如果没有按照应用层的消息格式来写，那么你返回给浏览器的信息，浏览器是没法识别的。而应用层的协议就是我们的HTTP协议，所以我们按照HTTP协议规定的消息格式来给浏览器返回消息就没有问题了，关于HTTP我们会细说，首先看一下直接写conn.send(b'hello')的效果，然后运行代码，通过浏览器来访问一下，然后再看这一句conn.send(b'HTTP/1.1 200 ok \r\n\r\nhello')的效果
#下面这句就是按照http协议来写的
# conn.send(b'HTTP/1.1 200 ok \r\n\r\nhello')
#上面这句还可以分成下面两句来写
conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
conn.send(b'hello')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　我们来浏览器上看一下浏览器发送的请求：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217165555288-1404955543.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　目前我们还没有写如何返回一个html文件给浏览器，所以这里暂时不用管它，那么我们点开这个127.0.0.1看看：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217165848448-2082569292.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们在python文件中打印一下浏览器发送过来的请求信息是啥：&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217171401085-1669271307.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　重启我们的代码，然后在网址中输入这个：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217171827604-1319061425.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　再重启我们的代码，然后在网址中输入这个：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217180502464-365178390.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　浏览器发过来一堆的消息，我们给浏览器回复(响应)信息的时候，也要按照一个消息格式来写，这些都是http协议规定的，那么我们就来学习一下http协议，然后继续完善我们的web框架：&lt;/p&gt;
&lt;p&gt;　　　　　　HTTP协议：https://www.cnblogs.com/clschao/articles/9230431.html&lt;/p&gt;

&lt;h3 id=&quot;二返回html文件的web框架&quot;&gt;&lt;strong&gt;二、返回HTML文件的web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　首先写一个html文件，内容如下，名称为test.html：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&amp;gt;

    &amp;lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&amp;gt;
    &amp;lt;style&amp;gt;
        h1{
            background-color: green;
            color: white;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&amp;lt;/h1&amp;gt;
&amp;lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1550395461724&amp;amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg&quot; alt=&quot;&quot;&amp;gt; 
&amp;lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&amp;gt;

&amp;lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;script&amp;gt;
    alert('这是我们第一个网页')
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　准备我们的python代码，服务端程序，文件内容如下，文件名称为test.py：　　　　　　　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()
conn,addr = sk.accept()
from_b_msg = conn.recv(1024)
str_msg = from_b_msg.decode('utf-8')
print('浏览器请求信息：',str_msg)

# conn.send(b'HTTP/1.1 200 ok \r\ncontent-type:text/html;charset=utf-8;\r\n') 
conn.send(b'HTTP/1.1 200 ok \r\n\r\n')

with open('test1.html','rb') as f:
    f_data = f.read()
conn.send(f_data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　页面上输入网址看效果，css和js代码的效果也有，very good：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217205314200-934222566.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　但是我们知道，我们的css和js基本都是写在本地的文件里面的啊，而且我们的图片基本也是我们自己本地的啊，怎么办，我们将上面我们提前准备好的js和css还有那个.ico结尾的图片文件都准备好，来我们在来一个升级版的web框架，其实css、js、图片等文件都叫做网站的静态文件。&lt;/p&gt;
&lt;p&gt;　　首先我们先看一个效果，如果我们直接将我们写好的css和js还有.ico和图片文件插入到我们的html页面里面，就是下面这个html文件&lt;/p&gt;
&lt;p&gt;　　　　名称为test.html，内容如下：　　　　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&amp;gt;
    &amp;lt;!--加上下面这句，那么我们看浏览器调试窗口中的那个network里面就没有那个favicon.ico的请求了，其实这就是页面title标签文字左边的那个页面图标,但是这个文件是我们自己本地的，所以我们需要在后端代码里面将这个文件数据读取出来返回给前端--&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;wechat.ico&quot;&amp;gt;
    &amp;lt;!--直接写在html页面里面的css样式是直接可以在浏览器上显示的--&amp;gt;
    &amp;lt;!--&amp;lt;style&amp;gt;--&amp;gt;
        &amp;lt;!--h1{--&amp;gt;
            &amp;lt;!--background-color: green;--&amp;gt;
            &amp;lt;!--color: white;--&amp;gt;
        &amp;lt;!--}--&amp;gt;
    &amp;lt;!--&amp;lt;/style&amp;gt;--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;姑娘，你好，我是Jaden，请问约吗？嘻嘻~~&amp;lt;/h1&amp;gt;
&amp;lt;!--直接写在html页面里面的img标签的src属性值如果是别人网站的地址（网络地址）是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;!--&amp;lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1550395461724&amp;amp;di=c2b971db12eef5d85aba410d1e2e8568&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fy0.ifengimg.com%2Fifengimcp%2Fpic%2F20140822%2Fd69e0188b714ee789e97_size87_w800_h1227.jpg&quot; alt=&quot;&quot;&amp;gt;--&amp;gt; &amp;lt;!--如果都是网络地址，那么只要你的电脑有网，就可以看到，不需要自己在后端写对应的读取文件，返回图片文件信息的代码，因为别人的网站就做了这个事情了--&amp;gt;
&amp;lt;img src=&quot;meinv.png&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;100&quot;&amp;gt; &amp;lt;!--如果你是本地的图片想要返回给页面，你需要对页面上的关于这个图片的请求要自己做出响应，这个src就是来你本地请求这个图片，你只要将图片信息读取出来，返回给页面，页面拿到这个图片的数据，就能够渲染出来了，是不是很简单--&amp;gt;

&amp;lt;!--直接写在html页面里面的js操作是直接可以在浏览器上显示的--&amp;gt;
&amp;lt;!--&amp;lt;script&amp;gt;--&amp;gt;
    &amp;lt;!--alert('这是我们第一个网页')--&amp;gt;
&amp;lt;!--&amp;lt;/script&amp;gt;--&amp;gt;

&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　同样使用我们之前的python程序，来看效果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217210153254-1291193522.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　发现js和css的效果都没有出来，并且我们看一下浏览器调试窗口的那个network&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217210402034-1514551154.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　在下来我们在network里面点击那个test.css文件，看看请求是什么：&lt;/p&gt;
&lt;p&gt;　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217210751685-1433657612.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　还有就是当我们直接在浏览器上保存某个页面的时候，随便一个页面，我们到页面上点击右键另存为，然后存到本地的一个目录下，你会发现这个页面的html、css、js、图片等文件都跟着保存下来了，我保存了一下博客园首页的页面，看，是一个文件夹和一个html文件：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217211604118-1129260335.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　我们点开博客园那个文件夹看看里面都有什么：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217211533384-439814169.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　发现js、css还有图片什么的都被保存了下来，说明什么，说明这些文件本身就存在浏览器上了，哦，原来就是将html页面需要的css、js、图片等文件也发送给浏览器就可以了，并且这些静态文件都是浏览器单独过来请求的，其实和标签的属性有有关系，css文件是link标签的href属性：，js文件是script标签的src属性：，图片文件是img标签的src属性：&lt;img src=&quot;https://www.cnblogs.com/changxin7/p/meinv.png&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt; ，那个.ico文件是link标签的属性：，其实这些属性都会在页面加载的时候，单独到自己对应的属性值里面取请求对应的文件数据，而且我们如果在值里面写的都是自己本地的路径，那么都会来自己的本地路径来找，如果我们写的是相对路径，就会到我们自己的网址+文件名称，这个路径来找它需要的文件，所以我们只需要将这些请求做一些响应，将对应的文件数据相应给浏览器就可以了！并且我们通过前面的查看，能够发现，浏览器url的请求路径我们知道是什么，静态文件不是也这样请求的吗，好，我们针对不同的路径给它返回不同的文件，&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217212514109-1556720401.png&quot; alt=&quot;img&quot;/&gt;非常好！我们来尝试一下！&lt;/p&gt;
&lt;h3 id=&quot;三返回静态文件的高级web框架&quot;&gt;&lt;strong&gt;三、返回静态文件的高级web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　还是用第二个web框架里面的那个html文件，我们只需要写一些我们的服务端程序就可以了，同样是test.py文件，内容如下：　　　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket

sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()

#首先浏览器相当于给我们发送了多个请求，一个是请求我们的html文件，而我们的html文件里面的引入文件的标签又给我们这个网站发送了请求静态文件的请求，所以我们要将建立连接的过程循环起来，才能接受多个请求，没毛病
while 1:
    conn,addr = sk.accept()
    # while 1:
    from_b_msg = conn.recv(1024)
    str_msg = from_b_msg.decode('utf-8')
    #通过http协议我们知道，浏览器请求的时候，有一个请求内容的路径，通过对请求信息的分析，这个路径我们在请求的所有请求信息中可以提炼出来，下面的path就是我们提炼出来的路径
    path = str_msg.split('\r\n')[0].split(' ')[1]
    print('path&amp;gt;&amp;gt;&amp;gt;',path)
    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    #由于整个页面需要html、css、js、图片等一系列的文件，所以我们都需要给人家浏览器发送过去，浏览器才能有这些文件，才能很好的渲染你的页面
    #根据不同的路径来返回响应的内容
    if path == '/': #返回html文件
        print(from_b_msg)
        with open('test.html','rb') as f:
        # with open('Python开发.html','rb') as f:
            data = f.read()
        conn.send(data)
        conn.close()
    elif path == '/meinv.png': #返回图片
        with open('meinv.png','rb') as f:
            pic_data = f.read()
        # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
        conn.send(pic_data)
        conn.close()
    elif path == '/test.css': #返回css文件
        with open('test.css','rb') as f:
            css_data = f.read()
        conn.send(css_data)
        conn.close()

    elif path == '/wechat.ico':#返回页面的ico图标
        with open('wechat.ico','rb') as f:
            ico_data = f.read()
        conn.send(ico_data)
        conn.close()

    elif path == '/test.js': #返回js文件
        with open('test.js','rb') as f:
            js_data = f.read()
        conn.send(js_data)
        conn.close()

    #注意：上面每一个请求处理完之后，都有一个conn.close()是因为，HTTP协议是短链接的，一次请求对应一次响应，这个请求就结束了，所以我们需要写上close，不然浏览器自己断了，你自己写的服务端没有断，就会出问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　运行起来我们的py文件，然后在浏览器访问一下我们的服务端，看效果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190217213105264-177729435.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　666666，完全搞定了，自己通过socket已经完全搞定了web项目，激动不，哈哈，我们再来完善一下&lt;/p&gt;

&lt;h3 id=&quot;四函数版高级web框架&quot;&gt;&lt;strong&gt;四：函数版高级web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　html文件和其他的静态文件还是我们上面使用的。&lt;/p&gt;
&lt;p&gt;　　　　python代码如下：　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @Time    : 2019/2/17 14:06
# @Author  : wuchao
# @Site    :
# @File    : test.py
# @Software: PyCharm
import socket

sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()

#处理页面请求的函数
def func1(conn):
    with open('test.html', 'rb') as f:
        # with open('Python开发.html','rb') as f:
        data = f.read()
    conn.send(data)
    conn.close()

#处理页面img标签src属性值是本地路径的时候的请求
def func2(conn):
    with open('meinv.png', 'rb') as f:
        pic_data = f.read()
    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    conn.send(pic_data)
    conn.close()
#处理页面link（ &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&amp;gt;）标签href属性值是本地路径的时候的请求
def func3(conn):
    with open('test.css', 'rb') as f:
        css_data = f.read()
    conn.send(css_data)
    conn.close()

#处理页面link（&amp;lt;link rel=&quot;icon&quot; href=&quot;wechat.ico&quot;&amp;gt;）标签href属性值是本地路径的时候的请求
def func4(conn):
    with open('wechat.ico', 'rb') as f:
        ico_data = f.read()
    conn.send(ico_data)
    conn.close()

#处理页面script（&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;）标签src属性值是本地路径的时候的请求
def func5(conn):
    with open('test.js', 'rb') as f:
        js_data = f.read()
    conn.send(js_data)
    conn.close()

while 1:
    conn,addr = sk.accept()
    # while 1:
    from_b_msg = conn.recv(1024)
    str_msg = from_b_msg.decode('utf-8')
    path = str_msg.split('\r\n')[0].split(' ')[1]
    print('path&amp;gt;&amp;gt;&amp;gt;',path)
    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    print(from_b_msg)
    if path == '/':
        func1(conn)
    elif path == '/meinv.png':
        func2(conn)
    elif path == '/test.css':
        func3(conn)
    elif path == '/wechat.ico':
        func4(conn)

    elif path == '/test.js':
        func5(conn)&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;五-更高级版多线程版web框架&quot;&gt;&lt;strong&gt;五 更高级版(多线程版)web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　应用上我们并发编程的内容，反正html文件和静态文件都直接给浏览器，那大家就一块并发处理，html文件和静态文件还是上面的。&lt;/p&gt;
&lt;p&gt;　　　　python代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @Time    : 2019/2/17 14:06
# @Author  : wuchao
# @Site    : 
# @File    : test.py
# @Software: PyCharm
import socket
from threading import Thread
#注意一点，不开多线程完全是可以搞定的，在这里只是教大家要有并发编程的思想，所以我使用了多线程

sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()

def func1(conn):
    with open('test.html', 'rb') as f:
        # with open('Python开发.html','rb') as f:
        data = f.read()
    conn.send(data)
    conn.close()

def func2(conn):
    with open('meinv.png', 'rb') as f:
        pic_data = f.read()
    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    conn.send(pic_data)
    conn.close()

def func3(conn):
    with open('test.css', 'rb') as f:
        css_data = f.read()
    conn.send(css_data)
    conn.close()

def func4(conn):
    with open('wechat.ico', 'rb') as f:
        ico_data = f.read()
    conn.send(ico_data)
    conn.close()

def func5(conn):
    with open('test.js', 'rb') as f:
        js_data = f.read()
    conn.send(js_data)
    conn.close()

while 1:
    conn,addr = sk.accept()
    # while 1:
    from_b_msg = conn.recv(1024)
    str_msg = from_b_msg.decode('utf-8')
    path = str_msg.split('\r\n')[0].split(' ')[1]
    print('path&amp;gt;&amp;gt;&amp;gt;',path)
    conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    print(from_b_msg)
    if path == '/':
        # func1(conn)
        t = Thread(target=func1,args=(conn,))
        t.start()
    elif path == '/meinv.png':
        # func2(conn)
        t = Thread(target=func2, args=(conn,))
        t.start()
    elif path == '/test.css':
        # func3(conn)
        t = Thread(target=func3, args=(conn,))
        t.start()
    elif path == '/wechat.ico':
        # func4(conn)
        t = Thread(target=func4, args=(conn,))
        t.start()
    elif path == '/test.js':
        # func5(conn)
        t = Thread(target=func5, args=(conn,))
        t.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六-更更高级版web框架&quot;&gt;&lt;strong&gt;六 更更高级版web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　if判断太多了，开线程的方式也比较恶心，有多少个if判断，就写多少次创建线程，简化一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
from threading import Thread

sk = socket.socket()
sk.bind(('127.0.0.1',8001))
sk.listen()

def func1(conn):

    conn.send(b'HTTP/1.1 200 ok\r\ncontent-type:text/html\r\ncharset:utf-8\r\n\r\n')
    with open('test.html', 'rb') as f:
        # with open('Python开发.html','rb') as f:
        data = f.read()
    conn.send(data)
    conn.close()

def func2(conn):
    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')
    with open('meinv.png', 'rb') as f:
        pic_data = f.read()
    # conn.send(b'HTTP/1.1 200 ok \r\n\r\n')
    conn.send(pic_data)
    conn.close()

def func3(conn):
    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')
    with open('test.css', 'rb') as f:
        css_data = f.read()
    conn.send(css_data)
    conn.close()

def func4(conn):
    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')
    with open('wechat.ico', 'rb') as f:
        ico_data = f.read()
    conn.send(ico_data)
    conn.close()

def func5(conn):
    conn.send(b'HTTP/1.1 200 ok\r\n\r\n')
    with open('test.js', 'rb') as f:
        js_data = f.read()
    conn.send(js_data)
    conn.close()

#定义一个路径和执行函数的对应关系，不再写一堆的if判断了
l1 = [
    ('/',func1),
    ('/meinv.png',func2),
    ('/test.css',func3),
    ('/wechat.ico',func4),
    ('/test.js',func5),
]

#遍历路径和函数的对应关系列表，并开多线程高效的去执行路径对应的函数，
def fun(path,conn):
    for i in l1:
        if i[0] == path:
            t = Thread(target=i[1],args=(conn,))
            t.start()
    # else:
    #     conn.send(b'sorry')

while 1:
    conn,addr = sk.accept()
    #看完这里面的代码之后，你就可以思考一个问题了，很多人要同时访问你的网站，你在请求这里是不是可以开起并发编程的思想了，多进程+多线程+协程，妥妥的支持高并发，再配合服务器集群，这个网页就支持大量的高并发了，有没有很激动，哈哈，但是咱们写的太low了，而且功能很差，容错能力也很差，当然了，如果你有能力，你现在完全可以自己写web框架了，写一个nb的，如果现在没有这个能力，那么我们就来好好学学别人写好的框架把，首先第一个就是咱们的django框架了，其实就是将这些功能封装起来，并且容错能力强，抗压能力强，总之一个字：吊。
    # while 1:
    from_b_msg = conn.recv(1024)
    str_msg = from_b_msg.decode('utf-8')
    path = str_msg.split('\r\n')[0].split(' ')[1]
    print('path&amp;gt;&amp;gt;&amp;gt;',path)
    # 注意：因为开启的线程很快，可能导致你的文件还没有发送过去，其他文件的请求已经来了，导致你文件信息没有被浏览器正确的认识，所以需要将发送请求行和请求头的部分写道前面的每一个函数里面去，并且防止出现浏览器可能不能识别你的html文件的情况，需要在发送html文件的那个函数里面的发送请求行和请求头的部分加上两个请求头content-type:text/html\r\ncharset:utf-8\r\n
    # conn.send(b'HTTP/1.1 200 ok\r\n\r\n')  不这样写了
    # conn.send(b'HTTP/1.1 200 ok\r\ncontent-type:text/html\r\ncharset:utf-8\r\n\r\n')  不这样写了
    print(from_b_msg)
    #执行这个fun函数并将路径和conn管道都作为参数传给他
    fun(path,conn)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七-根据不同路径返回不同页面的web框架&quot;&gt;&lt;strong&gt;七 根据不同路径返回不同页面的web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　既然知道了我们可以根据不同的请求路径来返回不同的内容，那么我们可不可以根据用户访问的不同路径，返回不同的页面啊，嗯，应该是可以的&lt;/p&gt;
&lt;p&gt;　　　　自己创建两个html文件，写几个标签在里面，名为index.html和home.html，然后根据不同的路径返回不同的页面，我就给大家写上python代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;&quot;
根据URL中不同的路径返回不同的内容
返回独立的HTML页面
&quot;&quot;&quot;

import socket
sk = socket.socket()
sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口
sk.listen()  # 监听


# 将返回不同的内容部分封装成函数
def index(url):
    # 读取index.html页面的内容
    with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        s = f.read()
    # 返回字节数据
    return bytes(s, encoding=&quot;utf8&quot;)


def home(url):
    with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        s = f.read()
    return bytes(s, encoding=&quot;utf8&quot;)


# 定义一个url和实际要执行的函数的对应关系
list1 = [
    (&quot;/index/&quot;, index),
    (&quot;/home/&quot;, home),
]

while 1:
    # 等待连接
    conn, add = sk.accept()
    data = conn.recv(8096)  # 接收客户端发来的消息
    # 从data中取到路径
    data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串
    # 按\r\n分割
    data1 = data.split(&quot;\r\n&quot;)[0]
    url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径
    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')  # 因为要遵循HTTP协议，所以回复的消息也要加状态行
    # 根据不同的路径返回不同内容
    func = None  # 定义一个保存将要执行的函数名的变量
    for i in list1:
        if i[0] == url:
            func = i[1]
            break
    if func:
        response = func(url)
    else:
        response = b&quot;404 not found!&quot;

    # 返回具体的响应消息
    conn.send(response)
    conn.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八返回动态页面的web框架&quot;&gt;&lt;strong&gt;八、返回动态页面的web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　这网页能够显示出来了，但是都是静态的啊。页面的内容都不会变化的，我想要的是动态网站，动态网站的意思是里面有动态变化的数据，而不是页面里面有动态效果，这个大家要注意啊。&lt;/p&gt;
&lt;p&gt;　　　　没问题，我也有办法解决。我选择使用字符串替换来实现这个需求。（这里使用时间戳来模拟动态的数据，还是只给大家python代码吧）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;&quot;
根据URL中不同的路径返回不同的内容
返回HTML页面
让网页动态起来
&quot;&quot;&quot;

import socket
import time

sk = socket.socket()
sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口
sk.listen()  # 监听


# 将返回不同的内容部分封装成函数
def index(url):
    with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        s = f.read()
        now = str(time.time())
        s = s.replace(&quot;@@oo@@&quot;, now)  # 在网页中定义好特殊符号，用动态的数据去替换提前定义好的特殊符号
    return bytes(s, encoding=&quot;utf8&quot;)


def home(url):
    with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
        s = f.read()
    return bytes(s, encoding=&quot;utf8&quot;)


# 定义一个url和实际要执行的函数的对应关系
list1 = [
    (&quot;/index/&quot;, index),
    (&quot;/home/&quot;, home),
]

while 1:
    # 等待连接
    conn, add = sk.accept()
    data = conn.recv(8096)  # 接收客户端发来的消息
    # 从data中取到路径
    data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串
    # 按\r\n分割
    data1 = data.split(&quot;\r\n&quot;)[0]
    url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径
    conn.send(b'HTTP/1.1 200 OK\r\n\r\n')  # 因为要遵循HTTP协议，所以回复的消息也要加状态行
    # 根据不同的路径返回不同内容
    func = None  # 定义一个保存将要执行的函数名的变量
    for i in list1:
        if i[0] == url:
            func = i[1]
            break
    if func:
        response = func(url)
    else:
        response = b&quot;404 not found!&quot;

    # 返回具体的响应消息
    conn.send(response)
    conn.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　这八个框架让大家满意了吧，这下子明白整个web框架的原理了吧，哈哈，但是我们写的框架还是太low了，不够强壮，那别人已经开发好了很多nb的框架了，如：Django、Flask、Tornado等等，我们学学怎么用就可以啦，但是注意一个问题，我们在里面获取路径的时候，我们是按照\r\n来分割然后再通过空格来分割获取到的路径，但是如果不是http协议的话，你自己要注意消息格式了。&lt;/p&gt;
&lt;p&gt;　　接下来我们看一个别人写好的模块来搞的web框架，这个模块叫做wsgiref&lt;/p&gt;
&lt;h3 id=&quot;九wsgiref模块版web框架&quot;&gt;&lt;strong&gt;九、wsgiref模块版web框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　wsgiref模块其实就是将整个请求信息给封装了起来，就不需要你自己处理了，假如它将所有请求信息封装成了一个叫做request的对象，那么你直接request.path就能获取到用户这次请求的路径，request.method就能获取到本次用户请求的请求方式(get还是post)等，那这个模块用起来，我们再写web框架是不是就简单了好多啊。&lt;/p&gt;
&lt;p&gt;　　　　对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。&lt;/p&gt;
&lt;p&gt;　　　　服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。&lt;/p&gt;
&lt;p&gt;　　　　应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。&lt;/p&gt;
&lt;p&gt;　　　　这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。&lt;/p&gt;
&lt;p&gt;正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口协议来实现这样的服务器软件，让我们专心用Python编写Web业务。&lt;/p&gt;
&lt;p&gt;　　　　这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。&lt;/p&gt;
&lt;p&gt;　　　　WSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。&lt;/p&gt;
&lt;p&gt;　　　　常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。&lt;/p&gt;

&lt;p&gt;　　　　好，接下来我们就看一下（能理解就行，了解就可以了）：先看看wsfiref怎么使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from wsgiref.simple_server import make_server
# wsgiref本身就是个web框架，提供了一些固定的功能（请求和响应信息的封装，不需要我们自己写原生的socket了也不需要咱们自己来完成请求信息的提取了，提取起来很方便）
#函数名字随便起
def application(environ, start_response):
    '''
    :param environ: 是全部加工好的请求信息，加工成了一个字典，通过字典取值的方式就能拿到很多你想要拿到的信息
    :param start_response: 帮你封装响应信息的（响应行和响应头），注意下面的参数
    :return:
    '''
    start_response('200 OK', [('Content-Type', 'text/html'),('k1','v1')])
    print(environ)
    print(environ['PATH_INFO'])  #输入地址127.0.0.1:8000，这个打印的是'/',输入的是127.0.0.1:8000/index，打印结果是'/index'
    return [b'&amp;lt;h1&amp;gt;Hello, web!&amp;lt;/h1&amp;gt;']

#和咱们学的socketserver那个模块很像啊
httpd = make_server('127.0.0.1', 8080, application)

print('Serving HTTP on port 8080...')
# 开始监听HTTP请求:
httpd.serve_forever()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　　　来一个完整的web项目，用户登录认证的项目，我们需要连接数据库了，所以先到mysql数据库里面准备一些表和数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create database db1;
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; use db1;
Database changed
mysql&amp;gt; create table userinfo(id int primary key auto_increment,username char(20) not null unique,password char(20) not null);
Query OK, 0 rows affected (0.23 sec)

mysql&amp;gt; insert into userinfo(username,password) values('chao','666'),('sb1','222');
Query OK, 2 rows affected (0.03 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&amp;gt; select * from userinfo;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | chao     | 666      |
|  2 | sb1      | 222      |
+----+----------+----------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　然后再创建这么几个文件：&lt;/p&gt;
&lt;p&gt;　　　　python文件名称webmodel.py，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#创建表，插入数据
def createtable():
    import pymysql
    conn = pymysql.connect(
        host='127.0.0.1',
        port=3306,
        user='root',
        password='666',
        database='db1',
        charset='utf8'
    )
    cursor = conn.cursor(pymysql.cursors.DictCursor)
    sql = '''
        -- 创建表
        create table userinfo(id int primary key auto_increment,username char(20) not null unique,password char(20) not null);
        -- 插入数据
        insert into userinfo(username,password) values('chao','666'),('sb1','222');
    '''
    cursor.execute(sql)
    conn.commit()
    cursor.close()
    conn.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　python的名为webauth文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#对用户名和密码进行验证
def auth(username,password):
    import pymysql
    conn = pymysql.connect(
        host='127.0.0.1',
        port=3306,
        user='root',
        password='123',
        database='db1',
        charset='utf8'
    )
    print('userinfo',username,password)
    cursor = conn.cursor(pymysql.cursors.DictCursor)
    sql = 'select * from userinfo where username=%s and password=%s;'
    res = cursor.execute(sql, [username, password])
    if res:
        return True
    else:
        return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　用户输入用户名和密码的文件，名为web.html，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--如果form表单里面的action什么值也没给，默认是往当前页面的url上提交你的数据，所以我们可以自己指定数据的提交路径--&amp;gt;
&amp;lt;!--&amp;lt;form action=&quot;http://127.0.0.1:8080/auth/&quot; method=&quot;post&quot;&amp;gt;--&amp;gt;
&amp;lt;form action=&quot;http://127.0.0.1:8080/auth/&quot; method=&quot;get&quot;&amp;gt;
    用户名&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;
    密码 &amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;script&amp;gt;

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　用户验证成功后跳转的页面，显示成功，名为websuccess.html，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        h1{
            color:red;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;宝贝儿，恭喜你登陆成功啦&amp;lt;/h1&amp;gt;


&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　python服务端代码(主逻辑代码)，名为web_python.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from urllib.parse import parse_qs
from wsgiref.simple_server import make_server
import webauth
def application(environ, start_response):

    # start_response('200 OK', [('Content-Type', 'text/html'),('k1','v1')])
    # start_response('200 OK', [('Content-Type', 'text/html'),('charset','utf-8')])
    start_response('200 OK', [('Content-Type', 'text/html')])
    print(environ)
    print(environ['PATH_INFO'])
    path = environ['PATH_INFO']
    #用户获取login页面的请求路径
    if path == '/login':
        with open('web.html','rb') as f:
            data = f.read()
    #针对form表单提交的auth路径，进行对应的逻辑处理
    elif path == '/auth/':
        #登陆认证
        #1.获取用户输入的用户名和密码

        #2.去数据库做数据的校验，查看用户提交的是否合法
        # user_information = environ['']
        if environ.get(&quot;REQUEST_METHOD&quot;) == &quot;POST&quot;:
            #获取请求体数据的长度,因为提交过来的数据需要用它来提取,注意POST请求和GET请求的获取数据的方式不同
            try:
                request_body_size = int(environ.get('CONTENT_LENGTH', 0))
            except (ValueError):
                request_body_size = 0
            #POST请求获取数据的方式
            request_data = environ['wsgi.input'].read(request_body_size)
            print('&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;',request_data) # &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; b'username=chao&amp;amp;password=123'，是个bytes类型数据
            print('?????',environ['QUERY_STRING']) #????? 空的，因为post请求只能按照上面这种方式取数据
            #parse_qs可以帮我们解析数据
            re_data = parse_qs(request_data)
            print('拆解后的数据',re_data) #拆解后的数据 {b'password': [b'123'], b'username': [b'chao']}            #post请求的返回数据我就不写啦　　　　　　  pass
        if environ.get(&quot;REQUEST_METHOD&quot;) == &quot;GET&quot;:
            #GET请求获取数据的方式，只能按照这种方式取
            print('?????',environ['QUERY_STRING']) #????? username=chao&amp;amp;password=123,是个字符串类型数据
            request_data = environ['QUERY_STRING']

            # parse_qs可以帮我们解析数据
            re_data = parse_qs(request_data)
            print('拆解后的数据', re_data) #拆解后的数据 {'password': ['123'], 'username': ['chao']}
            username = re_data['username'][0]
            password = re_data['password'][0]
            print(username,password)
            #进行验证：
            status = webauth.auth(username,password)
            if status:
            # 3.将相应内容返回
                with open('websuccess.html','rb') as f:
                    data = f.read()
            else:
                data = b'auth error'
        # 但是不管是post还是get请求都不能直接拿到数据，拿到的数据还需要我们来进行分解提取，所以我们引入urllib模块来帮我们分解



        #注意昂，我们如果直接返回中文，没有给浏览器指定编码格式，默认是gbk，所以我们需要gbk来编码一下，浏览器才能识别
        # data='登陆成功！'.encode('gbk')
    else:
        data = b'sorry 404!,not found the page'
    return [data]



#和咱们学的socketserver那个模块很像啊
httpd = make_server('127.0.0.1', 8080, application)

print('Serving HTTP on port 8080...')
# 开始监听HTTP请求:
httpd.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　把代码拷走，创建文件，放到同一个目录下，运行一下we_python.py文件的代码就能看到效果，注意先输入的网址是127.0.0.1:8080/login ，还要注意你的mysql数据库没有问题。&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218175649497-215686790.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;十起飞版web框架&quot;&gt;十、起飞版web框架&lt;/h3&gt;
&lt;p&gt;　　　　我们上一个web框架把所有的代码都写在了一个py文件中，我们拆到其他文件里面去，并且针对不用的路径来进行分发请求的时候都用的if判断，很多值得优化的地方，好，结合我们前面几个版本的优势我们来优化一下，分几个文件和文件夹&lt;/p&gt;
&lt;p&gt;　　　　代码就不在博客上都列出来了，我打包放到百度云上了，大家去下载看看把：https://pan.baidu.com/s/1Ns5QHFpZGusGHuHzrCto3A&lt;/p&gt;

&lt;p&gt;　　将来要说的MVC框架是什么呢：&lt;/p&gt;
&lt;p&gt;　　　　M：model.py 就是和数据库打交道用的，创建表等操作&lt;/p&gt;
&lt;p&gt;　　　　V：View 视图（视图函数，html文件）&lt;/p&gt;
&lt;p&gt;　　　　C：controller 控制器（其实就是我百度云代码里面那个urls文件里面的内容，url（路径）分发与视图函数的逻辑处理）&lt;/p&gt;
&lt;p&gt;　　Django叫做MTV框架&lt;/p&gt;
&lt;p&gt;　　　　M：model.py 就是和数据库打交道用的，创建表等操作（和上面一样）&lt;/p&gt;
&lt;p&gt;　　　　T：templates 存放HTML文件的&lt;/p&gt;
&lt;p&gt;　　　　V：View 视图函数（逻辑处理）&lt;/p&gt;
&lt;p&gt;　　　　其实你会发现MTV比MVC少一个url分发的部分&lt;/p&gt;
&lt;p&gt;　　　　所以我们学的django还要学一个叫做url控制器（路径分发）的东西，MTV+url控制器就是我们django要学的内容。 　　　　&lt;/p&gt;
&lt;p&gt;　　捋一下框架的整个流程吧~~~&lt;/p&gt;
&lt;h2 id=&quot;二-模板渲染jinja2&quot;&gt;二 模板渲染JinJa2&lt;/h2&gt;
&lt;p&gt;　　上面的代码实现了一个简单的动态页面(字符串替换)，我完全可以从数据库中查询数据，然后去替换我html中的对应内容（专业名词叫做模板渲染，你先渲染一下，再给浏览器进行渲染），然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： &lt;code&gt;jinja2&lt;/code&gt;　　&lt;/p&gt;
&lt;p&gt;　　下载：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install jinja2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　来一个html文件，index2,html，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;姓名：{{name}}&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;爱好：&amp;lt;/h1&amp;gt;
    &amp;lt;ul&amp;gt;
        {% for hobby in hobby_list %}
        &amp;lt;li&amp;gt;{{hobby}}&amp;lt;/li&amp;gt;
        {% endfor %}
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　使用jinja2渲染index2.html文件，创建一个python文件，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from wsgiref.simple_server import make_server
from jinja2 import Template


def index():
    with open(&quot;index2.html&quot;, &quot;r&quot;,encoding='utf-8') as f:
        data = f.read()
    template = Template(data)  # 生成模板文件
    ret = template.render({&quot;name&quot;: &quot;于谦&quot;, &quot;hobby_list&quot;: [&quot;烫头&quot;, &quot;泡吧&quot;]})  # 把数据填充到模板里面
    return [bytes(ret, encoding=&quot;utf8&quot;), ]


# 定义一个url和函数的对应关系
URL_LIST = [
    (&quot;/index/&quot;, index),
]

def run_server(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html;charset=utf8'), ])  # 设置HTTP响应的状态码和头信息
    url = environ['PATH_INFO']  # 取到用户输入的url
    func = None  # 将要执行的函数
    for i in URL_LIST:
        if i[0] == url:
            func = i[1]  # 去之前定义好的url列表里找url应该执行的函数
            break
    if func:  # 如果能找到要执行的函数
        return func()  # 返回函数的执行结果
    else:
        return [bytes(&quot;404没有该页面&quot;, encoding=&quot;utf8&quot;), ]


if __name__ == '__main__':
    httpd = make_server('', 8000, run_server)
    print(&quot;Serving HTTP on port 8000...&quot;)
    httpd.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　现在的数据是我们自己手写的，那可不可以从数据库中查询数据，来填充页面呢？&lt;/p&gt;
&lt;p&gt;　　使用pymysql连接数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conn = pymysql.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, passwd=&quot;xxx&quot;, db=&quot;xxx&quot;, charset=&quot;utf8&quot;)
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
cursor.execute(&quot;select name, age, department_id from userinfo&quot;)
user_list = cursor.fetchall()
cursor.close()
conn.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建一个测试的user表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE user(
  id int auto_increment PRIMARY KEY,
  name CHAR(10) NOT NULL,
  hobby CHAR(20) NOT NULL
)engine=innodb DEFAULT charset=UTF8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　模板的原理就是字符串替换，我们只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容。&lt;/p&gt;

&lt;h2 id=&quot;三-mvc和mtv框架&quot;&gt;三 MVC和MTV框架&lt;/h2&gt;
&lt;h4 id=&quot;mvc&quot;&gt;MVC&lt;/h4&gt;
&lt;p&gt;　　Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418162558974-92667466.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;mtv&quot;&gt;MTV&lt;/h4&gt;
&lt;p&gt;　　Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。&lt;/li&gt;
&lt;li&gt;T 代表模板 (Template)：负责如何把页面展示给用户(html)。&lt;/li&gt;
&lt;li&gt;V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418162350672-193671507.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。&lt;/p&gt;
&lt;h2 id=&quot;四-django下载安装&quot;&gt;四 Django下载安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.djangoproject.com/download/&quot;&gt;Django官网下载页面&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载django&quot;&gt;1、下载Django：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install django==1.11.9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建一个django-project&quot;&gt;2、创建一个django project&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;django-admin startproject mysite   创建了一个名为&quot;mysite&quot;的Django 项目：
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218205509202-588867847.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当前目录下会生成mysite的工程，目录结构如下：（大家注意昂，pip下载下来的django你就理解成一个模块，而不是django项目，这个模块可以帮我们创建django项目）&lt;/p&gt;
&lt;p&gt;​ 　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724114201404-1121087959.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;manage.py ----- Django项目里面的工具，通过它可以调用django shell和数据库，启动关闭项目与项目交互等，不管你将框架分了几个文件，必然有一个启动文件，其实他们本身就是一个文件。&lt;/li&gt;
&lt;li&gt;settings.py ---- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。&lt;/li&gt;
&lt;li&gt;urls.py ----- 负责把URL模式映射到应用程序。&lt;/li&gt;
&lt;li&gt;wsgi.py ---- runserver命令就使用wsgiref模块做简单的web server，后面会看到renserver命令，所有与socket相关的内容都在这个文件里面了，目前不需要关注它。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt; python manage.py runserver 127.0.0.1:8080  #此时已经可以启动django项目了，只不过什么逻辑也没有呢&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　你会发现，上面没有什么view视图函数的文件啊，这里我们说一个应用与项目的关系，上面我们只是创建了一个项目，并没有创建应用，以微信来举例，微信是不是一个大的项目，但是微信里面是不是有很多个应用，支付应用、聊天应用、朋友圈、小程序等这些在一定程度上都是相互独立的应用，也就是说一个大的项目里面可以有多个应用，也就是说项目是包含应用的，它没有将view放到这个项目目录里面是因为它觉得，一个项目里面可以有多个应用，而每个应用都有自己这个应用的逻辑内容，所以他觉得这个view应该放到应用里面，比如说我们的微信，刚才说了几个应用，这几个应用的逻辑能放到一起吗，放到一起是不是就乱套啦，也不好管理和维护，所以这些应用的逻辑都分开来放，它就帮我们提炼出来了，提炼出来一个叫做应用的东西，所以我们需要来创建这个应用。&lt;/p&gt;

&lt;h3 id=&quot;在mysite目录下创建应用&quot;&gt;3、在mysite目录下创建应用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py startapp blog   #通过执行manage.py文件来创建应用，执行这句话一定要注意，你应该在这个manage.py的文件所在目录下执行这句话，因为其他目录里面没有这个文件
python manage.py startapp blog2  #每个应用都有自己的目录，每个应用的目录下都有自己的views.py视图函数和models.py数据库操作相关的文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 　　 &lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724114930826-472002646.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们现在只需要看其中两个文件&lt;/p&gt;
&lt;p&gt;　　　　models.py ：之前我们写的那个名为model的文件就是创建表用的，这个文件就是存放与该app(应用)相关的表结构的&lt;/p&gt;
&lt;p&gt;　　　　views.py ：存放与该app相关的视图函数的&lt;/p&gt;
&lt;h3 id=&quot;启动django项目&quot;&gt;4、启动django项目&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver 8080   # python manage.py runserver 127.0.0.1:8080，本机就不用写ip地址了 如果连端口都没写，默认是本机的8000端口
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 这样我们的django就启动起来了！当我们访问：http://127.0.0.1:8080/时就可以看到：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724120547497-22629173.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学习Django，我们就学上面的这些文件，怎么在MTV+url分发的功能下来使用。&lt;/p&gt;
&lt;p&gt;最后我们说一下，其实我们将来创建django项目，很少用命令行了，就用pycharm来创建，怎么创建呢？看图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218212732820-700635300.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218212647295-533476159.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看项目目录：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218212923366-780961303.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五-基于django实现一个简单的示例&quot;&gt;五 基于Django实现一个简单的示例&lt;/h3&gt;
&lt;p&gt;现在实现一个用户输入一个timer路径，返回一个含有当前时间的页面，想想怎么做？用户输入网址--&amp;gt;路径--&amp;gt;函数--&amp;gt;返回数据(文件)&lt;/p&gt;
&lt;h3 id=&quot;url控制器第一步就找它&quot;&gt;url控制器（第一步就找它）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;django 1.11.9版本的url写法：from django.conf.urls import urlfrom django.contrib import adminfrom crm import viewsurlpatterns = [    url(r'^admin/', admin.site.urls),    url(r'^index/', views.index),]
下面是django2.x版本的url写法，不太一样了，但是兼容1.x的，不过我们现在还是主要说1.xx版本的，所以写url的时候按照上的方式写。from django.contrib import admin
from django.urls import path

#找对应的函数，是哪个app里面的函数
from app01 import views

urlpatterns = [
    path('admin/', admin.site.urls), #这个先不用管，后面会学
    path('index/',views.index),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　视图&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render,HttpResponse

# Create your views here.
#逻辑和返回数据
def index(request):

    import datetime
    now=datetime.datetime.now()
    ctime=now.strftime(&quot;%Y-%m-%d %X&quot;)
　　 #return HttpResponse('哈哈，好玩吗？')
    return render(request,&quot;index.html&quot;,{&quot;ctime&quot;:ctime}) #render，渲染html页面文件并返回给浏览器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　模板&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h4&amp;gt;当前时间:{{ ctime }}&amp;lt;/h4&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　通过pycharm来运行项目：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218214227231-153650928.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看控制台：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218214438381-1425402212.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行效果如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218213237723-1108613034.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有同学说：我想自己配置启动的端口怎么搞啊：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218214319870-1182270859.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218214345440-48001565.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　还有一点说一下昂，在settings配置文件里面有关于templates(放html文件的配置)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')] #有些版本的django没有写这个，自己写一下，就是配置一个django找html文件的路径，render方法就来这里找html文件
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　关于请求和响应的请求信息和相应信息的设置还需要你自己写吗？之前我们用wsgiref是不是还写来着，现在都不需要写了，简单不。&lt;/p&gt;
&lt;p&gt;　　还有一点：post请求的时候你会发现一个 Forbidden的错误：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218220535726-1977412154.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在只需要做一步，在settings配置文件里面将这一行注释掉，这是django给你加的一个csrf的认证，现在不需要，我们会讲的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　还记得django写视图函数的时候，有一个参数是必须要给的吗，叫做request，如果你是post请求，那么就用request.POST，就能拿到post请求提交过来的所有数据（一个字典，然后再通过字典取值request.POST.get('username')，取出来的就是个字符串，你在那个字典里面看到的是{'username':['chao']}，虽然看着是列表，但是request.POST.get('username')取出来的就是个字符串），通过request.GET就能拿到提交过来的所有数据，而且记着，每一个视图函数都要给人家返回一些内容，用render或者HttpResponse等，其实render里面也是通过HttpResponse来返回内容，不然会报错，错误是告诉你没有返回任何内容：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201902/988061-20190218220501334-1922192819.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　django认识了，以后我们就按照下面的步骤来学：&lt;/p&gt;
&lt;p&gt;　　　　1.django的url控制器&lt;/p&gt;
&lt;p&gt;　　　　2.django的视图&lt;/p&gt;
&lt;p&gt;　　　　3.django的模板(template)&lt;/p&gt;
&lt;p&gt;　　　　4.ORM（花的时间比较久）&lt;/p&gt;
&lt;p&gt;　　作业好了，我们之前写的那个登陆认证示例，加到django里面来吧！&lt;/p&gt;
</description>
<pubDate>Sun, 22 Sep 2019 00:24:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>一 web框架的本质及自定义web框架 我们可以这样理解：所有的Web应用本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端，基于请求做出响应，客户都先请求，服务端做出对应的响</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/11565833.html</dc:identifier>
</item>
<item>
<title>C++程序设计学习 - 山猫~</title>
<link>http://www.cnblogs.com/wzw0625/p/11565814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzw0625/p/11565814.html</guid>
<description>&lt;h3 class=&quot;title-article&quot;&gt;第一章 预备知识&lt;/h3&gt;
&lt;p&gt;1、C++历史起源&lt;/p&gt;
&lt;p&gt;由于C语言具有许多优点，比如语言简洁灵活；运算符和数据类型丰富；具有结构化控制语句；程序执行效率高；同时具有高级语言和汇编语言的优点等。与其他高级语言相比，C语言具有可以直接访问物理地址的优点，与汇编语言相比又具有良好的可读性和可移植性。因此，C语言得到了极为广泛的应用。但因为C语言是一种面向过程（即面向结构）的编程语言，不能满足面向对象开发软件的需要。为支持面向对象的程序设计，1980年由贝尔实验室的Bjarne Stroustrup创建了C++程序设计语言，C++的重要目标就是面向对象的程序设计，因此在C++中引入了类的机制。于是在1983年正式命名为C++（C Plus Plus）。&lt;/p&gt;
&lt;p&gt;2、C++的特点&lt;/p&gt;
&lt;p&gt;C++语言的主要特点表现在两个方面，一是全面兼容C语言，二是支持面向对象的程序设计方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全面兼容C语言：C++秉持了C语言的优点，大多数的C程序代码略作修改或不作修改就可在C++的集成环境下调试和运行。这对于继承和开发当前已在广泛使用的软件是非常重要的，可以节省大量的人力和物力。&lt;/li&gt;
&lt;li&gt;支持面向对象程序设计：C++是一种面向对象的程序设计语言。它使得程序的各个模块的独立性更强，程序的可读性和可移植性更强，程序代码的结构更加合理，程序的扩充性更强。这对于设计、编制和调试一些大型的软件尤为重要，而C语言是面向结构的程序设计语言，即面向过程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、C++程序基本结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C++程序通常由一个或多个函数组成，函数是构成C++程序的基本单位。C++程序中至少要包含一个主函数main()，一个C++程序总是从主函数开始执行的。&lt;/li&gt;
&lt;li&gt;C++函数由函数的说明部分和函数体两部分组成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、程序书写规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一层语句同列书写，另外同一层次的花括号必须与对应的闭括号在同一列上。C++中的每个语句和数据说明必须以分号(;)结束&lt;/li&gt;
&lt;li&gt;内层语句缩进两个字符的位置&lt;/li&gt;
&lt;li&gt;函数定义第一列书写&lt;/li&gt;
&lt;li&gt;严格区分字母的大小写&lt;/li&gt;
&lt;li&gt;C++输入/输出：输入、输出通过流cin和cout来实现的，例如： cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;用来输入变量a和b的值。cout&amp;lt;&amp;lt;&quot;the value is&quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;endl;用来输出变量value的值。&lt;/li&gt;
&lt;li&gt;注释：在C++程序的任何位置都可以插入注释信息，如 /* 注释内容 */；// 注释内容&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 22 Sep 2019 00:22:00 +0000</pubDate>
<dc:creator>山猫~</dc:creator>
<og:description>C++知识入门了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzw0625/p/11565814.html</dc:identifier>
</item>
<item>
<title>设计模式---桥接模式 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/11565760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/11565760.html</guid>
<description>&lt;p&gt;问题场景：&lt;/p&gt;
&lt;p&gt;现在的手机有很多不同的品牌，样式也各种各样，什么水滴屏，刘海屏，挖孔屏，什么华为，vivo，小米等等。如果我们基于继承关系来设计的话，你就会发现这个时候有点无从下手了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201909/1216484-20190922023845567-587613801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然这个图的设计是不合理的，你也可以试着将不同的屏再抽象下，但是发现还是不是很合理，而且即使实现了要扩展的话很是麻烦。这个时候我们就可以引入桥接模式。&lt;/p&gt;
&lt;p&gt;桥接模式的主要特点就是把抽象化与行为实现解耦，使得二者可以独立变化。&lt;/p&gt;
&lt;p&gt;在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活，就像上述场景，手机厂家有多个，手机屏幕也是多元化的。&lt;/p&gt;

&lt;p&gt;比如上诉问题，我们这样来设计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201909/1216484-20190922024004378-85775910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;打电话的行为提取一个接口出来，手机提取一个抽象出来，在抽象（Phone）里面去聚合行为(Brand)，这个过程就像搭了个桥把抽象与行为连接起来。当然这样也把抽象和行为分离开来了，可以独立扩展，如果我要新增一个折叠屏的，只需要在抽象这边加一个类就OK，如果需要扩展手机品牌，只需要在接口实现那边加个小米就可以了，二者可以独立变化，提高系统的灵活性&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;行为侧：&lt;/p&gt;
&lt;p&gt;接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.designpatterns.bridge.api;

/**
 * @author: create by nijunyang
 * @date:2019/9/22
 */
public interface Brand {
    void call();
    void close();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接口实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.designpatterns.bridge.impl;

import com.nijunyang.designpatterns.bridge.api.Brand;

/**
 * @author: create by nijunyang
 * @date:2019/9/22
 */
public class HuaWei implements Brand {
    @Override
    public void call() {
        System.out.println(&quot;华为手机打电话&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;华为手机关机&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 抽象：&lt;/p&gt;
&lt;p&gt;抽象类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.designpatterns.bridge.phone;

import com.nijunyang.designpatterns.bridge.api.Brand;

/**
 * @author: create by nijunyang
 * @date:2019/9/22
 */
public abstract class Phone {
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }


    public void call() {
        brand.call();
    }


    public void close() {
        brand.close();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 子类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.designpatterns.bridge.phone;

import com.nijunyang.designpatterns.bridge.api.Brand;

/**
 * @author: create by nijunyang
 * @date:2019/9/22
 */
public class WaterDropScreePhone extends Phone {

    public WaterDropScreePhone(Brand brand) {
        super(brand);
    }

    @Override
    public void call() {
        System.out.print(&quot;这是水滴屏&quot;);
        super.call();
    }

    @Override
    public void close() {
        System.out.print(&quot;这是水滴屏&quot;);
        super.close();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.nijunyang.designpatterns.bridge;

import com.nijunyang.designpatterns.bridge.impl.HuaWei;
import com.nijunyang.designpatterns.bridge.phone.Phone;
import com.nijunyang.designpatterns.bridge.phone.WaterDropScreePhone;

/**
 * @author: create by nijunyang
 * @date:2019/9/22
 */
public class Test {

    public static void main(String[] args)
    {
        Phone phone = new WaterDropScreePhone(new HuaWei());
        phone.call();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1216484/201909/1216484-20190922024454051-587320148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用桥接模式需要找到合适的抽象与行为进行分离，它可以替代使用继承出现的多层继承或者接口的多实现情况，降低系统的管理和维护成本。但是会增加系统的理解和设计难度。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC驱动就是一个桥接模式的应用，通过DriverManager去聚合Connection实现搭桥，DriverManager通过配置去看是mysql或者是oracle等。各种武功变化万千，为武功心法不变，桥接模式中，抽象不一定非得是抽象类，行为也不一定非要抽取一个接口出来，就像JDBC这个，心法是一样，打出来的招式却有些变化。还有银行转账也是一个场景，不同用户可以通过不同方式转账。用户：普通用户，黄金用户，白金用户...，转账方式：网银转账 ，柜台转账，ATM转账，第三方支付转账...&lt;/p&gt;

</description>
<pubDate>Sat, 21 Sep 2019 18:50:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>问题场景： 现在的手机有很多不同的品牌，样式也各种各样，什么水滴屏，刘海屏，挖孔屏，什么华为，vivo，小米等等。如果我们基于继承关系来设计的话，你就会发现这个时候有点无从下手了。 当然这个图的设计是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/11565760.html</dc:identifier>
</item>
<item>
<title>charles 高亮Hosts - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11565700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11565700.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/view/focused-hosts.html&quot;&gt;charles 高亮Hosts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Focus Host是焦点域名的；这里配置好的可以在结构视图中，单独拎出来显示；&lt;/p&gt;
&lt;p&gt;如下图，在把&lt;code&gt;zhubangbang.com&lt;/code&gt;设为焦点域名，在视图中是下图这么展示的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image_thumb-7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在序列视图的时候，是按照下面这么展示的；&lt;/p&gt;
&lt;p&gt;选择focued后，就会只保留你的焦点域名；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/02_thumb.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Sep 2019 17:53:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 高亮Hosts' Focus Host是焦点域名的；这里配置好的可以在结构视图中，单独拎出来显示； 如下图，在把 设为焦点域名，在视图中是下图这么展示的； 在序列视图的时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11565700.html</dc:identifier>
</item>
<item>
<title>charles 视图菜单总结 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11565673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11565673.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/view/readme.html&quot;&gt;charles 视图菜单总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Charles的视图菜单里的东西其实是非常常用的功能；&lt;/p&gt;
&lt;p&gt;但是我们一般是不需要从这里点进来的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_view.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面，无非是查看的视图结构（按照域名和按照访问时间）&lt;/p&gt;
&lt;p&gt;然后是一些概览之类的；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_porxy_content.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在下面是把charles的请求和响应以什么方式来展现的；&lt;/p&gt;
&lt;p&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Sep 2019 17:35:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 视图菜单总结' Charles的视图菜单里的东西其实是非常常用的功能； 但是我们一般是不需要从这里点进来的； 里面，无非是查看的视图结构（按照域名和按照访问时间） 然后是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11565673.html</dc:identifier>
</item>
<item>
<title>[FE] 有效开展一个前端项目3 (Vue CLI / Vue SSR ) - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/11565563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/11565563.html</guid>
<description>[unable to retrieve full-text content]关于如何有效开展一个前端项目，博客之前已有两篇如下： [FE] 有效开展一个前端项目1 (gulp/angular) [FE] 有效开展一个前端项目2 (vuejs-templates/webpack) 一些组件已经是过去式，但 Nodejs、Webpack 依旧再用，Vuejs、Vuex、Vue-</description>
<pubDate>Sat, 21 Sep 2019 17:31:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>本文参考： 'charles 视图菜单总结' Charles的视图菜单里的东西其实是非常常用的功能； 但是我们一般是不需要从这里点进来的； 里面，无非是查看的视图结构（按照域名和按照访问时间） 然后是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11565673.html</dc:identifier>
</item>
<item>
<title>charles 结构体 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11565650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11565650.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/view/structure.html&quot;&gt;charles 结构体&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Charles 主要提供两种查看封包的视图，分别名为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Structure/结构视图&lt;/li&gt;
&lt;li&gt;Sequence/序列视图&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;structure结构视图&quot;&gt;Structure/结构视图&lt;/h3&gt;
&lt;p&gt;将网络请求按访问的域名分类，比如某个域名下有n个资源请求，那么所有此域名下的请求都会在这里做一个详细的分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image_thumb-2.png&quot; alt=&quot;https://a.axihe.com/img/charles/image_thumb-2.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;sequence序列视图&quot;&gt;Sequence/序列视图&lt;/h3&gt;
&lt;p&gt;将网络请求按访问的时间排序，按照你的电脑的发送请求顺序进行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image_thumb-3.png&quot; alt=&quot;https://a.axihe.com/img/charles/image_thumb-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以根据具体的需要在这两种视图之前来回切换。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Sep 2019 17:21:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 结构体' Charles 主要提供两种查看封包的视图，分别名为 Structure/结构视图 Sequence/序列视图 Structure/结构视图 将网络请求按访问的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11565650.html</dc:identifier>
</item>
<item>
<title>charles 访问控制设置 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11565641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11565641.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/proxy/access-control-setting.html&quot;&gt;charles 访问控制设置&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;charles-访问控制设置&quot;&gt;charles 访问控制设置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;access control settings 访问账户设置&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;这里可以配置连接到charles时的一些配置；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_07.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个访问控制确定谁可以使用这个charles，&lt;/p&gt;
&lt;p&gt;本机是永远都可以访问的，默认的访问控制列表如果是空的；&lt;/p&gt;
&lt;p&gt;意味着除了这台电脑以外，没有任何设备可以使用charles。&lt;/p&gt;
&lt;p&gt;如果你把下面的提示开始，未经授权的设备连接时候会提示你是否允许；&lt;/p&gt;
&lt;p&gt;类似下面这种提示框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/chharles_phone_set_try.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你手机访问的时候，电脑会提示的；&lt;/p&gt;
&lt;p&gt;这里设置后的host，连接时候是无需确认的；&lt;br/&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Sep 2019 17:16:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 访问控制设置' charles 访问控制设置 access control settings 访问账户设置 ； 这里可以配置连接到charles时的一些配置； 这个访问控</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11565641.html</dc:identifier>
</item>
</channel>
</rss>