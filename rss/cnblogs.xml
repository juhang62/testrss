<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【运维】记一次上线前的紧急定位与修复-献上九条小经验 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/11854639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/11854639.html</guid>
<description>&lt;p&gt;本文介绍了作者所在团队在某次上线前测试发现问题、定位问题并修复上线的过程，最后给出几点经验总结，希望对大家有用。&lt;/p&gt;

&lt;p&gt;（1）今天需要上线，但昨晚才合并了所有分支，时间很紧迫。不幸的是，打包测试后发现有一个Springboot应用（模块R）启动失败，但进程没有死，一直在输出&lt;strong&gt;报错日志&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;Google&lt;/strong&gt;了相关的报错日志，并没有找到相关信息。查看了模块R的&lt;strong&gt;代码变更&lt;/strong&gt;，并没有什么改动，以为是环境问题；部署到其它环境后，发现问题依旧存在，而且这个问题从未出现过，基本&lt;strong&gt;排除环境问题&lt;/strong&gt;，问题还是出在代码上。&lt;/p&gt;
&lt;p&gt;（3）启动模块R&lt;strong&gt;上一个版本&lt;/strong&gt;（现生产环境）的代码，正常启动。所以问题还是出现模块R的改动上。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;对比&lt;/strong&gt;模块R的发布包的新版本与生产版本的差异，发现第三方依赖包都一致，但自己项目的依赖包不同。&lt;/p&gt;
&lt;p&gt;（5）想到一个有效的办法，依次用生产版本&lt;strong&gt;替换&lt;/strong&gt;掉自己项目的包，最终定位了问题出在&lt;strong&gt;通用模块D&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;（6）查看模块D的&lt;strong&gt;代码变更记录&lt;/strong&gt;，改动比较大，比较难发现是哪里的改动造成的。&lt;/p&gt;
&lt;p&gt;（7）重新&lt;strong&gt;看日志&lt;/strong&gt;。为何要重看呢？并不是心血来潮，主要是想找关联。既然已经知道了问题在哪个模块代码上，通过&lt;strong&gt;查看日志与该模块可能相关的信息&lt;/strong&gt;，或许能找到蛛丝马迹。&lt;/p&gt;
&lt;p&gt;（8）果然！！！重新查看日志发现，模块R启动时，报了一个其它错误ErrorA，但被后面不断重复出现的错误ErrorB刷掉了，所以一开始并没有注意到它。通过该报错，与模块D的代码改动对比。终于定位出了问题！&lt;/p&gt;
&lt;p&gt;（9）创建hotfix分支，修改代码提交，重新merge，打包，测试通过，部署生产！！！&lt;/p&gt;
&lt;p&gt;因为部署上线是有特定的时间窗口的，如果错过了时间，就要下次再上线，还好及时定位，及时解决！&lt;/p&gt;

&lt;p&gt;（1）&lt;strong&gt;不要放过任何日志&lt;/strong&gt;，特别是报错的日志，日志是极其有用的。不要只看最后面的报错，也不要只看最前面的报错，任何报错都可能提供新的方向和线索。如果日志信息不够，可以尝试打开&lt;strong&gt;debug模式&lt;/strong&gt;，会有大量的日志信息，当然也要求你有足够强的过滤和整理信息的能力。&lt;/p&gt;
&lt;p&gt;（2）提取有用日志，可以用&lt;code&gt;grep&lt;/code&gt;、&lt;code&gt;tail&lt;/code&gt;、&lt;code&gt;less&lt;/code&gt;等linux命令。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;组件化、模块化&lt;/strong&gt;很重要，能快速缩小问题范围。能通过只回退某个模块实现部分功能先上线。&lt;/p&gt;
&lt;p&gt;（4）善用&lt;strong&gt;对比&lt;/strong&gt;工具，如&lt;code&gt;diff&lt;/code&gt;命令，&lt;strong&gt;BeyondCompare&lt;/strong&gt;软件等。&lt;/p&gt;
&lt;p&gt;（5）善用&lt;strong&gt;代码变更记录&lt;/strong&gt;，这是版本控制给我们带来的好处，可以方便我们对比代码改动了什么，什么时候改的，能加速问题定位；也能及时回退代码。&lt;/p&gt;
&lt;p&gt;（6）上线前要做&lt;strong&gt;充分的测试&lt;/strong&gt;。这次问题的出现项目流程上的原因在于没有进行充分的测试。（1）写代码的人修改了通用模块，却没有测试依赖它的其它模块的功能会不会受影响，而只测试了自己那一部分；（2）合并代码后，没有足够的时间来进行测试。部署前一天，才合并了代码打包测试。所以时间非常紧迫，在短时间要定位问题并解决，容易造成压力。&lt;/p&gt;
&lt;p&gt;（7）要有&lt;strong&gt;独立的测试环境&lt;/strong&gt;。这个是导致方向性错误的原因，经过是这样的：A同学打包了自己的分支，这时刚好B同学稍晚一点也打包了分支，而打包的环境只有一个，B同学的包覆盖了A同学的包。所以在A部署的时候，实际用了B同学的代码打的包，导致启动失败。所以一直以为是A同学代码的问题，这个方向性的错误浪费了很多时间。应该要让每个分支可以同时打包，但不会覆盖。&lt;/p&gt;
&lt;p&gt;（8）不要先入为主。不要过早认定某个模块就是有问题的，请参考上一条。&lt;/p&gt;
&lt;p&gt;（9）团队作战，分工合作。整个过程全靠团队一起协作才能快速定位并解决；打造一个开放包容、沟通顺畅的团队是多么的重要。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;If You Want to Go Fast, Go Alone. If You Want to Go Far, Go Together.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运维和问题定位的知识很多，也非常重要，需要持续学习。本文仅讲述了本次过程用到的方法。更多的知识以后慢慢再介绍...&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946674/201911/946674-20191114082748568-1811092429.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 00:28:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 简介 本文介绍了作者所在团队在某次上线前测试发现问题、定位问题并修复上线的过程，最后给出几点经验总结，希望对大家有用。 2 过程 （1）今天需要上线，但昨晚才合并了所有分支，时间很紧迫。不幸的是，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/11854639.html</dc:identifier>
</item>
<item>
<title>领导要求996，我拒绝了 - 陈宏鸿</title>
<link>http://www.cnblogs.com/aspwebchh/p/11854624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aspwebchh/p/11854624.html</guid>
<description>&lt;p&gt;&lt;span&gt;互联网公司程序员，前些天项目赶进度，被强制加班。 我们公司以前也是鼓励员工加班，但比较隐晦， 不是强制的，而这次是上司直接发话，必须要加班，否则工作无法完成的责任会扣到你头上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被要求强行加班，无偿的，而且是丧心病狂的996，我脸上显得很平静，但是内心一万头草泥马在奔腾。当天晚上，我就发微信给上司，我说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“赶项目我一定不拖进度，该完成的工作按时完成，但是你别让我加班，第一天弄的太晚，直接影响第二天工作效率，这样得不偿失”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;工作只是生活的一部分，如果每天9点以后下班，就表示没时间陪家人，没时间娱乐活动，没时间弄好吃的，没有时间做自己感兴趣的事情，到家直接洗洗睡，第二天醒来继续上班，这样的生活岂不是很无趣，加班是罪魁祸首。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写程序是脑力劳动与体力劳动的结合，聚精会神写一整天代码，效率很高，但到了下班点，整个人会非常疲乏，如果继续工作，会影响第二天状态，所以后面所谓的加班其实是在划水，根本做不了什么东西。当然，也可以平均分布工作和划水，正常上班时也不用那么认真，那么加班的时候好像还能做点东西， 但是一整天的总工作成果没有变化。所以，与其把工作分布到12个小时，还不如前8个小时多做产出，后4个小时下班回家，这样有效工作量并不会减少，还有了自由时间， 只是看起来没那么积极，但不用怕完不成工作而被问责。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;程序员俗称码农，也叫IT民工，这是自黑，可在不懂技术的领导眼中就跟搬砖工没区别，在他们眼里，程序员多加班一小时，就会多一小时工作成果，搬砖嘛，或多或少总能搬几块。他们不知道，写程序虽然不像搞艺术，非常依赖灵感，没灵感什么都干不成，但在精神良好、脑子灵活的状态下，工作效率绝对要高于无精打采、混混沌沌的状态，有时候几小时搞不定的问题，忽然间灵光一闪就能解决，这就不是靠加班加出来的。良好的工作状态下产生的工作成果不是靠堆时间可以赶超的。所以很多时候在一个不开明的领导指挥下，团队所有人看似很努力的在加班工作，其实所花的时间都是没有意义的冤枉时间，原本这些时间可以做更有意义的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一种加班，更加无厘头，这种加班叫做：我也不知道为什么要加班，别人在加， 那么我也加一会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种加班，到下班时间点后员工们手上的工作停下来了，但没人动屁股，大家看网页的看网页，看视频的看视频，打游戏的打游戏，下班，不存在的。因为别人都在加班，我下班了，感觉就像在犯罪，有强烈的罪恶感。这种加班比前一种加班更加可恶，没半分实际意义， 但是偏偏就很难打破。其实每个人都在抱怨，可又没有人敢越雷池一步。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;说实话我挺佩服能不加班的人，虽然加班有很多外部因素，比如工作真的忙，比如公司文化就是这样，在比如领导犯浑，但加班表达出来的意思其实就是工作任务完不成了，要多花时间。那么不加班也意味着在正常的工作时间内能游刃有余的完成工作，是能力的体现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我也想实现这个梦想，所以我拒绝加班，领导也同意了，他说：“那你自己看着办吧， 我不强迫你”，然而我知道，我在这家公司只能在地板上混了，连天花板都别想碰到，更别谈升级，但是我觉得值，因为我想要更多的自由生活时间。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 00:13:00 +0000</pubDate>
<dc:creator>陈宏鸿</dc:creator>
<og:description>一 互联网公司程序员，前些天项目赶进度，被强制加班。 我们公司以前也是鼓励员工加班，但比较隐晦， 不是强制的，而这次是上司直接发话，必须要加班，否则工作无法完成的责任会扣到你头上。 被要求强行加班，无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aspwebchh/p/11854624.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html</guid>
<description>&lt;p&gt;生命周期决定了IServiceProvider对象采用怎样的方式提供和释放服务实例。虽然不同版本的依赖注入框架针对服务实例的生命周期管理采用了不同的实现，但总的来说原理还是类似的。在我们提供的&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;依赖注入框架Cat&lt;/a&gt;中，我们已经模拟了三种生命周期模式的实现原理，接下来我们结合“&lt;span&gt;服务范围&lt;/span&gt;”的概念来对这个话题做进一步讲述。&lt;/p&gt;

&lt;p&gt;对于依赖注入框架采用的三种生命周期模式（Singleton、Scoped和Transient）来说，Singleton和Transient都具有明确的语义，但是Scoped代表一种怎样的生命周期模式，很多初学者往往搞不清楚。这里所谓的Scope指的是由IServiceScope接口表示的“服务范围”，该范围由&lt;span&gt;IServiceScopeFactory&lt;/span&gt;接口表示的“服务范围工厂”来创建。如下面的代码片段所示，IServiceProvider的扩展方法CreateScope正是利用提供的IServiceScopeFactory服务实例来创建作为服务范围的IServiceScope对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServiceScope : IDisposable
{
    IServiceProvider ServiceProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServiceScopeFactory
{
    IServiceScope CreateScope();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderServiceExtensions
{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceScope CreateScope(&lt;span&gt;this&lt;/span&gt; IServiceProvider provider) =&amp;gt; provider.GetRequiredService&amp;lt;IServiceScopeFactory&amp;gt;&lt;span&gt;().CreateScope();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何一个IServiceProvider对象都可以利用其注册的IServiceScopeFactory服务创建一个代表服务范围的IServiceScope对象，后者代表的“范围”内具有一个新创建的IServiceProvider对象（对应着接口IServiceScope的ServiceProvider属性），该对象与当前IServiceProvider在逻辑上具有如下图所示的“父子关系”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075924047-2123512728.png&quot;&gt;&lt;img width=&quot;386&quot; height=&quot;230&quot; title=&quot;4-8&quot; alt=&quot;4-8&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075924387-1233916124.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示的树形层次结构只是一种逻辑结构，从对象引用层面来看，通过某个IServiceScope封装的IServiceProvider对象不需要知道自己的“父亲”是谁，它只关心作为根节点的IServiceProvider在哪里就可以了。下图从物理层面揭示了IServiceScope / IServiceProvider对象之间的关系，任何一个IServiceProvider对象都具有针对根容器的引用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075924652-624470460.png&quot;&gt;&lt;img width=&quot;286&quot; height=&quot;347&quot; title=&quot;4-9&quot; alt=&quot;4-9&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075924905-504107442.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只有在充分了解IServiceScope对象的创建过程以及它与IServiceProvider对象之间的关系之后，我们才会对三种生命周期管理模式（Singleton、Scoped和Transient）具有深刻的认识。就服务实例的提供方式来说，它们之间具有如下的差异：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Singleton：IServiceProvider对象创建的服务实例保存在作为&lt;span&gt;根容器的IServiceProvider对象&lt;/span&gt;上，所以多个&lt;span&gt;同根的IServiceProvider对象&lt;/span&gt;提供的针对同一类型的服务实例都是同一个对象。&lt;/li&gt;
&lt;li&gt;Scoped：IServiceProvider对象创建的服务实例由&lt;span&gt;自己保存&lt;/span&gt;，所以同一个IServiceProvider对象提供的针对同一类型的服务实例均是同一个对象。&lt;/li&gt;
&lt;li&gt;Transient：针对每一次服务提供请求，IServiceProvider对象&lt;span&gt;总是创建一个新的服务实例&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IServiceProvider除了为我们提供所需的服务实例之外，对于由它提供的服务实例，它还肩负起&lt;span&gt;回收释放&lt;/span&gt;的责任。这里所说的回收释放与.NET Core自身的垃圾回收机制无关，仅仅针对于自身类型实现了&lt;span&gt;IDisposable&lt;/span&gt;或者&lt;span&gt;IAsyncDisposable&lt;/span&gt;接口的服务实例（下面简称为Disposable服务实例），针对服务实例的释放体现为调用它们的Dispose或者DisposeAsync方法。IServiceProvider对象针对服务实例采用的回收释放策略取决于采用的生命周期模式，具体策略主要体现为如下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Singleton：提供Disposable服务实例保存在作为&lt;span&gt;根容器的IServiceProvider对象&lt;/span&gt;上，只有在这个IServiceProvider对象被释放的时候这些Disposable服务实例才能被释放。&lt;/li&gt;
&lt;li&gt;Scoped和Transient：&lt;span&gt;当前IServiceProvider对象&lt;/span&gt;会保存由它提供的Disposable服务实例，当自己被释放的时候，这些Disposable服务实例就会被释放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上所述，每个作为依赖注入容器的IServiceProvider对象都具有如下图所示的两个列表来存放服务实例，我们将它们分别命名为“&lt;span&gt;Realized Services&lt;/span&gt;”和“&lt;span&gt;Disposable Services&lt;/span&gt;”，对于一个作为非根容器的IServiceProvider对象来说，由它提供的Scoped服务保存在自身的Realized Services列表中，Singleton服务实例则会保存在根容器的Realized Services列表中。如果服务实现类型实现了IDisposable或者IAsyncDisposable接口，Scoped和Transient服务实例会被保存到自身的Disposable Services列表中，而Singleton服务实例则会保存到根容器的Disposable Services列表中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075925136-53532279.png&quot;&gt;&lt;img width=&quot;439&quot; height=&quot;343&quot; title=&quot;4-10&quot; alt=&quot;4-10&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075925340-829239909.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于作为根容器的IServiceProvider对象来说，Singleton和Scoped模式对它来说是两种等效的生命周期模式&lt;/span&gt;，由它提供的Singleton和Scoped服务实例会被存放到自身的Realized Services列表中，而所有需要被释放的服务实例则被存放到Disposable Services列表中。当某个IServiceProvider对象被用于提供针对指定类型的服务实例时，它会根据服务类型提取出表示服务注册的ServiceDescriptor对象并根据它得到对应的生命周期模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果生命周期模式为Singleton，并且作为根容器的Realized Services列表中包含对应的服务实例，它将作为最终提供的服务实例。如果这样的服务实例尚未创建，那么新的服务将会被创建出来并作为提供的服务实例。这个服务实例会被添加到根容器的Realized Services列表中。如果实例类型实现了IDisposable或者IAsyncDisposable接口，创建的服务实例会被添加到&lt;span&gt;根容器&lt;/span&gt;的Disposable Services列表中。&lt;/li&gt;
&lt;li&gt;如果生命周期为Scoped，那么IServiceProvider会先确定自身的Realized Services列表中是否存在对应的服务实例，存在的服务实例将作为最终的返回值。如果Realized Services列表不存在对应的服务实例，那么新的服务实例会被创建出来。在作为最终的服务实例被返回之前，创建的服务实例会被添加到自身的Realized Services列表中，如果实例类型实现了IDisposable或者IAsyncDisposable接口，创建的服务实例会被添加到&lt;span&gt;自身&lt;/span&gt;的Disposable Services列表中。&lt;/li&gt;
&lt;li&gt;如果提供服务的生命周期为Transient，那么IServiceProvider会直接创建一个新的服务实例。在作为最终的服务实例被返回之前，创建的服务实例会被添加到自身的Realized Services列表中，如果实例类型实现了IDisposable或者IAsyncDisposable接口，创建的服务实例会被添加到&lt;span&gt;自身&lt;/span&gt;的Disposable Services列表中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于非根容器的IServiceProvider对象来说，它的生命周期是由“包裹”着它的IServiceScope对象控制的。从前面给出的定义可以看出IServiceScope实现了IDisposable接口，Dispose方法的执行不仅标志着当前服务范围的终结，也意味着对应IServiceProvider对象生命周期的结束。&lt;/p&gt;
&lt;p&gt;当代表服务范围的IServiceScope对象的Dispose方法被调用的时候，它会调用对应IServiceProvider对象的Dispose方法。一旦IServiceProvider对象因自身Dispose方法的调用而被释放的时候，它会从自身的Disposable Services列表中提取出所有需要被释放的服务实例，并调用它们的Dispose或者DisposeAsync方法。在这之后，Disposable Services和Realized Services列表会被清空，列表中的服务实例和IServiceProvider对象自身会成为垃圾对象被GC回收。&lt;/p&gt;

&lt;p&gt;依赖注入框架所谓的服务范围在ASP.NET Core应用中具有明确的边界，指的是针对每个HTTP请求的上下文，也就是服务范围的生命周期与每个请求上下文绑定在一起。如下图所示，ASP.NET Core应用中用于提供服务实例的IServiceProvider对象分为两种类型，一种是作为根容器并与应用具有相同生命周期的IServiceProvider对象，另一个类则是根据请求及时创建和释放的IServiceProvider对象，我们一般将它们分别称为&lt;span&gt;ApplicationServices&lt;/span&gt;和&lt;span&gt;RequestServices&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075925576-1422963683.png&quot;&gt;&lt;img width=&quot;602&quot; height=&quot;402&quot; title=&quot;4-11&quot; alt=&quot;4-11&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191114075925852-792507313.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在ASP.NET Core应用初始化过程（即请求管道构建过程）中使用的服务实例都是由&lt;span&gt;ApplicationServices&lt;/span&gt;提供的。在具体处理每个请求时，ASP.NET Core框架会利用注册的一个中间件来针对当前请求创建一个代表服务范围的IServiceScope对象，该服务范围提供的&lt;span&gt;RequestServices&lt;/span&gt;用来提供当前请求处理过程中所需的服务实例。一旦服务请求处理完成，IServiceScoped对象代表的服务范围被终结，在当前请求处理过程中的Scoped服务会变成垃圾对象并最终被GC回收。对于实现了IDisposable或者IAsyncDisposable接口的Scoped或者Transient服务实例来说，在变成垃圾对象之前，它们的Dispose或者DisposeAsync方法会被调用。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 23:59:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>生命周期决定了IServiceProvider对象采用怎样的方式提供和释放服务实例。虽然不同版本的依赖注入框架针对服务实例的生命周期管理采用了不同的实现，但总的来说原理还是类似的。在我们提供的依赖注入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html</dc:identifier>
</item>
<item>
<title>web应用安全框架选型：Spring Security与Apache Shiro - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11854592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11854592.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191114073039122-824346673.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-springsecurity-框架简介&quot;&gt;一、 SpringSecurity 框架简介&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://projects.spring.io/spring-security/&quot; class=&quot;uri&quot;&gt;https://projects.spring.io/spring-security/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码: &lt;a href=&quot;https://github.com/spring-projects/spring-security/&quot; class=&quot;uri&quot;&gt;https://github.com/spring-projects/spring-security/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Security 是强大的，且容易定制的，基于Spring开发的实现认证登录与资源授权的应用安全框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringSecurity 的核心功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Authentication：认证，用户登陆的验证（解决你是谁的问题）&lt;/li&gt;
&lt;li&gt;Authorization：授权，授权系统资源的访问权限（解决你能干什么的问题）&lt;/li&gt;
&lt;li&gt;安全防护，防止跨站请求，session 攻击等&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二比较一下shiro与spring-security&quot;&gt;二、比较一下shiro与Spring Security&lt;/h2&gt;
&lt;p&gt;目前在java web应用安全框架中，与Spring Security形成直接竞争的就是shiro，二者在核心功能上几乎差不多，但从使用的角度各有优缺点。笔者认为：没有最好的，只有最合适的。&lt;/p&gt;
&lt;h3 id=&quot;用户量&quot;&gt;2.1 用户量&lt;/h3&gt;
&lt;p&gt;从使用情况上看，二者都在逐步提高使用量。shiro的使用量一直高于spring security.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191114073039484-1236949128.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用的方便程度&quot;&gt;2.2.使用的方便程度&lt;/h3&gt;
&lt;p&gt;通常来说，shiro入门更加容易，使用起来也非常简单，这也是造成shiro的使用量一直高于Spring Security的主要原因。但是从笔者的角度来看，二者其实都简单，我说说我的理由：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在没有Spring Boot之前，Spring Security的大部分配置要通过XML实现，配置还是还是非常复杂的。但是有了 Spring Boot之后，这一情况已经得到显著改善。&lt;/li&gt;
&lt;li&gt;Spring Security之所以看上去比shiro更复杂，其实是因为它引入了一些不常用的概念与规则。大家应该都知道2/8法则，这在Spring Security里面体现的特别明显，如果你只学Spring Security最重要的那20%，这20%的复杂度和shiro基本是一致的。也就是说，不重要的那80%，恰恰是Spring Security比shiro的“复杂度”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，如果有人能帮你把Spring Security最重要的那20%摘出来，二者的入门门槛、复杂度其实是差不太多的。&lt;/p&gt;
&lt;h3 id=&quot;社区支持&quot;&gt;2.3.社区支持&lt;/h3&gt;
&lt;p&gt;Spring Security依托于Spring庞大的社区支持，这点自不必多说。shiro属于apache社区，因为它的广泛使用，文档也非常的全面。二者从社区支持来看，几乎不相上下。&lt;/p&gt;
&lt;p&gt;但是从社区发展的角度看，Spring Security明显更占优势，随着Spring Cloud、Spring Boot、Spring Social的长足进步，这种优势会越来越大。因为Spring Security毕竟是Spring的亲儿子，Spring Security未来在于Spring系列框架集成的时候一定会有更好的融合性，前瞻性、兼容性！这也是为什么我们要学Spring Security的主要原因！&lt;/p&gt;
&lt;h3 id=&quot;功能丰富性&quot;&gt;2.4.功能丰富性&lt;/h3&gt;
&lt;p&gt;Spring Security因为它的复杂，所以从功能的丰富性的角度更胜一筹。其中比较典型的如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Security默认含有对OAuth2.0的支持，与Spring Social一起使用完成社交媒体登录也比较方便。shiro在这方面只能靠自己写代码实现。&lt;/li&gt;
&lt;li&gt;还有一种普遍说法：Spring Security在网络安全的方面下的功夫更多，但是笔者并未有非常直接的感受，有可能出现安全问题的时候才会感到不够安全的痛。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;如果你只是想实现一个简单的web应用，shiro更加的轻量级，学习成本也更低。如果您正在开发一个分布式的、微服务的、或者与Spring Cloud系列框架深度集成的项目，笔者还是建议您使用Spring Security。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Wed, 13 Nov 2019 23:31:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、 SpringSecurity 框架简介 官网：https://projects.spring.io/spring security/ 源代码: 'https://github.com/sprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11854592.html</dc:identifier>
</item>
<item>
<title>羞，Java 字符串拼接竟然有这么多姿势 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11854565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11854565.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;二哥，我今年大二，看你分享的《阿里巴巴 Java 开发手册》上有一段内容说：“循环体内，拼接字符串最好使用 StringBuilder 的 append 方法，而不是 + 号操作符。”到底为什么啊，我平常一直就用的‘+’号操作符啊！二哥有空的时候能否写一篇文章分析一下呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就在昨天，一位叫小菜的读者微信我说了上面这段话。&lt;/p&gt;
&lt;p&gt;我当时看到这条微信的第一感觉是：小菜你也太菜了吧，这都不知道为啥啊！我估计正在读这篇文章的你也会有同样的感觉。&lt;/p&gt;
&lt;p&gt;但扪心自问，在&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;做程序员的前两年内，我也不知道为啥。遇到&lt;a href=&quot;http://www.itwanger.com/java/2019/11/08/java-string.html&quot;&gt;字符串&lt;/a&gt;拼接就上“+”号操作符，甭管是不是在循环体内。和小菜比起来，我当时可没他这么幸运，还有一位热心的“二哥”能够分享这份价值连城的开发手册。&lt;/p&gt;
&lt;p&gt;既然我这么热心分享，不如好人做到底，对不对？我就认认真真地写一篇文章，给小菜解惑一下。&lt;/p&gt;
&lt;h3 id=&quot;号操作符&quot;&gt;01、“+”号操作符&lt;/h3&gt;
&lt;p&gt;要说姿势，“+”号操作符必须是字符串拼接最常用的一种了，没有之一。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String chenmo = &quot;沉默&quot;;
String wanger = &quot;王二&quot;;

System.out.println(chenmo + wanger);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把这段代码使用 JAD 反编译一下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String chenmo = &quot;\u6C89\u9ED8&quot;; // 沉默
String wanger = &quot;\u738B\u4E8C&quot;; // 王二
System.out.println((new StringBuilder(String.valueOf(chenmo))).append(wanger).toString());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我去，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append 方法。也就是说，“+”号操作符在拼接字符串的时候只是一种形式主义，让开发者使用起来比较简便，代码看起来比较简洁，读起来比较顺畅。算是 Java 的一种语法糖吧。&lt;/p&gt;
&lt;h3 id=&quot;stringbuilder&quot;&gt;02、StringBuilder&lt;/h3&gt;
&lt;p&gt;除去“+”号操作符，StringBuilder 的 append 方法就是第二个常用的字符串拼接姿势了。&lt;/p&gt;
&lt;p&gt;先来看一下 StringBuilder 类的 append 方法的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public StringBuilder append(String str) {
    super.append(str);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这 3 行代码没啥可看的，可看的是父类 AbstractStringBuilder 的 append 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。&lt;code&gt;appendNull&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = 'n';
    value[c++] = 'u';
    value[c++] = 'l';
    value[c++] = 'l';
    count = c;
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）拼接后的字符数组长度是否超过当前值，如果超过，进行扩容并复制。&lt;code&gt;ensureCapacityInternal&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length &amp;gt; 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）将拼接的字符串 str 复制到目标数组 value 中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;str.getChars(0, len, value, count)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stringbuffer&quot;&gt;03、StringBuffer&lt;/h3&gt;
&lt;p&gt;先有 StringBuffer 后有 StringBuilder，两者就像是孪生双胞胎，该有的都有，只不过大哥 StringBuffer 因为多呼吸两口新鲜空气，所以是线程安全的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;StringBuffer 类的 append 方法比 StringBuilder 多了一个关键字 synchronized，可暂时忽略 &lt;code&gt;toStringCache = null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;synchronized 是 Java 中的一个非常容易脸熟的关键字，是一种同步锁。它修饰的方法被称为同步方法，是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;string-类的-concat-方法&quot;&gt;04、String 类的 concat 方法&lt;/h3&gt;
&lt;p&gt;单就姿势上来看，String 类的 concat 方法就好像 StringBuilder 类的 append。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String chenmo = &quot;沉默&quot;;
String wanger = &quot;王二&quot;;

System.out.println(chenmo.concat(wanger));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章写到这的时候，我突然产生了一个奇妙的想法。假如有这样两行代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;chenmo += wanger
chenmo = chenmo.concat(wanger)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们之间究竟有多大的差别呢？&lt;/p&gt;
&lt;p&gt;之前我们已经了解到，&lt;code&gt;chenmo += wanger&lt;/code&gt; 实际上相当于 &lt;code&gt;(new StringBuilder(String.valueOf(chenmo))).append(wanger).toString()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要探究“+”号操作符和 &lt;code&gt;concat&lt;/code&gt; 之间的差别，实际上要看 append 方法和 concat 方法之间的差别。&lt;/p&gt;
&lt;p&gt;append 方法的源码之前分析过了。我们就来看一下 concat 方法的源码吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (otherLen == 0) {
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）将原字符串的字符数组 value 复制到变量 buf 数组中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;char buf[] = Arrays.copyOf(value, len + otherLen);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;str.getChars(buf, len);
return new String(buf, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码分析我们大致可以得出以下结论：&lt;/p&gt;
&lt;p&gt;1）如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+”号操作符会当做是“null”字符串来处理。&lt;/p&gt;
&lt;p&gt;2）如果拼接的字符串是一个空字符串（&quot;&quot;），那么 concat 的效率要更高一点。毕竟不需要 &lt;code&gt;new StringBuilder&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;3）如果拼接的字符串非常多，concat 的效率就会下降，因为创建的字符串对象越多，开销就越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;弱弱地问一下啊，还有在用 JSP 的同学吗？EL 表达式中是不允许使用“+”操作符来拼接字符串的，这时候就只能用 &lt;code&gt;concat&lt;/code&gt; 了。&lt;/p&gt;
&lt;pre class=&quot;jsp&quot;&gt;
&lt;code&gt;${chenmo.concat('-').concat(wanger)}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string-类的-join-方法&quot;&gt;05、String 类的 join 方法&lt;/h3&gt;
&lt;p&gt;JDK 1.8 提供了一种新的字符串拼接姿势：String 类增加了一个静态方法 join。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String chenmo = &quot;沉默&quot;;
String wanger = &quot;王二&quot;;
String cmower = String.join(&quot;&quot;, chenmo, wanger);
System.out.println(cmower);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数为字符串连接符，比如说：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String message = String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：王二-太特么-有趣了&lt;/p&gt;
&lt;p&gt;我们来看一下 join 方法的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static String join(CharSequence delimiter, CharSequence... elements) {
    Objects.requireNonNull(delimiter);
    Objects.requireNonNull(elements);
    // Number of elements not likely worth Arrays.stream overhead.
    StringJoiner joiner = new StringJoiner(delimiter);
    for (CharSequence cs: elements) {
        joiner.add(cs);
    }
    return joiner.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现了一个新类 StringJoiner，类名看起来很 6，读起来也很顺口。StringJoiner 是 &lt;code&gt;java.util&lt;/code&gt; 包中的一个类，用于构造一个由分隔符重新连接的字符序列。限于篇幅，本文就不再做过多介绍了，感兴趣的同学可以去了解一下。&lt;/p&gt;
&lt;h3 id=&quot;stringutils.join&quot;&gt;06、StringUtils.join&lt;/h3&gt;
&lt;p&gt;实战项目当中，我们处理字符串的时候，经常会用到这个类——&lt;code&gt;org.apache.commons.lang3.StringUtils&lt;/code&gt;，该类的 join 方法是字符串拼接的一种新姿势。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String chenmo = &quot;沉默&quot;;
String wanger = &quot;王二&quot;;

StringUtils.join(chenmo, wanger);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法更善于拼接数组中的字符串，并且不用担心 NullPointerException。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StringUtils.join(null)            = null
StringUtils.join([])              = &quot;&quot;
StringUtils.join([null])          = &quot;&quot;
StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过查看源码我们可以发现，其内部使用的仍然是 StringBuilder。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }

    final StringBuilder buf = new StringBuilder(noOfItems * 16);

    for (int i = startIndex; i &amp;lt; endIndex; i++) {
        if (i &amp;gt; startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家读到这，不约而同会有这样一种感觉：我靠（音要拖长），没想到啊没想到，字符串拼接足足有 6 种姿势啊，晚上回到家一定要一一尝试下。&lt;/p&gt;
&lt;h3 id=&quot;给小菜一个答复&quot;&gt;07、给小菜一个答复&lt;/h3&gt;
&lt;p&gt;我相信，小菜读到我这篇文章的时候，他一定会明白为什么阿里巴巴不建议在 for 循环中使用”+”号操作符进行字符串拼接了。&lt;/p&gt;
&lt;p&gt;来看两段代码。&lt;/p&gt;
&lt;p&gt;第一段，for 循环中使用”+”号操作符。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String result = &quot;&quot;;
for (int i = 0; i &amp;lt; 100000; i++) {
    result += &quot;六六六&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二段，for 循环中使用 append。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StringBuilder sb = new StringBuilder();
for (int i = 0; i &amp;lt; 100000; i++) {
    sb.append(&quot;六六六&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两段代码分别会耗时多长时间呢？在我的 iMac 上测试出的结果是：&lt;/p&gt;
&lt;p&gt;1）第一段代码执行完的时间为 6212 毫秒&lt;/p&gt;
&lt;p&gt;2）第二段代码执行完的时间为 1 毫秒&lt;/p&gt;
&lt;p&gt;差距也太特么大了吧！为什么呢？&lt;/p&gt;
&lt;p&gt;我相信有不少同学已经有了自己的答案：第一段的 for 循环中创建了大量的 StringBuilder 对象，而第二段代码至始至终只有一个 StringBuilder 对象。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;08、最后&lt;/h3&gt;
&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就随手点个赞👍，这将是我最强的写作动力。如果觉得文章对你有点帮助，还挺有趣，就关注一下我的公众号「&lt;strong&gt;沉默王二&lt;/strong&gt;」。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 22:00:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>二哥，我今年大二，看你分享的《阿里巴巴 Java 开发手册》上有一段内容说：“循环体内，拼接字符串最好使用 StringBuilder 的 append 方法，而不是 + 号操作符。”到底为什么啊，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11854565.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(十四) Toast 浅入浅出 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/11823411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/11823411.html</guid>
<description>&lt;p&gt;本篇参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/component-library/bundle/force:showToast/specification&quot;&gt;https://developer.salesforce.com/docs/component-library/bundle/force:showToast/specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://archive-2_9_4.lightningdesignsystem.com/components/toast/&quot;&gt;https://archive-2_9_4.lightningdesignsystem.com/components/toast/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Toast在项目中是基本不可能用不到的组件，用于在页面头部展示一条消息。之前也经常的用，但是没有深入的研究过，最近正好开始做lightning项目，便深入研究了一下，发现比以前了解的稍微多点，特此总结，便于以后的查看以及给没有接触过的小伙伴扫个盲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. Toast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Toast 用于在页面的头部展示一条消息，比如我们在更新数据完成后会提示修改成功，出现异常会提示更新失败等。Lightning将Toast封装成了事件，我们只需要根据指定的步骤获取Toast事件并且进行fire触发即可。下方的demo中展示了toast的使用，使用 $A.get(&quot;e.force:showToast&quot;)便可以获取事件，添加相关的属性触发即可实现Toast功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
showToast : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastEvent = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
    toastEvent.setParams({
        &lt;/span&gt;&quot;title&quot;: &quot;Success!&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;message&quot;: &quot;The record has been updated successfully.&quot;&lt;span&gt;
    });
    toastEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么 Toast 有哪些参数呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;title：此参数用于展示message的标题区域，通常标题会以稍微大的字体展示在上方；&lt;/li&gt;
&lt;li&gt;duration：此参数用于设置当前的Toast展示多久后自动消失，单位为毫秒，此属性可以不填写，默认为5秒中，如果设置的时间不足5秒也会按照5秒处理；&lt;/li&gt;
&lt;li&gt;message：此参数用于展示显示Toast的内容；&lt;/li&gt;
&lt;li&gt;mode：Toast展示的模式，Toast支持三种模式：dismissible(展示的消息包含一个关闭按钮，如果点击按钮则可以马上Toast消失，如果不点击则默认过5秒消失，这个是默认选项) / pester（不展示关闭按钮，过几秒以后自动消失） / sticky（只展示关闭按钮，不点击关闭按钮则永远不消失）&lt;/li&gt;
&lt;li&gt;type：Toast的类型，不同的类型会展示不同的图标以及不同的颜色样式。可选择的值有： error / warning / success / info / other。 前四个我们可能经常用，最后一个不经常用，其实other是此属性的默认值，展示的颜色样式和info相同，区别是此种不展示图标。当然不展示图标不是绝对的，如果搭配了key属性可以展示其他的图标，所以如果我们想要展示info的样式但是不想使用info的图标，我们可以考虑使用other然后设置key即可。&lt;/li&gt;
&lt;li&gt;key：当我们的type选择了other的情况下，此处可以指定toast里面展示的other图标，名字可以在lightning design system的icon中选择。&lt;/li&gt;
&lt;li&gt;messageTemplate： 上面的message用于Toast的消息展示，但是只能展示String字符串的信息，如果我们需要其他增强的功能展示（比如想要在toast的message中展示一个可以点击的URL），我们需要使用messageTemplate通过placeholder放入形参，使用messageTemplateData进行填充。 messageTemplate的placeholder很像我们在custom label中声明，也是从0开始，使用{}.比如Record {0} created! See it {1}这里就设置了两个placeholder，messageTemplateData需要传两个参数进来。&lt;/li&gt;
&lt;li&gt;messageTemplateData：当时用了messageTemplate以后，需要使用此属性去将placeholder的值进行替换，里面封装的是一组text文本以及其对应的action。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了Toast以外，小伙伴们可以自行查看： lightning:overlayLibrary（通过Modal 以及 popover展示消息） / lightning:notificationsLibrary（通过notice和toast方式展示消息）&lt;/p&gt;
&lt;p&gt;上面既然已经描述完Toast的所有属性以及Toast所能实现的功能，那么我们接下来对常用的展示可以进行一些简单的优化和处理。&lt;/p&gt;
&lt;p&gt;场景一. 内容多行展示&lt;/p&gt;
&lt;p&gt;Toast默认只能展示单行的内容，我们做了一个demo，将toast设置了sticky，这样我们可以查看到Toast的html的解析的实现，实现如下图所示。通过图片中的css内容我们可以看到toast的内容使用toastMessage forceActionsText两个进行渲染，因为css渲染也有前后顺序，我们只需要对这两个css样式进行重写，设置white-space: pre-line !important; 即可，意为如果有空格情况下，合并所有空行并且保留换行，然后message中对需要换行的地方使用\n进行字符串分隔即可从而实现换行的。&lt;/p&gt;
&lt;p&gt;我们尝试的在当前的component bundle的css重新渲染此样式发现不可用，所以只能引入外部的static resource覆盖此样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.toastMessage.forceActionsText&lt;/span&gt;{&lt;span&gt;
    white-space &lt;/span&gt;:&lt;span&gt; pre-line !important&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式为创建css,内容为上面描述的内容，然后命名上传到 static resource，代码引入即可。demo中我们命名的static resource名称为multipleLineToastCss。&lt;/p&gt;
&lt;p&gt;代码中我们只需要&amp;lt;ltng:require styles=&quot;{!$Resource.multipleLineToastCss}&quot;/&amp;gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201911/910966-20191108213524455-46986509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们做了简单的demo去验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForAllPageTypes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ltng:require &lt;/span&gt;&lt;span&gt;styles&lt;/span&gt;&lt;span&gt;=&quot;{!$Resource.multipleLineToastCss}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;variant&lt;/span&gt;&lt;span&gt;=&quot;brand&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;show toast&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.showToast}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的controller.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
showToast : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastEvent = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
   toastEvent.setParams({
        mode: &lt;/span&gt;'sticky'&lt;span&gt;,
        title: &lt;/span&gt;'Info'&lt;span&gt;,
        type: &lt;/span&gt;'info'&lt;span&gt;,
        message: &lt;/span&gt;'test message\ntest multiple lines'&lt;span&gt;
    });
    toastEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201911/910966-20191113000442190-1759639981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景二.  Toast展示可点击的URL&lt;/p&gt;
&lt;p&gt;某些场景下，我们需要展示Toast的时候搭配URL，用户点击URL后跳转到某个页面。此种情况下我们只需要使用 messageTemplate 以及 messageTemplateData进行搭配即可实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
showMyToast : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastEvent = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
    toastEvent.setParams({
        mode: &lt;/span&gt;'sticky'&lt;span&gt;,
        message: &lt;/span&gt;'This is a required message'&lt;span&gt;,
        messageTemplate: &lt;/span&gt;'Record {0} created! See it {1}!'&lt;span&gt;,
        messageTemplateData: [&lt;/span&gt;'Salesforce'&lt;span&gt;, {
            url: &lt;/span&gt;'http://www.salesforce.com/'&lt;span&gt;,
            label: &lt;/span&gt;'here'&lt;span&gt;,
            }
        ]
    });
    toastEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201911/910966-20191112235718730-1039284165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 场景三. 换 Toast的message的图标&lt;/p&gt;
&lt;p&gt;我们知道当toast的type赋值时，针对success/warning/error/info都会有默认的样式以及图标，当我们需要展示其他的图标时，我们只需要设置type为other或者不设置type（默认为other），然后设置key即可。key的话，我们可以找到lightning design system中的icon的名称赋值即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
showToast : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastEvent = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
    toastEvent.setParams({
        mode: &lt;/span&gt;'sticky'&lt;span&gt;,
        title: &lt;/span&gt;'Info'&lt;span&gt;,
        type: &lt;/span&gt;'other'&lt;span&gt;,
        key:&lt;/span&gt;'like'&lt;span&gt;,
        message: &lt;/span&gt;'test message\ntest multiple lines'&lt;span&gt;
    });
    toastEvent.fire();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201911/910966-20191113001002506-1565282312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;二. aura:method&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多内容我们可以进行公用的组件化操作，比如针对toast的展示（我们只需要设置方法传递参数，调用即可，不需要每个component的controller/helper js方法都重复的声明Toast的声明以及触发），针对picklist值获取，针对表字段label的获取。制作公用组建需要先了解一个aura封装的组件名称，aura:method。&lt;/p&gt;
&lt;p&gt; 我们在前端正常去进行方法调用通常是绑定一个handler或者执行某个事件从而去调用方法，使用aura:method定义一个方法可以作为组件的API的一部分，这样我们在client-controller部分可以直接调用此方法。使用aura:method可以设置传入的参数，也可以设置返回的同步或者异步的结果，所以通常我们可以使用aura:method去做共用组建的内容，作为公用组件，使用aura:method去声明，其他的component只需要引入此公用组件便有权限直接调用aura:method声明的方法了。&lt;/p&gt;
&lt;p&gt;aura:method总共有以下的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name： 用来声明方法的名称，后期调用直接使用此方法调用，传递相关的参数即可；&lt;/li&gt;
&lt;li&gt;action：此方法要去调用的client-controller的方法；&lt;/li&gt;
&lt;li&gt;access：public(在相同namespace的component可以调用此方法) / global(在所有的namespace的component可以调用此方法)；&lt;/li&gt;
&lt;li&gt;description：方法描述。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了以上属性以外，方法还要有参数，使用aura:attribute去声明方法体里的参数项。aura:method可以实现同步以及异步的返回，感兴趣的可以查看细节，下面内容为通过aura:method实现Toast公用组件。&lt;/p&gt;
&lt;p&gt;ToastServiceComponent.cmp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;access&lt;/span&gt;&lt;span&gt;=&quot;global&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ltng:require &lt;/span&gt;&lt;span&gt;styles&lt;/span&gt;&lt;span&gt;=&quot;{!$Resource.multipleLineToastCss}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:method &lt;/span&gt;&lt;span&gt;access&lt;/span&gt;&lt;span&gt;=&quot;global&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;showToast&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.showToastAction}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;the body message will show. use \n to break lines&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;displayTitle&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;the title hearder will show&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;displayType&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;success/warning/error/info/other&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mode&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;dismissible/pester/sticky&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;key&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;you can set name from lightning design system icon section&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ToastServiceComponentController.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    showToastAction : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; params = event.getParam('arguments'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastEvent = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type =&lt;span&gt; params.displayType;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(params.key) {
            type &lt;/span&gt;= 'other'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;params.mode) {
            params.mode &lt;/span&gt;= 'dismissible'&lt;span&gt;;
        }
        toastEvent.setParams({
            &lt;/span&gt;&quot;title&quot;&lt;span&gt;: params.displayTitle,
            &lt;/span&gt;&quot;message&quot;&lt;span&gt;: params.message,
            &lt;/span&gt;&quot;type&quot;&lt;span&gt;: type,
            &lt;/span&gt;&quot;mode&quot;&lt;span&gt;:params.mode,
            &lt;/span&gt;&quot;key&quot;&lt;span&gt;: params.key
        });

        toastEvent.fire();
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是调用：&lt;/p&gt;
&lt;p&gt;SimpleToastDemo.cmp：需要引入ToastServiceComponent，设置一个local id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForAllPageTypes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:ToastServiceComponent &lt;/span&gt;&lt;span&gt;aura:id&lt;/span&gt;&lt;span&gt;=&quot;toastService&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;variant&lt;/span&gt;&lt;span&gt;=&quot;brand&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;show toast&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.showToastHandler}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SimpleToastDemoController.js： find到aura:id，然后调用方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    showToastHandler : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastService = component.find('toastService'&lt;span&gt;);
        toastService.showToast(&lt;/span&gt;'this is a toast demo\n this can allow multiple lines\nhere we show like icon','simple toast demo','other','dismissible','like'&lt;span&gt;)
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;展示如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201911/910966-20191114002350443-261089018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;总结：&lt;/strong&gt;篇中简单介绍Toast以及aura:method，详细了解的自行查看文档，感兴趣的最好了解一下 lightning:overlayLibrary以及lightning:notificationsLibrary。篇中有错误的地方欢迎指出，有不懂的欢迎留言。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 16:31:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>本篇参考： https://developer.salesforce.com/docs/component-library/bundle/force:showToast/specification h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/11823411.html</dc:identifier>
</item>
<item>
<title>2. 彤哥说netty系列之IO的五种模型 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11854235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11854235.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000330956-1017331932.png&quot; alt=&quot;netty&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你好，我是彤哥，本篇是netty系列的第二篇。&lt;/p&gt;

&lt;p&gt;本文将介绍linux中的五种IO模型，同时也会介绍阻塞/非阻塞与同步/异步的区别。&lt;/p&gt;

&lt;p&gt;对于一次IO操作，数据会先拷贝到内核空间中，然后再从内核空间拷贝到用户空间中，所以一次read操作，会经历两个阶段：&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;等待数据准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;数据从内核空间拷贝到用户空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于以上两个阶段就产生了五种不同的IO模式。&lt;/p&gt;

&lt;p&gt;从进程发起IO操作，一直等待上述两个阶段完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶段一起阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000331258-345428442.png&quot; alt=&quot;blocking-io&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进程一直询问IO准备好了没有，准备好了再发起读取操作，这时才把数据从内核空间拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段不阻塞但要轮询，第二阶段阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000331622-2041451099.png&quot; alt=&quot;nonblocking-io&quot;/&gt;&lt;/p&gt;

&lt;p&gt;多个连接使用同一个select去询问IO准备好了没有，如果有准备好了的，就返回有数据准备好了，然后对应的连接再发起读取操作，把数据从内核空间拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶段分开阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000332473-1919115381.png&quot; alt=&quot;multiplexing-io&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进程发起读取操作会立即返回，当数据准备好了会以通知的形式告诉进程，进程再发起读取操作，把数据从内核空间拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段不阻塞，第二阶段阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000333086-1295093620.gif&quot; alt=&quot;signal-io&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进程发起读取操作会立即返回，等到数据准备好且已经拷贝到用户空间了再通知进程拿数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个阶段都不阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000334268-66663561.png&quot; alt=&quot;asynchronous-io&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各种IO模式同比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191114000335090-1910477389.png&quot; alt=&quot;model&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步非同步的区别在于调用操作系统的recvfrom()的时候是否阻塞，可见除了最后的异步IO其它都是同步IO。&lt;/p&gt;

&lt;p&gt;select 有最大文件描述符的限制，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。&lt;/p&gt;
&lt;p&gt;poll 没有最大文件描述符的限制，与select一样，只能监听到有几个文件描述符就绪了，得遍历所有文件描述符获取就绪的IO。&lt;/p&gt;
&lt;p&gt;epoll 没有最大文件描述符的限制，它通过回调的机制，一旦某个文件描述符就绪了，迅速激活这个文件描述符，当进程下一次调用epoll_wait()的时候便得到通知。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;在有大量空闲连接的时候，epoll的效率要高很多&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java中的nio使用的是哪种IO模型呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Java中的nio实际上是&lt;strong&gt;new io&lt;/strong&gt;的缩写，它使用的是&lt;strong&gt;多路复用的IO模型&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本文对IO的五种模型做了很简短的总结，没看懂的同学可以看看下面这篇文章，讲得很详细。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000003063859&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，也欢迎来我的公从号&lt;strong&gt;彤哥读源码&lt;/strong&gt;系统地学习&lt;strong&gt;源码&amp;amp;架构&lt;/strong&gt;的知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/code.gif&quot; alt=&quot;code&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 16:04:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>你好，我是彤哥，本篇是netty系列的第二篇。 简介 本文将介绍linux中的五种IO模型，同时也会介绍阻塞/非阻塞与同步/异步的区别。 何为IO模型 对于一次IO操作，数据会先拷贝到内核空间中，然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11854235.html</dc:identifier>
</item>
<item>
<title>CSS(4)---三大特性(继承性，层叠性，优先级) - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11787327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11787327.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;CSS有三大特性分别是: &lt;code&gt;继承性&lt;/code&gt;，&lt;code&gt;层叠性&lt;/code&gt;，&lt;code&gt;优先级&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一继承性&quot;&gt;&lt;span&gt;一、继承性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.并不是所有的属性都可以继承, 只有以color/font-/text-/line-开头的属性才可以继承
2.在CSS的继承中不仅仅是儿子可以继承, 只要是后代都可以继承
3.继承性中的特殊性
   3.1 a标签的文字颜色和下划线是不能继承的
   3.2 h标签的文字大小是不能继承的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- 样式部分 --&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    .father { 
         width: 300px;            /*设置宽度*/
         font-size: 20px;         /* 设置字体*/
         text-align: right;       /* 字体右对齐*/
         background-color: green; /*背景颜色绿色*/
         color:red; /*字体颜色红色*/
     }
 &amp;lt;/style&amp;gt;
 
&amp;lt;!-- html部分 --&amp;gt;
 &amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;father&quot;&amp;gt;father标签
      &amp;lt;p&amp;gt;father子标签 p&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191104233546374-974845314.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个例子中可以看出子标签p继承了父类div的样式。&lt;/p&gt;

&lt;h2 id=&quot;二层叠性&quot;&gt;&lt;span&gt;二、层叠性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 层叠性就是CSS处理冲突的一种能力。层叠性只有在多个选择器选中 &lt;code&gt;同一个标签&lt;/code&gt;, 然后又设置了&lt;code&gt;相同的属性&lt;/code&gt;, 才会发生层叠性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;CSS三大特性之层叠性&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        p {
            color: red;
        }
        p {
            color: blue;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p style=&quot;color: black&quot;&amp;gt;我是段落&amp;lt;/p&amp;gt; &amp;lt;!-- 最终显示black 就近原则 black &amp;gt; blue &amp;gt; red --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在相同优先级的的情况下 下面的样式元素会将上面的层叠掉。&lt;/p&gt;

&lt;h2 id=&quot;三css优先级&quot;&gt;&lt;span&gt;三、CSS优先级&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 当多个选择器选中同一个标签, 并且给同一个标签设置相同的属性时, 如何层叠就由优先级来确定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优先级&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;!important&amp;gt;行内样式&amp;gt;id选择器&amp;gt;类选择器&amp;gt;标签选择器&amp;gt;通配符&amp;gt;继承 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;补充说明&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。
2、行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。
3、权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。
4、CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于CSS权重，有一套计算公式来去计算，用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191104233835305-1782359076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分权重是可以叠加的。比如的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;div ul  li   ------&amp;gt;      0,0,0,3
a:hover      -----—&amp;gt;      0,0,1,1
.son ul li   ------&amp;gt;      0,0,1,2
.son a       ------&amp;gt;      0,0,1,1   
#son p       ------&amp;gt;      0,1,0,1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于并集选择器来说不是权重的加和，因为理论上它还是独立的，它只相当于将多个选择器的相同内容归于一个并集选择器中，理论上每一个选择器还是独立的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div,p {
            color: green; /*这里不能是0,0,0,2 而是两个0,0,0,1*/
        }

        p {
            color: red;  /*对于p标签最终会显示红色 0,0,0,1 (因为和上面优先级一样，所以下面会覆盖上面样式)*/
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;标签什么颜色&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;四经典测试题&quot;&gt;&lt;span&gt;四、经典测试题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里举几个测试题来巩固下css优先级的知识。首先我们要知道如何推断标签的最终样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 先找到影响文字的最里面的盒子
2. 然后计算权重
3. 如果权重一样，看层叠性&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第一题&quot;&gt;1、第一题&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;第2题&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #father{
                color:red;  /* 继承的权重为 0,0,0,0 */
            }
            p{
                color:blue;  /* 权重 0,0,0,1 */
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;father&quot;&amp;gt;
            &amp;lt;p&amp;gt;试问这行字体是什么颜色的？&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;答案&lt;/code&gt; 蓝色。&lt;/p&gt;
&lt;h4 id=&quot;第二题&quot;&gt;2、第二题&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;
&amp;lt;html&amp;gt;      
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;第1题&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            #father #son{    /*权重: 0,2,0,0 */
                color:blue;
            }
            #father p.c2{   /* 权重: 0,1,1,1 */
                color:black;
            }
            div.c1 p.c2{    /* 权重 0,0,2,2 */
                color:red;
            }
            #father{
                color:green !important;  /* 继承的权重为 0,0,0,0 */
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;father&quot; class=&quot;c1&quot;&amp;gt;
            &amp;lt;p id=&quot;son&quot; class=&quot;c2&quot;&amp;gt;
                试问这行字体是什么颜色的？
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;答案&lt;/code&gt; 蓝色。&lt;/p&gt;
&lt;h4 id=&quot;第三题&quot;&gt;3、第三题&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        div div div div div div div div div div div div{  /* 权重 0,0,0,11 (最后一位数再怎么相加都不会向前进一位) */
            color:red;
        }
        .me{ 
            color:blue; /* 权重 0,0,1,0 */
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;
                    &amp;lt;div&amp;gt;
                        &amp;lt;div&amp;gt;
                            &amp;lt;div&amp;gt;
                                &amp;lt;div&amp;gt;
                                    &amp;lt;div&amp;gt;
                                        &amp;lt;div&amp;gt;
                                            &amp;lt;div&amp;gt;
                                                &amp;lt;div class=&quot;me&quot;&amp;gt;试问这行文字是什么颜色的&amp;lt;/div&amp;gt;
                                            &amp;lt;/div&amp;gt;
                                        &amp;lt;/div&amp;gt;
                                    &amp;lt;/div&amp;gt;
                                &amp;lt;/div&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;答案&lt;/code&gt; 蓝色。&lt;/p&gt;
&lt;h4 id=&quot;第四题&quot;&gt;4、第四题&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;第四题&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .c1 .c2 div{       /* 权重 0,0,2,1 */
            color: blue;
        }
        div #box3{         /* 权重 0,1,0,1 */
            color:green;
        }
        #box1 div{         /* 权重 0,1,0,1 */
            color:yellow;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;box1&quot; class=&quot;c1&quot;&amp;gt;
        &amp;lt;div id=&quot;box2&quot; class=&quot;c2&quot;&amp;gt;
            &amp;lt;div id=&quot;box3&quot; class=&quot;c3&quot;&amp;gt;
                文字显示什么颜色
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;答案&lt;/code&gt; 黄色 （如果权重一样，看层叠性）&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;你如果愿意有所作为，就必须有始有终。(6)&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 13 Nov 2019 15:03:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>CSS(4) 三大特性(继承性，层叠性，优先级) CSS有三大特性分别是: ，`层叠性 优先级`。 一、继承性 给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。 注意 运行结果 从这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11787327.html</dc:identifier>
</item>
<item>
<title>使用.net core中的类DispatchProxy实现AOP - 欧阳.NET</title>
<link>http://www.cnblogs.com/oyang168/p/11853851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oyang168/p/11853851.html</guid>
<description>&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是软件开发中的一个热点，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性。&lt;/p&gt;
&lt;p&gt;比如说三层的调用：UI =&amp;gt; BLL =&amp;gt; DAL，正常来说我们会在UI层调用BLL层某个类的某个方法，然后BLL层某个类的某个方法又会调用DAL层某个类的某个方法，可以说通常情况下我们都是这么干的；如果说UI调BLL、BLL调DAL是纵向的话，那么AOP就是横向的，AOP可以做到在调用BLL层或DAL层任意方法之前之后做一些统一的逻辑处理。&lt;/p&gt;
&lt;p&gt;AOP的典型应用场景：日志记录、权限验证、异常处理、缓存等&lt;/p&gt;
&lt;p&gt;目前，可以实现AOP的类库也有很多，如下：&lt;/p&gt;
&lt;p&gt;AspectCore&lt;br/&gt;Unity&lt;br/&gt;Castle DynamicProxy&lt;br/&gt;Dora.Interception&lt;/p&gt;

&lt;p&gt;但是在.net core中有DispatchProxy类（命名空间:System.Reflection），提供实例化代理对象和处理其方法调度的机制，借助它我们可以自己实现AOP，直接看示例&lt;/p&gt;

&lt;p&gt;定义一个消息接口IMessage，其中有一个发送消息Send和接收消息Receive的方法定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMessage
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Send(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Receive(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;定义电子邮件类EmailMessage实现消息接口IMessage，实现使用电子邮件发送和接收消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmailMessage : IMessage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Email:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; content);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Receive(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Receive Email:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; content);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;定义日志拦截器LogDispatchProxy 继承自DispatchProxy类，重写基类Invoke方法并在目标方法调用前后加上所需业务逻辑；然后定义TargetClass属性，该属性是目标方法所属类的实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogDispatchProxy : DispatchProxy
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; TargetClass { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Invoke(MethodInfo targetMethod, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
        {
            Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方法执行前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; targetMethod.Invoke(TargetClass, args);
            Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方法执行后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Write(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content)
        {
            Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Red;
            Console.WriteLine(content);
            Console.ResetColor();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用DispatchProxy类的静态方法Create生成代理类，其中Create是个泛型方法，泛型有两个值，第一个值必须是接口，第二个值必须是DispatchProxy的子类&lt;/span&gt;
            IMessage messageDispatchProxy = DispatchProxy.Create&amp;lt;IMessage, LogDispatchProxy&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个实现了IMessage接口的类的实例，并赋值给代理类的TargetClass属性&lt;/span&gt;
            ((LogDispatchProxy)messageDispatchProxy).TargetClass = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmailMessage();
            messageDispatchProxy.Send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;早上好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            messageDispatchProxy.Receive(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中午好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/157950/201911/157950-20191113223400552-2083605708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的理解：通过DispatchProxy.Create创建的代理类messageDispatchProxy 就是一个LogDispatchProxy类，并且利用我们提供的的实例实现了IMessage接口，所以messageDispatchProxy可以强转为LogDispatchProxy或IMessage&lt;/p&gt;
&lt;p&gt;至此，我们没有通过任何第三方类库，自己实现了一个AOP&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 14:51:00 +0000</pubDate>
<dc:creator>欧阳.NET</dc:creator>
<og:description>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是软件开发中的一个热点，利用A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/oyang168/p/11853851.html</dc:identifier>
</item>
<item>
<title>Python语言基础04-函数和模块的使用 - alonghub</title>
<link>http://www.cnblogs.com/along21/p/11853881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/11853881.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文收录在&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/along21/p/9947209.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Python从入门到精通系列文章系列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分享本章节的内容之前，先来研究一道数学题，请说出下面的方程有多少组正整数解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1216496/201911/1216496-20191113223629255-635245096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上，上面的问题等同于将&lt;strong&gt;8个苹果&lt;/strong&gt;分成&lt;strong&gt;四组&lt;/strong&gt;每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1216496/201911/1216496-20191113223637218-1599151182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以用Python的程序来计算出这个值，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
输入M和N计算C(M,N)

Version: 0.1
Author: along
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
m &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
n &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
fm &lt;/span&gt;= 1
&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(1, m + 1&lt;span&gt;):
    fm &lt;/span&gt;*=&lt;span&gt; num
fn &lt;/span&gt;= 1
&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(1, n + 1&lt;span&gt;):
    fn &lt;/span&gt;*=&lt;span&gt; num
fmn &lt;/span&gt;= 1
&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(1, m - n + 1&lt;span&gt;):
    fmn &lt;/span&gt;*=&lt;span&gt; num
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fm // fn // fmn)
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;轻松得出答案为：35&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1. 函数的作用&lt;/h2&gt;
&lt;p&gt;　　不知道大家是否注意到，在上面的代码中，我们做了3次&lt;strong&gt;求阶乘&lt;/strong&gt;，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“&lt;strong&gt;代码有很多种坏味道，重复是最坏的一种！&lt;/strong&gt;”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。&lt;/p&gt;
&lt;h3&gt;1.1 定义函数&lt;/h3&gt;
&lt;p&gt;　　在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且&lt;strong&gt;命名规则跟变量的命名规则是一致&lt;/strong&gt;的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。&lt;/p&gt;
&lt;p&gt;在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(num):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;求阶乘&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    result &lt;/span&gt;= 1
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, num + 1&lt;span&gt;):
        result &lt;/span&gt;*=&lt;span&gt; i
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

m &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
n &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(factorial(m) // factorial(n) // factorial(m - n))
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　说明： Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的一些函数在Python中也都是现成的，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;2. 函数的参数&lt;/h2&gt;
&lt;p&gt;　　函数是绝大多数编程语言中都支持的一个代码的&quot;构建块&quot;，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，&lt;strong&gt;函数的参数可以有默认值，也支持使用可变参数&lt;/strong&gt;，所以Python并不需要像其他语言一样支持&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD&quot;&gt;函数的重载&lt;/a&gt;，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; random &lt;span&gt;import&lt;/span&gt;&lt;span&gt; randint

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; roll_dice(n=2&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;摇色子&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    total &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(n):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(_)&lt;/span&gt;
        total += randint(1, 6&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(total)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; total

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add(a=0, b=0, c=&lt;span&gt;0):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;三个数相加&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有指定参数那么使用默认值摇两颗色子&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(roll_dice())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 摇三颗色子&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(roll_dice(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(add())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1, 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1, 2, 3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传递参数时可以不按照设定的顺序进行传递&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(add(c=50, a=100, b=200))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。&lt;/p&gt;

&lt;h3&gt;2.1 函数的可变参数&lt;/h3&gt;
&lt;p&gt;　　其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在参数名前面的*表示args是一个可变参数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; add(*&lt;span&gt;args):
    result &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
        result &lt;/span&gt;+=&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(result)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在调用add函数时可以传入0个或多个参数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(add())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1, 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1, 2, 3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add(1, 3, 5, 7, 9))
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3. 用模块管理函数&lt;/h2&gt;
&lt;p&gt;　　对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么&lt;strong&gt;后面的定义会覆盖之前的定义&lt;/strong&gt;，也就意味着两个函数同名函数实际上只有一个是存在的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello, world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;goodbye, world!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面的代码会输出什么呢？&lt;/span&gt;
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，&lt;strong&gt;Python中每个文件就代表了一个模块（module）&lt;/strong&gt;，我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。&lt;/p&gt;
&lt;p&gt;（1）先在同级目录下，创建2个py文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;module1.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;module2.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;goodbye world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）直接使用模块使用函数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; module1 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo
foo()

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; module2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo
foo()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）也可以按照如下所示的方式来区分到底要使用哪一个foo函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module1 as m1
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module2 as m2

m1.foo()
m2.foo()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（4）但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; module1 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; module2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo

foo()

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; module2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; module1 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; foo

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出hello, world!&lt;/span&gt;
foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;__main__&quot;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;module3.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; __name__是Python中一个隐含的变量它代表了模块的名字&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 只有被Python解释器直接执行的模块的名字才是__main__&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call foo()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    foo()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call bar()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    bar()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;test.py&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; module3
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4. 练习&lt;/h2&gt;
&lt;h3&gt;练习1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现计算求最大公约数和最小公倍数的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考答案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gcd(x, y):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;求最大公约数&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;(x, y) = (y, x) if x &amp;gt; y else (x, y)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; x &amp;gt;&lt;span&gt; y:
        (x, y) &lt;/span&gt;=&lt;span&gt; (y, x)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        (x, y)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; factor &lt;span&gt;in&lt;/span&gt; range(x, 0, -1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x % factor == 0 &lt;span&gt;and&lt;/span&gt; y % factor ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factor

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lcm(x, y):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;求最小公倍数&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x * y //&lt;span&gt; gcd(x, y)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(gcd(9,12&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(lcm(9,12))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;练习2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现判断一个数是不是回文数的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考答案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_palindrome(num):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    判断一个数是不是回文数
    回文数是指将一个正整数从左往右排列和从右往左排列值一样的数
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    temp &lt;/span&gt;=&lt;span&gt; num
    total &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; temp &amp;gt;&lt;span&gt; 0:
        total &lt;/span&gt;= total * 10 + temp % 10&lt;span&gt;
        temp &lt;/span&gt;//= 10
    &lt;span&gt;return&lt;/span&gt; total == num
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;练习3&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现判断一个数是不是素数的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考答案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_prime(num):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断一个数是不是素数&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; factor &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;, num):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num % factor ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True &lt;span&gt;if&lt;/span&gt; num != 1 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; False

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(is_prime(1))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;练习4&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;写一个程序判断输入的正整数是不是回文素数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考答案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    num &lt;/span&gt;= int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正整数: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; is_palindrome(num) &lt;span&gt;and&lt;/span&gt;&lt;span&gt; is_prime(num):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d是回文素数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; num)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d不是回文素数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % num)
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　注意：通过上面的程序可以看出，当我们将代码中&lt;strong&gt;重复出现的和相对独立的功能抽取成函数&lt;/strong&gt;后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;5. 变量作用域&lt;/h3&gt;
&lt;p&gt;（1）最后，我们来讨论一下Python中有关变量作用域的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    b &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Python中可以在函数内部再定义函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar():
        c &lt;/span&gt;=&lt;span&gt; True
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

    bar()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(c)  # NameError: name 'c' is not defined&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    a &lt;/span&gt;= 100
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(b)  # NameError: name 'b' is not defined&lt;/span&gt;
    foo()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码能够顺利的执行并且打印出100、hello和True，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。&lt;/p&gt;
&lt;p&gt;　　我们在上面代码的if分支中定义了一个变量a，这是一个&lt;strong&gt;全局变量（global variable）&lt;/strong&gt;，属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的&lt;strong&gt;局部变量（local variable）&lt;/strong&gt;，属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于&lt;strong&gt;嵌套作用域&lt;/strong&gt;，在bar函数中我们是可以访问到它的。bar函数中的变量c属于&lt;strong&gt;局部作用域&lt;/strong&gt;，在bar函数之外是无法访问的。事实上，Python查找一个变量时会&lt;strong&gt;按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序&lt;/strong&gt;进行搜索（&lt;strong&gt;由小到大&lt;/strong&gt;），前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的input、print、int等都属于内置作用域。&lt;/p&gt;
&lt;p&gt;　　其中，在foo函数中调用bar函数的变量c，会报错；因为读不到此变量。&lt;/p&gt;

&lt;p&gt;（2）再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    a &lt;/span&gt;= 200
    &lt;span&gt;print&lt;/span&gt;(a)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    a &lt;/span&gt;= 100&lt;span&gt;
    foo()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是&lt;strong&gt;重新定义了一个名字为a的局部变量&lt;/strong&gt;，它&lt;strong&gt;跟全局作用域的a并不是同一个变量&lt;/strong&gt;，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。&lt;/p&gt;

&lt;p&gt;（3）如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    a &lt;/span&gt;= 200
    &lt;span&gt;print&lt;/span&gt;(a)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    a &lt;/span&gt;= 100&lt;span&gt;
    foo()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以使用&lt;strong&gt;global关键字&lt;/strong&gt;来指示&lt;strong&gt;foo函数中的变量a来自于全局作用域&lt;/strong&gt;，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。&lt;/p&gt;
&lt;p&gt;　　同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用&lt;strong&gt;nonlocal关键字&lt;/strong&gt;来指示变量来自于嵌套作用域，请大家自行试验。&lt;/p&gt;
&lt;p&gt;　　在实际开发中，我们应该尽量&lt;strong&gt;减少对全局变量的使用&lt;/strong&gt;，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外&lt;strong&gt;全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收&lt;/strong&gt;。事实上，减少对全局变量的使用，也是&lt;strong&gt;降低代码之间耦合度&lt;/strong&gt;的一个重要举措，同时也是对&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B&quot;&gt;迪米特法则&lt;/a&gt;的践行。减少全局变量的使用就意味着我们应该&lt;strong&gt;尽量让变量的作用域在函数的内部&lt;/strong&gt;，但是如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;闭包&lt;/a&gt;，这个我们在后续的内容中进行讲解。&lt;/p&gt;
&lt;blockquote readability=&quot;5.0575916230366&quot;&gt;
&lt;p&gt;　　说明： 很多人经常会将“闭包”和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0&quot;&gt;“匿名函数”&lt;/a&gt;混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看&lt;a href=&quot;https://zh.wikipedia.org/wiki/&quot;&gt;维基百科&lt;/a&gt;的解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Todo: Add your code here&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 13 Nov 2019 14:48:00 +0000</pubDate>
<dc:creator>alonghub</dc:creator>
<og:description>本文收录在Python从入门到精通系列文章系列 在分享本章节的内容之前，先来研究一道数学题，请说出下面的方程有多少组正整数解。 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/along21/p/11853881.html</dc:identifier>
</item>
</channel>
</rss>