<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【微信小程序】常用组件及自定义组件 - BWH_Steven</title>
<link>http://www.cnblogs.com/ideal-20/p/13664831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ideal-20/p/13664831.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79de7819a7b24837ad9fea1565afd81d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;组件你可以理解为传统页面开发时候的各种标签，例如 div span 等等，我这里只说一些常用的，这样就能能搭建出一个基本的页面了，但是如果想要更加美观以及拥有更好的体验，就需要 XSS 和 别的一些强大的组件了，如果有额外的需求，可以去官方文档查阅一下 (同时不常用的属性，也就不提了)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://developers.weixin.qq.com/miniprogram/dev/component/&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-view&quot;&gt;(1) view&lt;/h2&gt;
&lt;p&gt;view 可以理解为传统页面开发中的 div 块级元素，使用 view 会换行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3949b67b939c47e2a4575e5d0ae43c52~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 view 标签，还有一些额外的属性，说的也很清楚，但是前期的话，其实不考虑这个也是可以的，就单纯的当做一个布局的 div 来用&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hover-class&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;指定按下去的样式类。当 &lt;code&gt;hover-class=&quot;none&quot;&lt;/code&gt; 时，没有点击态效果&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hover-stop-propagation&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;指定是否阻止本节点的祖先节点出现点击态&lt;/td&gt;
&lt;td&gt;1.5.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hover-start-time&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;按住后多久出现点击态，单位毫秒&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hover-stay-time&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;手指松开后点击态保留时间，单位毫秒&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;2-text&quot;&gt;(2) text&lt;/h2&gt;
&lt;p&gt;text 可以理解为传统页面中的 span 行内元素，text 不会换行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88bfd58b5cc642ba9822f8ab4144f794~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;text 涉及的一些标签&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;selectable&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;文本是否可选&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;space&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;显示连续空格&lt;/td&gt;
&lt;td&gt;1.4.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否解码&lt;/td&gt;
&lt;td&gt;1.4.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;space 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ensp&lt;/td&gt;
&lt;td&gt;中文字符空格一半大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;emsp&lt;/td&gt;
&lt;td&gt;中文字符空格大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;nbsp&lt;/td&gt;
&lt;td&gt;根据字体设置的空格大小&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;decode可以解析的有&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;nbsp; &amp;amp;lt; &amp;amp;gt; &amp;amp;amp; &amp;amp;apos; &amp;amp;ensp; &amp;amp;emsp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单测试一下其中两个，可以看到，后者长按可以选择文字，同时编码被解析成空格，前者反之&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;text selectable=&quot;{{false}}&quot; decode=&quot;{{false}}&quot;&amp;gt;测&amp;amp;nbsp;试&amp;lt;/text&amp;gt;
&amp;lt;text selectable=&quot;{{true}}&quot; decode=&quot;{{true}}&quot;&amp;gt;测&amp;amp;nbsp;试&amp;lt;/text&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69f74b41a8cb4dff8d0b4f7d40eb5826~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-image&quot;&gt;(3) image&lt;/h2&gt;
&lt;p&gt;image 就是图片相关的一个组件，这个组件默认宽度320px、⾼度240px，同时支持懒加载&lt;/p&gt;
&lt;p&gt;我摘了三个比较常用的属性出来&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;图片资源地址&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mode&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;scaleToFill&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;图片裁剪、缩放的模式&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;lazy-load&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;图片懒加载，在即将进入一定范围（上下三屏）时才开始加载&lt;/td&gt;
&lt;td&gt;1.5.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;他作为图片的一个承载物，我们重点多说一下关于 mode 的问题，也就是图片的显示形式&lt;/p&gt;
&lt;p&gt;所以先来看一下，&lt;strong&gt;mode 的取值范围&lt;/strong&gt;（节选了相对常用的，其余的取值都属于裁剪类型）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;scaleToFill&lt;/td&gt;
&lt;td&gt;缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;aspectFit&lt;/td&gt;
&lt;td&gt;缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;aspectFill&lt;/td&gt;
&lt;td&gt;缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;widthFix&lt;/td&gt;
&lt;td&gt;缩放模式，宽度不变，高度自动变化，保持原图宽高比不变&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;heightFix&lt;/td&gt;
&lt;td&gt;缩放模式，高度不变，宽度自动变化，保持原图宽高比不变&lt;/td&gt;
&lt;td&gt;2.10.3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;比较常用是 widthFix，在这几个其中，aspectFill 相对还是用的比较少的&lt;/p&gt;
&lt;h2 id=&quot;4-swiper&quot;&gt;(4) swiper&lt;/h2&gt;
&lt;p&gt;这个组件，是小程序页面中的一个轮播图的效果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swiper&lt;/code&gt; 是轮播图的一个总的容器，&lt;code&gt;swiper-item&lt;/code&gt; 代表其中的每一个内容，配合其属性，能很方便的达到需要的样式&lt;/p&gt;
&lt;p&gt;同样摘了几个常见的属性&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;indicator-dots&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否显示面板指示点&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;indicator-color&lt;/td&gt;
&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;rgba(0, 0, 0, .3)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;指示点颜色&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;indicator-active-color&lt;/td&gt;
&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;#000000&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当前选中的指示点颜色&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;autoplay&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否自动切换&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;interval&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;自动切换时间间隔&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;duration&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;滑动动画时长&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;circular&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否采用衔接滑动&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vertical&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;滑动方向是否为纵向&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;显示比例问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先说明一下，swiper存在一些默认的样式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;width: 100%&lt;/li&gt;
&lt;li&gt;height 150px&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;image 默认宽高&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;width: 320px&lt;/li&gt;
&lt;li&gt;height: 240px&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果，swiper 的高度出现了问题，给出一个解决方式&lt;/p&gt;
&lt;p&gt;先根据素材图片的宽高比例，等比计算 swiper 的宽高，这样高度就换算出来了&lt;/p&gt;
&lt;p&gt;swiper 高度 = swiper 宽度 * 素材高度 / 素材宽度&lt;/p&gt;
&lt;p&gt;即：height: 750rpx * 素材高度 / 素材宽度&lt;/p&gt;
&lt;p&gt;来看个综合一些的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WXML&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片随便自己做了两张&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;swiper autoplay=&quot;{{true}}&quot; interval=&quot;5000&quot; circular=&quot;{{true}}&quot; indicator-dots=&quot;{{true}}&quot;
    indicator-color=&quot;#D3D3D3&quot; indicator-active-color=&quot;#FFFF00&quot;&amp;gt;
    &amp;lt;swiper-item&amp;gt;&amp;lt;image mode=&quot;widthFix&quot; src=&quot;../../image/swiperC.jpg&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;/swiper-item&amp;gt;
    &amp;lt;swiper-item&amp;gt;&amp;lt;image mode=&quot;widthFix&quot; src=&quot;../../image/swiperB.jpg&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;/swiper-item&amp;gt;
    &amp;lt;swiper-item&amp;gt;&amp;lt;image mode=&quot;widthFix&quot; src=&quot;../../image/swiperA.jpg&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;/swiper-item&amp;gt;
&amp;lt;/swiper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;WXSS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;swiper{
    width: 100%;
    height: calc(750rpx * 275 / 1000);
}

image{
    width: 100%;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下效果，现在就实现了轮播图的效果，同时会5秒自动循环轮播，自己可以对照属文档进行定制修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab985b76aaf4b4d853aa33b2f0e5ce6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-navigator&quot;&gt;(5) navigator&lt;/h2&gt;
&lt;p&gt;导航组件，这块可以理解为传统页面开发的超链接标签&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;target&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;self&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;在哪个目标上发生跳转，默认当前小程序&lt;/td&gt;
&lt;td&gt;2.0.7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当前小程序内的跳转链接&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;open-type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;navigate&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;跳转方式&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;open-type 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;navigate&lt;/td&gt;
&lt;td&gt;保留当前页面，跳转到应用内的某个页面，但是不能跳到tabbar 页面&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;redirect&lt;/td&gt;
&lt;td&gt;关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到tabbar 页面&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;switchTab&lt;/td&gt;
&lt;td&gt;跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reLaunch&lt;/td&gt;
&lt;td&gt;关闭所有页面，打开到应用内的某个页面&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;navigateBack&lt;/td&gt;
&lt;td&gt;关闭当前页面，返回上⼀页面或多级页面。可通过 getCurrentPages() 获取当&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;exit&lt;/td&gt;
&lt;td&gt;退出小程序，target=miniProgram时⽣效&lt;/td&gt;
&lt;td&gt;2.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面给出一个测试的代码，默认不添加 &lt;code&gt;open-type&lt;/code&gt; 的写法会有一个返回上一层的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;navigator url=&quot;/pages/test06/test06&quot;&amp;gt;默认跳转到test06&amp;lt;/navigator&amp;gt;

&amp;lt;navigator open-type=&quot;redirect&quot; url=&quot;/pages/test06/test06&quot;&amp;gt;redirect跳转到test06&amp;lt;/navigator&amp;gt;

&amp;lt;navigator open-type=&quot;switchTab&quot; url=&quot;/pages/index/index&quot;&amp;gt;switchTab跳转到主页&amp;lt;/navigator&amp;gt;

&amp;lt;navigator open-type=&quot;reLaunch&quot; url=&quot;/pages/index/index&quot;&amp;gt;reLaunch跳转到主页&amp;lt;/navigator&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6-rich-text&quot;&gt;(6) rich-text&lt;/h2&gt;
&lt;p&gt;这是一个富文本标签，作用就是把字符串中的对应标签解析出来，其主要的一个属性就是 &lt;code&gt;nodes&lt;/code&gt; ，我们先简单看一下 nodes的属性有哪些&lt;/p&gt;
&lt;p&gt;现支持两种节点，通过type来区分，分别是元素节点和文本节点，默认是元素节点，在富文本区域里显示的HTML节点 元素节点：type = node&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;标签名&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;支持部分受信任的 HTML 节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;attrs&lt;/td&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;支持部分受信任的属性，遵循 Pascal 命名法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;children&lt;/td&gt;
&lt;td&gt;子节点列表&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;结构和 nodes 一致&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;来看一个例子，这个nodes 的值，我们去 js 中定义一个&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;rich-text nodes=&quot;{{receive}}&quot;&amp;gt;&amp;lt;/rich-text&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有两种方式赋值，一种就是我注释掉的那一行，直接使用一个含有标签的字符串，直接赋值就会解析，另一种就是通过后面这样 JSON 的一种格式赋值，效果是一样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Page({
  data: {
    // receive:'&amp;lt;div class=&quot;div_class&quot;&amp;gt;&amp;lt;h3&amp;gt;理想二旬不止&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;'
    receive:[{
      name:'div',
      attrs:{
        class:'div_class'
      },
      children:[{
        name:'h3',
        attrs:{},
        children:[{
          type:'text',
          text:'理想二旬不止'
        }]
      }]
    }] 
  },
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7-button&quot;&gt;(7) button&lt;/h2&gt;
&lt;p&gt;按钮标签，也算是非常常用的内容了，同时相比较传统页面开发中的按钮，微信小程序中又有很多开放式的功能，首先看一些涉及的一些属性（更多内容可以看官网文档）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://developers.weixin.qq.com/miniprogram/dev/component/button.html&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;按钮的大小&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;按钮的样式类型&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;plain&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;按钮是否镂空，背景色透明&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否禁用&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;loading&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;名称前是否带 loading 图标&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;form-type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;用于 form 组件，点击分别会触发 form 组件的 submit/reset 事件&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;open-type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;微信开放能力&lt;/td&gt;
&lt;td&gt;1.10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;size 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;默认大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mini&lt;/td&gt;
&lt;td&gt;小尺寸&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;type 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;primary&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;白色&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;warn&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;form-type 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;submit&lt;/td&gt;
&lt;td&gt;提交表单&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;重置表单&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;open-type 的合法值&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;contact&lt;/td&gt;
&lt;td&gt;打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;share&lt;/td&gt;
&lt;td&gt;触发用户转发，使用前建议先阅读&lt;/td&gt;
&lt;td&gt;1.2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getPhoneNumber&lt;/td&gt;
&lt;td&gt;获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息&lt;/td&gt;
&lt;td&gt;1.2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getUserInfo&lt;/td&gt;
&lt;td&gt;获取用户信息，可以从bindgetuserinfo回调中获取到用户信息&lt;/td&gt;
&lt;td&gt;1.3.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;launchApp&lt;/td&gt;
&lt;td&gt;打开APP，可以通过app-parameter属性设定向APP传的参数&lt;/td&gt;
&lt;td&gt;1.9.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;openSetting&lt;/td&gt;
&lt;td&gt;打开授权设置页&lt;/td&gt;
&lt;td&gt;2.0.7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;feedback&lt;/td&gt;
&lt;td&gt;打开“意见反馈”页面，用户可提交反馈内容并上传日志，开发者可以登录小程序管理后台后进入左侧菜单“客服反馈”页面获取到反馈内容&lt;/td&gt;
&lt;td&gt;2.1.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这几个代码就是通过 &lt;code&gt;size&lt;/code&gt; 、&lt;code&gt;type&lt;/code&gt; 进行基本的大小或者说类型实现一个样式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;button style=&quot;width:100%&quot;&amp;gt;默认按钮&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; size=&quot;mini&quot;&amp;gt;mini 默认按钮&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; type=&quot;primary&quot;&amp;gt;primary 按钮&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; type=&quot;warn&quot;&amp;gt;warn 按钮&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; type=&quot;warn&quot; plain&amp;gt;plain 按钮&amp;lt;/button&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是一些开放的功能&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;contact&quot;&amp;gt;联系客服&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;share&quot;&amp;gt;分享小程序&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&amp;gt;
    获取电话号码
&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&amp;gt;
    获取用户信息
&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;launchApp&quot;&amp;gt;打开App&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;openSetting&quot;&amp;gt;打开授权设置页&amp;lt;/button&amp;gt;
&amp;lt;button style=&quot;width:100%&quot; open-type=&quot;feedback&quot;&amp;gt;意见反馈&amp;lt;/button&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要说明的几个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;联系客服这个功能只能在真机调试，需要先在后台绑定一个客服的微信号码，接着在开发工具中选择真机调试，然后扫描二维码就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc8314295484241a94993a78671ff5b~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d0469f5209349ee8e5bfb06713d4539~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取电话号码，以及用户信息，需要结合事件来做，例如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Page({
  // 获取用户的手机号码信息
  getPhoneNumber(e){
    console.log(e);
  },
  // 获取用户个人信息
  getUserInfo(e){
    console.log(e);
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如获取用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59b2dd7770cf416ebc989d17451c654f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是电话号码，不是企业的小程序账号 没有权限来获取用户的手机号码&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开App，是在 app 中 通过 app 的某个链接打开小程序，然后在小程序 再通过这个功 重新打开 app&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当前版本的微信小程序，在.wxss文件里设置Button宽度无效，网络上的一种解决方案就是把 app.json里的 style: v2语句删掉，还有一种就是像我代码中一样，直接加 style，暂时推荐后者吧，此处未深究&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;8-icon&quot;&gt;(8) icon&lt;/h2&gt;
&lt;p&gt;微信小程序默认封装了一些图标，也很简单，只有三个属性&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;number/string&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;icon的大小&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;icon的颜色，同css的color&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单用一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;icon  type=&quot;success&quot; size=&quot;50&quot;&amp;gt; &amp;lt;/icon&amp;gt;
&amp;lt;icon  type=&quot;success&quot; size=&quot;50&quot; color=&quot;#3390ff&quot;&amp;gt; &amp;lt;/icon&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定颜色，其默认都是有一定颜色样式的，如果指定了 color 就会覆盖掉原来的颜色&lt;/p&gt;
&lt;h2 id=&quot;9-radio&quot;&gt;(9) radio&lt;/h2&gt;
&lt;p&gt;单选框组件，需要配合 radio-group 使用，下面看代码就明白了&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;radio标识。当该radio选中时，radio-group 的 change 事件会携带 radio 的 value&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;checked&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当前是否选中&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否禁用&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;#09BB07&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;radio的颜色，同css的color&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单用一下，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;radio-group bindchange=&quot;handleChange&quot;&amp;gt;
  &amp;lt;radio color=&quot;blue&quot; value=&quot;male&quot;&amp;gt;男&amp;lt;/radio&amp;gt;
  &amp;lt;radio color=&quot;blue&quot; value=&quot;female&quot; &amp;gt;女&amp;lt;/radio&amp;gt;
&amp;lt;/radio-group&amp;gt;

&amp;lt;view&amp;gt;你选择的性别是:{{gender}}&amp;lt;/view&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js 内容，至于 e.detail.value 如何来的，可以通过 console.log(e) 打印看到&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Page({
  data: {
    gender: &quot;&quot;
  },
  handleChange(e){
    // 获取单选框中的值
    let gender=e.detail.value;
    // 把值 赋值给 data中的数据
    this.setData({
      gender
    })
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;10-checkbox&quot;&gt;(10) checkbox&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;checkbox 标识，选中时触发 checkbox-group 的 change 事件，并携带 checkbox 的 value&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是否禁用&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;checked&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当前是否选中，可用来设置默认选中&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;#09BB07&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;checkbox的颜色，同css的color&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;直接用一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;view&amp;gt;
  &amp;lt;checkbox-group bindchange=&quot;handleItemChange&quot;&amp;gt;
    &amp;lt;checkbox value=&quot;{{item.value}}&quot; wx:for=&quot;{{list}}&quot; wx:key=&quot;id&quot;&amp;gt;
      {{item.name}}
    &amp;lt;/checkbox&amp;gt;
  &amp;lt;/checkbox-group&amp;gt;
  &amp;lt;view&amp;gt;
    选中的内容:{{checkedList}}
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Page({
  data: {
    list:[
      {
        id:0,
        name:&quot;🌞️&quot;,
        value:&quot;太阳&quot;
      },
      {
        id:1,
        name:&quot;🌙&quot;,
        value:&quot;月亮&quot;
      },
      {
        id:2,
        name:&quot;⭐️&quot;,
        value:&quot;星星&quot;
      }
    ],
    checkedList:[]
  },
  // 复选框的选中事件
  handleItemChange(e){
    // 获取被选中的复选框的值
    const checkedList=e.detail.value;
    // 进行赋值
    this.setData({
      checkedList
    })
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6c4749dd11e40b78cbc3a3a7267204d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-快速体验&quot;&gt;(1) 快速体验&lt;/h2&gt;
&lt;p&gt;如果我们想要自定义一些组件，也就是说将一些代码抽离出来，可以达到复用等的效果&lt;/p&gt;
&lt;p&gt;我们一步一步举个例子：&lt;/p&gt;
&lt;p&gt;首先创建文件夹目录 components/header&lt;/p&gt;
&lt;p&gt;接着右键创建组件 header，点击新建 Component&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6c6d6ee1504c3f9786245477e30818~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构就是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a759782b0fe4730b010f6425c0e51f7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般点击创建组件的方式会自动将组件的 json 文件中声明组件，如果没有需要自己手动修改component 为 true&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;component&quot;: true,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在组件WXML中随便写点东西，然后打开想要引用组件的页面，首先在 json 中说明引用组件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;usingComponents&quot;: {
    &quot;header&quot;:&quot;/../../components/header/header&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后直接引用就可以了，效果就出来了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;header&amp;gt;&amp;lt;/header&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62d75fc231a64d47b5359660207fee1a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-组件传参&quot;&gt;(2) 组件传参&lt;/h2&gt;
&lt;p&gt;组件传参有两个方向，一个是父组件 --&amp;gt; 子组件 ，还有就是反过来。注：父组件是页面，子组件是自定义组件&lt;/p&gt;
&lt;p&gt;通过一个例子来演示&lt;/p&gt;
&lt;p&gt;在上面结构上自己写一个自定义的组件，一个导航条的效果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义组件的页面代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- components/header/header.wxml --&amp;gt;
&amp;lt;view class=&quot;header&quot;&amp;gt;
    &amp;lt;view class=&quot;header_tabs_title&quot;&amp;gt;
        &amp;lt;view wx:for=&quot;{{headerTabs}}&quot; 
        wx:key=&quot;id&quot; 
        class=&quot;header_tabs_title_item {{item.isActive?'active':''}}&quot;
        bindtap=&quot;hanldeItemTap&quot;
        data-index=&quot;{{index}}&quot;
        &amp;gt;
            {{item.name}}
        &amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义组件的样式文件如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/* components/header/header.wxss */
.header_tabs_title{
    display: flex;
    padding: 10px;
}
.header_tabs_title_item{
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
}

.active{
    color:blue;
    border-bottom: 5rpx solid currentColor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义组件的 js文件&lt;/strong&gt;，在 &lt;code&gt;properties&lt;/code&gt; 中的内容，就是接收到父（页面）的数据，也就是一个关于导航的数组，其中包括首页测试关于等等导航文字内容&lt;/p&gt;
&lt;p&gt;而下面的方法就是关于父传数据到子组件的内容，其代表触发父组件中的自定义事件，同时传递数据给 父组件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// components/header/header.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    headerTabs:{
      type:Array,
      value:[]
    }
  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {
    hanldeItemTap(e){
      const {index}=e.currentTarget.dataset;
      // 触发父组件中的自定义事件 同时传递数据给  
      this.triggerEvent(&quot;itemChange&quot;,{index});
    }
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补充：e.currentTarget.dataset; 是怎么来的，还是老办法，console 打印一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99182bd294664cc7ba5f56e40545d3d8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绑定一个事件，同时把等会再 js 中的定义数据，传递到自定义组件中去，名称就是刚才接收的 headerTabs&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;header headerTabs=&quot;{{headerTabs}}&quot; binditemChange=&quot;handleItemChange&quot; &amp;gt;&amp;lt;/header&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;父页面的 js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;code&gt;let { headerTabs } = this.data;&lt;/code&gt; 这是 ES6 的写法，也可以写成&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let headerTabs = this.data.headerTabs;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历数组的时候 修改了 v ，就把源数组也修改了&lt;/p&gt;
&lt;p&gt;目的就是通过点击修改定义导航中的 isActive 为 true 或 false&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// pages/test08/test08.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    headerTabs:[
      {
        id:0,
        name:&quot;首页&quot;,
        isActive:true
      },
      {
        id:1,
        name:&quot;测试&quot;,
        isActive:false
      },
      {
        id:2,
        name:&quot;测试&quot;,
        isActive:false
      },
      {
        id:3,
        name:&quot;关于&quot;,
        isActive:false
      },
    ]
  },
  // 自定义事件 用来接收子组件传递的数据的
  handleItemChange(e) {
    // 接收传递过来的参数
    const { index } = e.detail;
    let { headerTabs } = this.data;
    headerTabs.forEach((v, i) =&amp;gt; i === index ? v.isActive = true : v.isActive = false);
    this.setData({
      headerTabs
    })
  }
})
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果文章中有什么不足，欢迎大家留言交流，感谢朋友们的支持！&lt;/p&gt;
&lt;p&gt;如果能帮到你的话，那就来关注我吧！如果您更喜欢微信文章的阅读方式，可以关注我的公众号&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在这里的我们素不相识，却都在为了自己的梦而努力 ❤&lt;/p&gt;
&lt;p&gt;一个坚持推送原创开发技术文章的公众号：理想二旬不止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/587c6b9c2400490da3adc6134e1e3655~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Sep 2020 00:48:00 +0000</pubDate>
<dc:creator>BWH_Steven</dc:creator>
<og:description>微信小程序，常用组件及自定义组件，适合入门</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ideal-20/p/13664831.html</dc:identifier>
</item>
<item>
<title>Superset 0.37 发布——颜值最高的数据可视化平台 - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13664827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13664827.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914083926988-1321651688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用Superset已经有一段时间，其良好的体验与丰富的图表功能节省了大量的时间。但是对于权限，自定义图表，图表下载，报警邮件一直没有很好的支持，大部分公司对于这些功能的实现还是需要大量的二次开发，费时费力。&lt;/p&gt;
&lt;p&gt;近日Superset 0.37 正式发布，令人惊喜的是，新功能几乎都是大家期待已久的，而对于Superset的未来也更加的期待了。&lt;/p&gt;
&lt;p&gt;下面简单介绍本次的一些主要的更新~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914083942351-246990455.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;距离Superset 0.36 的发布已经过了四个多月的时间，但superset的活跃程度一点没有减弱，GitHub的Star已经突破了30k，Superset已经成为数据可视化平台的不二选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914083956109-2123998071.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;可视化插件&quot;&gt;可视化插件&lt;/h2&gt;
&lt;p&gt;0.37对Superset可视化代码进行了重构，开发人员现在可以引用图表API来构建自己的可视化插件，无需再去二次开发代码。&lt;/p&gt;
&lt;p&gt;除了对现有图表类型（如数据透视表，饼图和过滤器框）进行的其他小改进和错误修复之外，此新体系结构还&lt;strong&gt;使用户能够对数据进行更多处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，可以使用任何可用的基于JavaScript的数据可视化库在Superset上创建自定义可视化插件，例如ECharts，AntV，HighCharts，VX，D3。&lt;/p&gt;
&lt;h2 id=&quot;行级权限控制&quot;&gt;行级权限控制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084005051-1369618727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建新的可视化插件显然是很酷，但是对于要成为企业级的任何数据可视化应用程序，它在安全性上都必须坚如磐石。此次的0.37版本在此方向上也取得了长足的进步，并提高了行级安全性。&lt;/p&gt;
&lt;p&gt;现在，Superset可以具有多个表行级安全性过滤器，而不仅仅是一个表过滤器。&lt;/p&gt;
&lt;p&gt;相信未来Superset会在数据安全方面给我们更多的惊喜。&lt;/p&gt;
&lt;h2 id=&quot;excel上传功能&quot;&gt;Excel上传功能&lt;/h2&gt;
&lt;p&gt;在建表的时候，可以上传Excel&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084013134-520206451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于sql的电子邮件警报和屏幕截图&quot;&gt;基于SQL的电子邮件警报和屏幕截图&lt;/h2&gt;
&lt;p&gt;这功能就非常炫酷，可以将图表直接截图发送邮件&lt;/p&gt;
&lt;p&gt;在管理菜单选择报警功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084020252-2123796066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接收到的报警邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084027521-2128566360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编辑报警页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084041207-1389150612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报警记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084047378-779293425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084100244-1700729689.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;图表最大化最小化功能&quot;&gt;图表最大化最小化功能&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084110512-1972396803.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084122005-1895825137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202009/1089984-20200914084130608-507264237.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多Flink，Kafka等实时大数据分析相关技术博文，科技资讯，欢迎关注实时流式计算 公众号后台回复 “电子书” 下载300页Flink实战电子书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Sep 2020 00:46:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>Superset 0.37，增加可视化插件，行级权限控制 使用Superset已经有一段时间，其良好的体验与丰富的图表功能节省了大量的时间。但是对于权限，自定义图表，图表下载，报警邮件一直没有很好的支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13664827.html</dc:identifier>
</item>
<item>
<title>JS事件循环机制 - Annona</title>
<link>http://www.cnblogs.com/Annona/p/13664822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Annona/p/13664822.html</guid>
<description>&lt;h2&gt;JS事件循环设计的原因&lt;/h2&gt;
&lt;p&gt;（1）JavaScript语言最大的一个特点就是单线程，也就是说，同一时间只能做一件事情，（非阻塞），执行代码的时候只有一个主线程来处理所有任务；&lt;/p&gt;
&lt;p&gt;（2）JavaScript的单线程与它的用途有关，JavaScript作为浏览器脚本语言，JavaScript主要用途是与用户交互，以及DOM操作（JavaScript对DOM节点的操作包括访问，创建，添加，删除，替换，插入，复制，移动等），这就决定了JavaScript只能是单线程（如果是多线程的话，那么可能出现在同一时间对一个DOM中的节点进行不同的操作的话，就会出现问题，问题就会变得很复杂）—HTML5允许JavaScript脚本创建多个线程，但是子线程完全受主线程的控制；&lt;/p&gt;
&lt;p&gt;（3）&lt;/p&gt;
&lt;h2&gt;JS事件循环中术语概念&lt;/h2&gt;
&lt;p&gt;（1）执行栈&lt;/p&gt;
&lt;p&gt;（2）任务队列&lt;/p&gt;
&lt;p&gt;（3）宏任务和微任务&lt;/p&gt;
&lt;h2&gt;JS事件循环的实现细节&lt;/h2&gt;
</description>
<pubDate>Mon, 14 Sep 2020 00:45:00 +0000</pubDate>
<dc:creator>Annona</dc:creator>
<og:description>JS事件循环机制总结 JS事件循环设计的原因 （1）JavaScript语言最大的一个特点就是单线程，也就是说，同一时间只能做一件事情，（非阻塞），执行代码的时候只有一个主线程来处理所有任务； （2）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Annona/p/13664822.html</dc:identifier>
</item>
<item>
<title>Shader 001 - 函数造型能力 - knxfe</title>
<link>http://www.cnblogs.com/knxfe/p/13663495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/knxfe/p/13663495.html</guid>
<description>&lt;p&gt;Shader 中的很多效果都是由函数计算得出的，如何更好地理解二者的关系呢。不妨先看看函数是什么？函数的定义可以简单地描述为：给定一个集合 A，对于其中的元素施加法则 f，则可以得到另一个集合 B。将这样的 A 和 B 中的元素的对应关系，反映到二维直角坐标系中，就可以得到一条关于 f 的曲线。比如，正弦函数 sin 的曲线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202009/1890896-20200913213541564-1959257610.png&quot; alt=&quot;sin&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，应当如何通过函数来得到想要的 Shader 效果？&lt;/p&gt;
&lt;p&gt;我们都知道Shader 的中文翻译为着色器，Shader 的作用就是为屏幕中的每个像素着色。一段 Shader 程序的输入是位置信息，输出则是颜色信息。是不是很像函数中的映射关系：f(位置) = 颜色。&lt;/p&gt;

&lt;p&gt;有了上面的表达式，稍加转变，我们就可以用 shader 来描述 sin 的颜色。在 shader 中，颜色是由一个四维浮点数向量 vec4 来表示的，分别表示 (r, g, b, a)，取值范围为 0.0 到 1.0。为了展示一个完整的 sin 周期，可以对 sin 函数进行一些缩放和平移的操作，使其周期 T = 1.0：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;float f = sin(x * PI_2) / 2.0 + 0.5;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，也需要将屏幕的像素坐标规范化，使其落在 0.0 到 1.0 之间。下面 st 的计算是一个很常用的操作，其中，gl_FragCoord 是像素的坐标，u_resolution 是画布的尺寸，两者相除可以将像素坐标规范化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;vec2 st = gl_FragCoord.xy / u_resolution;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef GL_ES
precision mediump float;
#endif

#define PI_2 6.2831853

uniform vec2 u_resolution;

// 绘制 y 和 x 对应关系的曲线
float plot(float y, float x) {
    return smoothstep(x - 0.01, x, y) - smoothstep(x, x + 0.01, y);
}

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    float f = sin(st.x * PI_2) / 2.0 + 0.5;
    vec4 color = vec4(f);
    float p = plot(st.y, f);
    color = (1.0 - p) * color + p * vec4(0.0, 1.0, 0.0, 1.0);
    gl_FragColor = color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后得到的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202009/1890896-20200913213602928-2094645479.png&quot; alt=&quot;alpha&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察从左到右的颜色变化，以及曲线的高度变化。不难发现，函数值越大的地方，颜色就越白，即，越接近白色的 rgba (1.0, 1.0, 1.0, 1.0)；而函数值越小的地方，颜色就越黑，即，越接近黑色的 rgba (0.0, 0.0, 0.0, 0.0)。&lt;/p&gt;
&lt;p&gt;这非常好理解，颜色 gl_FragColor 的每个分量就是根据函数的值来构造的。&lt;/p&gt;

&lt;p&gt;说完颜色，不妨再观察一下 sin 的曲线变化，是不是很像一座座高低起伏的山？只需对上面的代码稍加改造，就能得到几座连绵的绿色小山。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef GL_ES
precision mediump float;
#endif

#define PI_2 6.2831853

uniform vec2 u_resolution;
uniform float u_time;

void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    // st.x += u_time / 2.0;
    float f = sin(st.x * PI_2 * 2.0) / 8.0 + 0.2;
    float p = 1.0 - smoothstep(f, f + 0.01, st.y);
    vec4 color = p * vec4(0.0, 1.0, 0.0, 1.0);
    // color = p * vec4(0.1, 0.3, 0.4, 1.0);
    gl_FragColor = color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几座抽象的绿色小山，虽然看上去有点粗糙：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202009/1890896-20200913213648042-1615469731.png&quot; alt=&quot;moutain&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以取消上面代码中的注释，利用 u_time 值赋予画面一点动效，这样几座绿色的小山又变成波动的海浪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202009/1890896-20200913213705014-451974625.gif&quot; alt=&quot;wave&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文仅谈论了最基本的 sin 函数，但也不难看出，sin 是一个强有力的造型工具。再结合另外两个工具：fract 和 dot，我们还能利用 sin 来绘制一幅简单的噪声图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    float rnd = random(st);
    gl_FragColor = vec4(vec3(rnd),1.0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;噪声在图形学中有广泛的应用，比如，用来模拟一些不规则的动态表面：火焰、云、岩石等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202009/1890896-20200914080201143-1436369217.png&quot; alt=&quot;noise&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Shader 中需要时时刻刻与各种函数模型打交道，正是这些函数多样的造型能力以及它们之间的有机结合，实现了多种多样的 Shader 效果。&lt;/p&gt;
&lt;p&gt;正确使用这些函数的能力，就是 Shader 的基本功。理解并不断地练习如何使用这些函数，是非常重要的。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Sep 2020 00:25:00 +0000</pubDate>
<dc:creator>knxfe</dc:creator>
<og:description>0x00 从函数出发 Shader 中的很多效果都是由函数计算得出的，如何更好地理解二者的关系呢。不妨先看看函数是什么？函数的定义可以简单地描述为：给定一个集合 A，对于其中的元素施加法则 f，则可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/knxfe/p/13663495.html</dc:identifier>
</item>
<item>
<title>多线程必考的「生产者 - 消费者」模型，看齐姐这篇文章就够了 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13664781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13664781.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者 - 消费者模型 &lt;code&gt;Producer-consumer problem&lt;/code&gt; 是一个非常经典的多线程并发协作的模型，在分布式系统里非常常见。也是面试中无论中美大厂都非常爱考的一个问题，对应届生问的要少一些，但是对于有工作经验的工程师来说，非常爱考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题有非常多的版本和解决方式，在本文我重点是和大家壹齐理清思路，由浅入深的思考问题，保证大家看完了都能有所收获。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;问题背景&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，这个模型是由两类线程构成：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;生产者线程：“生产”产品，并把产品放到一个队列里；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;消费者线程：“消费”产品。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gippgnh88tj31de0d0786.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个队列，生产者就只需要关注生产，而不用管消费者的消费行为，更不用等待消费者线程执行完；消费者也只管消费，不用管生产者是怎么生产的，更不用等着生产者生产。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以该模型实现了生产者和消费者之间的&lt;strong&gt;解藕&lt;/strong&gt;和&lt;strong&gt;异步&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;什么是异步呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说你和你女朋友打电话，就得等她接了电话你们才能说话，这是同步。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果你跟她发微信，并不需要等她回复，她也不需要立刻回复，而是等她有空了再回，这就是异步。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是呢，生产者和消费者之间也不能完全没有联系的。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;如果队列里的产品已经满了，生产者就不能继续生产；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果队列里的产品从无到有，生产者就得通知一下消费者，告诉它可以来消费了；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果队列里已经没有产品了，消费者也无法继续消费；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果队列里的产品从满到不满，消费者也得去通知下生产者，说你可以来生产了。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以它们之间还需要有协作，最经典的就是使用 &lt;code&gt;Object&lt;/code&gt; 类里自带的 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 或者 &lt;code&gt;notifyAll()&lt;/code&gt; 的消息通知机制。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述描述中的&lt;strong&gt;等着&lt;/strong&gt;，其实就是用 &lt;code&gt;wait()&lt;/code&gt; 来实现的；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;strong&gt;通知&lt;/strong&gt;，就是 &lt;code&gt;notify()&lt;/code&gt; 或者 &lt;code&gt;notifyAll()&lt;/code&gt; 。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么基于这种消息通知机制，我们还能够&lt;strong&gt;平衡生产者和消费者之间的速度差异&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果生产者的生产速度很慢，但是消费者消费的很快，就像是我们每月工资就发两次，但是每天都要花钱，也就是 1:15.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们就需要调整生产者（发工资）为 15 个线程，消费者保持 1 个线程，这样是不是很爽～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结下该模型的三大优点：&lt;br/&gt;解藕，异步，平衡速度差异。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;wait()/notify()&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们需要重点看下这个通知机制。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;notify()&lt;/code&gt; 都是 Java 中的 &lt;code&gt;Object&lt;/code&gt; 类自带的方法，可以用来实现线程间的通信。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw&quot;&gt;上一节&lt;/a&gt;讲的 11 个 APIs 里我也提到了它，我们这里再展开讲一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wait()&lt;/code&gt; 方法是用来让当前线程等待，直到有别的线程调用 &lt;code&gt;notify()&lt;/code&gt; 将它唤醒，或者我们可以设定一个时间让它自动苏醒。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用该方法之前，线程必须要获得该对象的对象监视器锁，也就是只能用在加锁的方法下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而调用该方法之后，当前线程会释放锁。&lt;/strong&gt;（提示：这里很重要，也是下文代码中用 &lt;code&gt;while&lt;/code&gt; 而非 &lt;code&gt;if&lt;/code&gt; 的原因。）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;notify()&lt;/code&gt; 方法只能通知一个线程，如果多个线程在等待，那就唤醒任意一个。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;notifyAll()&lt;/code&gt; 方法是可以唤醒所有等待线程，然后加入同步队列。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gippgxspy8j310k0sagqn.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用到了 2 个队列：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;同步队列：对应于我们&lt;a href=&quot;https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw&quot;&gt;上一节&lt;/a&gt;讲的线程状态中的 &lt;code&gt;Runnable&lt;/code&gt;，也就是线程准备就绪，就等着抢资源了。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;等待队列：对应于我们&lt;a href=&quot;https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw&quot;&gt;上一节&lt;/a&gt;讲的线程状态中的 &lt;code&gt;Waiting&lt;/code&gt;，也就是等待状态。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里需要注意，从等待状态线程无法直接进入 Q2，而是要先重新加入同步队列，再次等待拿锁，拿到了锁才能进去 Q2；一旦出了 Q2，锁就丢了。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;Q2&lt;/code&gt; 里，其实只有一个线程，因为这里我们必须要加锁才能进行操作。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;实现&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我首先建了一个简单的 &lt;code&gt;Product&lt;/code&gt; 类，用来表示生产和消费的产品，大家可以自行添加更多的 &lt;code&gt;fields&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Product&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String name;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Product&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主函数里我设定了两类线程，并且这里选择用普通的 &lt;code&gt;ArrayDeque&lt;/code&gt; 来实现 &lt;code&gt;Queue&lt;/code&gt;，更简单的方式是直接用 Java 中的 &lt;code&gt;BlockingQueue&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BlockingQueue&lt;/code&gt; 是阻塞队列，它有一系列的方法可以让线程实现自动阻塞，常用的 &lt;code&gt;BlockingQueue&lt;/code&gt; 有很多，后面会单独出一篇文章来讲。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里为了更好的理解并发协同的这个过程，我们先自己处理。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Queue&amp;lt;Product&amp;gt; queue = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Producer(queue, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)).start();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Consumer(queue, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)).start();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就是 &lt;code&gt;Producer&lt;/code&gt; 和 &lt;code&gt;Consumer&lt;/code&gt; 了。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Queue&amp;lt;Product&amp;gt; queue;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; maxCapacity;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Queue queue, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; maxCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.queue = queue;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.maxCapacity = maxCapacity;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (queue) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (queue.size() == maxCapacity) { &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;生产者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;等待中... Queue 已达到最大容量，无法生产&quot;&lt;/span&gt;);&lt;br/&gt;wait();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;生产者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;退出等待&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (queue.size() == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) { &lt;br/&gt;queue.notifyAll();&lt;br/&gt;}&lt;br/&gt;Random random = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random();&lt;br/&gt;Integer i = random.nextInt();&lt;br/&gt;queue.offer(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Product(&lt;span class=&quot;hljs-string&quot;&gt;&quot;产品&quot;&lt;/span&gt;  + i.toString()));&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;生产者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;生产了产品：&quot;&lt;/span&gt; + i.toString());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实它的主逻辑很简单，我这里为了方便演示加了很多打印语句才显得有点复杂。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把主要逻辑拎出来看：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (queue) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (queue.size() == maxCapacity) { &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;wait();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (queue.size() == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;queue.notifyAll();&lt;br/&gt;}&lt;br/&gt;queue.offer(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Product(&lt;span class=&quot;hljs-string&quot;&gt;&quot;产品&quot;&lt;/span&gt;  + i.toString()));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有 3 块内容，再对照这个过程来看：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gippe2prvkj310k0sagqn.jpg&quot; alt=&quot;&quot;/&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;生产者线程拿到锁后，其实就是进入了 &lt;code&gt;Q2&lt;/code&gt; 阶段。首先检查队列是否容量已满，如果满了，那就要去 &lt;code&gt;Q3&lt;/code&gt; 等待；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果不满，先检查一下队列原本是否为空，如果原来是空的，那就需要通知消费者；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;最后生产产品。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个问题，&lt;strong&gt;为什么只能用 &lt;code&gt;while&lt;/code&gt; 而不是 &lt;code&gt;if&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在这一小段，生产者线程经历了几个过程：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;如果队列已满，它就没法生产，那也不能占着位置不做事，所以要把锁让出来，去 &lt;code&gt;Q3 - 等待队列&lt;/code&gt; 等着；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在等待队列里被唤醒之后，不能直接夺过锁来，而是要先加入 &lt;code&gt;Q1 - 同步队列&lt;/code&gt; 等待资源；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;一旦抢到资源，关门上锁，才能来到 &lt;code&gt;Q2&lt;/code&gt; 继续执行 &lt;code&gt;wait()&lt;/code&gt; 之后的活，但是，此时这个队列有可能又满了，所以退出 &lt;code&gt;wait()&lt;/code&gt; 之后，还需要再次检查 &lt;code&gt;queue.size() == maxCapacity&lt;/code&gt; 这个条件，所以要用 &lt;code&gt;while&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么为什么可能又满了呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程没有一直拿着锁，&lt;strong&gt;在被唤醒之后，到拿到锁之间的这段时间里&lt;/strong&gt;，有可能其他的生产者线程先拿到了锁进行了生产，所以队列又经历了一个从不满到满的过程。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结：在使用线程的等待通知机制时，一般都要在 &lt;code&gt;while&lt;/code&gt; 循环中调用 &lt;code&gt;wait()&lt;/code&gt; 方法。&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者线程是完全对称的，我们来看代码。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Queue&amp;lt;Product&amp;gt; queue;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; maxCapacity;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Queue queue, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; maxCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.queue = queue;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.maxCapacity = maxCapacity;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; (queue) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (queue.isEmpty()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;消费者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;等待中... Queue 已缺货，无法消费&quot;&lt;/span&gt;);&lt;br/&gt;wait();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;消费者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;退出等待&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (queue.size() == maxCapacity) {&lt;br/&gt;queue.notifyAll();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;Product product = queue.poll();&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;消费者&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;消费了：&quot;&lt;/span&gt; + product.getName());&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gippfleex2j30pw0gujue.jpg&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者 - 消费者问题是面试中经常会遇到的题目，本文首先讲了该模型的三大优点：解藕，异步，平衡速度差异，然后讲解了等待/通知的消息机制以及在该模型中的应用，最后进行了代码实现。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中所有代码已经放到了我的 Github 上：&lt;code&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 Github 汇总了我所有的文章和资料，之后也会一直更新和维护，&lt;strong&gt;还希望大家帮忙点个 &lt;code&gt;Star&lt;/code&gt;&lt;/strong&gt;，你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Sep 2020 00:19:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>生产者 - 消费者模型 Producer-consumer problem 是一个非常经典的多线程并发协作的模型，在分布式系统里非常常见。也是面试中无论中美大厂都非常爱考的一个问题，对应届生问的要少一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13664781.html</dc:identifier>
</item>
<item>
<title>2020年 .NET ORM 完整比较、助力选择 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/13664720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/13664720.html</guid>
<description>&lt;h2 id=&quot;net-orm-前言&quot;&gt;.NET ORM 前言&lt;/h2&gt;
&lt;p&gt;为什么要写这篇文章？&lt;/p&gt;
&lt;p&gt;希望针对 SEO 优化搜索引擎，让更多中国人知道并且使用。目前百度搜索 .NET ORM 全是 sqlsugar，我个人是无语的，每每一个人进群第一件事就是拿来比较，每天要重复回答、重复解答、说服他们。想说服标签是名气大、使用者多的同类型 .NET ORM 非常困难，最多只能让他们勉强接受。FreeSql 不愿做自己发光的金子，希望在 2020年 写下这篇完整一点的 .NET ORM 比较，为准备使用 FreeSql 的朋友解惑，能排上百度搜索引擎当然再好不过了。&lt;/p&gt;
&lt;p&gt;肯请正在使用 CSRedisCore、FreeSql 的朋友，动一动手指转发本文，并加上原文链接指向本文，谢谢！ QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;原创文章欢迎转载，&lt;a href=&quot;https://www.cnblogs.com/kellynic/p/13664720.html&quot;&gt;2020年中文版 .NET ORM 完整功能比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MarkDown：&lt;a href=&quot;https://files.cnblogs.com/files/kellynic/ORM_VS.zip&quot;&gt;https://files.cnblogs.com/files/kellynic/ORM_VS.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章连接：&lt;a href=&quot;https://www.cnblogs.com/kellynic/p/13664720.html&quot;&gt;https://www.cnblogs.com/kellynic/p/13664720.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;net-orm-基础信息比较&quot;&gt;.NET ORM 基础信息比较&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能项&lt;/th&gt;
&lt;th&gt;FreeSql&lt;/th&gt;
&lt;th&gt;EFCore&lt;/th&gt;
&lt;th&gt;SqlSugar&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.9382716049383&quot;&gt;&lt;tr&gt;&lt;td&gt;出生时间&lt;/td&gt;
&lt;td&gt;2018年12月&lt;/td&gt;
&lt;td&gt;2015年(约)&lt;/td&gt;
&lt;td&gt;2014年(约)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开源协议&lt;/td&gt;
&lt;td&gt;MIT&lt;/td&gt;
&lt;td&gt;Apache-2.0&lt;/td&gt;
&lt;td&gt;Apache-2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;所属机构&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/dotnetcore&quot;&gt;dotnetcore(NCC)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;dotnet&lt;/td&gt;
&lt;td&gt;sunkaixuan(个人)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单元测试数量&lt;/td&gt;
&lt;td&gt;5500+&lt;/td&gt;
&lt;td&gt;很多&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;github star&lt;/td&gt;
&lt;td&gt;2.1k+&lt;/td&gt;
&lt;td&gt;9.5k+&lt;/td&gt;
&lt;td&gt;3.1k+&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;github issues&lt;/td&gt;
&lt;td&gt;活跃&lt;/td&gt;
&lt;td&gt;活跃&lt;/td&gt;
&lt;td&gt;不活跃&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持平台&lt;/td&gt;
&lt;td&gt;.NET4.0+、.NETCore&lt;/td&gt;
&lt;td&gt;.NETCore&lt;/td&gt;
&lt;td&gt;.NET4.5+、.NETCore&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;支持数据库&lt;/td&gt;
&lt;td&gt;很多，并且行为一致&lt;/td&gt;
&lt;td&gt;很多&lt;/td&gt;
&lt;td&gt;SqlServer/MySql/Sqlite/Oracle&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;生命周期&lt;/td&gt;
&lt;td&gt;Singleton&lt;/td&gt;
&lt;td&gt;Scoped&lt;/td&gt;
&lt;td&gt;Scoped&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;使用方式&lt;/td&gt;
&lt;td&gt;IFreeSql、Repository&lt;/td&gt;
&lt;td&gt;DbContext&lt;/td&gt;
&lt;td&gt;SugarClient&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;FreeSql .NET ORM 支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/Firebird/达梦/人大金仓/神舟通用/Access。&lt;/p&gt;
&lt;p&gt;.NET ORM 各有自已看家本领，本文主要按 FreeSql 提供的功能进行列举比较，如有冒犯请见谅，也欢迎向 FreeSql 提出功能建议。&lt;/p&gt;
&lt;p&gt;每个功能实现的深度层次不一样（比如 EFCore 支持 SqlServer 2012，FreeSql 支持 SqlServer 2005），很难彻底比较，提示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文比较的功能 FreeSql 每种数据库基本都有提供，不像 EFCore 偏向 SqlServer&lt;/li&gt;
&lt;li&gt;本文只比较官方提供的功能（不包含第三方扩展）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202009/31407-20200914063104631-2088330287.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202009/31407-20200914063148941-1489586974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202009/31407-20200914063955435-856878176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;net-orm-整体功能比较&quot;&gt;.NET ORM 整体功能比较&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能项&lt;/th&gt;
&lt;th&gt;FreeSql&lt;/th&gt;
&lt;th&gt;EFCore&lt;/th&gt;
&lt;th&gt;SqlSugar&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.596638655462&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 根据实体类型，创建表结构&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 根据实体类型，对比表结构&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 根据实体类型注释，迁移表结构备注&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst FluentApi&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst FluentApi 语法兼容 EFCore&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 实体特性兼容 EFCore&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 自定义实体特性(Aop)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CodeFirst 类型转换映射(MapType)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM DbFirst 根据数据库，生成实体类&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 导航属性(OneToOne)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 导航属性(ManyToOne)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 导航属性(OneToMany)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 导航属性(ManyToMany)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.2258064516129&quot;&gt;&lt;td&gt;.NET ORM 导航属性(Parent) &lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%e6%9f%a5%e8%af%a2%e7%88%b6%e5%ad%90%e5%85%b3%e7%b3%bb&quot;&gt;父子关系的实体类&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 导航属性延时加载、贪婪加载、级联保存&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 自定义表达式树解析&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 全局过滤器&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 事务&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 读写分离&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 分表分库&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 仓储 Repository&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 工作单元 UnitOfWork&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 工作单元管理器 UnitOfWorkManager&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM DbContext 状态管理&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;net-orm-crud-功能比较&quot;&gt;.NET ORM CRUD 功能比较&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能项&lt;/th&gt;
&lt;th&gt;FreeSql&lt;/th&gt;
&lt;th&gt;EFCore&lt;/th&gt;
&lt;th&gt;SqlSugar&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;48.174247277386&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CRUD 时，映射动态表名&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CRUD 时，使用参数化 SQL 执行&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CRUD 时，不使用参数化 SQL 执行(NoneParameter)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CRUD 时，获取对应的 SQL(ToSql)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM CRUD 时，统一审计实体属性值(Aop.AuditValue)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 插入(单条)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，忽略/指定列&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，返回影响的行数&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，返回插入后的自增值&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，返回插入后的记录&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，Insert Ignore Into&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，On Duplicate Key Update&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 插入时，On Conflict Do Update&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.0322580645161&quot;&gt;&lt;td&gt;.NET ORM 批量插入 &lt;a href=&quot;https://www.cnblogs.com/kellynic/p/10557882.html&quot;&gt;性能测试结果参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;.NET ORM 批量插入时，自动分批 &lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E6%B7%BB%E5%8A%A0#2%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5&quot;&gt;参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 批量插入时，使用BulkCopy&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 更新(单条)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，动态条件(WhereDynamic)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，根据实体对象更新&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，根据状态管理只更新有变化的属性&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，忽略/指定列&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，原子性 set num=num+1&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，指定条件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，自动附加全局过滤器条件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，不需要先查询&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，使用乐观行锁&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，使用悲观锁&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，返回影响的行数&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 更新时，返回插入后的记录&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 批量更新&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 删除(单条)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，动态条件(WhereDynamic)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，指定条件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，自动附加全局过滤器条件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，不需要先查询&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，返回影响的行数&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 删除时，返回插入后的记录&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 级联保存&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 添加或更新&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6619718309859&quot;&gt;&lt;td&gt;.NET ORM 添加或更新，自动适配 merge into &lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E6%B7%BB%E5%8A%A0%E6%88%96%E4%BF%AE%E6%94%B9&quot;&gt;参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.52&quot;&gt;&lt;td&gt;.NET ORM 批量编辑保存 &lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E6%B7%BB%E5%8A%A0%E6%88%96%E4%BF%AE%E6%94%B9#3beginedit-%E6%89%B9%E9%87%8F%E7%BC%96%E8%BE%91&quot;&gt;参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET ORM 查询(单条)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，分页&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，分页支持 SqlServer2008&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，动态条件(WhereDynamic)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7073170731707&quot;&gt;&lt;td&gt;.NET ORM 查询时，动态过滤条件(WhereDynamicFilter) &lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E6%9F%A5%E8%AF%A2#%E7%89%B9%E5%88%AB%E4%BB%8B%E7%BB%8D-wheredynamicfilter&quot;&gt;参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，自动附加全局过滤器条件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，多表条件传播(WhereCascade)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，在 lambda 中使用导航属性&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，用 Dto 映射只需要查询的字段&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，传 Sql 作二次查询(WithSql)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，子查询(Exists)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，子查询(In)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6842105263158&quot;&gt;&lt;td&gt;.NET ORM 查询时，子查询拼接结果(string.Join) &lt;a href=&quot;https://github.com/dotnetcore/FreeSql/wiki/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2#7%E5%AD%90%E8%A1%A8join&quot;&gt;参考文档&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，使用分组聚合(GroupBy/Having)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET ORM 查询时，使用 Linq To Sql 语法&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.36&quot;&gt;&lt;td&gt;.NET ORM 查询时，针对树形结构表 &lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%e6%9f%a5%e8%af%a2%e7%88%b6%e5%ad%90%e5%85%b3%e7%b3%bb&quot;&gt;父子关系的实体类&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;net-orm-总结&quot;&gt;.NET ORM 总结&lt;/h2&gt;
&lt;p&gt;.NET ORM FreeSql 功能强大，扩展方便，从 issues 和 qq群 可以看得出社区更新极积有问必应；&lt;/p&gt;
&lt;p&gt;.NET ORM EFCore 主要是面向对象操作，许多方式不符合中国人习惯，长期更新（但不友好兼容）；&lt;/p&gt;
&lt;p&gt;.NET ORM SqlSugar 历史问题多，并且 issues 和 qq群 已经基本不解决问题；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;.NET ORM FreeSql 作者的努力希望能打动到你，肯请正在使用的、善良的您能动一动小手指，把文章转发一下，让更多人知道 .NET 有这样一个好用的 ORM 存在。谢谢了！！&lt;/p&gt;
&lt;p&gt;.NET ORM FreeSql 开源协议 MIT &lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，可以商用，文档齐全。QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;如果你有好的 ORM 实现想法，欢迎给作者留言讨论，谢谢观看！&lt;/p&gt;
</description>
<pubDate>Sun, 13 Sep 2020 23:29:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>.NET ORM 前言 为什么要写这篇文章？ 希望针对 SEO 优化搜索引擎，让更多中国人知道并且使用。目前百度搜索 .NET ORM 全是 sqlsugar，我个人是无语的，每每一个人进群第一件事就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/13664720.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】菜单（Menu）功能 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13664727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13664727.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;老孟导读：今天介绍下Flutter中的&lt;strong&gt;菜单功能&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用PopupMenuButton，点击时弹出菜单，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  itemBuilder: (context) {
    return &amp;lt;PopupMenuEntry&amp;lt;String&amp;gt;&amp;gt;[
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '语文',
        child: Text('语文'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '数学',
        child: Text('数学'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '英语',
        child: Text('英语'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '生物',
        child: Text('生物'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '化学',
        child: Text('化学'),
      ),
    ];
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070844230-235779525.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置其初始值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  initialValue: '语文',
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置初始值后，打开菜单后，设置的值将会高亮，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070844615-173642006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取用户选择了某一项的值，或者用户未选中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  onSelected: (value){
    print('$value');
  },
  onCanceled: (){
    print('onCanceled');
  },
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tooltip&lt;/code&gt;是长按时弹出的提示，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  tooltip: 'PopupMenuButton',
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070844963-987718039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置其阴影值、内边距和弹出菜单的背景颜色：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  elevation: 5,
  padding: EdgeInsets.all(5),
  color: Colors.red,
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，PopupMenuButton显示3个小圆点，我们也可以对齐进行设置，设置文字如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  child: Text('学科'),
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;child&lt;/code&gt;组件将会被InkWell包裹，点击弹出菜单，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070845128-2116205882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以设置其他图标：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
        icon: Icon(Icons.add),
        ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070845564-434033978.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置弹出菜单边框：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  shape: RoundedRectangleBorder(
    side: BorderSide(
      color: Colors.red
    ),
    borderRadius: BorderRadius.circular(10)
  ),
        ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070845730-18985024.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;menu有一个非常重要的参数&lt;code&gt;Offset&lt;/code&gt;，这个参数是控制菜单弹出的位置，通常情况下，菜单在当前按钮下面展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  offset: Offset(0,100),
  itemBuilder: (context) {
    return &amp;lt;PopupMenuEntry&amp;lt;String&amp;gt;&amp;gt;[
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '语文',
        child: Text('语文'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '数学',
        child: Text('数学'),
      ),
    ];
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070845895-942972524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PopupMenuButton&lt;/code&gt;的每一项都需要是&lt;code&gt;PopupMenuEntry&lt;/code&gt;类型，&lt;code&gt;PopupMenuEntry&lt;/code&gt;为抽象类，其子类有PopupMenuItem、PopupMenuDivider、CheckedPopupMenuItem。&lt;/p&gt;

&lt;p&gt;构造函数为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070846037-2028907874.png&quot; alt=&quot;image-20200522160319731&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value：当此项选中后，此值将会通过&lt;code&gt;onSelected&lt;/code&gt;返回。&lt;/li&gt;
&lt;li&gt;enabled：此项是否可用。&lt;/li&gt;
&lt;li&gt;height：此项的高度&lt;/li&gt;
&lt;li&gt;textStyle：文本样式&lt;/li&gt;
&lt;li&gt;child：子控件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  onSelected: (value) {
    print('$value');
  },
  itemBuilder: (context) {
    return &amp;lt;PopupMenuEntry&amp;lt;String&amp;gt;&amp;gt;[
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '语文',
        enabled: false,
        child: Text('语文'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '数学',
        textStyle: TextStyle(color: Colors.red),
        child: Text('数学'),
      ),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '英语',
        height: 100,
        child: Text('英语'),
      ),
    ];
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070846269-1927788931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;PopupMenuDivider是菜单分割线，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  onSelected: (value) {
    print('$value');
  },
  itemBuilder: (context) {
    return &amp;lt;PopupMenuEntry&amp;lt;String&amp;gt;&amp;gt;[
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '语文',
        child: Text('语文'),
      ),
      PopupMenuDivider(),
      PopupMenuItem&amp;lt;String&amp;gt;(
        value: '数学',
        child: Text('数学'),
      ),
    ];
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070846423-930344362.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PopupMenuDivider默认高度为16，注意这个高度并不是分割线的高度，而是分割线控件的高度，设置为50代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuDivider(height: 50,),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070846560-2252811.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CheckedPopupMenuItem是前面带是否选中的控件，本质就是一个ListTile，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;PopupMenuButton&amp;lt;String&amp;gt;(
  onSelected: (value) {
    print('$value');
  },
  itemBuilder: (context) {
    return &amp;lt;PopupMenuEntry&amp;lt;String&amp;gt;&amp;gt;[
      CheckedPopupMenuItem(
        value: '语文',
        checked: true,
        child: Text('语文'),
      ),
      CheckedPopupMenuItem(
        value: '数学',
        child: Text('数学'),
      ),
    ];
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070846806-157782511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果你看下&lt;code&gt;PopupMenuButton&lt;/code&gt;的源码会发现，&lt;code&gt;PopupMenuButton&lt;/code&gt;也是使用showMenu实现的，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;showMenu(
    context: context,
    position: RelativeRect.fill,
    items: &amp;lt;PopupMenuEntry&amp;gt;[
      PopupMenuItem(child: Text('语文')),
      PopupMenuDivider(),
      CheckedPopupMenuItem(
        child: Text('数学'),
        checked: true,
      ),
      PopupMenuDivider(),
      PopupMenuItem(child: Text('英语')),
    ]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;position&lt;/code&gt;参数表示弹出的位置，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070847225-1448639309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性和&lt;code&gt;PopupMenuButton&lt;/code&gt;基本一样，但使用&lt;code&gt;showMenu&lt;/code&gt;需要我们指定位置，所以一般情况下，我们不会直接使用&lt;code&gt;showMenu&lt;/code&gt;，而是使用&lt;code&gt;PopupMenuButton&lt;/code&gt;，免去了计算位置的过程。&lt;/p&gt;
&lt;p&gt;看下&lt;code&gt;PopupMenuButton&lt;/code&gt;是如何计算的，有助于帮助我们理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;final PopupMenuThemeData popupMenuTheme = PopupMenuTheme.of(context);
    final RenderBox button = context.findRenderObject();
    final RenderBox overlay = Overlay.of(context).context.findRenderObject();
    final RelativeRect position = RelativeRect.fromRect(
      Rect.fromPoints(
        button.localToGlobal(widget.offset, ancestor: overlay),
        button.localToGlobal(button.size.bottomRight(Offset.zero), ancestor: overlay),
      ),
      Offset.zero &amp;amp; overlay.size,
    );
    final List&amp;lt;PopupMenuEntry&amp;lt;T&amp;gt;&amp;gt; items = widget.itemBuilder(context);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070847549-1265662357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200914070847846-891149191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sun, 13 Sep 2020 23:09:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：今天介绍下Flutter中的菜单功能。 PopupMenuButton 使用PopupMenuButton，点击时弹出菜单，用法如下： PopupMenuButton&amp;amp;lt;Stri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13664727.html</dc:identifier>
</item>
<item>
<title>高可用服务之Keepalived利用脚本实现服务的可用性检测 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13664040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13664040.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200907045236keepalived.png&quot; class=&quot;desc_img&quot;/&gt; 对于高可用nginx或haproxy这类在用户空间有监听端口和进程的服务来说，如果用keepalived做高可用，我们需要考虑到我们高可用的服务是否正常可用，从而实现在服务不正常的情况下，把对应的VIP能够迁移到其他节点；为了实现能够检测到高可用的服务是否正常，keepalived提供了调用外部脚本的接口，让我们配置对高可用的服务做可用性检测；根据我们定义的脚本，keepalived会周期性的去执行我们的定义的脚本，根据脚本执行退出码判断服务是否可用，一旦发生服务不可用，或者可用性检测不通过，它就会触发当前keepalived节点的优先级降低，从而实现当前节点在通告优先级时，触发备份节点接管VIP，从而实现VIP转移，服务的高可用；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;161.67994260835&quot;&gt;
&lt;p&gt;　　上一篇博客主要聊到了keepalived高可用LVS集群的相关配置，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13659428.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13659428.html&lt;/a&gt;；keepalived高可用LVS集群是Keepalived的设计之初的功能，所以它高可用LVS集群内置了对LVS的RS的健康状态检测，自动生成IPVS规则；我们知道LVS是Linux内核功能，本质上在用户空间不会监听任何端口，它的主要作用是对用户请求的流量做4层调度，所以对于这种没有进程，没有端口信息的服务我们怎么去判断它是否正常就先得尤为重要；同样的道理对于高可用nginx或haproxy这类在用户空间有监听端口和进程的服务来说，如果用keepalived做高可用，我们需要考虑到我们高可用的服务是否正常可用，从而实现在服务不正常的情况下，把对应的VIP能够迁移到其他节点；为了实现能够检测到高可用的服务是否正常，keepalived提供了调用外部脚本的接口，让我们配置对高可用的服务做可用性检测；根据我们定义的脚本，keepalived会周期性的去执行我们的定义的脚本，根据脚本执行退出码判断服务是否可用，一旦发生服务不可用，或者可用性检测不通过，它就会触发当前keepalived节点的优先级降低，从而实现当前节点在通告优先级时，触发备份节点接管VIP，从而实现VIP转移，服务的高可用；&lt;/p&gt;
&lt;p&gt;　　在keepalived的配置文件中，我们可以用vrrp_script {...} 来定义我们可以执行的脚本相关信息；用track_script {..}在对应vrrp实例中调用vrrp_script定义的脚本；&lt;/p&gt;
&lt;p&gt;　　示例：利用脚本对LVS做可用性检测&lt;/p&gt;
&lt;p&gt;　　1、编写脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 keepalived]# ls
check_lvs.sh  keepalived.conf  keepalived.conf.bak  notify.sh
[root@node01 keepalived]# chmod a+x check_lvs.sh 
[root@node01 keepalived]# ll
total 16
-rwxr-xr-x 1 root root   98 Sep 13 22:26 check_lvs.sh
-rw-r--r-- 1 root root 1611 Sep 13 22:24 keepalived.conf
-rw-r--r-- 1 root root 3598 Sep  8 23:29 keepalived.conf.bak
-rwxr-xr-x 1 root root  472 Sep 10 13:58 notify.sh
[root@node01 keepalived]# cat check_lvs.sh 
#!/bin/bash
ping -c 2 192.168.0.1 &amp;amp;&amp;gt; /dev/null
if [ $? -eq 0 ];then
    exit 0
else
    exit 1
fi
[root@node01 keepalived]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上脚本主要是利用ping 192.168.0.1这个地址来判断推出码是0还是1，正常退出时0，非正常退出为1；&lt;/p&gt;
&lt;p&gt;　　2、配置keepalived调用上面的脚本，并在VIP所在实例中引用；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913222427328-2093633183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示定义了一个脚本，名为check_LVS(这个名称可以任意起，主要起标识作用，后面在实例中引用的一个标识)；这个脚本执行时间间隔为每2秒执行一次，超时时长为2秒，如果脚本执行失败（退出码非0）就把对应节点的优先级降低20（通常这个降低的值要大于两节点优先级之差就行，意思就是降低后的优先级要小于备份节点优先级，这样才有意义）；脚本执行连续3次检测都为成功状态（脚本推出码都为0），则keepalived就标记该实例为OK状态，并会一直检测下去，如果连续3次检查都为失败状态（退出码非0），则标记对应实例为KO状态；一旦标记对应实例为失败状态就会触发当前节点的优先级降低；从而在通告心跳时，会通告降低后的优先级，从而实现备份节点接管VIP来完成vip转移；&lt;/p&gt;
&lt;p&gt;　　完整的keepalived配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c73e67ba-5b7f-413c-ba92-af274ff266da')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c73e67ba-5b7f-413c-ba92-af274ff266da&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c73e67ba-5b7f-413c-ba92-af274ff266da&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c73e67ba-5b7f-413c-ba92-af274ff266da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@node01 keepalived]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; keepalived.conf
&lt;/span&gt;! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node01_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node01
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_iptables
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_script check_LVS {
    script &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/check_lvs.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    interval &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    timeout &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    weight &lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
    rise &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    fall &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.111&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
    notify_master &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_backup &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh backup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_fault  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh fault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    track_script {
        check_LVS
    }
}

virtual_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.111&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
        delay_loop &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        lb_algo wrr
        lb_kind DR
        protocol TCP
        sorry_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;

        real_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.43&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
                weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                nb_get_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                delay_before_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
                HTTP_GET {
                    url {
                    path &lt;/span&gt;/&lt;span&gt;index.html
                    status_code &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
                    }
                }
        }
        real_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.44&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
                weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                nb_get_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                delay_before_retry &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
                HTTP_GET {
                    url {
                    path &lt;/span&gt;/&lt;span&gt;index.html
                    status_code &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
                    }
                }
        }
}

[root@node01 keepalived]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　提示：vrrp_script中的script可以是脚本路径，也可以是一段命令；&lt;/p&gt;
&lt;p&gt;　　验证：重启keepalived，修改脚本中的IP地址，模拟故障，故意让其对指定地址ping不通，看看对应vip是否会从master节点飘逸到备份节点？对应节点的优先级是否有变化？&lt;/p&gt;
&lt;p&gt;　　未修改脚本时，vip在node01上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913224558454-1726323840.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改脚本以后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913224636135-1384368657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：修改脚本以后对应的VIP就没有在node01上了；&lt;/p&gt;
&lt;p&gt;　　查看node01上keepalived的日志信息，看看它是如何故障转移的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913224953678-1282801434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从日志文件可以看到，当keepalived周期性去执行check_lvs.sh脚本时，连续3次都执行失败，就触发了动态调整当前节点所在keepalived的优先级，把原来优先级为100调整至80，然后通告自己的心跳信息时，又触发了备份节点通告自己的优先级信息，对应主节点收到高于它的优先级通告，所以它就自动转换成backup状态，并删除了VIP；然后后续也在每隔2秒检测一次脚本执行否正常；&lt;/p&gt;
&lt;p&gt;　　在node02上查看vip是否存在？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913225533986-1619406089.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　访问VIP看看服务是否可访问？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913225737753-1605767517.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应用户访问还是可以正常访问；&lt;/p&gt;
&lt;p&gt;　　验证：修改脚本为正常可通信地址，看看对应节点是否会重新转换为master角色呢？对应vip是否会漂移回来呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913230032301-87288647.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可看到修改脚本以后，对应vip就回来了；&lt;/p&gt;
&lt;p&gt;　　查看keepalived的日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913230230888-2065697261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当脚本执行成功以后，首先会触发当前节点的优先级还原为原有优先级，并通告出去，然后把当前节点从backup角色转换为master角色，接管VIP;&lt;/p&gt;
&lt;p&gt;　　以上示例主要用于对那种高可用服务在用户空间没有监听端口，没有进程，我们需要借助某种机制去判读该服务是否正常，比如上面我们利用ping某个ip地址去判断LVS是否正常，从而来决定对应节点的优先级是否调整，进而来决定vip是否转移；当然对于在用户空间有监听端口，有进程的服务也是同样的套路，我们可以利用脚本去检测端口是否存在，或者对应进程是否正常来决定VIP是否转移；&lt;/p&gt;
&lt;p&gt;　　示例：keepalived利用脚本来检测nginx进程是否正常，从而来实现对nginx的高可用&lt;/p&gt;
&lt;p&gt; 　　1、编写脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913231628960-1922993769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上脚本利用killall命令对nginx进程发送0号信号，去判断对应的nginx进程是否存在，如果存在该命令会返回0，否则返回非0；利用命令的返回值来确定脚本退出码；&lt;/p&gt;
&lt;p&gt;　　2、在keepalived的配置文件中定义脚本相关参数，并在vrrp实例中引用定义的脚本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913232025856-808275787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完整的keepalived配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5751d3b6-9a10-4453-b62f-7051a8fd6dbf')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_5751d3b6-9a10-4453-b62f-7051a8fd6dbf&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_5751d3b6-9a10-4453-b62f-7051a8fd6dbf&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5751d3b6-9a10-4453-b62f-7051a8fd6dbf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@node01 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/keepalived/&lt;span&gt;keepalived.conf
&lt;/span&gt;! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
        root@localhost
   }
   notification_email_from node01_keepalived@localhost
   smtp_server &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id node01
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_iptables
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_mcast_group4 &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;12.132&lt;/span&gt;&lt;span&gt;
}

vrrp_script check_LVS {
    script &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/check_lvs.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    interval &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    timeout &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    weight &lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
    rise &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    fall &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
}
vrrp_script check_nginx {
    script &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/check_nginx.sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    interval &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    timeout &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    weight &lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;
    rise &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    fall &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.111&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt; dev ens33 label ens33:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
    notify_master &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_backup &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh backup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    notify_fault  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/keepalived/notify.sh fault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    track_script {
        check_LVS
        check_nginx
    }
}
[root@node01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　提示：vrrp_script需要定义在实例之外，表示引用一段上下文来定义脚本相关信息；定义了脚本信息，如果不在实例中引用，它是不会周期性的去执行脚本，只有在实例中引用的脚本名称以后（这里的名称是vrrp_script后面的名称）才会使对应的脚本周期性的去执行；&lt;/p&gt;
&lt;p&gt;　　在node01和node02上安装nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum install nginx -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提供测试页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913232653021-493208830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913232712252-1726292154.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重启keepalived 和nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
systemctl restart nginx keepalived.service 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913233534111-1124801308.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913233607298-430523647.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到重启nginx和keepalived以后，在node01上有VIP和80端口，在node02上没有vip，但80端口处于监听状态；如果此时有用户访问vip，就会由node01上的nginx提供响应；&lt;/p&gt;
&lt;p&gt;　　验证：用浏览器访问vip，看看响应的内容是否是我们在node01上提供的测试页面？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913233956061-2138489995.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证：把node01上的nginx停掉，看看对应的服务是否还可访问？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913234117977-379633663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到把node01上的nginx停掉以后，对应的vip也就随之被删除；&lt;/p&gt;
&lt;p&gt;　　再次访问vip看看是否会有响应？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202009/1503305-20200913234312100-737442374.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在访问vip响应的页面内容变成了node02上nginx提供的测试页面；说明现在是由node02上的nginx在提供服务；&lt;/p&gt;
&lt;p&gt;　　到此keepalived高可用nginx的配置就完成了，至于nginx怎么工作，是否为调度器，这里的keepalived并不关心，它只关心nginx进程是否正常；对于keepalived高可用其他服务，思路都是类似的，不同的是对于不同的服务，检测脚本可能有所不同；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 13 Sep 2020 16:34:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>上一篇博客主要聊到了keepalived高可用LVS集群的相关配置，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13659428.html；keepalive</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13664040.html</dc:identifier>
</item>
<item>
<title>一文带你了解微服务架构和设计（多图） - 小二十七</title>
<link>http://www.cnblogs.com/xiao2shiqi/p/13664290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao2shiqi/p/13664290.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/b670310e76c4381777a7eb437048e9d8%E7%9A%84%E5%89%AF%E6%9C%AC.jpg&quot; alt=&quot;南岳衡阳（封面）&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近几年微服务很火，大家都在建设微服务，如果不懂点微服务相关的技术，都不好意思跟同行打招呼了，也见过身边很多人在微服务踩过很多坑，我从 16 年开始接触微服务，有多家大型企业的微服务分布式系统的架构经验，所以就打算跟大家做一期关于微服务的分享，不过微服务和涉及的分布式计算非常的复杂，绝非是一篇文章就可以讲清楚的，本文只是从最简单的概念的基本使用带你入门，如果后续还有兴趣的话，可以查阅相关的文献和技术书籍去深入学习&lt;/p&gt;
&lt;p&gt;本文的微服务分享以下三部分，总体大纲如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;微服务的概念和原则（理论）&lt;/li&gt;
&lt;li&gt;Spring Cloud 如何低成本的实现微服务（实现）&lt;/li&gt;
&lt;li&gt;Spring Cloud 大型项目的架构方案（真实案例）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;微服务的概念和原则&quot;&gt;微服务的概念和原则&lt;/h3&gt;
&lt;h5 id=&quot;什么是微服务？&quot;&gt;什么是微服务？&lt;/h5&gt;
&lt;p&gt;简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把单艘航母理解为的单体应用（防御差，机动性不好），把航母战斗群（调度复杂，维护费用高）理解为微服务。&lt;/p&gt;
&lt;p&gt;简单讲特征就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单体应用：简单，脆弱（某个模块出问题，整个系统不可用），战斗力弱，维护成本低&lt;/li&gt;
&lt;li&gt;微服务架构：复杂，健壮（某个模块出问题，不会影响系统整体的可用性），战斗力强，维护成本高&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/qa8ZwK.jpg&quot; alt=&quot;单体作战的应用&quot;/&gt;&lt;p&gt;单体作战的应用（图）&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/6Q8b7D.jpg&quot; alt=&quot;微服务战斗群&quot;/&gt;&lt;p&gt;微服务战斗群（图）&lt;/p&gt;
&lt;p&gt;大部分的开发者经历和开发过单体应用，无论是传统的 SSM，还是现在的 SpringBoot/Rails，它们都是单体应用，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署成本高（无论是修改1行代码，还是10行代码，都要全量部署替换）&lt;/li&gt;
&lt;li&gt;改动影响大，风险高，测试成本高（不论代码改动多小，成本都相同）&lt;/li&gt;
&lt;li&gt;因为成本高，风险高，所以导致部署频率低（无法满足快速交付客户需求）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题&lt;/p&gt;
&lt;p&gt;但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/hMIKpW.jpg&quot; alt=&quot;hMIKpW&quot;/&gt;&lt;p&gt;历代应用程序的架构变迁（图）&lt;/p&gt;
&lt;h5 id=&quot;解决什么问题，又引入了什么问题？&quot;&gt;解决什么问题，又引入了什么问题？&lt;/h5&gt;
&lt;p&gt;我们先看看微服务能带给我们什么？微服务架构的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对特定服务发布，影响小，风险小，成本低&lt;/li&gt;
&lt;li&gt;频繁发布版本，快速交付需求&lt;/li&gt;
&lt;li&gt;低成本扩容，弹性伸缩，适应云环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们知道一个朴素的理念，没有任何事物是完美的，任何东西都有两面性，有得必有失&lt;/p&gt;
&lt;p&gt;那么在选择微服务在解决了快速响应和弹性伸缩的问题同时，它又给我们带来了什么问题？个人总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式系统的复杂性&lt;/li&gt;
&lt;li&gt;部署，测试和监控的成本问题&lt;/li&gt;
&lt;li&gt;分布式事务和 CAP 的相关问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统应用由原来的单体变成几十到几百个不同的工程，会所产生例如包括服务间的依赖，服务如何拆封，内部接口规范，数据传递等等问题，尤其是服务拆分，需要团队熟悉业务流程，懂得取舍，要保证拆分的粒度服务既符合“高内聚，低耦合”的基本原则，还要兼顾业务的发展以及公司的愿景，要还要说服团队成员为之努力，并且积极投入，在多方中间取得平衡。&lt;/p&gt;
&lt;p&gt;对于分布式系统，部署，测试和监控都需要大量的中间件来支撑，而且中间件本身也要维护，原先单体应用很简单的事务问题 ，转到分布式环境就变得很复杂，分布式事务是采用简单的重试+补偿机制，还是采用二阶段提交协议等强一致性方法来解决，就要取决对业务场景的熟悉加上反复的权衡了，相同问题还包括对 CAP 模型的权衡，总之微服务对团队整体的技术栈水平整体要求更高&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/4Q2Tk0.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;微服务有应该遵循哪些原则？&quot;&gt;微服务有应该遵循哪些原则？&lt;/h5&gt;
&lt;p&gt;古人云：兵马未动，粮草先行。建设微服务是需要建立长远规划，不是像写 CMS 那样建好数据库表，然后就开始干活，这样十有八九是会失败的。我们要进行微服务改造前，架构师要提前做好规划，我们把这里分为三步，前期阶段，设计阶段，技术阶段&lt;/p&gt;
&lt;p&gt;前期阶段，大致要做好如下事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和多方充分沟通，确保能符合客户和组织的需求，并且得到认同&lt;/li&gt;
&lt;li&gt;和团队沟通，让队友（开发/测试/运维）理解，并且积极投入&lt;/li&gt;
&lt;li&gt;和业务部门沟通，指定版本计划和上线时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设计阶段，参考 Sam Newman 的著作&lt;a href=&quot;https://book.douban.com/subject/26772677/&quot;&gt;《微服务设计》&lt;/a&gt;，单微服务必须要满足以下的条件，才符合微服务的基本要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准的 REST 风格接口（基于 HTTP 和 JSON 格式）&lt;/li&gt;
&lt;li&gt;独立部署，避免共享数据库（避免因为数据库而影响整个分布式系统）&lt;/li&gt;
&lt;li&gt;业务上的高内聚，减少依赖（从设计上要避免服务过大或者太小）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;庞大的分布式系统，需要强大基础设施来支撑，微服务涉及哪些基础设施？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CI/CD和自动化（分布式系统几乎不可能通过人工手动发布）&lt;/li&gt;
&lt;li&gt;虚拟化技术（要保证微服务运行环境隔离，目前行业主流的是使用 Docker 容器）&lt;/li&gt;
&lt;li&gt;日志聚合，全链路监控（高度可观察和分析诊断问题）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说了那么多，那什么样的情况下，你的团队不适合建设微服务？（请勿对号入座）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发团队不具备自主性，所在组织对开发团队限制非常多（具体请参考 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B&quot;&gt;康威定律&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;团队不熟悉业务，无法识别出服务的边界，进行合理的拆分（请参考 DDD &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot;&gt;领域驱动设计&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;微服务设计其实是很早就有的设计思想，因为随着虚拟化技术的崛起，微服务可以低成本的实现，所以也开始流行和兴起。&lt;/p&gt;
&lt;p&gt;微服务的内涵很深，其中就包括，自动化，去中心化，独立性等等，其中细节无法用一篇文章概述清楚，我们在做技术选型或者方案的时候，尽可能多去了解技术的本身和起源再结合我们业务的特点，进行更好的选择。&lt;/p&gt;
&lt;h3 id=&quot;如何低成本的实现微服务的-？&quot;&gt;如何低成本的实现微服务的 ？&lt;/h3&gt;
&lt;p&gt;Spring Cloud 为什么是国内最流行的微服务框架，它提供哪些开箱即用的组件 ？概览如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Srping Boot 服务应用&lt;/li&gt;
&lt;li&gt;Spring Cloud Config 配置中心&lt;/li&gt;
&lt;li&gt;Spring Cloud Eureka 服务发现&lt;/li&gt;
&lt;li&gt;Spring Cloud Hystrix 熔断保护&lt;/li&gt;
&lt;li&gt;Spring Cloud Zuul 服务网关&lt;/li&gt;
&lt;li&gt;Spring Cloud OAuth 2 服务保护&lt;/li&gt;
&lt;li&gt;Spring Cloud Stream 消息驱动&lt;/li&gt;
&lt;li&gt;分布式全链路跟踪&lt;/li&gt;
&lt;li&gt;部署微服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建议参考资料：&lt;a href=&quot;https://www.springcloud.cc&quot;&gt;微服务架构集成，云计算最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;spring-boot-微服务基石&quot;&gt;Spring Boot 微服务基石&lt;/h5&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/KXO7YI.jpg&quot; alt=&quot;Srping Boot Admin&quot;/&gt;&lt;p&gt;SpringBoot是构建微服务的理想框架，主要得益于 SpringBoot 可以打包成为单个可执行JAR文件交付服务，Spring Actuator 公开服务健康信息都是微服务的基石，为甚么这么说 ？&lt;/p&gt;
&lt;p&gt;我们先看看构建微服务的 4 个重要原则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务应该是独立和可独立部署的&lt;/li&gt;
&lt;li&gt;应该从中央（配置中心）读取配置&lt;/li&gt;
&lt;li&gt;对客户端是透明的&lt;/li&gt;
&lt;li&gt;传达健康信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微服务有优点和缺点，并非所有应用都适合用微服务架构，架构师需要能做到以下要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分解业务问题：描述业务问题，注意动词，寻找数据内聚&lt;/li&gt;
&lt;li&gt;建立服务粒度：讲大服务重构到更小的服务，重点关注服务如何相互交互，服务职责随时间改变&lt;/li&gt;
&lt;li&gt;定义服务接口：拥抱REST的理念，使用URI来传达意图，使用HTTP状态码传达结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;糟糕的微服务有哪些特征？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;过于粗粒度：服务承担过多的职责，服务跨大量表来管理数据，测试用例太多&lt;/li&gt;
&lt;li&gt;过于细粒度：服务彼此依赖严重，服务内部没有逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;何时不应该使用微服务 ？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不愿投入（需要高度成熟的运维，伸缩，复杂性问题）&lt;/li&gt;
&lt;li&gt;管理 / 监控散乱的服务器也需要很高的成本&lt;/li&gt;
&lt;li&gt;小型应用不适合，太昂贵&lt;/li&gt;
&lt;li&gt;数据事务（分布式系统处理事务非常困难）&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-config-配置服务&quot;&gt;Spring Cloud Config 配置服务&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/kRSJID.jpg&quot; alt=&quot;Spring Config 工作原理&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Config 是 Spring 提供的配置中心轻量级实现，基于 Git 存储，&lt;/p&gt;
&lt;p&gt;国内用户大多推荐使用 Alibaba 开源的 &lt;a href=&quot;https://github.com/alibaba/nacos&quot;&gt;Nacos&lt;/a&gt; （集成配置中心和注册中心）都是非常不错的配置中心的实现&lt;/p&gt;
&lt;p&gt;微服务程序对于配置中心的几点管理原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序的配置和部署的实际代码分离（配置中心和应用程序分离）&lt;/li&gt;
&lt;li&gt;集中（将配置中心集中在少量的存储库中）&lt;/li&gt;
&lt;li&gt;稳定（配置中心要保证高可用）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Config 这款配置中心提供的核心功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置服务器允许使用环境特定值&lt;/li&gt;
&lt;li&gt;使用Spring Profile区分环境值&lt;/li&gt;
&lt;li&gt;可以使用基于文件或基于Git存储属性&lt;/li&gt;
&lt;li&gt;允许对称加密和非对称加密&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-eureka-服务发现&quot;&gt;Spring Cloud Eureka 服务发现&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/MiZyP7.jpg&quot; alt=&quot;服务发现的运行原理&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务发现是微服务架构中非常重要的概念，也称&lt;strong&gt;注册中心&lt;/strong&gt;，&lt;strong&gt;类似我们生活中的房地产中介的角色，买房卖房都要通过它&lt;/strong&gt;，所以是所有微服务上线/下线的必经之路，也掌握微服务的生杀大权，注册中心会根据 CAP 策略和对微服务的健康检查，作出对具体服务剔除，下线，恢复上线等操作，主要还有以下几个核心功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速对环境中服务数量水平伸缩（功能和 k8s 有些重合，不过也可以设定具体服务的运行时数量）&lt;/li&gt;
&lt;li&gt;抽象服务的物理位置（微服务通常运行在 Docker 容器内，没有固定 IP，只能通过注册中心才能找到它）&lt;/li&gt;
&lt;li&gt;提高程序的弹性，自动伸缩&lt;/li&gt;
&lt;li&gt;信息共享， 健康检测&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微服务架构里面要实现注册中心，需要达到哪些基本要求？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高可用，注册信息共享（注册中心集群部署），不可能因为注册中心挂了，导致所有集群不可用&lt;/li&gt;
&lt;li&gt;负载均衡（对服务间的动态请求负载均衡），合理在服务间分配流量&lt;/li&gt;
&lt;li&gt;有弹性（客户端缓存服务信息）&lt;/li&gt;
&lt;li&gt;容错，健康检查（检测坏掉的服务自动移除，无需人工干预）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/zVPd95.png&quot; alt=&quot;Spring Cloud Eureka 的工作页面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Eureka 提供的服务发现实现，具备哪些特点 ？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务发现抽象服务的物理位置&lt;/li&gt;
&lt;li&gt;无感知添加和移除服务&lt;/li&gt;
&lt;li&gt;为服务间调用提供负载均衡&lt;/li&gt;
&lt;li&gt;使用 3种不同机制来调用服务：DiscoveryClient，支持Ribbon的RestTemplate，Netflix的FeignClient&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-hystrix--熔断保护&quot;&gt;Spring Cloud Hystrix 熔断保护&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/tACQPW.png&quot; alt=&quot;tACQPW&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熔断的概念非常好理解，比如当我们家里的消耗电量负载太高，到达设定的阈值的时候，电路系统就会启动熔断机制，也叫过载保护，通过跳闸，强行断电的方式，来保护整体电路的稳定，熔断在微服务中的概念也是一样，是保护是微服务稳定的防火墙，避免单个服务溃崩或者异常导致出现整个集群系统的雪崩和连锁反应现场&lt;/p&gt;
&lt;p&gt;为什么微服务进行熔断 ？当一个服务出现问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通常都是从小部分开始，到耗尽线程彻底崩溃&lt;/li&gt;
&lt;li&gt;服务间调用会长时间阻塞&lt;/li&gt;
&lt;li&gt;服务未关闭就会一直被调用，导致连锁效应&lt;/li&gt;
&lt;li&gt;一个性能不佳的服务可以迅速拖垮整个应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么熔断很重要 ？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个节点（调用服务和数据库）实现断路器，可以避免服务崩溃的连锁效应&lt;/li&gt;
&lt;li&gt;实现只有出问题的服务受影响，其余的服务功能都是完整的（影响范围降到最小）&lt;/li&gt;
&lt;li&gt;熔断是服务器的灵活的基础&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;断路器提供的关键能力&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速失败&lt;/li&gt;
&lt;li&gt;功能降级（替代方案）&lt;/li&gt;
&lt;li&gt;无缝恢复（断路器定期检查，自动恢复服务）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/9YvOvl.png&quot; alt=&quot;Spring Boot Admin - Hystrix &amp;amp; Turbine&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Netflix 研发和出品的 Hystrix 实现是一款成熟稳定的熔断实现，在 Netflix 在生产实践和运行多年，非常可靠，后面加入 Spring Cloud 体系，成为 Spring Cloud 微服务生态链的一员，使用起来也非常的简单和方便&lt;/p&gt;
&lt;p&gt;Hystrix 支持 4 种断路模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端负载均衡模式（检测服务出错，移除服务）&lt;/li&gt;
&lt;li&gt;断路器模式（出现超时抛出异常强行失败，超过阈值强行失败所有调用）&lt;/li&gt;
&lt;li&gt;后备模式（不是抛出异常而是执行替代方案，例如排队，稍后再试等）&lt;/li&gt;
&lt;li&gt;舱壁模式（把远程调用的资源分配到独立的线程池中，调用出问题只是线程池饱和并停止请求）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;跳闸会导致的3种结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务B立即知道服务C有问题，不必等待，立即失败&lt;/li&gt;
&lt;li&gt;服务B执行服务C的替代代码来采取行动（后备模式）&lt;/li&gt;
&lt;li&gt;服务C可以再跳闸后，检查问题，快速恢复&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/s8Qggd.png&quot; alt=&quot;Spring Cloud Hystrix 实现的流量监控&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熔断的几个处理原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设计分布式应用必须考虑弹性&lt;/li&gt;
&lt;li&gt;服务的彻底故障是很容易检测和处理，只是需要时间，断路器给了这个时间窗口&lt;/li&gt;
&lt;li&gt;一个服务性能不佳，可能导致集群崩溃，因为相互调用会阻塞线程，耗尽资源&lt;/li&gt;
&lt;li&gt;Hystrix支持两种隔离模型，即 THREAD 和 SEMAPHORE&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-zuul-网关&quot;&gt;Spring Cloud Zuul 网关&lt;/h5&gt;
&lt;p&gt;网关是整个微服务分布式集群的入口，对于用户来说，用户无需知道你每个服务的地址，只需要记住网关地址就可以了，这样理解可能比较抽象，&lt;strong&gt;举一个生活的例子，微服务集群是一个大型公司，公司内部有很多个不同的职能部门（对应每个微服务），但是你如果要访问具体的职能部门，你必须先到前台登记，再由前台带你到你想访问的具体职能部门去办理实际的业务（智能路由）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务对于网关实现的规范：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个独立负责所有服务调用过滤和路由的服务&lt;/li&gt;
&lt;li&gt;服务和客户端的中间人，简化客户端开发&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网关通常要做哪些事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态路由，从注册中心获取每个微服务的具体位置&lt;/li&gt;
&lt;li&gt;动态路由（根据参数特点，调用特定服务，少量用户体验新功能，通常用于灰度发布）&lt;/li&gt;
&lt;li&gt;验证和授权：验证访客的身份信息（统一验证，服务只需要关注业务逻辑）&lt;/li&gt;
&lt;li&gt;数据收集和日志（收集调用次数和响应时间等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zuul 网关的具体运行参考图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/g1Ns6D.png&quot; alt=&quot;Zuul Api Gateway 工作流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Zuul 是初期版本的 API 网关实现，提供以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结合 Spring Cloud Eureka 将服务发现的注册地址加入到 Zuul 路由&lt;/li&gt;
&lt;li&gt;Zuul 可以给所有服务轻松的添加 /api 之类的前缀路由地址&lt;/li&gt;
&lt;li&gt;在全局上定制 Zuul 的 Spring Cloud Hystrix 和 Spring Cloud Ribbon （调度策略）的超时&lt;/li&gt;
&lt;li&gt;实现动态路由，不同版本进行A/B测试&lt;/li&gt;
&lt;li&gt;检查参数合法性等，例如 JWT，时间戳等等&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-oauth-2-服务保护&quot;&gt;Spring Cloud OAuth 2 服务保护&lt;/h5&gt;
&lt;p&gt;Oauth 2 是用于保证请求的合法和正确性，&lt;strong&gt;为了让微服务本身更加专注于业务&lt;/strong&gt;，所以 OAuth 2 类似配置中心被单独抽离出来作为基础组件的统一认证中心来使用，&lt;strong&gt;OAuth 2 的作用类似我们生活中的公安局的角色&lt;/strong&gt;，当我们需要去正规机构办理业务的时候，我们需要提供有效的身份证（合法的身份认证标示），如果没有你就需要去公安局（OAuth）申请一张在有效期内的身份证（Token），然后带着这张身份证我们才能去购买机票，酒店等其他社会服务（微服务），社会服务机构在拿到你提供的身份证（Token）后，也会向公安局（OAuth）联网发送信息，来验证你的身份证的合法性（Token 合法性校验），身份认证不通过就会被拒绝服务，合法的身份才能进行业务的办理，关于 OAuth 的工作流程，可以结合下图来理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/hgHFZc.png&quot; alt=&quot;OAuth 工作流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务对于 OAuth2 规范的4中类型授权：密码/客户端凭据/授权码/隐式&lt;/p&gt;
&lt;p&gt;Spring Cloud OAuth 2 为我们提供哪些便利？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全框架，提供令牌生成，验证等逻辑&lt;/li&gt;
&lt;li&gt;开箱即用，和其他服务无缝集成&lt;/li&gt;
&lt;li&gt;行业标准，轻松与云服务商集成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OAuth 2：/auth/oauth/token的返回信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;access_token（OAuth2令牌，每次调用出示）&lt;/li&gt;
&lt;li&gt;token_type（令牌类型，常用bearer token）&lt;/li&gt;
&lt;li&gt;refresh_token（续约令牌）&lt;/li&gt;
&lt;li&gt;expires_in（过期描述，默认12H）&lt;/li&gt;
&lt;li&gt;scope（令牌有效作用域）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OAuth 2 支持 JWT （JSON Web Token）的规范，关于 JWT 的原理就不特别解释了，简单的 JWT 有以下几个特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小巧（Base64编码）&lt;/li&gt;
&lt;li&gt;密码签名（防篡改）&lt;/li&gt;
&lt;li&gt;自包含（不需要调用验证服务确认内容，通过相同的密钥进行对称解密）&lt;/li&gt;
&lt;li&gt;可扩展（可在令牌内包含额外的信息）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OAuth 2 的简单总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OAuth2 是一个令牌验证框架&lt;/li&gt;
&lt;li&gt;使用OAuth2 需要建立OAuth2验证服务&lt;/li&gt;
&lt;li&gt;调用受保护的资源都要通过OAuth2验证&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;spring-cloud-stream-消息驱动&quot;&gt;Spring Cloud Stream 消息驱动&lt;/h5&gt;
&lt;p&gt;我们和世界的互动不是同步的，很多时候是基于消息异步驱动模型，比如邮件，点餐，订票等等，想要了解 Spring Cloud Stream，必须先要理解基于事件（MQ）编程的模型，基于消息驱动有利于开发构建高度解耦的系统，因为 Spring Cloud Stream 并不是自己实现了消息中间件，而是对于市场上主流（例如 RabbitMQ，KafKa）的 MQ 产品做了一层封装和抽象，Spring Cloud Stream 做的事情并不是什么新鲜的事情，非常类似 ORM 所做的事情，了解 ORM 框架的同学应该都熟悉对于多种数据库（MySQL，Oracle，SQL Server）产品的抽象是何等重要，面向 ORM 进行数据库访问，可以让你脱离对于指定数据库产品的深度依赖和绑定，而且可以不用特意去学习不同数据库的本地化特性和方言，降低学习成本，假如你想从 Oracle 迁移到 MySQL 上面，几乎是不需要改动一行代码，只需要改动 ORM 的配置就可以实现了，参考下图简单了解一下 ORM：&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/5s2tsN.png&quot; alt=&quot;简单了解 ORM&quot;/&gt;&lt;p&gt;Spring Cloud Stream 类似 ORM，你只需要基于 Spring Cloud Stream 提供的消息模型进行编程，至于底层的消息组件是用的 RabbitMQ 还是 kafka 还是其他的消息中间件产品，都没有关系，甚至更换底层消息组件也不会对你的应用产生任何影响，这就是标准化所带来的收益，关于如何更好的理解 Spring Cloud Stream 工作模型可以简单参考下图：&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/cImAiC.png&quot; alt=&quot;Stream 类似 ORM 的工作流程&quot;/&gt;&lt;p&gt;微服务中使用的的两种服务通信方式对比：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同步：通过REST端点接口进行请求：服务之间紧耦合（强依赖），服务之间的脆弱性（连锁效应），增加新的消费者不灵活&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;异步：基于消息中间件通信：松耦合（无接口直接调用的依赖），耐久性（服务重启后可以消费历史消息），可伸缩性（消息过多可启动多服务来处理消息），灵活性（轻松添加新的消费者）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;消息传递架构的缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息处理语义：消息顺序处理，消息异常处理&lt;/li&gt;
&lt;li&gt;消息可见性：消息不会立刻被处理，事务关联ID在消息中的传递&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;消息中放置什么数据 ？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息体要尽可能的小，减少传输成本：通常只返回action类型和id，然后用id获取最新数据&lt;/li&gt;
&lt;li&gt;只使用消息传递状态：在消息中包含版本号和时间戳，处理数据服务可以检查数据的版本号&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring Cloud Stream 的消息模型和概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发射器（Source）：接收对象（对象表示要发布的消息），序列化对象，将消息发布到通道&lt;/li&gt;
&lt;li&gt;通道（Channel）：队列的抽象，通道写在配置文件，更改配置切换通道（读取和写入队列）&lt;/li&gt;
&lt;li&gt;绑定器（Binder）：与消息平台对话的 Spring 代码，不必依赖特定的API来发布和消费消息&lt;/li&gt;
&lt;li&gt;接收器（Sink）：从队列接收消息，将消息反序列化为POJO&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Cloud Stream 的简单总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用消息传递的异步通信是微服务架构的关键部分&lt;/li&gt;
&lt;li&gt;使用消息传递可以使服务能够伸缩并且更具有容错性&lt;/li&gt;
&lt;li&gt;Spring Cloud Stream 通过简单的注解抽象底层的消息平台细节&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;sleuth-和-zipkin-分布式跟踪&quot;&gt;Sleuth 和 Zipkin 分布式跟踪&lt;/h5&gt;
&lt;p&gt;微服务分布式架构带来了复杂度，成本最高的就是跟踪检查和运维，分布式意味要在多个服务，机器跟踪一个事务，Sleuth 和 Zipkin 都是用于 Spring Cloud 服务体系的分布式跟踪技术，先直接看下最终效果，下图一个简单的可视化链路跟踪调用，ZipKin 可以清晰的看到一个客户端请求在每个服务上面处理所消耗的事情，点击进去可以看到具体的事务执行内容，方便排查错误&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/CmA4NW.png&quot; alt=&quot;全链路跟踪&quot;/&gt;&lt;p&gt;Spring Cloud Sleuth 的工作流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;透明地创建并注入一个关联ID到服务调用中&lt;/li&gt;
&lt;li&gt;管理关联ID到出站服务调用的传播&lt;/li&gt;
&lt;li&gt;将关联信息添加到Spring的MDC日志记录（应用/跟踪ID/跨度ID/数据发送）&lt;/li&gt;
&lt;li&gt;将服务调用中的跟踪信息发布到Zipkin跟踪平台&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Open Zipkin 的简单概述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用链使用一张干净简洁的图片，比一百万条日志要好看的多&lt;/li&gt;
&lt;li&gt;分布式跟踪平台，用于跟踪多个服务调用的事务&lt;/li&gt;
&lt;li&gt;图形的方式查看事务占用的时间量，分解每个服务所用的时间&lt;/li&gt;
&lt;li&gt;4种不同的数据存储：内存数据/MySQL/Cassandra/Elasticsearch&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于微服务全链路跟踪的总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SpringCloudSleuth 可以无缝将关联ID添加到微服务中&lt;/li&gt;
&lt;li&gt;可以使用关联ID查看事务涉及的所有服务行为&lt;/li&gt;
&lt;li&gt;关联ID需要与日志聚合结合使用&lt;/li&gt;
&lt;li&gt;日志平台很重要，但是可视化跟踪事务也是有价值的工具&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;部署微服务&quot;&gt;部署微服务&lt;/h5&gt;
&lt;p&gt;构建和部署管道是微服务架构重最要的部分，微服务的主要特点是快速构建，修改，发布&lt;/p&gt;
&lt;p&gt;符合微服务特征的部署要达到以下几个要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动的（自动构建和部署代码&lt;/li&gt;
&lt;li&gt;完整的（软件成品是镜像），不可变（发布过程不可人为干预）&lt;/li&gt;
&lt;li&gt;良好的微服务部署管道应该允许在几分钟部署新功能和修复bug&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spring-cloud-大型项目的架构方案&quot;&gt;Spring Cloud 大型项目的架构方案&lt;/h3&gt;
&lt;h6 id=&quot;真实案例讲解&quot;&gt;真实案例讲解&lt;/h6&gt;
&lt;p&gt;这是一个真实用于国内某大型企业的微服务架构体系，支撑日均百万订单的项目，因为已经过了2年的保密期，所以可以拿出来分享&lt;/p&gt;
&lt;p&gt;刚好可以结合前面凌乱的知识点，看看 Spring Cloud 这套组件是如何搭建起来的，整套微服务就是下面这张架构图：&lt;/p&gt;
&lt;img src=&quot;https://pcloud-1258173945.cos.ap-guangzhou.myqcloud.com/uPic/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-3.png&quot; alt=&quot;微服务架构设计-3&quot;/&gt;&lt;p&gt;具体每个组件的作用就不在这里详细说明了，在这套架构方案里面&lt;/p&gt;
&lt;p&gt;我们没有完全照搬 Spring Cloud 全家桶的组建，还是根据自己的需求对其中组件进行的更换例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置中心从 Spring Cloud Config 更换为 Apollo ，除了有更好的性能，还有更加简化的操作页面，修改配置文件毫秒级响应&lt;/li&gt;
&lt;li&gt;服务发现 Eureka 官网已经停止维护，我们后面更换为 Alibaba Nacos，服务注册和心跳检测都提升到毫秒级，Eureka 是90秒轮询&lt;/li&gt;
&lt;li&gt;分布式任务调度引入了 XXL-JOB，这是国内主流的分布式任务调度平台，没有特别需要说明的地方&lt;/li&gt;
&lt;li&gt;日志聚合也是用了主流的 ELK 技术方案，用于收集和检索日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：另外在值得补充的是，在写这篇文章的时候 Spring Cloud Zuul 已经不被官方推荐使用了，替代品是性能更好的 &lt;a href=&quot;https://spring.io/projects/spring-cloud-gateway&quot;&gt;Spring Cloud Gateway&lt;/a&gt; ，大家可以在了解的时候需要注意一下&lt;/p&gt;
&lt;p&gt;最后总结：&lt;/p&gt;
&lt;p&gt;微服务是未来大型企业的必经之路，虽然成本很高，但是可以提升 IT 系统的健壮性和提升技术人员的广度和深度都还是很有帮助的&lt;/p&gt;
</description>
<pubDate>Sun, 13 Sep 2020 16:28:00 +0000</pubDate>
<dc:creator>小二十七</dc:creator>
<og:description>不懂点微服务相关的技术，都快不好意思跟同行打招呼了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiao2shiqi/p/13664290.html</dc:identifier>
</item>
<item>
<title>flutter driver 集成测试 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/13664254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/13664254.html</guid>
<description>&lt;p&gt;最近一直断断续续的学习flutter，今天跟大家介绍一下flutter driver测试。&lt;/p&gt;
&lt;h2 id=&quot;flutter测试基础&quot;&gt;flutter测试基础&lt;/h2&gt;
&lt;p&gt;Flutter的测试遵循Android的测试规范进行了分层。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单元测试：测试单一功能、方法或类。例如，被测单元的外部依赖性通常被模拟出来，如package:mockito。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;widget 测试：(在其它UI框架称为 组件测试) 测试的单个widget。（我们要开发一个UI界面，需要通过组合其它Widget来实现，Flutter中，一切都是Widget！）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;集成测试： 测试一个完整的应用程序或应用程序的很大一部分。通常，集成测试可以在真实设备或OS仿真器上运行，例如iOS Simulator或Android Emulator。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同类型测试之间简单对比：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;单元测试&lt;/th&gt;
&lt;th&gt;widget测试&lt;/th&gt;
&lt;th&gt;集成测试&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Confidence&lt;/td&gt;
&lt;td&gt;Low Higher&lt;/td&gt;
&lt;td&gt;Highest&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;维护成本&lt;/td&gt;
&lt;td&gt;Low Higher&lt;/td&gt;
&lt;td&gt;Highest&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;依赖&lt;/td&gt;
&lt;td&gt;Few More&lt;/td&gt;
&lt;td&gt;Lots&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;执行速度&lt;/td&gt;
&lt;td&gt;Quick&lt;/td&gt;
&lt;td&gt;Slower&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;flutter-driver-集成测试&quot;&gt;flutter driver 集成测试&lt;/h2&gt;
&lt;p&gt;集成测试就是我们最常看到的 Flutter UI自动化测试，他的执行过程一般需要在模拟器或真机上启动App，模拟用户的点击、输入操作，从而完成功能的验证。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，你要创建第一个flutter应用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://book.flutterchina.club/chapter2/first_flutter_app.html&quot;&gt;https://book.flutterchina.club/chapter2/first_flutter_app.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202009/311516-20200914000715619-868477465.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面涉及到的文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter_app/
├── lib/
│   └── .dart 
├── test_driver/
|   ├── app.dart
|   └── app_test.dart 
├── pubspec.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;pubspec.yaml&lt;/code&gt; 文件中，添加&lt;code&gt;flutter_driver&lt;/code&gt;插件，所以 flutter_driver并不是创建项目标配的，需要你额外安装。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;dev_dependencies:
  test: ^1.5.1
  flutter_test:
    sdk: flutter
  flutter_driver:
    sdk: flutter

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在flutter应用根目录下执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;flutter_app&amp;gt; flutter pub get
Running &quot;flutter pub get&quot; in flutter_app...                         0.6s
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在项目的跟目录下创建&lt;code&gt;test_driver&lt;/code&gt;目录，分别在该目录下创建&lt;code&gt;app.dart&lt;/code&gt; 和 &lt;code&gt;app_test.dart&lt;/code&gt;文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个指令化的应用程序是一个Flutter应用程序，它启用了Flutter Driver 扩展。启用扩展请调用enableFlutterDriverExtension()。&lt;code&gt;app.dart&lt;/code&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;// 导入扩展
import 'package:flutter_driver/driver_extension.dart';
// 导入main入口文件
import 'package:flutter_app/main.dart' as app;

void main() {
  // 启用扩展
  enableFlutterDriverExtension();

  app.main();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;集成测试是一个简单的package:test测试，它使用Flutter Driver API告诉应用程序执行什么操作，然后验证应用程序是否执行了此操作。&lt;/p&gt;
&lt;p&gt;编写继承测试用例，&lt;code&gt;app_test.dart&lt;/code&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'dart:io';
// Imports the Flutter Driver API
import 'package:flutter_driver/flutter_driver.dart';
import 'package:test/test.dart';


void main() {
  group('计数器测试', () {

    final counterTextFinder = find.byValueKey('counter');
    FlutterDriver driver;

    setUpAll(() async {
      driver = await FlutterDriver.connect();
      sleep(Duration(seconds: 2));
    });

    tearDownAll(() async {
      if (driver != null) {
        driver.close();
      }
    });

    // 第一条用例
    test('starts at 1', () async {
      expect(await driver.getText(counterTextFinder), &quot;0&quot;);
    });

    // 第二条用例
    test('increments the counter', () async {
      driver.tap(find.byTooltip(&quot;Increment&quot;));
      expect(await driver.getText(counterTextFinder),  &quot;1&quot;);
    });

  });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为一个有多年测试经验的同学，单纯学习元素定位和断言也花了我半天时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setUpAll()&lt;/code&gt; &amp;amp; &lt;code&gt;tearDownAll()&lt;/code&gt; ：定义用例开始和结束的执行动作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;driver = await FlutterDriver.connect();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链接接app，这是App测试的入口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;driver.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭浏览器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;driver.tap()
driver.enterText()
driver.getText()
...

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;flutter常用操作，触摸、输入和获取文本等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;find.byValueKey()
find.byTooltip()
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;元素定位，Flutter driver提供了好几种定位方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;expect()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;断言方法，断言两个值是否相等。&lt;/p&gt;
&lt;p&gt;flutter driver API：&lt;br/&gt;&lt;a href=&quot;https://api.flutter.dev/flutter/flutter_driver/flutter_driver-library.html&quot;&gt;https://api.flutter.dev/flutter/flutter_driver/flutter_driver-library.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行集成测试&quot;&gt;运行集成测试&lt;/h2&gt;
&lt;p&gt;最后，如何运行集成测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter_app&amp;gt; flutter drive --target=./test_driver/app.dart

Using device Android SDK built for x86.
Starting application: ./test_driver/app.dart
Installing build\app\outputs\apk\app.apk...                         1.5s
Running Gradle task 'assembleDebug'...
Running Gradle task 'assembleDebug'... Done                         2.4s
✓ Built build\app\outputs\apk\debug\app-debug.apk.
I/flutter (16043): Observatory listening on http://127.0.0.1:58900/uUbkcJhS5qM=/
00:00 +0: 计数器测试 (setUpAll)

VMServiceFlutterDriver: Connecting to Flutter application at http://127.0.0.1:54121/uUbkcJhS5qM=/
VMServiceFlutterDriver: Isolate found with number: 4454864095217843
VMServiceFlutterDriver: Isolate is paused at start.
VMServiceFlutterDriver: Attempting to resume isolate
VMServiceFlutterDriver: Waiting for service extension
VMServiceFlutterDriver: Connected to Flutter application.
00:03 +0: 计数器测试 starts at 1

00:03 +1: 计数器测试 increments the counter

点击 add Icon

断言计数器加1

00:03 +2: 计数器测试 (tearDownAll)

00:03 +2: All tests passed!

Stopping application instance.
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 13 Sep 2020 16:09:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>最近一直断断续续的学习flutter，今天跟大家介绍一下flutter driver测试。 flutter测试基础 Flutter的测试遵循Android的测试规范进行了分层。 单元测试：测试单一功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/13664254.html</dc:identifier>
</item>
</channel>
</rss>