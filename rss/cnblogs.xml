<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[AspNetCore 3.0 ]  Blazor 服务端组件 Render, RenderFragment ，RenderTreeBuilder, CascadingValue/CascadingParameter 等等 - 前门后院</title>
<link>http://www.cnblogs.com/cerl/p/11834510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cerl/p/11834510.html</guid>
<description>&lt;p&gt;支撑Blazor的是微软的两大成熟技术，Razor模板和SignalR，两者的交汇点就是组件。通常，我们从ComponentBase派生的类型，或者创建的.razor 文件，就可以称作组件。基于这两大技术，组件也就具备了两大功能，1、生成html片段；2、维护组件状态。这里我们来说一下组件最基本的功能，生成html片段。&lt;/p&gt;

&lt;p&gt;我们知道，浏览器处理HTML 文档时会将所有的标签都挂到一颗文档树中，无论一段HTML来自哪里，总会被这棵树安排的明明白白。换句话说，如果有根线的话，我们可以依靠这棵树把所有的标签都串起来，而在Blazor组件中也有这么一根线，这根线就是RenderTreeBuilder，拿这根线的人就是Blazor框架。&lt;/p&gt;
&lt;p&gt;备注一下：以下涉及的代码如果没有特别说明，都是指写在.cs文件中，继承 Microsoft.AspNetCore.Components.ComponentBase 的组件类。&lt;/p&gt;
&lt;p&gt;下面用代码看看这根线。 新建一个Blazor 应用 项目，新增 一个c#类，&lt;code&gt;MyComp&lt;/code&gt; 继承 Microsoft.AspNetCore.Components.ComponentBase，然后override 一下，找到如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            base.BuildRenderTree(builder);//加断点
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加个断点，在项目的 Pages\Index.razor 里加上一行。&lt;code&gt;&amp;lt;MyComp /&amp;gt;&lt;/code&gt;&lt;br/&gt;如果不想代码执行两次，就在Pages_Host.cshtml 里修改一下rendermode&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @(await Html.RenderComponentAsync&amp;lt;App&amp;gt;(RenderMode.Server))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F5跑起来，虽然没有任何输出，但是断点命中了，RenderTreeBuilder这根线确实串起了我们的组件。&lt;br/&gt;现在让我们看看，RenderTreeBuilder 可以做什么。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.AddMarkupContent(0, &quot;&amp;lt;span&amp;gt; BuildRenderTree  使用 AddMarkupContent 输出 Html 。&amp;lt;/span&amp;gt;&quot;);
           // base.BuildRenderTree(builder);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次跑起来，我们发现页面上多了我们加的span.也就是说HTML的输出，靠的是调用RenderTreeBuilder上的各种方法加上的。组件的基本原理也就是这样，一个RenderTreeBuilder 进入不同组件的 BuildRenderTree 方法，方法内 通过RenderTreeBuilder上的add.. open.. 方法把我们想要输出的部分，挂载到builder上，最终输出到浏览器。&lt;/p&gt;
&lt;p&gt;接下来，我们考察一下&lt;code&gt;BuildRenderTree&lt;/code&gt;方法， 用委托描述一下，我们发现这就是一个&lt;code&gt;Action&amp;lt;RenderTreeBuilder&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在标题里我们提到了RenderFragment， 查看一下它的定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public delegate void RenderFragment(RenderTreeBuilder builder);//还是一个 Action&amp;lt;RenderTreeBuilder&amp;gt;，或者说，BuildRenderTree 就是一个RenderFragment&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现和前面的&lt;code&gt;BuildRenderTree&lt;/code&gt; 在签名上一模一样，既然blazor会使用RenderTreeBuilder 去调用BuildRenderTree 方法，那么RenderFragment会不会也被调用？&lt;/p&gt;
&lt;p&gt;让我们暂时离开组件MyComp,转到Index.razor 内加一段code&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @code{
     RenderFragment MyRender=(builder) =&amp;gt; builder.AddMarkupContent(0, &quot;&amp;lt;span&amp;gt;当前输出来自：Index.razor 组件， MyRender 字段。 &amp;lt;/span&amp;gt;&quot;);
        
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在之前我们声明 MyComp组件之后，再加一行调用 &lt;code&gt;@MyRender&lt;/code&gt;.&lt;br/&gt;完整的Index.razor&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;

&amp;lt;MyComp /&amp;gt;

 @MyRender

@code{
     
    RenderFragment MyRender = (builder) =&amp;gt; builder.AddMarkupContent(0, &quot;&amp;lt;div&amp;gt;当前输出来自：Index.razor 组件， MyRender 字段。 &amp;lt;/div&amp;gt;&quot;);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两段信息，如愿输出，证明blazor能够识别出模板中的 RenderFragment ，并自动调用。&lt;br/&gt;既然我们在组件模板中(Index.razor)书写RenderFragment ，当然有其他方式可以不用拼凑字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; RenderFragment AnotherRender =@&amp;lt;div&amp;gt;模板写法的RenderFragment&amp;lt;/div&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上调用 &lt;code&gt;@AnotherRender&lt;/code&gt;，跑起来，三段信息。&lt;/p&gt;
&lt;p&gt;至此，我们对RenderFragment 有了一个大概的了解，它是一个函数，内部打包了我们的输出内容。在模板中我们可以使用，&lt;code&gt;@xxxrender&lt;/code&gt;将其就地展开输出，在c#环境下我们可以通过 &lt;code&gt;xxxrender(builder)&lt;/code&gt;的形式进行调用（比如在BuildRenderTree方法内调用）。又因为其本身就是一个委托函数，因此我们即可以在组件内使用，也可以自由的在组件之间传递， 完成对输出内容及逻辑的复用。&lt;br/&gt;同时，为了更好的配合RenderFragment 使用，Blazor中还提供了一个工厂委托，RenderFragment , 即 Func&amp;lt;TValue,RenderFragment&amp;gt; 用法一般如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//模板中(Index.razor)
RenderFragment&amp;lt;object&amp;gt; RenderValue =value=&amp;gt; @&amp;lt;div&amp;gt; render value :@value&amp;lt;/div&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;@RenderValue (123)&lt;/code&gt; 如果在c#代码中,比如在BuildRenderTree 方法内， &lt;code&gt;RenderValue (123)(builder)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;vs中*.razor在编译时会生成对应的.g.cs代码，位置在obj/debug/netcoreapp3.0/ razor 下，可以多打开看看。&lt;/p&gt;

&lt;p&gt;1、html中，我们可以在一对标签内添加 内容，比如 &lt;code&gt;&amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt;&lt;/code&gt;,组件默认是不支持此类操作的，这时我们就需要RenderFragment来包装标签内的内容。&lt;/p&gt;
&lt;p&gt;让我们回到MyComp组件类中，增加一个属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Parameter] public RenderFragment ChildContent{ get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Index.razor&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;MyComp&amp;gt;&amp;lt;div&amp;gt; 组件标记内部&amp;lt;/div&amp;gt;&amp;lt;/MyComp&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时直接运行的话，组件不会输出内部信息，需要在BuildRenderTree 中执行一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
          ChildContent?.Invoke(builder);
          
            base.BuildRenderTree(builder);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件标记内的片段被打包进了 ChildContent，已经变成了独立的一个片段，因此需要我们显式的调用一下。&lt;br/&gt;ChildContent 是特殊名称&lt;/p&gt;
&lt;p&gt;2、组件上有多个RenderFragment&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   [Parameter] public RenderFragment Fragment1 { get; set; }
        [Parameter] public RenderFragment Fragment2 { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时调用需要调整一下,不然框架不知道把内容片段打包进哪个属性里&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;MyComp&amp;gt;
        &amp;lt;Fragment1&amp;gt;

            &amp;lt;div&amp;gt; Fragment1 &amp;lt;/div&amp;gt;
        &amp;lt;/Fragment1&amp;gt;
        &amp;lt;Fragment1&amp;gt;
            &amp;lt;div&amp;gt; Fragment1.1  &amp;lt;/div&amp;gt;

        &amp;lt;/Fragment1&amp;gt;
        &amp;lt;Fragment2&amp;gt;
            &amp;lt;div&amp;gt; Fragment2  &amp;lt;/div&amp;gt;

        &amp;lt;/Fragment2&amp;gt;
  
    &amp;lt;/MyComp&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里故意重复处理了Fragment1，可以看看结果。&lt;/p&gt;
&lt;p&gt;3、带参数的RenderFragment&lt;br/&gt;code:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Parameter] public RenderFragment&amp;lt;MyComp&amp;gt; ChildContent { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用及传参&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;MyComp Context=&quot;self&quot; &amp;gt; //&amp;lt;ChildContent&amp;gt;
       @self.GetType()
      
    &amp;lt;/MyComp&amp;gt;  //&amp;lt;/ChildContent&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、打开的组件声明标记内部，除了可以使用RenderFragment 参数属性外，其他的razor 语法基本都支持，也包括另外一个组件。&lt;br/&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;MyComp&amp;gt;
         &amp;lt;CompA /&amp;gt;
          &amp;lt;CompB&amp;gt; ...... &amp;lt;/CompB&amp;gt;
&amp;lt;/MyComp&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;MyComp&amp;gt;
       &amp;lt;Fragment1&amp;gt;
         &amp;lt;CompA /&amp;gt;
      &amp;lt;/Fragment1&amp;gt;

          &amp;lt;Fragment2&amp;gt;
          &amp;lt;CompB&amp;gt; ...... &amp;lt;/CompB&amp;gt;
          &amp;lt;/Fragment2&amp;gt;
&amp;lt;/MyComp&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然看上去，声明标记的代码很相似，但却有着实质上的不同。&lt;br/&gt;当我们使用 标记声明一个参数属性时，我们是在生成RenderFragment，随后将其赋值给对应的属性。&lt;br/&gt;当我们使用标记声明一个组件时，我们是在构造一个组件实例，然后调用它，将组件输出插入到组件所在位置。&lt;br/&gt;参数属性（RenderFragment ）属于组件，是组件的一个属性，互相关系是明确的类型《=》成员关系。&lt;br/&gt;组件内部的其他组件标记很多时候只是为了复用一些输出片段，如果不通过代码进行一些处理的话，是无法明确知道组件之间关系的。&lt;/p&gt;

&lt;p&gt;组件多起来之后，组件之间的数据共享和传递以及组件间的关系就会变的很麻烦，数量少的时候，还可以使用@ref 手工指定，多起来之后@ref明显不是一个好方法。 组件CascadingValue和对应的特性[CascadingParameter]就是为了解决这一问题而出现。&lt;/p&gt;
&lt;p&gt;一个CascadingValue 内的所有组件 包括子级，只要组件属性上附加了[CascadingParameter]特性，并且值内容可以兼容，此属性就会被赋值。&lt;/p&gt;
&lt;p&gt;比如给组件定义 属性接收CascadingValue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [CascadingParameter] public  int Value { get; set; }
        [CascadingParameter] public string SValue { get; set; }

//修改下输出
    protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.AddMarkupContent(0, $&quot;&amp;lt;div&amp;gt;CascadingValue: {Value},{SValue} &amp;lt;/div&amp;gt;&quot;);// 一个int，一个string
            ChildContent?.Invoke(this)(builder);//加载下级组件
            base.BuildRenderTree(builder);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在razor页中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;CascadingValue Value=&quot;123&quot;&amp;gt; //int
      &amp;lt;MyComp&amp;gt;
                         &amp;lt;MyComp&amp;gt;&amp;lt;/MyComp&amp;gt;
                     &amp;lt;/MyComp&amp;gt;
&amp;lt;/CascadingValue &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后我们就会发现，两个组件都捕获到了int 值 123.&lt;br/&gt;现在再加一个CascadingValue&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;CascadingValue Value=&quot;123&quot;&amp;gt; //int
&amp;lt;CascadingValue Value=&quot;@(&quot;aaaa&quot;)&quot;&amp;gt; //string
      &amp;lt;MyComp&amp;gt;
                         &amp;lt;MyComp&amp;gt;&amp;lt;/MyComp&amp;gt;
                     &amp;lt;/MyComp&amp;gt;
&amp;lt;/CascadingValue &amp;gt;
&amp;lt;/CascadingValue &amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分属两个CascadingValue 的两个不同类型值，就被每个组件的两个属性捕获到，方便、强大而且自身不产生任何HTML输出，因此使用场景非常广泛。比如官方Forms组件中就是借助CascadingValue/Parameter 完成model的设置，再比如，组件默认没有处理父子、包含关系的接口，这时就可以简单的定义一个&lt;code&gt;[CascadingParameter] public ComponentBase Parent{get;set;}&lt;/code&gt;专门接收父级组件，处理类似Table/Columns之类的组件关系。&lt;/p&gt;

&lt;p&gt;组件是为其自身的 BuildRenderTree方法 （ RenderFragment ）服务的，组件上的各种属性方法，都是为了给RenderFragment 做环境准备，因此组件实质上是个RenderFragment的包装类。组件系统则通过一个RenderTreeBuilder依次调用各组件，收集输出内容，最终交给系统内部完成输出。&lt;br/&gt;1、.Razor文件会被编译为一个组件类（obj/debug/netcore3.0/razor/...)&lt;br/&gt;2、组件系统创建RenderTreeBuilder，将其交给组件实例&lt;br/&gt;3、组件实例使用 RenderTreeBuilder，调用自身 BuildRenderTree。&lt;br/&gt;4、等待组件状态变化，再次输出。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:53:00 +0000</pubDate>
<dc:creator>前门后院</dc:creator>
<og:description>一、组件 支撑Blazor的是微软的两大成熟技术，Razor模板和SignalR，两者的交汇点就是组件。通常，我们从ComponentBase派生的类型，或者创建的.razor 文件，就可以称作组件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cerl/p/11834510.html</dc:identifier>
</item>
<item>
<title>一文彻底搞定谱聚类 - PJQOOO</title>
<link>http://www.cnblogs.com/PJQOOO/p/11830838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PJQOOO/p/11830838.html</guid>
<description>&lt;p&gt;&lt;span&gt;上文我们引入了是聚类，并介绍了第一种聚类算法K-means。今天，我们来介绍一种流行的聚类算法——谱聚类（Spectral Clustering），它的实现简单，而且效果往往好于传统的聚类算法，如k-means，但是其背后的原理涉及了很多重要而复杂的知识，如图论，矩阵分析等。别担心，今天小编就带你一举攻克这些难关，拿下谱聚类算法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Q：什么是谱聚类？&lt;/p&gt;
&lt;p&gt;A：&lt;span&gt;谱聚类是最流行的聚类算法之一，它的实现简单，而且效果往往胜过传统的聚类算法，如K-means。它的主要思想是把所有数据看作空间中的点，这些点之间用带权重的边相连，距离较远的点之间的边权重较低，距离较近的点之间边权重较高，通过对所有数据点和边组成的图进行切图，让切图后不同子图间边权重和尽可能低，而子图内边权重和尽可能高来达到聚类的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们先介绍图的基础知识以及图拉普拉斯，然后引入谱聚类算法，最后从图分割的角度来解释谱聚类算法。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;图的概念&lt;/h2&gt;
&lt;p&gt;    &lt;span&gt;对于一个图&lt;strong&gt;G&lt;/strong&gt;，我们通常用&lt;strong&gt;G(V，E)&lt;/strong&gt;来表示它，其中V代表数据集合中的点{v1,v2,...vn}，E代表边集（可以有边相连，也可以没有）。在接下来的内容中我们用到的都是带权重图（即两个顶点vi和vj之间的连边带有非负权重wij&amp;gt;0）.由此可以得到一个图的&lt;strong&gt;加权邻接矩阵W&lt;/strong&gt;=（Wij）i,j=1,...n。如果Wij=0代表两个顶点之间无边相连。无向图G中wij=wji，所以权重矩阵是对称的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    对于图中的任意一个点vi，定义它的度为与它相连的所有边的权重之和，即&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/bZaD6Uhf_Et5j.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;。&lt;strong&gt;度矩阵&lt;/strong&gt;就是对角元素分别为每个点的度，非对角元素为0的矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    给定点的一个子集A属于V，定义A的补集为&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/BFjrtdYs_DwW9.png&quot; alt=&quot;image.png&quot; width=&quot;35&quot; height=&quot;42&quot; data-ratio=&quot;1&quot;/&gt;A的指示向量为&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/VQz5FKPW_gKQa.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;如果fi=1，则顶点vi在子集A中，否则为0。为了方便，在下文中，我们使用&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/T383HCqg_gJ2E.png&quot; alt=&quot;image.png&quot; width=&quot;51&quot; height=&quot;25&quot; data-ratio=&quot;1&quot;/&gt;来表示顶点i在集合A中。对于两个不相交子集A，B属于V，我们定义&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/jIMuZfBF_nWm3.png&quot; alt=&quot;image.png&quot; width=&quot;96&quot; height=&quot;27&quot; data-ratio=&quot;1&quot;/&gt;表示两个子集之间的权重和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    有两种度量V中子集A大小的方法：|A|表示A中顶点的个数，vol（A）表示A中顶点的度的和。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;相似图&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;思考我们构建相似性图的目的是什么？是为了对点之间的局部邻域关系建模。那么根据我们所关注的邻域关系，相似性图的定义也可以不同，以下提到的图都经常在谱聚类中使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ε邻域图&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：将所有距离小于ε的点相连，由于有边相连的点之间都差不多，加权边不会包含关于图中数据点更多的关系，因此，这种图常常是无权重的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;k近邻图&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：将vi与它前k近的顶点相连，要注意，这种定义的图是有向图，因为k近邻关系并不是对称的（A是B的k近邻，而B不一定是A的k近邻）。我们可以通过两种方式将它变成无向图：一种是只要A是B的k近邻，AB之间就会连一条边；另一种是必须同时满足A，B是彼此的k近邻，才能在AB之间连一条边。在构建好图之后，在根据点的相似性给边赋权重；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;全连接图&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：任意两点之间都连一条边，并根据两点之间的相似性给边赋权重。由于图必须能代表局部邻居关系，所以使用的相似性度量方法必须能对这种关系建模。比如，高斯相似性方程&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/9ZnyUaeN_FfBy.png&quot; alt=&quot;image.png&quot; width=&quot;127&quot; height=&quot;15&quot; data-ratio=&quot;1&quot;/&gt;，其中参数σ控制邻域的宽度（作用类似ε邻域图中的ε参数）。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;图拉普拉斯矩阵及其基本性质&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图拉普拉斯矩阵&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是谱聚类的主要工具，对这些矩阵的研究有一个专门的领域，叫做谱图理论，感兴趣的同学可以去了解下。在这章中我们定义不同的图拉普拉斯并介绍它们最重要的性质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在接下来的介绍中，我们定义的图&lt;strong&gt;G&lt;/strong&gt;是无向的，带权重的（权重矩阵为&lt;strong&gt;W&lt;/strong&gt;），我们假定所有特征向量都是标准化的（如常向量C和aC是一样的），特征值是有序且可重复的，如果提到了前k个特征向量，就意味着这k个特征向量对应k个最小的特征值。D代表上文提到的度矩阵，W代表权重矩阵。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;非规范化图拉普拉斯矩阵：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非规范化图拉普拉斯矩阵定义为&lt;span&gt;&lt;strong&gt;L：D-W&lt;/strong&gt;&lt;/span&gt;，它具有如下重要特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 对于任意特征向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/3EyzKVc8_IXWe.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，有：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/GYP97QeR_gFXY.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/NmHhhSIy_9tGA.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. L是对称半正定的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;证明：D，W都是对称的，且特性1的证明表明L是半正定的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. L的最小特征值是0，对应的特征向量是单位向量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. L有n个非负的实值特征向量&lt;/span&gt;：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/4e7NZ7cP_BOU2.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;证明：由前三个特性可以直接得出；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意非规范化图拉普拉斯矩阵以及它的特征向量，特征值可以被用在描述图的很多特性，其中在谱聚类中的一个重要性质如下：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;连通分量数与L的普&lt;span&gt;：G是一个非负权重无向图，那么L的特征值0的重数k就等于图中联通分量A1，...Ak的个数，特征值0的特征空间由这些联通分量的指示向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/ss2JXIse_3TGr.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;表示；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;证明：以k=1为例，代表这是一个连通图，假设特征值0对应的特征向量为f，则&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/vGJu2src_UWAN.png&quot; alt=&quot;image.png&quot; width=&quot;127&quot; height=&quot;31&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，由于权重w是非负的，要使和为0当且仅当每一项都为0。因此，如果两个顶点vi和vj有边相连（wij&amp;gt;0），fi必须等于fj，从这里可以看出如果图中的顶点可以有一条路径相连，那么f必须是常向量。此外，由于无向图中连通分量的所有顶点都可以通过一条路径相连，所以f在整个连通分量上必须是常数。因此在只有一个连通分量的图中，只有一个常向量作为0的特征向量（作为唯一一个联通部分的指示向量）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在考虑k大于1的场景，不失一般性，我们假设顶点是按照它们所属的连通分量排序的，在这种情形下，邻接权重矩阵W可以写成分块对角矩阵的形式，同样，L可以写作&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/xDSC2Ody_LBWK.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，每一个块Li 也是一个图拉普拉斯矩阵，分别对应图的第i个连通分量，L的普就由Li的普组合而成，而且L对应的特征向量就是Li的特征向量。由于Li一个连通图的图拉普拉斯矩阵，而每一个Li有重数为1的特征值0，也就是对应第i个联通子图的常向量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;规范化图拉普拉斯矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规范化图拉普拉斯矩阵有如下两种定义：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/ssm67cEn_bkZ2.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先来介绍它们的性质：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 对任意特征向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/3K9JXDDs_7UaZ.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，我们有：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/TVhywR4M_wJae.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. λ是Lrw的特征向量u的特征值 当且仅当 λ是Lsym的特征向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/qzTfCPGW_vmMI.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;的特征值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. λ是Lrw的特征向量u的特征值当且仅当λ和u满足Lu=λDu；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 0是Lrw的常数特征向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/7nEdZYsP_cDGR.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;的特征值，那么0也是Lsym的特征向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/rcMBjxAH_Y7zc.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;的特征值。；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. Lsym和Lrw是半正定的且有n个非负的实特征值；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    与非规范化图拉普拉斯矩阵相同，Lsym和Lrw的0特征值的重数k就等于图中联通分量的个数，证明与上面类似，不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;谱聚类算法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;现在我们来介绍最常见的谱聚类算法。&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/f38BQm2w_Gupb.png&quot; alt=&quot;image.png&quot; width=&quot;350&quot; height=&quot;121&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：首先构建相似性图，并用W表示权重邻接矩阵，构建度矩阵D，求出拉普拉斯矩阵L；计算L的前m个特征向量，以这m个特征向量作为列组成n*m的矩阵U，其中每一行作为一个m维的样本，共n个，对这n个行向量进行kmeans聚类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于规范化的谱聚类有两种不同的版本，依赖于两种标准化图拉普拉斯矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/VEbIXrLA_2usk.png&quot; alt=&quot;image.png&quot; width=&quot;349&quot; height=&quot;112&quot; data-ratio=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意这里使用的是generalized eigenvectors（广义特征向量），即矩阵Lrw对应的特征向量，所以这一算法针对的是标准化的拉普拉斯矩阵Lrw。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    下一个算法也是标准化的谱聚类，不过用的是Lsym，该算法介绍了一种额外的行标准化步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/ta7Y5w7B_2tJW.png&quot; alt=&quot;image.png&quot; width=&quot;359&quot; height=&quot;146&quot; data-ratio=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面三种算法的步骤其实都差不多，只不过是使用的拉普拉斯矩阵有差别。在算法中，主要的工作就是将x抽象表征为k维的数据点（降维），接下来我们将揭晓为什么这样做能提高聚类的效果。我们将从图分割的角度来介绍谱聚类的工作原理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;图切分的观点&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    聚类算法的思想就是根据数据点之间的&lt;strong&gt;相似性&lt;/strong&gt;将它们&lt;strong&gt;划分&lt;/strong&gt;到不同组。当我们的数据以&lt;strong&gt;相似性图&lt;/strong&gt;的形式给出时，聚类问题又可以这样解释：我们想要找到图的一种划分，不同组点的边之间有很低的权重而同一个组中点之间的边有较高的权重。在本节中，我们将介绍如何将谱聚类问题近似于图的划分问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定一个相似性图，邻接权重矩阵W，最简单直接的方法来创建一个图的分割就是解决最小割问题。前面我们已经提到过&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/C3eOK5Ac_LhgH.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;和A的补集的概念。给定子集个数k，最小割方法就是选择一种划分A1,...,Ak使得&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/g6GE4Cvq_4ykk.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;最小。特别是对k=2，最小割问题相对是一个简单的问题，可以被有效地解决。然而在实际中，最小割的解并不能很好地将图划分，因为它只是简单地将一个独立的点从剩余的图中划分出来，这显然不符合聚类的需求。解决这种问题的一种方法是必须保证子集A1,...,Ak足够大，实现这一限制的最常见的目标函数有两种：RatioCut和Ncut。RatioCut用子集A中点的个数表示A的大小，Ncut用子集A中边的权重和来度量A的大小，它们的定义分别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/J5cLkcUI_enZO.png&quot; alt=&quot;image.png&quot; width=&quot;294&quot; height=&quot;68&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如簇Ai不是特别小，两个目标函数的值都会有较小的值，因此这两种函数都试图达到聚类的平衡，但是，引入这一“平衡”条件使得之前简单的最小割问题变成了np难问题。谱聚类就是解决这一问题的一种松弛版本，我们将看到松弛Ncut将会导致规范化谱聚类，而松弛RatioCut将导致非标准化谱聚类。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;从RatioCut切图的角度解释谱聚类算法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们先讨论k=2的情形，我们的目标函数是&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/rBUBJFjs_vCkV.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，首先重写这个问题。给定子集&lt;span&gt;A&lt;/span&gt;，我们定义向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/GHIB8YuL_DcsJ.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/KLKUpPwD_uRg8.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;现在RatioCut目标函数可以写作非规范化图拉普拉斯矩阵的形式：&lt;br/&gt; &lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/Kp5aBLCa_6sOQ.png&quot; alt=&quot;image.png&quot; width=&quot;353&quot; height=&quot;150&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/MITF4Tgh_hTvC.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，由于f满足&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/6J8Qgg2N_vA77.png&quot; alt=&quot;image.png&quot; width=&quot;329&quot; height=&quot;36&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，优化问题重写为&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/DsMrM4bt_EXCp.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/MEMyrqdW_hTmC.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个离散优化问题因为仅允许解向量f中的每一个值只能是两个特殊值，仍是Np难问题。最常用的松弛就是将离散条件改为fi可以取任意实数，松弛后的目标函数为&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/kheb4gFI_ICZ4.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据Rayleigh-Ritz理论，问题的解f为拉普拉斯矩阵L的第二小的特征值所对应的特征向量（最小的特征值为0，对应常向量）。所以我们可以通过求L的第二特征向量来解决RatioCut问题。然而我们得到的f是实值向量，要把它转化为离散的指示向量，最简单的方式就是使用sign，&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/JPfcVuFP_qCtC.png&quot; alt=&quot;image.png&quot; width=&quot;125&quot; height=&quot;35&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推广到k&amp;gt;2的场景，将V划分成k个子集A1,...Ak，我们定义k个指示向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/vbcDZc5s_aSVI.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，其中&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/anKfywA4_yKng.png&quot; alt=&quot;image.png&quot; width=&quot;342&quot; height=&quot;32&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;代表每个点的划分情况。定义矩阵&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/Hju7uwU4_DvwU.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;作为以k个指示向量为列向量的矩阵，显然H中的列相互正交&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/5nq9NYxP_WHp2.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，于上面的计算类似，我们可以得到&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/ntFORQZC_9KMa.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，进而&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/YWEYNJjU_D9tD.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，然后得到RatioCut问题的定义：&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/uHDCPTAc_KLBP.png&quot; alt=&quot;image.png&quot; width=&quot;369&quot; height=&quot;30&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tr表示矩阵的迹，所以最小化RatioCut问题可以写作&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/O9ynsmIj_pjey.png&quot; alt=&quot;image.png&quot; width=&quot;296&quot; height=&quot;34&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，我们运行H中的取值为任意实数，松弛后的问题为：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/wUyAsmqY_smu6.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是迹极小化问题的标准形式，同样根据Rayleigh-Ritz理论，问题的解就是选择包含L的前k个特征向量作为列而组成的H矩阵。其实矩阵H就是上面非标准化谱聚类算法中提到的矩阵U。然后将实值矩阵转化成离散的形式。最后用kmeans对U的每一行进行聚类。&lt;/span&gt;&lt;/p&gt;

&lt;h3 align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;从NCut的角度解释谱聚类算法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 与在RatioCut中用到的相似的技术同样可以用到规范化谱聚类作为最小化Ncut的松弛。当k=2时我们定义聚类的指示向量f中的每个元素为&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/4hB8VRaa_whrK.png&quot; alt=&quot;image.png&quot; width=&quot;189&quot; height=&quot;52&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和上面类似我们可以检查&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/qxhmy9cC_KkNN.png&quot; alt=&quot;image.png&quot; width=&quot;54&quot; height=&quot;13&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/gaF3FCr5_YwUF.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，以及&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/zH3bOnhx_u6E9.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;因此，可以重写最小化Ncut问题为&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/cdHbsSYf_UCEr.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后对问题进行松弛：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/mGZP6Gw6_mJsa.png&quot; alt=&quot;image.png&quot; width=&quot;343&quot; height=&quot;34&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/MtMIZrL5_q5kA.png&quot; alt=&quot;image.png&quot; width=&quot;79&quot; height=&quot;20&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/JTCkjjuY_b9ah.png&quot; alt=&quot;image.png&quot; width=&quot;380&quot; height=&quot;30&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/aqMC7W7F_dgrz.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/UKN33WhF_2QKx.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;是Lsym的第一特征向量，vol(V)是常数。因此，上述目标函数符合Rayleigh-Ritz理论，最优解g就是Lrw的第二特征向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推广到k&amp;gt;2的场景，我们定义指示向量&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/QD7A2dez_Z2gw.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，且&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/6Vx3T6Mc_x5X5.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义H为包含k个指示向量（作为列）的矩阵。显然&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/geFmFngS_AXBA.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/HyTrudhY_DtxN.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么最小化Ncut问题可以写作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/EMOPTVwJ_7Hfn.png&quot; alt=&quot;image.png&quot; width=&quot;310&quot; height=&quot;28&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;，松弛后为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/OcxWazr6_DgQK.png&quot; alt=&quot;image.png&quot; width=&quot;313&quot; height=&quot;29&quot; data-ratio=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这又是一个标准的迹最小化问题，问题的解T是包含Lsym的前k个特征向量为列向量的矩阵。再将&lt;/span&gt;&lt;img src=&quot;https://image.135editor.com/files/users/720/7208581/201911/XrJKqZ7p_QxtO.png&quot; alt=&quot;image.png&quot; data-ratio=&quot;1&quot;/&gt;&lt;span&gt;代入，可以发现H包含矩阵Lrw的前k个特征向量。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;谱聚类算法总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;谱聚类的优点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 对于处理稀疏数据的聚类效果很有效；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 使用了降维，在处理高维数据聚类时比传统聚类好；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 当聚类的类别个数较小的时候，谱聚类的效果会很好；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 谱聚类算法建立在谱图理论上，与传统的聚类算法相比，具有能在任意形状的样本空间上聚类且收敛于全局最优解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;谱聚类的缺点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 谱聚类对相似图和聚类参数的选择非常敏感；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 谱聚类适用于均衡分类问题，即簇之间点的个数差别不大，对于簇之间点的个数相差悬殊的问题不适用。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;img class=&quot;assistant&quot; src=&quot;https://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9naWYvN1FSVHZrSzJxQzZtcHQ3SmJCb0NkSWJrZjRJZVVVc2pUTHBpY0pGbmo1WnZUTHYydGM5SFcwNk9kTmljZ2RaOVY5MEdHVW9ub2s4bmliU2lhZ3JUWlVpY2JpYWcvMD93eF9mbXQ9Z2lm&quot; alt=&quot;&quot; height=&quot;102&quot; data-ratio=&quot;0.275&quot; data-width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫码关注&lt;/p&gt;
&lt;p&gt;获取有趣的算法知识&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;qrcode_for_gh_32a933b66b99_258.jpg&quot; src=&quot;https://image.135editor.com/files/users/720/7208581/201911/D96dShcj_IZqC.jpg&quot; alt=&quot;qrcode_for_gh_32a933b66b99_258.jpg&quot; height=&quot;402&quot; data-ratio=&quot;1&quot; data-width=&quot;100%&quot; data-op=&quot;change&quot;/&gt;&lt;img class=&quot;assistant&quot; src=&quot;https://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9naWYvN1FSVHZrSzJxQzZtcHQ3SmJCb0NkSWJrZjRJZVVVc2pHckJNQWxIaWNPMjltYW5Ba2lieXdZdDVzWVZ0ZDdRb0ppYWljckhTZmVJSkNjSVFpYjRQSnVvWXQ5Zy8wP3d4X2ZtdD1naWY=&quot; alt=&quot;&quot; height=&quot;108&quot; data-ratio=&quot;0.275&quot; data-width=&quot;100%&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 12 Nov 2019 00:52:00 +0000</pubDate>
<dc:creator>PJQOOO</dc:creator>
<og:description>Clustering 聚类 谱聚类 上文我们引入了是聚类，并介绍了第一种聚类算法K-means。今天，我们来介绍一种流行的聚类算法——谱聚类（Spectral Clustering），它的实现简单，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PJQOOO/p/11830838.html</dc:identifier>
</item>
<item>
<title>小白学 Python（19）：基础异常处理 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11839613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11839613.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191112084436105-139334302.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/25/1277177083/&quot;&gt;小白学 Python（10）：基础数据结构（列表）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/26/1783681326/&quot;&gt;小白学 Python（11）：基础数据结构（元组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/1304658395/&quot;&gt;小白学 Python（12）：基础数据结构（字典）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/2327215405/&quot;&gt;小白学 Python（13）：基础数据结构（字典）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/29/2327215406/&quot;&gt;小白学 Python（14）：基础数据结构（集合）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/30/3105860436/&quot;&gt;小白学 Python（15）：基础数据结构（集合）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/31/3818474124/&quot;&gt;小白学 Python（16）：基础数据类型（函数）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/619492986/&quot;&gt;小白学 Python（17）：基础数据类型（函数）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/3195979051/&quot;&gt;小白学 Python（18）：基础文件操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面我们已经写了这么多示例代码了，对于报错信息各位同学可能都已经司空见惯了，今天我们就来聊一下报错信息的处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191112084436424-1726711684.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，程序在运行的过程中，产生了异常，这时，我们可能会有两种想法，第一种是针对这个异常做某些特殊的处理来进行程序的降级处理；第二种是希望程序忽略这个异常继续执行下去，这个异常可能并不干扰主逻辑的执行。&lt;/p&gt;
&lt;p&gt;那这个时候我们怎么办呢？&lt;/p&gt;
&lt;p&gt;有编程经验的同学马上就想到了，那我们去 try 它啊，在 Python 中，我们同样可以去 try 它，从字面意思上理解就已经非常清晰明确了，以下的内容是要尝试执行的。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    ...(可能产生异常的代码)
except:
    ...(产生异常后的处理代码)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，还会有一种情况，不管上面的代码有没有出错，有一部分代码我们总希望它能执行，这时，我们可以添加另一个关键字 &lt;code&gt;finally&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从字面意思可以就可以看出来，这个是最后要执行的意思。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    ...(可能产生异常的代码)
except:
    ...(产生异常后的处理代码)
finally:
    ...(一定要执行的代码)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面开始我们今天的代码演示。&lt;/p&gt;
&lt;p&gt;我们先拟定一个场景，我们定义一个除法函数，如果除数不为 0 ，是可以正常返回值的，如果除数为 0 ，那么整个程序肯定会直接异常报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def division(x, y):
    try:
        return x / y
    except:
        print('程序报错啦！！！')
        return None

print(division(15, 5))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时程序是可以正常输出的，这时我们修改一下调用的参数，改为 &lt;code&gt;division(15, 0)&lt;/code&gt; ，看下输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;程序报错啦！！！
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里打印了我在程序中设置的 &lt;code&gt;None&lt;/code&gt; ，并没有之前的红色的异常信息抛出。这里的 &lt;code&gt;except&lt;/code&gt; 会捕捉我们所有的异常信息，但是，异常信息也是有很多分类的，比如我们之前遇到过的访问字典中不存在的 key 的异常 &lt;code&gt;KeyError&lt;/code&gt; ，比如我们刚才捕捉到的 &lt;code&gt;ZeroDivisionError&lt;/code&gt; 异常，还有也是我们之前遇到过的数组下标越界的异常 &lt;code&gt;IndexError&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;比如这里的代码我可以捕捉更加详细的异常信息 &lt;code&gt;ZeroDivisionError&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def division1(x, y):
    try:
        return x / y
    except ZeroDivisionError:
        print('程序报错啦！！！')
        return None

print(division1(15, 0))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;程序报错啦！！！
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，看到这里，你可能会有一个疑问，我们为什么要对异常分类，直接抓取所有异常不是更方便么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191112084436669-315633588.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，对于逻辑比较简单的程序，直接捕捉所有异常是更方便的，但是在某些特定的业务场景下，一段程序可能会抛出多种异常，我们希望根据异常种类的不同，定制不同的解决方案，至少我们知道当前的程序是抛出了什么异常，这时，程序异常分类就显得尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191112084438009-404288401.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这里演示一下，如果我们输出的值不是数字，是字符串的话。。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def division2(x, y):
    try:
        return x / y
    except ZeroDivisionError:
        print('您输出的除数为 0 ！！！')
        return None
    except TypeError:
        print('您输出的参数类型非法！！！')
        return None

print(division2('python', 0))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;您输出的参数类型非法！！！
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对的，你没有看错，异常信息是能捕捉多个的，是可以并排写的。至于先抛出那个，就要看那个异常先发生了。&lt;/p&gt;
&lt;p&gt;因为示例代码的逻辑过于简单，异常抛出顺序无法演示，请各位同学见谅（li zhi qi zhuang）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191112084438269-1779075598.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面我们还提到了 &lt;code&gt;finally&lt;/code&gt; ，我们接着来演示 &lt;code&gt;finally&lt;/code&gt; 这个关键字的使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def division3(x, y):
    try:
        return x / y
    except ZeroDivisionError:
        print('您输出的除数为 0 ！！！')
        return None
    except TypeError:
        print('您输出的参数类型非法！！！')
        return None
    finally:
        print('你一定能看到我！！！')

print(division3(15, 3))
print(division3('python', 0))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里我使用有异常和正常无任何问题的数据进行测试，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;你一定能看到我！！！
5.0
您输出的参数类型非法！！！
你一定能看到我！！！
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确实， &lt;code&gt;finally&lt;/code&gt; 中的内容是能正常打印的，这里多提一句，这里经常的使用方式是来关闭一些 I/O 读写操作或者一些外部连接，如数据库、缓存服务等。&lt;/p&gt;
&lt;p&gt;今天的内容就到这里，各位同学请回去自行尝试。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-except&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/base-except&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11839613.html</dc:identifier>
</item>
<item>
<title>动画 | 大学四年结束之前必须透彻的排序算法 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11839611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11839611.html</guid>
<description>&lt;p&gt;现如今大学生学习排序算法，除了学习它的算法原理、代码实现之外，作为一个大学生更重要的往往是要学会如何评价、分析一个排序算法。排序对于任何一个程序员来说，可能都不会陌生。大部分编程语言中，也都提供了排序函数。在平常的项目中，我们也经常会用到排序。排序非常重要！本章主要从如何分析一个算法开始入手，从而循进渐进的分析那些大学四年结束之前必须掌握的排序算法！&lt;br/&gt;@&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当然你可以先思考一两分钟，带着这个问题，我们开始如下的内容！&lt;span&gt;&lt;strong&gt;并且注意我标红的字体，往往是起眼或者不起眼的重点&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何分析一个排序算法&quot;&gt;如何分析一个“排序算法”？&lt;/h2&gt;
&lt;h6 id=&quot;排序算法的执行效率&quot;&gt;1、排序算法的&lt;span&gt;执行效率&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;对于排序算法执行效率的分析，我们一般会从这三个方面来衡量：&lt;/p&gt;
&lt;h6 id=&quot;最好最坏平均时间复杂度&quot;&gt;1.1.最好、最坏、平均时间复杂度&lt;/h6&gt;
&lt;p&gt;我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。&lt;/p&gt;
&lt;p&gt;为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。&lt;/p&gt;
&lt;h6 id=&quot;时间复杂度的系数常数-低阶&quot;&gt;1.2.时间复杂度的系数、常数 、低阶&lt;/h6&gt;
&lt;p&gt;我们知道，时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。&lt;/p&gt;
&lt;h6 id=&quot;比较次数和交换或移动次数&quot;&gt;1.3.比较次数和交换（或移动）次数&lt;/h6&gt;
&lt;p&gt;这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。&lt;/p&gt;
&lt;h6 id=&quot;排序算法的内存消耗&quot;&gt;2、排序算法的&lt;span&gt;内存消耗&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，&lt;strong&gt;原地排序&lt;/strong&gt;（Sorted in place）。原地排序算法，&lt;strong&gt;就是特指空间复杂度是O(1)的排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;h6 id=&quot;排序算法的稳定性&quot;&gt;3、排序算法的&lt;span&gt;稳定性&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;稳定性千万不要忽略，仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。&lt;/p&gt;
&lt;p&gt;我通过一个例子来解释一下。比如我们有一组数据2，9，3，4，8，3，按照大小排序之后就是2，3，3，4，8，9。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7bcb51c39?w=993&amp;amp;h=496&amp;amp;f=png&amp;amp;s=56722&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这组数据里有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作&lt;strong&gt;稳定的排序算法&lt;/strong&gt;；如果前后顺序发生变化，那对应的排序算法就叫作&lt;strong&gt;不稳定的排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可能要问了，两个3哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？&lt;/p&gt;
&lt;p&gt;很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个key来排序。&lt;/p&gt;
&lt;p&gt;比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有10万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？&lt;/p&gt;
&lt;p&gt;最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。&lt;/p&gt;
&lt;p&gt;借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变&lt;/span&gt;。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7bcf8958d?w=982&amp;amp;h=619&amp;amp;f=png&amp;amp;s=123413&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，分析一个“排序算法”就结束了，你get到了吗？接下来，我们进入实战算法分析。&lt;/p&gt;
&lt;h2 id=&quot;开始分析冒泡排序算法&quot;&gt;开始分析冒泡“排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;冒泡排序描述&quot;&gt;1.冒泡排序描述&lt;/h6&gt;
&lt;p&gt;冒泡排序描述：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。&lt;/p&gt;
&lt;h6 id=&quot;图解冒泡排序&quot;&gt;2.图解冒泡排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7bdf2555b?w=600&amp;amp;h=187&amp;amp;f=gif&amp;amp;s=296806&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;如果还是不能一眼看出其灵魂，没事，我还有一招：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7bdd6ced7?w=500&amp;amp;h=300&amp;amp;f=gif&amp;amp;s=240908&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;怎么样，够不够直观，就是有点慢，哈哈~&lt;/p&gt;
&lt;h6 id=&quot;代码实现冒泡排序&quot;&gt;3.代码实现冒泡排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package BubbleSort;
import java.util.Arrays;

public class generalBubble {
   public static void main(String[] args) {
        int[] arr=new int[] {5,7,2,9,4,1,0,5,8,7};
        System.out.println(Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    //冒泡排序
    public static void bubbleSort(int[]  arr) {
        //控制共比较多少轮
        for(int i=0;i&amp;lt;arr.length-1;i++) {
            //控制比较的次数
            for(int j=0;j&amp;lt;arr.length-1-i;j++) {
                if(arr[j]&amp;gt;arr[j+1]) {
                    int temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7be1da3f8?w=1920&amp;amp;h=254&amp;amp;f=png&amp;amp;s=55657&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码优化冒泡排序&quot;&gt;4.代码优化冒泡排序&lt;/h6&gt;
&lt;p&gt;实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给6个元素排序，只需要4次冒泡操作就可以了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n &amp;lt;= 1) return;
 
 for (int i = 0; i &amp;lt; n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j &amp;lt; n - i - 1; ++j) {
      if (a[j] &amp;gt; a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，结合刚才我分析排序算法的三个方面，开始分析冒泡排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第一冒泡排序是原地排序算法吗&quot;&gt;第一：冒泡排序是原地排序算法吗？&lt;/h6&gt;
&lt;p&gt;首先，原地排序算法就是特指空间复杂度是O(1)的排序算法，我在上文提及过的，再提一遍（我猜你们肯定没仔细看文章。。。）&lt;/p&gt;
&lt;p&gt;冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第二冒泡排序是稳定的排序算法吗&quot;&gt;第二：冒泡排序是稳定的排序算法吗？&lt;/h6&gt;
&lt;p&gt;在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第三冒泡排序的时间复杂度是多少&quot;&gt;第三：冒泡排序的时间复杂度是多少？&lt;/h6&gt;
&lt;p&gt;最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行n次冒泡操作，所以最坏情况时间复杂度为O(n2)，平均情况下的时间复杂度就是O(n2)。&lt;/p&gt;
&lt;h2 id=&quot;开始分析插入排序算法&quot;&gt;开始分析“插入排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;插入排序描述&quot;&gt;1.插入排序描述&lt;/h6&gt;
&lt;p&gt;插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p&gt;
&lt;h6 id=&quot;图解插入排序&quot;&gt;2.图解插入排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7be2b9723?w=683&amp;amp;h=565&amp;amp;f=gif&amp;amp;s=368676&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;同样，我也准备了数字版的，是不是很贴心？&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7c55a3710?w=500&amp;amp;h=300&amp;amp;f=gif&amp;amp;s=229109&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现插入排序&quot;&gt;3.代码实现插入排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class InsertSort {
    
    public static void main(String[] args) {
        int[] arr = new int[] {5,3,2,8,5,9,1,0};
        insertSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    //插入排序
    public static void insertSort(int[] arr) {
        //遍历所有的数字
        for(int i=1;i&amp;lt;arr.length;i++) {
            //如果当前数字比前一个数字小
            if(arr[i]&amp;lt;arr[i-1]) {
                //把当前遍历数字存起来
                int temp=arr[i];
                int j;
                //遍历当前数字前面所有的数字
                for(j=i-1;j&amp;gt;=0&amp;amp;&amp;amp;temp&amp;lt;arr[j];j--) {
                    //把前一个数字赋给后一个数字
                    arr[j+1]=arr[j];
                }
                //把临时变量（外层for循环的当前元素）赋给不满足条件的后一个元素
                arr[j+1]=temp;
            }
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，结合刚才我分析排序算法的三个方面，开始分析插入排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第一插入排序是原地排序算法吗&quot;&gt;第一：插入排序是原地排序算法吗？&lt;/h6&gt;
&lt;p&gt;从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第二插入排序是稳定的排序算法吗&quot;&gt;第二：插入排序是稳定的排序算法吗？&lt;/h6&gt;
&lt;p&gt;在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。&lt;/p&gt;
&lt;h6 id=&quot;第三插入排序的时间复杂度是多少&quot;&gt;第三：插入排序的时间复杂度是多少？&lt;/h6&gt;
&lt;p&gt;如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是从尾到头遍历已经有序的数据。&lt;/p&gt;
&lt;p&gt;如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为O(n2)。&lt;/p&gt;
&lt;p&gt;还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n2)。&lt;/p&gt;
&lt;h2 id=&quot;开始分析选择排序算法&quot;&gt;开始分析“选择排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;选择排序描述&quot;&gt;1.选择排序描述&lt;/h6&gt;
&lt;p&gt;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。&lt;/p&gt;
&lt;h6 id=&quot;图解选择排序&quot;&gt;2.图解选择排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7c57c726a?w=640&amp;amp;h=195&amp;amp;f=gif&amp;amp;s=452539&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现选择排序&quot;&gt;3.代码实现选择排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SelectSort {

    public static void main(String[] args) {
        int[] arr = new int[] {3,4,5,7,1,2,0,3,6,8};
        selectSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    //选择排序
    public static void selectSort(int[] arr) {
        //遍历所有的数
        for(int i=0;i&amp;lt;arr.length;i++) {
            int minIndex=i;
            //把当前遍历的数和后面所有的数依次进行比较，并记录下最小的数的下标
            for(int j=i+1;j&amp;lt;arr.length;j++) {
                //如果后面比较的数比记录的最小的数小。
                if(arr[minIndex]&amp;gt;arr[j]) {
                    //记录下最小的那个数的下标
                    minIndex=j;
                }
            }
            //如果最小的数和当前遍历数的下标不一致,说明下标为minIndex的数比当前遍历的数更小。
            if(i!=minIndex) {
                int temp=arr[i];
                arr[i]=arr[minIndex];
                arr[minIndex]=temp;
            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析选择排序算法&quot;&gt;4.分析选择排序算法&lt;/h6&gt;
&lt;p&gt;选择排序算法是一种原地、不稳定的排序算法，最好时间复杂度情况：T(n) = O(n2) 最差时间复杂度情况：T(n) = O(n2) 平均时间复杂度情况：T(n) = O(n2)&lt;/p&gt;
&lt;h2 id=&quot;开始分析希尔排序算法&quot;&gt;开始分析“希尔排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;希尔排序描述&quot;&gt;1.希尔排序描述&lt;/h6&gt;
&lt;p&gt;希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。&lt;br/&gt;&lt;strong&gt;希尔排序常规步骤：&lt;/strong&gt;&lt;br/&gt;1、选择增量gap=length/2&lt;br/&gt;2、缩小增量继续以gap = gap/2的方式，n/2,(n/2)/2...1 ，有点晕了对吧，还是看图解吧哈哈~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7be26f7b2?w=665&amp;amp;h=290&amp;amp;f=gif&amp;amp;s=1102998&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;同样是二图（捂脸）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7c4c3640b?w=962&amp;amp;h=558&amp;amp;f=gif&amp;amp;s=536127&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现希尔排序&quot;&gt;3.代码实现希尔排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ShellSort {

    public static void main(String[] args) {
        int[] arr = new int[] { 3, 5, 2, 7, 8, 1, 2, 0, 4, 7, 4, 3, 8 };
        System.out.println(Arrays.toString(arr));
        shellSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    public static void shellSort(int[] arr) {
        int k = 1;
        // 遍历所有的步长
        for (int d = arr.length / 2; d &amp;gt; 0; d /= 2) {
            // 遍历所有有元素
            for (int i = d; i &amp;lt; arr.length; i++) {
                // 遍历本组中所有的元素
                for (int j = i - d; j &amp;gt;= 0; j -= d) {
                    // 如果当前元素大于加上步长后的那个元素
                    if (arr[j] &amp;gt; arr[j + d]) {
                        int temp = arr[j];
                        arr[j] = arr[j + d];
                        arr[j + d] = temp;
                    }
                }
            }
            System.out.println(&quot;第&quot; + k + &quot;次排序结果：&quot; + Arrays.toString(arr));
            k++;
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析希尔排序算法&quot;&gt;4.分析希尔排序算法&lt;/h6&gt;
&lt;p&gt;希尔排序算法是一种原地、不稳定的排序算法，最好时间复杂度情况：T(n) = O(nlog2 n) 最差时间复杂度情况：T(n) = O(nlog2 n) 平均时间复杂度情况：T(n) =O(nlog2n)　&lt;/p&gt;
&lt;h2 id=&quot;开始分析快速排序算法&quot;&gt;开始分析“快速排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;快速排序描述&quot;&gt;1.快速排序描述&lt;/h6&gt;
&lt;p&gt;我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。&lt;br/&gt;&lt;strong&gt;快速排序常规步骤：&lt;/strong&gt;&lt;br/&gt;1、从数列中挑出一个元素，称为 “&lt;span&gt;&lt;strong&gt;基准&lt;/strong&gt;&lt;/span&gt;”（pivot），一般第一个基数取第一个数；&lt;br/&gt;2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;br/&gt;3、&lt;span&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/span&gt;地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/p&gt;
&lt;h6 id=&quot;图解快速排序&quot;&gt;2.图解快速排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7c4e7ff48?w=310&amp;amp;h=566&amp;amp;f=gif&amp;amp;s=191782&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;貌似上图太过于抽象，还是看下图吧，哈哈~&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7c561e51f?w=665&amp;amp;h=290&amp;amp;f=gif&amp;amp;s=2190337&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现快速排序&quot;&gt;3.代码实现快速排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QuickSort {

    public static void main(String[] args) {
        int[] arr = new int[] {3,4,6,7,2,7,2,8,0,9,1};
        quickSort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
    
    public static void quickSort(int[] arr,int start,int end) {
        if(start&amp;lt;end) {
            //把数组中的第0个数字做为标准数
            int stard=arr[start];
            //记录需要排序的下标
            int low=start;
            int high=end;
            //循环找比标准数大的数和比标准数小的数
            while(low&amp;lt;high) {
                //右边的数字比标准数大
                while(low&amp;lt;high&amp;amp;&amp;amp;stard&amp;lt;=arr[high]) {
                    high--;
                }
                //使用右边的数字替换左边的数
                arr[low]=arr[high];
                //如果左边的数字比标准数小
                while(low&amp;lt;high&amp;amp;&amp;amp;arr[low]&amp;lt;=stard) {
                    low++;
                }
                arr[high]=arr[low];
            }
            //把标准数赋给低所在的位置的元素
            arr[low]=stard;
            //处理所有的小的数字
            quickSort(arr, start, low);
            //处理所有的大的数字
            quickSort(arr, low+1, end);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析快速排序算法&quot;&gt;4.分析快速排序算法&lt;/h6&gt;
&lt;p&gt;快速排序算法是一种原地、不稳定的排序算法，最好时间复杂度情况：T(n) = O(nlogn) 最差时间复杂度情况：T(n) = O(n2) 平均时间复杂度情况：T(n) = O(nlogn)　&lt;/p&gt;
&lt;h2 id=&quot;开始分析并归排序算法&quot;&gt;开始分析“并归排序算法”&lt;/h2&gt;
&lt;p&gt;归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。&lt;/p&gt;
&lt;h6 id=&quot;并归排序描述&quot;&gt;1.并归排序描述&lt;/h6&gt;
&lt;p&gt;归并操作的工作原理如下：&lt;br/&gt;第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;br/&gt;第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;br/&gt;第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;br/&gt;重复步骤3直到某一指针超出序列尾&lt;br/&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
&lt;h6 id=&quot;图解并归排序&quot;&gt;2.图解并归排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7ecdb625d?w=1029&amp;amp;h=633&amp;amp;f=gif&amp;amp;s=1366227&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现并归排序&quot;&gt;3.代码实现并归排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MergeSort {

    public static void main(String[] args) {
        int[] arr = new int[] {1,3,5,2,4,6,8,10};
        System.out.println(Arrays.toString(arr));
        mergeSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
    
    //归并排序
    public static void mergeSort(int[] arr,int low,int high) {
        int middle=(high+low)/2;
        if(low&amp;lt;high) {
            //处理左边
            mergeSort(arr, low, middle);
            //处理右边
            mergeSort(arr, middle+1, high);
            //归并
            merge(arr,low,middle,high);
        }
    }
    
    public static void merge(int[] arr,int low,int middle, int high) {
        //用于存储归并后的临时数组
        int[] temp = new int[high-low+1];
        //记录第一个数组中需要遍历的下标
        int i=low;
        //记录第二个数组中需要遍历的下标
        int j=middle+1;
        //用于记录在临时数组中存放的下标
        int index=0;
        //遍历两个数组取出小的数字，放入临时数组中
        while(i&amp;lt;=middle&amp;amp;&amp;amp;j&amp;lt;=high) {
            //第一个数组的数据更小
            if(arr[i]&amp;lt;=arr[j]) {
                //把小的数据放入临时数组中
                temp[index]=arr[i];
                //让下标向后移一位；
                i++;
            }else {
                temp[index]=arr[j];
                j++;
            }
            index++;
        }
        //处理多余的数据
        while(j&amp;lt;=high) {
            temp[index]=arr[j];
            j++;
            index++;
        }
        while(i&amp;lt;=middle) {
            temp[index]=arr[i];
            i++;
            index++;
        }
        //把临时数组中的数据重新存入原数组
        for(int k=0;k&amp;lt;temp.length;k++) {
            arr[k+low]=temp[k];
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析并归排序算法&quot;&gt;4.分析并归排序算法&lt;/h6&gt;
&lt;p&gt;并归排序算法是一种稳定的排序算法，最好时间复杂度情况：T(n) = O(n) 最差时间复杂度情况：T(n) = O(nlogn) 平均时间复杂度情况：T(n) = O(nlogn)　&lt;/p&gt;
&lt;h2 id=&quot;开始分析基数排序算法&quot;&gt;开始分析“基数排序算法”&lt;/h2&gt;
&lt;p&gt;基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。&lt;/p&gt;
&lt;h6 id=&quot;图解基数排序&quot;&gt;2.图解基数排序&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;小提示：注意进度条挡住的0~9的数字归类&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7edc55304?w=619&amp;amp;h=349&amp;amp;f=gif&amp;amp;s=98359&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现基数排序&quot;&gt;3.代码实现基数排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RadixSort {

    public static void main(String[] args) {
        int[] arr = new int[] {23,6,189,45,9,287,56,1,798,34,65,652,5};
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    public static void  radixSort(int[] arr) {
        //存最数组中最大的数字
        int max=Integer.MIN_VALUE;
        for(int i=0;i&amp;lt;arr.length;i++) {
            if(arr[i]&amp;gt;max) {
                max=arr[i];
            }
        }
        //计算最大数字是几位数
        int maxLength = (max+&quot;&quot;).length();
        //用于临时存储数据的数组
        int[][] temp = new int[10][arr.length];
        //用于记录在temp中相应的数组中存放的数字的数量
        int[] counts = new int[10];
        //根据最大长度的数决定比较的次数
        for(int i=0,n=1;i&amp;lt;maxLength;i++,n*=10) {
            //把每一个数字分别计算余数
            for(int j=0;j&amp;lt;arr.length;j++) {
                //计算余数
                int ys = arr[j]/n%10;
                //把当前遍历的数据放入指定的数组中
                temp[ys][counts[ys]] = arr[j];
                //记录数量
                counts[ys]++;
            }
            //记录取的元素需要放的位置
            int index=0;
            //把数字取出来
            for(int k=0;k&amp;lt;counts.length;k++) {
                //记录数量的数组中当前余数记录的数量不为0
                if(counts[k]!=0) {
                    //循环取出元素
                    for(int l=0;l&amp;lt;counts[k];l++) {
                        //取出元素
                        arr[index] = temp[k][l];
                        //记录下一个位置
                        index++;
                    }
                    //把数量置为0
                    counts[k]=0;
                }
            }
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析基数排序算法&quot;&gt;4.分析基数排序算法&lt;/h6&gt;
&lt;p&gt;基数排序算法是一种稳定的排序算法，最好时间复杂度情况：T(n) = O(n * k) 最差时间复杂度情况：T(n) = O(n * k) 平均时间复杂度情况：T(n) = O(n * k)。&lt;/p&gt;
&lt;h2 id=&quot;开始分析堆排序算法&quot;&gt;开始分析“堆排序算法”&lt;/h2&gt;
&lt;h6 id=&quot;堆排序描述&quot;&gt;1.堆排序描述&lt;/h6&gt;
&lt;p&gt;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;
&lt;p&gt;在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：&lt;br/&gt;最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点&lt;br/&gt;创建最大堆（Build Max Heap）：将堆中的所有数据重新排序&lt;br/&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算&lt;/p&gt;
&lt;h6 id=&quot;图解堆排序&quot;&gt;2.图解堆排序&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7f45fd4fa?w=802&amp;amp;h=504&amp;amp;f=gif&amp;amp;s=3298127&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;代码实现堆排序&quot;&gt;3.代码实现堆排序&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HeapSort {
    
    public static void main(String[] args) {
        int[] arr = new int[] {9,6,8,7,0,1,10,4,2};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    public static void heapSort(int[] arr) {
        //开始位置是最后一个非叶子节点，即最后一个节点的父节点
        int start = (arr.length-1)/2;
        //调整为大顶堆
        for(int i=start;i&amp;gt;=0;i--) {
            maxHeap(arr, arr.length, i);
        }
        //先把数组中的第0个和堆中的最后一个数交换位置，再把前面的处理为大顶堆
        for(int i=arr.length-1;i&amp;gt;0;i--) {
            int temp = arr[0];
            arr[0]=arr[i];
            arr[i]=temp;
            maxHeap(arr, i, 0);
        }
    }
    
    public static void maxHeap(int[] arr,int size,int index) {
        //左子节点
        int leftNode = 2*index+1;
        //右子节点
        int rightNode = 2*index+2;
        int max = index;
        //和两个子节点分别对比，找出最大的节点
        if(leftNode&amp;lt;size&amp;amp;&amp;amp;arr[leftNode]&amp;gt;arr[max]) {
            max=leftNode;
        }
        if(rightNode&amp;lt;size&amp;amp;&amp;amp;arr[rightNode]&amp;gt;arr[max]) {
            max=rightNode;
        }
        //交换位置
        if(max!=index) {
            int temp=arr[index];
            arr[index]=arr[max];
            arr[max]=temp;
            //交换位置以后，可能会破坏之前排好的堆，所以，之前的排好的堆需要重新调整
            maxHeap(arr, size, max);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;分析堆排序算法&quot;&gt;4.分析堆排序算法&lt;/h6&gt;
&lt;p&gt;基数排序算法是一种原地、不稳定的排序算法，最好时间复杂度情况：T(n) = O(nlogn) 最差时间复杂度情况：T(n) = O(nlogn) 平均时间复杂度情况：：T(n) = O(nlogn)&lt;/p&gt;
&lt;h2 id=&quot;为什么插入排序要比冒泡排序更受欢迎&quot;&gt;为什么插入排序要比冒泡排序更受欢迎？&lt;/h2&gt;
&lt;p&gt;基本的知识都讲完了，不知道各位有木有想过这样一个问题：冒泡排序和插入排序的时间复杂度都是O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？&lt;/p&gt;
&lt;p&gt;我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。&lt;/p&gt;
&lt;p&gt;但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。我们来看这段操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;冒泡排序中数据的交换操作：
if (a[j] &amp;gt; a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] &amp;gt; value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是K的数组进行排序。用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时就是3*K单位时间。而插入排序中数据移动操作只需要K个单位时间。&lt;/p&gt;
&lt;p&gt;这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的Java代码，我写了一个性能对比测试程序，随机生成10000个数组，每个数组中包含200个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约700ms才能执行完成，而插入排序只需要100ms左右就能搞定！&lt;/p&gt;
&lt;p&gt;所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行再温习一下希尔排序。&lt;/p&gt;
&lt;p&gt;下面是八大经典算法的分析图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/12/16e5d0c7e93e989c?w=876&amp;amp;h=315&amp;amp;f=png&amp;amp;s=527156&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，以上八大经典算法分析，都是基于数组实现的。如果数据存储在链表中，这些排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？期待大牛评论出来~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果本文章对你有帮助，哪怕是一点点，请点个赞呗，谢谢~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...说好了来了就是盆友喔...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/7/16e434427587000f?w=430&amp;amp;h=430&amp;amp;f=png&amp;amp;s=94196&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:43:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>现如今大学生学习排序算法，除了学习它的算法原理、代码实现之外，作为一个大学生更重要的往往是要学会如何评价、分析一个排序算法。排序对于任何一个程序员来说，可能都不会陌生。大部分编程语言中，也都提供了排序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11839611.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html</guid>
<description>&lt;p&gt;通过《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;利用容器提供服务&lt;/a&gt;》我们知道作为依赖注入容器的IServiceProvider对象是通过调用IServiceCollection接口的扩展方法BuildServiceProvider创建的，IServiceCollection对象是一个存放服务注册信息的集合。在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;一个迷你版DI框架&lt;/a&gt;》中创建的Cat框架中的服务注册是通过类型ServiceRegistry表示的，在.NET Core依赖注入框架中，与之对应的类型是ServiceDescriptor。&lt;/p&gt;

&lt;p&gt;ServiceDescriptor是对某个服务注册项的描述，作为依赖注入容器的IServiceProvider对象正是利用该对象提供的描述信息才得以提供我们需要的服务实例。服务描述总是注册到通过ServiceType属性表示的服务类型上，ServiceDescriptor的Lifetime表示采用的生命周期模式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ServiceType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceLifetime Lifetime { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type ImplementationType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt; ImplementationFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ImplementationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceDescriptor(Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; instance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceDescriptor(Type serviceType,  Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; factory, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceDescriptor(Type serviceType, Type implementationType,  ServiceLifetime lifetime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServiceDescriptor的其他三个属性体现了服务实例的三种提供方式，并分别对应着三个构造函数。如果我们指定了服务的&lt;span&gt;实现类型&lt;/span&gt;（对应于ImplementationType属性），那么最终的服务实例将通过调用定义在该类型中的某一个构造函数来创建。如果指定的是一个&lt;span&gt;Func&amp;lt;IServiceProvider, object&amp;gt;&lt;/span&gt;对象（对应于ImplementationFactory属性），那么该委托对象将作为提供服务实例的工厂。如果我们直接指定一个&lt;span&gt;现成的对象&lt;/span&gt;（对应的属性为ImplementationInstance），那么该对象就是最终提供的服务实例。&lt;/p&gt;
&lt;p&gt;如果我们采用提供的现成服务实例来创建ServiceDescriptor对象，对应服务注册自然会采用&lt;span&gt;Singleton&lt;/span&gt;生命周期模式。对于通过其他两个构造函数创建的ServiceDescriptor对象来说，需要显式指定采用的生命周期模式。相较于ServiceDescriptor，我们在&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;Cat框架&lt;/a&gt;中定义的ServiceRegistry显得更加简单，因为我们直接提供了一个类型为Func&amp;lt;Cat,Type[], object&amp;gt;的对象来提供对应的服务实例。&lt;/p&gt;
&lt;p&gt;除了调用上面介绍的三个构造函数来创建对应的ServiceDescriptor对象之外，我们还可以利用定义在ServiceDescriptor类型中的一系列静态方法来创建该对象。如下面的代码片段所示，ServiceDescriptor提供了如下两个名为&lt;span&gt;Describe&lt;/span&gt;的方法重载来创建对应的ServiceDescriptor对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Describe(Type serviceType,  Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory,  ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ServiceDescriptor Describe(Type serviceType,  Type implementationType, ServiceLifetime lifetime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们调用上面两个Describe方法来创建ServiceDescriptor对象的时候总是需要指定采用的生命周期模式，为了让对象创建变得更加简单，ServiceDescriptor中还定义了一系列针对具体生命周期模式的静态工厂方法。如下所示的是针对Singleton模式的一组静态工厂方法重载的定义，针对其他两种模式的Scoped和Transient方法具有类似的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceDescriptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton &amp;lt;TService, TImplementation&amp;gt;()  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton &amp;lt;TService, TImplementation&amp;gt;( Func&amp;lt;IServiceProvider, TImplementation&amp;gt; implementationFactory)   &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;  TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService&amp;gt;( Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton&amp;lt;TService&amp;gt;( TService implementationInstance) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton(Type serviceType,  Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceDescriptor Singleton(Type serviceType,  &lt;span&gt;object&lt;/span&gt;&lt;span&gt; implementationInstance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ServiceDescriptor Singleton(Type service,  Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;依赖注入框架将服务注册存储在一个通过IServiceCollection接口表示的集合之中。如下面的代码片段所示，一个IServiceCollection对象本质上就是一个元素类型为ServiceDescriptor的列表。在默认情况下我们使用的是实现该接口的ServiceCollection类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IServiceCollection : IList&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceCollection : IServiceCollection {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在应用启动时针对服务的注册本质上就是创建相应的ServiceDescriptor对象并将其添加到指定IServiceCollection对象中的过程。考虑到服务注册是一个高频调用的操作，所以依赖注入框架为IServiceCollection接口定义了一系列扩展方法完成服务注册的工作，比如下面的这两个Add方法可以将指定的一个或者多个ServiceDescriptor对象添加到IServiceCollection集合中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Add(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;依赖注入框架还针对具体生命周期模式为IServiceCollection接口定义了一系列的扩展方法，它们会根据提供的输入创建出对应的ServiceDescriptor对象，并将其添加到指定的IServiceCollection对象中。如下所示的是针对Singleton模式的&lt;span&gt;AddSingleton&lt;/span&gt;方法重载的定义，针对其他两个生命周期模式的&lt;span&gt;AddScoped&lt;/span&gt;和&lt;span&gt;AddTransient&lt;/span&gt;方法具有类似的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionServiceExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService, TImplementation&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services, TService implementationInstance)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService, TImplementation&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services,  Func&amp;lt;IServiceProvider, TImplementation&amp;gt; implementationFactory)   &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton&amp;lt;TService&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services,  Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection services,  Type serviceType, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection services,   Type serviceType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; implementationInstance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services,  Type serviceType, Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然针对同一个服务类型可以添加多个ServiceDescriptor对象，但这种情况只有在应用需要使用到同一类型的多个服务实例的情况下才有意义，比如我们可以注册多个ServiceDescriptor来提供同一个主题的多个订阅者。如果我们总是根据指定的服务类型来提取单一的服务实例，这种情况下一个服务类型只需要一个ServiceDescriptor对象就够了。对于这种场景我们可能会使用如下两个名为&lt;span&gt;TryAdd&lt;/span&gt;的扩展方法，该方法会根据指定ServiceDescriptor提供的服务类型判断对应的服务注册是否存在，只有在指定类型的服务注册不存在的情况下，我们提供的ServiceDescriptor才会被添加到指定的IServiceCollection对象中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAdd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAdd(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展方法TryAdd同样具有基于三种生命周期模式的版本，如下所示的是针对Singleton模式的&lt;span&gt;TryAddSingleton&lt;/span&gt;方法的定义。在指定服务类型对应的ServiceDescriptor不存在的情况下，这些方法会采用提供的实现类型、服务实例创建工厂或者服务实例来创建生命周期模式为Singleton的ServiceDescriptor对象，并将其添加到指定的IServiceCollection对象中。针对其他两种生命周期模式的&lt;span&gt;TryAddScoped&lt;/span&gt;和&lt;span&gt;TryAddTransient&lt;/span&gt;方法具有类似的定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService, TImplementation&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection collection)   &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;  &lt;span&gt;where&lt;/span&gt; TImplementation: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;, TService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type service);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  TService instance) &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton&amp;lt;TService&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services,  Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory)  &lt;span&gt;where&lt;/span&gt; TService: &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt; IServiceCollection collection,  Type service, Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; implementationFactory);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddSingleton(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type service, Type implementationType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了上面介绍的扩展方法TryAdd和TryAdd{Lifetime}之外，IServiceCollection接口还具有如下两个名为&lt;span&gt;TryAddEnumerable&lt;/span&gt;的扩展方法。当TryAddEnumerable方法在决定将指定的ServiceDescriptor添加到IServiceCollection对象之前，它也会做存在性检验。与TryAdd和TryAdd{Lifetime}方法不同的是，该方法在判断执行的ServiceDescriptor是否存在是同时考虑服务类型和实现类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddEnumerable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services,  ServiceDescriptor descriptor);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TryAddEnumerable(&lt;span&gt;this&lt;/span&gt; IServiceCollection services,  IEnumerable&amp;lt;ServiceDescriptor&amp;gt;&lt;span&gt; descriptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被TryAddEnumerable方法用来判断存在性的实现类型不只是ServiceDescriptor的ImplementationType属性。如果ServiceDescriptor是通过一个指定的服务实例创建的，那么该&lt;span&gt;实例的类型&lt;/span&gt;会用来判断对应的服务注册是否存在。如果ServiceDescriptor是通过提供的服务实例工厂来创建的，那么代表服务实例创建工厂的&lt;span&gt;Func&amp;lt;in T, out TResult&amp;gt;&lt;/span&gt;对象的第二个参数类型将被用于判断ServiceDescriptor的存在性。扩展方法TryAddEnumerable的实现逻辑可以通过如下这段程序来验证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo()));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

Func&lt;/span&gt;&amp;lt;IServiceProvider, Foo&amp;gt; factory4Foo = _ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo();
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;&lt;span&gt;(factory4Foo));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Bar&amp;gt;&lt;span&gt;());
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Baz()));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

Func&lt;/span&gt;&amp;lt;IServiceProvider, Gux&amp;gt; factory4Gux = _ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gux();
services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux&amp;gt;&lt;span&gt;(factory4Gux));
Debug.Assert(services.Count &lt;/span&gt;== &lt;span&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果通过上述策略得到的实现类型为&lt;span&gt;Object&lt;/span&gt;，那么TryAddEnumerable会因为实现类型不明确而抛出一个ArgumentException类型的异常。这主要发生在提供的ServiceDescriptor对象是由服务实例工厂创建的情况，所以上面实例中用来创建ServiceDescriptor的工厂类型分别为Func&amp;lt;IServiceProvider, Foo&amp;gt;和Func&amp;lt;IServiceProvider, Gux&amp;gt;，而不是Func&amp;lt;IServiceProvider, object&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; service = ServiceDescriptor.Singleton&amp;lt;IFoobarbazgux&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo());
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ServiceCollection().TryAddEnumerable(service);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设我们采用如上所示的方式利用一个Lamda表达式来创建一个ServiceDescriptor对象，对于创建的ServiceDescriptor来说，其服务实例工厂是一个Func&amp;lt;IServiceProvider, object&amp;gt;对象，所以当我们将它作为参数调用TryAddEnumerable方法时会抛出如下图所示的ArgumentException异常，并提示“Implementation type cannot be 'App.IFoobarbazgux' because it is indistinguishable from other services registered for 'App.IFoobarbazgux'.”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191112081952401-2045061945.png&quot;&gt;&lt;img width=&quot;379&quot; height=&quot;166&quot; title=&quot;4-5&quot; alt=&quot;4-5&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191112081952716-412830984.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面介绍的这些方法最终的目的都是添加新的ServiceDescriptor对象到指定的IServiceCollection集合中，有的时候我们还希望删除或者替换现有的某个ServiceDescriptor对象，这种情况通常发生在需要对当前使用框架中由某个服务提供的功能进行定制的时候。由于IServiceCollection实现了IList&amp;lt;ServiceDescriptor&amp;gt;接口，所以我们可以调用其&lt;span&gt;Clear&lt;/span&gt;、&lt;span&gt;Remove&lt;/span&gt;和&lt;span&gt;RemoveAt&lt;/span&gt;方法来清除或者删除现有的ServiceDescriptor对象。除此之外，我们还可以选择如下这些扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionDescriptorExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection RemoveAll&amp;lt;T&amp;gt;( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection RemoveAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  Type serviceType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Replace(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection collection,  ServiceDescriptor descriptor);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;RemoveAll&lt;/span&gt;和&lt;span&gt;RemoveAll&amp;lt;T&amp;gt;&lt;/span&gt;方法帮助我们根据指定的服务类型来删除现有的ServiceDescriptor对象。&lt;span&gt;Replace&lt;/span&gt;方法会使用指定的ServiceDescriptor去替换第一个具有相同服务类型（对应ServiceType属性）的ServiceDescriptor，实际操作是先删除后添加。如果从目前的IServiceCollection集合中找不到服务类型匹配的ServiceDescriptor对象，指定的ServiceDescriptor对象会直接添加到IServiceCollection对象中，这一逻辑也可以利用如下的程序来验证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection();
services.Replace(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Foo&amp;gt;&lt;span&gt;());
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Foo)));

services.AddSingleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Bar&amp;gt;&lt;span&gt;();
services.Replace(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFoobarbazgux, Baz&amp;gt;&lt;span&gt;());
Debug.Assert(&lt;/span&gt;!services.Any(it=&amp;gt;it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Foo)));
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Bar)));
Debug.Assert(services.Any(it &lt;/span&gt;=&amp;gt; it.ImplementationType == &lt;span&gt;typeof&lt;/span&gt;(Baz)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:20:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>通过《利用容器提供服务》我们知道作为依赖注入容器的IServiceProvider对象是通过调用IServiceCollection接口的扩展方法BuildServiceProvider创建的，ISe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html</dc:identifier>
</item>
<item>
<title> 2019.NET Conf China（中国.NET开发者峰会）活动全纪录：.NET技术之崛起，已势不可挡 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/11839527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/11839527.html</guid>
<description>&lt;p&gt;当今时代，气象更新，技术飞速发展。&lt;/p&gt;
&lt;p&gt;当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成就企业发展的宏伟蓝图的同时，也在实现自己的个人梦想。&lt;/p&gt;
&lt;p&gt;微软，无疑便是最善于应对时代变化的英雄，从比尔盖茨选择从哈佛大学创业开始，历经四十年时间，经过了三个变革的时期。每个时代都以其独特的方式深深地鼓舞人心，哪怕历经千辛万苦，哪怕一度前途充满阴霾，也能实现自我价值的刷新，并重回巅峰。&lt;/p&gt;
&lt;p&gt;当代的微软，已经从一家技术驱动型公司，变革为一家文化驱动型公司，在纳德拉的领导下，云战略，开放，分享，自我刷新的企业文化精神已经让人们深深的意识到，那个沉睡的巨象一旦觉醒，该有着多么大的魄力和影响力。&lt;/p&gt;
&lt;p&gt;大环境已经在悄然改变，在隔壁Java走下坡路时，这边的.NET，也迎来了新的发展机遇。微软不再靠自己一家企业来控制这种优秀的技术，而是成立了一个.NET基金会，他扮演着技术公司于开发者之间的窗口，旨在加强和扩大以.NET技术为核心的技术生态系统。并随着.NET技术交给了社区由基金会来管理，基于.NET的开源生态已经如星火燎然之势蓬勃开展起来。到目前为止该基金会的参与者已经包括谷歌，红帽等知名互联网公司，这么多优秀的企业都参与其中。众人拾柴火焰高，有了这么多企业的积极参与，.NET技术生态已经迎来了前所未有的战略机遇期。&lt;/p&gt;
&lt;p&gt;2019年的9月份，在2019年的.NET Conf上已经发布了.NET技术体系下、面向开源和跨平台的技术组件.NET Core3.0，该技术包含了一系列组件和新特性，能够让无论是Web开发者，还是ML.NET开发者，或者是游戏开发者都能直接感受到.NET Core跨平台技术的魅力和价值。&lt;/p&gt;

&lt;p&gt;2019年对于广大.NET开发者来说算是不平凡的一年。在这一年里，在微软云技术社区的支持下、在.NET社区领袖张善友老师、衣明志老师、叶伟民老师、陈作老师、潘淳老师等行业翘楚的摇旗呐喊之下，各地的.NET技术社区（微软.NET俱乐部）如雨后春笋般蓬勃开展起来。&lt;/p&gt;
&lt;p&gt;首先是胶东开发者部落的诞生、广州微软.NET俱乐部的复活。&lt;/p&gt;
&lt;p&gt;接着是苏州微软.NET俱乐部的诞生。&lt;/p&gt;
&lt;p&gt;随后是长沙.NET技术社区、沈阳、东莞、厦门、北京等地区.NET社区的诞生 。&lt;/p&gt;
&lt;p&gt;以及随后各地都相继成立了主题为.NET技术或互联网技术的各类线上或线下的技术交流组织，可以说无论你目前身处祖国的哪一个角落，总是能在最近的地域找到一个活跃的技术社区，通过社区能够跟当地的技术大佬们进行充满高质量的技术交流，这对于每一位开发者来说都是非常难能可贵的体验。&lt;/p&gt;
&lt;p&gt;除了这些.NET技术社区外，还有数十位.NET开发者们自发运营起主打.NET方向的技术公众号来，通过这些公众号，能够让开发者从全方位多维度了解和学习面向互联网大时代的.NET技术，能够让爱学习的开发者们的技术每时每刻都做好积累。&lt;/p&gt;
&lt;p&gt;而且在.NET开发者的主阵地，博客园每天发表的新内容中，与.NET技术相关的话题也越来越多；而且越来越多的优秀的.NET技术书籍也已经付梓，并被出版社相继出版，成为畅销书，还有许多开发者们都相继把他们的写的新书交给了出版社，预计在明年年初将迎来一波.NET技术类书籍的小高潮。&lt;/p&gt;
&lt;p&gt;这些都是.NET开发者们迎来的良好机遇，借着行业互联网的逐渐深化、以及.NET技术的进一步推广、技术社区的繁荣昌盛、.NET学习资源的源源不绝，相信开发者们一定能借此良机成就个人的美好梦想。&lt;/p&gt;
&lt;p&gt;在这样的大背景之下，为了让.NET开发者们能够更加直观的感受到.NET技术的强大魅力，微软云（Azure)、.NET技术社区的行业翘楚、企业代表、活跃在.NET技术圈的优秀开发者们、以及各地.NET技术社区们，打算干一件大事，这就是本次2019年的.NET Conf，中国.NET 开发者峰会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/dHeSY1m1vxU7M0xT.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有别于一般都是由大型企业组织、或者甚至有微软包办的其他类型技术峰会，这次峰会完全来自.NET技术圈开发者们的无偿付出，我们可以看到，张善友老师经常在他的公众号里发布与Conf有关的资讯，而这些文章的撰写都是来源于社区；我们也可以看到许多精美的海报，这些也是来源于开发者，甚至也许就是我们身边的某位不知名的开发者。还有在活动现场的许多志愿者、主持人，这些都是对.NET 技术充满大爱的优秀开发者；尤其是那些为大家带来精彩内容的老师们，他们有时候为了PPT上的每一页内容，需要花费大量的业余时间；除了这些之外，我们还能看到许多细节，如那些设计精美的PPT、那些设计精良的文化衫、甚至还有那些小巧玲珑的贴纸图案、海报，无一不是来源于社区志愿者的精心奉献。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/aKGIP2ffgY0sBy14.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么多开发者、志愿者、老师们的专注认真、精心设计、严密组织， 从宣传、活动安排、布置、会场组织的每一个细节出发，我们看到的，正是一个充满生机和活力、专业的技术社区，这样的社区，让我们对.NET技术充满了激情，也让我们对未来充满了无限期待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/c4p8aTPXKyUlWWP5.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/FTy19dQR6V0gtjvx.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次.NET Conf的主题是《开源，共享，创新》，既可以称为社区的主题，也可以拥抱新时代的.net开发者们的共同心声。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/KrzXe1O3egUWHHhN.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源：随着.Net技术推出的新版技术框架.net core已经发布3.0版本，开源社区建设正如同雨后春笋一般蓬勃发展。&lt;/p&gt;
&lt;p&gt;共享：.net开发者们，不再选择敝帚自珍，而是以更加开放的心态参与到社区建设之中，共享知识，也是在分享财富。&lt;/p&gt;
&lt;p&gt;创新：开发者们拥有的最优秀的品质，在时代的浪潮下，唯有不断刷新，创新，才能始终如一的创造价值。&lt;/p&gt;
&lt;p&gt;而围绕主题出发的各种主题也同样贴合了行业发展的大趋势，许多.NET开发者虽然目前从事的领域也许是某些行业应用的开发，但是都说想了解新兴技术是如何运用到其中的，那么这次盛会给了大家机会。在本次峰会上，不仅有开发者职业发展规划的内容，也有.NET Core新的特性介绍，更有许多新兴技术，例如人工智能、实时计算、混沌工程、服务网格、RPA等新潮技术，还有PowerBI、Unity Bot、 ABP等备受期待的传统技术，能够各个让对技术充满兴趣的开发者都能学到自己想学的东西。&lt;/p&gt;
&lt;p&gt;我们可以跟随.NET Core项目负责人Scott Hunter一起，看看在.NET Core3.0中，哪些新的特性能够获得怎样的好处。&lt;/p&gt;
&lt;p&gt;也可以跟着来自澳大利亚的微软MVPJustin Yoo一起，听听他讲的故事，看看他的职业发展；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/fXT5Sm9hcmYlKN7X.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以跟着来自校宝在线的肖伟宇老师一起，看看如何在.NET Core中将检测组件集成到高可用的.NET Core微服务中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/xolfXf9N2Ngt0ZEw.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还可以听卢建辉老师谈谈ML.NET 和SciSharp项目以及TensorFlow.NET项目，而这个TensorFlow.NET项目尤其值得大家关注，因为他的主要开发团队，许多成员都是我们身边的、来自中国内地的.NET开发者们，这个项目不仅仅是中国.NET开发者们的小圈子自嗨，更是成为微软人工智能框架ML.NET的基础平台框架，通过这款框架，能够让全世界范围内超过六百二十万.NET开发者们无需转语音，便可畅想人工智能的美妙。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/kWU0c7E8ZgIetK76.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而刘腾飞Jesse这位英俊帅气不凡的开发者，也把他们公司踩坑K8s的全过程搬上讲台，用血和汗的教训告诉大家，其实.NET Core什么都能干好，而且不比隔壁家的技术差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/lsRndjg1IV02vuRj.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次大会与某些大厂组织的自称科技未来的技术峰会、喜欢吹假大空技术不同，这次大会完全是面向开发者的毫无套路的技术大会，内容都是来源于身边那些热衷于技术的开发者们平时工作的点滴积累。&lt;/p&gt;
&lt;p&gt;例如，我们可以看到博客园常年排名第一的蒋金楠大大，从多个角度出发，向开发者介绍在过去、现在，如何使用.NET/.NET Core的技术实现跨平台应用的开发；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/tVCggMaeuy4Otn49.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以及来自特来电的周国庆老师，把特来电如何构建一个覆盖全国二十万个充电站的过程讲述给大家听，混沌工程，从未离大家如此贴近。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/U8orKf4948oFTT06.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，还有目前在日本从事聚合支付的桂素伟老师也分享了他们使用.NET Core+K8s的开发实践过程，让开发者能够更加深入的了解.NET技术是如何更好的融入到云原生之中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/sCLVEiNw2fsVvXTC.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有来自中通快递的黄国石老师，把中通基于.NET技术构建实时计算框架的过程也搬上舞台，让大家看到了这双十一一亿订单背后，.NET技术也做出了如此巨大的贡献。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/jjRmo0c3OuEIBzIO.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有来自刘钰老师分享的PowerBI，如何无需编程就能掌握大数据分析的技能，只要使用PowerBI，谁都可以办到。&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/r8YuyEEQ2bQJengS.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了一对多式的讲座，活动还提供了面对面的workshop讲座，在张善友老师、陈计节老师、刘腾飞老师等几位老师花了半天时间向参加工作坊的开发者们介绍如何在azure云中使用k8s的全过程，让大家在互动中学习，产生了非常不错的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/hlroKh2ssdEyvdyY.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从11月8日的.NET 之夜，到11月9日，11月10日的.NET Conf，我在上海呆了不足三天，有幸作为观众参与到这场活动之中，让我获益匪浅。我不仅仅学到了许多在现有工作经历中无法获取的机会，认识了许多在原来圈子中无法认识的优秀开发者，更让我深刻明白，自身离他们的巨大差距，这将激励我进一步努力。&lt;/p&gt;
&lt;p&gt;时光流逝如白驹，短暂而稍纵即逝，如同黄浦江，时而平静流淌，时而泛起波澜，正如我们所亲历的这个时代。&lt;/p&gt;
&lt;p&gt;人类从未有过如此般壮阔的变革。无时无刻不在变革，是因为历史的车轮滚滚向，历史眷顾的是坚定者、奋斗者、搏击者。&lt;/p&gt;
&lt;p&gt;我相信，我们每个人都将迎来同样更加壮阔的明天，因为我们正赶上了行业互联网大发展的时代、以及.NET发展的大时代。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/vsXjGb1qoVguk6Ik.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201911/191302-20191107083325021-982706970.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文版权归原作者和博客园共同拥有。作品采用知识共享署名-非商业性使用-相同方式共享4.0 国际许可协议进行许可。&lt;br/&gt;本文来自： 溪源 | 长沙.NET技术社区。阅读更多精彩好文，欢迎关注长沙.NET技术社区公众号【DotNET技术圈】。&lt;br/&gt;首发于溪源的个人博客www.techq.xyz&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:11:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一、微软走向开放与.NET Core的诞生 当今时代，气象更新，技术飞速发展。 当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/11839527.html</dc:identifier>
</item>
<item>
<title>Netty启动流程剖析 - luoxn28</title>
<link>http://www.cnblogs.com/luoxn28/p/11839293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoxn28/p/11839293.html</guid>
<description>&lt;blockquote readability=&quot;7.3066666666667&quot;&gt;
&lt;p&gt;编者注：Netty是Java领域有名的开源网络库，特点是高性能和高扩展性，因此很多流行的框架都是基于它来构建的，比如我们熟知的Dubbo、Rocketmq、Hadoop等，针对高性能RPC，一般都是基于Netty来构建，比如soft-bolt。总之一句话，Java小伙伴们需要且有必要学会使用Netty并理解其实现原理。&lt;br/&gt;关于Netty的入门讲解可参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;amp;mid=2649938635&amp;amp;idx=1&amp;amp;sn=fc22d218fb1529e8f4c1fcb659838d75&amp;amp;chksm=8f35097eb8428068258b95a652e46ed082499b3952ac11af2027400db758a1ac4b158412aeea&amp;amp;token=132576240&amp;amp;lang=zh_CN#rd&quot;&gt;Netty 入门，这一篇文章就够了&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Netty的启动流程(&lt;code&gt;ServerBootstrap&lt;/code&gt;)，就是创建&lt;code&gt;NioEventLoopGroup&lt;/code&gt;（内部可能包含多个NioEventLoop，每个eventLoop是一个线程，内部包含一个FIFO的taskQueue和Selector）和ServerBootstrap实例，并进行bind的过程（bind流程涉及到channel的创建和注册），之后就可以对外提供服务了。&lt;/p&gt;
&lt;p&gt;Netty的启动流程中，涉及到多个操作，比如register、bind、注册对应事件等，为了不影响main线程执行，这些工作以task的形式提交给NioEventLoop，由NioEventLoop来执行这些task，也就是register、bind、注册事件等操作。&lt;/p&gt;
&lt;p&gt;NioEventLoop（准确来说是&lt;code&gt;SingleThreadEventExecutor&lt;/code&gt;）中包含了&lt;code&gt;private volatile Thread thread&lt;/code&gt;，该thread变量的初始化是在new的线程第一次执行run方式时才赋值的，这种形式挺新颖的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibNZvHljNHL0XBElMznic1a9JbU3wJDS4QkLQ6lZJXJT6JeSXSMhMpicicwSQkJibzIVzcRIOcESSRxMzg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Netty启动流程图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibNZvHljNHL0XBElMznic1a9J06OeGUCuG94fZe8U2XUlHfnqMIXjp1Ttb3n8hTmibfLYYWYZ0BMUMkQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致了解了Netty启动流程之后，下面就按照Netty启动流程中涉及到的源码来进行分析。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;netty启动流程分为server端和client端，不同之处就是前者监听端口，对外提供服务（socket-&amp;gt;bind-&amp;gt;listen操作），对应类ServerBootstrap；后者主动去连接远端端口（socket-&amp;gt;connect），对应类Bootstrap。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;server端启动流程&quot;&gt;server端启动流程&lt;/h2&gt;
&lt;p&gt;server端启动流程可以理解成创建ServerBootstrap实例的过程，就以下面代码为例进行分析（echo服务）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class EchoServer {
    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;));

    public static void main(String[] args) throws Exception {
        // bossGroup处理connect事件
        // workerGroup处理read/write事件
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        EchoServerHandler serverHandler = new EchoServerHandler();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
             .option(ChannelOption.SO_BACKLOG, 100)
             .handler(new LoggingHandler(LogLevel.INFO))
             .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     // 当连接建立后（register到childWorkerGroup前）初始化channel.pipeline
                     ch.pipeline().addLast(serverHandler);
                 }
             });

            // Start the server.
            ChannelFuture f = b.bind(PORT).sync();
            // Wait until the server socket is closed.
            f.channel().closeFuture().sync();
        } finally {
            // Shut down all event loops to terminate all threads.
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}

public class EchoServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;eventloopgroup创建&quot;&gt;EventLoopGroup创建&lt;/h3&gt;
&lt;p&gt;EventLoopGroup中可能包含了多个EventLoop，EventLoop是一个Reactor模型的事件处理器，一个EventLoop对应一个线程，其内部会维护一个selector和taskQueue，负责处理客户端请求和内部任务，内部任务如ServerSocketChannel注册和ServerSocket绑定操作等。关于NioEventLoop，后续专门写一篇文章分析，这里就不再展开，只需知道个大概即可，其架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibNZvHljNHL0XBElMznic1a9JWIALze8WppAdrX3VLt2mq9AZ1D7qYzR4tw27ngy26mwTSDiaVhriae9g/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EventLoopGroup创建本质就是创建多个NioEventLoop，这里创建NioEventLoop就是初始化一个Reactor，包括selector和taskQueue。主要逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
    // 创建NioEventLoop实例
    children = new EventExecutor[nThreads];
    // 初始化NioEventLoop,实际调用的是NioEventLoopGroup.newChild方法
    for (int i = 0; i &amp;lt; nThreads; i ++) {
        children[i] = newChild(executor, args);
    }

    // 多个NioEventLoop中选择策略
    chooser = chooserFactory.newChooser(children);
}

NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
    // 创建taskQueue
    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
    // 是不是很熟悉，java nio selector操作
    provider = selectorProvider;
    final SelectorTuple selectorTuple = openSelector();
    selector = selectorTuple.selector;
    unwrappedSelector = selectorTuple.unwrappedSelector;
    selectStrategy = strategy;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EventLoopGroup创建OK后，启动的第一步就算完成了，接下来该进行bind、listen操作了。&lt;/p&gt;
&lt;h2 id=&quot;serverbootstrap流程&quot;&gt;ServerBootstrap流程&lt;/h2&gt;
&lt;h3 id=&quot;bind操作&quot;&gt;bind操作&lt;/h3&gt;
&lt;p&gt;bind操作是ServerBootstrap流程重要的一环，bind流程涉及到NioChannel的创建、初始化和注册(到Selector)，启动NioEventLoop，之后就可以对外提供服务了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ChannelFuture bind(SocketAddress localAddress) {
    validate(); // 参数校验
    return doBind(localAddress);
}
private ChannelFuture doBind(final SocketAddress localAddress) {
    // 1. 初始化注册操作
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
        return regFuture;
    }
 
    // 2. doBind0操作
    if (regFuture.isDone()) {
        // register已完成，这里直接调用doBind0
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // register还未完成，注册listener回调，在回调中调用doBind0
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            /**
             * channel register完成（注册到Selector并且调用了invokeHandlerAddedIfNeeded）之后，
             * 会调用safeSetSuccess，触发各个ChannelFutureListener，最终会调用到这里的operationComplete方法
             */
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                Throwable cause = future.cause();
                if (cause != null) {
                    promise.setFailure(cause);
                } else {
                    promise.registered();
                    doBind0(regFuture, channel, localAddress, promise);
                }
            }
        });
        return promise;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里涉及到2个操作，一个是channel的创建、初始化、注册操作，另一个是bind操作，下面兵分两路，分别来讲。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意，这里如果main线程执行到regFuture.isDone()时，register还未完成，那么main线程是不会直接调用bind操作的，而是往regFuture上注册一个Listenner，这样channel register完成（注册到Selector并且调用了invokeHandlerAddedIfNeeded）之后，会调用safeSetSuccess，触发各个ChannelFutureListener，最终会调用到这里的operationComplete方法，进而在执行bind操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;channel初始化注册操作&quot;&gt;channel初始化、注册操作&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // 1.创建(netty自定义)Channel实例，并初始化
        // channel为 NioServerSocketChannel 实例,NioServerSocketChannel的父类AbstractNioChannel保存有nio的ServerSocketChannel
        channel = channelFactory.newChannel();
        // 2.初始化channel（）
        init(channel);
    } catch (Throwable t) {
    }
 
    // 3.向Selector注册channel
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
     
    return regFuture;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里重点关注下初始化channel流程，主要操作是设置channel属性、设置channel.pipeline的ChannelInitializer，注意，ChannelInitializer是在channel注册到selector之后被回调的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 初始channel属性，也就是ChannelOption对应socket的各种属性。
 * 比如 SO_KEEPALIVE SO_RCVBUF ... 可以与Linux中的setsockopt函数对应起来。
 * 最后将ServerBootstrapAcceptor添加到对应channel的ChannelPipeline中。
 */
@Override
void init(Channel channel) throws Exception {
    final Map&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt; options = options0();
    synchronized (options) {
        setChannelOptions(channel, options, logger);
    }
    
    ChannelPipeline p = channel.pipeline();
    // 获取childGroup和childHandler，传递给ServerBootstrapAcceptor
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildOptions;
    final Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildAttrs;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
    }
    synchronized (childAttrs) {
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
    }
 
    p.addLast(new ChannelInitializer&amp;lt;Channel&amp;gt;() {
        /**
         * 在register0中，将channel注册到Selector之后，会调用invokeHandlerAddedIfNeeded，
         * 进而调用到这里的initChannel方法
         */
        @Override
        public void initChannel(final Channel ch) throws Exception {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
 
            // 这里注册一个添加ServerBootstrapAcceptor的任务
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // 添加ServerBootstrapAcceptor
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;channel初始化之后就该将其注册到selector，即下面的register流程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ChannelFuture register(Channel channel) {
    // next()挑选一个EventLoop，默认轮询选择某个NioEventLoop
    return next().register(channel);
}
public ChannelFuture register(final ChannelPromise promise) {
    promise.channel().unsafe().register(this, promise);
    return promise;
}
// AbstractChannel
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    AbstractChannel.this.eventLoop = eventLoop;
 
    // 直接执行register0或者以任务方式提交执行
    // 启动时，首先执行到这里的是main线程，所以是以任务的方式来提交执行的。
    // 也就是说，该任务是NioEventLoop第一次执行的任务，即调用register0
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {
        // 往NioEventLoop中(任务队列)添加任务时，如果NioEventLoop线程还未启动，则启动该线程
        eventLoop.execute(new Runnable() {
            @Override
            public void run() {
                register0(promise);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;register操作&quot;&gt;register操作&lt;/h3&gt;
&lt;p&gt;register操作之后伴随着多个回调及listener的触发：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// AbstractChannel$AbstractUnsafe
private void register0(ChannelPromise promise) {
    boolean firstRegistration = neverRegistered;
    // 这里调用的是AbstractNioChannel.doRegister
    // 这里将channel注册上去，并没有关注对应的事件（read/write事件）
    doRegister();
    neverRegistered = false;
    registered = true;
 
    // 调用handlerAdd事件，这里就会调用initChannel方法，设置channel.pipeline，也就是添加 ServerBootstrapAcceptor
    pipeline.invokeHandlerAddedIfNeeded();
 
    // 调用operationComplete回调
    safeSetSuccess(promise);
    // 回调fireChannelRegistered
    pipeline.fireChannelRegistered();
    // Only fire a channelActive if the channel has never been registered. This prevents firing
    // multiple channel actives if the channel is deregistered and re-registered.
    if (isActive()) {
        if (firstRegistration) {
            // 回调fireChannelActive
            pipeline.fireChannelActive();
        } else if (config().isAutoRead()) {
            beginRead();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中的initChannel回调也就是设置对外监听channel的channelHanlder为ServerBootstrapAcceptor；operationComplete回调也就是触发&lt;code&gt;ChannelFutureListener.operationComplete&lt;/code&gt;，这里会进行后续的doBind操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// AbstractBootstrap
private static void doBind0(
        final ChannelFuture regFuture, final Channel channel,
        final SocketAddress localAddress, final ChannelPromise promise) {
    // doBind0向EventLoop任务队列中添加一个bind任务来完成后续操作。
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                // bind操作
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            }
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bind操作-1&quot;&gt;bind操作&lt;/h3&gt;
&lt;p&gt;在回顾上面的bind操作代码，bind操作是在register之后进行的，因为register0是由NioEventLoop执行的，所以main线程需要先判断下future是否完成，如果完成直接进行doBind即可，否则添加listener回调进行doBind。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibNZvHljNHL0XBElMznic1a9JzOa49OlDynOwKzMJ4L6DqJFfkic2pXLQfNL4jiaibNC4HmLiaZyzertibzg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bind操作及后续初始化操作（channelActive回调、设置监听事件）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
    boolean wasActive = isActive();
    try {
        // 调用底层bind操作
        doBind(localAddress);
    } catch (Throwable t) {
        safeSetFailure(promise, t);
        closeIfClosed();
        return;
    }

    if (!wasActive &amp;amp;&amp;amp; isActive()) {
        invokeLater(new Runnable() {
            @Override
            public void run() {
                pipeline.fireChannelActive();
            }
        });
    }
    safeSetSuccess(promise);
}

// 最后底层bind逻辑bind入参包括了backlog，也就是底层会进行listen操作
// DefaultChannelPipeline.headContext -&amp;gt; NioMessageUnsafe -&amp;gt; NioServerSocketChannel
protected void doBind(SocketAddress localAddress) throws Exception {
    if (PlatformDependent.javaVersion() &amp;gt;= 7) {
        javaChannel().bind(localAddress, config.getBacklog());
    } else {
        javaChannel().socket().bind(localAddress, config.getBacklog());
    }
}

public void channelActive(ChannelHandlerContext ctx) throws Exception {
    // 回调fireChannelActive
    ctx.fireChannelActive();
    
    // 设置selectKey监听事件，对于监听端口就是SelectionKey.OP_ACCEPT，对于新建连接就是SelectionKey.OP_READ
    readIfIsAutoRead();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里为止整个netty启动流程就基本接近尾声，可以对外提供服务了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;推荐阅读&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;欢迎小伙伴&lt;strong&gt;关注【TopCoder】&lt;/strong&gt;阅读更多精彩好文。&lt;br/&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibP4TMsUhZhl8N3f7mphlhYMhnu8RbooMP7Ab6UbHF4BITSCe6D8hPy3VyzTu2Yp23vRRRTzJj8AQg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 00:05:00 +0000</pubDate>
<dc:creator>luoxn28</dc:creator>
<og:description>编者注：Netty是Java领域有名的开源网络库，特点是高性能和高扩展性，因此很多流行的框架都是基于它来构建的，比如我们熟知的Dubbo、Rocketmq、Hadoop等，针对高性能RPC，一般都是基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luoxn28/p/11839293.html</dc:identifier>
</item>
<item>
<title>[springboot 开发单体web shop] 5. 用户登录及首页展示 - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11839530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11839530.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;用户登录&quot;&gt;用户登录&lt;/h2&gt;
&lt;p&gt;在之前的文章中我们实现了用户注册和验证功能，接下来我们继续实现它的登录，以及登录成功之后要在页面上显示的信息。&lt;br/&gt;接下来，我们来编写代码。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;实现service&quot;&gt;实现service&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;com.liferunner.service.IUserService&lt;/code&gt;接口中添加用户登录方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IUserService {
    ...
    /**
     * 用户登录
     * @param userRequestDTO 请求dto
     * @return 登录用户信息
     * @throws Exception
     */
    Users userLogin(UserRequestDTO userRequestDTO) throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在&lt;code&gt;com.liferunner.service.impl.UserServiceImpl&lt;/code&gt;实现类中实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class UserServiceImpl implements IUserService {
    ...
    @Override
    public Users userLogin(UserRequestDTO userRequestDTO) throws Exception {
        log.info(&quot;======用户登录请求：{}&quot;, userRequestDTO);
        Example example = new Example(Users.class);
        val condition = example.createCriteria();
        condition.andEqualTo(&quot;username&quot;, userRequestDTO.getUsername());
        condition.andEqualTo(&quot;password&quot;, MD5GeneratorTools.getMD5Str(userRequestDTO.getPassword()));
        val user = this.usersMapper.selectOneByExample(example);
        log.info(&quot;======用户登录处理结果：{}&quot;, user);
        return user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Error Tips：&lt;/strong&gt;&lt;br/&gt;这里有一个小小的&lt;code&gt;坑点&lt;/code&gt;，大家一定要注意，在使用&lt;code&gt;selectOneByExample()&lt;/code&gt;查询的时候,该方法传入的参数一定注意是&lt;code&gt;tk.mybatis.mapper.entity.Example&lt;/code&gt;实例，而不是&lt;code&gt;tk.mybatis.mapper.entity.Example.Criteria&lt;/code&gt;,否则会报动态SQL生成查询错误，信息如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'distinct' in 'class tk.mybatis.mapper.entity.Example$Criteria'
  at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:92)
  at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:440)
  at com.sun.proxy.$Proxy106.selectOne(Unknown Source)
  at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:159)
  at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87)
  at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:93)
  at com.sun.proxy.$Proxy109.selectOneByExample(Unknown Source)
  at com.liferunner.service.impl.UserServiceImpl.userLogin(UserServiceImpl.java:80)
  ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新人在写代码的时候，特别容易在上一行写了查询变量，下一行就直接开用了，越是简单的错误越是让人无从下手。&lt;/p&gt;
&lt;h3 id=&quot;实现controller&quot;&gt;实现Controller&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(value = &quot;/users&quot;)
@Slf4j
@Api(tags = &quot;用户管理&quot;)
public class UserController {
    ...
    @ApiOperation(value = &quot;用户登录&quot;, notes = &quot;用户登录接口&quot;)
    @PostMapping(&quot;/login&quot;)
    public JsonResponse userLogin(@RequestBody UserRequestDTO userRequestDTO,
                                  HttpServletRequest request,
                                  HttpServletResponse response) {
        try {
            if (StringUtils.isBlank(userRequestDTO.getUsername()))
                return JsonResponse.errorMsg(&quot;用户名不能为空&quot;);
            if (StringUtils.isBlank(userRequestDTO.getPassword()) ||
                    userRequestDTO.getPassword().length() &amp;lt; 8) {
                return JsonResponse.errorMsg(&quot;密码为空或长度小于8位&quot;);
            }
            val user = this.userService.userLogin(userRequestDTO);
            UserResponseDTO userResponseDTO = new UserResponseDTO();
            BeanUtils.copyProperties(user, userResponseDTO);
            log.info(&quot;BeanUtils copy object {}&quot;, userResponseDTO);
            if (null != userResponseDTO) {
                // 设置前端存储的cookie信息
                CookieTools.setCookie(request, response, &quot;user&quot;,
                        JSON.toJSONString(userResponseDTO), true);
                return JsonResponse.ok(userResponseDTO);
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.error(&quot;用户登录失败,{},exception = {}&quot;, userRequestDTO, e.getMessage());
        }
        return JsonResponse.errorMsg(&quot;用户登录失败&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，基本校验问题就不再赘述，我们主要关注几点新的特性信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;com.liferunner.dto.UserResponseDTO&lt;/code&gt; 将我们需要展示给前端的数据封装为一个新的返回对象，我们从数据库中查询出来的&lt;code&gt;Users&lt;/code&gt;pojo包含用户的所有数据，比如其中的&lt;code&gt;password&lt;/code&gt;、&lt;code&gt;mobile&lt;/code&gt;等等一些用户私密的数据是不应该展示给前端的，即便要展示，那也是需要经过脱敏以及加密。因此，常见的做法就是封装一个新的返回对象，其中只需要包含前端需要的数据字段就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@ApiModel(value = &quot;用户信息返回DTO&quot;, description = &quot;用户登录成功后需要的返回对象&quot;)
public class UserResponseDTO {
    /**
     * 主键id
     */
    private String id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 昵称 昵称
     */
    private String nickname;

    /**
     * 头像
     */
    private String face;

    /**
     * 性别  1:男  0:女  2:保密
     */
    private Integer sex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里建议大家使用&lt;code&gt;Ctrl+C&lt;/code&gt;我们的&lt;code&gt;com.liferunner.pojo.Users&lt;/code&gt;对象，然后删除掉我们不需要的字段就可以了，为什么这么&lt;code&gt;建议&lt;/code&gt;呢，是因为下一个好处啦。&lt;/p&gt;
&lt;ul readability=&quot;8.4270177447052&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;org.springframework.beans.BeanUtils.copyProperties(user, userResponseDTO);&lt;/code&gt;&lt;br/&gt;大家可以看到，这里直接使用的是&lt;code&gt;Spring BeanUtils&lt;/code&gt;工具类进行的值拷贝，就减少了我们循环遍历每一个字段去挨个赋值&lt;code&gt;(SetValue)&lt;/code&gt;的工作。（也是一种偷懒小技巧哦，这样是不对的～）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.9290444654683&quot;&gt;
&lt;p&gt;&lt;code&gt;CookieTools.setCookie();&lt;/code&gt;&lt;br/&gt;之前我们有提过，一般情况下，我们用户登录之后，数据都会被存储在本地浏览器&lt;code&gt;Cookie&lt;/code&gt;中,比如我登录的&lt;code&gt;baidu.com&lt;/code&gt;:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075906009-909346891.png&quot; alt=&quot;baidu&quot;/&gt;&lt;br/&gt;此时，鼠标在图片中左侧的&lt;code&gt;Cookies =&amp;gt; www.baidu.com&lt;/code&gt;右键&lt;code&gt;clear&lt;/code&gt;,然后再次刷新我们当前界面，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075907044-1713450539.png&quot; alt=&quot;clear cookies&quot;/&gt;&lt;br/&gt;我们可以看到，从登录状态已经变为退出状态了，并且&lt;code&gt;Cookies&lt;/code&gt;中的内容也少了很多，这就说明，百度是把我们的用户登录信息加密后存储在了浏览器cookie中。&lt;br/&gt;大家可以查看京东，淘宝等等，也是基于这种方式实现的，开篇之初就说过，我们的系统是基于生产来实现的demo,那么我们就是用主流的实现方法来做。当然，有的同学会说，这个应该我们把数据传递给前端，让前端来实现的！！！当然，你说的对，可是我们掌握一种实现方式，对于我们个人而言应该是没有坏处的吧？&lt;br/&gt;这里就需要一个工具类了，大家可以在&lt;a href=&quot;https://github.com/Isaac-Zhang/expensive-shop&quot;&gt;github传送门&lt;/a&gt;来下载相关代码。目录&lt;code&gt;com.liferunner.utils.CookieTools&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;com.alibaba.fastjson.JSON.toJSONString(userResponseDTO)&lt;/code&gt;&lt;br/&gt;因为我们要返回的是一个对象，但是&lt;code&gt;cookie&lt;/code&gt;中我们需要放入的是&lt;code&gt;String&lt;/code&gt;,这里我们引入了alibaba的JSON工具，在&lt;code&gt;mscx-shop-common/pom.xml&lt;/code&gt;,加入依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.2.56&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用户登出&quot;&gt;用户登出&lt;/h2&gt;
&lt;p&gt;在用户操作结束之后，我们需要将用户从系统中退出登录，因为我们的用户登录信息会存储在浏览器cookie中，因此，我们需要根据用户的登出操作来删除相关用户缓存:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @ApiOperation(value = &quot;用户登出&quot;,notes = &quot;用户登出&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/logout&quot;)
    public JsonResponse userLogout(@RequestParam String uid,
        HttpServletRequest request,HttpServletResponse response){
        // clear front's user cookies
        CookieTools.deleteCookie(request,response,&quot;user&quot;);
        // return operational result
        return JsonResponse.ok();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开发调试小福利&quot;&gt;开发调试小福利&lt;/h2&gt;
&lt;h3 id=&quot;java日志追踪&quot;&gt;java日志追踪&lt;/h3&gt;
&lt;p&gt;一般在电商场景中，对于请求的响应时间有着极其严格的要求，比如你在一个网站买商品的时候，如果每点击一次按钮都要等待，或者系统感觉卡顿一下，你会毫不犹豫的选择右上角的&lt;code&gt;小红叉&lt;/code&gt;，把它干掉。因此，在我们系统的开发过程中，很多时候需要对我们的请求响应时间进行监控，甚至会通过压力测试来进行测试。但是，让我们在每一个方法中都做这种请求的实现，显然是不合理甚至说是让开发人员难受的，所以，我们来实现一种通用的做法，那就是通过&lt;code&gt;AOP&lt;/code&gt;，面向切面来实现。关于切面的基本使用，大家可以参考&lt;a href=&quot;https://www.cnblogs.com/xrq730/p/4919025.html&quot;&gt;AOP传送门&lt;/a&gt;，接下来，开始我们的编码。&lt;br/&gt;根据&lt;code&gt;springboot&lt;/code&gt;实现功能三部曲：&lt;br/&gt;setp 1. 添加依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;step 2. 启动配置（没有就忽略掉这一步）&lt;br/&gt;setp 3. 加注解&lt;br/&gt;在我们的&lt;code&gt;mscx-shop-api&lt;/code&gt;项目中，创建&lt;code&gt;com.liferunner.api.aspect&lt;/code&gt;package,然后创建&lt;code&gt;com.liferunner.api.aspect.CommonLogAspect&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.liferunner.api.aspect;

import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import java.util.Date;

/**
 * CommonLogAspect for : AOP切面实现日志确认
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 * @since 2019/11/11
 */
@Component
@Aspect
@Slf4j
public class CommonLogAspect {

    @Around(&quot;execution(* com.liferunner.api.controller..*.*(..))&quot;)
    public void recordLogTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info(&quot;----------- {}.{} process log time started.---------------&quot;,
                proceedingJoinPoint.getTarget().getClass(),
                proceedingJoinPoint.getSignature().getName());

        val startTime = System.currentTimeMillis();
        proceedingJoinPoint.proceed();
        val afterTime = System.currentTimeMillis();
        if (afterTime - startTime &amp;gt; 1000) {
            log.warn(&quot;cost : {}&quot;, afterTime - startTime);
        } else {
            log.info(&quot;cost : {}&quot;, afterTime - startTime);
        }

        log.info(&quot;----------- {}.{} process log time ended.---------------&quot;,
                proceedingJoinPoint.getSourceLocation().getClass(),
                proceedingJoinPoint.getSignature().getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第一行日志代表我们想要监控的是哪个类的哪个方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proceedingJoinPoint.proceed();&lt;/code&gt;表示方法执行&lt;/li&gt;
&lt;li&gt;当请求查过1000ms的时候，我们使用&lt;code&gt;log.warn(...)&lt;/code&gt;进行日志告警&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;step 4. 效果演示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询用户耗时&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075915818-2028908820.jpg&quot; alt=&quot;get&quot;/&gt;&lt;/li&gt;
&lt;li&gt;注册用户耗时&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075916887-236777661.png&quot; alt=&quot;insert&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上图，我们明显能看出来我们每一次的请求耗时，之后就可以针对性的对每一个方法进行优化！！！&lt;/p&gt;
&lt;h3 id=&quot;sql日志追踪&quot;&gt;sql日志追踪&lt;/h3&gt;
&lt;p&gt;在我们开发的过程中，往往会遇到针对数据库的&lt;code&gt;CRUD&lt;/code&gt;的操作，但是，因为我们使用了&lt;code&gt;mybatis&lt;/code&gt; 动态生成了简单的SQL查询，而不是手动编写的，比如我们在&lt;code&gt;UserServiceImpl.java&lt;/code&gt;中实现的用户查询以及用户注册代码中的&lt;code&gt;tk.mybatis.mapper.entity.Example&lt;/code&gt; 以及 &lt;code&gt;this.usersMapper.insertSelective(user);&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public Users findUserByUserName(String username) {
        // 构建查询条件
        Example example = new Example(Users.class);
        val condition = example.createCriteria()
                .andEqualTo(&quot;username&quot;, username);
        return this.usersMapper.selectOneByExample(example);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    @Override
    public Users createUser(UserRequestDTO userRequestDTO) throws Exception {
        log.info(&quot;======begin create user : {}=======&quot;, userRequestDTO);
        val user = Users.builder()
                .id(sid.next()) //生成分布式id
                .username(userRequestDTO.getUsername())
                .password(MD5GeneratorTools.getMD5Str(userRequestDTO.getPassword()))
                .birthday(DateUtils.parseDate(&quot;1970-01-01&quot;, &quot;yyyy-MM-dd&quot;))
                .nickname(userRequestDTO.getUsername())
                .face(this.FACE_IMG)
                .sex(SexEnum.secret.type)
                .createdTime(new Date())
                .updatedTime(new Date())
                .build();
        this.usersMapper.insertSelective(user);
        log.info(&quot;======end create user : {}=======&quot;, userRequestDTO);
        return user;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦遇到了问题之后，我们往往不知道到底是哪里出现了错误，这个时候我们的&lt;code&gt;SQL&lt;/code&gt;是否有问题我们也不知道，因此，接下来我们来配置一种可以让我们&lt;code&gt;看&lt;/code&gt;到SQL的小实现：&lt;/p&gt;
&lt;p&gt;1.设置日志配置(如图)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075917337-1931016139.png&quot; alt=&quot;log4j.properties&quot;/&gt;&lt;br/&gt;2.修改mybatis配置（&lt;code&gt;log-impl: org.apache.ibatis.logging.stdout.StdOutImpl&lt;/code&gt;）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075918122-2060260715.png&quot; alt=&quot;mybatis&quot;/&gt;&lt;br/&gt;3.&lt;code&gt;SELECT&lt;/code&gt;效果演示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075919955-1691465114.png&quot; alt=&quot;result&quot;/&gt;&lt;br/&gt;4.&lt;code&gt;INSERT&lt;/code&gt;效果演示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191112075921067-140426759.png&quot; alt=&quot;INSERT&quot;/&gt;&lt;br/&gt;从上图可以看出控制台JDBC操作进行了2次，其实第一次是对我们的用户名进行校验。第二次&lt;code&gt;INSERT&lt;/code&gt;是真实的插入。&lt;/p&gt;
&lt;p&gt;通过上面的演示结果，大家可以想到，这个日志针在我们日常的开发中解决问题是非常有必要的。但是一定记得，在上生产的时候，日志一定要关闭，否则数据量一旦大了之后，会对系统的性能造成严重伤害！！！&lt;/p&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;源码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Isaac-Zhang/expensive-shop&quot;&gt;Github 传送门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://gitee.com/IsaacZhang/expensive-shop&quot;&gt;Gitee 传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;下节预告&quot;&gt;下节预告&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;下一节我们将继续开发我们电商的核心部分-商品以及广告的展示，在过程中使用到的任何开发组件，我都会通过专门的一节来进行介绍的，兄弟们末慌！&lt;/p&gt;
&lt;p&gt;gogogo！&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 23:59:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>[TOC] 用户登录 在之前的文章中我们实现了用户注册和验证功能，接下来我们继续实现它的登录，以及登录成功之后要在页面上显示的信息。 接下来，我们来编写代码。 实现service 在 接口中添加用户登</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11839530.html</dc:identifier>
</item>
<item>
<title>数据同步的一些思考与改进 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/11839520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/11839520.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;闲的没事,自己写了个小网站,搭建在自己国外的VPS上,VPS内存极小(512M),而且还要跑点别的(你懂的),内存更紧张巴巴. 改造之前小网站用到了时髦的Redis,Rabbmitmq,Mysql,那时候阿里云的学生主机内存富足,装这么多中间件压力不大,可到了这样的小内存VPS上,一切都变得水土不服,索性啥中间件都不要了,数据库也不要了.&lt;br/&gt;没了数据库,网站的数据从哪里来?存在哪里? 文本形式持久化到本地磁盘?&lt;br/&gt;国外的VPS不比国内,可能哪天说不能访问就不能访问了,VPS的磁盘存储显然不踏实.&lt;br/&gt;同事给我建议了万能的Github,听过Github托管代码📜,托管静态页面🔮,托管女装大佬💃,但托管网站数据倒是第一次听说,于是我对网站架构进行了重新设计.&lt;/p&gt;
&lt;h3 id=&quot;plan1-数据的同步&quot;&gt;Plan1 数据的同步&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/iblogs.site/datasync.png&quot; alt=&quot;users&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小网站数据不多,10M左右,所有数据直接加载到内存中服务器也不会吃力,网站启动,自动从Github Clone数据,并定期把内存中的数据序列化后Push到Github.&lt;br/&gt;可以看到,整个过程中,好像没有磁盘啥事了,在我的眼里,Github就是一块延时略高的磁盘(其实延时也还好,国外的Github访问速度飞快).&lt;/p&gt;
&lt;h3 id=&quot;plan2-同步的频率&quot;&gt;Plan2 同步的频率&lt;/h3&gt;
&lt;p&gt;磁盘的读取速度和内存无法比,何况远程的Github,那么如果减少数据从内存到Github的同步开销呢?显然就是减少同步的频率.&lt;br/&gt;一小时同步一次,应该够了.&lt;br/&gt;但如果我的网站在这一小时挂了boom🌋,而数据还没来得及同步,那上次一同步到网站挂掉这个时间段内的数据不就没了吗?细思极恐😱!&lt;/p&gt;
&lt;h3 id=&quot;plan3-多多不益善&quot;&gt;Plan3 多多不益善&lt;/h3&gt;
&lt;p&gt;既然一小时一次不安全,那就一分钟同步一次!&lt;br/&gt;其实这样也是有问题的,小网站一般都是无人问津,如果以较高的频率进行数据同步,可以说绝大多数(用互联网的所法是百分之N个9)的数据同步都是没意义的,同时还增大了数据的同步开销,没准Github还会把我的账号给封了.&lt;/p&gt;
&lt;h3 id=&quot;plan4-内存数据变更立即触发数据同步&quot;&gt;Plan4 内存数据变更立即触发数据同步&lt;/h3&gt;
&lt;p&gt;在我的网站中,有统一的数据访问层,只要数据访问层中的insert,update,delete处加入数据同步事件,即可实现一旦更新立即同步.&lt;br/&gt;这样是数据是安全了,可是一次访问请求往往伴随着多次数据更新,每更新一次同步一次,可能是最脑残🙈的做法吧.&lt;/p&gt;
&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;数据更改一次同步一次不合理,同步频率太低数据不安全,频率太高多数同步没有意义,到底该怎样呢?&lt;/p&gt;
&lt;h2 id=&quot;局部性原理&quot;&gt;局部性原理&lt;/h2&gt;
&lt;p&gt;在揭开我的设计方案前,我们先来过一下CPU访问存储器时所遵守的局部性原理.&lt;/p&gt;
&lt;p&gt;在计算机存储介质这个金字塔中,越靠近金字塔顶端,空间越小,但是读取数据越快;越靠近金字塔底端,空间越大,但访问速度也越慢.&lt;br/&gt;正式因为这样,所以每次自下而上的数据数据流大小逐层递增, 交换频率逐层递减,如何在时间与空间上取到平衡点是关键.&lt;br/&gt;于是有了空间局部性原理和时间局部性原理,力求让计算机的数据流动更高效.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/iblogs.site/memory-hierarchy.png&quot; alt=&quot;users&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;空间局部性&quot;&gt;空间局部性&lt;/h3&gt;
&lt;p&gt;如果一条数据被访问,那么与它临近的数据也可能要被用到. 比如数组,你访问了索引1上的数据,那么1附近的数据当然很有可能被访问,所以这个时候干脆把1附近的数据也往上加载一个层级.&lt;/p&gt;
&lt;h3 id=&quot;时间局部性&quot;&gt;时间局部性&lt;/h3&gt;
&lt;p&gt;如果一条数据项正在被访问，那么在近期它很可能还会被再次访问,所以这个时候干脆就把它留在当前层级,先不急着回收掉.&lt;/p&gt;
&lt;p&gt;而网站的数据的更新也是具有时间局部性的,像我这样并冷门的网站,基本没人访问,但是一旦访问了,立即就要进行点击量的更新,站点响应速度的记录,没准又会有评论留言,然后要通知管理员进行留言审核.这大概就是不鸣则已,一鸣惊人,一次访问短期内往往立即触发一连串的数据更新,我认为这也是一种时间局部性.&lt;/p&gt;
&lt;p&gt;所以,在数据同步上,我设计了如下方案.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;另起一个线程作为定时任务,主要负责定时数据同步&lt;/li&gt;
&lt;li&gt;正常情况下,每小时与Github进行数据同步.&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一旦网站数据被更新,检查剩余同步时间是否大于30秒.&lt;br/&gt;** 如果大于三十秒,强行把计时器剩余时间设置为30秒.&lt;br/&gt;** 如果小于三十秒,不做操作.&lt;/li&gt;
&lt;li&gt;计时器时间走完,立即同步数据到Github.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;定时沙漏&quot;&gt;定时沙漏⏳&lt;/h2&gt;
&lt;p&gt;原本文章说到这里就可以结束了,但程序员注定爱代码爱过文字,又恰好我天生爱造轮子,我从令牌桶得到灵感设计了一个乞丐版沙&lt;code&gt;漏计时器&lt;/code&gt;,可以用于任何定时任务的执行,班门弄斧,欢迎提出改进意见.&lt;/p&gt;
&lt;h2 id=&quot;show-time&quot;&gt;Show time&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class BlogsTimer
{
    private static Stack&amp;lt;int&amp;gt; _upFunnel;  //沙漏上部分
    private static Stack&amp;lt;int&amp;gt; _downFunnel;  //沙漏下部分
    private static readonly List&amp;lt;Action&amp;gt; TimerEvents;  //定时执行的事件
    private static bool _timerSwitch;  //沙漏开关
    private static readonly int Speed;  //每秒消费令牌数量
    private static Thread _timerThread;
    private static readonly object TimerLock;
    static BlogsTimer()
    {
        _upFunnel = new Stack&amp;lt;int&amp;gt;();
        _downFunnel = new Stack&amp;lt;int&amp;gt;();
        Speed = 1 * 1000;
        TimerEvents = new List&amp;lt;Action&amp;gt;();
        TimerLock = new object();
    }
    //计时器开始
    public static void Start(TimeSpan timeSpan)
    {
        lock (TimerLock)
        {
            _upFunnel.Clear();
            _downFunnel.Clear();
            for (var i = 0; i &amp;lt; timeSpan.TotalSeconds; i++)
            {
                _upFunnel.Push(i);
            }
        }
        _timerSwitch = true;
        _timerThread = new Thread(Consume); //起一个线程消费桶里的令牌
        _timerThread.Start();
        LunchEvents(); // 触发事件
    }
    public static void Stop()
    {
        _timerSwitch = false;
    }

    //给沙漏注册定时执行事件
    public static void Register(Action timeEvent)
    {
        TimerEvents.Add(timeEvent);
        timeEvent.Invoke();
    }

    //把沙漏加速到指定的时间
    public static void AccelerateTo(TimeSpan timeSpan)
    {
        var accelerateSeconds = timeSpan.TotalSeconds;
        lock (TimerLock)
        {
            if (_upFunnel.Count &amp;lt; accelerateSeconds) //当前沙漏中剩余令牌小于设置中秒数,则返回不加速
                return;
            while (_upFunnel.Count &amp;gt; accelerateSeconds &amp;amp;&amp;amp; _upFunnel.Count &amp;gt; 1)  //令牌数大于秒数,则释放出多余令牌
            {
                _downFunnel.Push(_upFunnel.Pop());
            }
        }
    }
    private static void LunchEvents()
    {
        TimerEvents.ForEach(a =&amp;gt; a.Invoke());
    }
    private static void Consume()
    {
        while (_timerSwitch)
        {
            lock (TimerLock)
            {
                if (_upFunnel.TryPop(out var item))
                {
                    _downFunnel.Push(item);
                }
                else
                {
                    LunchEvents();
                    var tempStack = _downFunnel;  //旋转沙漏
                    _downFunnel = _upFunnel;
                    _upFunnel = tempStack;
                }
            }
            Thread.Sleep(Speed);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码地址: &lt;a href=&quot;https://github.com/liuzhenyulive/iBlogs/blob/master/Src/iBlogs.Site.Core/Common/iBlogsTimer.cs&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/iBlogs/blob/master/Src/iBlogs.Site.Core/Common/iBlogsTimer.cs&lt;/a&gt;&lt;br/&gt;演示地址: &lt;a href=&quot;https://www.iblogs.site&quot; class=&quot;uri&quot;&gt;https://www.iblogs.site&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 23:52:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>数据同步的一些思考与改进 背景 闲的没事,自己写了个小网站,搭建在自己国外的VPS上,VPS内存极小(512M),而且还要跑点别的(你懂的),内存更紧张巴巴. 改造之前小网站用到了时髦的Redis,R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoderAyu/p/11839520.html</dc:identifier>
</item>
<item>
<title>Java Stream函数式编程第三篇：管道流结果处理 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11839517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11839517.html</guid>
<description>&lt;h2 id=&quot;一java-stream管道数据处理操作&quot;&gt;一、Java Stream管道数据处理操作&lt;/h2&gt;
&lt;p&gt;在本号之前写过的文章中，曾经给大家介绍过 Java Stream管道流是用于简化集合类元素处理的java API。在使用的过程中分为三个阶段。在开始本文之前，我觉得仍然需要给一些新朋友介绍一下这三个阶段，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191112074737235-2125907225.jpg&quot; alt=&quot;Java Stream函数式编程？用过都说好，案例图文详解送给你&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一阶段(图中蓝色)：将集合、数组、或行文本文件转换为java Stream管道流&lt;/li&gt;
&lt;li&gt;第二阶段(图中虚线部分)：管道流式数据处理操作，处理管道中的每一个元素。上一个管道中的输出元素作为下一个管道的输入元素。&lt;/li&gt;
&lt;li&gt;第三阶段(图中绿色)：管道流结果处理操作，也就是本文的将介绍的核心内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开始学习之前，仍然有必要回顾一下我们之前给大家讲过的一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
List&amp;lt;String&amp;gt; nameStrs = Arrays.asList(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;,&quot;Lemur&quot;);

List&amp;lt;String&amp;gt; list = nameStrs.stream()
        .filter(s -&amp;gt; s.startsWith(&quot;L&quot;))
        .map(String::toUpperCase)
        .sorted()
        .collect(toList());
System.out.println(list);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先使用stream()方法将字符串List转换为管道流Stream&lt;/li&gt;
&lt;li&gt;然后进行管道数据处理操作，先用fliter函数过滤所有大写L开头的字符串，然后将管道中的字符串转换为大写字母toUpperCase，然后调用sorted方法排序。这些API的用法在本号之前的文章有介绍过。其中还使用到了lambda表达式和函数引用。&lt;/li&gt;
&lt;li&gt;最后使用collect函数进行结果处理，将java Stream管道流转换为List。最终list的输出结果是:&lt;code&gt;[LEMUR, LION]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你不使用java Stream管道流的话，想一想你需要多少行代码完成上面的功能呢？回到正题，这篇文章就是要给大家介绍第三阶段：对管道流处理结果都可以做哪些操作呢？下面开始吧！&lt;/p&gt;
&lt;h2 id=&quot;二foreach和foreachordered&quot;&gt;二、ForEach和ForEachOrdered&lt;/h2&gt;
&lt;p&gt;如果我们只是希望将Stream管道流的处理结果打印出来，而不是进行类型转换，我们就可以使用forEach()方法或forEachOrdered()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Stream.of(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;)
        .parallel()
        .forEach(System.out::println);
Stream.of(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;)
        .parallel()
        .forEachOrdered(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;parallel()函数表示对管道中的元素进行并行处理，而不是串行处理，这样处理速度更快。但是这样就有可能导致管道流中后面的元素先处理，前面的元素后处理，也就是元素的顺序无法保证&lt;/li&gt;
&lt;li&gt;forEachOrdered从名字上看就可以理解，虽然在数据处理顺序上可能无法保障，但是forEachOrdered方法可以在元素输出的顺序上保证与元素进入管道流的顺序一致。也就是下面的样子（forEach方法则无法保证这个顺序）：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Monkey
Lion
Giraffe
Lemur
Lion&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三元素的收集collect&quot;&gt;三、元素的收集collect&lt;/h2&gt;
&lt;p&gt;java Stream 最常见的用法就是：一将集合类转换成管道流，二对管道流数据处理，三将管道流处理结果在转换成集合类。那么collect()方法就为我们提供了这样的功能：将管道流处理结果在转换成集合类。&lt;/p&gt;
&lt;h3 id=&quot;收集为set&quot;&gt;3.1.收集为Set&lt;/h3&gt;
&lt;p&gt;通过Collectors.toSet()方法收集Stream的处理结果，将所有元素收集到Set集合中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Set&amp;lt;String&amp;gt; collectToSet = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
) 
.collect(Collectors.toSet());

//最终collectToSet 中的元素是:[Monkey, Lion, Giraffe, Lemur]，注意Set会去重。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;收集到list&quot;&gt;3.2.收集到List&lt;/h3&gt;
&lt;p&gt;同样，可以将元素收集到&lt;code&gt;List&lt;/code&gt;使用&lt;code&gt;toList()&lt;/code&gt;收集器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
List&amp;lt;String&amp;gt; collectToList = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
).collect(Collectors.toList());

// 最终collectToList中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通用的收集方式&quot;&gt;3.3.通用的收集方式&lt;/h3&gt;
&lt;p&gt;上面为大家介绍的元素收集方式，都是专用的。比如使用Collectors.toSet()收集为Set类型集合；使用Collectors.toList()收集为List类型集合。那么，有没有一种比较通用的数据元素收集方式，将数据收集为任意的Collection接口子类型。&lt;br/&gt;所以，这里就像大家介绍一种通用的元素收集方式，你可以将数据元素收集到任意的Collection类型：即向所需Collection类型提供构造函数的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
LinkedList&amp;lt;String&amp;gt; collectToCollection = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
).collect(Collectors.toCollection(LinkedList::new));

//最终collectToCollection中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：代码中使用了LinkedList::new，实际是调用LinkedList的构造函数，将元素收集到Linked List。当然你还可以使用诸如&lt;code&gt;LinkedHashSet::new&lt;/code&gt;和&lt;code&gt;PriorityQueue::new&lt;/code&gt;将数据元素收集为其他的集合类型，这样就比较通用了。&lt;/p&gt;
&lt;h3 id=&quot;收集到array&quot;&gt;3.4.收集到Array&lt;/h3&gt;
&lt;p&gt;通过toArray(String[]::new)方法收集Stream的处理结果，将所有元素收集到字符串数组中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
String[] toArray = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
) .toArray(String[]::new);

//最终toArray字符串数组中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;收集到map&quot;&gt;3.5.收集到Map&lt;/h3&gt;
&lt;p&gt;使用Collectors.toMap()方法将数据元素收集到Map里面，但是出现一个问题：那就是管道中的元素是作为key，还是作为value。我们用到了一个Function.identity()方法，该方法很简单就是返回一个“ t -&amp;gt; t ”（输入就是输出的lambda表达式）。另外使用管道流处理函数&lt;code&gt;distinct()&lt;/code&gt;来确保Map键值的唯一性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Map&amp;lt;String, Integer&amp;gt; toMap = Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
)
.distinct()
.collect(Collectors.toMap(
       Function.identity(),   //元素输入就是输出，作为key
       s -&amp;gt; (int) s.chars().distinct().count()// 输入元素的不同的字母个数，作为value
));

// 最终toMap的结果是: {Monkey=6, Lion=4, Lemur=5, Giraffe=6}   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分组收集groupingby&quot;&gt;3.6.分组收集groupingBy&lt;/h3&gt;
&lt;p&gt;Collectors.groupingBy用来实现元素的分组收集，下面的代码演示如何根据首字母将不同的数据元素收集到不同的List，并封装为Map。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Map&amp;lt;Character, List&amp;lt;String&amp;gt;&amp;gt; groupingByList =  Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
)
.collect(Collectors.groupingBy(
       s -&amp;gt; s.charAt(0) ,  //根据元素首字母分组，相同的在一组
       // counting()        // 加上这一行代码可以实现分组统计
));

// 最终groupingByList内的元素: {G=[Giraffe], L=[Lion, Lemur, Lion], M=[Monkey]}
//如果加上counting() ，结果是:  {G=1, L=3, M=1}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四其他常用方法&quot;&gt;四、其他常用方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
boolean containsTwo = IntStream.of(1, 2, 3).anyMatch(i -&amp;gt; i == 2);
// 判断管道中是否包含2，结果是: true

long nrOfAnimals = Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;
).count();
// 管道中元素数据总计结果nrOfAnimals: 4


int sum = IntStream.of(1, 2, 3).sum();
// 管道中元素数据累加结果sum: 6


OptionalDouble average = IntStream.of(1, 2, 3).average();
//管道中元素数据平均值average: OptionalDouble[2.0]



int max = IntStream.of(1, 2, 3).max().orElse(0);
//管道中元素数据最大值max: 3



IntSummaryStatistics statistics = IntStream.of(1, 2, 3).summaryStatistics();
// 全面的统计结果statistics: IntSummaryStatistics{count=3, sum=6, min=1, average=2.000000, max=3}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Mon, 11 Nov 2019 23:48:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、Java Stream管道数据处理操作 在本号之前写过的文章中，曾经给大家介绍过 Java Stream管道流是用于简化集合类元素处理的java API。在使用的过程中分为三个阶段。在开始本文之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11839517.html</dc:identifier>
</item>
</channel>
</rss>