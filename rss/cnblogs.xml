<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# List引用类型的克隆 - 陈国良</title>
<link>http://www.cnblogs.com/cglandy/p/10301548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cglandy/p/10301548.html</guid>
<description>&lt;p&gt;有时候我们想克隆一个List去做别的事，而不影响原来的List,我们直接在list后面加上小点点，发现并没有Clone这样的扩展函数。这时候就只有自己扩展了。&lt;/p&gt;
&lt;p&gt;尝试了三种方式，测试都通过了，至于性能方面我还没有做测试。&lt;/p&gt;
&lt;p&gt;一、反射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt; list) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             List&amp;lt;T&amp;gt; items = &lt;span&gt;new&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; model = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ps =&lt;span&gt; model.GetType().GetProperties();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; m.GetType().GetProperties();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; pm &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ps)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (pm.Name ==&lt;span&gt; p.Name)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                            pm.SetValue(model, p.GetValue(m));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                items.Add(model);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; items;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、序列化（依赖Newtonsoft.Json)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt; list) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; str =&lt;span&gt; JsonConvert.SerializeObject(list);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;(str);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、序列化（BinaryFormatter）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (Stream objectStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 IFormatter formatter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryFormatter();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                formatter.Serialize(objectStream, list);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 objectStream.Seek(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SeekOrigin.Begin);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; (List&amp;lt;T&amp;gt;&lt;span&gt;)formatter.Deserialize(objectStream);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     List&amp;lt;NormalSetting&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;NormalSetting&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     list.Add(&lt;span&gt;new&lt;/span&gt; NormalSetting { RedisIp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     List&amp;lt;NormalSetting&amp;gt; items =&lt;span&gt; list.Clone();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     list[&lt;span&gt;0&lt;/span&gt;].RedisIp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     logMessager.Show(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, list[&lt;span&gt;0&lt;/span&gt;].RedisIp, items[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].RedisIp);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43951/201901/43951-20190121232623391-232085980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;第一种方式无需任何依赖。&lt;/p&gt;
&lt;p&gt;第二种方式需要Newtonsoft.Json，如果项目中没有用到它，不推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;第三种方式序要给引用类型实体加上[Serializable]特性&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 15:30:00 +0000</pubDate>
<dc:creator>陈国良</dc:creator>
<og:description>有时候我们想克隆一个List去做别的事，而不影响原来的List,我们直接在list后面加上小点点，发现并没有Clone这样的扩展函数。这时候就只有自己扩展了。 尝试了三种方式，测试都通过了，至于性能方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cglandy/p/10301548.html</dc:identifier>
</item>
<item>
<title>spring之旅第二篇-spring IOC概念及原理分析 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10301499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10301499.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一、IOC概念&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上一篇已经了解了spring的相关概念，并且创建了一个spring项目。spring中有最重要的两个概念：&lt;strong&gt;IOC&lt;/strong&gt;和&lt;strong&gt;AOP&lt;/strong&gt;，我们先从IOC入手。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IOC&lt;/strong&gt;&lt;span&gt;全称Inversion of Control，中文通常翻译为“控制反转”，这其实不是一种技术，而是一种思想。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;简单理解就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里&lt;span&gt;&lt;strong&gt;分享Iteye的开涛对Ioc的精彩讲解&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;地址：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://jinnianshilongnian.iteye.com/blog/1413846&quot;&gt;https://jinnianshilongnian.iteye.com/blog/1413846&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC是什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。&lt;/strong&gt;&lt;span&gt;在Java开发中，&lt;span&gt;&lt;strong&gt;Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/strong&gt;&lt;span&gt;如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁控制谁，控制什么：&lt;/strong&gt;&lt;span&gt;传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；&lt;span&gt;&lt;strong&gt;谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;为何是反转，哪些方面反转了：&lt;/strong&gt;&lt;span&gt;有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;span&gt;&lt;strong&gt;因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　用图例说明一下，传统程序设计如图1-1，都是主动去创建相关对象然后再组合起来：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152619832-169850656.jpg&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152619832-169850656.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;图1-1 传统应用程序示意图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152826535-1580521182.png&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152826535-1580521182.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;图1-2有IoC/DI容器后程序结构示意图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC能做什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　其实&lt;span&gt;&lt;strong&gt;IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC和DI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;DI—Dependency Injection，即“依赖注入”&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;strong&gt;组件之间依赖关系&lt;/strong&gt;&lt;span&gt;由容器在运行期决定，形象的说，即&lt;span&gt;&lt;strong&gt;由容器动态的将某个依赖关系注入到组件之中&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;&lt;strong&gt;依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。&lt;/strong&gt;&lt;span&gt;通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁依赖于谁：&lt;/strong&gt;&lt;span&gt;当然是&lt;span&gt;&lt;strong&gt;应用程序依赖于IoC容器&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;为什么需要依赖：*&lt;/strong&gt;&lt;span&gt;*应用程序需要IoC容器来提供对象需要的外部资源**；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁注入谁：&lt;/strong&gt;&lt;span&gt;很明显是&lt;span&gt;&lt;strong&gt;IoC容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;●注入了什么：&lt;/strong&gt;&lt;span&gt;就是&lt;span&gt;&lt;strong&gt;注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;IoC和DI&lt;/strong&gt;&lt;span&gt;由什么&lt;span&gt;&lt;strong&gt;关系&lt;/strong&gt;&lt;span&gt;呢？其实它们&lt;span&gt;&lt;strong&gt;是同一个概念的不同角度描述&lt;/strong&gt;&lt;span&gt;，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，&lt;span&gt;&lt;strong&gt;“*&lt;/strong&gt;&lt;span&gt;*依赖注入”&lt;span class=&quot;md-empty&quot;&gt;&lt;span&gt;明确描述了“被注入对象依赖IoC&lt;span class=&quot;md-empty&quot;&gt;&lt;span&gt;容器配置依赖对象”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;相信通过上面的文章，对IOC的理解会更深。下面讲讲三种依赖注入的方式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;顾名思义，构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部（通常是IoC容器）知道它需要哪些依赖对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; classA(IinterfaceA a,IinterfaceB b){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a=&lt;span&gt;a;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b=&lt;span&gt;b;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;setter 方法注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。这些setXXX()方法统称为setter方法，getXXX()当然就称为getter方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; classB(){
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IinterfaceA a;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IinterfaceB b;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IinterfaceA getIinterfaceA(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setIinterfaceA(IinterfaceA a){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a=&lt;span&gt;a;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IinterfaceB getIinterfaceB(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setIinterfaceB(IinterfaceB b){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b=&lt;span&gt;b;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;接口注入&lt;/strong&gt; &lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;创建Person （被注入对象）要实现的接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserInject{
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; injectUser(User user);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里必须 是被注入对象依赖的对象&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Person 对象实现接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserInject{ 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; User user; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(){} 
    @Override 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; injectUser(User user)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.user = user;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现注入方法，外部通过此方法给此对象注入User对象&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;外部调injectUser方法为Persion对象注入User对象，此即接口注入&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;三种注入方式的比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;构造方法注入。这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以 9马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;setter方法注入。因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无法在构造完成后马上进入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式；而接口注入因为侵入性较强，近年来已经不流行了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;二、源码分析&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在学习spring的具体配置之前，先了解下源码的基本结构。上一篇的测试代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ApplicationContext ctx=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;META-INF/applicationContext.xml&quot;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取bean的实例&lt;/span&gt;
HelloWorld t=(HelloWorld) ctx.getBean(&quot;hello&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们大致分析下过程：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过Resource对象加载配置文件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解析配置文件,得到bean&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解析bean,id作为bean的名字,class用于反射得到bean的实例(Class.forName(className));&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;调用getBean的时候,从容器中返回对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;当然这只是简单的理解，IOC核心内容是beanFactory与ApplicationContext&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean，BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190121230459062-1263771299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;9&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;BeanFactory作为一个主接口不继承任何接口，暂且称为&lt;span&gt;&lt;strong&gt;一级接口&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有3个子接口继承了它，进行功能上的增强。这3个子接口称为&lt;span&gt;&lt;strong&gt;二级接口&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ConfigurableBeanFactory可以被称为&lt;span&gt;&lt;strong&gt;三级接口&lt;/strong&gt;&lt;span&gt;，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为&lt;span&gt;&lt;strong&gt;四级接口&lt;/strong&gt;&lt;span&gt;。（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;最基本的IOC容器接口BeanFactory&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactory {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;amp;a会得到那个Factory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String FACTORY_BEAN_PREFIX &lt;/span&gt;= &quot;&amp;amp;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 四个不同形式的getBean方法，获取实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字，获取在IOC容器中得到bean实例   &lt;/span&gt;
    Objecpublic &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactory {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;amp;a会得到那个Factory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String FACTORY_BEAN_PREFIX &lt;/span&gt;= &quot;&amp;amp;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 四个不同形式的getBean方法，获取实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字，获取在IOC容器中得到bean实例   &lt;/span&gt;
    Object getBean(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。    &lt;/span&gt;
    &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    
    &lt;/span&gt;&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;

    Object getBean(String name, Object... args) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否存在&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBean(String name); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为单实例&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isSingleton(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为原型（多实例）&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isPrototype(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 名称、类型是否匹配&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, Class&amp;lt;?&amp;gt;&lt;span&gt; targetType)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到bean实例的Class类型&lt;/span&gt;
    Class&amp;lt;?&amp;gt; getType(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException; 

    String[] getAliases(String name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据实例的名字获取实例的别名 getBean(String name) throws BeansException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。    &lt;/span&gt;
    &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    
    &lt;/span&gt;&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;

    Object getBean(String name, Object... args) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否存在&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBean(String name); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为单实例&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isSingleton(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为原型（多实例）&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isPrototype(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 名称、类型是否匹配&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, Class&amp;lt;?&amp;gt;&lt;span&gt; targetType)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到bean实例的Class类型&lt;/span&gt;
    Class&amp;lt;?&amp;gt; getType(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException; 

    String[] getAliases(String name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据实例的名字获取实例的别名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BeanFactory接口只是做了最基本的定义，里面不管如何定义和加载，只关心如何得到对象，要知道如何得到对象，必须看具体的实现类，其中XmlBeanFactory就是针对最基本的ioc容器的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; XmlBeanDefinitionReader reader;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(resource, (BeanFactory)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parentBeanFactory);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt; XmlBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions(resource);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息&lt;/span&gt;
 Resource resource = &lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;META-INF/applicationContext.xml&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory&lt;/span&gt;
 BeanFactory beanFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlBeanFactory(resource);
 HelloWorld helloWorld &lt;/span&gt;= beanFactory.getBean(&quot;hello&quot;,HelloWorld.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
 System.out.println(helloWorld.getInfo());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;支持信息源，可以实现国际化。（实现MessageSource接口）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;访问资源。(实现ResourcePatternResolver接口)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;支持应用事件。(实现ApplicationEventPublisher接口)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;两者的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;3.beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;spring 的IOC实现当然不止这些，这些以后再学，推荐一篇大牛写的博客：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ITtangtang/p/3978349.html&quot;&gt;https://www.cnblogs.com/ITtangtang/p/3978349.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;看完这些相信对spring IOC概念及其实现会有了一些理性认识了，这里面参考了很多园子里大神的文字，下一篇开始学习spring的配置&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、IOC概念 上一篇已经了解了spring的相关概念，并且创建了一个spring项目。spring中有最重要的两个概念：IOC和AOP，我们先从IOC入手。 IOC全称Inversion of Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10301499.html</dc:identifier>
</item>
<item>
<title>Excel与Google Sheets中实现线性规划求解 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/10301487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/10301487.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;很久没更新过APS系列文章了，这段时间项目工作确实非常紧，所以只能抽点时间学习一下运筹学的入门知识，算是为以后的APS项目积累点基础。看了一些运筹学的书（都是科普级别的）发现原来我目前面对的很多排产、排班、资源分配和路线规划问题，都是运筹学上的典型案例。与此同时，除了继续使用Optaplanner来做我们的规划类项目外，还花点时间去研究了一下Google OR-Tools开源规划引擎，这是Google旗下的一个开源求解器，接下来我会专门写一些关于Google OR-Tools应用的文章，并与Optaplanner作些关联对比。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;本篇先向大家展示一下两个规划工具，在求解线性规划问题上的应用方法，分别是Microsoft Office的Excel里的”规划求解”组件和Google Dos中的Spreadsheet上提供的Linear Optimization插件。这两个工具都可以作为规划问题的求解器。因为它们是以插件或软件功能形式提供的，在灵活性和扩展性方面限制还是比较大，但是因为不涉及软件开发的技能，普通用户都能很好地应用它们来解决一些现实业务中遇到的规则问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;因为Google的Linear Optimization是Google文件服务中的Spreadsheet（Google提供的类似于Excel的电子表格程序），因为目前国内的网络情况（你懂的），访问它需要自己想办法，我们公司总部不在中国境内，所以我们的办公网络经过注册，是可以合法访问外界的；关于网方面不在本篇中讨论，大家自己科学解决就可以了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       下面先给出本次我们需要求解的线性规划问题，其实在Optaplanner相关的文章中，详细介绍过关于NPC问题，普通线性规划问题很多并不是NPC问题，因为对于线性规划模型，还是有例如单纯形法等算法推算它的最优解的，而不是所有规划问题的时间复杂度都是O(a^n)或O(n!)的，大家要理解清楚两者的关系。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       我们要求解的问题跟很多运筹学教材或科普书籍上的例子一样，也是最简单的在确定的条件约束下，求最大利润下的产品生产方案问题。例如一家工厂生产两种产品，产品A与产品B，均需使用到三种资源，资源1、资源2和资源3。其中生产一件产品A，需要5个单位的资源1，4个单位的资源2，3个单位的资源3。生产一件产品B需要3个单位的资源1，8个单位的资源2，5个单位的资源3。一个产品A的利润是20，一个产品B的利润是25。库存中三种资源的存量为：280单位的资源1，580单位的资源2，360单位的资源3.见下表：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223212111-912311816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;求：两种产品分别生产多少件，才能令到总利润最大？此时的利润是多少？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       以上问题是典型的线性规划问题，运筹学的同学可以通过单纯形法进行求解，但是这种方法对于没有运筹学背景的普通工程师来说，困难还是不小。即使我们学会这种办法，但遇到更复杂问题的时候，对我们来说其挑战还是相当大。因此，目前市上，或开源世界里，提供了很多解决此类规划问题的开源软件。但对于非IT人员来说，没有软件开发背景，很难利用这些开源软件工具写程序求解。因此，一些知名的办公软提供了相关的特性，让非IT专业人员直接使用其规划功能，输入数据即可快速求得答案。对各行业的生产、管理活动提供了极大的帮助。下面我们就以Excel和Google Spreadsheet两种工具中的规划求解功能，尝试求解上述问题。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       要解决上述问题，就需要对问题进行线性规划建模，建立数学模型，以数学工具对问题的约束和目标进行归纳、抽象，用数学语言表达问题的本质意义。对于上面的问题我们的建模如下：假设产品A生产x件，产品B生产y件，才能让利润最大化。那么我们通过对问题的约条件和规划目标的分析，可以得出以下数学模型。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223419895-1434200281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;该模型表示：生产产品A和产品B所需的三种资源的总量，均不能超过每种资源的库存量；并且产品件数量必须是大于等于0的整数。规划的目标函数是找出两种产品的利润之和的最大值，并计算出获得该利润时，两种产品的产量分别是多少。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对于线性规划问题，其实可以通过单纯形法、对模型进行求解，从而得出z最大时的x与y的值。但此方法需要一定的数学知识，此范围的知识不在本文的讨论范围内，以后若有机会，我再简单介绍一下通过单纯形法对此模型求解步骤。但本人也不是运筹专业出身，估计也只是班门弄斧；因此，大家可以上网寻找更专业的运筹学资源，了解规划模型的解法。本文通过Excel下的规划求解功能，以及Google下的Spreadsheet中的Linear Optimization插件，对该规划模型进行求解，从而取得该生产安排问题的解。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       Excel提供了一个非常强大的组件用于解决此类规划问题，目前我还只尝试过线性规划问题，根据其资料显示，非线性规划也是可以解的。以后若有机会尝试一下基它规划问题再分享给大家。下面逐一展示这组件具体用法给大家。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第一步：添加“规则求解”组件&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;因为规则求解功能默认不会出现在Excel的常用工具栏中，因此，需要从加载项目中把它加载出来才能使用。在Excel菜单栏中，选择【文件】-&amp;gt;【选项】，在弹出的【Excel选项】窗口中，选择【加载项】页签，在列表中的【非活动应用程序加载项】（意思是说Excel目前有这些功能可以用，但还没有加载进去，所以不会显示在工具栏中）的其下方找到【规则求解加载项】，如下图.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223627978-1449084006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在列表下方的【管理(A)】下拉框中选择【Excel加载项】，点击【“转到...】按钮，会弹加载项窗口，如下图。在【可用加载宏(A)】列表中，选中【规划求解加载项】，点击确定，窗口关闭。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223705911-82349586.png&quot; alt=&quot;&quot;/&gt;      &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在Excel的【数据】工具栏的最右则，你会看到【规划求解】的图标，即是刚才我们操作完成后加载进来的组件，如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223725997-767134091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;事实上它是Microsoft提供的一个求解器，该组件对应的文件在C:\Program Files (x86)\Microsoft Office\root\Office16\Library\SOLVER此文件夹下。该文件夹下有两个文件，分别是SOLVER.XLAM和SOLVER32.DLL, SOLVER.XLAM是一个Excel的宏文件，用于实现Excel对求解器核心SOLVER32.DLL的调用，因此SOLVER32.DLL应该就是这个求解器的核心程序动态连接库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第二步：将问题填入Excel表并建立各变量之间的关系&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;完成规划求解组件加载后，下面就可以将数学模型的各个常量、变量和约束关系填入Excel单元格中；先将两种产品和三种资源对应的使用数量建立一张二维表，如下表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223824644-1703596535.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;194&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过Excel及规划求解组件解答此问题步骤如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;填&lt;/strong&gt;&lt;strong&gt;入常量：&lt;/strong&gt;上表中，产品A对资源1、资源2和资源3的要求量分别是5，4，3(即B2,B3,B4的值)，其单件利润为20(B5)。 同样方法将产品B对应的数量填入C２- C5单元格中。另外，对于三种资源的库存量，将其值填 入D2 - D4中。自此，模型中涉及的常量已经全部填写时表格。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;根据数学模型，定义运算关系：&lt;/strong&gt;本模型中，我们的目标是求得当z最大时变量x,y的值(x,y在运筹学的规划模型中被称为 决策变量；在Optaplanner中，它们被称作规划变量)。在Excel中每一个决策变量需要确定在一个单元格，以备参与接下来的规划计算，如上表的B6,C6单元格。在未启动规划的时候，这两个单元格直接填上0作为初始值即可。这两个代表决策变量的单元格在完成规划，找到答案后，运算结果值将会被填到对应的单元格中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;确定好这两个变量后，下一步需要考虑规划目标，也就是总利润最大化的目标，也需要为此目标值确定一个单元格，此单元格的值会在规划完成时，确定了B6和C6两件单元格的值之后计算出来。根据目标函数z = 20x X 25y的定义，此单元格的公式应为 ：B5 * B6 + C5 * C6，即两种产品的利润之和。我们把存储利润之和的值定在D7单元格，为了直观美观，我们把D7与E7合并。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;确定了目标函数值的单元格和计算公式后，下一步需要处理约束条件，也就是产品的资源使用量与库存的约束关系。对于资源1，我们将E2确定为其资源用量，它计算公式应该是:B2 * B6 + C2 * C6,即两种产品对该资源的使用量之和。按相同的规则，设置E3 = B3 * B6+ C3* C6, E4 = B4 * B6 + C4 * C6.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第三步：设定规划求解逻辑参数&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;通过上述两个步骤设定后，各个单元格的常量值、决策变量和运算关系已设定好。接下来就可以启动【规划求解】插件进行逻辑设定。在【数据】菜单项目中，最右则的【分析】组里，有一个【规划求解】图标，点击它，即可打开【规划求解】窗口(如下图)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223956162-1962865514.png&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以下讲解这些参数意义及其设置。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.【设置目标&lt;/strong&gt;&lt;strong&gt;(T)&lt;/strong&gt;&lt;strong&gt;】项&lt;/strong&gt;:该项目我们需要选定一个单元格，表示该单元格是本次规划活动需要计算的目标。通过问题描述和规划模型，我们得知该问题目标是求利润的最大值及取得该利润时两种产品的产量。也即模型中的目标函数z的最大值，及此时的x,y的值。在上表中D7就是存放这个目标函数的单元格，因此这里选中D7即可。在参数设置时，都是使用单元格的绝对地址，因此单元格地址前面都有$符号。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;2.目标值中【到】项&lt;/strong&gt;：该项用于设置对于目标函数的取值要求，可以看到它有【最大值】，【最小值】和【目标值】三个选项。其中【最大值】和【最小值】，表示目标函数往最大或最小两个极值方向求解，即最优解中，D7单元格的值是在满足约束条件情况下取得的最大值。而【目标值】则表示取得最优解时，目标函数值最等于或最接近于此值。本问题中的目标是求利润最大，所以我们选择【最大值】。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;3.【通过更改可变单元格(B)】&lt;/strong&gt;：该项表示在规划过程中求解器，通过改变哪些单元格的值，来获得结果，直到【目标值】所指的单远格（本例中的D7)中的值达到极值。对应到模型中，也就是x与y两个决策变量，本例中对应的单元格是B6和C6，分别表示产品A和产品B的产量。因此，选择B6和C6即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;4.【遵守约束】&lt;/strong&gt;：该项内容表示本次规划需要符合的约束条件，也就是模型中的s.t.部分(s.t. 是subject to的缩写)和各个不等式和各变量的范围条件。点击右则的【添加(A)】按钮，弹出【添加约束】窗口(如下图)，可以看到约束的表达方式非常简单，就是添加左右两则值的逻辑关系。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224218459-597434062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　参照模型中的s.t.部分，和excel中的单元格位置关系，添加它们的关系即可。例如对于资源1，s.t.中的约束条件5x * 3y &amp;lt;= 280, 可参通过选择操作，添加以下关系: E2 &amp;lt;= D2，表示产品A所需资源量与产品B所需资源量之和，不能大于资源库存量。按相同的规则设置好资源2和资源3的约束条件。另外对于决策变量x,y，模型中有这两个变量应为整数，且大于等于0的约束。因此，分选选择B6和C6，并在条件表达关系选择int即可。完成后条件约束的内容如上图中的【遵守约束】列表中的内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　5.【选择求解方法】&lt;/strong&gt;：该栏列举了目前可选择的三种求解算法，分别是【单纯线性规划】，即单纯形解法，【非线性GRG】和【演化】。具体的求解方法在选择框下方有简单解释，我们选择默认的【非线性GRG】或【单纯形法】即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;6.【求解】&lt;/strong&gt;：点击【求解】按钮，即会启动求解器进行规划求解。完成后会弹出【规划求解结果】窗口，供进一步操作（例如保存规划方案等）。与此同时，原来在未求解前，因为产量设置为0，所以所需资源（E列）的三个单格E2,E3,E4,以及总利润单元格D7的初始值是0。完成规划后，找到最大利润下两种产品的产量(B6,C6)之后，上述原值为0的单元格的值，也随即被更新为该利润最大方案时对应的值。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224339359-973545515.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由结果可知，完规划求解后，得到的决策变量值：x=20, y=60, 目标函数z的值为1900，即表示：当产品A生产20个(B6单元格)，产品B生产60(C6单元格)个时，其利润达到最大值1900(D7单元格)。上述规划问题得到完美解。下面我们再使用另外一个工具 - Google Spreadsheet中的线性优化插件，求解同样的问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;     &lt;/strong&gt; 对于规划问题，微软和Google通提供了很强大的套件，令到像我这种没有运筹学背景的普通用户，可以方便地求解一些规划问题。在此不得不感叹一下，在此方面国内类似软件与国外的差别。曾经有朋友跟我讨论过，公司使用的国内某个一线办公软件，功能直逼office，办公中绝大部分情况，这个软件都能处理，但遇到一些需要进行规划运算的问题，此软件则没有提供类似的功能，不得不求助于Microsoft Excel。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       说到这种非专业人员用的规划求解工具，不得不延伸提一下规划引擎软件方面，也存同类问题。目前在国内，如果是针对某一大型公司或项目，只要资源到位，实现一个可用的规划引擎问题不算大。但涉及要求更高，可用性更强的通用规划引擎(无论是开源还是商业)国内外的差距就体现出来了。商业求解器领域暂不深入讨论，本人专注于开源规划引擎的应用 研究，近两三年项目应用或自己学习研究中，曾分析应用过一些开源规划引擎，除开优化性能和优化结果的质量上的比较；仅就在工程实践的可用性、易用性上，目前还很难在国内找到一款能跟Optaplanner及Google OR-Tools媲美的开源引擎。先不说可以满足建模要求的引擎软件包，就是求解器方面，国内开源项目也寥寥可数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       下面开始对Google Spreadsheet中的Linear Optimization插件的应用进行具体介绍。还是在上面已经建立好的数学模型基础上，讨论通过Google的Linear Optimization求解此模型。在开始之前，需要完成以下准备工作：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;&lt;strong&gt;解决网络连接问题&lt;/strong&gt;。这个大家懂的，大家可以自行想办法解决，如果一些在外资或需要访问国外网络的机构工作的朋友（如我们办公室是可能正常合法访问国外网络），则可以跳过此节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册Google帐号(若你未有Google帐号）&lt;/strong&gt;。因为Google Docs，Google Spreadsheet均是类似于Microsoft Office的在线文件处理应用服务。无论是哪个Google服务，需要使用必须通过Google帐号。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;　　完成上述前期工作后，即可开始Google Spreadsheet的配置和应用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第一步：安装Linear Optimization(线性优化)插件&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       Linear Optimization是Google Spreadsheet的一个插件，可以实现对线性规划模型的求解。默认状态下，Google Spreadsheet是不包括此插件的，需要使用的话，则需要将期添加Spreadsheet中才能使用。下面将操作接步骤列出。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1.创建Spreedsheet文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　登录Google帐号，进入Google Sheets页面（http://sheets.google.com）。进入后Spreadsheet主页后，点击页面右下解的红色添加按钮，创建一个Google Spreadsheet文件。在创建好的文件中，可以将文件命名为“LP_Test”文件即会自动保存到你的Google帐号。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224509867-2115452280.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224550491-2101689754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             添加Spreadsheet              重命名文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 添加Linear Optimization插件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过Spreadsheet页面的Add-ons菜单，将Linear Optimization插件添加到你的帐号上，才能进一步使用该线性优化插件，可以看到还有更多规划功能的插入可以添加。这也是Google在运筹优化方面的系统架构与Optaplanner存在的差别。我将会有新的一篇文章对比两个开源规划引擎这方面的差异，敬请期待。点击Add-ons -&amp;gt; Get add-ons… 菜单项目，将会弹出【Add-ons】页面，在页面上的搜索框中输入”Linear Optimization”并回车，即可搜索出该插件,并点击【+FREE】按钮进行添加。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224634131-996489833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在添加过程中，需要你登录或选择一个已经登录的帐号,选择你已登录的帐号即可，如下图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224646893-1548257726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选择或输入帐号后，会转到一个Sign in页面，大概意思是说Linear Optimization将会被添加到指定页面，点击页面底部右则的【Allow】按钮即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 创建线性规划模板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　添加完成后，在【Add-ons】菜下会出现【Linear Optimization】子菜单项，该子菜单下会有用于设置决策变量、约束和求解的子项。见下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224751316-403988257.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选择【Linear Optimization】菜单下的【Set up optimization sheet】子项，即可在当前Sheet中生成求解模板，模板中包含f了决策变量定义区域、目标函数区域和约束区域。下图为新创建的线性规划模板刚创建好的状态.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224914147-134775963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;4.填入决策变量、约束和目标函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　创建好线性规划模板后，需要将上面已经建立好的数学规划模型输入模板中对应的单元格，正确地反映数学模型的意义，才启动求解器（Google的在线规划服务，是用通WebAPI提供的，因此其求解器是部署在Google自己的服务器上）。初学者可以通过Linear Optimization菜单下的子项，来辅助输入决策变量和约束。选择Linear Optimization菜单下的【Add Variables...】子项，在页面的右则会显示【Describe data】 页面。该页面中点击【Variables】和【Constrains】页签分别可以提供定义决策变量(即模型中的x,y)和约束条件(即模型中s.t.部分中的不等式)的输入元素。以下是【Variables】的各个字段输入如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　a. &lt;strong&gt;Variable Name&lt;/strong&gt;: 该字段表示决策变量，输入第一个决策变量名x.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　b&lt;strong&gt;. Type:&lt;/strong&gt; 从我们建立的规划模型中，知道决策变量x是一个整数，因此Type中选择Integer,(它默认是Continuous).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　c.&lt;strong&gt;  Lower bound, Upper bound&lt;/strong&gt;:这两个字段分别表示约束变量的最大值与最小值（即决策变量的取值范围），从模型中可以看到它们的最小值是0, 且无最大值限制，因此，Lower bound填上0， Upper bound留空（它提示为Defaults to Infinity,大家应该懂了吧?)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　d&lt;strong&gt;. Objective coefficient&lt;/strong&gt;:该字段表示该决策变量在目标函数中的系数，也就是目标函数表达式中，x前面的常数，从模型的目标函数上可以看到x前面的技术系数为20，因此填入20即可。点击【Add】按钮，x的相关值及其在目标函数上的体现将会被填入模板中。以相同的规则填入决策变量y相关的信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　下面介绍约束的输入，点击【Constraints】页签，页面将会展示约束条件填入界面：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　a. &lt;strong&gt;Constraint Name&lt;/strong&gt;:因为现在我们是新建立约束，因此在下拉框中选择【New Constraint】, 页面中将会出同【Constraint Name】、【Lower bound】和【 Upper bound】三个字段。【Constraint Name】字段中输入一个名称用于标识该约束即可，因为模型中每个不等式是表示一种资源的限制，因此第一个不等式是针对资源1的库存限制的，我们输入”Resource1”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　b. &lt;strong&gt;Lower bound&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;Lower bound&lt;/strong&gt;：以模型的s.t.部分中的首个不等式 &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121225907828-487881289.png&quot; alt=&quot;&quot;/&gt;为例，其实我们根据题意可以把它补充成&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121225934508-911614235.png&quot; alt=&quot;&quot;/&gt;，也就是说，模型中少了产品A资源用量大于等于０这个限制；其实这样是不严谨的。但因为目标函数是求最大值，因此，大于等于0这个条件不表示出来，也不会影响模型的正确性。但需要在Google的Linear Optimization中表未这个不等式时，必然存此条件才能完整表示，包括以后我们直接使用Google OR-Tools中的线性规划模块，不等式的必须有明确的范围才行。根据上面的不等式，我们在【Lower bound】中填入0，【Upper bound】输入280(即少于等于280)。点【Add】按钮，首个约束就会被添加到模板中，并添加了范围限制见下图红框内.此时,Resource1这一行(第8行)仅仅表示了式子的值域，具体的式子并未完成。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230028136-910669881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　c. &lt;strong&gt;Variable Name, Coefficient&lt;/strong&gt;:一上步仅添加了约束Resource1的基本结构。本步骤将要完成不等式中的式子部分。点击【Add】后，页面将会出现【Variable name】下拉框，其中有当前模型的所有决策变量(即本例中的x与y）供选择。在右则还会出现【Variable coefficient】输入框，表示你选择的决策变量在不等式中前面的常数（即技术系数），通过模型我们看到Resource1不等式中x前面的常数是5，因此填入5，并点击【Add】，此时常数5就会被填入当前约束，x对应列的单元格（即D8单元格)。同样地，不等式中决策变量y前面的常是3，因此我们在【Variable name】中选择y，并在【Variable coefficient】中填入3。点击【Add】即可完成约束Resource1的输入。同样的方法输入资源2和资源3的约束，完成后如下图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230130139-968541220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.求解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　完成上述步骤之后，我们建立的规划模型已经全部表达到Linear Optimization模板中，选中【Linear Optimization】菜单下的【Solve】子项，程序将会启用Google的线性规划Web服务，对刚才输入的模型进行求解，并把结果填回表格中，见下图.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230609793-1944522223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       上图是模型的规划结果，可以看到，通过这个模型计算出来的最大的利润是1900(B6单元格)，获得此利润时，产品A的产量是20(D6单元格)，产品B的产量是60(E6单元格).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       本文通过对一个简单的线性规划问题，建立线性规划模型；并分别通过Excel的规划求解组件，和Google Spreadsheet下的Linear Optimization插件对模型进行求解，从而得出最优结果。非IT专业人员在实际生产活动中，遇到此类线性规划问题时，可以通过此方法对问题进行求解。而专业的IT人员，遇到的问题会比本文中的情况复杂得多，通过现成的软件功能很可能是无法解决，需要通过软件开发技术，结合规划引擎进行求解。大家可以参考我之前的Optaplanner系列文章 .&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       本人近段时间也在研究Google OR-Tools，发现本文用到的Linear Optimization其实是通过将Google OR-Tools的多个运筹求解器，建立在Google自身的服务器上；再以Web服务方式提供给的。在实际软件项目开发过程中，我们可以绕开Google Spreadsheet服务程序，通过自己的程序调用其运筹优化服务进行求解。当然现目前国内的情况来看，通过对它的开源项目Google OR-Tools的引用，直接将其求解器纳入我们自己开发的系统中更现实。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       我正在撰写一篇关于Optaplanner与Google OR-Tools的对比文章，通过对比两个引擎的用法，有针对性的引出对Google OR-Tools的应用，敬请期待，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;如需了解更多关于Optaplanner的应用，请发电邮致：&lt;a href=&quot;mailto:kentbill@gmail.com&quot; target=&quot;_blank&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;或到讨论组发表你的意见：&lt;a href=&quot;https://groups.google.com/forum/#!forum/optaplanner-cn&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!forum/optaplanner-cn&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 21 Jan 2019 15:08:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>很久没更新过APS系列文章了，这段时间项目工作确实非常紧，所以只能抽点时间学习一下运筹学的入门知识，算是为以后的APS项目积累点基础。看了一些运筹学的书（都是科普级别的）发现原来我目前面对的很多排产、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/10301487.html</dc:identifier>
</item>
<item>
<title>如何一步步使用国内yum源一键安装openstack-ocata版本基于centos7 - 木直</title>
<link>http://www.cnblogs.com/muzhifei/p/10301417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muzhifei/p/10301417.html</guid>
<description>&lt;p&gt;写在前面的话，在网上看了一个国外的一键安装视频，我也照着做，结果出现很多错误，现在把坑解决了，照着做肯定能安装成功的&lt;/p&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;p&gt;　　virtualhost 下的centos7&lt;/p&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;p&gt;　　双网卡 一个10网段，nat通信用 一个192网段 和宿主机通信使用&lt;/p&gt;
&lt;p&gt;　　2c 这个测试部署的话，不是强要求，我部署后CPU也就占20%&lt;/p&gt;
&lt;p&gt;　　5.4G内存 我的宿主机也就8G内存 配到这个数据已经很卡了 再次PS &lt;/p&gt;
&lt;p&gt;　　安装完成要占用约5G左右的内存&lt;/p&gt;
&lt;p&gt;部署&lt;/p&gt;
&lt;p&gt;　　由于我的是nat 网络，所以现配置双网卡，否组部署后，不能正常访问openstack的管理网页，因为需要修改到这个参数，这个到后面再说&lt;/p&gt;
&lt;p&gt;　　双网卡配置略过，自己在网上查吧很多的。实在找不到就留言&lt;/p&gt;
&lt;p&gt;正式开始&lt;/p&gt;
&lt;p&gt;　　1-设置yum源01_setyum.sh（非常重要，虽然出了openstack 专用的yum源，但那不是咱们能用的），我做成了脚本样子的，直接拷贝拿去用，镜像源用的是清华源，因为阿里源有的包跳转到404的链接还在上面，后面一键安装的时候就会坑哭你，亲测。。都是泪。脚本正文如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#创建备份路径
&lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; -p /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/bak_tmp/&lt;span&gt;
#移走当前的所有源，为什么？因为一键安装会乱跳，跳到不能用的就报错，然后你就安装失败
&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.repo /etc/yum.repos.d/bak_tmp/&lt;br/&gt;#创建yum 文件
touch /etc/yum.repos.d/centos-tuna.repo
#导入镜像内容到yum文件中
cat   &amp;gt;&amp;gt;/etc/yum.repos.d/centos-tuna.repo &amp;lt;&amp;lt; EOF
#CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the
# remarked out baseurl= line instead.
#
#

[base]
name=CentOS-$releasever - Base
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/os/$basearch/
#mirrorlist=&lt;/span&gt;&lt;span&gt;http://mirrorlist.centos.org/?release=&lt;/span&gt;&lt;span&gt;$releasever&amp;amp;arch=$basearch&amp;amp;repo=os
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#released updates
[updates]
name=CentOS-$releasever - Updates
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/updates/$basearch/
#mirrorlist=&lt;/span&gt;&lt;span&gt;http://mirrorlist.centos.org/?release=&lt;/span&gt;&lt;span&gt;$releasever&amp;amp;arch=$basearch&amp;amp;repo=updates
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

#additional packages that may be useful

[centosplus]
name=CentOS-$releasever - Plus
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/centosplus/$basearch/
#mirrorlist=&lt;/span&gt;&lt;span&gt;http://mirrorlist.centos.org/?release=&lt;/span&gt;&lt;span&gt;$releasever&amp;amp;arch=$basearch&amp;amp;repo=centosplus
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
[cloud]
name=CentOS-$releasever - Cloud
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/cloud/$basearch/openstack-ocata/
enabled=1
gpgcheck=0
[paas]
name=CentOS-$releasever - paas
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/paas/$basearch/openshift-origin13/
enabled=1
gpgcheck=0
[kvm]
name=CentOS-$releasever - kvm
baseurl=&lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/&lt;/span&gt;&lt;span&gt;$releasever/virt/$basearch/kvm-common/
enabled=1
gpgcheck=0

EOF
#清除yum缓存
yum clean all
#重新做yum 缓存
yum makecache&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2-配置环境 02_setenv.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat&lt;/span&gt; &amp;gt;/etc/environment &amp;lt;&amp;lt;&lt;span&gt;EOF
LANG&lt;/span&gt;=en_US.utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
LC_ALL&lt;/span&gt;=en_US.utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
EOF

systemctl disable firewalld
systemctl stop firewalld
systemctl disable NetworkManager
systemctl stop NetworkManager
systemctl enable network
systemctl restart network&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3-安装一键部署包 03_set_openstack-packstack.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; -&lt;span&gt;y update
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y openstack-&lt;span&gt;packstack
#报错无法安装openstack&lt;/span&gt;-&lt;span&gt;selinux 没有相关依赖包，通过增加paas 镜像源解决
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y openstack-&lt;span&gt;selinux
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; &lt;span&gt;wget&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;--提示缺少libLibev.so.&lt;span&gt;4&lt;/span&gt;&lt;span&gt;()(64bit)
&lt;/span&gt;&lt;span&gt;wget&lt;/span&gt; -O /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/epel.repo http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/repo/epel-7.repo&lt;/span&gt;
&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt;&lt;span&gt; libev&lt;br/&gt;#有可能yum源混乱了，所以重新执行yibian
&lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; -p /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/&lt;span&gt;bak_tmp_1
&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.repo /etc/yum.repo.d/bak_tmp_1/
mv /etc/yum.repos.d/bak_tmp_1/centos-tuna.repo /etc/yum.repos.d/
yum clean all&lt;br/&gt;yum makecache&lt;br/&gt;#解决python-werkzeug 不在cloud源，在virt里面,所以找不到此包
wget -O /root/python-werkzeug-0.9.1-1.el7.noarch.rpm &lt;/span&gt;&lt;span&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/7/virt/x86_64/ovirt-4.3/common/python-werkzeug-0.9.1-1.el7.noarch.rpm&lt;/span&gt;&lt;span&gt;
rpm -ivh /root/python-werkzeug-0.9.1-1.el7.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行到这里才完成一点点，为了保险。重新进入到yum文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/&lt;span&gt;
ll
#确认当前只有一个centos&lt;/span&gt;-tuna.repo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　确认完成执行最后一步安装操作，也就是出错最多的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#-&lt;span&gt;d 表示debug 日志级别
packstack &lt;/span&gt;--allinone -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装成功的样例如下&lt;/p&gt;
&lt;p&gt;　　比较长，就不展开了　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_146aca79-88f1-48e2-a8cd-f52a65d79037&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_146aca79-88f1-48e2-a8cd-f52a65d79037&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_146aca79-88f1-48e2-a8cd-f52a65d79037&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
[root@openstack-allinone &lt;span&gt;yum&lt;/span&gt;.repos.d]# packstack --allinone -&lt;span&gt;d
Welcome to the Packstack setup utility

The installation log &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; is available at: /var/tmp/packstack/&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;202443&lt;/span&gt;-CWIVyN/openstack-&lt;span&gt;setup.log

Installing:
Clean Up                                             [ DONE ]
Discovering ip protocol version                      [ DONE ]
Setting up &lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt; keys                                  [ DONE ]
Preparing servers                                    [ DONE ]
Pre installing Puppet and discovering hosts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; details [ DONE ]&lt;/span&gt;
Preparing pre-&lt;span&gt;install&lt;/span&gt;&lt;span&gt; entries                        [ DONE ]
Setting up CACERT                                    [ DONE ]
Preparing AMQP entries                               [ DONE ]
Preparing MariaDB entries                            [ DONE ]
Fixing Keystone LDAP config parameters to be undef &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; empty[ DONE ]
Preparing Keystone entries                           [ DONE ]
Preparing Glance entries                             [ DONE ]
Checking &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; the Cinder server has a cinder-&lt;span&gt;volumes vg[ DONE ]
Preparing Cinder entries                             [ DONE ]
Preparing Nova API entries                           [ DONE ]
Creating &lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt; keys &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Nova migration                 [ DONE ]
Gathering &lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt; host keys &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Nova migration           [ DONE ]
Preparing Nova Compute entries                       [ DONE ]
Preparing Nova Scheduler entries                     [ DONE ]
Preparing Nova VNC Proxy entries                     [ DONE ]
Preparing OpenStack Network&lt;/span&gt;-&lt;span&gt;related Nova entries     [ DONE ]
Preparing Nova Common entries                        [ DONE ]
Preparing Neutron LBaaS Agent entries                [ DONE ]
Preparing Neutron API entries                        [ DONE ]
Preparing Neutron L3 entries                         [ DONE ]
Preparing Neutron L2 Agent entries                   [ DONE ]
Preparing Neutron DHCP Agent entries                 [ DONE ]
Preparing Neutron Metering Agent entries             [ DONE ]
Checking &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; NetworkManager is enabled and running    [ DONE ]
Preparing OpenStack Client entries                   [ DONE ]
Preparing Horizon entries                            [ DONE ]
Preparing Swift builder entries                      [ DONE ]
Preparing Swift proxy entries                        [ DONE ]
Preparing Swift storage entries                      [ DONE ]
Preparing Gnocchi entries                            [ DONE ]
Preparing MongoDB entries                            [ DONE ]
Preparing Redis entries                              [ DONE ]
Preparing Ceilometer entries                         [ DONE ]
Preparing Aodh entries                               [ DONE ]
Preparing Puppet manifests                           [ DONE ]
Copying Puppet modules and manifests                 [ DONE ]
Applying &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp:                             [ DONE ]      
Applying &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_network.pp
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_network.pp:                                [ DONE ]   
Applying &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_compute.pp
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_compute.pp:                                [ DONE ]   
Applying Puppet manifests                            [ DONE ]
Finalizing                                           [ DONE ]

 &lt;/span&gt;**** Installation completed successfully ******&lt;span&gt;

Additional information:
 &lt;/span&gt;* A new answerfile was created &lt;span&gt;in&lt;/span&gt;: /root/packstack-answers-&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;202444&lt;/span&gt;&lt;span&gt;.txt
 &lt;/span&gt;* Time synchronization installation was skipped. Please note that unsynchronized &lt;span&gt;time&lt;/span&gt; on server instances might be problem &lt;span&gt;for&lt;/span&gt;&lt;span&gt; some OpenStack components.
 &lt;/span&gt;* File /root/keystonerc_admin has been created on OpenStack client host &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2.28&lt;/span&gt;. To use the command line tools you need to source the &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
 &lt;/span&gt;* To access the OpenStack Dashboard browse to http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.2.28/dashboard .&lt;/span&gt;
Please, &lt;span&gt;find&lt;/span&gt; your &lt;span&gt;login&lt;/span&gt; credentials stored &lt;span&gt;in&lt;/span&gt; the keystonerc_admin &lt;span&gt;in&lt;/span&gt;&lt;span&gt; your home directory.
 &lt;/span&gt;* Because of the kernel update the host &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2.28&lt;/span&gt;&lt;span&gt; requires reboot.
 &lt;/span&gt;* The installation log &lt;span&gt;file&lt;/span&gt; is available at: /var/tmp/packstack/&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;202443&lt;/span&gt;-CWIVyN/openstack-&lt;span&gt;setup.log
 &lt;/span&gt;* The generated manifests are available at: /var/tmp/packstack/&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;202443&lt;/span&gt;-CWIVyN/&lt;span&gt;manifests
 &lt;/span&gt;* Note temporary directory /var/tmp/packstack/503a14fac81b4a29937e3fc3f14381f5 on host &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2.28&lt;/span&gt; was not deleted &lt;span&gt;for&lt;/span&gt;&lt;span&gt; debugging purposes.
You have new mail &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /var/spool/mail/root
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　失败的案例如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d74b1048-c761-4a77-9d07-3557c6a6ff93&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d74b1048-c761-4a77-9d07-3557c6a6ff93&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d74b1048-c761-4a77-9d07-3557c6a6ff93&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Preparing Redis entries                              [ DONE ]
Preparing Ceilometer entries                         [ DONE ]
Preparing Aodh entries                               [ DONE ]
Preparing Puppet manifests                           [ DONE ]
Copying Puppet modules and manifests                 [ DONE ]
Applying &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp:                          [ ERROR ]        
Applying Puppet manifests                         [ ERROR ]

ERROR : Error appeared during Puppet run: &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp
Error: Execution of &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/bin/yum -d 0 -e 0 -y install openstack-aodh-notifier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; returned &lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Error downloading packages:
You will &lt;/span&gt;&lt;span&gt;find&lt;/span&gt; full trace &lt;span&gt;in&lt;/span&gt; log /var/tmp/packstack/&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;193700&lt;/span&gt;-TbxiNW/manifests/&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.28_controller.pp.log
Please check log &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; /var/tmp/packstack/&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;193700&lt;/span&gt;-TbxiNW/openstack-setup.log &lt;span&gt;for&lt;/span&gt; &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information
Additional information:
 &lt;/span&gt;* A new answerfile was created &lt;span&gt;in&lt;/span&gt;: /root/packstack-answers-&lt;span&gt;20190121&lt;/span&gt;-&lt;span&gt;193701&lt;/span&gt;&lt;span&gt;.txt
 &lt;/span&gt;* Time synchronization installation was skipped. Please note that unsynchronized &lt;span&gt;time&lt;/span&gt; on server instances might be problem &lt;span&gt;for&lt;/span&gt;&lt;span&gt; some OpenStack components.
 &lt;/span&gt;* File /root/keystonerc_admin has been created on OpenStack client host &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2.28&lt;/span&gt;. To use the command line tools you need to source the &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
 &lt;/span&gt;* To access the OpenStack Dashboard browse to http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.0.2.28/dashboard .&lt;/span&gt;
Please, &lt;span&gt;find&lt;/span&gt; your &lt;span&gt;login&lt;/span&gt; credentials stored &lt;span&gt;in&lt;/span&gt; the keystonerc_admin &lt;span&gt;in&lt;/span&gt;&lt;span&gt; your home directory.
 &lt;/span&gt;* Note temporary directory /var/tmp/packstack/ff08df80e03e49f49e802dd352ea13e0 on host &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;2.28&lt;/span&gt; was not deleted &lt;span&gt;for&lt;/span&gt;&lt;span&gt; debugging purposes.
不要慌，检查你的文件夹下的yum 源，全部移除到备份文件夹
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt; makecache 
重新开始执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　部署成功后验证登陆，ip 为你自己虚拟机的ip，主要看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;more&lt;/span&gt; /etc/httpd/&lt;span&gt;15&lt;/span&gt;-hrion*&lt;span&gt;.conf #记不清全拼了，找到这个文件
增加一个serveralias &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;&lt;span&gt;.x。x #宿主机和虚拟机能正常通信的IP
#重启
systemctl restart httpd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　千辛万苦就是要看到这么一个图。爬坑也是花时间的，现在总结在这里。祝你们测试部署成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1470369/201901/1470369-20190121223249923-1739924259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　登陆的账号密码在&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
--&lt;span&gt;密码文件在root用户目录下
&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; /root/&lt;span&gt;keystonerc_admin
复制OS_USERNAME&lt;/span&gt;=&lt;span&gt;admin
     OS_PASSWORD&lt;/span&gt;=XXXX
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结束语&lt;/p&gt;
&lt;p&gt;　　这次的部署获益良多，要感谢阿里云yum源的一个功能，就是在页面可以支持搜索包，这样我就知道这个包在哪个文件夹下，也是感谢清华yum源的给力，通过在阿里yum搜索到的包，去清华yum源找到对应的页面 ，一步步配置到第一步设置的yum中。才能正常的安装这个一键安装包。否则在vpn的龟速下是很难正常完成一键部署的安装，这个一键部署的openstack 主要还是用来体会一下openstack是一个怎么样使用的。我从了解到部署成功也是 断断续续花了接近两天的时间，每一次的探索都感觉对于部署各种应用有熟悉的感觉。&lt;/p&gt;

</description>
<pubDate>Mon, 21 Jan 2019 14:44:00 +0000</pubDate>
<dc:creator>木直</dc:creator>
<og:description>centos 7 -openstack 一键部署</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/muzhifei/p/10301417.html</dc:identifier>
</item>
<item>
<title>关于weblogic部署Java项目的包冲突问题 - sunshine6</title>
<link>http://www.cnblogs.com/sunshine6/p/10301372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine6/p/10301372.html</guid>
<description>&lt;p&gt;　　我们可能会用各种应用服务部署我们的Java应用，比如Tomcat、WAS、weblogic等。Tomcat和WAS可能会比较少遇到一些奇怪的问题，但是用weblogic部署项目则经常遇到一些比如包冲突问题，路径问题等奇怪但又常见的问题。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　今天我就讲讲关于weblogic部署Java项目包冲突的问题。下面我举个例子：&lt;/p&gt;
&lt;p&gt;　　当我在weblogic部署Java项目之后，启动没报任何错，没有异常。但是当我操作某个功能的时候页面就报错了：&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1014963/201901/1014963-20190121211219072-754764889.png&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后台报了这个错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Root cause of ServletException.
java.lang.LinkageError: loader constraint violation: loader (instance of weblogic&lt;/span&gt;/utils/classloaders/ChangeAwareClassLoader) &lt;br/&gt;previously initiated loading for a different type with name &quot;javax/xml/namespace/QName&quot;&lt;span&gt;
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at weblogic.utils.classloaders.GenericClassLoader.defineClass(GenericClassLoader.java:343)
    at weblogic.utils.classloaders.GenericClassLoader.findLocalClass(GenericClassLoader.java:302)
    at weblogic.utils.classloaders.GenericClassLoader.findClass(GenericClassLoader.java:270)
    at weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(ChangeAwareClassLoader.java:64)
    at weblogic.utils.classloaders.ChangeAwareClassLoader.loadClass(ChangeAwareClassLoader.java:49)
    at java.lang.Class.getDeclaredMethods0(Native Method)
    at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
    at java.lang.Class.privateGetMethodRecursive(Class.java:3048)
    at java.lang.Class.getMethod0(Class.java:3018)
    at java.lang.Class.getMethod(Class.java:1784)
    at org.apache.xmlbeans.XmlBeans.buildMethod(XmlBeans.java:174)
    at org.apache.xmlbeans.XmlBeans.buildNoArgMethod(XmlBeans.java:190)
    at org.apache.xmlbeans.XmlBeans.buildGetContextTypeLoaderMethod(XmlBeans.java:200)
    at org.apache.xmlbeans.XmlBeans.&amp;lt;clinit&amp;gt;(XmlBeans.java:126)
    at org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbook$Factory.newInstance(Unknown Source)
    at org.apache.poi.xssf.usermodel.XSSFWorkbook.onWorkbookCreate(XSSFWorkbook.java:290)
    at org.apache.poi.xssf.usermodel.XSSFWorkbook.&amp;lt;init&amp;gt;(XSSFWorkbook.java:170)
    at com.kayak.web.base.util.export.ExportExcelXSSF.export(ExportExcelXSSF.java:893)
    at com.kayak.web.base.action.ExportExcelAction.exportExcel(ExportExcelAction.java:318)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706)
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)
    at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:868)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
    at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)
    at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)
    at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:301)
    at weblogic.servlet.internal.TailFilter.doFilter(TailFilter.java:26)
    at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:60)
    at com.kayak.web.user.filter.LoginCertifyFilter.doFilter(LoginCertifyFilter.java:125)
    at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:60)
    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)
    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)
    at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:60)
    at com.kayak.web.base.filter.LocalRequestFilter.doFilter(LocalRequestFilter.java:28)
    at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:60)
    at weblogic.servlet.internal.RequestEventsFilter.doFilter(RequestEventsFilter.java:27)
    at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:60)
    at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.wrapRun(WebAppServletContext.java:3748)
    at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3714)
    at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
    at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:120)
    at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2283)
    at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2182)
    at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1499)
    at weblogic.work.ExecuteThread.execute(ExecuteThread.java:263)
    at weblogic.work.ExecuteThread.run(ExecuteThread.java:221)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　错误内容很长，但是要学会辨认，我刚开始就被一大堆错误误导了。关键的都是下面的这个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
loader (instance of weblogic/utils/classloaders/ChangeAwareClassLoader) 
previously initiated loading &lt;span&gt;for&lt;/span&gt; a different type &lt;span&gt;with&lt;/span&gt; name &quot;javax/xml/namespace/QName&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　大概意思就是“加载器之前启动的时候加载了名字叫javax/xml/namespace/QName的其他类型的类”。其实转换一下就是，在启动的时候加载了一个javax/xml/namespace/QName类，我们现在要用的功能需要一个类也叫javax/xml/namespace/QName，但是这个不是我们真正想要的class。&lt;/p&gt;
&lt;p&gt;　　从上面的意思可以知道，这就是有两个相同包包路径和类名称的class，但是有一个想要的却没有，只有一个我们并不想要的class。了解weblogic部署的同学都知道，weblogic加载了一个相同的class就不会在加载其他一样的class了。&lt;/p&gt;
&lt;p&gt;　　当我再操作一次的之后又报另一个错（部分错误内容）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Root cause of ServletException.
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;java.lang.NoClassDefFoundError: Could not initialize class org.apache.xmlbeans.XmlBeans
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    at org.openxmlformats.schemas.spreadsheetml.x2006.main.CTWorkbook$Factory.newInstance(Unknown Source)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     at org.apache.poi.xssf.usermodel.XSSFWorkbook.onWorkbookCreate(XSSFWorkbook.java:290&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     at org.apache.poi.xssf.usermodel.XSSFWorkbook.&amp;lt;init&amp;gt;(XSSFWorkbook.java:170&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     at com.kayak.web.base.util.export.ExportExcelXSSF.export(ExportExcelXSSF.java:893&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     at com.kayak.web.base.action.ExportExcelAction.exportExcel(ExportExcelAction.java:318&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     at java.lang.reflect.Method.invoke(Method.java:498)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就是说不能初始化class  org.apache.xmlbeans.XmlBeans。但是我们不要被这个所误导，关键还是在于上面的  javax/xml/namespace/QName ，就是因为这个冲突了所以才会导致后面的问题发生。&lt;/p&gt;
&lt;p&gt;　　我用 jfind.jar  在项目下的lib目录下搜索发现在axis-jaxrpc-1.4.jar下有 javax/xml/namespace/QName.class文件。因为在jdk下的 rt.jar 下面也有 javax/xml/namespace/QName.class所以就会有两个一样的class文件。&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;https://img2018.cnblogs.com/blog/1014963/201901/1014963-20190121215408217-705987515.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后面我发现在项目的 WEB-INF 下面有个 weblogic.xml 文件，里面就有一些关于weblogic的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;weblogic-web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;container-descriptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prefer-web-inf-classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prefer-web-inf-classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;container-descriptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;charset-params&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input-charset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource-path&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource-path&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java-charset-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java-charset-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input-charset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;charset-params&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;weblogic-web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个配置文件里的第4行配置就是只先加载项目里的class文件，再加载weblogic的class，也就是因为这个配置而导致了项目里的axis-jaxrpc-1.4.jar下有 javax/xml/namespace/QName.class，jdk下的 rt.jar 下面也有 javax/xml/namespace/QName.class却没有加载到，但是后者才是程序所需要的。&lt;/p&gt;
&lt;p&gt;　　因此，我就尝试把weblogic.xml的第4行配置 改成 false，重新打war包，重新部署，然后发现问题解决了。&lt;/p&gt;
&lt;p&gt;　　接着我又换了一种尝试，就是weblogic.xml的第4行配置依然是true ，但是我把项目里那个冲突的class所在的包 axis-jaxrpc-1.4.jar 删了，也重新打包部署，也没有问题了。所以到此就把问题给解决了&lt;/p&gt;
&lt;p&gt;　　总结：&lt;/p&gt;
&lt;p&gt;　　　　1.  在weblogic中部署Java应用时，经常遇到包冲突问题，其实首先可以通过修改weblogic.xml配置来解决，另一种方式就是通过jfind.jar 找出冲突的class所在的包，直接把这个包删了，可以解决。&lt;/p&gt;
&lt;p&gt;　　　　2.  包冲突问题都可以通过上面的两种方式解决，还有就是 有时候可能会包找不到某个class文件，其实很有可能就是因为class文件冲突，以及先后加载的顺序问题，导致我们项目中真正需要的class文件却没有被加载进来。&lt;/p&gt;




</description>
<pubDate>Mon, 21 Jan 2019 14:29:00 +0000</pubDate>
<dc:creator>sunshine6</dc:creator>
<og:description>我们可能会用各种应用服务部署我们的Java应用，比如Tomcat、WAS、weblogic等。Tomcat和WAS可能会比较少遇到一些奇怪的问题，但是用weblogic部署项目则经常遇到一些比如包冲突</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine6/p/10301372.html</dc:identifier>
</item>
<item>
<title>ffplay源码分析2-数据结构 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/10301253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/10301253.html</guid>
<description>&lt;p&gt;“ffplay源码分析”系列文章如下：&lt;br/&gt;[1]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10301215.html&quot;&gt;ffplay源码分析1-概述&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析2-数据结构&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;http://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析3-代码框架&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;http://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析4-音视频同步&lt;/a&gt;&lt;br/&gt;[5]. &lt;a href=&quot;http://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析5-图像格式转换&lt;/a&gt;&lt;br/&gt;[6]. &lt;a href=&quot;http://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析6-音频重采样&lt;/a&gt;&lt;br/&gt;[7]. &lt;a href=&quot;http://www.cnblogs.com/leisure_chn/p/10301253.html&quot;&gt;ffplay源码分析7-播放控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;几个关键的数据结构如下：&lt;/p&gt;
&lt;h2 id=&quot;struct-videostate&quot;&gt;2.1 struct VideoState&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct VideoState {
    SDL_Thread *read_tid;           // demux解复用线程
    AVInputFormat *iformat;
    int abort_request;
    int force_refresh;
    int paused;
    int last_paused;
    int queue_attachments_req;
    int seek_req;                   // 标识一次SEEK请求
    int seek_flags;                 // SEEK标志，诸如AVSEEK_FLAG_BYTE等
    int64_t seek_pos;               // SEEK的目标位置(当前位置+增量)
    int64_t seek_rel;               // 本次SEEK的位置增量
    int read_pause_return;
    AVFormatContext *ic;
    int realtime;

    Clock audclk;                   // 音频时钟
    Clock vidclk;                   // 视频时钟
    Clock extclk;                   // 外部时钟

    FrameQueue pictq;               // 视频frame队列
    FrameQueue subpq;               // 字幕frame队列
    FrameQueue sampq;               // 音频frame队列

    Decoder auddec;                 // 音频解码器
    Decoder viddec;                 // 视频解码器
    Decoder subdec;                 // 字幕解码器

    int audio_stream;               // 音频流索引

    int av_sync_type;

    double audio_clock;             // 每个音频帧更新一下此值，以pts形式表示
    int audio_clock_serial;         // 播放序列，seek可改变此值
    double audio_diff_cum; /* used for AV difference average computation */
    double audio_diff_avg_coef;
    double audio_diff_threshold;
    int audio_diff_avg_count;
    AVStream *audio_st;             // 音频流
    PacketQueue audioq;             // 音频packet队列
    int audio_hw_buf_size;          // SDL音频缓冲区大小(单位字节)
    uint8_t *audio_buf;             // 指向待播放的一帧音频数据，指向的数据区将被拷入SDL音频缓冲区。若经过重采样则指向audio_buf1，否则指向frame中的音频
    uint8_t *audio_buf1;            // 音频重采样的输出缓冲区
    unsigned int audio_buf_size; /* in bytes */ // 待播放的一帧音频数据(audio_buf指向)的大小
    unsigned int audio_buf1_size;   // 申请到的音频缓冲区audio_buf1的实际尺寸
    int audio_buf_index; /* in bytes */ // 当前音频帧中已拷入SDL音频缓冲区的位置索引(指向第一个待拷贝字节)
    int audio_write_buf_size;       // 当前音频帧中尚未拷入SDL音频缓冲区的数据量，audio_buf_size = audio_buf_index + audio_write_buf_size
    int audio_volume;               // 音量
    int muted;                      // 静音状态
    struct AudioParams audio_src;   // 音频frame的参数
#if CONFIG_AVFILTER
    struct AudioParams audio_filter_src;
#endif
    struct AudioParams audio_tgt;   // SDL支持的音频参数，重采样转换：audio_src-&amp;gt;audio_tgt
    struct SwrContext *swr_ctx;     // 音频重采样context
    int frame_drops_early;          // 丢弃视频packet计数
    int frame_drops_late;           // 丢弃视频frame计数

    enum ShowMode {
        SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB
    } show_mode;
    int16_t sample_array[SAMPLE_ARRAY_SIZE];
    int sample_array_index;
    int last_i_start;
    RDFTContext *rdft;
    int rdft_bits;
    FFTSample *rdft_data;
    int xpos;
    double last_vis_time;
    SDL_Texture *vis_texture;
    SDL_Texture *sub_texture;
    SDL_Texture *vid_texture;

    int subtitle_stream;                // 字幕流索引
    AVStream *subtitle_st;              // 字幕流
    PacketQueue subtitleq;              // 字幕packet队列

    double frame_timer;                 // 记录最后一帧播放的时刻
    double frame_last_returned_time;
    double frame_last_filter_delay;
    int video_stream;
    AVStream *video_st;                 // 视频流
    PacketQueue videoq;                 // 视频队列
    double max_frame_duration;      // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity
    struct SwsContext *img_convert_ctx;
    struct SwsContext *sub_convert_ctx;
    int eof;

    char *filename;
    int width, height, xleft, ytop;
    int step;

#if CONFIG_AVFILTER
    int vfilter_idx;
    AVFilterContext *in_video_filter;   // the first filter in the video chain
    AVFilterContext *out_video_filter;  // the last filter in the video chain
    AVFilterContext *in_audio_filter;   // the first filter in the audio chain
    AVFilterContext *out_audio_filter;  // the last filter in the audio chain
    AVFilterGraph *agraph;              // audio filter graph
#endif

    int last_video_stream, last_audio_stream, last_subtitle_stream;

    SDL_cond *continue_read_thread;
} VideoState;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;struct-clock&quot;&gt;2.2 struct Clock&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct Clock {
    // 当前帧(待播放)显示时间戳，播放后，当前帧变成上一帧
    double pts;           /* clock base */
    // 当前帧显示时间戳与当前系统时钟时间的差值
    double pts_drift;     /* clock base minus time at which we updated the clock */
    // 当前时钟(如视频时钟)最后一次更新时间，也可称当前时钟时间
    double last_updated;
    // 时钟速度控制，用于控制播放速度
    double speed;
    // 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列
    int serial;           /* clock is based on a packet with this serial */
    // 暂停标志
    int paused;
    // 指向packet_serial
    int *queue_serial;    /* pointer to the current packet queue serial, used for obsolete clock detection */
} Clock;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;struct-packetqueue&quot;&gt;2.3 struct PacketQueue&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct PacketQueue {
    MyAVPacketList *first_pkt, *last_pkt;
    int nb_packets;                 // 队列中packet的数量
    int size;                       // 队列所占内存空间大小
    int64_t duration;               // 队列中所有packet总的播放时长
    int abort_request;
    int serial;                     // 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列
    SDL_mutex *mutex;
    SDL_cond *cond;
} PacketQueue;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;栈(LIFO)是一种表，队列(FIFO)也是一种表。数组是表的一种实现方式，链表也是表的一种实现方式，例如FIFO既可以用数组实现，也可以用链表实现。PacketQueue是用链表实现的一个FIFO。&lt;/p&gt;
&lt;h2 id=&quot;struct-framequeue&quot;&gt;2.4 struct FrameQueue&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct FrameQueue {
    Frame queue[FRAME_QUEUE_SIZE];
    int rindex;                     // 读索引。待播放时读取此帧进行播放，播放后此帧成为上一帧
    int windex;                     // 写索引
    int size;                       // 总帧数
    int max_size;                   // 队列可存储最大帧数
    int keep_last;                  // 是否保留已播放的最后一帧使能标志
    int rindex_shown;               // 是否保留已播放的最后一帧实现手段
    SDL_mutex *mutex;
    SDL_cond *cond;
    PacketQueue *pktq;              // 指向对应的packet_queue
} FrameQueue;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FrameQueue是一个环形缓冲区(ring buffer)，是用数组实现的一个FIFO。下面先讲一下环形缓冲区的基本原理，其示意图如下：&lt;br/&gt;&lt;img src=&quot;https://leichn.github.io/img/ffplay_analysis/ring_buffer.png&quot; title=&quot;ring_buffer示意图&quot; alt=&quot;ring buffer示意图&quot;/&gt;&lt;br/&gt;环形缓冲区的一个元素被用掉后，其余元素不需要移动其存储位置。相反，一个非环形缓冲区在用掉一个元素后，其余元素需要向前搬移。换句话说，环形缓冲区适合实现FIFO，而非环形缓冲区适合实现LIFO。环形缓冲区适合于事先明确了缓冲区的最大容量的情形。扩展一个环形缓冲区的容量，需要搬移其中的数据。因此一个缓冲区如果需要经常调整其容量，用链表实现更为合适。&lt;/p&gt;
&lt;p&gt;环形缓冲区使用中要避免读空和写满，但空和满状态下读指针和写指针均相等，因此其实现中的关键点就是如何区分出空和满。有多种策略可以用来区分空和满的标志：&lt;br/&gt;1) 总是保持一个存储单元为空：“读指针”==“写指针”时为空，“读指针”==“写指针+1”时为满；&lt;br/&gt;2) 使用有效数据计数：每次读写都更新数据计数，计数等于0时为空，等于BUF_SIZE时为满；&lt;br/&gt;3) 记录最后一次操作：用一个标志记录最后一次是读还是写，在“读指针”==“写指针”时若最后一次是写，则为满状态；若最后一次是读，则为空状态。&lt;/p&gt;
&lt;p&gt;可以看到，FrameQueue使用上述第2种方式，使用FrameQueue.size记录环形缓冲区中元素数量，作为有效数据计数。&lt;br/&gt;ffplay中创建了三个frame_queue：音频frame_queue，视频frame_queue，字幕frame_queue。每一个frame_queue一个写端一个读端，写端位于解码线程，读端位于播放线程。&lt;br/&gt;为了叙述方便，环形缓冲区的一个元素也称作节点(或帧)，将rindex称作读指针或读索引，将windex称作写指针或写索引，叫法用混用的情况，不作文字上的严格区分。&lt;/p&gt;
&lt;h3 id=&quot;初始化与销毁&quot;&gt;2.4.1 初始化与销毁&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last)
{
    int i;
    memset(f, 0, sizeof(FrameQueue));
    if (!(f-&amp;gt;mutex = SDL_CreateMutex())) {
        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateMutex(): %s\n&quot;, SDL_GetError());
        return AVERROR(ENOMEM);
    }
    if (!(f-&amp;gt;cond = SDL_CreateCond())) {
        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateCond(): %s\n&quot;, SDL_GetError());
        return AVERROR(ENOMEM);
    }
    f-&amp;gt;pktq = pktq;
    f-&amp;gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);
    f-&amp;gt;keep_last = !!keep_last;
    for (i = 0; i &amp;lt; f-&amp;gt;max_size; i++)
        if (!(f-&amp;gt;queue[i].frame = av_frame_alloc()))
            return AVERROR(ENOMEM);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;队列初始化函数确定了队列大小，将为队列中每一个节点的frame(&lt;code&gt;f-&amp;gt;queue[i].frame&lt;/code&gt;)分配内存，注意只是分配frame对象本身，而不关注frame中的数据缓冲区。frame中的数据缓冲区是AVBuffer，使用引用计数机制。&lt;br/&gt;&lt;code&gt;f-&amp;gt;max_size&lt;/code&gt;是队列的大小，此处值为16，细节不展开。&lt;br/&gt;&lt;code&gt;f-&amp;gt;keep_last&lt;/code&gt;是队列中是否保留最后一次播放的帧的标志。&lt;code&gt;f-&amp;gt;keep_last = !!keep_last&lt;/code&gt;是将int取值的keep_last转换为boot取值(0或1)。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void frame_queue_destory(FrameQueue *f)
{
    int i;
    for (i = 0; i &amp;lt; f-&amp;gt;max_size; i++) {
        Frame *vp = &amp;amp;f-&amp;gt;queue[i];
        frame_queue_unref_item(vp);     // 释放对vp-&amp;gt;frame中的数据缓冲区的引用，注意不是释放frame对象本身
        av_frame_free(&amp;amp;vp-&amp;gt;frame);      // 释放vp-&amp;gt;frame对象
    }
    SDL_DestroyMutex(f-&amp;gt;mutex);
    SDL_DestroyCond(f-&amp;gt;cond);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;队列销毁函数对队列中的每个节点作了如下处理：&lt;br/&gt;1) &lt;code&gt;frame_queue_unref_item(vp)&lt;/code&gt;释放本队列对vp-&amp;gt;frame中AVBuffer的引用&lt;br/&gt;2) &lt;code&gt;av_frame_free(&amp;amp;vp-&amp;gt;frame)&lt;/code&gt;释放vp-&amp;gt;frame对象本身&lt;/p&gt;
&lt;h3 id=&quot;写队列&quot;&gt;2.4.2 写队列&lt;/h3&gt;
&lt;p&gt;写队列的步骤是：&lt;br/&gt;1) 获取写指针(若写满则等待)；&lt;br/&gt;2) 将元素写入队列；&lt;br/&gt;3) 更新写指针。&lt;br/&gt;写队列涉及下列两个函数：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;frame_queue_peek_writable()     // 获取写指针
frame_queue_push()              // 更新写指针&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实例看一下写队列的用法：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static int queue_picture(VideoState *is, AVFrame *src_frame, double pts, double duration, int64_t pos, int serial)
{
    Frame *vp;

    if (!(vp = frame_queue_peek_writable(&amp;amp;is-&amp;gt;pictq)))
        return -1;

    vp-&amp;gt;sar = src_frame-&amp;gt;sample_aspect_ratio;
    vp-&amp;gt;uploaded = 0;

    vp-&amp;gt;width = src_frame-&amp;gt;width;
    vp-&amp;gt;height = src_frame-&amp;gt;height;
    vp-&amp;gt;format = src_frame-&amp;gt;format;

    vp-&amp;gt;pts = pts;
    vp-&amp;gt;duration = duration;
    vp-&amp;gt;pos = pos;
    vp-&amp;gt;serial = serial;

    set_default_window_size(vp-&amp;gt;width, vp-&amp;gt;height, vp-&amp;gt;sar);

    av_frame_move_ref(vp-&amp;gt;frame, src_frame);
    frame_queue_push(&amp;amp;is-&amp;gt;pictq);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面一段代码是视频解码线程向视频frame_queue中写入一帧的代码，步骤如下：&lt;br/&gt;1) &lt;code&gt;frame_queue_peek_writable(&amp;amp;is-&amp;gt;pictq)&lt;/code&gt;向队列尾部申请一个可写的帧空间，若队列已满无空间可写，则等待&lt;br/&gt;2) &lt;code&gt;av_frame_move_ref(vp-&amp;gt;frame, src_frame)&lt;/code&gt;将src_frame中所有数据拷贝到vp-&amp;gt;&lt;br/&gt;frame并复位src_frame，vp-&amp;gt;&lt;br/&gt;frame中AVBuffer使用引用计数机制，不会执行AVBuffer的拷贝动作，仅是修改指针指向值。为避免内存泄漏，在&lt;code&gt;av_frame_move_ref(dst, src)&lt;/code&gt;之前应先调用&lt;code&gt;av_frame_unref(dst)&lt;/code&gt;，这里没有调用，是因为frame_queue在删除一个节点时，已经释放了frame及frame中的AVBuffer。&lt;br/&gt;3) &lt;code&gt;frame_queue_push(&amp;amp;is-&amp;gt;pictq)&lt;/code&gt;此步仅将frame_queue中的写指针加1，实际的数据写入在此步之前已经完成。&lt;/p&gt;
&lt;p&gt;frame_queue写操作相关函数实现如下：&lt;br/&gt;&lt;strong&gt;frame_queue_peek_writable()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static Frame *frame_queue_peek_writable(FrameQueue *f)
{
    /* wait until we have space to put a new frame */
    SDL_LockMutex(f-&amp;gt;mutex);
    while (f-&amp;gt;size &amp;gt;= f-&amp;gt;max_size &amp;amp;&amp;amp;
           !f-&amp;gt;pktq-&amp;gt;abort_request) {
        SDL_CondWait(f-&amp;gt;cond, f-&amp;gt;mutex);
    }
    SDL_UnlockMutex(f-&amp;gt;mutex);

    if (f-&amp;gt;pktq-&amp;gt;abort_request)
        return NULL;

    return &amp;amp;f-&amp;gt;queue[f-&amp;gt;windex];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向队列尾部申请一个可写的帧空间，若无空间可写，则等待&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;frame_queue_push()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void frame_queue_push(FrameQueue *f)
{
    if (++f-&amp;gt;windex == f-&amp;gt;max_size)
        f-&amp;gt;windex = 0;
    SDL_LockMutex(f-&amp;gt;mutex);
    f-&amp;gt;size++;
    SDL_CondSignal(f-&amp;gt;cond);
    SDL_UnlockMutex(f-&amp;gt;mutex);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向队列尾部压入一帧，只更新计数与写指针，因此调用此函数前应将帧数据写入队列相应位置&lt;/p&gt;
&lt;h3 id=&quot;读队列&quot;&gt;2.4.3 读队列&lt;/h3&gt;
&lt;p&gt;写队列中，应用程序写入一个新帧后通常总是将写指针加1。而读队列中，“读取”和“更新读指针(同时删除旧帧)”二者是独立的，可以只读取而不更新读指针，也可以只更新读指针(只删除)而不读取。而且读队列引入了是否保留已显示的最后一帧的机制，导致读队列比写队列要复杂很多。&lt;/p&gt;
&lt;p&gt;读队列和写队列步骤是类似的，基本步骤如下：&lt;br/&gt;1) 获取读指针(若读空则等待)；&lt;br/&gt;2) 读取一个节点；&lt;br/&gt;3) 更新写指针(同时删除旧节点)。&lt;br/&gt;写队列涉及如下函数：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;frame_queue_peek_readable()     // 获取读指针(若读空则等待)
frame_queue_peek()              // 获取当前节点指针
frame_queue_peek_next()         // 获取下一节点指针
frame_queue_peek_last()         // 获取上一节点指针
frame_queue_next()              // 更新读指针(同时删除旧节点)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实例看一下读队列的用法：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void video_refresh(void *opaque, double *remaining_time)
{
    ......
    if (frame_queue_nb_remaining(&amp;amp;is-&amp;gt;pictq) == 0) {    // 所有帧已显示
        // nothing to do, no picture to display in the queue
    } else {
        Frame *vp, *lastvp;
        lastvp = frame_queue_peek_last(&amp;amp;is-&amp;gt;pictq);     // 上一帧：上次已显示的帧
        vp = frame_queue_peek(&amp;amp;is-&amp;gt;pictq);              // 当前帧：当前待显示的帧
        frame_queue_next(&amp;amp;is-&amp;gt;pictq);                   // 删除上一帧，并更新rindex
        video_display(is)--&amp;gt;video_image_display()--&amp;gt;frame_queue_peek_last();
    }
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面一段代码是视频播放线程从视频frame_queue中读取视频帧进行显示的基本步骤，其他代码已省略，只保留了读队列部分。&lt;code&gt;video_refresh()&lt;/code&gt;的实现详情可参考第3节。&lt;br/&gt;记lastvp为上一次已播放的帧，vp为本次待播放的帧，下图中方框中的数字表示显示序列中帧的序号(实际就是&lt;code&gt;Frame.frame.display_picture_number&lt;/code&gt;变量值)。&lt;br/&gt;&lt;img src=&quot;https://leichn.github.io/img/ffplay_analysis/frame_queue.jpg&quot; title=&quot;frame_queue示意图&quot; alt=&quot;frame_queue示意图&quot;/&gt;&lt;br/&gt;在启用keep_last机制后，rindex_shown值总是为1，rindex_shown确保了最后播放的一帧总保留在队列中。&lt;br/&gt;假设某次进入&lt;code&gt;video_refresh()&lt;/code&gt;的时刻为T0，下次进入的时刻为T1。在T0时刻，读队列的步骤如下：&lt;br/&gt;1) rindex(图中ri)表示上一次播放的帧lastvp，本次调用&lt;code&gt;video_refresh()&lt;/code&gt;中，lastvp会被删除，rindex会加1&lt;br/&gt;2) rindex+rindex_shown(图中ris)表示本次待播放的帧vp，本次调用&lt;code&gt;video_refresh()&lt;/code&gt;中，vp会被读出播放&lt;br/&gt;图中已播放的帧是灰色方框，本次待播放的帧是黑色方框，其他未播放的帧是绿色方框，队列中空位置为白色方框。&lt;br/&gt;在之后的某一时刻TX，首先调用&lt;code&gt;frame_queue_nb_remaining()&lt;/code&gt;判断是否有帧未播放，若无待播放帧，函数&lt;code&gt;video_refresh()&lt;/code&gt;直接返回，不往下执行。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/* return the number of undisplayed frames in the queue */
static int frame_queue_nb_remaining(FrameQueue *f)
{
    return f-&amp;gt;size - f-&amp;gt;rindex_shown;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rindex_shown为1时，队列中总是保留了最后一帧lastvp(灰色方框)。按照这样的设计思路，如果rindex_shown为2，队列中就会保留最后2帧。&lt;br/&gt;&lt;span&gt;但keep_last机制有什么用途呢？希望知道的同学指点一下。&lt;/span&gt;&lt;br/&gt;注意，在TX时刻，无新帧可显示，保留的一帧是已经显示过的。那么最后一帧什么时候被清掉呢？在播放结束或用户中途取消播放时，会调用&lt;code&gt;frame_queue_destory()&lt;/code&gt;清空播放队列。&lt;/p&gt;
&lt;p&gt;rindex_shown的引入增加了读队列操作的理解难度。大多数读操作函数都会用到这个变量。&lt;br/&gt;通过&lt;code&gt;FrameQueue.keep_last&lt;/code&gt;和&lt;code&gt;FrameQueue.rindex_shown&lt;/code&gt;两个变量实现了保留最后一次播放帧的机制。&lt;br/&gt;是否启用keep_last机制是由全局变量&lt;code&gt;keep_last&lt;/code&gt;值决定的，在队列初始化函数&lt;code&gt;frame_queue_init()&lt;/code&gt;中有&lt;code&gt;f-&amp;gt;keep_last = !!keep_last;&lt;/code&gt;，而在更新读指针函数&lt;code&gt;frame_queue_next()&lt;/code&gt;中如果启用keep_last机制，则&lt;code&gt;f-&amp;gt;rindex_shown&lt;/code&gt;值为1。如果rindex_shown对理解代码造成了困扰，可以先将全局变量&lt;code&gt;keep_last&lt;/code&gt;值赋为0，这样&lt;code&gt;f-&amp;gt;rindex_shown&lt;/code&gt;值为0，代码看起来会清晰很多。理解了读队列的基本方法后，再看&lt;code&gt;f-&amp;gt;rindex_shown&lt;/code&gt;值为1时代码是如何运行的。&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;frame_queue_next()&lt;/code&gt;函数：&lt;br/&gt;&lt;strong&gt;frame_queue_next()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static void frame_queue_next(FrameQueue *f)
{
    if (f-&amp;gt;keep_last &amp;amp;&amp;amp; !f-&amp;gt;rindex_shown) {
        f-&amp;gt;rindex_shown = 1;
        return;
    }
    frame_queue_unref_item(&amp;amp;f-&amp;gt;queue[f-&amp;gt;rindex]);
    if (++f-&amp;gt;rindex == f-&amp;gt;max_size)
        f-&amp;gt;rindex = 0;
    SDL_LockMutex(f-&amp;gt;mutex);
    f-&amp;gt;size--;
    SDL_CondSignal(f-&amp;gt;cond);
    SDL_UnlockMutex(f-&amp;gt;mutex);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个动作：删除rindex节点(lastvp)，更新&lt;code&gt;f-&amp;gt;rindex&lt;/code&gt;和&lt;code&gt;f-&amp;gt;size&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;frame_queue_peek_readable()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static Frame *frame_queue_peek_readable(FrameQueue *f)
{
    /* wait until we have a readable a new frame */
    SDL_LockMutex(f-&amp;gt;mutex);
    while (f-&amp;gt;size - f-&amp;gt;rindex_shown &amp;lt;= 0 &amp;amp;&amp;amp;
           !f-&amp;gt;pktq-&amp;gt;abort_request) {
        SDL_CondWait(f-&amp;gt;cond, f-&amp;gt;mutex);
    }
    SDL_UnlockMutex(f-&amp;gt;mutex);

    if (f-&amp;gt;pktq-&amp;gt;abort_request)
        return NULL;

    return &amp;amp;f-&amp;gt;queue[(f-&amp;gt;rindex + f-&amp;gt;rindex_shown) % f-&amp;gt;max_size];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从队列头部读取一帧(vp)，只读取不删除，若无帧可读则等待。这个函数和&lt;code&gt;frame_queue_peek()&lt;/code&gt;的区别仅仅是多了不可读时等待的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;frame_queue_peek()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static Frame *frame_queue_peek(FrameQueue *f)
{
    return &amp;amp;f-&amp;gt;queue[(f-&amp;gt;rindex + f-&amp;gt;rindex_shown) % f-&amp;gt;max_size];
}

static Frame *frame_queue_peek_next(FrameQueue *f)
{
    return &amp;amp;f-&amp;gt;queue[(f-&amp;gt;rindex + f-&amp;gt;rindex_shown + 1) % f-&amp;gt;max_size];
}

// 取出此帧进行播放，只读取不删除，不删除是因为此帧需要缓存下来供下一次使用。播放后，此帧变为上一帧
static Frame *frame_queue_peek_last(FrameQueue *f)
{
    return &amp;amp;f-&amp;gt;queue[f-&amp;gt;rindex];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从队列头部读取一帧(vp)，只读取不删除。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 13:55:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>“ffplay源码分析”系列文章如下： '1]. [ffplay源码分析1 概述' '2]. [ffplay源码分析2 数据结构' '3]. [ffplay源码分析3 代码框架' '4]. [ffpl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leisure_chn/p/10301253.html</dc:identifier>
</item>
<item>
<title>07 JVM 是如何实现反射的 - 黑_子</title>
<link>http://www.cnblogs.com/yuepenglei/p/10301213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuepenglei/p/10301213.html</guid>
<description>&lt;h4 id=&quot;java-中的反射&quot;&gt;Java 中的反射&lt;/h4&gt;
&lt;p&gt;反射是 Java 语言的一个相当重要的特性，它允许正在运行的 Java 程序观测，甚至是修改程序的动态行为。&lt;/p&gt;
&lt;p&gt;我们可以通过 Class 对象枚举该类中的所有方法，还可以通过 Method.SetAccessible 让过 Java 语言的访问权限，在私有方法所在类之外的地方调用该方法。&lt;/p&gt;
&lt;p&gt;反射在 Java 中的引用十分广泛。日常我们用的 Java 继承开发工具 IDE 便运用了这一功能。比如，敲下点号时，IDE便会根据点号之前的内容动态的展示可以访问的字段或者方法。Java 调试器，能够在调试过程中枚举某一对象所有字段的值。当然，这些功能的实现也用到了语法树。在 Web 开发中，我们接触到的各种通用框架。为了保证框架的可扩展性，旺旺借助 Java 的反射机制，根据配置文件加载不同的类。例如 Spring 框架的以来反转 IOC。&lt;/p&gt;
&lt;h4 id=&quot;反射调用的实现&quot;&gt;反射调用的实现&lt;/h4&gt;
&lt;p&gt;首先，看一下 Method.invoke 的实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class Method extends Executable {
  ...
  public Object invoke(Object obj, Object... args) throws ... {
    ... // 权限检查
    MethodAccessor ma = methodAccessor;
    if (ma == null) {
      ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，invoke 方法实际上委派给了 MethodAccessor 来处理。MethodAccessor 是一个接口，有两个具体的实现。一个是通过本地方法来实现反射调用，另一个则使用了委派模式。&lt;/p&gt;
&lt;p&gt;每个 Method 实例第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。在反射过程中，反射调用先是调用了 Method.invoke，然后进入委派实现 DelegatingMethodAccessorlmpl，再然后进入本地实现 NativeMethodAccessorlmpl，最后到达目标方法。&lt;/p&gt;
&lt;p&gt;有个疑问，为什么反射调用还要采取委托实现作为中间层，为何不直接交给本地实现？&lt;/p&gt;
&lt;p&gt;其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现(下称动态实现)来直接使用 invoke 指令来调用目标方法。之所以采用委派实现，是为了能够在本地实现和动态实现中切换。动态实现和本地实现相比，运行效率更高。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，单由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要更快。&lt;/p&gt;
&lt;p&gt;实际中，许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15，当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程叫 inflation。&lt;/p&gt;
&lt;p&gt;反射调用的 inflation 机制是可以通过参数(-Dsun.reflect.noinflation = true)来关闭的。这样一来，在反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。&lt;/p&gt;
&lt;h4 id=&quot;反射调用的开销&quot;&gt;反射调用的开销&lt;/h4&gt;
&lt;p&gt;在反射中 Class.forName，Class.getMethod 以及 Method.invoke 这三个方法，Class.forName 会调用本地方法，Class.getMethod 会遍历该类的共有方法。如果没有匹配，则会遍历父类的方法。在以 getMethod 为代表的查找方法操作中，会返回查找得到结果的一份拷贝。因此，应该避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。实际开发中，我们也往往会缓存 Class.forName，Class.getMethod 的结果，因此，下面只关注反射调用本身的性能开销。&lt;/p&gt;
&lt;p&gt;第一，Method.invoke 中的第二个参数是一个可以变长度的 Object 数组，数组中存放的都是对象类型。如果我们存入参数是基本类型，可以提前装箱，减少性能损耗。&lt;/p&gt;
&lt;p&gt;第二，可以关闭反射调用的 inflation 机制，从而取消委派实现，并且直接使用动态实现。&lt;/p&gt;
&lt;p&gt;第三，每次反射调用都会检查目标方法的权限，而这个检查同样可以在 Java 代码里关闭。&lt;/p&gt;
&lt;h4 id=&quot;反射-api-简介&quot;&gt;反射 API 简介&lt;/h4&gt;
&lt;p&gt;使用反射 API 第一步便是获取 Class 对象。获取对象有以下三种方式：&lt;br/&gt;1：使用静态方法 Class.forName 来获取&lt;br/&gt;2：调用对象的 getClass 方法&lt;br/&gt;3：直接使用 类名+“.class” 访问。对于基本类型来说，他们的包装类型拥有一个名为 &quot;TYPE&quot; 的 final 静态字段，指向该基本类型对应的 Class 对象。&lt;/p&gt;
&lt;p&gt;例如，Integer.TYPE 指向 int.class。对于数组类型来说，可以使用 类名+[].class 来访问，如 int[].class。&lt;/p&gt;
&lt;p&gt;除此之外，Class 类和 java.lang.reflect 包中还提供了许多返回 Class 对象的方法。&lt;/p&gt;
&lt;p&gt;获得 Class 对象之后，就可以正式使用反射功能了。下列为常用的几项：&lt;br/&gt;1：使用 newInstance() 生成一个该类的实例。该类必须有一个无参构造函数&lt;br/&gt;。&lt;br/&gt;2：使用 isInstance(Object) 判断一个对象是否是该类的实例，语法上等同于 instanceof。&lt;br/&gt;3：使用 Array.newInstance(Class,int) 来构造该类型的数组。&lt;br/&gt;4：使用 getFields()/getConstructors()/getMethods() 来访问该类的成员。&lt;/p&gt;
&lt;h4 id=&quot;问答&quot;&gt;问答&lt;/h4&gt;
&lt;h6 id=&quot;q当某个反射调用的调用次数在-15-之下时采用本地实现当达到-15-时便开始动态生成字节码...&quot;&gt;Q：当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码...&lt;/h6&gt;
&lt;p&gt;动态生成发生在第15次(从0开始数的话)，所以第15次比较耗时。&lt;/p&gt;
&lt;h6 id=&quot;q什么是-inflation-机制&quot;&gt;Q：什么是 inflation 机制&lt;/h6&gt;
&lt;p&gt;反射的inflation机制是当反射被频繁调用时，动态生成一个类来做直接调用的机制，可以加速反射调用&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文创作灵感来源于 极客时间 郑雨迪老师的《深入拆解 Java 虚拟机》课程，通过课后反思以及借鉴各位学友的发言总结，现整理出自己的知识架构，以便日后温故知新，查漏补缺。&lt;/p&gt;
&lt;h4 id=&quot;关注本人公众号第一时间获取最新文章发布每日更新一篇技术文章&quot;&gt;关注本人公众号，第一时间获取最新文章发布，每日更新一篇技术文章。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562380/201901/1562380-20190113225450069-1906096752.png&quot; alt=&quot;关注我就是给我最大的鼓励和支持&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 13:46:00 +0000</pubDate>
<dc:creator>黑_子</dc:creator>
<og:description>Java 中的反射 反射是 Java 语言的一个相当重要的特性，它允许正在运行的 Java 程序观测，甚至是修改程序的动态行为。 我们可以通过 Class 对象枚举该类中的所有方法，还可以通过 Met</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuepenglei/p/10301213.html</dc:identifier>
</item>
<item>
<title>OGG学习笔记05-OGG的版本 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10301139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10301139.html</guid>
<description>&lt;p&gt;刚接触OGG的时候，很容易被众多的版本搞晕，虽然官方有提供各版本对应认证OS和DB的表格。&lt;br/&gt;个人认为一个比较简单的方式，是直接去edelivery.oracle.com下载OGG，选定一个大版本后，这里以11.1（一个较旧的版本，这里只是举例说明），再选择自己可能用到的OS，得出的列表如下：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1387828/o_OGG11.1.1.1.2.PNG&quot;/&gt;&lt;br/&gt;把这张图片保存好，之后就可以根据实际需求去快速下载和部署（如果你的OGG环境选择的是其他大版本，也是同样的方法，不再赘述）。&lt;br/&gt;比如构建一个这样的OGG环境，有A\B\C三套数据库环境如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A(RHEL 4 + Oracle 9.2.0.8)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;B(WIN 2008 + Oracle 10.2.0.5)&lt;/li&gt;
&lt;li&gt;C(RHEL 7 + Oracle 11.2.0.4 RAC)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的同步需求待定，目前需要先各自部署好对应的OGG程序。根据上图，我们就可以只下载V28957-01.zip、V28987-01.zip、V28941-01.zip，将对应的程序压缩包再依次上传到A、B、C环境。&lt;br/&gt;ggs_Linux_x64_ora9i_64bit.tar（V28957-01.zip解压后得到）&lt;br/&gt;V28987-01.zip（可直接解压到Windows的d:\ogg目录下）&lt;br/&gt;fbo_ggs_Linux_x64_ora11g_64bit.tar（V28941-01.zip解压后得到）&lt;/p&gt;
&lt;p&gt;为后续OGG的系列测试做准备，我这里在所有Linux环境（A\C）下都新建了一个ogg用户，而Windows环境（B）就直接使用Administrator用户。&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;新建的ogg用户需要有LD_LIBRARY_PATH这个环境变量，ogg解压就算安装完成，以第一个9i环境为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--新建ogg用户
useradd ogg -g oinstall
passwd ogg
mkdir /ogg
chown ogg.oinstall /ogg

--ogg用户下tar解压ogg安装包到/ogg目录下
[ogg@db09 ogg]$ tar -xvf /public/DBM/OGG/OGG11.1/ggs_Linux_x64_ora9i_64bit.tar 

--ogg用户环境变量：
vi ~/.bash_profile 增加一行变量：
export LD_LIBRARY_PATH=/u01/app/oracle/product/9.2.0/db_1/lib:/lib:/usr/lib:/lib64:/usr/lib64

--验证ggsci可以正常运行：
[root@db09 ~]# su - ogg
[ogg@db09 ~]$ cd /ogg
[ogg@db09 ogg]$ ./ggsci

Oracle GoldenGate Command Interpreter for Oracle
Version 11.1.1.1.2 OGGCORE_11.1.1.1.2_PLATFORMS_111004.2100 
Linux, x64, 64bit (optimized), Oracle 9i on Oct  4 2011 23:49:32

Copyright (C) 1995, 2011, Oracle and/or its affiliates. All rights reserved.



GGSCI (db09) 1&amp;gt; info all

Program     Status      Group       Lag           Time Since Chkpt

MANAGER     STOPPED                                           


GGSCI (db09) 2&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后再根据后续的实际需求进一步配置OGG环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果OGG同步的需求很简单，可参考OGG学习笔记基础篇：&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 13:40:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>刚接触OGG的时候，很容易被众多的版本搞晕，虽然官方有提供各版本对应认证OS和DB的表格。 个人认为一个比较简单的方式，是直接去edelivery.oracle.com下载OGG，选定一个大版本后，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10301139.html</dc:identifier>
</item>
<item>
<title>关于 JS 模块化的最佳实践总结 - 石桥码农</title>
<link>http://www.cnblogs.com/sban/p/10301143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sban/p/10301143.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/567788/201901/567788-20190121212830905-284679745.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;模块化开发是 JS 项目开发中的必备技能，它如同面向对象、设计模式一样，可以兼顾提升软件项目的可维护性和开发效率。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;模块之间通常以全局对象维系通讯。在小游戏中，GameGlobal 是全局对象。在小程序中，App 是全局对象，任何页面都可以使用 getApp() 获取这个全局对象。在 NodeJS 中，global 是全局对象。在传统浏览器宿主中，window 是全局对象。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;以下是作者总结的模块化实践经验。简言之，除了在浏览器项目中使用 sea.js，其它类型项目均建议直接使用原生的 ES6 模块规范。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CommonJS 规范&lt;/li&gt;
&lt;li&gt;AMD 规范&lt;/li&gt;
&lt;li&gt;CMD 规范&lt;/li&gt;
&lt;li&gt;ES6 模块规范&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;CommonJS 规范最早在 NodeJS 中实践并被推广开来。它使用 module.exports 输出模块，一个模块写在一个独立的文件内，一个文件即是一个模块。在另一个JS文件中，使用 require 导入模块。各个模块相互隔离，模块之间的通讯，通过全局对象 global 完成。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;值得特别注意的是，CommonJS 这种规范天生是为 NodeJS 服务的。NodeJS 是一种服务器端编程语言，源码文件都在硬盘上，读起来很方便。CommonJS 规范作为一种同步方案，后续代码必须等待前面的require指令加载模块完成。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;使用 CommonJS 规范的代码示例如下：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 定义模块math.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}
module.exports = { //在这里写上需要向外暴露的函数、变量
  add: add,
  basicNum: basicNum
}
// 在另一个文件中，引用自定义的模块时，参数包含路径，可省略后缀.js
var math = require('./math');
math.add(2, 5);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在小程序与小游戏的官方文档中，提到模块化时官方建议的规范即是 CommonJS 规范。但其实在作者看来，更适合小游戏/小程序开发的规范是 ES6 模块规范，原因稍后便会讲到。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;CommonJS 规范主要是为服务器端的 NodeJS 服务，服务器端加载模块文件无延时，但是在浏览器上就大不相同了。AMD 即是为了在浏览器宿主环境中实现模块化方案的规范之一。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;AMD是一种使用JS语言自实现的模块化规范方案，主要由require.config()、define()、require 三个函数实现。require.config() 用于声明基本路径和模块名称；define() 用于定义模块对象；require() 则用于加载模块并使用。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;与 CommonJS 规范不同，AMD 规范身处浏览器环境之中，是一种异步模块加载规范。在使用时，首先要加载模块化规范实现文件 require.js 及 JS 主文件，示例如下：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;/** 网页中引入require.js及main.js **/
&amp;lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在上面的 Html 代码中，&quot;js/require.js&quot; 是实现 AMD 规范的类库文件，是任何使用 AMD 规范的网页都需要加载的；&quot;js/main&quot; 是开发者的代码主文件，在这个文件中加载并使用自定义模块，示例代码如下：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config({
  baseUrl: &quot;js/lib&quot;,
  paths: {
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  }
});
// 执行基本操作
require([&quot;jquery&quot;,&quot;underscore&quot;,&quot;math&quot;],function($,_,math){//在这里$代表jqurey、_代表underscore
  var sum = math.add(10,20);
  $(&quot;#sum&quot;).html(sum);
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;而用于模块的定义，在其它 JS 文件中是这样声明的：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 定义math.js模块
define(function () {
    var basicNum = 0;
    var add = function (x, y) {
        return x + y;
    };
    return {
        add: add,
        basicNum :basicNum
    };
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果在一个模块定义中依赖另一个模块对象，可以这样声明：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 定义一个依赖underscore模块的模块
define(['underscore'],function(_){
  var classify = function(list){
    _.countBy(list,function(num){
      return num &amp;gt; 30 ? 'old' : 'young';
    })
  };
  return {
    classify :classify
  };
})
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;AMD 规范看起来完美解决了浏览器模块化开发的难题。但是它有一个天生的缺陷，对于依赖的模块无论实际需要与否，都会先加载并执行。如下所示：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) { 
    // 等于在最前面声明并初始化了要用到的所有模块
    if (false) {
      // 即便没用到某个模块 b，但 b 还是提前执行了
      b.foo()
    } 
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在上面的代码中，模块 a、b、c、d、e、f 都会加载并执行，即使它们在实际的模块代码中没有被用到。为了解决这个“浪费”的问题，CMD 规范应运而生。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;CMD 规范单从名字来看，它也与 AMD 规范很像。CMD 与 AMD 规范一样，同样是一种 JS 语言自实现的模块化方案。不同之处在于，AMD 规范是依赖前置、模块提前加载并执行；CMD 是依赖后置、模块懒惰加载再执行。示例代码如下：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;/** CMD写法 **/
define(function(require, exports, module) {
    var a = require('./a'),
     b = require('./b'),
     c = require('./c'); //在需要时申明、加载和使用
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在上面的代码中，模块 a 在使用时才被声明并加载。sea.js 是一个模块加载器，是 AMD 规范的主要实现者之一。使用 sea.js 定义和使用模块的示例如下所示：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;/** sea.js **/
// 定义模块 math.js
define(function(require, exports, module) {
    var $ = require('jquery.js');
    var add = function(a,b){
        return a+b;
    }
    exports.add = add;
});
// 加载模块
seajs.use(['math.js'], function(math){
    var sum = math.add(1+2);
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;与 AMD 相比，CMD 貌似确实节省了无谓的模块加载。但是 AMD 规范本身就是一种异步模块加载方案，是只有在运行时才被加载并运行的，用则加载，不用不加载，有何浪费可言？况且，比起在代码中分别以 require 函数加载模块，直接在 define 方法的第一个参数中声明，似乎还更简洁与潇洒些。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;sea.js 作为 AMD 规范的升级版，简化了使用方法，在使用上更加方便，值得推崇。但是 sea.js 便是浏览器开发中最佳的模块化解决方案吗？未必，还要看是什么类型的项目，后面会讲到。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在讲 ES6 模块规范之前，我们先看一下规范前驱 CommonJS 的一个缺陷。如下所示：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 模块定义代码：lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
// 模块使用代码：main.js
var mod = require('./lib');
console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3
var mod2 = require('./lib');
console.log(mod2.counter);  // 3
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在上面的代码中，为什么三个 mod.counter 的输出均是3？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;CommonJS 规范是一种动态加载、拷贝值对象执行的模块规范。每个模块在被使用时，都是在运行时被动态拉取并被拷贝使用的，模块定义是唯一的，但有几处引用便有几处拷贝。所以，对于不同的 require 调用，生成的是不同的运行时对象。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;即使如此，在上面的代码中，mod 只有一个，为什么 mod.incCounter() 对这个模块对象——即 mod 中的 counter 变量改变无效？相反，对于以下的代码：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  get counter() {
    return counter
  },
  incCounter: incCounter,
};
// main.js
var mod = require('./lib');
console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 4
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第二个输出是4。只是将 counter 声明为一个 getter 存取器属性，调用便正常了，为什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;这是由于 CommonJS 的拷贝机制造成的。由于 CommonJS 规范的拷贝运行机制，在 lib.js 中使用 module.exports 输出的对象，是从 lib 模块内拷贝而得，当时 counter 的值是几，便拷贝了几。无论执行 incCounter 多少次，改变的都不是输出对象的 counter 变量。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;而当定义了 getter 属性之后，该属性指向了模块定义对象中的 counter 变量了吗？不，是指向了被 incCounter 方法以闭包形式囊括的 counter 变量，这个变量是输出的模块对象的一部分。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;CommonJS 规范的这个缺陷，有时候让程序很无奈，一不小心就写出了错误的代码。这个缺陷在 ES6 中得到了很好的解决。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 ES6 模块规范中，只有 export 与 import 两个关键字。示例如下：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;/** 定义模块 math.js **/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };
/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在上面的代码中，使用 export 关键字在 math.js 文件中输出模块，这里使用了对象字面量的属性名称简写与方法名称简写。在另一个文件中引用模块，在 import 关键字后面，{basicNum, add} 这是对象变量析构的写法。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果在 export 模块时，使用了 default 限定词，如下所示：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;//定义输出
export default { basicNum, add };
//引入
import math from './math';
function test(ele) {
    ele.textContent = math.add(99 + math.basicNum);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 import 引入时，便可以省去花括号。这样看起来代码更清爽简洁。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;ES6 模块规范与 CommonJS 规范相比，有以下不同：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）ES6 模块规范是解析（是解析不是编译）时静态加载、运行时动态引用，所有引用出去的模块对象均指向同一个模块对象。在上面使用 CommonJS 规范声明的 lib 模块，如果使用 ES6 模块规范声明，根本不会出现 counter 变量含糊不清的问题。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（2）CommonJS 规范是运行时动态加载、拷贝值对象使用。每一个引用出去的模块对象，都是一个独立的对象。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;所以综上所述，在模块化方案上最佳选择是什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在小程序（包括小游戏）开发项目中，由于支持 ES6，所以小程序最好的模块化方案便是使用ES6模块规范。虽然官方文档中提到的模块化规范是 CommonJS，但最佳方案作者认为却应该是 ES6。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小程序在手机端（无论 iOS 还是 Android）的底层渲染内核都是类 Chrome v8 引擎。v8 引擎在执行JS代码时，是将代码先以 MacroAssembler 汇编库在内存中先编译成机器码再送往 CPU 执行的，并不是像其它 JS 引擎那样解析一行执行一行。所以，静态加载的 ES6 模块规范，更有助于 v8 引擎发挥价值。而运行时加载的 CommonJS 规范、AMD 规范、CMD 规范等，均不利于 v8 引擎施展拳脚。遇到 CommonJS 代码，v8 可能会怒骂：“有什么话能不能一次讲完，你这样猫拉屎式的做法只能让我更慢！”&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 NodeJS 开发项目中，Node9 已经支持 ES6 语法，完全可以使用 ES6 模块规范。NodeJS 的诞生，本身就基于 Google 的 v8 引擎，没有理由不考虑发挥 v8 的最大潜能。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在浏览器 JS 开发项目中，因为从服务器加载文件需要时间，使用 CommonJS 规范肯定是不合适了。至于是使用原生的 ES 模块规范，还是使用sea.js，要看具体场景。如果想页面尽快加载，sea.js 适合；如果是单页面网站，适合使用原生的 ES6 模块规范。还有一点，浏览器并非只有 Chrome 一家，对于没有使用 v8 引擎的浏览器，使用 ES6 原生规范的优势就又减少了一点。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2019年1月21日于北京&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器已原生支持 ES 模块，这对前端开发来说意味着什么？&lt;/li&gt;
&lt;li&gt;Node 9下import/export的丝般顺滑使用&lt;/li&gt;
&lt;li&gt;Sea.js 是什么？&lt;/li&gt;
&lt;li&gt;前端模块化：CommonJS,AMD,CMD,ES6&lt;/li&gt;
&lt;li&gt;Module 的加载实现&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;本文首先于微信公众号「艺述思维」：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/4DuCcq6SxqMsb5ZiKHgGzw&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;关于 JS 模块化的最佳实践总结&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 21 Jan 2019 13:29:00 +0000</pubDate>
<dc:creator>石桥码农</dc:creator>
<og:description>模块化开发是 JS 项目开发中的必备技能，它如同面向对象、设计模式一样，可以兼顾提升软件项目的可维护性和开发效率。 模块之间通常以全局对象维系通讯。在小游戏中，GameGlobal 是全局对象。在小程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sban/p/10301143.html</dc:identifier>
</item>
<item>
<title>经验分享 | 如何拿到自己满意的offer？ - 计算机视觉life</title>
<link>http://www.cnblogs.com/CV-life/p/10301087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CV-life/p/10301087.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文阅读时间约16分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近两年，人工智能（AI）就像一个点石成金的神器，所有的行业，创业公司，或是求职，只要沾着这个词，多少有点脚踩五彩祥云的感觉，故事来了，融资来了，高薪来了。&lt;/p&gt;
&lt;p&gt;于是，越来越多的人开始往AI方向涌。我曾经参加一个群面，12个人，其中一半以上做人工智能方向的，可见现在AI有多热。可是，问题就在于，这条路就一定靠谱吗？这个方向前景如何呢？我们究竟怎样才能找到一份算法工程师的工作呢？相信不少同学都有这些疑问。下面权且从个人经验结合一些资料，进行深度剖析。由于个人经验可能存在局限性，不一定正确供大家参考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文会写到以下小话题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、什么是人工智能&lt;/li&gt;
&lt;li&gt;2、为什么现在人工智能这么火&lt;/li&gt;
&lt;li&gt;3、为什么要学习人工智能&lt;/li&gt;
&lt;li&gt;4、找工作的经验&lt;/li&gt;
&lt;li&gt;4.1、工作要求分析&lt;/li&gt;
&lt;li&gt;4.2、如何找一个自己满意的工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前三部分，作为一个铺垫，如果你已经跨过小白阶段，可以直接跳到最后一部分，观看精华部分。&lt;/p&gt;
&lt;h2 id=&quot;什么是人工智能&quot;&gt;1、什么是人工智能&lt;/h2&gt;
&lt;p&gt;其实对于什么是人工智能，目前还没有一个统一的定义。对于我们目前常说的人工智能其实，可以用一张图来解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c2879e697ec5.jpg&quot; alt=&quot;1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么用一句话总结就是：人工智能是为了让机器拥有类人的智能，其中机器学习是一种实现人工智能的方法，而深度学习是一种机器学习的技术。&lt;/p&gt;
&lt;h2 id=&quot;为什么现在人工智能这么火&quot;&gt;2、为什么现在人工智能这么火&lt;/h2&gt;
&lt;p&gt;那为什么人工智能火起来了，其实之前人工智能曾火了两次，但都因为各种问题而没有发展起来。而这次又重新火起来很大程度是因为近年来互联网高速发展所产生的数据，这些数据极其庞大，需要处理和加工提炼，数据过于庞大人工处理非常困难，这时，数据处理的需求一定程度上催生了人工智能的迅速发展。同时，计算机的硬件的发展也提供了基础。&lt;/p&gt;
&lt;p&gt;而2016年的一场人机大战举行，随着 Google 的 AlphaGo 打败韩国围棋棋手李世乭之后，机器学习尤其是深度学习的热潮席卷了整个IT界。所有的互联网公司，尤其是 Google、 微软、百度、阿里、腾讯等巨头，无不在布局人工智能技术和市场。前有百度深度学习研究院，腾讯的AILab，后有阿里的“达摩院”。并且国家不断的鼓励与布局下更加促进了人工智能的发展。&lt;/p&gt;
&lt;p&gt;人工智能已经慢慢的进入平常百姓的生活，可以说人工智能的发展前景非常广，通过一个图看一下人工智能在生活中有哪些应用呢。应用场景广泛，其实也是人工智能火起来的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287da029560.png&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么以后人工智能还会一直这么火么？其实，从面试了解的大部分公司，其实最关心的是如何落地算法，一般都会问你这个项目有没有用到实际。其实侧面反映出人工智能方向难得是落地，现在很多公司纷纷踏入，其实大部分公司没什么技术积累，随着时间的发展，市场会趋于冷静。就像之前p2p、共享单车、比特币一样，资本快速催生出的市场，冷静下来会出现一地鸡毛啊。但不妨碍人工智能有广阔的前景，毕竟解放人类生产力啊。同时，最近的cai yuan潮一样给大家提个醒，尽量进入大厂或者核心部门，风险相对较小。&lt;/p&gt;
&lt;h2 id=&quot;为什么要学习人工智能&quot;&gt;3、为什么要学习人工智能&lt;/h2&gt;
&lt;p&gt;我认为在做任何重要决定之前，比起搞清楚该怎么做（HOW），追问自己&lt;strong&gt;为什么&lt;/strong&gt;要做出这个选择要重要得多（WHY）。&lt;strong&gt;方向大于努力&lt;/strong&gt;。你在一条错误的路上越努力，你离目标越远。&lt;/p&gt;
&lt;p&gt;==&lt;strong&gt;钱&lt;/strong&gt;更多？更&lt;strong&gt;喜欢&lt;/strong&gt;？更&lt;strong&gt;擅长&lt;/strong&gt;？==&lt;/p&gt;
&lt;p&gt;任何一条理由都没问题，但为了增加你求职的成功率和工作的发展前景，应该尽量去寻找这三条职场优势公共的&lt;strong&gt;交集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一开始，很难有人一击命中&lt;strong&gt;既钱多又喜欢还擅长&lt;/strong&gt;的工作，但这并不妨碍你先从已经&lt;strong&gt;同时具备了两个职场优势的选项&lt;/strong&gt;（钱多、擅长、喜欢）出发，并&lt;strong&gt;把三大优势的交集作为自己职业规划的终极目标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除此之外，每个人或许还有些个人限制条件，比如经验和教育水平不同。&lt;/p&gt;
&lt;p&gt;如何利用以上理论来分析自己适不适学习人工智能？我就拿自己来举例分析分析——&lt;/p&gt;
&lt;blockquote readability=&quot;31&quot;&gt;
&lt;p&gt;首先我大学是一个普通的不能在普通的一本，学的还是万金油的自动化专业，其实跟编程关系不大。以至于去招聘的时候别人都问，你会不会硬件。这时候内心简直想怼他“学自动化就得做硬件么？”，还是要面带微笑耐心的，说之前确实做PLC，但后面，做的是深度学习。&lt;/p&gt;
&lt;p&gt;目标1：考研&lt;/p&gt;
&lt;p&gt;另一方面由于学校很普通，又不想安心的考个公务员就算了（内心还是有个搞技术的心，皮一下），毅然选择考研，第一年复试被刷，只能调剂，但是调剂的话，还是不能上985或者211，并不能改变我第一学历出身不好，所以选择二战。（ps：有目标后千万不要轻易放弃）&lt;/p&gt;
&lt;p&gt;目标2：选择喜欢的方向&lt;/p&gt;
&lt;p&gt;当考上研究生后，其实，由于“散养”自己玩了一年，荒废了这一年宝贵时光。当选择方向时，实验室有两个方向，一个图像处理，一个雷达。由于个人对雷达实在提不起兴趣，又比较&lt;strong&gt;喜欢&lt;/strong&gt;图像处理，觉得很有意思，想选择图像，但是这个项目不需要这么多人，导师不想让选。我就提前准备，询问了师兄师姐，还有其他老师，带着自己想法，跟导师谈，最终说服导师让做试试看。（这真的需要技巧，不能跟导师硬碰硬，说我就不想做，想做啥。还是总体要听导师的。如果实在有自己想法，就要带着想法与导师谈）你对一个东西感兴趣，真的很重要，事半功倍的感觉。更愿意付出去学习去奋斗。&lt;/p&gt;
&lt;p&gt;目标3：算法工程师&lt;/p&gt;
&lt;p&gt;其实入门学习真的不简单，因为我之前是做PLC的，编程基础真的几乎为零，就从头开始学。&lt;strong&gt;后来通过招聘发现自己不足，接着学习不足的地方。&lt;/strong&gt;（其实这可以看做一个反馈，发现不足，弥补不足。）&lt;/p&gt;
&lt;p&gt;找工作的时候，我仔细思考了自己的工作反向觉得对算法更有兴趣，决定去找算法岗，虽然道路不是特别顺利，但终有一个好结果。（虽然，自己拿到过几家软开的职位，但，觉得自己还是想做自己喜欢的工作，身边很多同学并没能坚持去找算法职位，可能去了软开，测试。并不是说这些岗位不好，而是，你最好找到一个自己喜欢的，这样你才有兴趣持续学习。如果你喜欢软开，当然一样有钱途）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;找工作的经验&quot;&gt;4、找工作的经验&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;可能有小伙伴纳闷，怎么不介绍怎么学习？==主要是每个人的基础不一样，实在很难一概而论，大家可以自行，知乎，如何入门机器学习。==有很多推荐，最主要找到一种适合自己的情况的学习方法。但有两个要注意的地方，我觉得是入门时很容易出现的情况，也是一定要避免的，大家需要注意。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;放弃海量资料！&lt;/p&gt;
&lt;p&gt;没错，就是放弃海量资料！在我们想要入门机器学习的时候，往往会搜集很多资料，什么 xx学院机器学习内部资源、机器学习从入门到进阶百 G 资源、xx 人工智能教程，等等。很多时候我们拿着十几 G、几百 G 的学习资源，然后踏踏实实地放到了某云盘里存着，等着日后慢慢学习。殊不知，有 90% 的人仅仅只是搜集资料、保存资料而已，放在云盘里一年半载也忘了打开学习。（看了一眼自己的云盘，莫名感觉打脸，好呗，捂着脸接着写）躺在云盘的资料很多时候只是大多数人“以后好好学习”的自我安慰和“自我”安全感而已。而且，面对海量的学习资料，很容易陷入到一种迷茫的状态，最直接的感觉就是：天啊，有这么多东西要学！天啊，还有这么多东西没学！简单来说，就是选择越多，越容易让人陷入无从选择的困境。&lt;/p&gt;
&lt;p&gt;所以，第一步就是要放弃海量资料！而是选择一份真正适合自己的资料，好好研读下去！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;千万别先从头学数学！千万别先从头学数学！千万别先从头学数学！（重要的事情多说几遍）&lt;/p&gt;
&lt;p&gt;说到入门，很多人会想着那就要从最基础的知识开始学起！机器学习是一门融合概率论、线性代数、凸优化、计算机、神经科学等多方面的复杂技术。学好机器学习需要的理论知识很多，有些人可能基础不是特别扎实，就想着从最底层的知识开始学起，概率论、线性代数、机器学习凸优化公式推导，等等。千万不要这样，极有可能你都看不完一本数学理论的书，就放弃了。当然，不是说不需要钻研基础知识，基础理论知识非常重要！只是说，在入门的时候，最好先从顶层框架上有个系统的认识，然后再从实践到理论，有的放矢的查缺补漏机器学习知识点。而且从学习的积极性来说，也起到了“正反馈”的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;工作要求分析&quot;&gt;4.1工作要求分析&lt;/h4&gt;
&lt;p&gt;因为，大部分人学习的目的，是为了求职去找一个好工作，我觉得有必要首先对这份工作的行情和要求做个大概的了解。俗话说知己知彼百战百胜嘛。&lt;/p&gt;
&lt;p&gt;本人爬了智联招聘上的关于算法工程师的将近6000个职位，进行分析。具有一定参考价值，如图所示：&lt;/p&gt;
&lt;h5 id=&quot;我们来探索一下算法工程师岗位在全国各城市的需求情况&quot;&gt;1.我们来探索一下算法工程师岗位在全国各城市的需求情况：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287e94651bf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，北京、上海和深圳对算法工程师的需求最多，尤其是北京，需求量甚至超过了上海、深圳的总和。所以如果想找算法工作北京机会最多，其次是上海、深圳。所以，如果想更容易的去找工作，上面的城市要更容易。&lt;/p&gt;
&lt;h5 id=&quot;薪资水平的探索&quot;&gt;2.薪资水平的探索&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287eadd0e2b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，对于算法工程师的岗位而言，绝大多数岗位的薪资在1K-2.6K之前，薪资其实相对较高。是不是突然有学习的动力。&lt;/p&gt;
&lt;h5 id=&quot;学历要求&quot;&gt;3.学历要求&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287f0c257dd.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;学历与工资的关系&quot;&gt;4.学历与工资的关系&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287f2fb1a06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上可以反映学历与工资成正比，如果想获得高收入，提高学历同样是个办法。&lt;/p&gt;
&lt;h5 id=&quot;企业的类型分布&quot;&gt;5.企业的类型分布&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/30/5c287f2fb6381.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;算法工程师所需要的技能非常的重要哦&quot;&gt;6.算法工程师所需要的技能(非常的重要哦)&lt;/h5&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;1.学历：本科及以上学历，数学，计算机，自动化等相关专业（有些大厂提高到硕士及以上，所有学历有时候是个门槛）；&lt;/p&gt;
&lt;p&gt;2.编程能力：C/C++、Python、java任意两种；常用数据结构和算法；熟悉linux系统&lt;/p&gt;
&lt;p&gt;3.算法能力：熟练掌握计算机视觉&amp;amp;机器学习的基本方法（这里所说的是可以手推公式，例如：决策树、临近取样、支持向量机、神经网络算法、回归、聚类等。同时要熟练掌握TensorFlow、Keras、PyTorch等框架）&lt;/p&gt;
&lt;p&gt;4.经验：有项目经历；比赛经历；实习经历&lt;/p&gt;
&lt;p&gt;5.团队合作能力：良好的沟通能力和团队合作能力。&lt;/p&gt;
&lt;p&gt;6.加分项：有博客或者公众号；github；顶级会议论文；各种比赛奖项&lt;/p&gt;
&lt;p&gt;7.针对细分领域可能还有一些，其他的要求，比如图像处理方向可能会要求opencv。数据分析可能要求会数据可视化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如何找一个自己满意的工作&quot;&gt;4.2 如何找一个自己满意的工作&lt;/h4&gt;
&lt;h5 id=&quot;简历&quot;&gt;4.2.1 简历&lt;/h5&gt;
&lt;p&gt;简历是你求职的第一步，也是很重要的部分，因为他是你与应聘公司沟通的桥梁。那该如何制作一份合格的简历？（推荐：简历就得这么做才行https://www.bilibili.com/video/av12771675）简历的第一个字就突出简，简单美观就好，千万不要弄得特别花哨，反而没有什么好效果。简历最好一页，将最能代表自己能力的写清楚，最好简洁扼要。要针对投递公司的职位要求，去写自己的简历。例如：你去应聘一个公司，可以打开他们的招聘网站，查看一下岗位要求和公司文化是什么。对应着要求去写。但是千万不要写一些自己根本讲不出的东西，比如你写了熟悉什么算法，问你一个问题，就答不出，这样还不如不写。关于如何写工作经验或者项目经验，推荐给大家“ STAR ” 法则。&lt;/p&gt;
&lt;p&gt;情境（Stuation）：写出你的工作背景&lt;/p&gt;
&lt;p&gt;任务（Task）：我负责做什么&lt;/p&gt;
&lt;p&gt;行动（Action）：我做了什么&lt;/p&gt;
&lt;p&gt;结果（Result）：我的工作取得了什么样的结果&lt;/p&gt;
&lt;p&gt;举例：某某公司的算法岗实习，参与人脸识别的项目，负责算法的实现与改进，最终结果提高了多少多少。&lt;/p&gt;
&lt;p&gt;千万不要写一堆，甚至，有同学简历好多页，HR没时间去细看，不知道你的重点是什么。而且简历最好有量化的数字，比如提高了多少，写了多少代码，这样让人更直观。最后，一个小贴士，如果需要自带简历，请不要舍不得花钱，找一家好一点打印店，彩打厚纸，这样给人感觉更舒服一些。下面我们就该针对，求职要求去丰富自己的简历。&lt;/p&gt;
&lt;h5 id=&quot;学历&quot;&gt;4.2.2 学历&lt;/h5&gt;
&lt;p&gt;一些大厂的起步要求确实是硕士说明门槛逐渐在提高，如果真的想深造，读书不失一个办法，尤其现在应届生与往届生的工资出现，应届生工资更高的情况。当然，还得结合自身实际选择。&lt;/p&gt;
&lt;h5 id=&quot;coding能力&quot;&gt;4.2.3 coding能力&lt;/h5&gt;
&lt;p&gt;算法的同学coding能力是在面试中必须要考察的。虽然可能比软开要求要低，但并不是就不要求，只会python肯定是会被鄙视的。所以自己的coding能力必须多练练，推荐在牛客网或者LeetCode的在线编程多多敲代码。掌握类似leetcode medium程度的题目就可以了，hard程度的可以不用掌握。面试中一般会出几道题目，要求手写，能顺利写出的都是加分项。语言要掌握一大两小三门语言，大语言是Java或者C++,小语言掌握python，SQL。有时间精力可以将常见的算法用python实现一下。语言不必掌握很深，但是要做到能熟练用Python或者SQL处理数据，算法用Python也要掌握差不多。对于大语言来说基本语法和一些基本概念都要熟练掌握。同时对基本的计算机原理要熟悉，面试同样会问。&lt;/p&gt;
&lt;p&gt;资料请自取哦：&lt;/p&gt;
&lt;p&gt;python面试知识点总结：&lt;a href=&quot;https://github.com/taizilongxu/interview_python&quot; class=&quot;uri&quot;&gt;https://github.com/taizilongxu/interview_python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;c\c++面试知识点总结：&lt;a href=&quot;https://github.com/huihut/interview#cc&quot; class=&quot;uri&quot;&gt;https://github.com/huihut/interview#cc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;java面试知识点总结：&lt;a href=&quot;https://github.com/guanzhenxing/java_interview_manual&quot; class=&quot;uri&quot;&gt;https://github.com/guanzhenxing/java_interview_manual&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;算法能力&quot;&gt;4.2.4 算法能力&lt;/h5&gt;
&lt;p&gt;熟练掌握计算机视觉&amp;amp;机器学习的基本方法（这里所说的是可以手推公式，例如：决策树、临近取样、支持向量机、神经网络算法、回归、聚类等。同时要熟练掌握TensorFlow、Keras、PyTorch等框架，TensorFlow可能入门有点难，可以PyTorch）&lt;/p&gt;
&lt;p&gt;资料请自取哦：&lt;/p&gt;
&lt;p&gt;推荐书籍：《机器学习》&lt;/p&gt;
&lt;p&gt;机器学习算法实现：&lt;a href=&quot;https://github.com/lawlite19/MachineLearning_Python&quot; class=&quot;uri&quot;&gt;https://github.com/lawlite19/MachineLearning_Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐视频：李宏毅机器学习&lt;/p&gt;
&lt;p&gt;算法面试经验：&lt;a href=&quot;https://github.com/imhuay/Algorithm_Interview_Notes-Chinese&quot; class=&quot;uri&quot;&gt;https://github.com/imhuay/Algorithm_Interview_Notes-Chinese&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;算法工程师面试常见问题：&lt;a href=&quot;https://github.com/PPshrimpGo/AIinterview&quot; class=&quot;uri&quot;&gt;https://github.com/PPshrimpGo/AIinterview&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;经验&quot;&gt;4.2.5 经验&lt;/h5&gt;
&lt;p&gt;有项目经历；比赛经历；实习经历&lt;/p&gt;
&lt;p&gt;对于在校生，项目经历要熟知你自己的方向，平常可以多了解实验室其他同门的项目，关键时刻懂点，总比不懂要好。比赛可以参加：kaggale或者一些大厂的比赛，当然得取得名次，要不然写出来，也体现不了能力。实习的话每年三月份会有很多实习，大家可以关注一些公众号，获取实习信息，对于实习尽量去大厂，能为你的招聘增分不少哦。&lt;/p&gt;
&lt;h5 id=&quot;团队合作能力&quot;&gt;4.2.6 团队合作能力&lt;/h5&gt;
&lt;p&gt;这个对于在校生，可以说自己组织什么样的活动，或者参与项目时，怎么与他人合作。&lt;/p&gt;
&lt;h5 id=&quot;加分项&quot;&gt;4.2.7 加分项&lt;/h5&gt;
&lt;p&gt;需要平时自己积累了，github、博客，能为你增分的。而且最近越发的重要了。大家可以平常的笔记注意整理。&lt;/p&gt;
&lt;p&gt;写在最后，当大家有这些基础条件后，可能就需要去面试了。分享一些面试经验。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;面试通过=50%实力+30%运气+20%技巧。你能掌握70%的主动，剩下的交给运气。&lt;/li&gt;
&lt;li&gt;首先要告诉自己，这不是一场面试，而是一场与自己未来同事之间的交流探讨。尽量消除紧张心理，完全不紧张也是不可能的，但是还是要尽可能稳下来。面试过程中尽量幽默，能做到和面试官谈笑风生你就赢了。在脉脉上看到的有人说做了面试官之后才发现其实你技术差不多就行，决定你过不过的就是看你顺不顺眼，所以最好能让面试官在短短几十分钟里喜欢上你！如果你实在很害怕，给你个经验之谈，首先找一些小一点的公司，会对各方面要求低一些，去练习面试，多练，就能消除你的紧张感，尤其当你收到offer后，会越来越自信的。（如果一点经验没有推荐看这个：Offer拿到手软——史上最良心的校招求职攻略：&lt;a href=&quot;https://space.bilibili.com/17320304?spm_id_from=333.788.b_765f7570696e666f.2&quot; class=&quot;uri&quot;&gt;https://space.bilibili.com/17320304?spm_id_from=333.788.b_765f7570696e666f.2&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;一个良好的开头、一个高潮加一个完美的结尾。开头是自我介绍，怎么吸引面试官去问你最擅长的问题。进入你擅长的领域，争取给面试官一个惊艳的表现。同时如何结束面试一样很重要，这个可能需要自己不断练，全程记得要礼貌。&lt;/li&gt;
&lt;li&gt;电话面试的话要注意语速吐字，现场面试也要注意语速，可以用在草稿纸上写一写的方式帮助解释。&lt;/li&gt;
&lt;li&gt;面试中遇到没理解的问题要尽可能与面试官沟通，说不定他就在考你的沟通能力呢。&lt;/li&gt;
&lt;li&gt;在面试中遇到不会的或者完全不会的问题要在面试之前想好策略。我的策略一般是允许自己对于最多两个问题直接说我不会，此策略一般是对于自己完全没有把握的问题，让面试官换另一个问题。如果你强答这个题的话只能是勉勉强强的回答一下。在一场面试中有1,2个问题说不会的没有多大问题，但是对于其他的问题要尽量做到完美作答，这样才有把握。&lt;/li&gt;
&lt;li&gt;关于HR面，尽量提前查一下公司的文化是什么，表现的自己很向往并且符合这种文化就好。千万不要太个性。希望大家找到一个完美工作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;欢迎关注公众号：计算机视觉life，一起探索计算机视觉新世界~&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 13:19:00 +0000</pubDate>
<dc:creator>计算机视觉life</dc:creator>
<og:description>本文阅读时间约16分钟 最近两年，人工智能（AI）就像一个点石成金的神器，所有的行业，创业公司，或是求职，只要沾着这个词，多少有点脚踩五彩祥云的感觉，故事来了，融资来了，高薪来了。 于是，越来越多的人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CV-life/p/10301087.html</dc:identifier>
</item>
</channel>
</rss>