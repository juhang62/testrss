<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>又是一年1024 - AprilBlank</title>
<link>http://www.cnblogs.com/AprilBlank/p/11730194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AprilBlank/p/11730194.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;又是一年1024，大早上坐到电脑前，无心工作，先祝各位程序猿：&lt;strong&gt;上班时间短，月月薪水多，代码少bug，测试全通过，下班回家早，周末还双休，生活无压力，还有女朋友。&lt;/strong&gt; 感觉写完这句话整篇已经可以结束了，这可能是工作生活平衡点的最终实现目标吧。&lt;/p&gt;
&lt;h3 id=&quot;彷徨&quot;&gt;彷徨&lt;/h3&gt;
&lt;p&gt;总觉得自己还年轻，但是也不知不觉走在奔三的路上，总觉得自己还有精力，但是也不知不觉晚上到家连电脑也开的少。时间总是在不知不觉中流逝，梦想着今朝有酒今朝醉，却还要考虑着明日之事昨日遗留，按说这个20出头的年纪（还年轻，正青年）不该有这么尴尬的想法，但确实是个比较尴尬的年纪。&lt;/p&gt;
&lt;p&gt;16年刚离开校门就步入公司，在郑州呆了两年全都从事.net开发，至于大学的生活不过多描述，恍惚而已，18年考虑了许久（应该有个半年吧），离开了郑州回到了家乡——洛阳，这个我觉得应该不至于环境太差的城市，却因为年轻低估了旅游城市对于软件开发的需求，幸好，还有.net的公司。&lt;/p&gt;
&lt;p&gt;其实对于编程语言并没有太多执念，但却总想用C#开发，看着身边的转行，转语言，我也是不禁在想，是否也要考虑下转转试试，也是在这种纠纠结结中鼓捣过php，java，python，go，也都是看看视频看看资料后做个不成型的小demo，比如先跟world打个招呼？，涉猎而已。&lt;/p&gt;
&lt;p&gt;工作当然也不会顺人心意，毕竟公司比较喜欢全能型人才，而为了全能，就不得不去接触种种，前端，后端，sql，架构，分布式…，可想而知，精力有限，学的多不代表就好，能咬着牙一条路走到黑的才能有所收获（要么大佬，要么，emm，一根筋），身边同事有句话说的我觉得挺好，==&quot;拿着白菜的价格，操着盖大楼的心&quot;==，虽然这样说不妥，但我想应该会引起共鸣吧，也有一句话 ==&quot;钱是别人的，命是自己的，上班996，下班ICU&quot;==，服务上线，项目验收，在这之前都经历过什么相信我也不需要多说，上线后有维护，验收后有反馈，这一行，是停不下来的一行 。&lt;/p&gt;
&lt;p&gt;有不少人跟我说，&lt;strong&gt;在家里二三线城市，还干啥程序猿，趁早转行吧，要么趁着年轻试试上岸，要么趁着年轻折腾从商，要么趁着年轻工地搬砖，要么趁着年轻外卖走起&lt;/strong&gt;。对于这些提议，我只能说，有道理，我也在考虑。不抱怨生态如何，只觉得自己还要走很长，我一直坚信，程序猿是能改变世界的群体。&lt;/p&gt;
&lt;h3 id=&quot;一步一个脚印慢慢来&quot;&gt;一步一个脚印，慢慢来&lt;/h3&gt;
&lt;p&gt;做开发后会有个习惯，看到生活当中觉得麻烦的事都会去想，如果用软件能否改善现状，工作之余也喜欢自己鼓捣些东西，简单列下自己鼓捣的东西吧，都是.net的工程，可能是因为执念，可能是因为用着顺手吧。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;基于netframework的代码生成器&lt;/td&gt;
&lt;td&gt;郑州回来待业的两个月&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;基于netframeword的基础工程&lt;/td&gt;
&lt;td&gt;同样是待业的两个月&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;基于layui的后台界面工程&lt;/td&gt;
&lt;td&gt;家里工作的第二个月&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;在线点餐系统&lt;/td&gt;
&lt;td&gt;公司业务需要，后来搁置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;在线票务系统&lt;/td&gt;
&lt;td&gt;同样搁置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;基于net core2.1的基础工程&lt;/td&gt;
&lt;td&gt;18年10月左右&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;April.WebApi&lt;/td&gt;
&lt;td&gt;今年7月左右&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;要说荒废吧，确实有点儿荒废，自控能力比较差的我，平时不太喜欢说不的我，总是把自己的事往后推，期间也搁置了不少想鼓捣的东西，至于怎么改进吧，也没啥喊口号的话，生活是自己的，怎么过也是自己的。&lt;/p&gt;
&lt;p&gt;另外从今年7月，开始写博客，记录下平时自己鼓捣东西或者工作中遇到的问题及解决方法，一是为了以后需要的时候随翻随用，毕竟好记性不如烂笔头，二是为了分享出来给遇到同样问题的人给予一定帮助，万一帮到人了呢。在写之前有很多顾虑，感觉不知道写啥，也不知道写的有没有人看，也感觉别人已经写过相关的自己再写有点儿多余，在后来写开之后，才对这些顾虑释然，一个字，干就完了。&lt;/p&gt;
&lt;p&gt;至于转行，当然也依然在考虑范围内，毕竟有些不是个人能力所能左右的（当然还是因为自己是渣鸡），但是编程这条路不会断，不仅仅是因为兴趣爱好吧，当然也还是希望通过这双敲代码的手去搞点儿能于生活便利的事。去了泰国一趟，别的没学会，就学会了一句翟炎炎（也不知道对不对），凡事急不得，慢慢来，质变之所以那么明显是因为量变的千锤百炼，滴水之所以石穿是因为目标明确，不能把鸡蛋放到同一个篮子里，也不能把鸡蛋放到百十个篮子里，置之死地而后生这个大英雄气概我搞不来，生而为凡人，那就只有靠自己的双手，不断的撸树挖矿，才能盖房子造装备，手拿钻石剑，最终干掉末影龙。&lt;/p&gt;
&lt;h3 id=&quot;总想&quot;&gt;总想…&lt;/h3&gt;
&lt;p&gt;想的越多，顾虑越多，如何整理思路规整目标，可能是目前我最迫切需要做的，年轻人该有的冲劲儿感觉在我身上已经不知何时已经木得了，取而代之的是走路手不自觉的背后（可怕可怕）。还是想通过.net去鼓捣些什么，毕竟真的是觉得net core这个，用起来确实是比之前舒服多了，但正如前面所说，编程语言的执念没有，毕竟这只是个工具，就像镐，铲，剑，斧都能砍怪（当然这举例不恰当），语言不重要，重要的是需求与流程还有解决方案。&lt;/p&gt;
&lt;p&gt;语言也好，业务也好，行为习惯也好，都是需要不断的交流沟通，思想的火花是靠碰撞的，有些时候自己确实有点儿闭门造车的感觉，还是需要没事多关注下官网啊文档资料已经其他博客的分享，集思广益，取长补短。&lt;/p&gt;
&lt;p&gt;能推的事就推，能拒绝的得拒绝，老好人往往都是牺牲自己的时间去帮助别人，最终自己越过越累，当然好人还是要当的（不要好人卡），学会合理的拒绝也是需要的，时间用在该用的地方，精力搞在该搞的地方，对于自己的想法要么不开始，要么做到底，年轻，还是需要偶尔的冲动的。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps:总算有篇不用写测试了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写着写着感觉成了个总结了，不过也确实是整理下，生活不止眼前的苟且，当有人告诉你前面是堵墙的时候，你是选择绕路而行，还是选择勇往直前，亲身体会撞墙的感觉，可能撞的是堵纸墙，但谁知道呢，&lt;strong&gt;猜不到的明天，留不住的昨天，属于自己的，只有今天。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Oct 2019 00:47:00 +0000</pubDate>
<dc:creator>AprilBlank</dc:creator>
<og:description>[toc] 前言 又是一年1024，大早上坐到电脑前，无心工作，先祝各位程序猿： 上班时间短，月月薪水多，代码少bug，测试全通过，下班回家早，周末还双休，生活无压力，还有女朋友。 感觉写完这句话整篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AprilBlank/p/11730194.html</dc:identifier>
</item>
<item>
<title>小白学 Python（5）：基础运算符（上） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11730187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11730187.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191024084342062-13566012.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面我们讲了变量的基础操作，本文我们接着讲运算符。&lt;/p&gt;
&lt;p&gt;运算符根据用途可以分为以下这么几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;比较运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;成员运算符&lt;/li&gt;
&lt;li&gt;身份运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇我们先介绍前两个，算术运算符和比较运算符。&lt;/p&gt;
&lt;h2 id=&quot;算数运算符&quot;&gt;算数运算符&lt;/h2&gt;
&lt;p&gt;算术运算符顾名思义就是我们做数字计算的时候用到的运算符，当然，加减乘除肯定都有，除此之外呢，还有程序中常见的取摸、取幂和取整除。详细如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取模 - 返回除法的余数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;幂 - 返回x的y次幂&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;取整除 - 向下取接近除数的整数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们来看几个简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 5
b = 10

c = a + b
print(&quot;1. c 的值为：&quot;, c)

c = a - b
print(&quot;2. c 的值为：&quot;, c)

c = a * b
print(&quot;3. c 的值为：&quot;, c)

c = a / b
print(&quot;4. c 的值为：&quot;, c)

c = a % b
print(&quot;5. c 的值为：&quot;, c)

c = a ** b
print(&quot;6. c 的值为：&quot;, c)

# 改变 a 和 b 的值

a = 10
b = 5

c = a // b
print(&quot;7. c 的值为：&quot;, c)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. c 的值为： 15
2. c 的值为： -5
3. c 的值为： 50
4. c 的值为： 0.5
5. c 的值为： 5
6. c 的值为： 9765625
7. c 的值为： 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的栗子都整形的计算，如果是不同类型的数据运算，会发生隐式类型转换。&lt;/p&gt;
&lt;p&gt;类型转换的规则由低等向高等转换。&lt;/p&gt;
&lt;p&gt;bool（布尔） &amp;lt; int（整形） &amp;lt; float（浮点型） &amp;lt; complex（复数）&lt;/p&gt;
&lt;p&gt;我们再看几个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 1
b = 1.5
c = a + b
print(&quot;8. c 的值为：&quot;, c, &quot;，c 的类型为：&quot;, type(c))

d = True
e = c + d
print(&quot;9. e 的值为：&quot;, e, &quot;，e 的类型为：&quot;, type(e))

f = 2 + 4j
g = e + f
print(&quot;10. g 的值为：&quot;, g, &quot;，g 的类型为：&quot;, type(g))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;8. c 的值为： 2.5 ，c 的类型为： &amp;lt;class 'float'&amp;gt;
9. e 的值为： 3.5 ，e 的类型为： &amp;lt;class 'float'&amp;gt;
10. g 的值为： (5.5+4j) ，g 的类型为： &amp;lt;class 'complex'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在算术运算时，True代表1，False代表0&lt;/p&gt;
&lt;h2 id=&quot;运算内置函数&quot;&gt;运算内置函数&lt;/h2&gt;
&lt;p&gt;内置的意思就是安装好就有，无需额外安装，就比如我们每次买回来的新手机都有一堆内置的软件：）&lt;/p&gt;
&lt;p&gt;Python 提供的内置函数如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191024084342434-1750261030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这里选取一些和计算相关的常用的内置函数做一些简单的讲解和演示（个人觉得演示更加的重要）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;abs(x)&lt;/td&gt;
&lt;td&gt;返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;complex([real[, imag]])&lt;/td&gt;
&lt;td&gt;返回值为 real + imag*1j 的复数，或将字符串或数字转换为复数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;divmod(a, b)&lt;/td&gt;
&lt;td&gt;它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;float([x])&lt;/td&gt;
&lt;td&gt;返回从数字或字符串 x 生成的浮点数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;pow(x, y[, z])&lt;/td&gt;
&lt;td&gt;返回 x 的 y 次幂；如果 z 存在，则对 z 取余（比直接 pow(x, y) % z 计算更高效）。两个参数形式的 pow(x, y) 等价于幂运算符： x**y。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;round(number[, ndigits])&lt;/td&gt;
&lt;td&gt;返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回最接近输入值的整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;sum(iterable[, start])&lt;/td&gt;
&lt;td&gt;从 start 开始自左向右对 iterable 中的项求和并返回总计值。 start 默认为 0。 iterable 的项通常为数字，开始值则不允许为字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;bin(x)&lt;/td&gt;
&lt;td&gt;将一个整数转变为一个前缀为“0b”的二进制字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;oct(x)&lt;/td&gt;
&lt;td&gt;将一个整数转变为一个前缀为“0o”的八进制字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hex(x)&lt;/td&gt;
&lt;td&gt;将整数转换为以“0x”为前缀的小写十六进制字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;chr(i)&lt;/td&gt;
&lt;td&gt;返回 Unicode 码位为整数 i 的字符的字符串格式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ord(c)&lt;/td&gt;
&lt;td&gt;对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;bool([x])&lt;/td&gt;
&lt;td&gt;返回一个布尔值，True 或者 False。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;测试示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(&quot;11. -1 的绝对值为：&quot;, abs(-1))

print(&quot;12. 创建的复数为：&quot;, complex(1, -2))

print(&quot;13. 商和余数为：&quot;, divmod(10, 3))

print(&quot;14. 浮点型转换：&quot;, float(1))

print(&quot;15. 10的3次幂为：&quot;, pow(10, 3))

print(&quot;16. 四舍五入为：&quot;, round(5.5))

print(&quot;17. 集合求和结果为：&quot;, sum({1, 2, 3 ,4}))

print(&quot;18. 整数20的二进制为：&quot;, bin(20))

print(&quot;19. 整数20的八进制为：&quot;, oct(20))

print(&quot;20. 整数20的十六进制为：&quot;, hex(20))

print(&quot;21. Unicode 为 97 的字符串：&quot;, chr(97))

print(&quot;22. 字符串 a 的 Unicode 码：&quot;, ord('a'))

print(&quot;23. 123 的 boolean 值为：&quot;, bool(123))

print(&quot;24. 空字符串的 boolean 的值为：&quot;, bool(''))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;11. -1 的绝对值为： 1
12. 创建的复数为： (1-2j)
13. 商和余数为： (3, 1)
14. 浮点型转换： 1.0
15. 10的3次幂为： 1000
16. 四舍五入为： 6
17. 集合求和结果为： 10
18. 整数20的二进制为： 0b10100
19. 整数20的八进制为： 0o24
20. 整数20的十六进制为： 0x14
21. Unicode 为 97 的字符串： a
22. 字符串 a 的 Unicode 码： 97
23. 123 的 boolean 值为： True
24. 空字符串的 boolean 的值为： False&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;比较运算符&quot;&gt;比较运算符&lt;/h2&gt;
&lt;p&gt;从字面意思来理解，比较运算符就是比较两个数值或者字符串类型的数据，返回一个布尔值。&lt;/p&gt;
&lt;p&gt;比较运算符有以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;等于 - 比较对象是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于 - 比较两个对象是否不相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于 - 返回x是否大于y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于等于 - 返回x是否大于等于y。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于 - 返回x是否小于等于y。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面我们举几个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 5
b = 10

if (a == b):
    print(&quot;25. a 等于 b&quot;)
else:
    print(&quot;25. a 不等于 b&quot;)

if (a != b):
    print(&quot;26. a 不等于 b&quot;)
else:
    print(&quot;26. a 等于 b&quot;)

if (a &amp;lt; b):
    print(&quot;27. a 小于 b&quot;)
else:
    print(&quot;27. a 大于等于 b&quot;)

if (a &amp;gt; b):
    print(&quot;28. a 大于 b&quot;)
else:
    print(&quot;28. a 小于等于 b&quot;)

if (a &amp;lt;= b):
    print(&quot;29. a 小于等于 b&quot;)
else:
    print(&quot;29. a 大于  b&quot;)

if (b &amp;gt;= a):
    print(&quot;30. b 大于等于 a&quot;)
else:
    print(&quot;30. b 小于 a&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;25. a 不等于 b
26. a 不等于 b
27. a 小于 b
28. a 小于等于 b
29. a 小于等于 b
30. b 大于等于 a&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-operator&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/base-operator&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Oct 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11730187.html</dc:identifier>
</item>
<item>
<title>这可能就是你苦苦寻找免费、高颜值、功能强大的 Markdown 编辑器（共5款） - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11728087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11728087.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185006924-550856556.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文作者 | &lt;a href=&quot;https://chungzh.cn/&quot;&gt;HelloGitHub-小猪蹄&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Markdown 是一个轻量级的标记语言，语法简单、容易上手，它深受程序员、博客主等人群的钟爱。随着越来越多的博客系统支持 Markdown，它也开始越来越流行。那么一个趁手的 Markdown 编辑器能够让你醉心于创作、专注于文字、行文如流水般丝滑。&lt;/p&gt;
&lt;p&gt;下面这个 5 款编辑器各有特色，相信总有一款适合你。俗话说：“工欲善其事，必先利其器”，快根据个人的需求挑选一款合适自己的 Markdown 编辑器吧！&lt;/p&gt;
&lt;h2 id=&quot;mark-text&quot;&gt;1、Mark Text&lt;/h2&gt;
&lt;p&gt;如果你用过 Typora，那么这款编辑器你一定会觉得十分熟悉。它并没有采用普遍的双栏模式，而是使用了和 Typora 一样的“所见即所得”，使您获得无干扰的写作体验。它支持 &lt;a href=&quot;https://spec.commonmark.org/0.29/&quot;&gt;CommonMark Spec&lt;/a&gt; 和 &lt;a href=&quot;https://github.github.com/gfm/&quot;&gt;GitHub Flavored Markdown Spec&lt;/a&gt; 这两个 Markdown 扩展、数学表达式（KaTeX）、front matter 和 emoji。它还有各种预设主题，以后还会开放自己导入主题的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185026686-215824840.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;vnote&quot;&gt;2、VNote&lt;/h2&gt;
&lt;p&gt;VNote 使用 C++ 开发，基于 Qt 5.9。它号称是更懂程序员和 Markdown 的笔记软件，虽然看上去并不十分美观，但它的功能很强大。它有 &lt;strong&gt;Vim&lt;/strong&gt; 模式和一系列强大的快捷键、可以直接从剪切板插入图片、支持 &lt;a href=&quot;http://knsv.github.io/mermaid/&quot;&gt;Mermaid&lt;/a&gt;、 &lt;a href=&quot;http://flowchart.js.org/&quot;&gt;Flowchart.js&lt;/a&gt;、 &lt;a href=&quot;https://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;、 &lt;a href=&quot;http://plantuml.com/&quot;&gt;PlantUML&lt;/a&gt; 和 &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt;、强大的原地预览（图片、图表、公式）等功能，确实是一个很懂程序员的强大 Markdown 编辑器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185037047-1661560154.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;notable&quot;&gt;3、Notable&lt;/h2&gt;
&lt;p&gt;Notable 是一个使用 TypeScript 开发的 Markdown 编辑器。Notable 支持 GFM(GitHub-Flavored Markdown)、KaTeX 以及 Mermaid 图。它与 VS Code 编辑器相同，因此内置了多光标、小地图和漂亮的语法高亮等功能。它采用分栏设计，同时还可以导入 Evernote 笔记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185047953-1801407361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是它与其它 Markdown 编辑器的对比图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185104672-1151068211.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;boostnote&quot;&gt;4、Boostnote&lt;/h2&gt;
&lt;p&gt;Boostnote 是一款面向程序员的漂亮 Markdown 笔记软件，基于 Electron、React+Redux、Webpack 和 CSSModules 构建。采用分栏式预览，你可以根据自己的喜好对它的缩进、字体、样式以及 UI 语言进行自定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185119977-1317654940.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;simplenote&quot;&gt;5、Simplenote&lt;/h2&gt;
&lt;ul readability=&quot;-0.45876288659794&quot;&gt;&lt;li&gt;GitHub 项目地址：
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stars 数量：2k&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.28125&quot;&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://simplenote.com/&quot; class=&quot;uri&quot;&gt;https://simplenote.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持的操作系统：Linux、MacOS、Windows、Android 和 iOS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这款编辑器由 Wordpress 的母公司 Automattic 开发（没错，就是收购 Tumblr 的那个公司！）。正如其名，它是一款很 simple、很小巧的编辑器。你在 simplenote 上写的笔记会在所有设备上同步更新，同时它还支持多人协作编辑文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201910/759200-20191023185132982-1041987557.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;以上就是本期推荐的 5 款免费、开源的 Markdown 编辑器，是不是要颜有颜、要功能有功能呢？快快挑选一个趁手的‘利器’，让你的创作之路披荆斩棘！&lt;/p&gt;
&lt;p&gt;这里是 HelloGitHub 我们专注于分享 GitHub 上有趣、入门级的开源项目。下一期您想来点什么呢？欢迎留言告诉我们。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Thu, 24 Oct 2019 00:38:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文作者 | 'HelloGitHub 小猪蹄' Markdown 是一个轻量级的标记语言，语法简单、容易上手，它深受程序员、博客主等人群的钟爱。随着越来越多的博客系统支持 Markdown，它也开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11728087.html</dc:identifier>
</item>
<item>
<title>AOP框架Dora.Interception 3.0 [4]: 基于特性的拦截器注册 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-3-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-3-04.html</guid>
<description>&lt;p&gt;按照单一职责的原则，拦截器只负责需要的拦截操作的执行，至于它采用何种方式应用到目标方法上，以及它在整个拦截器管道中的位置则属于“拦截器注册”的范畴。Dora.Interception提供了几种典型的注册方法，用户也可以根据自己的需求实现自己的注册方式。&lt;/p&gt;

&lt;p&gt;一般来说，每一个拦截器类型都对应着一个IInterceptorProvider实现类型，后者利用其&lt;strong&gt;Use&lt;/strong&gt;方法负责将前者放置到拦截器管道指定的位置。如下面的代码所示，IInterceptorProvider还具有一个布尔类型的&lt;strong&gt;AllowMultiple&lt;/strong&gt;属性，它表示&lt;strong&gt;相同类型的多一个拦截器对象是否可以同时应用到同一个方法上&lt;/strong&gt;。如果该属性返回False，Dora.Interception只会选择其中一个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptorProvider
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Use(IInterceptorChainBuilder builder);
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; AllowMultiple { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IInterceptorProvider的Use方法具有一个IInterceptorChainBuilder类型的参数。IInterceptorChainBuilder类似于ASP.NET Core中的&lt;strong&gt;IApplicationBuilder&lt;/strong&gt;，我们将InterceptorDelegate 对象表示的拦截器根据指定的位置（order属性）注册到IInterceptorChainBuilder对象上，并最终利用其Build方法构建一个通过InterceptorDelegate 表示的拦截器管道。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptorChainBuilder
{
    IServiceProvider ServiceProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    IInterceptorChainBuilder Use(InterceptorDelegate interceptor, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; order);
    InterceptorDelegate Build();
    IInterceptorChainBuilder New();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于大部分情况下的拦截器都是根据约定定义的,所以我们为IInterceptorChainBuilder 定义了如下的扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorChainBuilderExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IInterceptorChainBuilder Use&amp;lt;TInterceptor&amp;gt;(&lt;span&gt;this&lt;/span&gt; IInterceptorChainBuilder builder, &lt;span&gt;int&lt;/span&gt; order, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] arguments)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IInterceptorChainBuilder Use(&lt;span&gt;this&lt;/span&gt; IInterceptorChainBuilder builder, Type interceptorType, &lt;span&gt;int&lt;/span&gt; order, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] arguments);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IInterceptorChainBuilder Use(&lt;span&gt;this&lt;/span&gt; IInterceptorChainBuilder builder, &lt;span&gt;object&lt;/span&gt; interceptor, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; order)；
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过在类型和方法/属性成员上标注对应特性是最常用的拦截器注册方式，这样的特性一般继承自InterceptorAttribute。如下面的代码片段所示，InterceptorAttribute实现了IInterceptorProvider接口，它的定义了&lt;strong&gt;Order&lt;/strong&gt;属性来表示注册拦截器最终在管道中的位置。AllowMultiple 属性来源于应用到当前特性类型上的AttributeUsageAttribute特性的同名属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorAttribute : Attribute, IInterceptorProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AllowMultiple {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Use(IInterceptorChainBuilder builder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-03.html&quot;&gt;拦截器的设计&lt;/a&gt;》中定义了那个FoobarInterceptor，我们可以将对应的特性定义成如下的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarAttribute: InterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _baz;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarAttribute (&lt;span&gt;string&lt;/span&gt; baz) =&amp;gt; _baz =&lt;span&gt; baz;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Use(IInterceptorChainBuilder builder)=&amp;gt; builder.Use&amp;lt;FoobarInterceptor&amp;gt;&lt;span&gt;(Order, _baz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果嫌将拦截器和对应的特性分开定义太繁琐，我们可以将它们合二为一。对于在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-03.html&quot;&gt;拦截器的设计&lt;/a&gt;》中定义了那个FoobarInterceptor可以定义成如下的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarAttribute:InterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _baz;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarAttribute(&lt;span&gt;string&lt;/span&gt; baz)=&amp;gt;_baz =&lt;span&gt; baz;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; InvokeAsync(InvocationContext context, IFoo foo, IBar bar)
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; PreInvokeAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; PostInvokeAsync();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Use(IInterceptorChainBuilder builder) =&amp;gt; builder.Use(&lt;span&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, Order, _baz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果某个类型或者方法不应该被拦截，我们可以在上面标注一个NonIntercetableAttribute。以如下这个Foobarbaz类型为例，由于FoobarInterceptorAttribute标注在类型，意味着对应的拦截器会应用到所有可被拦截的虚方法上。如果Baz方法不应该被拦截，应该在上面标注NonIntercetableAttribute特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[FoobarInterceptor]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobarbaz
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Foo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Bar();
    [NonInterceptable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Baz();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了利用NonIntercetableAttribute屏蔽所有的拦截器之外，我们还可以利用它&lt;strong&gt;屏蔽指定类型的拦截器&lt;/strong&gt;。如下面的代码片段所示，Foobarbaz类型上标注了三个InterceptorAttribute，但是方法Baz只需要BazInterceptorAttribute，我们可以利用NonIntercetableAttribute特性将其他两个屏蔽掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[FooInterceptor]
[BarInterceptor]
[BazInterceptor]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobarbaz
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Foo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Bar();
    [NonInterceptable(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(FooInterceptorAttribute), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(BarInterceptorAttribute), )]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Baz();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-01.html&quot;&gt;AOP框架Dora.Interception 3.0 [1]: 编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-2.html&quot;&gt;AOP框架Dora.Interception 3.0 [2]: 实现原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-03.html&quot;&gt;AOP框架Dora.Interception 3.0 [3]: 拦截器设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-04.html&quot;&gt;AOP框架Dora.Interception 3.0 [4]: 基于特性的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-05.html&quot;&gt;AOP框架Dora.Interception 3.0 [5]: 基于策略的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-06.html&quot;&gt;AOP框架Dora.Interception 3.0 [6]: 自定义拦截器注册方式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Oct 2019 00:29:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>按照单一职责的原则，拦截器只负责需要的拦截操作的执行，至于它采用何种方式应用到目标方法上，以及它在整个拦截器管道中的位置则属于“拦截器注册”的范畴。Dora.Interception提供了几种典型的注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/dora-interception-3-04.html</dc:identifier>
</item>
<item>
<title>创建优化的Go镜像文件以及踩过的坑 - 倚天码农</title>
<link>http://www.cnblogs.com/code-craftsman/p/11730136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code-craftsman/p/11730136.html</guid>
<description>&lt;p&gt;在Docker上创建Go镜像文件并不困难，但建立的文件很大，接近1G，使用起来不太方便。Docker镜像的一个主要难题就是如何优化，创建小的镜像。我们可以用多级构建的方法来创建Docker镜像文件，它也不复杂。但由于使用这种方法时，需要用简版的Linux（Alpine），它带来了一系列的问题。本文讲述如何解决这些问题并成功创建优化的Go镜像文件，优化之后只有14M。&lt;/p&gt;
&lt;h3 id=&quot;单级构建&quot;&gt;单级构建：&lt;/h3&gt;
&lt;p&gt;我们用一个Go程序作为例子来展示如何创建Go镜像。下面就是这个程序的目录结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201910/1805487-20191024082114914-1248736587.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Go程序的具体内容并不重要，只要能运行就行了。我们重点关注“docker”子目录（“kubernetes”子目录里的文件有别的用途，会在另外的文章中讲解）。它里面有三个文件。“docker-backend.sh”是创建镜像的命令文件，“Dockerfile-k8sdemo-backend”是多级构建文件，“Dockerfile-k8sdemo-backend-full”是单级构建文件，&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;FROM golang:latest # 从Docker库中获取标准golang镜像
WORKDIR /app # 设置镜像内的当前工作目录
COPY go.mod go.sum ./ # 拷贝Go的包管理文件
RUN go mod download # 下载依赖包中的依赖库
COPY . . #从宿主机拷贝文件到镜像
WORKDIR /app/cmd # 设置新的镜像内的当前工作目录
RUN GOOS=linux go build -o main.exe #编译Go程序，并在生成可执行文件
CMD exec /bin/bash -c &quot;trap : TERM INT; sleep infinity &amp;amp; wait&quot; # 保持镜像一直运行，容器不被停掉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是“Dockerfile-k8sdemo-backend-full”镜像文件。请阅读文件中的注释以获得解释。&lt;/p&gt;
&lt;p&gt;生成镜像容器&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd /home/vagrant/jfeng45/k8sdemo/
docker build -f ./script/kubernetes/backend/docker/Dockerfile-k8sdemo-backend-full -t k8sdemo-backend-full .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行镜像容器，“--name k8sdemo-backend-full”是给这个容器一个名字（k8sdemo-backend-full），最后的“k8sdemo-backend-full”是镜像的名字&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -td --name k8sdemo-backend-full k8sdemo-backend-full&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录镜像容器, 其中“a95c”是容器ID的前四位。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker exec -it a95c /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件里有一条语句需要特别解释一下“COPY . .”，它把文件从宿主机拷贝到镜像里，在镜像里已经用“WORKDIR”设置了当前工作目录，那么宿主机的“.”（当前目录）是哪个目录呢？它不是Dockerfile文件所在的目录，而是你运行“Docker build”命令时所在的目录。&lt;/p&gt;
&lt;p&gt;我们要把整个程序都拷贝到镜像里，那么在运行docker命令时一定是在程序的根目录，也就是“k8sdemo”目录。但是与容器有关的文件都在“script”目录的子目录下，那么当你运行“Docker build”命令时，它是怎么找到Docekrfile的呢？这里有一个重要的概念就是“build cotext”（构建上下文），由它来决定Dockerfile的缺省目录。当你运行“docker build -t k8sdemo-backend .”创建镜像时，它会从“build cotext”的根目录去找Dockerfile文件，缺省值是你运行docker命令的目录。但由于我们的Dockerfile在另外的目录里，因此需要在命令里加一个“-f”选项来指定Dockerfile的位置，命令如下。 其中“-t k8sdemo-backend-full” 是指明镜像名，格式是“name:tag”, 我们这里没有tag，就只有镜像名。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker build -f ./script/kubernetes/backend/docker/Dockerfile-k8sdemo-backend-full -t k8sdemo-backend-full .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情请参见&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/build/&quot;&gt;Dockerfile reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样创建的镜像用的是全版的Linux系统，因此比较大，大概接近1G。如果要想优化，就要用多级构建。&lt;/p&gt;
&lt;h3 id=&quot;multi-stage-builds多级构建&quot;&gt;Multi-stage builds(多级构建）：&lt;/h3&gt;
&lt;p&gt;单级构建只有一个“From”语句，而在多级构建中，有多个“From”，每个“From”构成一级。例如，下面的文件有两个“From”，是一个二级构建。每一级都可以根据需要选择适合自己的基础（base）镜像来构造本级镜像。每级镜像完成之后，下一级镜像可选择只保留上一级构建中对自己有用的最终文件，而删除所有的中间产物，这样就大大节省了空间。详情请参见&lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;Use multi-stage builds&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面就是多级构建的dockerfile(“Dockerfile-k8sdemo-backend”).&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;FROM golang:latest as builder # 本级镜像用“builder”标识
# Set the Current Working Directory inside the container
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
WORKDIR /app/cmd
# Build the Go app
#RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main.exe
RUN go build -o main.exe

######## Start a new stage from scratch #######
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
RUN mkdir /lib64 &amp;amp;&amp;amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
# Copy the Pre-built binary file from the previous stage
COPY --from=builder /app/cmd/main.exe . #把“/app/cmd/main.exe”文件从“builder”中拷贝到本级的当前目录
# Command to run the executable
CMD exec /bin/sh -c &quot;trap : TERM INT; (while true; do sleep 1000; done) &amp;amp; wait&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd /home/vagrant/jfeng45/k8sdemo/
docker build -f ./script/kubernetes/backend/docker/Dockerfile-k8sdemo-backend -t k8sdemo-backend .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --name k8sdemo-backend k8sdemo-backend /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的文件把构造过程分成两部分，第一部分编译并生成Go可执行文件，用的是是全版Linux. 第二部分是拷贝可执行文件到合适的目录并保持容器运行，用的是简化版Linux。第一部分的命令与单级构建指令基本相同，第二部分的命令会在后面解释。&lt;/p&gt;
&lt;p&gt;使用这种方法大大减少了空间占用，创建的Docker镜像只有14M，但由于它使用的简化版的Linux（Alpine），导致我踩了很多坑，下面看看这些坑是如何被填上的。&lt;/p&gt;
&lt;h3 id=&quot;踩过的坑&quot;&gt;踩过的坑：&lt;/h3&gt;
&lt;h4 id=&quot;找不到文件&quot;&gt;1. 找不到文件&lt;/h4&gt;
&lt;p&gt;创建镜像成功后，登录镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --name k8sdemo-backend k8sdemo-backend /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行编译后的Go可执行文件“main.exe”,错误信息如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;~ # ./main.exe
./main.exe not found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go是一个静态编译的语言，也就是说在编译时就把需要的库存放在编译好的程序里了，这样在执行时就不需要再动态链接其它库，使得运行起来非常方便。但并不是所有情况下都是这样，例如但当你使用了cgo(让Go程序可以调用C程序)时，通常需要动态链接libc库（在Linux里是glibc）。Go里的net和os/user库都用了cgo。但由于Apline的Linux版本没有libc库，这样在运行时就找不到动态链接，因此报错。它有两种办法来解决：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CGO_ENABLED=0：当你在编译Go时加了这个参数，编译时就不会使用cgo，当然也就意味着使用cgo的库都不能用了。这是最简单的办法，但它对你的程序有所限制。&lt;/li&gt;
&lt;li&gt;使用musl：musl是一个轻量级的libc库。Apline的Linux版本里自带musl库，你只要加入如下命令就行了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;RUN mkdir /lib64 &amp;amp;&amp;amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于musl的详情请参见&lt;a href=&quot;http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/&quot;&gt;Statically compiled Go programs, always, even with cgo, using musl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于这个错误的讨论请参见&lt;a href=&quot;https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker&quot;&gt;Installed Go binary not found in path on Alpine Linux Docker&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;zap报错&quot;&gt;2. Zap报错&lt;/h4&gt;
&lt;p&gt;Zap是一个很流行的Go日志库，我在程序里用它来输出日志。当加上上面的语句后，原来的错误消失了，但又有一个新的错。它是由Zap产生的。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;~ # ./main.exe
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x6a37ab]

goroutine 1 [running]:
github.com/jfeng45/k8sdemo/config.initLog(0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, ...)
        /app/config/zap.go:94 +0x1fb
github.com/jfeng45/k8sdemo/config.RegisterLog(0x0, 0x0)
        /app/config/zap.go:42 +0x42
github.com/jfeng45/k8sdemo/config.BuildRegistrationInterface(0x751137, 0x5, 0x43ab77, 0x984940, 0xc00002c750, 0xc000074f50)
        /app/config/appConfig.go:23 +0x26
main.testRegistration()
        /app/cmd/main.go:18 +0x3a
main.main()
        /app/cmd/main.go:11 +0x20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我现在也不十分清楚出错的原因，应该是跟Musl库有关。估计是Zap用到的某个库与Musl不兼容。我把日志换成另一个库Logrus问题就不存在了。这确实有点小遗憾，Zap是迄今为止我发现的最好的Go日志库。如果你坚持用Zap的话就只能用全版Linux，忍受大的镜像文件；或者改用Logrus日志库，这样就可以享受小的镜像文件。&lt;/p&gt;
&lt;h4 id=&quot;k8s部署不成功&quot;&gt;3. k8s部署不成功&lt;/h4&gt;
&lt;p&gt;换成Logrus之后，就没再报错，Docker里的程序运行正常。但如果你用这个镜像创建k8s部署时又出了问题。&lt;/p&gt;
&lt;p&gt;下面是k8s创建部署的命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vagrant@ubuntu-xenial:~/jfeng45/k8sdemo/script/kubernetes/backend$ kubectl get pod k8sdemo-backend-deployment-6b99dc6b8c-2fwnm
NAME                                          READY   STATUS             RESTARTS   AGE
k8sdemo-backend-deployment-6b99dc6b8c-2fwnm   0/1     CrashLoopBackOff   42         3h10m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误信息是“CrashLoopBackOff”。它产生的原因是容器要求里面的程序一直运行，一旦运行结束，容器就会停掉。k8s发现容器停掉之后会重新部署容器，然后又被停掉，这样就陷入了死循环。&lt;br/&gt;解决的办法是在镜像文件里加入如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;CMD exec /bin/bash -c &quot;trap : TERM INT; sleep infinity &amp;amp; wait&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情请参见&lt;a href=&quot;https://stackoverflow.com/questions/31870222/how-can-i-keep-a-container-running-on-kubernetes&quot;&gt;How can I keep a container running on Kubernetes?&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/questions/41604499/my-kubernetes-pods-keep-crashing-with-crashloopbackoff-but-i-cant-find-any-lo&quot;&gt;My kubernetes pods keep crashing with “CrashLoopBackOff” but I can't find any log&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;pod出错&quot;&gt;4. Pod出错&lt;/h4&gt;
&lt;p&gt;加入命令，重新生成镜像之后，果然解决了死循环的问题，k8s部署没有报错，但Pod又有了新的错误如下，“k8sdemo-backend-deployment-6b99dc6b8c-n6bnt”的“STATUS”是“Error”。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vagrant@ubuntu-xenial:~/jfeng45/k8sdemo/script/kubernetes/backend$ kubectl get pod
NAME                                           READY   STATUS    RESTARTS   AGE
envar-demo                                     1/1     Running   8          16d
k8sdemo-backend-deployment-6b99dc6b8c-n6bnt    0/1     Error     1          6s
k8sdemo-database-deployment-578fc88c88-mm6x8   1/1     Running   2          4d21h
nginx-deployment-77fff558d7-84z9z              1/1     Running   3          10d
nginx-deployment-77fff558d7-dh2ms              1/1     Running   3          10d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是在Docker文件里运行了如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;CMD exec /bin/bash -c &quot;trap : TERM INT; sleep infinity &amp;amp; wait&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但Alpine里没有“/bin/bash”.需要改成“/bin/sh”，需要修改成如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;CMD exec /bin/sh -c &quot;trap : TERM INT; (while true; do sleep 1000; done) &amp;amp; wait&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改之后，k8s部署成功，程序运行正常。&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;源码:&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jfeng45/k8sdemo&quot;&gt;完整源码的github链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;索引&quot;&gt;索引&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/build/&quot;&gt;Dockerfile reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot;&gt;Use multi-stage builds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/&quot;&gt;Statically compiled Go programs, always, even with cgo, using musl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker&quot;&gt;Installed Go binary not found in path on Alpine Linux Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31870222/how-can-i-keep-a-container-running-on-kubernetes&quot;&gt;How can I keep a container running on Kubernetes?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/41604499/my-kubernetes-pods-keep-crashing-with-crashloopbackoff-but-i-cant-find-any-lo&quot;&gt;My kubernetes pods keep crashing with “CrashLoopBackOff” but I can't find any log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.callicoder.com/docker-golang-image-container-example/&quot;&gt;Building Docker Containers for Go Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 24 Oct 2019 00:21:00 +0000</pubDate>
<dc:creator>倚天码农</dc:creator>
<og:description>在Docker上创建Go镜像文件并不困难，但建立的文件很大，接近1G，使用起来不太方便。Docker镜像的一个主要难题就是如何优化，创建小的镜像。我们可以用多级构建的方法来创建Docker镜像文件，它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/code-craftsman/p/11730136.html</dc:identifier>
</item>
<item>
<title>为程序员节日献礼--2019中国.NET开发者峰会主题内容发布 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11730063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11730063.html</guid>
<description>&lt;p&gt;2019年10月24日，组委会正式发布了China .NET Conf 2019中国 .NET 开发者峰会的主题内容。&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;900&quot; height=&quot;508&quot; alt=&quot;chinadotnetconnf&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201910/510-20191012084430371-413210351.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2014年微软组织并成立.NET基金会，微软在成为主要的开源参与者的道路上又前进了一步。2014年以来已经有众多知名公司加入.NET基金会，Google，微软，AWS三大云厂商已经齐聚.NET基金会，在平台项目中，.NET平台上有87％贡献者其实并不在Microsoft工作。为了将.NET基金会变成一个更加多样化和成员驱动的组织，微软把.NET 的发展真正交给社区，为了让OSS真正蓬勃发展。&lt;/p&gt;
&lt;p&gt;在中国这几年时间里我们不再局限于单打独斗的开源，我们通过协作来推动.NET开源项目和社区的发展，我们在github上成立了中国的开源组织dotnetcore，我们在全国各大城市有.NET 俱乐部定期举办活动。9月23号的2019年.Net Conf，今年它比以往任何时候规模都更大， .NET Core 3.0已经在大会上正式发布。中国区的活动也正式提上日程，好多年都没有像这样规模的社区大会，今年举办 .NET社区的中国峰会。预计1000人规模，覆盖中国 14个城市的.NET 社区及机构。&lt;/p&gt;
&lt;p&gt;我们从开始筹备2019 中国.NET 开发者峰会已经有好一段时间，从确定主题到寻找举办地，我们都是在业余时间进行，这次完全由中国.NET社区自发组织的大会，我们希望通过这次大会汇聚中国.NET社区的能量，.NET的刷新也包括我们自己的刷新。从10.11 日正式启动报名，在主题内容没有对外发布的情况下，得到了社区的积极支持，目前已经报名超过400人，我们为这次大会预备了1000人的规模。和参会人员规模相匹配的主题内容今天也正式对外发布。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;出品人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/a3c3423336042ef9acfd8d6029ffd918-sz_55130.jpeg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张善友 （张队）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET技术专家&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/63a2c07ea58c88cf506c754a99117252-sz_486578.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衣明志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;烟台易云网络&lt;/p&gt;
&lt;p&gt;创始人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/cb89c53b5f763e2985a87572f569ec69-sz_1320280.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苏震巍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;苏州盛派网络&lt;/p&gt;
&lt;p&gt;CEO兼首席架构师&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/881897fe25cce68b0a9f4d2b8e26ee76-sz_509971.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陈计节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;红帽开放创新实验室&lt;/p&gt;
&lt;p&gt;高级咨询顾问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/be0a2499ce7294f2bd38edbd34703993-sz_615978.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上海程析智能科技&lt;/p&gt;
&lt;p&gt;平台事业部负责人&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;大会议题及嘉宾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主会场&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间：09:00～12:20&lt;/p&gt;
&lt;p&gt;主持人：戚亚柱 - 广州.NET俱乐部 - 常务秘书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/f1d3cd221032cfe64ff2ff5c28d076b2-sz_467729.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;My Developer Journey with .NET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介:&lt;/strong&gt; As a former HR person, I changed my career to a software developer 15 years ago, and my developer journey started with .NET 1.0. Now, .NET Core 3.0 has been successfully launched, and I'd like to look back on how I and my work have dealt with .NET for their successful business, and what will be expected with the new .NET Core 3.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Justin Yoo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET / DevOps / Serverless / Messaging&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在从事软件开发期间，我在多家不同的公司担任过开发人员或顾问，涉猎众多行业。 在我的职业生涯中，学习新事物并与其他人分享始终让我充满激情。 它使得我两次荣获 Microsoft MVP 奖，而且现在我成为了 Microsoft 的云大使。&lt;/p&gt;
&lt;p&gt;我有两个博客，韩语的是 – aliencube，英语的是 devkimchi。 我还维护着很多面向 DevOps、无服务器、集成和消息传递的开源项目和示例代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/d71ee8e6e6ebc316de5ebdaaf5ae40f2-sz_98448.jpeg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在.NET Core下的机器学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;300 &lt;strong&gt;标签：&lt;/strong&gt;机器学习&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;.NET Core 在机器学习的应用场景，除了ML.NET还会介绍一个非常棒的開源技術TensorFlow.NET ， Keras.NET.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卢建晖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微软技术社区区域总监&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微软人工智能最有价值专家，Xamairn亚洲首位最有价值专家，腾讯云最有价值专家，华南师范大学网络教育学院程序开发总监。微软技术大会讲师，微软开发者峰会讲师，微软黑客马拉松教练。现阶段主要从事人工智能在教育，銀行领域的应用，专注于图像识别，人脸识别，行为识别，以及自然语言领域，会话机器人，知识图谱等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/be0a2499ce7294f2bd38edbd34703993-sz_615978.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASP.NET Core基于K8S的微服务电商案例实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;400  &lt;strong&gt;标签：&lt;/strong&gt;k8s，微服务&lt;/p&gt;
&lt;p&gt;主题简介：一个完整的电商项目微服务的实践过程，从选型、业务设计、架构设计到开发过程管理、以及上线运维的完整过程总结与剖析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上海程析智能科技  平台事业部负责人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;互联网老兵，多年产品研发、架构设计、团队管理经验。长期关注C#与.NET平台技术的发展，在博客园、infoQ以及公众号&quot;不务正业技术研究中心“发表多篇技术文章。并在video.jessetalk.cn上发布多个 .net core和Kubernetes相关的技术视频系列。目前技术研究方向为.net core平台与微服务和云原生架构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会场 A&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间：13:30～17:30&lt;/p&gt;
&lt;p&gt;主持人：张善友 （张队） .NET技术专家&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/950a073a13f5d57961870043424bbedb-sz_839195.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNC 在 K8S 上的开发实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200 &lt;strong&gt;标签：&lt;/strong&gt;.NET&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;本主题受众是架构师，开发人员，互联网企业IT运维人员.&lt;/p&gt;
&lt;p&gt;大纲：&lt;/p&gt;
&lt;p&gt;1 K8S对应用的要求&lt;/p&gt;
&lt;p&gt;2 DNC上K8S的优势&lt;/p&gt;
&lt;p&gt;3 K8S 下的 DNC 配置&lt;/p&gt;
&lt;p&gt;4 DNC 上分布式组件概览&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桂素伟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;株式会社ネットスターズ(NetStars) 架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前在株式会社ネットスターズ从事系统架构工作，多届微软MVP，喜欢分布式技术，迷恋在GitHub上彻墙，热衷技术社区分享，忠实的.net core布道者，从事.net 开发、架构10余年，仍然奋斗在码码的第一线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/36d3df738ecab60cfd25cf2606e3f2be-sz_85576.jpeg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务快速开发框架的设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200&lt;strong&gt;  标签：&lt;/strong&gt;微服务, 开发框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;从零开始搭建一个基于.net core平台的微服务快速开发框架，抛开深奥的理论与繁多的设计模式，以一线业务开发人员的需求视角，分享作为一个功能齐全的微服务开发框架到底要有哪些东西，又该如何去实现。&lt;/p&gt;
&lt;p&gt;目标受众：一线开发工程师，想体验架构师工作的高级开发工程师，入门级系统架构师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朱宗海&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蔚来汽车  架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前在上海蔚来汽车有限公司数字发展部从事系统架构和软件开发工作，中学化学教师出身，热爱搬砖码代码，码龄超过19年。从事.net开发、架构也已有10余年，热衷从GitHub上搬东挪西，寻找宝贝；常年潜水于各大技术社区，静观风云变幻，然后毫不动摇的奋战在码农一线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/bd50ad000489522bfd4957a616e33671-sz_763829.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深入浅出Application Insights&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200  &lt;strong&gt;标签：&lt;/strong&gt;Application Insights&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介&lt;/strong&gt;：介绍如何将Application Insights用于生产上实践，并透过它发现/诊断问题。同时也会介绍如何将Application Insighs与其他体系相集成实现Devops（与发布系统整合，自动报表，历史数据持久化等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;罗彬&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一嗨租车 架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;擅长和热衷于对.Net技术，Devops等方面的研究。现在主要负责公司底层接口开发和架构设计，并负责Devops敏捷工程的落地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/cb89c53b5f763e2985a87572f569ec69-sz_1320280.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.Net Core + 微信赋能企业级智能客服系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;围绕目前需求猛增的微信及移动端企业智能客服业务，利用 .NET Core 的一系列优秀特性及 SignalR 模块打造全双工、跨微信/QQ/钉钉等应用平台、跨系统平台、跨终端、支持企业级并发的移动端客服系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苏震巍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;苏州盛派网络科技 CEO 兼首席架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微软最有价值专家（MVP）、微软技术俱乐部（苏州）主席、苏州市人工智能学会理事、Senparc.Weixin SDK 作者、《网站模块化开发全程实录》《微信开发深度解析》图书作者。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;闪电演讲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RPA AI .NET Core 与未来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;潘淳 -&lt;/strong&gt; 微软技术俱乐部（苏州） - 执行主席&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会场B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间：13:30～17:30&lt;/p&gt;
&lt;p&gt;主持人：朱兴亮 微软 CA PM&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/5c33fcc9b05220223298df57d3b79540-sz_1055344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET 大数据实时计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200 &lt;strong&gt;标签：&lt;/strong&gt;大数据分析、实时计算平台、万亿级计算量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;纯.Net自研大数据实时计算平台，在中通快递服务数百亿包裹，处理数据万亿计！将分享大数据如何落地以及设计思路，技术重难点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黄国石&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中通快递，资深架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;20年码农，多年物联网创业经验，近两三年负责公司营运方向大数据分析，团队自研.NET实时计算平台，700多个作业，万亿级计算量，为每天一亿个包裹保驾护航！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/c3d68fcbe175938d47c2683ce1e2659d-sz_1005804.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET 技术架构下的混沌工程实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;300 &lt;strong&gt;标签：&lt;/strong&gt;混沌工程，.NET开发，分布式系统高可用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主&lt;/strong&gt;&lt;strong&gt;题简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1 .Net混沌工程-写在前面的话，什么是混沌工程，为什么需要混沌工程，.Net大型分布式、服务化系统架构下高可用性挑战：IIS被打爆、SQLServer被打爆、RPC通讯不稳定、Redis、RabbitMQ、Kafka等中间件宕机等等&lt;/p&gt;
&lt;p&gt;2.  .Net混沌工程-方法论和因地制宜，混沌工程推荐的方法论和实施步骤，基于已有的线上事故和问题，面向.Net分布式架构制定混沌工程实验的方法和套路&lt;/p&gt;
&lt;p&gt;3.  .Net混沌工程-实践和成果，分享基于.Net技术的混沌事件注入框架和工具，通过混沌工程踩过的坑、发现的问题，以及问题的解决方案：容错降级、故障转移、超时治理、重试补偿、限流隔离等，最终做到问题闭环、质量归零&lt;/p&gt;
&lt;p&gt;4.  混沌工程-展望和规划，混沌工程Team建设和文化建设，持续执行改进&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周国庆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特来电新能源公共技术部部长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特来电公共技术平台（基于 .NET 技术栈，每天5亿次服务调用、670W度充电量的应用规模）负责人，十年以上的一线开发、运维经历，积累了大量分布式系统高可用性架构设计经验，目前专注于高可用平台的建设和混沌工程实践，希望通过高可用改造和大量的混沌实验，不断提升系统的稳定性和可用性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/e90647c3541dc906b8f5e8dd8acb0906-sz_203808.jpeg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core下建立测试驱动的高效开发模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200 &lt;strong&gt;标签：&lt;/strong&gt;单元测试、文件监视测试、托管测试主机集成测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-为什么要编写测试用例&lt;/p&gt;
&lt;p&gt;-.NETCore下的测试框架&lt;/p&gt;
&lt;p&gt;-单元测试&lt;/p&gt;
&lt;p&gt;-文件监视测试&lt;/p&gt;
&lt;p&gt;-托管逐渐集成测试&lt;/p&gt;
&lt;p&gt;-CI/CD下的自动化测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梁规晓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gworld（平潭）互联网科技首席架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/881897fe25cce68b0a9f4d2b8e26ee76-sz_509971.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core 微服务测试最佳实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;300 &lt;strong&gt;标签：&lt;/strong&gt;微服务，测试自动化&lt;/p&gt;
&lt;p&gt;从单元测试的分层和边界介绍微服务系统中的单元测试、集成测试、组件测试和契约测试等各类测试及其适应场景，总结 .NET Core 在微服务系统中进行自动化测试可用的各种工具和最佳实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陈计节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;红帽开放创新实验室 高级咨询顾问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注运用云原生 DevOps 和敏捷方法帮助企业构建数字化转型的中坚力量。陈计节是社区的活跃贡献者，dotnet club 项目负责人。翻译有《ASP.NET Core 微服务实战》、参与翻译《.NET 性能优化》，大量发表各类技术文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闪电演讲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用.NET Core技术构建全新物联网电子标签系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黄海鹏&lt;/strong&gt; - 苏州易泰勒电子 - 研发总监   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会场C&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间：13:30～17:30&lt;/p&gt;
&lt;p&gt;主持人：衣明志 烟台易云网络 创始人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/f1a2e49946bc987dd40fd67c76f932c5-sz_572547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;健康检查组件与高可用架构实战&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200&lt;strong&gt;标签：&lt;/strong&gt;.NET Core, 高可用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;介绍NetCorePal.HealthCheck健康检查组件的使用方法，以及如何与k8s、阿里云SLB、Azure云等基础设施集成实现可监控、具备自愈能力的高可用架构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;肖伟宇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;校宝在线技术专家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;擅长微软.NET技术，十多年技术架构经验，SkyWalking .NET探针贡献者 NetCorePal组件库创建者，Global Azure Bootcamp 2019 组办者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/12412779e32572786e52107aea45c739-sz_28366.jpg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET 下的深度学习应用实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;300  &lt;strong&gt;标签：&lt;/strong&gt;深度学习，人工智能技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 介绍.NET 下的深度学习技术；&lt;/p&gt;
&lt;p&gt;2. 通过案例实践介绍应用效果；&lt;/p&gt;
&lt;p&gt;3. 深度学习开发中的一些技巧；&lt;/p&gt;
&lt;p&gt;4. 介绍未来 .NET下深度学习相关技术可能的发展趋势；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘凡平&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;国内某科技公司算法团队负责人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;擅长于搜索引擎、大数据分析、传统机器学习及深度学习等相关研发工作，曾出版《大数据-搜索引擎原理分析》、《大数据时代的算法》、《神经网络与深度学习应用实战》等技术专著，是执着于将技术演绎为艺术的完美追求者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/32e97132ca0adaf0b5211c40e5c6b00f-sz_263228.jpeg?x-oss-process=style/xmorient&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core IOT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;200 &lt;strong&gt;标签：&lt;/strong&gt;.NET Core, IOT,树莓派(Raspberry Pi)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本主题介绍了如何在物联网设备上安装和使用.NET Core 技术进行物联网边缘系统的开发.整个主题涉及到如下的部分:&lt;/p&gt;
&lt;p&gt;1. 在Raspberry Pi设备上安装.NET Core SDK,以 Raspberry Pi 3(也可以安装Windows 10 IOT Core版本)和Ubuntu系统为例.&lt;/p&gt;
&lt;p&gt;2. 利用.NET Core 操作树莓派的GPIO口&lt;/p&gt;
&lt;p&gt;3. 向Azure IOT Hub传输模拟数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杨守斌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;青岛萨纳斯智能科技 副总经理兼技术总监&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;曾连任多年微软最有价值专家，目前主要是从事基于云计算的物联网、大数据、BIM系统开发,并结合机器学习和人工智能应用方面的研究。在生物，新能源，物理海洋,交通和信息结合领域有丰富的实践经验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/badb2dc35e7b3cdba96ebd21ede98de8-sz_960317.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abp vNext 下一代ASP.NET Core开源应用程序框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;100 &lt;strong&gt;标签：&lt;/strong&gt;abp，aspnetcore&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;ABP vNext是ASP.NET  Boilerplate下一代框架，它吸收了ASP.NET Boilerplate的经验并且重新设计。  它基于领域驱动思想设计，拥有模块化、多租户、虚拟文件系统、审计、动态API等众多特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梁士伟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上海(韵达)蜜罐信息科技架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专注Net最佳实践. 开源爱好者&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闪电演讲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;winform场景化窗体设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;郭腾飞 -&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;工作坊&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;***注意：工作坊需单独报名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作坊时间：2019年11月10日（会议后一天）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core 基于 K8S 的微服务和 CI/CD 动手实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【课程大纲】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;09:00~12:00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整流程介绍&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core 容器化开发基础 - 张善友&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;K8S 基础 - 刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Pod&lt;/p&gt;
&lt;p&gt;- Service&lt;/p&gt;
&lt;p&gt;- Ingress&lt;/p&gt;
&lt;p&gt;- Deployment&lt;/p&gt;
&lt;p&gt;- Dashboard &lt;/p&gt;
&lt;p&gt;Demo &amp;amp; 动手 （动手实现一个API部署到k8s中）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13:30 ~ 16:30&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务原理、结构 - 刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 服务通信&lt;/p&gt;
&lt;p&gt;- 网关&lt;/p&gt;
&lt;p&gt;- 统一认证&amp;amp;授权 &lt;/p&gt;
&lt;p&gt;- 配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CI/CD讲解- 陈计节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 基本原理&lt;/p&gt;
&lt;p&gt;- .NET Core CI/CD 流程&lt;/p&gt;
&lt;p&gt;- Jenkins 工具的使用&lt;/p&gt;
&lt;p&gt;- 云原生环境的 CI/CD&lt;/p&gt;
&lt;p&gt;Demo &amp;amp; 动手 (微服务 &amp;amp; CI/CD)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【讲师】 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张善友 （张队）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET技术专家，前腾讯 FIT 研发平台部高级工程师，连续14年被评为微软（MVP），腾讯云TVP，华为云MVP。拥有超过十七年IT行业经验，他是深圳市友浩达科技有限公司CEO&amp;amp;CTO，他还热心于进行社区奉献，运营微信公众号“dotnet跨平台”,同时积极参与.NET社区开源项目，被尊称为张队长&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陈计节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;红帽开放创新实验室 高级咨询顾问&lt;/p&gt;
&lt;p&gt;关注运用云原生 DevOps 和敏捷方法帮助企业构建数字化转型的中坚力量。陈计节是社区的活跃贡献者，dotnet club 项目负责人。翻译有《ASP.NET Core 微服务实战》、参与翻译《.NET 性能优化》，大量发表各类技术文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘腾飞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上海程析智能科技  平台事业部负责人&lt;/p&gt;
&lt;p&gt;互联网老兵，多年产品研发、架构设计、团队管理经验。长期关注C#与.NET平台技术的发展，在博客园、infoQ以及公众号&quot;不务正业技术研究中心“发表多篇技术文章。并在video.jessetalk.cn上发布多个 .net core和Kubernetes相关的技术视频系列。目前技术研究方向为.net core平台与微服务和云原生架构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;助教&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;陈作 -  广州.NET技术俱乐部执行主席&lt;/p&gt;
&lt;p&gt;章展宏 -  程析智能&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;支持伙伴&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;战略合作伙伴：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/0c275f2c032dc9c3c46b55e98033e46d-sz_32725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高效、混合、智能、可信赖。Azure 是一个不断扩展的云计算服务集合，它可以帮助组织应对各种商业挑战。通过 Azure，公司和组织可使用首选工具和框架，在大规模全球性网络上随心所欲地构建、管理和部署应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;星牌支持：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/e6348b8b1e86c645948e6348149ebb89-sz_47672.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;校宝在线成立于2010年，是中国深受欢迎的教育产业服务平台，目前已帮助超9万个教育品牌实现信息化管理，超18万个校区实现互联网+教育业务升级。校宝在线正以“双轮驱动+增值服务”战略全面布局教育服务产业。&lt;/p&gt;
&lt;p&gt;网址：https://www.xiaobaoonline.com/pc/index&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PPT设计支持：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/76b250059b63d9f4486c99f6f852a165-sz_99913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;武汉享绎多媒体技术有限公司是一家专注Office培训与PPT商业定制服务的公司，为企事业单位及个人提供线下培训服务以及提供发布会、工作汇报、产品介绍、课件制作等方面的PPT定制服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社区伙伴：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/a2d1fcc2e5e2b983faee8fd6e87eaa0b-sz_23003.png&quot;/&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/64c1b67d959fbd04da478767e8016b83-sz_27049.png&quot;/&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/fde262413ad61c26a912d7687965845f-sz_292573.png&quot;/&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/3e5a90348878f5106167e8a1c0cd8933-sz_156028.png&quot;/&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/19199f1449869d7f4a5418c77dfd4237-sz_148820.png&quot;/&gt;&lt;img src=&quot;http://img.xiumi.us/xmi/ua/fxGo/i/c8b52bf20ecdf03be61b9044b1e2e148-sz_78392.png&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;大会的日期是：2019年11月9日 09:00-18：00&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;大会地址：（上海杨浦）佳木斯路777号上海中谷小南国花园酒店&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;门票优惠：10月20日前购票可享受早鸟票100元优惠，只需199，限量300张，先到先得；超级早鸟票及社区特价票需要审核资料；购买团体票（大于10张）享受整单8折优惠，请通过邮箱联系主办方 &lt;a href=&quot;mailto:dotnet@dotnetconf.cn&quot;&gt;dotnet@dotnetconf.cn&lt;/a&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;报名方式&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;活动行：&lt;a href=&quot;https://www.huodongxing.com/event/4514005355700&quot;&gt;https://www.huodongxing.com/event/4514005355700&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6I1WlPicJvFuFjHvWBbEVViaz3U9YaXEGEUgXQL9d3rhMGlxKSsQ0wP19iczrdjficiaYjLaickMxNNlicKw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;百格活动：&lt;a href=&quot;https://www.bagevent.com/event/6069892&quot;&gt;https://www.bagevent.com/event/6069892&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gak2lhVxV6II7iaqGVXFFOTeOUlAPiciamw5kYrQBMiaN88WKoLJZHLZEc74SFBarusxnIM6A9h4lWELVSPMkFd74g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
</description>
<pubDate>Wed, 23 Oct 2019 22:45:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>2019年10月24日，组委会正式发布了China .NET Conf 2019中国 .NET 开发者峰会的主题内容。2014年微软组织并成立.NET基金会，微软在成为主要的开源参与者的道路上又前进了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11730063.html</dc:identifier>
</item>
<item>
<title>深入理解Transformer及其源码解读 - ZingpLiu</title>
<link>http://www.cnblogs.com/zingp/p/11696111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zingp/p/11696111.html</guid>
<description>&lt;div&gt;　　&lt;span&gt;深度学习广泛应用于各个领域。基于transformer的预训练模型（gpt/bertd等）基本已统治NLP深度学习领域，可见transformer的重要性。本文结合&lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot; target=&quot;_blank&quot;&gt;《Attention is all you need》&lt;/a&gt;与Harvard的代码&lt;a href=&quot;http://nlp.seas.harvard.edu/2018/04/03/attention.html&quot; target=&quot;_blank&quot;&gt;《Annotated Transformer》&lt;/a&gt;深入理解transformer模型。 Harvard的代码在python3.6 torch 1.0.1 上跑不通，本文做了很多修改。修改后的代码地址：&lt;a href=&quot;https://github.com/zingp/NLP/blob/master/P006TheAnnotatedTransformer/model_transformer.ipynb&quot; target=&quot;_blank&quot;&gt;Transformer&lt;/a&gt;。&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;1 模型的思想&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Transformer中抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。 作者采用Attention机制的原因是考虑到RNN（或者LSTM，GRU等）的计算限制为是顺序的，也就是说RNN相关算法只能从左向右依次计算或者从右向左依次计算，这种机制带来了两个问题：　&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;(1) 时间片 $t$ 的计算依赖 $t-1$ 时刻的计算结果，&lt;span&gt;这样限制了模型的并行能力&lt;/span&gt;；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2) 顺序计算的过程中信息会丢失，尽管LSTM等门机制的结构一定程度上缓解了长期依赖的问题，但是对于特别&lt;span&gt;&lt;strong&gt;长期的依赖现象，LSTM依旧无能为力&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Transformer的提出解决了上面两个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1) 首先它使用了&lt;span&gt;&lt;strong&gt;Attention机制&lt;/strong&gt;&lt;/span&gt;，将序列中的任意两个位置之间的距离是缩小为一个常量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2) 其次它不是类似RNN的顺序结构，因此具有&lt;span&gt;&lt;strong&gt;更好的并行性，符合现有的GPU框架&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;2 模型的架构&lt;/h2&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191022014647792-1133349172.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;425&quot;/&gt;&lt;p&gt;&lt;span&gt;　　如上图，transformer模型本质上是一个Encoder-Decoder的结构。输入序列先进行Embedding，经过Encoder之后结合上一次output再输入Decoder，最后用softmax计算序列下一个单词的概率。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;3 Embedding&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;transformer的输入是&lt;span&gt;&lt;strong&gt;Word Embedding + Position Embedding&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.1 Word Embedding&lt;/h2&gt;
&lt;div readability=&quot;16&quot;&gt;　　&lt;span&gt;Word embedding在pytorch中通常用 nn.Embedding 实现，其权重矩阵通常有两种选择：&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　（1）使用 Pre-trained的&lt;strong&gt;Embeddings并固化&lt;/strong&gt;，这种情况下实际就是一个 Lookup Table。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）对其进行随机初始化(当然也可以选择 Pre-trained 的结果)，但&lt;strong&gt;设为 Trainable&lt;/strong&gt;。这样在 training 过程中不断地对 Embeddings 进行改进。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　transformer选择后者，代码实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Embeddings(nn.Module):
    def __init__(self, d_model, vocab):
        super(Embeddings, self).__init__()
        self.lut = nn.Embedding(vocab, d_model)
        self.d_model = d_model  #表示embedding的维度

    def forward(self, x):
        return self.lut(x) * math.sqrt(self.d_model)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;其中d_model表示embedding的维度，即词向量的维度；vocab表示词汇表的数量。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;3.2 Positional Embedding&lt;/h2&gt;
&lt;div readability=&quot;36&quot;&gt;
&lt;p&gt;　　&lt;span&gt;在RNN中，对句子的处理是一个个word按顺序输入的。但在 Transformer 中，输入句子的所有word是同时处理的，没有考虑词的排序和位置信息。因此，Transformer 的作者提出了加入 “positional encoding” 的方法来解决这个问题。“positional encoding“”使得 Transformer 可以衡量 word 位置有关的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;如何实现具有位置信息的encoding呢？&lt;/strong&gt;作者提供了两种思路：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过训练学习 positional encoding 向量；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用公式来计算 positional encoding向量。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　试验后发现两种选择的结果是相似的，所以采用了第2种方法，优点是不需要训练参数，而且即使在训练集中没有出现过的句子长度上也能用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Positional Encoding的公式如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;$$PE_{(pos,2i)} = sin(pos / 10000^{2i/d_{\text{model}}})$$&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;$$PE_{(pos,2i+1)} = cos(pos / 10000^{2i/d_{\text{model}}})$$&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，$pos$指的是这个 word 在这个句子中的位置；&lt;/span&gt;&lt;span&gt;$2i$指的是 embedding 词向量的偶数维度，$2i+1$指的是embedding 词向量的奇数维度。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;&lt;span&gt;具体实现如下&lt;/span&gt;：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# Positional Encoding
class PositionalEncoding(nn.Module):
    &quot;实现PE功能&quot;
    def __init__(self, d_model, dropout, max_len=5000):
        super(PositionalEncoding, self).__init__()
        self.dropout = nn.Dropout(p=dropout)
        
        pe = torch.zeros(max_len, d_model)
        position = torch.arange(0., max_len).unsqueeze(1)
        div_term = torch.exp(torch.arange(0., d_model, 2) *
                             -(math.log(10000.0) / d_model))
        
        pe[:, 0::2] = torch.sin(position * div_term)    # 偶数列
        pe[:, 1::2] = torch.cos(position * div_term)    # 奇数列
        pe = pe.unsqueeze(0)           # [1, max_len, d_model]
        self.register_buffer('pe', pe)
        
    def forward(self, x):
        x = x + Variable(self.pe[:, :x.size(1)], requires_grad=False)
        return self.dropout(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&quot;x = x + Variable(self.pe[:, :x.size(1)], requires_grad=False)&quot; 这行代码表示；输入模型的&lt;span&gt;&lt;strong&gt;整个Embedding是Word Embedding与Positional Embedding直接相加之后的结果。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;为什么上面的两个公式能体现单词的相对位置信息呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;&lt;span&gt;&lt;span&gt;　　我们写一段代码取词向量的4个维度看下：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 在位置编码下方，将基于位置添加正弦波。对于每个维度，波的频率和偏移都不同。
plt.figure(figsize=(15, 5))
pe = PositionalEncoding(20, 0)
y = pe.forward(Variable(torch.zeros(1, 100, 20)))
plt.plot(np.arange(100), y[0, :, 4:8].data.numpy())
plt.legend([&quot;dim %d&quot;%p for p in [4,5,6,7]])
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;　　&lt;span&gt;输出图像：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191022192204824-1243950811.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;可以看到某个序列中不同位置的单词，在某一维度上的位置编码数值不一样，即同一序列的不同单词在单个纬度符合某个正弦或者余弦，可认为他们的具有相对关系。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;4 Encoder&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Encoder部分是由个层相同小Encoder Layer串联而成。小Encoder Layer可以简化为两个部分：&lt;span&gt;（&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1）Multi-Head Self Attention&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;(2) Feed-Forward network&lt;/strong&gt;&lt;/span&gt;。示意图如下:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191022202020864-1986279470.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;254&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;事实上multi head self attention 和feed forward network之后都接了一层add 和norm这里先不讲，后面4.1.2再讲。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.1 Muti-Head-Attention&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Multi-Head Self Attention 实际上是&lt;strong&gt;由h个Self Attention 层并行组成，原文中h=8&lt;/strong&gt;。接下来我们先介绍Self Attention。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.1.1 Self-Attention&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;　self-attention的输入是序列词向量，此处记为x。x经过一个线性变换得到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;query(Q)&lt;span&gt;,&lt;/span&gt; x经过第二个线性变换得到&lt;code class=&quot;language-python&quot;&gt;key(K)&lt;/code&gt;,  x经过第三个线性变换得到&lt;code class=&quot;language-python&quot;&gt;value(V)&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;key = linear_k(x)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;query = linear_q(x)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;value = linear_v(x)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;用矩阵表示即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191024014205410-2072234373.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;402&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;这里的linear_k, linear_q, linear_v是相互独立、权重（$W^Q$, $W^K$, $&lt;strong&gt;W^V&lt;/strong&gt;$)是不同的，通过训练可得到。&lt;/strong&gt;得到query(Q)，key(K)，value(V)之后按照下面的公式计算attention(Q, K, V)：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$$Attention(Q, K, V) = Softmax(\frac{QK^T}{\sqrt{d_k}})V$$&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用矩阵表示上面的公式即：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;49&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191023002754992-1294082266.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;325&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;p&gt; 　　&lt;span&gt;这里Z就是attention(Q, K, V)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1) 这里$d_k=d_{model}/h = 512/8 = 64$。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2) 为什么要用$\sqrt{d_k}$ 对 $QK^T$进行缩放呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$d_k$实际上是Q/K/V的最后一个维度，当$d_k$越大，$QK^T$就越大，可能会&lt;span&gt;&lt;strong&gt;将&lt;/strong&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span&gt;&lt;strong&gt;softmax函数推入梯度极小的区域&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;(3) softmax之后值都介于0到1之间，可以理解成得到了 attention weights。然后基于这个 attention weights 对 V 求 weighted sum 值 Attention(Q, K, V)。&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Multi-Head-Attention 就是将embedding之后的X按&lt;span&gt;维度$d_{model}=512$ 切割成$h=8$个，分别做self-attention之后再合并在一起&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;源码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;80&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class MultiHeadedAttention(nn.Module):
    def __init__(self, h, d_model, dropout=0.1):
        &quot;Take in model size and number of heads.&quot;
        super(MultiHeadedAttention, self).__init__()
        assert d_model % h == 0
        self.d_k = d_model // h
        self.h = h
        self.linears = clones(nn.Linear(d_model, d_model), 4)
        self.attn = None
        self.dropout = nn.Dropout(p=dropout)
        
    def forward(self, query, key, value, mask=None):
        &quot;&quot;&quot;
        实现MultiHeadedAttention。
           输入的q，k，v是形状 [batch, L, d_model]。
           输出的x 的形状同上。
        &quot;&quot;&quot;
        if mask is not None:
            # Same mask applied to all h heads.
            mask = mask.unsqueeze(1)
        nbatches = query.size(0)
        
        # 1) 这一步qkv变化:[batch, L, d_model] -&amp;gt;[batch, h, L, d_model/h] 
        query, key, value = \
            [l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2)
                   for l, x in zip(self.linears, (query, key, value))]
        
        # 2) 计算注意力attn 得到attn*v 与attn
        # qkv :[batch, h, L, d_model/h] --&amp;gt;x:[b, h, L, d_model/h], attn[b, h, L, L]
        x, self.attn = attention(query, key, value, mask=mask, dropout=self.dropout)
        # 3) 上一步的结果合并在一起还原成原始输入序列的形状
        x = x.transpose(1, 2).contiguous().view(nbatches, -1, self.h * self.d_k)
        # 最后再过一个线性层
        return self.linears[-1](x)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;4.1.2 Add &amp;amp; Norm&lt;/h2&gt;
&lt;div readability=&quot;16&quot;&gt;　　&lt;span&gt;x 序列经过multi-head-self-attention 之后实际经过一个“add+norm”层，再进入feed-forward network(后面简称FFN)，在FFN之后又经过一个norm再输入下一个encoder layer。&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class LayerNorm(nn.Module):
    &quot;&quot;&quot;构造一个layernorm模块&quot;&quot;&quot;
    def __init__(self, features, eps=1e-6):
        super(LayerNorm, self).__init__()
        self.a_2 = nn.Parameter(torch.ones(features))
        self.b_2 = nn.Parameter(torch.zeros(features))
        self.eps = eps

    def forward(self, x):
        &quot;Norm&quot;
        mean = x.mean(-1, keepdim=True)
        std = x.std(-1, keepdim=True)
        return self.a_2 * (x - mean) / (std + self.eps) + self.b_2


class SublayerConnection(nn.Module):
    &quot;&quot;&quot;Add+Norm&quot;&quot;&quot;
    def __init__(self, size, dropout):
        super(SublayerConnection, self).__init__()
        self.norm = LayerNorm(size)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x, sublayer):
        &quot;add norm&quot;
        return x + self.dropout(sublayer(self.norm(x)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意：几乎每个sub layer之后都会经过一个归一化，然后再加在原来的输入上。这里叫残余连接。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;4.2 Feed-Forward Network&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Feed-Forward Network可以细分为有两层，第一层是一个线性激活函数，第二层是激活函数是ReLU。可以表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;$$FFN=max(0, xW_1+b_1)W_2 + b_2$$&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;&lt;span&gt;　　这层比较简单，就是实现上面的公式，直接看代码吧&lt;/span&gt;：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# Position-wise Feed-Forward Networks
class PositionwiseFeedForward(nn.Module):
    &quot;实现FFN函数&quot;
    def __init__(self, d_model, d_ff, dropout=0.1):
        super(PositionwiseFeedForward, self).__init__()
        self.w_1 = nn.Linear(d_model, d_ff)
        self.w_2 = nn.Linear(d_ff, d_model)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x):
        return self.w_2(self.dropout(F.relu(self.w_1(x))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　总的来说Encoder 是由上述小encoder layer 6个串行叠加组成。encoder sub layer主要包含两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;SubLayer-1 做 Multi-Headed Attention&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SubLayer-2 做 Feed Forward Neural Network&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　来看下Encoder主架构的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def clones(module, N):
    &quot;产生N个相同的层&quot;
    return nn.ModuleList([copy.deepcopy(module) for _ in range(N)])

class Encoder(nn.Module):
    &quot;&quot;&quot;N层堆叠的Encoder&quot;&quot;&quot;
    def __init__(self, layer, N):
        super(Encoder, self).__init__()
        self.layers = clones(layer, N)
        self.norm = LayerNorm(layer.size)
        
    def forward(self, x, mask):
        &quot;每层layer依次通过输入序列与mask&quot;
        for layer in self.layers:
            x = layer(x, mask)
        return self.norm(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;5 Decoder&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Decoder与Encoder有所不同，Encoder与Decoder的关系可以用下图描述（以机器翻译为例）：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;28&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191023010637011-63525330.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;367&quot;/&gt;&lt;p&gt;&lt;span&gt;Decoder的代码主要结构：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# Decoder部分
class Decoder(nn.Module):
    &quot;&quot;&quot;带mask功能的通用Decoder结构&quot;&quot;&quot;
    def __init__(self, layer, N):
        super(Decoder, self).__init__()
        self.layers = clones(layer, N)
        self.norm = LayerNorm(layer.size)
        
    def forward(self, x, memory, src_mask, tgt_mask):
        for layer in self.layers:
            x = layer(x, memory, src_mask, tgt_mask)
        return self.norm(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Decoder子结构（Sub layer）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986023/201910/986023-20191023011659600-898343727.png&quot; alt=&quot;&quot; width=&quot;241&quot; height=&quot;615&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Decoder 也是N=6层堆叠的结构。被分为3个 SubLayer，Encoder与Decoder有&lt;strong&gt;三大主要的不同&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）Decoder SubLayer-1 使用的是 “Masked” Multi-Headed Attention 机制，防止为了模型看到要预测的数据，防止泄露。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）SubLayer-2 是一个 Encoder-Decoder Multi-head Attention。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　(3)  LinearLayer 和 SoftmaxLayer 作用于 SubLayer-3 的输出后面，来预测对应的 word 的 probabilities 。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;5.1 Mask-Multi-Head-Attention&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Mask 的目的是防止 Decoder “seeing the future”，就像防止考生偷看考试答案一样。这里mask是一个下三角矩阵，对角线以及对角线左下都是1，其余都是0。下面是个10维度的下三角矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;57.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;135&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
tensor([[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
         [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
         [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
         [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
         [1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
         [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
         [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]], dtype=torch.uint8)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Mask的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def subsequent_mask(size):
    &quot;&quot;&quot;
    mask后续的位置，返回[size, size]尺寸下三角Tensor
    对角线及其左下角全是1，右上角全是0
    &quot;&quot;&quot;
    attn_shape = (1, size, size)
    subsequent_mask = np.triu(np.ones(attn_shape), k=1).astype('uint8')
    return torch.from_numpy(subsequent_mask) == 0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　当mask不为空的时候，attention计算需要将x做一个操作：scores = scores.masked_fill(mask == 0, -1e9)。即将mask==0的替换为-1e9,其余不变。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.2 Encoder-Decoder Multi-head Attention&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这部分和Multi-head Attention的区别是该层的输入&lt;strong&gt;来自encoder和上一次decoder的结果&lt;/strong&gt;。具体实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class DecoderLayer(nn.Module):
    &quot;Decoder is made of self-attn, src-attn, and feed forward (defined below)&quot;
    def __init__(self, size, self_attn, src_attn, feed_forward, dropout):
        super(DecoderLayer, self).__init__()
        self.size = size
        self.self_attn = self_attn
        self.src_attn = src_attn
        self.feed_forward = feed_forward
        self.sublayer = clones(SublayerConnection(size, dropout), 3)
 
    def forward(self, x, memory, src_mask, tgt_mask):
        &quot;将decoder的三个Sublayer串联起来&quot;
        m = memory
        x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask))
        x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask))
        return self.sublayer[2](x, self.feed_forward)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;注意：&lt;/span&gt;self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) 这行就是Encoder-Decoder Multi-head Attention。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　query = x，key = m, value = m, mask = src_mask，&lt;strong&gt;这里&lt;span&gt;x来自上一个 DecoderLayer&lt;/span&gt;，&lt;span&gt;m来自 Encoder的输出&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.3 Linear and Softmax to Produce Output Probabilities&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Decoder的最后一个部分是过一个linear layer将decoder的输出扩展到与vocabulary size一样的维度上。经过softmax 后，选择概率最高的一个word作为预测结果。&lt;/span&gt;&lt;span&gt;假设我们有一个已经训练好的网络，&lt;strong&gt;在做预测时，步骤如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（1）给 decoder 输入 encoder 对整个句子 embedding 的结果 和一个特殊的开始符号 &amp;lt;/s&amp;gt;。decoder 将产生预测，在我们的例子中应该是 ”I”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（2）给 decoder 输入 encoder 的 embedding 结果和 “&amp;lt;/s&amp;gt;I”，在这一步 decoder 应该产生预测 “am”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（3）给 decoder 输入 encoder 的 embedding 结果和 “&amp;lt;/s&amp;gt;I am”，在这一步 decoder 应该产生预测 “a”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（4）给 decoder 输入 encoder 的 embedding 结果和 “&amp;lt;/s&amp;gt;I am a”，在这一步 decoder 应该产生预测 “student”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（5）给 decoder 输入 encoder 的 embedding 结果和 “&amp;lt;/s&amp;gt;I am a student”, decoder应该生成句子结尾的标记，decoder 应该输出 ”&amp;lt;/eos&amp;gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（6）然后 decoder 生成了 &amp;lt;/eos&amp;gt;，翻译完成。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　这部分的代码实现：&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Generator(nn.Module):
    &quot;&quot;&quot;
    Define standard linear + softmax generation step。
    定义标准的linear + softmax 生成步骤。
    &quot;&quot;&quot;
    def __init__(self, d_model, vocab):
        super(Generator, self).__init__()
        self.proj = nn.Linear(d_model, vocab)

    def forward(self, x):
        return F.log_softmax(self.proj(x), dim=-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;在训练过程中，&lt;/strong&gt;模型没有收敛得很好时，Decoder预测产生的词很可能不是我们想要的。这个时候如果再把错误的数据再输给Decoder，就会越跑越偏。这个时候怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （1）在训练过程中可以使用 “teacher forcing”。因为我们知道应该预测的word是什么，那么可以给Decoder喂一个正确的结果作为输入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2）除了选择最高概率的词 (greedy search)，还可以选择是比如 “Beam Search”，可以保留topK个预测的word。 Beam Search 方法不再是只得到一个输出放到下一步去训练了，我们可以设定一个值，拿多个值放到下一步去训练，这条路径的概率等于每一步输出的概率的乘积。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;6 Transformer的优缺点&lt;/h2&gt;
&lt;h2&gt;6.1 优点&lt;/h2&gt;
&lt;div readability=&quot;34.08681462141&quot;&gt;
&lt;p&gt;　　&lt;span&gt;（1）每层计算&lt;strong&gt;复杂度比RNN要低&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）可以进行&lt;strong&gt;并行计算&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（3）从计算一个序列长度为n的信息要经过的路径长度来看, CNN需要增加卷积层数来扩大视野，RNN需要从1到n逐个进行计算，而Self-attention只需要一步矩阵计算就可以。Self-Attention可以比RNN&lt;strong&gt;更好地解决长时依赖问题&lt;/strong&gt;。当然如果计算量太大，比如序列长度N大于序列维度D这种情况，也可以用窗口限制Self-Attention的计算数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（4）从作者在附录中给出的栗子可以看出，Self-Attention&lt;strong&gt;模型更可解释，Attention结果的分布表明了该模型学习到了一些语法和语义信息&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.2 缺点&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;在原文中没有提到缺点，是后来在Universal Transformers中指出的，主要是两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）实践上：有些RNN轻易可以解决的问题transformer没做到，比如&lt;strong&gt;复制string&lt;/strong&gt;，或者推理时碰到的sequence长度比训练时更长（因为碰到了没见过的position embedding）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）理论上：transformers不是computationally universal(图灵完备)，这种非RNN式的模型是非图灵完备的的，&lt;strong&gt;无法单独完成NLP中推理、决策等计算问题&lt;/strong&gt;（包括使用transformer的bert模型等等）。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;7 References&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1 &lt;a href=&quot;http://jalammar.github.io/illustrated-transformer/&quot;&gt;http://jalammar.github.io/illustrated-transformer/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/48508221&quot;&gt;https://zhuanlan.zhihu.com/p/48508221&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/47063917&quot;&gt;https://zhuanlan.zhihu.com/p/47063917&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/80986272&quot;&gt;https://zhuanlan.zhihu.com/p/80986272&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5 &lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot;&gt;https://arxiv.org/abs/1706.03762&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 23 Oct 2019 18:27:00 +0000</pubDate>
<dc:creator>ZingpLiu</dc:creator>
<og:description>深度学习广泛应用于各个领域。基于transformer的预训练模型（gpt/bertd等）基本已统治NLP深度学习领域，可见transformer的重要性。本文结合《Attention is all</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zingp/p/11696111.html</dc:identifier>
</item>
<item>
<title>为什么阿里巴巴Java开发手册中不建议在循环体中使用+进行字符串拼接？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11729920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11729920.html</guid>
<description>&lt;p&gt;之前在阅读《阿里巴巴Java开发手册》时，发现有一条是关于循环体中字符串拼接的建议，具体内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191024001215255-1771752737.png&quot; alt=&quot;阿里巴巴Java开发手册&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们首先来用例子来看看在循环体中用 + 或者用 StringBuilder 进行字符串拼接的效率如何吧（JDK版本为 jdk1.8.0_201）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wupx.demo;

/**
 * @author wupx
 * @date 2019/10/23
 */
public class StringConcatDemo {
    public static void main(String[] args) {
        long s1 = System.currentTimeMillis();
        new StringConcatDemo().addMethod();
        System.out.println(&quot;使用 + 拼接:&quot; + (System.currentTimeMillis() - s1));

        s1 = System.currentTimeMillis();
        new StringConcatDemo().stringBuilderMethod();
        System.out.println(&quot;使用 StringBuilder 拼接:&quot; + (System.currentTimeMillis() - s1));
    }

    public String addMethod() {
        String result = &quot;&quot;;
        for (int i = 0; i &amp;lt; 100000; i++) {
            result += (i + &quot;武培轩&quot;);
        }
        return result;
    }

    public String stringBuilderMethod() {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i &amp;lt; 100000; i++) {
            result.append(i).append(&quot;武培轩&quot;);
        }
        return result.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;使用 + 拼接:29282
使用 StringBuilder 拼接:4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么这两种方法的时间会差这么多呢？接下来让我们一起进一步研究。&lt;/p&gt;

&lt;p&gt;从字节码层面来看下，为什么循环体中字符串拼接 StringBuilder 比 + 快这么多？&lt;/p&gt;
&lt;p&gt;使用 javac StringConcatDemo.java 命令编译源文件，使用 javap -c StringConcatDemo 命令查看字节码文件的内容。&lt;/p&gt;
&lt;p&gt;其中 addMethod() 方法的字节码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public java.lang.String addMethod();
    Code:
       0: ldc           #16                 // String
       2: astore_1
       3: iconst_0
       4: istore_2
       5: iload_2
       6: ldc           #17                 // int 100000
       8: if_icmpge     41
      11: new           #7                  // class java/lang/StringBuilder
      14: dup
      15: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V
      18: aload_1
      19: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: iload_2
      23: invokevirtual #18                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      26: ldc           #19                 // String wupx
      28: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      31: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      34: astore_1
      35: iinc          2, 1
      38: goto          5
      41: aload_1
      42: areturn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，第 8 行到第 38 行构成了一个循环体：在第 8 行的时候做条件判断，如果不满足循环条件，则跳转到 41 行。编译器做了一定程度的优化，在 11 行 new 了一个 StringBuilder 对象，然后再 19 行、23 行、28 行进行了三次 append() 方法的调用，不过每次循环都会重新 new 一个 StringBuilder 对象。&lt;/p&gt;
&lt;p&gt;再来看 stringBuilderMethod() 方法的字节码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public java.lang.String stringBuilderMethod();
    Code:
       0: new           #7                  // class java/lang/StringBuilder
       3: dup
       4: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V
       7: astore_1
       8: iconst_0
       9: istore_2
      10: iload_2
      11: ldc           #17                 // int 100000
      13: if_icmpge     33
      16: aload_1
      17: iload_2
      18: invokevirtual #18                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      21: ldc           #19                 // String wupx
      23: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      26: pop
      27: iinc          2, 1
      30: goto          10
      33: aload_1
      34: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      37: areturn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;13 行到 30 行构成了循环体，可以看出，在第4行（循环体外）就构建好了 StringBuilder 对象，然后再循环体内只进行 append() 方法的调用。&lt;/p&gt;
&lt;p&gt;由此可以看出，在 for 循环中，使用 + 进行字符串拼接，每次都是 new 了一个 StringBuilder，然后再把 String 转成 StringBuilder，再进行 append，而频繁的新建对象不仅要耗费很多时间，还会造成内存资源的浪费。这就从字节码层面解释了为什么不建议在循环体内使用 + 去进行字符串的拼接。&lt;/p&gt;
&lt;p&gt;接下来再来让我们看下使用 + 或者 StringBuilder 拼接字符串的原理吧。&lt;/p&gt;

&lt;p&gt;在 Java 开发中，最简单常用的字符串拼接方法就是直接使用 + 来完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String boy = &quot;wupx&quot;;
String girl = &quot;huyx&quot;;
String love = boy + girl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译后的内容如下：（使用的反编译工具为 jad）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String boy = &quot;wupx&quot;;
String girl = &quot;huyx&quot;;
String love = (new StringBuilder()).append(boy).append(girl).toString();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过查看反编译以后的代码，可以发现，在字符串常量在拼接过程中，是将 String 转成了 StringBuilder 后，使用其 append() 方法进行处理的。&lt;/p&gt;
&lt;p&gt;那么也就是说，Java中的 + 对字符串的拼接，其实现原理是使用 StringBuilder 的 append() 来实现的，使用 + 拼接字符串，其实只是 Java 提供的一个语法糖。&lt;/p&gt;

&lt;p&gt;StringBuilder 的 append 方法就是第二个常用的字符串拼接姿势了。&lt;/p&gt;
&lt;p&gt;和 String 类类似，StringBuilder 类也封装了一个字符数组，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char[] value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与 String 不同的是，它并不是 final 的，所以是可以修改的。另外，与 String 不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int count;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其 append() 方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public StringBuilder append(String str) {
   super.append(str);
   return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类继承了 AbstractStringBuilder 类，看下其 append() 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先判断拼接的字符串 str 是不是 null，如果是，调用 appendNull() 方法进行处理，appendNull() 方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private AbstractStringBuilder appendNull() {
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = 'n';
    value[c++] = 'u';
    value[c++] = 'l';
    value[c++] = 'l';
    count = c;
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果字符串 str 不为 null，则判断拼接后的字符数组长度是否超过当前数组长度，如果超过，则调用 Arrays.copyOf() 方法进行扩容并复制，ensureCapacityInternal() 方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void ensureCapacityInternal(int minimumCapacity) {
    if (minimumCapacity - value.length &amp;gt; 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，将拼接的字符串 str 复制到目标数组 value 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;str.getChars(0, len, value, count);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文针对《阿里巴巴Java开发手册》中的循环体中拼接字符串建议出发，从字节码层面，来解释为什么 StringBuilder 比 + 快，还分别介绍了字符串拼接中 + 和 StringBuilder 的原理，因此在循环体拼接字符串时，应该使用 StringBuilder 的 append() 去完成拼接。&lt;/p&gt;
</description>
<pubDate>Wed, 23 Oct 2019 16:12:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>之前在阅读《阿里巴巴Java开发手册》时，发现有一条是关于循环体中字符串拼接的建议，具体内容如下： 那么我们首先来用例子来看看在循环体中用 + 或者用 StringBuilder 进行字符串拼接的效率</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11729920.html</dc:identifier>
</item>
<item>
<title>B/S 端基于 HTML5 + WebGL 的 VR 3D 机房数据中心可视化 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/11729853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/11729853.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020234801-137915723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在监控摄像机数量的不断庞大的同时，在监控系统中面临着严峻的现状问题：海量视频分散、孤立、视角不完整、位置不明确等问题，始终围绕着使用者。因此，如何更直观、更明确的管理摄像机和掌控视频动态，已成为提升视频应用价值的重要话题。所以当前项目正是从解决此现状问题的角度，应运而生。围绕如何提高、管理和有效利用前端设备采集的海量信息为公共安全服务，特别是在技术融合大趋势下，如何结合当前先进的视频融合，虚实融合、三维动态等技术，实现三维场景实时动态可视化监控，更有效的识别、分析、挖掘海量数据的有效信息服务公共应用，已成为视频监控平台可视化发展的趋势和方向。目前，在监控行业中，海康、大华等做监控行业领导者可基于这样的方式规划公共场所园区等的摄像头规划安放布局，可以通过海康、大华等摄像头品牌的摄像头参数，调整系统中摄像头模型的可视范围，监控方向等，更方便的让人们直观的了解摄像头的监控区域，监控角度等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020257928-452162414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是项目地址：&lt;a href=&quot;http://www.hightopo.com/demo/Camera/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;基于 HTML5 的 WebGL 自定义 3D 摄像头监控模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整体场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074129353-858216626.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074159610-98573873.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;摄像头模型及场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中使用的摄像头模型是通过 3dMax 建模生成的，该建模工具可以导出 obj 与 mtl 文件，在 HT 中可以通过解析 obj 与 mtl 文件来生成 3d 场景中的摄像头模型。&lt;/p&gt;
&lt;p&gt;项目中场景通过 HT 的 3d 编辑器进行搭建，场景中的模型有些是通过 HT 建模，有些通过 3dMax 建模，之后导入 HT 中，场景中的地面白色的灯光，是通过 HT 的 3d 编辑器进行地面贴图呈现出来的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锥体建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3D 模型是由最基础的三角形面拼接合成，例如 1 个矩形可以由 2 个三角形构成，1 个立方体由 6 个面即 12 个三角形构成， 以此类推更复杂的模型可以由许多的小三角形组合合成。因此 3D 模型定义即为对构造模型的所有三角形的描述， 而每个三角形由三个顶点 vertex 构成， 每个顶点 vertex 由 x, y, z 三维空间坐标决定，HT 采用右手螺旋定则来确定三个顶点构造三角形面的正面。&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt; 函数，可注册自定义 3D 模型，摄像头前方生成的锥体便是通过该方法生成。可以将该锥体看成由 5 个顶点，6 个三角形组成，具体图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074221681-1867969782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;name&lt;/strong&gt; 为模型名称，如果名称与预定义的一样，则会替换预定义的模型 &lt;br/&gt;2. &lt;strong&gt;model&lt;/strong&gt; 为JSON类型对象，其中 &lt;em&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;/em&gt; 表示顶点坐标数组，&lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; 表示索引数组，&lt;em&gt;&lt;strong&gt;uv&lt;/strong&gt;&lt;/em&gt; 表示贴图坐标数组，如果想要单独定义某个面，可以通过 &lt;em&gt;&lt;strong&gt;bottom_vs，bottom_is，bottom_uv，top_vs，top_is， top_uv&lt;/strong&gt; &lt;/em&gt;等来定义，之后便可以通过&lt;em&gt;&lt;strong&gt; shape3d.top.*， shape3d.bottom.*&lt;/strong&gt;&lt;/em&gt;  等单独控制某个面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是我定义模型的代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
// camera 是当前的摄像头图元
// fovy 为摄像头的张角的一半的 tan 值
var setRangeModel = function(camera, fovy) {
    var fovyVal = 0.5 * fovy;
    var pointArr = [0, 0, 0, -fovyVal, fovyVal, 0.5, fovyVal, fovyVal, 0.5, fovyVal, -fovyVal, 0.5, -fovyVal, -fovyVal, 0.5];
    ht.Default.setShape3dModel(camera.getTag(), [{
        vs: pointArr,
        is: [2, 1, 0, 4, 1, 0, 4, 3, 0, 3, 2, 0],
        from_vs: pointArr.slice(3, 15),
        from_is: [3, 1, 0, 3, 2, 1],
        from_uv: [0, 0, 1, 0, 1, 1, 0, 1]
    }]);
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我将当前摄像头的 tag 标签值作为模型的名称，tag 标签在 HT 中用于唯一标识一个图元，用户可以自定义 tag 的值。通过 pointArr 记录当前五面体的五个顶点坐标信息，代码中通过 from_vs, from_is, from_uv 单独构建五面体底面，底面用于显示当前摄像头呈现的图像。&lt;/p&gt;
&lt;p&gt;代码中设置了锥体 style 对象的 &lt;strong&gt;wf.geometry&lt;/strong&gt; 属性，通过该属性可以为锥体添加模型的线框，增强模型的立体效果，并且通过&lt;strong&gt; wf.color，wf.width&lt;/strong&gt; 等参数调节线框的颜色，粗细等。&lt;/p&gt;
&lt;p&gt;相关模型 style 属性的设置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 rangeNode.s({
 2     'shape3d': cameraName,
 3     // 摄像头模型名称
 4     'shape3d.color': 'rgba(52, 148, 252, 0.3)',
 5     // 锥体模型颜色
 6     'shape3d.reverse.flip': true,
 7     // 锥体模型的反面是否显示正面的内容
 8     'shape3d.light': false,
 9     // 锥体模型是否受光线影响
10     'shape3d.transparent': true,
11     // 锥体模型是否透明
12     '3d.movable': false,
13     // 锥体模型是否可移动
14     'wf.geometry': true // 是否显示锥体模型线框
15 });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;摄像头图像生成原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透视投影&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。 透视使得远的对象变小，近的对象变大，平行线会出现先交等更更接近人眼观察的视觉效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074233279-699657637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，透视投影最终显示到屏幕上的内容只有截头锥体( View Frustum )部分的内容， 因此 Graph3dView 提供了 eye, center, up, far，near，fovy 和 aspect 参数来控制截头锥体的具体范围。具体的透视投影可以参考 &lt;strong&gt;HT for Web&lt;/strong&gt; 的 &lt;a href=&quot;https://hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;3D&lt;/a&gt; 手册。&lt;/p&gt;
&lt;p&gt;根据上图的描述，在本项目中可以在摄像头初始化之后，缓存当前 3d 场景 eyes 眼睛的位置，以及 center 中心的位置，之后将 3d 场景 eyes 眼睛和 center 中心设置成摄像头中心点的位置，然后在这个时刻获取当前 3d 场景的截图，该截图即为当前摄像头的监控图像，之后再将 3d 场景的 center 与 eyes 设置成开始时缓存的 eyes 与 center 位置，通过该方法即可实现 3d 场景中任意位置的快照，从而实现摄像头监控图像实时生成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 function getFrontImg(camera, rangeNode) {
 2     var oldEye = g3d.getEye();
 3     var oldCenter = g3d.getCenter();
 4     var oldFovy = g3d.getFovy();
 5     g3d.setEye(摄像头位置);
 6     g3d.setCenter(摄像头朝向);
 7     g3d.setFovy(摄像头张角);
 8     g3d.setAspect(摄像头宽高比);
 9     g3d.validateImp();
10     g3d.toDataURL();
11     g3d.setEye(oldEye);;
12     g3d.setCenter(oldCenter);
13     g3d.setFovy(oldFovy);
14     g3d.setAspect(undefined);
15     g3d.validateImp();
16 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经过测试之后，通过该方法进行图像的获取会导致页面有所卡顿，因为是获取当前 3d 场景的整体截图，由于当前3d场景是比较大的，所以 toDataURL 获取图像信息是非常慢的，因此我采取了离屏的方式来获取图像，具体方式如下：&lt;br/&gt;   1. 创建一个新的 3d 场景，将当前场景的宽度与高度都设置为 200px 的大小，并且当前 3d 场景的内容与主屏的场景是一样的，HT中通过 new ht.graph3d.Graph3dView(dataModel) 来新建场景，其中的 dataModel 为当前场景的所有图元，所以主屏与离屏的 3d 场景都共用同一个 dataModel，保证了场景的一致。&lt;br/&gt;   2. 将新创建的场景位置设置成屏幕看不到的地方，并且添加进 dom 中。&lt;br/&gt;   3. 将之前对主屏获取图像的操作变成对离屏获取图像的操作，此时离屏图像的大小相对之前主屏获取图像的大小小很多，并且离屏获取不需要保存原来的眼睛 eyes 的位置以及 center 中心的位置，因为我们没有改变主屏的 eyes 与 center 的位置， 所以也减少的切换带来的开销，大大提高了摄像头获取图像的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是该方法实现的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 function getFrontImg(camera, rangeNode) {
 2     // 截取当前图像时将该摄像头所属的五面体隐藏
 3     rangeNode.s('shape3d.from.visible', false);
 4     rangeNode.s('shape3d.visible', false);
 5     rangeNode.s('wf.geometry', false);
 6     var cameraP3 = camera.p3();
 7     var cameraR3 = camera.r3();
 8     var cameraS3 = camera.s3();
 9     var updateScreen = function() {
10         demoUtil.Canvas2dRender(camera, outScreenG3d.getCanvas());
11         rangeNode.s({
12             'shape3d.from.image': camera.a('canvas')
13         });
14         rangeNode.s('shape3d.from.visible', true);
15         rangeNode.s('shape3d.visible', true);
16         rangeNode.s('wf.geometry', true);
17     };
18 
19     // 当前锥体起始位置
20     var realP3 = [cameraP3[0], cameraP3[1] + cameraS3[1] / 2, cameraP3[2] + cameraS3[2] / 2];
21     // 将当前眼睛位置绕着摄像头起始位置旋转得到正确眼睛位置
22     var realEye = demoUtil.getCenter(cameraP3, realP3, cameraR3);
23 
24     outScreenG3d.setEye(realEye);
25     outScreenG3d.setCenter(demoUtil.getCenter(realEye, [realEye[0], realEye[1], realEye[2] + 5], cameraR3));
26     outScreenG3d.setFovy(camera.a('fovy'));
27     outScreenG3d.validate();
28     updateScreen();
29 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;上面代码中有一个 getCenter 方法是用于获取 3d 场景中点 A 绕着点 B 旋转 angle 角度之后得到的点 A 在 3d 场景中的位置，方法中采用了 HT 封装的 ht.Math 下面的方法，以下为代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 // pointA 为 pointB 围绕的旋转点
 2 // pointB 为需要旋转的点
 3 // r3 为旋转的角度数组 [xAngle, yAngle, zAngle] 为绕着 x, y, z 轴分别旋转的角度 
 4 var getCenter = function(pointA, pointB, r3) {
 5     var mtrx = new ht.Math.Matrix4();
 6     var euler = new ht.Math.Euler();
 7     var v1 = new ht.Math.Vector3();
 8     var v2 = new ht.Math.Vector3();
 9 
10     mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]));
11 
12     v1.fromArray(pointB).sub(v2.fromArray(pointA));
13     v2.copy(v1).applyMatrix4(mtrx);
14     v2.sub(v1);
15 
16     return [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z];
17 };
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里应用到向量的部分知识，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OA + OB = OC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074251110-1058475078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法分为以下几个步骤求解：&lt;/p&gt;
&lt;p&gt;   1.  &lt;strong&gt;var mtrx = new ht.Math.Matrix4()&lt;/strong&gt; 创建一个转换矩阵，通过 &lt;strong&gt;mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]))&lt;/strong&gt; 获取绕着 r3[0]，r3[1]，r3[2] 即 x 轴，y 轴，z 轴旋转的旋转矩阵。&lt;br/&gt;   2. 通过&lt;strong&gt; new ht.Math.Vector3()&lt;/strong&gt; 创建 v1，v2 两个向量。&lt;br/&gt;   3.&lt;strong&gt; v1.fromArray(pointB)&lt;/strong&gt; 为建立一个从原点到 pointB 的一个向量。&lt;br/&gt;   4. &lt;strong&gt;v2.fromArray(pointA)&lt;/strong&gt; 为建立一个从原点到 pointA 的一个向量。&lt;br/&gt;   5. &lt;strong&gt;v1.fromArray(pointB).sub(v2.fromArray(pointA))&lt;/strong&gt; 即向量 OB - OA 此时得到的向量为 AB，此时 v1 变为向量 AB。&lt;br/&gt;   6. &lt;strong&gt;v2.copy(v1)&lt;/strong&gt; v2 向量拷贝 v1 向量，之后通过 &lt;strong&gt;v2.copy(v1).applyMatrix4(mtrx)&lt;/strong&gt; 对 v2 向量应用旋转矩阵，变换之后即为 v1向量绕着 pointA 旋转之后的的向量 v2。&lt;br/&gt;   7. 此时通过 &lt;strong&gt;v2.sub(v1)&lt;/strong&gt; 就获取了起始点为 pointB，终点为 pointB 旋转之后点构成的向量，该向量此时即为 v2。&lt;br/&gt;   8. 通过向量公式得到旋转之后的点为 [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z]。&lt;/p&gt;
&lt;p&gt;项目中的 3D 场景例子其实是 &lt;a href=&quot;http://www.hightopo.com&quot; target=&quot;_blank&quot;&gt;Hightopo&lt;/a&gt; 最近贵州数博会，HT 上工业互联网展台的 VR 示例，大众对 VR/AR 的期待很高，但路还是得一步步走，即使融资了 23 亿美金的 Magic Leap 的第一款产品也只能是 &lt;a href=&quot;https://mp.weixin.qq.com/s/Z-gcPasf6E4OdNbqBwBhFA&quot; target=&quot;_blank&quot;&gt;Full of Shit&lt;/a&gt;，这话题以后再展开，这里就上段当时现场的视频照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074306832-325606716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2d 图像贴到 3d 模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上一步的介绍我们可以获取当前摄像机位置的截屏图像，那么如何将当前图像贴到前面所构建的五面体底部呢？前面通过 from_vs, from_is 来构建底部的长方形，所以在 HT 中可以通过将五面体的 style 中 shape3d.from.image 属性设置成当前图像，其中 from_uv 数组用来定义贴图的位置，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074323039-360588324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;以下为定义贴图位置 from_uv 的代码：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 from_uv: [0, 0, 1, 0, 1, 1, 0, 1] &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;from_uv 就是定义贴图的位置数组，根据上图的解释，可以将 2d 图像贴到 3d 模型的 from 面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;new ht.widget.Panel()&lt;/strong&gt; 来生成如下图的面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074334164-1462206036.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面板中每个摄像头都有一个模块来呈现当前监控图像，其实这个地方也是一个 canvas，该 canvas 与场景中锥体前面的监控图像是同一个 canvas，每一个摄像头都有一个自己的 canvas 用来保存当前摄像头的实时监控画面，这样就可以将该 canvas 贴到任何地方，将该 canvas 添加进面板的代码如下：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 formPane.addRow([{ 2 element: camera.a('canvas') 3 }], 240, 240); &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码中将 canvas 节点存储在摄像头图元的 attr 属性下面，之后便可以通过&lt;strong&gt; camera.a('canvas')&lt;/strong&gt; 来获取当前摄像头的画面。&lt;/p&gt;
&lt;p&gt;在面板中的每一个控制节点都是通过&lt;strong&gt; formPane.addRow&lt;/strong&gt; 来进行添加，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;表单手册&lt;/a&gt;。之后通过 ht.widget.Panel 将表单面板 formPane 添加进 panel 面板中，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/panel/ht-panel-guide.html&quot; target=&quot;_blank&quot;&gt;面板手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分控制代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 formPane.addRow(['rotateY', {
 2     slider: {
 3         min: -Math.PI,
 4         max: Math.PI,
 5         value: r3[1],
 6         onValueChanged: function() {
 7             var cameraR3 = camera.r3();
 8             camera.r3([cameraR3[0], this.getValue(), cameraR3[2]]);
 9             rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]]);
10             getFrontImg(camera, rangeNode);
11         }
12     }
13 }], [0.1, 0.15]);
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;控制面板通过 &lt;strong&gt;addRow&lt;/strong&gt; 来添加控制元素，以上代码为添加摄像头绕着 y 轴进行旋转的控制，&lt;strong&gt;onValueChanged&lt;/strong&gt; 在 slider 的数值改变的时候调用，此时通过&lt;strong&gt; camera.r3()&lt;/strong&gt; 获取当前摄像头的旋转参数， 由于是绕着 y 轴旋转所以 x 轴与 z 轴的角度是不变的，变的是 y 轴的旋转角度，所以通过&lt;strong&gt; camera.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来调整摄像头的旋转角度以及通过 &lt;strong&gt;rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来设置摄像头前方锥体的旋转角度，然后调用之前封装好的 &lt;strong&gt;getFrontImg&lt;/strong&gt; 函数来获取此时旋转角度下面的实时图像信息。&lt;/p&gt;
&lt;p&gt;项目中通过 Panel 面板的配置参数 &lt;strong&gt;titleBackground: rgba(230, 230, 230, 0.4) &lt;/strong&gt;即可将标题背景设置为具有透明度的背景，其它类似的 titleColor, titleHeight 等标题参数都可以配置，通过 separatorColor,separatorWidth 等分割参数可以设置内部面板之间分割线的颜色，宽度等。最后面板通过&lt;strong&gt; panel.setPositionRelativeTo('rightTop')&lt;/strong&gt; 将面板的位置设置成右上角，并且通过 &lt;strong&gt;document.body.appendChild(panel.getView())&lt;/strong&gt; 将面板最外层的 div 添加进页面中， &lt;strong&gt;panel.getView()&lt;/strong&gt; 用来获取面板的最外层 dom 节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体初始化面板代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 function initPanel() {
 2     var panel = new ht.widget.Panel();
 3     var config = {
 4         title: &quot;摄像头控制面板&quot;,
 5         titleBackground: 'rgba(230, 230, 230, 0.4)',
 6         titleColor: 'rgb(0, 0, 0)',
 7         titleHeight: 30,
 8         separatorColor: 'rgb(67, 175, 241)',
 9         separatorWidth: 1,
10         exclusive: true,
11         items: []
12     };
13     cameraArr.forEach(function(data, num) {
14         var camera = data['camera'];
15         var rangeNode = data['rangeNode'];
16         var formPane = new ht.widget.FormPane();
17         initFormPane(formPane, camera, rangeNode);
18         config.items.push({
19             title: &quot;摄像头&quot; + (num + 1),
20             titleBackground: 'rgba(230, 230, 230, 0.4)',
21             titleColor: 'rgb(0, 0, 0)',
22             titleHeight: 30,
23             separatorColor: 'rgb(67, 175, 241)',
24             separatorWidth: 1,
25             content: formPane,
26             flowLayout: true,
27             contentHeight: 400,
28             width: 250,
29             expanded: num === 0
30         });
31     });
32     panel.setConfig(config);
33     panel.setPositionRelativeTo('rightTop');
34     document.body.appendChild(panel.getView());
35     window.addEventListener(&quot;resize&quot;,
36     function() {
37         panel.invalidate();
38     });
39 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在控制面板中可以调整摄像头的方向，摄像头监控的辐射范围，摄像头前方锥体的长度等等，并且摄像头的图像是实时生成，以下为运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074359161-1813880965.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是本项目采用的 3D 场景结合 HT for Web 的 VR 技术实现的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074423850-451548743.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Oct 2019 15:46:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。 在监控摄像机数量的不断庞大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/11729853.html</dc:identifier>
</item>
<item>
<title>ES6入门之变量的解构赋值(二) - 一只流浪的KK</title>
<link>http://www.cnblogs.com/jjgw/p/11717379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jjgw/p/11717379.html</guid>
<description>&lt;p&gt;在上一章 &lt;a href=&quot;https://www.cnblogs.com/jjgw/p/11675028.html&quot; target=&quot;_blank&quot;&gt;ES6入门之let和const命令&lt;/a&gt;中我们对ES6的相关语法已经有了初步了解，上一章中我们主要学习了三大部分的内容，let命令的使用，块级作用域，const命令的使用，那么从本篇博客将进一步深入了解ES6中的相关语法，毕竟未来ES6是主流。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;　学会数组的解构赋值&lt;/li&gt;
&lt;li&gt;　学会对象的解构赋值&lt;/li&gt;
&lt;li&gt;　学会字符串的解构赋值&lt;/li&gt;
&lt;li&gt;　学会数值和布尔值的解构赋值&lt;/li&gt;
&lt;li&gt;　学会函数参数的解构赋值&lt;/li&gt;
&lt;li&gt;    学会解构赋值的用途&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本人对解构赋值的理解：模式匹配，匹配成功获取值，匹配不成功则为undefined，好比开心消消乐一样(我没有玩过，但是听过一点点)，开心消消乐中只要有相同的就会消失，然后加分，而模式匹配呢？匹配成功加分，匹配不成功则失败。&lt;/p&gt;

&lt;p&gt; 数组的解构赋值十分简单，只要等号左右两边模式匹配成功，则获取值，否则为undefined，在讲解数组解构赋值之前，我们先来看下我们以前定义变量的格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            let a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            let b&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            let c&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
&lt;span&gt;            let a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                b&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                c&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6的模式&lt;/span&gt;
&lt;span&gt;            let [a,b,c]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右两边相等，a=4,b=5,c=6&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们已经使用了数组的解构赋值，即let [a,b,c]=[4,5,6]左右两边进行模式匹配，可得a=4,b=5,c=6&lt;/p&gt;
&lt;p&gt;(1)不完全解构&lt;/p&gt;
&lt;p&gt;解构除了完全解构之外，还具备不完全解构的特性,即左边的模式只匹配一部分等号右边的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            let [x,y]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
            console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;            let [a,[b],d]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;],&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
            console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;            console.log(d);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)特殊值&lt;/p&gt;
&lt;p&gt;如果等号右边不是数组，那么将会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let [foo] = 1&lt;span&gt;;
let [foo] &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
let [foo] &lt;/span&gt;=&lt;span&gt; NaN;
let [foo] &lt;/span&gt;=&lt;span&gt; undefined;
let [foo] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)默认值&lt;/p&gt;
&lt;p&gt;数组的解构允许有默认值，如果一个数组的成员为null,默认值就不会生效，因为null不严格等于undefined&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            let [foo&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[];
            console.log(foo);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;            let [x,y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
            let [z,w&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,undefined];
            console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;
&lt;span&gt;            console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;
&lt;span&gt;            console.log(z);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;
&lt;span&gt;            console.log(w);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;
&lt;span&gt;            let [a&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[undefined];
            let [b&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;];
            console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于对象的解构赋值我总结了如下三点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组的元素是按次序排列的，变量的取值有它的位置决定，而对象的属性是没有次序的，变量必须和属性同名，才能取到正确的值&lt;/li&gt;
&lt;li&gt;如果解构失败，变量的值等于undefined&lt;/li&gt;
&lt;li&gt;对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而不是前者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;对象的解构赋值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按顺序排列&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            let {foo,bar}={foo:'foo',bar:'bar'};&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(foo);//foo&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(bar);;//bar&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不按顺序排列&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            let {bar,foo}={foo:'foo',bar:'bar'};&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(bar);//bar&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(foo);;//foo&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解构不成功，值为undefined&lt;/span&gt;
&lt;span&gt;            let {baz}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{foo:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,bar:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
            console.log(baz);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个案例中，我们有按顺序的解构，没有顺序的解构，以及解构不成功的情况&lt;/p&gt;
&lt;p&gt;示例二&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;对象的解构赋值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            let {foo:baz}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{foo:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,bar:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
            console.log(baz);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;
&lt;span&gt;            let obj&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{first:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,last:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
            let {first:a,last:b}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;obj;
            console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;
&lt;span&gt;            console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从而可以看出：对象解构赋值的原理是先找到同名属性，然后再赋给对应变量，真正被赋值的是后者而不是前者&lt;/p&gt;

&lt;p&gt;字符串的结构赋值十分简单，和之前的解构赋值一样也是模式匹配，注意：字符串中有length属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;字符串解构赋值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            const [a,b,c,d,e]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            console.log(a);;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;
&lt;span&gt;            console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;
&lt;span&gt;            console.log(c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;
&lt;span&gt;            console.log(d);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;
&lt;span&gt;            console.log(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;
&lt;span&gt;            let {length:len}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            console.log(len);//5
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解构赋值原理：只要等号右边的值不是数组或对象，就先将其转为对象，但是也有特殊情况，如：&lt;span&gt;undefined和null无法转为对象&lt;/span&gt;，所以对它们进行解构赋值都会报错。这一点非常重要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;数值和布尔值的解构赋值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            let {toString:s}=123;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(s===Number.prototype.toString);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            let {toString:b}=true;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(b===Boolean.prototype.toString);&lt;/span&gt;
&lt;span&gt;            let {prototype:x}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;undefined;
            let {prop:y}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;span&gt;            console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;函数参数解构赋值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add([x,y]){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;y;
            }
            console.log(add([&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;            [[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;],[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]].map(([a,b])&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;{
                console.log(a&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,7&lt;/span&gt;
&lt;span&gt;            })
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认值&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; move({x&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [x,y]
            }
            move({x:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,y:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3,8]&lt;/span&gt;
&lt;span&gt;            move({x:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;})&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3,0]&lt;/span&gt;
&lt;span&gt;            move({})&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0,0]&lt;/span&gt;
&lt;span&gt;            move();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0,0]&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar({x,y}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{x:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;}){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [x,y]
            }
            move({x:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,y:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3,8]&lt;/span&gt;
&lt;span&gt;            move({x:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3,undefined]&lt;/span&gt;
&lt;span&gt;            move({});&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[undefined,undefined]&lt;/span&gt;
&lt;span&gt;            move();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0,0]&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在move方法中函数&lt;code&gt;move&lt;/code&gt;的参数是一个对象，通过对这个对象进行解构，得到变量&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的值。如果解构失败，&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;等于默认值，而函数bar的参数指定默认值，而不是为变量&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;指定默认值，所以会得到与前一种写法不同的结果&lt;/p&gt;

&lt;h4&gt;(1)交换变量的值&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)交换变量的值&lt;/span&gt;
&lt;span&gt;            let x&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            let y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            [x,y]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[y,x];
            console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;            console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，我们可以看到x和y的值进行了交换，x的值从1变成的2，而y的值从2变成了1&lt;/p&gt;
&lt;h4&gt;(2)从函数返回多个值&lt;/h4&gt;
&lt;p&gt; 我们知道javascript中中使用return只能返回一个值，如果需要返回多个值的话就需要将数据放在数组或对象中，然后return回去，但是有了解构赋值，你想要取出这些值就非常方便，我们看下下面的示例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)从函数返回多个值&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个数组&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]
            }
            let[a,b,c]&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;bar();
            console.log(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            console.log(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;            console.log(c);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个对象&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
                    x:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                    y:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                }
            }
            let {x,y}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;baz();
            console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们返回一个数组之后使用a,b,c进行解构赋值，匹配a=1,b=2,c=3,而返回对象之后我们使用对象来接收，注意：返回对象的键名一定要和需要解构的键名一致，否则取到的值为undefined&lt;/p&gt;
&lt;h4&gt;(3)函数参数定义&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(3)函数参数定义&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组有次序的值&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo([x,y,z]){
                console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;                console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;                console.log(z);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;            }
            foo([&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组无序的值&lt;/span&gt;
            &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar({x,y,z}){
                console.log(x);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;                console.log(y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;span&gt;                console.log(z);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;            }
            bar({z:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,x:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;,y:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;})
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;(4)提取JSON数据&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(4)提取JSON数据&lt;/span&gt;
&lt;span&gt;            let stu&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{
                name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;一只流浪的kk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                age:&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
                sex:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
            let {name:name,age:age,sex:sex}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;stu;
            console.log(name,age,sex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一只流浪的kk,18,male&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用解构赋值可以很方便的提取JSON中的数据&lt;/p&gt;
&lt;h4&gt;(5)函数参数默认值&lt;/h4&gt;
&lt;p&gt; 这种方法我们见过很多，再封装ajax的时候经常用到或者是扩张jquery插件的时候，我们都会添加默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(5)函数参数默认值&lt;/span&gt;
&lt;span&gt;            ;
            (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(method) {
                method(window, window.document, jQuery);
            }(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(win, doc, $) {
                ＄.fn.SuperPlus &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(options) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认参数&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; setting=&lt;span&gt;{
                        length:&lt;/span&gt;3&lt;span&gt;,
                        color:&lt;/span&gt;&quot;blue&quot;&lt;span&gt;
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用用户的参数覆盖默认参数&lt;/span&gt;
&lt;span&gt;                    $.extend(setting,options);
                    
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $.each(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index, obj) {
                        $(&lt;/span&gt;&quot;&amp;lt;span/&amp;gt;&quot;).html(&quot;+&quot;).css(&quot;cursor&quot;, &quot;pointer&quot;).css(&quot;color&quot;,setting.color).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                            $(obj).width($(obj).width() &lt;/span&gt;+&lt;span&gt; setting.length);
                        }).insertAfter(obj);
                    });
                    
                }
            }));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们就是指定了默认值，我们对外开发我们可以让用户进行修改的一些参数，当用户没有传递的时候，我们就使用默认值&lt;/p&gt;
&lt;h4&gt;(6)遍历Map结构&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(6)遍历Map结构&lt;/span&gt;
&lt;span&gt;            const map&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
            map.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            map.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,value] of map){
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;键是：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;key,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;值是:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;value);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键：first,last,值：hello,world&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,value] of map.entries()){
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;键是：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;key,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;值是:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;value);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键：first,last,值：hello,world&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果只想遍历key&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,] of map){
                console.log(key);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;first,last&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果只想遍历value&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [,value] of map){
                console.log(value);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello,world&lt;/span&gt;
&lt;span&gt;            }
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里涉及到map的相关知识，关于ES6新增的数据结构，查看博客&lt;a href=&quot;https://www.cnblogs.com/jjgw/p/11561169.html&quot; target=&quot;_blank&quot;&gt; https://www.cnblogs.com/jjgw/p/11561169.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;(7)输入模块的指定方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;解构赋值的用途&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(7)输入模块的指定方法&lt;/span&gt;
&lt;span&gt;            const{add,sub}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;require(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法我们之后会用到，关于ES6中模块的加载，例如：AMD,CMD,UMD等等，现阶段只需要了解一下&lt;/p&gt;

</description>
<pubDate>Wed, 23 Oct 2019 15:19:00 +0000</pubDate>
<dc:creator>一只流浪的KK</dc:creator>
<og:description>前言 在上一章&amp;#160;ES6入门之let和const命令中我们对ES6的相关语法已经有了初步了解，上一章中我们主要学习了三大部分的内容，let命令的使用，块级作用域，const命令的使用，那么从本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jjgw/p/11717379.html</dc:identifier>
</item>
</channel>
</rss>