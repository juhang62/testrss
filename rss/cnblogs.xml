<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>linux学习问题总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10661946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10661946.html</guid>
<description>&lt;p&gt;本文主要是自己学习linux中的一些思考和总结的记录&lt;/p&gt;
&lt;h2 id=&quot;一环境变量和普通变量的区别&quot;&gt;一、环境变量和普通变量的区别&lt;/h2&gt;
&lt;p&gt;区别就是普通变量只会影响当前进程，子进程可以继承父进程的环境变量&lt;/p&gt;
&lt;h2 id=&quot;二rsyslog和logrotate会不会丢记录的问题&quot;&gt;二、rsyslog和logrotate会不会丢记录的问题&lt;/h2&gt;
&lt;p&gt;先说结论：不会&lt;/p&gt;
&lt;p&gt;logrotate有create和copytruncate方案，这里是考虑create这种默认方案。说说logrotate的操作步骤：假设日志文件为daemon.log，当前已经到了轮换的时间，logrotate会先重命名daemon.log为daemon.log.1，然后新建一个daemon.log，给对应的进程发送HUP信号通知他日志已经更新&lt;/p&gt;
&lt;p&gt;当时一直在思考这个问题，一个进程在写入一个日志，然后logrotate将该日志文件重命名，创建个新的同名文件的过程中，日志数据会不会丢失，这个问题其实还是对linux文件系统的理解不够深刻。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;linux的文件分为inode和datanode，而文件系统是以inode来唯一标志这个文件的，进程在打开文件的时候对应这个inode的一个文件标志符。&lt;/li&gt;
&lt;li&gt;你要明白linux的文件名存在哪里，linux文件名其实是存在目录中，目录也是文件，该文件存放了文件名和inode的对应关系，这里也就理解了linux的硬链接，同一个文件可以有多个名字&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;理解了上面的也就理解了为什么不会，logrotate在重命名的时候只是修改了目录项，并没有影响实际的文件，所以&lt;span&gt;该进程还是在往重命名后的文件写入&lt;/span&gt;，logrotate给进程发信号通知进程，进程在响应信号的函数中去根据文件名查找新的inode，替换文件描述符，往新文件写入&lt;/p&gt;
&lt;p&gt;这里要特别注意你的程序要能响应这个HUP信号，不处理这个信号默认行为就是停止进程。&lt;/p&gt;
&lt;h2 id=&quot;三为什么有些文件夹大小不是4096的整数倍&quot;&gt;三、为什么有些文件夹大小不是4096的整数倍&lt;/h2&gt;
&lt;p&gt;我们知道文件系统中文件存放需要inode(索引区块)和dnode(数据区块)，一个文件只有需要一个inode，dnode则是是一个或多个。目录也是文件，但是在查看目录的时候发现有时候目录竟然不占用区块，很多目录的大小都是4096的整数倍这个很好理解，因为文件系统每个dnode大小都是固定的，一般都是4k，所以占用一个或者多个就是4096的整数倍。那为什么有些目录大小不占用区块呢？&lt;/p&gt;
&lt;p&gt;这其实是xfs的一个优化，如果目录项比较少，那么他就将数据存放到了目录的inode当中，所以不占用区块。&lt;/p&gt;
&lt;p&gt;我在自己的电脑上里用&lt;code&gt;ll -s&lt;/code&gt;命令查看跟目录，可以看到dev、bin和home不占用数据区块（看第一列）。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;   0 lrwxrwxrwx.   1 root root    7 3月  23 08:30 bin -&amp;gt; usr/bin
   4 dr-xr-xr-x.   5 root root 4096 4月   3 22:01 boot
   0 drwxr-xr-x.  19 root root 3300 4月   3 23:17 dev
  12 drwxr-xr-x. 144 root root 8192 4月   6 11:18 etc
   0 drwxr-xr-x.   5 root root   45 4月   3 23:06 home&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然谈到了文件大小的问题就补充下ls命令和du命令&lt;/p&gt;
&lt;p&gt;du查看文件和目录的大小&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;du -sh *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ls命令显示文件大小问题&lt;/p&gt;
&lt;pre class=&quot;jshelllanguage&quot;&gt;
&lt;code&gt;ls -s -S
-s 输出大小
-S 按大小排序
-r 逆序排序&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四reboot和shutdown等软链接实现原理&quot;&gt;四、reboot和shutdown等软链接实现原理&lt;/h2&gt;
&lt;p&gt;我们先来查看下reboot和shutdown的文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[chen@chen ~]$ ll `which reboot` `which shutdown`
lrwxrwxrwx. 1 root root 16 3月  30 22:12 /usr/sbin/reboot -&amp;gt; ../bin/systemctl
lrwxrwxrwx. 1 root root 16 3月  30 22:12 /usr/sbin/shutdown -&amp;gt; ../bin/systemctl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这两文件都是链接到systemctl符号链接，这里我觉得很奇怪，都是链接到systemctl为什么行为能不一样？难道这两个符号链接有什么不一样吗？&lt;/p&gt;
&lt;p&gt;但是怎么去查看符号链接的内容，通过&lt;code&gt;cat /usr/sbin/reboot&lt;/code&gt;这种命令去查看时是直接到了源文件，这时候可以使用&lt;code&gt;readlink&lt;/code&gt;这个命令去读取符号链接的内容，内容如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[chen@chen ~]$ readlink `which reboot` `which shutdown`
../bin/systemctl
../bin/systemctl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到内容是一样的，那么到底是怎么实现的。其实这里是通过获取启动时的名称来做判断的。看下下面的程序你就明白了：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;

int main(int argc,char * argv[]){
        for(int i=0;i&amp;lt;argc;i++)
                printf(&quot;%s\n&quot;,argv[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的程序打印了程序的输入参数，利用&lt;code&gt;gcc -std=c99 name.c&lt;/code&gt;编译后产生a.out文件，建立一个a.out的符号链接&lt;code&gt;ln -s a.out b&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;[chen@chen ~]$ `pwd`/a.out
/home/chen/a.out
[chen@chen ~]$ ./a.out
./a.out
[chen@chen ~]$ ./b
./b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到输出的程序名称的不同，你在建立符号链接的时候用到了不同的名字，systemctl可以根据名字来走不同的逻辑。所以如果你在自己的目录建立一个reboot链接:&lt;code&gt;ln -s /bin/systemctl reboot&lt;/code&gt;实现的效果是一样的。&lt;/p&gt;
&lt;h2 id=&quot;五systemd启动时执行脚本的问题&quot;&gt;五、systemd启动时执行脚本的问题&lt;/h2&gt;
&lt;p&gt;早先SystemV的init中我们有启动时需要执行的脚本时都会加入rc.local中，在systemd已经不推荐使用这个方法，我想很大的一个原因就是因为并行执行的问题。如果这个脚本有大量耗时的任务，那么这个脚本只能按顺序一个一个的执行才能启动。所以systemd其中很大的一个改进就是并行执行，它建议我们自己编写一个service的配置文件，利用systemd来管理。&lt;/p&gt;
&lt;p&gt;我的理解是如果是快速简单的命令还是可以放在原来的init目录，毕竟比较方便&lt;/p&gt;
&lt;h2 id=&quot;六crontab计划任务随机执行&quot;&gt;六、crontab计划任务随机执行&lt;/h2&gt;
&lt;p&gt;有计划任务想到的一个问题，如果我有很多任务在某个时刻需要执行，为了避免同一个时间执行导致负载过高所以需要一些随机化的处理而不是同一时刻触发&lt;/p&gt;
&lt;p&gt;思想就是加入随机函数,例如要在1小时内随机化：利用RANDOM环境变量&lt;code&gt;$[(RANDOM%60]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;别忘了在cron配置文件中%需要转义：&lt;code&gt;$[(RANDOM\%60]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最终结果如下 : &lt;code&gt;0 1 * * * sleep $[(RANDOM\%60]m ; /home/data/shell/script.sh&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;七日志输出和标准输出&quot;&gt;七、日志输出和标准输出&lt;/h2&gt;
&lt;p&gt;这里谈谈自己java开发的业务中的日志，我们java的日志现在一般采用的是log4fj和logback这种，在日志的配置中我们一般会有多个appender，例如输出到文件的和输出到标准输出的。我们在ide中运行的程序的时候，标准输出的所有输出都会输出在console中，如果去线上部署，例如&lt;code&gt;nohup daemon &amp;amp; &amp;amp;&amp;gt;/dev/null&lt;/code&gt;这种方式，标准输出被重定向到/dev/null中，因为日志也配置了文件的appender所以没什么问题，但是如果你对代码中有&lt;code&gt;System.out.println&lt;/code&gt;这种输出，那么这些信息就都丢了。所以尽量使用log来统一输出日志，还可以配置下将程序的标准输出也写入到日志中。&lt;/p&gt;
&lt;p&gt;参考链接&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/585844/why-directories-size-are-different-in-ls-l-output-on-xfs-file-system&quot;&gt;why-directories-size-are-different-in-ls-l-output-on-xfs-file-system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9049460/cron-jobs-and-random-times-within-given-hours&quot;&gt;Cron jobs and random times, within given hours&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 06 Apr 2019 07:42:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 本文主要是自己学习linux中的一些思考和总结的记录 一、环境变量和普通变量的区别 区别就是普通变量只会影响当前进程，子进程可以继承父进程的环境变量 二、rsyslog和logrotate</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10661946.html</dc:identifier>
</item>
<item>
<title>Android开发过程中的坑及解决方法收录（六） - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/10661916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/10661916.html</guid>
<description>&lt;h3 id=&quot;file.listfiles-空指针异常&quot;&gt;1. file.listFiles 空指针异常&lt;/h3&gt;
&lt;p&gt;最近在弄个小项目，类似一个文件管理器，需要获得手机存储里的目录之后显示，但是运行过程中出现错误，搜索了资料，得出了以下的解决办法&lt;br/&gt;&lt;strong&gt;问题产生的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;android6.0以上需要动态申请权限，确保自己有读取和写入SD卡的权限&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;以往版本的话，写入SD卡的权限其实是包含了读取SD卡的权限，但是android6.0有所改变，所以得声明读取和写入SD卡的权限，两个权限&lt;/li&gt;
&lt;li&gt;存在有隐藏文件，在获取列表的时候出现空指针问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;br/&gt;针对第三个问题，我们只需要添加一个判断当前的数组是否为空即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; java.io.File[] childFiles = file.listFiles(new FileFilter() {
            @Override
            public boolean accept(java.io.File pathname) {
                return pathname.isDirectory() || pathname.getName().endsWith(&quot;.apk&quot;);//筛选文件夹和apk文件，统计为项目数
            }
        });

        if (childFiles != null) {
            if (childFiles.length == 0) {
                count = &quot;0项&quot;;
            } else {
                for (int i = 0; i &amp;lt; childFiles.length; i++) {
                    childFilesList.add(new File(childFiles[i].getPath()));
                }
                count = childFiles.length+&quot;项&quot;;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fragment覆盖问题&quot;&gt;2. fragment覆盖问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题产生原因：&lt;/strong&gt;&lt;br/&gt;Fragment默认的背景是透明的&lt;br/&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;br/&gt;把Fragment的背景统一设置为某个颜色即可解决&lt;/p&gt;
&lt;h3 id=&quot;recyclerview的复用导致图标错乱&quot;&gt;3. RecyclerView的复用导致图标错乱&lt;/h3&gt;
&lt;p&gt;还是之前的那个文件管理器项目遇到的问题，如果是文件夹，则显示文件夹的图标，如果是apk安装包，则显示apk图标。&lt;br/&gt;一个文件夹里面有N个文件夹，有几个是apk文件，滑到底，可以看到apk文件显示apk图标，但是，向上滑动，有几个文件夹的图标变成了apk的图标&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201904/1210268-20190406153128452-1148371040.gif&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; if (bean.isFile()) {
           //如果为文件，则设置图标为apk图标
            ImageView imageView = holder.getView(R.id.img_folder);
            imageView.setImageDrawable(getApkIcon(holder, bean.getPath()));
            imageView.setScaleType(ImageView.ScaleType.FIT_XY);

            holder.setViewGone(R.id.img_right);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;br/&gt;好像是因为RecyclerView有四层缓存，巴拉巴拉..&lt;br/&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;br/&gt;由于我们是在onBindViewHolder里面进行绘制每一个item的界面，但是，我们只有一个if语句，&lt;br/&gt;使用if判断条件，之后需要修改某个控件，&lt;strong&gt;我们需要补充else语句，不满足条件的则设置控件为原来的样子，也就是显示文件夹图标&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
 if (bean.isFile()) {
           //如果为文件，则设置图标为apk图标
            ImageView imageView = holder.getView(R.id.img_folder);
            imageView.setImageDrawable(getApkIcon(holder, bean.getPath()));
            imageView.setScaleType(ImageView.ScaleType.FIT_XY);

            holder.setViewGone(R.id.img_right);
        } else {
            //如果不是的话，设置图标为文件夹图标
            ImageView imageView = holder.getView(R.id.img_folder);
            imageView.setImageResource(R.drawable.vector_drawable_folder);
            imageView.setScaleType(ImageView.ScaleType.FIT_XY);

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;recyclerview中的checkbox的选择状态错乱问题&quot;&gt;4. RecyclerView中的checkbox的选择状态错乱问题&lt;/h3&gt;
&lt;p&gt;每个item中包含着一个checkbox，之后点击了某个item的checkbox，使其变成了选择状态，和上面的例子类似，当我们往下滑动的时候，会出现几个item的checkbox也变成了选择状态的情况&lt;br/&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;br/&gt;在onBindViewHolder方法里面给checkbox设置一个click监听器，之后补上相关的逻辑代码，如点击之后要取消选择状态..&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>1. file.listFiles 空指针异常 最近在弄个小项目，类似一个文件管理器，需要获得手机存储里的目录之后显示，但是运行过程中出现错误，搜索了资料，得出了以下的解决办法 问题产生的原因： 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/10661916.html</dc:identifier>
</item>
<item>
<title>两个案例轻松理解MyBatis中的TypeHandler！ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/10661934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/10661934.html</guid>
<description>&lt;p&gt;在做开发时，我们经常会遇到这样一些问题，比如我有一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，怎么实现？再比如我有一个User类，User类中有一个属性叫做interest，这个属性用来描述用户的爱好，它的数据类型是一个List集合，那么我想在把这个List集合存入数据库的时候能够自动的变成&lt;code&gt;{XXX,XXX,XXX}&lt;/code&gt;这样一个字符串然后存起来，当我从数据库读取的时候也是读取到这样一个字符串，读取成功之后再自动的将之转为一个List集合，OK，以上两种需求用我们传统的数据库读写操作肯定都是可以实现的，只不过工作量略大，在mybatis中有一个功能略强大的typeHandler专门用来解决数据库中的数据类型和Java中的数据类型之间的转化问题，那么我们今天以上面两种需求为例，来看看typeHandler要怎么使用。如果还有小伙伴对mybatis不太熟悉，建议先阅读一下前面几篇博客（&lt;a href=&quot;http://blog.csdn.net/u012702547/article/details/54408761&quot;&gt;初识mybatis&lt;/a&gt;/&lt;a href=&quot;http://blog.csdn.net/u012702547/article/details/54425130&quot;&gt;初识mybatis(二)&lt;/a&gt;/&lt;a href=&quot;http://blog.csdn.net/u012702547/article/details/54428432&quot;&gt;mybatis常用配置&lt;/a&gt;/&lt;a href=&quot;http://blog.csdn.net/u012702547/article/details/54562619&quot;&gt;mybatis映射器配置细则&lt;/a&gt;），本文的内容将在前面几篇博客的基础上展开，当然如果小伙伴有mybatis基础，那直接往下看即可。&lt;br/&gt;事实上，mybatis本身已经为我们提供了许多typeHandler了，系统提供的typeHandler能够满足我们日常开发中的大部分需求，如上这两种特殊的需求就需要我们自己去定义typeHandler了。&lt;/p&gt;

&lt;p&gt;先来看日期的转换，假设我现在创建一张表，如下：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116135952484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;这张表中有一个字段叫做regTime，这个字段表示用户的注册时间，它的数据类型为varchar，OK，然后我再在Java中定义一个实体类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class User {
    private Long id;
    private String username;
    private String password;
    private Date regTime;
    //省略getter/setter
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个JavaBean中也有一个regTime字段，不同的是这里的数据类型是Date，OK，如果我不做任何特殊处理，直接像&lt;a href=&quot;http://blog.csdn.net/u012702547/article/details/54425130&quot;&gt;初识mybatis(二)&lt;/a&gt;这篇博客中介绍的那样向数据库插入数据，也是可以插入成功的，但是插入成功后是这样：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116140552851?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;这个当然不是我想要的，我希望存到数据库里的是这样的：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116140722447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;就是我直接向数据库写数据，要写的是一个Date对象，但是写到数据库之后这个Date对象就变成了Date对象所描述的时间到1970年的秒数了，然后当我从数据库读取这个秒数之后，系统又会自动帮我将这个秒数转为Date对象，就是这样两个需求。这个时候，我们要做的事情其实很简单，那就是自定义typeHandler，自定义typeHandler我们有两种方式，一种是实现TypeHandler接口，还有一种简化的写法就是继承自BaseTypeHandler类，我这里先以第二种为例来进行说明。&lt;/p&gt;
&lt;h2 id=&quot;自定义typehandler继承自basetypehandler&quot;&gt;自定义typeHandler继承自BaseTypeHandler&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@MappedJdbcTypes({JdbcType.VARCHAR})
@MappedTypes({Date.class})
public class MyDateTypeHandler extends BaseTypeHandler&amp;lt;Date&amp;gt; {
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException {
        preparedStatement.setString(i, String.valueOf(date.getTime()));
    }

    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException {
        return new Date(resultSet.getLong(s));
    }

    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException {
        return new Date(resultSet.getLong(i));
    }

    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
        return callableStatement.getDate(i);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于这个类我说如下几点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.@MappedJdbcTypes定义的是JdbcType类型，这里的类型不可自己随意定义，必须要是枚举类org.apache.ibatis.type.JdbcType所枚举的数据类型。&lt;br/&gt;2.@MappedTypes定义的是JavaType的数据类型，描述了哪些Java类型可被拦截。&lt;br/&gt;3.在我们启用了我们自定义的这个TypeHandler之后，数据的读写都会被这个类所过滤&lt;br/&gt;4.在setNonNullParameter方法中，我们重新定义要写往数据库的数据。&lt;br/&gt;5.在另外三个方法中我们将从数据库读出的数据类型进行转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;在mapper中进行配置&quot;&gt;在Mapper中进行配置&lt;/h2&gt;
&lt;p&gt;自定义好了typeHandler之后，接下来我们需要在userMapper.xml中进行简单的配置，首先我们可以像上文说的，配置resultMap，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;org.sang.bean.User&quot;&amp;gt;
        &amp;lt;result typeHandler=&quot;org.sang.db.MyDateTypeHandler&quot; column=&quot;regTime&quot; javaType=&quot;java.util.Date&quot;
                jdbcType=&quot;VARCHAR&quot;
                property=&quot;regTime&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置resultMap的时候我们指定了javaType和jdbcType，同时也指定了处理的typeHandler，然后在select中使用这个resultMap：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUser&quot; resultMap=&quot;userResultMap&quot;&amp;gt;
        select * from user4
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这种方式有一个缺点那就是只适用于查询操作，即在查询的过程中系统会启用我们自定义的typeHandler，会将秒数转为Date对象，但是在插入的时候却不会启用我们自定义的typeHandler，想要在插入的时候启用自定义的typeHandler，需要我们在insert节点中简单配置一下，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;org.sang.bean.User&quot;&amp;gt;
        INSERT INTO user4(username,password,regTime) VALUES (#{username},#{password},#{regTime,javaType=Date,jdbcType=VARCHAR,typeHandler=org.sang.db.MyDateTypeHandler})
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以只配置javaType和jdbcType，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;insert id=&quot;insertUser2&quot;&amp;gt;
        INSERT INTO user4(username,password,regTime) VALUES (#{username},#{password},#{regTime,javaType=Date,jdbcType=VARCHAR})
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者只配置typeHandler：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;insert id=&quot;insertUser3&quot;&amp;gt;
        INSERT INTO user4(username,password,regTime) VALUES (#{username},#{password},#{regTime,typeHandler=org.sang.db.MyDateTypeHandler})
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三种效果都是一样的，都是在插入的时候将数据Date对象转为秒数。OK，如此之后，我们就可以实现将Date对象插入数据库之后变秒数以及将数据库中的秒数读取之后自动转为Date对象了。我们来看一个简单的测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void test2() {
        SqlSession sqlSession = null;
        try {
            sqlSession = DBUtils.openSqlSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
            User user = new User();
            user.setPassword(&quot;222222&quot;);
            user.setUsername(&quot;李四&quot;);
            Date regTime = new Date();
            user.setRegTime(regTime);
            userMapper.insertUser(user);
            sqlSession.commit();
        } catch (Exception e) {
            e.printStackTrace();
            sqlSession.rollback();
        } finally {
            if (sqlSession != null) {
                sqlSession.close();
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入结果如下：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116150906329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读取代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
    public void test1() {
        SqlSession sqlSession = null;
        try {
            sqlSession = DBUtils.openSqlSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
            List&amp;lt;User&amp;gt; list = userMapper.getUser();
            for (User user : list) {
                System.out.println(user);
            }
            sqlSession.commit();
        } catch (Exception e) {
            e.printStackTrace();
            sqlSession.rollback();
        } finally {
            if (sqlSession != null) {
                sqlSession.close();
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取结果如下：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116151001112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，结果上面几步配置我们就完美的解决了读写时的数据转换问题了，读取时的数据转换除了我们上面介绍的定义resultMap然后在select节点中引用这种方式之外，也可以使用下面这种方式，注意下面这种方式&lt;strong&gt;只能解决读取时的数据转换问题&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;在配置文件中注册typehandler&quot;&gt;在配置文件中注册typeHandler&lt;/h2&gt;
&lt;p&gt;我们需要在我们的mybatis配置文件中注册typeHandler，注册有两种不同的方式，可以像下面这样一个类一个类的注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;typeHandlers&amp;gt;
        &amp;lt;typeHandler handler=&quot;org.sang.db.MyDateTypeHandler&quot;/&amp;gt;
    &amp;lt;/typeHandlers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以直接注册一个包中所有的typeHandler，系统在启动时会自动扫描包下的所有文件，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;typeHandlers&amp;gt;
        &amp;lt;package name=&quot;org.sang.db&quot;/&amp;gt;
    &amp;lt;/typeHandlers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样配置完成之后，我们的目的就达到了，当我们进行数据库的读取操作的时候，秒数就会自动转为Date对象。&lt;/p&gt;

&lt;p&gt;OK，经过上面的介绍，想必小伙伴对typeHandler的使用已经有一定了解了，总结一下就是读取时的配置要和插入时的配置分贝来做，读取时数据转换我们有两种配置方式，分别是resultMap和在mybatis配置文件中配置typeHandlers，插入时的配置就是在insert节点中进行配置。&lt;/p&gt;

&lt;p&gt;OK，如果小伙伴们学会了如何把Date转为秒数，那么对于List集合的转换我就不再赘述了，道理都是一样的，大家可以可以直接在文末下载Demo，Demo中有List集合转换的案例。&lt;br/&gt;这里给大家看两张效果图吧：&lt;br/&gt;List集合存入数据库之后变成这样：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116154544442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;读取出来之后又自动转为List集合了，下图是查询操作，实体类，和查询结果：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170116154915791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjcwMjU0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，以上就是我们对typeHandler的一个简单介绍。&lt;/p&gt;
&lt;p&gt;本文案例下载：&lt;br/&gt;本文案例GitHub地址&lt;a href=&quot;https://github.com/lenve/JavaEETest/tree/master/Test27-mybatis6&quot; class=&quot;uri&quot;&gt;https://github.com/lenve/JavaEETest/tree/master/Test27-mybatis6&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;更多资料，请关注公众号牧码小子，回复 Java， 获取松哥为你精心准备的Java干货！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190406153642155.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;《深入浅出MyBatis 技术原理与实战》第三章&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 07:37:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>在做开发时，我们经常会遇到这样一些问题，比如我有一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，怎么实现？再比如我有一个User类，User类中有一个属性叫做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lenve/p/10661934.html</dc:identifier>
</item>
<item>
<title>.NetCore技术研究-EntityFramework Core 3.0 Preview - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/10661571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/10661571.html</guid>
<description>&lt;p&gt;前段时间.Net Core 3.0 发布了，Entity Framework Core 3.0 也发布了Preview版。假期用了一上午大致研究了一遍，同时又体验了一把Visual Studio 2019。总结一下分享给大家：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;VS2019 新建.Net Core 3.0 Console应用，添加EFCore相关的Nuget引用&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;增加appSettings.json配置文件，配置数据库连接&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;新建OneToMany模型，使用EF Core完成数据库操作&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、VS2019 新建.Net Core 3.0 Console应用，添加EFCore相关的Nuget引用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 1. 新建.Net Core控制台应用 EFCoreTest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201904/23525-20190406134459471-448043963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201904/23525-20190406134513664-571192900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   新建完成后，查看项目的依赖性，我们可以看到：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201904/23525-20190406134608234-1797239857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;2. 添加Microsoft.EntityFrameworkCore 3.0 Preview版 Nuget引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201904/23525-20190406134752164-516467009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   同时添加Microsoft.EntityFrameworkCore.SqlServer3.0 Nuget引用（我们要用到SQL Server）&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201904/23525-20190406134840536-510334946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   这样我们就完成了项目的初始化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、增加appsettings.json配置文件，配置数据库连接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  1. 项目中添加appsettings.json文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   配置文件的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{&lt;/span&gt;&quot;ConnectionStrings&quot;&lt;span&gt;: {&lt;/span&gt;&quot;BizDatabase&quot;: &quot;Server=127.0.0.1;Database=master;User id=sa;password=******&quot; &lt;span&gt;}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;2. 访问这个appsettings.json配置文件我们需要引用以下Nuget包&lt;/strong&gt;：版本用的都是：3.0.0-preview3.19153.1&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.Extensions.Configuration&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Configuration.Json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、新建OneToMany模型，使用EF Core完成数据库操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  这里以充电站和集控为例，1：M的关联关系。&lt;/p&gt;
&lt;p&gt;  这里我们同时使用了EF的注解，示例了个性化数据库表结构。以及外键关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations.Schema;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreTest
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 充电站
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [Table(&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Stations&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChargeStation
    {
        [Key]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Code { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaintainTel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MaintainTel { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

     &lt;strong&gt;   [ForeignKey(&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StationID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;)]&lt;/strong&gt;        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; List&amp;lt;ChargeStationController&amp;gt; Controllers { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations.Schema;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreTest
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 电站集控
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [Table(&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;StationCtrl&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChargeStationController
    {
        [Key]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Code { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ControlAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ControlAddress { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]        
        [Column(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StationID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [ForeignKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StationID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; StationID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  实体及关联关系搞定后，我们介绍今天的主角  DbContext的实现：&lt;strong&gt;ChargeDbContext&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  ChargeDbContext 有几个重要的属性和方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;public DbSet&amp;lt;ChargeStation&amp;gt; Stations { get; set; }&lt;br/&gt;public DbSet&amp;lt;ChargeStationController&amp;gt; StationCtrl { get; set; }&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重载OnConfiguring方法，加载配置系统、数据库连接串&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChargeDbContext : DbContext 
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;ChargeStation&amp;gt; Stations { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;ChargeStationController&amp;gt; StationCtrl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
           .SetBasePath(Directory.GetCurrentDirectory())
           .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration =&lt;span&gt; builder.Build();
        
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conn = configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BizDatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;strong&gt;optionsBuilder.UseSqlServer(conn);&lt;/strong&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 至此， 核心主要的EFCore 代码已经完成，我们继续来实现对ChargeStation的数据库操作：&lt;/p&gt;
&lt;p&gt; 我们在Main函数中实现对ChargeStation和ChargeStationController的删除和保存操作，以下代码，大家用过EF应该很熟悉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChargeDbContext())
            {                
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sta &lt;span&gt;in&lt;/span&gt; context.Stations.Include(i =&amp;gt;&lt;span&gt; i.Controllers))
                {
                    context.Remove(sta);
                }
               
                context.SaveChanges();

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; station = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChargeStation
                {
                    ID &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Station0001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Station0001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;济南市奥体中路汉庭充电站&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    MaintainTel &lt;/span&gt;= &lt;span&gt;13799990001&lt;/span&gt;&lt;span&gt;,
                    Controllers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; System.Collections.Generic.List&amp;lt;ChargeStationController&amp;gt;&lt;span&gt;
                    {
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChargeStationController
                         {
                              ID &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Station0001-101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                              Code &lt;/span&gt;=  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Station0001-101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                              ControlAddress &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                              StationID &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Station0001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                         }
                    }
                };

                context.Stations.Add(station);
                context.SaveChanges();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press any key!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.ReadKey();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上即是EntityFramework Core 3.0 Preview 体验和使用分享，后续有会有一篇文章介绍在Debug时，如何Trace SQL语句。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2019/4/6&lt;/p&gt;


</description>
<pubDate>Sat, 06 Apr 2019 06:43:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>前段时间.Net Core 3.0 发布了，Entity Framework Core 3.0 也发布了Preview版。假期用了一上午大致研究了一遍，同时又体验了一把Visual Studio 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianqing/p/10661571.html</dc:identifier>
</item>
<item>
<title>性能测试工具 wrk 使用教程 - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10661650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10661650.html</guid>
<description>&lt;blockquote readability=&quot;4.2692307692308&quot;&gt;
&lt;p&gt;文章首发自个人微信公众号：小哈学Java&lt;br/&gt;个人网站地址：&lt;a href=&quot;https://www.exception.site/wrk&quot; class=&quot;uri&quot;&gt;https://www.exception.site/wrk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155452229133769&quot; title=&quot;什么？QPS 多少？wrk 性能测试&quot; alt=&quot;什么？QPS 多少？wrk 性能测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;被面试官经常问到之前开发的系统接口 QPS 能达到多少，经常给不出一个数值，支支吾吾，导致整体面试效果降低？&lt;/p&gt;
&lt;p&gt;原因基本是一些公司中，做完功能测试就完了，压根不会有性能测试这一步，或者说并发量较少，没有必要进行性能测试，亦或者，交给测试人员后，只要整体问题不大，测试报告一般也是不会再给后端人员看的，这就导致我们在面试的时候，场面一度尴尬 ！！！&lt;/p&gt;
&lt;p&gt;其实，不单单是针对面试，作为一名后端开发者，我们在完成一个接口开发后，在交给测试工程师之前，经常也会想知道，自己写的这个接口的性能如何呢？吞吐量能达到多少？QPS（Query per second 每秒处理完的请求数） 能达到多少呢？&lt;/p&gt;
&lt;p&gt;这个时候，我们就需要借助一些常用的性能测试工具，如 Apache ab, Apache JMeter (互联网公司用的较多)，LoadRunner 等。&lt;/p&gt;
&lt;p&gt;我们今天主要说一说轻量级性能测试工具 &lt;strong&gt;wrk&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;一、什么是 wrk&lt;br/&gt;二、 wrk 的优势&amp;amp;劣势&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2.1 优势&lt;/li&gt;
&lt;li&gt;2.2 劣势&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三、wrk 安装&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.1 Linux 安装&lt;/li&gt;
&lt;li&gt;3.2 MacOS 安装&lt;/li&gt;
&lt;li&gt;3.3 Window 10 安装&lt;/li&gt;
&lt;li&gt;3.4 验证一下，是否安装成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四、如何使用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4.1 简单使用&lt;/li&gt;
&lt;li&gt;4.2 wrk 子命令参数说明&lt;/li&gt;
&lt;li&gt;4.3 测试报告&lt;/li&gt;
&lt;li&gt;4.4 使用 Lua 脚本进行复杂测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;五、总结&lt;br/&gt;六、参考文档&lt;br/&gt;七、赠送面试&amp;amp;学习福利资源&lt;/p&gt;
&lt;h2 id=&quot;一什么是-wrk&quot;&gt;一、什么是 wrk&lt;/h2&gt;
&lt;p&gt;摘自官方 GitHub 上的英文介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155452441166263&quot; title=&quot;wrk 官方说明&quot; alt=&quot;wrk 官方说明&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;翻译一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wrk 是一款针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;PS: 其实，wrk 是复用了 redis 的 ae 异步事件驱动框架，准确来说 ae 事件驱动框架并不是 redis 发明的, 它来至于 Tcl 的解释器 jim, 这个小巧高效的框架, 因为被 redis 采用而被大家所熟知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二-wrk-的优势劣势&quot;&gt;二、 wrk 的优势&amp;amp;劣势&lt;/h2&gt;
&lt;h3 id=&quot;优势&quot;&gt;2.1 优势&lt;/h3&gt;
&lt;p&gt;在说 wrk 的优势之前，瞅一下 wrk 的 GitHub Star 数，也能侧面反映下它的可靠性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155451300057853&quot; title=&quot;wrk Star 数&quot; alt=&quot;wrk Star 数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Wow ! 截止笔者截图为止, Star 数已经达到了 &lt;strong&gt;19742&lt;/strong&gt; !!!&lt;/p&gt;
&lt;p&gt;再来说说 wrk 的优势：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;轻量级性能测试工具;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;安装简单（相对 Apache ab 来说）;&lt;/li&gt;
&lt;li&gt;学习曲线基本为零，几分钟就能学会咋用了；&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基于系统自带的高性能 I/O 机制，如 epoll, kqueue, 利用异步的事件驱动框架，通过很少的线程就可以压出很大的并发量；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;劣势&quot;&gt;2.2 劣势&lt;/h3&gt;
&lt;p&gt;wrk 目前仅支持单机压测，后续也不太可能支持多机器对目标机压测，因为它本身的定位，并不是用来取代 JMeter, LoadRunner 等专业的测试工具，wrk 提供的功能，对我们后端开发人员来说，应付日常接口性能验证还是比较友好的。&lt;/p&gt;
&lt;h2 id=&quot;三wrk-安装&quot;&gt;三、wrk 安装&lt;/h2&gt;
&lt;p&gt;wrk 只能被安装在类 Unix 系统上，所以我们需要一个 Linux 或者 MacOS 环境。Windows 10 安装需要开启自带的 Ubuntu 子系统。&lt;/p&gt;
&lt;h3 id=&quot;linux-安装&quot;&gt;3.1 Linux 安装&lt;/h3&gt;
&lt;h4 id=&quot;ubuntudebian&quot;&gt;3.1.1 Ubuntu/Debian&lt;/h4&gt;
&lt;p&gt;依次执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;sudo apt-get install build-essential libssl-dev git -y
git clone https://github.com/wg/wrk.git wrk
cd wrk
make
# 将可执行文件移动到 /usr/local/bin 位置
sudo cp wrk /usr/local/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;centos-redhat-fedora&quot;&gt;3.2.2 CentOS / RedHat / Fedora&lt;/h4&gt;
&lt;p&gt;依次执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;sudo yum groupinstall 'Development Tools'
sudo yum install -y openssl-devel git 
git clone https://github.com/wg/wrk.git wrk
cd wrk
make
# 将可执行文件移动到 /usr/local/bin 位置
sudo cp wrk /usr/local/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;macos-安装&quot;&gt;3.2 MacOS 安装&lt;/h3&gt;
&lt;p&gt;Mac 系统也可以通过先编译的方式来安装，但是更推荐使用 &lt;code&gt;brew&lt;/code&gt; 的方式来安装, 步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装 Homebrew，安装方式参考官网 &lt;a href=&quot;https://brew.sh/&quot;&gt;https://brew.sh&lt;/a&gt; （也就一行命令的事）;&lt;/li&gt;
&lt;li&gt;安装 wrk: &lt;code&gt;brew install wrk&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;window-10-安装&quot;&gt;3.3 Window 10 安装&lt;/h3&gt;
&lt;p&gt;Windown 10 需要在 &lt;code&gt;Windows 功能&lt;/code&gt; 里勾选 &lt;code&gt;适用于 Linux 的 Windows 子系统&lt;/code&gt;, 然后通过 &lt;code&gt;bash&lt;/code&gt; 命令切换到 Ubuntu 子系统。接下来，参考 &lt;strong&gt;3.1.1&lt;/strong&gt; Ubuntu 的操作系通中，安装 wrk 的步骤。&lt;/p&gt;
&lt;blockquote readability=&quot;7.6384615384615&quot;&gt;
&lt;p&gt;由于笔者使用的是 MacOS, Windows 上的安装步骤，并没有实际操作过，具体安装步骤，您可以参考官方 Windows 10 的安装教程：&lt;a href=&quot;https://github.com/wg/wrk/wiki/Installing-wrk-on-Windows-10&quot; class=&quot;uri&quot;&gt;https://github.com/wg/wrk/wiki/Installing-wrk-on-Windows-10&lt;/a&gt; ，或者用您喜欢的搜索引擎来搜索 Windows 10 如何启用 Ubuntu 子系统后，再安装 wrk，亦或者通过安装 Linux 虚拟机的方式来使用 wrk。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;验证一下是否安装成功&quot;&gt;3.4 验证一下，是否安装成功&lt;/h3&gt;
&lt;p&gt;命令行中输入命令：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;wrk -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155451915918630&quot; title=&quot;查看 wrk 是否安装成功&quot; alt=&quot;查看 wrk 是否安装成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出如上信息，说明安装成功了！&lt;/p&gt;
&lt;h2 id=&quot;四如何使用&quot;&gt;四、如何使用&lt;/h2&gt;
&lt;p&gt;安装成功了，要如何使用呢？&lt;/p&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;4.1 简单使用&lt;/h3&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;wrk -t12 -c400 -d30s http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令表示，利用 wrk 对 www.baidu.com 发起压力测试，线程数为 12，模拟 400 个并发请求，持续 30 秒。&lt;/p&gt;
&lt;h3 id=&quot;wrk-子命令参数说明&quot;&gt;4.2 wrk 子命令参数说明&lt;/h3&gt;
&lt;p&gt;除了上面简单示例中使用到的子命令参数，&lt;code&gt;wrk&lt;/code&gt; 还有其他更丰富的功能，命令行中输入 &lt;code&gt;wrk --help&lt;/code&gt;, 可以看到支持以下子命令：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;[root@VM_0_5_centos ~]# wrk --help
Usage: wrk &amp;lt;options&amp;gt; &amp;lt;url&amp;gt;                            
  Options:                                            
    -c, --connections &amp;lt;N&amp;gt;  Connections to keep open   
    -d, --duration    &amp;lt;T&amp;gt;  Duration of test           
    -t, --threads     &amp;lt;N&amp;gt;  Number of threads to use   
                                                      
    -s, --script      &amp;lt;S&amp;gt;  Load Lua script file       
    -H, --header      &amp;lt;H&amp;gt;  Add header to request      
        --latency          Print latency statistics   
        --timeout     &amp;lt;T&amp;gt;  Socket/request timeout     
    -v, --version          Print version details      
                                                      
  Numeric arguments may include a SI unit (1k, 1M, 1G)
  Time arguments may include a time unit (2s, 2m, 2h)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译一下：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;使用方法: wrk &amp;lt;选项&amp;gt; &amp;lt;被测HTTP服务的URL&amp;gt;                            
  Options:                                            
    -c, --connections &amp;lt;N&amp;gt;  跟服务器建立并保持的TCP连接数量  
    -d, --duration    &amp;lt;T&amp;gt;  压测时间           
    -t, --threads     &amp;lt;N&amp;gt;  使用多少个线程进行压测   
                                                      
    -s, --script      &amp;lt;S&amp;gt;  指定Lua脚本路径       
    -H, --header      &amp;lt;H&amp;gt;  为每一个HTTP请求添加HTTP头      
        --latency          在压测结束后，打印延迟统计信息   
        --timeout     &amp;lt;T&amp;gt;  超时时间     
    -v, --version          打印正在使用的wrk的详细版本信息
                                                      
  &amp;lt;N&amp;gt;代表数字参数，支持国际单位 (1k, 1M, 1G)
  &amp;lt;T&amp;gt;代表时间参数，支持时间单位 (2s, 2m, 2h)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS: 关于线程数，并不是设置的越大，压测效果越好，线程设置过大，反而会导致线程切换过于频繁，效果降低，一般来说，推荐设置成压测机器 CPU 核心数的 2 倍到 4 倍就行了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试报告&quot;&gt;4.3 测试报告&lt;/h3&gt;
&lt;p&gt;执行压测命令:&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;wrk -t12 -c400 -d30s --latency http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的压测命令，30 秒压测过后，生成如下压测报告：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;Running 30s test @ http://www.baidu.com 
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   386.32ms  380.75ms   2.00s    86.66%
    Req/Sec    17.06     13.91   252.00     87.89%
  Latency Distribution
     50%  218.31ms
     75%  520.60ms
     90%  955.08ms
     99%    1.93s 
  4922 requests in 30.06s, 73.86MB read
  Socket errors: connect 0, read 0, write 0, timeout 311
Requests/sec:    163.76
Transfer/sec:      2.46MB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来具体说一说，报告中各项指标都代表什么意思：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;Running 30s test @ http://www.baidu.com （压测时间30s）
  12 threads and 400 connections （共12个测试线程，400个连接）
              （平均值） （标准差）  （最大值）（正负一个标准差所占比例）
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    （延迟）
    Latency   386.32ms  380.75ms   2.00s    86.66%
    (每秒请求数)
    Req/Sec    17.06     13.91   252.00     87.89%
  Latency Distribution （延迟分布）
     50%  218.31ms
     75%  520.60ms
     90%  955.08ms
     99%    1.93s 
  4922 requests in 30.06s, 73.86MB read (30.06s内处理了4922个请求，耗费流量73.86MB)
  Socket errors: connect 0, read 0, write 0, timeout 311 (发生错误数)
Requests/sec:    163.76 (QPS 163.76,即平均每秒处理请求数为163.76)
Transfer/sec:      2.46MB (平均每秒流量2.46MB)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，压测报告还是非常直观的！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;标准差&lt;/strong&gt;啥意思？标准差如果太大说明样本本身离散程度比较高，有可能系统性能波动较大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-lua-脚本进行复杂测试&quot;&gt;4.4 使用 Lua 脚本进行复杂测试&lt;/h3&gt;
&lt;p&gt;您可能有疑问了，你这种进行 GET 请求还凑合，我想进行 POST 请求咋办？而且我想每次的请求参数都不一样，用来模拟用户使用的实际场景，又要怎么弄呢？&lt;/p&gt;
&lt;p&gt;对于这种需求，我们可以通过编写 Lua 脚本的方式，在运行压测命令时，通过参数 &lt;code&gt;--script&lt;/code&gt; 来指定 Lua 脚本，来满足个性化需求。&lt;/p&gt;
&lt;h4 id=&quot;wrk-对-lua-脚本的支持&quot;&gt;4.4.1 wrk 对 Lua 脚本的支持&lt;/h4&gt;
&lt;p&gt;wrk 支持在三个阶段对压测进行个性化，分别是启动阶段、运行阶段和结束阶段。每个测试线程，都拥有独立的Lua 运行环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动阶段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function setup(thread)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在脚本文件中实现 setup 方法，wrk 就会在测试线程已经初始化，但还没有启动的时候调用该方法。wrk会为每一个测试线程调用一次 setup 方法，并传入代表测试线程的对象 thread 作为参数。setup 方法中可操作该 thread 对象，获取信息、存储信息、甚至关闭该线程。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;thread.addr             - get or set the thread's server address
thread:get(name)        - get the value of a global in the thread's env
thread:set(name, value) - set the value of a global in the thread's env
thread:stop()           - stop the thread&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function init(args)
function delay()
function request()
function response(status, headers, body)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init(args)&lt;/code&gt;: 由测试线程调用，只会在进入运行阶段时，调用一次。支持从启动 wrk 的命令中，获取命令行参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delay()&lt;/code&gt;： 在每次发送请求之前调用，如果需要定制延迟时间，可以在这个方法中设置；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request()&lt;/code&gt;: 用来生成请求, 每一次请求都会调用该方法，所以注意不要在该方法中做耗时的操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;response(status, headers, body)&lt;/code&gt;: 在每次收到一个响应时被调用，为提升性能，如果没有定义该方法，那么wrk不会解析 &lt;code&gt;headers&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;结束阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;function done(summary, latency, requests)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;done() 方法在整个测试过程中只会被调用一次，我们可以从给定的参数中，获取压测结果，生成定制化的测试报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义 Lua 脚本中可访问的变量以及方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量：wrk&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk = {
    scheme  = &quot;http&quot;,
    host    = &quot;localhost&quot;,
    port    = 8080,
    method  = &quot;GET&quot;,
    path    = &quot;/&quot;,
    headers = {},
    body    = nil,
    thread  = &amp;lt;userdata&amp;gt;,
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上定义了一个 &lt;code&gt;table&lt;/code&gt; 类型的全局变量，修改该 &lt;code&gt;wrk&lt;/code&gt; 变量，会影响所有请求。&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;wrk.fomat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrk.lookup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrk.connect&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面三个方法解释如下：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function wrk.format(method, path, headers, body)

    wrk.format returns a HTTP request string containing the passed parameters
    merged with values from the wrk table.
    # 根据参数和全局变量 wrk，生成一个 HTTP rquest 字符串。

function wrk.lookup(host, service)

    wrk.lookup returns a table containing all known addresses for the host
    and service pair. This corresponds to the POSIX getaddrinfo() function.
    # 给定 host 和 service（port/well known service name），返回所有可用的服务器地址信息。

function wrk.connect(addr)

    wrk.connect returns true if the address can be connected to, otherwise
    it returns false. The address must be one returned from wrk.lookup().
    # 测试给定的服务器地址信息是否可以成功创建连接&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过-lua-脚本压测示例&quot;&gt;4.4.1 通过 Lua 脚本压测示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;调用 POST 接口：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk.method = &quot;POST&quot;
wrk.body   = &quot;foo=bar&amp;amp;baz=quux&quot;
wrk.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意: wrk 是个全局变量，这里对其做了修改，使得所有请求都使用 POST 的方式，并指定了 body 和 Content-Type头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义每次请求的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;request = function()
   uid = math.random(1, 10000000)
   path = &quot;/test?uid=&quot; .. uid
   return wrk.format(nil, path)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 request 方法中，随机生成 1~10000000 之间的 uid，并动态生成请求 URL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次请求前，延迟 10ms:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function delay()
   return 10
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请求的接口需要先进行认证，获取 token 后，才能发起请求，咋办？&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;token = nil
path  = &quot;/auth&quot;

request = function()
   return wrk.format(&quot;GET&quot;, path)
end

response = function(status, headers, body)
   if not token and status == 200 then
      token = headers[&quot;X-Token&quot;]
      path  = &quot;/test&quot;
      wrk.headers[&quot;X-Token&quot;] = token
   end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的脚本表示，在 token 为空的情况下，先请求 &lt;code&gt;/auth&lt;/code&gt; 接口来认证，获取 token, 拿到 token 以后，将 token 放置到请求头中，再请求真正需要压测的 &lt;code&gt;/test&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;压测支持 HTTP pipeline 的服务：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;init = function(args)
   local r = {}
   r[1] = wrk.format(nil, &quot;/?foo&quot;)
   r[2] = wrk.format(nil, &quot;/?bar&quot;)
   r[3] = wrk.format(nil, &quot;/?baz&quot;)

   req = table.concat(r)
end

request = function()
   return req
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过在 init 方法中将三个 HTTP请求拼接在一起，实现每次发送三个请求，以使用 HTTP pipeline。&lt;/p&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;本文中，我们学习了轻量级性能测试工具 wrk, 如何安装，以及具体的使用方法，包括通过 Lua 脚本来个性化定制请求等。希望读完本文，能对您有所帮助哦！&lt;/p&gt;
&lt;h2 id=&quot;六参考文档&quot;&gt;六、参考文档：&lt;/h2&gt;
&lt;h2 id=&quot;六赠送-面试学习福利资源&quot;&gt;六、赠送 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心面试知识.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复 &lt;strong&gt;资源&lt;/strong&gt;，既可获取资源链接，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400833400257&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400839732898&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400852415356&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400881121484&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400845880272&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400888166824&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155400892078337&quot; title=&quot;福利资源截图&quot; alt=&quot;福利资源截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复 &lt;strong&gt;资源&lt;/strong&gt;，既可获取资源链接 ！！！&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/154874842150997&quot; title=&quot;小哈学Java&quot; alt=&quot;小哈学Java&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 06:24:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>文章首发自个人微信公众号：小哈学Java 个人网站地址： 'https://www.exception.site/wrk' 被面试官经常问到之前开发的系统接口 QPS 能达到多少，经常给不出一个数值，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10661650.html</dc:identifier>
</item>
<item>
<title>大话JVM（一）：垃圾收集算法 - Jack·J</title>
<link>http://www.cnblogs.com/jpwahaha/p/10639662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpwahaha/p/10639662.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;　　 系列介绍｜&lt;/strong&gt;本系列主要是记录学习jvm过程中觉得重要的内容，方便以后复习&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在说垃圾收集算法之前，先要说一下垃圾收集，&lt;strong&gt;从大的讲，垃圾收集需要考虑三件事情：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.哪些内存需要回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.什么时候回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.如何回收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JVM在执行java程序时，把他管理的内存分为多个数据区域：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.程序计数器（记录程序执行到哪了，各线程之间独立存储， 互不影响）&lt;/p&gt;
&lt;p&gt;2.虚拟机栈（这个栈就是我们常说的jvm的“堆”和“栈”中的栈，这里存放的是编译期间可知的各种数据类型（8种基本类型）、对象引用（reference类型，就是一种数据指针，指向对象的起始地址，或者句柄，或者是对象相关的位置）&lt;/p&gt;
&lt;p&gt;3.本地方法栈（这个跟虚拟机栈非常相似，只不过虚拟机栈是为虚拟机执行java方法服务的，而本地方法栈是为虚拟机使用Natvie方法服务的，虚拟机规范中没有对本地方法栈做强制规定，HotSpot把虚拟机栈和本地方法栈合二为一了）&lt;/p&gt;
&lt;p&gt;4.java堆（这堆是JVM管理内存中最多的一块，几乎所有的对象实例都存放在这里，java虚拟机规范中描述：所有对象的实例以及数据都要在堆上分配，GC就是主要管理这个区域）&lt;/p&gt;
&lt;p&gt;5.方法区（在HotSpot中，这个区就是我们常说的“永久代”，这是一个线程共享的区域，它主要用来存储被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据）&lt;/p&gt;

&lt;p&gt;其中程序计数器、虚拟机栈、本地方法栈3个区随线程而生，随线程而灭；栈中的栈帧随方法的进入和退出有条不紊的执行出栈和入栈操作，内存的分配是在类结构确定下来时就已知的，内存的分配和回收都具有确定性，因此这几个区域不需要过多考虑回收问题，因为方法结束或线程结束时，内存自然跟着回收了。主要考虑的是JAVA堆和方法区，因为这部分内存分配是动态的，程序在运行时才知道创建哪个对象实例，执行哪个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GC回收前需要考虑对象已经“死&lt;/strong&gt;”了吗&lt;/p&gt;
&lt;p&gt;判断对象是否存活有两种算法，一种是引用计数算法，另一种是可达性算法&lt;/p&gt;
&lt;p&gt;1）引用计数算法&lt;/p&gt;
&lt;p&gt;引用计数算法就是给对象中添加一个引用计数器，每当有地方引用他时，计算器值加1，当引用失效时，计数器值减1，计算器值为0时，表示对象不再被使用。&lt;/p&gt;
&lt;p&gt;引用计数算法实现简单，判定效率高，但是有个致命确定，就是循环引用时无法正常工作。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountGC {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object instance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGC(String[] args){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建了一个CountGC对象，并发把它赋给了countGC1,CountGC的对象引用计数值加1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         CountGC countGC1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountGC();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;又创建了一个CountGC对象，并发把它赋给了countGC2,另一个CountGC的对象引用计数值加1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         CountGC countGC2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountGC();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把第一个CountGC对象的instance字段赋值上第二个CountGC对象，第二个CountGC对象引用计数值再加1，这是就变成了2&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         countGC1.instance =&lt;span&gt; countGC2;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把第二个CountGC对象的instance字段赋值上第一个CountGC对象，第一个CountGC对象的引用计数值再加2，这时也变成了2&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         countGC2.instance =&lt;span&gt; countGC1;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;countGC1赋空值，第一个CountGC对象引用减1&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         countGC1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;countGC2赋空值，第二个CountGC对象引用减1&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         countGC2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这时候回收，这两个CountGC对象是无法回收的，因为他们的引用计数值不为0&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        System.gc();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 2）可达性算法 &lt;/p&gt;
&lt;p&gt;可达性算法就是以一个 GC Roots对象向下搜索，能搜索到的对象就说明是存活的，搜索不到的对象说明就是不可用的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406102050525-1101194439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 不管是引用计数算法，还是不可达算法，最终判断对象是否存活的关键，是引用。&lt;/p&gt;


&lt;p&gt;下面我们正式介绍垃圾收集算法，我们主要介绍下面几种算法：&lt;/p&gt;
&lt;p&gt;1.标记 - 清除算法&lt;/p&gt;
&lt;p&gt;2.复制算法&lt;/p&gt;
&lt;p&gt;3.标记 - 整理算法&lt;/p&gt;
&lt;p&gt;4.分代收集算法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）标记 - 清除算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标记 - 清除算法就跟他的名字一样，分为“标记”和“清除”两阶段，首选标记出所有可回收的对象，然后统一回收所有被标记的对象。&lt;/p&gt;
&lt;p&gt;标记 - 清除算法是最基础的算法，后续的几个算法都是基于这种算法思路对其不足进行改进得到的。&lt;/p&gt;
&lt;p&gt;它的不足主要表现在两个方面，一是效率问题，二是空间利用问题&lt;/p&gt;
&lt;p&gt;效率不高是因为，它标记是需要遍历所有内存空间，清除时也是一个个清除&lt;/p&gt;
&lt;p&gt;空间利用率问题是因为清理后内存空间是零碎的，当需要分配大空间时，没有连续空间，需要再次触发GC&lt;/p&gt;

&lt;p&gt;回收前状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111109047-56829986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 回收后状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111338072-38145044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111426356-1914410776.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111502524-1839901683.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111517430-689373458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决效率问题，复制算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块的内存用完时，就将存活的对象复制到另外一块内存上面，然后把使用过的内存空间一次清理掉。&lt;/p&gt;

&lt;p&gt;回收前状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115202379-903813300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;回收后状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115302580-312310815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115343014-437589407.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115352465-253974912.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115405262-793463915.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406115414458-618265304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;复制算法的优点是：实现简单，运行高效&lt;/p&gt;
&lt;p&gt;缺点是：浪费内存，从上面算法来看，实际使用只有原来内存的一半，浪费太大了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现在的商用虚拟机都采用这种算法来回收新生代&lt;/strong&gt;，IBM公司专门研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1来划分内存，而是将内存分成一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survivor，另一个Survivor作为预留空间。（HotSopt中默认分配比例是8:1:1，这样只浪费了10%的空间）。&lt;/p&gt;
&lt;p&gt;采用这种内存分配方式的回收过程：&lt;/p&gt;
&lt;p&gt;1.每次使用Eden和一块Survivor，另一块Survivor作为预留空间，&lt;/p&gt;
&lt;p&gt;2.标记出Eden和一块Survivor空间中存活的对象，并复制到另一块Survivor空间中&lt;/p&gt;
&lt;p&gt;3.清理掉使用过的Eden和一块Survivor空间。&lt;/p&gt;

&lt;p&gt;这种做法有一个不足之处，就是当Eden和一块Survivor空间中存活的对象（对象存活率较高）大于另一块Survivor空间时，需要老年代担保分配，这时候效率非常低（因为存活对象是一个个复制到预留内存空间的，对象存活率特别高时，对象数也会非常多），而且还浪费空间（这时候预留空间就起不到作用了，浪费了预留空间的内存）。&lt;/p&gt;
&lt;p&gt;因为当发现Eden和一块Survivor空间中存活的对象大于另一块Survivor空间时，这时候会把存活对象直接分配到老年代。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3）标记 - 整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标记 - 整理算法就是把标记 - 清除算法中的清除替换成整理，整理时不直接对回收对象清理，而是让所有存活对象向一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;

&lt;p&gt;回收前状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406133410408-206182956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;回收后状态：&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406133531587-1468400065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111426356-1914410776.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111502524-1839901683.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/741113/201904/741113-20190406111517430-689373458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这个算法是根据老年代的特点设计出来的，因为老年代中对象存活率较高，并且没有额外的空间对它进行分配担保，就必须采用“标记 - 清楚” 或者 “标记 - 整理”算法来进行回收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4）分代收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前商业虚拟机都是采用“分代收集”算法，这种算法并没有什么新的思想，只是按照对象存活周期不同将内存划分为几个区域，就像java堆中的新生代和老年代一样，这样做的好处是，可以根据各个年代的特点采用适当的收集算法。&lt;/p&gt;

</description>
<pubDate>Sat, 06 Apr 2019 05:49:00 +0000</pubDate>
<dc:creator>Jack&amp;#183;J</dc:creator>
<og:description>系列介绍｜本系列主要是记录学习jvm过程中觉得重要的内容，方便以后复习 在说垃圾收集算法之前，先要说一下垃圾收集，从大的讲，垃圾收集需要考虑三件事情： 1.哪些内存需要回收 2.什么时候回收 3.如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpwahaha/p/10639662.html</dc:identifier>
</item>
<item>
<title>彻底填平Static坑(细节决定成败) - 泰斗贤若如</title>
<link>http://www.cnblogs.com/zyx110/p/10661545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyx110/p/10661545.html</guid>
<description>&lt;p&gt;                &lt;strong&gt;&lt;span&gt;学习的过程就是填坑的过程，可不要偷懒想着跳过去，你现在跳过去，就相当于给自己挖了一个坑，你迟早会掉进去的，为了避免不掉坑，所以，努力填坑吧！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.如果没有static会怎样？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;需求：　　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1：定义Student类&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      1：姓名、国籍，说话行为&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      2：多个构造，重载形式体现&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2：学生的国籍都是确定的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      1：国籍可以进行显示初始化&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Student {
    String name;//姓名
    String country;//国籍

    public Student(String name, String country) {
        this.name = name;
        this.country = country;
    }

    public void speak(){
        System.out.println(&quot;姓名:&quot;+this.name+&quot; &quot;+&quot;国籍:&quot;+this.country);
    }
}

class Test{
    public static void main(String[] args) {
        Student student = new Student(&quot;何道昌&quot;,&quot;中国&quot;);
        Student student1 = new Student(&quot;孙双双&quot;,&quot;中国&quot;);

        student.speak();
        student1.speak();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

姓名:何道昌 国籍:中国
姓名:孙双双 国籍:中国
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;目前存在的问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        现在我们已知学生都是中国人，现在我们每创建一个学生对象，就要给所有学生的国籍属性赋相同的值，这样造成堆内存空间资源浪费&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;目前方案：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        把“中国”这个数据移动到数据共享区中，共享这个数据给所有的Student对象使用即可&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        疑问：如何才能把这个数据移动到数据共享区中共享呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        只需要用static修饰该数据即可&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        静态的成员变量只会在数据共享区中维护一份，而非静态成员变量的数据会在每个对象中都维护一份&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201904/1640688-20190406123823507-441810494.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Student {
    String name;//姓名
    //使用了static修饰country，那么这时候country就是一个共享的数据
    static String country = &quot;中国&quot;;//国籍
    //构造函数
    public Student(String name) {
        this.name = name;
    }
     //说话行为
    public void speak(){
        System.out.println(&quot;姓名:&quot;+this.name+&quot; &quot;+&quot;国籍:&quot;+country);
    }
}

class Test{
    public static void main(String[] args) {
        Student student = new Student(&quot;何道昌&quot;);
        Student student1 = new Student(&quot;孙双双&quot;);

        student.speak();
        student1.speak();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

姓名:何道昌 国籍:中国
姓名:孙双双 国籍:中国
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;下面我来详细解说&lt;strong&gt;static&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;static（静态修饰符）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.static修饰静态变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        静态成员变量的访问方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               方式一： 可以使用对象进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                             格式：对象.变量名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               方式二：可以使用类名进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                             格式：类名.变量名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                         1.非静态的成员变量只能使用对象进行访问，不能使用类命进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Student {
    String name;//姓名     非静态成员变量
    //使用了static修饰country，那么这时候country就是一个共享的数据
    static String country = &quot;中国&quot;;//国籍    静态成员变量
    //构造函数
    public Student(String name) {
        this.name = name;
    }
     //说话行为
    public void speak(){
        System.out.println(&quot;姓名:&quot;+this.name+&quot; &quot;+&quot;国籍:&quot;+country);
    }
}

class Test{
    public static void main(String[] args) {
        Student student = new Student(&quot;何道昌&quot;);

        System.out.println(student.name);//用对象访问非静态变量&lt;br/&gt;Systen.out.println(student.country);//用对象访问静态变量
        System.out.println(Student.country);//用类命访问静态变量
 &lt;br/&gt;}
}&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

何道昌&lt;br/&gt;中国
中国
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;                 &lt;strong&gt;&lt;span&gt;2.千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据真正需要被共享的时候，才使用static修饰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;            static修饰成员变量的应用场景：如果一个数据需要被所有对象共享使用的时候，用static修饰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.static修饰成员函数（静态的成员方法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;            &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 静态成员函数的访问方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               方式一： 可以使用对象进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                             格式：对象.静态的函数名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               方式二：可以使用类名进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                             格式：类名.静态的函数名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐使用类名直接访问静态的成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                   1.方便      &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                   2.节省内存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态函数要注意的事项：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        1.静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        2.静态的函数可以访问静态的成员，但是不能直接访问非静态的成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        3.非静态的函数是可以直接访问静态与非静态的成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        4.静态函数不能出现this或者super关键字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Student {
    String name;//姓名     非静态成员变量
    //使用了static修饰country，那么这时候country就是一个共享的数据
    static String country = &quot;中国&quot;;//国籍    静态成员变量
    //构造函数
    public Student(String name) {
        this.name = name;
    }
     //说话行为
    //静态成员方法
    public static void speak(){
        System.out.println(&quot;国籍:&quot;+country);
    }
    //学习行为
    //非静态成员方法
    public  void study(){
        System.out.println(name+&quot;好好学习&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        Student student = new Student(&quot;何道昌&quot;);

        System.out.println(student.name);//用对象访问非静态变量
        System.out.println(student.country);//用对象访问静态变量
        System.out.println(Student.country);//用类命访问静态变量

        student.study();//用对象访问非静态方法
        student.speak();//用对象访问静态方法
        Student.speak();//用类名访问静态方法
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

何道昌
中国
中国
何道昌好好学习
国籍:中国
国籍:中国
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，继续用这个例子穿插一下静态代码块的知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;           静态代码块是在Student.class文件加载到内存的时候就马上执行的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Student {
    String name;//姓名     非静态成员变量
    //使用了static修饰country，那么这时候country就是一个共享的数据
    static String country = &quot;中国&quot;;//国籍    静态成员变量
    //静态代码块
    static{
        System.out.println(&quot;静态代码块执行了！！&quot;);
    }
    //构造函数
    public Student(String name) {
        this.name = name;
    }
     //说话行为
    //静态成员方法
    public static void speak(){
        System.out.println(&quot;国籍:&quot;+country);
    }
    //学习行为
    //非静态成员方法
    public  void study(){
        System.out.println(name+&quot;好好学习&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        Student.speak();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

静态代码块执行了！！
国籍:中国
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;理解到这，你再看看下面的分析图，应该还会有所收获&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201904/1640688-20190406134252893-368675615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;最后再跟大家分享一句话：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;          一个人若想改变自己的命运，最重要的是要改变自己，改变心态，改变环境，这样命运也会随之改变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;          读完此篇，如若对你有用，记得推荐，如若有误，欢迎指正！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;          此篇为本人原创，转载请说明出处&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 06 Apr 2019 05:48:00 +0000</pubDate>
<dc:creator>泰斗贤若如</dc:creator>
<og:description>static 学习的过程就是填坑的过程，可不要偷懒想着跳过去，你现在跳过去，就相当于给自己挖了一个坑，你迟早会掉进去的，为了避免不掉坑，所以，努力填坑吧！ 一.如果没有static会怎样？ 需求： 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zyx110/p/10661545.html</dc:identifier>
</item>
<item>
<title>【极简版】SpringBoot+SpringData JPA 管理系统 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10661322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10661322.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有光头才能变强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;文本已收录至我的GitHub仓库，欢迎Star：&lt;a href=&quot;https://github.com/ZhongFuCheng3y/3y&quot; class=&quot;uri&quot;&gt;https://github.com/ZhongFuCheng3y/3y&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一篇中已经讲解了如何&lt;strong&gt;从零&lt;/strong&gt;搭建一个SpringBoot+SpringData JPA的环境，测试接口的时候也成功获取得到数据了。&lt;/p&gt;
&lt;p&gt;我的目的是做一个&lt;strong&gt;十分简易&lt;/strong&gt;的管理系统，这就得有页面，下面我继续来讲讲我是怎么&lt;strong&gt;快速&lt;/strong&gt;搭一个管理系统的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps:由于是简易版，我的目的是能够&lt;strong&gt;快速&lt;/strong&gt;搭建，而不在于代码的规范性。(所以在后面你可能会看到很多丑陋的代码)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一搭建管理系统&quot;&gt;一、搭建管理系统&lt;/h2&gt;
&lt;h3 id=&quot;搭建页面&quot;&gt;1.1. 搭建页面&lt;/h3&gt;
&lt;p&gt;在上一篇的最后，我们可以通过&lt;code&gt;http://localhost:8887/user&lt;/code&gt;接口拿到我们User表所有的记录了。我们现在希望把记录&lt;strong&gt;塞到&lt;/strong&gt;一个管理页面上(展示起来)。&lt;/p&gt;
&lt;p&gt;作为一个后端，我HTML+CSS实在是丑陋，于是我就去找了一份&lt;strong&gt;BootStrap&lt;/strong&gt;的模板。首先，我进到bootStrap的官网，找到&lt;strong&gt;基本模板&lt;/strong&gt;这一块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a53d991b?w=2182&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=235234&quot; alt=&quot;bootStrap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在里边可以看到挺多的模板的，这里选择一个&lt;strong&gt;控制台&lt;/strong&gt;页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a523bb58?w=2102&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=275378&quot; alt=&quot;bootstrap example&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，就把这份&lt;strong&gt;模板下载&lt;/strong&gt;下来，在本地中运行起来试试看。官方给出的链接是下载整一份文档，我们找到想要的页面即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a6ace50c?w=1484&amp;amp;h=538&amp;amp;f=jpeg&amp;amp;s=86978&quot; alt=&quot;files&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我们将这两份文件&lt;strong&gt;单独&lt;/strong&gt;粘贴在我们的项目中，发现这HTML文件需要&lt;code&gt;bootstrap.css、bootstrap.js、jquery &lt;/code&gt;的依赖(原来用的是相对路径，其实我们就是&lt;strong&gt;看看相对路径的文件在我们这有没有&lt;/strong&gt;，如果没有，那就是我们需要的)。这里我们在CDN中找找，导入链接就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a6906cc2?w=1948&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=260822&quot; alt=&quot;bootcdn&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我们就将&lt;strong&gt;所缺&lt;/strong&gt;的依赖替换成BootCDN的依赖，最重要的几个依赖如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;link href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.0/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如无意外的话，我们也能在项目中正常打开页面。&lt;/p&gt;
&lt;h3 id=&quot;把数据塞到页面上&quot;&gt;1.1.2 把数据塞到页面上&lt;/h3&gt;
&lt;p&gt;把数据塞到页面上，有两种方案：要么就后端返回json给前端进行解析，要么就使用模板引擎。而我为了便捷，是不想写JS代码的。所以，我使用freemarker这个模板引擎。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么这么多模板引擎，我选择这个？因为我只会这个！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在SpringBoot下使用freemarker也是非常简单，首先，我们需要加入pom文件依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--freemarker--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后，在&lt;code&gt;application.yml&lt;/code&gt;文件中，加入freemarker的配置：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;  # freemarker配置
  freemarker:
    suffix: .ftl
    request-context-attribute: request
    expose-session-attributes: true
    content-type: text/html
    check-template-location: true
    charset: UTF-8
    cache: false
    template-loader-path: classpath:/templates&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我简单解释一下：freemarker的文件后缀名为&lt;code&gt;.ftl&lt;/code&gt;，程序从&lt;code&gt;/templates&lt;/code&gt;路径下加载我们的文件。&lt;/p&gt;
&lt;p&gt;于是乎，我将本来是&lt;code&gt;.html&lt;/code&gt;的文件修改成&lt;code&gt;.ftl&lt;/code&gt;文件，并放在templates目录下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a6ed28a9?w=638&amp;amp;h=362&amp;amp;f=jpeg&amp;amp;s=32285&quot; alt=&quot;templates&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来将我们Controller得到的数据，塞到Model对象中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 得到所有用户
     */
    @GetMapping(value = &quot;/user&quot;, produces = {&quot;application/json;charset=UTF-8&quot;})
    public String  getAllUser ( Model model) {
        List&amp;lt;User&amp;gt; allUser = userService.getAllUser();
        model.addAttribute(&quot;users&quot;, allUser);
        return &quot;/index&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图片如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce1a6d351b6?w=1796&amp;amp;h=466&amp;amp;f=jpeg&amp;amp;s=140684&quot; alt=&quot;user code&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ftl文件中，我们只要判断数据是否存在，如果存在则在表格中遍历出数据就行了：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;   &amp;lt;#if users?? &amp;amp;&amp;amp; (users?size &amp;gt; 0)&amp;gt;
     &amp;lt;#list users as user&amp;gt;
       &amp;lt;tr&amp;gt;
         &amp;lt;td&amp;gt;${user.userId}&amp;lt;/td&amp;gt;
         &amp;lt;td&amp;gt;${user.userNickname}&amp;lt;/td&amp;gt;
         &amp;lt;td&amp;gt;${user.userEmail}&amp;lt;/td&amp;gt;
         &amp;lt;td&amp;gt;${user.actiState}&amp;lt;/td&amp;gt;
         &amp;lt;td&amp;gt;&amp;lt;a href=&quot;http://localhost:8887/deleteUser?id=${user.userId}&quot;&amp;gt;删除&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
       &amp;lt;/tr&amp;gt;
       &amp;lt;/#list&amp;gt;
     &amp;lt;#else&amp;gt;
       &amp;lt;h3&amp;gt;还没有任何用户&amp;lt;/h3&amp;gt;
   &amp;lt;/#if&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图片如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce23c6d2b16?w=1850&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=192257&quot; alt=&quot;code image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除的Controller代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 根据ID删除某个用户
 */
@GetMapping(value = &quot;/deleteUser&quot;, produces = {&quot;application/json;charset=UTF-8&quot;})
public String  deleteUserById (String id,Model model) {

  userService.deleteUserById(id);
  return getAllUser(model);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再找几张自己喜欢的图片，简单删除一些不必要模块，替换成我们想要的文字，就可以得到以下的效果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce24acafd1c?w=2328&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=228150&quot; alt=&quot;result iamge&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于图片上的评论管理、备忘录管理的做法都如上，我只是把文件再复制一次而已(期中没有写任何的JS代码,懒)。&lt;/p&gt;
&lt;p&gt;在编写的期中，要值得注意的是：静态的文件一般我们会放在static文件夹中。&lt;/p&gt;
&lt;p&gt;项目的目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f0ce2571b2b24?w=890&amp;amp;h=1030&amp;amp;f=jpeg&amp;amp;s=114093&quot; alt=&quot;project structure&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本文涉及到的链接(bootstrap &amp;amp; cdn)：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/30/169cdcbb93ac61e1?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=19384&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 04:05:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强。 文本已收录至我的GitHub仓库，欢迎Star： 'https://github.com/ZhongFuCheng3y/3y' 在上一篇中已经讲解了如何 从零 搭建一个Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10661322.html</dc:identifier>
</item>
<item>
<title>从ASP.NET Core2.2到3.0你可能会遇到这些问题 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10661161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10661161.html</guid>
<description>&lt;p&gt;趁着假期的时间所以想重新学习下微软的官方文档来巩固下基础知识。我们都知道微软目前已经发布了.NET Core3.0的第三个预览版，同时我家里的电脑也安装了vs2019。So，就用vs2019+.NET Core3.0来跟着做一下Contoso University这个WEB应用，但是在基于3.0进行操作的时候遇到了一些问题，所以我就查看了微软的《&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;amp;tabs=visual-studio&quot;&gt;从 ASP.NET Core 迁移 2.2 到 3.0 预览版 2&lt;/a&gt;》这篇文档，就着今天遇到的问题，所以我整理下，希望对大伙有所帮助，当然大伙也可以直接阅读微软的官方文档进行查看。但是我在阅读官方说明的时候，总感觉翻译的不是很准确，读起来很拗口，所以这里我是自己的理解对官方文档的一个补充。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10661161.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10661161.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我遇到的问题&quot;&gt;我遇到的问题&lt;/h2&gt;
&lt;p&gt;ASP.NET Core2.0时代，若要为项目添加 EF Core 支持，需要安装相应的数据库驱动包。 教程中使用 SQL Server，相关驱动包&lt;a href=&quot;https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.SqlServer/&quot;&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/a&gt;。 此包包含在 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.0&quot;&gt;Microsoft.AspNetCore.App 元包&lt;/a&gt;中，因此，如果应用具有对 &lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt; 包的包引用，则无需引用该包。而2.0中的模板项目会自动为我们加载&lt;code&gt;Mcrosoft.AspNetCore.App&lt;/code&gt;这个包的。但是3.0中没有了这个&lt;code&gt;Mcrosoft.AspNetCore.App&lt;/code&gt;这个包，模块化的更彻底了！所需要的EF相关的包需要你自己来进行引用。&lt;/p&gt;
&lt;h2 id=&quot;升3.0升级指南&quot;&gt;2.0升3.0升级指南&lt;/h2&gt;
&lt;p&gt;就着今天遇到的问题，所以我整理下ASP.NET Core从2.0升级3.0的一个升级指南，希望对大伙有所帮助，当然大伙也可以直接阅读微软的官方文档进行查看。但是我在阅读官方说明的时候，总感觉翻译的不是很准确，读起来很拗口，所以这里我是自己的理解对官方文档的一个补充。&lt;/p&gt;
&lt;h3 id=&quot;更新项目文件&quot;&gt;更新项目文件&lt;/h3&gt;
&lt;ul readability=&quot;7.9484286865431&quot;&gt;&lt;li readability=&quot;0.82758620689655&quot;&gt;
&lt;p&gt;设置&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/frameworks#referring-to-frameworks&quot;&gt;TargetFramework&lt;/a&gt;到&lt;code&gt;netcoreapp3.0&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.48387096774194&quot;&gt;
&lt;p&gt;删除&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/metapackage?view=aspnetcore-3.0&quot;&gt;Microsoft.AspNetCore.All&lt;/a&gt;或&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.0&quot;&gt;Microsoft.AspNetCore.App&lt;/a&gt;元包的任何&lt;code&gt;&amp;lt;PackageReference&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.75&quot;&gt;
&lt;p&gt;将&lt;code&gt;&amp;lt;PackageReference&amp;gt;&lt;/code&gt;元素中剩余的&lt;code&gt;Microsoft.AspNetCore.*&lt;/code&gt;程序包更新到当前的预览版中 (例如，3.0.0-preview3.19128.7)。&lt;/p&gt;
&lt;p&gt;如果没有对应的 3.0 版本的包，则说明包可能会在 3.0 中弃用。 其中许多之前都属于&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;并且不需要单独引用的包，如上面我遇到的问题，关于SQL Server的EF相关的包。 具体的不再在 3.0 中生成的包的列表，请参阅&lt;a href=&quot;https://github.com/aspnet/AspNetCore/issues/3756&quot;&gt;aspnet/AspNetCore #3756&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.7591623036649&quot;&gt;
&lt;p&gt;某些程序集已从2.x和3.0之间的Microsoft.aspnetcore.app中删除。如果您正在使用&lt;a href=&quot;https://github.com/aspnet/AspNetCore/issues/3755&quot;&gt;aspnet/AspNetCore #3755&lt;/a&gt;中列出的包中的API，则可能需要单独添加到。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;Microsoft.EntityFrameworkCore&lt;/code&gt;和&lt;code&gt;System.Data.SqlClient&lt;/code&gt;不再属于&lt;code&gt;Microsoft.AspNetCore.App&lt;/code&gt;得一部分。 Microsoft.aspnetcore.app中的程序集列表尚未定稿，将在3.0 RTM之前更改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;amp;tabs=visual-studio#json&quot;&gt;Json.NET 支持&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;项目默认为 ASP.NET Core 3.0 或更高版本设置为&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-3.0#in-process-hosting-model&quot;&gt;进程内承载模型&lt;/a&gt;。 当然，如果其值为&lt;code&gt;InProcess&lt;/code&gt;您还可以通过删除&lt;code&gt;&amp;lt;AspNetCoreHostingModel&amp;gt;&lt;/code&gt;元素，来进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;json.net-支持&quot;&gt;Json.NET 支持&lt;/h3&gt;
&lt;p&gt;作为&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/&quot;&gt;提高 ASP.NET Core 共享的框架&lt;/a&gt;工作的一部分， &lt;a href=&quot;https://www.newtonsoft.com/json/help/html/Introduction.htm&quot;&gt;Json.NET&lt;/a&gt;已从 ASP.NET Core 共享框架中删除。&lt;/p&gt;
&lt;p&gt;若要在 ASP.NET Core 3.0 项目中使用 Json.NET:&lt;/p&gt;
&lt;p&gt;Newtonsoft 的个性化设置可以设置为&lt;code&gt;AddNewtonsoftJson&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddMvc()
    .AddNewtonsoftJson(options =&amp;gt;
           options.SerializerSettings.ContractResolver =
              new CamelCasePropertyNamesContractResolver());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hostbuilder-替换-webhostbuilder&quot;&gt;HostBuilder 替换 WebHostBuilder&lt;/h3&gt;
&lt;p&gt;使用 ASP.NET Core 3.0 模板&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0&quot;&gt;泛型宿主&lt;/a&gt;。 早期版本使用&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/web-host?view=aspnetcore-3.0&quot;&gt;Web 主机&lt;/a&gt;。 下面的代码显示了生成 ASP.NET Core 3.0 模板&lt;code&gt;Program&lt;/code&gt;类：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =&amp;gt;
            {
                webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
            });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码演示模板生成 ASP.NET Core 2.2&lt;code&gt;Program&lt;/code&gt;类：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.hosting.iwebhostbuilder&quot;&gt;IWebHostBuilder&lt;/a&gt; 将保留在 3.0，是一种&lt;code&gt;webBuilder&lt;/code&gt;上面的代码示例所示。 &lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder&quot;&gt;WebHostBuilder&lt;/a&gt; 将在未来版本中弃用并替换为&lt;code&gt;HostBuilder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;WebHostBuilder&lt;/code&gt;到&lt;code&gt;HostBuilder&lt;/code&gt;最显著的变化是&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.0&quot;&gt;依赖关系注入 (DI)&lt;/a&gt;。 使用时&lt;code&gt;HostBuilder&lt;/code&gt;，只能将&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration&quot;&gt;IConfiguration&lt;/a&gt;并&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.hosting.ihostingenvironment&quot;&gt;IHostingEnvironment&lt;/a&gt;注入到&lt;code&gt;Startup&lt;/code&gt;的构造函数中。 &lt;code&gt;HostBuilder&lt;/code&gt; DI 约束：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使DI容器只能构建一次。&lt;/li&gt;
&lt;li&gt;避免产生的对象生存期问题，例如解决多个单例实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更新-signalr-代码&quot;&gt;更新 SignalR 代码&lt;/h3&gt;
&lt;p&gt;如果您调用&lt;code&gt;AddJsonProtocol&lt;/code&gt;，将其替换为&lt;code&gt;AddNewtonsoftJsonProtocol&lt;/code&gt;。&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;以下示例显示更改前后的服务器代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSignalR(...)
        .AddJsonProtocol(...) // 2.2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSignalR(...)
        .AddNewtonsoftJsonProtocol(...) // 3.0&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;以下示例显示更改前后的.NET客户端代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;connection = new HubConnectionBuilder()
    .WithUrl(...)
    .AddJsonProtocol(...) // 2.2
    .Build()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;connection = new HubConnectionBuilder()
    .WithUrl(...)
    .AddNewtonsoftJsonProtocol(...) // 3.0
    .Build()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;选择启用运行时编译&quot;&gt;选择启用运行时编译&lt;/h3&gt;
&lt;p&gt;在 3.0 中，运行时编译是可选的方案。 若要启用运行时编译，请参阅&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation&quot;&gt;ASP.NET Core 中的 Razor 文件编译&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;感觉微软在努力实现ASP.NET Core的模块化，减小各种依赖，让包变得更小。同时ASP.NET Core也已经很完善了，大伙是时候用起来ASP.NET Core了。另外需要说明的一点是，大伙如果是为了体验ASP.NET Core3.0的话，现在就可以，如果是用在生产环境的话最好还是等待正式版的发布吧。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 03:21:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>趁着假期的时间所以想重新学习下微软的官方文档来巩固下基础知识。我们都知道微软目前已经发布了.NET Core3.0的第三个预览版，同时我家里的电脑也安装了vs2019。So，就用vs2019+.NET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10661161.html</dc:identifier>
</item>
<item>
<title>机器学习 ML.NET 发布 1.0 RC - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10661117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10661117.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110415537-1930296325.png&quot;&gt;&lt;img width=&quot;119&quot; height=&quot;119&quot; title=&quot;mlnet&quot; alt=&quot;mlnet&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110415827-525188079.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dot.net/ml&quot;&gt;ML.NET&lt;/a&gt; 是面向.NET开发人员的开源和跨平台机器学习框架（Windows，Linux，macOS）,通过使用ML.NET,.NET开发人员可以利用他们现有的工具和技能组，为情感分析，推荐，图像分类等常见场景创建自定义机器学习模型，将开发自定义AI并注入其应用程序之中，微软.NET团队在官方博客[&lt;a title=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-1-0-rc-machine-learning-for-net/&quot; href=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-1-0-rc-machine-learning-for-net/&quot;&gt;https://devblogs.microsoft.com/dotnet/announcing-ml-net-1-0-rc-machine-learning-for-net/&lt;/a&gt;]发布了&lt;strong&gt;&lt;a href=&quot;https://dot.net/ml&quot;&gt;ML.NET&lt;/a&gt; 1.0 RC（Release Candidate）&lt;/strong&gt;（版本&lt;code&gt;1.0.0-preview&lt;/code&gt;）, 这是在2019年第二季度发布最终 &lt;a href=&quot;https://dot.net/ml&quot;&gt;ML.NET&lt;/a&gt; 1.0 RTM 之前的最后预览版本, 我猜测发布的时间点应该是微软5月6-8举办的 Build开发者大会上【&lt;a title=&quot;https://www.microsoft.com/en-us/build&quot; href=&quot;https://www.microsoft.com/en-us/build&quot;&gt;https://www.microsoft.com/en-us/build&lt;/a&gt;】。下图是从2018年5月份开源发布ML.NET 0.1版本以来到1.0 RTM之前的预览时间图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110416128-410527012.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;142&quot; title=&quot;allmlnetpreview&quot; alt=&quot;allmlnetpreview&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110416468-1384208012.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在此版本（&lt;a href=&quot;https://dot.net/ml&quot;&gt;ML.NET&lt;/a&gt; 1.0 RC）中，主要是API更改完成，进入稳定。对于下一个sprint，我们专注于改进文档和示例，并在需要时解决主要的关键问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ML.NET包的稳定版与预览版的分离：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dot.net/ml&quot;&gt;ML.NET&lt;/a&gt; 的包现在分成 1.0 RC 和 0.12 版本预览版，ML.NET中的大部分功能（约95％）将作为稳定版本发布，下列这些包是稳定的进入1.0 RC &lt;a title=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/index?view=ml-dotnet&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/index?view=ml-dotnet&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/index?view=ml-dotnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110416863-2110962433.png&quot;&gt;&lt;img width=&quot;612&quot; height=&quot;371&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110417278-1753695714.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一些功能在发布ML.NET 1.0时仍然不会处于RTM状态。仍保留为预览的这些功能被归类为具有该版本的预览包&lt;code&gt;0.12.0-preview：&lt;a title=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.ml?view=ml-dotnet-preview&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.ml?view=ml-dotnet-preview&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.ml?view=ml-dotnet-preview&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;主要是&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TensorFlow组件&lt;/li&gt;
&lt;li&gt;Onnx 组件&lt;/li&gt;
&lt;li&gt;TimeSeries 组件&lt;/li&gt;
&lt;li&gt;Recommendadtions 组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110417651-573140653.png&quot;&gt;&lt;img width=&quot;612&quot; height=&quot;361&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201904/510-20190406110418041-469458378.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 03:04:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>ML.NET 是面向.NET开发人员的开源和跨平台机器学习框架（Windows，Linux，macOS）,通过使用ML.NET,.NET开发人员可以利用他们现有的工具和技能组，为情感分析，推荐，图像分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10661117.html</dc:identifier>
</item>
</channel>
</rss>