<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HTML学习笔记 - 书白</title>
<link>http://www.cnblogs.com/w9er/p/10125450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w9er/p/10125450.html</guid>
<description>&lt;p&gt; 1)       结构标签&amp;lt;html&amp;gt;;&amp;lt;body&amp;gt;;&amp;lt;head&amp;gt;;&amp;lt;title&amp;gt;&amp;lt;title&amp;gt;——标题&lt;/p&gt;

&lt;p&gt;2)       防乱码标签&amp;lt;metacharset=&quot;UTF-8&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;3)       标题标签&amp;lt;h1&amp;gt;——&amp;lt;h6&amp;gt;&lt;/p&gt;

&lt;p&gt;4)       段落标签&amp;lt;p&amp;gt;&lt;/p&gt;

&lt;p&gt;5)       下划线&amp;lt;u&amp;gt;&lt;/p&gt;

&lt;p&gt;6)       删除标签&amp;lt;s&amp;gt;&lt;/p&gt;

&lt;p&gt;7)       列表标签无序列表&amp;lt;ul&amp;gt;有序列表&amp;lt;ol&amp;gt;&lt;/p&gt;

&lt;p&gt;8)       表格标签内容&lt;/p&gt;

&lt;p&gt;9)       &amp;lt;table&amp;gt;表格标签&lt;/p&gt;

&lt;p&gt;10）&amp;lt;border&amp;gt;表格线标签&lt;/p&gt;
&lt;p&gt;n  1线框solid-实线dotted-点线dashed-短横线doubt-双线&lt;/p&gt;
&lt;p&gt;n  2边框颜色&lt;/p&gt;
&lt;p&gt;n  3边框宽度&lt;/p&gt;
&lt;p&gt;n  &amp;lt;align&amp;gt;在网页中位置标签&lt;/p&gt;
&lt;p&gt;n  &amp;lt;width&amp;gt;宽度&lt;/p&gt;
&lt;p&gt;n  &amp;lt;height&amp;gt;高度&lt;/p&gt;
&lt;p&gt;n  &amp;lt;cellpadding&amp;gt;单元格间距&lt;/p&gt;
&lt;p&gt;n  &amp;lt;cellspacing&amp;gt;表格线间&lt;/p&gt;
&lt;p&gt;n  &amp;lt;tr&amp;gt;行&lt;/p&gt;
&lt;p&gt;n  &amp;lt;td&amp;gt;列&lt;/p&gt;
&lt;p&gt;n  &amp;lt;th&amp;gt;__表格里标题标签—有加粗，和居中效果可充当&amp;lt;td&amp;gt;&lt;/p&gt;
&lt;p&gt;插入图片&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;colspan=&quot;5&quot;是合并五列的意思，表示这个单元格要占五列&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;rowspan=&quot;3&quot;是合并三行的意思，表示这个单元格要占三行&lt;/p&gt;

&lt;p&gt;&amp;lt;imgsrc=&quot;图片名称&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;tr&amp;gt;&amp;lt;tdrowspan=&quot;&quot;&amp;gt;合并单元格——行&lt;/p&gt;
&lt;p&gt;&amp;lt;tr&amp;gt;&amp;lt;tdcolspan=&quot;&quot;&amp;gt;合并单元格——列&lt;/p&gt;
&lt;p&gt;p{color:;&lt;/p&gt;
&lt;p&gt;width:____段落长度&lt;/p&gt;
&lt;p&gt;text-indent：首行缩进大小&lt;/p&gt;
&lt;p&gt;font-size：字体大小&lt;/p&gt;
&lt;p&gt;text-decoration：underline;-段落下划线&lt;/p&gt;
&lt;p&gt;line-height:行高&lt;/p&gt;
&lt;p&gt;text-align文本对齐方式centerorleft、reight&lt;/p&gt;

&lt;p&gt;html表单标签：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;inputtype=&quot;text&quot;/&amp;gt;&amp;lt;inputtype=&quot;button&quot;value=&quot;我是按钮&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;搜索框&lt;/p&gt;
&lt;p&gt;Value后加标签名称&lt;/p&gt;
&lt;p&gt;Button按钮&lt;/p&gt;
&lt;p&gt;Type=”text”—文本框&lt;/p&gt;
&lt;p&gt;鼠标属性：手型cursor:pointer;&lt;/p&gt;

&lt;p&gt;CSS知识点&lt;/p&gt;

&lt;p&gt;内部样式表&lt;/p&gt;
&lt;p&gt;&amp;lt;styletype=&quot;text/css&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;a&gt;&lt;span&gt;[王1]&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;body{&lt;/p&gt;
&lt;p&gt;color:color前可加下面的文字前标签名来确定颜色&lt;/p&gt;
&lt;p&gt;font-size:________字体大小列入&lt;/p&gt;
&lt;p&gt;h1{color:&quot;&quot;;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;类选择器&amp;lt;h1class=&quot;小的类名&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;font-family:&quot;字体&quot;&lt;/p&gt;
&lt;p&gt;font-weight：bold；粗细&lt;/p&gt;
&lt;p&gt;font-style：italic；倾斜&lt;/p&gt;
&lt;p&gt;margin=0auto&lt;/p&gt;
&lt;p&gt;overflow：hidden？&lt;/p&gt;
&lt;p&gt;*{margin=0&lt;/p&gt;
&lt;p&gt;Padding=0}&lt;/p&gt;
&lt;p&gt;position=absolute——绝对定位在浏览器中右上角为（0,0）lefttop&lt;/p&gt;
&lt;p&gt;position=relative——相对定位相对于之前的位置做出移动，以图形本来位置的右上&lt;/p&gt;
&lt;p&gt;角为（0,0）&lt;/p&gt;


&lt;p&gt;——————在上一级中相对定位可以，可以改变下一级的绝对定位的原点&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;外部样式表标签style.css---外部表格&lt;/p&gt;
&lt;p&gt;&amp;lt;linkhref=&quot;style.css&quot;rel=&quot;stylesheet&quot;type=&quot;text/css&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;行内元素：加粗，倾斜&lt;/p&gt;
&lt;p&gt;块级元素(可设置宽高)：标题标签，块级标签&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一、块级标签&lt;/p&gt;
&lt;p&gt;1.独占一行，不和其他元素待在同一行给定要居中的块级元素的宽度。块级标签居中的不同方式margin0auto&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.能设置宽高&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;常见的块级标签：div,p,h1-h6,ul,li,dl,dt,dd&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;代码：&amp;lt;p&amp;gt;我们是p标签&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;p&amp;gt;我们是p标签&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;p&amp;gt;我们是p标签&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在浏览器打开显示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二、行级标签&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.能和其他元素待在同一行&lt;/p&gt;
&lt;p&gt;2.不能设置宽高①设置display:block；②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置）行内元素text-align文本方式对齐&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;常见的行级标签：a，span,strong,u,em--&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;代码：&amp;lt;ahref=&quot;&quot;&amp;gt;hello&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;ahref=&quot;&quot;&amp;gt;hello&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;ahref=&quot;&quot;&amp;gt;hello&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;三、行内块标签&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.能和其他元素待在一行&lt;/p&gt;
&lt;p&gt;2能设置宽高：设置display:block。（如input、button、img等元素，自带宽度可以不用设置其宽度）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;常见的行内块标签：img,input,textarea&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;代码：&amp;lt;imgsrc=&quot;meinv.jpg&quot;/&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;imgsrc=&quot;liang.jpg&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;overlow：hidden；div达不到你想要的结果&lt;/p&gt;
&lt;p&gt;margin:0auto；在不同场景下生效条件如下：&lt;/p&gt;
&lt;div&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;7.9351265822785&quot;&gt;
&lt;div readability=&quot;11.20253164557&quot;&gt;
&lt;p&gt; &lt;a&gt;&lt;span&gt;[王1]&lt;/span&gt;&lt;/a&gt;它是CSS样式的标记。&lt;br/&gt;type-&amp;gt;类型,这里是style的属性&lt;br/&gt;text/css-&amp;gt;文本/css,即css文本&lt;br/&gt;type=&quot;text/css&quot;表示的是浏览器的解释方式，如果不定义的话，有些CSS效果浏览器解释得不一样。&lt;br/&gt;&amp;lt;styletype=&quot;text/css&quot;&amp;gt;&amp;lt;/style&amp;gt;&lt;br/&gt;HTML&lt;a href=&quot;https://www.baidu.com/s?wd=%E5%86%85%E9%83%A8%E6%A0%B7%E5%BC%8F%E8%A1%A8&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot;&gt;内部样式表&lt;/a&gt;，位于&amp;lt;head&amp;gt;与&lt;br/&gt;&amp;lt;/head&amp;gt;之间&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 15 Dec 2018 15:56:00 +0000</pubDate>
<dc:creator>书白</dc:creator>
<og:description>1) 结构标签&lt;html&gt;;&lt;body&gt;;&lt;head&gt;;&lt;title&gt;&lt;title&gt;——标题 2) 防乱码标签&lt;metacharset</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w9er/p/10125450.html</dc:identifier>
</item>
<item>
<title>数据量庞大的分页穿梭框实现 - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/10125443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/10125443.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/63&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/63&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天偶然看到评论区一位老哥的需求，一时兴起，就答应了当天写好源码写个博客&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;回来的晚，第二天才写好。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1154520/8v38d5pes7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写个分页的穿梭框，从而解决数据量庞大的问题&lt;/p&gt;
&lt;p&gt;我之前写过一篇博客：&lt;a href=&quot;https://ainyi.com/#/57&quot;&gt;关于 Element 组件的穿梭框的重构&lt;/a&gt; 介绍并实现的方法&lt;/p&gt;
&lt;p&gt;但是第二个分页的 demo 没有，在上一家公司匆匆解决后，没有写入自己的 GitHub，有点可惜...&lt;/p&gt;
&lt;p&gt;当时可是在上班，而且太忙了，不过既然答应了这位老哥写个 demo，就要做到，也是给自己一个挑战&lt;/p&gt;
&lt;h2 id=&quot;进入正题&quot;&gt;进入正题&lt;/h2&gt;
&lt;p&gt;看实现效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1154520/q1lez7emuv.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然之前博客谈过，这里就不仔细谈了，主要放主要的源码&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;Element 官方组件目前（==18年==）明显对于多选==三级联动的穿梭框==没有解决方案，也对==数据量庞大的穿梭框==没有结局方案（各位看官可以试一下，放入几千条数据到穿梭框，卡到爆...），遂只能自己重写组件，完成业务需求&lt;/p&gt;
&lt;h2 id=&quot;功能&quot;&gt;功能&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;实现分页&lt;/li&gt;
&lt;li&gt;搜索，做成在所有数据里搜索，不是在当前分页的数据里搜索，这样就不用在每个分页都搜索一次了。搜索后的结果也会自动分页。（全部数据和仅作展示的数据存都是存放在不同变量）&lt;/li&gt;
&lt;li&gt;全选只在当前页里的全选&lt;/li&gt;
&lt;li&gt;穿梭框左右两个框的联动&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;关键点&quot;&gt;关键点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;每个框作为一个子组件（组件化思想）&lt;/li&gt;
&lt;li&gt;分页关键判断临界点&lt;/li&gt;
&lt;li&gt;搜索，监听 keyword 的变化，传递到父组件搜索，从全局数据搜索&lt;/li&gt;
&lt;li&gt;把备选的数据当做已选的过滤数组，把已选的数据当做备选的过滤数组，在全局 data 进行过滤，最后再进行一次搜索（备选、已选）（考虑到是在搜索过后点击的）&lt;/li&gt;
&lt;li&gt;中间的左右箭头（加入已选和移除已选）放在父组件控制数据流动&lt;/li&gt;
&lt;li&gt;数据流动：子备选框 -&amp;gt; 父组件 -&amp;gt; 子已选框 （移除已选相反）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Districts.vue（包裹两个穿梭框的父组件）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;export default {
  props: {
    data: {
      type: Array,
    },
  },
  data () {
    return {
      dataList: [], // 未选中（已过滤出已选)的数据
      selectList: [], // 已选中的数据，传递到子组件的数据

      dataListNoCheck: [], // 未选中的（或已搜索）传递到子组件的数据
      selectListCheck: [], // 已选中的（或已搜索）传递到子组件的数据

      checkData: [], // 已勾选的数据（待添加或删除数据)

      noSelectkeyword: '',
      haSelectkeyword: '',

      disablePre: true,
      disableNex: true,
    };
  },
  created () {
    this.getDistrict();
  },
  methods: {
    // 分页数据
    getDistrict () {
      this.dataList = this.data;
      this.dataListNoCheck = this.dataList;
    },
    searchWord (keyword, titleId) {
      // 过滤掉数据，保留搜索的数据
      if (titleId === 0) {
        this.noSelectkeyword = keyword;
        this.dataListNoCheck = this.dataList.filter(val =&amp;gt; val.name.includes(keyword));
      } else {
        this.haSelectkeyword = keyword;
        this.selectListCheck = this.selectList.filter(val =&amp;gt; val.name.includes(keyword));
      }
      let refsName = titleId === 0 ? 'noSelect' : 'hasSelect';
      // 延迟执行
      setTimeout(() =&amp;gt; {
        this.$refs[refsName].getDistrict();
      }, 0);
    },
    // 检查左右按钮可用性
    checkDisable (data, id) {
      if (id === 0) {
        data.length &amp;gt; 0 ? (this.disableNex = false) : (this.disableNex = true);
      } else {
        data.length &amp;gt; 0 ? (this.disablePre = false) : (this.disablePre = true);
      }
    },
    // 选择
    checkSelect (val) {
      this.checkData = val;
    },
    // 关键：把未选择的数据当做已选择的过滤数组，把已选择的数据当做未选择的过滤数组，在全局data进行过滤，最后进行一次搜索
    // 添加至已选
    addData () {
      let dataFilter = [
        ...this.selectList,
        ...this.checkData,
      ];
      this.dataList = this.data.filter(item1 =&amp;gt; {
        return dataFilter.every(item2 =&amp;gt; item2 !== item1);
      });
      this.selectList = this.data.filter(item1 =&amp;gt; {
        return this.dataList.every(item2 =&amp;gt; item2 !== item1);
      });
      // 搜索一次
      this.searchWord(this.noSelectkeyword, 0);
      this.searchWord(this.haSelectkeyword, 1);
    },
    // 从已选中删除
    deleteData () {
      let dataFilter = [
        ...this.dataList,
        ...this.checkData,
      ];
      this.selectList = this.data.filter(item1 =&amp;gt; {
        return dataFilter.every(item2 =&amp;gt; item2 !== item1);
      });
      this.dataList = this.data.filter(item1 =&amp;gt; {
        return this.selectList.every(item2 =&amp;gt; item2 !== item1);
      });
      // 搜索一次
      this.searchWord(this.noSelectkeyword, 0);
      this.searchWord(this.haSelectkeyword, 1);
    },
  },
  components: {
    Transfer,
  },
};
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Transfer.vue（穿梭框子组件）&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;export default {
  props: {
    titleId: {
      type: Number,
    },
    districtList: { // 父组件传递的数据
      type: Array,
    },
  },
  data () {
    return {
      title: ['渠道', '已选中'],
      districtListMock: [], // 展示的数据 （搜索和分页会自动修改这个数组）
      checkedCities: [], // 已选择，数据格式：[id,id,id...]
      isIndeterminate: false,
      checkAll: false,
      searchWord: '',
      len: 0,
      total: 0,
      pageIndex: 0,
      disabledPre: true,
      disabledNex: false,
    };
  },
  created () {
    this.getDistrict();
  },
  watch: {
    // 搜索框的监听器
    searchWord (newWord) {
      this.$emit('search-word', newWord, this.titleId);
    },
    // districtListMock 和 checkAll 的监听器
    districtListMock () {
      // 当方框中无已选择的数据时，不能勾选checkBox
      if (this.checkedCities.length === 0) {
        this.checkAll = false;
        this.isIndeterminate = false;
      }
    },
    checkedCities (newWord) {
      this.$emit('check-disable', newWord, this.titleId);
    },
    // 当列表中无数据时，不能勾选checkBox
    checkAll () {
      this.checkAll = this.districtListMock.length === 0 ? false : this.checkAll;
    },
  },
  methods: {
    // 分页数据
    getDistrict () {
      this.len = this.districtList.length;
      this.total = Math.ceil(this.len / 200);
      this.pageIndex = 0;
      this.pageData();
    },
    pageData () {
      this.checkedCities = [];
      if (this.total &amp;gt; 1 &amp;amp;&amp;amp; this.pageIndex &amp;lt; (this.total - 1)) {
        this.pageIndex === 0 ? this.disabledPre = true : this.disabledPre = false;
        this.disabledNex = false;
        this.districtListMock = this.districtList.slice(this.pageIndex \\* 200, this.pageIndex \\* 200 + 200);
      } else {
        this.total &amp;gt; 1 ? this.disabledPre = false : this.disabledPre = true;
        this.disabledNex = true;
        this.districtListMock = this.districtList.slice(this.pageIndex \\* 200, this.len);
      }
    },
    // 上一页
    prev () {
      this.pageIndex &amp;gt; 0 &amp;amp;&amp;amp; --this.pageIndex;
      this.pageData();
    },
    // 下一页
    next () {
      this.pageIndex &amp;lt;= (this.total - 1) &amp;amp;&amp;amp; ++this.pageIndex;
      this.pageData();
    },
    // 单选
    handleCheckedChange (value) {
      let checkedCount = value.length;
      this.checkAll = checkedCount === this.districtListMock.length;
      this.isIndeterminate = checkedCount &amp;gt; 0 &amp;amp;&amp;amp; checkedCount &amp;lt; this.districtListMock.length;
      // 子传父
      this.$emit('check-district', value);
    },
    // 全选
    handleCheckAllChange (val) {
      this.checkedCities = val ? this.districtListMock.map(val =&amp;gt; val) : [];
      this.isIndeterminate = false;
      // 子传父
      this.$emit('check-district', this.checkedCities);
    },
  },
};
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体源码可前往 Github：&lt;a href=&quot;https://github.com/Krryxa/my-transfer&quot; class=&quot;uri&quot;&gt;https://github.com/Krryxa/my-transfer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎 start&lt;/p&gt;
&lt;p&gt;呼呼，双休好好休息了~~&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/63&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/63&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 15:54:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/10125443.html</dc:identifier>
</item>
<item>
<title>线程并行学习笔记 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10125358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10125358.html</guid>
<description>&lt;h3 id=&quot;一线程并行相关概念&quot;&gt;一、线程并行相关概念&lt;/h3&gt;
&lt;h4 id=&quot;同步synchronous和异步asynchronous&quot;&gt;同步(Synchronous)和异步(Asynchronous)&lt;/h4&gt;
&lt;p&gt;同步和异步的本质区别是是否需要等待，比如一个方法在执行，必须等前面一个方法程执行完成，才可以执行，这就是同步。如果不需要等上一个方法执行完成，并行或者并发执行，这就是异步调用。&lt;/p&gt;
&lt;h4 id=&quot;并发concurrency和并行parallelism&quot;&gt;并发(Concurrency)和并行(Parallelism)&lt;/h4&gt;
&lt;p&gt;并发和并行两个概念很容易混淆。解释起来意思也差不多，不过说起来，并行才是真正意义上的并行执行，并发只是线程的交替执行，有可能存在串行的情况。&lt;/p&gt;
&lt;p&gt;在单核CPU的系统，线程只能是并发的，而不能支持并行，并行执行只能存在与多核CPU的系统。&lt;/p&gt;
&lt;h4 id=&quot;临界区&quot;&gt;临界区&lt;/h4&gt;
&lt;p&gt;临界区，可以理解为公共的资源或者说共享数据。临界区具有保护性，也就是说，只能一个线程占用临界区，一旦一个线程占了临界区，另外一个线程是不予许再占用的，必须等线程释放了才行。&lt;/p&gt;
&lt;h4 id=&quot;阻塞blocking和非阻塞non-blocking&quot;&gt;阻塞(Blocking)和非阻塞(Non-Blocking)&lt;/h4&gt;
&lt;p&gt;阻塞是线程的一种比较严重的情况，从前面我们知道了临界区只能允许一个线程占用，假如一个线程因为执行时间过长，占用了临界区，不挂起，其它想要占用临界区的线程只能等待，这种情况就容易造成线程阻塞。非阻塞的话就相反了，指所有线程都正常执行，不会出现线程占临界区不挂起的情况。&lt;/p&gt;
&lt;h4 id=&quot;饥饿starvation死锁deadlock和活锁livelock&quot;&gt;饥饿(Starvation)、死锁(Deadlock)和活锁(Livelock)&lt;/h4&gt;
&lt;p&gt;饥饿，有些情况可能是一个线程优先级太低了，每次都被其它线程占用了，导致改线程一种不能占用临界区。也有一些情况是上一个线程执行时间太长了，一直没释放，导致其它线程都不能占用临界区，这也是造成线程饥饿。&lt;/p&gt;
&lt;p&gt;死锁有可能是因为线程死循环调用等等情况造成的，一旦出现这种情况估计就得人工排查了。&lt;/p&gt;
&lt;p&gt;活锁，解释一下，一般就是这样的情况，因为线程互相挂起临界区，给其它线程用，互相“谦让”，导致资源在两个或者几个线程之间跳到，这种情况就是活锁。&lt;/p&gt;
&lt;h3 id=&quot;二并行的两个重要定律&quot;&gt;二、并行的两个重要定律&lt;/h3&gt;
&lt;h4 id=&quot;amdahi定律&quot;&gt;Amdahi定律&lt;/h4&gt;
&lt;p&gt;Amdahi定律定义了串行系统并行化后的加速比公式。&lt;/p&gt;
&lt;p&gt;加速比定义：加速比 = 优化前系统耗时 / 优化后系统耗时&lt;/p&gt;
&lt;p&gt;加速比越高，说明优化越明显。简单介绍一下Amdahi定律公式的推导。&lt;br/&gt;优化后耗时T_n＝T1(F+1/n(1-F))，其中T1表示优化前耗时，F表示串行比例，(1-F)表示并行比例，下标n就是处理器的个数。&lt;br/&gt;导入加速比公式，也就是T1/T_n，也就是1/(F + 1/n(1-F))，公式只是进行简单介绍。&lt;/p&gt;
&lt;p&gt;从公式可以看出，加速比是和串行比例F成反比的，从公式可以看出增加cpu的个数仅仅是一种提供加速比的方法，增加cpu个数的同时，还可以提供降低串行比例来做，也就是串行比例F越低，加速比也就越高&lt;/p&gt;
&lt;h4 id=&quot;gustafson定律&quot;&gt;Gustafson定律&lt;/h4&gt;
&lt;p&gt;Custafson公式也是并行的一个比较重要的公式，现在介绍一下Custafson公式的推导。&lt;/p&gt;
&lt;p&gt;定义一下串行执行时间为a，并行执行时间为b。即单核CPU情况，执行时间为a+b总执行时间为a+nb，n表示CPU个数。&lt;/p&gt;
&lt;p&gt;//定义串行比例&lt;br/&gt;F=a/(a+b)&lt;/p&gt;
&lt;p&gt;//得到加速比&lt;br/&gt;s(n)=a+nb/a+b=a/a+b + nb/a+b = F + n*(b-a+a)/a+b = F + n(1-F)&lt;/p&gt;
&lt;p&gt;从公式可以看出，如果串行比例足够小的情况，加速比其实就是约等于处理器个数，也就是说通过加多CPU的个数就能提高加速比。&lt;/p&gt;
&lt;p&gt;两个公式看起来似乎有点矛盾，其实不然，两个公式只是从不同角度分析问题。Amdahi是说在串行比例一定时，通过加CPU的方法是有上限的，通过降低串行比例同时增加cpu个数可以提高加速比。Custafson是说在串行比较趋于很小的情况，从公式可以看出，加cpu就可以提高加速比&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 15:18:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>一、线程并行相关概念 同步(Synchronous)和异步(Asynchronous) 同步和异步的本质区别是是否需要等待，比如一个方法在执行，必须等前面一个方法程执行完成，才可以执行，这就是同步。如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10125358.html</dc:identifier>
</item>
<item>
<title>根据时间戳，增量同步数据的解决办法 - 顺风椰子皮</title>
<link>http://www.cnblogs.com/BenAndWang/p/10125142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BenAndWang/p/10125142.html</guid>
<description>&lt;p&gt;由于markdown的样式太丑了，懒得再调整了，我另外再贴一个github的博客&lt;a href=&quot;https://mrbenwang.github.io/post/0024-incremen-sync-by-datetime/&quot;&gt;该文的 github链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近在工作中遇到一个比较棘手的问题，客户端从服务端同步数据的问题。&lt;br/&gt;背景简介：客户端有N个，客户端上的同步时间，各不相同。同步的时候，是一次获取10条数据，多批次获取。即分页获取。&lt;br/&gt;在代码中存在两种同步的方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全量同步。同步过程是从服务端拉取全部的数据；依赖具有&lt;code&gt;唯一约束&lt;/code&gt;的&lt;code&gt;ID&lt;/code&gt;来实现同步。只适用于数据量小的表，浪费网络流量。&lt;/li&gt;
&lt;li&gt;增量同步。从服务器拉取&lt;code&gt;大于&lt;/code&gt;客户端&lt;code&gt;最新时间&lt;/code&gt;的数据；依赖于&lt;code&gt;时间戳&lt;/code&gt;，问题时间戳&lt;code&gt;不唯一&lt;/code&gt;存在相同时间点下面多条数据，会出现数据遗漏，也会重复拉取数据，浪费网络流量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文的所使用到的解决办法，就是结合了&lt;strong&gt;唯一ID&lt;/strong&gt;和&lt;strong&gt;时间戳&lt;/strong&gt;，两个入参来做增量同步。本文也只做逻辑层面的说明。&lt;/p&gt;
&lt;h2 id=&quot;模拟场景&quot;&gt;模拟场景&lt;/h2&gt;
&lt;p&gt;表结构：ID 具有唯一约束， Name 姓名， UpdateTime 更新时间；现在问题的关键是ID为3，4，这两条时间点相同的数据。&lt;br/&gt;假如一次只能同步一条数据，如何同步完ID 2后，再同步 ID 3。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;张三&lt;/td&gt;
&lt;td&gt;2018-11-10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;李四&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2018-12-10&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;王五&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2018-12-10&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;赵六&lt;/td&gt;
&lt;td&gt;2018-11-20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;金七&lt;/td&gt;
&lt;td&gt;2018-11-30&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;解决思路&quot;&gt;解决思路&lt;/h2&gt;
&lt;h3 id=&quot;生成新的唯一标识&quot;&gt;&lt;del&gt;生成新的唯一标识&lt;/del&gt;&lt;/h3&gt;
&lt;p&gt;通过 UpdateTime 和 ID 这两种数据，通过某种运算，生成新的数。而这个&lt;code&gt;新的数&lt;/code&gt;具备&lt;strong&gt;可排序&lt;/strong&gt;和&lt;strong&gt;唯一&lt;/strong&gt;；同时还要携带有&lt;code&gt;ID&lt;/code&gt;和&lt;code&gt;UpdateTime&lt;/code&gt;的信息。&lt;br/&gt;简单表述就是，具有一个函数f： &lt;strong&gt;f(可排序A，可排序唯一B) = 可排序唯一C&lt;/strong&gt; 。 C 的唯一解是 A和B。&lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;RSA加密算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想出了一个方法，也是生活中比较常用的方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先把 UpdateTime 转变成数字。如： 字符串 2018-12-10 -&amp;gt; 数字 20181210;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后 UpdateTime 乘以权重，这个&lt;code&gt;权重&lt;/code&gt;必须大于&lt;code&gt;ID&lt;/code&gt;的可能最大值。如： 20181210 * 100 = 2018121000，Max(ID)&amp;lt;999&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后再把第二部的结果，加上唯一键&lt;code&gt;ID&lt;/code&gt;。如： 2018121000 + 3 = 2018121003。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个时候，&lt;strong&gt;2018121003&lt;/strong&gt; 这个数，既包含了&lt;code&gt;UpdateTime&lt;/code&gt;和&lt;code&gt;ID&lt;/code&gt;的信息，又具有&lt;strong&gt;可排序&lt;/strong&gt;和&lt;strong&gt;唯一性&lt;/strong&gt;。用它作为增量更新的判断点，是再好不过的了。&lt;br/&gt;但是它具有很大的缺点：数字太大了，时间转化成数字，目前还是用的是&lt;strong&gt;天&lt;/strong&gt;级别，如果换成&lt;strong&gt;毫秒&lt;/strong&gt;级别呢。还有ID可能的最大值也够大了，如果是&lt;strong&gt;int64&lt;/strong&gt;那就更没得搞了。&lt;/p&gt;
&lt;p&gt;这个方法理论上可行，实际中不可用基本不可行，除非找到一种非常好的函数f；&lt;br/&gt;&lt;em&gt;PS: 我的直觉告诉我： 极可能存在这种函数，既满足我的需要，又可以克服数字很大这个问题。只是我目前不知道。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据库表修改不推荐&quot;&gt;数据库表修改(不推荐)&lt;/h3&gt;
&lt;h4 id=&quot;修改数据内容&quot;&gt;修改数据内容&lt;/h4&gt;
&lt;p&gt;修改数据内容，使 &lt;code&gt;UpdateTime&lt;/code&gt; 数据值唯一。缺点也比较明显：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;脚本操作数据的情况下，或者直接sql更新。可能会，造成时间不唯一；&lt;/li&gt;
&lt;li&gt;只是适用在数据量小，系统操作频率小的情况下。因为毫秒级别的时间，在绝大多数软件系统中，可以认为是唯一；&lt;/li&gt;
&lt;li&gt;尤其是老旧项目，历史遗留数据如何处理。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;增加字段&quot;&gt;增加字段&lt;/h4&gt;
&lt;p&gt;还有一种办法，就是在数据库中，增加一个新的字段，专门用来同步数据的时候使用。&lt;br/&gt;比方说，增加字段 &lt;code&gt;SyncData&lt;/code&gt; int 类型。如果 UpdateTime 发生了改变，就把它更新为 &lt;code&gt;SyncData = Max(SyncData) + 1&lt;/code&gt;;&lt;br/&gt;也就是说， &lt;code&gt;SyncData&lt;/code&gt; 这个字段的最大值&lt;strong&gt;一定是&lt;/strong&gt;最新的数据，&lt;code&gt;SyncData&lt;/code&gt;的降序就是 更新时间的降序。&lt;code&gt;SyncData&lt;/code&gt;是&lt;code&gt;更新时间顺序&lt;/code&gt;的&lt;strong&gt;充分不必要条件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总的来说，这种办法是比较好的，但缺点也比较明显：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要修改表结构，并且额外维护这个字段；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;新增或者更新的时候，会先锁表，找出这个表的最大值，再更新，资源浪费明显。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果表的数据量比较大，或者更新比较频繁时候。时间消耗较大。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;我的解决方法&quot;&gt;我的解决方法&lt;/h3&gt;
&lt;h4 id=&quot;分页提取数据的可能情况&quot;&gt;分页提取数据的可能情况&lt;/h4&gt;
&lt;p&gt;首先，先来分析一下，一次提取10条数据，提取的数据，存在的可能情况。再次说明&lt;strong&gt;前提&lt;/strong&gt;，先时间倒序，再ID倒序。&lt;code&gt;Order By UpdateTime DESC, ID DESC&lt;/code&gt;&lt;br/&gt;可能情况如下图，可以简化为三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;情景1。当前获取的数据中包含了，&lt;strong&gt;所有&lt;/strong&gt;相同时间点的数据；图1，图5&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;情景2。当前获取的数据中包含了，&lt;strong&gt;部分&lt;/strong&gt;相同时间点的数据；图2，图3，图4，图6，图7&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;情景3。当前获取的数据中包含了，&lt;strong&gt;没有&lt;/strong&gt;相同时间点的数据；图···&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中&lt;code&gt;情景1&lt;/code&gt;和&lt;code&gt;情景3&lt;/code&gt;，可以把查询条件变为：&lt;code&gt;WHERE UpdateTime &amp;gt; sync_time LIMIT 10&lt;/code&gt;&lt;br/&gt;但是&lt;code&gt;情景2&lt;/code&gt;的情况不能使用大于&lt;code&gt;&amp;gt;&lt;/code&gt;这个条件。假如使用了大于&lt;code&gt;&amp;gt;&lt;/code&gt;这个条件，&lt;code&gt;情景2&lt;/code&gt;就会变成&lt;code&gt;情景1&lt;/code&gt;或&lt;code&gt;情景3&lt;/code&gt;或&lt;code&gt;图3&lt;/code&gt;这种情况。不是包含&lt;strong&gt;部分&lt;/strong&gt;了，需要额外特别处理。&lt;br/&gt;注：图3的&lt;code&gt;结束点 ]&lt;/code&gt;不重要，下面情景5有解释。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/286936/201812/286936-20181215222308890-1352176373.jpg&quot; alt=&quot;同步数据的可能性&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;情景2部分情况提取的起始点&quot;&gt;情景2部分情况，提取的起始点&lt;/h4&gt;
&lt;p&gt;提取的起始点：也就是说图中&lt;code&gt;[&lt;/code&gt;&lt;strong&gt;左中括号&lt;/strong&gt;的位置，需要准确定位这个位置。&lt;br/&gt;至于结束点：图中&lt;code&gt;]&lt;/code&gt;&lt;strong&gt;右中括号&lt;/strong&gt;的位置是在哪里。这个就不重要了，因为下一次的分页提取的&lt;code&gt;起始点&lt;/code&gt;，就是&lt;strong&gt;上一次的结束点&lt;/strong&gt;。只需要关注起始点就足够了。&lt;/p&gt;
&lt;p&gt;而根据起始点，又可以把&lt;code&gt;情景2&lt;/code&gt;，再做一次简化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;情景4。起始点&lt;strong&gt;在&lt;/strong&gt;相同时间点集合内的；图2，图4，图6，图7&lt;/li&gt;
&lt;li&gt;情景5。起始点&lt;strong&gt;不在&lt;/strong&gt;相同时间点集合内的；图3，&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;针对&lt;code&gt;情景4&lt;/code&gt;。这个时候，时间戳&lt;code&gt;sync_time&lt;/code&gt;一个入参就不够了，还额外需要&lt;strong&gt;唯一键&lt;/strong&gt;ID来准确定位。可以把查询写作：&lt;code&gt;WHERE UpdateTime = sync_time AND ID &amp;gt; sync_id LIMIT 10&lt;/code&gt;。&lt;br/&gt;如果查询的行数 &lt;strong&gt;等于&lt;/strong&gt; 10，则是图4；&lt;strong&gt;小于&lt;/strong&gt; 10，则是图2，图6，图7的情况。&lt;/p&gt;
&lt;p&gt;针对&lt;code&gt;情景5&lt;/code&gt;。依旧可以使用：&lt;code&gt;WHERE UpdateTime &amp;gt; sync_time LIMIT 10&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;完整的分页过程&quot;&gt;完整的分页过程&lt;/h4&gt;
&lt;p&gt;完整的分页过程的步骤：&lt;br/&gt;一、先用起始点来过滤：&lt;code&gt;WHERE UpdateTime = sync_time AND ID &amp;gt; sync_id LIMIT 10&lt;/code&gt;，查询结果行数N。如果 &lt;code&gt;N=10 或 N=0&lt;/code&gt;，则结束，并且直接返回结果。如果 &lt;code&gt;0&amp;lt; N &amp;lt;10&lt;/code&gt; ,则进行第二步；&lt;/p&gt;
&lt;p&gt;二、再用时间戳查询：&lt;code&gt;WHERE UpdateTime &amp;gt; sync_time LIMIT 10-N&lt;/code&gt;，查询结果行数 M ，&lt;code&gt;0&amp;lt;= M &amp;lt;=10-N&lt;/code&gt;；这个阶段，是否同一个时间点都不重要了。只需要按着顺序取&lt;strong&gt;已排序&lt;/strong&gt;的数据就可以了；&lt;/p&gt;
&lt;p&gt;三、把一和二的结果集合并，一并返回。&lt;/p&gt;
&lt;p&gt;四、重复步骤一二三，直到，分页获取的最后一条数据的&lt;code&gt;ID&lt;/code&gt;，是服务端数据库中最新的ID；(防止存在，恰好这十条是所需要获取的最后十条)。&lt;/p&gt;
&lt;p&gt;服务端中最新ID获取：&lt;code&gt;Select Id From myTable Order by UpdateTime desc,ID desc Limit 1&lt;/code&gt;;&lt;/p&gt;
&lt;h2 id=&quot;经验总结&quot;&gt;经验总结&lt;/h2&gt;
&lt;p&gt;寻找&lt;strong&gt;关键信息&lt;/strong&gt;，以及具有&lt;strong&gt;指标意义&lt;/strong&gt;的数据，或者&lt;strong&gt;数据的组合&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最开始，我只执着于 UpdateTime 这个数据，甚至提出去数据库中，修改历史数据，再把 UpdateTime 加上唯一约束(以前也没有听说过在 UpdateTime 这个字段上面加唯一约束)。并且这种办法，局限性有很强，不可以通用。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;主键ID唯一，但是它不具有时间属性。只适用于全部更新。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;把他们两个结合起来，才算是打开了新的思路。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;拆分&lt;/strong&gt;问题，&lt;strong&gt;简化&lt;/strong&gt;问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把 UpdateTime 和 ID 组合使用时。妄图在一个sql里面来实现。发现无论怎么改，都会存在逻辑上面的问题；&lt;/li&gt;
&lt;li&gt;没有拆分化简的时候，如果用存储过程来写的话，会非常非常复杂；&lt;/li&gt;
&lt;li&gt;直到，我在脑袋里面，模拟出来可能的情况后。也就是上面的图片&lt;code&gt;同步数据的可能性&lt;/code&gt;，慢慢归类，简化后；才发现。问题没有那么难，仅仅是&lt;strong&gt;起始点&lt;/strong&gt;这一个小小的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;strong&gt;逻辑分析&lt;/strong&gt;和&lt;strong&gt;哲学归纳&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在分析数据的意义和性质的时候，偶然间使用到了归纳的方法；也就是&lt;code&gt;唯一&lt;/code&gt;和&lt;code&gt;可排序&lt;/code&gt;；跳出了具体字段，使用场景的框架束缚，而去考虑这两种性质怎么结合的问题；&lt;/li&gt;
&lt;li&gt;在逻辑分析的时候，先用排列组合，算出多少种可能性；在脑中勾画出图形，把性质相同的可能性合并化简；&lt;/li&gt;
&lt;li&gt;在化简的过程中，不要仅仅着眼于查询的对象，也要去化简&lt;code&gt;查询的方法&lt;/code&gt;；有点绕，打个比方，既要优化最终产品，也要去优化制作工艺；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，我认为我最近的逻辑分析能力，好像有比较大的提升。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接得益于，常见的24种逻辑谬误的了解，&lt;a href=&quot;https://mrbenwang.github.io/post/0020-logical-fallacy-list-foreword/&quot;&gt;【转】逻辑谬误列表(序言)&lt;/a&gt;，在平常的生活中，说话做事，也就有了逻辑方面的意识；&lt;/li&gt;
&lt;li&gt;间接可能得益于台大哲学系苑举正，苑老师讲话的视频。其实我很早以前，高中时候就喜欢哲学，《哲学的基本原理》这么枯燥的书，我居然认认真真仔仔细细的边读边想的看了三四遍。只是那时好多完全不懂，好多似懂非懂。十多年后虽然什么都不记得了，但是好像又懂了。。。感觉太玄了。。。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 15 Dec 2018 15:06:00 +0000</pubDate>
<dc:creator>顺风椰子皮</dc:creator>
<og:description>由于markdown的样式太丑了，懒得再调整了，我另外再贴一个github的博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BenAndWang/p/10125142.html</dc:identifier>
</item>
<item>
<title>Spring AOP用法详解 - Liant</title>
<link>http://www.cnblogs.com/liantdev/p/10125284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liantdev/p/10125284.html</guid>
<description>&lt;h4 id=&quot;什么是aop&quot;&gt;什么是AOP&lt;/h4&gt;
&lt;p&gt;AOP：Aspect Oriented Programming，中文翻译为”面向切面编程“。面向切面编程是一种编程范式，它作为OOP面向对象编程的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、权限控制、缓存控制、日志打印等等。AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码&lt;br/&gt;AOP把软件的功能模块分为两个部分：&lt;strong&gt;核心关注点&lt;/strong&gt;和&lt;strong&gt;横切关注点&lt;/strong&gt;。业务处理的主要功能为核心关注点，而非核心、需要拓展的功能为横切关注点。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点进行分离&lt;br/&gt;使用AOP有诸多好处，如：&lt;br/&gt;&lt;strong&gt;1.集中处理某一关注点/横切逻辑&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.可以很方便的添加/删除关注点&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3.侵入性少，增强代码可读性及可维护性&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;aop的术语&quot;&gt;AOP的术语&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.Join point（连接点）&lt;/strong&gt;&lt;br/&gt;Spring 官方文档的描述：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序执行过程中的一个点，如方法的执行或异常的处理。在Spring AOP中，连接点总是表示方法的执行。通俗的讲，连接点即表示类里面可以被增强的方法&lt;br/&gt;&lt;strong&gt;2.Pointcut（切入点）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Pointcut are expressions that is matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切入点是与连接点匹配的表达式，用于确定是否需要执行通知。切入点使用与连接点匹配的不同类型的表达式，Spring框架使用AspectJ切入点表达式语言。我们可以将切入点理解为需要被拦截的Join point&lt;br/&gt;&lt;strong&gt;3.Advice（增强/通知）&lt;/strong&gt;&lt;br/&gt;所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知和环绕通知(切面要完成的功能)&lt;br/&gt;&lt;strong&gt;4.Aspect（切面）&lt;/strong&gt;&lt;br/&gt;Aspect切面表示Pointcut（切入点）和Advice（增强/通知）的结合&lt;/p&gt;
&lt;h4 id=&quot;spring-aop用法&quot;&gt;Spring AOP用法&lt;/h4&gt;
&lt;p&gt;示例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 设置登录用户名
 */
public class CurrentUserHolder {

    private static final ThreadLocal&amp;lt;String&amp;gt; holder = new ThreadLocal&amp;lt;&amp;gt;();

    public static String get() {
        return holder.get();
    }
    public static void set(String user) {
        holder.set(user);
    }
}
/**
 * 校验用户权限
 */
@Service(&quot;authService&quot;)
public class AuthServiceImpl implements AuthService {

    @Override
    public void checkAccess() {
        String user = CurrentUserHolder.get();

        if(!&quot;admin&quot;.equals(user)) {
            throw new RuntimeException(&quot;该用户无此权限！&quot;);
        }
    }
}
/**
 * 业务逻辑类
 */
@Service(&quot;productService&quot;)
public class ProductServiceImpl implements ProductService {

    @Autowired
    private AuthService authService;

    @Override
    public Long deleteProductById(Long id) {
        System.out.println(&quot;删除商品id为&quot; + id + &quot;的商品成功！&quot;);
        return id；
    }

    @Override
    public void deleteProductByName(String name) {
        System.out.println(&quot;删除商品名称为&quot; + name + &quot;的商品成功！&quot;);
    }

    @Override
    public void selectProduct(Long id) {
        if(&quot;100&quot;.equals(id.toString())) {
            System.out.println(&quot;查询商品成功！&quot;);
        } else {
            System.out.println(&quot;查询商品失败！&quot;);
            throw new RuntimeException(&quot;该商品不存在！&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.使用within表达式匹配包类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//匹配ProductServiceImpl类里面的所有方法
@Pointcut(&quot;within(com.aop.service.impl.ProductServiceImpl)&quot;)
public void matchType() {}

//匹配com.aop.service包及其子包下所有类的方法
@Pointcut(&quot;within(com.aop.service..*)&quot;)
public void matchPackage() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.使用this、target、bean表达式匹配对象类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//匹配AOP对象的目标对象为指定类型的方法，即ProductServiceImpl的aop代理对象的方法
@Pointcut(&quot;this(com.aop.service.impl.ProductServiceImpl)&quot;)
public void matchThis() {}

//匹配实现ProductService接口的目标对象
@Pointcut(&quot;target(com.aop.service.ProductService)&quot;)
public void matchTarget() {}

//匹配所有以Service结尾的bean里面的方法
@Pointcut(&quot;bean(*Service)&quot;)
public void matchBean() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.使用args表达式匹配参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//匹配第一个参数为Long类型的方法
@Pointcut(&quot;args(Long, ..) &quot;)
public void matchArgs() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.使用@annotation、@within、@target、@args匹配注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//匹配标注有AdminOnly注解的方法
@Pointcut(&quot;@annotation(com.aop.annotation.AdminOnly)&quot;)
public void matchAnno() {}

//匹配标注有Beta的类底下的方法，要求annotation的Retention级别为CLASS
@Pointcut(&quot;@within(com.google.common.annotations.Beta)&quot;)
public void matchWithin() {}

//匹配标注有Repository的类底下的方法，要求annotation的Retention级别为RUNTIME
@Pointcut(&quot;@target(org.springframework.stereotype.Repository)&quot;)
public void matchTarget() {}

//匹配传入的参数类标注有Repository注解的方法
@Pointcut(&quot;@args(org.springframework.stereotype.Repository)&quot;)
public void matchArgs() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.使用execution表达式&lt;/strong&gt;&lt;br/&gt;execution表达式是我们在开发过程中最常用的，它的语法如下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13172436-f29c6b3251eec05a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;execution表达式&quot;/&gt;&lt;br/&gt;modifier-pattern：用于匹配public、private等访问修饰符&lt;br/&gt;ret-type-pattern：用于匹配返回值类型，不可省略&lt;br/&gt;declaring-type-pattern：用于匹配包类型&lt;br/&gt;modifier-pattern（param-pattern）：用于匹配类中的方法，不可省略&lt;br/&gt;throws-pattern：用于匹配抛出异常的方法&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Aspect
public class SecurityAspect {

    @Autowired
    private AuthService authService;

    //匹配com.aop.service.impl.ProductServiceImpl类下的方法名以delete开头、参数类型为Long的public方法
    @Pointcut(&quot;execution(public * com.aop.service.impl.ProductServiceImpl.delete*(Long))&quot;)
    public void matchCondition() {}

    //使用matchCondition这个切入点进行增强
    @Before(&quot;matchCondition()&quot;)
    public void before() {
        System.out.println(&quot;before 前置通知......&quot;);
        authService.checkAccess();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringBootApplicationTests {

    @Autowired
    private ProductService productService;

    @Test
    public void contextLoads() {
        //设置用户名
        CurrentUserHolder.set(&quot;hello&quot;);

        productService.selectProduct(100L);
        productService.deleteProductByName(&quot;衣服&quot;);
        productService.deleteProductById(100L);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果（只有deleteProductById方法拦截成功）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;查询商品成功！
删除商品名称为衣服的商品成功！
before 前置通知......

java.lang.RuntimeException: 该用户无此权限！

    at com.aop.service.impl.AuthServiceImpl.checkAccess(AuthServiceImpl.java:15)
    at com.aop.security.SecurityAspect.before(SecurityAspect.java:50)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在多个表达式之间使用连接符匹配多个条件， 如使用||表示“或”，使用 &amp;amp;&amp;amp;表示“且”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//匹配com.aop.service.impl.ProductServiceImpl类下方法名以select或delete开头的所有方法
@Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.select*(..)) || &quot; +
            &quot;execution(* com.aop.service.impl.ProductServiceImpl.delete*(..))&quot;)
public void matchCondition() {}

//使用matchCondition这个切入点进行增强
@Before(&quot;matchCondition()&quot;)
public void before() {
   System.out.println(&quot;before 前置通知......&quot;);
   authService.checkAccess();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void contextLoads() {
        CurrentUserHolder.set(&quot;admin&quot;);

        productService.selectProduct(100L);
        productService.deleteProductByName(&quot;衣服&quot;);
        productService.deleteProductById(100L);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果（所有方法均拦截成功）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;before 前置通知......
查询商品成功！
before 前置通知......
删除商品名称为衣服的商品成功！
before 前置通知......
删除商品id为100的商品成功！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.Advice注解&lt;/strong&gt;&lt;br/&gt;Advice注解一共有五种，分别是：&lt;br/&gt;&lt;strong&gt;1.@Before前置通知&lt;/strong&gt;&lt;br/&gt;前置通知在切入点运行前执行，不会影响切入点的逻辑&lt;br/&gt;&lt;strong&gt;2.@After后置通知&lt;/strong&gt;&lt;br/&gt;后置通知在切入点正常运行结束后执行，如果切入点抛出异常，则在抛出异常前执行&lt;br/&gt;&lt;strong&gt;3.@AfterThrowing异常通知&lt;/strong&gt;&lt;br/&gt;异常通知在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行&lt;br/&gt;&lt;strong&gt;4.@AfterReturning返回通知&lt;/strong&gt;&lt;br/&gt;返回通知在切入点正常运行结束后执行，如果切入点抛出异常，则不执行&lt;br/&gt;&lt;strong&gt;5.@Around环绕通知&lt;/strong&gt;&lt;br/&gt;环绕通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行&lt;br/&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //匹配com.aop.service.impl.ProductServiceImpl类下面的所有方法
    @Pointcut(&quot;execution(* com.aop.service.impl.ProductServiceImpl.*(..))&quot;)
    public void matchAll() {}

    @Around(&quot;matchAll()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) {
        Object result = null;
        authService.checkAccess();
        System.out.println(&quot;befor 在切入点执行前运行&quot;);

        try{
            result = joinPoint.proceed(joinPoint.getArgs());//获取参数
            System.out.println(&quot;after 在切入点执行后运行,result = &quot; + result);
        } catch (Throwable e) {
            System.out.println(&quot;after 在切入点执行后抛出exception运行&quot;);
            e.printStackTrace();
        } finally {
            System.out.println(&quot;finally......&quot;);
        }

       return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void contextLoads() {
        CurrentUserHolder.set(&quot;admin&quot;);

        productService.deleteProductById(100L);
        productService.selectProduct(10L);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;before 在切入点执行前运行
删除商品id为100的商品成功！
after 在切入点执行后运行,result = 100
finally......
before 在切入点执行前运行
查询商品失败！
after 在切入点执行后抛出exception运行
java.lang.RuntimeException: 该商品不存在！
    at com.aop.service.impl.ProductServiceImpl.selectProduct(ProductServiceImpl.java:41)
    at com.aop.service.impl.ProductServiceImpl$$FastClassBySpringCGLIB$$f17a76a2.invoke(&amp;lt;generated&amp;gt;)
finally......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在执行ProceedingJoinPoint对象的proceed方法前相当于Before前置通知；执行proceed方法相当于运行切入点（同时可以获取参数）；在方法执行之后相当于After后置通知，如果运行切入点抛出异常，则catch中的内容相当于AfterThrowing异常通知;finally中的内容无论切入点是否抛出异常，都将执行&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>Liant</dc:creator>
<og:description>什么是AOP AOP：Aspect Oriented Programming，中文翻译为”面向切面编程“。面向切面编程是一种编程范式，它作为OOP面向对象编程的一种补充，用于处理系统中分布于各个模块的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liantdev/p/10125284.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合系列--整合MyBatis-plus - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/10125279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/10125279.html</guid>
<description>&lt;p&gt;原创作品，可以转载，但是请标注出处地址：&lt;a href=&quot;https://www.cnblogs.com/V1haoge/p/10125279.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/V1haoge/p/10125279.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;
&lt;h3 id=&quot;第一步添加必要的依赖&quot;&gt;第一步：添加必要的依赖&lt;/h3&gt;
&lt;p&gt;第一种是在已存在MyBatis的情况下，直接添加mybatis-plus包即可。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种是直接添加mybatis-plus的starter，它会自动导入mybatis的依赖包及其他相关依赖包&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步添加必要的配置&quot;&gt;第二步：添加必要的配置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：Mybatis-plus是MyBatis的再封装，添加MyBatis-plus之后我们的设置针对的应该是MyBatis-plus，而不是MyBatis。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;mybatis-plus:
  mapper-locations: classpath*:/mapper/*.xml
  type-aliases-package: com.example.springbootdemo.entity
  type-aliases-super-type: java.lang.Object
  type-handlers-package: com.example.springbootdemo.typeHandler
  type-enums-package: com.example.springbootdemo.enums&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第三步添加必要的配置类&quot;&gt;第三步：添加必要的配置类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.example.springbootdemo.plusmapper&quot;)
public class MyBatisPlusConfig {
    
    // mybatis-plus分页插件
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四步定义实体&quot;&gt;第四步：定义实体&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@Builder
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@TableName(value = &quot;ANIMAL&quot;)
public class Animal {
    @TableId(value = &quot;ID&quot;,type = IdType.AUTO)
    private Integer id;
    @TableField(value = &quot;NAME&quot;,exist = true)
    private String name;
    @TableField(value = &quot;TYPE&quot;,exist = true)
    private AnimalType type;
    @TableField(value = &quot;SEX&quot;,exist = true)
    private AnimalSex sex;
    @TableField(value = &quot;MASTER&quot;,exist = true)
    private String master;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum AnimalType implements IEnum {
    CAT(&quot;1&quot;,&quot;猫&quot;),DOG(&quot;2&quot;,&quot;狗&quot;),TIGER(&quot;3&quot;,&quot;虎&quot;),MOUSE(&quot;4&quot;,&quot;鼠&quot;),MONKEY(&quot;5&quot;,&quot;猴&quot;),LOAN(&quot;6&quot;,&quot;狮&quot;),OTHER(&quot;7&quot;,&quot;其他&quot;);
    private final String value;
    private final String desc;
    AnimalType(final String value,final String desc){
        this.value=value;
        this.desc = desc;
    }
    @Override
    public Serializable getValue() {
        return value;
    }
    public String getDesc() {
        return desc;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum AnimalSex implements IEnum {
    MALE(&quot;1&quot;,&quot;公&quot;),FEMALE(&quot;2&quot;,&quot;母&quot;);
    private final String value;
    private final String desc;
    AnimalSex(final String value,final String desc){
        this.value = value;
        this.desc = desc;
    }
    @Override
    public Serializable getValue() {
        return value;
    }
    public String getDesc() {
        return desc;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第五步定义mapper接口&quot;&gt;第五步：定义mapper接口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AnimalRepository extends BaseMapper&amp;lt;Animal&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;解说：使用MyBatis Plus后Mapper只要继承BaseMapper接口即可，即使不添加XML映射文件也可以实现该接口提供的增删改查功能，还可以配合Wrapper进行条件操作，当然这些操作都仅仅限于单表操作，一旦涉及多表联查，那么还是乖乖添加**Mapper.xml来自定义SQL吧！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第六步定义service重点&quot;&gt;第六步：定义service（重点）&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {

    @Autowired
    private AnimalRepository animalRepository;

    //增
    public ResponseEntity&amp;lt;Animal&amp;gt; addAnimal(final Animal animal) {
        animalRepository.insert(animal);
        return ResponseEntity.ok(animal);
    }

    //删
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalById(final int id){
        return ResponseEntity.ok(animalRepository.deleteById(id));
    }

    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimals(final Animal animal){
        return ResponseEntity.ok(animalRepository.delete(packWrapper(animal, WrapperType.QUERY)));
    }

    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalsByIds(List&amp;lt;Integer&amp;gt; ids){
        return ResponseEntity.ok(animalRepository.deleteBatchIds(ids));
    }

    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalsByMap(final Animal animal){
        Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;&amp;gt;();
        if(Objects.nonNull(animal.getId())){
            params.put(&quot;ID&quot;,animal.getId());
        }
        if(StringUtils.isNotEmpty(animal.getName())){
            params.put(&quot;NAME&quot;, animal.getName());
        }
        if(Objects.nonNull(animal.getType())){
            params.put(&quot;TYPE&quot;, animal.getType());
        }
        if(Objects.nonNull(animal.getSex())){
            params.put(&quot;SEX&quot;, animal.getSex());
        }
        if (StringUtils.isNotEmpty(animal.getMaster())){
            params.put(&quot;MASTER&quot;, animal.getMaster());
        }
        return ResponseEntity.ok(animalRepository.deleteByMap(params));
    }

    //改
    public ResponseEntity&amp;lt;Integer&amp;gt; updateAnimals(final Animal animal, final Animal condition){
        return ResponseEntity.ok(animalRepository.update(animal, packWrapper(condition, WrapperType.UPDATE)));
    }

    public ResponseEntity&amp;lt;Integer&amp;gt; updateAnimal(final Animal animal){
        Wrapper&amp;lt;Animal&amp;gt; animalWrapper = new UpdateWrapper&amp;lt;&amp;gt;();
        ((UpdateWrapper&amp;lt;Animal&amp;gt;) animalWrapper).eq(&quot;id&quot;,animal.getId());
        return ResponseEntity.ok(animalRepository.update(animal, animalWrapper));
    }

    //查
    public ResponseEntity&amp;lt;Animal&amp;gt; getAnimalById(final int id){
        return ResponseEntity.ok(animalRepository.selectById(id));
    }

    public ResponseEntity&amp;lt;Animal&amp;gt; getOneAnimal(final Animal animal){
        return ResponseEntity.ok(animalRepository.selectOne(packWrapper(animal, WrapperType.QUERY)));
    }

    public ResponseEntity&amp;lt;List&amp;lt;Animal&amp;gt;&amp;gt; getAnimals(final Animal animal){
        return ResponseEntity.ok(animalRepository.selectList(packWrapper(animal, WrapperType.QUERY)));
    }

    public ResponseEntity&amp;lt;List&amp;lt;Animal&amp;gt;&amp;gt; getAnimalsByIds(List&amp;lt;Integer&amp;gt; ids){
        return ResponseEntity.ok(animalRepository.selectBatchIds(ids));
    }

    public ResponseEntity&amp;lt;List&amp;lt;Animal&amp;gt;&amp;gt; getAnimalsByMap(final Animal animal){
        Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;&amp;gt;();
        if(Objects.nonNull(animal.getId())){
            params.put(&quot;ID&quot;,animal.getId());
        }
        if(StringUtils.isNotEmpty(animal.getName())){
            params.put(&quot;NAME&quot;, animal.getName());
        }
        if(Objects.nonNull(animal.getType())){
            params.put(&quot;TYPE&quot;, animal.getType());
        }
        if(Objects.nonNull(animal.getSex())){
            params.put(&quot;SEX&quot;, animal.getSex());
        }
        if (StringUtils.isNotEmpty(animal.getMaster())){
            params.put(&quot;MASTER&quot;, animal.getMaster());
        }
        return ResponseEntity.ok(animalRepository.selectByMap(params));
    }

    public ResponseEntity&amp;lt;List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&amp;gt; getAnimalMaps(final Animal animal){
        return ResponseEntity.ok(animalRepository.selectMaps(packWrapper(animal, WrapperType.QUERY)));
    }

    //查个数
    public ResponseEntity&amp;lt;Integer&amp;gt; getCount(final Animal animal){
        return ResponseEntity.ok(animalRepository.selectCount(packWrapper(animal, WrapperType.QUERY)));
    }

    //分页查询
    public ResponseEntity&amp;lt;Page&amp;lt;Animal&amp;gt;&amp;gt; getAnimalPage(final Animal animal,final int pageId,final int pageSize){
        Page&amp;lt;Animal&amp;gt; page = new Page&amp;lt;&amp;gt;();
        page.setCurrent(pageId);
        page.setSize(pageSize);
        return ResponseEntity.ok((Page&amp;lt;Animal&amp;gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY)));
    }

    private Wrapper&amp;lt;Animal&amp;gt; packWrapper(final Animal animal, WrapperType wrapperType){
        switch (wrapperType){
            case QUERY:
                QueryWrapper&amp;lt;Animal&amp;gt; wrapper = new QueryWrapper&amp;lt;&amp;gt;();
                if (Objects.nonNull(animal.getId()))
                    wrapper.eq(&quot;ID&quot;, animal.getId());
                if (StringUtils.isNotEmpty(animal.getName()))
                    wrapper.eq(&quot;name&quot;, animal.getName());
                if (Objects.nonNull(animal.getType()))
                    wrapper.eq(&quot;type&quot;, animal.getType());
                if (Objects.nonNull(animal.getSex()))
                    wrapper.eq(&quot;sex&quot;, animal.getSex());
                if (StringUtils.isNotEmpty(animal.getMaster()))
                    wrapper.eq(&quot;master&quot;, animal.getMaster());
                return wrapper;
            case UPDATE:
                UpdateWrapper&amp;lt;Animal&amp;gt; wrapper2 = new UpdateWrapper&amp;lt;&amp;gt;();
                if (Objects.nonNull(animal.getId()))
                    wrapper2.eq(&quot;ID&quot;, animal.getId());
                if (StringUtils.isNotEmpty(animal.getName()))
                    wrapper2.eq(&quot;name&quot;, animal.getName());
                if (Objects.nonNull(animal.getType()))
                    wrapper2.eq(&quot;type&quot;, animal.getType());
                if (Objects.nonNull(animal.getSex()))
                    wrapper2.eq(&quot;sex&quot;, animal.getSex());
                if (StringUtils.isNotEmpty(animal.getMaster()))
                    wrapper2.eq(&quot;master&quot;, animal.getMaster());
                return wrapper2;
            case QUERYLAMBDA:
                LambdaQueryWrapper&amp;lt;Animal&amp;gt; wrapper3 = new QueryWrapper&amp;lt;Animal&amp;gt;().lambda();
                if (Objects.nonNull(animal.getId()))
                    wrapper3.eq(Animal::getId, animal.getId());
                if (StringUtils.isNotEmpty(animal.getName()))
                    wrapper3.eq(Animal::getName, animal.getName());
                if (Objects.nonNull(animal.getType()))
                    wrapper3.eq(Animal::getType, animal.getType());
                if (Objects.nonNull(animal.getSex()))
                    wrapper3.eq(Animal::getSex, animal.getSex());
                if (StringUtils.isNotEmpty(animal.getMaster()))
                    wrapper3.eq(Animal::getMaster, animal.getMaster());
                return wrapper3;
            case UPDATELAMBDA:
                LambdaUpdateWrapper&amp;lt;Animal&amp;gt; wrapper4 = new UpdateWrapper&amp;lt;Animal&amp;gt;().lambda();
                if (Objects.nonNull(animal.getId()))
                    wrapper4.eq(Animal::getId, animal.getId());
                if (StringUtils.isNotEmpty(animal.getName()))
                    wrapper4.eq(Animal::getName, animal.getName());
                if (Objects.nonNull(animal.getType()))
                    wrapper4.eq(Animal::getType, animal.getType());
                if (Objects.nonNull(animal.getSex()))
                    wrapper4.eq(Animal::getSex, animal.getSex());
                if (StringUtils.isNotEmpty(animal.getMaster()))
                    wrapper4.eq(Animal::getMaster, animal.getMaster());
                return wrapper4;
            default:return null;
        }
    }
}
enum WrapperType{
    UPDATE,UPDATELAMBDA,QUERY,QUERYLAMBDA;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第七步定义controller&quot;&gt;第七步：定义controller&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;animal&quot;)
@Api(description = &quot;动物接口&quot;)
@Log4j2
public class AnimalApi {
    @Autowired
    private AnimalService animalService;
    @RequestMapping(value = &quot;addAnimal&quot;,method = RequestMethod.PUT)
    @ApiOperation(value = &quot;添加动物&quot;,notes = &quot;添加动物&quot;,httpMethod = &quot;PUT&quot;)
    public ResponseEntity&amp;lt;Animal&amp;gt; addAnimal(final Animal animal){
        return animalService.addAnimal(animal);
    }
    @RequestMapping(value = &quot;deleteAnimalById&quot;, method = RequestMethod.DELETE)
    @ApiOperation(value = &quot;删除一个动物&quot;,notes = &quot;根据ID删除动物&quot;,httpMethod = &quot;DELETE&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalById(final int id){
        return animalService.deleteAnimalById(id);
    }
    @RequestMapping(value = &quot;deleteAnimalsByIds&quot;,method = RequestMethod.DELETE)
    @ApiOperation(value = &quot;删除多个动物&quot;,notes = &quot;根据Id删除多个动物&quot;,httpMethod = &quot;DELETE&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalsByIds(Integer[] ids){
        return animalService.deleteAnimalsByIds(Arrays.asList(ids));
    }
    @RequestMapping(value = &quot;deleteAnimals&quot;, method = RequestMethod.DELETE)
    @ApiOperation(value = &quot;删除动物&quot;,notes = &quot;根据条件删除动物&quot;,httpMethod = &quot;DELETE&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalsByMaps(final Animal animal){
        return animalService.deleteAnimalsByMap(animal);
    }
    @RequestMapping(value = &quot;deleteAnimals2&quot;, method = RequestMethod.DELETE)
    @ApiOperation(value = &quot;删除动物&quot;,notes = &quot;根据条件删除动物&quot;,httpMethod = &quot;DELETE&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimals(final Animal animal){
        return animalService.deleteAnimals(animal);
    }
    @RequestMapping(value = &quot;getAnimalById&quot;,method = RequestMethod.GET)
    @ApiOperation(value = &quot;获取一个动物&quot;,notes = &quot;根据ID获取一个动物&quot;,httpMethod = &quot;GET&quot;)
    public ResponseEntity&amp;lt;Animal&amp;gt; getAnimalById(final int id){
        return animalService.getAnimalById(id);
    }
    // 注意，这里参数animal不能用RequstBody标注，否则接收不到参数
    // @RequestBody只能用在只有一个参数模型的方法中，用于将所有请求体中携带的参数全部映射到这个请求参数模型中
    @RequestMapping(value = &quot;getAnimalsByPage&quot;)
    @ApiOperation(value = &quot;分页获取动物们&quot;,notes = &quot;分页获取所有动物&quot;, httpMethod = &quot;GET&quot;)
    public ResponseEntity&amp;lt;Page&amp;lt;Animal&amp;gt;&amp;gt; getAnimalsByPage(@RequestParam final int pageId, @RequestParam final int pageSize, final Animal animal) {
        return animalService.getAnimalPage(animal==null?Animal.builder().build():animal, pageId, pageSize);
    }
    @RequestMapping(value = &quot;updateAnimal&quot;)
    @ApiOperation(value = &quot;更新动物&quot;, notes = &quot;根据条件更新&quot;,httpMethod = &quot;POST&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; updateAnimals(final Animal animal){
        return animalService.updateAnimal(animal);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高级功能&quot;&gt;高级功能&lt;/h2&gt;
&lt;h3 id=&quot;代码生成器&quot;&gt;代码生成器&lt;/h3&gt;
&lt;h3 id=&quot;分页插件&quot;&gt;分页插件&lt;/h3&gt;
&lt;h4 id=&quot;第一步添加必要的配置&quot;&gt;第一步：添加必要的配置&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.example.springbootdemo.plusmapper&quot;)
public class MyBatisPlusConfig {
    @Bean // mybatis-plus分页插件
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步添加mapper&quot;&gt;第二步：添加Mapper&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AnimalRepository extends BaseMapper&amp;lt;Animal&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第三步添加service&quot;&gt;第三步：添加service&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {
    @Autowired
    private AnimalRepository animalRepository;
    //...
    public Page&amp;lt;Animal&amp;gt; getAnimalsByPage(int pageId,int pageSize) {
        Page page = new Page(pageId, pageSize);
        return (Page&amp;lt;Animal&amp;gt;)animalRepository.selectPage(page,null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;逻辑删除&quot;&gt;逻辑删除&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;所谓逻辑删除是相对于物理删除而言的，MyBatis Plus默认的删除操作是物理删除，即直接调用数据库的delete操作，直接将数据从数据库删除，但是，一般情况下，我们在项目中不会直接操作delete，为了保留记录，我们只是将其标记为删除，并不是真的删除，也就是需要逻辑删除，MyBatis Plus也提供了实现逻辑删除的功能，通过这种方式可以将底层的delete操作修改成update操作。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第一步添加必要的配置-1&quot;&gt;第一步：添加必要的配置&lt;/h4&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;mybatis-plus:
  global-config:
    db-config:
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步添加必要的配置类&quot;&gt;第二步：添加必要的配置类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class MyBatisPlusConfiguration {

    @Bean
    public ISqlInjector sqlInjector() {
        return new LogicSqlInjector();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第三步添加字段isdel和注解&quot;&gt;第三步：添加字段isDel和注解&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@TableLogic
private Integer isDel;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;如此一来，我们再执行delete相关操作的时候，底层就会变更为update操作，将isDel值修改为1。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：通过此种方式删除数据后，实际数据还存在于数据库中，只是字段isDel值改变了，虽然如此，但是再通过MyBatis Plus查询数据的时候却会将其忽略，就好比不存在一般。&lt;br/&gt;即通过逻辑删除的数据和物理删除的外在表现是一致的，只是内在机理不同罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;枚举自动注入&quot;&gt;枚举自动注入&lt;/h3&gt;
&lt;h4 id=&quot;第一种方式&quot;&gt;第一种方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;使用注解@EnumValue
使用方式：定义普通枚举，并在其中定义多个属性，将该注解标注于其中一个枚举属性之上，即可实现自动映射，使用枚举name传递，实际入库的却是添加了注解的属性值，查询也是如此，可以将库中数据与添加注解的属性对应，从而获取到枚举值name。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二种方式&quot;&gt;第二种方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Mybatis Plus中定义了IEnum用来统筹管理所有的枚举类型，我们自定义的枚举只要实现IEnum接口即可，在MyBatis Plus初始化的时候，会自动在MyBatis中handler缓存中添加针对IEnum类型的处理器，我们的自定义的枚举均可使用这个处理器进行处理来实现自动映射。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;步骤一添加必要的配置&quot;&gt;步骤一：添加必要的配置&lt;/h5&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;mybatis-plus.type-enums-package: com.example.springbootdemo.enums&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;步骤二自定义枚举&quot;&gt;步骤二：自定义枚举&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum AnimalType implements IEnum {
    CAT(&quot;1&quot;,&quot;猫&quot;),DOG(&quot;2&quot;,&quot;狗&quot;),TIGER(&quot;3&quot;,&quot;虎&quot;),MOUSE(&quot;4&quot;,&quot;鼠&quot;),MONKEY(&quot;5&quot;,&quot;猴&quot;),LOAN(&quot;6&quot;,&quot;狮&quot;),OTHER(&quot;7&quot;,&quot;其他&quot;);
    private final String value;
    private final String desc;
    AnimalType(final String value,final String desc){
        this.value=value;
        this.desc = desc;
    }
    @Override
    public Serializable getValue() {
        return value;
    }
    public String getDesc() {
        return desc;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：一定要实现IEnum接口，否则无法实现自动注入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sql自动注入&quot;&gt;Sql自动注入&lt;/h3&gt;
&lt;h3 id=&quot;性能分析插件&quot;&gt;性能分析插件&lt;/h3&gt;
&lt;h4 id=&quot;第一步添加必要的配置-2&quot;&gt;第一步：添加必要的配置&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.example.springbootdemo.plusmapper&quot;)
public class MyBatisPlusConfig {
    //...
    //sql执行效率插件（性能分析插件）
    @Bean
    @Profile({&quot;dev&quot;,&quot;test&quot;})// 设置 dev test 环境开启
    public PerformanceInterceptor performanceInterceptor() {
        return new PerformanceInterceptor();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说明：&lt;br/&gt;性能分析拦截器，用于输出每条 SQL 语句及其执行时间:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;maxTime：SQL 执行最大时长，超过自动停止运行，有助于发现问题。&lt;/li&gt;
&lt;li&gt;format：SQL SQL是否格式化，默认false。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：性能分析工具最好不要在生产环境部署，只在开发、测试环境部署用于查找问题即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;乐观锁插件&quot;&gt;乐观锁插件&lt;/h3&gt;
&lt;h4 id=&quot;第一步添加必要的配置-3&quot;&gt;第一步：添加必要的配置&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.example.springbootdemo.plusmapper&quot;)
public class MyBatisPlusConfig {
    //...
    // mybatis-plus乐观锁插件
    @Bean
    public OptimisticLockerInterceptor optimisticLockerInterceptor() {
        return new OptimisticLockerInterceptor();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步添加version&quot;&gt;第二步：添加@Version&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Version
private int version;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Version支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime；&lt;/li&gt;
&lt;li&gt;整数类型下 newVersion = oldVersion + 1；&lt;/li&gt;
&lt;li&gt;newVersion 会回写到 entity 中&lt;/li&gt;
&lt;li&gt;仅支持 updateById(id) 与 update(entity, wrapper) 方法&lt;/li&gt;
&lt;li&gt;在 update(entity, wrapper) 方法下, wrapper 不能复用!!!&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;实体主键配置&quot;&gt;实体主键配置&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
public enum IdType {
    /**
     * 数据库ID自增
     */
    AUTO(0),
    /**
     * 该类型为未设置主键类型
     */
    NONE(1),
    /**
     * 用户输入ID
     * 该类型可以通过自己注册自动填充插件进行填充
     */
    INPUT(2),

    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 全局唯一ID (idWorker)
     */
    ID_WORKER(3),
    /**
     * 全局唯一ID (UUID)
     */
    UUID(4),
    /**
     * 字符串全局唯一ID (idWorker 的字符串表示)
     */
    ID_WORKER_STR(5);

    private int key;

    IdType(int key) {
        this.key = key;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;AUTO：自增，适用于类似MySQL之类自增主键的情况&lt;/li&gt;
&lt;li&gt;NONE：不设置？？？&lt;/li&gt;
&lt;li&gt;INPUT：通过第三方进行逐渐递增，类似Oracle数据库的队列自增&lt;/li&gt;
&lt;li&gt;ID_WORKER：全局唯一ID，当插入对象ID为空时，自动填充&lt;/li&gt;
&lt;li&gt;UUID：全局唯一ID，当插入对象ID为空时，自动填充，一般情况下UUID是无序的&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;ID_WORKER_STR：字符串全局唯一ID，当插入对象ID为空时，自动填充&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;最好不要和devTools一起使用，因为devTools中的RestartClassLoader会导致MyBatis Plus中的枚举自动映射失败，因为类加载器的不同从而在MyBatis的TypeHasnlerRegistry的TYPE_HANDLER_MAP集合中找不到对应的枚举类型（存在这个枚举类型，只不过是用AppClassLoader加载的，不同的加载器导致类型不同）&lt;br/&gt;MyBatis Plus和JPA分页有些不同，前者从1开始计页数，后者则是从0开始。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 15 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<og:description>原创作品，可以转载，但是请标注出处地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V1haoge/p/10125279.html</dc:identifier>
</item>
<item>
<title>动态编程（Dynamic Programming） - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/10125175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/10125175.html</guid>
<description>&lt;blockquote readability=&quot;2.65625&quot;&gt;
&lt;p&gt;本文素材来自视频，请自备梯子观看：&lt;a href=&quot;https://www.youtube.com/watch?v=vYquumk4nWw&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;What Is Dynamic Programming and How To Use It&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@codingfreak/top-50-dynamic-programming-practice-problems-4208fed71aa3&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Dynamic Programming&lt;/a&gt;：动态编程分为如下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将复杂问题拆分成多个较简单的子问题&lt;/li&gt;
&lt;li&gt;对每个子问题只计算一次，然后使用数据结构（数组，字典等）在内存中存储计算结果&lt;/li&gt;
&lt;li&gt;子问题的计算结果按照一定规则进行排序（如，基于输入参数）&lt;/li&gt;
&lt;li&gt;当需要再次运算子问题时直接使用已存储的计算结果而非再次运算以提升求解性能&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种存储计算结果以备再次使用称之为：Memoization（这个词，不知道怎么翻译好）&lt;/p&gt;

&lt;p&gt;以斐波那契数列为例来说明：&lt;/p&gt;
&lt;p&gt;1、使用递归实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;参数n必须为大于0的整数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1 &lt;span&gt;or&lt;/span&gt; n == 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;return&lt;/span&gt; fib(n-2)+fib(n-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法是经典的递归运算。以fib(5)为例，整个求解过程可以拆分为：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1196&quot; data-height=&quot;631&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1458860-1648085a4bdf2b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;图片来自Youtube&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1458860-1648085a4bdf2b60.png&quot; data-original-width=&quot;1196&quot; data-original-height=&quot;631&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;374757&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;我们可以看出，fib(2)被计算三次，fib(3)与fib(1)各被计算2次，时间复杂度为O(2^n)。&lt;/p&gt;
&lt;p&gt;2、对递归进行改进&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib_memory(n):
    d &lt;/span&gt;=&lt;span&gt; dict()
    _fib_memory(n, d)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _fib_memory(n, temp_dict):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;参数n必须为大于0的整数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(temp_dict) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; dict
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;参数temp_dict必须为dict类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; temp_dict:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp_dict[n]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1 &lt;span&gt;or&lt;/span&gt; n == 2&lt;span&gt;:
        result &lt;/span&gt;= 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        result &lt;/span&gt;= fib_memory(n-1, temp_dict)+fib_memory(n-2&lt;span&gt;, temp_dict)
    temp_dict[n] &lt;/span&gt;=&lt;span&gt; result
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; result
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;1207&quot; data-height=&quot;629&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1458860-cb32d45209321734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;图片来自Youtube&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1458860-cb32d45209321734.png&quot; data-original-width=&quot;1207&quot; data-original-height=&quot;629&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;538960&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;优化后，时间复杂度降为O(n)。优化后的算法依然使用了递归，当参数较大时（如，1000）会导致栈溢出：&lt;br/&gt;&lt;code&gt;RecursionError: maximum recursion depth exceeded in comparison&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3、脱离递归：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib_bottom_up(n):
    l &lt;/span&gt;= [None]*(n+1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _fib_bottom_up(n, l)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _fib_bottom_up(n, temp_list):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;参数n必须为大于0的整数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(temp_list) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; list:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;参数temp_list必须为list类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp_list[n] &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp_list[n]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1 &lt;span&gt;or&lt;/span&gt; n == 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
    temp_list[&lt;/span&gt;1] = 1&lt;span&gt;
    temp_list[&lt;/span&gt;2] = 1
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3, n+1&lt;span&gt;):
        temp_list[i] &lt;/span&gt;= temp_list[i-1]+temp_list[i-2&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; temp_list[n]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1176&quot; data-height=&quot;603&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1458860-5201a0943840913d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;图片来自Youtube&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1458860-5201a0943840913d.png&quot; data-original-width=&quot;1176&quot; data-original-height=&quot;603&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;419968&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;改进之后的算法不再使用递归，时间复杂度依然是O(n)。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对以上三种实现编写测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; temp
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestDif(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_fib_0_throw_value_error(self):
        with self.assertRaises(ValueError):
            temp.fib(0)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_fib_1_return_1(self):
        result &lt;/span&gt;= temp.fib(1&lt;span&gt;)
        self.assertEqual(&lt;/span&gt;1&lt;span&gt;, result)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_fib_10_return_false(self):
        result &lt;/span&gt;= temp.fib(10&lt;span&gt;)
        self.assertFalse(result &lt;/span&gt;== 10&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_fib_memory_10_return_false(self):
        result &lt;/span&gt;= temp.fib_memory(10&lt;span&gt;)
        self.assertNotEqual(result, &lt;/span&gt;10&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_fib_bottom_up_1000_return_true(self):
        result &lt;/span&gt;= temp.fib_bottom_up(1000&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
        self.assertTrue(result &lt;/span&gt;&amp;gt; 100000&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;无意中在Youtube上看到这段视频，就翻译整理下来与大家共享。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 14:29:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>本文素材来自视频，请自备梯子观看：What Is Dynamic Programming and How To Use It Dynamic Programming：动态编程分为如下几步： 这种存储计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/10125175.html</dc:identifier>
</item>
<item>
<title>Tomcat中的Host和Engine级别的servlet容器 - 陈东的博客</title>
<link>http://www.cnblogs.com/ChenD/p/10125124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChenD/p/10125124.html</guid>
<description>&lt;p&gt;　　这边文章主要介绍的是Host容器 和 Engine容器。如果你想在同一个Tomcat上部署运行多个Context容器的话，你就需要使用Host容器，从理论上来讲，如果你的Tomcat只想要部署一个Context容器的话，你可以不使用Host容器。&lt;/p&gt;
&lt;p&gt;在org.apache.catalina.Context接口的描述有下一段话：&lt;/p&gt;
&lt;p&gt;　　Context容器的父容器通常是Host容器，也有可能是其他实现，或者如果不是必要的话，就可以不使用父容器。&lt;/p&gt;
&lt;p&gt;　　但是 在tomcat的实际部署中，总会使用一个Host容器，在下面在解释原因，&lt;/p&gt;
&lt;p&gt;　　Engine容器表示Catalina的整个Servlet引擎，如果使用了Engine容器，那么它总是处于容器层级的最顶层，添加到Enginer容器中的子容器通常是org.apache.catalina.Host 或者 org.apahce.catalina.Context的实现，默认情况下Tomcat会使用一个Engine容器并且使用一个Host容器作为其子容器，&lt;/p&gt;

&lt;p&gt;　　host容器是 org.apahce.catalina.Host接口的实例，Host接口继承自Container接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.apache.catalina;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &amp;lt;p&amp;gt;
 * &amp;lt;b&amp;gt;Title:Host.java&amp;lt;/b&amp;gt;
 * &amp;lt;/p&amp;gt;
 * &amp;lt;p&amp;gt;
 * Copyright:ChenDong 2018
 * &amp;lt;/p&amp;gt;
 * &amp;lt;p&amp;gt;
 * Company:仅学习时使用
 * &amp;lt;/p&amp;gt;
 * &amp;lt;p&amp;gt;
 * 类功能描述:Host是表示Catalina servlet引擎中的虚拟主机的容器。它在以下类型的场景中很有用：
 * 
 * 
 * 
 * 您希望使用拦截器来查看此特定虚拟主机处理的每个请求。
 * 
 * 您希望使用独立的HTTP连接器运行Catalina，但是仍然希望支持多个虚拟主机。
 * 
 * 通常，在部署连接到Web服务器（如Apache）的Catalina时，您不会使用主机，因为连接器将利用Web服务器的设施来确定应该使用哪个上下文（
 * 或者甚至哪个包装器）来处理这个请求。
 * 
 * 附加到主机的父容器通常是一个引擎，但是可以是一些其他的实现，或者如果不必要的话可以省略。
 * 
 * 
 * 
 * 附加到主机的子容器通常是上下文的实现（表示单个servlet上下文）。
 * &amp;lt;/p&amp;gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 
 * @date 2018年12月15日 下午9:28:58
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Host &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Container {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------- Manifest Constants&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *
     * 
     * 当使用&amp;lt;code&amp;gt;addAlias()&amp;lt;/code&amp;gt;方法添加新的别名时发送的 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ContainerEvent}事件类型。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ADD_ALIAS_EVENT = &quot;addAlias&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当使用&amp;lt;code&amp;gt;removeAlias()&amp;lt;/code&amp;gt;移除一个旧的别名时 触发的 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ContainerEvent}事件类型
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String REMOVE_ALIAS_EVENT = &quot;removeAlias&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ------------------------------------------------------------- Properties&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回此{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Host}容器的 根路径，它可以是 绝对路径、相对路径、或者URL
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAppBase();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 为这个{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Host}容器 设置一个根路径，它可以是 绝对路径、相对路径、或者URL
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; appBase
     *            新的容器根路径
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAppBase(String appBase);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Return the value of the auto deploy flag. If true, it indicates that this
     * host's child webapps should be discovred and automatically deployed.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getAutoDeploy();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Set the auto deploy flag value for this host.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; autoDeploy
     *            The new auto deploy flag
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAutoDeploy(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoDeploy);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 为新的web应用程序设置 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DefaultContext}。
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defaultContext
     *            新的 DefaultContext
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addDefaultContext(DefaultContext defaultContext);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 为新的web应用程序检索 并返回 DefaultContext.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultContext getDefaultContext();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回此容器表示的虚拟主机的规范、完全限定的名称
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置此容器表示的虚拟主机的规范、完全限定的名称
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     *            虚拟主机的名称
     *
     * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt;&lt;span&gt; IllegalArgumentException
     *                如果这个名字是 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; --------------------------------------------------------- Public Methods&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 将DefaultContext 的 config 导入到web应用程序上下文中。
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     *            导入默认Context的web应用程序Context
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; importDefaultContext(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加应该映射到同一主机的别名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; alias
     *            要被添加的别名
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addAlias(String alias);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 返回此主机的别名集。如果没有定义，则返回一个零长度数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] findAliases();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 返回一个用来处理引用Http请求的 Context 根据 请求的URI 若果不存在则返回
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; uri
     *            Request URI to be mapped
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Context map(String uri);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从此主机的别名中删除指定的别名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; alias
     *            要被删除的别名
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeAlias(String alias);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面说下它在Tomat中的标准实现&lt;/p&gt;
&lt;h2&gt;StandardHost类&lt;/h2&gt;
&lt;p&gt;　　在Catalina中的  org.apache.catalina.core.StandardHost类 是 org.apache.catalin.Host接口的标准实现，该类继承自 org.apache.catalina.core.ContainerBase类 ，实现了 Host 和 Deployer接口。&lt;/p&gt;
&lt;p&gt;与StandardContext 和 StandardWrapper 类 相似，StandardHost类的构造器函数会将一个基础阀的实例 添加到其管道对相中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * 创建一个带有基础阀的 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt;  StandardHost}实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StandardHost() {

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        pipeline.setBasic(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardHostValve());

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么 它的基础阀 就是 org.apahce.catalina.core.StandardHostValue类的实例，&lt;/p&gt;
&lt;p&gt;　　当调用 StandardHost 类的 start()方法时，StandardHost实例 会新添加两个阀，分别是 ErrorReportValue类 和 ErrorDispatcherValue类的实例，这个两个阀均位于org.apahce.catalina.values包下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 启动这个Host.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt;&lt;span&gt; LifecycleException
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *                如果此组件检测到阻止其启动的致命错误
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 errorReportValveClass 阀的 完全限定名 不为空 的话 &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((errorReportValveClass != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; (!errorReportValveClass.equals(&quot;&quot;&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Valve valve =&lt;span&gt; (Valve) Class.forName(errorReportValveClass).newInstance();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加这个ErrorReportValve阀&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                addValve(valve);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 log(sm.getString(&quot;standardHost.invalidErrorReportValveClass&quot;&lt;span&gt;, errorReportValveClass));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个ErrorDispatcherValve阀&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         addValve(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ErrorDispatcherValve());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.start();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量 errorReportValueClass的值 定义在StandardHost类中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; String errorReportValveClass = &quot;org.apache.catalina.valves.ErrorReportValve&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每当引入一个Http请求的时候，都会调用StandardHost实例的 invoke方法，由于StandardHost类并没有提供invoke方法的实现，因此它会调用父类 ContainerBase 类的 invoke方法，而ContainerBase类 的invoke方法将会调用StandardHost类的 基础阀StandardHostValue实例的invoke方法，StandardHostValue的invoke方法将会调用StandardHostr类的map方法来获取响应的Context实例来处理Http请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 返回一个Context实例 来处理这个 相对于Host容器的 相对URI所代表的请求，如果没有则返回 &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; uri
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *            要被映射的请求URI
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Context map(String uri) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (debug &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             log(&quot;Mapping request URI '&quot; + uri + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (uri == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Match on the longest possible context path prefix
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配可能是最长的Context路径前缀&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (debug &amp;gt; 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             log(&quot;  Trying the longest context path prefix&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Context context = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         String mapuri =&lt;span&gt; uri;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不断尝试根据路径去子容器中找对应的Context&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             context =&lt;span&gt; (Context) findChild(mapuri);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (context != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; slash = mapuri.lastIndexOf('/'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (slash &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不断截取路径最后一个/之前的路径 做匹配路径&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             mapuri = mapuri.substring(0&lt;span&gt;, slash);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有匹配到Context 则选择 默认的Context&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (debug &amp;gt; 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 log(&quot;  Trying the default context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             context = (Context) findChild(&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还是没有选中的 Context 直接返回null 并返回 错误信息&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             log(sm.getString(&quot;standardHost.mappingError&quot;&lt;span&gt;, uri));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回映射的上下文（如果有的话）&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (debug &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             log(&quot; Mapped to context '&quot; + context.getPath() + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (context);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今天想更新到这里 明天继续搞起&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 14:17:00 +0000</pubDate>
<dc:creator>陈东的博客</dc:creator>
<og:description>这边文章主要介绍的是Host容器 和 Engine容器。如果你想在同一个Tomcat上部署运行多个Context容器的话，你就需要使用Host容器，从理论上来讲，如果你的Tomcat只想要部署一个Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChenD/p/10125124.html</dc:identifier>
</item>
<item>
<title>ResNet 论文研读笔记 - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/10124903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/10124903.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1512.03385.pdf&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深度神经网络很难去训练，本文提出了一个残差学习框架来简化那些非常深的网络的训练，该框架使得层能根据其输入来学习残差函数而非原始函数。本文提出证据表明，这些残差网络的优化更简单，而且通过增加深度来获得更高的准确率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深度网络很好的将一个端到端的多层模型中的低/中/高级特征以及分类器整合起来，特征的等级可以通过所堆叠层的数量来丰富。有结果显示，模型的深度发挥着至关重要的作用&lt;/p&gt;
&lt;p&gt;在深度的重要性的驱使下，出现了一个新的问题：训练一个更好的网络是否和堆叠更多的层一样简单呢？解决这一问题的障碍便是困扰人们很久的梯度消失/梯度爆炸，这从一开始便阻碍了模型的收敛。归一初始化（normalized initialization）和中间归一化（intermediate normalization）在很大程度上解决了这一问题，它使得数十层的网络在反向传播的随机梯度下降（SGD）上能够收敛。当深层网络能够收敛时，一个退化问题又出现了：随着网络深度的增加，准确率达到饱和（不足为奇）然后迅速退化。意外的是，这种退化并不是由过拟合造成的，并且在一个合理的深度模型中增加更多的层却导致了更高的错误率&lt;/p&gt;
&lt;p&gt;深层&quot;plain&quot;网络的在CIFAR-10上的错误率&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215215634811-1093988336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;退化的出现（训练准确率）表明了并非所有的系统都是很容易优化的。本文提出了一种深度残差学习框架来解决这个退化问题。方法是让这些层来拟合残差映射，而不是让每一个堆叠的层直接来拟合所需的底层映射。假设所需的底层映射为&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;，让堆叠的非线性层来拟合另一个映射：&lt;span class=&quot;math inline&quot;&gt;\(F(x):=H(x)−x\)&lt;/span&gt;。 因此原来的映射转化为：&lt;span class=&quot;math inline&quot;&gt;\(F(x)+x\)&lt;/span&gt;，研究者推断残差映射比原始未参考的映射（unreferenced mapping）更容易优化，在极端的情况下，如果某个恒等映射是最优的，那么将残差变为0比用非线性层的堆叠来拟合恒等映射更简单&lt;/p&gt;
&lt;p&gt;公式 F(x)+x 可以通过前馈神经网络的&lt;strong&gt;“shortcut连接”&lt;/strong&gt;来实现，Shortcut连接就是跳过一个或者多个层。shortcut 连接只是简单的执行恒等映射，再将它们的输出和堆叠层的输出叠加在一起。恒等的shortcut连接并不增加额外的参数和计算复杂度。完整的网络仍然能通过端到端的SGD反向传播进行训练，并且能够简单的通过公共库（例如，Caffe）来实现而无需修改求解器&lt;/p&gt;
&lt;p&gt;一个残差网络构建块(Fig.2)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215215836100-333602106.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文表明&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;极深的残差网络是很容易优化的，但是对应的“plain”网络（仅是堆叠了层）在深度增加时却出现了更高的错误率&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;深度残差网络能够轻易的由增加层来提高准确率，并且结果也大大优于以前的网络&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;深度残差学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;残差学习&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;看作一个由部分堆叠的层来拟合的底层映射，其中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;是这些层的输入。假设多个非线性层能够逼近复杂的函数，这就等价于这些层能够逼近复杂的残差函数，例如，&lt;span class=&quot;math inline&quot;&gt;\(H(x) - x\)&lt;/span&gt;。我们明确地让这些层来估计一个残差函数：&lt;span class=&quot;math inline&quot;&gt;\(F(x):=H(x)−x\)&lt;/span&gt;而不是&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;。因此原始函数变成了：&lt;span class=&quot;math inline&quot;&gt;\(F(x)+x\)&lt;/span&gt;。尽管这两个形式应该都能够逼近所需的函数，但是前者更易学习。使用这种表达方式的原因是之前提到的退化问题，使用残差学习的方式重新表达后，如果恒等映射是最优的，那么求解器将驱使多个非线性层的权重趋向于零来逼近恒等映射。如果最优函数更趋近于恒等映射而不是0映射，那么对于求解器来说寻找关于恒等映射的扰动比学习一个新的函数要容易的多，实验表明，学习到的残差函数通常只有很小的响应，说明了恒等映射提供了合理的预处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过捷径进行identity mapping&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在堆叠层上采取残差学习算法，一个构件块如上图(Fig.2)所示，其定义为(Eq.1)&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = F(x, {W_i}) + x \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;分别表示层的输入和输出。函数&lt;span class=&quot;math inline&quot;&gt;\(F(x, {Wi})\)&lt;/span&gt;代表着学到的残差映射，该shortcut连接没有增加额外的参数和计算复杂度&lt;/p&gt;
&lt;p&gt;在Eq.1中，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的维度必须相同，如果不同，可以通过shortcut连接执行一个线性映射&lt;span class=&quot;math inline&quot;&gt;\(W_s\)&lt;/span&gt; 来匹配两者的维度(Eq.2)&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = F({x, {W_i}}) + W_sx \]&lt;/span&gt;&lt;br/&gt;实验表明，恒等映射已足够解决退化问题，并且是经济的，因此&lt;span class=&quot;math inline&quot;&gt;\(W_s\)&lt;/span&gt;只是用来解决维度不匹配的问题&lt;/p&gt;
&lt;p&gt;不仅是对于全连接层，对于卷积层残差连接也是同样适用的。函数&lt;span class=&quot;math inline&quot;&gt;\(F(x, {W_i})\)&lt;/span&gt;可以表示多个卷积层，在两个特征图的通道之间执行元素级的加法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VGG、普通网络与残差网络的配置对比&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215215916082-1171961353.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细架构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215215929708-1488981016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;普通网络&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;卷积层主要为3*3的滤波器，并遵循以下两点要求&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输出特征尺寸相同的层含有相同数量的滤波器&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果特征尺寸减半，则滤波器的数量增加一倍来保证每层的时间复杂度相同&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;直接通过stride为2的卷积层来进行下采样。在网络的最后是一个全局的平均pooling层和一个1000 类的包含softmax的全连接层。加权层的层数为34&lt;/p&gt;
&lt;p&gt;&lt;em&gt;残差网络&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在普通网络的基础上，插入shortcut连接，将网络变成了对应的残差版本。如果输入和输出的维度相同时，可以直接使用恒等shortcuts(Eq.1)(残差连接实线部分)，当维度增加时(残差连接虚线部分)，考虑两个选项&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;shortcut仍然使用恒等映射，在增加的维度上使用0来填充，这样做不会增加额外的参数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用Eq.2的映射shortcut来使维度保持一致（通过1*1的卷积）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于这两个选项，当shortcut跨越两种尺寸的特征图时，均使用stride为2的卷积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;普通网络&lt;/em&gt;&lt;br/&gt;实验表明34层的网络比18层的网络具有更高的验证错误率，比较了训练过程中的训练及验证错误率之后，观测到了明显的退化现象----在整个训练过程中34 层的网络具有更高的训练错误率，即使18层网络的解空间为34层解空间的一个子空间&lt;/p&gt;
&lt;p&gt;&lt;em&gt;残差网络&lt;/em&gt;&lt;br/&gt;实验观察到以下三点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;34层的ResNet比18层ResNet的结果更优。更重要的是，34 层的ResNet在训练集和验证集上均展现出了更低的错误率。这表明了这种设置可以很好的解决退化问题，并且可以由增加的深度来提高准确率&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;与对应的普通网络相比，34层的ResNet在top-1 错误率上降低了3.5%，这得益于训练错误率的降低，也验证了在极深的网络中残差学习的有效性&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;18层的普通网络和残差网络的准确率很接近，但是ResNet 的收敛速度要快得多&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;错误率比较&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215215959159-2104193982.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果网络&quot;并不是特别深&quot;(如18层)，现有的SGD能够很好的对普通网络进行求解，而ResNet能够使优化得到更快的收敛&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;恒等 vs 映射 Shortcuts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;已经验证了无参数的恒等shortcuts是有助于训练的。接下来研究映射shortcut(Eq.2)，比较了三种选项&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对增加的维度使用0填充，所有的shortcuts是无参数的&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;对增加的维度使用映射shortcuts，其它使用恒等shortcuts&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;所有的都是映射shortcuts&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实验表明三种选项的模型都比普通模型要好，2略好于1，研究者认为这是因为1中的0填充并没有进行残差学习。3略好于2，研究者将其归结于更多的（13个）映射shortcuts所引入的参数，实验结果也表明映射shortcuts对于解决退化问题并不是必需的，因此为了减少复杂度和模型尺寸，在之下的研究中并不使用模型3。恒等shortcuts因其无额外复杂度而对以下介绍的瓶颈结构尤为重要&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度瓶颈结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将构建块修改为瓶颈设计。对于每一个残差函数&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;，使用了三个叠加层而不是两个，这三层分别是1*1、3*3 和1*1 的卷积，1*1 的层主要负责减少然后增加（恢复）维度，剩下的3*3的层来减少输入和输出的维度&lt;/p&gt;
&lt;p&gt;构建块(Fig.5)，这两种设计具有相似的时间复杂度&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215220019261-329015051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无参数的恒等shortcuts对于瓶颈结构尤为重要。如果使用映射shortcuts来替代Fig.5(右)中的恒等shortcuts，将会发现时间复杂度和模型尺寸都会增加一倍，因为shortcut连接了两个高维端，所以恒等shortcuts对于瓶颈设计是更加有效的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层响应分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在CIFAR-10上层响应的标准方差(std)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215220058122-1503938552.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以标准方差来展示层响应，响应是每一个3*3卷积层的BN之后、非线性层(ReLU/addition)之前的输出，实验表明ResNets的响应比它对应的普通网络的响应要小，即残差函数比非残差函数更接近于0，同时越深的ResNet的响应幅度越小。当使用越多层时，ResNets中单个层对信号的改变越少&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;网络随着深度的增加，训练误差和测试误差非但没有降低，反而变大了，然而这种问题的出现并不是因为过拟合，该现象被称为退化问题(degradation problem)，本文即是为了解决深度神经网络中产生的退化问题&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;作为我们的输入，期望的输出是&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;，如果我们直接把输入&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;传到输出作为初始结果，那么我们需要学习的目标就变成了&lt;span class=&quot;math inline&quot;&gt;\(F(X) = H(x) - x\)&lt;/span&gt;。Resnet相当于将学习目标改变了，不再是学习一个完整的输出&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;，而是&lt;span class=&quot;math inline&quot;&gt;\(H(x)-x\)&lt;/span&gt;，即残差，进行这样的改变不会计算量和参数，却能使网络更容易优化。然后，ResNet就是在原来网络的基础上，每隔2层（或者3层，或者更多）的输出&lt;span class=&quot;math inline&quot;&gt;\(F(x)\)&lt;/span&gt;上再加上之前的输入&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;。这样做，整个网络就可以用SGD方法进行端对端的训练，用目前流行的深度学习库（caffe等）也可以很容易地实现&lt;/p&gt;
&lt;p&gt;本文提出的深度残差学习架构，其中的构建块为&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201812/1503464-20181215220115873-1134690967.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该结构的思想就是：如果增加的层能够改善恒等映射，更深的网络应该不会比对应的浅层网络的训练误差大。如果恒等映射是最优的，训练会驱使增加的非线性层的权重趋于0以靠近恒等映射&lt;/p&gt;
&lt;p&gt;这种网络的优点有&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更容易优化&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;网络越深，准确率越高&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hejunlin1992/p/7751516.html&quot;&gt;[论文阅读] Deep Residual Learning for Image Recognition(ResNet)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/ymjyqsx/p/6694061.html&quot;&gt;Deep Residual Learning for Image Recognition(残差网络)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 14:02:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>ResNet 论文研读笔记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/10124903.html</dc:identifier>
</item>
<item>
<title>分块入门与分块的经典应用 - henry_y</title>
<link>http://www.cnblogs.com/henry-1202/p/10124856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henry-1202/p/10124856.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;分块是一种应用很广的根号算法&lt;/p&gt;
&lt;p&gt;有一个别名为“优雅的暴力”&lt;/p&gt;
&lt;p&gt;这篇文章偏向于介绍分块入门，并且讲解了几种OI中经典的分块套路&lt;/p&gt;
&lt;p&gt;（因为几道例题我做的时间间隔有点远，所以可能会有几种奇奇怪怪的不同的码风，请强迫症患者谨慎食用）&lt;/p&gt;
&lt;h2 id=&quot;分块入门&quot;&gt;分块入门&lt;/h2&gt;
&lt;h3 id=&quot;例题a-simple-problem-with-integers&quot;&gt;例题：A Simple Problem with Integers&lt;/h3&gt;
&lt;p&gt;给一个序列，支持区间加，区间查询&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(N&amp;lt;=100000\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(Ai&amp;lt;=1e9\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(M&amp;lt;=100000\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;M为操作数&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（其实就是线段树1）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;线段树和树状数组的板子题&lt;/p&gt;
&lt;p&gt;但是这里不讲线段树和树状数组的做法&lt;/p&gt;
&lt;p&gt;我们回归本真，思考一下使用暴力解决该题&lt;/p&gt;
&lt;p&gt;使用前缀和维护&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;修改 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;查询&lt;/p&gt;
&lt;p&gt;直接加&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;修改 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;查询&lt;/p&gt;
&lt;p&gt;当然。都会TLE&lt;del&gt;(雾&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;考虑优化，发现两种暴力都是有明显的复杂度瓶颈（一个在查询一个在修改）&lt;/p&gt;
&lt;p&gt;我们是不是可以以牺牲一种操作的复杂度为代价降低另一种操作的复杂度？（当然，总的复杂度需要比原先的复杂度低）&lt;/p&gt;
&lt;p&gt;这就需要使用到分块的思想&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;块：将整个序列划分为多段序列，这些序列被称之为块&lt;/p&gt;
&lt;p&gt;块的大小：块内元素个数（一般为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt(n)\)&lt;/span&gt;，但是可以根据不同的题目使用均值不等式计算出更优的块大小，一般用于卡常。平时用&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;就可以了），记为&lt;span class=&quot;math inline&quot;&gt;\(block\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;块的个数：&lt;span class=&quot;math inline&quot;&gt;\(num=n/block\)&lt;/span&gt;。即为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;，这也是为什么我们块的大小要选择&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;的原因，让大小和块数尽可能均衡，使查询，修改的复杂度都为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整块：在查询/修改操作中，一整个块都被包含在操作的区间中（如对于区间[1…10]，块[1…3]即为整块）&lt;/p&gt;
&lt;p&gt;散块：在查询/修改操作中，部分元素被包含在操作区间中的块（如对于区间[1…10]，块[10]即为散块）&lt;/p&gt;
&lt;p&gt;显然，对于每个操作，散块最多2个，整块最多&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;个&lt;/p&gt;
&lt;p&gt;一个序列，我们把它分成&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;块&lt;/p&gt;
&lt;p&gt;然后对于每个块分别统计前缀和&lt;/p&gt;
&lt;p&gt;查询的时候我们需要使用&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;的时间来统计答案&lt;/p&gt;
&lt;p&gt;查询的时候是给出一个区间[l…r]，因为我们把整个序列分成&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;块，所以对于[l…r]这个区间，我们需要统计的整个的块的数目不超过&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;个，对于两边边边角角的部分，我们直接使用暴力，也只需要&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;时间&lt;/p&gt;
&lt;p&gt;总的复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于修改操作，复杂度仍然存在瓶颈，我们仍然需要&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;修改每一块的前缀和&lt;/p&gt;
&lt;p&gt;引入一个东西：懒标记&lt;/p&gt;
&lt;p&gt;就是线段树下推时的那个玩意&lt;/p&gt;
&lt;p&gt;对于一个区间内所包含的整块&lt;/p&gt;
&lt;p&gt;我们只需要给当前块的懒标记加一下就好，查询的时候记得把每块的懒标记的值也给加上就好&lt;/p&gt;
&lt;p&gt;对于散块，我们暴力修改原数组，然后统计一下前缀和就好，因为散块最多只有两个，所以复杂度也是&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总的修改复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以对于一开始的那道题，使用分块对暴力进行优化我们可以在&lt;span class=&quot;math inline&quot;&gt;\(O((n+m)\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以说分块是一种优雅的暴力&lt;/p&gt;
&lt;p&gt;分块思想：&lt;strong&gt;整体维护，局部暴力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑到我就这么空泛的去讲估计也很虚，所以放个代码，代码内有一定量注释（并不多，请结合上文理解）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define ll long long
#define inf 0x3f3f3f3f 
#define il inline 

namespace io {//读优
    
    #define int long long
    #define in(a) a=read()
    #define out(a) write(a)
    #define outn(a) out(a),putchar('\n')

    #define I_int int 
    inline I_int read() {
        I_int x = 0 , f = 1 ; char c = getchar() ;
        while( c &amp;lt; '0' || c &amp;gt; '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; } 
        while( c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; } 
        return x * f ;
    } 
    char F[ 200 ] ;
    inline void write( I_int x ) {
        if( x == 0 ) { putchar( '0' ) ; return ; }
        I_int tmp = x &amp;gt; 0 ? x : -x ;
        if( x &amp;lt; 0 ) putchar( '-' ) ;
        int cnt = 0 ;
        while( tmp &amp;gt; 0 ) {
            F[ cnt ++ ] = tmp % 10 + '0' ;
            tmp /= 10 ;
        }
        while( cnt &amp;gt; 0 ) putchar( F[ -- cnt ] ) ;
    }
    #undef I_int

}
using namespace io ;

using namespace std ;

#define N 100010
#define M 5000

int block , num ;
// block - 块的大小
// num - 块的个数
int a[ N ] ;
// a - 原数组
int sum[ M ] , add[ M ] , L[ M ] , R[ M ] , bl[ N ] ;
// sum - 区间和
// add - 懒标记
// L - 块左端点 R - 块右端点 bl - 当前点属于哪个块
int n = read() , m = read() ;
 
void build() {
    block = sqrt( n ) ;
    num = n / block ;
    if( n % block ) num ++ ;
    for( int i = 1 ; i &amp;lt;= num ; i ++ ) {
        L[ i ] = (i - 1) * block + 1 ;
        R[ i ] = i * block ;
    }
    R[ num ] = n ; // 有可能有不完整的块 
    for( int i = 1 ; i &amp;lt;= n ; i ++ ) {
        bl[ i ] = (i - 1) / block + 1 ;
        // -1 针对右端点， +1 针对左端点 
    }
    for( int k = 1 ; k &amp;lt;= num ; k ++ ) {
        for( int i = L[ k ] ; i &amp;lt;= R[ k ] ; i ++ ) {
            sum[ k ] += a[ i ] ; //处理前缀和 
        }
    }
}

void reset( int x ) { // 重新统计当前块的和 
    sum[ x ] = 0 ;
    for( int i = L[ x ] ; i &amp;lt;= R[ x ] ; i ++ ) 
        sum[ x ] += a[ i ] ;
}

void upd( int l , int r , int c ) {
    if( bl[ l ] == bl[ r ] ) { // 特判 
        for( int i = l ; i &amp;lt;= r ; i ++ ) a[ i ] += c ;
        reset( bl[ l ] ) ;
        return ;
    }
    for( int i = l ; i &amp;lt;= R[ bl[ l ] ] ; i ++ ) // 处理散块 
        a[ i ] += c ;
    for( int i = L[ bl[ r ] ] ; i &amp;lt;= r ; i ++ ) 
        a[ i ] += c ;
    reset( bl[ l ] ) ; reset( bl[ r ] ) ;
    // 处理整块 
    for( int i = bl[ l ] + 1 ; i &amp;lt; bl[ r ] ; i ++ ) 
        add[ i ] += c ;
}

int query( int l , int r ) {
    int ans = 0 ;
    if( bl[ l ] == bl[ r ] ) {
        for( int i = l ; i &amp;lt;= r ; i ++ ) 
            ans += a[ i ] + add[ bl[ i ] ] ;
        return ans ;
    }
    for( int i = l ; i &amp;lt;= R[ bl[ l ] ] ; i ++ ) 
        ans += a[ i ] + add[ bl[ i ] ] ;
    for( int i = L[ bl[ r ] ] ; i &amp;lt;= r ; i ++ ) 
        ans += a[ i ] + add[ bl[ i ] ] ;
    for( int i = bl[ l ] + 1 ; i &amp;lt; bl[ r ] ; i ++ ) 
        ans += sum[ i ] + add[ i ] * (R[ i ] - L[ i ] + 1) ;
    return ans ;
}

signed main() {
    for( int i = 1 ; i &amp;lt;= n ; i ++ ) a[ i ] = read() ;
    build() ;
    for( int i = 1 ; i &amp;lt;= m ; i ++ ) {
        int opt = read() , x = read() , y = read() , k ;
        if( opt == 1 ) {
            k = read() ;
            upd( x , y , k ) ;
        } else outn( query( x , y ) ) ;
    }
    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分块的应用&quot;&gt;分块的应用&lt;/h2&gt;
&lt;p&gt;在讲应用之前插播一个东西&lt;/p&gt;
&lt;h3 id=&quot;分块与树状数组线段树对比&quot;&gt;分块与树状数组，线段树对比&lt;/h3&gt;
&lt;p&gt;树状数组和线段树的效率均为&lt;span class=&quot;math inline&quot;&gt;\(O(nlogn)\)&lt;/span&gt;，树状数组常数较小，分块效率为&lt;span class=&quot;math inline&quot;&gt;\(O(n\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般树状数组常数优秀的话可以承受到1e6的数据范围&lt;/p&gt;
&lt;p&gt;线段树可以承受5e5的数据范围&lt;/p&gt;
&lt;p&gt;分块可以承受5e4的数据范围，常数优秀的话可以承受1e5的数据范围&lt;/p&gt;
&lt;p&gt;树状数组最难理解，代码实现最简单&lt;/p&gt;
&lt;p&gt;线段树较易理解，代码实现最复杂，常数较之树状数组会比较大&lt;/p&gt;
&lt;p&gt;分块易理解，代码实现难度适中，复杂度较高&lt;/p&gt;
&lt;p&gt;所以请根据实际情况选择不同的算法&lt;/p&gt;
&lt;h3 id=&quot;分块块的大小的取值问题&quot;&gt;分块块的大小的取值问题&lt;/h3&gt;
&lt;p&gt;最懒的取法：&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最正规的取法：用均值不等式来推&lt;/p&gt;
&lt;p&gt;最玄学的取法：在&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;/均值不等式所推出来的大小上下浮动，可能会取出更优&lt;br/&gt;的块的大小&lt;/p&gt;
&lt;p&gt;好的取值可以帮助你卡更多的分（这点在后面蒲公英那道题很明显的体现了出来）&lt;/p&gt;
&lt;p&gt;然后不知道均值不等式怎么推？&lt;/p&gt;
&lt;p&gt;在&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;上下浮动，是上还是下根据实际情况：&lt;/p&gt;
&lt;p&gt;对于询问比修改多的操作，向上浮动&lt;/p&gt;
&lt;p&gt;对于修改比询问多的操作，向下浮动&lt;/p&gt;
&lt;p&gt;但其实正常情况下（即大部分题目）&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;就够可以了，少部分题目才需要推块的大小来卡常（以及你的分块暴力如果想拿高分也可以推一下块的大小）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几种应用将以例题形式呈现&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;luogu-p2801-教主的魔法&quot;&gt;Luogu P2801 教主的魔法&lt;/h3&gt;
&lt;p&gt;区间加，查询一个区间中大于等于k的数的个数&lt;/p&gt;
&lt;p&gt;N&amp;lt;=1e6&lt;/p&gt;
&lt;p&gt;按理说没办法过，但是事实上跑的挺快的&lt;/p&gt;
&lt;p&gt;将块内元素排序。&lt;/p&gt;
&lt;p&gt;修改时使用懒标记，对于散块暴力修改然后重新排序&lt;/p&gt;
&lt;p&gt;可以做到&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;修改&lt;/p&gt;
&lt;p&gt;如何查询？&lt;/p&gt;
&lt;p&gt;因为每个块是互不影响的。所以我们可以对每个块二分查找第一个大于等于它的数的下标，区间右端点减去该下标即为该区间对答案的贡献。&lt;/p&gt;
&lt;p&gt;散块依旧暴力查询&lt;/p&gt;
&lt;p&gt;查询复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n}*log2(\sqrt{n}))\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

#define N 1000100

int n,m,a[N];
int block,num,l[N],r[N],belong[N],sum[N],add[N];

void build(){
    block=sqrt(n);
    num=n/block;
    if(n%block)num++;
    for(int i=1;i&amp;lt;=num;i++){
        l[i]=block*(i-1)+1;
        r[i]=block*i;
    }
    r[num]=n;
    for(int i=1;i&amp;lt;=n;i++){
        belong[i]=(i-1)/block+1;
        sum[i]=a[i];
    }
    for(int i=1;i&amp;lt;=num;i++){
        sort(sum+l[i],sum+r[i]+1);
    }
}

void copy(int x){
    for(int i=l[x];i&amp;lt;=r[x];i++){
        sum[i]=a[i];
    }
    sort(sum+l[x],sum+r[x]+1);
}

void upd(int L,int R,int c){
    if(belong[L]==belong[R]){
        for(int i=L;i&amp;lt;=R;i++){
            a[i]+=c;
        }
        copy(belong[L]);
        return;
    }
    for(int i=L;i&amp;lt;=r[belong[L]];i++)a[i]+=c;
    copy(belong[L]);
    for(int i=l[belong[R]];i&amp;lt;=R;i++)a[i]+=c;
    copy(belong[R]);
    for(int i=belong[L]+1;i&amp;lt;=belong[R]-1;i++)add[i]+=c;
}

int find(int L,int R,int c){
    int r1=R;
    while(L&amp;lt;=R){
        int mid=(L+R)&amp;gt;&amp;gt;1;
        if(sum[mid]&amp;lt;c)L=mid+1;
        else R=mid-1;
    }
    return r1-L+1;
}

int query(int L,int R,int c){
    int ans=0;
    if(belong[L]==belong[R]){
        for(int i=L;i&amp;lt;=R;i++){
            if(a[i]+add[belong[i]]&amp;gt;=c)ans++;
        }
        return ans;
    }
    for(int i=L;i&amp;lt;=r[belong[L]];i++){
        if(a[i]+add[belong[i]]&amp;gt;=c)ans++;
    }
    for(int i=l[belong[R]];i&amp;lt;=R;i++){
        if(a[i]+add[belong[i]]&amp;gt;=c)ans++;
    }
    for(int i=belong[L]+1;i&amp;lt;=belong[R]-1;i++){
        ans+=find(l[i],r[i],c-add[i]);
    }
    return ans;
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%d&quot;,&amp;amp;a[i]);
    build();
    for(int i=1;i&amp;lt;=m;i++){
        char ch[10];
        int L,R,c;
        scanf(&quot;%s%d%d%d&quot;,ch,&amp;amp;L,&amp;amp;R,&amp;amp;c);
        if(ch[0]=='M')upd(L,R,c);
        else printf(&quot;%d\n&quot;,query(L,R,c));
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bzoj-2002弹飞绵羊&quot;&gt;BZOJ 2002:弹飞绵羊&lt;/h3&gt;
&lt;p&gt;对每个点点处理出跳出当前块要跳多少次，跳出当前块之后在哪个地方。&lt;/p&gt;
&lt;p&gt;因为是单点修改，所以直接修改整个块内的每个点就好，效率&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于查询，直接从当前点开始跳，只需要跳&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;次，所以也是&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#define ll long long
#define N 200010
inline void read(int &amp;amp;x){
    x=0;int f=1;char c=getchar();
    while(c&amp;lt;'0'||c&amp;gt;'9'){if(c=='-')f=-f;c=getchar();}
    while(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9'){x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+c-'0';c=getchar();}
    x*=f;
}
using namespace std;
int n,a[N],m;
int block,num,to[N],d[N],l[N],r[N],belong[N];
void build(){
    block=sqrt(n),num=n/block;
    if(n%block)num++;
    for(int i=1;i&amp;lt;=num;i++){
        l[i]=(i-1)*(block)+1;
        r[i]=block*i;
    } 
    r[num]=n;
    for(int i=1;i&amp;lt;=n;i++){
        belong[i]=(i-1)/block+1;
    }
    for(int i=n;i;i--){
        if(belong[i+a[i]]!=belong[i]){
            d[i]=1;
            to[i]=i+a[i];
        }else {
            d[i]=d[i+a[i]]+1;
            to[i]=to[i+a[i]];
        }
    }
}
void upd(int x,int c){
    a[x]=c;
    for(int i=r[belong[x]];i&amp;gt;=l[belong[x]];i--){
        if(belong[i+a[i]]!=belong[i]){
            to[i]=i+a[i];
            d[i]=1;
        }else {
            d[i]=d[i+a[i]]+1;
            to[i]=to[i+a[i]];
        }
    }
}
int query(int x){
    int ans=0;
    while(x&amp;lt;=n){
        ans+=d[x];
        x=to[x];
    }
    return ans;
}
int main(){
    read(n);
    for(int i=1;i&amp;lt;=n;i++)read(a[i]);
    build();
    read(m);
    while(m--){
        int x,y;
        read(x);read(y);
        if(x==1)printf(&quot;%d\n&quot;,query(y+1));
        else {
            int k;read(k);
            upd(y+1,k);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bzoj-2120-数颜色&quot;&gt;BZOJ 2120: 数颜色&lt;/h3&gt;
&lt;p&gt;对每个点预处理出该点颜色的上一次在哪里出现，设为pre。&lt;/p&gt;
&lt;p&gt;那么在一个区间里面，颜色i第一次出现即意味着pre_i&amp;lt;l（l为区间左端点）&lt;/p&gt;
&lt;p&gt;所以我们可以套用教主的魔法那题的套路，对pre进行排序，查询时在块内二分查找得到该块对答案的贡献。复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n}*log2(\sqrt{n}))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是这题不一样的是修改操作，这道题的修改需要O(n)的时间来修改（需要把整个的pre数组都给改了）&lt;/p&gt;
&lt;p&gt;因为BZOJ保证了修改的操作&amp;lt;=1000所以这题就可以用分块水了&lt;/p&gt;
&lt;p&gt;正解是带修莫队。&lt;/p&gt;
&lt;p&gt;luogu加强了数据这种分块写法只能水40分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

inline void read( int &amp;amp;x ){
    x = 0 ; int f = 1 ; char c = getchar() ;
    while( c &amp;lt; '0' || c &amp;gt; '9' ) {
        if( c == '-' ) f = -1 ;
        c = getchar() ;
    }
    while( c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9' ) {
        x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + c - 48 ;
        c = getchar() ;
    }
    x *= f ;
}

#define N 1000100

int belong[N],block,num,pre[N],last[N];
int n,a[N],m,b[N];

void reset(int x){
    int l=(x-1)*block+1,r=min(n,block*x);
    for(int i=l;i&amp;lt;=r;i++)pre[i]=b[i];
    sort(pre+l,pre+r+1);
}

void build(){
    block=int(sqrt(n)+log(2*n)/log(2));
    num=n/block;
    if(n%block)num++;
    for(int i=1;i&amp;lt;=n;i++){
        b[i]=last[a[i]];
        belong[i]=(i-1)/block+1;
        last[a[i]]=i;
    }
    for(int i=1;i&amp;lt;=num;i++)reset(i);
}

int find(int i,int x){
    int lt=(i-1)*block+1,l=lt,r=min(i*block,n);
    while(l&amp;lt;=r){
        int mid=(l+r)&amp;gt;&amp;gt;1;
        if(pre[mid]&amp;lt;x)l=mid+1;
        else r=mid-1;
    }
    return l-lt;
}

int query(int l,int r){
    int ans=0;
    if(belong[l]==belong[r]){
        for(int i=l;i&amp;lt;=r;i++){
            if(b[i]&amp;lt;l)ans++;
        }
        return ans;
    }
    for(int i=l;i&amp;lt;=belong[l]*block;i++){
        if(b[i]&amp;lt;l)ans++;
    }
    for(int i=(belong[r]-1)*block+1;i&amp;lt;=r;i++){
        if(b[i]&amp;lt;l)ans++;
    }
    for(int i=belong[l]+1;i&amp;lt;belong[r];i++){
        ans+=find(i,l);
    }
    return ans;
}

void upd(int l,int x){
    for(int i=1;i&amp;lt;=n;i++)last[a[i]]=0;
    a[l]=x;
    for(int i=1;i&amp;lt;=n;i++){
        int lt=b[i];
        b[i]=last[a[i]];
        if(lt!=b[i])reset(belong[i]);
        last[a[i]]=i;
    }
}

int main(){
    read( n ) ; read( m ) ;
    for(int i=1;i&amp;lt;=n;i++)read( a[i] ) ;
    build();
    for(int i=1;i&amp;lt;=m;i++){
        int l,r;
        char ch[10];
        scanf(&quot;%s&quot;,ch);
        read( l ) ; read( r ) ;
        if(ch[0]=='Q')printf(&quot;%d\n&quot;,query(l,r));
        else upd(l,r);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;luogup4168-violet蒲公英&quot;&gt;LuoguP4168 [Violet]蒲公英&lt;/h3&gt;
&lt;p&gt;在线区间众数，经典分块题&lt;/p&gt;
&lt;p&gt;做法很多，这里提供一种&lt;span class=&quot;math inline&quot;&gt;\(O(n*\sqrt{n}+n*\sqrt{n}*log2(\sqrt{n})\)&lt;/span&gt;的做法&lt;/p&gt;
&lt;p&gt;首先数的值域为1e9肯定要离散化一下，因为数最多有40000个所以开40000个vector，存一下每个数出现的位置&lt;/p&gt;
&lt;p&gt;预处理出每个以块的端点为左右端点的区间的众数，这种区间一共有&lt;span class=&quot;math inline&quot;&gt;\(O(block^2)\)&lt;/span&gt;个，所以可以用&lt;span class=&quot;math inline&quot;&gt;\(O(n*block)\)&lt;/span&gt;的时间复杂度来预处理&lt;/p&gt;
&lt;p&gt;可以发现的一点是，每个区间的众数，要么是散块里面的数，要么是中间所有整块的区间众数（因为散块中出现的那些数增加了中间的整块中第二大第三大的这些区间众数的出现次数，他们就有可能篡位了）&lt;/p&gt;
&lt;p&gt;那么我们可以在离散化之后，将每个数出现的位置存到一个vector里面，在处理散块中的数的时候，我们可以通过二分查找找出这个区间中该数出现过几次（二分查找右端点和左端点相减），效率是&lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n}*log2(\sqrt{n}))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整块直接调用我们预处理出来的区间众数就可以了&lt;/p&gt;
&lt;p&gt;块的大小可以推一下均值不等式，据说在30~200之间比较好，30最快，我在洛谷上面块的大小用200跑了9000ms用30跑了3000ms，中间的数据也试过几个，都没有30的表现好（这是开了O2的，不开O2的话200跑不过去，30跑13000ms）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define ll long long
#define inf 0x3f3f3f3f
#define il inline

namespace io {

    #define in(a) a=read()
    #define out(a) write(a)
    #define outn(a) out(a),putchar('\n')

    #define I_int int
    inline ll read() {
        ll x = 0 , f = 1 ; char c = getchar() ;
        while( c &amp;lt; '0' || c &amp;gt; '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; }
        while( c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; }
        return x * f ;
    }
    char F[ 200 ] ;
    inline void write( I_int x ) {
        if( x == 0 ) { putchar( '0' ) ; return ; }
        I_int tmp = x &amp;gt; 0 ? x : -x ;
        if( x &amp;lt; 0 ) putchar( '-' ) ;
        int cnt = 0 ;
        while( tmp &amp;gt; 0 ) {
            F[ cnt ++ ] = tmp % 10 + '0' ;
            tmp /= 10 ;
        }
        while( cnt &amp;gt; 0 ) putchar( F[ -- cnt ] ) ;
    }
    #undef I_int

}
using namespace io ;

using namespace std ;

#define N 100010

map&amp;lt; int , int &amp;gt; mp ;
vector&amp;lt; int &amp;gt; vt[ N ] ;
int val[ N ] , a[ N ] ;
int t[ 5010 ][ 5010 ] ;
int n , tot = 0 ;
int block , num , bl[ N ] , L[ N ] , R[ N ] ; 
int cnt[ N ] ;

void pre( int x ) {
    int mx = 0 , id = 0 ;
    memset( cnt , 0 , sizeof( cnt ) ) ;
    for( int i = L[ x ] ; i &amp;lt;= n ; i ++ ) {
        cnt[ a[ i ] ] ++ ;
        if( cnt[ a[ i ] ] &amp;gt; mx || (cnt[ a[ i ] ] == mx &amp;amp;&amp;amp; val[ a[ i ] ] &amp;lt; val[ id ] ) ) {
            mx = cnt[ a[ i ] ] ; id = a[ i ] ;
        }
        t[ x ][ bl[ i ] ] = id ;
    }
}

void build() {
    block = 30 ;
    num = n / block ;
    if( n % block ) num ++ ;
    for( int i = 1 ; i &amp;lt;= num ; i ++ ) {
        L[ i ] = (i - 1) * block + 1 ;
        R[ i ] = i * block ;
    }
    R[ num ] = n ;
    for( int i = 1 ; i &amp;lt;= n ; i ++ ) bl[ i ] = (i - 1) / block + 1 ;
    for( int i = 1 ; i &amp;lt;= num ; i ++ ) pre( i ) ;
}

int serach_ans( int l , int r , int x ) {
    return upper_bound( vt[ x ].begin() , vt[ x ].end() , r ) - lower_bound( vt[ x ].begin() , vt[ x ].end() , l ) ;
}

int query( int l , int r ) {
    int mx = 0 , id = t[ bl[ l ] + 1 ][ bl[ r ] - 1 ] ;
    mx = serach_ans( l , r , id ) ;
    if( bl[ l ] == bl[ r ] ) {
        for( int i = l ; i &amp;lt;= r ; i ++ ) {
            int x = serach_ans( l , r , a[ i ] ) ;
            if( x &amp;gt; mx || (x == mx &amp;amp;&amp;amp; val[ a[ i ] ] &amp;lt; val[ id ])) { mx = x ; id = a[ i ] ; }
        }
        return id ;
    }
    for( int i = l ; i &amp;lt;= R[ bl[ l ] ] ; i ++ ) {
        int x = serach_ans( l , r , a[ i ] ) ;
        if( x &amp;gt; mx || (x == mx &amp;amp;&amp;amp; val[ a[ i ] ] &amp;lt; val[ id ])) { mx = x ; id = a[ i ] ; }
    }
    for( int i = L[ bl[ r ] ] ; i &amp;lt;= r ; i ++ ) {
        int x = serach_ans( l , r , a[ i ] ) ;
        if( x &amp;gt; mx || (x == mx &amp;amp;&amp;amp; val[ a[ i ] ] &amp;lt; val[ id ])) { mx = x ; id = a[ i ] ; }
    }
    return id ;
}

int main() {
    n = read() ; int m = read() ;
    int ans = 0 ;
    for( int i = 1 ; i &amp;lt;= n ; i ++ ) {
        a[ i ] = read() ;
        if( mp[ a[ i ] ] == 0 ) { mp[ a[ i ] ] = ++ tot , val[ tot ] = a[ i ] ; }
        a[ i ] = mp[ a[ i ] ] ;
        vt[ a[ i ] ].push_back( i ) ;
    }
    build() ;
    for( int i = 1 ; i &amp;lt;= m ; i ++ ) {
        int l = read() , r = read() ;
        l = (l + ans - 1) % n + 1 , r = (r + ans - 1) % n + 1 ;
        if( l &amp;gt; r ) swap( l , r ) ;
        outn( ans = val[ query( l , r ) ] ) ;
    }
    return 0 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;分块在很多题目中是以非正解的形式出现的&lt;/p&gt;
&lt;p&gt;但是确实对于水分它是一个很好的算法&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（如果你的常数足够优秀的话甚至可以吊打正解）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（如弹飞绵羊分块吊打lct）&lt;/del&gt;&lt;/p&gt;
&lt;h3 id=&quot;其他题目&quot;&gt;其他题目&lt;/h3&gt;
&lt;p&gt;可以去写一下hzwer的数列分块入门&lt;/p&gt;
&lt;p&gt;&lt;del&gt;然后如果不怕死的话可以去写一下lxl的毒瘤分块题&lt;/del&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 13:54:00 +0000</pubDate>
<dc:creator>henry_y</dc:creator>
<og:description>前言 分块是一种应用很广的根号算法 有一个别名为“优雅的暴力” 这篇文章偏向于介绍分块入门，并且讲解了几种OI中经典的分块套路 （因为几道例题我做的时间间隔有点远，所以可能会有几种奇奇怪怪的不同的码风</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henry-1202/p/10124856.html</dc:identifier>
</item>
</channel>
</rss>