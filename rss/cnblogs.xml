<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes之初始容器(init container) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11007430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11007430.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;理解初始容器&quot;&gt;理解初始容器&lt;/h2&gt;
&lt;p&gt;一个pod里可以运行多个容器,它也可以运行一个或者多个初始容器,初始容器先于应用容器运行,除了以下两点外,初始容器和普通容器没有什么两样:&lt;/p&gt;
&lt;p&gt;如果pod中的一个初始容器运行失败,则kubernetes会尝试重启pod直到初始容器成功运行,如果pod的重启策略设置为&lt;code&gt;从不(never)&lt;/code&gt;,则不会重启.&lt;/p&gt;
&lt;p&gt;创建容器时,在podspec里添加&lt;code&gt;initContainers&lt;/code&gt;字段,则指定容器即为初始容器,它们的返回状态作为数组保存在&lt;code&gt;.status.initContainerStatuses&lt;/code&gt;里(与普通容器状态存储字段&lt;code&gt;.status.containerStatuses&lt;/code&gt;类似)&lt;/p&gt;
&lt;h3 id=&quot;初始容器和普通容器的不同&quot;&gt;初始容器和普通容器的不同:&lt;/h3&gt;
&lt;p&gt;初始容器支持所有普通容器的特征,包括资源配额限制和存储卷以及安全设置.但是对资源申请和限制处理初始容器略有不同,下面会介绍.此外,初始容器不支持可用性探针(readiness probe),因为它在&lt;code&gt;ready&lt;/code&gt;之前必须&lt;code&gt;run to completion&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果在一个pod里指定了多个初始容器,则它们会&lt;code&gt;依次&lt;/code&gt;启动起来(pod内的普通容器并行启动),并且只有上一个成功下一个才能启动.当所有的初始容器都启动了,kubernetes才开始启普通应用容器.&lt;/p&gt;
&lt;h2 id=&quot;初始容器能做什么&quot;&gt;初始容器能做什么&lt;/h2&gt;
&lt;p&gt;由于初始容器和普通应用容器是分开的镜像,因此他在做一些初始化工作很有优势:&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它们可以包含并且运行一些出于安全考虑不适合和应用放在一块的小工具.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;它们可以一些小工具和自定义代码来做些初始化工作,这样就不需要在普通应用容器里使用&lt;code&gt;sed&lt;/code&gt;,&lt;code&gt;awk&lt;/code&gt;,&lt;code&gt;python&lt;/code&gt;或者&lt;code&gt;dig&lt;/code&gt;来做初始化工作了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;应用构建者和发布者可以独立工作,而不必再联合起来处理同一个pod&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;它们使用linux &lt;code&gt;namespaces&lt;/code&gt;因此它们和普通应用pod拥有不同的文件系统视图.因此他们可以被赋予普通应用容器获取不到的&lt;code&gt;secrets&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;它们在应用容器启动前运行,因此它们可以阻止或者延缓普通应用容器的初始化直到需要的条件满足&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过执行shell命令来等待一个服务创建完成,命令如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;downward API&lt;/code&gt;把当前pod注册到远程服务器,命令如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d 'instance=$(&amp;lt;POD_NAME&amp;gt;)&amp;amp;ip=$(&amp;lt;POD_IP&amp;gt;)'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在容器启动之前等待一定时间:例如&lt;code&gt;sleep 60&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;克隆一个git仓库到存储目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过模板工具动态把一些值写入到主应用程序的配置文件里.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多详细示例请查看pod应用环境&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-initialization/&quot;&gt;布置指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初始容器使用&quot;&gt;初始容器使用&lt;/h2&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo The app is running! &amp;amp;&amp;amp; sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox
    command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
  - name: init-mydb
    image: busybox
    command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上pod定义包含两个初始容器,第一个等待&lt;code&gt;myservice&lt;/code&gt;服务可用,第二个等待&lt;code&gt;mydb&lt;/code&gt;服务可用,这两个pod执行完成,应用容器开始执行.&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;myservice&lt;/code&gt;和&lt;code&gt;mydb&lt;/code&gt;两个服务的yaml文件&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;kind: Service
apiVersion: v1
metadata:
  name: myservice
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
---
kind: Service
apiVersion: v1
metadata:
  name: mydb
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9377&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义的pod可以通过以下使用初始化和调试&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f myapp.yaml
pod/myapp-pod created&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get -f myapp.yaml

NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;kubectl logs myapp-pod -c init-myservice # Inspect the first init container
kubectl logs myapp-pod -c init-mydb      # Inspect the second init container&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们启动&lt;code&gt;mydb&lt;/code&gt;和&lt;code&gt;myservice&lt;/code&gt;两个服务后,我们可以看到初始容器完成并且&lt;code&gt;myapp-pod&lt;/code&gt; pod被创建.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f services.yaml

service/myservice created
service/mydb created&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get -f myapp.yaml
NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些示例非常简单但是应该能为你创建自己的初始容器提供一些灵感&lt;/p&gt;
&lt;h2 id=&quot;行为细节&quot;&gt;行为细节&lt;/h2&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;在启动pod的过程中,在存储卷和网络创建以后,初始容器依次创建.上一个容器必须返回成功下一个才能启动,如果由于运行时错误或者其它异常退出,它会依照&lt;code&gt;restartPolicy&lt;/code&gt;来重试,然而,如果&lt;code&gt;restartPolicy&lt;/code&gt;设置为&lt;code&gt;Always&lt;/code&gt;,初始容器实际上使用的是&lt;code&gt;OnFailure&lt;/code&gt;策略&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果pod重启了,则所有的初始容器要重新执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对初始容器的&lt;code&gt;spec&lt;/code&gt;的更改仅限于&lt;code&gt;镜像(image)&lt;/code&gt;字段的修改,更改了初始容器的镜像字段相当于重启pod&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;由于初始容器可以被重启,重试和重新执行,因此它里面的代码应当是幂等的,尤其是写入文件到&lt;code&gt;EmptyDirs&lt;/code&gt;的代码应当注意文件可能已经存在&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;容器中的所有初始容器和普通容器名称必须惟一.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;资源&quot;&gt;资源&lt;/h2&gt;
&lt;p&gt;基于初始容器的执行顺序,以下关于资源的规则适用:&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于特定资源,所有初始容器申请的最高的生效&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;对于pod,相同资源申请取以下两者较高的一个:&lt;/p&gt;
&lt;p&gt;1) 所有普通应用容器申请的资源总和&lt;br/&gt;2) 初始容器申请的生效的资源(上面说到,初始容器申请资源取所有初始容器申请最大的一个)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;调度基于生效的初始请求,这就意味着初始容器可以申请预留资源,即便在pod以后的整个生命周期都用不到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pod重启原因&quot;&gt;pod重启原因&lt;/h2&gt;
&lt;p&gt;一个pod基于以下列出的原因,会重启,重新执行初始容器:&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用户更新初始容器的&lt;code&gt;PodSpec&lt;/code&gt;导致镜像发生改变.普通应用容器改变只会使应用容器重启&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;由于&lt;code&gt;restartPolicy&lt;/code&gt;被设置为&lt;code&gt;Always&lt;/code&gt;,导致所有容器均被中止,强制重启,由于垃圾回收初始容器的初始状态记录丢失&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 12 Jun 2019 00:06:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 理解初始容器 一个pod里可以运行多个容器,它也可以运行一个或者多个初始容器,初始容器先于应用容器运行,除了以下两点外,初始容器和普通容器没有什么两样: + 它们总是 + 一个初始容器必</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11007430.html</dc:identifier>
</item>
<item>
<title>AppBoxFuture(九): 组织结构与权限体系 - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/11007400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/11007400.html</guid>
<description>&lt;p&gt;  权限体系是用于约束用户访问或操作资源的权利，这里的“资源”可以指数据，也可以指特定的功能（如审核订单）。通常的权限体系设计是基于角色的访问控制方式，用户通过角色与权限进行关联。作者的实现方式稍微有些不同，通过组织结构树与权限进行关联，这样可以实现子级节点继承上级节点设置的权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201906/4928-20190612072918425-2084750086.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组织单元(OrgUnit)：根据上级标识自引用的表结构，另通过EntityRef引用组织或工作组或员工；&lt;/li&gt;
&lt;li&gt;权限模型(PermissionModel)：框架内置的元数据，包含已赋予权限的组织单元集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;开发时根据业务需要，通过IDE主菜单-&amp;gt;New-&amp;gt;Permission新建权限模型，另可通过New-&amp;gt;Folder创建模型文件夹分门别类管理相关模型;&lt;/li&gt;
&lt;li&gt;运行时通过OrgUnits视图(暂简单实现，如下图所示)选择组织单元，然后在“权限设置”面板勾选相应的权限。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：请勿将Admin用户的Admin权限取消掉，未做判断会导致无权限。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201906/4928-20190612072930090-896309667.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;内部用户登录流程&quot;&gt;内部用户登录流程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;根据账号与密码查询员工并验证密码；&lt;/li&gt;
&lt;li&gt;查询员工映射的组织单元，形成组织单元路径(如：/公司/部门/员工)；&lt;/li&gt;
&lt;li&gt;以组织单元路径新建并缓存会话信息。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：系统默认的Admin密码:760wb,Test密码:la581&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;服务内验证权限&quot;&gt;服务内验证权限&lt;/h2&gt;
&lt;p&gt;  调用服务时，根据会话的组织单元路径与指定的权限比对，可判断当前用户是否具备特定的权限。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：目前未验证权限的服务所有人均可调用。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;服务方法Attribute方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[InvokePermission(Permissions.Admin || Permissions.Developer)] //可组合
public async Task&amp;lt;EntityList&amp;lt;Entities.OrgUnit&amp;gt;&amp;gt; LoadTreeList()
{
    var q = new TableScan&amp;lt;Entities.OrgUnit&amp;gt;();
    return await q.ToTreeListAsync(t =&amp;gt; t.Childs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;服务方法内代码验证方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task SaveOrder(Entities.Order order)
{
    if (!Permissions.SaveOrder)
        throw new Exception(&quot;不具备操作权限&quot;);
    await EntityStore.SaveAsync(order);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;  本篇主要介绍了框架集成的权限体系的实现方式，&lt;a href=&quot;https://github.com/enjoycode/appbox.deploy&quot;&gt;Github&lt;/a&gt;上的运行时已经更新可测试。如果您有问题或Bug报告，请留言或在&lt;a href=&quot;https://github.com/enjoycode/appbox.deploy&quot;&gt;Github&lt;/a&gt;提交Issue。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Jun 2019 23:31:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  权限体系是用于约束用户访问或操作资源的权利，这里的“资源”可以指数据，也可以指特定的功能（如审核订单）。通常的权限体系设计是基于角色的访问控制方式，用户通过角色与权限进行关联。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BaiCai/p/11007400.html</dc:identifier>
</item>
<item>
<title>vue安装遇到的5个报错小结 - 你不知道的巨蟹</title>
<link>http://www.cnblogs.com/tu-0718/p/11000182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tu-0718/p/11000182.html</guid>
<description>
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;这篇博文不会教你怎么安装vue，但会告知安装过程中可能遇到的5个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 2017年我写过一篇安装vue的博客，详情：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/tu-0718/p/7521099.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/tu-0718/p/7521099.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;5个报错&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;①：&lt;/strong&gt;若使用&lt;strong&gt;vue -V&lt;/strong&gt;查询是否安装vue时提示没有找到指令，可能是你没有安装&lt;strong&gt;vue-cli&lt;/strong&gt;脚手架&lt;span&gt;（vue-cli可快速创建vue项目）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610210021698-1906372868.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610210032288-672441574.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;　  ②：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;vue&lt;/strong&gt;安装淘宝镜像时报错，提示无效的配置，必须是完整合法的&lt;strong&gt;http&lt;/strong&gt;地址，&lt;/span&gt;&lt;span&gt;原因是我在&lt;strong&gt;url&lt;/strong&gt;前面加了&lt;strong&gt;1&lt;/strong&gt;个空格，&lt;span&gt;&lt;strong&gt;这里不要有空格&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　  &lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;安装淘宝镜像后，需要用到&lt;strong&gt;npm&lt;/strong&gt;的地方都可以用&lt;strong&gt;cnpm&lt;/strong&gt;替换，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;但建议安装模块和插件用&lt;strong&gt;cnpm&lt;/strong&gt;，打包和启动&lt;strong&gt;vue&lt;/strong&gt;用&lt;strong&gt;npm&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　&lt;/strong&gt;&lt;span&gt;（cnpm是国内镜像，npm服务器在国外，固cnpm安装速度更快，但可能出现更新不及时导致出现一些不可预料的问题）&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610210232736-1280246130.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;207&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　　　   &lt;strong&gt;&lt;span&gt;③：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;若&lt;/span&gt;&lt;span&gt;直接使用 &lt;strong&gt;npm run dev&lt;/strong&gt; 命令运行会报错，提示没有这样的文件或目录，需要先创建一个项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610210939927-1036501991.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;207&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;　  　   使用&lt;strong&gt;vue init webpack vue_test&lt;/strong&gt;&lt;span&gt;（vue_test为项目名称）&lt;/span&gt;创建项目，然后根据需要来选择，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　  　　&lt;/span&gt;&lt;span&gt;没有出现&lt;strong&gt;（Y/n）&lt;/strong&gt;让你选择是否安装的选项直接回车即可，&lt;strong&gt;Y&lt;/strong&gt;为安装，&lt;strong&gt;n&lt;/strong&gt;为不安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　  &lt;img class=&quot;en-media en-media-image en-media-selected&quot; src=&quot;en-resource://database/2013:0&quot; alt=&quot;&quot; data-filename=&quot;Image.png&quot; data-yjs-hook=&quot;en-resource&quot; data-reference=&quot;resource-19&quot; data-type=&quot;image/png&quot; data-url=&quot;en-resource://database/2013:0&quot; data-timestamp=&quot;1560170814170&quot;/&gt;&lt;img class=&quot;en-media en-media-image en-media-selected&quot; src=&quot;en-resource://database/2013:0&quot; alt=&quot;&quot; data-filename=&quot;Image.png&quot; data-yjs-hook=&quot;en-resource&quot; data-reference=&quot;resource-19&quot; data-type=&quot;image/png&quot; data-url=&quot;en-resource://database/2013:0&quot; data-timestamp=&quot;1560170814170&quot;/&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610211308362-1097537989.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;359&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　　　 &lt;strong&gt;&lt;span&gt;④：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;若&lt;/span&gt;&lt;span&gt;进入项目目录，输入&lt;strong&gt;npm run dev&lt;/strong&gt;后提示没有找到该项目，说明你的项目路径有误，检查项目路径和输入命令是否正确 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　   &lt;/span&gt;&lt;span&gt;这里是项目路径输入有误，直接复制路径粘贴到&lt;strong&gt;git bash&lt;/strong&gt;（相当于&lt;strong&gt;windows&lt;/strong&gt;的&lt;strong&gt;cmd&lt;/strong&gt;） 路径斜杠会变成&lt;span&gt;&lt;strong&gt;'\'&lt;/strong&gt;&lt;/span&gt;，实际应该用&lt;span&gt;&lt;strong&gt;'/'&lt;/strong&gt;&lt;/span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190611185425660-884323717.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;git bash&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;复制项目路径无法直接&lt;strong&gt;ctrl+v&lt;/strong&gt;粘贴，直接点一下鼠标滚轮即可粘贴&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;⑤：&lt;/strong&gt;输入&lt;strong&gt;npm install&lt;/strong&gt;安装依赖包时，若有下图提示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;span&gt;审核了&lt;strong&gt;11959&lt;/strong&gt;个包发现&lt;strong&gt;12&lt;/strong&gt;个漏洞（&lt;strong&gt;7&lt;/strong&gt;个中等，&lt;strong&gt;5&lt;/strong&gt;个高危）运行`&lt;strong&gt;npm audit fix&lt;/strong&gt;`来修复它们，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　或者运行`&lt;strong&gt;npm audit&lt;/strong&gt;`来获取详细信息，这里&lt;/span&gt;&lt;span&gt;直接输入&lt;strong&gt;npm audit fix&lt;/strong&gt;修复即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610213411972-544356161.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;161&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　 &lt;span&gt;    接着会出现下图所示，告知你已修复其中一些漏洞，还需输入&lt;strong&gt;npm audit fix --force&lt;/strong&gt; 进一步修复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190611101918439-1611176182.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　 &lt;span&gt;   然后看到下面提示在输入&lt;strong&gt;npm audit&lt;/strong&gt;即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190611103938327-1210047556.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　     &lt;span&gt;最后当你看到下图所示，说明你已经完全修复了漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190611104138523-507114016.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　  &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注：&lt;a href=&quot;https://blog.csdn.net/weixin_40817115/article/details/81007774&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;原文参考&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　 &lt;span&gt;①：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;运行&lt;strong&gt;npm run dev&lt;/strong&gt; 后自动打开浏览器设置&lt;span&gt;（默认是手动打开）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　   &lt;span&gt;&lt;strong&gt;config-index.js&lt;/strong&gt;，然后找到 &lt;strong&gt;autoOpenBrowser: false,&lt;/strong&gt; 把&lt;strong&gt;false&lt;/strong&gt;改为&lt;strong&gt;true&lt;/strong&gt;即可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;strong&gt;  ②：&lt;/strong&gt;若你想终止启动&lt;strong&gt;vue&lt;/strong&gt;，不想每次都重复下面&lt;strong&gt;3&lt;/strong&gt;个步骤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　 &lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;cd &quot;项目路径&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　&lt;span&gt;    npm install&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;span&gt;　   npm run dev&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　     &lt;/strong&gt;&lt;span&gt;可直接&lt;strong&gt;ctrl+c&lt;/strong&gt;会出现下图所示，根据提示选&lt;strong&gt;Y&lt;/strong&gt;，此时只需在输入一次 &lt;strong&gt;npm run dev&lt;/strong&gt; 即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033257/201906/1033257-20190610214528798-1766890388.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;86&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Jun 2019 17:17:00 +0000</pubDate>
<dc:creator>你不知道的巨蟹</dc:creator>
<og:description>前言 这篇博文不会教你怎么安装vue，但会告知安装过程中可能遇到的5个问题 2017年我写过一篇安装vue的博客，详情：https://www.cnblogs.com/tu-0718/p/752109</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tu-0718/p/11000182.html</dc:identifier>
</item>
<item>
<title>TypeScript 装饰器的执行原理 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/typescript_decorator_under_the_hook.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/typescript_decorator_under_the_hook.html</guid>
<description>&lt;p&gt;装饰器本质上提供了对被装饰对象 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor&quot; rel=&quot;nofollow&quot;&gt;Property​ Descriptor&lt;/a&gt; 的操作，在运行时被调用。&lt;/p&gt;
&lt;p&gt;因为对于同一对象来说，可同时运用多个装饰器，然后装饰器中又可对被装饰对象进行任意的修改甚至是替换掉实现，直观感觉会有一些主观认知上的错觉，需要通过代码来验证一下。&lt;/p&gt;
&lt;p&gt;比如，假若每个装饰器都对被装饰对象的有替换，其结果会怎样？&lt;/p&gt;
&lt;h2&gt;多个装饰器的应用&lt;/h2&gt;
&lt;p&gt;通过编译运行以下示例代码并查看其结果可以得到一些直观感受：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; f() {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;_target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; original &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;[]) {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[f]before ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;);
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[f]after ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;result&lt;/span&gt;;
    };
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;;
  };
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; g() {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;_target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; original &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;[]) {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[g]before ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;);
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[g]after ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;result&lt;/span&gt;;
    };
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;;
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt; {
  @&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;()
  @&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;()
  foo(&lt;span class=&quot;pl-v&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;foo called ${&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  }
}

&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt;();
&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先放出执行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): called
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): called
[f]before foo called [ 0 ]
[g]before foo called [ 0 ]
foo called 0
[g]after foo called [ 0 ]
[f]after foo called [ 0 ]
[f]before foo called [ 1 ]
[g]before foo called [ 1 ]
foo called 1
[g]after foo called [ 1 ]
[f]after foo called [ 1 ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面来详细分析。&lt;/p&gt;
&lt;h2&gt;编译后的装饰器代码&lt;/h2&gt;
&lt;p&gt;首页看看编译后变成 JavaScript 的代码，毕竟这是实际运行的代码：&lt;/p&gt;
&lt;details readability=&quot;21&quot;&gt;编译后的代码
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; __decorate &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;__decorate&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;decorators&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;desc&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;, r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; target &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; desc &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; desc &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(target, key) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; desc, d;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;object&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;decorate&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;function&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;decorate&lt;/span&gt;(decorators, target, key, desc);
    &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;decorators&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;; i &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i&lt;span class=&quot;pl-k&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (d &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; decorators[i]) r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (c &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(r) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(target, key, r) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(target, key)) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; r;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; r &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(target, key, r), r;
};
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; __metadata &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;__metadata&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;k&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;v&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;object&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;metadata&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;function&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;metadata&lt;/span&gt;(k, v);
};
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;_target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; original &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
        &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; args &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [];
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;; _i&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;) {
                args[_i] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;[_i];
            }
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[f]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, args);
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[f]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result;
        };
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; descriptor;
    };
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;_target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; original &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
        &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; args &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [];
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;; _i&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;) {
                args[_i] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;[_i];
            }
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, args);
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result;
        };
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; descriptor;
    };
}
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;@class&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt;() {
    }
    &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;) {
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo called &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; count);
    };
    &lt;span class=&quot;pl-en&quot;&gt;__decorate&lt;/span&gt;([
        &lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(),
        &lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:type&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;Function&lt;/span&gt;),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:paramtypes&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, [&lt;span class=&quot;pl-c1&quot;&gt;Number&lt;/span&gt;]),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:returntype&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)
    ], &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;;
}());
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt;();
&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;先看经过 TypeScript 编译后的代码，重点看这一部分：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;@class&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt;() {
    }
    &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;) {
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo called &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; count);
    };
    &lt;span class=&quot;pl-en&quot;&gt;__decorate&lt;/span&gt;([
        &lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(),
        &lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:type&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;Function&lt;/span&gt;),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:paramtypes&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, [&lt;span class=&quot;pl-c1&quot;&gt;Number&lt;/span&gt;]),
        &lt;span class=&quot;pl-en&quot;&gt;__metadata&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;design:returntype&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)
    ], &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;;
}());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;tslib 中装饰器的实现&lt;/h2&gt;
&lt;p&gt;其中 &lt;code&gt;__decorate&lt;/code&gt; 为 TypeScript 经 &lt;a href=&quot;https://github.com/microsoft/tslib&quot;&gt;tslib&lt;/a&gt; 提供的 Decorator 实现，其源码为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/tslib/blob/e1aae12c74c57200f72a7f9cfb53321e0c43b616/tslib.js#L90&quot;&gt;tslib/tslib.js(经过格式化)&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;25&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; __decorate &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
  (&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;__decorate&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;decorators&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;desc&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;,
      r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
        c &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;
          &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; target
          &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; desc &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;
          &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; (desc &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(target, key))
          &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; desc,
      d;
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;object&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;decorate&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;function&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)
      r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;decorate&lt;/span&gt;(decorators, target, key, desc);
    &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;decorators&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;; i &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; i&lt;span class=&quot;pl-k&quot;&gt;--&lt;/span&gt;)
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; ((d &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; decorators[i]))
          r &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (c &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(r) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(target, key, r) &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;d&lt;/span&gt;(target, key)) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; r;
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; r &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(target, key, r), r;
  };
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;装饰器的执行顺序&lt;/h2&gt;
&lt;p&gt;配合编译后代码和这里装饰器的实现来看，进一步&lt;a href=&quot;https://github.com/wayou/wayou.github.io/issues/103&quot; data-hovercard-type=&quot;issue&quot; data-hovercard-url=&quot;/wayou/wayou.github.io/issues/103/hovercard&quot;&gt;之前了解到的&lt;/a&gt;关于装饰器被求值和执行的顺序，&lt;/p&gt;
&lt;p&gt;源码中应用装饰器的地方：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
  @&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;()
  @&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;()
  &lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;: &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;foo called ${&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这里的 &lt;code&gt;@f() @g()&lt;/code&gt; 按照该顺序传递给了 &lt;code&gt;__decorate&lt;/code&gt; 函数，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
  __decorate(
    [
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      f(),&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      g(),&lt;/span&gt;
      __metadata(&quot;design:type&quot;, Function),
      __metadata(&quot;design:paramtypes&quot;, [Number]),
      __metadata(&quot;design:returntype&quot;, void 0)
    ],
    C.prototype,
    &quot;foo&quot;,
    null
  );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在 &lt;code&gt;__decorate&lt;/code&gt; 函数体中，对传入的 &lt;code&gt;decorators&lt;/code&gt; 从数据最后开始，取出装饰器函数顺次执行，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;25&quot;&gt;
&lt;pre&gt;
var __decorate =
  (this &amp;amp;&amp;amp; this.__decorate) ||
  function(decorators, target, key, desc) {
    var c = arguments.length,
      r =
        c &amp;lt; 3
          ? target
          : desc === null
          ? (desc = Object.getOwnPropertyDescriptor(target, key))
          : desc,
      d;
    if (typeof Reflect === &quot;object&quot; &amp;amp;&amp;amp; typeof Reflect.decorate === &quot;function&quot;)
      r = Reflect.decorate(decorators, target, key, desc);
    else
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      for (var i = decorators.length - 1; i &amp;gt;= 0; i--)&lt;/span&gt;
        if ((d = decorators[i]))
          r = (c &amp;lt; 3 ? d(r) : c &amp;gt; 3 ? d(target, key, r) : d(target, key)) || r;
    return c &amp;gt; 3 &amp;amp;&amp;amp; r &amp;amp;&amp;amp; Object.defineProperty(target, key, r), r;
  };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;r&lt;/code&gt; 便是装成器的返回，会被当作被装饰对象的新的属性描述器（Property Descriptor）来重新定义被装饰的对象：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(target, key, r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，像示例代码中多个装饰器均对被装饰对象有修改，原则上和多次调用 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 相当。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;而调用 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 的结果是后面的会覆盖前面的，比如来看这里一个简单的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {};

&lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(obj, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
  configurable&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;,
  &lt;span class=&quot;pl-en&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  }
});

&lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(obj, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, {
  &lt;span class=&quot;pl-en&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  }
});

&lt;span class=&quot;pl-smi&quot;&gt;obj&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;(); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 根据 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description&quot; rel=&quot;nofollow&quot;&gt;MDN 对 &lt;code&gt;defineProperty&lt;/code&gt; 的描述&lt;/a&gt;，&lt;code&gt;configurable&lt;/code&gt; 在缺省时为 &lt;code&gt;false&lt;/code&gt;，所以如果要重复定义同一个 &lt;code&gt;key&lt;/code&gt;，需要显式将其置为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;configurable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;true&lt;/code&gt; if and only if the type of this property descriptor may be changed and if the &amp;gt; property may be deleted from the corresponding object.&lt;br/&gt;Defaults to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到本文开头的示例，为了进一步验证，可通过将运用装饰之后的属性描述器打印出来：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;()&lt;/span&gt; {
            var args = []&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (var _i = 0&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; arguments.length&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; _i++) {
                args[_i] = arguments[_i]&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            }
            console.log(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[f]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + key + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            var result = original.apply(this, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            console.log(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[f]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + key + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这里引出另一个问题，通过装饰器重复定义同一属性时，并没有显式返回一个 &lt;code&gt;configurable:true&lt;/code&gt; 的对象，那为何在运用多个装饰器重复定义时没报错。&lt;/p&gt;
&lt;h2&gt;装饰器入参中的 &lt;code&gt;descriptor&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;答案就只有一个，那就是装饰器传入的 &lt;code&gt;descriptor&lt;/code&gt; 已经是 &lt;code&gt;configurable&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的状态。&lt;/p&gt;
&lt;p&gt;为了验证，只需要在 &lt;code&gt;@f()&lt;/code&gt; 或 &lt;code&gt;@g()&lt;/code&gt; 任意一个装饰器中将 &lt;code&gt;descriptor&lt;/code&gt; 打印出来即可。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
function g() {
  console.log(&quot;g(): evaluated&quot;);
  return function(_target: any, key: string, descriptor: PropertyDescriptor) {
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      console.log(descriptor)&lt;/span&gt;
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
      console.log(`[g]before ${key} called`, args);
      const result = original.apply(this, args);
      console.log(`[g]after ${key} called`, args);
      return result;
    };
    console.log(&quot;g(): called&quot;);
    return descriptor;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的 &lt;code&gt;descriptor&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
{
  value: [Function],
  writable: true,
  enumerable: true,
  configurable: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这便是最终运行时会执行的 &lt;code&gt;foo&lt;/code&gt; 方法真身。&lt;/p&gt;
&lt;p&gt;可以看到确实是最后生效的装饰器确实是后运用的 &lt;code&gt;@f()&lt;/code&gt;。因此你确实可以这么理解多个装饰器的重叠应用为，那一切都还说得通，就是 后运用的装饰器中 对被装饰对象的替换 会覆盖掉 先运用的装饰器 对被装饰对象的替换。&lt;/p&gt;
&lt;p&gt;But,&lt;/p&gt;
&lt;p&gt;这解释不了它的输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): called
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): called
[f]before foo called [ 0 ]
[g]before foo called [ 0 ]
foo called 0
[g]after foo called
[f]after foo called
[f]before foo called [ 1 ]
[g]before foo called [ 1 ]
foo called 1
[g]after foo called
[f]after foo called
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;装饰器嵌套&lt;/h2&gt;
&lt;p&gt;原因就在于这句代码：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;args&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这句，&lt;code&gt;@f()&lt;/code&gt; 和 &lt;code&gt;@g()&lt;/code&gt; 便不是简单的覆盖关系，而是形成了嵌套关系。&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;original&lt;/code&gt; 为 &lt;code&gt;descriptor.value&lt;/code&gt;，即装饰器传入的 &lt;code&gt;descriptor&lt;/code&gt; 的一个副本。我们在进行覆盖前保存了一下原方法的副本，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 保存原始的被装饰对象&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; original &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 替换被装饰对象&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;[]) {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为装饰器的目的只是&lt;strong&gt;对已有的对象进行修饰加强&lt;/strong&gt;，所以你不能粗暴地将原始的对象直接替换成新的实现（当然你确实可以那样粗暴的），那样并不符合大多数应用场景。所以在进行替换时，先保存原始对象（这里原始对象是 &lt;code&gt;foo&lt;/code&gt; 方法），然后在新的实现中对原始对象再进行调用，这样来实现了对原始对象进行修饰，添加新的特性。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
descriptor.value = function(...args: any[]) {
    console.log(`[g]before ${key} called`, args);
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    const result = original.apply(this, args);&lt;/span&gt;
    console.log(`[g]after ${key} called`, args);
    return result;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这种方式，多个装饰器对被装饰对象的修改可以层层传递下去，而不至于丢失。&lt;/p&gt;
&lt;p&gt;下面把每个装饰器接收到的属性描述器打印出来：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
function f() {
  console.log(&quot;f(): evaluated&quot;);
  return function(_target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    console.log(&quot;[f] receive descriptor:&quot;, original.toString());&lt;/span&gt;
    descriptor.value = function(...args: any[]) {
      console.log(`[f]before ${key} called`, args);
      const result = original.apply(this, args);
      console.log(`[f]after ${key} called`, args);
      return result;
    };
    console.log(&quot;f(): called&quot;);
    return descriptor;
  };
}

function g() {
  console.log(&quot;g(): evaluated&quot;);
  return function(_target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    console.log(&quot;[g] receive descriptor:&quot;, original.toString());&lt;/span&gt;
    descriptor.value = function(...args: any[]) {
      console.log(`[g]before ${key} called`, args);
      const result = original.apply(this, args);
      console.log(`[g]after ${key} called`, args);
      return result;
    };
    console.log(&quot;g(): called&quot;);
    return descriptor;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
[g] receive descriptor:
 &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;(count)&lt;/span&gt; {
        console.log(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo called &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + count)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
    }

[f] receive descriptor:
 &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;()&lt;/span&gt; {
            var args = []&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (var _i = 0&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; arguments.length&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; _i++) {
                args[_i] = arguments[_i]&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            }
            console.log(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + key + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            var result = original.apply(this, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            console.log(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; + key + &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的示例中，先是 &lt;code&gt;@g()&lt;/code&gt; 被调用，它接收到的 &lt;code&gt;descriptor&lt;/code&gt; 就是原始的 &lt;code&gt;foo&lt;/code&gt; 方法的属性描述器，打印出其值便是原始的 &lt;code&gt;foo&lt;/code&gt; 方法的方法体，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;count&lt;/span&gt;) {
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo called &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; count);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过 &lt;code&gt;@g()&lt;/code&gt; 处理后的属性描述器传递给了下一个装饰器 &lt;code&gt;@f()&lt;/code&gt;，所以后者接收到的是经过处理后新的属性描述器，即 &lt;code&gt;@g()&lt;/code&gt; 返回的那个：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
 &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; args &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [];
            &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;; _i&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;) {
                args[_i] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;[_i];
            }
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; result &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;original&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, args);
            &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
            &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将 &lt;code&gt;@f()&lt;/code&gt; 中 &lt;code&gt;original&lt;/code&gt; 替换成上述代码便是最终 &lt;code&gt;@f()&lt;/code&gt; 返回的最终 &lt;code&gt;foo&lt;/code&gt; 的样子，大致是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;any&lt;/span&gt;[]) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[f]before &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;key&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;, args);

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; g 开始&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; args &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [];
  &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; _i &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; _i &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;; _i&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;) {
    args[_i] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;[_i];
  }
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]before &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; foo 开始&lt;/span&gt;
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;foo called &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;count&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; foo 结束&lt;/span&gt;

  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[g]after &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; key &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, args);
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; g 结束&lt;/span&gt;
  
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;[f]after &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;key&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt; called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;, args);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; result;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以最终的 &lt;code&gt;foo&lt;/code&gt; 方法其实是 &lt;code&gt;f(g(x))&lt;/code&gt; 两者嵌套组合的结果，像数学上的函数调用一样。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;多个装饰器运用于同一对象时，其求值和执行顺序是相反的，&lt;/p&gt;
&lt;p&gt;对于类似这样的调用：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;求值顺序是由上往下&lt;/li&gt;
&lt;li&gt;执行顺序是由下往上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常情况下我们只关心执行顺序，除非是在编写复杂的装饰器工厂方法时。&lt;/p&gt;
&lt;p&gt;如果多个装饰器中都对被装饰对象有所修改，注意嵌套过程中修改被覆盖的问题，如果不想要产生覆盖，装饰器中应该有对被装饰对象保存副本并且调用，方法通过 &lt;code&gt;fn.apply()&lt;/code&gt;，类则可通过返回一个新的但继承自被装饰对象的新类来实现，比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; classDecorator&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; {&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;[])&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;{}}&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;constructor&lt;/span&gt; {
        newProperty &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;new property&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
        hello &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;override&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    }
}

@&lt;span class=&quot;pl-smi&quot;&gt;classDecorator&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt; {
    property &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;property&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    hello&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
        &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;;
    }
}

&lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;world&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里覆盖了被装饰类的构造器，但其他未修改的部分仍是原来类中的样子，因为这里返回的是一个 &lt;code&gt;extends&lt;/code&gt; 后的新类。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Jun 2019 15:52:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>装饰器本质上提供了对被装饰对象 Property​ Descriptor 的操作，在运行时被调用。 因为对于同一对象来说，可同时运用多个装饰器，然后装饰器中又可对被装饰对象进行任意的修改甚至是替换掉实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/typescript_decorator_under_the_hook.html</dc:identifier>
</item>
<item>
<title>【剑指Offer】矩形覆盖 - 坏坏也童鞋</title>
<link>http://www.cnblogs.com/iwiniwin/p/11006962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iwiniwin/p/11006962.html</guid>
<description>&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;

&lt;p&gt;一开始尝试解这道题的时候其实有些不知道怎么下手，花了很长时间。后来才发现可以利用递归的思想，将n的值不断放小到某个可以直接知道结果的值。虽然直接实现递归的算法可能效率不高，但在找到题目的递归解法后，再在递归算法的基础上做优化，就可以得到一个满意的答案。&lt;br/&gt;回到本题，用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，假设有F(n)中方法&lt;br/&gt;先用一个2*1的小矩形，&lt;strong&gt;竖着&lt;/strong&gt;覆盖大矩形，如下图所示。则还剩下2*(n-1)的大矩形需要覆盖，即有F(n-1)种方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1673734/201906/1673734-20190611233038663-1636229129.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果先用一个2*1的小矩形，&lt;strong&gt;横着&lt;/strong&gt;覆盖大矩形，如下图所示。则底部的红色区域也只能用一个2*1的小矩形横着覆盖。则还剩下2*(n-2)的大矩形需要覆盖，即有F(n-2)中方法&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1673734/201906/1673734-20190611233047624-1145983092.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由以上两种情况可知，F(n) = F(n - 1) + F(n - 2)，我们只需要知道F(0)，F(1)，就可以求得F(n)。很明显这是一个斐波那契数列的定义。对于斐波那契数列的多种求解方法可以参考&lt;a href=&quot;https://www.cnblogs.com/iwiniwin/p/10798884.html&quot;&gt;【剑指Offer】斐波那契数列&lt;/a&gt;&lt;br/&gt;当n = 0的时候，显然有0中覆盖方法，即F(0) = 0&lt;br/&gt;当n = 1的时候，只有一种覆盖方法，即F(1) = 1&lt;br/&gt;我们可以直接使用直观的递归算法求解，如下所示&lt;/p&gt;
&lt;h2 id=&quot;实现代码&quot;&gt;实现代码&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int rectCover(int number)
{
    if (number &amp;lt;= 0)
        return 0;
    if (number == 1)
        return 1;
    else if (number == 2)
        return 2;
    return rectCover(number - 1) + rectCover(number - 2);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以使用循环迭代的方式优化递归算法，如下所示&lt;/p&gt;
&lt;h2 id=&quot;实现代码-1&quot;&gt;实现代码&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int rectCoverOptimize(int number)
{
    int f = 0, g = 1;
    while (number-- &amp;gt; 0)
    {
        g = f + g;
        f = g - f;
    }
    return f == 0 ? 0 : g;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;既然已经知道本题实际上就是求解斐波那契数列，那么可以利用矩阵的快速幂求解&lt;/p&gt;
&lt;h2 id=&quot;实现代码-2&quot;&gt;实现代码&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 矩阵乘法
public int[,] matrixMul(int[,] m1, int[,] m2)
{
    int[,] ret = {
        {m1[0, 0] * m2[0,0] + m1[0, 1] * m2[1,0], m1[0, 0] * m2[0,1] + m1[0, 1] * m2[1,1]}, 
        {m1[1, 0] * m2[0,0] + m1[1, 1] * m2[1,0], m1[1, 0] * m2[0,1] + m1[1, 1] * m2[1,1]}
    };
    return ret;
}

// 矩阵快速幂
public int[,] matrixPow(int[,] m, int n)
{
    int[,] ret = { { 1, 0 }, { 0, 1 } };
    while (n &amp;gt; 0)
    {
        if ((n &amp;amp; 1)&amp;gt; 0){
            ret = matrixMul(ret, m);
        }
        n &amp;gt;&amp;gt;= 1;
        m = matrixMul(m, m);
    }
    return ret;
}

public int rectCoverOptimize2(int number)
{
    if (number == 0)
        return 0;
    int[,] unit = { { 1, 1 }, { 1, 0 } };
    int[,] ret = matrixPow(unit, number);
    int[,] m = { { 1, 0 }, { 0, 0 } };
    ret = matrixMul(ret, m);
    return ret[0,0];
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Jun 2019 15:33:00 +0000</pubDate>
<dc:creator>坏坏也童鞋</dc:creator>
<og:description>剑指Offer矩形覆盖题目，我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/iwiniwin/p/11006962.html</dc:identifier>
</item>
<item>
<title>JVM(四):深入分析Java字节码-下 - iceWang丶</title>
<link>http://www.cnblogs.com/JRookie/p/11006941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JRookie/p/11006941.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在上文中，我们讲解了 Class 文件中的文件标识，常量池等内容。在本文中，我们就详细说一下剩下的指令集内容，阐述其分别代表了什么含义，以及 JVM 团队这样设计的意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;JVM 指令设计为仅有一个字节长度，由操作码和紧随其后的零至多个操作数来构成。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里说到 JVM 的指令仅有一个字节，这意味着 JVM 在操作超过一个字节长度的数据时，需要在运行时重建出多字节数据类型的具体数据结构，例如 Long 等。这会导致这个操作不是原子操作，在高并发的情况下，就有可能会导致错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 JVM 的操作码长度只有一个字节，因此设计指令的时候，需要考虑所有指令加起来不能超过一个字节长度，正因如此，有许多数据类型是没有其对应的操作码的，其操作的方式是将其数据类型进行&lt;strong&gt;向上转型&lt;/strong&gt;为其他的数据类型来参与运算。&lt;/p&gt;
&lt;p&gt;例如大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上是将其转换成 int 类型来处理的。&lt;/p&gt;
&lt;h2 id=&quot;指令详解&quot;&gt;指令详解&lt;/h2&gt;
&lt;p&gt;JVM 指令如果详细来说的话有一百多个，在这里全部展开来描述的，不免有流水账的嫌疑，且价值不大，因此在本文中仅粗略描述一下，并找了一些关键的指令对其进行详细拆解，如果读者对其他指令有兴趣的话可以自行 Google 或翻书学习。&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008722128&quot;&gt;全部指令的内容&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;加载和存储指令：用于将数据在栈帧中的局部变量表和操作数栈之间转移(&lt;em&gt;栈帧的布局放在以后的文章 &lt;strong&gt;JVM-内存布局中&lt;/strong&gt;进行介绍，在这里读者只要明白其是根据栈进行操作就可以了&lt;/em&gt;)。eg：load，store；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运算指令：对两个操作数栈上的值进行计算并重新存入到操作栈顶。eg：add，sub，mul，div，rem，neg，shr，or，and，inc……；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类型转换指令：将一个值数据类型进行转换为其他的类型。eg：x2x；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象创建与访问指令：new，newarray(&lt;em&gt;数组和类实例创建和操作是不同的&lt;/em&gt;)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;操作数栈操作指令：直接操作操作数栈。eg：pop，swap；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;控制转移指令：有条件或无条件的控制 JVM 从指定的位置执行程序。(&lt;em&gt;可以简单理解为修改程序计数器中的值&lt;/em&gt;)。eg：if，goto……；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法调用和返回指令：根据对象的实际类型进行虚方法分配，调用类方法，调用接口方法等。另外还有根据不同的返回类型的不同返回指令；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;异常处理指令：目前异常处理在 JVM 内部是通过异常表来完成的；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception table:
     from    to  target type
         0     8    14   Class java/lang/RuntimeException
         0     8    29   any
        14    23    29   any&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;from 行 到 to 行之间的字节码指令如果出现了 type 以及其子类的类型错误，就跳转到 target 行对应的字节码指令进行执行；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步指令&lt;/strong&gt;：同步指令是通过管程(Monitor)来实现的。
&lt;ul&gt;&lt;li&gt;同步方法内部分为方法级的同步和方法内部一段指令的同步。&lt;/li&gt;
&lt;li&gt;方法内部的指令，其实现逻辑是设置方法的访问标志：&lt;strong&gt;ACC_SYNCHRONIZED&lt;/strong&gt;，如果其被设置了，表明该同步方法已经被别人调用，其他对象无法获得管程，就需要等待，在获得管程后才能继续执行。&lt;/li&gt;
&lt;li&gt;指令内部的同步，其实现逻辑是通过字节码指令来控制的，字节码执行到需要同步的指令时，其会调用&lt;strong&gt;monitorenter&lt;/strong&gt; 指令进行同步，此时其他线程无法进入这段指令序列，当程序正常或异常退出后，调用&lt;strong&gt;monitorexit&lt;/strong&gt; 指令进行锁释放，此时其他线程就可以执行同步方法了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：上面这段是 &lt;strong&gt;synchronized&lt;/strong&gt; 关键字的本质含义，其具体的细节放到&lt;em&gt;高并发编程系列文章&lt;/em&gt;中详细来说。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过 Class 文件这个中间文件，JVM 达成了语言无关性和平台无关性两个大突破，使得 Java 语言不仅达到了“一次编写，处处运行”，也使得其他语言只要符合 JVM 规范，就可以像 Java 一样，达到超然物外的无关性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://markdown-1254037841.cos.ap-shanghai.myqcloud.com/JVM_image/iceWang.jpg&quot; alt=&quot;iceWang公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章在公众号 “iceWang&quot; 第一手更新，有兴趣的朋友可以关注公众号，第一时间看到笔者分享的各项知识点，谢谢！笔芯！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本系列文章主要借鉴自《深入分析 JavaWeb 技术内幕》和《深入理解 Java 虚拟机- JVM 高级特性与最佳实践》。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 11 Jun 2019 15:23:00 +0000</pubDate>
<dc:creator>iceWang丶</dc:creator>
<og:description>本文阐述 Class 文件指令集内容的设计方式，以及其为什么这样设计。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JRookie/p/11006941.html</dc:identifier>
</item>
<item>
<title>Windows Azure AD (5) 在单一目录下，使用Azure AD单点登录 - Lei Zhang的博客</title>
<link>http://www.cnblogs.com/threestone/p/11006223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/threestone/p/11006223.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/threestone/archive/2012/01/06/2382322.html&quot;&gt;Windows Azure Platform 系列文章目录&lt;/a&gt;》&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;本文介绍的是，在单一目录下，使用Azure AD Connect，打通本地Domain Controller&lt;/p&gt;

&lt;p&gt;　　我们需要准备的环境有：&lt;/p&gt;
&lt;p&gt;　　1.Azure China订阅&lt;/p&gt;
&lt;p&gt;　　2.在本地或者在微软云端，创建1台Windows VM，安装Domain Controller域控制器服务。&lt;/p&gt;
&lt;p&gt;　　这里我们的测试环境为在云端创建1台Domain Controller机器，命名为CorpDC，安装的Domain Name为：&lt;strong&gt;leicorp.biz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3.注册一个公网的域名，名称为&lt;strong&gt;leicorp.biz&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;注意需要和上面的Domain Name一致&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　具体的步骤分为三个：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一步：在Azure AD增加自定义域名，在公网域名增加TXT记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二步：使用Azure AD Connect，将本地的Domain Controller用户名，Hash加密后的密码，同步到云端的Azure AD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第三&lt;/strong&gt;步：使用本地的Domain Controller的用户名和密码，访问Azure Portal&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;第一步：在Azure AD增加自定义域名，在公网域名增加TXT记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.首先我们登录Azure China Portal: &lt;a href=&quot;https://portal.azure.cn/&quot;&gt;https://portal.azure.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　2.在Azure AD里面，选择Custom Domain Name，点击Add Custom Domain，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611220622904-1414107593.png&quot; alt=&quot;&quot; width=&quot;1151&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.增加完毕后，页面会显示TXT记录，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611220855065-1331906952.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　4.我们在域名服务商那里，增加对&lt;strong&gt;leicorp.biz&lt;/strong&gt;的的TXT记录。这里我用的是海外的Azure App Service Domain服务&lt;/p&gt;
&lt;p&gt;　　把步骤3中的信息，输入到下图中：&lt;/p&gt;
&lt;p&gt;　　(1)Name输入@&lt;/p&gt;
&lt;p&gt;　　(2)Type为TXT&lt;/p&gt;
&lt;p&gt;　　(3)TTL使用默认的1 Hour，对应步骤3中的3600秒&lt;/p&gt;
&lt;p&gt;　　(4)Value输入上面步骤3的记录：MS=ms27412766&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611221145059-2108228025.png&quot; alt=&quot;&quot; width=&quot;1286&quot; height=&quot;658&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5.设置完毕后，我们稍微等待TXT生效，然后回到步骤3中，点击Verify按钮。如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611221552494-808012438.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　6.验证通过后，Custom domain names会显示验证通过：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611221701899-1681919993.png&quot; alt=&quot;&quot; width=&quot;1021&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;　　第二步：使用Azure AD Connect，将本地的Domain Controller用户名，Hash加密后的密码，同步到云端的Azure AD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.我们已经在云端创建了1台Domain Controller机器，命名为CorpDC，安装的Domain Name为：&lt;strong&gt;leicorp.biz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611220435434-7491245.jpg&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;309&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2.我们在DC上创建3个用户：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611222627571-1709304779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.在弹出的窗口中，输入用户信息，命名为user01, user02, user03&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611222724068-436094824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　4.微软官方建议在另外一台机器上，安装Azure AD Connect，该机器可以访问到Domain Controller域控制器&lt;/p&gt;
&lt;p&gt;　　为了演示方便，我们在云端的DC上，安装Azure AD Connect服务，下载地址：&lt;strong&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=47594&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=47594&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　安装完毕后，选择I agree&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611223028506-1624450374.png&quot; alt=&quot;&quot; width=&quot;830&quot; height=&quot;578&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5.根据自己的需求，我们这里选择Express&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611223131285-1399866154.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　6.在Connect to Azure AD栏目中，输入登录https://portal.azure.cn的用户名和密码&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611223332824-820344739.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　7.在Connect to AD DS中，输入域控制器管理员的用户名和密码&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611223531029-1025684783.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　8.验证完毕后，我们先不勾选Start the Synchronization&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225016295-1142847413.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　9.安装完毕后，&lt;strong&gt;界面显示Azure AD Connect同步尚未开始&lt;/strong&gt;。如下图红色部分&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225247860-1825162320.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　9.安装完毕后。我点击桌面的图表Azure AD Connect，进行配置和同步&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225101028-105955071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　10.配置里面有很多内容，笔者简单举几个例子，比如：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225430325-786851176.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　11.然后输入信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225610982-277673299.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　12.选择Domain和OU&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611225932491-662473900.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　13.设置AD属性，同时我们注意AD密码是哈希加密&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611230002195-958849758.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　14.选择需要同步的AD属性&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611230155244-220563676.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　15.配置完毕后，选择开始同步Azure AD Connect&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611230325384-1073543706.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　16.同步开始后，我们访问portal.azure.cn，可以查看到本地Domain Controller里面的账户都被同步到微软云Azure AD里&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611230912856-1359730549.png&quot; alt=&quot;&quot; width=&quot;1500&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;第三&lt;/strong&gt;步：使用本地的Domain Controller的用户名和密码，访问Azure Portal&lt;/p&gt;
&lt;p&gt;　　1.我们打开一个新的浏览器，输入&lt;strong&gt;&lt;a href=&quot;https://portal.azure.cn/&quot; target=&quot;_blank&quot;&gt;https://portal.azure.cn/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2.输入域控制器里面的用户名：user01@leicorp.biz，和对应的密码&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611231449480-889690490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.登录后，就可以访问Azure Portal了，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611231520654-1601829640.png&quot; alt=&quot;&quot; width=&quot;830&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后请注意：Azure AD的账户user01@leicorp.biz是没有任何订阅的权限，也不能访问任何资源&lt;/p&gt;
&lt;p&gt;　　我们需要把一个资源组的权限，分配给AD账户：user01@leicorp.biz，如下图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127213/201906/127213-20190611231927528-892748984.png&quot; alt=&quot;&quot; width=&quot;1500&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 11 Jun 2019 15:20:00 +0000</pubDate>
<dc:creator>Lei Zhang的博客</dc:creator>
<og:description>《Windows Azure Platform 系列文章目录》 本文介绍的是，在单一目录下，使用Azure AD Connect，打通本地Domain Controller 我们需要准备的环境有： 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/threestone/p/11006223.html</dc:identifier>
</item>
<item>
<title>大话Spark(6)-源码之SparkContext原理剖析 - wangt.cc</title>
<link>http://www.cnblogs.com/wangtcc/p/da-huaSpark-6yuan-ma-zhiSparkContext-yuan-li-pou-x.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangtcc/p/da-huaSpark-6yuan-ma-zhiSparkContext-yuan-li-pou-x.html</guid>
<description>&lt;p&gt;SparkContext是整个spark程序通往集群的唯一通道，他是程序的起点，也是程序的终点。&lt;br/&gt;我们的每一个spark个程序都需要先创建SparkContext，接着调用SparkContext的方法， 比如说 sc.textFile(filepath)，程序最后也会调用sc.stop（）来退出。&lt;br/&gt;让我们来一起看下SparkContext里面到底是如何实现的吧！&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;1 SparkContext内的三大核心对象：DAGScheduler，TaskScheduler，SchedulerBackend&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DAGScheduler&lt;/strong&gt;&lt;/span&gt;：面向Stage调度机制的高层调度器，会为每个job计算一个Stage的DAG(有向无环图）。追踪RDD和Stage的输出是否物化（写磁盘或内存），并且执行一个最优的调度机制来执行。将stage作为tasksets提交到底层的TaskScheduler并在集群上运行。DAGScheduler监控作业运行调度的过程，如果某个阶段运行失败，会重新提交提交该调度阶段。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TaskScheduler&lt;/strong&gt;&lt;/span&gt;：是一个接口，底层调度器。会根据ClusterManager的不同有不同的实现，在Standalone模式下的实现为TaskSchedulerImpl。接收DAGScheduler发过来的任务集，并以任务的形式分发到集群worker节点的Executor中去运行，任务失败TaskScheduler负责重试。如果TaskScheduler发现某个任务一直没运行完，可能会启动同样的任务去运行一个任务，结果选取早运行完的那个任务的（预测执行）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SchedulerBackend&lt;/strong&gt;&lt;/span&gt;：是一个接口，根据ClusterManager的不同会有不同的实现，Standalone模式下是StandaloneSchedulerBackend(2.3版本, 1.x版本是SparkDeploySchedulerBackend）底层接受TaskSchedulerImpl的控制，实际负责Master的注册和Tasks发送到Executor等操作。&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;2.1 图示SparkContext实例化过程&lt;/h2&gt;
&lt;p&gt;如下图所示，我们看下SparkContext在实例化过程中，会创建多少核心实例来完成整个应用程序的注册。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407668-1939054819.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;2.2 时序图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230408059-1939223803.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;3 主要内容描述&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;createTaskScheduler&lt;/li&gt;
&lt;li&gt;createSchedulerBackend&lt;/li&gt;
&lt;li&gt;SchedulerBackend的initialize初始化构造默认FIFO调度吃&lt;/li&gt;
&lt;li&gt;new DAGScheduler&lt;/li&gt;
&lt;li&gt;创建StandaloneAppClient与spark集群通信&lt;/li&gt;
&lt;li&gt;创建AppClient，ClientEndPoint（向master注册）&lt;/li&gt;
&lt;li&gt;发消息RegisterApplication&lt;/li&gt;
&lt;li&gt;ClientEndpoint.receive()函数接收master的回复消息&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_4&quot;&gt;4 通过源码看SparkContext实例化过程(Standalone模式）&lt;/h2&gt;
&lt;p&gt;scala中不在方法里的成员都会被实例化，开始最关键的方法是createTaskScheduler，它是位于 SparkContext 的 构造函数中，当它实例化时会直接被调用。&lt;/p&gt;
&lt;p&gt;createTaskScheduler创建了TaskSchedulerImpl并通过StandaloneSchedulerBackend对其进行初始化。&lt;/p&gt;
&lt;p&gt;createTaskScheduler返回scheduleBackend和TaskScheduler， 然后又基于TaskScheduler构造DAGScheduler。&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SparkContext调用createTaskScheduler方法，返回SchedulerBackend和TaskScheduler。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407497-1892801603.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;下createTaskScheduler方法内部：根据不同的master url创建不同的TaskScheduler实现和不同的SchedulerBackend实现。 master url就是创建SparkContext的时候传的，例如下面的&lt;code&gt;local&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;val conf = new SparkConf().setAppName(&quot;TestApp&quot;).setMaster(&quot;local&quot;)
val sc = new SparkContext(conf)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230408346-562630341.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;taskSchedulerImpl的初始化方法，创建一个默认FIFO的调度池：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230408109-311454567.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;taskSchedulerImpl初始化后，随即为其设置DAGScheduler，然后调用其start()方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407641-284142724.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在taskSchedulerImpl的start()方法中再调用backend（StandaloneSchedulerBackend）的start()方法，其中最重要的就是创建ApplicationDescription和AppClient&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407608-165396675.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建ApplicationDescription和AppClient&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230408271-761566564.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ApplicationDescription存放当前应用程序信息，name，cores，memory等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AppClient是Application与Spark通信的组件。在appClient.start()的时候会创建内部类ClientEndPoint&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407381-2130389388.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;clientEndPoint注册master。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407411-1996064073.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;注册的时候会从线程池中拿出一个线程并且会带上APPDescription中的作业信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407749-1194027761.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ClientEndpoint.receive接收master返回的消息，根据不同的返回消息做不同的操作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407808-2021285198.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SparkContext.DAGScheduler&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407314-1767267467.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建SparkUI&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159083/201906/1159083-20190611230407548-1828740458.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上就是SparkContext源码的构造过程，感谢阅读。&lt;br/&gt;End。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Jun 2019 15:04:00 +0000</pubDate>
<dc:creator>wangt.cc</dc:creator>
<og:description>SparkContext是整个spark程序通往集群的唯一通道，他是程序的起点，也是程序的终点。我们的每一个spark个程序都需要先创建SparkContext，接着调用SparkContext的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangtcc/p/da-huaSpark-6yuan-ma-zhiSparkContext-yuan-li-pou-x.html</dc:identifier>
</item>
<item>
<title>spark存储模块之内存存储--MemeoryStore - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11006860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11006860.html</guid>
<description>&lt;p&gt;上一节，我们对BlockManager的主要写入方法做了一个整理，知道了BlockMananger的主要写入逻辑，以及对于块信息的管理。但是，由于spark的整个存储模块是在是很庞大，而且很多细节的逻辑错综复杂，如果对于每个细节都刨根问底，一来精力有限，二来感觉也没有太大的必要，当然如果时间允许肯定是越详细越好，在这里，我的分析的主要目的是理清存储模块的重点逻辑，希望能够提纲契领地把各个模块的脉络领出来，建立起对spark-core中各模块的整体认知，这样我们在遇到一些问题的时候就能够很快地知道应该从何处下手，从哪个具体的模块去找问题。&lt;br/&gt;好了废话不多说，本节接着上一节。上一篇，我们分析了BlockManager的几个主要的存储方法，发现BlockManager主要依靠内部的两个组件MemoryStore和DiskStore来进行实际的数据写入和块的管理。&lt;br/&gt;本节，我们就来看一下MemoryStore这个组件。&lt;/p&gt;
&lt;p&gt;不过，我还是延续我一贯的风格，从外部对一个类的方法调用为切入点分析这个类的作用和逻辑。&lt;br/&gt;所以，我们先来看一下上一节对于MemoryStore的主要的方法调用的总结：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;memoryStore.putIteratorAsValues
memoryStore.putIteratorAsBytes
memoryStore.putBytes&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;memorystore.putiteratorasvalues&quot;&gt;memoryStore.putIteratorAsValues&lt;/h3&gt;
&lt;p&gt;这个方法主要是用于存储级别是非序列化的情况，即直接以java对象的形式将数据存放在jvm堆内存上。我们都知道，在jvm堆内存上存放大量的对象并不是什么好事，gc压力大，挤占内存，可能引起频繁的gc，但是也有明显的好处，就是省去了序列化和反序列化耗时，而且直接从堆内存取数据显然比任何其他方式（磁盘和直接内存）都要快很多，所以对于内存充足且要缓存的数据量本省不是很大的情况，这种方式也不失为一种不错的选择。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private[storage] def putIteratorAsValues[T](
  blockId: BlockId,
  values: Iterator[T],
  classTag: ClassTag[T]): Either[PartiallyUnrolledIterator[T], Long] = {

// 用于存储java对象的容器
val valuesHolder = new DeserializedValuesHolder[T](classTag)

putIterator(blockId, values, classTag, MemoryMode.ON_HEAP, valuesHolder) match {
    // 存储成功
  case Right(storedSize) =&amp;gt; Right(storedSize)
    // 存储失败的情况
  case Left(unrollMemoryUsedByThisBlock) =&amp;gt;
    // ValuesHolder内部的数组和vector会相互转换
    // 数据写入完成后会将vector中的数据转移到数组中
    val unrolledIterator = if (valuesHolder.vector != null) {
      valuesHolder.vector.iterator
    } else {
      valuesHolder.arrayValues.toIterator
    }

    // 返回写入一半的迭代器、
    // 外部调用者一半会选择关闭这个迭代器以释放被使用的内存
    Left(new PartiallyUnrolledIterator(
      this,
      MemoryMode.ON_HEAP,
      unrollMemoryUsedByThisBlock,
      unrolled = unrolledIterator,
      rest = values))
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的逻辑很简单，作用也比较单一，主要是对实际存储方法putIterator的返回结果做处理，如果失败的话，就封装一个PartiallyUnrolledIterator返回给外部调用这个，调用这个一般需要将这个写入一半的迭代器关闭。&lt;/p&gt;
&lt;h3 id=&quot;memorystore.putiterator&quot;&gt;MemoryStore.putIterator&lt;/h3&gt;
&lt;p&gt;这个方法看似很长，其实逻辑相对简单，主要做的事就是把数据一条一条往ValuesHolder中写，并周期性地检查内存，如果内存不够就通过内存管理器MemoryManager申请内存，每次申请当前内存量的1.5倍。&lt;br/&gt;最后，将ValuesHolder中的数据转移到一个数组中(其实数据在SizeTrackingVector中也是以数组的形式存储，只不过SizeTrackingVector对象内部处理数组还有一些其他的簿记量，更为关键的是我们需要将存储的数据以同一的接口进行包装，以利于MemoryStore进行同一管理)。最后还有关键的一步，就是释放展开内存，重新申请存储内存。&lt;br/&gt;此外，这个过程中有使用到memoryManager，具体的方法调用是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;memoryManager.acquireUnrollMemory(blockId, memory, memoryMode)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;------------------------------分割线------------------------------&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private def putIterator[T](
  blockId: BlockId,
  values: Iterator[T],
  classTag: ClassTag[T],
  memoryMode: MemoryMode,
  valuesHolder: ValuesHolder[T]): Either[Long, Long] = {
require(!contains(blockId), s&quot;Block $blockId is already present in the MemoryStore&quot;)

// Number of elements unrolled so far
var elementsUnrolled = 0
// Whether there is still enough memory for us to continue unrolling this block
var keepUnrolling = true
// Initial per-task memory to request for unrolling blocks (bytes).
// 用于数据在内存展开的初始的内存使用量
val initialMemoryThreshold = unrollMemoryThreshold
// How often to check whether we need to request more memory
// 检查内存的频率，每写这么多条数据就会检查一次是否需要申请额外的内存
val memoryCheckPeriod = conf.get(UNROLL_MEMORY_CHECK_PERIOD)
// Memory currently reserved by this task for this particular unrolling operation
// 内存阈值，开始时等于初始阈值
var memoryThreshold = initialMemoryThreshold
// Memory to request as a multiple of current vector size
// 内存增长因子，每次申请的内存是当前内存的这个倍数
val memoryGrowthFactor = conf.get(UNROLL_MEMORY_GROWTH_FACTOR)
// Keep track of unroll memory used by this particular block / putIterator() operation
// 当前的块使用的内存大小
var unrollMemoryUsedByThisBlock = 0L

// Request enough memory to begin unrolling
// 首先进行初始的内存申请,向MemoryManager申请内存
keepUnrolling =
  reserveUnrollMemoryForThisTask(blockId, initialMemoryThreshold, memoryMode)

if (!keepUnrolling) {
  logWarning(s&quot;Failed to reserve initial memory threshold of &quot; +
    s&quot;${Utils.bytesToString(initialMemoryThreshold)} for computing block $blockId in memory.&quot;)
} else {
  // 如果成功申请到内存，则累加记录
  unrollMemoryUsedByThisBlock += initialMemoryThreshold
}

// Unroll this block safely, checking whether we have exceeded our threshold periodically
// 循环将每条数据写入容器中valuesHolder
while (values.hasNext &amp;amp;&amp;amp; keepUnrolling) {
  valuesHolder.storeValue(values.next())
  // 如果写入数据的条数达到一个周期，那么就检查一下是否需要申请额外的内存
  if (elementsUnrolled % memoryCheckPeriod == 0) {
    // 通过valuesHolder获取已经写入的数据的评估大小
    // 注意，这里的数据大小只是估计值，并不是十分准确
    // 具体如何进行估算的可以看valuesHolder内部实现
    val currentSize = valuesHolder.estimatedSize()
    // If our vector's size has exceeded the threshold, request more memory
    // 如果已写入的数据大小超过了当前阈值
    if (currentSize &amp;gt;= memoryThreshold) {
      // 这里每次申请的内存量都是不一样的
      // 每次申请的内存是当前已使用内存的1.5倍（默认）
      val amountToRequest = (currentSize * memoryGrowthFactor - memoryThreshold).toLong
      keepUnrolling =
        reserveUnrollMemoryForThisTask(blockId, amountToRequest, memoryMode)
      if (keepUnrolling) {
        // 记录累积申请的内存量
        unrollMemoryUsedByThisBlock += amountToRequest
      }
      // New threshold is currentSize * memoryGrowthFactor
      // 目前已经向内存管理器申请的内存量
      memoryThreshold += amountToRequest
    }
  }
  // 记录插入的数据条数
  elementsUnrolled += 1
}

// Make sure that we have enough memory to store the block. By this point, it is possible that
// the block's actual memory usage has exceeded the unroll memory by a small amount, so we
// perform one final call to attempt to allocate additional memory if necessary.
// 如果keepUnrolling为true，说明顺利地将所有数据插入，
// 并未遇到申请内存失败的情况
if (keepUnrolling) {
  // 将内部的数据转移到一个数组中
  val entryBuilder = valuesHolder.getBuilder()
  // 数据在内存中的精确大小
  val size = entryBuilder.preciseSize
  // 实际的大小可能大于申请的内存量
  // 因此根据实际大小还要再申请额外的内存
  if (size &amp;gt; unrollMemoryUsedByThisBlock) {
    val amountToRequest = size - unrollMemoryUsedByThisBlock
    keepUnrolling = reserveUnrollMemoryForThisTask(blockId, amountToRequest, memoryMode)
    if (keepUnrolling) {
      unrollMemoryUsedByThisBlock += amountToRequest
    }
  }

  if (keepUnrolling) {
    // 获取MemoryEntry对象，该对象是对插入数据的包装
    val entry = entryBuilder.build()
    // Synchronize so that transfer is atomic
    memoryManager.synchronized {
      // 这一步主要是释放申请的展开内存
      // 然后申请存储内存
      // 这里需要弄清楚展开内存的概念
      // 展开状态指的是对象在内存中处于一种比较松散的状态，这样的状态方便做一些管理如统计大小等
      // 而随后将对象转移到数组中，处于一种比较紧实的状态，数组相对来说占用的额外内存是比较小的
      // 一个数组只是一个对象，只有一个对象头，可以用来管理大量的对象
      releaseUnrollMemoryForThisTask(memoryMode, unrollMemoryUsedByThisBlock)
      // 申请存储内存
      val success = memoryManager.acquireStorageMemory(blockId, entry.size, memoryMode)
      assert(success, &quot;transferring unroll memory to storage memory failed&quot;)
    }

    // 放入map中管理起来
    entries.synchronized {
      entries.put(blockId, entry)
    }

    logInfo(&quot;Block %s stored as values in memory (estimated size %s, free %s)&quot;.format(blockId,
      Utils.bytesToString(entry.size), Utils.bytesToString(maxMemory - blocksMemoryUsed)))
    Right(entry.size)
  } else {
    // We ran out of space while unrolling the values for this block
    logUnrollFailureMessage(blockId, entryBuilder.preciseSize)
    // 如果失败，返回已经申请的展开内存
    Left(unrollMemoryUsedByThisBlock)
  }
} else {
  // We ran out of space while unrolling the values for this block
  logUnrollFailureMessage(blockId, valuesHolder.estimatedSize())
  Left(unrollMemoryUsedByThisBlock)
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;memorystore.putiteratorasbytes&quot;&gt;memoryStore.putIteratorAsBytes&lt;/h3&gt;
&lt;p&gt;我们再看另一个方法。套路基本和putIteratorAsValues是一样一样的。&lt;br/&gt;最大的区别在于ValuesHolder类型不同。非序列化形式存储使用的是DeserializedMemoryEntry，而序列化形式存储使用的是SerializedMemoryEntry。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private[storage] def putIteratorAsBytes[T](
  blockId: BlockId,
  values: Iterator[T],
  classTag: ClassTag[T],
  memoryMode: MemoryMode): Either[PartiallySerializedBlock[T], Long] = {

require(!contains(blockId), s&quot;Block $blockId is already present in the MemoryStore&quot;)

// Initial per-task memory to request for unrolling blocks (bytes).
val initialMemoryThreshold = unrollMemoryThreshold
// 字节数组的块大小，默认是1m
val chunkSize = if (initialMemoryThreshold &amp;gt; Int.MaxValue) {
  logWarning(s&quot;Initial memory threshold of ${Utils.bytesToString(initialMemoryThreshold)} &quot; +
    s&quot;is too large to be set as chunk size. Chunk size has been capped to &quot; +
    s&quot;${Utils.bytesToString(Int.MaxValue)}&quot;)
  Int.MaxValue
} else {
  initialMemoryThreshold.toInt
}

// 字节数组的容器
val valuesHolder = new SerializedValuesHolder[T](blockId, chunkSize, classTag,
  memoryMode, serializerManager)

putIterator(blockId, values, classTag, memoryMode, valuesHolder) match {
  case Right(storedSize) =&amp;gt; Right(storedSize)
  case Left(unrollMemoryUsedByThisBlock) =&amp;gt;
    // 部分展开，部分以序列化形式存储的block
    Left(new PartiallySerializedBlock(
      this,
      serializerManager,
      blockId,
      valuesHolder.serializationStream,
      valuesHolder.redirectableStream,
      unrollMemoryUsedByThisBlock,
      memoryMode,
      valuesHolder.bbos,
      values,
      classTag))
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;memorystore.putbytes&quot;&gt;memoryStore.putBytes&lt;/h3&gt;
&lt;p&gt;我们再来看另一个被外部调用用来插入数据的方法。很简单，不说了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def putBytes[T: ClassTag](
  blockId: BlockId,
  size: Long,
  memoryMode: MemoryMode,
  _bytes: () =&amp;gt; ChunkedByteBuffer): Boolean = {
require(!contains(blockId), s&quot;Block $blockId is already present in the MemoryStore&quot;)
// 首先向内存管理器申请内存
// 这里申请的是存储内存，因为要插入的字节数组，
// 所以不需要再展开，也就不需要申请展开内存
if (memoryManager.acquireStorageMemory(blockId, size, memoryMode)) {
  // We acquired enough memory for the block, so go ahead and put it
  val bytes = _bytes()
  assert(bytes.size == size)
  // 这里直接构建了一个SerializedMemoryEntry
  // 并放到map中管理起来
  val entry = new SerializedMemoryEntry[T](bytes, memoryMode, implicitly[ClassTag[T]])
  entries.synchronized {
    entries.put(blockId, entry)
  }
  logInfo(&quot;Block %s stored as bytes in memory (estimated size %s, free %s)&quot;.format(
    blockId, Utils.bytesToString(size), Utils.bytesToString(maxMemory - blocksMemoryUsed)))
  true
} else {
  false
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;通过对上面的三个方法，其实主要是前两个方法的分析，我们发现，除了对内存进行簿记管理之外，以及通过内存管理器申请内存之外，插入数据最主要的工作其实都是有ValuesHolder对象来完成的。&lt;br/&gt;ValuesHolder特质有两个实现类：DeserializedValuesHolder和SerializedValuesHolder。&lt;/p&gt;
&lt;h3 id=&quot;deserializedvaluesholder&quot;&gt;DeserializedValuesHolder&lt;/h3&gt;
&lt;p&gt;DeserializedValuesHolder对象内部有两个成员：vector，是一个SizeTrackingVector；arrayValues，是一个存放值的数组，用于在所有数据插入后，将主句转移到一个数组中，方便包装成一个MemoryEntry对象。大部分工作是有SizeTrackingVector完成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private class DeserializedValuesHolder[T] (classTag: ClassTag[T]) extends ValuesHolder[T] {
  // Underlying vector for unrolling the block
  var vector = new SizeTrackingVector[T]()(classTag)
  var arrayValues: Array[T] = null

  override def storeValue(value: T): Unit = {
    vector += value
  }

  override def estimatedSize(): Long = {
    vector.estimateSize()
  }

  override def getBuilder(): MemoryEntryBuilder[T] = new MemoryEntryBuilder[T] {
    // We successfully unrolled the entirety of this block
    arrayValues = vector.toArray
    vector = null

    override val preciseSize: Long = SizeEstimator.estimate(arrayValues)

    override def build(): MemoryEntry[T] =
      DeserializedMemoryEntry[T](arrayValues, preciseSize, classTag)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sizetracker&quot;&gt;SizeTracker&lt;/h4&gt;
&lt;p&gt;上面提到的SizeTrackingVector继承了这个特质，除了这个特质，还集成了PrimitiveVector类，但是PrimitiveVector类基本上就是对一个数组的简单包装。&lt;br/&gt;SizeTrackingVector最重要的功能：追踪对象的大小，就是在SizeTracker特之中实现的。&lt;/p&gt;
&lt;p&gt;我大致说一下这个特质是如何实现对象大小跟踪和估算的，代码实现也并不复杂，感兴趣的可以看一看，限于篇幅这里就不贴了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每插入一定数量的数据（姑且称之为周期），就会对当前的对象进行一次取样，而这个取样的周期会越来越长，以1.1倍的速率增长；&lt;/li&gt;
&lt;li&gt;取样就是计算对象大小，并与前一次取样作比较，而且只会保留最近两次的取样数据；&lt;/li&gt;
&lt;li&gt;每次取样其实就是获取两个数据，当前对象大小，当前插入的数据条数；&lt;/li&gt;
&lt;li&gt;这样与上一次取样一比较，就能够计算出每条数据的大小了；&lt;/li&gt;
&lt;li&gt;最后，在返回整个对象大小时，是拿最近一次取样时记录下的对象大小，以及根据最近的情况估算的每条数据的大小乘以自从上次取样以来新插入的数据量，二者相加作为对象大小的估算值，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可见这么做并不是什么精确，但是由于是抽样，而且抽样周期越往后面越长，所以对于数据插入的效率影响很小，而且这种不精确性其实在后续的内存检查过程中是有考虑到的。在所有数据插入完的收尾工作中，会对对象大小做一次精确计算。此外，熟悉spark内存管理的同学应该知道，其实spark一般会配置一个安全因子（一般是0.9），也就是说只是用配置的内存大小的90%，就是为了尽可能地减少这种不精确的内存估算造成OOM的可能性。&lt;/p&gt;
&lt;h3 id=&quot;serializedvaluesholder&quot;&gt;SerializedValuesHolder&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;private class SerializedValuesHolder[T](
    blockId: BlockId,
    chunkSize: Int,
    classTag: ClassTag[T],
    memoryMode: MemoryMode,
    serializerManager: SerializerManager) extends ValuesHolder[T] {
  val allocator = memoryMode match {
    case MemoryMode.ON_HEAP =&amp;gt; ByteBuffer.allocate _
      // 调用unsafe的本地方法申请直接内存
      // 这个方法之所以没有调用ByteBuffer.allocateDirect方法
      // 是因为这个方法分配的直接内存大小收到参数MaxDirectMemorySize限制
      // 所以这里绕过ByteBuffer.allocateDirect方法，通过反射和unsafe类创建直接内存对象
    case MemoryMode.OFF_HEAP =&amp;gt; Platform.allocateDirectBuffer _
  }

  val redirectableStream = new RedirectableOutputStream
  val bbos = new ChunkedByteBufferOutputStream(chunkSize, allocator)
  redirectableStream.setOutputStream(bbos)
  val serializationStream: SerializationStream = {
    val autoPick = !blockId.isInstanceOf[StreamBlockId]
    val ser = serializerManager.getSerializer(classTag, autoPick).newInstance()
    // 包装压缩流和序列化流
    ser.serializeStream(serializerManager.wrapForCompression(blockId, redirectableStream))
  }

  // 写入方法，写入的对象经过序列化，压缩，
  // 然后经过ChunkedByteBufferOutputStream被分割成一个个的字节数组块
  override def storeValue(value: T): Unit = {
    serializationStream.writeObject(value)(classTag)
  }

  override def estimatedSize(): Long = {
    bbos.size
  }

  override def getBuilder(): MemoryEntryBuilder[T] = new MemoryEntryBuilder[T] {
    // We successfully unrolled the entirety of this block
    serializationStream.close()

    override def preciseSize(): Long = bbos.size

    override def build(): MemoryEntry[T] =
      SerializedMemoryEntry[T](bbos.toChunkedByteBuffer, memoryMode, classTag)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概看一下，主要的逻辑很简单，这里面有几个注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于直接内存分配，spark并没有使用jdk的高级api，而是反射配合unsafe类分配直接内存，这样可以绕过jvm参数MaxDirectMemorySize的限制，这也体现了spark的作者尽可能的降低用户使用难度&lt;/li&gt;
&lt;li&gt;另外，我们看到序列化流其实经过了层层包装（典型的装饰器模式），序列化和压缩以及分块是比较重要的几个点，感兴趣的话可以深究，序列化和压缩如果深入了解都是很大的课题，所以这里也仅仅是蜻蜓点水，不深究了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;MemoryStore.scala这个文件中乍看代码有八百多行，但是其实很大部分代码是一些辅助类，比较核心的写入逻辑也就是前面提到的几个方法，再加上核心的两个类DeserializedValuesHolder和SerializedValuesHolder实现了以对象或字节数组的形式存储数据。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Jun 2019 15:02:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>MemeoryStore 上一节，我们对BlockManager的主要写入方法做了一个整理，知道了BlockMananger的主要写入逻辑，以及对于块信息的管理。但是，由于spark的整个存储模块是在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11006860.html</dc:identifier>
</item>
<item>
<title>IdentityServer4学习及简单使用 - Vincent-yuan</title>
<link>http://www.cnblogs.com/Vincent-yuan/p/11006758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vincent-yuan/p/11006758.html</guid>
<description>&lt;p&gt;本文，主要用来记录IdentityServer4的简单使用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要学习&lt;/span&gt;IdentityServer&lt;span&gt;，需要了解下基于&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;的验证体系，其中涉及到&lt;/span&gt;&lt;span&gt;Token, OAuth&amp;amp;OpenID,JWT,&lt;/span&gt;&lt;span&gt;协议规范等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图过程&lt;/span&gt;,&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611214802677-1556242322.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;IdentityServer4 &lt;span&gt;是一个基于&lt;/span&gt;&lt;span&gt;OpenID Connect&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;OAuth 2.0&lt;/span&gt;&lt;span&gt;的针对&lt;/span&gt;&lt;span&gt;ASP.NET Core 2.0&lt;/span&gt;&lt;span&gt;的框架,以中间件的形式存在。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;通常你可以构建&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;或重新使用&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;包含登录和注销页面的应用程序，&lt;/span&gt;&lt;span&gt;IdentityServer&lt;/span&gt;&lt;span&gt;中间件会向其添加必要的协议头，以便客户端应用程序可以使用这些标准协议与其对话。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611215001128-265833573.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以用&lt;/span&gt;IdentityServer&lt;span&gt;来做什么？&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;身份验证服务：官方认证的OpenID Connect&lt;span&gt;实现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单点登录&lt;/span&gt;/&lt;span&gt;注销&lt;/span&gt;&lt;span&gt;(SSO)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;访问受控的&lt;/span&gt;API : &lt;span&gt;为不同的客户提供访问&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;的令牌，比如：&lt;/span&gt;&lt;span&gt;MVC&lt;/span&gt;&lt;span&gt;网站、&lt;/span&gt;&lt;span&gt;SPA&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Mobile APP&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;...&lt;span&gt;等等&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先列出目录结构，以及创建顺序，来方便阅读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611215548697-400485622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IdentityServerDemo --&amp;gt; APIService1和APIService2 --&amp;gt; MVCClient&lt;/p&gt;
&lt;p&gt;其中，处MVCClient是asp.net core web mvc项目外，其他都是asp.net core web api 项目&lt;/p&gt;
&lt;h2&gt;创建名为IdentityServerDemo的认证服务&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;创建一个&lt;/span&gt;asp.net core web api&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;:IdentityServerDemo&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意&lt;/span&gt;,&lt;span&gt;不要设置&lt;/span&gt;&lt;span&gt;HTTPS,&lt;/span&gt;&lt;span&gt;否则后面使用&lt;/span&gt;&lt;span&gt;postman&lt;/span&gt;&lt;span&gt;测试时，会&lt;/span&gt;&lt;span&gt;no response&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220006428-769949568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. 添加InMemoryConfiguration&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('40e997bf-63b5-4d12-a132-5aee05400e20')&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_40e997bf-63b5-4d12-a132-5aee05400e20&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_40e997bf-63b5-4d12-a132-5aee05400e20&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('40e997bf-63b5-4d12-a132-5aee05400e20',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_40e997bf-63b5-4d12-a132-5aee05400e20&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InMemoryConfiguration
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which APIs will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        { 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Product Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Agent Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which Apps will use thie IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agent.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                }
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which uses will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestUser&amp;gt;&lt;span&gt; GetUsers()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test3@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test3password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3. &lt;span&gt;使用&lt;/span&gt;nuget&lt;span&gt;管理器，添加&lt;/span&gt;&lt;span&gt;IdentityServer4 ,&lt;/span&gt;&lt;span&gt;并且修改&lt;/span&gt;&lt;span&gt;StartUp.cs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;StartUp.cs&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;Configure&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用IdentityServer&lt;/span&gt;
&lt;span&gt;            app.UseIdentityServer();
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;StartUp.cs&lt;span&gt;中的&lt;/span&gt;ConfigureServices方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加IdentityServer&lt;/span&gt;
&lt;span&gt;            services.AddIdentityServer()
                       .AddDeveloperSigningCredential()
                       .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
                       .AddInMemoryClients(InMemoryConfiguration.GetClients())
                       .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个主要是为了把&lt;/span&gt;IdentityServer注册到容器中，需要对其进行配置，而这个配置主要包含三个信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;哪些&lt;/span&gt;api可以使用这个AuthorizationServer&lt;/li&gt;
&lt;li&gt;&lt;span&gt;哪些&lt;/span&gt;client可以使用这个AuthorizationServer&lt;/li&gt;
&lt;li&gt;&lt;span&gt;哪些&lt;/span&gt;User可以被这个AuthorizationServer识别并授权&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这里的&lt;/span&gt;AuthorizationServer 指的就是这个项目的服务：用来认证及授权使用的.&lt;/p&gt;
&lt;p&gt;这里是使用基于内存的方式。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;对于&lt;/span&gt;Token签名需要一对公钥和私钥,IdentityServer为开发者提供了一个AddDeveloperSigningCredential()方法，它会帮我们搞定这个事情并且存储到硬盘。当切换到正式环境，需要使用真正的证书，更换为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1eb31b81-2ac6-4b74-910b-0f4412bc4d72')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1eb31b81-2ac6-4b74-910b-0f4412bc4d72&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1eb31b81-2ac6-4b74-910b-0f4412bc4d72&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1eb31b81-2ac6-4b74-910b-0f4412bc4d72',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1eb31b81-2ac6-4b74-910b-0f4412bc4d72&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        InMemoryConfiguration.Configuration &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Configuration;

        services.AddIdentityServer()
            .AddDeveloperSigningCredential()
            .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
            .AddInMemoryClients(InMemoryConfiguration.GetClients())
            .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;此项目，暂时不使用正式的证书了。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4.使用postman获取token&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;启动我们的&lt;/span&gt;IdentityServerDemo 项目，&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后使用&lt;/span&gt;postman发送请求&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220712149-1622505131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;5.引入QuickStartUI&lt;/p&gt;
&lt;p&gt;IdentityServer为我们提供了一套UI以使我们能快速的开发具有基本功能的认证/授权界面，下载地址：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/&quot; target=&quot;_blank&quot;&gt;QuickStartUI&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;把&lt;/span&gt;QuickStartUI引入到我们的项目中，目录结构如下：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220833788-1326632282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;5.&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;StartUp.cs&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;修改&lt;/span&gt;Configure&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;添加静态文件中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用IdentityServer&lt;/span&gt;
&lt;span&gt;            app.UseIdentityServer();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for QuickStart-UI 启用静态文件&lt;/span&gt;
&lt;span&gt;            app.UseStaticFiles();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.UseMvc();&lt;/span&gt;
            app.UseMvcWithDefaultRoute(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里带有默认的路由&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;6.&lt;span&gt;运行程序&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220920963-381802551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;登录&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;点击&lt;/span&gt;here&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220932985-664821798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220942060-497302533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;登出&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611220953339-399616195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;IdentityServer&lt;span&gt;集成&lt;/span&gt;&lt;span&gt;API Service&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.  &lt;span&gt;添加&lt;/span&gt;asp.net core web api&lt;span&gt;项目&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意，这里也是使用&lt;/span&gt;http&lt;span&gt;方式；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;nuget&lt;span&gt;中安装&lt;/span&gt;&lt;span&gt;IdentityServer4.AccessTokenValidation &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;StartUp.cs&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;修改&lt;/span&gt;configureServices&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IdentityServer&lt;/span&gt;
&lt;span&gt;            services.AddMvcCore().AddAuthorization().AddJsonFormatters();
            services.AddAuthentication(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity:Scheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
                        .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        {
                            options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要https&lt;/span&gt;
                            options.Authority = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IdentityServer授权路径&lt;/span&gt;
                            options.ApiName = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service:Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要授权的服务名称&lt;/span&gt;
&lt;span&gt;                        });

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;修改&lt;/span&gt;Configure&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在&lt;/span&gt;UseMvc()&lt;span&gt;之前启用&lt;/span&gt;&lt;span&gt;Authentication&lt;/span&gt;&lt;span&gt;中间件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用Authentication中间件&lt;/span&gt;
&lt;span&gt;            app.UseAuthentication();

            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;appsettings.json&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本服务的名称&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;53064&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,　　&lt;span&gt;//本服务的端口号，根据自己服务启动时的端口号进行更改
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DocName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API provide some API to help you get client information from CAS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Contact&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS 2.0 Team&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EdisonZhou@manulife.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XmlFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test.ApiService01.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去请求授权的Identity服务,这里即IdentityServerDemo的服务启动时的地址&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;49363&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  &lt;span&gt;//IdentityServerDemo项目启动时的端口号,根据实际情况修改
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;上面是&lt;/span&gt;APIService1&lt;span&gt;的添加&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;对应的服务名称是&lt;/span&gt;&lt;span&gt;clientservice;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; APIService2&lt;span&gt;与之类似，只是把&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;改为&lt;/span&gt;&lt;span&gt;productservice.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;在&lt;/span&gt;APIService1&lt;span&gt;和&lt;/span&gt;&lt;span&gt;APIService2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Controller&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;[Authorize]&lt;/span&gt;&lt;span&gt;特性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [Authorize]
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
    {
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;5. 测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611222021818-348098832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，这里模拟的是clientservice&lt;span&gt;服务&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;即&lt;/span&gt;&lt;span&gt;APIService1)&lt;/span&gt;&lt;span&gt;去认证服务器请求&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;的过程，所以请求到&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;，也应该在获取&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;相关授权的时候携带这个&lt;/span&gt;&lt;span&gt;token.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611222108269-183740026.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在请求&lt;/span&gt;productservice&lt;span&gt;的授权服务中，使用&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;则会显示未授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611222205399-1520901707.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;587&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;过程总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;首先，在授权服务中，设置需要请求的&lt;/span&gt;ApiResource,client,user&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在&lt;/span&gt;postman（相当于client）中，输入client的相关信息(client_id,client_serect)去请求token&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后就可以根据授权服务中相应&lt;/span&gt;client的AllowedScopes设置的范围来请求服务了。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;授权服务中的&lt;/span&gt;client设置&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611222312104-1449576339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1. &lt;span&gt;新建一个&lt;/span&gt;ASP.NET Core MVC&lt;span&gt;项目：&lt;/span&gt;&lt;span&gt;MVCClient&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.&lt;/span&gt;&lt;span&gt;为指定方法添加&lt;/span&gt;[Authorize]&lt;span&gt;特性&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;我们为&lt;/span&gt;HomeController&lt;span&gt;下的&lt;/span&gt;Privacy方法上添加Authorize特性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　[Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Privacy()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;这个时候，直接访问Privacy,会报错&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;而我们希望的效果是：当用户第一次点击Privacy,页面重定向到验证服务(IdentityServerDemo),当用户登录验证授权后,再重定向到该网站。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;此后一定时间范围内的第二次，第三次点击，都不需要再重定向到验证服务,而是直接读取保存的token.&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.  &lt;span&gt;给&lt;/span&gt;MVCClient项目添加OpenID Connect Authentication&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;而这部分主要集中于做&lt;/span&gt;Authentication(身份验证)而非Authorization(授权)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lambda determines whether user consent for non-essential cookies is needed for a given request.&lt;/span&gt;
                options.CheckConsentNeeded = context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });


            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这部分主要是做身份验证的(Authentication)，而不是授权(Authorization)&lt;/span&gt;
&lt;span&gt;            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;oidc =&amp;gt; open id connect&lt;/span&gt;
&lt;span&gt;            })
            .AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
            {
                options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.Authority &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:IP&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}:{Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Identity:Port&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                options.ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许返回access token&lt;/span&gt;
                options.SaveTokens = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            });

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里我们使用的是&lt;/span&gt;implicit这个flow，它主要用于客户端应用程序(主要指基于javascript的应用),它允许客户端程序重定向到验证服务(IdentityServerDemo),而后带着token重定向回来。&lt;/p&gt;
&lt;p&gt;另外,这里的ResponseType为”id_token token”,表示既获取id_token也获取access_token. 而SaveTokens设置为true，表示会将从验证服务返回的token持久化到cookie中，这样就不用每次请求token了。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;另在&lt;/span&gt;configure方法中，设置Authentication中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            app.UseAuthentication();

            app.UseStaticFiles();
            app.UseCookiePolicy();

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;主要&lt;/span&gt;Authentication中间件，要再UseMvc之前。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4. &lt;span&gt;修改&lt;/span&gt;app.settings&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本服务的名称&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;56458&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务端口号,根据实际情况调整&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DocName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service API provide some API to help you get client information from CAS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Contact&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS 2.0 Team&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EdisonZhou@manulife.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XmlFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test.ApiService01.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去请求授权的Identity服务&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;49363&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;port&lt;span&gt;根据自己此服务启动后的端口号修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;/span&gt;&lt;span&gt;在验证服务&lt;/span&gt;(IdentityServerDemo)&lt;span&gt;中添加&lt;/span&gt;&lt;span&gt;MvcClient&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;修改&lt;/span&gt; InMemoryConfiguration &lt;span&gt;中的&lt;/span&gt;GetClients&lt;span&gt;方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agent.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.mvc.client.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS MVC Web App Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.Implicit,
                    RedirectUris &lt;/span&gt;= { $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:56458/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:56458/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; [] {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    AllowAccessTokensViaBrowser &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; can return access_token to this client&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;&lt;span&gt;                },&lt;/span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这里&lt;/span&gt;ClientId&lt;span&gt;要和&lt;/span&gt;&lt;span&gt;MvcClient&lt;/span&gt;&lt;span&gt;中设置的一样。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;RedirectUris&lt;/span&gt;&lt;span&gt;是指登录成功以后需要重定向的地址&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;即重定向到&lt;/span&gt;&lt;span&gt;MvcClient&lt;/span&gt;&lt;span&gt;中的地址&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;PostLogoutRedirectUris&lt;/span&gt;&lt;span&gt;是指登出之后需要重定向的地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;API Service Client&lt;/span&gt;&lt;span&gt;的设置不同的就是&lt;/span&gt;&lt;span&gt;AllowedScopes&lt;/span&gt;&lt;span&gt;中给它增加了&lt;/span&gt;&lt;span&gt;OpenId&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Profile,&lt;/span&gt;&lt;span&gt;因为我们为&lt;/span&gt;&lt;span&gt;MvcClient&lt;/span&gt;&lt;span&gt;设定的是&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;而不是&lt;/span&gt;&lt;span&gt;bearer&lt;/span&gt;&lt;span&gt;模式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;最后为了使用这些&lt;/span&gt;&lt;span&gt;OpenID Connect Scopes,&lt;/span&gt;&lt;span&gt;需要设置这些&lt;/span&gt;&lt;span&gt;Identity Resources。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt; InMemoryConfiguration &lt;span&gt;中增加&lt;/span&gt;GetIdentityResources方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; GetIdentityResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile(),
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;在&lt;/span&gt;ConfigureServices方法中修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加IdentityServer&lt;/span&gt;
&lt;span&gt;            services.AddIdentityServer()
                       .AddDeveloperSigningCredential()
                       .&lt;span&gt;AddInMemoryIdentityResources(InMemoryConfiguration.GetIdentityResources())&lt;/span&gt;
                       .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
                       .AddInMemoryClients(InMemoryConfiguration.GetClients())
                       .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6. &lt;span&gt;在&lt;/span&gt;MvcClient项目的Privacy &lt;span&gt;页面中修改如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Privacy Policy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;h1&amp;gt;@ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;Use &lt;span&gt;this&lt;/span&gt; page to detail your site&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s privacy policy.&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span&gt;

@using Microsoft.AspNetCore.Authentication
&lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;strong&amp;gt;id_token&amp;lt;/strong&amp;gt;
    &amp;lt;span&amp;gt;@await ViewContext.HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;strong&amp;gt;access_token&amp;lt;/strong&amp;gt;
    &amp;lt;span&amp;gt;@await ViewContext.HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;dl&amp;gt;&lt;span&gt;
    @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claim &lt;span&gt;in&lt;/span&gt;&lt;span&gt; User.Claims)
    {
        &lt;/span&gt;&amp;lt;dt&amp;gt;@claim.Type&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@claim.Value&amp;lt;/dd&amp;gt;&lt;span&gt;
    }
&lt;/span&gt;&amp;lt;/dl&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;这里，我们会把&lt;/span&gt;id_token和access_token显示出来&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;7. &lt;span&gt;为了退出方便，暂时在&lt;/span&gt;HomeController下增加Logout方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Logout()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; HttpContext.SignOutAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; HttpContext.SignOutAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8. 简单测试&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;启动&lt;/span&gt;IdentityServerDemo这个验证服务；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动&lt;/span&gt;MvcClient&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;Mvc Web Application&lt;/span&gt;&lt;span&gt;服务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223535483-1123787093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223555050-1226887253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223544967-154297974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223610187-62567321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;这里没有添加可点击的按钮，可直接在url中修改路径来登出&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223626844-443388330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190611223637437-1330656362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html&quot;&gt;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 另外推荐&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html&quot;&gt;edisonchou&lt;/a&gt;微服务系列，感觉非常棒&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;a href=&quot;https://github.com/Vincent-yuan/IdentityServerDemo&quot;&gt;https://github.com/Vincent-yuan/IdentityServerDemo&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Jun 2019 14:43:00 +0000</pubDate>
<dc:creator>Vincent-yuan</dc:creator>
<og:description>本文，主要用来记录IdentityServer4的简单使用。 一. IdentityServer的预备知识 要学习IdentityServer，需要了解下基于Token的验证体系，其中涉及到Token</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Vincent-yuan/p/11006758.html</dc:identifier>
</item>
</channel>
</rss>