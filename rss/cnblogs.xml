<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>FFmpeg libswscale源码分析1-API介绍 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/14349382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/14349382.html</guid>
<description>&lt;p&gt;本文为作者原创，转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14349382.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/leisure_chn/p/14349382.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libswscale 是 FFmpeg 中完成图像尺寸缩放和像素格式转换的库。用户可以编写程序，调用 libswscale 提供的 API 来进行图像尺寸缩放和像素格式转换。也可以使用 scale 滤镜完成这些功能，scale 滤镜实现中调用了 libswscale 的 API。libswscale 的 API 非常简单，就一个 sws_scale() 接口，但内部的实现却非常复杂。&lt;/p&gt;
&lt;p&gt;本文分析 libswscale 源码，因篇幅较长，遂拆分成下面一系列文章：&lt;br/&gt;[1]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14349382.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析1-API介绍&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355015.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析2-转码命令行与滤镜图&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355017.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析3-scale滤镜源码分析&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355019.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析4-libswscale源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码分析基于 FFmpeg 4.1 版本。&lt;/p&gt;
&lt;h2 id=&quot;1-api-介绍&quot;&gt;1. API 介绍&lt;/h2&gt;
&lt;h3 id=&quot;11-相关基础概念&quot;&gt;1.1 相关基础概念&lt;/h3&gt;
&lt;p&gt;在解释具体的函数前，必须理解与像素格式相关的几个基础概念：参&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10290575.html&quot; target=&quot;_blank&quot;&gt;色彩空间与像素格式&lt;/a&gt;一文第 4.1 节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pixel_format&lt;/strong&gt;：像素格式，图像像素在内存中的排列格式。一种像素格式包含有色彩空间、采样方式、存储模式、位深等信息，其中体现的最重要信息就是存储模式，具体某一类的存储模式参照本文第 2 节、第 3 节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_depth&lt;/strong&gt;: 位深，指每个分量(Y、U、V、R、G、B 等)单个采样点所占的位宽度。&lt;/p&gt;
&lt;p&gt;例如对于 yuv420p(位深是8)格式而言，每一个 Y 样本、U 样本和 V 样本都是 8 位的宽度，只不过在水平方向和垂直方向，U 样本数目和 V 样本数目都只有 Y 样本数目的一半。而 bpp (Bits Per Pixel)则是将图像总比特数分摊到每个像素上，计算出平均每个像素占多少个 bit，例如 yuv420p 的 bpp 是 12，表示平均每个像素占 12 bit(Y占8位、U占2位、V占2位)，实际每个 U 样本和 V 样本都是 8 位宽度而不是 2 位宽度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;plane&lt;/strong&gt;: 存储图像中一个或多个分量的一片内存区域。一个 plane 包含一个或多个分量。planar 存储模式中，至少有一个分量占用单独的一个 plane，具体到 yuv420p 格式有 Y、U、V 三个 plane，nv12 格式有 Y、UV 两个 plane，gbrap 格式有 G、B、R、A 四个 plane。packed 存储模式中，因为所有分量的像素是交织存放的，所以 packed 存储模式只有一个 plane。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slice&lt;/strong&gt;: slice 是 FFmpeg 中使用的一个内部结构，在 codec、filter 中常有涉及，通常指图像中一片连续的行，表示将一帧图像分成多个片段。注意 slice 是针对图像分片，而不是针对 plane 分片，一帧图像有多个 plane，一个 slice 里同样包含多个 plane。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stride/pitch&lt;/strong&gt;: 一行图像中某个分量(如亮度分量或色度分量)所占的字节数， 也就是一个 plane 中一行数据的宽度。有对齐要求，计算公式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stride 值 = 图像宽度 * 分量数 * 单样本位宽度 / 水平子采样因子 / 8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，图像宽度表示图像宽度是多少个像素，分量数指当前 plane 包含多少个分量(如 rgb24 格式一个 plane 有 R、G、B 三个分量)，单位本位宽度指某分量的一个样本在考虑对齐后在内存中占用的实际位数(例如位深 8 占 8 位宽，位深 10 实际占 16 位宽，对齐值与平台相关)，水平子采样因子指在水平方向上每多少个像素采样出一个色度样本(亮度样本不进行下采样，所以采样因子总是 1)。&lt;/p&gt;
&lt;p&gt;需要注意的是，stride 考虑的是 plane 中的一行。对 yuv420p 格式而言，Y 分量是完全采样，因此一行 Y 样本数等于图像宽度，U 分量和 V 分量水平采样因子是 2(每两个像素采样出一个U样本和V样本)，因此一行 U 样本数和一行 V 样本数都等于图像宽度的一半。U 分量和 V 分量垂直采样因子也是 2，因此 U 分量和 V 分量的行数少了，只有图像高度的一半，但垂直方向的采样率并不影响一个 plane 的 stride 值，因为 stride 的定义决定了其值只取决于水平方向的采样率。&lt;/p&gt;
&lt;p&gt;若源图像像素格式是 yuv420p(有 Y、U、V 三个 plane)，位深是 8(每一个Y样本、U样本、V样本所占位宽度是 8 位)，分辨率是 1280x720，则在 Y plane 的一行数据中，有 1280 个 Y 样本，占用 1280 个字节，stride 值是 1280；在 U plane 的一行数据中，有 640 个 U 样本，占用 640 个字节，stride 值是 640；在 V plane 的一行数据中，有 640 个样本，占用 640 个字节，stride 值是 640。&lt;/p&gt;
&lt;p&gt;若源图像像素格式是 yuv420p10(有 Y、U、V 三个 plane)，位深是 10 (内存对齐后每个样本占 16 位)，分辨率仍然是 1280x720，则 Y plane 的 stride 值为 1280 x 16 / 8 = 2560，U plane stride 值为 640 x 16 / 8 = 1280，V plane stride 值为 640 x 16 / 8 = 1280。&lt;/p&gt;
&lt;p&gt;若源图像像素格式是 yuv420p16le(有 Y、U、V 三个 plane)，位深是 16，分辨率仍然是 1280x720，则 Y plane 的 stride 值为 1280 x 16 / 8 = 2560，U plane stride 值为 640 x 16 / 8 = 1280，V plane stride 值为 640 x 10 / 8 = 1280。&lt;/p&gt;
&lt;p&gt;若源图像像素格式是 p010le(有 Y、UV 两个 plane)，位深是 10 (内存对齐后，每个样本占 16 位)，分辨率仍然是 1280x720，则 Y plane 的 stride 值为 1280 x 16 / 8 = 2560，UV plane stride 值为 640 x 2 x 16 / 8 = 2560。&lt;/p&gt;
&lt;p&gt;若源图像像素格式是 bgr24(有 BGR 一个 plane)，位深是 8，分辨率仍然是 1280x720。因 bgr24 像素格式是 packed 存储模式，每个像素 R、G、B 三个采样点交织存放，内存区的排列形式为 BGRBGR...，因此可以认为它只有一个 plane，此 plane 中一行图像有 1280 个 R 样本，1280 个 G 样本，1280 个 B 样本，此 plane 的 stride 值为 1280 x 3 x 8 / 8 = 3840。&lt;/p&gt;
&lt;h3 id=&quot;12-初始化函数-sws_getcontext&quot;&gt;1.2 初始化函数 sws_getContext()&lt;/h3&gt;
&lt;p&gt;sws_getContext()函数将创建一个 SwsContext，后续使用 sws_scale() 执行缩放/格式转换操作时需要用到此 SwsContext。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Allocate and return an SwsContext. You need it to perform
 * scaling/conversion operations using sws_scale().
 *
 * @param srcW the width of the source image
 * @param srcH the height of the source image
 * @param srcFormat the source image format
 * @param dstW the width of the destination image
 * @param dstH the height of the destination image
 * @param dstFormat the destination image format
 * @param flags specify which algorithm and options to use for rescaling
 * @param param extra parameters to tune the used scaler
 *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis
 *              function, param[0] tunes f(1) and param[1] f´(1)
 *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff
 *              frequency
 *              For SWS_LANCZOS param[0] tunes the width of the window function
 * @return a pointer to an allocated context, or NULL in case of error
 * @note this function is to be removed after a saner alternative is
 *       written
 */
struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,
                                  int dstW, int dstH, enum AVPixelFormat dstFormat,
                                  int flags, SwsFilter *srcFilter,
                                  SwsFilter *dstFilter, const double *param);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数参数及返回值说明如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcW&lt;/strong&gt;&lt;br/&gt;srcW 是源图像的宽度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcH&lt;/strong&gt;&lt;br/&gt;srcH 是源图像的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcFormat&lt;/strong&gt;&lt;br/&gt;srcFormat 是源图像的像素格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param dstW&lt;/strong&gt;&lt;br/&gt;dstW 是目标图像的宽度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param dstH&lt;/strong&gt;&lt;br/&gt;dstH 是目标图像的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param dstFormat&lt;/strong&gt;&lt;br/&gt;dstFormat 是目标图像的像素格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param flags&lt;/strong&gt;&lt;br/&gt;flags 可以指定用于缩放/转换操作的算法以及选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param param&lt;/strong&gt;&lt;br/&gt;param 为缩放操作提供额外的参数。&lt;br/&gt;对于 BICUBIC 算法，param[0] 和 param[1] 调整基函数的形状，param[0] 调整 f(1)，param[1] 调整 f´(1)。&lt;br/&gt;对于 GAUSS 算法，param[0] 调整指数，从而调整了截止频率。&lt;br/&gt;对于 LANCZOS 算法，param[0] 调整窗口函数的宽度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@return&lt;/strong&gt;&lt;br/&gt;返回值是一个指向已分配 context 的指针，出错时为 NULL 。&lt;/p&gt;
&lt;h3 id=&quot;13-转换函数-sws_scale&quot;&gt;1.3 转换函数 sws_scale()&lt;/h3&gt;
&lt;p&gt;图像分辨率转换、像素格式转换都通过这一个函数完成。&lt;/p&gt;
&lt;p&gt;sws_scale() 函数接口定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Scale the image slice in srcSlice and put the resulting scaled
 * slice in the image in dst. A slice is a sequence of consecutive
 * rows in an image.
 *
 * Slices have to be provided in sequential order, either in
 * top-bottom or bottom-top order. If slices are provided in
 * non-sequential order the behavior of the function is undefined.
 *
 * @param c         the scaling context previously created with
 *                  sws_getContext()
 * @param srcSlice  the array containing the pointers to the planes of
 *                  the source slice
 * @param srcStride the array containing the strides for each plane of
 *                  the source image
 * @param srcSliceY the position in the source image of the slice to
 *                  process, that is the number (counted starting from
 *                  zero) in the image of the first row of the slice
 * @param srcSliceH the height of the source slice, that is the number
 *                  of rows in the slice
 * @param dst       the array containing the pointers to the planes of
 *                  the destination image
 * @param dstStride the array containing the strides for each plane of
 *                  the destination image
 * @return          the height of the output slice
 */
int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],
              const int srcStride[], int srcSliceY, int srcSliceH,
              uint8_t *const dst[], const int dstStride[]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sws_scale() 函数处理的对象是图像中的一个 slice。源图像中的一个 slice 经 sws_scale() 函数处理后，变成目标图像中的一个slice。一个 slice 指图像中一片连接的行。每次向 sws_scale() 函数提供的源 slice 必须是连续的，可以按由图像顶部到底部的顺序，也可以使用从图像底部到顶部的顺序。如果不按顺序提供 slice，sws_scale() 的执行结果是不确定的。&lt;/p&gt;
&lt;p&gt;函数参数及返回值说明如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param c&lt;/strong&gt;&lt;br/&gt;c 是由 sws_getContext() 函数创建的 SwsContext 上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcSlice&lt;/strong&gt;&lt;br/&gt;srcSlice 是一个指针数组(数组的每个元素是指针)，每个指针指向源 slice 里的各个 plane。一帧图像通常有多个 plane，若将一帧图像划分成多个 slice，则每个 slice 里同样包含多个 plane。&lt;/p&gt;
&lt;p&gt;通常调用 sws_scale() 时不会将一帧图像划分多个 slice，一帧图像就是一个 slice，所以通常为此函数提供的实参是 AVFrame.*data[]。&lt;/p&gt;
&lt;p&gt;在使用 scale 滤镜时，可以将 nb_slices 选项参数设置为大于 1，以观察将一帧图像划分为多个 slice 情况。scale 滤镜中 nb_slices 选项的说明中有提到，此选项仅用于调试目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcStride&lt;/strong&gt;&lt;br/&gt;srcStride 是一个数组，每个元素表示源图像中一个 plane 的 stride。通常为此函数提供的实参是 AVFrame.linesize[]。如前所述，若源图像是 yuv420p 8bit，分辨率是 1280x720，则 srcStride 数组有三个元素具有有效值，依次是 1280、640、640。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcSliceY&lt;/strong&gt;&lt;br/&gt;srcSliceY 表示待处理的 slice 在源图像中的起始位置(相对于第 1 行的行数)，第 1 行位置为 0，第 2 行位置为 1，依此类推。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param srcSliceH&lt;/strong&gt;&lt;br/&gt;srcSliceH 表示待处理的 slice 的高度(行数)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param dst&lt;/strong&gt;&lt;br/&gt;dst 是一个指针数组，每个指针指向目标图像中的一个 plane。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@param dstStride&lt;/strong&gt;&lt;br/&gt;dstStride 是一个数组，每个元素表示目标图像中一个 plane 的 stride。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@return&lt;/strong&gt;&lt;br/&gt;函数返回值表示输出 slice 的高度(行数)。&lt;/p&gt;
&lt;h2 id=&quot;5-参考资料&quot;&gt;5 参考资料&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10290575.html&quot; target=&quot;_blank&quot;&gt;色彩空间与像素格式&lt;/a&gt;, &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10290575.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/leisure_chn/p/10290575.html&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44305697&quot; target=&quot;_blank&quot;&gt;FFmpeg源代码简单分析：libswscale的sws_getContext()&lt;/a&gt;, &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44305697&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/leixiaohua1020/article/details/44305697&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44346687&quot; target=&quot;_blank&quot;&gt;FFmpeg源代码简单分析：libswscale的sws_scale()&lt;/a&gt;, &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/44346687&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/leixiaohua1020/article/details/44346687&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-修改记录&quot;&gt;6 修改记录&lt;/h2&gt;
&lt;p&gt;2021-01-30 V1.0 初稿&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:49:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>本文为作者原创，转载请注明出处：https://www.cnblogs.com/leisure_chn/p/14349382.html libswscale 是 FFmpeg 中完成图像尺寸缩放和像素</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leisure_chn/p/14349382.html</dc:identifier>
</item>
<item>
<title>虚函数表-C++多态的实现原理 - sherlock_lin</title>
<link>http://www.cnblogs.com/sherlock-lin/p/14355006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlock-lin/p/14355006.html</guid>
<description>[unable to retrieve full-text content]我们都知道多态指的是父类的指针在运行中指向子类，那么它的实现原理是什么呢？答案是虚函数表</description>
<pubDate>Mon, 01 Feb 2021 00:33:00 +0000</pubDate>
<dc:creator>sherlock_lin</dc:creator>
<og:description>我们都知道多态指的是父类的指针在运行中指向子类，那么它的实现原理是什么呢？答案是虚函数表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sherlock-lin/p/14355006.html</dc:identifier>
</item>
<item>
<title>请你讲讲分布式系统中的限流器一般如何实现？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14355001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14355001.html</guid>
<description>&lt;h3 id=&quot;限流器相关算法&quot;&gt;限流器相关算法&lt;/h3&gt;
&lt;p&gt;一般限流器有五种算法，分别是：令牌桶，漏斗桶，固定窗口，滑动日志（指的其实是广义上的滑动窗口），滑动窗口（&lt;strong&gt;这里指的是滑动日志+固定窗口结合的一种算法&lt;/strong&gt;）。&lt;/p&gt;
&lt;h4 id=&quot;1-令牌桶（token-bucket）&quot;&gt;1. 令牌桶（Token bucket）&lt;/h4&gt;
&lt;p&gt;令牌桶算法用来控制一段时间内发送到网络上的数据的数目，并允许突发数据的发送。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/TokenBucket.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法大概是：&lt;/strong&gt; 假设允许的请求速率为&lt;code&gt;r&lt;/code&gt;次每秒，那么每过&lt;code&gt;1/r&lt;/code&gt;秒就会向桶里面添加一个令牌。桶的最大大小是&lt;code&gt;b&lt;/code&gt;。当一个大小为&lt;code&gt;n&lt;/code&gt;的请求到来时，检查桶内令牌数是否足够，如果足够，令牌数减少&lt;code&gt;n&lt;/code&gt;，请求通过。不够的话就会触发拒绝策略。&lt;/p&gt;
&lt;p&gt;令牌桶有一个固定大小，假设每一个请求也有一个大小，当要检查请求是否符合定义的限制时，会检查桶，以确定它当时是否包含足够的令牌。如果有，那么会移除掉这些令牌，请求通过。否则，会采取其他操作，一般是拒绝。令牌桶中的令牌会以一定速率恢复，这个速率就是允许请求的速率（当然，根据大小的配置，可能实际会超过这个速率，但是随着令牌桶的消耗会被调整回这个恢复速率）。&lt;/p&gt;
&lt;p&gt;如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断地增多，直到把桶填满。可以看出，令牌桶在保持整体上的请求速率的同时，允许某种程度的突发传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式环境下的令牌桶的实现需要考虑如下几个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;令牌桶当前大小究竟如何存储？是只存储一个当前令牌桶的大小（例如通过 redis 的一个键值对存储），还是存放每个通过的请求到来的时间戳（例如通过 redis 的 zset 实现，zset 的大小就是桶的最大大小）？&lt;/li&gt;
&lt;li&gt;令牌桶的令牌补充是由谁补充？对于存储一个当前令牌桶的大小的实现方式，需要一个进程以速率&lt;code&gt;r&lt;/code&gt;不断地往里面添加令牌，&lt;strong&gt;那么如何在分布式的环境下保证有且只有一个这样的进程，这个进程挂了怎么办&lt;/strong&gt;？对于存放每个通过的请求到来的时间戳的这种实现方式实现，&lt;strong&gt;那么怎么控制记录请求的个数，肯定不能每个都记录&lt;/strong&gt;，并且&lt;strong&gt;每次怎么通过目前的请求以及时间戳来判断剩余令牌数量&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;2-漏斗桶（leaky-bucket）&quot;&gt;2. 漏斗桶（Leaky bucket）&lt;/h4&gt;
&lt;p&gt;漏斗桶控制请求必须在最大某个速率被消费，就像一个漏斗一样，入水量可大可小，但是最大速率只能到某一量值，不会像令牌桶一样，会有小的尖峰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/LeakyBucket.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法大概是：&lt;/strong&gt; 主要实现方式是通过一个 FIFO （First in first out）的队列实现，这个队列是一个有界队列，大小为&lt;code&gt;b&lt;/code&gt;，如果请求堆积满了队列，就会触发丢弃策略。假设允许的请求速率为&lt;code&gt;r&lt;/code&gt;次每秒，那么这个队列中的请求，就会以这个速率进行消费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式环境下的漏桶的实现需要考虑如下几个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 漏桶的队列，怎么存放？&lt;/strong&gt;这个队列需要存放每个通过的请求以及对应的消费的时间戳，保证消费的平稳。同时，这个队列最好是无锁队列，因为会有分布式锁征用。并且，这个队列大小应该设置为&lt;code&gt;b&lt;/code&gt;，并每次有请求到来时，放入队列的同时清理队列。&lt;br/&gt;&lt;strong&gt;2. 消费如何实现？&lt;/strong&gt;也就是存入队列的请求，如何消费呢？可以请求到来时，通过队列中的请求来判断当前这个请求的执行时间应该是多久以后，之后入队列，延迟这么久再执行这个请求。也可以利用本身带延迟时间实现的队列来实现。&lt;/p&gt;
&lt;h4 id=&quot;3-固定时间窗口（fixed-window）&quot;&gt;3. 固定时间窗口（Fixed window）&lt;/h4&gt;
&lt;p&gt;固定时间窗口比较简单，就是将时间切分成若干个时间片，每个时间片内固定处理若干个请求。这种实现不是非常严谨，但是由于实现简单，适用于一些要求不严格的场景。&lt;br/&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/FixedWindow.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;算法大概是：&lt;/strong&gt; 假设&lt;code&gt;n&lt;/code&gt;秒内最多处理&lt;code&gt;b&lt;/code&gt;个请求，那么每隔&lt;code&gt;n&lt;/code&gt;秒将计数器重置为&lt;code&gt;b&lt;/code&gt;。请求到来时，如果计数器值足够，则扣除并请求通过，不够则触发拒绝策略。&lt;/p&gt;
&lt;p&gt;固定时间窗口是最容易实现的算法，但是也是有明显的缺陷：那就是在很多情况下，尤其是请求限流后拒绝策略为排队的情况下，请求都在时间窗口的开头被迅速消耗，剩下的时间不处理任何请求，这是不太可取的。并且，在一些极限情况下，实际上的流量速度可能达到限流的 2 倍。例如限制 1 秒内最多 100 个请求。假设 0.99 秒的时候 100 个请求到了，之后 1.01 秒的时候又有 100 个请求到了，这样的话其实在 0.99 秒 ~ 1.01 秒这一段时间内有 200 个请求，并不是严格意义上的每一秒都只处理 100 个请求。为了能实现严格意义上的请求限流，则有了后面两种算法。&lt;/p&gt;
&lt;h4 id=&quot;4-滑动日志（sliding-log）&quot;&gt;4. 滑动日志（Sliding Log）&lt;/h4&gt;
&lt;p&gt;滑动日志根据缓存之前接受请求对应的时间戳，与当前请求的时间戳进行计算，控制速率。这样可以严格限制请求速率。一般的网上提到的滑动窗口算法也指的是这里的滑动日志（Sliding Log）算法，&lt;strong&gt;但是我们这里的滑动窗口是另一种优化的算法，待会会提到&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/SlidingLog.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法大概是：&lt;/strong&gt; 假设&lt;code&gt;n&lt;/code&gt;秒内最多处理&lt;code&gt;b&lt;/code&gt;个请求。那么会最多缓存 &lt;code&gt;b&lt;/code&gt; 个通过的请求与对应的时间戳，假设这个缓存集合为&lt;code&gt;B&lt;/code&gt;。每当有请求到来时，从&lt;code&gt;B&lt;/code&gt;中删除掉&lt;code&gt;n&lt;/code&gt;秒前的所有请求，查看集合是否满了，如果没满，则通过请求，并放入集合，如果满了就触发拒绝策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式环境下的滑动日志的实现需要考虑如下几个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们的算法其实已经简化了存储，但是对于高并发的场景，要缓存的请求可能会很多（例如限制每秒十万的请求，那么这个缓存的大小是否就应该能存储十万个请求？），这个缓存应该如何实现？&lt;/li&gt;
&lt;li&gt;高并发场景下，对于这个集合的删除掉&lt;code&gt;n&lt;/code&gt;秒前的所有请求的这个操作，需要速度非常快。如果你的缓存集合实现对于按照时间戳删除这个操作比较慢，可以缓存多一点请求，定时清理删除&lt;code&gt;n&lt;/code&gt;秒前的所有请求而不是每次请求到来都删除。请求到来的时候，查看&lt;code&gt;b&lt;/code&gt;个之前的请求是否存在并且时间差小于&lt;code&gt;n&lt;/code&gt;秒，存在并且小于代表应该触发限流策略。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;5-滑动窗口（滑动日志--固定窗口）&quot;&gt;5. 滑动窗口（滑动日志 + 固定窗口）&lt;/h4&gt;
&lt;p&gt;前面的滑动日志，我们提到了一个问题 - 要缓存的请求可能会很多。也许在我们的架构内不能使用一个恰当的缓存来实现，我们可以通过滑动窗口这个方法来减少要存储的请求数量，并减少集合大小减少同一个集合上面的并发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/SlidingWindow.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法大概是：&lt;/strong&gt; 假设&lt;code&gt;n&lt;/code&gt;秒内最多处理&lt;code&gt;b&lt;/code&gt;个请求。我们可以将&lt;code&gt;n&lt;/code&gt;秒切分成每个大小为&lt;code&gt;m&lt;/code&gt;毫秒得时间片，只有最新的时间片内缓存请求和时间戳，之前的时间片内只保留一个请求量的数字。这样可以大大优化存储，小幅度增加计算量。对于临界条件，就是之前已经有了&lt;code&gt;n/m&lt;/code&gt;个时间片，计算&lt;code&gt;n&lt;/code&gt;秒内请求量时可以计算当前时间片内经过时间的百分比，假设是 25%，那么就取开头的第一个时间片的请求量的 75% 进行计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%99%90%E6%B5%81%E5%99%A8/SlidingWindowCalculate.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:29:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>限流器相关算法 一般限流器有五种算法，分别是：令牌桶，漏斗桶，固定窗口，滑动日志（指的其实是广义上的滑动窗口），滑动窗口（这里指的是滑动日志+固定窗口结合的一种算法）。 1. 令牌桶（Token bu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14355001.html</dc:identifier>
</item>
<item>
<title>MySQL的索引为什么用B+Tree？InnoDB的数据存储文件和MyISAM的有何不同？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14353022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14353022.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;这篇文章的题目，是我真实在面试过程中遇到的问题，某互联网众筹公司在考察面试者MySQL相关知识的第一个问题，我当时还是比较懵的，没想到这年轻人不讲武德，不按套路出牌，一般的问MySQL的相关知识的时候，不都是问索引优化以及索引失效等相关问题吗？怎么还出来了，存储文件的不同？哪怕考察个MVCC机制也行啊。所以这次我就好好总结总结这部分知识点。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要建立索引&quot;&gt;为什么需要建立索引&lt;/h3&gt;
&lt;p&gt;首先，我们都知道建立索引的目的是为了提高查询速度，那么为什么有了索引就能提高查询速度呢？&lt;br/&gt;我们来看一下，一个索引的示意图。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124234421621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果我有一个SQL语句是：&lt;code&gt;select * from Table where id = 15&lt;/code&gt; 那么在没有索引的情况下其实是会进行全表扫描的，就是挨个去找，直到找到id=15的这条记录，时间复杂度是O(n)；&lt;/p&gt;
&lt;p&gt;如果在有索引的情况下去进行查询呢。首先会根据id=15，在索引值里面进行二分查找，二分查找的效率是很高的，它的时间复杂度是O(logn)；&lt;/p&gt;
&lt;p&gt;这就是索引为什么能提高查询效率了，但是索引数据的量也是比较大的，所以一般并不是存储在内存中的，都是直接存储在磁盘中的，所以对磁盘中的文件内容进行读取，免不了要进行磁盘IO。&lt;/p&gt;
&lt;h3 id=&quot;mysql的索引为什么使用btree&quot;&gt;MySQL的索引为什么使用B+Tree&lt;/h3&gt;
&lt;p&gt;上面我们也说了，索引数据一般是存储在磁盘中的，但是计算数据都是要在内存中进行的，如果索引文件很大的话，并不能一次都加载进内存，所以在使用索引进行数据查找的时候是会进行多次磁盘IO，将索引数据分批的加载到内存中，&lt;strong&gt;&lt;code&gt;因此一个好的索引的数据结构，在得到正确的结果前提下，一定是磁盘IO次数最少的。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;hash类型&quot;&gt;Hash类型&lt;/h4&gt;
&lt;p&gt;目前MySQL其实是有两种索引数据类型可以选择的，一个是BTree（实际是B+Tree）、一个Hash。&lt;/p&gt;
&lt;p&gt;但是为什么在实际的使用过程中，基本上大部分都是选择BTree呢？&lt;/p&gt;
&lt;p&gt;因为如果使用Hash类型的索引，MySQL在创建索引的时候，会对索引数据进行一次Hash运算，这样根据Hash值就能快速的定位到磁盘指针了，就算数据量很大，也能快速精准的定位到数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;但是像&lt;code&gt;select * from Table where id &amp;gt; 15&lt;/code&gt;这种范围查询，Hash类型的索引就搞不定了，对这种范围查询，会直接全表扫描，另外Hash类型的索引也搞不定排序。&lt;/li&gt;
&lt;li&gt;还有就是虽然MySQL底层做了一系列的处理，但还是不能完全的保证，不产生Hash碰撞。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二叉树&quot;&gt;二叉树&lt;/h4&gt;
&lt;p&gt;那MySQL为什么没有二叉树作为它的索引数据结构呢？我们都知道，二叉树是通过二分查找来进行定位数据的，所以效果还是不错的，时间复杂度是O(logn)；&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130143654325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;二叉树&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;但是二叉树有个问题，就是在特殊情况下，它会退化成一根棍子，也就是一个单向链表。这个时候，它的时间复杂度就会退化成O(n)；&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130143553853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;二叉树退化成链表&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;所以当我们要查询id=50的记录时，其实和全表扫描是一样的了。所以因为存在这种情况，二叉树不适合作为索引的数据结构。&lt;/p&gt;
&lt;h4 id=&quot;平衡二叉树&quot;&gt;平衡二叉树&lt;/h4&gt;
&lt;p&gt;那么既然二叉树，在特殊情况下会退化成链表，那么平衡二叉树为什么不可以呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡二叉树的子节点高度差不能超过1&lt;/strong&gt;，像下图中的二叉树，关键字为15的节点，它的左子节点高度为0，右子节点高度为1，高度差不超过1，所以下面这棵树是一棵平衡二叉树。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130164300319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;平衡二叉树&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因为能保持平衡，所以它的查询时间复杂度为O(logN)，至于怎么保持平衡的，主要是做一些左旋，右旋等，具体保持平衡的细节不是本文主要内容，想了解的可自行搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用这个数据结构来做MySQL的索引会有 什么问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;磁盘IO过多&lt;/strong&gt;：在MySQL当中，一次IO操作只读取一个节点，那么一个节点若是最多就两个子节点的话，那么就只有这两个子节点的查询范围，所以要精确到具体的数据时，就需要进行多次读取，如果树非常深的话，那么将会进行大量的磁盘IO。性能自然下降了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间利用率低&lt;/strong&gt;：对于平衡二叉树来说，每个节点值保存一个关键字，一个数据区，两个子节点的指针。这样导致了，一次辛辛苦苦的IO操作就只加载这么点数据，实在是有点杀鸡用牛刀了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询效果不稳定&lt;/strong&gt;：如果在一个高度很深的平衡二叉树中，若是查询的数据正好是根节点，那么就会很快的查到，若是查询的数据正好是叶子节点，那么会进行多次磁盘IO后才能返回，响应时间有可能和根节点的不在一个数量级上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然说二叉树解决的平衡的问题，但是也带来了新的问题，那就是由于它本身树的深度的，会造成一系列的效率问题。&lt;/p&gt;
&lt;p&gt;那么为了解决平衡二叉树的这类问题，平衡多叉树（Balance Tree）就成为了更好的选择。&lt;/p&gt;
&lt;h4 id=&quot;平衡多叉树（balance-tree--b-tree）&quot;&gt;平衡多叉树（Balance Tree--B-Tree）&lt;/h4&gt;
&lt;p&gt;B-Tree的意思是平衡多叉树，一般B-Tree中的一个节点有多少个子节点，我们就称为多少阶的B-Tree。通常用m表示阶数，当m为2的时候，就是平衡二叉树。&lt;/p&gt;
&lt;p&gt;一棵B-Tree的每个节点上最多能有m-1个关键字，最少要存放&lt;code&gt;Math.ceil(m/2)-1&lt;/code&gt;个关键字，所有的叶子节点都在同一层。如下图就是一个4阶的B-Tree。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130183719774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;那么我们看一下B-Tree是如何进行查找数据的&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若是查询id=7的数据，先将关键字20的节点加载进内存，判断出7比20小；&lt;/li&gt;
&lt;li&gt;那么加载第一个子节点，若查询的数据等于12或17则直接返回，不等于就继续向下找，发现7小于12；&lt;/li&gt;
&lt;li&gt;那么继续加载第一个子节点中去，找到7之后，直接将7下面的data数据返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样整个操作其实进行了3次IO操作，但实际上一般的B-Tree每层都是有很多分支（通常都大于100）。&lt;/p&gt;
&lt;p&gt;MySQL为了能更好的利用磁盘的IO能力，将操作页的大小设置为了16K，即每个节点的大小为16K。如果每个节点中的关键字都是int类型的，那么就是4个字节，若数据区的大小为8个字节，节点指针再占4个字节，那么B-Tree的每个节点中可以保存的关键字个数为：&lt;code&gt;(16*1000) / (4+8+4)=1000&lt;/code&gt;，每个节点最多可存储1000个关键字，每一个节点最多可以有1001个分支节点。&lt;/p&gt;
&lt;p&gt;这样在查询索引数据的时候，一次磁盘IO操作可以将1000个关键字，读取到内存中进行计算，B-Tree的一次磁盘IO的操作，顶上平衡二叉数据的N次磁盘IO操作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;要注意的是&lt;/code&gt;&lt;/strong&gt;：&lt;strong&gt;B-Tree为了保证数据的平衡，会做一系列的操作，这个保持平衡的过程比较耗时间，所以在创建索引的时候，要选择合适的字段，并且不要过多的创建索引，创建索引过多的话，在更新数据的时候，更新索引的过程也比较耗时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有就是&lt;strong&gt;不要选择低区分度字段值作为索引，例如性别字段，总共就两个值，那么就有可能会造成B-Tree的深度过大，索引效率降低。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;btree&quot;&gt;B+Tree&lt;/h4&gt;
&lt;p&gt;B-Tree已经很好的解决平衡二叉树的问题了，并且也能保证查询效率了，那么为什么会有B+Tree呢？&lt;/p&gt;
&lt;p&gt;我们先来B+Tree是什么样子的。&lt;/p&gt;
&lt;p&gt;B+Tree是B-Tree的变种，B+Tree的每个节点关键字和m阶的公式关系和B-Tree的不一样了。&lt;/p&gt;
&lt;p&gt;首先每个节点的子节点数量和每个节点可存储的关键字比例是&lt;code&gt;1:1&lt;/code&gt;，其次就是查询数据的时候采用的是左闭合区间进行查询，还有就是分支节点中没有数据了只保存关键字和子节点指向，数据都存储在叶子节点。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210130232536273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么来看一下在B+Tree中是如何进行数据查询的。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现在要查询id=2的数据，那么会先将根节点取出，加载到内存中，发现&lt;code&gt;id=2&lt;/code&gt;存在于根节点，因为是左闭合区间存储数据，所以&lt;code&gt;id&amp;lt;=2&lt;/code&gt;的都在根节点的第一个子节点上；&lt;/li&gt;
&lt;li&gt;那么取出第一个子节点，加载到内存中，发现当前节点存在&lt;code&gt;id=2&lt;/code&gt;的关键字，并且已经到了叶子节点了，那么直接取出叶子节点中的数据返回。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;现在来看一下b-tree和btree的区别&quot;&gt;现在来看一下B-Tree和B+Tree的区别&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;B+Tree的查询采用的左闭合区间，这样能更好的支持了自增索引的查询效果，所以一般在创建主键的时候通常都是自增的。这一点和B-Tree是不一样的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B+Tree中的根节点和分支节点上是不保存数据的，关键字相关的数据只保存在叶子节点上，这样保证了查询效果的稳定，任何查询都要走到叶子节点才能获取数据。而B-Tree在分支节点中保存了数据，若是命中关键字则直接返回数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B+Tree的叶子节点是顺序排列的，并且相邻的两个叶子节点中具有顺序引用的关系，这样能更好的支持了范围查询。而B-Tree是没有这个顺序关系的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mysql的索引为什么选择了btree&quot;&gt;MySQL的索引为什么选择了B+Tree&lt;/h4&gt;
&lt;p&gt;经过上面的层层分析，现在我们可以总结一下MySQL为什么选择了B+Tree作为它索引的数据结构呢。&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;首先和平衡二叉树相比，B+Tree的深度更低，节点保存关键字更多，磁盘IO次数更少，查询计算效率更好。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;B+Tree的全局扫描能力更强，若是想根据索引数据对数据表进行全局扫描，B-Tree会将整棵树进行扫描，然后逐层遍历。而B+Tree呢，只需要遍历叶子节点即可，因为叶子节点之间存在顺序引用的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;B+Tree的磁盘IO读写能力更强，因为B+Tree的每个分支节点上只保存了关键字，这样每次磁盘IO在读写的时候，一页16K数据量可以存储更多的关键字了，每个节点上保存的关键字也比B-Tree更多了。这样B+Tree的一次磁盘IO加载的数据比B-Tree的多很多了。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;B+Tree数据结构中有天然的排序能力，比其他数据结构排序能力更强而且排序时，是通过分支节点来进行的，若是需要将分支节点加载到内存中排序，一次加载的数据更多。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;B+Tree的查询效果更稳定，因为所有的查询都是需要扫描到叶子节点才将数据返回的。效果只是稳定而不一定是最优，若是直接查询B-Tree的根节点数据，那么B-Tree只需要一次磁盘IO就可以直接将数据返回，反而是效果最优。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过以上几点的分析，MySQL最终选择了B+Tree作为了它的索引的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;inndb的数据存储文件和myisam的有何不同？&quot;&gt;InnDB的数据存储文件和MyISAM的有何不同？&lt;/h3&gt;
&lt;p&gt;上面总结了MySQL的索引的数据结构，这次就可以说第二个问题了，因为这个问题其实和MySQL的索引还是有一定的关系的。&lt;br/&gt;下面来看一下，先找到服务器桑MySQL存储数据的目录：&lt;br/&gt;登录MySQL，打开MySQL的命令行界面：输入&lt;code&gt;show variables like '%datadir%';&lt;/code&gt;，就能看到存储数据的目录了。&lt;br/&gt;我的服务器中MySQL的存储数据的目录是在：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;/var/lib/mysql/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入到这个目录里后，能看到所有数据库的目录，新建一个&lt;code&gt;study_test&lt;/code&gt;的数据库。&lt;br/&gt;然后就进入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;/var/lib/mysql/study_test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个目录下，目前就只有一个文件，这个文件是用来记录创建数据库时配置的字符集的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;-rw-r----- 1 mysql mysql     60 1月  31 10:28 db.opt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在新建两个表，第一个表的引擎类型选择InnoDB，第二个表的引擎类型选择MyISAM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;student_innodb&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `student_innodb` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `address` varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE COMMENT 'name索引'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='innodb引擎表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;student_myisam&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `student_myisam` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `address` varchar(100) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE COMMENT 'name索引'
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='myISAM引擎类型表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将两个表创建完成后，我们再进入到&lt;code&gt;/var/lib/mysql/study_test&lt;/code&gt;看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;-rw-r----- 1 mysql mysql     60 1月  31 10:28 db.opt
-rw-r----- 1 mysql mysql   8650 1月  31 10:41 student_innodb.frm
-rw-r----- 1 mysql mysql 114688 1月  31 10:41 student_innodb.ibd
-rw-r----- 1 mysql mysql   8650 1月  31 10:58 student_myisam.frm
-rw-r----- 1 mysql mysql      0 1月  31 10:58 student_myisam.MYD
-rw-r----- 1 mysql mysql   1024 1月  31 10:58 student_myisam.MYI
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过目录中的文件可看到创建表之后多了几个文件，这样也看出来了，InnoDB引擎类型的表和MyISAM引擎类型的表的文件差异。&lt;/p&gt;
&lt;p&gt;这几个文件每个都是有自己的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InnoDB引擎的表文件，一共有两个：
&lt;ul&gt;&lt;li&gt;*.frm 这类文件是表的定义文件。&lt;/li&gt;
&lt;li&gt;*.ibd 这类文件是数据和索引存储文件。表数据和索引聚集存储，通过索引能直接查询到数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MyIASM引擎的表文件，一共有三个：
&lt;ul&gt;&lt;li&gt;*.frm 这类文件是表的定义文件。&lt;/li&gt;
&lt;li&gt;*.MYD 这类文件是表数据文件，表中的所有数据都保存在此文件中。&lt;/li&gt;
&lt;li&gt;*.MYI 这类文件是表的索引文件，MyISAM存储引擎的索引数据单独存储。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;myisam数据存储引擎，索引与数据的存储结构&quot;&gt;MyISAM数据存储引擎，索引与数据的存储结构&lt;/h4&gt;
&lt;p&gt;MyISAM存储引擎在存储索引的时候，是将索引数据单独存储，并且索引的B+Tree最终指向的是数据存在的物理地址，而不是具体的数据。然后再根据物理地址去数据文件（*.MYD）中找到具体的数据。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210131143858766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;MyISAM索引存储结构&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;那么当存在多个索引时，多个索引都指向相同的物理地址。&lt;br/&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210131150215709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;MyISAM的多个索引&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;通过这个结构，我们可以看出来，MyISAM的存储引擎的索引都是同级别的，主键和非主键索引结构和查询方式完全一样。&lt;/p&gt;
&lt;h4 id=&quot;innodb数据存储引擎，索引与数据的存储结构&quot;&gt;InnoDB数据存储引擎，索引与数据的存储结构&lt;/h4&gt;
&lt;p&gt;首先InnoDB的索引分为聚簇索引和非聚簇索引，聚簇索引即保存关键字又保存数据，在B+Tree的每个分支节点上保存关键字，叶子节点上保存数据。&lt;br/&gt;“&lt;strong&gt;聚簇&lt;/strong&gt;”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储。一个表只能有一个聚簇索引，因为在一个表中数据的存放方式只有一种，一般是主键作为聚簇索引，如果没有主键，InnoDB会默认生成一个隐藏的列作为主键。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210131152457160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;InnoDB的聚簇索引&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;非聚簇索引，又称为二级索引，虽然也是在B+Tree的每个分支节点上保存关键字，但是叶子节点不是保存的数据，而是保存的主键值。通过二级索引去查询数据会先查询到数据对应的主键，然后再根据主键查询到具体的数据行。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210131154558732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_c8cae6,t_70&quot; alt=&quot;InnoDB非聚簇索引&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;由于非聚簇索引的设计结构，导致了，非聚簇索引在查询的时候要进行两次索引检索，这样设计的好处，可以保证了一旦发生数据迁移的时候，只需要更新主键索引即可，非聚簇索引并不用动，而且也规避了像MyISAM的索引那样存储物理地址，在数据迁移的时候的需要重新维护所有索引的问题。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这次把MySQL的索引的数据结构，以及文件存储结构，总结清楚了，后面在实际的工作过程中，设计索引的时候能够考虑的更全了，通过了解了索引的数据结构，也能让自己在实际写SQL的时候，能考虑到哪些情况走索引哪些不走索引了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL使用B+Tree作为索引的数据结构，因为B+Tree的深度低，节点保存的关键字多，磁盘IO次数少，从而保证了查询效率更高。&lt;/li&gt;
&lt;li&gt;B+Tree能够保证MySQL无论是主键索引还是非主键索引的查询效果都是稳定的，每次都要查询到叶子节点才能返回数据，B+Tree的叶子节点的深度是一样的，而且为了更好的支持自增主键，B+Tree的查询节点范围是左闭合右开放。&lt;/li&gt;
&lt;li&gt;MySQL的MyISAM存储引擎，&lt;strong&gt;表数据&lt;/strong&gt;和&lt;strong&gt;索引数据&lt;/strong&gt;是分别放到两个文件中进行存储的，由于它本身的索引的B+Tree的叶子节点指向的表数据所在的磁盘地址，而且索引没有主键和非主键之分，所以分开存储，能够更好的统一管理索引；&lt;/li&gt;
&lt;li&gt;MySQL的InnoDB存储引擎，&lt;strong&gt;表数据&lt;/strong&gt;和&lt;strong&gt;索引数据&lt;/strong&gt;是存储在一个文件中的，因为InnoDB的聚簇索引的叶子节点指向的具体的数据行，而且为了保证查询效果的稳定，InnoDB表中必须要有一个聚簇索引，二级索引在进行索引检索时，会先通过二级索引检索到数据的主键值，再根据主键去聚簇索引中检索到具体的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210114225254706.png&quot; alt=&quot;欢迎关注我，一起学习，一起进步!&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/jimoer/p/14353022.html#jump_10&quot;&gt;Jimoer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:28:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 这篇文章的题目，是我真实在面试过程中遇到的问题，某互联网众筹公司在考察面试者MySQL相关知识的第一个问题，我当时还是比较懵的，没想到这年轻人不讲武德，不按套路出牌，一般的问MySQL的相关知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14353022.html</dc:identifier>
</item>
<item>
<title>Node.js躬行记（6）——自制短链系统 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/14299313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/14299313.html</guid>
<description>&lt;p&gt;　　短链顾名思义是一种很短的地址，应用广泛，例如页面中有一张二维码图片，包含的是一个原始地址（如下所示），如果二维码中的链接需要修改，那么就得发代码替换掉。&lt;/p&gt;
&lt;p&gt;　　但如果二维码图包含的是一条短链，那么只要修改短链中的映射关系，就能不发代码了。当然了，前提是有一套短链系统维护着他们之间的关系，下图是列表和新增的界面。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202101/211606-20210119181116813-1631519638.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202101/211606-20210119181136872-2012823980.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前端界面的代码省略了，直接看短链用Node.js实现的后端代码。&lt;/p&gt;

&lt;p&gt;　　在 web_short_chain 表中，主键 id 是一个自增的整数，short 字段存储着短链中的 key，也就是 http://t.cn/4fYKXF 中的 4fYKXF 之类的数据，并且是全表唯一的，目前还未对其建索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `web_short_chain` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `short` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) COLLATE utf8mb4_bin &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;短链地址中的key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `url` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) COLLATE utf8mb4_bin &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;原始地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `ctime` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt;&lt;span&gt;,
  `mtime` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt;&lt;span&gt;,
  `status` &lt;/span&gt;&lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`),
  &lt;/span&gt;&lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `short_UNIQUE` (`short`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COLLATE&lt;span&gt;=&lt;/span&gt;utf8mb4_bin COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;短链存储&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　需要两步才能将原始地址映射成短链地址，第一步是使用 &lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/Murmur%E5%93%88%E5%B8%8C/22689658?fr=aladdin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MurmurHash&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（么么哈希）算法，由Austin Appleby在2008年发明，可将原始地址转换成一个哈希值，算法如下（最新版本 MurmurHash3）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MurmurHashV3(key, seed) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; key === &quot;string&quot;) key =&lt;span&gt; createBuffer(key);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  remainder &lt;/span&gt;= key.length &amp;amp; 3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key.length % 4&lt;/span&gt;
  bytes = key.length -&lt;span&gt; remainder;
  h1 &lt;/span&gt;=&lt;span&gt; seed;
  c1 &lt;/span&gt;= 0xcc9e2d51&lt;span&gt;;
  c2 &lt;/span&gt;= 0x1b873593&lt;span&gt;;
  i &lt;/span&gt;= 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; bytes) {
    k1 &lt;/span&gt;=&lt;span&gt;
      (key[i] &lt;/span&gt;&amp;amp; 0xff) |&lt;span&gt;
      ((key[&lt;/span&gt;++i] &amp;amp; 0xff) &amp;lt;&amp;lt; 8) |&lt;span&gt;
      ((key[&lt;/span&gt;++i] &amp;amp; 0xff) &amp;lt;&amp;lt; 16) |&lt;span&gt;
      ((key[&lt;/span&gt;++i] &amp;amp; 0xff) &amp;lt;&amp;lt; 24&lt;span&gt;);
    &lt;/span&gt;++&lt;span&gt;i;
    k1 &lt;/span&gt;= ((k1 &amp;amp; 0xffff) * c1 + ((((k1 &amp;gt;&amp;gt;&amp;gt; 16) * c1) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
    k1 &lt;/span&gt;= (k1 &amp;lt;&amp;lt; 15) | (k1 &amp;gt;&amp;gt;&amp;gt; 17&lt;span&gt;);
    k1 &lt;/span&gt;= ((k1 &amp;amp; 0xffff) * c2 + ((((k1 &amp;gt;&amp;gt;&amp;gt; 16) * c2) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
    h1 &lt;/span&gt;^=&lt;span&gt; k1;
    h1 &lt;/span&gt;= (h1 &amp;lt;&amp;lt; 13) | (h1 &amp;gt;&amp;gt;&amp;gt; 19&lt;span&gt;);
    h1b &lt;/span&gt;= ((h1 &amp;amp; 0xffff) * 5 + ((((h1 &amp;gt;&amp;gt;&amp;gt; 16) * 5) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
    h1 &lt;/span&gt;= (h1b &amp;amp; 0xffff) + 0x6b64 + ((((h1b &amp;gt;&amp;gt;&amp;gt; 16) + 0xe654) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16&lt;span&gt;);
  }
  k1 &lt;/span&gt;= 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (remainder) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
      k1 &lt;/span&gt;^= (key[i + 2] &amp;amp; 0xff) &amp;lt;&amp;lt; 16&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
      k1 &lt;/span&gt;^= (key[i + 1] &amp;amp; 0xff) &amp;lt;&amp;lt; 8&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
      k1 &lt;/span&gt;^= key[i] &amp;amp; 0xff&lt;span&gt;;
      k1 &lt;/span&gt;= ((k1 &amp;amp; 0xffff) * c1 + ((((k1 &amp;gt;&amp;gt;&amp;gt; 16) * c1) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
      k1 &lt;/span&gt;= (k1 &amp;lt;&amp;lt; 15) | (k1 &amp;gt;&amp;gt;&amp;gt; 17&lt;span&gt;);
      k1 &lt;/span&gt;= ((k1 &amp;amp; 0xffff) * c2 + ((((k1 &amp;gt;&amp;gt;&amp;gt; 16) * c2) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
      h1 &lt;/span&gt;^=&lt;span&gt; k1;
  }
  h1 &lt;/span&gt;^=&lt;span&gt; key.length;
  h1 &lt;/span&gt;^= h1 &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;;
  h1 &lt;/span&gt;= ((h1 &amp;amp; 0xffff) * 0x85ebca6b + ((((h1 &amp;gt;&amp;gt;&amp;gt; 16) * 0x85ebca6b) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
  h1 &lt;/span&gt;^= h1 &amp;gt;&amp;gt;&amp;gt; 13&lt;span&gt;;
  h1 &lt;/span&gt;= ((h1 &amp;amp; 0xffff) * 0xc2b2ae35 + ((((h1 &amp;gt;&amp;gt;&amp;gt; 16) * 0xc2b2ae35) &amp;amp; 0xffff) &amp;lt;&amp;lt; 16)) &amp;amp; 0xffffffff&lt;span&gt;;
  h1 &lt;/span&gt;^= h1 &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h1 &amp;gt;&amp;gt;&amp;gt; 0&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在得到一个整型的哈希值后，就得转换成字符，像上面短链中的字符是 6 个，也就是将10进制转换成62进制，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; string10to62(n) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n === 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;0&quot;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; digits = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &quot;&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;gt; 0&lt;span&gt;) {
    result &lt;/span&gt;= digits[n % digits.length] +&lt;span&gt; result;
    n &lt;/span&gt;= parseInt(n / digits.length, 10&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在将映射关系存入数据库时，可将其直接存入 &lt;span&gt;&lt;a href=&quot;http://www.redis.cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;redis&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 缓存中，采用哈希的数据结构，也就是将计算出的 short 作为 key，原始地址作为 value。&lt;/p&gt;
&lt;p&gt;　　假设每条关系所占空间是50字节，那么2000W条记录大概占用 1G左右，为了节省空间，缓存的超时时间会设为 7 天。&lt;/p&gt;
&lt;p&gt;　　每次在访问短链时，首先从缓存中读取，若有，就直接跳转；若无，则查询数据库，再将映射关系存入缓存中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取redis&lt;/span&gt;
let url = await services.common.redisShortChainGet(&lt;span&gt;short&lt;/span&gt;&lt;span&gt;);
ctx.status &lt;/span&gt;= 302;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;临时跳转&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(url) {
  ctx.redirect(getCompleteUrl(url, querystring));
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中不存在，则读取数据库&lt;/span&gt;
const data = await services.common.getOneShortChain({ &lt;span&gt;short&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;data) {
  ctx.body &lt;/span&gt;= &quot;短链不存在&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据库中读取的短链缓存起来&lt;/span&gt;
await services.common.redisShortChainSet(&lt;span&gt;short&lt;/span&gt;&lt;span&gt;, data.url);
ctx.redirect(getCompleteUrl(data.url, querystring));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　网上的一些文章在判断短链是否存在时，会采用&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5384697&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;布隆过滤器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，长度是 10 亿的布隆过滤器，也只需要 125MB左右的内存空间。&lt;/p&gt;
&lt;p&gt;　　布隆过滤器的缺点是有一定的误识别率和删除困难，例如下图中的 A 和 E 是存在于布隆过滤器中的，它们的映射位置都设成了 1，而 B 并不存在，但它的映射指向了两个是 1 的位置，从而就造成了误识别。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202101/211606-20210119181643965-1535505592.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 01 Feb 2021 00:27:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>短链顾名思义是一种很短的地址，应用广泛，例如页面中有一张二维码图片，包含的是一个原始地址（如下所示），如果二维码中的链接需要修改，那么就得发代码替换掉。 原始地址：https://github.com</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/14299313.html</dc:identifier>
</item>
<item>
<title>迟来的2020年终总结--做历史的见证者 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/14354985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/14354985.html</guid>
<description>&lt;p&gt;拖更的这些天我一直有在反思，这个总结我到底该怎么去描绘我过去这一年的经历，我似乎也没有做出一件惊天动地的大事，过去立下的的flag似乎也没有一一实现，我的很多思考和想法只是存在于大脑之中，而并没有去做一个内容上的输出和行动上的实施。一时间我不知道该如何动笔，思索良久，挤牙膏似的写下了一堆没有意义的符号。&lt;/p&gt;
&lt;p&gt;21号从成都回来以后就开始忙着完成毕业论文的事情，谁料想突如其来的疫情却紧跟其后，当听到新闻播报武汉疫情全面爆发之时，我那段时间心里确实是有一点恐慌的（毕竟当时我在汉口中转站呆了足足30分钟），家家户户大门紧闭，过年特有的那股子年味儿也因为疫情的步步逼近烟消云散，曾经喧闹的街道也因此变得冷清了许多，全国人民的焦点都聚集在武汉疫情防控上，每天的新闻头条几乎都是跟疫情防护进展相关的。一方有难八方支援，全国各地的医护人员都纷纷伸出援手去支援了武汉一把。我当然也不例外，时刻有关注疫情防控的进展，也是真心希望武汉能早日度过这次难关。对我而言，作为这次疫情的旁观者，不给国家添乱就是对疫情防控最大的支持了。&lt;/p&gt;
&lt;p&gt;因为疫情的影响，长达数个月的宅家生活就成为了不可避免的事情，其实现在想想，我还是挺感谢那段时光的，让我能够静下心来读了百余本书，有了更多的时间去沉淀自己，如果没有那段时间的思考和学习，也许我也不会开启进军华尔街的投资历程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212840492-1815556405.jpg&quot; alt=&quot;wechat_read&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读书，能让人学会思考，让人在不知不觉中变得安静下来。 我觉得没有比看书更令人惬意的事情了。&lt;br/&gt;书能带给你心灵的宁静、人生的智慧、精神的愉悦，这些是用多少钱都买不到的。&lt;/p&gt;
&lt;p&gt;麦家说，读书就是回家。毛姆说，读书就是给自己构建一座随身携带的小型避难所。它们拥有温暖而强劲的力量，能够长久不衰地体贴灵魂、拨动心弦，触碰到我们情感深处最柔软最深刻的部位。这种力量，并不会因时间流逝和年代更迭而减弱。&lt;/p&gt;
&lt;p&gt;读书，也是为了让我们遇见一个更好的自己。&lt;/p&gt;
&lt;p&gt;我始终相信我读过的所有书都不会白读，它总会在未来日子的某一个场合帮助我表现得更出色。你在读书上花的任何时间，都会在某一个时刻给你回报。&lt;/p&gt;
&lt;p&gt;因为在这个世界上，一个人的谈吐和气质，是要通过时间的淘漉和心灵的沉淀，才能获得的。那是将思想酿成学识的途径，也是将灵魂修炼成珍珠的过程。&lt;/p&gt;
&lt;p&gt;苏联作家帕乌斯托夫斯基在《金蔷薇》中写过，一个人对生活，对周边一切的诗意的理解，都是在童年时代所获得的伟大馈赠。如果在漫长而艰难的余生中，还能够守护好这个馈赠，那么他本质上就成了作家或诗人。&lt;/p&gt;
&lt;p&gt;目前处在人生低谷的我确实是不敢有太多的想法，更没有资格去给任何人建议，从结果来看，我这一年注定是非常失败的，亲戚朋友的冷嘲热讽，让我不知道如何去应对，每一次我都是想干脆自我封闭起来好了，但是这种自我封闭真的能解决问题吗？&lt;/p&gt;
&lt;p&gt;很多习惯和规律的打破都是源于我对生活的自甘堕落，到底还是不愿面对现实，不愿面对失败带来的惨痛代价，沉醉于不值一提的过往。很多时候你对生活充满希望，生活却往往狠狠的给了你一记耳光，让你大梦初醒。&lt;/p&gt;
&lt;p&gt;自己处在低谷的时候，面对他人的安慰和好意可能会感到刺痛，觉得别人不理解自己，让别人别来管自己，可如果在你拒绝的时候，有人真的担心你怎么办呢？是不是很不值得？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212840174-852223770.jpg&quot; alt=&quot;qq&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要践踏此前积累起来的努力和信誉，这样对不起努力至今的自己，做下这种事还感到开心的，就是放弃努力的败犬了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人的本质是创造者，你的使命就是创造出一件灵魂级的作品。可能你走着走着就忘记自己的天赋和使命，或者被某些外界的眼光所遮蔽，乃至于当我讲到这些伟大的创造者的故事时，你觉得与自己无关。这才是悲剧所在。&lt;/p&gt;
&lt;blockquote readability=&quot;96&quot;&gt;
&lt;p&gt;人类只要一适应幸福的状态，就又会开始觉得不幸福。我们所处的时代明明是人类有史以来最繁盛和平的时期，但伴随而来的，却是有史以来困扰最多人的各种心理问题。&lt;/p&gt;
&lt;p&gt;我们对人性悲观的原因既适用于他人，也适用于自己，这些原因都是对人性的总结和概述，但没有人比你更了解你自己。别人或许知道你的缺点，但是只有你才了解自己所有的罪恶、不足和缺陷，因此没有人比你更有理由鄙视你自己。当你拒绝做对自己有益的事情时，就像是在为你所有的缺点惩罚自己。相比之下，一条无害、天真而且没有自我意识的狗显然比你更值得善待。&lt;/p&gt;
&lt;p&gt;在危机当中，生活带来的不可避免的痛苦对追求幸福的人生目标来说就是一种讽刺。&lt;/p&gt;
&lt;p&gt;人生需要更深层的意义，这种意义的本质反复出现在过去的伟大故事当中，而那些故事往往讨论的都是在痛苦中成长，而不是追求快乐。&lt;/p&gt;
&lt;p&gt;每个人都应该为自己、社会和世界承担尽可能多的责任，坚持真理，修补缺憾，这样人们才可以减少毒害世界的苦难。&lt;/p&gt;
&lt;p&gt;人永远都在渴望着真实存在的英雄主义，而主动承担责任无异于决定过有意义的人生。&lt;/p&gt;
&lt;p&gt;你需要一边依赖已知和已掌握的事物，一边探索和学习新的东西。这样你既可以平衡对未知的恐惧，同时又能保持兴奋和投入的状态。如此一来，你便可以掌握新的，提升旧的，并且发现意义所在。&lt;/p&gt;
&lt;p&gt;意义的出现表明了你在正确的时间和地点，恰当地平衡了秩序与混乱，让一切都实现了最好的可能性。意义能够让不可避免的痛苦变得值得。&lt;/p&gt;
&lt;p&gt;只有当你熟悉了邪恶，尤其是内心的邪恶之后，才能够选择不去靠近它或者创造它。你甚至可以将自己的全部生命都投入其中，这将为你痛苦的生活和存在赋予极大的意义，也能让你获得救赎，用本能的骄傲和不加掩饰的自信取代羞耻和难堪，因为你已经学会了待己如助人。&lt;/p&gt;
&lt;p&gt;当一个人自我价值感很低或者拒绝为自己的人生负责时，便会选择与那些生活已经一团糟的人为友。&lt;/p&gt;
&lt;p&gt;过去是固定的，但未来有可能变得更好。这种好或许可以是你在一天之内花费最小努力所能达到的。当下永远都是有缺陷的，但是你前行的方向比你的起点更重要。&lt;/p&gt;
&lt;p&gt;也许快乐总是产生于改善的过程，而不是目标达成时那转瞬即逝的满足感。有希望就是快乐的，不论这希望产生于多么黑暗的深渊。&lt;/p&gt;
&lt;p&gt;生活的不顺或许不是因为生活本身，而是源自你的无知。&lt;/p&gt;
&lt;p&gt;生活很艰难，每个人都注定要遭受痛苦和伤害。有时候痛苦显然源自个人过失，比如选择性失明、决策不当或者心怀怨恨。&lt;/p&gt;
&lt;p&gt;不论是积极情绪还是消极情绪，最后都会以两种很有价值的形式表现出来：一种是满足感，它告诉人们过去的行为是好的；另一种是希望，它告诉人们令人愉悦的事物即将到来。&lt;/p&gt;
&lt;p&gt;尼采曾经说过，无论是精神、身体还是心智上的痛苦，都不一定会带来彻底否定人生价值、意义和愿望的虚无主义。这样的痛苦总是可以从不同角度去理解的。&lt;/p&gt;
&lt;p&gt;习惯了拥有的一切，看不见世事的变化和腐败的滋生，然后一切就会分崩离析。&lt;/p&gt;
&lt;p&gt;停止用谎言填充头脑，头脑就会变得更清晰；停止用不坦诚的行为扭曲生活，生活就会得到改善。随后你就能发现和纠正那些更微妙的错误。&lt;/p&gt;
&lt;p&gt;你需要放下当前的预设和执念，甚至需要牺牲你最在乎的东西，才能够实现自己的潜力，而不是始终停滞不前。&lt;/p&gt;
&lt;p&gt;人们能够战胜地震、洪水、贫穷和癌症，但是人性之恶却为这个世界的痛苦增加了全新的维度。&lt;/p&gt;
&lt;p&gt;邪恶会放大生活的灾难，大大增加我们用权宜之计来应对人生悲剧的动机。&lt;/p&gt;
&lt;p&gt;我由此得出了自己基本的道德结论。为善，集中注意力，修复你能修复的，不要因为自己的知识而傲慢。尽力保持谦和，因为强权主义的骄傲会在不包容、压迫、折磨和死亡中体现。意识到自己的不足，如怯弱、恶意、怨念和仇恨，在指责他人和试图修复世界之前先看清自己凶残的内心。也许错不在世界，而在你自己。你失败了，错过了目标，这是你犯的罪，而这一切都是你在为世间的邪恶添砖加瓦。最重要的是，永远不要撒谎。&lt;/p&gt;
&lt;p&gt;你绝不仅仅由那些你已知的部分构成，你也包括那些你只要愿意就可以获得的部分。你永远不应该为了当下的自己而牺牲未来你可能成为的样子。&lt;/p&gt;
&lt;p&gt;未来并非只有一个，从当下眺望未来时，未来会产生分支和变化，分散成好几种可能。无论什么样的未来都有通往它的道路，无论什么样的未来都有发生的可能，而当选择其中一条路前进时，身后的分支会全部消失，过去会变成单独的一条路，身后只有一条路，面前则是无限条。未来总是未知且不确定的，而将存在未来的无限分支变成一条能决定抵达何处，决定未来的力量。&lt;/p&gt;
&lt;p&gt;记忆的目的，不是要记住过去，而是要避免重蹈覆辙。&lt;/p&gt;
&lt;p&gt;人们认为自己会思考，但事实并非如此。大多数时候我们只是在进行自我批判，真正的思考如同真正的聆听一样少见。思考就是聆听自己，而这并不容易。要思考，你至少要同时分饰两个角色，而且还要允许他们有分歧。思考是两个或两个以上世界观之间的对话。&lt;/p&gt;
&lt;p&gt;也许你会发现，&lt;strong&gt;真正阻碍你前进的不是机会的匮乏，而是你对已拥有的一切傲慢地视而不见。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2020年是见证历史的一年，b站抓住了承办春晚的机会一举成功破圈，至此以后股价开启了翻N倍的行情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212839481-1316815501.png&quot; alt=&quot;bilibili&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;见证了疫情来临的天价口罩，万万没想到，口罩成了最紧俏的年货。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212839212-693593487.png&quot; alt=&quot;mask&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;见证了美股4次熔断，美股历史上总共就5次熔断，4次就发生在了同年3月，北美原油期货最低跌到-40美刀。这场状况，让见多了涨涨跌跌的股神巴菲特也直呼“我太年轻了”：自己活了89岁，也没见过这个场面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212838827-1962718155.png&quot; alt=&quot;breaker&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也见证了两个老头为了争夺美国大选的胜利使出浑身解数，共和党和民主党的矛盾进一步加剧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1100338/202101/1100338-20210131212837571-59167356.jpg&quot; alt=&quot;confront&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一年，我们每天都在见证历史，我们每天都在绝望中看到希望。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家总抱怨生活好难，但还是很期待明年钟声的响起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实对于更多的我们这些普通人来说，&lt;strong&gt;2020年的特殊之处不在于什么见证了历史，而在于被历史参与了人生。&lt;/strong&gt; 我们只是在洪流淹没个体的巨大浪潮声中，被历史的车轮裹挟着滚滚向前。&lt;/p&gt;
&lt;p&gt;对我们而言，2020是魔幻的一年，也是成长的一年。&lt;/p&gt;
&lt;p&gt;正是这不平凡的一年，造就了不平凡的我们。自己曾以为走不过的坎，还是跨过去了。&lt;/p&gt;
&lt;p&gt;新的一年，希望自己少做鸽子，多输出点内容，长期坚持做对的事情，坚持分享正确的理念和价值观。&lt;/p&gt;
&lt;p&gt;新的一年，希望自己能够多出去走一走，接触更多行业的大牛，希望自己能够把握更多行业的发展脉络，深入了解多行业产业链的历史进程和商业模式，做一个大国崛起的见证者。&lt;/p&gt;
&lt;p&gt;新的一年，希望大家能够平平安安，身体健健康康，快快乐乐每一天，莎士比亚曾经说过，凡是过去，皆为序曲。见过万般风景，就再也不会被生活打败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命的意义在于开拓而不是固守&lt;/strong&gt;，愿我们在成长中，都学会珍惜，趁一切还来得及。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:13:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>拖更的这些天我一直有在反思，这个总结我到底该怎么去描绘我过去这一年的经历，我似乎也没有做出一件惊天动地的大事，过去立下的的flag似乎也没有一一实现，我的很多思考和想法只是存在于大脑之中，而并没有去做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ECJTUACM-873284962/p/14354985.html</dc:identifier>
</item>
<item>
<title>职场 | 3天准备5天面试，跳槽完成 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14354982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14354982.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么跳槽？大饼吃多了太撑，想出去走走。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;01&lt;/p&gt;
&lt;p&gt;从想离职到提出离职，考虑了半个月，至于跳槽的原因，已经有知名互联网大佬给出过精辟解答，这里不重复说了；&lt;/p&gt;
&lt;p&gt;离职手续办理好之后，休息了几天时间，然后准备简历和选择公司，在当前这个阶段和就业环境下，心里确实有点犯毛躁，&lt;strong&gt;不过选好的河就大胆的去趟，这就是生活该有的样子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面聊聊整个跳槽过程和面试相关的问题，首先说下跳槽的整体情况，从离职到休息结束开始算起话，计划是两周内完成跳槽，当时的构想是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225731250-494332961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一周&lt;/strong&gt;：休息的时候考虑好自己想去的公司，周三准备好简历，周四看看JDK必问试题，周五给意向公司投去简历，周末了解一下将要面试公司的基础业务；如果第二周意向公司面试失败，就海投准备再面一周；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二周&lt;/strong&gt;：本周面的都是意向公司，大概面了11家公司，收到了三份offer，也都是自己中意的公司，这样跳槽就结束，最后就选择一家公司继续搬砖的节奏，第三周的计划完全落空；&lt;/p&gt;
&lt;p&gt;上面就是整个离职和跳槽的整体情况，然后来说说详细的面试过程，希望给准备跳槽的朋友一些参考。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;02&lt;/p&gt;
&lt;p&gt;离职后的第一周，主要是休息和面试的准备时间，然后就是浏览自己想要跳槽的公司，准备好简历，在周四周五两天给想去的公司投简历或者发邮件。虽然这段时间是打算休息的，但是准备的事情还是很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225742737-534773591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻找意向公司&lt;/strong&gt;：每个程序员都有自己中意的几家公司，可能是大公司或者一些崛起的小厂，找好自己想去的公司，并且熟悉相关业务和网上的风评，这样给面试的时候留个话题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备简历&lt;/strong&gt;：简历是最关键的，用来介绍自己的相关学历信息，技能展示，以及工作经历和经验，最后&lt;strong&gt;做好PDF格式&lt;/strong&gt;的简历，避免不同电脑下的简历打不开或者格式混乱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试题准备&lt;/strong&gt;：程序员跳槽的最大麻烦就是要准备面试题，这个没什么需要多说的，在工作4-5年这个阶段，基本不会被问框架的大问题，更侧重细节和难点问题的解决思路，所以这些不用过度准备，就看了JVM的执行周期和并发编程相关的内容，这两个方面问题说清楚基本不会再问JDK底层原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;审视自己&lt;/strong&gt;：这是个人认为最重要的一个过程，看清自己业务经验和编程技能，尤其是自己写的简历内容，要知道面试官的提问除了JDK底层原理，其他问题基本都是根据简历描述提问，所以换位思考一下，如果拿自己的简历提问，会问出哪方面的问题，然后自己再构思好如何回答，这样真到面试的时候不会出现紧张情绪，如果你对自己的认知足够清楚，不出意外的话自己构思的问题一定会被面试官问到。&lt;/p&gt;
&lt;p&gt;出于对自己的工作经验的把握，当时根据自己的简历内容构思好如下几个方面问题的回答思路：1.分布式使用的难点和细节；2.微服务模式下事务组件和原理；3.异步流程的注意事项；4.海量数据的管理思路和不同业务场景存储选型；5.开发中遇到的难点问题解决思路；6.JDK底层的JVM虚拟机执行周期；从后来的面试过程看，不管是阿里快手等大厂，还是面试的几家小厂，技术问题基本都是问这几个，当时看自己的简历时，感觉也就问这几个问题合适了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;投递简历&lt;/strong&gt;：个人的计划是先面自己中意的公司，选择在第一周最后给这批公司投去简历，周末接到的第一个面试机会居然是支付宝，几轮面试下来简直是难尽一言。建议对于收到面试邀请的公司要快速熟悉一下对方的业务和简单的情况，这是多数HR和管理者喜欢问的内容，可以留个不错的印象。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;03&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大致流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;休息和准备一周之后，就正式开始面试，每天至少面试3家，有家公司面试到晚上10点结束，那感觉简直是细品柠檬味酸透心，不用惊讶晚上面试的情况，真的是很常见的操作。现在阶段的面试，公司对入职者更加谨慎，所以基本不会直接发offer下来，选择是双向的，求职者拿多个offer要权衡一下，公司对多个面试者也需要斟酌一下再选择，基本都是面试结束后2-3天的考虑时间才会有最终结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225753352-1740574816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没折腾完这个流程，很难收到最终的offer邮件，的确很闹心不过这就是职场，如果有其他公司卡offer时间节点，也可以提前和自己中意的公司沟通，加快面试的流程，这里完全没必要怂或者觉得尴尬。自己当时因为拿到offer，支付宝的面试流程还没走完，就直接电话和当时的面试官沟通，提前面了第三轮，但是难度过大，直接凉凉了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术面试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现场面的首轮非常重要，通常是由架构师或者服务端主管来面，主要还是技术问题居多，给第一位面试官留下足够好的印象，会让你接下来的面试难度降低。首轮技术面基本都是围绕简历内容：了解之前工作经验业务模式和相关技术选型，以及相关业务难点解决方案，这是一大块；另一块就是自己在简历上罗列的技术栈，结合项目的具体应用场景；最后就是JDK底层会有2-3个问题，无非就是容器，并发，JVM的内容；基本面到这里没有问题，就差不多结束了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225802061-377103707.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有的公司直接给你二轮技术面的机会，有的公司可能会让你回去等通知，毕竟技术负责人的时间确实需要协调，不可能随时有空来面试，技术二面基本都是技术负责人来面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225811365-128025051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何猜测可能的提问，你需要判断该公司是技术型公司，还是业务型公司，不同的类型的业务其部门负责人的关注方向自然不一样，技术二面的问题通常不会很偏专业技术或者业务，问题回答的空间很大，需要思路清晰并且言之有理，这个真的需要自己理解，当然不排除遇到技术型负责人，例如上面说的支付宝三面，被问哑口无言，个人觉得二面一般考验人的思维和事物的认知水平，难度会比一面要简单一些。在二面中如果熟悉过该公司的业务，也可以提出来简单沟通一下作为加分项，薪水问题也会在这里做个初步交流，面试的最后可以问下该公司的技术栈选型，后续如果拿到offer，也可以提前熟悉一下，避免刚入职时手忙脚乱。&lt;/p&gt;
&lt;p&gt;基本两轮技术面决定这家公司能给你开多少薪水，之后就会把技术面试的结果转到HR部门，由HR部门做消息同步，如果技术面试HR重点沟通薪水问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人事部HR面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先必须要说明一点，并不是前面两轮面试通过，就能拿到合适自己的薪水和offer邮件，和HR的面试对薪水的影响很大，HR面基本没有什么需要提前考虑的，基本就是有套路性的闲聊，熟悉一下性格三观等，所以放松且自信的有说有笑就好，也可以多问一些公司的情况，这是一个双向对话，不是单方面被提问。&lt;/p&gt;
&lt;p&gt;最后HR会给到一个薪水线，然后通常给1-2天的考虑时间，如果对这个薪水不满意，这里也可以给出自己的薪水线，这取决你自己对整个面试过程的把握，如果面试过程顺利，该公司也对你表现出很大的好感，就自信大胆的沟通就好，不会因为薪水问题直接拒绝的，后续考虑两天才会有最终结果。&lt;/p&gt;
&lt;p&gt;最后就是考虑后明确薪水的事，如果薪水没有问题，邮件offer也就基本当天就发了。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;04&lt;/p&gt;
&lt;p&gt;对面试过程的问题做个简单总结，给大家一个参考，注意这里针对【4-5年】的工作经验，同时也受到工作经验的影响，不同阶段的面试问题肯定是不一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210131225821542-1887741071.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是公司考察一个求职者的基本思路，从面试过程就能清楚的感觉到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务能力&lt;/strong&gt;：通常是面试最开始的提问，难度不大，都是关于之前接触的业务和技术选型，业务难点的解决思路，再难度大点就是业务的演进过程和相关处理方案，尤其是数据体量膨胀和业务重构的问题，这种问题的范围取决简历上你自己是否做了描述，如果你描述过项目有这样的历程，自然很可能被提问到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术栈应用&lt;/strong&gt;：这个就不用多说，简历上陈列的技术栈就是重点提问的内容，不过这里重点提一下现在阶段求职基本都很关注分布式体系，这算是基础的能力，尤其是微服务的技术组件，对于技术细节的考核不会过于深，重点是在业务中的应用细节处理，例如缓存，异步，高并发，服务状态，分布事务等问题，大的方向没必要多说，细节问题说好2-3个基本就能看出来是用过还是学过，或者是背过面试题。&lt;strong&gt;解决过业务问题的坑坑洼洼的事情吐槽它几件出来，很容易和面试官达成共识&lt;/strong&gt;，例如分布式事务组件或者中间件崩溃等常见问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK底层&lt;/strong&gt;：一个开明的面试官通常不会过度为难你JDK底层原理，基本都会抛选择给你自己：聊聊你最熟悉的JDK模块，或者分析阅读过的JDK源码。工作4.5年不能一点JDK底层不了解吧，选最熟悉的两块内容就好，推荐并发和JVM两方面内容。JVM作为底层多少都要熟悉基本流程，并发作为开发中难度较高的模块也最体现Java水准线。这里可以从实际的底层原理去聊，也可以从实际场景去聊，例如处理JVM问题或者用并发解决什么场景的问题，这样应付JDK底层的问题都是可以的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合能力&lt;/strong&gt;：综合考察基本都是在部门负责人和HR的两次面试中，会通过各种自带套路的问题，例如：上次离职的原因，如何看待上家公司，对自己职场规划等。这些问题最重要的是&lt;strong&gt;思路清晰并且避免吐槽指错现象，任何事情都是相互的，认知要好，态度要坦然，职场上公司和员工都不容易&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;05&lt;/p&gt;
&lt;p&gt;整体上看现在的跳槽情况，面试机会确实比上两年少一些，可能也因为不在3月和9月，公司的选择也更加谨慎，求职周期拉长，让人觉得跳槽难度很大，另外薪水相比之前确实有下降，这是大环境导致的，技术需要日常多用心积累，业务能力也需要用心去思考，平时积累足够，跳槽之前理清做好计划，心态平和就好。&lt;/p&gt;
&lt;p&gt;最后说一句个人对于工作理解就是：积累专业技能，提高认知能力，做事情三思而后行，预则立，不预则废。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202008/1691717-20200811231321146-174169065.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:11:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>为什么跳槽？大饼吃多了太撑，想出去走走。 01 从想离职到提出离职，考虑了半个月，至于跳槽的原因，已经有知名互联网大佬给出过精辟解答，这里不重复说了； 离职手续办理好之后，休息了几天时间，然后准备简历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14354982.html</dc:identifier>
</item>
<item>
<title>P95、P99.9百分位数值——服务响应时间的重要衡量指标 - 老于`</title>
<link>http://www.cnblogs.com/hunternet/p/14354983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/14354983.html</guid>
<description>&lt;p&gt;前段时间，在对系统进行改版后，经常会有用户投诉说页面响应较慢，我们看了看监控数据，发现从接口响应时间的平均值来看在500ms左右，也算符合要求，不至于像用户说的那么慢，岁很费解，后来观察其它的一些指标发现确实是有问题，这个指标就是P95,P99.9，我们发现虽然平均响应时间并不高，但P95和P99.9却达到了2s以上，说明我们的接口确实存在慢查询。于是捞取了一些慢查询的请求日志终于发现问题。那么P95、P99又代表什么意思呢？&lt;/p&gt;
&lt;p&gt;通常，我们对服务响应时间的衡量指标有Min(最小响应时间)、Max(最大响应时间)、Avg(平均响应时间)等。&lt;/p&gt;
&lt;h3 id=&quot;1-平均值avg&quot;&gt;1 平均值Avg&lt;/h3&gt;
&lt;p&gt;其中比较常用的值就是平均值，例如平均耗时为100ms，表示服务器当前&lt;code&gt;请求的总耗时/请求总数量&lt;/code&gt;，通过该值，我们大体能知道服务运行情况。&lt;/p&gt;
&lt;p&gt;但是使用平均值来衡量响应时间有个非常大的问题，举个例子：众所周知，我和Jack马和tony马的财富加起来足以撼动整个亚洲，我和姚明的平均身高有两米多......&lt;/p&gt;
&lt;p&gt;平均值同样有这种问题,这个衡量指标的计算方式会把一些异常的值平均掉，进而会掩盖一些问题，我们只知道所有请求的平均响应时间是100ms，但是具体有多少个请求比100ms要大，又有多少个请求比100ms要小，大多少，是200ms，还是500ms，又或是1000ms，我们无从得知。&lt;/p&gt;
&lt;h3 id=&quot;2-百分位数值&quot;&gt;2 百分位数值&lt;/h3&gt;
&lt;p&gt;平均值并不能反映数据分布及极端异常值的问题，这时我们可以使用百分位数值。&lt;/p&gt;
&lt;p&gt;百分位数值是一个统计学中的术语。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用我们软件开发行业的例子通俗来讲就是，假设有100个请求，按照响应时间从小到大排列，位置为X的值，即为PX值。&lt;/p&gt;
&lt;p&gt;P1就是响应时间最小的请求，P10就是排名第十的请求，P100就是响应时间最长的请求。&lt;/p&gt;
&lt;p&gt;在真正使用过程中，最常用的主要有P50(中位数)、P95、P99。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P50:&lt;/strong&gt; 即中位数值。100个请求按照响应时间从小到大排列，位置为50的值，即为P50值。如果响应时间的P50值为200ms，代表我们有半数的用户响应耗时在200ms之内，有半数的用户响应耗时大于200ms。如果你觉得中位数值不够精确，那么可以使用P95和P99.9&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P95：&lt;/strong&gt;响应耗时从小到大排列，顺序处于95%位置的值即为P95值。&lt;/p&gt;
&lt;p&gt;还是采用上面那个例子，100个请求按照响应时间从小到大排列，位置为95的值，即为P95值。 我们假设该值为200ms，那这个值又表示什么意思呢？&lt;/p&gt;
&lt;p&gt;意思是说，我们对95%的用户的响应耗时在200ms之内，只有5%的用户的响应耗时大于200ms，据此，我们掌握了更精确的服务响应耗时信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P99.9：&lt;/strong&gt;许多大型的互联网公司会采用P99.9值，也就是99.9%用户耗时作为指标，意思就是1000个用户里面，999个用户的耗时上限，通过测量与优化该值，就可保证绝大多数用户的使用体验。 至于P99.99值，优化成本过高，而且服务响应由于网络波动、系统抖动等不能解决之情况，因此大多数时候都不考虑该指标。&lt;/p&gt;
&lt;p&gt;下图是我从我们系统中随便拉的两个接口的性能监控数据，我们可以看到第一个均值在40ms，P95在82.5ms，看似还可以，但是P99.9却是1743ms。&lt;/p&gt;
&lt;p&gt;而第二个接口均值在710ms，但是P95却是1592.7ms，这代表我们有将近5%的用户访问该接口的时间要大于1592.7ms。P99.9更是达到了2494.2ms。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/image-P99-P95.png&quot; alt=&quot;image-20210129075549027&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上两个接口如果单纯只看均值指标，并没有什么问题，但是P95和P99.9却反映了我们一些慢请求的情况。拿到这个指标数据，我们就知道我们的服务并非没有问题，就可以去优化这两个指标的值，以达到更好的用户体验。&lt;/p&gt;
&lt;h3 id=&quot;3-如何计算百分位数值&quot;&gt;3 如何计算百分位数值&lt;/h3&gt;
&lt;p&gt;平均值之所以会成为大多数人使用衡量指标，其原因主要在于他的计算非常简单。&lt;code&gt;请求的总耗时/请求总数量&lt;/code&gt;就可以得到平均值。而P值的计算则相对麻烦一些。&lt;/p&gt;
&lt;p&gt;按照传统的方式，计算P值需要将响应耗时从小到大排序，然后取得对应百分位之值。&lt;/p&gt;
&lt;p&gt;如果服务qps较低，例如：100/秒，我们计算这1s内的P值，就记录这100请求的耗时数据，然后排序，然后取得P分位值，并非难事。但如果我们要计算1h内的p值呢，就是要对360000的数据进行排序然后取得P分位值。而如果对于一些用户量更大的系统，例如：QPS 30万/秒，那么1h内的p值如果还是采用&lt;code&gt;记录+排序&lt;/code&gt;的方式，就是要对十个多亿的数据进行排序，可想而知需要消耗多么大的内存与计算资源。&lt;/p&gt;
&lt;p&gt;那么有没有简单的计算方式呢？&lt;/p&gt;
&lt;p&gt;可以采用分桶计算的方式，即一个耗时范围一个桶，该计算方式虽不是完全准确值，但精度非常高，误差较小。&lt;/p&gt;
&lt;p&gt;首先需要界定每个桶的跨度，可以采用等分形式，例如对于耗时统计需求，我们可以假定一个耗时上界，然后等分成N个区间，如下图，如果响应耗时在30ms则落在0-50ms的桶内，如果响应时间在80ms则落在50-100ms的桶内，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/P99%E7%9B%B4%E6%96%B9%E5%9B%BE.png&quot; alt=&quot;直方图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就避免了对全部数据进行排序，只需要根据各个桶中的数据数量，即可计算出95%位置位于哪个桶，例如需要计算95线时，就从最大的桶开始剔除，当数量超过5%的时候，那个桶的值就是95线。然后在桶的内部采用插值方法，也可以通过桶内平均的方式来计算出一个相对精确的P95值。&lt;/p&gt;
&lt;p&gt;此外，考虑到数据分布特点，服务耗时异常数据应该只是少数，但是异常值跨度可能很大，大部分耗时数据均靠近正常值，如果采用桶等分的形式，可能会导致大量数据堆积在一个桶内中，又如何解决这个问题？&lt;/p&gt;
&lt;p&gt;其实可以采用非等分的跨度划分方式，例如采用&lt;strong&gt;指数&lt;/strong&gt;形式划分，耗时越低的区间，跨度越小，精度约高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/image-20210129085545814.png&quot; alt=&quot;image-20210129085545814&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外也可以采用美团点评的实时监控系统cat的桶跨度划分方式，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static int computeDuration(int duration) {
        if (duration &amp;lt; 1) {
            return 1;
        } else if (duration &amp;lt; 20) {
            return duration;
        } else if (duration &amp;lt; 200) {
            return duration - duration % 5;
        } else if (duration &amp;lt; 500) {
            return duration - duration % 20;
        } else if (duration &amp;lt; 2000) {
            return duration - duration % 50;
        } else if (duration &amp;lt; 20000) {
            return duration - duration % 500;
        } else if (duration &amp;lt; 1000000) {
            return duration - duration % 10000;
        } else {
            int dk = 524288;

            if (duration &amp;gt; 3600 * 1000) {
                dk = 3600 * 1000;
            } else {
                while (dk &amp;lt; duration) {
                    dk &amp;lt;&amp;lt;= 1;
                }
            }
            return dk;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即：小于20ms的时候1ms一个桶，大于20ms小于200ms的时候5ms一个桶，大于200ms小于500ms的时候20ms一个桶，以此类推！而桶的值也可以作为百分位数的近似值，而无需进行排序计算，这个时候约耗时越小的时候，精度越准确！&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;百分位数值在互联网系统中有很大的意义。&lt;strong&gt;通过对百分位数值的监控与优化，我们可以将更多的用户纳入我们的监控体系中，让我们的服务能够对绝对大多数的用户提供更好的体验！&lt;/strong&gt;在一些错误率、异常率上面我们也可以使用百分位数来进行系统可用性是否达到要求，甚至在一些新的产品特性或者AB测试上也可以用来统计分析用户对其的反响，以此来衡量该特性是否真正对用户有帮助......&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:11:00 +0000</pubDate>
<dc:creator>老于`</dc:creator>
<og:description>前段时间，在对系统进行改版后，经常会有用户投诉说页面响应较慢，我们看了看监控数据，发现从接口响应时间的平均值来看在500ms左右，也算符合要求，不至于像用户说的那么慢，岁很费解，后来观察其它的一些指标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/14354983.html</dc:identifier>
</item>
<item>
<title>为什么要学设计模式：本质、价值与收益 - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/why-learn-design-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/why-learn-design-pattern.html</guid>
<description>&lt;h2 id=&quot;设计模式的本质&quot;&gt;设计模式的本质&lt;/h2&gt;
&lt;p&gt;说起设计模式，就不得不说起重构。在 2017 年，当我还是一个工作 3 年的菜鸟，我重构了公司一个十几年的老系统，弄得心力交瘁。为了能深刻吸取这次重构的教训，我写了一篇文章记录这次重构的心得：&lt;a href=&quot;https://shuyi.tech/archives/some-experienc-in-system-refactor&quot; target=&quot;_blank&quot;&gt;浅谈重构中踩过的坑 - 陈树义的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;时隔三年，我再次刷了一遍设计模式相关知识，这次我对设计模式有了更深刻的认识。所以今天我们就来聊聊：设计模式的本质是什么？它的存在有什么价值？学了设计模式有什么好处？&lt;/p&gt;
&lt;p&gt;在这篇文章中，我对设计模式的总结是：&lt;strong&gt;设计模式用于承载复杂的业务逻辑，使写出的代码简洁、易扩展。&lt;/strong&gt; 简单地说，你需要去了解业务中哪些是变化的，哪些是不变的。这些变化的东西就是复杂的业务逻辑，你需要思考如何用一种合适的设计模式去承载它，使得当它发生变化的时候，能具有很好的扩展性。这时候如果你学过设计模式，对每种设计模式的使用场景都谙熟于心，那你做起来会更加得心应手。&lt;/p&gt;
&lt;p&gt;有些人说，我看有些人也没学过设计模式，但他们代码也写得挺好啊。&lt;strong&gt;这里我想表达我的第二个观点：抽象思维才是设计模式的内核。&lt;/strong&gt; 有些人接触的项目多了，其在项目中不知不觉地就用到了一些设计模式。这些人一般都具有一个共同点：抽象总结能力强。他们接触到了东西多了，会不断思考他们的共同之处，然后试图总结出经验。如果你具有这种抽象的思维，那即使你没看过设计模式，你也能写出类似于设计模式的代码。甚至到最后，你也可以设计出一种独特的设计模式。到时候你可能就成为了自创门派的「一代宗师」了。&lt;/p&gt;
&lt;h2 id=&quot;设计模式的价值&quot;&gt;设计模式的价值&lt;/h2&gt;
&lt;p&gt;对于设计模式，不少人也有很多见解。有的人觉得设计模式名过其实，实际编程中远远没有那么重要。在我看来，设计模式存在即合理，至少它有下面三点实在的意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式是经验沉淀，便于后来者快速学习。&lt;/strong&gt; 人类之所以能一代更比一代强，靠的就是用文字符号实现经验传承。而在编程领域，我们的设计模式其实就是前人在实战中的经验总结，他们将这些经验归纳出来成为设计模式。&lt;/p&gt;
&lt;p&gt;对于经验不是很多的人来说，学习设计模式可以让他们有个初步的印象，等到他们有对应的项目经验时，他们可以更好地应用上。而对于项目经验丰富的人来说，设计模式可以丰富他们的项目场景，进一步提高他们对于复杂场景的掌控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式可以方便交流。&lt;/strong&gt; 有些同学会觉得一些设计模式自己都用过，只不过先辈们给它起了个名字而已，没什么大不了的。但不知道这位同学是否有思考过：为什么要给各个设计模式起一个名字？&lt;/p&gt;
&lt;p&gt;我们的知道有显性知识和隐形知识之分。显性知识就是大家一说，我们都能听得懂的。例如锤子可以用来钉钉子，例如搜索引擎可以用来搜索知识。而隐形知识则是指那些我们做事的经验，我们很难描述出来的东西。&lt;/p&gt;
&lt;p&gt;我们这里说的设计模式，落地下去其实就是对应的代码结构。但我们如何将这种实战中的经验描述出来呢？一个最直接的方法是：我每次跟别人交流的时候，我都说：你这个创建一个接口，然后这个类继承这个接口，然后 bla bla …… 可能你说了半天，人家也还没听懂。即使听懂了，你下次还是得叽里呱啦说半天，别人才能听得懂。&lt;/p&gt;
&lt;p&gt;怎样才能让别人一下子领会到我们的意思呢？很简单，就是给这种代码结构起个名字嘛！这也才有了工厂方法、策略模式、模板模式这些名词。当你跟别人一说这个名字，别人就知道是怎么回事，这不就大大提高了沟通效率嘛！&lt;/p&gt;
&lt;p&gt;生活中其实也有很多类似的例子。我们为什么会有很多思考模型，例如：SMART 模型、PDCA 模型？本质上就是用来帮助记忆，以及便于沟通的。&lt;/p&gt;
&lt;p&gt;想想看「搜索引擎」这个词，在 50 年前还不存在，那为什么有搜索引擎这个词呢？不就是为了便于交流，让别人知道是怎么回事吗？假设没有「搜索引擎」这个词，我们要描述百度，我们得怎么描述？我们试一下：就是你打开一个网页，输入词语，然后会挑出来一大堆相关的信息。这样还是挺麻烦的吧。&lt;/p&gt;
&lt;p&gt;想想「五花肉」这个词，可能在古代还真没这个词。那我们要怎么形容？古代人说：就是那种一点肥、一点瘦的猪肉。现代人三个字搞定：五花肉！多高效啊！&lt;/p&gt;

&lt;h2 id=&quot;学设计模式的好处&quot;&gt;学设计模式的好处&lt;/h2&gt;
&lt;p&gt;聊完了设计模式的本质和意义，最后我们聊聊设计模式的好处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高系统设计能力，代码更简洁，更易于扩展。&lt;/strong&gt; 在互联网公司干过的都知道，研发流程里最确定的东西就是变化本身。需求是不可能一成不变的，唯一不变的就是需求会一直变。这就对研发人员提出了更高的要求，需要在系统设计的时候考虑到后续的扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式本质上就是对变化的封装，用结构化的代码结构去承载变化的需求。&lt;/strong&gt; 当你明白这一点后，你需要做的就是去分析出系统中变化的部分，之后采用合适的设计模式（代码结构）去实现。只要变化的部分拆解得好，那你就有足够强大的结构去应付变化的需求。&lt;/p&gt;
&lt;p&gt;在这一个层次上，考验的其实是你对业务的理解，还有你掌握的设计模式的数量。这些将直接决定你是否能抽离出变化的部分，而抽离出变化的部分之后，你能不能找到合理的设计模式去承载。如果找不到，那你的「抽象思维」层次决定了你是否能自我创造一种设计模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式可以帮助阅读源码、写框架。&lt;/strong&gt; 在我们现在使用的不少框架中，都使用了很多的设计模式。越是底层的系统，他们就需要越抽象，他们使用到的设计模式就越多。例如：Spring 框架中使用到的设计模式就多达十几种，有工厂模式、代理模式、模板模式等等。&lt;/p&gt;
&lt;p&gt;当你理解了这些设计模式之后，你再去阅读源码，你就能够更快速地领会框架作者的意思。否则你看源码只会像看天书一样，完全看不懂，还吐槽这代码怎么这么垃圾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式有利于你面试。&lt;/strong&gt; 这点可以说是挺功利的一点，但也确实是最实在的一点。工作三年以上的工程师，至少要会学习一些设计模式。只有掌握了合理的设计模式，你写的功能才能更易于扩展。这也是我们这些工作多年的老码农，和刚毕业的小年轻的区别。&lt;/p&gt;
&lt;p&gt;如果你工作了好几年，写代码的时候还是从头写到尾短平快，不考虑一点扩展性，那么你可能真的很容易被替代。现今的面试中，也越来越考察面试者的代码编写能力了。掌握设计模式的思维方式，可以帮助你在面试中拿到更多的筹码、赢得更高的薪资。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;设计模式本质上是用于承载变化的业务逻辑，使写出的代码简洁、易扩展。它们就像武功中的招式，但具体的招式并不是目的，抽象思维才是设计模式的内核。掌握了抽象的思维，你也能设计出属于自己的模式。&lt;/p&gt;
&lt;p&gt;设计模式是前人经验的总结，便于后来者快速学习。设计模式与菜名、标签一样，是对代码结构的一种描述，便于我们交流。掌握了设计模式，能够让我们提高系统设计能力，使系统更易于扩展。同时也能让我们读源码、写框架时事半功倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/16108678607363.jpg&quot; alt=&quot;-w856&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Mon, 01 Feb 2021 00:05:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>聊聊我对设计模式的理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanshuyi/p/why-learn-design-pattern.html</dc:identifier>
</item>
<item>
<title>一位大龄程序员所经历的面试的历炼和思考 - 琴水玉</title>
<link>http://www.cnblogs.com/lovesqcc/p/14354921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesqcc/p/14354921.html</guid>
<description>[unable to retrieve full-text content]从每一段经历中学习，在每一件事情中修行。善于从失败中学习。 引子 我今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。 在多年的读书、学习和思考中，我的价值观、人生观和世界观也逐步塑造成型。我意识到自己的志趣在于做教育文化方面，因此在半冲动之下，8</description>
<pubDate>Sun, 31 Jan 2021 19:34:00 +0000</pubDate>
<dc:creator>琴水玉</dc:creator>
<dc:identifier>https://www.cnblogs.com/lovesqcc/p/14354921.html</dc:identifier>
</item>
</channel>
</rss>