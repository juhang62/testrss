<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MQ疑难杂症小记 - 开心的鱼a1</title>
<link>http://www.cnblogs.com/dw-haung/p/10393338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dw-haung/p/10393338.html</guid>
<description>&lt;p&gt;&lt;span&gt;什么业务场景，这个业务场景有个什么技术挑战，如果不用&lt;/span&gt;MQ&lt;span&gt;可能会很麻烦，但是你现在用了&lt;/span&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;span&gt;之后带给了你很多的好处。消息队列的常见使用场景，其实场景有很多，但是比较核心的有&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个：&lt;strong&gt;解耦、异步、削峰。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;解耦：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A&lt;span&gt;系统发送个数据到&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统，接口调用发送，那如果&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;系统也要这个数据呢？那如果&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;系统现在不需要了呢？现在&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;系统又要发送第二种数据了呢？而且&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;系统要时时刻刻考虑&lt;/span&gt;&lt;span&gt;BCDE&lt;/span&gt;&lt;span&gt;四个系统如果挂了咋办？要不要重发？我要不要把消息存起来？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用&lt;/span&gt;MQ&lt;span&gt;给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个&lt;/span&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;span&gt;去进行系统的解耦。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;异步：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A&lt;span&gt;系统接收一个请求，需要在自己本地写库，还需要在&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统写库，自己本地写库要&lt;/span&gt;&lt;span&gt;30ms&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统分别写库要&lt;/span&gt;&lt;span&gt;300ms&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;450ms&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;200ms&lt;/span&gt;&lt;span&gt;。最终请求总延时是&lt;/span&gt;&lt;span&gt;30 + 300 + 450 + 200 = 980ms&lt;/span&gt;&lt;span&gt;，接近&lt;/span&gt;&lt;span&gt;1s&lt;/span&gt;&lt;span&gt;，异步后，&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统分别写库的时间，&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;系统就不再考虑了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;削峰：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;每天&lt;/span&gt;0&lt;span&gt;点到&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;点，&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;系统风平浪静，每秒并发请求数量就&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;个。结果每次一到&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;&lt;span&gt;~23&lt;/span&gt;&lt;span&gt;点，每秒并发请求数量突然会暴增到&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;万条。但是系统最大的处理能力就只能是每秒钟处理&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;个请求啊。怎么办？需要我们进行流量的削峰，让系统可以平缓的处理突增的请求。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;消息队列有什么优点和缺点&lt;/span&gt;?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。&lt;/p&gt;
&lt;p&gt;缺点呢？ &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;系统可用性降低&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;系统引入的外部依赖越多，越容易挂掉，本来你就是&lt;/span&gt;A&lt;span&gt;系统调用&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统的接口就好了，&lt;/span&gt;&lt;span&gt;ABCD&lt;/span&gt;&lt;span&gt;四个系统好好的，没啥问题，你偏加个&lt;/span&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;span&gt;进来，万一&lt;/span&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;span&gt;挂了怎么办？&lt;/span&gt;&lt;span&gt;MQ&lt;/span&gt;&lt;span&gt;挂了，整套系统崩溃了，业务也就停顿了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;系统复杂性提高&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;硬生生加个&lt;/span&gt;MQ&lt;span&gt;进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一致性问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A&lt;span&gt;系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;三个系统那里，&lt;/span&gt;&lt;span&gt;BD&lt;/span&gt;&lt;span&gt;两个系统写库成功了，结果&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;系统写库失败了，你这数据就不一致了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉。 &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;常见消息队列的比较&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1403971/201902/1403971-20190217225208894-365736742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;消息的重复&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;第一类原因&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;消息发送端应用的消息重复发送&lt;/span&gt;,&lt;span&gt;有以下几种情况。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息发送端发送消息给消息中间件&lt;/span&gt;,&lt;span&gt;消息中间件收到消息并成功存储&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而这时消息中间件出现了问题&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;导致应用端没有收到消息发送成功的返回因而进行重试产生了重复。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息中间件因为负载高响应变慢&lt;/span&gt;,&lt;span&gt;成功把消息存储到消息存储中后&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;返回“成功”这个结果时超时。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息中间件将消息成功写入消息存储&lt;/span&gt;,&lt;span&gt;在返回结果时网络出现问题&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;导致应用发送端重试&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而重试时网络恢复&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;由此导致重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到&lt;/span&gt;,&lt;span&gt;通过消息发送端产生消息重复的主要原因是消息成功进入消息存储后&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;因为各种原因使得消息发送端没有收到“成功”的返回结果&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;并且又有重试机制&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;因而导致重复。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;第二类原因&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;消息到达了消息存储&lt;/span&gt;,&lt;span&gt;由消息中间件进行向外的投递时产生重复，有以下几种情况。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息被投递到消息接收者应用进行处理&lt;/span&gt;,&lt;span&gt;处理完毕后应用出问题了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;消息中间件不知道消息处理结果&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会再次投递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息被投递到消息接收者应用进行处理&lt;/span&gt;,&lt;span&gt;处理完毕后网络出现问题了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;消息中间件没有收到消息处理结果&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会再次投递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息被投递到消息接收者应用进行处理&lt;/span&gt;,&lt;span&gt;处理时间比较长&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;消息中间件因为消息超时会再次投递。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息被投递到消息接收者应用进行处理&lt;/span&gt;,&lt;span&gt;处理完毕后消息中间件出问题了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;没能收到消息结果并处理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会再次投递&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;l &lt;span&gt;消息被投递到消息接收者应用进行处理&lt;/span&gt;,&lt;span&gt;处理完毕后消息中间件收到结果但是遇到消息存储故障&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;没能更新投递状态&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会再次投递。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到&lt;/span&gt;,&lt;span&gt;在投递过程中产生的消息重复接收主要是因为消息接收者成功处理完消息后&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;消息中间件不能及时更新投递状态造成的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;如何解决重复消费&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;那么有什么办法可以解决呢&lt;/span&gt;?&lt;span&gt;主要是要求消息接收者来处理这种重复的情况&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;也就是要求消息接收者的消息处理是幂等操作。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;什么是幂等性？&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;对于消息接收端的情况&lt;/span&gt;,&lt;span&gt;幂等的含义是采用同样的输入多次调用处理函数&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;得到同样的结果。例如，一个&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;update stat_table set count= 10 where id =1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个操作多次执行&lt;/span&gt;,id&lt;span&gt;等于&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;的记录中的&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;&lt;span&gt;字段的值都为&lt;/span&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span&gt;这个操作就是幂等的&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;我们不用担心这个操作被重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再来看另外一个&lt;/span&gt;SQL&lt;span&gt;操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;update stat_table set count= count +1 where id= 1;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的&lt;/span&gt;SQL&lt;span&gt;操作就不是幂等的&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;一旦重复&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;结果就会产生变化。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;常见办法&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;因此应对消息重复的办法是&lt;/span&gt;,&lt;span&gt;使消息接收端的处理是一个幂等操作。这样的做法降低了消息中间件的整体复杂性&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不过也给使用消息中间件的消息接收端应用带来了一定的限制和门槛。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;1. MVCC：&lt;/h5&gt;
&lt;p&gt;多版本并发控制，乐观锁的一种实现，在生产者发送消息时进行数据更新时需要带上数据的版本号，消费者去更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。例如博客点赞次数自动+1的接口：&lt;/p&gt;
&lt;p&gt;public boolean addCount(Long id, Long version);&lt;/p&gt;
&lt;p&gt;update blogTable set count= count+1,version=version+1 where id=321 and version=123&lt;/p&gt;
&lt;p&gt;每一个version只有一次执行成功的机会，一旦失败了生产者必须重新获取数据的最新版本号再次发起更新。&lt;/p&gt;
&lt;h5&gt;2. 去重表：&lt;/h5&gt;
&lt;p&gt;利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求不再重复处理了（利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。）&lt;/p&gt;
&lt;p&gt;以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;消息的可靠性传输&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;ActiveMQ&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要保证消息的可靠性，除了消息的持久化，还包括两个方面，一是生产者发送的消息可以被&lt;/span&gt;ActiveMQ&lt;span&gt;收到，二是消费者收到了&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;span&gt;发送的消息。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;生产者&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;非持久化又不在事务中的消息，可能会有消息的丢失。为保证消息可以被&lt;/span&gt;ActiveMQ&lt;span&gt;收到，我们应该采用事务消息或持久化消息。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;消费者&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;对消息的确认有&lt;/span&gt;4&lt;span&gt;种机制&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1、 AUTO_ACKNOWLEDGE = 1    &lt;span&gt;自动确认&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2、 CLIENT_ACKNOWLEDGE = 2    &lt;span&gt;客户端手动确认&lt;/span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3、 DUPS_OK_ACKNOWLEDGE = 3    &lt;span&gt;自动批量确认&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;4、 SESSION_TRANSACTED = 0    &lt;span&gt;事务提交并确认&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ACK_MODE&lt;span&gt;描述了&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;确认消息的方式&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;时机&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;比如当消息被&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;接收之后&lt;/span&gt;&lt;span&gt;,Consumer&lt;/span&gt;&lt;span&gt;将在何时确认消息。所以&lt;/span&gt;&lt;span&gt;ack_mode&lt;/span&gt;&lt;span&gt;描述的不是&lt;/span&gt;&lt;span&gt;producer&lt;/span&gt;&lt;span&gt;于&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;之间的关系，而是&lt;/span&gt;&lt;span&gt;customer&lt;/span&gt;&lt;span&gt;于&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;broker&lt;span&gt;而言，只有接收到&lt;/span&gt;&lt;span&gt;ACK&lt;/span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;才会认为消息被正确的接收或者处理成功了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;ACK&lt;/span&gt;&lt;span&gt;，可以在&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;之间建立一种简单的“担保”机制&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;em&gt;AUTO_ACKNOWLEDGE  &lt;/em&gt;&lt;/h6&gt;
&lt;p&gt;自动确认&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;“同步”&lt;/span&gt;&lt;span&gt;(receive)&lt;/span&gt;&lt;span&gt;方法返回&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;给消息时会立即确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步&lt;/span&gt;&lt;span&gt;&quot;(messageListener)&lt;/span&gt;&lt;span&gt;方式中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;将会首先调用&lt;/span&gt;&lt;span&gt;listener.onMessage(message)&lt;/span&gt;&lt;span&gt;，如果&lt;/span&gt;&lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;方法正常结束&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;消息将会正常确认。如果&lt;/span&gt;&lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;方法异常，将导致消费者要求&lt;/span&gt;&lt;span&gt;ActiveMQ&lt;/span&gt;&lt;span&gt;重发消息。&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;em&gt;CLIENT_ACKNOWLEDGE :&lt;/em&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;客户端手动确认，这就意味着&lt;/span&gt;AcitveMQ&lt;span&gt;将不会“自作主张”的为你&lt;/span&gt;&lt;span&gt;ACK&lt;/span&gt;&lt;span&gt;任何消息，开发者需要自己择机确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以在当前消息处理成功之后，立即调用&lt;/span&gt;message.acknowledge()&lt;span&gt;方法来&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;逐个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确认消息，这样可以尽可能的减少因网络故障而导致消息重发的个数；当然也可以处理多条消息之后，间歇性的调用&lt;/span&gt;&lt;span&gt;acknowledge&lt;/span&gt;&lt;span&gt;方法来一次确认多条消息，减少&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;的次数来提升&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;的效率，不过需要自行权衡。&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;em&gt;DUPS_OK_ACKNOWLEDGE&lt;/em&gt;&lt;/h6&gt;
&lt;p&gt;类似于AUTO_ACK&lt;span&gt;确认机制，为&lt;/span&gt;自动&lt;span&gt;批量确认而生，而且具有&lt;/span&gt;“&lt;span&gt;延迟&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;确认的特点&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;ActiveMQ&lt;span&gt;会根据内部算法，在收到一定数量的消息自动进行确认。在&lt;/span&gt;&lt;span&gt;此模式下，可能会出现重复消息&lt;/span&gt;，&lt;span&gt;什么时候&lt;/span&gt;？&lt;span&gt;当&lt;/span&gt;consumer&lt;span&gt;故障重启后，那些尚未&lt;/span&gt;&lt;span&gt;ACK&lt;/span&gt;&lt;span&gt;的消息会重新发送过来。&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;em&gt;SESSION_TRANSACTED&lt;/em&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;当&lt;/span&gt;session&lt;span&gt;使用事务时，就是使用此模式。当决定事务中的消息可以确认时，必须调用&lt;/span&gt;&lt;span&gt;session.commit()&lt;/span&gt;&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;方法将会导致当前&lt;/span&gt;&lt;span&gt;session&lt;/span&gt;&lt;span&gt;的事务中所有消息立即被确认&lt;/span&gt;。&lt;span&gt;在事务开始之后的任何时机调用&lt;/span&gt;rollback()，&lt;span&gt;意味着当前事务的结束，事务中所有的消息都将被重发。当然在&lt;/span&gt;commit之前&lt;span&gt;抛出异常&lt;/span&gt;，也会导致事务的rollback。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）生产者弄丢了数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;生产者将数据发送到&lt;/span&gt;RabbitMQ&lt;span&gt;的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。此时可以选择用&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;提供的事务功能，就是生产者发送数据之前开启&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;事务（&lt;/span&gt;&lt;span&gt;channel.txSelect&lt;/span&gt;&lt;span&gt;），然后发送消息，如果消息没有成功被&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;接收到，那么生产者会收到异常报错，此时就可以回滚事务（&lt;/span&gt;&lt;span&gt;channel.txRollback&lt;/span&gt;&lt;span&gt;），然后重试发送消息；如果收到了消息，那么可以提交事务（&lt;/span&gt;&lt;span&gt;channel.txCommit&lt;/span&gt;&lt;span&gt;）。但是问题是，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;事务机制一搞，基本上吞吐量会下来，因为太耗性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以一般来说，如果要确保&lt;/span&gt;RabbitMQ&lt;span&gt;的消息别丢，可以开启&lt;/span&gt;&lt;span&gt;confirm&lt;/span&gt;&lt;span&gt;模式，在生产者那里设置开启&lt;/span&gt;&lt;span&gt;confirm&lt;/span&gt;&lt;span&gt;模式之后，你每次写的消息都会分配一个唯一的&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;，然后如果写入了&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会给你回传一个&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;消息，告诉你说这个消息&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;了。如果&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;没能处理这个消息，会回调你一个&lt;/span&gt;&lt;span&gt;nack&lt;/span&gt;&lt;span&gt;接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事务机制和&lt;/span&gt;cnofirm&lt;span&gt;机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是&lt;/span&gt;&lt;span&gt;confirm&lt;/span&gt;&lt;span&gt;机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;接收了之后会异步回调你一个接口通知你这个消息接收到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以一般在生产者这块避免数据丢失，都是用&lt;/span&gt;confirm&lt;span&gt;机制的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;弄丢了数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;就是&lt;/span&gt;RabbitMQ&lt;span&gt;自己弄丢了数据，这个你必须开启&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;的持久化，就是消息写入之后会持久化到磁盘，哪怕是&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置持久化有两个步骤，第一个是创建&lt;/span&gt;queue&lt;span&gt;和交换器的时候将其设置为持久化的，这样就可以保证&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;持久化相关的元数据，但是不会持久化&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;里的数据；第二个是发送消息的时候将消息的&lt;/span&gt;&lt;span&gt;deliveryMode&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，就是将消息设置为持久化的，此时&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;哪怕是挂了，再次重启，也会从磁盘上重启恢复&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;，恢复这个&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;里的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且持久化可以跟生产者那边的&lt;/span&gt;confirm&lt;span&gt;机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;了，所以哪怕是在持久化到磁盘之前，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;挂了，数据丢了，生产者收不到&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;，你也是可以自己重发的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪怕是你给&lt;/span&gt;RabbitMQ&lt;span&gt;开启了持久化机制，也有一种可能，就是这个消息写到了&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;中，但是还没来得及持久化到磁盘上，结果不巧，此时&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;挂了，就会导致内存里的一点点数据会丢失。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）消费端弄丢了数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;RabbitMQ&lt;span&gt;如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;认为你都消费了，这数据就丢了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候得用&lt;/span&gt;RabbitMQ&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;机制，简单来说，就是你关闭&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;自动&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;，可以通过一个&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;来调用就行，然后每次你自己代码里确保处理完的时候，再程序里&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;一把。这样的话，如果你还没处理完，不就没有&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;？那&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;就认为你还没处理完，这个时候&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会把这个消费分配给别的&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;去处理，消息是不会丢的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Kafka&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）消费端弄丢了数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了&lt;/span&gt;offset&lt;span&gt;，让&lt;/span&gt;&lt;span&gt;kafka&lt;/span&gt;&lt;span&gt;以为你已经消费好了这个消息，其实你刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家都知道&lt;/span&gt;kafka&lt;span&gt;会自动提交&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;，那么只要关闭自动提交&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;，在处理完之后自己手动提交&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;，就可以保证数据不会丢。但是此时确实还是会重复消费，比如你刚处理完，还没提交&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产环境碰到的一个问题，就是说我们的&lt;/span&gt;kafka&lt;span&gt;消费者消费到了数据之后是写到一个内存的&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;里先缓冲一下，结果有的时候，你刚把消息写入内存&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;，然后消费者会自动提交&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后此时我们重启了系统，就会导致内存&lt;/span&gt;queue&lt;span&gt;里还没来得及处理的数据就丢失了&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;kafka&lt;/span&gt;&lt;span&gt;弄丢了数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这块比较常见的一个场景，就是&lt;/span&gt;kafka&lt;span&gt;某个&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;宕机，然后重新选举&lt;/span&gt;&lt;span&gt;partiton&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;时。大家想想，要是此时其他的&lt;/span&gt;&lt;span&gt;follower&lt;/span&gt;&lt;span&gt;刚好还有些数据没有同步，结果此时&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;挂了，然后选举某个&lt;/span&gt;&lt;span&gt;follower&lt;/span&gt;&lt;span&gt;成&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;之后，他不就少了一些数据？这就丢了一些数据啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以此时一般是要求起码设置如下&lt;/span&gt;4&lt;span&gt;个参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给这个&lt;/span&gt;topic&lt;span&gt;设置&lt;/span&gt;&lt;span&gt;replication.factor&lt;/span&gt;&lt;span&gt;参数：这个值必须大于&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，要求每个&lt;/span&gt;&lt;span&gt;partition&lt;/span&gt;&lt;span&gt;必须有至少&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个副本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;kafka&lt;span&gt;服务端设置&lt;/span&gt;&lt;span&gt;min.insync.replicas&lt;/span&gt;&lt;span&gt;参数：这个值必须大于&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，这个是要求一个&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;至少感知到有至少一个&lt;/span&gt;&lt;span&gt;follower&lt;/span&gt;&lt;span&gt;还跟自己保持联系，没掉队，这样才能确保&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;挂了还有一个&lt;/span&gt;&lt;span&gt;follower&lt;/span&gt;&lt;span&gt;吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;producer&lt;span&gt;端设置&lt;/span&gt;&lt;span&gt;acks=all&lt;/span&gt;&lt;span&gt;：这个是要求每条数据，必须是写入所有&lt;/span&gt;&lt;span&gt;replica&lt;/span&gt;&lt;span&gt;之后，才能认为是写成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;producer&lt;span&gt;端设置&lt;/span&gt;&lt;span&gt;retries=MAX&lt;/span&gt;&lt;span&gt;（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）生产者会不会弄丢数据&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果按照上述的思路设置了&lt;/span&gt;ack=all&lt;span&gt;，一定不会丢，要求是，你的&lt;/span&gt;&lt;span&gt;leader&lt;/span&gt;&lt;span&gt;接收到消息，所有的&lt;/span&gt;&lt;span&gt;follower&lt;/span&gt;&lt;span&gt;都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;消息的顺序性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;从根本上说，异步消息是不应该有顺序依赖的。在&lt;/span&gt;MQ&lt;span&gt;上估计是没法解决。&lt;/span&gt;&lt;span&gt;要实现严格的顺序消息，简单且可行的办法就是：保证生产者&lt;/span&gt; - MQServer - &lt;span&gt;消费者是一对一对一的关系&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ActiveMQ&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1&lt;span&gt;、通过高级特性&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;独有消费者（&lt;/span&gt;&lt;span&gt;exclusive consumer&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;queue = new ActiveMQQueue(&quot;TEST.QUEUE?consumer.exclusive=true&quot;);&lt;/p&gt;
&lt;p&gt;consumer = session.createConsumer(queue);&lt;/p&gt;
&lt;p&gt;当在接收信息的时候，有多个独占消费者的时候，只有一个独占消费者可以接收到消息。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;独占消息就是在有多个消费者同时消费一个&lt;/span&gt;queue&lt;span&gt;时，可以保证只有一个消费者可以消费消息，这样虽然保证了消息的顺序问题，不过也带来了一个问题，就是这个&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;的所有消息将只会在这一个主消费者上消费，其他消费者将闲置，达不到负载均衡分配，而实际业务我们可能更多的是这样的场景，比如一个订单会发出一组顺序消息，我们只要求这一组消息是顺序消费的，而订单与订单之间又是可以并行消费的，不需要顺序，因为顺序也没有任何意义，有没有办法做到呢？可以利用&lt;/span&gt;&lt;span&gt;activemq&lt;/span&gt;&lt;span&gt;的另一个高级特性之&lt;/span&gt;&lt;span&gt;messageGroup&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、利用&lt;/span&gt;&lt;span&gt;Activemq&lt;/span&gt;&lt;span&gt;的高级特性：&lt;/span&gt;&lt;span&gt;messageGroups&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Message Groups&lt;span&gt;特性是一种负载均衡的机制。在一个消息被分发到&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;之前，&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;首先检查消息&lt;/span&gt;&lt;span&gt;JMSXGroupID&lt;/span&gt;&lt;span&gt;属性。如果存在，那么&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;会检查是否有某个&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;拥有这个&lt;/span&gt;&lt;span&gt;message group&lt;/span&gt;&lt;span&gt;。如果没有，那么&lt;/span&gt;&lt;span&gt;broker&lt;/span&gt;&lt;span&gt;会选择一个&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;，并将它关联到这个&lt;/span&gt;&lt;span&gt;message group&lt;/span&gt;&lt;span&gt;。此后，这个&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;会接收这个&lt;/span&gt;&lt;span&gt;message group&lt;/span&gt;&lt;span&gt;的所有消息，直到：&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;被关闭。&lt;/span&gt;&lt;span&gt;Message group&lt;/span&gt;&lt;span&gt;被关闭，通过发送一个消息，并设置这个消息的&lt;/span&gt;&lt;span&gt;JMSXGroupSeq&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bytesMessage&lt;/strong&gt;.setStringProperty(&quot;JMSXGroupID&quot;, &quot;constact-20100000002&quot;);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bytesMessage&lt;/strong&gt;.setIntProperty(&quot;JMSXGroupSeq&quot;, -1);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，同一个&lt;/span&gt;queue&lt;span&gt;中，拥有相同&lt;/span&gt;&lt;span&gt;JMSXGroupID&lt;/span&gt;&lt;span&gt;的消息将发往同一个消费者，解决顺序问题，不同分组的消息又能被其他消费者并行消费，解决负载均衡的问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果有顺序依赖的消息，要保证消息有一个&lt;/span&gt;hashKey&lt;span&gt;，类似于数据库表分区的的分区&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;列。保证对同一个&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;的消息发送到相同的队列。&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;用户产生的消息（包括创建消息和删除消息）都按&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;hashKey&lt;/span&gt;&lt;span&gt;分发到同一个队列。只需要把强相关的两条消息基于相同的路由就行了，也就是说经过&lt;/span&gt;&lt;span&gt;m1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;span&gt;的在路由表里的路由是一样的，那自然&lt;/span&gt;&lt;span&gt;m1&lt;/span&gt;&lt;span&gt;会优先于&lt;/span&gt;&lt;span&gt;m2&lt;/span&gt;&lt;span&gt;去投递。而且&lt;/span&gt;&lt;span&gt;一个&lt;/span&gt;queue只&lt;span&gt;对应一个&lt;/span&gt;consumer。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Kafka&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一个&lt;/span&gt;topic&lt;span&gt;，一个&lt;/span&gt;&lt;span&gt;partition&lt;/span&gt;&lt;span&gt;，一个&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;，内部单线程消费&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;如何解决消息队列的延时以及过期失效问题？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;rabbitmq&lt;span&gt;，&lt;/span&gt;&lt;span&gt;rabbitmq&lt;/span&gt;&lt;span&gt;是可以设置过期时间的，就是&lt;/span&gt;&lt;span&gt;TTL&lt;/span&gt;&lt;span&gt;，如果消息在&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;中积压超过一定的时间，而又没有设置死信队列机制，就会被&lt;/span&gt;&lt;span&gt;rabbitmq&lt;/span&gt;&lt;span&gt;给清理掉，这个数据就没了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ActiveMQ&lt;span&gt;则通过更改配置，支持消息的定时发送。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;有几百万消息持续积压几小时怎么解决？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;发生了线上故障，几千万条数据在&lt;/span&gt;MQ&lt;span&gt;里积压很久。是修复&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;的问题，让他恢复消费速度，然后等待几个小时消费完毕？这是个解决方案。不过有时候我们还会进行临时紧急扩容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个消费者一秒是&lt;/span&gt;1000&lt;span&gt;条，一秒&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个消费者是&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;条，一分钟是&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;万条。&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;多万条，所以如果积压了几百万到上千万的数据，即使消费者恢复了，也需要大概&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;小时的时间才能恢复过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先修复&lt;/span&gt;consumer&lt;span&gt;的问题，确保其恢复消费速度，然后将现有&lt;/span&gt;&lt;span&gt;cnosumer&lt;/span&gt;&lt;span&gt;都停掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建一个&lt;/span&gt;topic&lt;span&gt;，&lt;/span&gt;&lt;span&gt;partition&lt;/span&gt;&lt;span&gt;是原来的&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;倍，临时建立好原先&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;倍或者&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;倍的&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;数量。然后写一个临时的分发数据的&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;倍数量的&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着临时征用&lt;/span&gt;10&lt;span&gt;倍的机器来部署&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;，每一批&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;消费一个临时&lt;/span&gt;&lt;span&gt;queue&lt;/span&gt;&lt;span&gt;的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种做法相当于是临时将&lt;/span&gt;queue&lt;span&gt;资源和&lt;/span&gt;&lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;资源扩大&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;倍，以正常的&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;倍速度来消费数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等快速消费完积压数据之后，再恢复原先部署架构，重新用原先的&lt;/span&gt;consumer&lt;span&gt;机器来消费消息。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Kafka&lt;span&gt;是如何实现高性能的？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;宏观架构层面利用&lt;/span&gt;Partition&lt;span&gt;实现并行处理&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Kafka&lt;span&gt;中每个&lt;/span&gt;&lt;span&gt;Topic&lt;/span&gt;&lt;span&gt;都包含一个或多个&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;，不同&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;可位于不同节点。同时&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;在物理上对应一个本地文件夹，每个&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;包含一个或多个&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt;&lt;span&gt;，每个&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt;&lt;span&gt;包含一个数据文件和一个与之对应的索引文件。在逻辑上，可以把一个&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;当作一个非常长的数组，可通过这个“数组”的索引（&lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;）去访问其数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一方面，由于不同&lt;/span&gt;Partition&lt;span&gt;可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。另一方面，由于&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;在物理上对应一个文件夹，即使多个&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;位于同一个节点，也可通过配置让同一节点上的不同&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;置于不同的&lt;/span&gt;&lt;span&gt;disk drive&lt;/span&gt;&lt;span&gt;上，从而实现磁盘间的并行处理，充分发挥多磁盘的优势。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用多磁盘的具体方法是，将不同磁盘&lt;/span&gt;mount&lt;span&gt;到不同目录，然后在&lt;/span&gt;&lt;span&gt;server.properties&lt;/span&gt;&lt;span&gt;中，将&lt;/span&gt;&lt;span&gt;log.dirs&lt;/span&gt;&lt;span&gt;设置为多目录（用逗号分隔）。&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;会自动将所有&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;尽可能均匀分配到不同目录也即不同目录（也即不同&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;）上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Partition&lt;span&gt;是最小并发粒度，&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;个数决定了可能的最大并行度。。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ISR&lt;span&gt;实现可用性与数据一致性的动态平衡&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;常用数据复制及一致性方案&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;Master-Slave&lt;/h5&gt;
&lt;p&gt;- RDBMS&lt;span&gt;的读写分离即为典型的&lt;/span&gt;&lt;span&gt;Master-Slave&lt;/span&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;同步复制可保证强一致性但会影响可用性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;异步复制可提供高可用性但会降低一致性&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;WNR&lt;/h5&gt;
&lt;p&gt;- &lt;span&gt;主要用于去中心化的分布式系统中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- N&lt;span&gt;代表总副本数，&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;代表每次写操作要保证的最少写成功的副本数，&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;代表每次读至少要读取的副本数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;当&lt;/span&gt;&lt;span&gt;W+R&amp;gt;N&lt;/span&gt;&lt;span&gt;时，可保证每次读取的数据至少有一个副本拥有最新的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;多个写操作的顺序难以保证，可能导致多副本间的写操作顺序不一致。&lt;/span&gt;&lt;span&gt;Dynamo&lt;/span&gt;&lt;span&gt;通过向量时钟保证最终一致性&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;Paxos&lt;span&gt;及其变种&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;- Google&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Chubby&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt;的原子广播协议（&lt;/span&gt;&lt;span&gt;Zab&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;RAFT&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;基于&lt;/span&gt;ISR&lt;span&gt;的数据复制方案&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kafka&lt;span&gt;的数据复制是以&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;为单位的。而多个备份间的数据复制，通过&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;向&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;拉取数据完成。从一这点来讲，&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;的数据复制方案接近于上文所讲的&lt;/span&gt;&lt;span&gt;Master-Slave&lt;/span&gt;&lt;span&gt;方案。不同的是，&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;既不是完全的同步复制，也不是完全的异步复制，而是基于&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;的动态复制方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ISR&lt;span&gt;，也即&lt;/span&gt;&lt;span&gt;In-sync Replica&lt;/span&gt;&lt;span&gt;。每个&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;都会维护这样一个列表，该列表中，包含了所有与之同步的&lt;/span&gt;&lt;span&gt;Replica&lt;/span&gt;&lt;span&gt;（包含&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;自己）。每次数据写入时，只有&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;中的所有&lt;/span&gt;&lt;span&gt;Replica&lt;/span&gt;&lt;span&gt;都复制完，&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;才会将其置为&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt;，它才能被&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;所消费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方案，与同步复制非常接近。但不同的是，这个&lt;/span&gt;ISR&lt;span&gt;是由&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;动态维护的。如果&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;不能紧“跟上”&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;，它将被&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;中移除，待它又重新“跟上”&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;后，会被&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;再次加加&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;中。每次改变&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;后，&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;都会将最新的&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;持久化到&lt;/span&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于&lt;/span&gt;Leader&lt;span&gt;可移除不能及时与之同步的&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;，故与同步复制相比可避免最慢的&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;拖慢整体速度，也即&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;提高了系统可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ISR&lt;span&gt;中的所有&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;都包含了所有&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt;过的消息，而只有&lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt;过的消息才会被&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;消费，故从&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;的角度而言，&lt;/span&gt;&lt;span&gt;ISR&lt;/span&gt;&lt;span&gt;中的所有&lt;/span&gt;&lt;span&gt;Replica&lt;/span&gt;&lt;span&gt;都始终处于同步状态，从而与异步复制方案相比提高了数据一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ISR&lt;span&gt;可动态调整，极限情况下，可以只包含&lt;/span&gt;&lt;span&gt;Leader&lt;/span&gt;&lt;span&gt;，极大提高了可容忍的宕机的&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;的数量。与&lt;/span&gt;&lt;span&gt;Majority Quorum&lt;/span&gt;&lt;span&gt;方案相比，容忍相同个数的节点失败，所要求的总节点数少了近一半。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;具体实现层面高效使用磁盘特性和操作系统特性&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;将写磁盘的过程变为顺序写&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kafka&lt;span&gt;的整个设计中，&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;相当于一个非常长的数组，而&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;接收到的所有消息顺序写入这个大数组中。同时&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;Offset&lt;/span&gt;&lt;span&gt;顺序消费这些数据，并且不删除已经消费的数据，从而避免了随机写磁盘的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于磁盘有限，不可能保存所有数据，实际上作为消息系统&lt;/span&gt;Kafka&lt;span&gt;也没必要保存所有数据，需要删除旧的数据。而这个删除过程，并非通过使用“读&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;写”模式去修改文件，而是将&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;分为多个&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt;&lt;span&gt;，每个&lt;/span&gt;&lt;span&gt;Segment&lt;/span&gt;&lt;span&gt;对应一个物理文件，通过删除整个文件的方式去删除&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;内的数据。这种方式清除旧数据的方式，也避免了对文件的随机写操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在存储机制上，使用了&lt;/span&gt;Log Structured Merge Trees(LSM) &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;Log Structured Merge Trees(LSM)&lt;span&gt;，谷歌 “&lt;/span&gt;&lt;span&gt;BigTable&lt;/span&gt;&lt;span&gt;” 的论文，中提出，&lt;/span&gt;&lt;span&gt;LSM&lt;/span&gt;&lt;span&gt;是当前被用在许多产品的文件结构策略：&lt;/span&gt;&lt;span&gt;HBase, Cassandra, LevelDB, SQLite,Kafka&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;LSM&lt;/span&gt;&lt;span&gt;被设计来提供比传统的&lt;/span&gt;&lt;span&gt;B+&lt;/span&gt;&lt;span&gt;树或者&lt;/span&gt;&lt;span&gt;ISAM&lt;/span&gt;&lt;span&gt;更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。这个问题的本质还是磁盘随机操作慢，顺序读写快。这二种操作存在巨大的差距，无论是磁盘还是&lt;/span&gt;&lt;span&gt;SSD&lt;/span&gt;&lt;span&gt;，而且快至少三个数量级。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;充分利用&lt;/span&gt;Page Cache&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Page Cache&lt;span&gt;的好处如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- I/O Scheduler&lt;span&gt;会将连续的小块写组装成大块的物理写从而提高性能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- I/O Scheduler&lt;span&gt;会尝试将一些写操作重新按顺序排好，从而减少磁盘头的移动时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;充分利用所有空闲内存（非&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;内存）。如果使用应用层&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;（即&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;堆内存），会增加&lt;/span&gt;&lt;span&gt;GC&lt;/span&gt;&lt;span&gt;负担&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;读操作可直接在&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;内进行。如果消费和生产速度相当，甚至不需要通过物理磁盘（直接通过&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;）交换数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- &lt;span&gt;如果进程重启，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;内的&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;会失效，但&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;仍然可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Broker&lt;span&gt;收到数据后，写磁盘时只是将数据写入&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;，并不保证数据一定完全写入磁盘。从这一点看，可能会造成机器宕机时，&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;内的数据未写入磁盘从而造成数据丢失。但是这种丢失只发生在机器断电等造成操作系统不工作的场景，而这种场景完全可以由&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;层面的&lt;/span&gt;&lt;span&gt;Replication&lt;/span&gt;&lt;span&gt;机制去解决。如果为了保证这种情况下数据不丢失而强制将&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;中的数据&lt;/span&gt;&lt;span&gt;Flush&lt;/span&gt;&lt;span&gt;到磁盘，反而会降低性能。也正因如此，&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;虽然提供了&lt;/span&gt;&lt;span&gt;flush.messages&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;flush.ms&lt;/span&gt;&lt;span&gt;两个参数将&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;中的数据强制&lt;/span&gt;&lt;span&gt;Flush&lt;/span&gt;&lt;span&gt;到磁盘，但是&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;并不建议使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据消费速度与生产速度相当，甚至不需要通过物理磁盘交换数据，而是直接通过&lt;/span&gt;Page Cache&lt;span&gt;交换数据。同时，&lt;/span&gt;&lt;span&gt;Follower&lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;Leader Fetch&lt;/span&gt;&lt;span&gt;数据时，也可通过&lt;/span&gt;&lt;span&gt;Page Cache&lt;/span&gt;&lt;span&gt;完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;Page Cache&lt;span&gt;，又称&lt;/span&gt;&lt;span&gt;pcache&lt;/span&gt;&lt;span&gt;，其中文名称为页高速缓冲存储器，简称页高缓。&lt;/span&gt;&lt;span&gt;page cache&lt;/span&gt;&lt;span&gt;的大小为一页，通常为&lt;/span&gt;&lt;span&gt;4K&lt;/span&gt;&lt;span&gt;。在&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;读写文件时，它用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;操作系统的一个特色。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;支持多&lt;/span&gt;Disk Drive&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Broker&lt;span&gt;的&lt;/span&gt;&lt;span&gt;log.dirs&lt;/span&gt;&lt;span&gt;配置项，允许配置多个文件夹。如果机器上有多个&lt;/span&gt;&lt;span&gt;Disk Drive&lt;/span&gt;&lt;span&gt;，可将不同的&lt;/span&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt;挂载到不同的目录，然后将这些目录都配置到&lt;/span&gt;&lt;span&gt;log.dirs&lt;/span&gt;&lt;span&gt;里。&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;会尽可能将不同的&lt;/span&gt;&lt;span&gt;Partition&lt;/span&gt;&lt;span&gt;分配到不同的目录，也即不同的&lt;/span&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt;上，从而充分利用了多&lt;/span&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt;的优势。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;零拷贝&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kafka&lt;span&gt;中存在大量的网络数据持久化到磁盘（&lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;）和磁盘文件通过网络发送（&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;）的过程。这一过程的性能直接影响&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;的整体吞吐量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;传统模式下的四次拷贝与四次上下文切换&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以将磁盘文件通过网络发送为例。传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过&lt;/span&gt;Socket&lt;span&gt;将内存中的数据发送出去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;buffer = File.readSocket.send(buffer)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一过程实际上发生了四次数据拷贝。首先通过系统调用将文件数据读入到内核态&lt;/span&gt;Buffer&lt;span&gt;（&lt;/span&gt;&lt;span&gt;DMA&lt;/span&gt;&lt;span&gt;拷贝），然后应用程序将内存态&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;数据读入到用户态&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;拷贝），接着用户程序通过&lt;/span&gt;&lt;span&gt;Socket&lt;/span&gt;&lt;span&gt;发送数据时将用户态&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;数据拷贝到内核态&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;拷贝），最后通过&lt;/span&gt;&lt;span&gt;DMA&lt;/span&gt;&lt;span&gt;拷贝将数据拷贝到&lt;/span&gt;&lt;span&gt;NIC Buffer&lt;/span&gt;&lt;span&gt;。同时，还伴随着四次上下文切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而&lt;/span&gt;Linux 2.4+&lt;span&gt;内核通过&lt;/span&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;span&gt;系统调用，提供了零拷贝。数据通过&lt;/span&gt;&lt;span&gt;DMA&lt;/span&gt;&lt;span&gt;拷贝到内核态&lt;/span&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;后，直接通过&lt;/span&gt;&lt;span&gt;DMA&lt;/span&gt;&lt;span&gt;拷贝到&lt;/span&gt;&lt;span&gt;NIC Buffer&lt;/span&gt;&lt;span&gt;，无需&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;网络发送由一个&lt;/span&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;span&gt;调用完成，整个过程只有两次上下文切换，因此大大提高了性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从具体实现来看，&lt;/span&gt;Kafka&lt;span&gt;的数据传输通过&lt;/span&gt;&lt;span&gt;Java NIO&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;FileChannel&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;transferTo&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;transferFrom&lt;/span&gt;&lt;span&gt;方法实现零拷贝。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt; transferTo&lt;span&gt;和&lt;/span&gt;&lt;span&gt;transferFrom&lt;/span&gt;&lt;span&gt;并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供&lt;/span&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;span&gt;这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;减少网络开销批处理&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;批处理是一种常用的用于提高&lt;/span&gt;I/O&lt;span&gt;性能的方式。对&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;而言，批处理既减少了网络传输的&lt;/span&gt;&lt;span&gt;Overhead&lt;/span&gt;&lt;span&gt;，又提高了写磁盘的效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Kafka &lt;span&gt;的&lt;/span&gt;&lt;span&gt;send&lt;/span&gt;&lt;span&gt;方法并非立即将消息发送出去，而是通过&lt;/span&gt;&lt;span&gt;batch.size&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;linger.ms&lt;/span&gt;&lt;span&gt;控制实际发送频率，从而实现批量发送。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于每次网络传输，除了传输消息本身以外，还要传输非常多的网络协议本身的一些内容（称为&lt;/span&gt;Overhead&lt;span&gt;），所以将多条消息合并到一起传输，可有效减少网络传输的&lt;/span&gt;&lt;span&gt;Overhead&lt;/span&gt;&lt;span&gt;，进而提高了传输效率。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;数据压缩降低网络负载&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kafka&lt;span&gt;从&lt;/span&gt;&lt;span&gt;0.7&lt;/span&gt;&lt;span&gt;开始，即支持将数据压缩后再传输给&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;。除了可以将每条消息单独压缩然后传输外，&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;还支持在批量发送时，将整个&lt;/span&gt;&lt;span&gt;Batch&lt;/span&gt;&lt;span&gt;的消息一起压缩后传输。数据压缩的一个基本原理是，重复数据越多压缩效果越好。因此将整个&lt;/span&gt;&lt;span&gt;Batch&lt;/span&gt;&lt;span&gt;的数据一起压缩能更大幅度减小数据量，从而更大程度提高网络传输效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Broker&lt;span&gt;接收消息后，并不直接解压缩，而是直接将消息以压缩后的形式持久化到磁盘。&lt;/span&gt;&lt;span&gt;Consumer Fetch&lt;/span&gt;&lt;span&gt;到数据后再解压缩。因此&lt;/span&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt;的压缩不仅减少了&lt;/span&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;的网络传输负载，同时也降低了&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;磁盘操作的负载，也降低了&lt;/span&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;span&gt;间的网络传输量，从而极大得提高了传输效率，提高了吞吐量。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;em&gt;高效的序列化方式&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kafka&lt;span&gt;消息的&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Payload&lt;/span&gt;&lt;span&gt;（或者说&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;）的类型可自定义，只需同时提供相应的序列化器和反序列化器即可。因此用户可以通过使用快速且紧凑的序列化&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;反序列化方式（如&lt;/span&gt;&lt;span&gt;Avro&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Protocal Buffer&lt;/span&gt;&lt;span&gt;）来减少实际网络传输和磁盘存储的数据规模，从而提高吞吐率。这里要注意，如果使用的序列化方法太慢，即使压缩比非常高，最终的效率也不一定高。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 23:36:00 +0000</pubDate>
<dc:creator>开心的鱼a1</dc:creator>
<og:description>为什么使用消息队列？ 什么业务场景，这个业务场景有个什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多的好处。消息队列的常见使用场景，其实场景有很多，但是比较核心的有3个：解耦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dw-haung/p/10393338.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--27 计算着色器：双调排序 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10398953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10398953.html</guid>
<description>&lt;p&gt;上一章我们用一个比较简单的例子来尝试使用计算着色器，但是在看这一章内容之前，你还需要了解一些缓冲区的创建和使用方式：&lt;/p&gt;
&lt;p&gt;这一章我们继续用一个计算着色器的应用实例作为切入点，进一步了解相关知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于线程组(大小&lt;code&gt;(ThreadDimX, ThreadDimY, ThreadDimZ)&lt;/code&gt;)中的每一个线程，它们都有一个唯一的线程ID值。我们可以使用系统值&lt;code&gt;SV_GroupThreadID&lt;/code&gt;来取得，它的索引范围为&lt;code&gt;(0, 0, 0)&lt;/code&gt;到&lt;code&gt;(ThreadDimX - 1, ThreadDimY - 1, ThreadDimZ - 1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021341694-68018688.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而对于整个线程组来说，由于线程组集合也是在3D空间中排布，它们也有一个唯一的线程组ID值。我们可以使用系统值&lt;code&gt;SV_GroupID&lt;/code&gt;来取得，线程组的索引范围取决于调用&lt;code&gt;ID3D11DeviceContext::Dispatch&lt;/code&gt;时提供的线程组(大小&lt;code&gt;(GroupDimX, GroupDimY, GroupDimZ)&lt;/code&gt;)，范围为&lt;code&gt;(0, 0, 0)&lt;/code&gt;到&lt;code&gt;(GroupDimX - 1, GroupDimY - 1, GroupDimZ - 1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021446761-2099606415.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;紧接着就是系统值&lt;code&gt;SV_GroupIndex&lt;/code&gt;，它是单个线程组内的线程三维索引的一维展开。若已知线程组的大小为&lt;code&gt;(ThreadDimX, ThreadDimY, ThreadDimZ)&lt;/code&gt;，则可以确定&lt;code&gt;SV_GroupIndex&lt;/code&gt;与&lt;code&gt;SV_GroupThreadID&lt;/code&gt;满足下面关系：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;SV_GroupIndex = SV_GroupThreadID.z * ThreadDimX * ThreadDimY + SV_GroupThreadID.y * ThreadDimX + SV_GroupThreadID.x;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是系统值&lt;code&gt;SV_DispatchThreadID&lt;/code&gt;，线程组中的每一个线程在&lt;code&gt;ID3D11DeviceContext::Dispatch&lt;/code&gt;提供的线程组集合中都有其唯一的线程ID值。若已知线程组的大小为 &lt;code&gt;(ThreadDimX, ThreadDimY, ThreadDimZ)&lt;/code&gt;，则可以确定&lt;code&gt;SV_DispatchThreadID&lt;/code&gt;，&lt;code&gt;SV_GroupThreadID&lt;/code&gt;和&lt;code&gt;SV_GroupID&lt;/code&gt;满足以下关系：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;SV_DispatchThreadID.xyz = SV_GroupID.xyz * float3(ThreadDimX, ThreadDimY, ThreadDimZ) + SV_GroupThreadID.xyz;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021456284-1495063153.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在一个线程组内，允许设置一片共享内存区域，使得当前线程组内的所有线程都可以访问当前的共享内存。一旦设置，那么每个线程都会各自配备一份共享内存。共享内存的访问速度非常快，就像寄存器访问CPU缓存那样。&lt;/p&gt;
&lt;p&gt;共享内存的声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;groupshared float4 gCache[256];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于每个线程组来说，它所允许分配的总空间最大为32kb(即8192个标量，或2048个向量)。内部线程通常应该使用&lt;code&gt;SV_ThreadGroupID&lt;/code&gt;来写入共享内存，这样以保证每个线程不会出现重复写入操作，而读取共享内存一般是线程安全的。&lt;/p&gt;
&lt;p&gt;分配太多的共享内存会导致性能问题。假如一个多处理器支持32kb的共享内存，然后你的计算着色器需要20kb的共享内存，这意味着一个多处理器只适合处理一个线程组，因为剩余的共享内存不足以给新的线程组运行，这也会限制GPU的并行运算，当该线程组因为某些原因需要等待，会导致当前的多处理器处于闲置状态。因此保证一个多处理器至少能够处理两个或以上的线程组(比如每个线程组分配16kb以下的共享内存)，以尽可能减少该多处理器的闲置时间。&lt;/p&gt;
&lt;p&gt;现在来考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Texture2D gInput : register(t0);
RWTexture2D&amp;lt;float4&amp;gt; gOutput : register(u0);

groupshared float4 gCache[256];

[numthreads(256, 1, 1)]
void CS(uint3 GTid : SV_GroupThreadID,
    uint3 DTid : SV_DispatchThreadID)
{
    // 将纹理像素值缓存到共享内存
    gCache[GTid.x] = gInput[DTid.xy];
    
    // 取出共享内存的值进行计算
    
    // 注意！！相邻的两个线程可能没有完成对纹理的采样
    // 以及存储到共享内存的操作
    float left = gCache[GTid.x - 1];
    float right = gCache[GTid.x + 1];
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为多个线程同时运行，同一时间各个线程当前执行的指令有所偏差，有的线程可能已经完成了共享内存的赋值操作，有的线程可能还在进行纹理采样操作。如果当前线程正在读取相邻的共享内存片段，结果将是未定义的。为了解决这个问题，我们必须在读取共享内存之前让当前线程等待线程组内其它的所有线程完成写入操作。这里我们可以使用&lt;code&gt;GroupMemoryBarrierWithGroupSync&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Texture2D gInput : register(t0);
RWTexture2D&amp;lt;float4&amp;gt; gOutput : register(u0);

groupshared float4 gCache[256];

[numthreads(256, 1, 1)]
void CS(uint3 GTid : SV_GroupThreadID,
    uint3 DTid : SV_DispatchThreadID)
{
    // 将纹理像素值缓存到共享内存
    gCache[GTid.x] = gInput[DTid.xy];
    
    // 等待所有线程完成写入
    GroupMemoryBarrierWithGroupSync();
    
    // 现在读取操作是线程安全的，可以开始进行计算
    float left = gCache[GTid.x - 1];
    float right = gCache[GTid.x + 1];
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;双调序列&quot;&gt;双调序列&lt;/h2&gt;
&lt;p&gt;所谓双调序列(Bitonic Sequence)，是指由一个非严格递增序列X(允许相邻两个数相等)和非严格递减序列Y构成的序列，比如序列&lt;span class=&quot;math inline&quot;&gt;\((5, 3, 2, 1, 4, 6, 6, 12)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;定义：一个序列&lt;span class=&quot;math inline&quot;&gt;\(a_1 , a_2, ..., a_n\)&lt;/span&gt;是双调序列，需要满足下面条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存在一个&lt;span class=&quot;math inline&quot;&gt;\(a_k(1 &amp;lt;= k &amp;lt;= n)\)&lt;/span&gt;，使得&lt;span class=&quot;math inline&quot;&gt;\(a_1 &amp;gt;= ... &amp;gt;= a_k &amp;lt;= ... &amp;lt;= a_n\)&lt;/span&gt;成立，或者&lt;span class=&quot;math inline&quot;&gt;\(a_1 &amp;lt;= ... &amp;lt;= a_k &amp;gt;= ... &amp;gt;= a_n\)&lt;/span&gt;成立；&lt;/li&gt;
&lt;li&gt;序列循环移位后仍能够满足条件(1)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;batcher归并网络&quot;&gt;Batcher归并网络&lt;/h2&gt;
&lt;p&gt;Batcher归并网络是由一系列Batcher比较器组成的，Batcher比较器是指在两个输入端给定输入值x和y，再在两个输出端输出最大值&lt;span class=&quot;math inline&quot;&gt;\(max(x, y)\)&lt;/span&gt;和最小值&lt;span class=&quot;math inline&quot;&gt;\(min(x, y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;双调归并网络&quot;&gt;双调归并网络&lt;/h2&gt;
&lt;p&gt;双调归并网络是基于Batch定理而构建的。该定理是说将任意一个长为2n的双调序列分为等长的两半X和Y，将X中的元素与Y中的元素按原序比较，即&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(a_{i+n}(i &amp;lt;= n)\)&lt;/span&gt;比较，将较大者放入MAX序列，较小者放入MIN序列。则得到的MAX序列和MIN序列仍然是双调序列，并且MAX序列中的任意一个元素不小于MIN序列中的任意一个元素。&lt;/p&gt;
&lt;p&gt;根据这个原理，我们可以将一个n元素的双调序列通过上述方式进行比较操作来得到一个MAX序列和一个MIN序列，然后对这两个序列进行递归处理，直到序列不可再分割为止。最终归并得到的为一个有序序列。&lt;/p&gt;
&lt;p&gt;这里我们用一张图来描述双调排序的全过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021729794-1114533651.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中箭头方向指的是两个数交换后，箭头段的数为较大值，圆点段的数为较小值。&lt;/p&gt;
&lt;p&gt;我们可以总结出如下规律：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每一趟排序结束会产生连续的双调序列，除了最后一趟排序会产生我们所需要的单调序列&lt;/li&gt;
&lt;li&gt;对于2^k个元素的任意序列，需要进行k趟排序才能产生单调序列&lt;/li&gt;
&lt;li&gt;对于由&lt;span class=&quot;math inline&quot;&gt;\(2^{k-1}\)&lt;/span&gt;个元素的单调递增序列和&lt;span class=&quot;math inline&quot;&gt;\(2^{k-1}\)&lt;/span&gt;个元素的单调递减序列组成的双调序列，需要进行k趟交换才能产生2^k个元素的单调递增序列&lt;/li&gt;
&lt;li&gt;在第n趟排序中的第m趟交换，若两个比较数中较小的索引值为i，那么与之进行交换的数索引为&lt;span class=&quot;math inline&quot;&gt;\(i+2^{n-m}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;双调排序的空间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n{(lg(n))}^2)\)&lt;/span&gt;，看起来比&lt;span class=&quot;math inline&quot;&gt;\(O(nlg(n))\)&lt;/span&gt;系列的排序算法慢上一截，但是得益于GPU的并行计算，可以看作同一时间内有n个线程在运行，使得最终的时间复杂度可以降为&lt;span class=&quot;math inline&quot;&gt;\(O({(lg(n))}^2)\)&lt;/span&gt;，效率又上了一个档次。&lt;/p&gt;
&lt;p&gt;需要注意的是，双调排序要求排序元素的数目为&lt;span class=&quot;math inline&quot;&gt;\(2^k, (k&amp;gt;=1)\)&lt;/span&gt;，如果元素个数为&lt;span class=&quot;math inline&quot;&gt;\(2^k &amp;lt; n &amp;lt; 2^{k+1}\)&lt;/span&gt;，则需要填充数据到&lt;span class=&quot;math inline&quot;&gt;\(2^{k+1}\)&lt;/span&gt;个。若需要进行升序排序，则需要填充足够的最大值；若需要进行降序排序，则需要填充足够的最小值。&lt;/p&gt;
&lt;h2 id=&quot;排序核心代码实现&quot;&gt;排序核心代码实现&lt;/h2&gt;
&lt;p&gt;本HLSL实现参考了&lt;a href=&quot;https://github.com/walbourn/directx-sdk-samples&quot;&gt;directx-sdk-samples&lt;/a&gt;，虽然里面的实现看起来比较简洁，但是理解它的算法实现费了我不少的时间。个人以自己能够理解的形式对它的实现进行了修改，因此这里以我这边的实现版本来讲解。&lt;/p&gt;
&lt;p&gt;首先是排序需要用到的资源和常量缓冲区，定义在&lt;code&gt;BitonicSort.hlsli&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// BitonicSort.hlsli
Buffer&amp;lt;uint&amp;gt; gInput : register(t0);
RWBuffer&amp;lt;uint&amp;gt; gData : register(u0);

cbuffer CB : register(b0)
{
    uint gLevel;        // 2^需要排序趟数
    uint gDescendMask;  // 下降序列掩码
    uint gMatrixWidth;  // 矩阵宽度(要求宽度&amp;gt;=高度且都为2的倍数)
    uint gMatrixHeight; // 矩阵高度
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是核心的排序算法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// BitonicSort_CS.hlsl
#include &quot;BitonicSort.hlsli&quot;

#define BITONIC_BLOCK_SIZE 512

groupshared uint shared_data[BITONIC_BLOCK_SIZE];

[numthreads(BITONIC_BLOCK_SIZE, 1, 1)]
void CS(uint3 Gid : SV_GroupID,
    uint3 DTid : SV_DispatchThreadID,
    uint3 GTid : SV_GroupThreadID,
    uint GI : SV_GroupIndex)
{
    // 写入共享数据
    shared_data[GI] = gData[DTid.x];
    GroupMemoryBarrierWithGroupSync();
    
    // 进行排序
    for (uint j = gLevel &amp;gt;&amp;gt; 1; j &amp;gt; 0; j &amp;gt;&amp;gt;= 1)
    {
        uint smallerIndex = GI &amp;amp; ~j;
        uint largerIndex = GI | j;
        bool isDescending = (bool) (gDescendMask &amp;amp; DTid.x);
        bool isSmallerIndex = (GI == smallerIndex);
        uint result = ((shared_data[smallerIndex] &amp;lt;= shared_data[largerIndex]) == (isDescending == isSmallerIndex)) ?
            shared_data[largerIndex] : shared_data[smallerIndex];
        GroupMemoryBarrierWithGroupSync();

        shared_data[GI] = result;
        GroupMemoryBarrierWithGroupSync();
    }
    
    // 保存结果
    gData[DTid.x] = shared_data[GI];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们实际上可以将递归过程转化成迭代来实现。&lt;/p&gt;
&lt;p&gt;现在我们先从核心排序算法讲起，由于收到线程组的线程数目、共享内存大小限制，这里定义一个线程组包含512个线程，即一个线程组最大允许排序的元素数目为512。这里共享内存的作用在这里是临时缓存中间排序的结果。&lt;/p&gt;
&lt;p&gt;首先，我们需要将数据写入共享内存中：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 写入共享数据
shared_data[GI] = gData[DTid.x];
GroupMemoryBarrierWithGroupSync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着就是要开始递归排序的过程，其中&lt;code&gt;gLevel&lt;/code&gt;的含义为单个双调序列的长度，它也说明了需要对该序列进行&lt;span class=&quot;math inline&quot;&gt;\(lg(gLevel)\)&lt;/span&gt;趟递归交换。&lt;/p&gt;
&lt;p&gt;在一个线程中，我们仅知道该线程对应的元素，但现在我们还需要做两件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到需要与该线程对应元素进行Batcher比较的另一个元素&lt;/li&gt;
&lt;li&gt;判断当前线程对应元素与另一个待比较元素相比，是较小索引还是较大索引&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里用到了位运算的魔法。先举个例子，当前&lt;code&gt;j&lt;/code&gt;为4，则待比较两个元素的索引分别为2和6，这两个索引值的区别在于索引2(二进制010)和索引6(二进制110)，前者二进制第三位为0，后者二进制第三位为1.&lt;/p&gt;
&lt;p&gt;但只要我们知道上述其中的一个索引，就可以求出另一个索引。较小索引值的索引可以通过屏蔽二进制的第三位得到，而较大索引值的索引可以通过按位或运算使得第三位为1来得到：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;uint smallerIndex = GI &amp;amp; ~j;
uint largerIndex = GI | j;
bool isSmallerIndex = (GI == smallerIndex);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是判断当前元素是位于当前趟排序完成后的递增序列还是递减序列，比如序列&lt;span class=&quot;math inline&quot;&gt;\((4, 6, 4, 3, 5, 7, 2, 1)\)&lt;/span&gt;，现在要进行第二趟排序，那么前后4个数将分别生成递增序列和递减序列，我们可以设置&lt;code&gt;gDescendMask&lt;/code&gt;的值为4(二进制100)，这样二进制索引范围在100到111的值(对应十进制4-7)处在递减序列，如果这个双调序列长度为16，那么索引4-7和12-15的两段序列都可以通过&lt;code&gt;gDescendMask&lt;/code&gt;来判断出处在递减序列：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool isDescending = (bool) (gDescendMask &amp;amp; DTid.x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是要确定当前线程对应的共享内存元素需要得到较小值，还是较大值了。这里又以一个双调序列&lt;span class=&quot;math inline&quot;&gt;\((2, 5, 7, 4)\)&lt;/span&gt;为例，待比较的两个元素为5和4，当前趟排序会将它变为单调递增序列，即所处的序列为递增序列，当前线程对应的元素为5，&lt;code&gt;shared_data[smallerIndex] &amp;lt;= shared_data[largerIndex]&lt;/code&gt;的比较结果为&lt;code&gt;&amp;gt;&lt;/code&gt;，那么它将拿到(较小值)较大索引的值。经过第一趟交换后将变成&lt;span class=&quot;math inline&quot;&gt;\((2, 4, 7, 5)\)&lt;/span&gt;，第二趟交换就不讨论了。&lt;/p&gt;
&lt;p&gt;根据对元素所处序列、元素当前索引和比较结果的讨论，可以产生出八种情况：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递减&lt;/td&gt;
&lt;td&gt;小索引&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;(较大值)较大索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递减&lt;/td&gt;
&lt;td&gt;大索引&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;(较小值)较大索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递增&lt;/td&gt;
&lt;td&gt;小索引&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;(较小值)较小索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递增&lt;/td&gt;
&lt;td&gt;大索引&lt;/td&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;(较大值)较小索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递减&lt;/td&gt;
&lt;td&gt;小索引&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;(较大值)较小索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递减&lt;/td&gt;
&lt;td&gt;大索引&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;(较小值)较小索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递增&lt;/td&gt;
&lt;td&gt;小索引&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;(较小值)较大索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;递增&lt;/td&gt;
&lt;td&gt;大索引&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;(较大值)较大索引的值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;显然现有的变量判断较大/较小索引值比判断较大值/较小值容易得多。上述结果表可以整理成下面的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;uint result = ((shared_data[smallerIndex] &amp;lt;= shared_data[largerIndex]) == (isDescending == isSmallerIndex)) ?
    shared_data[largerIndex] : shared_data[smallerIndex];
GroupMemoryBarrierWithGroupSync();

shared_data[GI] = result;
GroupMemoryBarrierWithGroupSync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在C++中，现在有如下资源和着色器：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ComPtr&amp;lt;ID3D11Buffer&amp;gt; mConstantBuffer;           // 常量缓冲区
ComPtr&amp;lt;ID3D11Buffer&amp;gt; mTypedBuffer1;             // 有类型缓冲区1
ComPtr&amp;lt;ID3D11Buffer&amp;gt; mTypedBuffer2;             // 有类型缓冲区2

ComPtr&amp;lt;ID3D11UnorderedAccessView&amp;gt; mDataUAV1;    // 有类型缓冲区1对应的无序访问视图
ComPtr&amp;lt;ID3D11UnorderedAccessView&amp;gt; mDataUAV2;    // 有类型缓冲区2对应的无序访问视图
ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; mDataSRV1;     // 有类型缓冲区1对应的着色器资源视图
ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; mDataSRV2;     // 有类型缓冲区2对应的着色器资源视图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是对512个元素进行排序的部分代码(size为2的次幂)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::SetConstants(UINT level, UINT descendMask, UINT matrixWidth, UINT matrixHeight);

//
// GameApp::GPUSort
//

md3dImmediateContext-&amp;gt;CSSetShader(mBitonicSort_CS.Get(), nullptr, 0);
md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mDataUAV1.GetAddressOf(), nullptr);

// 按行数据进行排序，先排序level &amp;lt;= BLOCK_SIZE 的所有情况
for (UINT level = 2; level &amp;lt;= size &amp;amp;&amp;amp; level &amp;lt;= BITONIC_BLOCK_SIZE; level *= 2)
{
    SetConstants(level, level, 0, 0);
    md3dImmediateContext-&amp;gt;Dispatch((size + BITONIC_BLOCK_SIZE - 1) / BITONIC_BLOCK_SIZE, 1, 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;给更多的数据排序&quot;&gt;给更多的数据排序&lt;/h2&gt;
&lt;p&gt;上述代码允许我们对元素个数为2到512的序列进行排序，但缓冲区的元素数目必须为2的次幂。由于在CS4.0中，一个线程组最多允许一个线程组包含768个线程，这意味着双调排序仅允许在一个线程组中对最多512个元素进行排序。&lt;/p&gt;
&lt;p&gt;这里我们看一个例子，假如有一个16元素的序列，然而线程组仅允许包含最多4个线程，那我们将其放置在一个4x4的矩阵内：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021752932-239981084.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后对矩阵转置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021756874-1543313005.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，通过转置后，列数据变换到行数据的位置，这样我们就可以进行跨度更大的交换操作了。处理完大跨度的交换后，我们再转置回来，处理行数据即可。&lt;/p&gt;
&lt;p&gt;现在假定我们已经对行数据排完序，下图演示了剩余的排序过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021801453-711853086.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是在线程组允许最大线程数为4的情况下，通过二维矩阵最多也只能排序16个数。。。。也许可以考虑三维矩阵转置法，这样就可以排序64个数了哈哈哈。。。&lt;/p&gt;
&lt;p&gt;不过还有一个情况我们要考虑，就是元素数目不为(2x2)的倍数，无法构成一个方阵，但我们也可以把它变成对两个方阵转置。这时矩阵的宽是高的两倍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219021958972-1084106231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于元素个数为32，它的最大索引跨度为16，转置后的索引跨度为2，不会越界到另一个方阵进行比较。但是当&lt;code&gt;gLevel&lt;/code&gt;到32时，此时进行的是单调排序，&lt;code&gt;gDescendMask&lt;/code&gt;也必须设为最大值&lt;code&gt;32&lt;/code&gt;(而不是4)，避免产生双调序列。&lt;/p&gt;
&lt;p&gt;负责转置的着色器实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// MatrixTranspose_CS.hlsl
#include &quot;BitonicSort.hlsli&quot;

#define TRANSPOSE_BLOCK_SIZE 16

groupshared uint shared_data[TRANSPOSE_BLOCK_SIZE * TRANSPOSE_BLOCK_SIZE];

[numthreads(TRANSPOSE_BLOCK_SIZE, TRANSPOSE_BLOCK_SIZE, 1)]
void CS(uint3 Gid : SV_GroupID,
    uint3 DTid : SV_DispatchThreadID,
    uint3 GTid : SV_GroupThreadID,
    uint GI : SV_GroupIndex)
{
    uint index = DTid.y * gMatrixWidth + DTid.x;
    shared_data[GI] = gInput[index];
    GroupMemoryBarrierWithGroupSync();
    
    uint2 outPos = DTid.yx % gMatrixHeight + DTid.xy / gMatrixHeight * gMatrixHeight;
    gData[outPos.y * gMatrixWidth + outPos.x] = shared_data[GI];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是GPU排序用的函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::GPUSort()
{
    UINT size = (UINT)mRandomNums.size();

    md3dImmediateContext-&amp;gt;CSSetShader(mBitonicSort_CS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mDataUAV1.GetAddressOf(), nullptr);

    // 按行数据进行排序，先排序level &amp;lt;= BLOCK_SIZE 的所有情况
    for (UINT level = 2; level &amp;lt;= size &amp;amp;&amp;amp; level &amp;lt;= BITONIC_BLOCK_SIZE; level *= 2)
    {
        SetConstants(level, level, 0, 0);
        md3dImmediateContext-&amp;gt;Dispatch((size + BITONIC_BLOCK_SIZE - 1) / BITONIC_BLOCK_SIZE, 1, 1);
    }
    
    // 计算相近的矩阵宽高(宽&amp;gt;=高且需要都为2的次幂)
    UINT matrixWidth = 2, matrixHeight = 2;
    while (matrixWidth * matrixWidth &amp;lt; size)
    {
        matrixWidth *= 2;
    }
    matrixHeight = size / matrixWidth;

    // 排序level &amp;gt; BLOCK_SIZE 的所有情况
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; pNullSRV;
    for (UINT level = BITONIC_BLOCK_SIZE * 2; level &amp;lt;= size; level *= 2)
    {
        // 如果达到最高等级，则为全递增序列
        if (level == size)
        {
            SetConstants(level / matrixWidth, level, matrixWidth, matrixHeight);
        }
        else
        {
            SetConstants(level / matrixWidth, level / matrixWidth, matrixWidth, matrixHeight);
        }
        // 先进行转置，并把数据输出到Buffer2
        md3dImmediateContext-&amp;gt;CSSetShader(mMatrixTranspose_CS.Get(), nullptr, 0);
        md3dImmediateContext-&amp;gt;CSSetShaderResources(0, 1, pNullSRV.GetAddressOf());
        md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mDataUAV2.GetAddressOf(), nullptr);
        md3dImmediateContext-&amp;gt;CSSetShaderResources(0, 1, mDataSRV1.GetAddressOf());
        md3dImmediateContext-&amp;gt;Dispatch(matrixWidth / TRANSPOSE_BLOCK_SIZE, 
            matrixHeight / TRANSPOSE_BLOCK_SIZE, 1);

        // 对Buffer2排序列数据
        md3dImmediateContext-&amp;gt;CSSetShader(mBitonicSort_CS.Get(), nullptr, 0);
        md3dImmediateContext-&amp;gt;Dispatch(size / BITONIC_BLOCK_SIZE, 1, 1);

        // 接着转置回来，并把数据输出到Buffer1
        SetConstants(matrixWidth, level, matrixWidth, matrixHeight);
        md3dImmediateContext-&amp;gt;CSSetShader(mMatrixTranspose_CS.Get(), nullptr, 0);
        md3dImmediateContext-&amp;gt;CSSetShaderResources(0, 1, pNullSRV.GetAddressOf());
        md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mDataUAV1.GetAddressOf(), nullptr);
        md3dImmediateContext-&amp;gt;CSSetShaderResources(0, 1, mDataSRV2.GetAddressOf());
        md3dImmediateContext-&amp;gt;Dispatch(matrixWidth / TRANSPOSE_BLOCK_SIZE,
            matrixHeight / TRANSPOSE_BLOCK_SIZE, 1);

        // 对Buffer1排序剩余行数据
        md3dImmediateContext-&amp;gt;CSSetShader(mBitonicSort_CS.Get(), nullptr, 0);
        md3dImmediateContext-&amp;gt;Dispatch(size / BITONIC_BLOCK_SIZE, 1, 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是&lt;code&gt;std::sort&lt;/code&gt;和双调排序的比较结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190219022009460-395235915.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以初步看到双调排序的排序用时比较稳定，而快速排序明显随元素数目增长而变慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 18:37:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 上一章我们用一个比较简单的例子来尝试使用计算着色器，但是在看这一章内容之前，你还需要了解一些缓冲区的创建和使用方式： |章节| | | | '深入理解与使用缓冲区资源' | 这一章我们继续用一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10398953.html</dc:identifier>
</item>
<item>
<title>SLAM+语音机器人DIY系列：（二）ROS入门——9.熟练使用rviz - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10398534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10398534.html</guid>
<description>&lt;p&gt;&lt;span&gt;ROS&lt;span&gt;机器人操作系统&lt;/span&gt;在机器人应用领域很流行，依托代码开源和模块间协作等特性，给机器人开发者带来了很大的方便。我们的机器人“&lt;span&gt;miiboo&lt;/span&gt;”中的大部分程序也采用ROS进行开发，所以本文就重点对ROS基础知识进行详细的讲解，给不熟悉ROS的朋友起到一个抛砖引玉的作用。本章节主要内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10383892.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;1.ROS是什么&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10385374.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;2.ROS系统整体架构&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10386598.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;3.在ubuntu16.04中安装ROS kinetic&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10387292.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;4.如何编写ROS的第一个程序hello_world&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10390038.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;5.编写简单的消息发布器和订阅器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10390922.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;6.编写简单的service和client&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10392877.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;7.理解tf的原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10393328.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;8.理解roslaunch在大型项目中的作用&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10398534.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;9.熟练使用rviz&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10398930.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;10.在实际机器人上运行ROS高级功能预览&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;整体界面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011048593-385148156.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;29&lt;span&gt;）&lt;/span&gt;rviz&lt;span&gt;整体界面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rviz&lt;span&gt;是&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;自带的图形化工具，可以很方便的让用户通过图形界面开发调试&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;。操作界面也十分简洁，如图&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;，界面主要分为上侧菜单区、左侧显示内容设置区、中间显示区、右侧显示视角设置区、下侧&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;状态区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）添加显示内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011157528-1299190712.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;30&lt;span&gt;）设置&lt;/span&gt;&lt;span&gt;Global Options&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图&lt;/span&gt;30&lt;span&gt;，启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;界面后，首先要对&lt;/span&gt;&lt;span&gt;Global Options&lt;/span&gt;&lt;span&gt;进行设置，&lt;/span&gt;&lt;span&gt;Global Options&lt;/span&gt;&lt;span&gt;里面的参数是一些全局显示相关的参数。其中的&lt;/span&gt;&lt;span&gt;Fixed Frame&lt;/span&gt;&lt;span&gt;参数是全局显示区域依托的坐标系，我们知道机器人中有很多坐标系，坐标系之间有各自的转换关系，有些是静态关系，有些是动态关系，不同的&lt;/span&gt;&lt;span&gt;Fixed Frame&lt;/span&gt;&lt;span&gt;参数有不同的显示效果，&lt;/span&gt;&lt;span&gt;&lt;span&gt;在导航机器人应用中，一般将&lt;/span&gt;Fixed Frame&lt;span&gt;参数设置为&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，也就是以&lt;/span&gt;map&lt;span&gt;坐标系作为全局坐标系。值得注意的是，在机器人的&lt;/span&gt;&lt;span&gt;tf tree&lt;/span&gt;&lt;span&gt;里面必须要有&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;坐标系，否则该选项栏会包&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;。至于&lt;/span&gt;&lt;span&gt;Global Options&lt;/span&gt;&lt;span&gt;里面的其他参数可以不用管，默认就行了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011331107-222587003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;31&lt;span&gt;）添加地图显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如图&lt;/span&gt;31&lt;span&gt;，在机器人导航应用中，我们常常需要用&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察机器人建立的地图，在机器人发布了地图到主题的情况下，我们就可以通过&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;订阅地图相应主题（一般是&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;主题）来显示地图。订阅地图的&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;主题方法很简单，首先点击&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;界面左下角&lt;/span&gt;&lt;span&gt;[add]&lt;/span&gt;&lt;span&gt;按钮，然后在弹出的对话框中选择&lt;/span&gt;&lt;span&gt;[By topic]&lt;/span&gt;&lt;span&gt;，最后在列出的&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;名字中找到我们要订阅的主题名字&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;，最后点击&lt;/span&gt;&lt;span&gt;[OK]&lt;/span&gt;&lt;span&gt;就完成了对&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;主题的订阅。订阅成功后，会在&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;左侧栏中看到&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;项，并且中间显示区正常显示出地图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011433378-87632208.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;32&lt;span&gt;）添加&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如图&lt;/span&gt;32&lt;span&gt;，在机器人导航应用中，除了观察地图外，我们常常还需要观察机器人在地图中的位置以及各个坐标系的关系是否工作正常，这个时候就需要通过&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;来显示&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;。和上面添加显示主题的方法类似，这里添加&lt;/span&gt;&lt;span&gt;TF&lt;/span&gt;&lt;span&gt;这个类型主题就可以了。说明一下，添加主题可以按主题类型查找，也可以按主题名称查找。上面添加地图主题就是按主题名称查找的，这里添加&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;主题是按主题类型查找的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011546386-1445598382.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;33&lt;span&gt;）添加里程计显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图&lt;/span&gt;33&lt;span&gt;，我们可以通过&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;订阅里程计来观察机器人的运动轨迹（图中红色箭头连接起来的轨迹）。和上面添加显示主题的方法类似，这里添加&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;这个主题就可以了。这里特别说明一点，&lt;/span&gt;&lt;span&gt;&lt;span&gt;我们需要去掉左侧栏中&lt;/span&gt;Odometry&lt;span&gt;里面&lt;/span&gt;&lt;span&gt;Covariance&lt;/span&gt;&lt;span&gt;项后面后面的勾&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，也就是在&lt;/span&gt;Odometry&lt;span&gt;显示中不启用&lt;/span&gt;&lt;span&gt;Covariance&lt;/span&gt;&lt;span&gt;信息。&lt;/span&gt;&lt;span&gt;Covariance&lt;/span&gt;&lt;span&gt;是描述里程计误差的协方差矩阵，如果启用&lt;/span&gt;&lt;span&gt;Covariance&lt;/span&gt;&lt;span&gt;来描述&lt;/span&gt;&lt;span&gt;Odometry&lt;/span&gt;&lt;span&gt;将导致显示效果很难看，所以建议去掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011658290-1151090236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;34&lt;span&gt;）添加机器人位置粒子滤波点显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图&lt;/span&gt;34&lt;span&gt;，在机器人导航中，通常采用&lt;/span&gt;&lt;span&gt;AMCL&lt;/span&gt;&lt;span&gt;粒子滤波来实现机器人的全局定位。通过&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;可以显示全局定位的例子点。和上面添加显示主题的方法类似，这里添加&lt;/span&gt;&lt;span&gt;/particlecloud&lt;/span&gt;&lt;span&gt;这个主题就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011752129-240644432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;35&lt;span&gt;）添加激光雷达显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如图&lt;/span&gt;35&lt;span&gt;，机器人&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;和导航中用到的核心传感器激光雷达数据，我们可以通过&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;显示激光雷达数据（图中红色点组成的轮廓）。和上面添加显示主题的方法类似，这里添加&lt;/span&gt;&lt;span&gt;/scan&lt;/span&gt;&lt;span&gt;这个主题就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219011916670-123501123.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;36&lt;span&gt;）添加摄像头显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图&lt;/span&gt;36&lt;span&gt;，&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;还可以订阅摄像头发布的主题，这样在&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;上就可以实现远程视频监控了。和上面添加显示主题的方法类似，这里添加&lt;/span&gt;&lt;span&gt;/usb_cam/image_raw&lt;/span&gt;&lt;span&gt;这个主题就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面的实例，我们已经知道在&lt;/span&gt;rviz&lt;span&gt;中订阅需要显示的主题了，被订阅的主题会在&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;左侧栏中列出，并且主题的显示与否是相互独立的，可以通过勾选的方式决定是否显现该主题，主题项下拉条目中有很多参数可以设置，这些参数决定显示的风格等等，可以根据需要进行设置。其他一些不常用的主题订阅实例没有给出，有需要可以依葫芦画瓢在&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;中进行订阅显示就行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）主界面中常用按钮&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219012033014-1623358664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;37&lt;span&gt;）&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;显示配置保存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的添加显示内容的实例中，我们在&lt;/span&gt;rviz&lt;span&gt;中添加了很多主题显示项，并对各显示项的参数做了相应的设置。为了下次启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;时，能直接显示这些内容和风格，我们需要将当前的&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;显示风格以配置文件的方式保存，下次启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;后只需要载入这个配置文件就能进入相应的显示风格。很简单，点击&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;左上角&lt;/span&gt;&lt;span&gt;[file]&lt;/span&gt;&lt;span&gt;菜单，在下拉中选择&lt;/span&gt;&lt;span&gt;[Save Config As]&lt;/span&gt;&lt;span&gt;，在弹出来的对话框中给配置文件取一个名字（我取名为&lt;/span&gt;&lt;span&gt;my_cfg1&lt;/span&gt;&lt;span&gt;），然后直接&lt;/span&gt;&lt;span&gt;Save,my_cfg1.rviz&lt;/span&gt;&lt;span&gt;配置文件会被保存到系统中&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;的默认目录。下次启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;后，通过点击&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;左上角&lt;/span&gt;&lt;span&gt;[file]&lt;/span&gt;&lt;span&gt;菜单，在下拉中选择&lt;/span&gt;&lt;span&gt;[Open Config]&lt;/span&gt;&lt;span&gt;，打开相应的配置文件就行了。如图&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219012120894-671058501.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;38&lt;span&gt;）机器人初始位置设定与导航目标设定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在机器人导航中，当机器人刚启动的时候，机器人位置往往需要人为给定一个大概的估计位置，这样有利于&lt;/span&gt;AMCL&lt;span&gt;粒子滤波中粒子点的快速收敛。如图&lt;/span&gt;&lt;span&gt;38,&lt;/span&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;[2D Pose Estimate]&lt;/span&gt;&lt;span&gt;按钮，然后在地图中找到机器人大致的位置后再次点击鼠标左键并保持按下状态，拖动鼠标来指定机器人的朝向，最后松手就完成对机器人初始位置的设定了。其实就是两步，先指定机器人的位置，再指定机器人的朝向。我们可以在地图中指定导航目标点，让机器人自动导航到我们的指定的位置。通过&lt;/span&gt;&lt;span&gt;[2D Nav Goal]&lt;/span&gt;&lt;span&gt;按钮就可以完成。操作步骤和机器人初始位置的设定是类似的，就不累述了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219012232630-1628096551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;39&lt;span&gt;）获取地图中指定点的坐标值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候我们需要知道地图中某个位置的坐标值，比如我们获取地图中各个位置的坐标值并填入巡逻轨迹中，让机器人按照指定巡逻路线巡逻。通过&lt;/span&gt;[Publish Point]&lt;span&gt;按钮就可以知道地图中的任意位置的坐标值，点击&lt;/span&gt;&lt;span&gt;[Publish Point]&lt;/span&gt;&lt;span&gt;按钮，然后将鼠标放置到想要获取坐标值的位置，&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;底部显示栏中就会出现相应的坐标值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;启动方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先需要启动&lt;/span&gt;roscore&lt;span&gt;，然后启动&lt;/span&gt;&lt;span&gt;rviz,&lt;/span&gt;&lt;span&gt;命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#打开终端，输入下面命令
roscore
#再打开一个终端，输入下面命令
rviz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 18 Feb 2019 17:28:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 ROS机器人操作系统在机器人应用领域很流行，依托代码开源和模块间协作等特性，给机器人开发者带来了很大的方便。我们的机器人“miiboo”中的大部分程序也采用ROS进行开发，所以本文就重点对ROS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10398534.html</dc:identifier>
</item>
<item>
<title>JS中函数常见的表现形式以及立即执行函数 - viky丶一口一个小盆友</title>
<link>http://www.cnblogs.com/xuxiaoqiangAndHM/p/10398923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuxiaoqiangAndHM/p/10398923.html</guid>
<description>&lt;p&gt;　　函数常见的几种表现形式：&lt;/p&gt;
&lt;p&gt;　　1.一般形式（函数声明）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219001747501-1465563227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　会进行函数的预解释，函数会进行声明和定义，在函数体前面或则后面都可以进行调用。&lt;/p&gt;
&lt;p&gt;　　2.函数表达式（匿名函数）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219001831167-1757996559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　会进行函数的预解析，函数会进行声明但是不会定义（赋值），只能在函数体后面进行调用。&lt;/p&gt;
&lt;p&gt;　　3.匿名函数：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219001945533-1161948550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　匿名函数属于函数表达式，javascript引擎将开头的&lt;strong&gt;function关键字当作函数声明&lt;/strong&gt;但未进行赋值操作。&lt;/p&gt;
&lt;p&gt;　　函数声明和函数表达式的区别：&lt;/p&gt;
&lt;p&gt;　　一：Javascript引擎在解析javascript代码时会‘函数声明提升'（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，从上至下解析函数表达式。&lt;/p&gt;
&lt;p&gt;　　二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219002317873-1347540273.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　了解了函数常见的几种表现形式，我们再来看看立即执行函数两种表现形式：( function(){…} )()和( function (){…} () )，两种写法是等价的。立即执行函数能做到立即执行，不存在预解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219003801894-1315117460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将&lt;strong&gt;函数声明转换成函数表达式&lt;/strong&gt;，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219004047586-1436948604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拓展：当多个立即执行函数运行过程中抛出错误的相关解析。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219005350913-1454766346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据ECMAScript规范分号&lt;strong&gt;自动插入规则&lt;/strong&gt;，可以知道第一个立即执行函数后没有自动插入&quot;;&quot;，所以导致最后解析出来的结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219010030251-1313741105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解决办法，在第一个立即执行函数后面加上&quot;;&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1190962/201902/1190962-20190219010317823-257212367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　优点：javascript中&lt;strong&gt;没有私有作用域&lt;/strong&gt;的概念，多人开发过程中在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数&lt;strong&gt;作用域链的特性&lt;/strong&gt;，可以使用这种技术可以模仿一个私有作用域，用&lt;strong&gt;匿名函数&lt;/strong&gt;作为一个“&lt;strong&gt;容器&lt;/strong&gt;”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“&lt;strong&gt;匿名包裹器&lt;/strong&gt;”或“&lt;strong&gt;命名空间&lt;/strong&gt;”。深入可以了解下我另一篇关于&lt;a title=&quot;闭包相关知识点&quot; href=&quot;https://www.cnblogs.com/xuxiaoqiangAndHM/p/10024098.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;闭包&lt;/strong&gt;&lt;/a&gt;的知识点。&lt;/p&gt;
&lt;p&gt;　　举例：JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。&lt;/p&gt;
&lt;p&gt;　　好了，谢谢你这么帅，还能看完我的分享，希望对你有所帮助（辛辛苦苦写了那么多，兄dei，点个赞再走吧），送你一朵❀。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 17:13:00 +0000</pubDate>
<dc:creator>viky丶一口一个小盆友</dc:creator>
<og:description>函数常见的几种表现形式： 1.一般形式（函数声明）： 会进行函数的预解释，函数会进行声明和定义，在函数体前面或则后面都可以进行调用。 2.函数表达式（匿名函数）： 会进行函数的预解析，函数会进行声明但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuxiaoqiangAndHM/p/10398923.html</dc:identifier>
</item>
<item>
<title>how networks work sixth note - lingyefengzi</title>
<link>http://www.cnblogs.com/lingyefengzi/p/10398913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lingyefengzi/p/10398913.html</guid>
<description>&lt;h2 id=&quot;思维导图&quot;&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557340/201902/1557340-20190219012622873-1833276749.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;服务器向客户端返回的响应消息不一定和客户端向服务器发送的请求消息通过相同的路由传输
客户端计算机也可以当作服务器来使用
一台服务器可以同时用作Web服务器和邮件服务器&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;看点&quot;&gt;看点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务器概览&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器的接收操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web服务器程序器解释请求消息并作出响应&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器接收响应消息并显示内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;服务器概览&quot;&gt;服务器概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;客户端与服务器的区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;其硬件和操作系统不同
应用程序调用的Socket库的程序组件不同
服务器的程序可以同时和多台客户端计算机进行通信&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务器程序的结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;服务器操作系统具有多任务、多线程功能，可以同时运行多个程序
每一个客户端连接进来，就启动一个新的服务器程序

模块：等待连接模块 通信模块&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务器端的套接字和端口号&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;区别(数据收发的角度):发起连接的一方是客户端，等待连接的一方是服务器

客户端数据收发需要经过的4个阶段
(1)创建套接字(创建套接字阶段)
(2)用管道连接服务器端的套接字(连接阶段)
(3)收发数据(收发阶段)
(4)断开管道删除套接字(断开阶段)

服务器是将阶段(2)改成了等待连接
(1)创建套接字(创建套接字阶段)
(2-1)将套接字设置为等待连接状态(等待连接阶段)
(2-2)接受连接(接受连接阶段)
(3)收发数据(收发阶段)
(4)断开管道并删除套接字(断开阶段)

服务器创建过程：
协议栈调用socket创建套接字
调用bind将端口号写入套接字中
协议栈会调用listen向套接字写入等待连接状态控制信息
协议栈会调用accept来接受连接
一旦客户端的包到达，就会返回响应包并开始接受连接操作
协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中
当accept结束之后，等待连接的过程也就结束了，这时候等待连接模块会启动客户端通信模块

套接字的识别：
客户端IP地址
客户端端口号
服务器IP地址
服务器端口号

使用描述符来指代套接字的原因(应用程序和协议栈之间是使用描述符来指代套接字的)
(1)等待连接的套接字中没有客户端IP地址和端口号
(2)使用描述符这一种信息比较简单&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务器的接收操作&quot;&gt;服务器的接收操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;网卡将接收到的信号转化成数字信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;接收操作：
网卡接收到信号，将其还原成数字信息
(报头部分提取出时钟信号，并在每个时钟周期位置检测信号的变化方向)
需要根据包末尾的帧校验序列(FCS)来校验错误
检查MAC头部中的接收方MAC
网卡需要通过中断将网络包到达的事件通知给CPU
(网卡驱动会根据MAC头部判断协议类型，并将包交给相应的协议栈)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;IP模块的接收操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;检查IP头部格式，检查接收方IP地址
检查包有没有被分片
检查IP头部的协议号字段，并将包转发给相应的模块(TCP模块 UDP模块)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TCP模块如何处理连接包&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;TCP头部中的控制位SYN为1时(发起连接的包)，检查包的接收端口号并进行与进行等待连接的套接字进行对比

为套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值、窗口大小等参数写入套接字中，同时分配用于
发送缓冲区和接收缓冲区的内存空间。

然后生成代表接收确认的ACK号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口号大小，并用
这些信息生成TCP头部，委托IP模块发送给客户端

客户端会返回表示接收确认的ACK端口号，当这个ACK号返回服务器后，连接操作就完成了

服务器端的程序进入调用accept的暂停状态，当将新套接字的描述符转交给服务器程序之后，服务器程序就会恢复运行&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TCP模块如何处理数据包&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;根据四种信息匹配套接字
TCP模块会对比该套接字中保存的数据收发状态和收到的包的TCP头部中的信息是否匹配
从包中提取数据，存放到接收到缓冲区中，与上次收到的数据快连接起来
TCP模块会生成确认应答TCP头部，并根据接收包的序号和数据长度计算出ACK号，然后委托IP模块发送给客户端
应用程序会调用Socket库的read来获取收到的数据
控制流程会转移到服务器程序，对收到的数据进行处理(检查HTTP请求消息的内容)，并根据请求的内容向浏览器返回相应的
数据&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TCP模块的断开操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HTTP1.0中，服务器先发起断开操作

服务器程序会调用调用Socket库的close,TCP模块会生成一个控制位FIN为1的TCP,并委托IP模块发送给客户端
当客户端收到这个包后，会返回一个ACK号。
客户端调用close,生成一个FIN为1的TCP头部发给服务器，服务器再返回ACK，这时断开操作就完成了&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web服务器程序解释请求消息并作出响应&quot;&gt;Web服务器程序解释请求消息并作出响应&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将请求的URI转换为实际的文件名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;虚拟目录与实际目录进行转化&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;运行CGI程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;GET方法 输入的数据作为参数添加在URI后面发送给服务器
POST方法 将数据放在HTTP请求消息的消息体中发送给服务器&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Web程序的访问控制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Web服务器的访问规则
(1)客户端IP地址
(2)客户端域名
(2)用户名和密码(Web服务器提供的密码认证功能     Web服务器运行的CGI认证程序来验证密码)

根据客户端域名设计规则
(使用DNS服务器，通过IP查域名)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;返回响应消息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Web服务器调用Socket库的write,将响应消息交给协议栈&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;浏览器接收响应消息并显示内容&quot;&gt;浏览器接收响应消息并显示内容&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过响应的数据类型判断其中的内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;网卡将信号还原成数字信息，协议栈将拆分的网络包组装起来并取出响应消息，然后将消息转交给浏览器

根据响应消息开头的Content-Type头部字段的值来进行判断 charset附加表示文本编码方式

Content-Encoding(压缩或编码技术转化方式)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;浏览器显示网页内容!访问完成!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;实际的显示操作是由操作系统来完成的，浏览器负责对操作系统发出指令&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 18 Feb 2019 17:04:00 +0000</pubDate>
<dc:creator>lingyefengzi</dc:creator>
<og:description>请求到达Web服务器,响应返回浏览器 思维导图 问题 看点 服务器概览 服务器的接收操作 Web服务器程序器解释请求消息并作出响应 浏览器接收响应消息并显示内容 服务器概览 客户端与服务器的区别 服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lingyefengzi/p/10398913.html</dc:identifier>
</item>
<item>
<title>Oracle SQL优化器简介 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10398701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10398701.html</guid>
<description>&lt;p&gt;在看《基于Oracle的SQL优化一书》知道了很多专业名称，做了记录，CBO、优化器、查询转换、执行计划、Hint、并行、游标、绑定变量、统计信息、直方图、索引等等。这篇博客可以说是读书笔记&lt;/p&gt;
&lt;h2 id=&quot;一oracle的优化器&quot;&gt;一、Oracle的优化器&lt;/h2&gt;
&lt;h3 id=&quot;优化器简介&quot;&gt;1.1 优化器简介&lt;/h3&gt;
&lt;p&gt;优化器(Optimizer):优化器是Oracle数据库内置的一个核心子系统，负责解析SQL，Oracle优化器是Oracle系统的一个核心组件，其目的是按照一定的原则来获取目标SQL在当前情形下执行的最高效执行路径，也可以说是执行计划。&lt;/p&gt;
&lt;h3 id=&quot;sql执行过程&quot;&gt;1.2 SQL执行过程&lt;/h3&gt;
&lt;p&gt;Oracle SQL的执行过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190216232916387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二优化器优化方式&quot;&gt;二、优化器优化方式&lt;/h2&gt;
&lt;h3 id=&quot;优化器的优化方式&quot;&gt;2.1 优化器的优化方式&lt;/h3&gt;
&lt;p&gt;Oracle优化器按照优化方式分为两种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于规则的优化器(Rule-Based Optimizer)，简称RBO&lt;/li&gt;
&lt;li&gt;基于成本的优化器(Cost-Based Optimizer)，简称CBO&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基于规则的优化器&quot;&gt;2.2 基于规则的优化器&lt;/h3&gt;
&lt;h4 id=&quot;rbo简介&quot;&gt;2.2.1 RBO简介&lt;/h4&gt;
&lt;p&gt;基于规则的优化器(Rule-Based Optimizer)：所谓基于规则的优化器是指Oracle按照硬编码在数据库的一系列规则来决定SQL的执行计划，简称是RBO&lt;/p&gt;
&lt;h4 id=&quot;rbo缺陷&quot;&gt;2.2.2 RBO缺陷&lt;/h4&gt;
&lt;p&gt;RBO在oracle10后官方就不建议用，因为RBO并不支持oracle一些性能比较好的功能特性,也不会根据表的数据量等等获取执行计划，而且RBO定的那些规则也不是很容易修改。不过代码在oracle10后版本还是保存的，所以要学习测试也可以用SQL开启RBO模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter session set optimizer_mode='RULE';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;rbo执行过程&quot;&gt;2.2.3 RBO执行过程&lt;/h4&gt;
&lt;p&gt;RBO的执行过程：对于一条sql，oracle会事先给sql各种情况的执行计划定一个等级，一共有15个等级，从等级1到等级15，规则是等级越低执行效率越高，也就是等级1的执行计划执行效率是最高的。然后oracle自然就选出等级1的执行路径作为执行计划。&lt;/p&gt;
&lt;h4 id=&quot;rbo特殊情况&quot;&gt;2.2.4 RBO特殊情况&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;对于执行路径一样的情况:假如出现执行路径一样的情况，这时候就要根据数据字典缓存来确定最低的等级了，意思就是获取缓存中的先后顺序确定哪条作为执行计划&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;强制cbo的情况&quot;&gt;2.2.5 强制CBO的情况&lt;/h4&gt;
&lt;p&gt;上面说了可以通过SQL开启CBO模式，这是针对普通情况的，假如出现下面情况，那就是强制使用CBO&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SQL涉及对象有IOT(Index Organized Table)&lt;/li&gt;
&lt;li&gt;SQL涉及的对象分区表&lt;/li&gt;
&lt;li&gt;使用了并行查询或者并行DML&lt;/li&gt;
&lt;li&gt;使用了星型连接&lt;/li&gt;
&lt;li&gt;使用了哈希连接&lt;/li&gt;
&lt;li&gt;使用了索引快速全扫描&lt;/li&gt;
&lt;li&gt;使用了函数索引&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些情况总结来自《基于Oracle的SQL优化一书》&lt;/p&gt;
&lt;p&gt;虽然Oracle针对上述情况都开启了强制CBO，但是我们还是可以手动解决的，方法也是来自《基于Oracle的SQL优化一书》，作者提供了改写等价sql的方法，比如在sql的where条件中对number或者date类型的列加0，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from 表格 where a+0&amp;gt;参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是varchar2类型的，加可以加个空字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from 表格 where a || '' = 参数&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于成本的优化器&quot;&gt;2.3 基于成本的优化器&lt;/h3&gt;
&lt;h4 id=&quot;cbo简介&quot;&gt;2.3.1 CBO简介&lt;/h4&gt;
&lt;p&gt;介绍一下基于成本的优化器(Cost-Based Optimization)：基于成本的优化器简称是CBO，在SQL执行过程，会缓存执行的一些信息到Oracle的数据字典里，这里的信息就有sql执行路径的I/O、网络资源、CPU的使用情况，其实这个就是SQL的执行成本，也是按照这个成本来确定执行计划。所以CBO概念就是根据I/O、网络资源、CPU的使用情况来确定SQL执行路径也可以说是执行计划的优化器。&lt;/p&gt;
&lt;h4 id=&quot;集的势&quot;&gt;2.3.2 集的势&lt;/h4&gt;
&lt;p&gt;集的势(Cardinality)是CBO特有的概念，集的势指结果集的行数。引入这个概念是为了表示SQL执行成本值，Cardinality越大，也就是说sql执行返回的结果集所包含的行数就越多，也说明成本越大。&lt;/p&gt;
&lt;h4 id=&quot;可选择率&quot;&gt;2.3.3 可选择率&lt;/h4&gt;
&lt;p&gt;可选择率(Selectivity)：指施加指定谓语条件后返回结果集的记录数占未施加任何谓语条件的原始结果集的记录数的比率。可选择率的范围是0~1,它的值越小，说明可选择性越好，值越大说明可选择性越差，也就是成本值越大。可选择率为1时性能是最差的。&lt;/p&gt;
&lt;p&gt;可选择率 = 施加指定谓语条件后返回结果集的记录数/未施加任何谓语条件的原始结果集的记录数。&lt;/p&gt;
&lt;h2 id=&quot;三优化器优化模式&quot;&gt;三、优化器优化模式&lt;/h2&gt;
&lt;h3 id=&quot;优化器优化模式分类&quot;&gt;3.1 优化器优化模式分类&lt;/h3&gt;
&lt;p&gt;优化器优化模式分为Rule、Choose、First rows、All rows&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Rule：就是基于规则Rule的方式&lt;/li&gt;
&lt;li&gt;Choose：当一个表或索引有统计信息,则走CBO的方式,如果表或索引没统计信息,表又不是特别的小,而且相应的列有索引时,那么就走索引,走RBO的方式。这是Oracle的默认方式&lt;/li&gt;
&lt;li&gt;First rows：与Choose方式是类似的,所不同的是当一个表有统计信息时,它将是以最快的方式返回查询的最先的几行,从总体上减少了响应时间。&lt;/li&gt;
&lt;li&gt;All rows：其实就是基于Cost方式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优化模式使用方法&quot;&gt;3.2 优化模式使用方法&lt;/h3&gt;
&lt;p&gt;要修改优化模式可以使用类似SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter session set optimizer_mode='RULE';&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 18 Feb 2019 16:07:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>[TOC] 在看《基于Oracle的SQL优化一书》知道了很多专业名称，做了记录，CBO、优化器、查询转换、执行计划、Hint、并行、游标、绑定变量、统计信息、直方图、索引等等。这篇博客可以说是读书笔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10398701.html</dc:identifier>
</item>
<item>
<title>Springboot 系列（四）Spring Boot 日志框架 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10398595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10398595.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：本 Spring Boot 系列文章基于 Spring Boot 版本 &lt;strong&gt;v2.1.1.RELEASE&lt;/strong&gt; 进行学习分析，版本不同可能会有细微差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-caddee2a901aa899.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Spring 框架选择使用了 JCL 作为默认日志输出。而 Spring Boot 默认选择了 SLF4J 结合 LogBack。那我们在项目中该使用哪种日志框架呢？在对于不同的第三方 jar 使用了不同的日志框架的时候，我们该怎么处理呢？&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志框架介绍&quot;&gt;1. 日志框架介绍&lt;/h2&gt;
&lt;p&gt;日志对于应用程序的重要性不言而喻，不管是记录运行情况还是追踪线上问题，都离不开对日志的分析，在 Java 领域里存在着多种日志框架，如 JUL, Log4j, Log4j2, Commons Loggin, Slf4j, Logback 等。关于 Log4j, Log4j2 和 Slf4j 直接的故事这里不做介绍，有兴趣可以自行百度。&lt;/p&gt;
&lt;h2 id=&quot;slf4-的使用&quot;&gt;2. SLF4 的使用&lt;/h2&gt;
&lt;p&gt;在开发的时候不应该直接使用日志实现类，应该使用日志的抽象层。具体参考 &lt;a href=&quot;https://www.slf4j.org/manual.html&quot;&gt;SLF4J 官方&lt;/a&gt;。&lt;br/&gt;下图是 SLF4J 结合各种日志框架的官方示例，从图中可以清晰的看出 SLF4J API 永远作为日志的门面，直接应用与应用程序中。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2626549-fc7062c793f03993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SLF4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时 SLF4 官方给出了简单示例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info(&quot;Hello World&quot;);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，要为系统导入 SLF4J 的 jar 和 日志框架的实现 jar. 由于每一个日志的实现框架都有自己的配置文件，所以在使用 SLF4 之后，配置文件还是要使用实现日志框架的配置文件。&lt;/p&gt;
&lt;h2 id=&quot;统一日志框架的使用&quot;&gt;3. 统一日志框架的使用&lt;/h2&gt;
&lt;p&gt;一般情况下，在项目中存在着各种不同的第三方 jar ，且它们的日志选择也可能不尽相同，显然这样是不利于我们使用的，那么如果我们想为项目设置统一的日志框架该怎么办呢？&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.slf4j.org/legacy.html&quot;&gt;SLF4J 官方&lt;/a&gt;，也给了我们参考的例子。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://www.slf4j.org/images/legacy.png&quot; alt=&quot;Bridging legacy APIs&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从图中我们得到一种统一日志框架使用的方式，可以使用一种和要替换的日志框架类完全一样的 jar 进行替换，这样不至于原来的第三方 jar 报错，而这个替换的 jar 其实使用了 SLF4J API. 这样项目中的日志就都可以通过 SLF4J API 结合自己选择的框架进行日志输出。&lt;br/&gt;&lt;strong&gt;统一日志框架使用步骤归纳如下&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;排除系统中的其他日志框架。&lt;/li&gt;
&lt;li&gt;使用中间包替换要替换的日志框架。&lt;/li&gt;
&lt;li&gt;导入我们选择的 SLF4J 实现。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;spring-boot-的日志关系&quot;&gt;4. Spring Boot 的日志关系&lt;/h2&gt;
&lt;h3 id=&quot;排除其他日志框架&quot;&gt;4.1. 排除其他日志框架&lt;/h3&gt;
&lt;p&gt;根据上面总结的要统一日志框架的使用，第一步要排除其他的日志框架，在 Spring Boot 的 Maven 依赖里可以清楚的看到 Spring Boot 排除了其他日志框架。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-a5ad6deebf7c7cc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring Boot 排除其他日志框架&quot;/&gt;&lt;/div&gt;
我们自行排除依赖时也只需要按照图中的方式就好了。
&lt;h3 id=&quot;统一框架引入替换包&quot;&gt;4.2. 统一框架引入替换包&lt;/h3&gt;
&lt;p&gt;其实 Spring Boot 也是使用了 SLF4J+logback 的日志框架组合，查看 Spring Boot 项目的 Maven 依赖关系可以看到 Spring Boot 的核心启动器 spring-boot-starter 引入了 spring-boot-starter-logging.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 spring-boot-starter-logging 的 Maven 依赖主要引入了 logback-classic (包含了日志框架 Logback 的实现)，log4j-to-slf4j (在 log4j 日志框架作者开发此框架的时候还没有想到使用日志抽象层进行开发，因此出现了 log4j 向 slf4j 转换的工具)，jul-to-slf4j ( Java 自带的日志框架转换为 slf4j).&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;log4j-to-slf4j&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.11.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的分析，Spring Boot 对日志框架的使用已经是清晰明了了，我们使用 IDEA 工具查看 Maven 依赖关系，可以清晰的看到日志框架的引用。如果没有 IDEA 工具，也可以使用 Maven 命令查看依赖关系。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mvn dependency:tree&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26371673/50733360-33660980-11c7-11e9-8742-1f24e7449db2.png&quot; alt=&quot;Spring Boot Maven 依赖&quot;/&gt;&lt;/div&gt;
&lt;p&gt;由此可见，Spring Boot 可以自动的适配日志框架，而且底层使用 &lt;strong&gt;SLF4 + LogBack&lt;/strong&gt; 记录日志，如果我们自行引入其他框架，需要排除其日志框架。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-的日志使用&quot;&gt;5. Spring Boot 的日志使用&lt;/h2&gt;
&lt;h3 id=&quot;日志级别和格式&quot;&gt;5.1. 日志级别和格式&lt;/h3&gt;
&lt;p&gt;从上面的分析，发现 Spring Boot 默认已经使用了 &lt;strong&gt;SLF4J + LogBack&lt;/strong&gt; . 所以我们在不进行任何额外操作的情况下就可以使用 &lt;strong&gt;SLF4J + Logback&lt;/strong&gt; 进行日志输出。&lt;br/&gt;编写 Java 测试类进行测试。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.junit.Test;
import org.junit.runner.RunWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * &amp;lt;p&amp;gt;
 * 测试日志输出，
 * SLF4J 日志级别从小到大trace,debug,info,warn,error
 *
 * @Author niujinpeng
 * @Date 2018/12/11 21:12
 */
@RunWith(SpringRunner.class)
@SpringBootTest
public class LogbackTest {
    
    Logger logger = LoggerFactory.getLogger(getClass());

    @Test
    public void testLog() {
        logger.trace(&quot;Trace 日志...&quot;);
        logger.debug(&quot;Debug 日志...&quot;);
        logger.info(&quot;Info 日志...&quot;);
        logger.warn(&quot;Warn 日志...&quot;);
        logger.error(&quot;Error 日志...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;已知日志级别从小到大为 trace &amp;lt; debug &amp;lt; info &amp;lt; warn &amp;lt; error . 运行得到输出如下。由此可见 &lt;strong&gt;&lt;em&gt;Spring Boot 默认日志级别为 INFO&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;2018-12-11 23:02:58.028 [main] INFO  n.c.boot.LogbackTest - Info 日志...
2018-12-11 23:02:58.029 [main] WARN  n.c.boot.LogbackTest - Warn 日志...
2018-12-11 23:02:58.029 [main] ERROR n.c.boot.LogbackTest - Error 日志...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的日志结合 Logback 日志格式可以知道 Spring Boot 默认日志格式是。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
# %d{yyyy-MM-dd HH:mm:ss.SSS} 时间
# %thread 线程名称
# %-5level 日志级别从左显示5个字符宽度
# %logger{50} 类名
# %msg%n 日志信息加换行&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于为什么 Spring Boot 的默认日志输出格式是这样？&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-4b5ae9e8632c808f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring Boot 默认日志输出&quot;/&gt;&lt;/div&gt;
我们可以在 Spring Boot 的源码里找到答案。
&lt;h3 id=&quot;自定义日志输出&quot;&gt;5.2 自定义日志输出&lt;/h3&gt;
&lt;p&gt;可以直接在配置文件编写日志相关配置。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 日志配置
# 指定具体包的日志级别
logging.level.net.codingme=debug
# 控制台和日志文件输出格式
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
# 日志文件大小
logging.file.max-size=10MB
# 保留的日志时间
logging.file.max-history=10
# 日志输出路径，默认文件spring.log
logging.path=systemlog
#logging.file=log.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于日志的输出路径，可以使用 logging.file 或者 logging.path 进行定义，两者存在关系如下表。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;em&gt;（没有）&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;（没有）&lt;/em&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;仅控制台记录。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;具体文件&lt;/td&gt;
&lt;td&gt;&lt;em&gt;（没有）&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;my.log&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入指定的日志文件，名称可以是精确位置或相对于当前目录。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;（没有）&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;具体目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/var/log&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入&lt;code&gt;spring.log&lt;/code&gt;指定的目录，名称可以是精确位置或相对于当前目录。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;替换日志框架&quot;&gt;6. 替换日志框架&lt;/h2&gt;
&lt;p&gt;因为 Log4j 日志框架已经年久失修，原作者都觉得写的不好，所以下面演示替换日志框架为 Log4j2 的方式。根据&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.x/reference/html/using-boot-build-systems.html#using-boot-starter&quot;&gt;官网&lt;/a&gt;我们 Log4j2 与 logging 需要二选一，因此修改 pom如下。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章代码已经上传到 GitHub &lt;a href=&quot;https://github.com/niumoo/springboot/tree/master/springboot-logback&quot;&gt;Spring Boot 日志系统&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:50:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>注意：本 Spring Boot 系列文章基于 Spring Boot 版本 v2.1.1.RELEASE 进行学习分析，版本不同可能会有细微差别。 前言 Spring 框架选择使用了 JCL 作为默</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10398595.html</dc:identifier>
</item>
<item>
<title>SpringMvc @RequestParam 使用推荐使用包装类型代替包装类型 - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10398652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10398652.html</guid>
<description>&lt;p&gt;SpringMvc 中@RequestParam注解使用 &lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;建议使用包装类型来代替基本数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;public String form2(&lt;span&gt;@RequestParam(name=&lt;span&gt;&quot;age&quot;) &lt;span&gt;int age){&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　&lt;span&gt;public String form2(&lt;span&gt;@RequestParam(name=&lt;span&gt;&quot;age&quot;) Integer age) {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上述两种方式 这种情况下使用起来基本没有差别，但是为什么要说建议使用包装类型而不是基本类型呢？&lt;/p&gt;

&lt;h2&gt;一.@RequestParam属性作用&lt;/h2&gt;
&lt;p&gt;因为当@RequestParam注解 required 属性(默认为true，代表该参数在请求中必不可少) 设置为false时，判断的标准是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if (arg == &lt;span&gt;null) {&lt;br/&gt;&lt;span&gt;if (namedValueInfo.&lt;span&gt;defaultValue != &lt;span&gt;null) {&lt;br/&gt;arg = resolveStringValue(namedValueInfo.&lt;span&gt;defaultValue);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else if (namedValueInfo.&lt;span&gt;required &amp;amp;&amp;amp; !nestedParameter.isOptional()) {&lt;br/&gt;handleMissingValue(namedValueInfo.&lt;span&gt;name, nestedParameter, webRequest);&lt;br/&gt;}&lt;br/&gt;arg = handleNullValue(namedValueInfo.&lt;span&gt;name, arg, nestedParameter.getNestedParameterType());&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else if (&lt;span&gt;&quot;&quot;.equals(arg) &amp;amp;&amp;amp; namedValueInfo.&lt;span&gt;defaultValue != &lt;span&gt;null) {&lt;br/&gt;arg = resolveStringValue(namedValueInfo.&lt;span&gt;defaultValue);&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码为Spring &lt;span&gt;AbstractNamedValueMethodArgumentResolver 的 resolveArgument&lt;/span&gt; 方法，顾名思义就是&lt;span&gt;解析请求中参数并完成类型转换的方法&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　  arg 是从请求中获取的对应参数值，调用 request.getParameterValues(name) ；&lt;/p&gt;
&lt;p&gt;         当arg==null时，意味着请求中不包含该参数(即请求中不包含age参数)，@RequestParam的defaultValue不为空 那就使用 defaultValue作为请求中的参数， &lt;/p&gt;
&lt;p&gt;         但是required为true且默认值为null，就会执行&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;handleMissingValue&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;抛出异常，请求中缺少对应参数 ；&lt;/p&gt;
&lt;p&gt;　　  两种逻辑都没有执行就代表required为 false 且 默认值为 null ，这时候就会抛出另外一种异常，&lt;span&gt;java.lang.IllegalStateException: Optional int parameter 'age' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  查看异常说明，age参数存在但是无法转为null类型，因为age被定义为基本数据类型了，建议把它声明为对应的包装类型；&lt;/p&gt;
&lt;p&gt;　　但是八种基本数据类型测试的时候， 就是 布尔类型 boolean，代码原因如下：&lt;/p&gt;
&lt;p&gt;　　　　可以看到Spring的解析当方法入参为boolean类型时候，直接返回Boolean.FALSE，但是其他七个基本数据类型就抛出异常了；&lt;/p&gt;
&lt;p&gt;　　（补充一句，Spring mvc:annotation-driven使用的情况下，比如请求中传入属性需要赋给布尔值，该属性值为 true  1  on yes这四个都可以赋给boolean类型的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Object handleNullValue(String name, Object value, Class&amp;lt;?&amp;gt;&lt;span&gt; paramType) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Boolean.TYPE.equals(paramType)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Boolean.FALSE;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (paramType.isPrimitive()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Optional &quot; + paramType.getSimpleName() + &quot; parameter '&quot; + name +
                        &quot;' is present but cannot be translated into a null value due to being declared as a &quot; +
                        &quot;primitive type. Consider declaring it as object wrapper for the corresponding primitive type.&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 二.@RequestParam使用情形列举&lt;/h2&gt;
&lt;p&gt;简而言之@RequestParam使用如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;@RequestParam  name必须存在的情况&lt;/td&gt;
&lt;td&gt;           defaultValue存在&lt;/td&gt;
&lt;td&gt;             defaultValue不存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;required为true&lt;/td&gt;
&lt;td&gt;请求中存在该参数     按照该参数来传递&lt;/td&gt;
&lt;td&gt;请求中存在该参数     按照该参数来传递&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;请求中不存在该参数  使用默认值来传递&lt;/td&gt;
&lt;td&gt;请求中不存在该参数  抛出缺少参数异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;required为false&lt;/td&gt;
&lt;td&gt;请求中存在该参数     按照该参数来传递&lt;/td&gt;
&lt;td&gt;请求中存在该参数     按照该参数来传递&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;请求中不存在该参数  使用默认值来传递&lt;/td&gt;
&lt;td&gt;请求中不存在该参数  使用null来传递&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　　&lt;span&gt;总结就是请求中包含参数信息，就使用请求中的参数；使用默认值的情况除上图两种以外，比如请求中值为空字符串&quot;&quot; 且 defaultValue不为null，那也是用DefaultValue；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 三.@RequestParam出现两种异常原因解析&lt;/h2&gt;
&lt;p&gt;Spring @RequestParam中可能抛出两种异常原因解释：&lt;/p&gt;
&lt;p&gt;　　异常一.  Required int parameter 'age' is not present&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1550387/201902/1550387-20190218233501076-368538552.png&quot; alt=&quot;&quot; width=&quot;1075&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　  异常原因：required为true  且 请求中不包含 对应的参数 ；&lt;/p&gt;

&lt;p&gt;　　异常二.Optional int parameter 'age' is present but cannot be translated into a null value due to being declared as a primitive type.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1550387/201902/1550387-20190218233703569-1350730742.png&quot; alt=&quot;&quot; width=&quot;1230&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　异常原因：required为false 且 defaultValue不存在  且 参数类型为基本数据类型；&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>SpringMvc 中@RequestParam注解使用 建议使用包装类型来代替基本数据类型 public String form2(@RequestParam(name=&quot;age&quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10398652.html</dc:identifier>
</item>
<item>
<title>分享基于 websocket 网页端聊天室 - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/10398665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/10398665.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/67&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/67&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一个月没有写博客了，也是因为年前需求多、回家过春节的原因，现在返回北京的第二天，想想，应该也要分享技术专题的博客了！！&lt;/p&gt;
&lt;h2 id=&quot;主题&quot;&gt;主题&lt;/h2&gt;
&lt;p&gt;基于 websocket 网页端聊天室&lt;/p&gt;
&lt;p&gt;WebSocket 协议是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工 (full-duplex) 通信——允许服务器主动发送信息给客户端。&lt;/p&gt;
&lt;p&gt;使用 java 开发后台&lt;/p&gt;
&lt;p&gt;需要导入一个jar包：javax.websocket-api-1.0-rc4.jar&lt;/p&gt;
&lt;h2 id=&quot;后台代码&quot;&gt;后台代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.krry.socket;
import java.io.IOException;
import java.util.concurrent.CopyOnWriteArraySet;
 
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
 
//该注解用来指定一个URI，客户端可以通过这个URI来连接到WebSocket。类似Servlet的注解mapping。无需在web.xml中配置。
@ServerEndpoint(&quot;/websocket&quot;)
public class MyWebSocket {
    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;
     
    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识
    private static CopyOnWriteArraySet&amp;lt;MyWebSocket&amp;gt; webSocketSet = new CopyOnWriteArraySet&amp;lt;MyWebSocket&amp;gt;();
     
    //与某个客户端的连接会话，需要通过它来给客户端发送数据
    private Session session;
     
    /**
     * 连接建立成功调用的方法
     * @param session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据
     */
    @OnOpen
    public void onOpen(Session session){
        this.session = session;
        webSocketSet.add(this);     //加入set中
        addOnlineCount();           //在线数加1
        System.out.println(&quot;有新连接加入！当前在线人数为&quot; + getOnlineCount());
    }
     
    /**
     * 连接关闭调用的方法
     */
    @OnClose
    public void onClose(){
        webSocketSet.remove(this);  //从set中删除
        subOnlineCount();           //在线数减1    
        System.out.println(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());
    }
     
    /**
     * 收到客户端消息后调用的方法
     * @param message 客户端发送过来的消息
     * @param session 可选的参数
     */
    @OnMessage
    public void onMessage(String message, Session session) {
        System.out.println(&quot;来自客户端的消息:&quot; + message);
         
        //群发消息
        for(MyWebSocket item: webSocketSet){             
            try {
                item.sendMessage(message);
            } catch (IOException e) {
                e.printStackTrace();
                continue;
            }
        }
    }
     
    /**
     * 发生错误时调用
     * @param session
     * @param error
     */
    @OnError
    public void onError(Session session, Throwable error){
        System.out.println(&quot;发生错误&quot;);
        error.printStackTrace();
    }
     
    /**
     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。
     * @param message
     * @throws IOException
     */
    public void sendMessage(String message) throws IOException{
        this.session.getBasicRemote().sendText(message);
        //this.session.getAsyncRemote().sendText(message);
    }
 
    public static synchronized int getOnlineCount() {
        return onlineCount;
    }
 
    public static synchronized void addOnlineCount() {
        MyWebSocket.onlineCount++;
    }
     
    public static synchronized void subOnlineCount() {
        MyWebSocket.onlineCount--;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;前端代码&quot;&gt;前端代码&lt;/h2&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;前端需要实现这几个方法：&lt;/p&gt;
&lt;pre class=&quot;jsp&quot;&gt;
&lt;code&gt;  // 注册事件
  // 监听打开连接
  ws.onopen = function(){
    openWs();
  };
  // 监听消息
  ws.onmessage = function(event){
    msgWs(event);
  };
  // 监听关闭连接
  ws.onclose = function(){
    closeWs();
  };
  // 监听发送错误
  ws.onerror = function(){
    errorWs();
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;具体代码&quot;&gt;具体代码&lt;/h3&gt;
&lt;pre class=&quot;jsp&quot;&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&amp;gt;
&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  
  &amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;keywords&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;meta name=&quot;description&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;title&amp;gt;
      基于Java服务器端的消息主动推送技术揭秘 --krry
    &amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/animate.css&quot; /&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/sg.css&quot; /&amp;gt;
    &amp;lt;style&amp;gt;
      *{margin:0;padding:0;} body{background:url(&quot;images/5.jpg&quot;);background-size:cover;}
      h1{margin-top:50px;text-align:center;color:#fff;text-shadow:1px 1px 1px
      #000;font-family:-webkit-body;font-size:24px;} .box{width:700px;margin:20px
      auto;} .box span{color:#f60;font-size:16px;font-family:&quot;微软雅黑&quot;;} .box .shu{text-indent:1em;height:24px;font-family:&quot;微软雅黑&quot;;border:0;outline:none;font-size:14px;}
      .box .add{width:300px;margin-right:24px;} .box .user{width:200px;} .box
      .btn{width:80px;height:34px;color:#fff;background:#6c0;border:0;outline:none;cursor:pointer;margin-top:20px;font-size:16px;font-family:&quot;微软雅黑&quot;;}
      .box .area{line-height: 29px;height:280px;width:680px;padding:10px;overflow:auto;font-size:16px;font-family:&quot;微软雅黑&quot;;margin:20px
      0;outline:none;box-shadow:1px 2px 18px #000} .box .setex{text-indent:1em;height:28px;border:1px
      solid #6c0;width:618px;outline:none;float:left;font-family:&quot;微软雅黑&quot;;} .box
      .send{font-size:14px;width:80px;height:30px;color:#fff;background:#6c0;border:0;outline:none;cursor:pointer;font-family:&quot;微软雅黑&quot;;}
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;
      基于Java服务器端的消息主动推送技术揭秘 --krry
    &amp;lt;/h1&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
      &amp;lt;span&amp;gt;
        服务器地址：
      &amp;lt;/span&amp;gt;
      &amp;lt;input type=&quot;text&quot; class=&quot;shu add&quot; value=&quot;www.ainyi.com/krry_NetChat/websocket&quot;
      readonly/&amp;gt;
      &amp;lt;span&amp;gt;
        用户名：
      &amp;lt;/span&amp;gt;
      &amp;lt;input type=&quot;text&quot; class=&quot;shu user&quot; value=&quot;匿名&quot; /&amp;gt;
      &amp;lt;input type=&quot;button&quot; value=&quot;连接&quot; class=&quot;btn&quot; /&amp;gt;
      &amp;lt;div class=&quot;area&quot; id=&quot;boxx&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;c_cen&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; class=&quot;setex&quot; /&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;发送&quot; class=&quot;send&quot;&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;js/jquery-1.11.1.min.js&quot;&amp;gt;
    &amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/sg.js&quot;&amp;gt;
    &amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/sgutil.js&quot;&amp;gt;
    &amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      var close = true;
      var ws;
      $(function() {
        $(&quot;.c_cen&quot;).hide();
        //首先判断浏览器是否支持webSocket，支持h5的浏览器才会支持
        if (window.WebSocket) {
          printMsg(&quot;您的浏览器支持WebSocket，您可以尝试连接到聊天服务器！&quot;, &quot;OK&quot;);
        } else {
          printMsg(&quot;您的浏览器不支持WebSocket，请选择其他浏览器！&quot;, &quot;ERROR&quot;);
          //设置按钮不可点击
          $(&quot;.btn&quot;).attr(&quot;disabled&quot;, &quot;true&quot;);
        }
      });
      //打印信息
      function printMsg(msg, msgType) {
        if (msgType == &quot;OK&quot;) {
          msg = &quot;&amp;lt;span style='color:green'&amp;gt;&quot; + msg + &quot;&amp;lt;/span&amp;gt;&quot;;
        }
        if (msgType == &quot;ERROR&quot;) {
          msg = &quot;&amp;lt;span style='color:red'&amp;gt;&quot; + msg + &quot;&amp;lt;/span&amp;gt;&quot;;
        }
        $(&quot;.area&quot;).append(msg + &quot;&amp;lt;br/&amp;gt;&quot;);
        var boxx = document.getElementById(&quot;boxx&quot;);
        boxx.scrollTop = boxx.scrollHeight; //使滚动条一直在底部
      }

      //打开Socket
      function openWs() {
        printMsg(&quot;链接已建立&quot;, &quot;OK&quot;);
        ws.send(&quot;【&quot; + $(&quot;.user&quot;).val() + &quot;】已进入聊天室&quot;);
        $(&quot;.c_cen&quot;).show();
      }

      //接收消息的时候
      function msgWs(e) {
        printMsg(e.data);
      }
      //关闭连接
      function closeWs() {
        $(&quot;.btn&quot;).val(&quot;连接&quot;);
        $(&quot;.c_cen&quot;).hide();
      }
      //产生错误
      function errorWs() {
        printMsg(&quot;您与服务器连接错误...&quot;, &quot;ERROR&quot;);
      }

      //点击发送按钮
      $(&quot;.send&quot;).click(function() {
        var text = $(&quot;.setex&quot;).val();
        if (text == null || text == &quot;&quot;) return;
        $(&quot;.setex&quot;).val(&quot;&quot;);
        ws.send(&quot;【&quot; + $(&quot;.user&quot;).val() + &quot;】：&quot; + text);
      });

      //点击连接
      $(&quot;.btn&quot;).click(function() {
        if ($(&quot;.add&quot;).val() &amp;amp;&amp;amp; $(&quot;.user&quot;).val()) {
          if (close) {
            printMsg(&quot;正在准备连接服务器，请稍等...&quot;);
            var url = &quot;wss://&quot; + $(&quot;.add&quot;).val();
            if (&quot;WebSocket&quot; in window) {
              ws = new WebSocket(url);
            } else if (&quot;MozWebSocket&quot; in window) {
              ws = new MozWebSocket(url);
            }
            //已连接
            $(&quot;.btn&quot;).val(&quot;断开&quot;);
            close = false;

            //注册事件
            ws.onopen = function() {
              openWs();
            };
            ws.onmessage = function(event) {
              msgWs(event);
            };
            ws.onclose = function() {
              closeWs();
            };
            ws.onerror = function() {
              errorWs();
            };

            //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
            window.onbeforeunload = function() {
              ws.send(&quot;【&quot; + $(&quot;.user&quot;).val() + &quot;】离开了聊天室&quot;);
              close = true;
              ws.close();
            };

          } else {
            ws.send(&quot;【&quot; + $(&quot;.user&quot;).val() + &quot;】离开了聊天室&quot;);
            close = true;
            ws.close();
          }
        } else {
          $.tmDialog.alert({
            open: &quot;left&quot;,
            content: &quot;服务器地址和用户名不能为空哦...&quot;,
            title: &quot;提示哦~~~&quot;
          });
        }
      });

      //回车键
      $(&quot;.setex&quot;).keypress(function(event) {
        if (event.keyCode == 13) {
          $(&quot;.send&quot;).trigger(&quot;click&quot;);
        }
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里大功告成&lt;/p&gt;
&lt;h2 id=&quot;聊天方法&quot;&gt;聊天方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;打开两个窗口输入项目地址进行聊天&lt;/li&gt;
&lt;li&gt;可以把链接发给朋友打开，进行聊天&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;来一波截图&quot;&gt;来一波截图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/w_1.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/w_2.jpeg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;移动端&quot;&gt;移动端&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/w_3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/WORK-LEARNING/master/images/w_4.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在线演示&quot;&gt;在线演示&lt;/h2&gt;
&lt;p&gt;PC 端：&lt;a href=&quot;https://www.ainyi.com/krry_NetChat&quot; class=&quot;uri&quot;&gt;https://www.ainyi.com/krry_NetChat&lt;/a&gt;&lt;br/&gt;移动端：&lt;a href=&quot;https://www.ainyi.com/krry_NetChatPho&quot; class=&quot;uri&quot;&gt;https://www.ainyi.com/krry_NetChatPho&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打完收工~&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/67&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/67&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:43:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址： 'https://ainyi.com/ /67' 有一个月没有写博客了，也是因为年前需求多、回家过春节的原因，现在返回北京的第二天，想想，应该也要分享技术专题的博客了！！ 主题 基于 we</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/10398665.html</dc:identifier>
</item>
<item>
<title>陪你解读Spring Batch（一）Spring Batch介绍 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10398535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10398535.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　整个章节由浅入深了解Spring Batch，让你掌握批处理利器。面对大批量数据毫无惧色。本章只做介绍，后面章节有代码示例。好了，接下来是我们的主角Spring Batch。&lt;/p&gt;

&lt;h2&gt;1.1 背景介绍&lt;/h2&gt;
&lt;h3&gt;1.1.1 诞生&lt;/h3&gt;
&lt;p&gt;　　开源社区一直把大部分注意力集中在web和SOA框架中，基于java的批处理框架确很少，因此一个标准的、可重用的批处理框架对我们来说很重要。先来说一下什么是批处理？在企业应用时，需要定期或者人工触发的读入大批量数据，然后完成相应的业务处理并进行归档。这类工作就成为批处理。&lt;/p&gt;
&lt;p&gt;　　SpringSource和Accenture致力于通过合作来解决这种状况，Accenture在实现批处理架构上有着丰富的产业实践经验，SpringSource则有深厚的技术开发经验，两者成为强大的合作伙伴，创造出高质量的、市场认可的企业级java解决方案。因此诞生了Spring Batch&lt;/p&gt;
&lt;h3&gt;1.1.2 为什么使用它？&lt;/h3&gt;
&lt;p&gt;　　Spring Batch作为Spring的子项目，是一款轻量级的综合批处理框架，通过它可以构建出壮健的企业级批处理应用，因为基于Spring，所以开发者十分容易上手使用。SpringBatch不仅提供了统一的读写接口、丰富的任务处理方式、可重用的功能，还包括了日志，事务管理，任务统计、弹性处理等功能。使开发人员可以更多的关注业务处理过程。&lt;/p&gt;
&lt;p&gt;　　Spring Batch不是一个调度框架，因为已经有非常好的企业级调度框架包括Quartz等，它只注重任务处理相关问题，如执行任务、事务、并发等，而不是提供调度功能。它是为了和调度程序一起完成任务而设计的。比如我们希望定期的执行大批量数据任务，那么可结合Quartz等来实现。&lt;/p&gt;
&lt;h3&gt;1.1.3 应用场景&lt;/h3&gt;
&lt;p&gt;　　大量文件处理是比较常见的企业级应用场景，比如你要做聚合支付，那么必定会有聚合账单，如果每天有百万甚至千万级别的交易数据。那么将如何处理呢？如何进行海量数据的对账成了难题。或者每天需要处理其他业务场景的大数据量的文件，最后将处理好的数据写入数据库中。&lt;/p&gt;
&lt;p&gt;　　其实可以先不用想Spring Batch，如果没有，我们如何开发？这里就需要一个框架需要以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持对多种数据源进行操作&lt;/li&gt;
&lt;li&gt;能够定义不同job之间的顺序关系&lt;/li&gt;
&lt;li&gt;能够定义每个job的输入和输出数据操作&lt;/li&gt;
&lt;li&gt;对异常输入数据有校验机制和弹性处理&lt;/li&gt;
&lt;li&gt;支持job重跑等处理机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这不就是一个批处理框架需要的基础功能吗？&lt;/p&gt;

&lt;h2&gt;1.2 Spring Batch架构&lt;/h2&gt;
&lt;h3&gt;1.2.1 框架层次&lt;/h3&gt;
&lt;p&gt;　　Spring Batch分三层，应用层，核心层和基础架构层。&lt;/p&gt;
&lt;p&gt;　　应用层：开发人员使用Spring Batch编写的所有批处理任务代码&lt;/p&gt;
&lt;p&gt;　　核心层：包含加载和控制批处理作业所需的核心类，Job，Step等类的实现&lt;/p&gt;
&lt;p&gt;　　基础架构层：包含通用的读写器和重试模块　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218231412276-527792233.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;510&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2.2 概念模型　　&lt;/h3&gt;
&lt;p&gt;　　下图显示了完整的概念模型，JobLauncher启动Job，Job可以有多个Step组合，每一个Step由开发者自己编写，可一把一个大Step分成多个小Step，完全看开发者意愿。每一个Step对应一个ItemReader、ItemProcessor和ItemWriter。所有的批处理框架都可以抽象成最简单的过程，读取数据，处理数据，写数据。所以Spring Batch提供了3个接口，ItemReader、ItemProcessor和ItemWriter。JobRepository则是记录Job、Step和发起Job的执行信息等。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218232049040-793474258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图为处理流程，reader读，processor处理校验数据，writer写数据（入参是list，减少io次数）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218232355643-908833388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.3 处理原则&lt;/h2&gt;
&lt;p&gt;　　下面是一些处理原则，可参考&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量使用公用模块&lt;/li&gt;
&lt;li&gt;尽量简化操作，不要有复杂的业务逻辑。更不要处理一条数据还要调外部接口进行数据加工&lt;/li&gt;
&lt;li&gt;尽可能少的IO操作&lt;/li&gt;
&lt;li&gt;同一个批处理文件不要处理2次&lt;/li&gt;
&lt;li&gt;尽可能压力测试&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 整个章节由浅入深了解Spring Batch，让你掌握批处理利器。面对大批量数据毫无惧色。本章只做介绍，后面章节有代码示例。好了，接下来是我们的主角Spring Batch。 1.1 背景介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10398535.html</dc:identifier>
</item>
</channel>
</rss>