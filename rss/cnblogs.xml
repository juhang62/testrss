<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>pom文件信息的解析 - 泽国江山入战图</title>
<link>http://www.cnblogs.com/code12306/p/10117261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code12306/p/10117261.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.forezp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-world&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-world&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo project for Spring Boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pom.xml文件的信息解析：&lt;/p&gt;
&lt;p&gt;1.第一行指定了xml的版本号和编码方式。&lt;/p&gt;
&lt;p&gt;2.project的标签是改文件的根元素，它声明pom相关的命名空间。&lt;/p&gt;
&lt;p&gt;3.modelVersion指定pom的版本。&lt;/p&gt;
&lt;p&gt;4.groupId代表了公司、组织的名称，一般为公司域名的倒写。&lt;/p&gt;
&lt;p&gt;5.artifactId代表了该项目的全局唯一Id。&lt;/p&gt;
&lt;p&gt;6.version代表了该项目的版本号。&lt;/p&gt;
&lt;p&gt;7.parent标签用于指定父pom。&lt;/p&gt;
&lt;p&gt;8.properties标签用于声明一些常量。&lt;/p&gt;
&lt;p&gt;9.dependencies标签为依赖的根元素，里面可以包含多个dependency元素。&lt;/p&gt;
&lt;p&gt;10.build为构建标签，它可以包含plugins（插件）标签，plugins标签中可以包含若干个plugin标签，可以根据项目的需求添加相应的plugin。&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 15:54:00 +0000</pubDate>
<dc:creator>泽国江山入战图</dc:creator>
<og:description>pom.xml文件的信息解析： 1.第一行指定了xml的版本号和编码方式。 2.project的标签是改文件的根元素，它声明pom相关的命名空间。 3.modelVersion指定pom的版本。 4.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code12306/p/10117261.html</dc:identifier>
</item>
<item>
<title>MyBatis开发Dao层的两种方式（Mapper动态代理方式） - 谢亚峰</title>
<link>http://www.cnblogs.com/xyfer1018/p/10117227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyfer1018/p/10117227.html</guid>
<description>&lt;p&gt;　　MyBatis开发原始Dao层请阅读我的上一篇博客：&lt;a title=&quot;MyBatis开发Dao层的两种方式（原始Dao层开发）&quot; href=&quot;https://www.cnblogs.com/xyfer1018/p/10111817.html%20&quot; target=&quot;_blank&quot;&gt;MyBatis开发Dao层的两种方式（原始Dao层开发）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　接上一篇博客继续介绍MyBatis开发Dao层的第二种方式：&lt;strong&gt;Mapper动态代理方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上一篇博客中Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Mapper&lt;/strong&gt;&lt;strong&gt;接口开发需要遵循以下规范：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（1）Mapper.xml文件中的namespace与mapper接口的类路径相同。&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（2）Mapper接口方法名和Mapper.xml中定义的每个statement的id相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（3）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（4）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
&lt;p&gt;　　1、定义mapper映射文件UserMapper.xml（内容同User.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下sqlmapperr目录下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.mapper.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 根据id查询用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user where id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;selectKey &lt;/span&gt;&lt;span&gt;keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; order&lt;/span&gt;&lt;span&gt;=&quot;AFTER&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select LAST_INSERT_ID() 
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;selectKey&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      insert into user(username,birthday,sex,address) 
      values(#{username},#{birthday},#{sex},#{address})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 修改用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}
        where id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 删除用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        delete from user where id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、UserMapper.java接口文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xyfer.po.User;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserMapper {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User getUserById(&lt;span&gt;int&lt;/span&gt; id);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据id值查询一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertUser(User user); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateUser(User user); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteUser(&lt;span&gt;int&lt;/span&gt; id);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除一个用户&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接口定义有如下特点：&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（1）UserMapper接口方法名和Mapper.xml中定义的statement的id相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（2）UserMapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（3） UserMapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　3、在SqlMapConfig.xml文件中加载UserMapper.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;UserMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; org.junit.Assert.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xyfer.po.User;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; junit.framework.TestCase;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserMapperTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestCase{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactory sqlSessionFactory;
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SqlSessionFactoryBuilder sessionFactoryBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
        InputStream inputStream &lt;/span&gt;= Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;&lt;span&gt;);
        sqlSessionFactory &lt;/span&gt;=&lt;span&gt; sessionFactoryBuilder.build(inputStream);
    }


    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGetUserById() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
        User user = userMapper.getUserById(10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印结果&lt;/span&gt;
&lt;span&gt;        System.out.println(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsertUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个对象&lt;/span&gt;
        User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUsername(&lt;/span&gt;&quot;小谢&quot;&lt;span&gt;);
        user.setSex(&lt;/span&gt;&quot;男&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        user.setAddress(&lt;/span&gt;&quot;浙江省杭州市&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
&lt;span&gt;        userMapper.insertUser(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdateUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个对象&lt;/span&gt;
        User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUsername(&lt;/span&gt;&quot;小谢&quot;&lt;span&gt;);
        user.setSex(&lt;/span&gt;&quot;男&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        user.setAddress(&lt;/span&gt;&quot;上海市&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
&lt;span&gt;        userMapper.updateUser(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDeleteUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
        userMapper.deleteUser(6&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上步骤，完成mybatis框架以&lt;strong&gt;Mapper动态代理方式&lt;/strong&gt;开发Dao层，并对数据库进行增删改查操作。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，上文提到的config文件夹和sqlmapper文件夹均为资源文件夹（source folder），默认会加载该路径下的文件。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>谢亚峰</dc:creator>
<og:description>MyBatis开发原始Dao层请阅读我的上一篇博客：MyBatis开发Dao层的两种方式（原始Dao层开发） 接上一篇博客继续介绍MyBatis开发Dao层的第二种方式：Mapper动态代理方式 Ma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyfer1018/p/10117227.html</dc:identifier>
</item>
<item>
<title>JavaScipt 中的事件循环机制，以及微任务 和宏任务的概念 - daisy,gogogo</title>
<link>http://www.cnblogs.com/daisygogogo/p/10116694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daisygogogo/p/10116694.html</guid>
<description>&lt;p&gt;说事件循环（event loop）之前先要搞清楚几个问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. js为什么是单线程的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　试想一下，如果js不是单线程的，同时有两个方法作用dom，一个删除，一个修改，那么这时候浏览器该听谁的？这就是js被设计成单线程的原因。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.js为什么需要异步？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果js不是异步的话，由于js代码本身是自上而下执行的，那么如果上一行代码需要执行很久，下面的代码就会被阻塞，对用户来说，就是”卡死”，这样的话，会造成很差的用户体验。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.js是如何实现异步的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　既然js是单线程的，那么js是如何实现异步的呢，是通过事件循环（event loop），理解了event loop 就理解了js的执行机制。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.浏览器中的多线程？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　js是单线程的，但是浏览器是多线程的，多个线程相互配合以保持同步，浏览器下的常驻线程有&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;js线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GUI&lt;span&gt;渲染线程，（它与javaScript线程是互斥的）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件线程(onclick,onchange,…)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;定时器线程(setTimeout, setInterval)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;异步http线程(ajax)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;5. javaScript 的事件循环（&lt;span&gt;event loop&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然js是单线程的，那么所有的任务就需要排队执行。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;javaScript 中的任务可以被划分为&lt;strong&gt;宏任务（Macrotask）&lt;/strong&gt;或者&lt;strong&gt;微任务（Microtask）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;像鼠标事件，键盘事件,&quot;ajax&quot;,&quot;setTimeout&quot;等就属于宏任务，需要注意的是，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;主线程的整体代码(script标签)，也是一个宏任务&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;process.nextTick，&lt;span&gt;PromiseA.then()， &lt;span&gt;MutaionObserver 就属于微任务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单概括一下事件循环，就是&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;1.执行宏任务队列中第一个任务，执行完后移除它&lt;/p&gt;
&lt;p&gt;2.执行所有的微任务，执行完后移除它们&lt;/p&gt;
&lt;p&gt;3.执行下一轮宏任务（重复步骤2）&lt;/p&gt;
&lt;p&gt;如此循环就形成了event loop，其中，每轮执行&lt;span&gt;一个宏任务&lt;/span&gt;和&lt;span&gt;所有的微任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下图很形象的描述了event loop&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181213220454860-1986292692.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;下面我通过分析一个示例来说一下：&lt;/p&gt;
&lt;div readability=&quot;64&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
console.log(1&lt;span&gt;);

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;2&lt;span&gt;)
},&lt;/span&gt;10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i=100000 ; i&amp;gt;0 ; i--&lt;span&gt; ){
        i&lt;/span&gt;==1 &amp;amp;&amp;amp;&lt;span&gt; resolve()
    }
    console.log(&lt;/span&gt;4&lt;span&gt;)
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;5&lt;span&gt;)
})&lt;span&gt;.then(&lt;span&gt;function&lt;span&gt;(){ &lt;br/&gt;console.log(6&lt;span&gt;) &lt;br/&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;

console.log(&lt;/span&gt;7);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出来的结果是：1 3 4 7 5 6 2&lt;/p&gt;
&lt;p&gt;我们分析一下整个过程&lt;/p&gt;
&lt;p&gt;1. 首先执行主线程这个宏任务，从上到下执行，遇到console.log(1&lt;span&gt;); 打印1出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 遇到setTimeout，把它丢给定时器线程处理，&lt;span&gt;然后继续往下执行&lt;/span&gt;，并不会阻塞10毫秒，而此处定时器线程会在，&lt;strong&gt;主线程执行完后的10毫秒&lt;/strong&gt;，把回调函数放入&lt;strong&gt;宏任务队列&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 遇到&lt;span&gt;new Promise&lt;/span&gt;，直接执行，先打印 ‘3‘ 出来，然后执行for循环，达到条件之后，把promise的状态改为resolved，继续执行打印 ‘4’ 出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.遇到promise的then， 属于微任务，则把回调函数放入微任务队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.又&lt;span&gt;遇到promise的then， 属于微任务，则把回调函数放入微任务队列&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;6. 遇到&lt;span&gt;console.log(7) 打印 ‘7’ 出来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;7. 宏任务执行完后会执行所有待执行的微任务，所以会相继打印 ‘6’， ‘7’ 出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至此第一轮循环已经结束了，第一轮循环里的宏任务和微任务都会被移除出任务队列，接下来开启第二轮循环，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.首先查找是否有宏任务，由于setTimeout 的回调被放入了宏任务队列，这里会执行回调函数的代码，打印了 ‘2’ 出来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2. 接着查找是否有微任务，发现没有微任务，则本轮循环结束&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接下来会重复上面的步骤，整个过程就是 event loop 了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6. 扩展题目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的题目扩展一下，大家看一下打印出来的结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
console.log(1&lt;span&gt;);

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;'promise in setTimeout1'&lt;span&gt;);
    resolve();
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;'then in setTimeout1'&lt;span&gt;);
    })
},&lt;/span&gt;10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;3&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i=100000 ; i&amp;gt;0 ; i--&lt;span&gt; ){
        i&lt;/span&gt;==1 &amp;amp;&amp;amp;&lt;span&gt; resolve();
    }
    console.log(&lt;/span&gt;4&lt;span&gt;)
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;5&lt;span&gt;);
});

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;'setTimeout2'&lt;span&gt;);
},&lt;/span&gt;10&lt;span&gt;);

console.log(&lt;/span&gt;7);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181213225633417-1595552298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，第二个setTimeout 的回调函数，执行的比第一个setTimeout里面的promise.then()的回调要晚，这是因为每次循环只执行一个宏任务，但是却会执行所有待执行的微任务，而第二个setTimeout在宏任务队列的位置在第一个setTimeout后面。&lt;/p&gt;

&lt;p&gt;这个就是我理解的JavaScipt 事件循环机制，参考了很多文章，也自己做了很多思考写出来的，码字不易，觉得有帮助可以点个赞哦。也欢迎留言交流&lt;/p&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;https://segmentfault.com/a/1190000012806637?utm_source=tag-newest&lt;/p&gt;
&lt;p&gt;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/33127885&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/33136054&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context&lt;/p&gt;

&lt;/div&gt;


</description>
<pubDate>Thu, 13 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>daisy,gogogo</dc:creator>
<og:description>说事件循环（event loop）之前先要搞清楚几个问题。 1. js为什么是单线程的？ 试想一下，如果js不是单线程的，同时有两个方法作用dom，一个删除，一个修改，那么这时候浏览器该听谁的？这就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daisygogogo/p/10116694.html</dc:identifier>
</item>
<item>
<title>单页面应用在微信服务号下的登录流程 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/10116017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/10116017.html</guid>
<description>&lt;p&gt;最近我们的小程序涉及到虚拟支付的问题，在ios端的支付被封掉了😇，所以有了在服务号上搞一套H5版的小程序的需求。由于我们小程序是mpvue写的，为了尽量复用之前的样式和逻辑，选择了前后端分离的模式，于是一段新的踩坑之旅开始了。放下wx的jssdk暂且不表，今天来说说登录时遇到的坑。&lt;/p&gt;
&lt;h3 id=&quot;服务号的登录流程&quot;&gt;服务号的登录流程&lt;/h3&gt;
&lt;p&gt;以前搞过服务号的同学对于它的登录流程应该不陌生，就是当后端检测到当前用户没有授权时，将会重定向到微信的授权页面，当用户点击这个授权的button时，微信会根据Url查询字符串中的重定向URL，重新回到我们的页面。&lt;/p&gt;
&lt;p&gt;下面3幅图展示了整个过程:&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当我们的服务器发现用户没有授权，返回&lt;code&gt;302&lt;/code&gt;状态码，以及微信的授权页面location&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213224427706-1929619708.png&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户在该页面点击确认登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213194530805-1260660333.png&quot; alt=&quot;uploading-image-28683.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;微信服务器根据location里的redirectURL，返回&lt;code&gt;301&lt;/code&gt;code，重定向回来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213194940834-1542448116.png&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面三步，经历了两次重定向，第一次从自己的服务器重定向到微信的服务器，微信展示授权页面。第二次重定向是当用户点击之后，微信会带一个code重定向回来，当服务器拿到这个code之后，经历一波获取openId的操作之后，生成一个session，这样用户以后访问时就不需要再次登录。&lt;/p&gt;
&lt;p&gt;这样的模式在传统的前后端不分离，基于模板的情况下，是没有问题的，因为没有json的返回，后端进行逻辑处理后，渲染出html。但是在单页面的情况下，如果思路跑偏会出现一堆问题。&lt;/p&gt;
&lt;h3 id=&quot;单页面遇到的问题&quot;&gt;单页面遇到的问题&lt;/h3&gt;
&lt;p&gt;上面说的思路跑偏是什么意思呢？就是当用户进来时，先将单页面的&lt;code&gt;index.html&lt;/code&gt;发给浏览器。当浏览器执行开始js脚本（app.js）时，就会向服务器发送请求。&lt;/p&gt;
&lt;p&gt;此时如果是一个新用户在访问，由于没有登录，服务器会返回一个302的重定向状态码，然而这次请求是通过ajax发起的。浏览器不会自动重定向到授权页面，导致请求失败。&lt;/p&gt;
&lt;p&gt;此时你会想，浏览器不会重定向，我可以当请求失败时通过设置&lt;code&gt;window.location&lt;/code&gt;自己重定向到微信授权页面，这样解决了第一步的重定向问题，然后当用户点击确定登录时，马上又面临第二个重定向的问题--重定向到哪里。&lt;/p&gt;
&lt;p&gt;由于微信重定向的url是带着code返回的，重定向的Url肯定不能是一个静态页面的Url，必须是一个api，假设还是login。后端在请求中拿到code之后，生成一个新的session，再将原先的html再次返回给浏览器，并带上&lt;code&gt;set-cookie&lt;/code&gt;字段，此后浏览器会带着cookie请求，登录至此完成。&lt;/p&gt;
&lt;p&gt;这样做ok，当时却留下一个很恐怖的URL：&lt;code&gt;https://example.com/login?code=001QLbSQ0Ujc162Sp5UQ0IG6SQ0QLbSD&lt;/code&gt;，此后前端路由开始work，就在前面的基础上加上一个&lt;code&gt;#&lt;/code&gt;号，如果你的业务还涉及支付，那就完蛋了，因为支付需要配置的url应该是稳定的而code这个查询参数是动态变的。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;我画了一张图解释了重新设计的登录流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213192838716-507236655.png&quot; alt=&quot;uploading-image-511687.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个新的流程中，当新用户第一次发起请求（login）时，不会返html给浏览器，只会进行重定向：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果用户未登录，重定向到微信的授权页，并设置redirect url，使用户点击授权后可以重定向回来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;新用户重定向回来之后，login api拿到code，经过生成session操作后，再次重定向到&lt;code&gt;home&lt;/code&gt;url下&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果是老用户，直接重定向到&lt;code&gt;home&lt;/code&gt;url下&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;此时由于访问&lt;code&gt;home&lt;/code&gt;的用户都是已登录状态，api统一返回index.html,所以最终用户看到的是&lt;code&gt;https://example.com/home&lt;/code&gt;下的页面，后面的单页面路由会在这个url下展开。（虽然对服务号用户来说可能没什么区别）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下这么做的好处：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;少传输一次html页面，第一种方式一开始就给未登录的用户传html是没用的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;美观的url（用户感知不到）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前端无需手动重定向，后端将显示页面和登录逻辑放到两个api中，逻辑更清晰&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;了解到&lt;code&gt;3xx&lt;/code&gt;状态码的博大精深，尽管对普通用户感知不深，没有&lt;code&gt;2xx&lt;/code&gt;受群众欢迎，也没有&lt;code&gt;404&lt;/code&gt;,&lt;code&gt;500&lt;/code&gt;知名度高，属于默默无闻型的。但是在互联网世界里却扮演着重要的角色。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>最近我们的小程序涉及到虚拟支付的问题，在ios端的支付被封掉了😇，所以有了在服务号上搞一套H5版的小程序的需求。由于我们小程序是mpvue写的，为了尽量复用之前的样式和逻辑，选择了前后端分离的模式，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/10116017.html</dc:identifier>
</item>
<item>
<title>JaveScript 中使用 XSLT转换XML文档 - 西秀岭</title>
<link>http://www.cnblogs.com/xixiuling/p/10116108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xixiuling/p/10116108.html</guid>
<description>&lt;p&gt;我们经常将数据存储在XML 中，在展示的时候需要转换为其它的形式，这里介绍使用XSLT 对XML数据进行转换。&lt;/p&gt;
&lt;p&gt;要学习XSLT对XML的转换，需要先了解三个文件。&lt;/p&gt;
&lt;p&gt;第一个是存储数据的XML文件:employees.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employee &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Software Engineer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Nicholas C. Zakas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employee&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employee &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Salesperson&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Jim Smith&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employee&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个是存储XSLT的文件：employees.xslt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:stylesheet &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsl&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/XSL/Transform&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:output &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;html&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:stylesheet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三个是我们进行转换的代码example.htm：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;XSLTProcessor Example&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        window.onload &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;use XHR to load&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmlhttp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmldom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xmlhttp.responseXML;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            xmlhttp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees.xslt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xsltdom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xmlhttp.responseXML;  
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; processor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            processor.importStylesheet(xsltdom);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; processor.transformToDocument(xmldom);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; div &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;divResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLSerializer()).serializeToString(result);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            alert(xml);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            div.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xml;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;           
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;This example loads employees.xml and transforms it using employees.xslt. 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     The resulting code is then displayed.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们通过 XSLTProcessor 类型使用XSLT转换XML文档，第一步加载两个DOM文档，一个基于XML,另一个基于XSLT,下面的代码在Edge 中可以顺利执行，在Chrome中，因为禁止从本地装载文件随意会会失败，如果从网络服务器上读取数据则没有问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;use XHR to load&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; xmlhttp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xmlhttp.open(&lt;/span&gt;&quot;get&quot;, &quot;employees.xml&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmldom =&lt;span&gt; xmlhttp.responseXML;
            
xmlhttp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xmlhttp.open(&lt;/span&gt;&quot;get&quot;, &quot;employees.xslt&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xsltdom = xmlhttp.responseXML;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后创建一个新XSLTProcessor对象，并使用importStylesheet()方法为其指定一个XSLT&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后一步是执行转换，这一步有两种不同的方式，如果想返回一个完整的DOM文档，可以调用transformToDocument().而通过调用transforToFragment()则可以得到一个文档片段对象。一般来说。使用transformToFragment()的唯一理由，就是你想把返回的结果添加到另一个DOM文档中。&lt;/p&gt;
&lt;p&gt;在使用transforToDocument()时，只要传入XML DOM,就可以将结果作为一个完全不同的DOM文档来使用。来看例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result = processor.transformToDocument(xmldom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将result 结果进行序列化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xml = (&lt;span&gt;new&lt;/span&gt; XMLSerializer()).serializeToString(result);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看转换后的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Nicholas C. Zakas, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Software Engineer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Jim Smith, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Salesperson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们来看一下XSLT中的定义:&lt;/p&gt;
&lt;p&gt;下面的这段代码会让我们将所有的内容都放到&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;之中，之所以会这样是因为我们的选择符指定了全部 select=&quot;*&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面这段代码的含义是对 employee 元素进行转换 match=&quot;employee&quot;&lt;/p&gt;
&lt;p&gt;将name 元素放到&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;中  select=&quot;name&quot;&lt;/p&gt;
&lt;p&gt;将title 属性提取出来放到&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;中  select=&quot;@title&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而transformToFragment()方法接收两个参数：要转换的XML DOM 和应该拥有结果片段的文档。换句话说，如果你想将返回的片段插入到页面中，只要将document作为第二个参数即可。&lt;/p&gt;
&lt;p&gt;我们只需要将example.htm中 23 - 28 行代码替换成下面代码就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var fragment = processor.transformToFragment(xmldom, document);
var div = document.getElementById(&quot;divResult&quot;);
            
div.appendChild(fragment);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，处理器创建了一个有document对象拥有的片段。这样，就可以将返回的片段添加到页面中已有的&amp;lt;div&amp;gt;元素中了。&lt;/p&gt;
&lt;p&gt;在XSLT样式表的输出格式为&quot;xml&quot;,&quot;html&quot;的情况下，创建文档或文档片段会非常有用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.使用参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;XSLTProcessor 也支持使用 setParameter()来设置XSLT的参数，这个方法接收三个参数：命名空间URI，参数的内部名称和要设置的值。通常，命名空间URI都是null,而内部名称就是参数的名称。另外必须在调用transformToDocument()或transformToFragment()之前调用这个方法。来看例子&lt;/p&gt;
&lt;p&gt;我们先看XSLT文件 employees2.xslt：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:stylesheet &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsl&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/XSL/Transform&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:output &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;html&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Message: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;$message&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:stylesheet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对 example.htm的修改&lt;/p&gt;
&lt;p&gt;第16行替换为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
xmlhttp.open(&quot;get&quot;, &quot;employees2.xslt&quot;, false);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第23 - 28替换为下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
processor.setParameter(&lt;span&gt;null&lt;/span&gt;, &quot;message&quot;, &quot;Hello World!&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fragment =&lt;span&gt; processor.transformToFragment(xmldom, document);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.getElementById(&quot;divResult&quot;&lt;span&gt;);
            
div.appendChild(fragment);            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看运行后的结果：通过转换将模板中的 &lt;span&gt;&lt;span&gt;$message&lt;/span&gt;&lt;span&gt;变量替换成了我们传入的参数&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div id=&quot;divResult&quot;&amp;gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Nicholas C. Zakas, &amp;lt;em&amp;gt;Software Engineer&amp;lt;/em&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Jim Smith, &amp;lt;em&amp;gt;Salesperson&amp;lt;/em&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;p&amp;gt;Message: Hello World!&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有两个与参数有关的方法，getParamenter()和removeParamenter(),分别用于取得和一处当前参数的值。这两个方法都要接受命名空间参数和参数内部i名称。例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);
processor.setParameter(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &quot;message&quot;, &quot;Hello World!&quot;&lt;span&gt;);
&lt;br/&gt;alert(processor.getParaeter(null,&quot;message&quot;));     //输出 “Hello World!&quot;&lt;br/&gt;processor.removeParameter(null,&quot;message&quot;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fragment = processor.transformToFragment(xmldom, document);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个方法并不常用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.重置处理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个XSLTProcessor 的实例都可以重用，以便使用不同的XSLT样式表执行不同的转换。重置处理器时要调用reset()方法，这个方法会从处理器中移除所有的参数和样式表。然后，你就可以再次调用importStylesheet(),以加载不同的XSLT样式表，如下面的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span readability=&quot;1&quot;&gt;&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);&lt;p&gt;//执行转换&lt;/p&gt;&lt;p&gt;processor.reset();&lt;br/&gt;processor.importStylesheet(xsltdom2);&lt;/p&gt;&lt;p&gt;//在执行转换&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在需要基于多个样式表进行转换时，重用一个XSLTProcessor可以节省内存。&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>西秀岭</dc:creator>
<og:description>我们经常将数据存储在XML 中，在展示的时候需要转换为其它的形式，这里介绍使用XSLT 对XML数据进行转换。 要学习XSLT对XML的转换，需要先了解三个文件。 第一个是存储数据的XML文件:emp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xixiuling/p/10116108.html</dc:identifier>
</item>
<item>
<title>Python异常处理详解 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10116936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10116936.html</guid>
<description>&lt;h2 id=&quot;入门示例&quot;&gt;入门示例&lt;/h2&gt;
&lt;h3 id=&quot;异常处理tryexcept&quot;&gt;异常处理：try/except&lt;/h3&gt;
&lt;p&gt;对于索引查找的操作，在索引越界搜索的时候会报错。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s=&quot;long&quot;
&amp;gt;&amp;gt;&amp;gt; s[4]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所报的错误是IndexError。如果将索引查找放在一个函数里：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fetcher(obj,index):
...     return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么调用函数的时候，如果里面的索引越界了，异常将汇报到函数调用者。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fetcher(s,3)
'g'

&amp;gt;&amp;gt;&amp;gt; fetcher(s,4)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in fetcher
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用try/except来捕获异常。作为入门示例，下面是简单版的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
except &amp;lt;ERRORTYPE&amp;gt;:
    ...statementS...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，try中是要监视正确执行与否的语句，ERRORTYPE是要监视的错误类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只要try中的任何一条语句抛出了错误，try中该异常语句后面的语句都不会再执行；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果抛出的错误正好是except所监视的错误类型，就会执行statementS部分的语句；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果异常正好被except捕获(匹配)到了，程序在执行完statementS后会继续执行下去，如果没有捕获到，程序将终止；
&lt;ul&gt;&lt;li&gt;换句话说，except捕获到错误后，相当于处理了这个错误，程序不会因为已经被处理过的错误而停止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如捕获上面的函数调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    return obj[index]

s = &quot;long&quot;
try:
    print(fetcher(s, 3) * 4)
    print(fetcher(s, 4) * 4)
except IndexError:
    print(&quot;something wrong&quot;)

print(&quot;after Exception, Continue&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
something wrong
after Exception, Continue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为上面的&lt;code&gt;fetcher(s, 4)&lt;/code&gt;会抛出异常，且正好匹配except监视的异常类型，所以输出&lt;code&gt;something wrong&lt;/code&gt;，异常被处理之后，程序继续执行，即try/except后面的print()。&lt;/p&gt;
&lt;h3 id=&quot;异常处理tryfinally&quot;&gt;异常处理：try/finally&lt;/h3&gt;
&lt;p&gt;finally是try之后一定会执行的语句段落。可以结合except一起使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
finally:
    ...statementF...&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
except &amp;lt;ERRORTYPE&amp;gt;:
    ...statementS...
finally:
    ...statementF...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不论try中的语句是否出现异常，不论except是否捕获到对应的异常，finally都会执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果异常没有被捕获，则在执行finally之后程序退出&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果异常被except捕获，则执行完except的语句之后执行finally的语句，然后程序继续运行下去&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，finally中都会用来做程序善后清理工作。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    return obj[index]

s = &quot;long&quot;
try:
    print(fetcher(s, 3) * 4)
    print(fetcher(s, 4) * 4)
except IndexError:
    print(&quot;something wrong&quot;)
finally:
    print(&quot;in finally&quot;)

print(&quot;after Exception, Continue&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
something wrong
in finally
after Exception, Continue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把except那段代码删掉，得到的结果将是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
in finally      # 输出了finally的内容
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 8, in &amp;lt;module&amp;gt;
    print(fetcher(s, 4) * 4)
  File &quot;g:/pycode/list.py&quot;, line 2, in fetcher
    return obj[index]
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;产生异常raise和assert&quot;&gt;产生异常：raise和assert&lt;/h3&gt;
&lt;p&gt;使用raise或assert可以主动生成异常情况。其中raise可以直接抛出某个异常，assert需要通过布尔值来判断，然后再抛出给定的错误。&lt;/p&gt;
&lt;p&gt;例如，在函数里做个没什么用的的判断，用来演示raise：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    if index &amp;gt;= len(obj):
        raise IndexError
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和直接索引越界是以一样的。上面raise抛出的异常IndexError是一个内置异常，可以直接引用这些内置异常。稍后会演示如何自定义自己的异常。&lt;/p&gt;
&lt;p&gt;抛出异常后，就可以按照前面介绍的try来处理异常。&lt;/p&gt;
&lt;p&gt;assert是一种断言，在计算机语言中表示：如果断言条件为真就跳过，如果为假就抛出异常信息。它可以自定义异常信息。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    assert index &amp;lt; len(obj),  &quot;one exception&quot;
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多时候会直接在assert中使用False、True的布尔值进行程序的调试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assert True, &quot;assert not hit&quot;
assert False, &quot;assert hit&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义异常&quot;&gt;自定义异常&lt;/h3&gt;
&lt;p&gt;python中的异常是通过类来定义的，而且所有的异常类都继承自Exception类，而Exception又继承自BaseException(这个类不能直接作为其它异常类的父类)。所以自定义异常的时候，也要继承Exception，当然，继承某个中间异常类也可以。&lt;/p&gt;
&lt;p&gt;例如，定义索引越界的异常类，注意这个类中直接pass，但因为继承了Exception，它仍然会有异常信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyIndexError(Exception):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，判断字母是否是大写，如果是，就抛异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj,index):
    if index &amp;gt;= len(obj):
        raise MyIndexError
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = &quot;long&quot;

print(fetcher(s, 3) * 4)
print(fetcher(s, 4) * 4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 12, in &amp;lt;module&amp;gt;
    print(fetcher(s, 4) * 4)
  File &quot;g:/pycode/list.py&quot;, line 6, in fetcher
    raise MyIndexError
__main__.MyIndexError&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，因为异常类都继承字Exception，except监视Exception异常的时候，也会匹配其它的异常。更标准地说，&lt;strong&gt;监视异常父类，也会捕获到这个类的子类异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;如何看抛出的异常&quot;&gt;如何看抛出的异常&lt;/h3&gt;
&lt;p&gt;看异常信息是最基本的能力。例如，下面的这段代码会报除0错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def a(x, y):
    return x/y

def b(x):
    print(a(x, 0))

b(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行时，报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 7, in &amp;lt;module&amp;gt;
    b(1)
  File &quot;g:/pycode/list.py&quot;, line 5, in b
    print(a(x, 0))
  File &quot;g:/pycode/list.py&quot;, line 2, in a
    return x/y
ZeroDivisionError: division by zero&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个堆栈跟踪信息中已经明确说明了&lt;code&gt;(most recent call last)&lt;/code&gt;，说明最近产生异常的调用在最上面，也就是第7行。上面的整个过程是这样的：第7行出错，它是因为第5行的代码引起的，而第5行之所以错是第2行的源代码引起的。&lt;/p&gt;
&lt;p&gt;所以，从最底部可以看到最终是因为什么而抛出异常，从最顶部可以看到是执行到哪一句出错。&lt;/p&gt;
&lt;h2 id=&quot;深入异常处理&quot;&gt;深入异常处理&lt;/h2&gt;
&lt;h3 id=&quot;tryexceptelsefinally&quot;&gt;try/except/else/finally&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;try:
    &amp;lt;statements&amp;gt;
except &amp;lt;name1&amp;gt;:           # 捕获到名为name1的异常
    &amp;lt;statements&amp;gt;
except (name2, name3):    # 捕获到name2或name3任一异常
    &amp;lt;statements&amp;gt;
except &amp;lt;name4&amp;gt; as &amp;lt;data&amp;gt;: # 捕获name4异常，并获取异常的示例
    &amp;lt;statements&amp;gt;
except:                   # 以上异常都不匹配时
    &amp;lt;statements&amp;gt;
else:                     # 没有产生异常时
    &amp;lt;statements&amp;gt;
finally:                  # 一定会执行的
    &amp;lt;statements&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，当抛出的异常无法被匹配时，将归类于空的&lt;code&gt;except:&lt;/code&gt;，但这是很危险的行为，因为很多时候的异常是必然的，比如某些退出操作、内存不足、Ctrl+C等等，而这些都会被捕获。与之大致等价的是捕获异常类的&quot;伪&quot;祖先类&lt;code&gt;Exception&lt;/code&gt;，即&lt;code&gt;except Exception:&lt;/code&gt;，它和空异常匹配类似，但能解决不少不应该匹配的异常。但使用Exception依然是危险的，能不用尽量不用。&lt;/p&gt;
&lt;p&gt;如果一个异常既能被name1匹配，又能被name2匹配，则先匹配到的处理这个异常。&lt;/p&gt;
&lt;p&gt;通过as关键字可以将except捕获到的异常对象赋值给data变量。用法稍后会解释，现在需要知道的是，在python 3.x中，&lt;strong&gt;变量data只在当前的except块范围内有效，出了范围就会被回收&lt;/strong&gt;。如果想要保留异常对象，可以将data赋值给一个变量。例如下面的b在出了try范围都有效，但是a在这个except之后就无效了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;except Exception as a:
    print(a)
    b=a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过else分句可以知道，这段try代码中没有出现任何异常。否则就不会执行到else分句。&lt;/p&gt;
&lt;h3 id=&quot;raise&quot;&gt;raise&lt;/h3&gt;
&lt;p&gt;raise用于手动触发一个异常。而每一种异常都是一个异常类，所以触发实际上是触发一个异常类的实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;raise &amp;lt;instance&amp;gt;  # 直接触发一个异常类的对象
raise &amp;lt;class&amp;gt;     # 构建此处所给类的一个异常对象并触发
raise             # 触发最近触发的异常
raise &amp;lt;2&amp;gt; from &amp;lt;1&amp;gt;  # 将&amp;lt;1&amp;gt;的异常附加在&amp;lt;2&amp;gt;上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第二种形式，raise会根据给定类不传递任何参数地自动构建一个异常对象，并触发这个异常对象。第三种直接触发最近触发的异常对象，这在传播异常的时候很有用。&lt;/p&gt;
&lt;p&gt;例如，下面两种方式实际上是等价的，只不过第一种方式传递的是类，raise会隐式地自动创建这个异常类的实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;raise IndexError
raise IndexError()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以为异常类构建实例时指定点参数信息，这些参数会保存到名为args的元组。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;something wrong&quot;)
except Exception as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;('something wrong',)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不仅如此，只要是异常类或异常对象，不管它们的存在形式如何，都可以放在raise中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err = IndexErro()
raise err

errs = [IndexError, TypeError]
raise errs[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第三种raise形式，它主要用来传播异常，一般用在except代码段中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;aaaaa&quot;)
except IndexError:
    print(&quot;something wrong&quot;)
    raise&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为异常被except捕获后，就表示这个异常已经处理过了，程序会跳转到finally或整个try块的尾部继续执行下去。但是如果不想让程序继续执行，而是仅仅只是想知道发生了这个异常，并做一番处理，然后继续向上触发异常。这就是异常传播。&lt;/p&gt;
&lt;p&gt;因为实际触发的异常都是类的实例对象，所以它有属性。而且，可以通过在except中使用as来将对象赋值给变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as a:
    print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量a在出了except的范围就失效，所以可以将它保留给一个不会失效的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as a:
    print(a)
    b=a

print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在一个except中触发了另一个异常，会造成&lt;strong&gt;异常链&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会报告两个异常，并提示处理异常E的时候，触发了另一个异常TypeError。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad')
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用from关键字，可以让关系更加明确。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad') from E&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是错误报告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad') from E
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，使用from关键字的时候，会将E的异常对象附加到TypeError的&lt;code&gt;__cause__&lt;/code&gt;属性上。&lt;/p&gt;
&lt;p&gt;但无论如何，这里都触发了多个异常。在python 3.3版本，可以使用&lt;code&gt;from None&lt;/code&gt;的方式来掩盖异常的来源，也就是禁止输出异常E，停止异常链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad') from None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误报告如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad') from None
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，异常信息中少了很多内容。&lt;/p&gt;
&lt;h3 id=&quot;assert&quot;&gt;assert&lt;/h3&gt;
&lt;p&gt;assert断言常用于调试。用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assert test, data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它实际上等价于是条件判断的raise。它等价于下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __debug__:
    if not test:
        raise AssertionError(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果条件test的测试为真，就跳过，否则就抛出异常。这个异常是通过AssertionError类构造的，构造异常对象的参数是data。data会放进名为args的元组属性中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    assert False,&quot;something wrong&quot;
except Exception as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，assert产生的是名为AssertionError的异常，如果不捕获这个AssertionError异常，程序将会终止。&lt;/p&gt;
&lt;p&gt;除了调试，assert还偶尔用来判断必要的条件，不满足条件就异常，以便让程序更加健壮。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    assert x &amp;gt;= 0, &quot;x must great or equal than 0&quot;
    return x ** 2

print(f(2))
print(f(0))
print(f(-2))   # 触发AssertionError异常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，写assert的测试条件时，测试结果为假才触发异常。所以，应该以if not true的角度去考虑条件，或者以unless的角度考虑。或者说，后面触发的异常信息，和测试条件应该是正相关的，例如示例中异常信息的说法是x必须大于等于0，和测试条件&lt;code&gt;x &amp;gt;= 0&lt;/code&gt;是正相关的。&lt;/p&gt;
&lt;p&gt;assert还常用于父类方法的某些方法中，这些方法要求子类必须重写父类的方法。于是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    ...
    def f(self):
        assert False, &quot;you must override method: f&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，assert不应该用来触发那些python早已经定义好的异常。例如索引越界、类型错误等等。这些python已经定义好的异常，我们再去用AssertionError触发，这是完全多余的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(obj,index):
    assert index &amp;gt; len(obj), &quot;IndexError&quot;
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sys.exc_info&quot;&gt;sys.exc_info()&lt;/h2&gt;
&lt;p&gt;该函数用来收集正在处理的异常的信息。&lt;/p&gt;
&lt;p&gt;它返回一个包含3个值的元组&lt;code&gt;(type, value, traceback)&lt;/code&gt;，它们是当前正在处理的异常的信息。如果没有正在处理的异常，则返回3个None组成的元组。&lt;/p&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type表示正在处理的异常类&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;value表示正在处理的异常实例&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;traceback表示一个栈空间的回调对象(参考官方手册&lt;a href=&quot;https://docs.python.org/3/library/traceback.html&quot;&gt;traceback object&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看一个示例即可知道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass

def raise0():
    x = General()
    raise x

try:
    raise0()
except Exception:
    import sys
    print(sys.exc_info())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&amp;lt;class '__main__.General'&amp;gt;, General(), &amp;lt;traceback object at 0x0388F2B0&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果很明显，第一个返回值是异常类General，第二个返回值是抛出的异常类的实例对象，第三个返回值是traceback对象。&lt;/p&gt;
&lt;p&gt;实际上，当需要获取当前处理的异常类时，还可以通过异常对象的&lt;code&gt;__class__&lt;/code&gt;来获取，因为异常对象可以在except/as中赋值给变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass

def raise0():
    x = General()
    raise x

try:
    raise0()
except Exception as E:
    import sys
    print(sys.exc_info()[0])
    print(E.__class__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们的的结果是完全一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class '__main__.General'&amp;gt;
&amp;lt;class '__main__.General'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么时候要获取异常类的信息？当except所监视的异常类比较大范围，同时又想知道具体的异常类。比如，&lt;code&gt;except:&lt;/code&gt;或&lt;code&gt;except Exception:&lt;/code&gt;这两种监视的异常范围都非常大，前者会监视BaseException，也就是python的所有异常，后者监视的是Exception，也就是python的所有普通的异常。正因为监视范围太大，导致不知道具体是抛出的是哪个异常。&lt;/p&gt;
&lt;h2 id=&quot;区分异常和错误&quot;&gt;区分异常和错误&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;错误都是异常，但异常并不一定都是错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很常见的，文件结尾的EOF在各种语言中它都定义为异常，是异常就能被触发捕获，但在逻辑上却不认为它是错误。&lt;/p&gt;
&lt;p&gt;除此之外，还有操作系统的异常，比如sys.exit()引发的SystemeExit异常，ctrl+c引发的的中断异常KeyboardInterrupt都属于异常，但它们和普通的异常不一样。而且python中的普通异常都继承字Exception类，但SystemExit却并非它的子类，而是BaseException的子类。所以能通过空的&lt;code&gt;except:&lt;/code&gt;捕获到它，却不能通过&lt;code&gt;except Exception:&lt;/code&gt;来捕获。&lt;/p&gt;
&lt;h2 id=&quot;异常类的继承&quot;&gt;异常类的继承&lt;/h2&gt;
&lt;p&gt;所有异常类都继承自Exception，要编写自定义的异常时，要么直接继承该类，要么继承该类的某个子类。&lt;/p&gt;
&lt;p&gt;例如，下面定义三个异常类，General类继承Exception，另外两个继承General类，表示这两个是特定的、更具体的异常类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass
class Specific1(General): pass
class Specific2(General): pass

def raise0():
    x = General()
    raise x

def raise1():
    x = Specific1()
    raise x

def raise2():
    x = Specific2()
    raise x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for func in (raise0, raise1, raise2):
    try:
        func()
    except General as E:
        import sys
        print(&quot;caught: &quot;, E.__class__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;caught:  &amp;lt;class '__main__.General'&amp;gt;
caught:  &amp;lt;class '__main__.Specific1'&amp;gt;
caught:  &amp;lt;class '__main__.Specific2'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过，except监视父类异常的时候，也会捕获该类的子类异常。正如这里监视的是Gereral类，但触发了Specific子类异常也会被捕获。&lt;/p&gt;
&lt;h2 id=&quot;异常类的嵌套&quot;&gt;异常类的嵌套&lt;/h2&gt;
&lt;p&gt;这是非常常见的陷阱。有两种异常嵌套的方式：try的嵌套；代码块的异常嵌套(比如函数嵌套)。无论是哪种嵌套模式，异常都只在最近(或者说是最内层)的代码块中被处理，但是finally块是所有try都会执行的。&lt;/p&gt;
&lt;p&gt;第一种try的嵌套模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    try:
        (1)
    except xxx:
        (2)
    finally:
        (3)
except yyy:
    ...
finally:
    (4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在(1)处抛出了异常，无论yyy是否匹配这个异常，只要xxx能匹配这个异常，就会执行(2)。但(3)、(4)这两个finally都会执行。&lt;/p&gt;
&lt;p&gt;第二种代码块嵌套，常见的是函数调用的嵌套，这种情况可能会比较隐式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def action2():
    print(1 + [])

def action1():
    try:
        action2()
    except TypeError:
        print('inner try')

try:
    action1()
except TypeError:
    print('outer try')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inner try&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的action2()会抛出一个TypeError的异常。在action1()中用了try包围action2()的调用，于是action2()的异常汇报给action1()层，然后被捕获。&lt;/p&gt;
&lt;p&gt;但是在最外面，使用try包围action1()的调用，看上去异常也会被捕获，但实际上并不会，因为在action2()中就已经通过except处理好了异常，而处理过的异常将不再是异常，不会再触发外层的异常，所以上面不会输出&quot;outer try&quot;。&lt;/p&gt;
&lt;h2 id=&quot;except应该捕获哪些异常&quot;&gt;except应该捕获哪些异常&lt;/h2&gt;
&lt;p&gt;在考虑异常捕获的时候，需要注意几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;except监视的范围别太大了&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;except监视的范围别太小了&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;有些异常本就该让它中断程序的运行，不要去捕获它&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三点很容易理解，有些异常会导致程序无法进行后续的运行，改中断还是得中断。&lt;/p&gt;
&lt;p&gt;对于第一点，可能常用的大范围异常监视就是下面两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;except:
except Exception:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方式监视的范围都太大了，比如有些不想处理的异常也会被它们监视到。更糟糕的可能是本该汇报给上层的异常，结果却被这种大范围捕获了。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def func():
    try:
        ...
    except:
        ...

try:
    func()
except IndexErro:
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来是想在外层的try中明确捕获func触发的IndexError异常的，但是func()内却使用了空的&lt;code&gt;except:&lt;/code&gt;，使得异常直接在这里被处理，外层的try永远也捕获不到任何该函数的异常。&lt;/p&gt;
&lt;p&gt;关于第二点，不应该监视范围太小的异常。范围小，意味着监视的异常太过具体，太过细致，这种监视方式虽然精确，但却不利于维护。例如E1异常类有2个子异常类E2、E3，在代码中监视了E2、E3，但如果未来又添加了一个E1的子异常类E4，那么又得去改代码让它监视E4。如果代码是写给自己用的倒无所谓，但如果像通用模块一样交给别人用的，这意味着让别的模块使用者也去改代码。&lt;/p&gt;
&lt;h2 id=&quot;自定义异常类&quot;&gt;自定义异常类&lt;/h2&gt;
&lt;p&gt;在前面设计异常类的时候，总是使用pass跳过类代码体。但却仍然能使用这个类作为异常类，因为它继承了Exception，在Exception中有相关代码可以输出异常信息。&lt;/p&gt;
&lt;p&gt;前面说过，在构造异常类的时候可以传递参数，它们会放进异常实例对象的args属性中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;something wrong&quot;)
except Exception as E:
    print(E.args)

try:
    assert False,&quot;something wrong too&quot;
except Exception as E:
    print(E.args)

I = IndexError('text')
print(I.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于用户自定义的类，也一样如此：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):pass
try:
    raise MyError('something wrong')
except MyError as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不仅如此，虽然异常实例对象是一个对象，但如果直接输出实例对象，那么得到的结果将是给定的异常信息，只不过它不在元组中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I = IndexError(&quot;index wrong&quot;)
print(I)      # 输出&quot;index wrong&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易想到，这是因为Exception类中重写了&lt;code&gt;__str__&lt;/code&gt;或者&lt;code&gt;__repr__&lt;/code&gt;中的某一个或两个都重写了。&lt;/p&gt;
&lt;h3 id=&quot;自定义异常输出&quot;&gt;自定义异常输出&lt;/h3&gt;
&lt;p&gt;于是，自定义异常类的时候，也可以重写这两个中的一个，从而可以定制属于自己的异常类的输出信息。一般来说只重写&lt;code&gt;__str__&lt;/code&gt;，因为Exception中也是重写该类，且它的优先级高于&lt;code&gt;__repr__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如下面自定义的异常类。当然，这个示例的效果非常简陋，但已足够说明问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __str__(self):
        return 'output this message for something wrong'

try:
    raise MyError(&quot;hahhaha&quot;)
except MyError as E:
    print(E)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;output this message for something wrong&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提供构造方法&quot;&gt;提供构造方法&lt;/h3&gt;
&lt;p&gt;自定义异常类的时候，可以重写构造方法&lt;code&gt;__init__()&lt;/code&gt;，这样raise异常的时候，可以指定构造的数据。而且更进一步的，还可以重写&lt;code&gt;__str__&lt;/code&gt;来自定义异常输出。&lt;/p&gt;
&lt;p&gt;例如，格式化文件的程序中定义一个异常类，用来提示解析到哪个文件的哪一行出错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __init__(self,line,file):
        self.line = line
        self.file = file
    def __str__(self):
        return &quot;format failed: %s at %s&quot; % (self.file, self.line)

def format():
    ...
    raise MyError(42, &quot;a.json&quot;)
    ...

try:
    format()
except MyError as E:
    print(E)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提供异常类的其它方法&quot;&gt;提供异常类的其它方法&lt;/h3&gt;
&lt;p&gt;异常类既然是类，说明它可以像普通类一样拿来应用。比如添加其它类方法。&lt;/p&gt;
&lt;p&gt;例如，可以将异常信息写入到文件中。只需提供一个向文件写入的方法，并在except的语句块中调用这个方法即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __init__(self, line, file):
        self.line = line
        self.file = file

    def logerr(self):
        with open('Error.log', 'a') as logfile:
            print(self, file=logfile)

    def __str__(self):
        return &quot;format failed: %s at %s&quot; % (self.file, self.line)

def format():
    raise MyError(42, &quot;a.json&quot;)

try:
    format()
except MyError as E:
    E.logerr()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 13 Dec 2018 14:35:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>入门示例 异常处理：try/except 对于索引查找的操作，在索引越界搜索的时候会报错。例如： 所报的错误是IndexError。如果将索引查找放在一个函数里： 那么调用函数的时候，如果里面的索引越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10116936.html</dc:identifier>
</item>
<item>
<title>自制 COCO api 直接读取类 COCO 的标注数据的压缩文件 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/10116893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/10116893.html</guid>
<description>&lt;p&gt;COCO 数据库是由微软发布的一个大型图像数据集，该数据集专为对象检测、分割、人体关键点检测、语义分割和字幕生成而设计。如果你要了解 COCO 数据库的一些细节，你可以参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MS COCO 数据集主页：http://mscoco.org/&lt;/li&gt;
&lt;li&gt;我改写的 COCO API 网址：https://github.com/Xinering/cocoapi&lt;/li&gt;
&lt;li&gt;数据下载: http://mscoco.org/dataset/#download&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cocodataset/cocoapi&quot;&gt;COCO API&lt;/a&gt; 提供了 Matlab, Python 和 Lua 的 API 接口。该 API 接口提供完整的图像标签数据的加载，解析和可视化的工作。此外，网站还提供了与数据相关的文章，教程等。&lt;/p&gt;
&lt;p&gt;在使用 COCO 数据库提供的 API 和 demo 之前，我们首先需要下载 COCO 的图像和标签数据：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图像数据下载到 &lt;code&gt;coco/images/&lt;/code&gt; 文件夹中&lt;/li&gt;
&lt;li&gt;标签数据下载到 &lt;code&gt;coco/annotations/&lt;/code&gt; 文件夹中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本章快报：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;介绍和使用官方 API：详细说明如何在 Linux 和 Windows 系统下使用 cocoapi&lt;/li&gt;
&lt;li&gt;改写官方 API：利用 Python 的特性对 API 进行改写，同时支持直接读取压缩文件&lt;/li&gt;
&lt;li&gt;API 扩展：将 API 推广至其他数据集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来探讨一下如何利用 Python 来使用 COCO 数据集？&lt;/p&gt;
&lt;h2 id=&quot;coco-api-的配置与简介&quot;&gt;6.1 COCO API 的配置与简介&lt;/h2&gt;
&lt;p&gt;为了方便操作，我们先 fork 官方 &lt;a href=&quot;https://github.com/cocodataset/cocoapi&quot;&gt;COCO API&lt;/a&gt;，然后下载到本地，并切换到 API 所在目录，如 &lt;code&gt;D:\API\cocoapi\PythonAPI&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;cd D:\API\cocoapi\PythonAPI&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开当前目录下的 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/Makefile&quot;&gt;Makefile&lt;/a&gt; 可以看到 API 的安装和使用说明。&lt;/p&gt;
&lt;h3 id=&quot;windows-的配置&quot;&gt;6.1.1 Windows 的配置&lt;/h3&gt;
&lt;p&gt;在 Windows 下直接运行 &lt;code&gt;python setup.py build_ext --inplace&lt;/code&gt; 会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128171152074-712787406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows 中 （一般需要安装 visual studio）有许多的坑，参考 &lt;a href=&quot;https://www.jianshu.com/p/de455d653301&quot;&gt;Windows 10 编译 Pycocotools 踩坑记&lt;/a&gt; 暴力删掉参数 &lt;code&gt;Wno-cpp&lt;/code&gt; 和 &lt;code&gt;Wno-unused-function&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128172018282-613145959.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们便可以在 Python 中使用 &lt;code&gt;pycocotools&lt;/code&gt;，不过每次你想要调用 &lt;code&gt;pycocotools&lt;/code&gt; 需要先载入局部环境：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
sys.path.append('D:\API\cocoapi\PythonAPI')   # 将你的 `pycocotools` 所在路径添加到系统环境&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不想这么麻烦，你可以直接将 &lt;code&gt;pycocotools&lt;/code&gt; 安装在你的主环境下：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;cd D:\API\cocoapi\PythonAPI

python setup.py build_ext install
rd build   # 删除&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，这样并没有解决根本问题，还有许多 bug 需要你自己调，因而在第 6.2 节 介绍了 cocoapi 对 Windows 系统更加的友好实现。&lt;/p&gt;
&lt;h3 id=&quot;linux-下的配置&quot;&gt;6.1.2 Linux 下的配置&lt;/h3&gt;
&lt;p&gt;在 Linux 下，不需要上面这么多编译步骤，我们直接在终端输入下列命令即可正常使用 COCO API：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;pip3 install -U Cython
pip3 install -U pycocotools&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以使用和 Windows 系统同样的处理方法，具体操作方法也可以参考 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/Makefile&quot;&gt;Makefile&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;api-简介&quot;&gt;6.1.3 API 简介&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Xinering/cocoapi&quot;&gt;COCO API&lt;/a&gt; 可以帮助你载入、解析和可视化 annotations。 该 API 支持 multiple annotation 格式 (详情见 &lt;a href=&quot;http://cocodataset.org/#format-data&quot;&gt;data format&lt;/a&gt;). 更多关于 API 的细节可参考 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/coco.py&quot;&gt;coco.py&lt;/a&gt;，同时 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocoDemo.ipynb&quot;&gt;Python API demo&lt;/a&gt; 也提供了API 的英文使用说明。&lt;/p&gt;
&lt;p&gt;下面从官方页面截了张 COCO API 的记号说明的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128204835168-782917471.png&quot; alt=&quot;cocoapi&quot;/&gt;&lt;/p&gt;
&lt;p&gt;COCO 还为每个实例对象提供了分割掩码（segmentation masks），但是产生了两个挑战：紧凑地存储掩码和高效地执行掩码计算。 MASK API 使用自定义运行长度编码 (Run Length Encoding, RLE) 方案解决这两个难题。RLE 表示的大小与掩码的边界像素数成正比，并且可以在 RLE 上直接有效地计算操作 (如面积、联合或交集)。具体来说，假设 shapes 相当简单, RLE 表示形式为 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;, 其中 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 是对象中的像素数, 而通常计算量同样是 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;。在解码掩码 (存储为阵列) 上进行相同操作的自然的计算量将是 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Mask API 提供了一个用于操作以 RLE 格式存储的掩码的接口。这个 API 被定义在 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/mask.py&quot;&gt;mask.py&lt;/a&gt;。最后, 大多数 ground truth masks 存储为多边形 (相当紧凑), 这些多边形在需要时转换为 RLE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128214541861-1026383433.png&quot; alt=&quot;MASK&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，cocoapi 的介绍便宣告结束了，具体使用细则可以参考&lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocoDemo.ipynb&quot;&gt;pycocoDemo.ipynb&lt;/a&gt; 提供的 cocoapi 的使用 demo，我已经翻译成中文，大家可以查阅：&lt;a href=&quot;https://www.cnblogs.com/q735613050/p/8969452.html&quot;&gt;COCO 数据集的使用&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;改写-coco-api-的初衷&quot;&gt;6.2 改写 COCO API 的初衷&lt;/h2&gt;
&lt;p&gt;前文我一直在说 cocoapi 对 Windows 系统不友好，相信在 Windows 系统下使用过 cocoapi 的朋友一定会十分赞同的。&lt;/p&gt;
&lt;h3 id=&quot;why-api-改写的目的&quot;&gt;6.2.1 Why? API 改写的目的&lt;/h3&gt;
&lt;p&gt;为了在 Windows 系统下更加友好的使用 cocoapi，抛去各种调 bug 的烦恼，我们十分有必要对 cocoapi 进行改写。但是，完全改写源码是有点让人感到恐惧的事情，而 Python 是一个十分强大的语言，我们利用它的继承机制可以无压力改写代码。&lt;/p&gt;
&lt;h3 id=&quot;what-api-可以做什么&quot;&gt;6.2.2 What? API 可以做什么&lt;/h3&gt;
&lt;p&gt;读者朋友是不是感觉改写 API 在做无用功，我们直接在 Linux 系统使用 cocoapi 也没有这么多的烦恼，为什么一定要改写？因为，改写后的 API 除了可以直接在 Windows 系统友好使用之外，它还提供了无需解压（直接跳过解压）直接获取标注信息和图片的功能。&lt;/p&gt;
&lt;h3 id=&quot;how-api-如何设计&quot;&gt;6.2.3 How? API 如何设计&lt;/h3&gt;
&lt;p&gt;我们在 cocoapi 所在目录 &lt;code&gt;D:\API\cocoapi\PythonAPI\pycocotools&lt;/code&gt; 下创建 &lt;code&gt;cocoz.py&lt;/code&gt; 文件。下面我们来一步一步的填充 &lt;code&gt;cocoz.py&lt;/code&gt;。为了方便调试，我们先在 Notebook 模式下设计该 API，设计好之后，我们再封装到 &lt;code&gt;cocoz.py&lt;/code&gt; 文件中。为了令 cocoapi 可以使用，需要先载入环境：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
sys.path.append(r'D:\API\cocoapi\PythonAPI')

from pycocotools.coco import COCO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们需要直接读取压缩文件，因而我们需要 &lt;code&gt;zipfile&lt;/code&gt;，为了减少代码编写的工作量，我们直接借用 cocoapi 的 &lt;code&gt;COCO&lt;/code&gt; 类。又因为标注信息是以 &lt;code&gt;.json&lt;/code&gt; 形式存储的，所以载入 &lt;code&gt;json&lt;/code&gt; 也是必要的，而 &lt;code&gt;numpy&lt;/code&gt; 和 &lt;code&gt;cv2&lt;/code&gt; 处理图片数据的重要工具当然也需要。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os
import zipfile
import numpy as np
import cv2
import json
import time&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更加方便的查看某个函数运行时间，我们需要一个计时器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def timer(func):
    '''
    Define a timer, pass in one, and
    return another method with the timing feature attached
    '''
    def wrapper(*args):
        start = time.time()
        print('Loading json in memory ...')
        value = func(*args)
        end = time.time()
        print('used time: {0:g} s'.format(end - start))
        return value

    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我将 COCO 的所有数据都下载到了磁盘，我们可以查看如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据根目录

dataDir = os.path.join(root, 'images')  #  图片所在目录
annDir = os.path.join(root, 'annotations')  # 标注信息所在目录

print('images:\n',os.listdir(dataDir))
print('='*50)
print('annotations:\n',os.listdir(dataDir))
print(os.listdir(annDir))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;images:
['test2014.zip', 'test2015.zip', 'test2017.zip', 'train2014.zip', 'train2017.zip', 'unlabeled2017.zip', 'val2014.zip', 'val2017.zip']
==================================================
annotations:
['test2014.zip', 'test2015.zip', 'test2017.zip', 'train2014.zip', 'train2017.zip', 'unlabeled2017.zip', 'val2014.zip', 'val2017.zip']
['annotations_trainval2014.zip', 'annotations_trainval2017.zip', 'image_info_test2014.zip', 'image_info_test2015.zip', 'image_info_test2017.zip', 'image_info_unlabeled2017.zip', 'panoptic_annotations_trainval2017.zip', 'stuff_annotations_trainval2017.zip']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出：所有数据我都没有解压，下面我们将动手设计一个无需解压便可获取数据信息的接口。&lt;/p&gt;
&lt;h2 id=&quot;imagez-的设计和使用&quot;&gt;6.3 ImageZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;我们先设计一个用来处理 &lt;code&gt;coco/images/&lt;/code&gt; 文件夹下的图片数据集的类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ImageZ(dict):
    '''
    Working with compressed files under the images
    '''

    def __init__(self, root, dataType, *args, **kwds):
        '''
        root:: root dir
        dataType in ['test2014', 'test2015',
                    'test2017', 'train2014',
                    'train2017', 'unlabeled2017',
                    'val2014', 'val2017']
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.shuffle = True if dataType.startswith('train') else False
        self.Z = self.__get_Z(root, dataType)
        self.names = self.__get_names(self.Z)
        self.dataType = self.Z.namelist()[0]

    @staticmethod
    def __get_Z(root, dataType):
        '''
        Get the file name of the compressed file under the images
        '''
        dataType = dataType + '.zip'
        img_root = os.path.join(root, 'images')
        return zipfile.ZipFile(os.path.join(img_root, dataType))

    @staticmethod
    def __get_names(Z):
        names = [
            name.split('/')[1] for name in Z.namelist()
            if not name.endswith('/')
        ]
        return names

    def buffer2array(self, image_name):
        '''
        Get picture data directly without decompression

        Parameters
        ===========
        Z:: Picture data is a ZipFile object
        '''
        image_name = self.dataType + image_name
        buffer = self.Z.read(image_name)
        image = np.frombuffer(buffer, dtype=&quot;B&quot;)  # 将 buffer 转换为 np.uint8 数组
        img_cv = cv2.imdecode(image, cv2.IMREAD_COLOR)  # BGR 格式
        img = cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB)
        return img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码这么长看着是不是有点懵，具体细节大家自己琢磨，我们直接看看它有什么神奇之处？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataDir = r'E:\Data\coco'   # COCO 数据根目录
dataType = 'val2017'
imgZ = ImageZ(dataDir, dataType)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;imgZ&lt;/code&gt; 继承自 &lt;code&gt;dict&lt;/code&gt;，所以它拥有字典的几乎所有属性和功能：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;imgZ.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['shuffle', 'Z', 'names', 'dataType'])&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;names&lt;/code&gt;：存储了 &lt;code&gt;val2017.zip&lt;/code&gt; 的所有图片的文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shuffle&lt;/code&gt;：判断是否是训练数据集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Z&lt;/code&gt;：&lt;code&gt;ZipFile&lt;/code&gt; 对象，用来操作整个 &lt;code&gt;val2017.zip&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一个实例方法 &lt;code&gt;buffer2array&lt;/code&gt; 可以直接通过图片的文件名获取其像素级特征。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;fname = imgZ.names[77]  # 一张图片的文件名
img = imgZ.buffer2array(fname)  # 获取像素级特征&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;img&lt;/code&gt; 是 Numpy 数组，这样我们就可以对其进行各种我们熟悉的操作，如图片显示：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt

plt.imshow(img)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222516954-1842373832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经完成无需解压直接读取图片的工作。&lt;/p&gt;
&lt;h2 id=&quot;annz-的设计和使用&quot;&gt;6.4 AnnZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AnnZ(dict):
    '''
    Working with compressed files under annotations
    '''

    def __init__(self, root, annType, *args, **kwds):
        '''
        dataType in [
              'annotations_trainval2014',
              'annotations_trainval2017',
              'image_info_test2014',
              'image_info_test2015',
              'image_info_test2017',
              'image_info_unlabeled2017',
              'panoptic_annotations_trainval2017',
              'stuff_annotations_trainval2017'
        ]
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.Z = self.__get_Z(root, annType)
        self.names = self.__get_names(self.Z)

    @staticmethod
    def __get_Z(root, annType):
        '''
        Get the file name of the compressed file under the annotations
        '''
        annType = annType + '.zip'
        annDir = os.path.join(root, 'annotations')
        return zipfile.ZipFile(os.path.join(annDir, annType))

    @staticmethod
    def __get_names(Z):
        names = [name for name in Z.namelist() if not name.endswith('/')]
        return names

    @timer
    def json2dict(self, name):
        with self.Z.open(name) as fp:
            dataset = json.load(fp)
        return dataset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们直接看看如何使用？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型

annZ = AnnZ(root, annType)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来查看一下，该标注数据所包含的标注种类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;annZ.names&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['annotations/instances_train2017.json',
 'annotations/instances_val2017.json',
 'annotations/captions_train2017.json',
 'annotations/captions_val2017.json',
 'annotations/person_keypoints_train2017.json',
 'annotations/person_keypoints_val2017.json']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面以 &lt;code&gt;dict&lt;/code&gt; 的形式载入 'annotations/instances_train2017.json' 的具体信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;annFile = 'annotations/instances_val2017.json'
dataset = annZ.json2dict(annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 1.052 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以查看 &lt;code&gt;dataset&lt;/code&gt; 的关键字：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['info', 'licenses', 'images', 'annotations', 'categories'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们可以很方便的使用 &lt;code&gt;dict&lt;/code&gt; 的相关操作获取我们想要的一些信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset['images'][7]  # 查看一张图片的一些标注信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{'license': 6,
'file_name': '000000480985.jpg',
'coco_url': 'http://images.cocodataset.org/val2017/000000480985.jpg',
'height': 500,
'width': 375,
'date_captured': '2013-11-15 13:09:24',
'flickr_url': 'http://farm3.staticflickr.com/2336/1634911562_703ff01cff_z.jpg',
'id': 480985}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以利用 &lt;code&gt;'coco_url'&lt;/code&gt; 直接从网上获取图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
import skimage.io as sio

coco_url = dataset['images'][7]['coco_url']
# use url to load image
I = sio.imread(coco_url)
plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222535903-113671340.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助 ImageZ 从本地读取图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
imgType = 'val2017'
imgZ = ImageZ(root, imgType)

I = imgZ.buffer2array(dataset['images'][100]['file_name'])

plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222613885-1170522480.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cocoz-的设计和使用&quot;&gt;6.5 COCOZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;ImageZ 和 AnnZ 虽然很好用，但是它们的灵活性太大，并且现在的开源代码均是基于 COCO 类进行设计的。为了更加契合 cocoapi 我们需要一个中转类 COCOZ 去实现和 COCO 几乎一样的功能，并且使用方法也尽可能的保留。具体是代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class COCOZ(COCO, dict):
    def __init__(self, annZ, annFile, *args, **kwds):
        '''
        ptint(coco):: View Coco's Instance object Coco's 'info'

        example
        ==========
        annZ = AnnZ(annDir, annType)
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.dataset = annZ.json2dict(annFile)
        self.createIndex()

    @timer
    def createIndex(self):
        # create index
        print('creating index...')
        cats, anns, imgs = {}, {}, {}
        imgToAnns, catToImgs = {}, {}
        if 'annotations' in self.dataset:
            for ann in self.dataset['annotations']:
                imgToAnns[ann['image_id']] = imgToAnns.get(
                    ann['image_id'], []) + [ann]
                anns[ann['id']] = ann
        if 'images' in self.dataset:
            for img in self.dataset['images']:
                imgs[img['id']] = img
        if 'categories' in self.dataset:
            for cat in self.dataset['categories']:
                cats[cat['id']] = cat
        if 'annotations' in self.dataset and 'categories' in self.dataset:
            for ann in self.dataset['annotations']:
                catToImgs[ann['category_id']] = catToImgs.get(
                    ann['category_id'], []) + [ann['image_id']]

        print('index created!')

        # create class members
        self.anns = anns
        self.imgToAnns = imgToAnns
        self.catToImgs = catToImgs
        self.imgs = imgs
        self.cats = cats

    def __str__(self):
        &quot;&quot;&quot;
        Print information about the annotation file.
        &quot;&quot;&quot;
        S = [
            '{}: {}'.format(key, value)
            for key, value in self.dataset['info'].items()
        ]
        return '\n'.join(S)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们直接看看如何使用 COCOZ？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/instances_val2017.json'

annZ = AnnZ(root, annType)
coco = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 1.036 s
Loading json in memory ...
creating index...
index created!
used time: 0.421946 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你需要预览你载入的 COCO 数据集，可以使用 &lt;code&gt;print()&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(coco)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;description: COCO 2017 Dataset
url: http://cocodataset.org
version: 1.0
year: 2017
contributor: COCO Consortium
date_created: 2017/09/01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;coco.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['dataset', 'anns', 'imgToAnns', 'catToImgs', 'imgs', 'cats'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;展示-coco-的类别与超类&quot;&gt;6.5.1 展示 COCO 的类别与超类&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cats = coco.loadCats(coco.getCatIds())
nms = set([cat['name'] for cat in cats])  # 获取 cat 的 name 信息
print('COCO categories: \n{}\n'.format(' '.join(nms)))
# ============================================================
snms = set([cat['supercategory'] for cat in cats])  # 获取 cat 的 name 信息
print('COCO supercategories: \n{}'.format(' '.join(snms)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;COCO categories:
kite sports ball horse banana toilet mouse frisbee bed donut clock sheep keyboard tv cup elephant cake potted plant snowboard train zebra fire hydrant handbag cow wine glass bowl sink parking meter umbrella giraffe suitcase skis surfboard stop sign bear cat chair traffic light fork truck orange carrot broccoli couch remote hair drier sandwich laptop tie person tennis racket apple spoon pizza hot dog bird refrigerator microwave scissors backpack airplane knife baseball glove vase toothbrush book bottle motorcycle bicycle car skateboard bus dining table cell phone toaster boat teddy bear dog baseball bat bench oven

COCO supercategories:
animal kitchen food appliance indoor accessory person sports furniture outdoor electronic vehicle&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过给定条件获取图片&quot;&gt;6.5.2 通过给定条件获取图片&lt;/h3&gt;
&lt;p&gt;获取包含给定类别的所有图片&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# get all images containing given categories, select one at random
catIds = coco.getCatIds(catNms=['cat', 'dog', 'snowboar'])  # 获取 Cat 的 Ids
imgIds = coco.getImgIds(catIds=catIds )  # 
img = coco.loadImgs(imgIds)
# 随机选择一张图片的信息
img = coco.loadImgs(imgIds[np.random.randint(0,len(imgIds))])[0]

img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{'license': 3,
'file_name': '000000179392.jpg',
'coco_url': 'http://images.cocodataset.org/val2017/000000179392.jpg',
'height': 640,
'width': 480,
'date_captured': '2013-11-18 04:07:31',
'flickr_url': 'http://farm5.staticflickr.com/4027/4329554124_1ce02506f8_z.jpg',
'id': 179392}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将图片的-anns-信息标注在图片上&quot;&gt;6.5.3 将图片的 anns 信息标注在图片上&lt;/h3&gt;
&lt;p&gt;先从本地磁盘获取一张图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
imgType = 'val2017'
imgZ = ImageZ(root, imgType)

I = imgZ.buffer2array(dataset['images'][55]['file_name'])

plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222634810-1586403502.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将标注信息加入图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load and display instance annotations
plt.imshow(I)
plt.axis('off')
annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
anns = coco.loadAnns(annIds)
coco.showAnns(anns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222650232-1068692901.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关键点检测&quot;&gt;6.5.4 关键点检测&lt;/h3&gt;
&lt;p&gt;载入标注信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# initialize COCO api for person keypoints annotations
root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/person_keypoints_val2017.json'

annZ = AnnZ(root, annType)
coco_kps = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 0.924155 s
Loading json in memory ...
creating index...
index created!
used time: 0.378003 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先选择一张带有 person 的图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt

catIds = coco.getCatIds(catNms=['person'])  # 获取 Cat 的 Ids
imgIds = coco.getImgIds(catIds=catIds)  
img = coco.loadImgs(imgIds)[99]
# use url to load image
I = sio.imread(img['coco_url'])
plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222710248-1937593350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将标注加到图片上：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load and display keypoints annotations
plt.imshow(I); plt.axis('off')
ax = plt.gca()
annIds = coco_kps.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
anns = coco_kps.loadAnns(annIds)
coco_kps.showAnns(anns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222723816-567517866.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;看图说话&quot;&gt;6.5.5 看图说话&lt;/h3&gt;
&lt;p&gt;载入标注信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# initialize COCO api for person keypoints annotations
root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/captions_val2017.json'

annZ = AnnZ(root, annType)
coco_caps = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 0.0760329 s
Loading json in memory ...
creating index...
index created!
used time: 0.0170002 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将标注加到图片上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A man riding on a skateboard on the sidewalk.
a kid riding on a skateboard on the cement
There is a skateboarder riding his board on the sidewalk
A skateboarder with one fut on a skateboard raising it up.
A pavement where a person foot are seen having skates.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222742261-49376028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经完成了我们的预期目标。&lt;/p&gt;
&lt;h2 id=&quot;让-api-更加通用&quot;&gt;6.6 让 API 更加通用&lt;/h2&gt;
&lt;p&gt;虽然我们完成了预期目标，但是 &lt;code&gt;cocoz.py&lt;/code&gt; 还有很大的改进余地。比如我们可以令 ImageZ 变得像列表一样，支持索引和切片。为了优化结构，我们可以将其封装为生成器。基于这些想法我们便得到一个改进版的 ImageZ，只需添加几个实例方法即可：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def __getitem__(self, item):
    names = self.names[item]
    if isinstance(item, slice):
        return [self.buffer2array(name) for name in names]
    else:
        return self.buffer2array(names)


def __len__(self):
    return len(self.names)


def __iter__(self):
    for name in self.names:
        yield self.buffer2array(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细代码被我放在：&lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/cocoz.py&quot;&gt;cocoz.py&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;小节&quot;&gt;6.7 小节&lt;/h2&gt;
&lt;p&gt;本章主要介绍了 COCO 数据及其 API cocoapi ，同时为了更好的使用 cocoapi，又自制了一个可以直接读取 &lt;code&gt;.zip&lt;/code&gt; 数据集的接口 &lt;code&gt;cocoz.py&lt;/code&gt;。同时，&lt;code&gt;cocoz.py&lt;/code&gt; 也可以用来直接读取以 COCO 标注数据形式封装的其他数据集。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 14:28:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>第6章 COCO API 的使用 COCO 数据库是由微软发布的一个大型图像数据集，该数据集专为对象检测、分割、人体关键点检测、语义分割和字幕生成而设计。如果你要了解 COCO 数据库的一些细节，你可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/10116893.html</dc:identifier>
</item>
<item>
<title>金融数据分析与挖掘具体实现方法 -2 - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/10116572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/10116572.html</guid>
<description>&lt;p&gt;貌似三个月没有更新博客园了，当时承诺的第二篇金融数据分析与挖掘这几天刚好又做了总结，在国内经济不景气的现在来对这个话题结个尾。&lt;/p&gt;

&lt;h2 id=&quot;611-投资的两种方法&quot;&gt;1.1 投资的两种方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;技术分析&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;基本面分析&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;基本面分析又称基本分析，是以证券的内在为依据，着重于对影响证券价格及其走势的各项因素的分析，宏观数据、市场行为、企业财务数据、交易数据等进行分析，以此决定投资购买何种证券及何时购买。&lt;code&gt;主要是用利用数学、统计技术、机器学习技术获得投资机会。&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：大型的基金、券商、投资机构大多数投资股票使用基本面分析方式。量化投资中基本面分析得益于一些市场模型理论的提出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;         趋势追踪，就是假设之前价格的上涨预示着之后一段时间内也会上涨，很多交易都是围绕着趋势追踪模型。比如各种突破的信号等。 趋势追踪属于技术分析。&lt;/h3&gt;
&lt;h3&gt;常用的技术指标：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;MACD&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;RSI&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;BOLL&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;接下来我们挨个分析，首先要了解一下什么是双均线策略&lt;/h3&gt;
&lt;h3&gt;双均线策略是量化策略中经典的策略之一，其属于趋势跟踪策略，实现思想如下：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;预设两条均线一条长均线、一条短均线。比如一个ma=5，一个ma=60, 5的均线被称作快线，60的均线被称作慢线&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;买入策略中当快线上穿慢线（ma5上穿ma60）称为形成金叉买点信号，买入股票&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;卖出策略中当快线下穿慢线（ma5下穿ma60）称为形成死叉卖点信号，卖出股票&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213204035053-1881250200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6221-分析&quot;&gt;分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当快线穿过慢线的时候，代表最近价格已经上涨，之前的价格已经下跌一段时间&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6222-作用&quot;&gt;作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;比如macd，kdj等等依赖均线的技术指标，其核心思想都差不多，作为其他趋势策略的基础。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;63-macd分析&quot;&gt;2.1 MACD分析&lt;/h2&gt;
&lt;p&gt;第一个问题，什么是什么是MACD指标，请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213204305909-916273475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        指数平滑异同移动平均线（Moving Average Convergence /Divergence, MACD）是股票交易中一种常见的技术分析工具，由Gerald Appel于1970年代提出，用于研判股票价格变化的强度、方向、能量，以及趋势周期，以便把握股票买进和卖出的时机。&lt;/p&gt;
&lt;h2 id=&quot;632-macd的原理以及计算公式&quot;&gt;2.1.1 MACD的原理以及计算公式&lt;/h2&gt;
&lt;h3 id=&quot;6321-原理&quot;&gt;原理：MACD的意义和双移动平均线基本相同，即由快、慢均线的离散、聚合表征当前的多空状态和股价可能的发展变化趋势，但阅读起来更方便。&lt;/h3&gt;
&lt;h3 id=&quot;6322-计算公式&quot;&gt;计算公式：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;1、MACD首先行计算出快速（一般选12日）移动平均值与慢速（一般选26日）移动平均值&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;2、12日EMA数值减去26日EMA数值得到，差离值DIF&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;3、根据离差值计算其9日的EMA，即离差平均值，是所求的MACD值。为了不与指标原名相混淆，又名DEA或DEM(讯号线)&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;4、DIF与DEA的差值，为MACD柱状图&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6323-交易信号种类&quot;&gt;交易信号种类：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;差离值（DIF值）与讯号线（DEA值，又称MACD值）相交；&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;差离值与坐标轴相交；&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;股价与差离值的背离。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6324-交易信号分析&quot;&gt;交易信号分析：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;差离值和讯号线&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;差离值（MACD柱状图）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;1、当红柱状持续放大时，表明投资市场处于牛市行情中，价格走势将继续上涨，这时应持仓待涨或短线买入投资品种，直到红柱无法再放大时才考虑卖出&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;2、当绿柱状持续放大时，表明投资市场处于熊市行情之中，价格走势将继续下跌，这时应持币观望或卖出投资品种，直到绿柱开始缩小时才可以考虑少量买入投资品种。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;3、当红柱状开始缩小时，表明投资市场牛市即将结束（或要进入调整期），价格走势将大幅下跌，这时应卖出大部分投资品种而不能买入投资品种。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;4、当绿柱状开始收缩时，表明投资市场的大跌行情即将结束，价格走势将止跌向上（或进入盘整），这时可以少量进行长期战略建仓而不要轻易卖出投资品种。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;5、当红柱开始消失、绿柱开始放出时，这是投资市场转市信号之一，表明投资市场的上涨行情（或高位盘整行情）即将结束，价格走势将开始加速下跌，这时应开始卖出大部分投资品种而不能买入投资品种。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;6、当绿柱开始消失、红柱开始放出时，这也是投资市场转市信号之一，表明投资市场的下跌行情（或低位盘整）已经结束，价格走势将开始加速上升，这时应开始加码买入投资品种或持仓待涨。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;633-talib库进行指标运算&quot;&gt;2.1.2 TA-Lib库进行指标运算&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213205310234-1748294268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213205321377-493355879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;634-案例：-计算macd指标、画出图形&quot;&gt;2.1.3 接下来我们自己动手一步步计算MACD指标、然后画出图形&lt;/h2&gt;
&lt;h3&gt;效果图：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213205446764-88350730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;第一步：导入包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import pandas as pd
import talib
import matplotlib.pyplot as plt
import numpy as np
from mpl_finance import candlestick_ochl
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;6341-获取股票日线数据&quot;&gt;第二步：获取股票日线数据&lt;/h3&gt;
&lt;h4&gt;实现思路和步骤是:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h4&gt;从文件读取股票数据&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;按照日期索引排序&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;增加一列index索引数据, 后续不需要日期索引&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;抽取index, open, close, high, low五列数据, 后续用来计算MACD值, 其他的值不需要&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 读取日线的数据
stock_day = pd.read_csv(&quot;./data/stock_day/stock_day.csv&quot;)
stock_day = stock_day.sort_index()[:200]
stock_day['index'] = [i for i in range(stock_day.shape[0])]
arr = stock_day[['index', 'open', 'close', 'high', 'low']].values
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;6342-分析&quot;&gt;第三步：分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;计算MACD值的TA-Lib函数&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213205804470-557179058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;传入的参数序列必须是Numpy序列&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;返回的值&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;macd:差离值&lt;/li&gt;
&lt;li&gt;macdsignal:信号线&lt;/li&gt;
&lt;li&gt;macdhist:MACD柱状图值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;方法: 使用股票的收盘价格(close)去计算MACD指标数据 快速移动周期为12，慢速移动周期为26，DIF的移动平均线的周期为9日&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# dif: 12， 与26日的差别
# dea:dif的9日以移动平均线
dif, dea, macd_hist = talib.MACD(stock_day['close'].values, fastperiod=12, slowperiod=26, signalperiod=9)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;通过画图展示MACD值&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;步骤:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;构造画布，里面包含了一个axes&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;产生一个x的单维数组&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;画出DIF差离值线&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;画出MACD柱状图&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;显示一下K线图对比MACD指标图&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 构造画布，里面包含了一个axes
fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(20, 8), dpi=100)

# 产生一个x的单维数组
index = [i for i in range(200)]

# 画出dif这根差离值线
plt.plot(index, dif, color='y', label=&quot;差离值 DIF&quot;)
plt.plot(index, dea, color='b', label=&quot;讯号线 DEA&quot;)

# 画出MACD柱状图
# 分开正负的柱状图去画出来
# 画第一个bar， macd_hist，如果大于0， 保留当前值，如果小于0，变为0，得出一个red_hist
# 画出第二个bar，macd_hisr，如果小于0， 保留当前值，如果大于0，直接变为0
red_hist = np.where(macd_hist &amp;gt; 0 , macd_hist, 0)
green_hist = np.where(macd_hist &amp;lt; 0 , macd_hist, 0)

plt.bar(index, red_hist, label=&quot;红色MACD值&quot;, color='r')
plt.bar(index, green_hist, label=&quot;绿色MACD值&quot;, color='g')

# 显示一下K线图对比MACD指标图
candlestick_ochl(axes, arr, width=0.2, colorup='r', colordown='g')

plt.legend(loc=&quot;best&quot;)
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;    了解一下背离分析，如果解释得不全面可以自行百度：当股价创新低，但MACD并没有相应创新低（牛市背离或顶背离），视为利多讯息，股价跌势或将完结。相反，若股价创新高，但MACD并没有相应创新高（熊市背离或底背离），视为利空讯息。　&lt;/h4&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213210058462-2008209325.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213210115363-1326729685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213210124384-1461254216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;635-macd总结&quot;&gt;我们对MACD做个总结&lt;/h3&gt;
&lt;h4&gt;      MACD是一种中长线的研判指标。当股市强烈震荡或股价变化巨大（如送配股拆细等）时，可能会给出错误的信号。所以在决定股票操作时，应该谨慎参考其他指标，以及市场状况，不能完全信任差离值的单一研判，避免造成损失。&lt;/h4&gt;

&lt;h3&gt;　　什么是RSI？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213210343797-1449158141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;641-rsi相对强弱指数&quot;&gt;2.2.1 RSI相对强弱指数&lt;/h2&gt;
&lt;h4&gt;相对强弱指数（RSI）是通过比较一段时期内的平均收盘涨数和平均收盘跌数来分析市场买沽盘的意向和实力，从而作出未来市场的走势。&lt;/h4&gt;
&lt;h4&gt;注：RSI在1978年6月由WellsWider创制的一种通过特定时期内股价的变动情况计算市场买卖力量对比，来判断股票价格内部本质强弱、推测价格未来的变动方向的技术指标。&lt;/h4&gt;
&lt;h2 id=&quot;642-rsi原理和计算方法&quot;&gt;2.2.2 RSI原理和计算方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;1、相对强弱指标的区间段&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RSI6一般是6日相对强弱指标&lt;/li&gt;
&lt;li&gt;RSI12 一般是12日相对强弱指标&lt;/li&gt;
&lt;li&gt;RSI24一般是24日相对强弱指标&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;2、强弱指标的计算公式如下&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RSI=100×RS/(1+RS) 或者 RSI=100－100÷(1+RS)&lt;/li&gt;
&lt;li&gt;RS=X天的平均上涨点数/X天的平均下跌点数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;3、RS计算方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RS=14天内收市价上涨数之和的平均值/14天内收市价下跌数之和的平均值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;为了更好的理解上面的公式，通过下面的计算案例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213210705082-728312670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;643-rsi交易信号判断&quot;&gt;2.2.3 RSI交易信号判断&lt;/h2&gt;
&lt;h3 id=&quot;6431-rsi值的意义&quot;&gt;RSI值的意义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;（1）受计算公式的限制，不论价位如何变动，强弱指标的值均在0与100之间。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;（2）强弱指标保持高于50表示为强势市场，反之低于50表示为弱势市场。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;（3）强弱指标多在70与30之间波动。当六日指标上升到达80时，表示股市已有超买现象，如果一旦继续上升，超过90以上时，则表示已到严重超买的警戒区，股价已形成头部，极可能在短期内反转回转。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;比如：在牛市时，通常蓝筹股的强弱指数若是80，便属超买，若是30便属超卖，至于二三线股，强弱指数若是85至90，便属超买，若是20至25，便属超卖。因此我们对一只股票采取买/卖行动前，一定要先找出该只股票的超买/超卖水平。至于衡量一只股票的超买/超卖水平，我们可以参考该股票过去12个月之强弱指标记录。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6432-长短线结合来判断交易&quot;&gt;长短线结合来判断交易&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;1．白色的短期RSI值在20以下，由下向上交叉黄色的长期RSI值时为买入信号。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;2．白色的短期RSI值在80以上，由上向下交叉黄色的长期RSI值时为卖出信号。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;案例：rsi指标计算以及交易判断实现&quot;&gt;2.2.4 RSI指标计算以及交易判断实现&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;RSI指标计算&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213211111425-1127153840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;传入的参数序列必须是Numpy序列&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;real:返回固定区间内的柱状图值&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 通过taLib计算出RSI的指标值
# 断线RSI
short_rsi = talib.RSI(stock_day['close'].values, timeperiod=6)
# 长线RSI
long_rsi = talib.RSI(stock_day['close'].values, timeperiod=12)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　交易判断实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;卖出信号：在交叉点之前，短线&amp;lt; 长线，交叉点之后：断线 &amp;gt;长线&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;交易信号，卖出的判断：在交叉点之前，短线 &amp;gt; 长线，交叉点之后：短线 &amp;lt;长线&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 进行交易的一个判断
for i in range(1, 200):
    # 取出短线RSI
    s = short_rsi[i]

    # 取出长线的RSI值
    l = long_rsi[i]

    # 交易信号信号输入
    # 卖出信号：在交叉点之前，短线&amp;lt; 长线，交叉点之后：断线 &amp;gt;长线
    if s &amp;lt; 45 and short_rsi[i-1] &amp;lt; long_rsi[i-1] and short_rsi[i] &amp;gt; long_rsi[i]:

        # 进行买入
        print(&quot;买入某某股票多少股&quot;)

    # 交易信号，卖出的判断：在交叉点之前，短线 &amp;gt; 长线，交叉点之后：短线 &amp;lt;长线
    if s &amp;gt; 65 and short_rsi[i-1] &amp;gt; long_rsi[i-1] and short_rsi[i] &amp;lt; long_rsi[i]:

        print(&quot;卖出的某某股票多少股&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;644-rsi总结&quot;&gt;  我们对RSI做个总结&lt;/h3&gt;
&lt;h4&gt;    尤其在市场剧烈震荡时，还应参考其它指标进行综合分析，不能简单地依赖RSI的信号来作出买卖决定，可以和MACD结合一起使用。&lt;/h4&gt;

&lt;h2 id=&quot;651-boll指标&quot;&gt;2.3.1 BOLL指标&lt;/h2&gt;
&lt;h4&gt;布林线(BOLL)利用统计原理，求出的标准差及其信赖区间，从而确定股价的波动范围及未来走势，利用波带显示股价的安全高低价位，因而也被称为布林带。其上下限范围不固定，随股价的滚动而变化。股价波动在上限和下限的区间之内，这条带状区的宽窄，随着股价波动幅度的大小而变化，股价涨跌幅度加大时，带状区变宽，涨跌幅度狭小盘整时，带状区则变窄。&lt;/h4&gt;
&lt;blockquote&gt;
&lt;h4&gt;注：BOLL指标是美国股市分析家约翰·布林根据统计学中的标准差原理设计出来的一种非常简单实用的技术分析指标&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213211811274-959922207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;652-boll指标的计算方法&quot;&gt;2.3.2 BOLL指标的计算方法&lt;/h3&gt;
&lt;h4 id=&quot;6521-boll指标的计算公式&quot;&gt;BOLL指标的计算公式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;中轨线(MA)=N日的移动平均线&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;上轨线(UP)=中轨线＋两倍的标准差&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;下轨线(DN)=中轨线－两倍的标准差&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;6522、强弱指标的计算公式如下&quot;&gt;强弱指标的计算公式如下&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;计算N日内的收盘价的移动平均值MA&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;计算标准差MD&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213212827170-1907000829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;计算MB、UP、DN线&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;MB=（N－1）日的MA&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;UP=MB＋2×MD&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;DN=MB－2×MD&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;653-boll交易信号判断&quot;&gt;2.3.3 BOLL交易信号判断&lt;/h3&gt;
&lt;h4 id=&quot;6531-boll布林线的意义&quot;&gt;BOLL布林线的意义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;股价在中轨上方运行时属较安全状态，短线可持有观望。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;股价在中轨下方运行时属较危险状态，短线应趁反弹中轨时离场。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;股价突破上轨线后，回探中轨线时不跌破中轨线，显示后市看涨，可持股或加仓。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;股价跌破下轨线后，反弹中轨线时不站回中轨线以上，则后市看跌，要卖出。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;通道突然呈急剧变窄收拢形状时，显示股价方向将会发生重大转折，这时结合其他指数技术进行行情判断。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;6532-案例：boll布林线计算以及交易判断实现&quot;&gt;2.3.4 BOLL布林线计算以及交易判断实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;布林线指标计算&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1396321/201812/1396321-20181213213114515-1439199108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;close : 5日close的array，传入的参数序列必须是Numpy序列&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;timeperiod ：默认5天的平均线&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;nbdevip/nbdevdn : 默认2倍的标准差&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
upperband, middleband, lowerband = talib.BBANDS(df[&quot;close&quot;].values[:200],timeperiod=20,nbdevdn=2,nbdevup=2)
candlestick_ochl(axes[2],quotes=arr,width=0.2, colorup='r', colordown='g');
axes[2].plot(range(200),upperband)
axes[2].plot(range(200),middleband)
axes[2].plot(range(200),lowerband)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 13 Dec 2018 13:33:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<og:description>貌似三个月没有更新博客园了，当时承诺的第二篇金融数据分析与挖掘这几天刚好又做了总结，在国内经济不景气的现在来对这个话题结个尾。 1、(量化)投资的方法基础分析 1.1 投资的两种方法 技术分析 技术分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/10116572.html</dc:identifier>
</item>
<item>
<title>Python 读取图像文件的性能对比 - brifuture</title>
<link>http://www.cnblogs.com/brifuture/p/10116553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brifuture/p/10116553.html</guid>
<description>&lt;p&gt;使用 Python 读取一个保存在本地硬盘上的视频文件，视频文件的编码方式是使用的原始的 RGBA 格式写入的，即无压缩的原始视频文件。最开始直接使用 Python 对读取到的文件数据进行处理，然后显示在 Matplotlib 窗口上，后来发现视频播放的速度比同样的处理逻辑的 C++ 代码慢了很多，尝试了不同的方法，最终实现了在 Python 中读取并显示视频文件，帧率能够达到 120 FPS 以上。&lt;/p&gt;
&lt;h2 id=&quot;读取一帧图片数据并显示在窗口上&quot;&gt;读取一帧图片数据并显示在窗口上&lt;/h2&gt;
&lt;p&gt;最简单的方法是直接在 Python 中读取文件，然后逐像素的分配 RGB 值到窗口中，最开始使用的是 matplotlib 的 pyplot 组件。&lt;/p&gt;
&lt;p&gt;一些用到的常量：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;FILE_NAME = &quot;I:/video.dat&quot;
WIDTH = 2096
HEIGHT = 150
CHANNELS = 4
PACK_SIZE = WIDTH * HEIGHT * CHANNELS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每帧图片的宽度是 2096 个像素，高度是 150 个像素，CHANNELS 指的是 RGBA 四个通道，因此 PACK_SIZE 的大小就是一副图片占用空间的字节数。&lt;/p&gt;
&lt;p&gt;首先需要读取文件。由于视频编码没有任何压缩处理，大概 70s 的视频（每帧约占 1.2M 空间，每秒 60 帧）占用达 4Gb 的空间，所以我们不能直接将整个文件读取到内存中，借助 Python &lt;code&gt;functools&lt;/code&gt; 提供的 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;partial&lt;/a&gt; 方法，我们可以每次从文件中读取一小部分数据，将 partial 用 iter 包装起来，变成可迭代的对象，每次读取一帧图片后，使用 next 读取下一帧的数据，接下来先用这个方法将保存在文件中的一帧数据读取显示在窗口中。&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;with open( file, 'rb') as f:
    e1 = cv.getTickCount()
    records = iter( partial( f.read, PACK_SIZE), b'' )  # 生成一个 iterator
    frame = next( records ) # 读取一帧数据
    img = np.zeros( ( HEIGHT, WIDTH, CHANNELS ), dtype = np.uint8)
    for y in range(0, HEIGHT):
        for x in range( 0, WIDTH ):
            pos = (y * WIDTH + x) * CHANNELS
            for i in range( 0, CHANNELS - 1 ):
                img[y][x][i] = frame[ pos + i ]
            img[y][x][3] = 255
    plt.imshow( img )
    plt.tight_layout()
    plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
    plt.xticks([])
    plt.yticks([])
    e2 = cv.getTickCount()
    elapsed = ( e2 - e1 ) / cv.getTickFrequency()
    print(&quot;Time Used: &quot;, elapsed )
    plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要说明的是，在保存文件时第 4 个通道保存的是透明度，因此值为 0，但在 matplotlib （包括 opencv）的窗口中显示时第 4 个通道保存的一般是不透明度。我将第 4 个通道直接赋值成 255，以便能够正常显示图片。&lt;/p&gt;
&lt;p&gt;这样就可以在我们的窗口中显示一张图片了，不过由于图片的宽长比不协调，使用 matplotlib 绘制出来的窗口必须要缩放到很大才可以让图片显示的比较清楚。&lt;/p&gt;
&lt;p&gt;为了方便稍后的性能比较，这里统一使用 &lt;a href=&quot;https://opencv.org/&quot;&gt;opencv&lt;/a&gt; 提供的 &lt;code&gt;getTickCount&lt;/code&gt; 方法测量用时。可以从控制台中看到显示一张图片，从读取文件到最终显示大概要用 1.21s 的时间。如果我们只测量三层嵌套循环的用时，可以发现有 0.8s 的时间都浪费在循环上了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212543771-1195915904.png&quot;/&gt;&lt;br/&gt;读取并显示一帧图片用时 1.21s&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212614707-2075972699.png&quot;/&gt;&lt;br/&gt;在处理循环上用时 0.8s&lt;/p&gt;
&lt;p&gt;约百万级别的循环处理，同样的代码放在 C++ 里面性能完全没有问题，在 Python 中执行起来就不一样了。在 Python 中这样的处理速度最多就 1.2 fps。我们暂时不考虑其他方法进行优化，而是将多帧图片动态的显示在窗口上，达到播放视频的效果。&lt;/p&gt;
&lt;h2 id=&quot;连续读取图片并显示&quot;&gt;连续读取图片并显示&lt;/h2&gt;
&lt;p&gt;这时我们继续读取文件并显示在窗口上，为了能够动态的显示图片，我们可以使用 &lt;a href=&quot;https://matplotlib.org/api/animation_api.html&quot;&gt;matplotlib.animation&lt;/a&gt; 动态显示图片，之前的程序需要进行相应的改动:&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;fig = plt.figure()
ax1 = fig.add_subplot(1, 1, 1)
try:
    img = np.zeros( ( HEIGHT, WIDTH, CHANNELS ), dtype = np.uint8)
    f = open( FILE_NAME, 'rb' )
    records = iter( partial( f.read, PACK_SIZE ), b'' )
    
    def animateFromData(i):
        e1 = cv.getTickCount()
        frame = next( records ) # drop a line data
        for y in range( 0, HEIGHT ):
            for x in range( 0, WIDTH ):
                pos = (y * WIDTH + x) * CHANNELS
                for i in range( 0, CHANNELS - 1 ):
                    img[y][x][i] = frame[ pos + i]
                img[y][x][3] = 255
        ax1.clear()
        ax1.imshow( img )
        e2 = cv.getTickCount()
        elapsed = ( e2 - e1 ) / cv.getTickFrequency()
        print( &quot;FPS: %.2f,  Used time: %.3f&quot; % (1 / elapsed, elapsed ))

    a = animation.FuncAnimation( fig, animateFromData, interval=30 ) # 这里不要省略掉 a = 这个赋值操作
    plt.tight_layout()
    plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
    plt.xticks([])
    plt.yticks([])
    plt.show()
except StopIteration:
    pass
finally:
    f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和第 1 部分稍有不同的是，我们显示每帧图片的代码是在 &lt;code&gt;animateFromData&lt;/code&gt; 函数中执行的，使用 &lt;code&gt;matplotlib.animation.FuncAnimation&lt;/code&gt; 函数循环读取每帧数据（给这个函数传递的 interval = 30 这个没有作用，因为处理速度跟不上）。另外值得注意的是不要省略掉 &lt;code&gt;a = animation.FuncAnimation( fig, animateFromData, interval=30 )&lt;/code&gt; 这一行的赋值操作，虽然不太清楚原理，但是当我把 &lt;code&gt;a =&lt;/code&gt; 删掉的时候，程序莫名的无法正常工作了。&lt;/p&gt;
&lt;p&gt;控制台中显示的处理速度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212628220-396027122.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于对 matplotlib 的了解不多，最开始我以为是 matplotlib 显示图像过慢导致了帧率上不去，打印出代码的用时后发现不是 matplotlib 的问题。因此我也使用了 PyQt5 对图像进行显示，结果依然是 1~2 帧的处理速度。因为只是换用了 Qt 的界面进行显示，逻辑处理的代码依然沿用的 &lt;code&gt;matplotlib.animation&lt;/code&gt; 提供的方法，所以并没有本质上的区别。这段用 Qt 显示图片的代码来自于 &lt;a href=&quot;https://github.com/matplotlib/matplotlib/issues/9113&quot;&gt;github matplotlib issue&lt;/a&gt;，我对其进行了一些适配。&lt;/p&gt;
&lt;h2 id=&quot;使用-numpy-的数组处理-api&quot;&gt;使用 Numpy 的数组处理 api&lt;/h2&gt;
&lt;p&gt;我们知道，显示图片这么慢的原因就是在于 Python 处理 2096 * 150 这个两层循环占用了大量时间。接下来我们换用一种 &lt;a href=&quot;http://www.numpy.org/&quot;&gt;numpy&lt;/a&gt; 的 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.reshape.html&quot;&gt;reshape&lt;/a&gt; 方法将文件中的像素数据读取到内存中。注意 reshape 方法接收一个 ndarray 对象。我这种每帧数据创造一个 ndarray 数组的方法可能会存在内存泄漏的风险，实际上可以调用一个 ndarray 数组对象的 reshape 方法。这里不再深究。&lt;/p&gt;
&lt;p&gt;重新定义一个用于动态显示图片的函数 &lt;code&gt;optAnimateFromData&lt;/code&gt;，将其作为参数传递个 &lt;code&gt;FuncAnimation&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def optAnimateFromData(i):
    e1 = cv.getTickCount()
    frame = next( records ) # one image data
    img = np.reshape( np.array( list( frame ), dtype = np.uint8 ), ( HEIGHT, WIDTH, CHANNELS ) )
    img[ : , : , 3] = 255
    ax1.clear()
    ax1.imshow( img )
    e2 = cv.getTickCount()
    elapsed = ( e2 - e1 ) / cv.getTickFrequency()
    print( &quot;FPS: %.2f,  Used time: %.3f&quot; % (1 / elapsed, elapsed ))

a = animation.FuncAnimation( fig, optAnimateFromData, interval=30 )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下，可以看到使用 &lt;code&gt;numpy&lt;/code&gt; 的 &lt;code&gt;reshape&lt;/code&gt; 方法后，处理用时大幅减少，帧率可以达到 8~9 帧。然而经过优化后的处理速度仍然是比较慢的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212643141-351844158.png&quot;/&gt;&lt;br/&gt;优化过的代码执行结果&lt;/p&gt;
&lt;h2 id=&quot;使用-numpy-提供的-memmap&quot;&gt;使用 Numpy 提供的 memmap&lt;/h2&gt;
&lt;p&gt;在用 Python 进行机器学习的过程中，发现如果完全使用 Python 的话，很多运算量大的程序也是可以跑的起来的，所以我确信可以用 Python 解决我的这个问题。在我不懈努力下找到 Numpy 提供的 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html&quot;&gt;memmap&lt;/a&gt; api，这个 API 以数组的方式建立硬盘文件到内存的映射，使用这个 API 后程序就简单一些了：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;cv.namedWindow(&quot;file&quot;)
count = 0
start = time.time()
try:
    number = 1
    while True:
        e1 = cv.getTickCount()
        img = np.memmap(filename=FILE_NAME, dtype=np.uint8, shape=SHAPE, mode=&quot;r+&quot;, offset=count )
        count += PACK_SIZE
        cv.imshow( &quot;file&quot;, img )
        e2 = cv.getTickCount()
        elapsed = ( e2 - e1 ) / cv.getTickFrequency()
        print(&quot;FPS: %.2f Used time: %.3f&quot; % (number / elapsed, elapsed ))
        key = cv.waitKey(20)
        if key == 27:  # exit on ESC
            break
except StopIteration:
    pass
finally:
    end = time.time()
    print( 'File Data read: {:.2f}Gb'.format( count / 1024 / 1024 / 1024), ' time used: {:.2f}s'.format( end - start ) )
    cv.destroyAllWindows()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 memmap 读取到的数据 img 直接显示在窗口中 &lt;code&gt;cv.imshow( &quot;file&quot;, img)&lt;/code&gt;，每一帧打印出显示该帧所用的时间，最后显示总的时间和读取到的数据大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212704152-797890057.png&quot;/&gt;&lt;br/&gt;执行效率最高的结果&lt;/p&gt;
&lt;p&gt;读取速度非常快，每帧用时只需几毫秒。这样的处理速度完全可以满足 60FPS 的需求。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Python 语言写程序非常方便，但是原生的 Python 代码执行效率确实不如 C++，当然了，比 JS 还是要快一些。使用 Python 开发一些性能要求高的程序时，要么使用 Numpy 这样的库，要么自己&lt;a href=&quot;https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p15_c_extensions.html&quot;&gt;编写一个 C 语言库供 Python 调用&lt;/a&gt;。在实验过程中，我还使用 Flask 读取文件后以流的形式发送的浏览器，让浏览器中的 JS 文件进行显示，不过同样存在着很严重的性能问题和内存泄漏问题。这个过程留到之后再讲。&lt;/p&gt;
&lt;p&gt;本文中的相应代码可以在 &lt;a href=&quot;https://github.com/BriFuture/blog-code-example/tree/master/18-10to12/python_image_processing!%5B%5D(https://img2018.cnblogs.com/blog/1049594/201812/1049594-20181213212536353-785754815.png)&quot;&gt;github&lt;/a&gt; 上查看。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;functools partial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opencv.org/&quot;&gt;opencv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://matplotlib.org/api/animation_api.html&quot;&gt;matplotlib animation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.numpy.org/&quot;&gt;numpy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.15.1/reference/generated/numpy.reshape.html&quot;&gt;numpy reshape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html&quot;&gt;memmap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matplotlib/matplotlib/issues/9113&quot;&gt;matplotlib issue on github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p15_c_extensions.html&quot;&gt;C 语言扩展&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 13 Dec 2018 13:29:00 +0000</pubDate>
<dc:creator>brifuture</dc:creator>
<og:description>Python 读取图像文件的性能对比 使用 Python 读取一个保存在本地硬盘上的视频文件，视频文件的编码方式是使用的原始的 RGBA 格式写入的，即无压缩的原始视频文件。最开始直接使用 Pytho</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brifuture/p/10116553.html</dc:identifier>
</item>
<item>
<title>前端入门24-响应式布局（BootStrap） - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/10116533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/10116533.html</guid>
<description>&lt;p&gt;本篇内容摘抄自以下两个来源：&lt;/p&gt;
&lt;p&gt;感谢大佬们的分享。&lt;/p&gt;

&lt;p&gt;这次想来讲讲一个前端开发框架：BootStrap&lt;/p&gt;
&lt;p&gt;BootStrap 目前已经出了 4 个版本，每个版本都有对应的官网教程，先来看看不同版本里的宣传语：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。--- BootStrap 2.x.x 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 --- BootStrap 3.x.x 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。&lt;/p&gt;
&lt;p&gt;Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用我们提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为你的想法开发出原型或者构建整个 app 。 --- BootStrap 4.x.x 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，什么是响应式布局呢？&lt;/p&gt;
&lt;p&gt;通俗的理解，就是在不同的屏幕规格上能够有不同的布局效果，比如在大尺寸屏幕上呈现多列的布局，在小尺寸屏幕上呈现不了这么多，可能就只剩下一列布局了。&lt;/p&gt;
&lt;p&gt;那么，当屏幕尺寸发生变化时，在不同屏幕规格上，应该呈现怎样的布局，一般是通过媒体查询 @Media 来实现，但自己在 CSS 中书写的话，需要处理较多工作。&lt;/p&gt;
&lt;p&gt;所以，也可以选择一些热门的框架，由它来帮忙处理这些响应式布局的工作，就像 BootStrap，但 BootStrap 功能不仅只有响应式功能，它还内置了很多预制组件等等，总之，很强大，虽然我还没用过。&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;那就来学学如何使用，首先第一步肯定是安装，我直接选择最新版 4.x.x 系列的来作为入手了，旧版本没去了解，有机会再说。&lt;/p&gt;
&lt;p&gt;将 BootStrap 引入项目中使用有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接使用网上资源&lt;/li&gt;
&lt;li&gt;将相关资源下载至本地使用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用网上资源&quot;&gt;使用网上资源&lt;/h4&gt;
&lt;p&gt;第一种方式最简单，直接在 HTML 文档中声明 css 和 js 文件来源即可，如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;!-- Required meta tags --&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt;

    &amp;lt;!-- Bootstrap CSS --&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot; crossorigin=&quot;anonymous&quot;&amp;gt;

    &amp;lt;title&amp;gt;Hello, world!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;

    &amp;lt;!-- Optional JavaScript --&amp;gt;
    &amp;lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js&quot; integrity=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js&quot; integrity=&quot;sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js&quot; integrity=&quot;sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl&quot; crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 BootStrap，上面的 HTML 文档模板是必须的，带有注释的都是在所有使用了 BootStrap 的页面中需要引入的，需要注意的是，由于 BootStrap 一些组件依赖于 jQuery 和 Popper，所以需要引入这两份 js，而且顺序是 jQuery 先，Popper 后，最后再引入 BootStrap 提供的 bootstrap.min.js。&lt;/p&gt;
&lt;p&gt;这是第一种方式，也是最省力的。&lt;/p&gt;
&lt;h4 id=&quot;将资源下载至本地使用&quot;&gt;将资源下载至本地使用&lt;/h4&gt;
&lt;p&gt;这种方式就比较折腾了，好处就在于资源文件都可以放在自己服务器上，无需依赖他人。下载资源到本地也有两种方式，一是手动到官网下载，下面三个地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v4.bootcss.com/docs/4.0/getting-started/download/&quot;&gt;下载 BootStrap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jquery.com/download/&quot;&gt;下载 jQuery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/FezVrasta/popper.js#installation&quot;&gt;下载 popper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二是利用一些工具来下载，如 node.js 的 npm 命令来下载，打开终端，进入项目的根目录：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;npm init -y&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npm install bootstrap&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;npm install jquery&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;npm install popper.js --save&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果执行命令过程中报错了，自行去搜索解决吧，我是一次性成功，没出啥问题，都下载结束后，项目里的结构如下，node_modules 文件夹里会有下载好的资源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ab7880d54e0f6f7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;package.json 配置项如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ed196f8679e0e8ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我下载使用的版本。&lt;/p&gt;
&lt;p&gt;好，不管是手动去下载，还是接着 npm 下载，最后都需要将下载的资源放进项目中，那么，下载下来的这么多东西，该怎么用，哪些是有用的？&lt;/p&gt;
&lt;p&gt;可借鉴上面第一种方式里的 HTML 文档，总共需要的其实就四份文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.min.css&lt;/li&gt;
&lt;li&gt;jquery.slim.min.js&lt;/li&gt;
&lt;li&gt;popper.min.js&lt;/li&gt;
&lt;li&gt;bootstrap.min.js&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分别找下四份文件在哪，我的是在这几个路径下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;!-- Required meta tags --&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt;

    &amp;lt;!-- Bootstrap CSS --&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&amp;gt;

    &amp;lt;title&amp;gt;Hello, world!&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;

&amp;lt;!-- Optional JavaScript --&amp;gt;
&amp;lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&amp;gt;
&amp;lt;script src=&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;node_modules/popper.js/dist/popper.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;node_modules/bootstrap/dist/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;官方教程说了，上面这是使用 BootStrap 的 HTML 模板，当然也有进行了解释，下面稍微说说：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是 h5 的 HTML 文档的声明，不加这句的话，可能会出现一些奇怪的样式；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码表示的意思是，让网页可以自动适应当前移动设备的屏幕。&lt;/p&gt;
&lt;p&gt;所以，使用 BootStrap 除了需要在 HTML 文档中引入所需的资源文件外，别忘了加上上面两个处理。&lt;/p&gt;
&lt;h3 id=&quot;官方示例&quot;&gt;官方示例&lt;/h3&gt;
&lt;p&gt;BootStrap 4.x.x 版本，官方还没有中文教程，3.x.x 的中文教程倒是很齐全了。但 4.x.x 版本和 3.x.x 版本差别还是蛮大的，首先，4.x.x 选用 Sass 来作为预处理器，选择 flex 来实现它的栅格布局系统等等。&lt;/p&gt;
&lt;p&gt;反正，BootStrap 本质就就是一个框架，封装了一系列的属性样式、组件给开发者使用，开发者只要了解有哪些属性样式可以用、有哪些组件可以用、效果怎么样、怎么用就可以了，至于这些，就只能是一步步在实际开发中，一边写一边查文档来慢慢积累了。&lt;/p&gt;
&lt;p&gt;所以，本篇也就不会去列举各个组件效果、属性样式效果、还一个个去说明怎么用。&lt;/p&gt;
&lt;p&gt;接下去的内容，就是想着，能够读懂官方某个示例项目的代码就足够了。&lt;/p&gt;
&lt;p&gt;选择了官方的这个示例：&lt;a href=&quot;https://v4.bootcss.com/docs/4.0/examples/album/&quot;&gt;Album&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5c07defdb2056bed.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一步步来读懂它的 HTML 代码吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步就是 HTML 的模板了，就上一小节中介绍的，需要进行 H5 声明、meta 声明、引入四个资源文件的那份模板；&lt;/li&gt;
&lt;li&gt;第二步，来看看 &amp;lt;body&amp;gt; 内的 &amp;lt;header&amp;gt; 代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;!-- Required meta tags --&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt;

    &amp;lt;!-- Bootstrap CSS --&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&amp;gt;

    &amp;lt;title&amp;gt;Hello, world!&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--header 部分--&amp;gt;
&amp;lt;header&amp;gt;
    &amp;lt;div class=&quot;collapse bg-dark&quot; id=&quot;navbarHeader&quot;&amp;gt;
        &amp;lt;div class=&quot;container&quot;&amp;gt;
            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;col-sm-8 col-md-7 py-4&quot;&amp;gt;
                    &amp;lt;h4 class=&quot;text-white&quot;&amp;gt;About&amp;lt;/h4&amp;gt;
                    &amp;lt;p class=&quot;text-muted&quot;&amp;gt;Add some information about the album below, the author, or any other background context. Make it a few sentences long so folks can pick up some informative tidbits. Then, link them off to some social networking sites or contact information.&amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;col-sm-4 offset-md-1 py-4&quot;&amp;gt;
                    &amp;lt;h4 class=&quot;text-white&quot;&amp;gt;Contact&amp;lt;/h4&amp;gt;
                    &amp;lt;ul class=&quot;list-unstyled&quot;&amp;gt;
                        &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;text-white&quot;&amp;gt;Follow on Twitter&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                        &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;text-white&quot;&amp;gt;Like on Facebook&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                        &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;text-white&quot;&amp;gt;Email me&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;/ul&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;navbar navbar-dark bg-dark box-shadow&quot;&amp;gt;
        &amp;lt;div class=&quot;container d-flex justify-content-between&quot;&amp;gt;
            &amp;lt;a href=&quot;#&quot; class=&quot;navbar-brand d-flex align-items-center&quot;&amp;gt;
                &amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;mr-2&quot;&amp;gt;&amp;lt;path d=&quot;M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z&quot;&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;circle cx=&quot;12&quot; cy=&quot;13&quot; r=&quot;4&quot;&amp;gt;&amp;lt;/circle&amp;gt;&amp;lt;/svg&amp;gt;
                &amp;lt;strong&amp;gt;Album&amp;lt;/strong&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarHeader&quot; aria-controls=&quot;navbarHeader&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&amp;gt;
                &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;

&amp;lt;!-- Optional JavaScript --&amp;gt;
&amp;lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&amp;gt;
&amp;lt;script src=&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;node_modules/popper.js/dist/popper.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;node_modules/bootstrap/dist/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-3121815420e6b629.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前的代码里，我们完全没有写过 CSS，只在 HTML 文档中，添加了 &amp;lt;header&amp;gt; 标签内容，就能够达到这样的页面效果了，所以，其实，BootStrap 已经封装好了一大堆属性样式，我们只要在标签上通过 class 将这些属性样式应用起来就可以了。&lt;/p&gt;
&lt;p&gt;示例中使用的 class 很多，基本都是 BootStrap 封装好的，我也没想把所有用到的都搞清楚具体作用，只是想了解个大概，后续在使用中慢慢积累学习吧。&lt;/p&gt;
&lt;p&gt;对于这个 &amp;lt;header&amp;gt; 的效果，我主要想理清楚两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;展开和折叠是怎么实现的？&lt;/li&gt;
&lt;li&gt;展开时那些列表是如何实现的？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回过头看上面的动图，&amp;lt;header&amp;gt; 部分是作为导航栏，并且存在两种状态，折叠和展开，所以两种状态对应着两个 &amp;lt;div&amp;gt;，&amp;lt;header&amp;gt; 儿子标签里刚好两个 &amp;lt;div&amp;gt;；&lt;/p&gt;
&lt;p&gt;看第一个 &amp;lt;div&amp;gt; 的 class：&lt;code&gt;collapse bg-dark&lt;/code&gt;，collapse 是折叠的意思，所以第一个 &amp;lt;div&amp;gt; 就是一开始被折叠的容器，而控制这个 &amp;lt;div&amp;gt; 折叠起来，也就是 BootStrap 提供的 collapse 起的作用了；&lt;/p&gt;
&lt;p&gt;同层次的第二个 &amp;lt;div&amp;gt; 的 class：&lt;code&gt;navbar navbar-dark bg-dark box-shadow&lt;/code&gt;，两个 &amp;lt;div&amp;gt; 都有同一个 bg-dark，那么这个其实就是用来设置背景的，因为展开后，其实 &amp;lt;header&amp;gt; 区域是由两个 &amp;lt;div&amp;gt; 拼接起来的，只是背景色刚好一样，看不出来而已。&lt;/p&gt;
&lt;p&gt;所以，页面渲染后，其实有个 &amp;lt;div&amp;gt; 被 collapse 折叠起来了，此时页面上只呈现第二个 &amp;lt;div&amp;gt; 内容而已，这个 &amp;lt;div&amp;gt; 的高度等样式由 navbar、navbar-dark、bg-dark 这些决定。&lt;/p&gt;
&lt;p&gt;那么，点击完按钮后，第一个 &amp;lt;div&amp;gt; 为什么会被展开了呢？&lt;/p&gt;
&lt;p&gt;看一下那个按钮：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarHeader&quot; aria-controls=&quot;navbarHeader&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&amp;gt;
                &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;button&amp;gt; 的子标签 &amp;lt;span&amp;gt; 里的那个 navbar-toggler-icon 就是按钮的 icon，而之所以点击了后可以展开第一个 &amp;lt;div&amp;gt; 就是由其他属性来控制。&lt;/p&gt;
&lt;p&gt;首先，需要对当前这个按钮添加 navbar-toggler 的 class，然后需要通过 data-target 指明控制展开的区域，这也是为什么第一个 &amp;lt;div&amp;gt; 中会有一个 id 属性，就是用来给这个按钮控制它的。&lt;/p&gt;
&lt;p&gt;所以，梳理一下，通过给 &amp;lt;div&amp;gt; 添加 collapse 的 class 可以让这个区域折叠隐藏起来，然后给它设置一个 id；然后给控制这个折叠区域的按钮添加 data-toggle 和 data-target 属性，通过 id 来控制指定区域的折叠和展开。&lt;/p&gt;
&lt;p&gt;至于其他 class 则是各种样式效果。&lt;/p&gt;
&lt;p&gt;那么，展开之后的区域里的列表控件上，出现了一些例如：row，col-sm-8 之类的 class，这些又是什么意思呢？&lt;/p&gt;
&lt;p&gt;首先，container 来设定区域的大小，row 用来设置这个容器作为 flex 布局，而弹性布局中，一行会被划分成 12 列，看张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-03a91e133e27d79b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以 col-sm-8 表示当显示区域 &amp;gt;= 576px 时，该控件占据 8 列，所以，同一个控件里会出现诸如：&lt;code&gt;col-sm-8 col-md-7&lt;/code&gt; 其实就是响应式布局处理，在不同显示区域大小时，呈现不同的大小。&lt;/p&gt;
&lt;p&gt;而 py-4 是 pading-top 的意思，-4 表示不同的大小。&lt;/p&gt;
&lt;p&gt;offset 表示在一个 12 列的一行里，前面需要空出几列。&lt;/p&gt;
&lt;p&gt;总之，&lt;a href=&quot;https://getbootstrap.com/docs/4.0/layout/grid/&quot;&gt;官方教程里有对栅格系统 Grid&lt;/a&gt; 做了详细的介绍，虽然是英文的，慢慢啃吧。&lt;/p&gt;
&lt;p&gt;只有理清楚了这篇文章中介绍的 Grid，才能够理解，怎么写可以达到响应式的效果。&lt;/p&gt;
&lt;p&gt;我们再来看导航栏的一个效果，我再来分析下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a4bfb71b4f52e683.gif?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当显示区域逐渐变小时，布局从一行变成了两行，这就是响应式布局，来解释下为什么会有这个行为：&lt;/p&gt;
&lt;p&gt;看看这两个区域的代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;col-sm-8 col-md-7 py-4&quot;&amp;gt;
...
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;col-sm-4 offset-md-1 py-4&quot;&amp;gt;
...
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面说过，BootStrap 里的 Grid 将每一行划分成 12 列，所以当显示区域大小在 md 范围，即 &amp;gt;= 768px 情况下，第一个 &amp;lt;div&amp;gt; 的 col-md-7 生效，它占据 7 列的宽度，第二个 &amp;lt;div&amp;gt; 的 offset-md-1 和 col-sm-4 都生效，所以它前面空着 1 列的宽度，然后它占据着 4 列的宽度，这加起来是不是刚好 12 列，所以在 &amp;gt;= 768 时，一行可以放下这两个 &amp;lt;div&amp;gt;。&lt;/p&gt;
&lt;p&gt;但当显示区域逐渐缩小，当进入 sm 范围，即 &amp;gt;= 576px 时，此时，第一个 &amp;lt;div&amp;gt; 的 col-sm-8 生效，所以它占据 8 列，而第二个 &amp;lt;div&amp;gt; 仍旧是 offset-md-1 和 col-sm-4 生效，那么此时加起来一共 13 列，超过了 12 列，一行里已经不足够放这两个 &amp;lt;div&amp;gt; 了，根据 flex 的弹性布局，此时超过的会自动换行。&lt;/p&gt;
&lt;p&gt;以上，就是我对 Grid 的理解，也许有误，如果是错的，等后续用熟悉了再回来改，大伙看的时候，就当个借鉴看一看就好了。&lt;/p&gt;
&lt;p&gt;分析到这里，大概清楚了 Grid 还有导航栏的一些用法了，也大体清楚 BootStrap 的响应式原理好像是基于它的栅格系统，通过为不同控件设置诸如 col-(sm/md/ls/xl)-(1/2/3/4/5/6/7/8/9/10/11/12) 来达到在不同显示区域下，不一样的布局效果，实现响应式布局。&lt;/p&gt;
&lt;p&gt;所以，剩余的代码不想看了，头有点懵了，我对 BootStrap 唯一的感觉就是，学习成本好高，它提供太多东西了，封装了太多的样式、控件，反而不知道从哪看。&lt;/p&gt;
&lt;p&gt;也许，本来就不需要特意去看，学习 BootStrap 应该是当需要时，再来查阅文档，然后逐步，慢慢积累对 BootStrap 的熟悉程度，而不是一开始就来看细看文档，文档当然要看，但快速过一遍，大概清楚提供了哪些东西就好了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），公众号中有我的联系方式，欢迎有事没事来唠嗑一下，如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 13:26:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>声明 本篇内容摘抄自以下两个来源：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/10116533.html</dc:identifier>
</item>
</channel>
</rss>