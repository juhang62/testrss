<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>剖析Unreal Engine超真实人类的渲染技术Part 2 - 眼球渲染 - 0向往0</title>
<link>http://www.cnblogs.com/timlly/p/11144950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timlly/p/11144950.html</guid>
<description>&lt;p&gt;都说眼睛是人类心灵的窗户，若是眼睛渲染得逼真，将给虚拟角色点睛之笔，给予其栩栩如生的灵魂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033609168-1650461692.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mike那深邃的眼眸，唏嘘的胡渣子，神乎其神的眼神。。。应该征服了不少迷妹&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;再来一张超近距离的特写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033625780-854449327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;超近距离的眼睛特写，细节刻画得无与伦比，足以以假乱真。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然而，要渲染出如此逼真有神的眼睛，可不是那么简单，需要经过多道工序，运用许多渲染技法，刻画很多细节。&lt;/p&gt;
&lt;h2 id=&quot;眼球的构造及理论&quot;&gt;&lt;strong&gt;3.1 眼球的构造及理论&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;眼球的构造&quot;&gt;&lt;strong&gt;3.1.1 眼球的构造&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;生物学的眼球解剖图非常复杂，涉及的部位数十种。（下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201904/1617944-20190425003017686-673569941.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;人类眼球的生物学剖面图，涉及部位多达数十种。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在图形渲染领域，当然不可能关注这么多细节，可以将眼球构造做简化，只关注其中的几个部位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033726800-1274030338.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图所示的序号代表的部位：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 - &lt;strong&gt;巩膜（sclera）&lt;/strong&gt;：也称为“眼白”，通常非常湿润，包含少量的触感纹理、血丝等细节。&lt;/li&gt;
&lt;li&gt;2 - &lt;strong&gt;角膜缘（limbus）&lt;/strong&gt;：角膜缘存在于虹膜和巩膜之间的深色环形。有些眼睛中的角膜缘更为明显，从侧面看时往往会消退。&lt;/li&gt;
&lt;li&gt;3 - &lt;strong&gt;虹膜（iris）&lt;/strong&gt;：虹膜是围绕在眼睛中心周围的一圈色环。如果某个人有“绿”眼睛，就是因为虹膜主要是绿色的。在真实的眼睛中，虹膜是类似肌肉的纤维结构，有扩张和收缩功能，以让更多光线进入瞳孔或者不让光线进入瞳孔。还需要注意的是，在真实世界中，虹膜实际上更像是圆盘或锥形，不会向眼部其余部分突出。&lt;/li&gt;
&lt;li&gt;4 - &lt;strong&gt;瞳孔（pupil）&lt;/strong&gt;：瞳孔是眼睛中心的黑点。这是一个孔，光线穿过这个孔后才会被视网膜的视杆和视锥捕捉到。&lt;/li&gt;
&lt;li&gt;5 - &lt;strong&gt;角膜（cornea）&lt;/strong&gt;：角膜是位于虹膜表面上的一层透明的、充满液体的圆顶结构。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;眼球的渲染理论&quot;&gt;&lt;strong&gt;3.1.2 眼球的渲染理论&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于眼球充满了液体，因此会折射照射进来的任何光线。在真实世界中从多个角度观察眼球时就会看到这种效果。虹膜和瞳孔会因为折射而变形，因为它们是透过角膜观看的。&lt;/p&gt;
&lt;p&gt;游戏和电影中用来解决这个问题的传统方法是创建两层独立的眼睛表面，一层提供巩膜、虹膜和瞳孔，另一层位于顶部，提供角膜和眼睛的总体湿润度。这样底层表面透过湿润层观看时就会产生折射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033742704-669939754.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;《A Boy and His Kite》中的男孩眼睛中采用的就是两层表面的渲染模型&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;根据上面的分析，以及简化后的眼球解剖结构，就可以得出结论，要渲染好眼睛，需要着重实现的效果包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;角膜的半透和光泽反射效果。&lt;/li&gt;
&lt;li&gt;瞳孔的次表面散射。&lt;/li&gt;
&lt;li&gt;瞳孔的缩放。最好根据整个场景的光照强度动态调整缩放大小。&lt;/li&gt;
&lt;li&gt;虹膜的颜色变化。&lt;/li&gt;
&lt;li&gt;其它眼球细节。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下节将详细探讨。&lt;/p&gt;
&lt;h2 id=&quot;眼球的渲染技术&quot;&gt;&lt;strong&gt;3.2 眼球的渲染技术&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本节主要参考来源：&lt;/p&gt;
&lt;h3 id=&quot;角膜的半透和光泽反射&quot;&gt;&lt;strong&gt;3.2.1 角膜的半透和光泽反射&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;角膜的半透射和反射效果最能体现眼球渲染的效果。&lt;/p&gt;
&lt;p&gt;简单的做法就是直接把角膜看做一个半透明光泽球体的反射，正常的做法是用PBR流程计算其镜面反射和IBL反射，然后给眼球一张虹膜和眼白的贴图，这张贴图作为角膜下面的折射效果，最后给角膜设定一个混合系数，把光泽球体反射效果和虹膜及眼白贴图上的颜色进行混合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033800710-290127617.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;角膜的镜面反射和环境反射丰富了眼球的细节，增加了真实可信度&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;瞳孔的次表面散射&quot;&gt;&lt;strong&gt;3.2.2 瞳孔的次表面散射&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;瞳孔本身实际上也是一个高低不平有纵深感的结构，它与角膜存在一定距离。这使得瞳孔会发生折射，并且，当光线到达瞳孔表面的时候，还会进一步在瞳孔结构内部发生次表面散射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033818438-1880689515.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把眼球看成了一个双层结构，外面一层是角膜，里面一层是瞳孔的表面，而角膜和瞳孔之间我们可以认为是充斥了某种透明液体。&lt;/p&gt;
&lt;p&gt;光线在进入瞳孔组织的内部前，首先会在角膜的表面发生一次折射，然后进入瞳孔组织的内部，产生散射，最后从瞳孔表面的另一个点散射出来。这里就涉及到了两个问题：&lt;/p&gt;
&lt;p&gt;（1）一束射到角膜表面的光线在经过折射后，如何计算最终入射到瞳孔表面的位置；&lt;/p&gt;
&lt;p&gt;（2）光线进入角膜内部后，如何计算其散射效果。&lt;/p&gt;
&lt;p&gt;为了解决以上两个问题，可使用&lt;strong&gt;次表面纹理映射&lt;/strong&gt;（Subsurface texture mapping），这个方法旨在解决多层厚度不均匀的材质的次表面散射效果的计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033831228-1921466876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，每一层材质都有一个单独的深度图，保存在一个通道里，然后每一层单独的材质被认为是均匀的，拥有相同的散射、吸收系数以及相应的相位函数（散射相关的参数）。然后，以视线和第一层材质的交点为起点，沿着视线方向对多层材质进行ray-marching，每行进一步就根据位置和深度图计算当前点位于材质的哪一层，对应什么散射参数，再根据上一步的位置以及光照方向计算散射和吸收，直到ray-marching结束。具体到眼球的散射计算，实际上只有一层散射材质，即瞳孔材质。因此我们只需要提供瞳孔表面的深度图，并设定好瞳孔材质的相关散射参数，再结合次表面纹理映射的方法计算即可。&lt;/p&gt;
&lt;p&gt;这部分主要涉及的渲染技术：&lt;/p&gt;
&lt;ul readability=&quot;12.234042553191&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;视差贴图&lt;/strong&gt;（parallax mapping，也叫relief mapping）。可以通过ray marching的方法结合一张深度图在相对平坦的几何表面上实现视觉正确的高低起伏效果，法线效果虽然也能在平面上产生凹凸起伏，但在比较斜的视角下平面还是平面，视差贴图则不会这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033841821-2140853879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：normal mapping效果；右：parallax mapping效果。可见在倾斜视角下，后者效果要好很多。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于物理的折射&lt;/strong&gt;（Physically based Refraction）。与视差贴图的欺骗式计算不同，基于物理的折射是根据真实的折射模型进行模拟，效果更真实。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033854940-553810392.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;float cosAlpha = dot(frontNormalW, -refractedW);
float dist = height / cosAlpha;
float3 offsetW = dist * refractedW;
float2 offsetL = mul(offsetW, (float3x2) worldInverse);
texcoord += float2(mask, -mask) * offsetL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033906170-929652603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：视差贴图效果；右：基于物理的折射效果。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当光线从侧面射进眼球时，经过折射和透射后，会在另一侧发生较强烈的透射光环：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033917285-1847321289.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种跟光线角度相关的折射，可以通过预计算的方式解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033928907-470987144.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.6753731343284&quot;&gt;
&lt;p&gt;&lt;strong&gt;参合多介质渲染&lt;/strong&gt;（participating media rendering）。它在近年来广泛地被应用在体积光、云彩和天空相关的渲染技术中。更多内容请参看：&lt;a href=&quot;https://dai.fmph.uniba.sk/upload/f/f9/Ris_lesson07.pdf&quot;&gt;Rendering participating media&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707033939456-1213953055.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;利用participating media rendering技术渲染的体积雾。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;瞳孔的缩放&quot;&gt;&lt;strong&gt;3.2.3 瞳孔的缩放&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;瞳孔的放大和缩小实现非常简单，通过控制采样瞳孔贴图的UV即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034004867-475274673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;UE4的眼球模型的UV布局&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034027384-837105562.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mike的眼球材质提供了缩放参数，以便调节瞳孔大小。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;虹膜的颜色&quot;&gt;&lt;strong&gt;3.2.4 虹膜的颜色&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;虹膜的颜色可以首先给定一个虹膜纹理的灰度图，然后用给定虹膜颜色乘以灰度颜色，即可得到最终虹膜的颜色，这样可以通过一套资源来实现不同颜色的眼球的渲染。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034047778-825710583.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mike的眼球材质提供了更改瞳孔、虹膜等颜色的参数。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它眼球细节&quot;&gt;&lt;strong&gt;3.2.5 其它眼球细节&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;眼球的细节刻画可以增加其真实度，使画面更上一个台阶。&lt;/p&gt;
&lt;ul readability=&quot;18&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;不平坦反射&lt;/strong&gt;。真实的眼白不是完全镜面平坦的，有一定程度的凹凸不平，可以通过类Sine函数扰动其法线贴图达到模拟效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034103165-970981638.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;湿润度&lt;/strong&gt;。大多数人的眼睛都带有不同程度的泪水，具有不同的湿润度。可通过建立一层透明网格来模拟此效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034114232-658148557.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不同湿润度的网格模型&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;模拟出来的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034123371-1972696352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;眼球的湿润度从左到右：低、中、高。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;此外，可以模糊湿润网格，以便更好地将眼睛边缘做融合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034133288-1692090839.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;眼睛自反射&lt;/strong&gt;。由于眼球具体较强的反射，而已睫毛、眼皮会反射在上面，如果这部分被忽略，将会有点怪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034145842-791259918.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：没有自反射；右：有睫毛、眼皮等的自反射。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然而要实时地计算自反射会消耗较多的性能，可预先烘焙环境遮蔽图，渲染时直接采样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034157995-1789177253.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;瞳孔、虹膜、巩膜等部位之间的过渡&lt;/strong&gt;。由于它们分属不同的材质，有着各自的属性，如果它们的交界处不进行插值过渡，将会出现恐怖的效果（下图右）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034207744-311895470.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：采用了过渡；右：未采用过渡。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;过渡曲线可采用类似Sine函数的变种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034219619-702452109.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;血色和血丝&lt;/strong&gt;。血丝可在眼白的纹理添加血管纹理细节，而血色可在计算时乘以由一张遮罩纹理控制的红色来模拟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034229335-931079895.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;带血丝细节的眼球纹理。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;接触阴影（Contact Shadow）&lt;/strong&gt;。半透明材质可以启用接触阴影。此功能使用类似于光源接触阴影的功能，但不会链接到光源接触阴影参数。这是屏幕空间效果，可以作为几何体的补充，也可以取代几何体，让眼睛看起来牢牢地长在眼眶中，提高可信度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034238392-1578070601.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：未开启接触阴影；右：开启接触阴影，开启后，反射光变弱了。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;眼球的底层实现&quot;&gt;&lt;strong&gt;3.3 眼球的底层实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本节将深入源码层剖析UE的眼睛渲染细节。需要注意的是，要将眼睛材质的&lt;code&gt;Shading Model&lt;/code&gt;选择为&lt;code&gt;Eye&lt;/code&gt;（下图），并且眼睛着色模式启用了次表面散射，即眼睛着色模式是一种特殊化的次表面剖面（Subsurface Profile）着色模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034247238-791504684.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在shader层，Eye的渲染模型跟普通的PBR流程和逻辑区别甚微，跟它相关的代码文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;G:\UnrealEngine\Engine\Shaders\Private\DeferredLightingCommon.ush。&lt;/li&gt;
&lt;li&gt;G:\UnrealEngine\Engine\Shaders\Private\BasePassPixelShader.usf。&lt;/li&gt;
&lt;li&gt;G:\UnrealEngine\Engine\Shaders\Private\ShadowProjectionPixelShader.usf。&lt;/li&gt;
&lt;li&gt;G:\UnrealEngine\Engine\Shaders\Private\ShadingModelsMaterial.ush。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先分析&lt;code&gt;ShadingModelsMaterial.ush&lt;/code&gt;在眼睛着色模式下GBuffer数据初始化相关的代码：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;void SetGBufferForShadingModel(
    in out FGBufferData GBuffer, 
    in const FMaterialPixelParameters MaterialParameters,
    const float Opacity,
    const half3 BaseColor,
    const half  Metallic,
    const half  Specular,
    const float Roughness,
    const float3 SubsurfaceColor,
    const float SubsurfaceProfile,
    const float dither)
{

    // ... （省略部分代码）

#elif MATERIAL_SHADINGMODEL_EYE
    GBuffer.ShadingModelID = SHADINGMODELID_EYE;
    GBuffer.CustomData.x = EncodeSubsurfaceProfile(SubsurfaceProfile).x;
    GBuffer.CustomData.w = 1.0f - saturate(GetMaterialCustomData0(MaterialParameters)); // Opacity = 1.0 - Iris Mask
    GBuffer.Metallic = saturate(GetMaterialCustomData1(MaterialParameters));            // Iris Distance

// 如果定义了虹膜法线，进入了一段较复杂的数据处理。可见开启虹膜法线需要消耗较多性能。
#if IRIS_NORMAL
    float IrisMask      = saturate( GetMaterialCustomData0(MaterialParameters) );
    float IrisDistance  = saturate( GetMaterialCustomData1(MaterialParameters) );

    GBuffer.CustomData.x = EncodeSubsurfaceProfile(SubsurfaceProfile).x;
    GBuffer.CustomData.w = 1.0 - IrisMask;  // Opacity

    float2 WorldNormalOct = UnitVectorToOctahedron( GBuffer.WorldNormal );

    // CausticNormal stored as octahedron
    #if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT &amp;gt; 0
        // 通过法线的变换，创建一些凹陷度。
        // Blend in the negative intersection normal to create some concavity
        // Not great as it ties the concavity to the convexity of the cornea surface
        // No good justification for that. On the other hand, if we're just looking to
        // introduce some concavity, this does the job.
        float3 PlaneNormal = normalize( GetTangentOutput0(MaterialParameters) );
        float3 CausticNormal = normalize( lerp( PlaneNormal, -GBuffer.WorldNormal, IrisMask*IrisDistance ) );
        float2 CausticNormalOct  = UnitVectorToOctahedron( CausticNormal );
        float2 CausticNormalDelta = ( CausticNormalOct - WorldNormalOct ) * 0.5 + (128.0/255.0);
        GBuffer.Metallic = CausticNormalDelta.x;
        GBuffer.Specular = CausticNormalDelta.y;
    #else
        float3 PlaneNormal = GBuffer.WorldNormal;
        GBuffer.Metallic = 128.0/255.0;
        GBuffer.Specular = 128.0/255.0;
    #endif

    // IrisNormal CustomData.yz
    #if NUM_MATERIAL_OUTPUTS_CLEARCOATBOTTOMNORMAL &amp;gt; 0
        float3 IrisNormal = normalize( ClearCoatBottomNormal0(MaterialParameters) );
        #if MATERIAL_TANGENTSPACENORMAL
            IrisNormal = normalize( TransformTangentVectorToWorld( MaterialParameters.TangentToWorld, IrisNormal ) );
        #endif
    #else
        float3 IrisNormal = PlaneNormal;
    #endif

    float2 IrisNormalOct  = UnitVectorToOctahedron( IrisNormal );
    float2 IrisNormalDelta = ( IrisNormalOct - WorldNormalOct ) * 0.5 + (128.0/255.0);
    GBuffer.CustomData.yz = IrisNormalDelta;
#else
    GBuffer.Metallic = saturate(GetMaterialCustomData1(MaterialParameters));            // Iris Distance

    #if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT &amp;gt; 0
        float3 Tangent = GetTangentOutput0(MaterialParameters);
        GBuffer.CustomData.yz = UnitVectorToOctahedron( normalize(Tangent) ) * 0.5 + 0.5;
    #endif
#endif

    // ... （省略部分代码）
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着分析&lt;strong&gt;接触阴影&lt;/strong&gt;相关的代码，在&lt;code&gt;DeferredLightingCommon.ush&lt;/code&gt;内：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;void GetShadowTerms(FGBufferData GBuffer, FDeferredLightData LightData, float3 WorldPosition, float3 L, float4 LightAttenuation, float Dither, inout FShadowTerms Shadow)
{
    // 默认接触阴影强度是0。
    float ContactShadowLength = 0.0f;
    // 接触阴影长度屏幕空间缩放
    const float ContactShadowLengthScreenScale = View.ClipToView[1][1] * GBuffer.Depth;

    BRANCH
    if (LightData.ShadowedBits)
    {

        // ... （省略部分代码）
        
        // 根据缩放因子计算接触阴影长度。
        FLATTEN
        if (LightData.ShadowedBits &amp;gt; 1 &amp;amp;&amp;amp; LightData.ContactShadowLength &amp;gt; 0)
        {
            ContactShadowLength = LightData.ContactShadowLength * (LightData.ContactShadowLengthInWS ? 1.0f : ContactShadowLengthScreenScale);
        }
    }

#if SUPPORT_CONTACT_SHADOWS
    // 如果是头发或者眼睛着色模式，接触阴影长度强制缩放到0.2倍（这个值应该是测量过的值）。
    if ((LightData.ShadowedBits &amp;lt; 2 &amp;amp;&amp;amp; (GBuffer.ShadingModelID == SHADINGMODELID_HAIR))
        || GBuffer.ShadingModelID == SHADINGMODELID_EYE)
    {
        ContactShadowLength = 0.2 * ContactShadowLengthScreenScale;
    }

    #if MATERIAL_CONTACT_SHADOWS
        ContactShadowLength = 0.2 * ContactShadowLengthScreenScale;
    #endif

    BRANCH
    if (ContactShadowLength &amp;gt; 0.0)
    {
        float StepOffset = Dither - 0.5;
        // 计算接触阴影
        float ContactShadow = ShadowRayCast( WorldPosition + View.PreViewTranslation, L, ContactShadowLength, 8, StepOffset );
        
        Shadow.SurfaceShadow *= ContactShadow;
        
        // 计算透射阴影
        FLATTEN
        if( GBuffer.ShadingModelID == SHADINGMODELID_HAIR )
            Shadow.TransmissionShadow *= ContactShadow;
        // 如果是眼睛渲染模式，则不加深阴影强度，否正加深。
        else if( GBuffer.ShadingModelID != SHADINGMODELID_EYE )
            Shadow.TransmissionShadow *= ContactShadow * 0.5 + 0.5;
    }
#endif
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有小部分逻辑在&lt;code&gt;ShadowProjectionPixelShader.ush&lt;/code&gt;，关于阴影计算的：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;void Main(
    in float4 SVPos : SV_POSITION,
    out float4 OutColor : SV_Target0
    )
{
    // ... （省略部分代码）

        if (IsSubsurfaceModel(GBufferData.ShadingModelID))
        {
            float Opacity = GBufferData.CustomData.a;
            // Derive density from a heuristic using opacity, tweaked for useful falloff ranges and to give a linear depth falloff with opacity
            float Density = -.05f * log(1 - min(Opacity, .999f));
            // 如果是头发或眼睛渲染模式，不透明度和密度强制设为1。
            if( GBufferData.ShadingModelID == SHADINGMODELID_HAIR || GBufferData.ShadingModelID == SHADINGMODELID_EYE )
            {
                Opacity = 1;
                Density = 1;
            }
        
    // ... （省略部分代码）
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面分析可知，眼睛着色模式与次表面剖面着色模式基本一致，只是在GBuffer数据初始化、阴影计算上有所差别。&lt;/p&gt;
&lt;h2 id=&quot;眼球的材质&quot;&gt;&lt;strong&gt;3.4 眼球的材质&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本节将分析Mike的眼球主材质和附属物材质。&lt;/p&gt;
&lt;h3 id=&quot;眼球主材质&quot;&gt;&lt;strong&gt;3.4.1 眼球主材质&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;眼球主材质是&lt;code&gt;M_EyeRefractive&lt;/code&gt;，下图是眼球主材质的总览图，节点排布有点乱（UE材质编辑器并没有提供自动排布功能）。下面将分小节重点分析眼球材质的重要或主要算法过程，其它的小细节将被忽略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034303141-376670001.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;眼球的折射&quot;&gt;&lt;strong&gt;3.4.1.1 眼球的折射&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034319987-1266617304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，眼球的折射主要通过材质函数&lt;code&gt;ML_EyeRefraction&lt;/code&gt;实现，下面将对它的输入参数和输出参数进行分析。&lt;/p&gt;
&lt;p&gt;材质函数&lt;code&gt;ML_EyeRefraction&lt;/code&gt;的输入参数：&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;InternalIoR&lt;/code&gt;：眼球内部折射，用于模拟光线进入虹膜后的折射率，数值通常在&lt;span class=&quot;math inline&quot;&gt;\([1.0,1.4]\)&lt;/span&gt;之间，越大折射效果越明显。直接由变量&lt;code&gt;IoR&lt;/code&gt;提供。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ScaleByCenter&lt;/code&gt;：眼球（包含眼白、瞳孔、虹膜等）的缩放大小。直接由变量&lt;code&gt;ScaleByCenter&lt;/code&gt;提供。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;LimbusUVWidth&lt;/code&gt;：角膜缘的UV宽度，由&lt;code&gt;LimbusUVWidthColor&lt;/code&gt;和&lt;code&gt;LimbusUVWidthShading&lt;/code&gt;组成的2D向量提供。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;DepthScale&lt;/code&gt;：虹膜的深度缩放。数值越大，折射效果越明显。由变量&lt;code&gt;DepthScale&lt;/code&gt;提供。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;DepthPlaneOffset&lt;/code&gt;：深度平面偏移。决定瞳孔的大小和深度。由变量&lt;code&gt;Iris UV Radius&lt;/code&gt;和&lt;code&gt;ScaleByCenter&lt;/code&gt;共同算出UV，然后采样贴图&lt;code&gt;T_EyeMidPlaneDisplacement&lt;/code&gt;的R通道提供数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;MidPlaneDisplacement&lt;/code&gt;：中平面偏移，决定角膜平面到瞳孔平面的深度偏移，瞳孔周边的偏移会较小。直接采样贴图&lt;code&gt;T_EyeMidPlaneDisplacement&lt;/code&gt;获得。&lt;code&gt;T_EyeMidPlaneDisplacement&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034330501-754040674.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;EyeDirectionWorld&lt;/code&gt;：眼球模型的世界空间的法线。由&lt;code&gt;UseEyeBuldge&lt;/code&gt;控制的两张法线贴图&lt;code&gt;T_Eye_N&lt;/code&gt;和&lt;code&gt;T_Eye_Sphere_N&lt;/code&gt;采样后，由切线空间变换到世界空间获得。其中&lt;code&gt;T_Eye_N&lt;/code&gt;是中间有凸出的眼球结构（下图左），而&lt;code&gt;T_Eye_Sphere_N&lt;/code&gt;则没有（下图右）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034340342-406390194.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;IrisUVRadius&lt;/code&gt;：虹膜UV半径，直接由变量&lt;code&gt;Iris UV Radius&lt;/code&gt;提供。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;材质函数&lt;code&gt;ML_EyeRefraction&lt;/code&gt;的输出参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RefractedUV&lt;/code&gt;：折射后的UV，经过材质函数内部计算后，输出的UV结果，后面可以用于采样漫反射、其它遮罩贴图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transparency&lt;/code&gt;：虹膜颜色透明度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IrisMask&lt;/code&gt;：标识虹膜UV区域的遮罩。后续用于虹膜区域的相关着色处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面只是分析了&lt;code&gt;ML_EyeRefraction&lt;/code&gt;的输入、输出参数，下面将进入其内部计算过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034349203-517683686.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先分析折射向量（Refraction Direction）的计算：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;float airIoR = 1.00029;

// 空气对眼球内部的折射率比。
float n = airIoR / internalIoR;
// 法线和摄像机向量的夹角相关的缩放因子
float facing = dot(normalW, cameraW);
// 视角缩放后的折射率比。
float w = n * facing;
// 根据n和w计算中间因子。
float k = sqrt(1+(w-n)*(w+n));

// 根据n、w和k算出最终的折射向量。
float3 t;
t = (w - k)*normalW - n*cameraW;
t = normalize(t);
return -t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再分析折射纹理偏移（Refracted UV Offset）的计算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034359468-39062849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可见，要算出右边红色方框标识的折射纹理偏移，需要用到众多输入参数，以及经过多次坐标运算和角度计算。虽然过程比较复杂，但原理跟&lt;a href=&quot;https://www.cnblogs.com/timlly/p/11144950.html#3.2.2%20瞳孔的次表面散射&quot;&gt;3.2.2 瞳孔的次表面散射&lt;/a&gt;的基于物理的折射一致。&lt;/p&gt;
&lt;p&gt;有了折射向量和折射纹理偏移，就可以通过数次基本运算调整，算出最终的输出参数&lt;code&gt;RefractedUV&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于输出参数&lt;code&gt;IrisMask&lt;/code&gt;的计算，由以下shader代码完成：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;// 计算Iris遮罩（R通道）和角膜缘过渡区域（G通道）
UV = UV - float2(0.5f, 0.5f);

float2 m, r;
r = (length(UV) - (IrisUVRadius - LimbusUVWidth)) / LimbusUVWidth;
m = saturate(1 - r);
// 通过类sine函数变种，输出柔和的混合因子，使得角膜缘过渡自然、柔和。
m = smoothstep(0, 1, m);
return m;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;瞳孔的缩放-1&quot;&gt;&lt;strong&gt;3.4.1.2 瞳孔的缩放&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034409356-1879469060.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，如果开启了折射（&lt;code&gt;Refraction On/Off&lt;/code&gt;为true），则会使用上一小节计算的折射后的UV坐标，经过坐标换算和中心缩放，成为&lt;code&gt;Custom&lt;/code&gt; shader节点的输入参数，它的输入还有&lt;code&gt;PupilScale&lt;/code&gt;，用于决定瞳孔的大小。&lt;code&gt;Custom&lt;/code&gt; shader节点的代码如下：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;// 主要是将UV坐标绕着纹理中心进行PupilScale缩放

// float2 UV, float PupilScale

float2 UVcentered = UV - float2(0.5f, 0.5f);
float UVlength = length(UVcentered);
// UV on circle at distance 0.5 from the center, in direction of original UV
float2 UVmax = normalize(UVcentered)*0.5f;

float2 UVscaled = lerp(UVmax, float2(0.f, 0.f), saturate((1.f - UVlength*2.f)*PupilScale));
return UVscaled + float2(0.5f, 0.5f);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;眼球颜色的混合&quot;&gt;&lt;strong&gt;3.4.1.3 眼球颜色的混合&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034419004-1137536125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;眼球的颜色主要有两种颜色提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;眼白颜色（Sclera Color）：由&lt;code&gt;T_EyeScleraBaseColor&lt;/code&gt;采样获得，并且经过变量&lt;code&gt;ScleraBrightness&lt;/code&gt;缩放。其中采样的UV没有折射，只经过中心点缩放。&lt;/li&gt;
&lt;li&gt;虹膜颜色（Iris Color）：颜色采样&lt;code&gt;T_EyeIrisBaseColor&lt;/code&gt;获得，并且纹理UV经过&lt;a href=&quot;https://www.cnblogs.com/timlly/p/11144950.html#3.4.1.1%20眼球的折射&quot;&gt;3.4.1.1 眼球的折射&lt;/a&gt;的折射计算，以及&lt;a href=&quot;https://www.cnblogs.com/timlly/p/11144950.html#3.4.1.2%20瞳孔的缩放&quot;&gt;3.4.1.2 瞳孔的缩放&lt;/a&gt;的中心点缩放。采样得到的颜色经过&lt;code&gt;IrisBRightness&lt;/code&gt;和角膜缘（Limbus）相关的参数缩放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上两种颜色经过&lt;code&gt;ML_EyeRefraction&lt;/code&gt;输出的&lt;code&gt;IrisMask&lt;/code&gt;进行插值，添加虹膜颜色（&lt;code&gt;CloudyIris&lt;/code&gt;）后，最终输出到Base Color引脚。&lt;/p&gt;
&lt;h4 id=&quot;眼球的法线&quot;&gt;&lt;strong&gt;3.4.1.4 眼球的法线&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034428287-1194756470.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;眼球法线的UV经过中心点缩放，接着去采用法线贴图&lt;code&gt;T_Eye_Wet_N&lt;/code&gt;，得出的法线经过材质函数&lt;code&gt;FlattenNormal&lt;/code&gt;和缩放因子调整法线强度，最终输出到法线引脚。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;FlattenNormal&lt;/code&gt;的强度由&lt;code&gt;ML_EyeRefraction&lt;/code&gt;输出的&lt;code&gt;IrisMask&lt;/code&gt;指示的虹膜区域在&lt;span class=&quot;math inline&quot;&gt;\([FlattenNormal, 1.0]\)&lt;/span&gt;进行插值。如果是虹膜区域，则不受法线影响，即完全光滑的。&lt;/p&gt;
&lt;h4 id=&quot;虹膜的遮罩和深度&quot;&gt;&lt;strong&gt;3.4.1.5 虹膜的遮罩和深度&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;虹膜的遮罩直接由&lt;code&gt;ML_EyeRefraction&lt;/code&gt;输出的&lt;code&gt;IrisMask&lt;/code&gt;获得。&lt;/p&gt;
&lt;p&gt;虹膜的深度由折射后的纹理UV计算出距离圆心（0.5，0.5）的长度，获得与&lt;code&gt;Iris UV Radius&lt;/code&gt;的比值，再经过&lt;code&gt;Iris Concavity Scale&lt;/code&gt;缩放和&lt;code&gt;Power&lt;/code&gt;调整后，得到最终结果。（下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034438202-1060912511.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;清漆底部法线clearcoatbottomnormal&quot;&gt;&lt;strong&gt;3.4.1.6 清漆底部法线（ClearCoatBottomNormal）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034446625-614522552.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，Custom节点与&lt;a href=&quot;https://www.cnblogs.com/timlly/p/11144950.html#3.4.1.2%20瞳孔的缩放&quot;&gt;3.4.1.2 瞳孔的缩放&lt;/a&gt;中的一样，计算了UV沿着中心点缩放，接着去采样瞳孔法线纹理&lt;code&gt;iris08_leftEye_nml&lt;/code&gt;，获得的结果经过&lt;code&gt;IrisDispStrength&lt;/code&gt;控制的因子缩放，最后通过节点&lt;code&gt;BlendAngleCorrectedNormals&lt;/code&gt;与眼球表面法线混合，输出结果到Output节点&lt;code&gt;ClearCoatBottomNormal&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;眼球的其它部分&quot;&gt;&lt;strong&gt;3.4.1.7 眼球的其它部分&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;眼球的其它属性，如镜面度、粗糙度、切线等，都比较简单，直接看材质即可明白其计算过程，故这里不做分析。&lt;/p&gt;
&lt;h3 id=&quot;眼球附属物材质&quot;&gt;&lt;strong&gt;3.4.2 眼球附属物材质&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;上小节分析了眼球的主材质，然而，眼睛的渲染还包含了很多附加物体，它们各自有着独立的材质属性（下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034502370-1702079857.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;泪腺液体&quot;&gt;&lt;strong&gt;3.4.2.1 泪腺液体&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034511226-1182793946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;泪腺几何体是一个包围着眼皮周围的网格体（上图），提供了眼皮处的高光反射（下图），用于模拟光线照射到泪腺后的镜面反射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034520001-251893327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：无泪腺几何体；右：有泪腺几何体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它的材质如下图，采用了透明混合模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034528381-1160915475.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的颜色、金属度默认都是1，可见用高反射率和高金属度来获得极强的镜面反射效果。&lt;/p&gt;
&lt;p&gt;它的粗糙度计算较复杂，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034547307-444436992.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;纹理坐标经过变量&lt;code&gt;DetailScale_1&lt;/code&gt;缩放后，去采样细节纹理&lt;code&gt;skin_h&lt;/code&gt;，获得的结果再依次经过&lt;code&gt;DetailAmount&lt;/code&gt;缩放、固定常量0.1和&lt;code&gt;Roughness&lt;/code&gt;调整后，进入自定义shader节点&lt;code&gt;CurveToRoughness&lt;/code&gt;计算，最终得到结果。其中&lt;code&gt;CurveToRoughness&lt;/code&gt;的shader代码如下：&lt;/p&gt;
&lt;pre class=&quot;hlsl&quot;&gt;
&lt;code&gt;// Specular antialiasing using derivatives and normal variance

float3 N = WorldNormal;
float3 dN = fwidth( N );
float Curvature = sqrt( 1 - dot( normalize( N + dN ), N ) );

// TODO find an approximation that more directly uses Roughness
float Power = 2 / pow( Roughness, 4 ) - 2;
float Angle = 4.11893 / sqrt( Power ) + Curvature;
Power = 16.9656 / ( Angle * Angle );
Roughness = sqrt( sqrt( 2 / (Power + 2) ) );

return Roughness;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面涉及的粗糙度算法在&lt;a href=&quot;http://advances.realtimerendering.com/s2012/Ubisoft/Rock-Solid%20Shading.pdf&quot;&gt;Rock-Solid Shading: Image Stability Without Sacrificing Detail&lt;/a&gt;有详细描述。&lt;/p&gt;
&lt;p&gt;它的法线计算比较简单，采样法线贴图&lt;code&gt;skin_n&lt;/code&gt;后经过变量&lt;code&gt;DetailAmount&lt;/code&gt;调整，就得到最终结果。&lt;/p&gt;
&lt;p&gt;此外，它还增加了世界坐标偏移，由变量'DepthOffset'控制偏移量，经过材质函数&lt;code&gt;CameraOffset&lt;/code&gt;得到相机空间的偏移。&lt;/p&gt;
&lt;h4 id=&quot;遮蔽模糊体&quot;&gt;&lt;strong&gt;3.4.2.2 遮蔽模糊体&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034559647-231646992.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遮蔽模糊体跟泪腺液体类似，环绕于眼角周边，用于遮挡部分光照并模糊，使得周边混合更真实（下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034609515-1802325644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：无遮蔽模糊体；右：有遮蔽模糊体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它的材质采用透明混合模式，并且光照模型是&lt;code&gt;Unlit&lt;/code&gt;。它的总览图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034618445-1853602284.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可分下面几个部分进行分析：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;不透明度（Opacity）：&lt;/p&gt;
&lt;p&gt;这部分主要是生成需要遮蔽和模糊的区域掩码。过程大致是通过采样初始掩码图，加上纹理线性过渡、反向、加上Power运算调整，以及若干变量控制的因子进行基本运算，获得眼部周边掩码（下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034627125-603090909.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模糊（Blur）：&lt;/p&gt;
&lt;p&gt;在当前UV周边采样16个&lt;code&gt;Scene Color&lt;/code&gt;求得平均值。此处的&lt;code&gt;Scene Color&lt;/code&gt;一定是已经渲染眼球后的颜色，因为眼球是非透明物体，可保证在透明的遮蔽模糊体之前先绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;颜色（Color）：&lt;/p&gt;
&lt;p&gt;原始颜色的输出很简单，利用上面计算的遮罩，在白色和&lt;code&gt;Blur Color&lt;/code&gt;之间插值，然后与上面模糊后的场景颜色相乘。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;阴影（Shadow）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034635628-364706620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，通过UV的上下左右线性渐变及调整后获得4个不同的值，进行相乘，获得周边黑色，最后通过变量在1.0之间插值，获得顶部为深色的阴影图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;综合计算：&lt;/p&gt;
&lt;p&gt;在此阶段，利用上面的几个计算结果，颜色和阴影相乘，并预乘了Alpha，获得最终颜色和不透明度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，还有位置偏移的计算，这里将忽略。&lt;/p&gt;
&lt;h4 id=&quot;眼角混合体&quot;&gt;&lt;strong&gt;3.4.2.3 眼角混合体&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;眼角混合体为眼角增加血色及血丝细节，并调整亮度，使得眼白过渡更自然（下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034644442-2120969121.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;左：无眼角混合体；右：有眼角混合体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它的材质启用了次表面散射，并且混合模式是裁剪（Masked），材质总览图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034658005-895453119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面将其拆分成若干部分进行分析：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;渐变掩码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034712493-241429576.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用UV的横坐标获得线性过渡，用&lt;code&gt;Power&lt;/code&gt;调整强度，然后用&lt;code&gt;SmoothStep&lt;/code&gt;获得平滑过渡的掩码图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;颜色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617944/201907/1617944-20190707034720402-933592893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过几个变量将UV坐标进行拉伸，去采样眼睛贴图&lt;code&gt;eye_sclera_right_clr&lt;/code&gt;，获得拉伸后的颜色，经过眼白亮度调整和由上节计算出的掩码决定的眼白到血色的调整，获得最终颜色。其中眼角偏红，呈现出更多血色，而靠近瞳孔的区域受影响程度较低。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;法线：&lt;/p&gt;
&lt;p&gt;法线的获得，主要由上面计算出的掩码，在向量[0, 0, 1]和[-1, 0, 0]插值获得。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;睫毛和眉毛&quot;&gt;&lt;strong&gt;3.4.2.4 睫毛和眉毛&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;由于睫毛和眉毛的材质属于&lt;code&gt;Hair&lt;/code&gt;着色模式，虽然是眼睛的组成部分，但其实是毛发渲染的范畴，后续章节将会详细阐述。&lt;/p&gt;
&lt;h2 id=&quot;眼球渲染总结&quot;&gt;&lt;strong&gt;3.5 眼球渲染总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;由上面可知，虽然眼睛的渲染技术不如皮肤渲染来得更高深、更系统，但由于其涉及的部位和细节多，环环相扣，各个材质之间相辅相成，形成了一套完整而逼真的眼睛渲染体系。&lt;/p&gt;
&lt;p&gt;本章结尾，引用官方文档的建议：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在开发数字人类角色时，我们在模型中使用了一些不同方法和材质提升了角色眼部的逼真度。如上所述，许多眼部设置与材质设置和采集的参考资料之间存在着相互依赖的关系。我们强烈建议使用我们的眼部设置作为您的起点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见，要完全从零开始制作一个成像逼真的眼睛的资源（模型、贴图、材质等），还是有相当的难度。幸好慷慨的虚幻引擎官方已经给出了足够多的示例及资源，以供个人及团队研究和研发，大大缩短了学习、开发的周期。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;感谢参考文献的所有作者们！&lt;/li&gt;
&lt;li&gt;后续还有毛发渲染等部分，敬请期待！&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 06 Jul 2019 19:50:00 +0000</pubDate>
<dc:creator>0向往0</dc:creator>
<og:description>[TOC] 三、眼球渲染 都说眼睛是人类心灵的窗户，若是眼睛渲染得逼真，将给虚拟角色点睛之笔，给予其栩栩如生的灵魂。 Mike那深邃的眼眸，唏嘘的胡渣子，神乎其神的眼神。。。应该征服了不少迷妹 再来一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/timlly/p/11144950.html</dc:identifier>
</item>
<item>
<title>springboot+redis+Interceptor+自定义annotation实现接口自动幂等 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/11130034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/11130034.html</guid>
<description>&lt;p&gt;前言: 在实际的开发项目中,一个对外暴露的接口往往会面临很多次请求，我们来解释一下幂等的概念：&lt;strong&gt;任意多次执行所产生的影响均与一次执行的影响相同&lt;/strong&gt;。按照这个含义，最终的含义就是 对数据库的影响只能是一次性的，不能重复处理。如何保证其幂等性，通常有以下手段：&lt;/p&gt;
&lt;p&gt;        1:数据库建立唯一性索引，可以保证最终插入数据库的只有一条数据&lt;/p&gt;
&lt;p&gt;        2:token机制，每次接口请求前先获取一个token，然后再下次请求的时候在请求的header体中加上这个token，后台进行验证，如果验证通过删除token，下次请求再次判断token&lt;/p&gt;
&lt;p&gt;        3:悲观锁或者乐观锁，悲观锁可以保证每次for update的时候其他sql无法update数据(在数据库引擎是innodb的时候,select的条件必须是唯一索引,防止锁全表)&lt;/p&gt;
&lt;p&gt;       4:先查询后判断，首先通过查询数据库是否存在数据，如果存在证明已经请求过了，直接拒绝该请求，如果没有存在，就证明是第一次进来，直接放行。&lt;/p&gt;
&lt;p&gt;redis实现自动幂等的原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201907/1066538-20190705184548440-1976170744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：搭建redis的服务Api&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1:首先是搭建redis服务器，这个之前搭过了，就不赘述了。详情可参考：&lt;a href=&quot;https://www.cnblogs.com/wyq178/p/10340234.html&quot;&gt;https://www.cnblogs.com/wyq178/p/10340234.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2:引入springboot中到的redis的stater，或者Spring封装的jedis也可以，后面主要用到的api就是它的set方法和exists方法,这里我们使用springboot的封装好的redisTemplate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * redis工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; set(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key, Object value) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            operations.set(key, value);
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存设置时效时间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; setEx(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key, Object value, Long expireTime) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            operations.set(key, value);
            redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断缓存中是否有对应的value
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; exists(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.hasKey(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读取缓存
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Object get(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
        result &lt;/span&gt;=&lt;span&gt; operations.get(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除对应的value
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; remove(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (exists(key)) {
            Boolean delete &lt;/span&gt;=&lt;span&gt; redisTemplate.delete(key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delete;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;二：自定义注解AutoIdempotent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 自定义一个注解，定义此注解的主要目的是把它添加在需要实现幂等的方法上，凡是某个方法注解了它，都会实现自动幂等。后台利用反射如果扫描到这个注解，就会处理这个方法实现自动幂等，使用元注解ElementType.METHOD表示它只能放在方法上，etentionPolicy.RUNTIME表示它在运行时&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AutoIdempotent {
  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三：token创建和检验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1:token服务接口&lt;/p&gt;
&lt;p&gt;我们新建一个接口，创建token服务，里面主要是两个方法，一个用来创建token，一个用来验证token。创建token主要产生的是一个字符串，检验token的话主要是传达request对象，为什么要传request对象呢？主要作用就是获取header里面的token,然后检验，通过抛出的Exception来获取具体的报错信息返回给前端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TokenService {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建token
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  String createToken();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检验token
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkToken(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2:token的服务实现类&lt;/p&gt;
&lt;p&gt;token引用了redis服务，创建token采用随机算法工具类生成随机uuid字符串,然后放入到redis中，如果放入成功，最后返回这个token值。checkToken方法就是从header中获取token到值(如果header中拿不到，就从paramter中获取)，如若不存在,直接抛出异常。这个异常信息可以被拦截器捕捉到，然后返回给前端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TokenServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TokenService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisService redisService;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建token
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String createToken() {
        String str &lt;/span&gt;=&lt;span&gt; RandomUtil.randomUUID();
        StrBuilder token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StrBuilder();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            token.append(Constant.Redis.TOKEN_PREFIX).append(str);
            redisService.setEx(token.toString(), token.toString(),&lt;/span&gt;1000L&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; notEmpty =&lt;span&gt; StrUtil.isNotEmpty(token.toString());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (notEmpty) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token.toString();
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
            ex.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检验token
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkToken(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        String token &lt;/span&gt;=&lt;span&gt; request.getHeader(Constant.TOKEN_NAME);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StrUtil.isBlank(token)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; header中不存在token&lt;/span&gt;
            token =&lt;span&gt; request.getParameter(Constant.TOKEN_NAME);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StrUtil.isBlank(token)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; parameter中也不存在token&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceException(Constant.ResponseCode.ILLEGAL_ARGUMENT, 100&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;redisService.exists(token)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceException(Constant.ResponseCode.REPETITIVE_OPERATION, 200&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; remove =&lt;span&gt; redisService.remove(token);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;remove) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceException(Constant.ResponseCode.REPETITIVE_OPERATION, 200&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四：拦截器的配置 &lt;/p&gt;
&lt;p&gt;1:web配置类，实现WebMvcConfigurerAdapter，主要作用就是添加autoIdempotentInterceptor到配置类中，这样我们到拦截器才能生效，注意使用@Configuration注解，这样在容器启动是时候就可以添加进入context中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebConfiguration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebMvcConfigurerAdapter {

    @Resource
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AutoIdempotentInterceptor autoIdempotentInterceptor;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加拦截器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registry
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(autoIdempotentInterceptor);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.addInterceptors(registry);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2:拦截处理器：主要的功能是拦截扫描到AutoIdempotent到注解到方法,然后调用tokenService的checkToken()方法校验token是否正确，如果捕捉到异常就将异常信息渲染成json返回给前端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 拦截器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AutoIdempotentInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerInterceptor {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TokenService tokenService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 预处理
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(handler &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HandlerMethod)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        HandlerMethod handlerMethod &lt;/span&gt;=&lt;span&gt; (HandlerMethod) handler;
        Method method &lt;/span&gt;=&lt;span&gt; handlerMethod.getMethod();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被ApiIdempotment标记的扫描&lt;/span&gt;
        AutoIdempotent methodAnnotation = method.getAnnotation(AutoIdempotent.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodAnnotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tokenService.checkToken(request);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 幂等性校验, 校验通过则放行, 校验失败则抛出异常, 并通过统一异常处理返回友好提示&lt;/span&gt;
            }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
                ResultVo failedResult &lt;/span&gt;= ResultVo.getFailedResult(101&lt;span&gt;, ex.getMessage());
                writeReturnJson(response, JSONUtil.toJsonStr(failedResult));
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }
        }&lt;br/&gt;//必须返回true,否则会被拦截一切请求
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; true&lt;span&gt;;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回的json值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; json
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeReturnJson(HttpServletResponse response, String json) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        PrintWriter writer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        response.setCharacterEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);
        response.setContentType(&lt;/span&gt;&quot;text/html; charset=utf-8&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            writer &lt;/span&gt;=&lt;span&gt; response.getWriter();
            writer.print(json);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (writer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                writer.close();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 五：测试用例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1:模拟业务请求类&lt;/p&gt;
&lt;p&gt;首先我们需要通过/get/token路径通过getToken()方法去获取具体的token，然后我们调用testIdempotence方法，这个方法上面注解了@AutoIdempotent，拦截器会拦截所有的请求，当判断到处理的方法上面有该注解的时候，就会调用TokenService中的checkToken()方法，如果捕获到异常会将异常抛出调用者，下面我们来模拟请求一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BusinessController {


    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TokenService tokenService;

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestService testService;


    @PostMapping(&lt;/span&gt;&quot;/get/token&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String  getToken(){
        String token &lt;/span&gt;=&lt;span&gt; tokenService.createToken();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StrUtil.isNotEmpty(token)) {
            ResultVo resultVo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResultVo();
            resultVo.setCode(Constant.code_success);
            resultVo.setMessage(Constant.SUCCESS);
            resultVo.setData(token);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSONUtil.toJsonStr(resultVo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StrUtil.EMPTY;
    }


    @AutoIdempotent
    @PostMapping(&lt;/span&gt;&quot;/test/Idempotence&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testIdempotence() {
        String businessResult &lt;/span&gt;=&lt;span&gt; testService.testIdempotence();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StrUtil.isNotEmpty(businessResult)) {
            ResultVo successResult &lt;/span&gt;=&lt;span&gt; ResultVo.getSuccessResult(businessResult);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSONUtil.toJsonStr(successResult);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StrUtil.EMPTY;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2:使用postman请求&lt;/p&gt;
&lt;p&gt;首先访问get/token路径获取到具体到token：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201907/1066538-20190707013422385-1105527902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用获取到到token,然后放到具体请求到header中,可以看到第一次请求成功，接着我们请求第二次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201907/1066538-20190707013547092-516515651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次请求，返回到是重复性操作，可见重复性验证通过，再多次请求到时候我们只让其第一次成功，第二次就是失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201907/1066538-20190707013702417-1750429850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 六：总结&lt;/p&gt;
&lt;p&gt;  本篇博客介绍了使用springboot和拦截器、redis来优雅的实现接口幂等，对于幂等在实际的开发过程中是十分重要的，因为一个接口可能会被无数的客户端调用，如何保证其不影响后台的业务处理，如何保证其只影响数据一次是非常重要的，它可以防止产生脏数据或者乱数据，也可以减少并发量，实乃十分有益的一件事。而传统的做法是每次判断数据，这种做法不够智能化和自动化，比较麻烦。而今天的这种自动化处理也可以提升程序的伸缩性。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jul 2019 17:54:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言: 在实际的开发项目中,一个对外暴露的接口往往会面临很多次请求，我们来解释一下幂等的概念：任意多次执行所产生的影响均与一次执行的影响相同。按照这个含义，最终的含义就是 对数据库的影响只能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq178/p/11130034.html</dc:identifier>
</item>
<item>
<title>SQL Server温故系列(1)：SQL 数据操作 CRUD 之增删改合 - 韩宗泽</title>
<link>http://www.cnblogs.com/hanzongze/p/tsql-crud.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanzongze/p/tsql-crud.html</guid>
<description>&lt;p&gt;毋庸置疑，开发者最常用的数据库技术就是 SQL 了，即便是 ORM 大行其道的今天也常常需要写 SQL 语句。而 SQL 语句中最常用的就是增删改查了，本系列就先对增删改查语句来个系统的回顾吧！&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;1、插入语句 INSERT INTO&lt;/h2&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1、用 INSERT 插入单行数据&lt;/h4&gt;
&lt;p&gt;INSERT INTO 的作用是向表中添加新行，语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO table-name(column1,column2,...column-n) VALUES(value1,value2,...value-n);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;譬如要向好学生表中添加 1 条数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents(Name,Birthday) VALUES('李尔','1990-01-09'); -- 显示指定要插入字段&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果按表中的字段顺序给出全部字段的值，那么就不用显示指定字段了，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents VALUES(1,'邱晨',1,'1990-09-01');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2、用 INSERT 插入多行数据&lt;/h4&gt;
&lt;p&gt;INSERT INTO 还可以一次向表中添加多条数据，如要一次性向学生表中添加 3 条数据，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents(Name,Gender,Birthday) 
VALUES('张三',1,'1993-03-03'),('李四',1,'1994-04-04'),('王五',1,'1995-05-05');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在插入全部字段时，插入多行数据也可以像插入单行数据那样省略字段列表，但必须确保各行之间的数据&lt;strong&gt;个数相同&lt;/strong&gt;、&lt;strong&gt;类型兼容&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;13&quot;&gt;1.3、用 INSERT 插入子查询结果行&lt;/h4&gt;
&lt;p&gt;向表中插入数据时，既可以通过 VALUES 子句显示地列出插入值，也可以通过 SELECT 子句来获得插入值。语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO target-table-name SELECT columns FROM source-table-name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该语句的效果类似于把一张表的数据复制到另一张表，要复制的字段和行都可以显示的指定。当要将大量行从源表传输到目标表中时，该语句还能够以最小日志记录的方式高效的完成。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents SELECT Id,Name,Gender,Birthday FROM T_Students;   -- 完全复制（数据）
INSERT INTO T_GoodStudents(Name,Gender) SELECT Name,Gender FROM T_Students;  -- 指定部分字段复制
INSERT INTO T_GoodStudents(Name) SELECT Name FROM T_Students WHERE Gender=1; -- 指定部分数据复制&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果目标表和源表的表结构相同，子查询的字段列表还可以用 * 来代替。在指定字段复制时，无需表结构相同，只要对应字段的数据类型兼容即可，甚至还可以没有源表，一个子查询就够了。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents SELECT 999,'李敏',0,'1991-02-02'; -- 插入 1 条（来自子查询的）数据

INSERT INTO T_GoodStudents(Id,Name,Birthday)
SELECT 11,'王阳','1991-03-02' UNION ALL
SELECT 12,'李玉','1991-07-02' UNION ALL
SELECT 13,'郑爽','1991-02-02';                               -- 插入 3 条（来自子查询的）数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;14&quot;&gt;1.4、INSERT 小结及特殊字段插入方法&lt;/h4&gt;
&lt;p&gt;在使用 INSERT INTO 语句向表中插入新行时，除了带默认值和带标识的字段，其它必填的字段都需要显示的给出值，而非必填字段不给值时 SQL Server 默认会给它一个 NULL 值，也可以显示的给定一个 NULL 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.4.1、将数据插入有默认值的字段中&lt;/strong&gt; 时，如果没有为指定了默认值的字段指定值，那么新行的该字段的值将会是默认值。假如要添加一行，有默认值的字段就让它为默认值，没有默认值的字段就让它为 NULL，那么就可以用如下语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents DEFAULT VALUES;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.4.2、将数据插入到标识列中&lt;/strong&gt; 时，无论是指定插入字段还是不指定插入字段，都无需考虑标识列，因为 SQL Server 的关系引擎会根据标识增量和标识种子自动为标识列赋值。如果需要为标识列指定值，就需要先把 IDENTITY_INSERT 打开，然后才能插入，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET IDENTITY_INSERT T_Students ON;                  -- 当前会话有效，别的会话不受影响
INSERT INTO T_Students(Id,Name) VALUES(-1,'李哈哈'); -- Id 字段为标识列&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意1：必须在 INTO 子句中显示列出标识列，否则即便在 VALUES 子句中提供所有字段的值也还是会报错。&lt;/p&gt;
&lt;p&gt;注意2：如果想在当前会话中继续像默认情况那样忽略标识列，就需要把 IDENTITY_INSERT 关掉，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET IDENTITY_INSERT T_Students OFF;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2&quot;&gt;2、删除语句 DELETE&lt;/h2&gt;
&lt;h4 id=&quot;21&quot;&gt;2.1、用 DELETE 删除表中指定行&lt;/h4&gt;
&lt;p&gt;DELETE 语句用于从表中删除现有行，语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE FROM table-name WHERE delete-conditions;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WHERE 子句的作用在于确定删除哪些行，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE FROM T_GoodStudents WHERE Id &amp;gt;= 20;                             -- 删除 Id 大于等于 20 的数据
DELETE FROM T_GoodStudents WHERE Id NOT IN(SELECT Id FROM T_Students); -- 删除 Id 不在学生表中的数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在 PL/SQL 中可以方便的给要删数据的表取个别名，以便限定 WHERE 子句中的字段，但在 T-SQL 中却不能直接给 DELETE 语句中要删数据的表取别名。如果想要限定删除条件中的字段，可以用如下两种写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE FROM T_Students WHERE T_Students.Id = 4;     -- 直接用表名来限定（条件字段少时比较方便）
DELETE T_Students FROM T_Students t WHERE t.Id = 5; -- 在 DELETE 子句中加上表名（条件字段多时更方便）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;理论上 DELETE 语句是可以不带 WHERE 子句的，但这个操作很危险，因为它意味着删除表中所有行。&lt;/p&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2、用 TRUNCATE TABLE 高效清空表&lt;/h4&gt;
&lt;p&gt;TRUNCATE TABLE 用于删除表中的所有行，如果表中有标识列，标识列会重新开始计数，相当于清空了整个表。语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TRUNCATE TABLE table-name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如要清空好学生表，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TRUNCATE TABLE T_GoodStudents;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：尽管不带 WHERE 条件的 DELETE 语句就可以删除表中所有数据，但 TRUNCATE TABLE 比 DELETE 的速度更快，使用的系统资源和事务日志资源也更少。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;3、更新语句 UPDATE&lt;/h2&gt;
&lt;p&gt;UPDATE 语句用于更新指定表中的现有数据，语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE table-name 
SET column1 = value1,column2 = value2,...column-n = value-n 
WHERE update-conditions;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WHERE 子句用于限定哪些行需要被更新，如果不带 WHERE 子句就会更新所有行，当然这很危险，一般也没有这种需求。可以一次更新一个字段，也可以一次更新多个字段，字段的值可以显示给出，也可以是个表达式，表达式中还可以引用表中的字段。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_GoodStudents SET Name = '王娜' WHERE Id = 7;            -- 更新一个字段的值
UPDATE T_GoodStudents SET Name = '徐莉',Gender = 0 WHERE Id = 7; -- 更新多个字段的值
UPDATE T_GoodStudents SET Birthday = GETDATE()-10 WHERE Id = 7;  -- 用表达式给字段赋值
UPDATE T_GoodStudents SET Birthday = Birthday-10 WHERE Id = 7;   -- 在表达式中引用字段
UPDATE T_GoodStudents SET Name += '学生' WHERE Id &amp;gt; 3;           -- 在姓名后面加上&quot;学生&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.1、SET 子句内包含子查询&lt;/strong&gt;时，示例如下（把班级名更新到学生备注中）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_Students SET Remark = (SELECT t.Name FROM T_Classes t WHERE t.Id = ClassId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意1：上例中没有 WHERE 子句，这意味着（不论学生表中的 ClassId 是否在班级表中出现过）都会更新整个学生表，ClassId 未在班级表中出现过的学生备注会被更新为 NULL。尽管看似简单，但笔者就曾在职场中多次遇到工作数年的技术人员因忽略这点而误改了数据。&lt;/p&gt;
&lt;p&gt;注意2，如果恰好两个表中的关联字段名相同，大概率上会出问题或报错，为了稳妥起见需要限定一下字段。在 Oracle 中可以方便的通过表别名来限定，然而 SQL Server 却不支持给 UPDATE 语句的 UPDATE 子句中的表取别名，但可以直接通过表名来限定字段。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_GoodStudents 
SET Name = (SELECT t.Name FROM T_Students t WHERE t.Id = T_GoodStudents.Id) 
WHERE T_GoodStudents.Id IN(SELECT Id FROM T_Students); -- 将学生表的姓名同步到好学生表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2、WHERE 子句内含子查询&lt;/strong&gt;时，示例如下（将单科考试 3 次不及格的写入到学生备注中）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_Students SET Remark = '单科3次不及格' 
WHERE Id IN(
    SELECT t.StudentId 
    FROM T_ExamResults t 
    WHERE t.Scores &amp;lt; 60 
    GROUP BY t.StudentId,t.CourseId HAVING COUNT(1) &amp;gt;= 3
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.3、带 FROM 子句的 UPDATE 语句&lt;/strong&gt;，示例如下（把所有学生最近一次考试的总成绩更新到学生备注中）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_Students SET Remark = t2.SumScore
FROM T_Students t1 
JOIN(
    SELECT t.StudentId,SUM(t.Scores) SumScore 
    FROM T_ExamResults t 
    WHERE t.Counts = (SELECT MAX(Counts) FROM T_ExamResults) 
    GROUP BY t.StudentId
) t2 
ON t1.Id=t2.StudentId;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只需要更新部分学生，比如仅更新 1 班的学生，就可以在 ON 后面直接加&lt;code&gt;AND t1.ClassId=1&lt;/code&gt;，或者在整个语句后面加&lt;code&gt;WHERE t1.ClassId=1&lt;/code&gt;。有意思的是，这种 UPDATE 语句即便没有 WHERE 条件，也不会对未在 FROM 子句中限定的行产生影响。&lt;/p&gt;
&lt;h2 id=&quot;4&quot;&gt;4、合并语句 MERGE&lt;/h2&gt;
&lt;p&gt;相比较 INSERT、DELETE、UPDATE 和 SELECT 来说，MERGE 出现的要晚一些，但也有十多年了，各大 SQL 数据库在 21 世纪头几年陆续提供了对 MERGE 的支持。简单来说，MERGE 语句就是对增删改查的“合并”，使得可以在一个语句内根据查询的匹配情况来决定是否要增、删或改某些数据，而不必再写冗长的逻辑判断和事物处理了。语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MERGE target-table-name
USING source-table-expressions ON merge-search-conditions
WHEN MATCHED AND clause-search-conditions THEN merge-matched
WHEN NOT MATCHED AND clause-search-conditions THEN merge-not-matched;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 MERGE 在单个语句中对表执行 INSERT 或 UPDATE 操作，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MERGE T_Students AS target 
USING(SELECT '朱丹丹',0) AS source (Name,Gender) ON(target.Name = source.Name)
WHEN MATCHED THEN 
    UPDATE SET Gender = source.Gender 
WHEN NOT MATCHED THEN 
    INSERT(Name,Gender) VALUES(source.Name,source.Gender);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 MERGE 在单个语句中对表执行 INSERT、DELETE 或 UPDATE 操作，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MERGE T_Students AS target 
USING(SELECT '刘天宝',1,'1990-09-09') AS source (Name,Gender,Birthday) 
ON(target.Name = source.Name)
WHEN MATCHED AND target.Birthday &amp;lt; source.Birthday THEN 
    DELETE 
WHEN MATCHED THEN 
    UPDATE SET target.Gender = source.Gender,target.Birthday = source.Birthday
WHEN NOT MATCHED THEN
    INSERT(Name,Gender,Birthday) VALUES(source.Name,source.Gender,source.Birthday);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5&quot;&gt;5、用 TOP 参数限制受影响的行&lt;/h2&gt;
&lt;p&gt;熟悉 SQL Server 的开发者估计都知道 TOP 参数可以用来限制查询语句的返回行数，但其实 TOP 参数不仅可以限制 SELECT 的结果集，还以限制受 INSERT、DELETE 或 UPDATE 影响的行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1、带 TOP 参数的 INSERT 语句&lt;/strong&gt;，示例如下（随机将 3 个女学生添加到好学生表）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT TOP(3) INTO T_GoodStudents 
SELECT t.Id,t.Name,t.Gender,t.Birthday FROM T_Students t WHERE t.Gender = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要按某种特定的顺序插入数据，譬如要把年龄最大的 3 个学生添加到好学生表，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO T_GoodStudents 
SELECT TOP(3) t.Id,t.Name,t.Gender,t.Birthday FROM T_Students t ORDER BY t.Birthday;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.2、带 TOP 参数的 DELETE 语句&lt;/strong&gt;，示例如下（随机删除 3 个女学生）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE TOP(3) FROM T_GoodStudents WHERE Gender = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要按某种特定的顺序删除数据，譬如要删除年龄最大的 3 个学生的信息，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE FROM T_GoodStudents 
WHERE Id IN(SELECT TOP(3) t.Id FROM T_GoodStudents t ORDER BY t.Id DESC);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.3、带 TOP 参数的 UPDATE 语句&lt;/strong&gt;，示例如下（随机将 3 个男学生的性别更新为 0）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE TOP(3) T_Students SET Gender = 0 WHERE Gender = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要按某种特定的顺序更新数据，譬如要将年龄最大的 3 个男学生的性别更新为 0，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE T_GoodStudents SET Gender = 0 
FROM(SELECT TOP(3) t1.Id FROM T_GoodStudents t1 ORDER BY t1.Id DESC) t2 
WHERE T_GoodStudents.Id = t2.Id;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6&quot;&gt;6、用 OUTPUT 子句返回受影响的数据&lt;/h2&gt;
&lt;p&gt;试想一下，如果需要在插入的一条数据的同时返回这条数据，或者在删除一条数据的同时备份这条数据，我们当然可以用多条简单语句来共同完成，并且通过事务来确保操作的原子性。但其实这类需求可以通过 OUTPUT 子句来更好的完成，而且一个语句就能搞定，不必加事务，因为它本身就具备原子性。&lt;/p&gt;
&lt;p&gt;在使用 OUTPUT 返回数据时，需要借助 INSERTED 或 DELETED 来引用字段值。INSERTED 用来引用插入操作或更新操作添加的值，DELETED 用来引用删除操作或更新操作删除的值。在 INSERT 语句中不能访问 DELETED，在 DELETE 语句中不能访问 INSERTED，在 UPDATE 语句中两个都能访问。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT T_GoodStudents OUTPUT inserted.* VALUES(7,'高鹏',1,'1979-11-11'); -- 插入 1 条信息并输出
DELETE TOP(1) FROM T_GoodStudents OUTPUT deleted.Id,deleted.Name;       -- 删除 1 条信息并输出

UPDATE TOP(2) T_GoodStudents SET Gender = 1 
OUTPUT deleted.Name,inserted.Name,deleted.Gender,inserted.Gender;       -- 更新 2 条信息并输出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以结合 INTO 把 OUTPUT 返回的数据插入到另一张表中，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT T_GoodStudents OUTPUT inserted.* INTO T_GoodStudents VALUES(9,'黄强',1,'1999-11-11');
DELETE TOP(1) FROM T_GoodStudents OUTPUT deleted.* INTO T_GoodStudents;
UPDATE TOP(2) T_GoodStudents SET Gender = 1 OUTPUT deleted.* INTO T_GoodStudents;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7&quot;&gt;7、本文小结&lt;/h2&gt;
&lt;p&gt;本文主要讲述了 T-SQL 语句中的 INSERT、DELETE、UPDATE 和 MERGE 共 4 个 DML 语句及其子句，以及一个 DDL 语句 TRUNCATE TABLE，而且这几个语句都是实际开发中特别常用的语句。&lt;/p&gt;
&lt;p&gt;在 Oracle 中总是给表取别名是个很好的习惯，但 SQL Server 的增删改语句均不支持对目标表取别名，只有合并语句和查询语句支持别名。不过 SQL Server 中的所有 DML 语句都支持用表名来限定字段名。&lt;/p&gt;
&lt;p&gt;有些读者可能会有疑问“为什么 SQL Server 管理工具生成的语句总是要给对象名前后加上中括号？”。尽管不好看，但的确有道理，因为它可以防止用户自定义名称跟系统关键字冲突。譬如你要用 USER 做表名或字段名，就得用中括号包裹一下。另外，如果想用某些特殊符号来命名也需要用中括号包裹，但一般不建议这么做，太变态了！&lt;/p&gt;
&lt;p&gt;如果你不幸遇到头尾带空格的对象名，你会发现只写空格以外的名称部分是访问不到该对象的，这种情况也可以用中括号来解决。如果你有修改权限的话建议还是把空格删掉吧，太恶心了！假如学生表前后有空格，查询示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM [ T_Students ];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.6892655367232&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文链接&lt;/strong&gt;：&lt;a href=&quot;http://www.cnblogs.com/hanzongze/p/tsql-crud.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/hanzongze/p/tsql-crud.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;版权声明&lt;/strong&gt;：本文为博客园博主 &lt;a href=&quot;http://www.cnblogs.com/hanzongze/&quot;&gt;&lt;strong&gt;韩宗泽&lt;/strong&gt;&lt;/a&gt; 原创，作者保留署名权！欢迎通过转载、演绎或其它传播方式来使用本文，但必须在明显位置给出作者署名和本文链接！个人博客，能力有限，若有不当之处，敬请批评指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 06 Jul 2019 15:09:00 +0000</pubDate>
<dc:creator>韩宗泽</dc:creator>
<og:description>《SQL Server温故系列》，sql，crud。毋庸置疑，开发者最常用的数据库技术就是 SQL 了，即便是 ORM 大行其道的今天也常常需要写 SQL 语句。而 SQL 语句中最常用的就是增删改查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanzongze/p/tsql-crud.html</dc:identifier>
</item>
<item>
<title>如何提升团队速率、保证产品质量和提升团队积极性？ - kakake</title>
<link>http://www.cnblogs.com/kakake/p/11144488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kakake/p/11144488.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;团队采用敏捷开发已经一年时间了，刚开始半年随着团队成员之间的磨合以及技术的熟悉，开发的效率确实逐渐在提升，所以自认为团队上路了只会原来越好，谁想到后面团队没有进步，反而退步得厉害。&lt;/p&gt;
&lt;h2 id=&quot;一何时发现产品质量这个问题&quot;&gt;一、何时发现产品质量这个问题？&lt;/h2&gt;
&lt;p&gt;在指导对接监管平台的过程中突然发现产品质量已经下降得如此厉害，随便列出几项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）监管平台导入频次、用法、剂型、诊断等字典数据都没有验证一下程序，后面一跑流程很多功能都用不了。&lt;/li&gt;
&lt;li&gt;2）上传到监管平台的科室、医生、病人、病历、处方、诊断都没有关联起来，没有人提出这个问题。&lt;/li&gt;
&lt;li&gt;3）产品封版迭代中，尽然一下冒出140多个BUG。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：产品一定把关故事质量，SM把关技术质量，一起合作细化故事的验收条件。测试用例一定要覆盖全面。&lt;/p&gt;
&lt;h2 id=&quot;二分析造成这种现象的原因&quot;&gt;二、分析造成这种现象的原因？&lt;/h2&gt;
&lt;h3 id=&quot;团队产品质量下降的过程&quot;&gt;1、团队产品质量下降的过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1）每个人都有偷懒的心态，能简单完成，肯定不会花太多时间去深入思考。这时候如果SM没有及时发现并纠正过来，这时候就出现一个破窗户，一段时间下来基本上整个街道的窗户都会出现破损。大家就这样养成了偷工减料的习惯。&lt;/li&gt;
&lt;li&gt;2）本来测试是把控质量这道关，但是随着这种低级的BUG越来越多，大量占用了他的时间，那他肯定也就慢慢降低了对质量的要求。&lt;/li&gt;
&lt;li&gt;3）然后就团队一起拿这个质量来应付产品经理，产品经理也没有办法了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;初步分析解决方案&quot;&gt;2、初步分析解决方案&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1）靠外部力量来改变或者加强监督，不是好办法，最好的办法自己找到自己的问题，以及自己的解决方案。&lt;/li&gt;
&lt;li&gt;2）收集数据，定义好质量的标准，形成制度。&lt;/li&gt;
&lt;li&gt;3）《BUG分析总结会议》&lt;/li&gt;
&lt;li&gt;4）《绩效扣分加分制度》&lt;/li&gt;
&lt;li&gt;5）《每月一次的绩效面谈与签字》&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三解决过程&quot;&gt;三、解决过程&lt;/h2&gt;
&lt;h3 id=&quot;组织团队posm会议提出团队问题讨论结果&quot;&gt;1）组织团队PO、SM会议，提出团队问题，讨论结果：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、定期组织产品培训、产品规划、技术培训，产品培训由测试主讲，产品规划由PO主讲，技术培训由SM主持。&lt;/li&gt;
&lt;li&gt;2、SM对于设计把关一定要当担起责任，一定要识别出那些负责设计，影响面广的设计，组织讨论要评审后才能做。另外调动起团队参与设计评审的积极性，这样才能识别出更多的设计问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参加团队早会提出新的早会制度&quot;&gt;2）参加团队早会，提出新的早会制度&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;规范每日站会的流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、大家讲&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三句话，昨天做了什么，今天准备做什么，有什么难点；大家围成一圈顺时针轮流讲，讲的时候不需要看电脑；有难点先不讨论只是提出来；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2、SM提问&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家讲完后，SM针对看板上延期的故事和任务提问，一定要找到延期的原因和解决办法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3、会后难点讨论&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，有难点的成员留下来讨论一下，找出解决办法。&lt;/p&gt;
&lt;h3 id=&quot;参加团队迭代总结会议重点总结了产品质量产生的原因&quot;&gt;3）参加团队迭代总结会议，重点总结了产品质量产生的原因&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、需求反复&lt;/li&gt;
&lt;li&gt;2、开发不熟悉不是自己编写的那块代码或业务，在不熟悉的代码上增加新功能导致产生很多bug&lt;/li&gt;
&lt;li&gt;3、测试在迭代中覆盖不全面，加强自动化测试，分析bug产生原因，反过来要求开发提升&lt;/li&gt;
&lt;li&gt;4、态度问题，不是自己的事情不做自己的任务不考虑细致深入，应付式的完成，包括开发测试都这样&lt;/li&gt;
&lt;li&gt;5、开发分析问题要找到根本原因，而不是直接打个补丁。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;组织bug分析总结会议重新定义bug分类&quot;&gt;4）组织BUG分析总结会议，重新定义BUG分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、开发不应该犯的BUG
&lt;ul&gt;&lt;li&gt;粗心大意&lt;/li&gt;
&lt;li&gt;逻辑不严谨&lt;/li&gt;
&lt;li&gt;反复出现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2、值得总结的BUG
&lt;ul&gt;&lt;li&gt;设计不合理&lt;/li&gt;
&lt;li&gt;业务不熟悉&lt;/li&gt;
&lt;li&gt;经验不足&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/79997/201907/79997-20190706131814179-904706858.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绩效面谈与签字&quot;&gt;5）绩效面谈与签字&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、扣分加分明细表&lt;/li&gt;
&lt;li&gt;2、绩效表签字&lt;/li&gt;
&lt;li&gt;3、意见反馈收集&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;根据这段时间的观察和改进，总结出3点来提升我们团队的产品质量；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、收集数据，所有的问题都要进禅道管理，并对这些问题进行分类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、BUG分析总结会，每个迭代后，有测试组织对本次迭代中产生的BUG进行分析与总结，提出改进建议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、绩效面谈与签字，月底SM跟团队每个人进行绩效面谈，包括本月员工取得的成绩、优点与不足、改进措施。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;附件&quot;&gt;附件：&lt;/h3&gt;
&lt;p&gt;1、绩效扣分加分制度：&lt;/p&gt;
&lt;p&gt;1、迭代故事没有完成扣绩效&lt;/p&gt;
&lt;p&gt;2、迭代后bug没有处理完成扣绩效&lt;/p&gt;
&lt;p&gt;3、代码评审发现问题扣绩效&lt;/p&gt;
&lt;p&gt;4、每次迭代之后进行一次产品演示，发现问题扣绩效，开发测试都扣&lt;/p&gt;
&lt;p&gt;5、迭代之星加绩效&lt;/p&gt;
&lt;p&gt;6、给团队培训加绩效&lt;/p&gt;
&lt;p&gt;7、热心为团队做了技术服务加绩效&lt;/p&gt;
&lt;p&gt;8、主动发现产品问题并登记进禅道加绩效&lt;/p&gt;
&lt;p&gt;2、日常注意事项：&lt;/p&gt;
&lt;p&gt;A、早会上不要讲一些很空洞的问题，不要等他们自己解决，要把问题具体化，并找到解决方案。&lt;/p&gt;
&lt;p&gt;B、测试所有问题要登禅道，除了发群里，这样今天没有解决的bug在明天早会上过，并给出解决方案。&lt;/p&gt;
&lt;p&gt;C、一个团队是否优秀主要看SM，所以SM不要承担太多的杂活，可以培养一个开发分担这些技术杂活。&lt;/p&gt;
&lt;p&gt;3、文档：互联网医院迭代17产生BUG分析.note&lt;/p&gt;
&lt;p&gt;4、互联网医院团队绩效分数统计&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jul 2019 14:45:00 +0000</pubDate>
<dc:creator>kakake</dc:creator>
<og:description>背景 团队采用敏捷开发已经一年时间了，刚开始半年随着团队成员之间的磨合以及技术的熟悉，开发的效率确实逐渐在提升，所以自认为团队上路了只会原来越好，谁想到后面团队没有进步，反而退步得厉害。 一、何时发现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kakake/p/11144488.html</dc:identifier>
</item>
<item>
<title>Selenium Grid分布式测试环境搭建 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-selenium-grid.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-selenium-grid.html</guid>
<description>&lt;h3&gt;Selenium Grid简介&lt;/h3&gt;
&lt;p&gt;Selenium Grid实际上是基于Selenium RC的，而所谓的分布式结构就是由一个hub节点和若干个node代理节点组成。Hub用来管理各个代理节点的注册信息和状态信息，并且接受远程客户端代码的请求调用，然后把请求的命令转发给代理节点来执行(官方说明)&lt;/p&gt;
&lt;p&gt;简单来说通过selenium grid可以实现一台服务器控制多台node节点机器远程执行selenium自动化测试脚本。比如自动化测试脚本存放在一台hub主机上，那么通过grid就可以控制多台node客户端来执行hub主机上的自动化测试脚本，下面我们就开始配置一下分布式测试运行环境&lt;/p&gt;
&lt;h4&gt;环境准备&lt;/h4&gt;
&lt;p&gt;其实hub主机和node节点可以同时配置在一台物理机上，但是为了模拟真实的测试环境，我准备了2台真实的物理机，当然你也可以使用一台物理机+虚拟机的方式练习&lt;/p&gt;
&lt;p&gt;1. 准备2台处于同一个局域网下的物理机，保证2台物理机能够相互ping通&lt;/p&gt;
&lt;p&gt;2.下载selenium-server-standalone包&lt;/p&gt;
&lt;p&gt;3.作为node节点的物理机需要配置好浏览器和对应驱动，并把驱动程序加入环境变量&lt;/p&gt;
&lt;p&gt;4.hub主机和node主机均需要配置java jdk 1.8 (切记本版，否则可能配置不成功)&lt;/p&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;如果你的两台机器处于同一个网络，但是无法相互ping通，你可以尝试下面的办法解决&lt;/p&gt;
&lt;p&gt;打开控制面板-打开防火墙设置-点击【高级设置】-点击【入站规则】找到下面两个规则并开启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706211203548-1666846571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;下载selenium-server-standalone&lt;/h4&gt;
&lt;p&gt;访问官网 &lt;a href=&quot;https://www.seleniumhq.org/download/&quot; target=&quot;_blank&quot;&gt;https://www.seleniumhq.org/download/&lt;/a&gt; 下载 selenium-server-standalone&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706211502686-1870116322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载好selenium-server-standalone-3.141.59.jar包后，分别放到两台电脑的任意位置&lt;/p&gt;
&lt;h4&gt;配置浏览器驱动&lt;/h4&gt;
&lt;p&gt;浏览器驱动如何配置，请自行百度(谷歌的驱动可以从这里下载&lt;a href=&quot;https://npm.taobao.org/mirrors/chromedriver&quot; target=&quot;_blank&quot;&gt;https://npm.taobao.org/mirrors/chromedriver&lt;/a&gt;)，我后面主要使用的是firefox浏览器&lt;/p&gt;
&lt;h4&gt;安装JDk&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linuxchao/p/linuxchao-jenkins-setup.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linuxchao/p/linuxchao-jenkins-setup.html&lt;/a&gt; 我的这篇文章里面有安装jdk的教程，但是请注意jdk的版本&lt;/p&gt;
&lt;h3&gt;搭建环境&lt;/h3&gt;
&lt;h4&gt;配置hub主机&lt;/h4&gt;
&lt;p&gt;我选择作为hub主机的地址为：192.168.1.103&lt;/p&gt;
&lt;p&gt;打开cmd终端，并切换到selenium-server-standalone-3.141.59.jar所在的目录下，执行命令：java -jar selenium-server-standalone-3.141.59.jar -role hub&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706212939546-2124379609.png&quot; alt=&quot;&quot; width=&quot;944&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行命令后，会初始化本机为hub服务器，自动分配一个ip地址(如图，这个地址是个虚拟地址，作为hub的主机地址，因为同一台机器可以同时作为hub和note，所以会自动生成一个虚拟地址)，端口号默认为4444，当然你在初始化hub主机的时候也可以修改默认端口，添加-port=指定端口号即可&lt;/p&gt;
&lt;p&gt;初始化完成后，我们可以访问http://192.168.24.1:4444:/grid/console来查看初始化的hub状态如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706213617622-511337905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;配置node节点&lt;/h4&gt;
&lt;p&gt;我选择的node节点机器的地址为：192.168.1.102&lt;/p&gt;
&lt;p&gt;同样打开cmd终端，并切换到selenium-server-standalone-3.141.59.jar所在的目录下，执行命令：&lt;/p&gt;
&lt;p&gt;java -jar selenium-server-standalone-3.141.59.jar -role webdriver -browser &quot;browserName=firefox,platform=WINDOWS&quot; -hubHost 192.168.1.103(hub所在的主机地址)&lt;/p&gt;
&lt;p&gt;如果你使用的浏览器是chrome，可能你需要执行这个命令(别问我为什么，我使用chrome浏览器的时候，使用上面的命令，只是修改了browserName=chrome，没有成功)&lt;/p&gt;
&lt;p&gt;java -jar -Dwedriver.chrome.driver=driver所在的目录\chromedriver.exe selenium-server-standalone-3.141.59.jar -browser &quot;browserName=chrome, version=75&quot; -role node -hubHost 192.168.1.103&lt;/p&gt;
&lt;p&gt;命令执行完毕后你会看到下面的输出信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706214917851-1512532112.png&quot; alt=&quot;&quot; width=&quot;1076&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，现在我们再次访问一下hub主机的地址看下状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706215056020-2050575252.png&quot; alt=&quot;&quot; width=&quot;1156&quot; height=&quot;630&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右边就是我初始化成功后的远程node节点机器的配置，左边我也配置了一个，是在hub所在的主机配置的一个note节点&lt;/p&gt;
&lt;p&gt;到这里，我们的分布式自动化测试环境就配置完成了，接下来开始编写我们的测试代码，看下是否能够在远程note机器上执行测试&lt;/p&gt;
&lt;h3&gt;测试脚本&lt;/h3&gt;
&lt;p&gt;测试脚本放在hub所在的机器(我们的目的就是控制远程note机器执行测试(打开浏览器执行测试)，并不是hub所在机器执行(要不然还有啥意义呢？))&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
------------------------------------
@Time : 2019/7/6 16:55
@Auth : linux超
@File : testCaseNodeB.py
@IDE  : PyCharm
@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!
@QQ   : 28174043@qq.com
@GROUP: 878565760
------------------------------------
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSeleniumGrid(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.driver &lt;/span&gt;= webdriver.Remote(command_executor=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.1.102:16891/wd/hub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                       desired_capabilities&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;browserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;firefox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 浏览器名称&lt;/span&gt;
                                                             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;platform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WINDOWS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                                             })

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_grid(self):
        self.driver.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux超&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;su&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
        WebDriverWait(self.driver, &lt;/span&gt;10&lt;span&gt;). \
            until(EC.visibility_of_element_located((By.XPATH, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[text()=&quot;https://www.cnblogs.com/&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
        page_source &lt;/span&gt;=&lt;span&gt; self.driver.page_source
        self.assertIn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, page_source)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        self.driver.quit()


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;执行过程&lt;/h4&gt;
&lt;p&gt;我们运行hub主机上的代码然后看一下note节点机器上执行的过程, 并注意看hub主机和note点击机器cmd终端的输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201907/1421063-20190706221359989-1023682654.gif&quot; alt=&quot;&quot; width=&quot;1169&quot; height=&quot;556&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行过程中有一些警告信息，也不知道什么原因，我还没找到解决的办法，但是并不影响测试的执行，到此为止整个测试环境搭建就完成了&lt;/p&gt;
&lt;h3&gt;最后&lt;/h3&gt;
&lt;p&gt;搭建过程需要注意&lt;/p&gt;
&lt;p&gt;1.浏览器和浏览器驱动版本要匹配，且添加到系统环境变量&lt;/p&gt;
&lt;p&gt;2.初始化hub和node时的命令不要敲错，算这次我一共搭过2次环境， 之前2次折腾命令参数就折腾了好久(对一个参数选项不太理解)&lt;/p&gt;
&lt;p&gt;3.不要被hub和node机器的ip搞晕，脚本中的要在哪里运行测试就要配置哪个node节点机器的地址 （command_executor=&quot;http://192.168.1.102:16891/wd/hub&quot;，而且要主要后面接的/wd/hub是固定的不要写错）&lt;/p&gt;
&lt;p&gt;需要注意的差不多就这么多吧， 自己不手动配置一遍你也不会知道究竟会遇到什么问题&lt;/p&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;p&gt;配置这个测试环境之后，我一直有个疑问，我的代码只能在一个node上的一个浏览器上执行，分布式分布式，这样的话还有啥意义呢？我的理解是应该能同时在不同的node机器上不同的浏览器上运行才符合这个概念，所以呢我试着使用python线程并发修改了几次代码也没有成功，试着找资料也没有解决我这个疑惑，也可能我理解的有问题，不管怎么样了，以后有了思路再更新这篇文章吧！&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jul 2019 14:42:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>Selenium Grid简介 Selenium Grid实际上是基于Selenium RC的，而所谓的分布式结构就是由一个hub节点和若干个node代理节点组成。Hub用来管理各个代理节点的注册信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-grid.html</dc:identifier>
</item>
<item>
<title>敏捷开发，如何编写架构文档 - 土豆的奥特之父</title>
<link>http://www.cnblogs.com/xguo/p/11144324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xguo/p/11144324.html</guid>
<description>&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201907/57355-20190706220210839-86106149.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;每个系统都包含一系列架构决策，定义了设计和实现的边界和限制，&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;架构设计文档的核心是以某种方式的选型决策，而开发团队可能不太清楚这个决策背后的假设和思考。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于这些决策，由于我们缺少当时的上下文，只能盲目的接受和盲目的做出改变。&lt;/p&gt;
&lt;p&gt;闲逛ThoughtWorks Radar偶然发现一个在17年和18年都被ADOPT（采用）的技术叫“ADR - Lightweight Architecture Decision Records”，轻量的架构决策记录，针对演进式架构而提出的一种架构文档管理方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fassets.thoughtworks.com%2Fassets%2Ftechnology-radar-vol-18-cn.pdf&quot; target=&quot;_blank&quot;&gt;https://assets.thoughtworks.com/assets/technology-radar-vol-18-cn.pdf&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1562&quot; data-height=&quot;952&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201907/57355-20190706215230235-907064280.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ADR&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;敏捷开发和ADR&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;敏捷宣言说：“可以工作的软件，强过全面的文档”&lt;br/&gt;&lt;em&gt;(agile manifesto: Working software over comprehensive documentation)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;--- 意思不是说不需要文档！&lt;/p&gt;
&lt;p&gt;特别是敏捷类型的项目，软件架构需要适应新的业务、市场的变化，架构技术重要的决策是如何做出的，为什么这么选择，背后有怎样的假设。&lt;/p&gt;
&lt;p&gt;所以，主要的问题是架构的文档形式和内容，架构文档需要与项目的状态保持紧密的关系，并且简洁，明了，便于维护和阅读，不然，架构的文档就没有人看，更不会有人去更新他。&lt;/p&gt;
&lt;h2&gt;什么是ADR&lt;/h2&gt;
&lt;p&gt;接下来我们就来简单看一下什么是ADR，如何解决篇头提出的几个疑虑。&lt;/p&gt;
&lt;p&gt;ADR，先来看一下什么是AD（Architecture Decision）？，&lt;/p&gt;
&lt;p&gt;在《Documenting Architecture Decisions》一文中说道架构文档应该关注和收集的内容包括：“affect the structure, non-functional characteristics, dependencies, interfaces, or construction techniques”。&lt;/p&gt;
&lt;p&gt;因此，架构决策，是一个软件设计的选择，涵盖了功能性和非功能性所需要的重要架构选型和设计，系统架构的质量是可以被衡量的（&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FArchitecturally_significant_requirements&quot; target=&quot;_blank&quot;&gt;Architecturally Significant Requirement (ASR)&lt;/a&gt; ）。&lt;/p&gt;
&lt;p&gt;Architectural Decision Record (ADR)是一个单一的架构决策的记录文件，例如架构师所做出的架构决策思考，或者架构设计会要的记录等，而 &lt;code&gt;ADRs&lt;/code&gt; 则是维护了一系列架构记录文件集合（ARD），通常存储在项目的 &lt;code&gt;doc/adr&lt;/code&gt; 目录下，文件名的格式形如：&lt;code&gt;adr-NNNN-title-with-dashes.md&lt;/code&gt; ，或者 &lt;code&gt;NNNN-title-with-dashes.md&lt;/code&gt;，&lt;code&gt;NNNN&lt;/code&gt; 是一个单调的数字序列，例如 &lt;code&gt;0001&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;注意 ，当某个决策被废除，这个旧的ADR文件应该保留，只是做个标记，表示被取代，因为它也是曾经决策思考的结果。&lt;/p&gt;
&lt;h3&gt;ADR文件的结构：&lt;/h3&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;# [short title of solved problem and solution]

* Status: [proposed | rejected | accepted | deprecated | … | superseded by [ADR-0005](0005-example.md)] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，有很多项是optional 的，根据情况，自行取舍。&lt;/p&gt;
&lt;h3&gt;一个例子：（doc/adr/0005-help-comments.md）&lt;/h3&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;5. Help comments
Date: 2016-02-13

Status
Accepted

Amended by 9. Help scripts

Context
The tool will have a &lt;span class=&quot;hljs-built_in&quot;&gt;help subcommand to provide documentation &lt;span class=&quot;hljs-keyword&quot;&gt;for users.

It&lt;span class=&quot;hljs-string&quot;&gt;'s nice to have usage documentation in the script files themselves, in comments. When reading the code, that's the first place to look &lt;span class=&quot;hljs-keyword&quot;&gt;for information about how to run a script.

Decision
Write usage documentation &lt;span class=&quot;hljs-keyword&quot;&gt;in comments &lt;span class=&quot;hljs-keyword&quot;&gt;in the &lt;span class=&quot;hljs-built_in&quot;&gt;source file.

Distinguish between documentation comments and normal comments. Documentation comments have two &lt;span class=&quot;hljs-built_in&quot;&gt;hash characters at the start of the line.

The adr &lt;span class=&quot;hljs-built_in&quot;&gt;help &lt;span class=&quot;hljs-built_in&quot;&gt;command can parse comments out from the script using the standard Unix tools grep and cut.

Consequences
No need to maintain &lt;span class=&quot;hljs-built_in&quot;&gt;help text &lt;span class=&quot;hljs-keyword&quot;&gt;in a separate file.

Help text can easily be kept up to date as the script is edited.

There&lt;span class=&quot;hljs-string&quot;&gt;'s no automated check that the help text is up to date. The tests do not work well as documentation for users, and the help text is not easily cross-checked against the code.

This won't work &lt;span class=&quot;hljs-keyword&quot;&gt;if any subcommands are not implemented as scripts that use &lt;span class=&quot;hljs-string&quot;&gt;'#' as a comment character.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;总结一下，越来越多的基于敏捷的项目开发模式，要求我们有演进式的架构设计眼光，因此我们也需要采用一种类似的技术，去有效的，敏捷的整理架构文档，去跟踪记录你或者你们团队，曾经对一系列功能所做出的架构思考和取舍权衡的过程。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fadr.github.io%2F&quot; target=&quot;_blank&quot;&gt;https://adr.github.io/&lt;/a&gt; Homepage of the ADR&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.thoughtworks.com%2Fradar%2Ftechniques%2Flightweight-architecture-decision-records&quot; target=&quot;_blank&quot;&gt;https://www.thoughtworks.com/radar/techniques/lightweight-architecture-decision-records&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.hascode.com%2F2018%2F05%2Fmanaging-architecture-decision-records-with-adr-tools%2F&quot; target=&quot;_blank&quot;&gt;https://www.hascode.com/2018/05/managing-architecture-decision-records-with-adr-tools/&lt;/a&gt; Managing Architecture Decision Records with ADR-Tools&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fresources.sei.cmu.edu%2Fasset_files%2FPresentation%2F2017_017_001_497746.pdf&quot; target=&quot;_blank&quot;&gt;https://resources.sei.cmu.edu/asset_files/Presentation/2017_017_001_497746.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fagilemanifesto.org&quot; target=&quot;_blank&quot;&gt;https://agilemanifesto.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 06 Jul 2019 14:03:00 +0000</pubDate>
<dc:creator>土豆的奥特之父</dc:creator>
<og:description>每个系统都包含一系列架构决策，定义了设计和实现的边界和限制， 架构设计文档的核心是以某种方式的选型决策，而开发团队可能不太清楚这个决策背后的假设和思考。 对于这些决策，由于我们缺少当时的上下文，只能盲</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xguo/p/11144324.html</dc:identifier>
</item>
<item>
<title>Dubbo源码学习之-SPI介绍 - 张曾经</title>
<link>http://www.cnblogs.com/zzq6032010/p/11144350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzq6032010/p/11144350.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;学习之路还是要戒骄戒躁，一以贯之的积累前行。之前的公司部门技术达人少，自己总向往那些技术牛人多的团队，想象自己进去之后能跟别人学到多少东西。如今进到一个这样的团队之后，却发现之前自己的想法过于幼稚。且不说由于人与人之间性格不合导致的难以深入相处，即使相处融洽，别人也不会给你太多的帮扶，更多的还是靠自己去学习去探究。学习的道路上没有什么捷径，且会有很多的心魔需要自己去克服。闲话少叙，今天主要是说一下Dubbo中SPI的基本内容，自适应拓展的部分后面单独成文。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要说Dubbo的SPI，则必须先说说Java原生的SPI。可能很多道友都没有听说过SPI，它是Service Provider Interface 即服务提供接口的简称，顾名思义，它就是用来提供服务的。&lt;/p&gt;
&lt;p&gt;在Java中是如何提供服务的呢？简要来说，就是在资源文件目录下（即resource目录下）的META-INF/services文件夹下，建立文件名为接口的全路径名的文件，文件内容为此接口的实现类全路径名。然后在代码中通过ServiceLoader类获取这些配置的实现类，然后就可以自由的使用这么实现类了。下面是我在本地写的一个小Demo：&lt;/p&gt;
&lt;p&gt;代码结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558028/201907/1558028-20190706212433923-2036126541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spipackage;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SpiInterface {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getName();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个实现类代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spipackage;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpiImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SpiInterface{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getName() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;SpiImpl&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spipackage;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpiImplTwo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SpiInterface {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getName() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;SpiImplTwo&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;资源文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spipackage.SpiImpl
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; spipackage.SpiImplTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spipackage;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ServiceLoader;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpiTestClient {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         ServiceLoader&amp;lt;SpiInterface&amp;gt; spiInterfaces = ServiceLoader.load(SpiInterface.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环调用实现类中的方法&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        spiInterfaces.forEach(SpiInterface::getName);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取某个实现类进行调用&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         Iterator&amp;lt;SpiInterface&amp;gt; iterator =&lt;span&gt; spiInterfaces.iterator();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             SpiInterface next =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (next &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SpiImplTwo) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                next.getName();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558028/201907/1558028-20190706212823223-938311089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Dubbo的SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从java原生SPI的使用上可知，它是一次性加载整个资源文件中的数据，当你要获取其中某个实现类时也只能通过遍历来得到。而Dubbo的开发人员们显然要让其更加灵活，所以Dubbo中的SPI是在Java原生SPI基础上做了改造升级。首先可以按需加载，需要用哪个就加载哪个，这是通过键值对来配置实现类做到的，相当于给每个实现类打上了标签；其次还实现了依赖注入，即如果实现类A中需要注入实现类B，则dubbo在获取实现类A时会自动将B注入进去。&lt;/p&gt;
&lt;p&gt;具体的本地代码测试跟上述类似，此处就不在贴出来了，只是需将ServiceLoader换成Dubbo的ExtensionLoader，且接口需带有@SPI注解，并且资源文件也可放入META-INF/dubbo目录下。&lt;/p&gt;
&lt;p&gt;下面简要讲一下ExtensionLoader中的源码实现。Dubbo的ExtensionLoader类中，获取服务类的主要方法是getExtension方法，而在这个方法中，核心方法是createExtension，此方法很重要，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T createExtension(String name) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、先获取class类&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; getExtensionClasses().get(name);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; findException(name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             T instance =&lt;span&gt; (T) EXTENSION_INSTANCES.get(clazz);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、通过反射创建实例，且存入缓存&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 instance =&lt;span&gt; (T) EXTENSION_INSTANCES.get(clazz);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、注入依赖，类似spring的依赖注入&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            injectExtension(instance);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、将扩展对象包进wrapper对象中&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses =&lt;span&gt; cachedWrapperClasses;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isNotEmpty(wrapperClasses)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; wrapperClass : wrapperClasses) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     instance =&lt;span&gt; injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Extension instance (name: &quot; + name + &quot;, class: &quot; +
&lt;span&gt;26&lt;/span&gt;                     type + &quot;) couldn't be instantiated: &quot; +&lt;span&gt; t.getMessage(), t);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分四步获取了类的实例对象。其中第一步中包含了主要的逻辑，它读取配置文件，是通过类加载器加载文件获取输入流，然后一行一行读取的，其中包括了对空格的处理、对注释的处理。之前总感觉读取配置文件的实现很神奇，现在慢慢的可以一窥其中究竟了，觉得也没多高大上，都是很实际的操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小结：SPI的作用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过SPI实现的功能扩展，更类似于插拔式的扩展。增加了某些功能类之后，通过配置文件引入，然后在某些地方获取，调用即可。SPI机制是Dubbo的基础，了解了它才能更加清楚的看清Dubbo的框架设计。另外，通过对SPI的了解，个人感觉SPI有点类似于Spring的IOC实现，也可以说Spring通过XMl配置文件或者注解实现了一种另类的SPI机制，让你不用关注实例对象的创建，只是用的时候获取到用即可，当然Spring实现的功能内容更多更易于扩展。&lt;/p&gt;
&lt;p&gt;只要每天都有进步，都在朝目标前行，就可心安。戒骄戒躁，努力前行！&lt;/p&gt;

</description>
<pubDate>Sat, 06 Jul 2019 14:02:00 +0000</pubDate>
<dc:creator>张曾经</dc:creator>
<og:description>前言 学习之路还是要戒骄戒躁，一以贯之的积累前行。之前的公司部门技术达人少，自己总向往那些技术牛人多的团队，想象自己进去之后能跟别人学到多少东西。如今进到一个这样的团队之后，却发现之前自己的想法过于幼</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzq6032010/p/11144350.html</dc:identifier>
</item>
<item>
<title>数据库之MySQL高级 - YifChan</title>
<link>http://www.cnblogs.com/yifchan/p/sql-1-4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifchan/p/sql-1-4.html</guid>
<description>&lt;p&gt;内容来自本人以前在github搭建的博客写的：&lt;a title=&quot;MySQL高级&quot; href=&quot;https://yifchan.github.io/2018/12/02/pymysql%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95/&quot; target=&quot;_blank&quot;&gt;MySQL高级之视图事务函数触发器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;pymysql安装&quot;&gt;pymysql安装&lt;/h2&gt;
&lt;p&gt;pymysql是python用于连接并操作数据库的一个原生模块&lt;/p&gt;
&lt;p&gt;linux下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip3 install pymysql
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;sql注入&quot;&gt;sql注入&lt;/h2&gt;
&lt;h3 id=&quot;1-简单模拟登录&quot;&gt;1.简单模拟登录&lt;/h3&gt;
&lt;p&gt;先来看一个简单例子，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

&lt;/span&gt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; input(&quot;username:&quot;)
pwd &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; input(&quot;password:&quot;)

# 与数据库建立连接
conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&quot;localhost&quot;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;root&quot;, password&lt;span&gt;=&lt;/span&gt;&quot;root&quot;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;test&quot;)
# 设置游标
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;()
# 将要执行的sql语句
sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; username &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&quot; &lt;span&gt;%&lt;/span&gt; (&lt;span&gt;user&lt;/span&gt;&lt;span&gt;, pwd)
# 执行语句
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
# 用fetchone获取查询结果
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchone()
# 关闭连接
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()
conn.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&quot;登录成功&quot;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&quot;用户名或密码错误&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-sql注入漏洞&quot;&gt;2.sql注入漏洞&lt;/h3&gt;
&lt;p&gt;注意，上面的代码虽然可正确执行，但是是存在漏洞的。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox fancybox.image&quot; href=&quot;https://wx2.sinaimg.cn/mw1024/006s58zcgy1fxmcpk7a3mj30te0c9dgs.jpg&quot; rel=&quot;group&quot;&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw1024/006s58zcgy1fxmcpk7a3mj30te0c9dgs.jpg&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;296&quot;/&gt;&lt;/a&gt;&lt;br/&gt;如图，漏洞为即使你随便输入一个账户，按照”xxx’ or 1=1 – “的格式，不输入密码也能登录进去，这种漏洞我们称呼为”sql注入”；问题主要存在于sql语句的写法。&lt;/p&gt;
&lt;h3 id=&quot;3-sql注入原理&quot;&gt;3.sql注入原理&lt;/h3&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1618401/201907/1618401-20190706213520817-81858362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-避免sql注入&quot;&gt;4.避免sql注入&lt;/h3&gt;
&lt;p&gt;为了避免sql注入，我们不要自己做拼接，用pymysql自带的execute后面传参数的方式,有如下三种方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; username &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;s &lt;span&gt;and&lt;/span&gt; password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;&lt;span&gt;s&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, (&lt;span&gt;user&lt;/span&gt;, pwd))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; username &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;s &lt;span&gt;and&lt;/span&gt; password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;&lt;span&gt;s&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;user, pwd&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; username &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;(u)s &lt;span&gt;and&lt;/span&gt; password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;&lt;span&gt;(p)s&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;user&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: pwd})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺利解决sql注入问题，如图&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox fancybox.image&quot; href=&quot;https://wx1.sinaimg.cn/mw1024/006s58zcgy1fxmcpmdsatj30tf0b1js5.jpg&quot; rel=&quot;group&quot;&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw1024/006s58zcgy1fxmcpmdsatj30tf0b1js5.jpg&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;273&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-模拟登陆代码&quot;&gt;5.模拟登陆代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; input(&quot;username:&quot;)
pwd &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; input(&quot;password:&quot;)

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;()

sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; name&lt;span&gt;=%&lt;/span&gt;s &lt;span&gt;and&lt;/span&gt; password&lt;span&gt;=%&lt;/span&gt;&lt;span&gt;s&quot;
r &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql, (name, pwd))
# 方法二
# sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; name&lt;span&gt;=%&lt;/span&gt;s &lt;span&gt;and&lt;/span&gt; password&lt;span&gt;=%&lt;/span&gt;&lt;span&gt;s&quot;
# r &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;name, pwd&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)
# 方法三
# sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; name&lt;span&gt;=%&lt;/span&gt;(u)s &lt;span&gt;and&lt;/span&gt; password&lt;span&gt;=%&lt;/span&gt;&lt;span&gt;(p)s&quot;
# r &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: pwd})
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchone()

&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()
conn.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&quot;登陆成功&quot;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&quot;账户名或密码错误&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;pymysql操作数据库&quot;&gt;pymysql操作数据库&lt;/h2&gt;
&lt;h3 id=&quot;1-pymysql增&quot;&gt;1.pymysql增&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.1.插入一行数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&quot;localhost&quot;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;root&quot;, password&lt;span&gt;=&lt;/span&gt;&quot;root&quot;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;test&quot;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;()
sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(username,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;那英&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;naying&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()
conn.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是，在增删改时我们用的是commit进行提交，在查时用的是fetchone进行查找。&lt;/strong&gt;&lt;br/&gt;当然，我们也可以自定义插入，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(username,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;%&lt;/span&gt;s,&lt;span&gt;%&lt;/span&gt;&lt;span&gt;s)&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(sql, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;user, pwd&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2.插入多行数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在插入当行数据是，应注意此时我们用的是&lt;strong&gt;executemany&lt;/strong&gt;，而不是execute。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(username,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;%&lt;/span&gt;s,&lt;span&gt;%&lt;/span&gt;&lt;span&gt;s)&quot;
r &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.executemany(sql, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;('张学友', 'zhangxueyou'), ('林俊杰', 'linjunjie')&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.execute的返回值r&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;execute和executemany都有返回值，用来记录受影响的行数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(username,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;%&lt;/span&gt;s,&lt;span&gt;%&lt;/span&gt;&lt;span&gt;s)&quot;
r &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.executemany(sql, &lt;span&gt;[&lt;/span&gt;&lt;span&gt;('张学友', 'zhangxueyou'), ('林俊杰', 'linjunjie')&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为2；&lt;br/&gt;不仅仅是增删改会有受影响的行数，查询时也会有。&lt;br/&gt;同时，&lt;strong&gt;executemany只适用于插入数据&lt;/strong&gt;，删和改用execute即可。&lt;/p&gt;
&lt;h3 id=&quot;2-pymysql查&quot;&gt;2.pymysql查&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1.fetchone&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchone()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchone()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchone()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;刘德华&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;liudehua&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;郭德纲&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;guodegang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;胡歌&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;huge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fetchone可以单次查询，也可以连续单次查询，连续单次查询时，会有类似于指针一样的东西，当你查询一次后，指针自动跳往下一行数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.fetchall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fetchall在未指定limit时，默认查询所有数据&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; userinfo&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchall()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
((&lt;span&gt;1&lt;/span&gt;, ‘刘德华’, ‘liudehua’), (&lt;span&gt;3&lt;/span&gt;, ‘郭德纲’, ‘guodegang’), (&lt;span&gt;4&lt;/span&gt;, ‘胡歌’, ‘huge’), (&lt;span&gt;5&lt;/span&gt;, ‘周杰伦’, ‘zhoujielun’), (&lt;span&gt;7&lt;/span&gt;, ‘那英’, ‘naying’), (&lt;span&gt;8&lt;/span&gt;, ‘王菲’, ‘wangfei’), (&lt;span&gt;11&lt;/span&gt;, ‘张学友’, ‘zhangxueyou’), (&lt;span&gt;14&lt;/span&gt;, ‘林俊杰’, ‘linjunjie’))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.3.fetchmany&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fetchmany(n)查询指定前n条数据&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sql &lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; userinfo&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.fetchmany(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
((&lt;span&gt;1&lt;/span&gt;, ‘刘德华’, ‘liudehua’), (&lt;span&gt;3&lt;/span&gt;, ‘郭德纲’, ‘guodegang’), (&lt;span&gt;4&lt;/span&gt;, ‘胡歌’, ‘huge’))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.4.fetch小结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.fetchone查询单次数据，fetchall查询所有数据，fetchmany(n)查询指定n词数据。&lt;/li&gt;
&lt;li&gt;2.如果想要实现分页的话，要先在查询语句中limit 10数据，再用fetchall查询指定的10条数据；而不能先fetchall所有数据，再一部分一部分的显示。&lt;/li&gt;
&lt;li&gt;3.相对来说，用的最多的是fetchone和fetchall&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cursor.scroll(1,mode=’relative’) # 相对当前位置移动&lt;/li&gt;
&lt;li&gt;cursor.scroll(2,mode=’absolute’) # 相对绝对位置移动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.5.查询数据字典形式显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了方便查看，我们会将数据以字典格式显示key和value&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;(&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;pymysql.cursors.DictCursor)
sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; userinfo&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;.fetchmany(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;{‘id’: 1, ‘username’: ‘刘德华’, ‘password’: ‘liudehua’}, {‘id’: 3, ‘username’: ‘郭德纲’, ‘password’: ‘guodegang’}, {‘id’: 4, ‘username’: ‘胡歌’, ‘password’: ‘huge’}&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.6.新增数据的自增id&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取新增数据的自增id:cursor.lastrowid,直接用&lt;br/&gt;如果插入的为多行数据，则显示的为最后一个自增的id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;cursor&lt;/span&gt;.lastrowid)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-pymysql删改&quot;&gt;3.pymysql删改&lt;/h3&gt;
&lt;p&gt;增和查的注意点可能多一点，而pymysql删与改的操作重点在于sql语句，其他只需要连接，执行，关闭连接即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1.改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;()

sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;update&lt;/span&gt; userinfo &lt;span&gt;set&lt;/span&gt; name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李玉刚&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()
conn.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-pymysql删&quot;&gt;4.pymysql删&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;4.1.删&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pymysql

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;()

sql &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(sql)
conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;()

&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;视图&quot;&gt;视图&lt;/h2&gt;
&lt;p&gt;为某个查询语句设置别名，方便使用，即为视图；&lt;/p&gt;
&lt;h3 id=&quot;1-创建视图&quot;&gt;1.创建视图&lt;/h3&gt;
&lt;p&gt;创建语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; viewname &lt;span&gt;as&lt;/span&gt; SQL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; v1 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; userinfo &lt;span&gt;WHERE&lt;/span&gt; id&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; v1 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; id,name &lt;span&gt;FROM&lt;/span&gt; userinfo &lt;span&gt;WHERE&lt;/span&gt; id&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-修改视图&quot;&gt;2.修改视图&lt;/h3&gt;
&lt;p&gt;修改语句：alter view viewname as SQL&lt;br/&gt;eg：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; v1 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; id,NAME &lt;span&gt;from&lt;/span&gt; userinfo &lt;span&gt;WHERE&lt;/span&gt; id &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-删除视图&quot;&gt;3.删除视图&lt;/h3&gt;
&lt;p&gt;删除语句：drop view viewname;&lt;br/&gt;eg：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; v1;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-查看视图&quot;&gt;4.查看视图&lt;/h3&gt;
&lt;p&gt;查看语句：select from viewname;&lt;br/&gt;eg:&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; v1;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; id,name &lt;span&gt;from&lt;/span&gt; v1;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-视图小结&quot;&gt;5.视图小结&lt;/h3&gt;
&lt;p&gt;给一个临时表设置别名的过程就叫做创建视图，别名就是视图的名称；实际存在的表比如userinfo就是物理表，而一个视图就是虚拟表，虚拟表动态的从物理表中取数据，所以在物理表中插入数据后虚拟表也可能会随之改变，但不能向虚拟表中插入数据；创建，修改，删除视图。&lt;/p&gt;

&lt;h2 id=&quot;触发器&quot;&gt;触发器&lt;/h2&gt;
&lt;p&gt;对某个表进行【增/删/改】操作的前后触发一些操作即为触发器，如果希望触发增删改的行为之前或之后做操作时，可以使用触发器，触发器用于自定义用户对表的行进行【增/删/改】前后的行为。&lt;/p&gt;
&lt;h3 id=&quot;1-创建触发器&quot;&gt;1.创建触发器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
delimiter &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   # 修改终止符
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TRIGGER&lt;/span&gt; tri_before_insert_userinfo BEFORE &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; userinfo &lt;span&gt;for&lt;/span&gt;&lt;span&gt; EACH ROW
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,newname) &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;
delimiter ;    # 结束后将终止符修改回来&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-多次触动触发器&quot;&gt;2.多次触动触发器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(name,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;石超&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shichao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;林殊&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linshu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为each row的存在，在一次SQL中插入两行数据，会触发两次触发器，即向userinfo插入数据前，会分别两次向user插入数据。&lt;/p&gt;
&lt;h3 id=&quot;3-自定义触发器新插入数据&quot;&gt;3.自定义触发器新插入数据&lt;/h3&gt;
&lt;p&gt;在前面我们写的触发器里，只能插入固定的数据，那么我们可不可以在user中插入即将插入userinfo的数据呢？答案是可以的，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
delimiter &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; tri_after_delete_userinfo after &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; userinfo &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each row
&lt;/span&gt;&lt;span&gt;begin&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,oldname) &lt;span&gt;values&lt;/span&gt;(‘&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;’,OLD.name);
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;
delimiter ;

delimiter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; tri_after_update_userinfo after &lt;span&gt;update&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; userinfo &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each row
&lt;/span&gt;&lt;span&gt;begin&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,oldname,newname) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,OLD.name,NEW.name);
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：触发器无法被修改，如果想要修改的话，可以先drop，再重新创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
delimiter &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; tri_after_update_userinfo after &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; userinfo &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each row
&lt;/span&gt;&lt;span&gt;begin&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; NEW.operate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,newname) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,NEW.name);
elseif NEW.operate &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
    &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,newname) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,OLD.name);
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
    &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfolog(type,oldname,newname) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,OLD.name);
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;h3 id=&quot;1、内置函数&quot;&gt;1、内置函数&lt;/h3&gt;
&lt;p&gt;MySQL中提供了许多内置函数，例如：&lt;br/&gt;CURDATE(),可以查看当前时间；&lt;br/&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; CURDATE()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a title=&quot;查看更多&quot; href=&quot;https://dev.mysql.com/doc/refman/5.7/en/string-functions.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;查看更多&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、自定义函数&quot;&gt;2、自定义函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delimiter \\
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1(
    i1 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    i2 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;returns&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;declare&lt;/span&gt; num &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; num &lt;span&gt;=&lt;/span&gt; i1 &lt;span&gt;+&lt;/span&gt;&lt;span&gt; i2;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(num);
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; \\
delimiter ; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3、删除函数&quot;&gt;3、删除函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; func_name();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4、执行函数&quot;&gt;4、执行函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 获取返回值
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@i1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@i2&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; f1(&lt;span&gt;@i1&lt;/span&gt;,&lt;span&gt;@i2&lt;/span&gt;) &lt;span&gt;into&lt;/span&gt; &lt;span&gt;@j&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@j&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; f1(&lt;span&gt;11&lt;/span&gt;,nid) ,name &lt;span&gt;from&lt;/span&gt; tb2; # 在查询中使用,对列的值函数计算后返回。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;5、查看函数&quot;&gt;5、查看函数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show &lt;span&gt;function&lt;/span&gt; status;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;6、查看函数构建语句&quot;&gt;6、查看函数构建语句&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show &lt;span&gt;create&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; func_name\G 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;存储过程&quot;&gt;存储过程&lt;/h2&gt;
&lt;p&gt;存储过程是一个SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。&lt;/p&gt;
&lt;h3 id=&quot;1、创建存储过程&quot;&gt;1、创建存储过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;无参数存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;– 创建存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
delimiter &lt;span&gt;//&lt;/span&gt;　　#修改结束符号，为&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;procedure&lt;/span&gt;&lt;span&gt; p1()
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t1;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;– 执行存储过程&lt;/p&gt;


&lt;p&gt;对于存储过程，可以接收参数，其参数有三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;in 仅用于传入参数用&lt;/li&gt;
&lt;li&gt;out 仅用于返回值用&lt;/li&gt;
&lt;li&gt;inout 既可以传入又可以当作返回值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于变量设置，对于调用存储过程或者函数时，外部传入参数或者获取参数，需加符号@，例如set @t=1；在本次会话内这些带@的变量都可以被获取到。断开连接后变量失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有参数存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;– 创建存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delimiter \\
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;procedure&lt;/span&gt;&lt;span&gt; p1(
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; i1 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; i2 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    inout i3 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    out r1 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; temp1 &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; temp2 &lt;span&gt;int&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; temp1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; r1 &lt;span&gt;=&lt;/span&gt; i1 &lt;span&gt;+&lt;/span&gt; i2 &lt;span&gt;+&lt;/span&gt; temp1 &lt;span&gt;+&lt;/span&gt;&lt;span&gt; temp2;  
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; i3 &lt;span&gt;=&lt;/span&gt; i3 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;\\
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;– 执行存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@t2&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
CALL p1 (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;@t1&lt;/span&gt;, &lt;span&gt;@t2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@t1&lt;/span&gt;,&lt;span&gt;@t2&lt;/span&gt;&lt;span&gt;;

delimiter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;　 将结束符号;修改为&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt;&lt;span&gt;　　声明变量。如果没有DEFAULT子句，初始值为NULL。用于内部变量申明。
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;　　　　  变量赋值。用于内部变量赋值，和传参数时参数赋值。 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2、删除存储过程&quot;&gt;2、删除存储过程&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;procedure&lt;/span&gt; proc_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3、执行存储过程&quot;&gt;3、执行存储过程&lt;/h3&gt;
&lt;p&gt;– 无参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
call proc_name();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;– 有参数，全in&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
call proc_name(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;– 有参数，有in，out，inout&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@t1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
call proc_name(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;@t1&lt;/span&gt;,&lt;span&gt;@t2&lt;/span&gt;&lt;span&gt;);


import pymysql

conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; pymysql.connect(host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, db&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; conn.&lt;span&gt;cursor&lt;/span&gt;(&lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;pymysql.cursors.DictCursor)

&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.callproc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, args&lt;span&gt;=&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)) # 执行存储过程

&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;(&quot;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@_p1_0&lt;/span&gt;,&lt;span&gt;@_p1_1&lt;/span&gt;,&lt;span&gt;@_p1_2&lt;/span&gt;,&lt;span&gt;@_p1_3&lt;/span&gt;&lt;span&gt;&quot;) # 获取执行完存储的参数
result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;cursor&lt;/span&gt;&lt;span&gt;.fetchall()

conn.&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;cursor&lt;/span&gt;.&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()
conn.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;()


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4、查看存储过程&quot;&gt;4、查看存储过程&lt;/h3&gt;
&lt;p&gt;列出所有的存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
SHOW  &lt;span&gt;PROCEDURE&lt;/span&gt;  STATUS;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;5、查看存储过程生成语句&quot;&gt;5、查看存储过程生成语句&lt;/h3&gt;
&lt;p&gt;查看存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SHOW &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; 存储过程名\G
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。&lt;/p&gt;
&lt;p&gt;定义存储过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delimiter \\
&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; p1;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt;&lt;span&gt; p1(
    OUT p_return_code &lt;/span&gt;&lt;span&gt;tinyint&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; 
  &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;exit&lt;/span&gt; handler &lt;span&gt;for&lt;/span&gt; sqlexception     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 定义错误处理&lt;/span&gt;
  &lt;span&gt;BEGIN&lt;/span&gt; 
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; ERROR &lt;/span&gt;
    &lt;span&gt;set&lt;/span&gt; p_return_code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;rollback&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 回滚&lt;/span&gt;
  &lt;span&gt;END&lt;/span&gt;&lt;span&gt;; 

  &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;exit&lt;/span&gt; handler &lt;span&gt;for&lt;/span&gt; sqlwarning     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 定义告警处理&lt;/span&gt;
  &lt;span&gt;BEGIN&lt;/span&gt; 
    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; WARNING &lt;/span&gt;
    &lt;span&gt;set&lt;/span&gt; p_return_code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;; 
  &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;; 

  START &lt;/span&gt;&lt;span&gt;TRANSACTION&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 开始事务，使下面的多条SQL语句操作变成原子性操作&lt;/span&gt;
        &lt;span&gt;UPDATE&lt;/span&gt; tb7 &lt;span&gt;set&lt;/span&gt; licnese&lt;span&gt;=&lt;/span&gt;(licnese&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;WHERE&lt;/span&gt; nid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; tb7 &lt;span&gt;set&lt;/span&gt; licnese&lt;span&gt;=&lt;/span&gt;(licnese&lt;span&gt;+&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;WHERE&lt;/span&gt; nid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;; 

  &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt;&lt;span&gt;; 

  &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; SUCCESS &lt;/span&gt;
  &lt;span&gt;set&lt;/span&gt; p_return_code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;\\
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行存储过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
call p1(&lt;span&gt;@p&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@p&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;SQL防注入之动态SQL&quot;&gt;SQL防注入之动态SQL&lt;/h2&gt;
&lt;p&gt;在高级语言的DB API不提供防注入的参数化查询功能时，可以使用这种方法来防止SQL注入。在pymysql中的调用点这里。&lt;/p&gt;
&lt;p&gt;定义存储过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delimiter \\
&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; proc_sql \\
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt;&lt;span&gt; proc_sql (
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; nid1 &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; nid2 &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; callsql &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
    )
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;set&lt;/span&gt; &lt;span&gt;@nid1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; nid1;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@nid2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; nid2;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@callsql&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; callsql;
        &lt;/span&gt;&lt;span&gt;PREPARE&lt;/span&gt; myprod &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;@callsql&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;     PREPARE prod FROM 'select * from tb2 where nid&amp;gt;? and  nid&amp;lt;?';    传入的值为字符串，？为占位符&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;     用@nid1，和@nid2填充占位符&lt;/span&gt;
        &lt;span&gt;EXECUTE&lt;/span&gt; myprod USING &lt;span&gt;@nid1&lt;/span&gt;,&lt;span&gt;@nid2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;DEALLOCATE&lt;/span&gt; &lt;span&gt;prepare&lt;/span&gt;&lt;span&gt; myprod; 

&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;\\
delimiter ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@nid1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@nid2&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@callsql&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb7 where nid&amp;gt;? and nid&amp;lt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
CALL proc_sql(&lt;/span&gt;&lt;span&gt;@nid1&lt;/span&gt;,&lt;span&gt;@nid2&lt;/span&gt;,&lt;span&gt;@callsql&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 06 Jul 2019 13:50:00 +0000</pubDate>
<dc:creator>YifChan</dc:creator>
<og:description>python用于操作数据的pymysql模块，及相关的视图，触发器，函数，存储过程，事务，SQL注入等相关拓展。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yifchan/p/sql-1-4.html</dc:identifier>
</item>
<item>
<title>Salesforce Admin篇（一）Duplicate Management - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/11135540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/11135540.html</guid>
<description>&lt;p&gt;参考资料：&lt;a href=&quot;https://help.salesforce.com/articleView?id=managing_duplicates_overview.htm&quot;&gt;https://help.salesforce.com/articleView?id=managing_duplicates_overview.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Salesforce 很重要的一个平台是Sales Cloud，涉及到的流程是Lead-Cash。销售团队跟进潜在的客户，争取让他们变成自己的客户并创造机会购买他们的产品。有时，销售人员可能会电话或者其他方式联系不属于他own的Account或者Lead，由于系统中存在着重复的Account/Lead数据，导致销售人员做了很多无用功，同时被电联的客户也会被浪费时间以及认为公司团队办事混乱。所以重复的数据造成的影响特别大，针对这种重复数据的管理也特别有必要。&lt;/p&gt;
&lt;p&gt;Salesforce提供了一套针对针对Duplicate数据的管理方式，Duplicate Management可用于以下的object的数据: Account(business &amp;amp; person) / Contact / Lead / 自定义对象。Sales force针对重复数据的管理基于两个Rule： Matching Rule &amp;amp; Duplicate Rule。&lt;/p&gt;
&lt;p&gt;通过下面的截图可以看到， Matching rule是用来识别两条记录是否是重复数据的，当我们用Matching Rule确定是否重复以后，通过Duplicate Rule的配置方式来进行后续的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190704230053590-1574388859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当我们进行一条Contact插入时，Duplicate Management会进行以下的步骤：&lt;/p&gt;
&lt;p&gt;1. 一个Contact 创建；&lt;/p&gt;
&lt;p&gt;2. 通过Matching Rule规则去查看有哪些匹配到的重复的Contact数据；&lt;/p&gt;
&lt;p&gt;3. 通过不同的Duplicate Rule会有不同的操作，比如可以block住创建的操作，也可以弹出alert提示框然后允许其继续创建，针对继续创建也可以做到将潜在的重复记录生成report发送给他的经理邮件。下面分别讲一下Matching Rule以及Duplicate Rule的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190704231805486-1851135171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Mattching Rule 以及 Duplicate Rule可在Set Up中搜索Duplicate,在Duplicate Management下进行访问，下面针对这两个规则进行详细的说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190705181627388-2055915331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. Matching Rule&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Salesforce默认提供了关于Account / Contact / Lead的标准的Matching Rule，针对这三种Matching Rule的详细使用如下链接所示：&lt;/p&gt;
&lt;p&gt;Account Standard Matching Rule:&lt;a href=&quot;https://help.salesforce.com/articleView?id=matching_rules_standard_account_rule.htm&amp;amp;type=0&quot;&gt;https://help.salesforce.com/articleView?id=matching_rules_standard_account_rule.htm&amp;amp;type=0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Contact Standard Matching Rule:&lt;a href=&quot;https://help.salesforce.com/articleView?err=1&amp;amp;id=matching_rules_standard_contact_rule.htm&amp;amp;type=5&quot;&gt;https://help.salesforce.com/articleView?err=1&amp;amp;id=matching_rules_standard_contact_rule.htm&amp;amp;type=5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lead Standard Matching Rule: &lt;a href=&quot;https://help.salesforce.com/articleView?err=1&amp;amp;id=matching_rules_standard_leads_on_accounts_rule.htm&amp;amp;type=5&quot;&gt;https://help.salesforce.com/articleView?err=1&amp;amp;id=matching_rules_standard_leads_on_accounts_rule.htm&amp;amp;type=5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 我们下面的内容讲的是如何创建自定义的Matching Rule，以及创建好以后如何判断两条记录是Matching的还是不同的。&lt;/p&gt;
&lt;p&gt;1. 首先我们在系统中新建一个Matching Rule，管理员需要设置Matching Criteria。我们在demo中设置了4列，并且设置他们的逻辑为（1 OR 2） AND (3 OR 4).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190706092407975-615347357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过上图自定义Matching Rule我们可以看到Matching Criteria有三列，这三列的含义如下：&lt;/p&gt;
&lt;p&gt;Field: 用来指定哪个字段用来做比较，支持的比较类型包括email, lookup relationship, master-detail relationship, number, phone, standard picklists, custom picklists (single-select only), text, and URL。&lt;/p&gt;
&lt;p&gt;Matching Method: 定义Field如何进行比较的方法。有两种类型可供选择： Exact / Fuzzy。 Exact大部分字段都可以选择，Fuzzy针对常用的字段可以选择。针对Exact以及Fuzzy选择如何影响匹配规则会在下面说明。&lt;/p&gt;
&lt;p&gt;Match Blank Fields: 指定在字段比较时，空字符串是否被用于比较。如果没有勾选，则如果两条记录的比较的字段都是空的也会被认为是不一致的。如果勾选的情况下，如果两个记录的比较的字段均为空，则认为是一致，如果一个为空，一个不为空也不认为是一致的。&lt;/p&gt;
&lt;p&gt; 当我们选择了上面的逻辑进行操作以后，Salesforce适用了一系列的运算逻辑和运算算法来实现匹配。这里涉及到几个关键的概念。&lt;/p&gt;
&lt;p&gt;1. Matching equation：&lt;/p&gt;
&lt;p&gt;我们在Matching Criteria 选择了字段以及匹配了规则以后，我们便知道了 Matching equation。通过下图可以知道，当前的匹配规则为：&lt;br/&gt;（Field1 OR Field2） &amp;amp; (Field3 OR Field4)。Matching Equation知道以后，我们需要变形，括号内适用AND链接，括号外适用OR链接。&lt;/p&gt;
&lt;p&gt;所以 （Field1 OR Field2）AND (Field3 OR Field4) =&lt;/p&gt;
&lt;p&gt;(Field1 AND Field3) OR&lt;br/&gt;(Field1 AND Field4) OR&lt;br/&gt;(Field2 AND Field3) OR&lt;br/&gt;(Field2 AND Field4)&lt;/p&gt;
&lt;p&gt;我们通过解析成OR的形式便可以知道当前的 matching key的个数，即一个OR的group对应一个 matching key. demo中总共有4个matching key&lt;/p&gt;
&lt;p&gt;matching key 由两部分进行自动生成，一个是matching equation，一个是matching method(exact/fuzzy)。当Matching Rule运行时，实际上是根据matching key是否匹配来判断两条数据是否为重复数据，如果matching key匹配，则认为是潜在的匹配数据进行评估，如果matching key不匹配，则认为两条数据不是重复数据。&lt;/p&gt;
&lt;p&gt;上面的matching equation已经可以通过Matching Criteria确定出来，matching method可以由管理员勾选选项确定下来。matching method两种方式的详细区别以及用途如下：&lt;/p&gt;
&lt;p&gt;exact:顾名思义，精确匹配，用来匹配字符串完全一样的信息。如果你使用的是国际化的数据，建议使用exact模式，大部分字段都支持此种类型匹配，包括自定义字段；&lt;/p&gt;
&lt;p&gt;fuzzy: 模糊匹配，寻找与目标字符串近乎匹配的字符串。此种方式匹配不是所有的字段都可以使用，通常用户Account/Contact/Lead的标准字段。&lt;br/&gt;看到上面的两个声明方式，可以看到exact需要完全匹配，fuzzy可以模糊匹配，那针对匹配两个值的准确率是多少，运用什么规则匹配，我们还要针对fuzzy方式提出另外几个概念。&lt;/p&gt;
&lt;p&gt;2. Matching Algorithm&lt;/p&gt;
&lt;p&gt;定义两个字段是否匹配的逻辑的算法。针对exact模式，则自动使用精确匹配的算法。针对模糊匹配的算法，官方提供了各种模糊匹配的算法。每个字段都是根据匹配程度来评分，用来记录当前的两个字段的匹配分值。针对fuzzy方式可能会有各种评分的匹配值，针对exact只有0和100。Salesforce提供了以下的匹配算法，各个匹配算法描述如下所示。&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;1&quot;&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr&gt;&lt;td&gt;MATCHING ALGORITHM&lt;/td&gt;
&lt;td&gt;DESCRIPTION&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Acronym&lt;/td&gt;
&lt;td&gt;判断一个公司的名称是否和他的缩写名称一致。比如上面例子中的International Business Machines和IBM会被认为是一致的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;Edit Distance&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;通过两个字符串之间的删除，添加，字符的替换来决定两个字符串的相似度。比如&lt;/p&gt;
&lt;p&gt;VP Sales 和 VP Of Sales匹配分数为73%&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;Initials                                                                   &lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;比较两个名字的首字母是否相同。比如First Name: Jane 和首字母为J的匹配相似度为100.&lt;/p&gt;
&lt;p&gt;需要注意的一点是，如果我们在match rule中配置了First Name为 Fuzzy方式的匹配，设置Last Name为Exact方式的匹配，则我们的match key应该是First Name的首字母加上First Name的最后一个字母加上Last Name全部作为match key。比如Jane Smith，Jane作为First Name使用了Fuzzy方式，Smith作为Last Name使用了Exact方式。则匹配的key应该为 jesmith.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Jaro-Winkler Distance&lt;/td&gt;
&lt;td&gt;比较一个字符串转换成另外一个字符串所需要的替换的数量的相似度。通常用于短的字符串的比较。比如Johnny和Johny匹配分数为97&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Keyboard Distance&lt;/td&gt;
&lt;td&gt;比较一个字符串通过删除，添加，字符替换转换成另外一个字符串的（由键盘的键的位置加权）来确定两个字符串的相似度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Kullback Liebler Distance&lt;/td&gt;
&lt;td&gt;根据两个字段中的相同的单词所占的比例来确定相似度。比如Director of Engineering 和 Engineering Director  有2个单词匹配，匹配分数为65%&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Metaphone 3&lt;/td&gt;
&lt;td&gt;根据两个字符串发音来确定两个单词的相似度，这个针对First Name和Last Name都有效。比如Joseph和Josef两个单词发音一样，所以匹配程度为100.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Name Variant&lt;/td&gt;
&lt;td&gt;根据两个单词是否为相互之间的变形来确定两个单词的相似度，官方给的单词为Bob是Robert的变形，所以返回100， Bob不是Bill的变形，所以返回0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Syllable Alignment&lt;/td&gt;
&lt;td&gt;根据两个单词的发音来确定两个单词的相似度，首先先将单词转换成音节的字符串，然后使用Edit Distance algorithm比较相似度。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 3. Threshold&lt;/p&gt;
&lt;p&gt;当我们使用了Fuzzy的匹配方法以后，我们需要知道针对每个字段的匹配相似度最低在多少情况下，salesforce才认为是匹配的。下面的表例举了针对Fuzzy的各个标准字段适用的匹配算法以及匹配的权重的最小值。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr&gt;&lt;td&gt;Matching Method&lt;/td&gt;
&lt;td&gt;MATCHING ALGORITHMS&lt;/td&gt;
&lt;td&gt;SCORING METHOD&lt;/td&gt;
&lt;td&gt;THRESHOLD&lt;/td&gt;
&lt;td&gt;SPECIAL HANDLING&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exact&lt;/td&gt;
&lt;td&gt;Exact&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;Fuzzy: First Name&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Exact&lt;/p&gt;
&lt;p&gt;Initials&lt;/p&gt;
&lt;p&gt;Jaro-Winkler&lt;/p&gt;
&lt;p&gt;Name Variant&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;Maximum&lt;/td&gt;
&lt;td&gt;85&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;如果Middle Name字段用来作为matching rule的比较字段，则根据Fuzzy:First Name matching method比较&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Fuzzy: Last Name&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Exact&lt;/p&gt;
&lt;p&gt;Keyboard Distance&lt;/p&gt;
&lt;p&gt;Metaphone 3&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;Maximum&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; Fuzzy: Company Name&lt;/td&gt;
&lt;td&gt; 
&lt;p&gt;Acronym&lt;/p&gt;
&lt;p&gt;Exact&lt;/p&gt;
&lt;p&gt;Syllable Alignment&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; Maximum&lt;/td&gt;
&lt;td&gt; 70&lt;/td&gt;
&lt;td&gt; 在比较字段以前需要先移除inc, corp等词。除此之外，公司名称也遵循规范化的。比如IBM会先规范化成International Business Machines&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;17.5&quot;&gt;&lt;td&gt; Fuzzy: Phone&lt;/td&gt;
&lt;td&gt; Exact&lt;/td&gt;
&lt;td&gt; Weighted Average&lt;/td&gt;
&lt;td&gt; 80&lt;/td&gt;
&lt;td readability=&quot;20&quot;&gt;
&lt;p&gt; 电话号码会分成多个部分进行比较。每个部分都有自己的匹配方法和匹配分数。部分分数经过加权后得出该字段的一个分数。这个计算过程最适合北美的数据。&lt;/p&gt;
&lt;p&gt;International code (exact, 10% of field’s match score)&lt;br/&gt;Area code (exact, 50% of field’s match score)&lt;br/&gt;Next 3 digits (exact, 30% of field’s match score&lt;br/&gt;Last 4 digits (exact, 10% of field’s match score)&lt;/p&gt;
&lt;p&gt;当我们比较这两个号码：1-415-555-1234 and 1-415-555-5678.&lt;/p&gt;
&lt;p&gt;1　　　　　　1&lt;/p&gt;
&lt;p&gt;415　　　　　415&lt;/p&gt;
&lt;p&gt;555　　　　  555&lt;/p&gt;
&lt;p&gt;1234　　　　5678&lt;/p&gt;
&lt;p&gt;前三个部分都匹配，最后一个不匹配，最后一个占的权重为90%超过了80，所以我们认为这两个号码是匹配的。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; Fuzzy: City&lt;/td&gt;
&lt;td&gt; 
&lt;p&gt;Edit Distance&lt;/p&gt;
&lt;p&gt;Exact&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; Maximum&lt;/td&gt;
&lt;td&gt;85 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; Fuzzy: Street&lt;/td&gt;
&lt;td&gt;Exact &lt;/td&gt;
&lt;td&gt;Weighted Average &lt;/td&gt;
&lt;td&gt; 80&lt;/td&gt;
&lt;td&gt; 街道字段的比较方式和上面的电话号码类似，差分成多个比较，不同模块会有不同的权重。这个也是最适合北美的数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt; Fuzzy: ZIP&lt;/td&gt;
&lt;td&gt; Exact&lt;/td&gt;
&lt;td&gt;Weighted Average &lt;/td&gt;
&lt;td&gt;80 &lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt; ZIP code也拆分成多个模块比较
&lt;p&gt;First five digits (Exact, 90% of field’s match score)&lt;/p&gt;
&lt;p&gt;Next four digits (Exact, 10% of field’s match score)&lt;/p&gt;
&lt;p&gt;因为前5个匹配便已经90超过80，所以前5位匹配即认为相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; Fuzzy: Title&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt; 
&lt;p&gt;Acronym&lt;/p&gt;
&lt;p&gt;Exact&lt;/p&gt;
&lt;p&gt;Kullback-Liebler Distance&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; Maximum&lt;/td&gt;
&lt;td&gt; 50&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 4. Matching Key&lt;/p&gt;
&lt;p&gt;上文也提到了，我们在有了Matching equation 以后，需要变形成指定的格式，目的就是为了生成 Matching Key。Matching Key有助于提高匹配算法的性能。我们可以根据生成的Matching Key来比较两个字段的相似度，从而可以知道权重是否满足在salesforce规定的范围内。那Matching Key需要如何生成？有哪些要求？&lt;/p&gt;
&lt;p&gt;1. 将匹配的方程式从 OR语句格式转换成AND语句格式&lt;br/&gt;2. 匹配规则中的字段的值是规范化的&lt;br/&gt;3. 一个matching rule最多只能有10个matching key，也就是说OR语句转成AND后的数量必须在10个以内，否则会报错。&lt;br/&gt;4. match key用于针对每条记录将规范化的值组合。&lt;/p&gt;
&lt;p&gt;第一个我们在前面已经了解了，第二个规范化有什么意义？salesforce又是如何设计的？&lt;/p&gt;
&lt;p&gt;意义： 在我们比较两个字段相似度时，不同的字段类型，不同销售人员填的内容可能是不一样的。比如针对名称，可能有些人添加了称呼语(Mr./Mrs)，针对公司名称，有些人可能填写的时缩写，有些人可能在名称中添加了 and,the这种连接词等，大大的增加了匹配的难度以及准确性，所以针对部分字段，我们将其按照某种规则在比较以前进行规范化，可以大幅度的增强匹配的准确性以及匹配的效率。&lt;/p&gt;
&lt;p&gt;salesforce针对主要字段的规范化如下表所示：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;34.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;FIELD&lt;/td&gt;
&lt;td&gt;NORMALIZATION DETAILS&lt;/td&gt;
&lt;td&gt;APPLIES TO STANDARD AND CUSTOM MATCHING RULES?&lt;/td&gt;
&lt;td&gt;EXAMPLES&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;City                                                          &lt;/td&gt;
&lt;td&gt;将所有字符小写。删除非字母和非数字字符，包括空格也要删掉。最多保留6位字符&lt;/td&gt;
&lt;td&gt;如果适用自定义Match Rule，City的match method需要是fuzzy&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;San Francisco = sanfra&lt;/p&gt;
&lt;p&gt;首先先将空格去掉，然后全部小写，最后保留前6个字符串&lt;/p&gt;
&lt;p&gt;Rome = rome&lt;/p&gt;
&lt;p&gt;如果不到6位的字符串则完全保留&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt;Company&lt;/td&gt;
&lt;td&gt;针对缩写的公司名称先变成全称，将所有的字符小写，删除后缀字符串，比如Corporation, Incorporated, Inc, Limited, and Ltd等。移除and, the , of这种单词。移除特殊字符和accent.&lt;/td&gt;
&lt;td&gt;同上。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;IBM = international business machines&lt;/p&gt;
&lt;p&gt;Intel Corp. = intel&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td&gt;First Name&lt;/td&gt;
&lt;td&gt;如果适用的情况下，将名字替换成别名。移除dear,sir这种称呼语，移除特殊字符。只保留第一个单词的第一个字母并且将字母小写。&lt;/td&gt;
&lt;td&gt;同上。&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;Dr. Jane = j&lt;/p&gt;
&lt;p&gt;Dr是称呼语，所以删掉，Jane的首字母是J小写以后为j&lt;/p&gt;
&lt;p&gt;Mr. Bob= robert = r&lt;/p&gt;
&lt;p&gt;Mr是称呼语，Bob是robert的变形，可以理解成别名，所以Bot替换成Robert首字母为R小写成r&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;Last Name&lt;/td&gt;
&lt;td&gt; 删除特殊字符和后缀，将连续的相同的辅音字母替换成单个的辅音字母(b，c，d，f等)。将第一个字母小写。在上述操作标准化以后，使用双变音算法（double metaphone）用来规避拼写错误和拼写变体情况。&lt;/td&gt;
&lt;td&gt; 同上。&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt; 
&lt;p&gt;O’Reilly, Jr. = oreily (without double metaphone)&lt;/p&gt;
&lt;p&gt;O’Reilly, Jr. = oreily = arl (with double metaphone)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt; 删除部分字符串。例如下划线和点(.)，保留@字符串&lt;/td&gt;
&lt;td&gt; 只适用于标准的Match Rule&lt;/td&gt;
&lt;td&gt; john.doe@us.salesforce.com = johndoe@salesforcecom&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;Phone&lt;/td&gt;
&lt;td&gt; 删除所有的非字母和非数字字符，针对美国的电话号码，将字母字符转换成数字字符并删除国际电码。删除后4位小数。&lt;/td&gt;
&lt;td&gt; 如果适用自定义的Phone,match method需要Fuzzy&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt; 
&lt;p&gt;1-800-555-1234 = 800555&lt;/p&gt;
&lt;p&gt;44 20 0540 0202 = 44200540&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Street Address&lt;/td&gt;
&lt;td&gt; 删除所有的字符除了连接符。删除所有的禁用词，比如Avenue和Street等。取前两个单词(token)的前5个字符串&lt;/td&gt;
&lt;td&gt; 同上&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt; 
&lt;p&gt;123 Ocean View Avenue = 123ocean&lt;/p&gt;
&lt;p&gt;567 Fifty-fourth St. = 567fifty&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;Website&lt;/td&gt;
&lt;td&gt; 删除协议名称(http/https),删除子域(www),删除文件路径。取2个或者3个的单词(token)&lt;/td&gt;
&lt;td&gt; 只适用于标准的Match Rule&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt; 
&lt;p&gt;http://www.us.salesforce.com/product = salesforce.com&lt;/p&gt;
&lt;p&gt;http://www.ox.ac.uk/ = ox.ac.uk&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 当我们规范化完以后，我们将根据规则来确定哪些字段和哪些字符串用于match key里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190706165328504-1400906193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1代表在match key里面的字段。&lt;/p&gt;
&lt;p&gt;2代表在match key里面的单词或者token的数量,没有单词数量则所有单词全添加。&lt;/p&gt;
&lt;p&gt;3代表在match key里面的单词的字符数，没有单词则字符全算。&lt;/p&gt;
&lt;p&gt;4代表着在match key里面的其他的字段。&lt;/p&gt;
&lt;p&gt;下面可以通过1个例子直观的展示match key如何操作以及如何生成。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;FIELDS&lt;/td&gt;
&lt;td&gt;Matching Method&lt;/td&gt;
&lt;td&gt;Match Blank Fields&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Company&lt;/td&gt;
&lt;td&gt;Fuzzy(Company)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;Exact&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Phone&lt;/td&gt;
&lt;td&gt;Fuzzy(Phone)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Matching equation为(&lt;samp class=&quot;parmname&quot;&gt;Company&lt;/samp&gt; OR &lt;samp class=&quot;parmname&quot;&gt;Email&lt;/samp&gt;) AND&lt;samp class=&quot;parmname&quot;&gt;Phone&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;这边有两条数据：&lt;/samp&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;Company &lt;/td&gt;
&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;Phone&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; Elite Sport&lt;/td&gt;
&lt;td&gt; john.doe@elitesport.com&lt;/td&gt;
&lt;td&gt;1-415-555-1235&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; Elite Sports&lt;/td&gt;
&lt;td&gt; john.doe@elitesport.com&lt;/td&gt;
&lt;td&gt;1-415-555-1234&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第一步，转换成AND模式： (&lt;samp class=&quot;parmname&quot;&gt;Company&lt;/samp&gt; OR &lt;samp class=&quot;parmname&quot;&gt;Email&lt;/samp&gt;) AND &lt;samp class=&quot;parmname&quot;&gt;Phone = (Company AND Phone) OR (Email AND Phone)&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;第二步，规范化需要匹配的字段的值。&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;针对第一条：&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;company: Elite Sport -&amp;gt; elite sport&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;Email: johndoe@elitesport.com&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;Phone: 415555&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;针对第二条：&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;company: Elites Sports -&amp;gt; elites sport&lt;/samp&gt;&lt;samp class=&quot;parmname&quot;&gt;Email: &lt;/samp&gt;&lt;span&gt;johndoe@elitesport.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Phone: 415555&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，生成matching key.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第一条会生成两个matching key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Company(2,5) Phone = elitesport&lt;/span&gt;&lt;span&gt;415555&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Email Phone = &lt;/span&gt;&lt;span&gt;johndoe@elitesport.com&lt;/span&gt;&lt;span&gt;415555&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对第二条会生成两个matching key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Company(2,6) Phone = &lt;/span&gt;&lt;span&gt;elitessport415555&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Email Phone = &lt;/span&gt;&lt;span&gt;johndoe@elitesport.com&lt;/span&gt;&lt;span&gt;415555&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两条数据尽管第一个key不完全匹配，但是第二个匹配，salesforce会认为这两条时潜在的重复数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190706174402424-147416935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二. Duplicate Rule&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们第一步用了大量的内容去描述Matching Rule的规则，其实Matching Rule一大部分作用是为了Duplicate Rule去服务。用户更关心的是如果出现了Duplicate 数据要如何去处理。我们可以配置自定义的Duplicate Rule去配置给用户关于重复数据的后续处理方式。&lt;/p&gt;
&lt;p&gt;从下图中我们可以看到Duplicate Rule配置时可以控制的选项。&lt;/p&gt;
&lt;p&gt;1. Record Level Security: matching rule比较的范围，是比较当前用户有权限的记录还是所有的记录；&lt;/p&gt;
&lt;p&gt;2. Action区域可以选择用户基于Create / Edit操作时，针对Duplicate是要block创建还是在提出信息情况下允许创建并且允许report；&lt;/p&gt;
&lt;p&gt;3.Matching Rules选择我们如何来确定两条数据时matching的；&lt;/p&gt;
&lt;p&gt;4. Conditions可以限制某些条件下才执行当前的Duplicate Rule,比如某些profile或者某些role才需要执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190706180502251-2100106434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 效果展示：&lt;/strong&gt;当我们active 针对lead的duplicate rule以后，修改了 lead1的数据，会提示以下的内容告诉你有重复的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201907/910966-20190706180718991-198506196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;本篇浅入浅出的讲了以下salesforce中关于Duplicate的数据的管理方式。关于Matching Rule / Duplicate Rule的相关的limitation以及深层次的用法没有涉及。感兴趣的可以自行查看。篇中有错误的地方欢迎指出，有问题欢迎留言。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jul 2019 13:35:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>参考资料：https://help.salesforce.com/articleView?id=managing_duplicates_overview.htm Salesforce 很重要的一个平台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/11135540.html</dc:identifier>
</item>
<item>
<title>线性模型之对数几率回归 - 少说话多读书</title>
<link>http://www.cnblogs.com/yunp-kon/p/11144173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunp-kon/p/11144173.html</guid>
<description>&lt;p&gt;广义线性模型：&lt;span class=&quot;math inline&quot;&gt;\(y=g^{-1}(w^Tx+b)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(g^{-1}(x)\)&lt;/span&gt;，单调可微函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果用线性模型完成分类任务如何做?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据线性模型可知，找到一个单调可微函数将分类任务的真实标记&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;与线性模型的预测值联系起来即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;广义线性模型对样本要求不必要服从正态分布、只需要服从指数分布簇(二项&lt;br/&gt;分布、泊松分布、伯努利分布、指数分布等)即可；广义线性模型的自变量可&lt;br/&gt;以是连续的也可以是离散的.&lt;/p&gt;
&lt;h2 id=&quot;logistic回归&quot;&gt;logistic回归&lt;/h2&gt;
&lt;p&gt;logistic/sigmoid函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p=h_\theta(x)=g(\theta^Tx+b)=\frac{1}{1+e^{-\theta^Tx+b}}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(ln\frac{y}{1-y} = \theta^Tx+b\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(ln\frac{y}{1-y}\)&lt;/span&gt;：对数几率，将预测的结果逼近真实标记的对数几率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(g^`(z)=g(z)(1-g(z))\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将y视为类后验概率估计&lt;span class=&quot;math inline&quot;&gt;\(h_\theta(x)=P(y=1|x)\)&lt;/span&gt;，则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(y=1|x;\theta)=(h_\theta(x))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(y=0|x;\theta)=1-(h_\theta(x))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(y|x;\theta)=(h_\theta(x))^y(1-h_\theta(x))^{1-y}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一步：似然函数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(L(\theta)=\prod_{i=1}^mp(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^m(h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二步：取对数似然函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(l(\theta)=L(\theta)=\sum^m_{i=1}(y^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)})))\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Logistic损失函数：&lt;span class=&quot;math inline&quot;&gt;\(-l(\theta)=\sum^m_{i=1}(-y^{(i)}ln(h_\theta(x^{(i)}))-(1-y^{(i)})ln((1-h_\theta(x^{(i)}))))\)&lt;/span&gt;$&lt;/p&gt;
&lt;p&gt;第三步：对属于j类别&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;求导：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial l(\theta)}{\partial \theta_j} =\sum^m_{i=1}(\frac{y^{(i)}}{g(\theta^Tx^{(i)})}-\frac{1-y^{(i)}}{1-g(\theta^Tx^{(i)})})\cdot g(\theta^Tx^{(i)})(1-g(\theta^Tx^{(i)}))\cdot\frac{\partial \theta^Tx^{(i)}}{\partial \theta_j}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;=&lt;span class=&quot;math inline&quot;&gt;\(\sum^m_{i=1}(y^{(i)}(1-g(\theta^Tx^{(i)}))-(1-y^{(i)})g(\theta^Tx^{(i)})\cdot x^{(i)}_j\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;=&lt;span class=&quot;math inline&quot;&gt;\(\sum^m_{i=1}(y^{(i)}-g(\theta^Tx^{(i)})\cdot x^{(i)}_j\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第四步：梯度求解&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;批量梯度下降：
&lt;ul&gt;&lt;li&gt;for j=1 to n:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta_j=\theta_j +\alpha\sum^m_{i=1}(y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随机梯度下降法（SGD）
&lt;ul&gt;&lt;li&gt;for j=1 to n:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta_j=\theta_j +\alpha(y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;与批量梯度下降法主要体现在权重不同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import numpy as np

# 假设空间函数：h(x)
def sigmoid (xArr):
    xMat = np.mat(xArr)
    return xMat.T * xMat

# 批量梯度下降法
# alpha：学习率 maxCycle：学习的迭代次数 
def gradAscent (dataMatin,labels, alpha=0.1, maxCycle=100):
    
    dataMatrix= np.mat(dataMatin)
    labelsMatrix = np.mat(labels).T 
    m,n = np.shape(dataMatrix)
    # 初始化权重
    weights = np.ones((n,1))
    for k in maxCycle:
        # error, dataMatrix 为m*n的矩阵
        error = labelsMatrix - sigmoid(dataMatrix *weights)
        weights = weights + alpha * dataMatrix.T * error
    return weight

# 随机梯度下降法
# alpha：学习率
def gradAscent (dataMatin,labels, alpha=0.1):
    
    dataMatrix= np.mat(dataMatin)
    labelsMatrix = np.mat(labels).T 
    m,n = np.shape(dataMatrix)
    # 初始化权重
    weights = np.ones((n,1))
    # m为样本数
    for i in range(m):
        # error, dataMatrix 为m*n的矩阵
        error = labelsMatrix[i] - sigmoid(dataMatrix[i] * weights)
        weights = weights + alpha * error * dataMatrix[i]
    return weights&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;softmax回归&quot;&gt;softmax回归&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;softmax回归是logistic回归的一般化，适用于K分类的问题，第k类的参数为向量&lt;span class=&quot;math inline&quot;&gt;\(θ_k\)&lt;/span&gt;，组成的二维矩阵为&lt;span class=&quot;math inline&quot;&gt;\(θ_{k*n}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;softmax函数的本质就是将一个K维的任意实数向量压缩（映射）成另一个K维的实数向量，其中向量中的每个元素取值都介于（0，1）之间。&lt;/li&gt;
&lt;li&gt;logistics回归概率函数：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p(y=1|x;\theta)=\frac{1}{1+e^{-\theta^Tx}}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;softmax回归概率函数：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(p(y=k|x;\theta)=\frac{e^{\theta^T_kx}}{\sum_{j=1}^{k}e^{-\theta^T_jx}} \quad k=1,2.\dots,K\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;softmax假设函数：&lt;/li&gt;
&lt;li&gt;softmax损失函数：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(J(\theta)=-\frac{1}{m}\sum^m_(i=1)\sum^k_(j=1)I(y^{(i)}=j)ln(\frac{e^{\theta^T_jx^{(i)}}}{\sum_{l=1}^{k}e^{-\theta^T_lx^{(i)}}})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;解法同上：logistics回归的对数似然函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数&lt;span class=&quot;math inline&quot;&gt;\(I(y^{(i)}=j)\)&lt;/span&gt;：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(if(y^{(i)}=j): \quad I(y^{(i)}=j)=1 \quad else \quad I(y^{(i)}=j)=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;存在的意思：使不是j类别的样本损失为0，使似然函数最大化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对第i个样本的属于j类别&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;分量求导：（&lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;i&amp;lt;m\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(1&amp;lt;j&amp;lt;k\)&lt;/span&gt;）
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\nabla_{\theta_j}J(\theta)=\nabla-I(y^{(i)}=j)ln(\frac{e^{\theta_j^Tx^{(i)}}}{\sum_{l=1}^Ke^{\theta_l^Tx^{(i)}}})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(ln(\frac{e^{\theta_j^Tx^{(i)}}}{\sum_{l=1}^Ke^{\theta_l^Tx^{(i)}}}) = \theta_j^Tx^{(i)}-ln(\sum_{l=1}^Ke^{\theta_l^Tx^{(i)})}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\nabla_{\theta_j}J(\theta)=-I(y^{(i)}=j)(1-\frac{e^{\theta^T_jx^{(i)}}}{\sum_{l=1}^{k}e^{-\theta^T_lx^{(i)}}})x^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第j类别&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;更新：
&lt;ul&gt;&lt;li&gt;批量梯度下降
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta_j=\theta_j+\alpha \sum_{i=1}^{m}I(y^{(i)}=j)(1-p(y^{(i)}=j|x^{(i)};\theta))x^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;随机梯度下降
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta_j=\theta_j+\alpha I(y^{(i)}=j)(1-p(y^{(i)}=j|x^{(i)};\theta))x^{(i)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 06 Jul 2019 13:16:00 +0000</pubDate>
<dc:creator>少说话多读书</dc:creator>
<og:description>线性模型之对数几率回归 广义线性模型：$y=g^{ 1}(w^Tx+b)$ $g^{ 1}(x)$，单调可微函数 如果用线性模型完成分类任务如何做? 根据线性模型可知，找到一个单调可微函数将分类任务的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yunp-kon/p/11144173.html</dc:identifier>
</item>
</channel>
</rss>