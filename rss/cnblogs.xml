<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis分布式锁的使用与实现原理 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/14012661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/14012661.html</guid>
<description>&lt;p&gt;模拟一个电商里面下单减库存的场景。&lt;br/&gt;1.首先在redis里加入商品库存数量。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718178/202011/718178-20201120192413579-2003089469.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.新建一个Spring Boot项目，在pom里面引入相关的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.接下来，在application.yml配置redis属性和指定应用的端口号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8090

spring:
  redis:
    host: 192.168.0.60
    port: 6379
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.新建一个Controller类，扣减库存第一版代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Objects;

@RestController
public class StockController {

    private static final Logger logger = LoggerFactory.getLogger(StockController.class);

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @RequestMapping(&quot;/reduceStock&quot;)
    public String reduceStock() {
        // 从redis中获取库存数量
        int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));
        if (stock &amp;gt; 0) {
            // 减库存
            int restStock = stock - 1;
            // 剩余库存再重新设置到redis中
            stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));
            logger.info(&quot;扣减成功，剩余库存：{}&quot;, restStock);
        } else {
            logger.info(&quot;库存不足，扣减失败。&quot;);
        }

        return &quot;success&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面第一版的代码存在什么问题：超卖。假如多个线程同时调用获取库存数量的代码，那么每个线程拿到的都是100，判断库存都大于0，都可以执行减库存的操作。假如两个线程都做减库存更新缓存，那么缓存的库存变成99，但实际上，应该是减掉2个库存。&lt;br/&gt;那么很多人的第一个想法是加synchronized同步代码块，因为获取数量和减库存不是原子性操作，有多个线程来执行代码的时候，只允许一个线程执行代码块里的代码。那么改完的第二版的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @RequestMapping(&quot;/reduceStock&quot;)
    public String reduceStock() {
        synchronized (this) {
            // 从redis中获取库存数量
            int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));
            if (stock &amp;gt; 0) {
                // 减库存
                int restStock = stock - 1;
                // 剩余库存再重新设置到redis中
                stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));
                logger.info(&quot;扣减成功，剩余库存：{}&quot;, restStock);
            } else {
                logger.info(&quot;库存不足，扣减失败。&quot;);
            }
        }

        return &quot;success&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但使用synchronize存在的问题，就是只能保证单机环境运行时没有问题的。但现在的软件公司里，基本上都是集群架构，是多实例，前面使用Nginx做负载均衡，大概架构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718178/202011/718178-20201120203107979-1328710368.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nginx分发请求，把请求发送到不同的Tomcat容器，而synchronize只能保证一个应用是没有问题的。&lt;/p&gt;
&lt;p&gt;那么代码改进第三版，就是引入redis分布式锁，具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @RequestMapping(&quot;/reduceStock&quot;)
    public String reduceStock() {
        String lockKey = &quot;stockKey&quot;;
        try {
            boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;);
            if (!result) {
                return &quot;errorCode&quot;;
            }
            // 从redis中获取库存数量
            int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));
            if (stock &amp;gt; 0) {
                // 减库存
                int restStock = stock - 1;
                // 剩余库存再重新设置到redis中
                stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));
                logger.info(&quot;扣减成功，剩余库存：{}&quot;, restStock);
            } else {
                logger.info(&quot;库存不足，扣减失败。&quot;);
            }
        } finally {
            stringRedisTemplate.delete(lockKey)
        }
        return &quot;success&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有一个线程拿到锁，那么其他的线程就会等待。一定要记得在finally里面把使用完的锁要删除掉。否则一旦抛出异常，只有一个线程会一直持有锁，其他线程没有机会获取。&lt;br/&gt;但如果在执行&lt;code&gt;if (stock &amp;gt; 0) {&lt;/code&gt;代码块里的代码，因为宕机或重启没有执行完，也会一直持有锁，所以，这里需要把锁加一个超时时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;);
   stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果上面两行代码在中间执行出问题了，设置超时时间的代码还没执行，也会出现锁不能释放的问题。好在有对应的方法：就是把上面两行代码设置成一个原子操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 这里默认设置超时时间为10秒
   boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;, 10, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，如果并发量不是很大的话，基本上是没有问题的。&lt;/p&gt;
&lt;p&gt;但是，如果请求的并发量很大，就会出现新的问题：有种比较特殊的情况，第一个线程执行了15秒，但是执行到10秒钟的时候，锁已经失效释放了，那么在高并发场景下，第二个线程发现锁已经失效，那么它就可以拿到这把锁进行加锁，&lt;br/&gt;假设第二个线程执行需要8秒，它执行到5秒钟后，此时第一个线程已经执行完了，执行完那一刻，进行了删除key的操作，但是此时的锁是第二个线程加的，这样第一个线程把第二个线程加的锁删掉了。&lt;br/&gt;那意味着第三个线程又可以拿到锁，第三个线程执行了3秒钟，此时第二个线程执行完毕，那么第二个线程把第三个线程的锁又删除了。导致锁失效。&lt;br/&gt;那么解决的思路就是，我自己加的锁，不要被别人删掉。那么可以为每个进来的请求生成一个唯一的id，作为分布式锁的值，然后在释放时，判断一下当前线程的id，是不是和缓存里的id是否相等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @RequestMapping(&quot;/reduceStock&quot;)
    public String reduceStock() {
        String lockKey = &quot;stockKey&quot;;
        String id = UUID.randomUUID().toString();
        try {
            // 这里默认设置超时时间为30秒
            boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, id, 30, TimeUnit.SECONDS);
            if (!result) {
                return &quot;errorCode&quot;;
            }
            // 从redis中获取库存数量
            int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));
            if (stock &amp;gt; 0) {
                // 减库存
                int restStock = stock - 1;
                // 剩余库存再重新设置到redis中
                stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));
                logger.info(&quot;扣减成功，剩余库存：{}&quot;, restStock);
            } else {
                logger.info(&quot;库存不足，扣减失败。&quot;);
            }
        } finally {
            if (id.contentEquals(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(lockKey)))) {
                stringRedisTemplate.delete(lockKey);
            }
        }
        return &quot;success&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，一个比较完善的锁就实现了，可以应付大部分场景。&lt;br/&gt;当然，上面的代码还有一个问题，就是一个线程执行时间超过了过期时间，后面的代码还没有执行完，锁就已经删除了，还是会有些bug存在。解决的方法是给锁续命的操作。&lt;br/&gt;在当前主线程获取到锁以后，可以fork出一个线程，执行Timer定时器操作，假如默认超时时间为30秒，那么定时器每隔10秒去看下这把锁还是否存在，存在就说明这个锁里的逻辑还没有执行完，那么就可以把当前主线程的超时时间重新设置为30秒；如果不存在，就直接结束掉。&lt;/p&gt;
&lt;p&gt;但是上面的逻辑，在高并发场景下，实现比较完善还是比较困难的。好在现在已经有比较成熟的框架，那就是Redisson。官方地址https://redisson.org。&lt;br/&gt;下面用Redisson来实现分布式锁。&lt;br/&gt;首先引入依赖包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.6.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class RedissonConfig {
    @Bean
    public Redisson redisson() {
        // 单机模式
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://192.168.0.60:6379&quot;).setDatabase(0);
        return (Redisson) Redisson.create(config);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来用redisson重写上面的减库存操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @Resource
    private Redisson redisson;
    
    @RequestMapping(&quot;/reduceStock&quot;)
    public String reduceStock() {
        String lockKey = &quot;stockKey&quot;;
        RLock redissonLock = redisson.getLock(lockKey);
        try {
            // 加锁，锁续命
            redissonLock.lock();
            // 从redis中获取库存数量
            int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));
            if (stock &amp;gt; 0) {
                // 减库存
                int restStock = stock - 1;
                // 剩余库存再重新设置到redis中
                stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));
                logger.info(&quot;扣减成功，剩余库存：{}&quot;, restStock);
            } else {
                logger.info(&quot;库存不足，扣减失败。&quot;);
            }
        } finally {
           redissonLock.unlock();
        }
        return &quot;success&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实就是三个步骤：获取锁，加锁，释放锁。&lt;/p&gt;
&lt;p&gt;先简单看下Redisson的实现原理：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718178/202011/718178-20201120230819105-769274887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里先说一下Redis很多操作使用Lua脚本来实现原子性操作，关于Lua语法，可以去网上找下相关教程。&lt;br/&gt;使用Lua脚本的好处有：&lt;br/&gt;1.减少网络开销，多个命令可以使用一次请求完成；&lt;br/&gt;2.实现了原子性操作，Redis会把Lua脚本作为一个整体去执行；&lt;br/&gt;3.实现事务，Redis自带的事务功能有限，而Lua脚本实现了事务的常规操作，而且还支持回滚。&lt;/p&gt;
&lt;p&gt;但是Lua实际上不会使用很多，如果Lua脚本执行时间过长，因为Redis是单线程，因此会导致堵塞。&lt;/p&gt;
&lt;p&gt;最后，说下Redisson分布式锁的代码实现，&lt;br/&gt;找到上面的redissonLock.lock()；&lt;br/&gt;lock方法点进去，一直点到RedissonLock类里面的lockInterruptibly方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException {
        // 获取线程id
        long threadId = Thread.currentThread().getId();
        Long ttl = tryAcquire(leaseTime, unit, threadId);
        // lock acquired
        if (ttl == null) {
            return;
        }

        RFuture&amp;lt;RedissonLockEntry&amp;gt; future = subscribe(threadId);
        commandExecutor.syncSubscription(future);

        try {
            while (true) {
                ttl = tryAcquire(leaseTime, unit, threadId);
                // lock acquired
                if (ttl == null) {
                    break;
                }

                // waiting for message
                if (ttl &amp;gt;= 0) {
                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } else {
                    getEntry(threadId).getLatch().acquire();
                }
            }
        } finally {
            unsubscribe(future, threadId);
        }
//        get(lockAsync(leaseTime, unit));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点看下tryAcquire方法，把线程id作为一个参数传递进来，在这个方法里面，找到tryLockInnerAsync方法点进去，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;T&amp;gt; RFuture&amp;lt;T&amp;gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {
        internalLockLeaseTime = unit.toMillis(leaseTime);

        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                  &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; +
                      &quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; +
                      &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                      &quot;return nil; &quot; +
                  &quot;end; &quot; +
                  &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                      &quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; +
                      &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                      &quot;return nil; &quot; +
                  &quot;end; &quot; +
                  &quot;return redis.call('pttl', KEYS[1]);&quot;,
                    Collections.&amp;lt;Object&amp;gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是一堆Lua脚本，先看第一个if命令，先去判断 KEYS[1]（就是对应的锁key的名字），如果不存在，在hashmap里，设置一个属性为线程id，值为1，再把map的过期时间设置为internalLockLeaseTime，这个值默认是30秒，&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718178/202011/718178-20201121000545088-356966651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上面的操作对应的命令是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hset keyname id:thread 1
pexpire keyname 30
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后返回nil，相当于null，那程序return了。&lt;br/&gt;另外，Redisson还支持重入锁，那第二个if就是执行重入锁的操作，会判断锁是否存在，并且传入的线程id是否是当前线程的id，若果是，支持重复加锁进行自增操作；&lt;br/&gt;如果是其他线程调用lock方法，上面两个if判断不会走，会返回锁剩余过期时间。&lt;/p&gt;
&lt;p&gt;接着返回到tryAcquireAsync方法里面往下看：&lt;br/&gt;实际上是加了一个监听器，在监听器里面有个很重要的方法scheduleExpirationRenewal，一看这个名字就能大概猜出是什么功能，&lt;br/&gt;里面有个定时任务的轮询，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void scheduleExpirationRenewal(final long threadId) {
        if (expirationRenewalMap.containsKey(getEntryName())) {
            return;
        }

        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                // 判断传递进来的线程id是否是我们之前主线程设置的id，如果是，则增加续命，增加30秒。
                RFuture&amp;lt;Boolean&amp;gt; future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                        &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                            &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                            &quot;return 1; &quot; +
                        &quot;end; &quot; +
                        &quot;return 0;&quot;,
                          Collections.&amp;lt;Object&amp;gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
                
                future.addListener(new FutureListener&amp;lt;Boolean&amp;gt;() {
                    @Override
                    public void operationComplete(Future&amp;lt;Boolean&amp;gt; future) throws Exception {
                        expirationRenewalMap.remove(getEntryName());
                        if (!future.isSuccess()) {
                            log.error(&quot;Can't update lock &quot; + getName() + &quot; expiration&quot;, future.cause());
                            return;
                        }
                        
                        if (future.getNow()) {
                            // reschedule itself
                            scheduleExpirationRenewal(threadId);
                        }
                    }
                });
            }
        }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);

        if (expirationRenewalMap.putIfAbsent(getEntryName(), task) != null) {
            task.cancel();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着推迟10秒钟（internalLockLeaseTime / 3），再执行续命操作逻辑。&lt;/p&gt;
&lt;p&gt;到最后，再回到lockInterruptibly方法，&lt;br/&gt;如果ttl 为null，说明加锁成功了，就返回null，那如果其他线程的话，就会返回剩余过期时间，那么就会进入到while死循环里，一直尝试加锁，调用tryAcquire方法，在琐失效以后，再会尝试获取加锁。&lt;/p&gt;
&lt;p&gt;到此为止，分析完毕。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 16:44:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>模拟一个电商里面下单减库存的场景。 1.首先在redis里加入商品库存数量。 2.新建一个Spring Boot项目，在pom里面引入相关的依赖。 &amp;amp;lt;dependency&amp;amp;gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/IcanFixIt/p/14012661.html</dc:identifier>
</item>
<item>
<title>分布式监控系统之Zabbix宏、模板和自定义item - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14013331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14013331.html</guid>
<description>&lt;p&gt;　　前文我们聊了下zabbix的基础使用，包括主机的添加、监控项、触发器、action以及告警通知的配置，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14007342.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14007342.html&lt;/a&gt;；今天我们来了解下zabbix的宏、模板和自定义监控项的相关话题；&lt;/p&gt;
&lt;p&gt;　　1、什么是宏？&lt;/p&gt;
&lt;p&gt;　　简单讲宏就是一个字符串变量，作用和变量作用很类似；不同的是宏它是一个常量，通常是一个固定值的替代形式；宏主要作用是方便我们配置一些经常需要修改的值，用宏替换比较方便；比如我们要监控700台nginx，其中nginx的端口有时候监听在80，有时候监听在8080，如果不使用宏，那么对应端口信息就是一个数字，如果端口发生变化我们要修改700次；有了宏我们只需要修改对应宏的值即可；&lt;/p&gt;
&lt;p&gt;　　宏的分类&lt;/p&gt;
&lt;p&gt;　　在zabbix中宏分内建宏和自定义宏，所谓内建宏就是zabbix中原生就有的宏，我们可以直接调用；自定义宏就是我们自己按照需求定义的一个宏；除了按照这种方式划分宏，我们也可以按照宏的作用范围来划分；比如定义在某一个主机之上，其作用域仅对该主机生效的宏我们叫主机宏，这种宏作用范围小，但优先级很高；除了主机宏还有模板宏，全局宏；所谓模板宏就是定义在某个模板上的宏，其作用域是针对链接了该模板的所有主机，其优先级要略小主机宏；全局宏是指作用整个zabbix的宏，其优先级最小，生效范围是zabbix上的所有调用了该宏主机；在zabbix中内建宏的格式是{全大写字母}，我们在引用时，直接使用大括号+宏名就好；在上一篇博客中，我们定义脚本媒介时，就用到了三个内建的宏，{ALERT.SENDTO}，这个就是一个内建宏，它代表接收邮件的地址；内建宏在官方文档中有很详细的说明，如果用到可以去官方文档查看&lt;a href=&quot;https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location&quot; target=&quot;_blank&quot;&gt;https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location&lt;/a&gt;；自定义宏在定义和引用和内建宏稍有不同，自定义宏在定义和引用都需要用在大括号里用$符号+宏名；比如定义一个nginx端口的宏，我们可以写成{$NGINX_PORT}；&lt;/p&gt;
&lt;p&gt;　　zabbix自定义全局宏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120205851030-255978114.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在Administration---&amp;gt;General 然后选择下拉菜单找到Macros，点击进去进入全局宏的定义页面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120210120107-630939682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这样就定义了两个全局宏，我们在添加主机监控项就可以直接调用对应的宏就可以了；&lt;/p&gt;
&lt;p&gt;　　自定义主机宏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120210318982-434227666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在主机列表中找到对应主机，然后点击进入编辑主机信息的页面，找到Macros；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120210615460-1017275880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自定义模板宏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120210738033-1101843473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在configuration---&amp;gt;Templates中，找对应要定义模板宏的模板，点击进入编辑模板的界面，找到Macros，添加对应的宏即可；最后点击update即可；&lt;/p&gt;
&lt;p&gt;　　2、自定义监控项&lt;/p&gt;
&lt;p&gt;　　在上一篇博客我们就了解了什么是监控项，监控项就是定义怎么去采集数据的一个key；但是我们前边用到都是内建的监控项，在zabbix上内建的监控项都是针对很通用的指标数据；在一定程度上不是很满足自己业务的监控需求，此时我们就需要自定义监控项来采集我们需要的指标数据；我们在使用监控项时，其实就是在使用一种方法或程序通过zabbix server和agent通信，在被监控主机上执行我们选定的程序或方法，程序和方法执行后得到的数据，就是监控项采集的数据，然后通过zabbix agent将采集的数据发送或响应给zabbixserver；不难理解就是在被监控端执行一段代码，然后将代码返回的结果通过agent发送或响应给zabbix server完成一次数据采集；那么我们自定义监控项就是来自定义怎么获取对应指标数据的方法；然后给这个获取对应指标数据的方法或程序用一个key表示，在zabbix上直接调用key，zabbix就会发指令给agent执行对应key说对应的程序或方法来采集数据；在zabbix中，自定义监控项我们需要自己手动写脚本或命令去获取指定的数据；然后通过配置文件的方式告诉agent；&lt;/p&gt;
&lt;p&gt;　　自定义监控项的格式&lt;/p&gt;
&lt;p&gt;　　在zabbix agent配置文件中以UserParameter=&amp;lt;key&amp;gt;,&amp;lt;shell command&amp;gt;格式来自定义监控项；通常我们都是将自定义监控项手动的写一个以.conf结尾的文件中，然后通过zabbix agent配置文件中的Include指定将其导入agent配置生效；默认/etc/zabbix/zabbix_agentd.d/目录下的所有以.conf结尾的文件都是被导入的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120213335147-1905422954.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　示例：自定义监控项采集node04上的内存空闲空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# cat /etc/zabbix/zabbix_agentd.d/mem.conf
UserParameter=node04.os.Mem.free,free |awk '/^Mem/{print $4}' 
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置表示自定义监控项的key为node04.os.Mem.free；对应采集数据的方法是执行后面对命令；&lt;/p&gt;
&lt;p&gt;　　重启zabbix agent　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl restart zabbix-agent.service 
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:80                                       *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：重启如果对应agent监听端口正常处于监听，说明我们的配置文件没有问题；&lt;/p&gt;
&lt;p&gt;　　在zabbix server上安装zabbix-get工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# yum install -y zabbix-get
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：在zabbix server上使用zabbix_get命令看看是否能够使用对应的key获取到数据呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# zabbix_get -s 192.168.0.44 -p 10050 -k 'node04.os.Mem.free'
1594992
[root@node03 ~]# zabbix_get -s 192.168.0.44 -p 10050 -k 'node04.os.Mem.free'
1595248
[root@node03 ~]# zabbix_get -s 192.168.0.44 -p 10050 -k 'node04.os.Mem.free'
1595132
[root@node03 ~]# zabbix_get -s 192.168.0.44 -p 10050 -k 'node04.os.Mem.free'
1595008
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在zabbix sever上能够使用zabbix_get工具获取到node04上我们自定义监控项的值；&lt;/p&gt;
&lt;p&gt;　　配置zabbix 使用自定义监控项，周期性的检测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120215117738-1619852756.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：调用自定义监控项，直接写对应的key即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120215604914-674450217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应的监控项已经采集到数据了；&lt;/p&gt;
&lt;p&gt;　　自定义带参监控项&lt;/p&gt;
&lt;p&gt;　　所谓带参监控项指使用一个key，传递不同的参数，采集不同的指标；&lt;/p&gt;
&lt;p&gt;　　示例：根据传递不同参数，来采集内存总量、空闲量、buffers等值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# cat /etc/zabbix/zabbix_agentd.d/mem.conf
UserParameter=node04.os.Mem.free,free |awk '/^Mem/{print $4}' 
UserParameter=os.mem[*], awk '/^$1/ {print $$2}' /proc/meminfo 
[root@node04 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里需要说明一点，在配置文件中使用$1表示引用传递给key的第一个参数，那么对应awk中的$1就需要写成$$1来表示awk自身的参数；以上配置表示使用os.mem这个key在中括号里支持参数，传递的参数将会被后面定义的命令中的$1引用；&lt;/p&gt;
&lt;p&gt;　　重启zabbix-agent，让其配置生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl restart zabbix-agent.service 
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:80                                       *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：在zabbix server 上使用zabbix_get来获取指定key是否能够获取到数据？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# zabbix_get -s node04 -p 10050 -k 'os.mem[MemTotal]'
1867048
[root@node03 ~]# zabbix_get -s node04 -p 10050 -k 'os.mem[MemFree]' 
1595552
[root@node03 ~]# zabbix_get -s node04 -p 10050 -k 'os.mem[Buffers]'
2108
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在zabbix server上使用zabbix_get工具，给key传递不同的参数，获取到的数据也不尽相同；我们就可以基于这个key传递不同的参数来采集对应的指标数据；&lt;/p&gt;
&lt;p&gt;　　验证：在zabbix上使用我们自定义带参监控项周期性采集数据，看看是否能够采集到数据？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120221459383-1067640252.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：添加item对应key和参数即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120221727921-601115780.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在zabbix上使用指定带参监控项也能正常的采集到数据；&lt;/p&gt;
&lt;p&gt;　　3、模板&lt;/p&gt;
&lt;p&gt;　　模板是zabbix中快速添加配置监控的一种机制；它省去了我们大量重复的配置item,触发器，graph等等操作；它是一个逻辑的概念，只有当模板链接到某个主机才会生效；在zabbix也内建了很多模板，我们添加主机时，直接连接某个模板，对应主机就会继承连接的模板上定义的所有监控配置；模板可以导出和导入，也可以模板中嵌套模板；&lt;/p&gt;
&lt;p&gt;　　模板的使用&lt;/p&gt;
&lt;p&gt;　　链接某个模板到node04&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120223115062-1847240792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在主机列表中找到对应主机，点击对应主机名称进入编辑主机配置界面，找到Templates子菜单，选择要链接的模板，点击add后再点击updete即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120223226678-71173408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到链接了某个模板以后，对应主机上就多了很多item,触发器和graphs等等，同时在templates下也显示了链接的某班名称；&lt;/p&gt;
&lt;p&gt;　　创建模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120223450402-1913133856.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在configuration---&amp;gt;Templates菜单下找到create template按钮，点击进入创建模板的界面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120223901144-663116943.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：填写好对应的名称和组点击add，一个模板就创建好了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120223957578-1167903889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：创建好一个空模板就有点类似我们添加了一个主机，上面没有任何监控配置，我们可以像在某个主机上定义监控项，触发，graph一样的操作在模板上定义监控项，触发器等等；&lt;/p&gt;
&lt;p&gt;　　取消模板链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120224611388-1943001433.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：找到对应主机，进入编辑主机配置界面，进入templates子菜单，选择对应模板的操作；这里有unlink和unlink and clear两个操作，unlink表示取消链接模板，但之前收集的数据并不会删除，第二个unlink add clear表示取消链接的同时删除之前收集的数据；&lt;/p&gt;
&lt;p&gt;　　导入模板&lt;/p&gt;
&lt;p&gt;　　在zabbix share这个网站上有很多模板，我们可以选择一款模板下载下来导入到本地使用&lt;/p&gt;
&lt;p&gt;　　示例：找模板监控redis的模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120230038226-1553083045.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120230154073-692973277.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：找到对应的代码托管地址，然后点击进入对应地址下载模板和agent配置文件；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120230240679-1053707362.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：下载上面两个文件，.conf文件是agent配置文件，在对应主机上下载放在agentd.d目录下；模板文件是.xml格式的文件，下载到本地上传至zabbix上；&lt;/p&gt;
&lt;p&gt;　　在node04上安装redis,telnet&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# yum install redis telnet -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改redis配置文件，让其监听在node04的所有可用地址上&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# grep &quot;^bind&quot; /etc/redis.conf
bind 0.0.0.0
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动redis&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl start redis
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:6379                                     *:*                  
LISTEN     0      128                          *:80                                       *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将配置文件导入到zabbix agent配置目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# wget https://raw.githubusercontent.com/cuimingkun/zbx_tem_redis/master/userparameter_redis_lld_plus.conf -O /etc/zabbix/zabbix_agentd.d/userparameter_redis_lld_plus.conf
--2020-11-20 23:16:36--  https://raw.githubusercontent.com/cuimingkun/zbx_tem_redis/master/userparameter_redis_lld_plus.conf
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.76.133
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.76.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1717 (1.7K) [text/plain]
Saving to: ‘/etc/zabbix/zabbix_agentd.d/userparameter_redis_lld_plus.conf’

100%[======================================================================&amp;gt;] 1,717       --.-K/s   in 0.08s   

2020-11-20 23:17:06 (20.8 KB/s) - ‘/etc/zabbix/zabbix_agentd.d/userparameter_redis_lld_plus.conf’ saved [1717/1717]

[root@node04 ~]# ll /etc/zabbix/zabbix_agentd.d/userparameter_redis_lld_plus.conf
-rw-r--r-- 1 root root 1717 Nov 20 23:17 /etc/zabbix/zabbix_agentd.d/userparameter_redis_lld_plus.conf
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改zabbix agent配置文件和unit file，允许zabbix agent 以root身份运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# grep &quot;^AllowRoot&quot; /etc/zabbix/zabbix_agentd.conf                                               
AllowRoot=1
[root@node04 ~]# grep &quot;^[User|Group]&quot; /etc/systemd/system/multi-user.target.wants/zabbix-agent.service          
User=root
Group=root
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重启zabbix_agent&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node04 ~]# systemctl daemon-reload 
[root@node04 ~]# systemctl restart zabbix-agent.service 
[root@node04 ~]# ss -tnl
State      Recv-Q Send-Q           Local Address:Port                          Peer Address:Port              
LISTEN     0      128                          *:6379                                     *:*                  
LISTEN     0      128                          *:80                                       *:*                  
LISTEN     0      128                          *:22                                       *:*                  
LISTEN     0      100                  127.0.0.1:25                                       *:*                  
LISTEN     0      128                          *:10050                                    *:*                  
LISTEN     0      128                         :::80                                      :::*                  
LISTEN     0      128                         :::22                                      :::*                  
LISTEN     0      100                        ::1:25                                      :::*                  
[root@node04 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在zabbix web gui导入模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120232146618-1423268695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在configuration---&amp;gt;Templates菜单下找到Import，点击进入导入模板的界面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120232322907-83377377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：选择下载的模板，然后点击Import即可；&lt;/p&gt;
&lt;p&gt;　　查看导入的模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120235956759-286291931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们的模板已经导入成功；&lt;/p&gt;
&lt;p&gt;　　链接导入的模板到node04，看看是否能够采集到对应的数据呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201120232931961-1764581859.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201121000106996-455838486.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到对应主机链接模板以后，多了两个自动发现的配置；其他的监控项，触发器都没有变，这是因为它这个模板是自动发现的配置，等它扫描完配置，对应的监控配置都会自动应用上去；&lt;/p&gt;
&lt;p&gt;　　查看是否能够采集到数据呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201121000902575-1452684414.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这个扫描配置和采集数据的过程稍微有点长，要耐心多等一会；&lt;/p&gt;
&lt;p&gt;　　现在查看主机列表，看看对应监控项和其他监控配置是否有变化呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201121001205428-21550349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在就多了很多监控配置；好了从互联网下载的模板已经成功导入到zabbix并成功采集到数据；&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 16:31:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下zabbix的基础使用，包括主机的添加、监控项、触发器、action以及告警通知的配置，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/140073</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14013331.html</dc:identifier>
</item>
<item>
<title>c++11-17 模板核心知识（五）—— 理解模板参数推导规则 - 张雅宸</title>
<link>http://www.cnblogs.com/zhangyachen/p/14013605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyachen/p/14013605.html</guid>
<description>&lt;p&gt;首先我们定义一下本文通用的模板定义与调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(ParamType param);

......
f(expr); // call f with some expression
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在编译阶段使用&lt;code&gt;expr&lt;/code&gt;来推断&lt;code&gt;ParamType&lt;/code&gt;和&lt;code&gt;T&lt;/code&gt;这两个类型。这两个类型通常不同，因为&lt;code&gt;ParamType&lt;/code&gt;会有&lt;code&gt;const&lt;/code&gt;和引用等修饰。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param);      // ParamType is const T&amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int x = 0;
f(x);      // call f with an int
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，T被推断成&lt;code&gt;int&lt;/code&gt;，但是&lt;code&gt;ParamType&lt;/code&gt;的类型是&lt;code&gt;const T&amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;直觉下&lt;code&gt;T&lt;/code&gt;的类型应该和&lt;code&gt;expr&lt;/code&gt;的一样，比如上面的例子中，&lt;code&gt;expr&lt;/code&gt;和&lt;code&gt;T&lt;/code&gt;的类型都是&lt;code&gt;int&lt;/code&gt;。但是会有一些例外情况：&lt;code&gt;T&lt;/code&gt;的类型不仅依赖&lt;code&gt;expr&lt;/code&gt;，还依赖&lt;code&gt;ParamType&lt;/code&gt;。总共分为三大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ParamType&lt;/code&gt;是一个指针或者引用，但不是&lt;code&gt;universal reference&lt;/code&gt;(或者叫&lt;code&gt;forwarding references&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParamType&lt;/code&gt;是一个&lt;code&gt;universal reference&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParamType&lt;/code&gt;既不是指针也不是引用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;case-1--paramtype是一个指针或者引用，但不是universal-reference&quot;&gt;Case 1 : ParamType是一个指针或者引用，但不是universal reference&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;expr&lt;/code&gt;是一个引用，忽略其引用部分。&lt;/li&gt;
&lt;li&gt;比较&lt;code&gt;expr&lt;/code&gt;与&lt;code&gt;ParamType&lt;/code&gt;的类型来决定&lt;code&gt;T&lt;/code&gt;的类型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;t&quot;&gt;T&amp;amp;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param);       // param is a reference

......
int x = 27;                  // x is an int
const int cx = x;       // cx is a const int
const int&amp;amp; rx = x;     // rx is a reference to x as a const int

// call f
f(x);            // T is int, param's type is int&amp;amp;
f(cx);          // T is const int,  param's type is const int&amp;amp;
f(rx);         // T is const int,  param's type is const int&amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子是左值引用，但是这点对右值引用也适用。&lt;br/&gt;&lt;strong&gt;注意第三点，&lt;code&gt;const&lt;/code&gt;修饰符依旧保留。&lt;/strong&gt; 这和普通函数的类似调用有区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void f(int &amp;amp;x){

}

... 
const int x  = 10;
f(x);       // error
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;const-t&quot;&gt;const T&amp;amp;&lt;/h3&gt;
&lt;p&gt;如果给&lt;code&gt;ParamType&lt;/code&gt;加上&lt;code&gt;const&lt;/code&gt;，情况也没有太大变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param);        // param is now a ref-to-const

......
int x = 27;                // as before
const int cx = x;     // as before
const int&amp;amp; rx = x;    // as before

......
f(x);         // T is int, param's type is const int&amp;amp;
f(cx);     // T is int, param's type is const int&amp;amp;
f(rx);      // T is int, param's type is const int&amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;t-2&quot;&gt;T*&lt;/h3&gt;
&lt;p&gt;改为指针也一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T* param); // param is now a pointer

......
int x = 27;                    
const int *px = &amp;amp;x;      

f(&amp;amp;x);               // T is int, param's type is int*
f(px);              // T is const int, param's type is const int*
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;case-2--paramtype是universal-reference&quot;&gt;Case 2 : ParamType是Universal Reference&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;expr&lt;/code&gt;是左值，那么&lt;code&gt;T&lt;/code&gt;和&lt;code&gt;ParamType&lt;/code&gt;会被推断为左值引用。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;expr&lt;/code&gt;是右值，那么就是Case 1的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param);       // param is now a universal reference

......
int x = 27;                
const int cx = x;    
const int&amp;amp; rx = x;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;f(x);          // x is lvalue, so T is int&amp;amp;, param's type is also int&amp;amp;
f(cx);         // cx is lvalue, so T is const int&amp;amp;, param's type is also const int&amp;amp;
f(rx);        // rx is lvalue, so T is const int&amp;amp;, param's type is also const int&amp;amp;
f(27);        // 27 is rvalue, so T is int, param's type is therefore int&amp;amp;&amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果之前了解过完美转发和折叠引用的概念，结合Case1，这一个规则还是比较好理解的。&lt;/p&gt;
&lt;h3 id=&quot;注意区别universal-reference与右值引用&quot;&gt;注意区别Universal Reference与右值引用&lt;/h3&gt;
&lt;p&gt;这两点需要区分清楚，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param);           // universal reference


template&amp;lt;typename T&amp;gt;
void f(std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; param);       // rvalue reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个通用规则 ： &lt;code&gt;universal reference&lt;/code&gt;会有类型推断的过程。具体在后面的单独文章会讲，跟这篇文章的主题关系不大，这里稍微提一下 : )&lt;/p&gt;
&lt;h2 id=&quot;case-3--paramtype既不是指针也不是引用&quot;&gt;Case 3 : ParamType既不是指针也不是引用&lt;/h2&gt;
&lt;p&gt;这种情况就是pass-by-value的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T param); // param is now passed by value
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着，param是一个被拷贝的全新对象，也就是param决定着T的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;expr&lt;/code&gt;是引用类型，忽略。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;expr&lt;/code&gt;带有const、volatile，忽略。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int x = 27;
const int cx = x; 
const int&amp;amp; rx = x; 
f(x);         // T's and param's types are both int
f(cx);      // T's and param's types are again both int
f(rx);      // T's and param's types are still both int
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;忽略const和volatile也比较好理解：参数是值拷贝，所以形参和实参其实是互相独立的。正如下面代码可以将&lt;code&gt;const int&lt;/code&gt;传递给&lt;code&gt;int&lt;/code&gt;，但是声明为引用则不行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void f(int x){

}

int main() {
  const int x  = 10;

  f(x);       
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意忽略的const是针对参数本身的，而不针对指针指向的const对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T param);

......
const char* const ptr = &quot;Fun with pointers&quot;;       // ptr is const pointer to const object
f(ptr);             // pass arg of type const char * const
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个按照值传递的是ptr，所以ptr的const会被忽略，但是ptr指向的对象依然是const。&lt;/p&gt;
&lt;h2 id=&quot;数组作为参数&quot;&gt;数组作为参数&lt;/h2&gt;
&lt;p&gt;数组类型和指针类型是两种类型，但是有时候他们是可以互换的，比如在下面这种情况下，数组会decay成指针：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;const char name[] = &quot;J. P. Briggs&quot;;     // name's type is const char[13]
const char * ptrToName = name;       // array decays to pointer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在普通函数中，函数形参为数组类型和指针类型是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void myFunc(int param[]);
void myFunc1(int* param);         // same function as above
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是数组作为模板参数是比较特殊的一种情况。&lt;/p&gt;
&lt;h3 id=&quot;paramtype按值传递&quot;&gt;ParamType按值传递&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T param); // template with by-value parameter

......
const char name[] = &quot;J. P. Briggs&quot;;     // name's type is  const char[13]

f(name);           // name is array, but T deduced as const char*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下，&lt;code&gt;T&lt;/code&gt;被推断为指针类型&lt;code&gt;const char*&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;paramtype为引用类型&quot;&gt;ParamType为引用类型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param); 

......
const char name[] = &quot;J. P. Briggs&quot;;     // name's type is  const char[13]
f(name);             // pass array to f
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在&lt;code&gt;T&lt;/code&gt;被推断为数组类型&lt;code&gt;const char [13]&lt;/code&gt;，&lt;code&gt;ParamType&lt;/code&gt;为&lt;code&gt;const char (&amp;amp;)[13]&lt;/code&gt;，这种情况是很特殊的，要与&lt;code&gt;ParamType&lt;/code&gt;按值传递区分开。&lt;/p&gt;
&lt;p&gt;我们可以利用上面这种特性定义一个模板来推断数组的大小，这种用法还蛮常见的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T, std::size_t N&amp;gt; 
constexpr std::size_t arraySize(T (&amp;amp;)[N]) noexcept  {
    return N;
}

......
int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 };
std::array&amp;lt;int, arraySize(keyVals)&amp;gt; mappedVals;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/14103319/99179355-d559c400-2757-11eb-926b-7ebef4719d8b.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数作为参数&quot;&gt;函数作为参数&lt;/h2&gt;
&lt;p&gt;上面讨论的关于数组的情况同样适用于函数作为参数，函数类型同样也可以&lt;code&gt;decay&lt;/code&gt;成函数指针：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void someFunc(int, double);        // someFunc is a function;type is void(int, double)
template &amp;lt;typename T&amp;gt; void f1(T param);     // in f1, param passed by value
template &amp;lt;typename T&amp;gt; void f2(T &amp;amp;param);    // in f2, param passed by ref
f1(someFunc);        // param deduced as ptr-to-func; type is void (*)(int, double)
f2(someFunc);      // param deduced as ref-to-func; type is void (&amp;amp;)(int, double)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这在平时应用中也没有太大差别。&lt;/p&gt;
&lt;p&gt;(完)&lt;/p&gt;
&lt;p&gt;朋友们可以关注下我的公众号，获得最及时的更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1298604/202011/1298604-20201103132150036-885052821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 16:00:00 +0000</pubDate>
<dc:creator>张雅宸</dc:creator>
<og:description>Case 1 : ParamType是一个指针或者引用，但不是universal reference T&amp;amp;amp; const T&amp;amp;amp; T* Case 2 : ParamType</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangyachen/p/14013605.html</dc:identifier>
</item>
<item>
<title>Charles mock数据详解 - 尘世风</title>
<link>http://www.cnblogs.com/feng0815/p/14010112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feng0815/p/14010112.html</guid>
<description>&lt;p&gt;Charles是一款非常好用的代理工具，关于Charles的安装、破解、安装证书，连接手机代理等使用方法详见我之前的博客：&lt;a href=&quot;https://www.cnblogs.com/feng0815/p/8043375.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/feng0815/p/8043375.html&lt;/a&gt; ，本次只介绍Charles的几种mock方法。&lt;/p&gt;
&lt;p&gt;话不多说，直接开始&lt;/p&gt;
&lt;p&gt;一、Breakpoints  断点mock&lt;/p&gt;
&lt;p&gt;       对要打断点的接口右键，然后选择【BreakPoints】(点击一次就行了，点击多次会移除) ，如果是已经好了的，显示是一个“√”的状态。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到你想要的链接右键勾选Breakpoints功能，工具栏的断点图标就会变红；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120224853768-1473684366.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;802&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.设置断点，“Proxy”-&amp;gt;“Breakpoints”&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120225152426-1961726946.png&quot; alt=&quot;&quot; width=&quot;719&quot; height=&quot;559&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.弹出Breakpoints Settings 弹窗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120225434037-929224607.png&quot; alt=&quot;&quot; width=&quot;884&quot; height=&quot;563&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.双击Location中的想要打断点的接口，弹出Edit Breakpoints，将Query中的内容删除，输入&lt;code&gt;*&lt;/code&gt;；如果修改Request数据，就将Request勾选；如果修改Response数据，就将Response勾选；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120225348920-1548177651.png&quot; alt=&quot;&quot; width=&quot;924&quot; height=&quot;519&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.此时重新访问该接口，Charles自动跳转到Breakpoints页面，此时修改Response数据，点击Edit Response，切换底部tab至Text，修改所需要的数据；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120230032918-1163844503.png&quot; alt=&quot;&quot; width=&quot;937&quot; height=&quot;870&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120230130492-1051655295.png&quot; alt=&quot;&quot; width=&quot;938&quot; height=&quot;306&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 二、Rewrite&lt;/p&gt;
&lt;p&gt;1.添加rewrite&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120231152472-102473406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.设置要替代的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120231229381-1277842388.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.再次刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120231314765-215015119.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、MapLocal&lt;/p&gt;
&lt;p&gt;1.先抓取某个页面的接口数据，修改并保存，如下图这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120232147314-1781766732.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改接口数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120234944362-2005868526.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在要mock的接口右键选择MapLocal&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120234318008-2081076864.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 或者从Tools工具栏进入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120232920668-284302142.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.进入设置页面，现在要替换的数据文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120234539567-1265705360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5.再次刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202011/1024536-20201120234615376-1004576424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Nov 2020 15:07:00 +0000</pubDate>
<dc:creator>尘世风</dc:creator>
<og:description>Charles是一款非常好用的代理工具，关于Charles的安装、破解、安装证书，连接手机代理等使用方法详见我之前的博客：https://www.cnblogs.com/feng0815/p/8043</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feng0815/p/14010112.html</dc:identifier>
</item>
<item>
<title>Vue 组件化开发 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/14013159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/14013159.html</guid>
<description>&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;　　 在最开始的时候，已经大概的聊了聊&lt;code&gt;Vue&lt;/code&gt;是单页面开发，用户总是在一个页面上进行操作，看到的不同内容也是由不同组件构成的。&lt;/p&gt;
&lt;p&gt;　　 通过用户的操作，&lt;code&gt;Vue&lt;/code&gt;将会向用户展示某些组件，也会隐藏某些组件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 一个Vue的项目就是一个Vue的实例对象。而用户看到的页面则是Vue.component的实例对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 对于一些复用性高的内容，我们也可以将它封装成一个单独的组件，如导航栏、搜索框、版权信息等等。&lt;/p&gt;
&lt;p&gt;　　 所以说组件是&lt;code&gt;Vue&lt;/code&gt;的核心、但是本章节不会讨论&lt;code&gt;Vue&lt;/code&gt;如何实现组件的显示、隐藏，而是聊一聊如何使用组件。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115114950426.png&quot; alt=&quot;image-20201115114950426&quot; width=&quot;808&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;根组件&lt;/h2&gt;
&lt;p&gt;　　 被挂载管理的元素块就是一个根组件。在此根组件中可以嵌套多个子组件，根组件一般来说一个就够了。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        const app = new Vue({
            el:&quot;#app&quot;,
        })
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;子组件&lt;/h2&gt;
&lt;p&gt;　　 子组件即是被嵌套在根组件中的组件，子组件可复用，并且数据都是相互独立的。&lt;/p&gt;
&lt;p&gt;　　 子组件可以拥有根组件所拥有的任意的属性，如&lt;code&gt;data/methods/computed/watch/filter&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　 需要注意一点：组件名字如果有多个单词构成，应当写成驼峰形式(个人推荐)。&lt;/p&gt;
&lt;p&gt;　　 并且在模板中进行引用时，当以-进行分割。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115120054672.png&quot; alt=&quot;image-20201115120054672&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;!-- 使用全局组件 --&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 定义组件名字与模板
    Vue.component(&quot;cpnHeader&quot;, {
        template: &quot;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;这是一个头部组件&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&quot;,
    })
    const app = new Vue({
        el: &quot;#app&quot;,
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;全局子组件&lt;/h2&gt;
&lt;p&gt;　　 全局子组件会自动进行注册，任何&lt;code&gt;Vue&lt;/code&gt;的实例都能进行使用。&lt;/p&gt;
&lt;p&gt;　　 使用&lt;code&gt;Vue.component(&quot;name&quot;,{})&lt;/code&gt;对其进行声明并注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;!-- 使用全局组件 --&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 定义组件名字与模板
    Vue.component(&quot;cpnHeader&quot;, {
        template: &quot;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;这是一个头部组件&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&quot;,
    })
    const app = new Vue({
        el: &quot;#app&quot;,
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;局部子组件&lt;/h2&gt;
&lt;p&gt;　　 局部子组件在&lt;code&gt;Vue&lt;/code&gt;实例下使用&lt;code&gt;components&lt;/code&gt;进行注册。它仅供当前实例使用，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 定义组件
    const cpn = {
        template:&quot;&amp;lt;div&amp;gt;&amp;lt;mark&amp;gt;HELLO,WORLD&amp;lt;/mark&amp;gt;&amp;lt;/div&amp;gt;&quot;,
    }

    const app = new Vue({
        el:&quot;#app&quot;,
        components:{  // 进行注册
            cpn,  //es6语法
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;根标签&lt;/h2&gt;
&lt;p&gt;　　 每一个组件对象都应该具有&lt;code&gt;template&lt;/code&gt;属性，它应当是一个&lt;code&gt;HTML&lt;/code&gt;字符串。&lt;/p&gt;
&lt;p&gt;　　 并且，要拥有一个根标签在下面，否则将会抛出警告信息：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201120200646941.png&quot; alt=&quot;image-20201120200646941&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 当发生这样的警告信息，你应该检查一下你的子组件模板，并给他套上根标签，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 定义组件
    const cpn = {
        template: `
        &amp;lt;div&amp;gt;  
            &amp;lt;div&amp;gt;
                HELLO,VUE
            &amp;lt;/div&amp;gt;
            &amp;lt;div&amp;gt;
                HELLO,WORLD
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        `,
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;抽离写法&lt;/h2&gt;
&lt;p&gt;　　 如果在定义组件时在&lt;code&gt;template&lt;/code&gt;属性中写&lt;code&gt;HTML&lt;/code&gt;代码，是不太友好的，你可以将模板抽离出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用script标签，并添加type=&quot;text/x-template&quot;的属性&lt;/li&gt;
&lt;li&gt;使用template标签&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;　　 如下所示，使用&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;标签配合&lt;code&gt;id&lt;/code&gt;属性将其作为子组件模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;template id=&quot;cpn&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
            HELLO,VUE
        &amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;
            HELLO,WORLD
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    const cpn = {
        template: &quot;#cpn&quot;,
    }

    const app = new Vue({
        el: &quot;#app&quot;,
        components: { 
            cpn,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;错误示范&lt;/h2&gt;
&lt;p&gt;　　 如果你书写了一个&lt;code&gt;DOM&lt;/code&gt;可识别的标签，则是错误的操作，如下所示我使用了&lt;code&gt;main&lt;/code&gt;标签来定义组件模板，很显然&lt;code&gt;DOM&lt;/code&gt;认识它，就会自己先一步渲染它再交由&lt;code&gt;Vue&lt;/code&gt;进行处理，这会导致我们的组件模板会多一次渲染。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115122413269.png&quot; alt=&quot;image-20201115122413269&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
    &amp;lt;cpn-header&amp;gt;&amp;lt;/cpn-header&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!--子组件模板--&amp;gt;
&amp;lt;main id=&quot;cpn-header-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;这是一个头部组件&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/main&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var cpnHeader = {
        template: &quot;#cpn-header-template&quot;,
    }
    const app = new Vue({
        el: &quot;#app&quot;,
        components: {  // Vue实例内部进行注册
            cpnHeader,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 上面已经说过，子组件可以拥有&lt;code&gt;data/methods/computed/watch/filter&lt;/code&gt;等对象。&lt;/p&gt;
&lt;p&gt;　　 但是需要注意的是子组件的&lt;code&gt;data&lt;/code&gt;必须是一个函数，且必须返回一个&lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 这是因为每个子组件是相互独立的，如果&lt;code&gt;data&lt;/code&gt;是一个对象，那么获取所有的子组件数据都会引用同一个&lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 所以子组件中的&lt;code&gt;data&lt;/code&gt;必须是一个函数，因为函数调用时会重新申请内存，返回一个全新的&lt;code&gt;Object&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;template id=&quot;cpn&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;{{childrenMessage}}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    const cpn = {
        template: &quot;#cpn&quot;,
        data() {
            return {
                childrenMessage: &quot;子组件数据&quot;,
            }
        }
    }

    const app = new Vue({
        el: &quot;#app&quot;,
        components: {
            cpn,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;通信意义&lt;/h2&gt;
&lt;p&gt;　　 组件之间的通信是十分有必要的，例如当&lt;code&gt;Vue&lt;/code&gt;项目启动后，父组件获取到了一些数据，它将如何把这些数据分发到子组件上。&lt;/p&gt;
&lt;p&gt;　　 再比如，子组件上产生了一个新数据，它将如何把该数据交由父组件？&lt;/p&gt;
&lt;h2&gt;props&lt;/h2&gt;
&lt;p&gt;　　 父组件向子组件传递数据时，则通过&lt;code&gt;props&lt;/code&gt;进行传递。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　 接收值在父组件模板中采用 - 分割命名，在props中采用驼峰式，在子组件模板中进行使用时采用与props中同样的命名方式&lt;/p&gt;
&lt;p&gt;　　 这是因为 - 分割命名方式不是Js的合法变量名，如果props中采用 - 来进行命名，子组件模板在使用时将查询不到该变量名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 具体操作步骤如下所示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201120204132757.png&quot; alt=&quot;image-20201120204132757&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;!--根组件模板--&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;father&amp;gt;&amp;lt;/father&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!--子组件模板--&amp;gt;
&amp;lt;template id=&quot;son&quot;&amp;gt;
    &amp;lt;div&amp;gt;
&amp;lt;!--        ④ 子组件现在已经可以正常渲染出该值了，使用接收的变量名即可--&amp;gt;
        &amp;lt;p&amp;gt;{{childerRecv}}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;!--父组件模板--&amp;gt;
&amp;lt;template id=&quot;father&quot;&amp;gt;
    &amp;lt;div&amp;gt;
&amp;lt;!--② 子组件通过v-bind，将父组件中的值存储到props中，需要注意的是再模板中应该使用 - 进行多单词分割--&amp;gt;
        &amp;lt;son :childer-recv=&quot;fatherMessage&quot;&amp;gt;&amp;lt;/son&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    const son = {
        template: &quot;#son&quot;,
        // ③ 现在子组件中已经用childerRecv这个变量名接收到父组件中传递过来的值了，需要注意的是接收时使用驼峰式命名进行接收，否则模板中不会渲染
        props: [&quot;childerRecv&quot;,]
    }

    const father = {
        template: &quot;#father&quot;,
        components: {
            son,
        },
        data() {
            return {
                // ① 父组件的作用域内能够接收到该值了
                fatherMessage: {id: 1, name: &quot;yunya&quot;, age: 18},
            }
        }
    }


    const app = new Vue({
        el: &quot;#app&quot;,
        components: {
            father,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 上面这个是三层组件嵌套，可能看起来有点绕。我这里有个双层嵌套的，看起来比较简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;!-- 接收： - 分割命名 --&amp;gt;
    &amp;lt;cpn :recv-msg=&quot;sendMsg&quot;&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;!-- 使用： 与props同样的命名方式 --&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;接收到的信息:{{recvMsg}}&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var cpn = {
        // props：使用驼峰式命名，为了子组件模板中能够使用而不产生报错
        props: [&quot;recvMsg&quot;,],
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {}
        }
    }
    const app = new Vue({
        el: &quot;#app&quot;,
        data: {
            sendMsg: {
                id: 1,
                name: &quot;admin&quot;,
            }
        },
        components: {  // Vue实例内部进行注册
            cpn,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 画张图，让你更容易理解：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201120204754847.png&quot; alt=&quot;image-20201120204754847&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;props数据验证&lt;/h2&gt;
&lt;p&gt;　　 在上述例子中，父组件从后端获取的数据传递到子组件时没由进行任何验证就直接渲染了，这可能导致子组件渲染错误。&lt;/p&gt;
&lt;p&gt;　　 所以在子组件接收父组件数据时进行验证是十分必要的流程。&lt;/p&gt;
&lt;p&gt;　　 我们可以发现，上述例子的&lt;code&gt;props&lt;/code&gt;接收是一个&lt;code&gt;array&lt;/code&gt;，如果要使用验证，则接收要用&lt;code&gt;Object&lt;/code&gt;，如下示例：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;验证项目&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;一个Array，允许的类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;required&lt;/td&gt;
&lt;td&gt;一个Boolen，是否必须传递&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;任意类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;validator&lt;/td&gt;
&lt;td&gt;一个Function，返回需要验证的数据字段&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;cpn :recv-msg=&quot;sendMsg&quot;&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;接收到的信息:{{recvMsg}}&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var cpn = {
        props: {  // props是一个Object
            recvMsg: {  // 参数验证是一个Object
                // 允许的类型
                type: [Object, Array],
                // 是否是必须传递
                required: true,
                // 如果没有传递的默认值
                default() {
                    return &quot;默认值&quot;;
                },
                // 验证，当验证失败后，会在调试台显示错误
                validator(v) {
                    // v就是父组件传递过来的数据
                    return v.id;
                },
            },
        },
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {}
        }
    }
    const app = new Vue({
        el: &quot;#app&quot;,
        data: {
            sendMsg: {
                // id: 1,
                name: &quot;admin&quot;,
            }
        },
        components: {  // Vue实例内部进行注册
            cpn,
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 由于父组件中传递的数据不具有&lt;code&gt;id&lt;/code&gt;字段，所以控制台抛出异常，但是不会影响正常渲染：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115155932001.png&quot; alt=&quot;image-20201115155932001&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;$emit&lt;/h2&gt;
&lt;p&gt;　　 当子组件中发生某一个事件，我们可以使用父组件对其进行处理。&lt;/p&gt;
&lt;p&gt;　　 使用&lt;code&gt;$emit&lt;/code&gt;进行自定义事件，由父组件进行处理，示例如下：&lt;/p&gt;
&lt;p&gt;　　 我们使用子组件定义了一个加法的运算，但是结果却是在父组件中显示，需要子组件将计算结果发送给父组件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　 如果自定义事件的单词有多个，则在Js中采用驼峰形式，在html中采用 - 分割形式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115155119333.png&quot; alt=&quot;image-20201115155119333&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
&amp;lt;!--    父组件监听add事件，并且交由fatherAdd进行处理--&amp;gt;
    &amp;lt;cpn @add=&quot;fatherAdd&quot;&amp;gt;&amp;lt;/cpn&amp;gt;
    结果:{{showResult}}
    &amp;lt;!-- 结果显示在父组件 但是计算确是在子组件 --&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;text&quot; v-model.number=&quot;n1&quot;&amp;gt; + &amp;lt;input type=&quot;text&quot; v-model.number=&quot;n2&quot;&amp;gt;
        &amp;lt;button @click=&quot;sum&quot;&amp;gt;计算&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var cpn = {
        template: &quot;#cpn-template&quot;,
        data() {
            return {
                n1: 0,
                n2: 0,
            }
        },
        methods: {
            sum() {
                let sonResult = this.n1 + this.n2;
                // 自定义了一个add事件，由父组件进行监听。并且传递了一个值
                this.$emit(&quot;add&quot;, sonResult);
            }
        }
    }
    const app = new Vue({
        el: &quot;#app&quot;,
        components: {  // Vue实例内部进行注册
            cpn,
        },
        data: {
            showResult: 0,
        },
        methods: {
            fatherAdd(v) {
                this.showResult = v;
            }
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 还是画一张图梳理一下流程，这其实都是固定的用法：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201120205801581.png&quot; alt=&quot;image-20201120205801581&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;.sync&lt;/h2&gt;
&lt;p&gt;　　 如果子组件的数据来自于父组件，当子组件中的数据发生改变时我们也想让父组件中的数据发生同样的改变。&lt;/p&gt;
&lt;p&gt;　　 则可以使用&lt;code&gt;.sync&lt;/code&gt;修饰符（尽量少用，会破坏单一性），如下所示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.sync.gif&quot; alt=&quot;Vue的组件通信.sync&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;span&amp;gt;父组件的值:{{num}}&amp;lt;/span&amp;gt;
    &amp;lt;cpn :son-num.sync=&quot;num&quot;&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;子组件的值:{{sonNum}}&amp;lt;/span&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;input type=&quot;text&quot; @keyup=&quot;changeValue&quot; v-model=&quot;newValue&quot; placeholder=&quot;输入新的值&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    
    var cpn = {
        props: [&quot;sonNum&quot;,],
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {
                newValue: this.sonNum,
            }
        },
        methods: {
            changeValue() {
                this.$emit(&quot;update:sonNum&quot;, this.newValue)
            }
        }
    }
    
    const app = new Vue({
        el: &quot;#app&quot;,
        data: {
            num: 100,
        },
        components: {  // Vue实例内部进行注册
            cpn,
        },
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 流程图如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201115162925120.png&quot; alt=&quot;image-20201115162925120&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;$children&lt;/h2&gt;
&lt;p&gt;　　 有的时候我们想直接通过父组件拿到子组件这个对象，调用其下面的某一个方法，可以使用&lt;code&gt;$children&lt;/code&gt;属性完成操作。&lt;/p&gt;
&lt;p&gt;　　 如下所示，父组件想调用子组件中的&lt;code&gt;show()&lt;/code&gt;方法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 一个父组件可能有多个子组件，所以该属性$children是一个Array&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE$children.gif&quot; alt=&quot;Vue的组件访问$children&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;button @click=&quot;btn&quot;&amp;gt;父组件调用子组件方法&amp;lt;/button&amp;gt;
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    var cpn = {
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {
                msg: &quot;子组件show未调用&quot;,
            }
        },
        methods: {
            show() {
                this.msg = &quot;子组件show已调用&quot;;
            }
        }
    }

    const app = new Vue({
        el: &quot;#app&quot;,
        components: {  // Vue实例内部进行注册
            cpn,
        },
        methods: {
            btn() {
                // 取出第0个子组件，进行调用其下方法
                this.$children[0].show();
            }
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;$refs&lt;/h2&gt;
&lt;p&gt;　　 上述的访问方法并不常用，因为父组件非常依赖索引值来访问子组件。&lt;/p&gt;
&lt;p&gt;　　 使用&lt;code&gt;$refs&lt;/code&gt;来访问子组件就方便的多，我们需要给子组件取一个名字，再用父组件进行调用，这个是非常常用的手段。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE$children.gif&quot; alt=&quot;Vue的组件访问$children&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;button @click=&quot;btn&quot;&amp;gt;父组件调用子组件方法&amp;lt;/button&amp;gt;
    &amp;lt;!-- 取名字 --&amp;gt;
    &amp;lt;cpn ref=&quot;nbcpn&quot;&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    
    var cpn = {
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {
                msg: &quot;子组件show未调用&quot;,
            }
        },
        methods: {
            show() {
                this.msg = &quot;子组件show已调用&quot;;
            }
        }
    }
    
    const app = new Vue({
        el: &quot;#app&quot;,
        components: {  // Vue实例内部进行注册
            cpn,
        },
        methods: {
            btn() {
                // 根据取的名字进行调用
                this.$refs.nbcpn.show();
            }
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;$parent&lt;/h2&gt;
&lt;p&gt;　　 如果在子组件中想拿到父组件的对象，使用&lt;code&gt;$parent&lt;/code&gt;即可，如果存在多层嵌套，它只会拿自己上一层。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　 一个子组件，在一块被挂载区域中只有一个父组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE$parent.gif&quot; alt=&quot;Vue的组件访问$parent&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    {{msg}}
    &amp;lt;cpn&amp;gt;&amp;lt;/cpn&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- 子组件模板 --&amp;gt;
&amp;lt;template id=&quot;cpn-template&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;button @click=&quot;btn&quot;&amp;gt;子组件调用父组件方法&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    
    var cpn = {
        template: &quot;#cpn-template&quot;,
        data: function () {
            return {}
        },
        methods: {
            btn() {
                this.$parent.show();
            }
        }
    }
    
    const app = new Vue({
        el: &quot;#app&quot;,
        data: {
            msg: &quot;父组件show未调用&quot;,
        },
        components: {  // Vue实例内部进行注册
            cpn,
        },
        methods: {
            show() {
                // 取出自己的父组件，进行调用其下方法
                this.msg = &quot;父组件show已调用&quot;;
            }
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;$root&lt;/h2&gt;
&lt;p&gt;　　 如果存在三级或以上嵌套，可以直接使用&lt;code&gt;$root&lt;/code&gt;来访问根组件。与&lt;code&gt;$parent&lt;/code&gt;使用相同，但是它是具体的一个对象，而并非&lt;code&gt;Array&lt;/code&gt;，所以这里不再做演示。&lt;/p&gt;

&lt;p&gt;　　 使用&lt;code&gt;:is&lt;/code&gt;属性，可以让我们动态使用不同的组件。&lt;/p&gt;
&lt;p&gt;　　 如下，定义了一个&lt;code&gt;input&lt;/code&gt;框和文本域两个组件，当我们点击不同按钮，它就会选择不同的组件。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E7%BB%84%E4%BB%B6.gif&quot; alt=&quot;Vue的动态改变组件&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;div :is=&quot;choice&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;input type=&quot;radio&quot; v-model=&quot;choice&quot; value=&quot;inputCPN&quot;&amp;gt;文本框
    &amp;lt;input type=&quot;radio&quot; v-model=&quot;choice&quot; value=&quot;textareaCPN&quot;&amp;gt;文本域
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    const inputCPN = {
        template: &quot;&amp;lt;div&amp;gt;&amp;lt;input type='text'/&amp;gt;&amp;lt;/div&amp;gt;&quot;,
    }

    const textareaCPN = {
        template: &quot;&amp;lt;div&amp;gt;&amp;lt;textarea&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;/div&amp;gt;&quot;,
    }

    const app = new Vue({
        el: &quot;#app&quot;,
        data: {
            choice: &quot;inputCPN&quot;,
        },
        components: {
            inputCPN, textareaCPN,
        },
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 一个&lt;code&gt;Vue&lt;/code&gt;的项目就是由不同的组件构成，不管是局部注册也好，全局注册也罢，&lt;code&gt;Vue&lt;/code&gt;官方都给你提供了一些钩子函数供你调用，如下图所示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTMwNzY0LzE1ODIxMTM2NzcxNTctMThmZjMzM2QtODdlNC00NjQ3LWI0ZWEtNzdjZGZkOTEwMWYwLnBuZw?x-oss-process=image/format,png#align=left&amp;amp;display=inline&amp;amp;height=745&amp;amp;name=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png&amp;amp;originHeight=3039&amp;amp;originWidth=1200&amp;amp;size=77677&amp;amp;status=done&amp;amp;style=none&amp;amp;width=294&quot; alt=&quot;生命周期图.png&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;钩子函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;beforeCreate&lt;/td&gt;
&lt;td&gt;创建Vue实例之前调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;created&lt;/td&gt;
&lt;td&gt;创建Vue实例成功后调用（可以在此处发送异步请求后端数据）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;beforeMount&lt;/td&gt;
&lt;td&gt;渲染DOM之前调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mounted&lt;/td&gt;
&lt;td&gt;渲染DOM之后调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;beforeUpdate&lt;/td&gt;
&lt;td&gt;重新渲染之前调用（数据更新等操作时，控制DOM重新渲染）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;updated&lt;/td&gt;
&lt;td&gt;重新渲染完成之后调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;beforeDestroy&lt;/td&gt;
&lt;td&gt;销毁之前调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;destroyed&lt;/td&gt;
&lt;td&gt;销毁之后调用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 如下所示，定义这几个钩子函数：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vue%E7%BB%84%E4%BB%B6%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0.gif&quot; alt=&quot;vue组件钩子函数&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{msg}}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    let app = new Vue({
        el: &quot;#app&quot;,
        data:{
            msg:&quot;HELLO,VUE&quot;,
        },
        beforeCreate() {
            console.log(&quot;创建Vue实例之前...&quot;);
        },
        created() {
            console.log(&quot;创建Vue实例成功...&quot;);
        },
        beforeMount() {
            console.log(&quot;准备渲染DOM...&quot;);
        },
        mounted() {
            console.log(&quot;渲染DOM完成...&quot;);
        },
        beforeUpdate() {
            console.log(&quot;准备重新渲染DOM...&quot;);
        },
        updated() {
            console.log(&quot;重新渲染DOM完成&quot;);
        },
        // 后两个暂时体会不到
        beforeDestroy() {
            console.log(&quot;准备销毁当前实例&quot;);
        },
        destroyed() {
            console.log(&quot;当前实例销毁完成...&quot;);
        }
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Nov 2020 14:55:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>组件化开发 基本概念 在最开始的时候，已经大概的聊了聊Vue是单页面开发，用户总是在一个页面上进行操作，看到的不同内容也是由不同组件构成的。 通过用户的操作，Vue将会向用户展示某些组件，也会隐藏某些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/14013159.html</dc:identifier>
</item>
<item>
<title>程序员是青春饭吗？30岁后的发展方向和突破 - 程序之心</title>
<link>http://www.cnblogs.com/chengxuzhixin/p/14009189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxuzhixin/p/14009189.html</guid>
<description>&lt;blockquote readability=&quot;1.1682242990654&quot;&gt;
&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;作者：丁仪&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;来源：&lt;a href=&quot;https://chengxuzhixin.com/blog/post/30_sui_hou_de_fa_zhan_fang_xiang_he_tu_po.html&quot; target=&quot;_blank&quot;&gt;https://chengxuzhixin.com/blog/post/30_sui_hou_de_fa_zhan_fang_xiang_he_tu_po.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot; data-wording=&quot;true&quot;&gt; &lt;/p&gt;
&lt;p data-lake-id=&quot;a20d224c568e48b9d67847a2c66a8c01_p_0&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;前些年，有人说程序员只能干到 30，后来大家把年龄提到 35，最近好像又有提到 40 的迹象。最近 Python 创始人 Guido 入职微软了。&lt;span class=&quot;lake-fontsize-12&quot;&gt;Guido 在 1989 年创造了 Python，无论从哪个角度看，都是绝对的高龄程序员了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;0b795578c05771b8c8eabc91d6c7ce4d&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;uhdcA&quot; data-lake-id=&quot;ca6067dfed97e3064f618d563fc5846d&quot; data-wording=&quot;true&quot;&gt;程序员是青春饭吗&lt;/h2&gt;
&lt;p data-lake-id=&quot;2d503d3c68022eec01676ee099d2a72c&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;很多人都说写代码最多到 35 岁，妥妥的青春饭，然而科学分析不这么认为。《Is Programming Knowledge Related to Age?》论文对 1694981 名 StackOverflow 用户的研究发现，程序员的平均年龄是 30.3 岁，其中数据清洗后参与分析的用户是 84248 名程序员，平均年龄 29.02 岁。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;1c2a51f3b71f4531f3c7bf9c516c7dca&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;在年龄分布中，人数最多的是 25 岁，中位数是 29 岁。然而分析发现，程序员的能力从 25 岁左右开始上升，一直到 50 岁后才会开始下降。论文还研究了程序员对新技术的跟进，发现不同年龄的程序员对新技术的学习并没有差太多。大龄程序员对某些新技术的学习甚至超过年轻程序员。所以论文得出的结论是，程序员的技术能力上升可以到 50 - 60 岁，并且大龄程序员跟进新技术的能力和年轻程序员相差不多。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;1d273e584436996c0e46fdfd4dce1c3e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;从身边的观察发现，30 岁的程序员积累了大量经验，可能才刚刚成为优秀的人才，架构设计能力、领导力需要大量的实践积累，不是能够轻松掌握的。互联网是&lt;span class=&quot;lake-fontsize-12&quot;&gt;一个新兴行业，大部分从业者都是后期加入的，平均年龄要低于其他行业。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;5a1f714581c6a9d649e432a494717fbb&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;OkgpR&quot; data-lake-id=&quot;99ecfbb165d8a057ee67ad06717b5a2a&quot; data-wording=&quot;true&quot;&gt;30 岁后的职业规划&lt;/h2&gt;
&lt;p data-lake-id=&quot;1864378ec104ae4153310b2b427d4d5f&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;一个程序员在 30 岁后，可能面临技术专家、技术 Leader&lt;span class=&quot;lake-fontsize-12&quot;&gt;、架构师&lt;span class=&quot;lake-fontsize-12&quot;&gt;三个发展方向的选择。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;4d988d9a46496a423c6e3517bce54aab&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术专家很好理解，在一个领域深耕，对业务和代码都有很好深刻的理解，经验丰富，能够用技术解决公司遇到的实际问题。成为技术专家需要大量的实践积累，正常发展情况下差不多都要到 30 岁左右。正常来说，技术专家是人才梯队中非常重要的角色，对技术方案设计有很大影响。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;05963a35f8e2a05c4bea0235be789cc0&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;前几天看到有个公众号转载一篇高并发的文章，一个看起来一年内工作经验的作者展示了漏洞百出的技术方案，还能发上线，可见技术专家对团队的重要作用。没有技术专家的团队，人才梯队很难建立起来，团队内成员的成长可能也会受影响。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;f38d420ee4dca6007af2dadcb13e9596&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术 &lt;span class=&quot;lake-fontsize-12&quot;&gt;Leader &lt;span class=&quot;lake-fontsize-12&quot;&gt;会开始涉及技术管理方面的事务。注意这里是 Leader，不是 Manager。Manager 是管理者，而 Leader 更多是领导者。作为技术 Leader，需要重点保障核心业务、做技术建设、提升业务效果。为团队&lt;span class=&quot;lake-fontsize-12&quot;&gt;设定合理的目标，做好排兵布阵，协调各个团队和资源。所以业内往往称为“技术管理”而不是“管理”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;7f61f4045e1fbc262300c9b5ae1da82e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术 Leader 比团队其他同学视野更开阔，对长远的发展趋势看的更准，有技术前瞻性。虽然已经成为团队中最牛逼的程序员之一，但是也要逐渐学会借他人之手写代码，专注于写代码的时间比&lt;span class=&quot;lake-fontsize-12&quot;&gt;以前减少很多，而这一点正是优秀程序员转变为技术 &lt;span class=&quot;lake-fontsize-12&quot;&gt;Leader &lt;span class=&quot;lake-fontsize-12&quot;&gt;所面临的最大挑战之一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;17025399ca6163ad74046369a4f9ecd6&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;架构师是一个非常出名的称谓了，然而却很少有专门的架构师岗位。阿里前几年有架构师岗位，不过现在也回归“技术专家”这样的纯技术岗位了。架构师必须是最出色的程序员，拥有技术深度和广度，&lt;span class=&quot;lake-fontsize-12&quot;&gt;有系统性的认知和技术前瞻性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;709ea791248af4dc9d0c5b103b252452&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;架构师通常和&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术 &lt;span class=&quot;lake-fontsize-12&quot;&gt;Leader 有部分重叠，尤其是在团队规模比较小的时候，两者往往是同一个人。随着软件规模的增大，架构师开始在比&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术 &lt;span class=&quot;lake-fontsize-12&quot;&gt;Leader 更高的高度上看待问题，这时候架构师和&lt;span class=&quot;lake-fontsize-12&quot;&gt;技术 Leader 开始分化为不同的人。架构师也不一定是公司任命的权威领导者，但是在团队内部通常有非权威领导力，是团队内部非常信任的技术领导者。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;852acfdff8ae9f8e7f854a54f88395d5&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;这三个发展方向可能会有重叠，对个人来说，还是最好想清楚侧重点是什么。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;f43dc6460ddfced1adac596421f0b6ae&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;NpRsZ&quot; data-lake-id=&quot;971a2f538b6f1453ac380c92cad5e301&quot; data-wording=&quot;true&quot;&gt;掌握软件系统方法论&lt;/h2&gt;
&lt;p data-lake-id=&quot;9c90e6da1c0f2429e789077b5476ebf5&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;越是到职业发展的后期，越不能依靠代码本身。所有人都使用着同样的开发语言，掌握着同样的语法和脚本。作为执行者很难体现出优势，总不能说掌握的语法和二方包比别人多吧。优秀的程序员能比别人写出更好的代码，主要还是在如何写代码，以及代码背后的思考，也就是程序员的方法论。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;bc65d274a8b5d6d2229a5809a1d31c98&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;方法论英文单词是 methodology，也就是说它是关于方法(method)的学问&lt;span class=&quot;lake-fontsize-12&quot;&gt;，是关于人们认识世界、改造世界的方法的理&lt;span class=&quot;lake-fontsize-12&quot;&gt;论，&lt;span class=&quot;lake-fontsize-12&quot;&gt;是人们用什么样的方式、方法来观察事物和处理问题。简单地说，方法论是成熟的思维方式&lt;span class=&quot;lake-fontsize-12&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;38a7c10736f9caf734fcf34dce3b93ad&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;成熟的方法论有很多。前面文章提到的黄金圈法则，是思考问题、分析问题的方法论。领域驱动设计是架构设计方面的方法论，能够帮助解决复杂问题。金字塔原理，是思考问题、解决问题、写作、PPT 演示方面的方法论&lt;span class=&quot;lake-fontsize-12&quot;&gt;。系统化思维，是对复杂系统如何观察和分析的理论，也能指导设计复杂系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;156beef5a2624aab9f086b4cf8a8e660&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;我们常说的“抓手”、“赋能”、“共建”、“打法”、“对焦”等看起来比较虚的东西，其实就出自于方法论，是方法论中对具体事物和行为背后的客观规律的总结。脉脉上很多人对此嗤之以鼻，成为了大家吐槽的对象，但是这都是很成熟的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d08182322e0e93447c28d64d3a365b92&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;如果长期停留在使用框架的层面，容易陷入工具误区，把使用框架当做技术，思维方式也被局限在框架里。会有一种技术很牛逼的错觉，但是和其他人相比，却没有多少优势，容易被更年轻更有活力的后辈取代。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;c690208595d287cd8978c5fadb12a9b6&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;HB3PS&quot; data-lake-id=&quot;6e10d2e7f3bff6f553a3c93b31a78840&quot; data-wording=&quot;true&quot;&gt;形成自己的方法论&lt;/h2&gt;
&lt;p data-lake-id=&quot;24d99bcfa4f7e982db66d06ff7e58987&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;方法论的形成需要长期的积累，可以借鉴学习圈理论。学习过程由具体经验、反思观察、抽象概括、主动实验四个阶段，并形成一个闭环。首先学习一个具体的东西，然后停下来对自己的经历进行复盘和思考，再对学习的内容进行抽象，概括成为真正能理解、能吸收的知识，最后再把学习的概念和理论应用于实践并解决现实的问题，如此往复循环。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e6f7f112fb8171a62fd5ac3d8d5a4478&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;4be11d36c3b970477a0897fa5153fd48&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F261496%2F1605763530833-1d5a70aa-945b-4d26-96af-f0a517a711cb.png%22%2C%22originWidth%22%3A400%2C%22originHeight%22%3A240%2C%22name%22%3A%22image.png%22%2C%22size%22%3A22616%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A169.5161%2C%22y%22%3A11.3966675%2C%22width%22%3A63.402950000000004%2C%22height%22%3A16.3871225%2C%22text%22%3A%22%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%22%7D%2C%7B%22x%22%3A132.87766%2C%22y%22%3A94.92685%2C%22width%22%3A45.85647%2C%22height%22%3A17.044150000000002%2C%22text%22%3A%22%E8%A1%8C%E5%8A%A8%E8%80%85%22%7D%2C%7B%22x%22%3A222.66109%2C%22y%22%3A95.54752%2C%22width%22%3A44.87738999999999%2C%22height%22%3A15.203419999999994%2C%22text%22%3A%22%E7%90%86%E8%AE%BA%E8%80%85%22%7D%2C%7B%22x%22%3A25.310425%2C%22y%22%3A109.09499%2C%22width%22%3A63.533855%2C%22height%22%3A17.79834000000001%2C%22text%22%3A%22%E4%B8%BB%E5%8A%A8%E9%AA%8C%E8%AF%81%22%7D%2C%7B%22x%22%3A313.43204%2C%22y%22%3A109.38337%2C%22width%22%3A65.32690000000002%2C%22height%22%3A19.29074999999999%2C%22text%22%3A%22%E5%8F%8D%E6%80%9D%E8%A7%82%E5%AF%9F%22%7D%2C%7B%22x%22%3A132.8296%2C%22y%22%3A127.956085%2C%22width%22%3A45.414860000000004%2C%22height%22%3A16.690474999999992%2C%22text%22%3A%22%E5%86%B3%E7%AD%96%E8%80%85%22%7D%2C%7B%22x%22%3A223.3697%2C%22y%22%3A130.14539%2C%22width%22%3A43.21428%2C%22height%22%3A14.941210000000012%2C%22text%22%3A%22%E6%80%9D%E8%80%83%E8%80%85%22%7D%2C%7B%22x%22%3A167.50938%2C%22y%22%3A212.48047%2C%22width%22%3A66.41286%2C%22height%22%3A18.05095%2C%22text%22%3A%22%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E5%85%B7%E4%BD%93%E7%BB%8F%E9%AA%8C%20%E8%A1%8C%E5%8A%A8%E8%80%85%20%E7%90%86%E8%AE%BA%E8%80%85%20%E4%B8%BB%E5%8A%A8%E9%AA%8C%E8%AF%81%20%E5%8F%8D%E6%80%9D%E8%A7%82%E5%AF%9F%20%E5%86%B3%E7%AD%96%E8%80%85%20%E6%80%9D%E8%80%83%E8%80%85%20%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A400%2C%22height%22%3A240%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/261496/1605763530833-1d5a70aa-945b-4d26-96af-f0a517a711cb.png&quot; alt=&quot;image.png&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;240px&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;61c67fc791802f140e18f9667b8234e2&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;定向钻研一个技术方向，可以加深技术深度，有助于形成方法论。比如，可以定一个目标，让需求上线的时间缩减一半或者同样成本支撑的需求数量翻倍。接下来就需要思考什么样的架构设计能够支撑翻倍的效能，很多情况下都会走向配置化、提升复用、热部署等，接下来你就可以总结出你的方法论了。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;b937460d01c743e98cad1012e830a51a&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;亲自设计一个框架，也是一个不错的选择。既能在纵向深挖，又会有横向拓展的机会。不过这样的尝试一定要以足够的经验积累为前提，否则可能走入误区。跳出日常的习惯，拔高视野，很快就会有领悟，甚至推翻低层次的认知。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;2cbb132f40327de4a45300c56f1d7647&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;复盘和反思有助于改造认知，实现认知升级。推荐使用黑匣子思维，记录下过程中的思考和问题，能够帮助更好地复盘。关于复盘的方法，推荐阅读《复盘:对过去的事情做思维演练》，书中讲了很多复盘的方法和技巧，是关于复盘的方法论。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;b4e22ae00a3e84b6a336a8a77ec4495d&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;经过思考和训练，你会得到很多经验和认知，会形成自己的思维方式，能够对一类问题形成体系化的深度思考，然后再总结出一些概念进行抽象，使经验适用于更广阔的共性问题，就实现了经验到理论的升华。把自己的理论应用于实践，观察实际效果，对比之前的预期，再领悟新的经验和思考，循环往复，就形成了方法论。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;b4e22ae00a3e84b6a336a8a77ec4495d&quot; data-wording=&quot;true&quot;&gt; &lt;/p&gt;
&lt;p data-lake-id=&quot;b6e14023d404b1b8d1e370b3dbe7e175&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;以上就是本文的全部内容了，与君共勉。&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;dbbae49786a950f808b65f91713a7deb&quot;&gt;微.信.搜.一.搜.程序之心，每周一三五原创更新。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 14:52:00 +0000</pubDate>
<dc:creator>程序之心</dc:creator>
<og:description>作者：丁仪 来源：https://chengxuzhixin.com/blog/post/30_sui_hou_de_fa_zhan_fang_xiang_he_tu_po.html 前些年，有人说程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengxuzhixin/p/14009189.html</dc:identifier>
</item>
<item>
<title>无所不能的Embedding4 - Doc2vec第二弹[skip-thought &amp; tf-Seq2Seq源码解析] - 风雨中的小七</title>
<link>http://www.cnblogs.com/gogoSandy/p/14009265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoSandy/p/14009265.html</guid>
<description>&lt;p&gt;前一章Doc2Vec里提到，其实Doc2Vec只是通过加入Doc_id捕捉了文本的主题信息，并没有真正考虑语序以及上下文语义，n-gram只能在局部解决这一问题，那么还有别的解决方案么？依旧是通用文本向量，skip-thought尝试应用encoder-decoder来学习包含上下文信息和语序的句子向量。魔改后的实现可以看这里( ´▽｀) &lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/skip_thought&quot;&gt;&lt;strong&gt;github-DSXiangLi-Embedding-skip_thought&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;skip-thought模型分析&quot;&gt;Skip-Thought模型分析&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326688/202011/1326688-20201120093133998-2123908266.png&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Skip-Thought顾名思义是沿用了skip-gram的路子,不熟悉的童鞋看这里 &lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/13418257.html&quot;&gt;无所不能的Embedding1 - Word2vec模型详解&amp;amp;代码实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;skip-gram是用中间词来预测周围单词，skip-Thought是用中间句子来预测前一个句子和后一个句子，模型思路就是这么简单粗暴，具体实现就涉及到句子的信息要如何提取，以及loss function的选择。作者选择了encoder-decoder来提取句子信息，用翻译模型常用的log-perplrexity作为loss。&lt;/p&gt;
&lt;p&gt;这里想提一句不同模型，在不同的样本上，训练出的文本向量所包含的信息是不同的。例如word2vec的假设就是context（windo_size内周围词）相似的单词更相似（向量空间距离更近）。skip-thought作者对于文本向量的假设是：能更好reconstruct前后句子的信息，就是当前句子的所含信息，换言之前后句子相似的句子，文本向量的空间距离更近。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第一次读到这里感觉哇make perfect sense！可越琢磨越觉着这个task有些迷幻，word2vec skip-gram可以这么搞，是因为给定中间词window_size内的单词选择是相对有限的。你给我个句子就让我精准预测前后句子的每一个词，这能收敛？you what?! 不着急后面似乎有反转~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Encoder部分负责提取中间句子的信息生成定长向量output_state，Decoder则基于ouput_state进行迭代生成前（后）句子。Encoder-Decoder支持任意记忆单元，这里作者选择了GRU-GRU。&lt;/p&gt;
&lt;p&gt;简单回顾下GRU Cell，GRU有两个Gate，从两个角度衡量历史sequence信息和当前token的相关程度，&lt;span class=&quot;math inline&quot;&gt;\(\Gamma_r\)&lt;/span&gt;控制多少历史信息参与state的重新计算是reset gate，&lt;span class=&quot;math inline&quot;&gt;\(\Gamma_u\)&lt;/span&gt;控制多少历史信息直接进入当前state是update gate，这里安利一篇博客 &lt;a href=&quot;https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21&quot;&gt;Illustrated Guide to LSTM’s and GRU’s: A step by step explanation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\[\begin{align} \Gamma_u &amp;amp; =\sigma(w_{u}[h^{&amp;lt;t-1&amp;gt;},x^{&amp;lt;t&amp;gt;}]+ b_{u})\\ \Gamma_r &amp;amp; =\sigma(w_{r}[h^{&amp;lt;t-1&amp;gt;},x^{&amp;lt;t&amp;gt;}]+ b_{r})\\ h^{&amp;lt;t&amp;gt;} &amp;amp;= tanh( w_{a}[ \Gamma_r \odot h^{&amp;lt;t-1&amp;gt;},x^{&amp;lt;t&amp;gt;}]+ b_{a} )\\ h^{&amp;lt;t&amp;gt;} &amp;amp;= \Gamma_u \odot h^{&amp;lt;t&amp;gt;} + (1-\Gamma_u) \odot h^{&amp;lt;t-1&amp;gt;} \end{align} \]&lt;/p&gt;
&lt;p&gt;Encoder部分经过GRU把长度为T的sequence信息压缩到hidden_size的&lt;span class=&quot;math inline&quot;&gt;\(h^{&amp;lt;T&amp;gt;}\)&lt;/span&gt;，这里&lt;span class=&quot;math inline&quot;&gt;\(h^{&amp;lt;T&amp;gt;}\)&lt;/span&gt;也是最终skip-thought为每一个句子生成的通用向量表达。&lt;/p&gt;
&lt;p&gt;Decoder部分基于&lt;span class=&quot;math inline&quot;&gt;\(h^{&amp;lt;T&amp;gt;}\)&lt;/span&gt;向前预测下一个/上一个句子中的每一个单词。Decoder比Encoder略复杂，在于训练阶段和预测阶段对于input的处理存在差异。&lt;/p&gt;
&lt;p&gt;训练阶段使用了100%的Teacher Forcing，每个cell的输入除了上一个cell的hidden state，还有预测句子中前一个真实token对应的embedding，如图&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326688/202011/1326688-20201120093154049-2137847807.png&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而在预测阶段真实序列未知，因此会转而使用前一个cell的output来预测前一个token，再用预测token的embedding作为输入，如图&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1326688/202011/1326688-20201120093251787-510193623.png&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于翻译模型来说，在训练阶段使用TeacherForcing的好处是可以加速模型收敛，避免向前迭代预测的误差进一步放大。坏处自然是训练和预测时decoder的表现存在差异（Exposure Bias)，以及预测时decode的output会受到训练样本的约束。这里最常用的解决方案是Scheduled Sampling, 简单来说就是在训练阶段有P的概率输入用teacher forcing，1-P的概率用预测output。但是！skip-thought并没有使用这个解决方案，为啥嘞？反转来了V(^_^)V&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;看到无采样的teacherforcing这里，前面的迷惑已然解答。其实skip-thought并不只是使用中间句子来预测前后句子，而是基于中间句子的ouput_state，用前后句子中T-1前的单词来预测第T个单词（感觉和missing imputation只有一步之遥)。encoder部分只需要在output_state中最大程度的提取句子信息，保证在不同的前后句子上output state都可以generalize。至于decoder的预测部分效果如何模型并不关心，因为skip-thought的预测输出就是encoder部分的output state，所以自然是不需要使用Scheduled Sampling&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;skip-thought的Decoder还有两点特殊：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前/后句子用两个decoder来训练，两个decoder除了word embedding共享之外，参数独立&lt;/li&gt;
&lt;li&gt;encoder state不只作为decoder的initial_state，而是直接传入decoder的每一个cell，起到类似residual/connditional的作用，避免encoder的信息传着传着给传没了。这里感觉不用attention而是直接传入outpu_state也是为了保证这个output_state能最大程度的学到用来reconstruct前后句子的信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;loss部分作者用了语言模型的log-perplexity把前后句子的loss加总得到loss function&lt;/p&gt;
&lt;p&gt;\[\sum_t logP(w_{i+1}^t| w_{i+1}^{&amp;lt;t}, h_i) + logP(w_{i-1}^t| w_{i-1}^{&amp;lt;t}, h_i) \]&lt;/p&gt;
&lt;p&gt;论文比较有意思的一个点还有vocabulary expansion，就是如何把word embedding扩展到训练集之外。作者尝试用linear-mapping的方式学习word2vec和skip-thought里面word-embedding的映射关系，就是找到word2vec和skip-thought交集的word, 对他们的embedding做regression $ X_{word2vec} \sim W \cdot X_{skipthought} $，这样对样本外但是word2vec内的单词直接用W映射就能得到skip-thougt的词向量&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里直接用word2vec/glove的word embedding来初始化skip-thougt的词向量是不是更好？在后面的模型实现里我就是直接用word2vec来初始化了embedding, word2vec之外词用random.uniform(-0.1,0.1)来初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最终在生成文本向量的时候，作者给出了几种方案，遵循大力一定出奇迹的原则自然方案3效果更好&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;2400-dim的uni-skip, 就是以上encoder生成的output state&lt;/li&gt;
&lt;li&gt;两个1200-dim的bi-skip向量拼接得到2400-dim的向量，是在处理训练样本时一个用正常语序训练，一个reverse语序训练&lt;/li&gt;
&lt;li&gt;把上面两个2400-dim拼接得到4800-dim&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;skip-thought-模型实现&quot;&gt;skip-thought 模型实现&lt;/h2&gt;
&lt;p&gt;这里有点任性的对论文做了魔改。。。部分细节和论文已经天差地别，可以拿来了解encoder-decoder的实现但不保证完全reproduce skip-thought的结果。。。以下只保留代码核心部分，完整代码在 &lt;a href=&quot;https://github.com/DSXiangLi/Embedding/tree/master/skip_thought&quot;&gt;&lt;strong&gt;github-DSXiangLi-Embedding-skip_thought&lt;/strong&gt;&lt;/a&gt;。 这里用了tensorflow seq2seq的框架，不熟悉的童鞋可以先看后面seq2seq的代码解析~&lt;/p&gt;
&lt;h3 id=&quot;dataset&quot;&gt;dataset&lt;/h3&gt;
&lt;p&gt;论文中是&lt;span class=&quot;math inline&quot;&gt;\((s_{i-1}, s_i, s_{i+1})\)&lt;/span&gt;作为一组样本，其中&lt;span class=&quot;math inline&quot;&gt;\(s_i\)&lt;/span&gt;是encoder source，&lt;span class=&quot;math inline&quot;&gt;\(s_{i-1}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(s_{i+1}\)&lt;/span&gt;是decoder target，这里我直接处理成&lt;span class=&quot;math inline&quot;&gt;\((s_i,s_{i-1})\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\((s_i,s_{i+1})\)&lt;/span&gt;两组样本。&lt;/p&gt;
&lt;p&gt;其中encoder source不需要多做处理，但是decoder source在Train和Eval时需要在sequence前后加入start和end_token标记序列的开始和结束，在Predict时需要加入start_token标记开始。最后通过word_table把token映射到token_id，再Padding到相同长度就齐活。&lt;/p&gt;
&lt;p&gt;这里在Dataset的部分加入了获取word2vec embedding的部分, word2vec以外的单词默认random.uniform(-0.1,0.1)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class SkipThoughtDataset(BaseDataset):
    def __init__(self, data_file, dict_file, epochs, batch_size, buffer_size, min_count, max_count,
                 special_token, max_len):
    ...
    def parse_example(self, line, prepend, append):
        features = {}
        tokens = tf.string_split([tf.string_strip(line)]).values

        if prepend:
            tokens = tf.concat([[self.special_token.SEQ_START], tokens], 0)
        if append:
            tokens = tf.concat([tokens, [self.special_token.SEQ_END]], 0)

        features['tokens'] = tokens
        features['seq_len'] = tf.size(tokens)
        return features
    ...

    def make_source_dataset(self, file_path, data_type, is_predict, word_table_func):
        prepend, append = self.prepend_append_logic(data_type, is_predict)

        dataset = tf.data.TextLineDataset(file_path).\
            map(lambda x: self.parse_example(x, prepend, append), num_parallel_calls=tf.data.experimental.AUTOTUNE).\
            map(lambda x: word_table_func(x), num_parallel_calls=tf.data.experimental.AUTOTUNE)

        return dataset

    def build_dataset(self, is_predict=0):
        def input_fn():
            word_table_func = self.word_table_lookup(self.build_wordtable())
            _ = self.build_tokentable() # initialize here to ensure lookup table is in the same graph

            encoder_source = self.make_source_dataset(self.data_file['encoder'], 'encoder', is_predict, word_table_func)
            decoder_source = self.make_source_dataset(self.data_file['decoder'], 'decoder', is_predict, word_table_func)

            dataset = tf.data.Dataset.zip((encoder_source, decoder_source)).\
                filter(self.sample_filter_logic)

            if not is_predict:
                dataset = dataset.\
                    repeat(self.epochs)

                dataset = dataset. \
                    padded_batch( batch_size=self.batch_size,
                                  padded_shapes=self.padded_shape,
                                  padding_values=self.padding_values,
                                  drop_remainder=True ). \
                    prefetch( tf.data.experimental.AUTOTUNE )
            else:
                dataset = dataset.batch(1)

            return dataset
        return input_fn

    def load_pretrain_embedding(self):
        if self.embedding is None:
            word_vector = gensim.downloader.load(PretrainModel)
            embedding = []
            for i in self._dictionary.keys():
                try:
                    embedding.append( word_vector.get_vector( i ) )
                except KeyError:
                    embedding.append( np.random.uniform(low=-0.1, high=0.1, size=300))
            self.embedding = np.array(embedding, dtype=np.float32)
        return self.embedding
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;encoder-decoder&quot;&gt;Encoder-Decoder&lt;/h3&gt;
&lt;p&gt;Encoder的部分很常规，确认cell类型，然后经过dynamic_rnn迭代，输出output和state&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def gru_encoder(input_emb, input_len, params):
    gru_cell = build_rnn_cell('gru', params)

    # state: batch_size * hidden_size, output: batch_size * max_len * hidden_size
    output, state = tf.nn.dynamic_rnn(
        cell=gru_cell, # one rnn units
        inputs=input_emb, # batch_size * max_len * feature_size
        sequence_length=input_len, # batch_size * seq_len
        initial_state=None,
        dtype=params['dtype'],
        time_major=False # whether reshape max_length to first dim
    )
    return ENCODER_OUTPUT(output=output, state=state)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Decoder的部分可以分成helper, decoder, 以及最终dynamic_decode的部分。比较容易踩坑的有几个点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dynamic_decode部分的max_iteration在训练时可以不设定，train_helper会基于seq_len判断finish，在Eval时因为用GreedyEmbeddingHelper所以需要手动传入pad_len，在predict部分只需给定最大max_iter保证预测一定会停止就好&lt;/li&gt;
&lt;li&gt;Decoder的output layer必须要有, 因为需要做hidden_size -&amp;gt; vocab_size(softmax)的转换，用于预测每个cell的token输出&lt;/li&gt;
&lt;li&gt;前面dataset的decoder_source我们在前后都加了开始/停止token，训练时需要移除最后一个token(对于trainHelper可以改inputs也可以改sequence_length), 这样在计算loss时可以和移除第一个token的target对齐。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里针对上面提到的把encoder的output_state直接传入每个decoder cell做了实现，直接把encoder state和embedding input做了拼接作为输入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def get_helper(encoder_output, input_emb, input_len, batch_size, embedding, mode, params):

    if mode == tf.estimator.ModeKeys.TRAIN:
        if params['conditional']:
            # conditional train helper with encoder output state as direct input
            # Reshape encoder state as auxiliary input: 1* batch_size * hidden -&amp;gt; batch_size * max_len * hidden
            decoder_length = tf.shape(input_emb)[1]
            state_shape = tf.shape(encoder_output.state)
            encoder_state = tf.tile(tf.reshape(encoder_output.state, [state_shape[1],
                                                                      state_shape[0],
                                                                      state_shape[2]]),
                                    [1, decoder_length, 1])
            input_emb = tf.concat([encoder_state, input_emb], axis=-1)

            helper = seq2seq.TrainingHelper( inputs=input_emb, # batch_size * max_len-1 * emb_size
                                             sequence_length=input_len-1, # exclude last token
                                             time_major=False,
                                             name='training_helper' )
    else:
        helper = seq2seq.GreedyEmbeddingHelper( embedding=embedding_func( embedding ),
                                                start_tokens=tf.fill([batch_size], params['start_token']),
                                                end_token=params['end_token'] )

    return helper
    
def get_decoder(decoder_cell, encoder_output, input_emb, input_len, embedding, output_layer, mode, params):
    batch_size = tf.shape(encoder_output.output)[0]
    if params['beam_width'] &amp;gt;1 :
        # If beam search multiple prediction are uesd at each time step
        decoder = seq2seq.BeamSearchDecoder( cell=decoder_cell,
                                             embedding=embedding_func( embedding ),
                                             initial_state=encoder_output,
                                             beam_width=params['beam_width'],
                                             start_tokens=tf.fill([batch_size], params['start_token']),
                                             end_token=params['end_token'],
                                             output_layer=output_layer )

    else:
        helper = get_helper(encoder_output, input_emb, input_len, batch_size, embedding, mode, params)

        decoder = seq2seq.BasicDecoder( cell=decoder_cell,
                                        helper=helper,
                                        initial_state=encoder_output.state,
                                        output_layer=output_layer )

    return decoder

def gru_decoder(encoder_output, input_emb, input_len, embedding, params, mode):
    gru_cell = build_rnn_cell( 'gru', params )

    if mode == tf.estimator.ModeKeys.TRAIN:
        max_iteration = None
    elif mode == tf.estimator.ModeKeys.EVAL:
        max_iteration = tf.reduce_max(input_len) # decode max sequence length(=padded_length)in EVAL
    else:
        max_iteration = params['max_decode_iter']  # decode pre-defined max_decode iter in predict

    output_layer=tf.layers.Dense(units=params['vocab_size'])  # used for infer helper sample or train loss calculation
    decoder = get_decoder(gru_cell, encoder_output, input_emb, input_len, embedding, output_layer, mode, params)

    output, state, seq_len = seq2seq.dynamic_decode(decoder=decoder,
                                                    output_time_major=False,
                                                    impute_finished=True,
                                                    maximum_iterations=max_iteration)

    return DECODER_OUTPUT(output=output, state = state, seq_len=seq_len)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;loss&quot;&gt;loss&lt;/h3&gt;
&lt;p&gt;loss这了自己实现的一版sequence_loss，把计算loss和按不同维度聚合拆成了两块。感觉tf.sequence_loss只针对train,对eval的部分并不友好，因为trainHelper可以保证source和target的长度一致，但是infer时调用GreedyEmbeddingHelper是无法保证输出长度的(不知道是不是我哪里理解错了，如果是请大神指正(o^^o)), 所以对eval部分也做了特殊处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def sequence_loss(logits, target, mask, mode):
    with tf.variable_scope('Sequence_loss_matrix'):
        n_class = tf.shape(logits)[2]
        decode_len = tf.shape(logits)[1] # used for infer only, max_len is determined by decoder
        logits = tf.reshape(logits, [-1, n_class])

        if mode == tf.estimator.ModeKeys.TRAIN:
            # In train, target
            target = tf.reshape(target[:, 1:], [-1]) # (batch * (padded_len-1)) * 1
        elif mode == tf.estimator.ModeKeys.EVAL:
            # In eval, target has paded_len, logits have decode_len
            target = tf.reshape(target[:, : decode_len], [-1]) # batch * (decode_len) *1
        else:
            raise Exception('sequence loss is only used in train or eval, not in pure prediction')
        loss_mat = tf.nn.sparse_softmax_cross_entropy_with_logits(labels = target, logits = logits)
        loss_mat = tf.multiply(loss_mat, tf.reshape(mask, [-1])) # apply padded mask on output loss
    return loss_mat
    
def agg_sequence_loss(loss_mat, mask,  axis):
    with tf.variable_scope('Loss_{}'.format(axis)):
        if axis == 'scaler':
            loss = tf.reduce_sum(loss_mat)
            n_sample = tf.reduce_sum(mask)
            loss = loss/n_sample
        else:
            loss_mat = tf.reshape(loss_mat, tf.shape(mask)) # (batch_size * max_len) * 1-&amp;gt; batch_size * max_len
            if axis == 'batch':
                loss = tf.reduce_sum(loss_mat, axis=1) # batch
                n_sample = tf.reduce_sum(mask, axis=1) # batch
                loss = tf.math.divide_no_nan(loss, n_sample) # batch
            elif axis == 'time':
                loss = tf.reduce_sum(loss_mat, axis=0) # max_len
                n_sample = tf.reduce_sum(mask, axis=0) # max_len
                loss = tf.math.divide_no_nan(loss, n_sample) # max_len
            else:
                raise Exception('Only scaler/batch/time are supported in axis param')
    return loss
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;model&quot;&gt;model&lt;/h3&gt;
&lt;p&gt;encoder, decoder, loss都ready，拼一块就齐活了, 这里embedding我们用了前面加载的word2vec来进行初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class QuickThought(object):
    def __init__(self, params):
        self.params = params
        self.init()

    def init(self):
        with tf.variable_scope('embedding', reuse=tf.AUTO_REUSE):
            self.embedding = tf.get_variable(dtype = self.params['dtype'],
                                             initializer=tf.constant(self.params['pretrain_embedding']),
                                             name='word_embedding' )

            add_layer_summary(self.embedding.name, self.embedding)

    def build_model(self, features, labels, mode):
        encoder_output = self._encode(features)
        decoder_output = self._decode(encoder_output, labels, mode )

        loss_output = self.compute_loss( decoder_output, labels, mode )

        ...
    def _encode(self, features):
        with tf.variable_scope('encoding'):
            encoder = ENCODER_FAMILY[self.params['encoder_type']]

            seq_emb_input = tf.nn.embedding_lookup(self.embedding, features['tokens']) # batch_size * max_len * emb_size

            encoder_output = encoder(seq_emb_input, features['seq_len'], self.params) # batch_size
        return encoder_output

    def _decode(self, encoder_output, labels, mode):
        with tf.variable_scope('decoding'):
            decoder = DECODER_FAMILY[self.params['decoder_type']]

            if mode == tf.estimator.ModeKeys.TRAIN:
                seq_emb_output = tf.nn.embedding_lookup(self.embedding, labels['tokens']) # batch_size * max_len * emb_size
                input_len = labels['seq_len']
            elif mode == tf.estimator.ModeKeys.EVAL:
                seq_emb_output = None
                input_len = labels['seq_len']
            else:
                seq_emb_output = None
                input_len = None

            decoder_output = decoder(encoder_output, seq_emb_output, input_len,\
                                     self.embedding, self.params, mode)
        return decoder_output
    def compute_loss(self, decoder_output, labels, mode):
        with tf.variable_scope('compute_loss'):
            mask = sequence_mask(decoder_output, labels, self.params, mode)

            loss_mat = sequence_loss(logits=decoder_output.output.rnn_output,
                                     target=labels['tokens'],
                                     mask=mask,
                                     mode=mode)
            loss = []
            for axis in ['scaler', 'batch', 'time']:
                loss.append(agg_sequence_loss(loss_mat, mask, axis))

        return SEQ_LOSS_OUTPUT(loss_id=loss_mat,
                               loss_scaler=loss[0],
                               loss_per_batch=loss[1],
                               loss_per_time=loss[2])
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tfseq2seq-代码解析&quot;&gt;tf.seq2seq 代码解析&lt;/h2&gt;
&lt;p&gt;稀里糊涂开始用seq2seq，结果盯着shape mismatch的报错险些看到地老天荒，索性咱老老实实看一遍tf的实现, 以下代码只保留了核心部分，完整的官方代码在这里哟 &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/r1.8/tensorflow/contrib/seq2seq/python/ops&quot;&gt;&lt;strong&gt;tf.seq2seq.contrib&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;encoding&quot;&gt;Encoding&lt;/h3&gt;
&lt;p&gt;Encoding部分就是一个dynamic_rnn，先看下输入&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cell：任意类型记忆单元rnn,gru, lstm&lt;/li&gt;
&lt;li&gt;inputs：rnn输入，一般是[batch_size, max_len, emb_siz] 也就是padding的序列token,经过embedding映射之后作为输入&lt;/li&gt;
&lt;li&gt;sequence_length: 真实序列长度(不包含padding)，用于判断序列是遍历完&lt;/li&gt;
&lt;li&gt;initial_state: encoder最初state，None则默认是zero_state&lt;/li&gt;
&lt;li&gt;dtype: output数据类型，建议全局设置统一数据类型，不然会有各种mismatch，不要问我是怎么知道的&amp;gt;.&amp;lt;&lt;/li&gt;
&lt;li&gt;parallel_iteration：内存换速度，没有上下文依赖的op进行并行计算&lt;/li&gt;
&lt;li&gt;time_major：如果你的输入数据是[max_len, batch_size，emb_siz]则为True，一般为False在dynamic_rnn内部再做reshape。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;dynamic_rnn主函数其实只做了输入/输出数据的处理部分，包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;reshape_input：对应上面time_major=False, 把输入数据从[batch_size, max_len, emb_siz]转换为[max_len, batch_size，emb_siz]&lt;/li&gt;
&lt;li&gt;inital_state: 默认是batch size的zero_state&lt;/li&gt;
&lt;li&gt;reshape_output: output输出是[max_len, batch_size，hidden_siz]转换为[batch_size, max_len, hidden_size]&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def dynamic_rnn(cell, inputs, sequence_length=None, initial_state=None,
                dtype=None, parallel_iterations=None, swap_memory=False,
                time_major=False, scope=None):
    flat_input = nest.flatten(inputs)

    if not time_major:
      flat_input = [ops.convert_to_tensor(input_) for input_ in flat_input]
      flat_input = tuple(_transpose_batch_time(input_) for input_ in flat_input)

    batch_size = _best_effort_input_batch_size(flat_input)
    state = cell.zero_state(batch_size, dtype)

    inputs = nest.pack_sequence_as(structure=inputs, flat_sequence=flat_input)

    (outputs, final_state) = _dynamic_rnn_loop(
        cell,
        inputs,
        state,
        parallel_iterations=parallel_iterations,
        swap_memory=swap_memory,
        sequence_length=sequence_length,
        dtype=dtype)

    if not time_major:
      # (T,B,D) =&amp;gt; (B,T,D)
      outputs = nest.map_structure(_transpose_batch_time, outputs)
    return (outputs, final_state)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心计算部分都在_dynamic_rnn_loop，是一个while_loop, 所以需要定义三要素[loop_var, body, condition]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;loop_var：(time, output_ta, state)
&lt;ul&gt;&lt;li&gt;time:遍历到第几个token&lt;/li&gt;
&lt;li&gt;output_ta: 每个cell的输出，padding部分是zero-output&lt;/li&gt;
&lt;li&gt;state: 最后一个cell的输出，对于padding的序列，只计算到最后一个真实token，之后的state是直接copy through&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里output_ta的shape是(batch, max_len, hidden_units), 对于rnn和GRU，state就是最后一个output, 那shape自然是(1, batch, hidden_units), 但LSTM是有两个hidden state的，一个用于向前传递信息一个用于输出，所以这里state的shape会是（2, batch, hidden_units)&lt;/p&gt;
&lt;p&gt;loop的核心计算部分是lambda: cell(input_t, state)，也就是相应记忆单元的计算。当sequence_length给定时，_rnn_step的额外操作其实是对已经遍历完的序列直接copy through（zero_output, last_state)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;  def _time_step(time, output_ta_t, state):

    input_t = tuple(ta.read(time) for ta in input_ta)
    input_t = nest.pack_sequence_as(structure=inputs, flat_sequence=input_t)
    call_cell = lambda: cell(input_t, state)

    if sequence_length is not None:
      (output, new_state) = _rnn_step(
          time=time,
          sequence_length=sequence_length,
          min_sequence_length=min_sequence_length,
          max_sequence_length=max_sequence_length,
          zero_output=zero_output,
          state=state,
          call_cell=call_cell,
          state_size=state_size,
          skip_conditionals=True)
    else:
      (output, new_state) = call_cell()

    # Pack state if using state tuples
    output = nest.flatten(output)
    output_ta_t = tuple(ta.write(time, out) for ta, out in zip(output_ta_t, output))

    return (time + 1, output_ta_t, new_state)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停止loop的条件loop_bound=min(max_sequence_length, max(1,time_steps) , 其中time_step是输入的max_len维度，也就是padding length, max_sequence_length是输入batch的最大真实长度，如果是batch_padding这两个取值应该是一样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;time_steps = input_shape[0]

if sequence_length is not None:
    min_sequence_length = math_ops.reduce_min(sequence_length)
    max_sequence_length = math_ops.reduce_max(sequence_length)
else:
    max_sequence_length = time_steps

loop_bound = math_ops.minimum(time_steps, math_ops.maximum(1, max_sequence_length))
        
  _, output_final_ta, final_state = control_flow_ops.while_loop(
      cond=lambda time, *_: time &amp;lt; loop_bound,
      body=_time_step,
      loop_vars=(time, output_ta, state),
      parallel_iterations=parallel_iterations,
      maximum_iterations=time_steps,
      swap_memory=swap_memory)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;decoding&quot;&gt;Decoding&lt;/h3&gt;
&lt;p&gt;Decoding主要有三个组件，Decoder，Helper和dynamic_decode。还有比较特殊独立出来的BeamSearch和Attention，这两个后面用到再说&lt;/p&gt;
&lt;h4 id=&quot;basicdecoder&quot;&gt;BasicDecoder&lt;/h4&gt;
&lt;p&gt;BasicDecoder主要接口有2个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;initialize生成decode阶段的最初input&lt;/li&gt;
&lt;li&gt;step实现每一步decode的计算,之后被dynamic_decode的while_loop调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中initialize拼接了helper的初始化返回再加上initial_state，也就是encoder最后一步的output_state，helper返回的部分我们放在后面说。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initialize(self, name=None):
    return self._helper.initialize() + (self._initial_state,)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;step部分做了如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入上一步的output, state计算下一步的output，这是Decoder的核心计算&lt;/li&gt;
&lt;li&gt;如果定义了output_layer，对output做transform，为啥需要output_layer嘞? 这个看到Helper你就明白了&lt;/li&gt;
&lt;li&gt;sample, next_inputs: 都是调用Helper的接口&lt;/li&gt;
&lt;li&gt;输出: BasicDecoderOutput(rnn_output, sample_id), next_state, next_inputs, finished&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;class BasicDecoderOutput(
    collections.namedtuple(&quot;BasicDecoderOutput&quot;, (&quot;rnn_output&quot;, &quot;sample_id&quot;))):
  pass

class BasicDecoder(decoder.Decoder):
  &quot;&quot;&quot;Basic sampling decoder.&quot;&quot;&quot;

  def __init__(self, cell, helper, initial_state, output_layer=None):

  def step(self, time, inputs, state, name=None):
    with ops.name_scope(name, &quot;BasicDecoderStep&quot;, (time, inputs, state)):
      cell_outputs, cell_state = self._cell(inputs, state)
      if self._output_layer is not None:
        cell_outputs = self._output_layer(cell_outputs)
      sample_ids = self._helper.sample(
          time=time, outputs=cell_outputs, state=cell_state)
      (finished, next_inputs, next_state) = self._helper.next_inputs(
          time=time,
          outputs=cell_outputs,
          state=cell_state,
          sample_ids=sample_ids)
    outputs = BasicDecoderOutput(cell_outputs, sample_ids)
    return (outputs, next_state, next_inputs, finished)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里发现BasicDecoder的实现只包括了承上的部分，启下的部分都放在了Helper里面，下面我们具体看下Helper的next_input和Sample接口干了啥&lt;/p&gt;
&lt;h4 id=&quot;helper&quot;&gt;Helper&lt;/h4&gt;
&lt;p&gt;我们主要看两个helper一个用于训练，一个用于预测，主要实现3个接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;initialize：生成decode阶段的最初input&lt;/li&gt;
&lt;li&gt;sample：生成decode下一步的input id&lt;/li&gt;
&lt;li&gt;next_inputs：生成decode下一步的input&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;TrainHelper&lt;/strong&gt;用于训练，sample接口实际并没有用，next_input把sample_id定义为unused_kwargs.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;initialize返回 (finished, next_inputs)
&lt;ul&gt;&lt;li&gt;finished: 判断当前batch每个sequence是否已经遍历完, sequence_length是不包含padded的实际sequencec长度&lt;/li&gt;
&lt;li&gt;除非batch里所有seq_length的长度都是0，否则直接读取每个sequence的第一个token作为decoder的初始输入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;decoder输入sequence会在预处理时加入start_token标记seq的开始，对应上图的&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;go&amp;gt;\)&lt;/span&gt;标记,同时加入start_token也为了形成source和target的错位，做到输入T-1个字符预测T个字符。例如source是[&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;go&amp;gt;\)&lt;/span&gt;, I, love, you]，target是[I, love, you, &lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;eos&amp;gt;\)&lt;/span&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;next_inputs输出(finished, next_inputs, state)
&lt;ul&gt;&lt;li&gt;finished: 判断当前batch每个sequence是否已经遍历完, sequence_length是不包含padded的实际sequencec长度&lt;/li&gt;
&lt;li&gt;next_inputs: 训练时使用Teaching Force，传入下一个decoder cell的就是前一个位置的实际token embedding，所以这里next_input直接读取input sequence的下一个值，如果finished都是True就返回0【其实返回啥都无所谓因为在loss那里padded的部分会被mask掉】&lt;/li&gt;
&lt;li&gt;state: 这里是打酱油的，直接pass-throuh&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class TrainingHelper(Helper):

  def __init__(self, inputs, sequence_length, time_major=False, name=None):
    ...

  def initialize(self, name=None):
    with ops.name_scope(name, &quot;TrainingHelperInitialize&quot;):
      finished = math_ops.equal(0, self._sequence_length)
      all_finished = math_ops.reduce_all(finished)
      next_inputs = control_flow_ops.cond(
          all_finished, lambda: self._zero_inputs,
          lambda: nest.map_structure(lambda inp: inp.read(0), self._input_tas))
      return (finished, next_inputs)
      
  def next_inputs(self, time, outputs, state, name=None, **unused_kwargs):
    &quot;&quot;&quot;next_inputs_fn for TrainingHelper.&quot;&quot;&quot;
    with ops.name_scope(name, &quot;TrainingHelperNextInputs&quot;,
                        [time, outputs, state]):
      next_time = time + 1
      finished = (next_time &amp;gt;= self._sequence_length)
      all_finished = math_ops.reduce_all(finished)
      def read_from_ta(inp):
        return inp.read(next_time)
      next_inputs = control_flow_ops.cond(
          all_finished, lambda: self._zero_inputs,
          lambda: nest.map_structure(read_from_ta, self._input_tas))
      return (finished, next_inputs, state)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;GreedyHelper&lt;/strong&gt;用于预测&lt;/p&gt;
&lt;p&gt;负责根据每个decoder cell的output计算出现概率最大的token，作为下一个decoder cell的输入，&lt;strong&gt;这里也是上面提到需要output_layer的原因，因为需要hidden_size -&amp;gt; vocab_size的变换，才能进一步计算softmax&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;next_input
&lt;ul&gt;&lt;li&gt;finished: 如果sequence预测为end_token则该sequence预测完成，判断batch里所有sequence是否预测完成&lt;/li&gt;
&lt;li&gt;next_inputs: 对sample_id做embedding_lookup作为下一步的输入，如果finished都是True就返回start_token&lt;/li&gt;
&lt;li&gt;state: 继续打酱油&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class GreedyEmbeddingHelper(Helper):
  def __init__(self, embedding, start_tokens, end_token):
    self._start_tokens = ops.convert_to_tensor(
        start_tokens, dtype=dtypes.int32, name=&quot;start_tokens&quot;)
    self._end_token = ops.convert_to_tensor(
        end_token, dtype=dtypes.int32, name=&quot;end_token&quot;)
    self._start_inputs = self._embedding_fn(self._start_tokens)
    。。。
  def sample(self, time, outputs, state, name=None):
    sample_ids = math_ops.cast(
        math_ops.argmax(outputs, axis=-1), dtypes.int32)
    return sample_ids

  def initialize(self, name=None):
    finished = array_ops.tile([False], [self._batch_size])
    return (finished, self._start_inputs)
    
  def next_inputs(self, time, outputs, state, sample_ids, name=None):
    finished = math_ops.equal(sample_ids, self._end_token)
    all_finished = math_ops.reduce_all(finished)
    next_inputs = control_flow_ops.cond(
        all_finished,
        lambda: self._start_inputs,
        lambda: self._embedding_fn(sample_ids))
    return (finished, next_inputs, state)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dynamic_decode&quot;&gt;dynamic_decode&lt;/h4&gt;
&lt;p&gt;承上启下的工具都齐活了，要实现对sequence的预测，只剩下一步就是loop，于是有了dynamic_decode，它其实就干了个while_loop的活，于是还是loop三兄弟[loop_vars, condition, body]&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;loop_vars=[initial_time, initial_outputs_ta, initial_state, initial_inputs, initial_finished, initial_sequence_lengths]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;initial_finished, initial_inputs, initial_state是上面decoder的initialize返回&lt;/li&gt;
&lt;li&gt;initial_time, initial_sequennce=0&lt;/li&gt;
&lt;li&gt;initial_output_ta是每个elemennt都是batch * decoder.output_size的不定长TensorArray, 这里output_size=(rnn_output_size,sample_id_shape),预测返回1个token的sample_id_shape都是scaler, 有output_layer时rnn_output_size=output_layer_size, default= hidden_size&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;condition: 判断是否所有finished都为True，都遍历完则停止loop&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;body: loop的核心计算逻辑&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;step：调用Decoder进行每一步的decode计算&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;finished: 这里finished主要由三个逻辑判断（tracks_own_finished我没用过先忽略了哈哈）其余两个是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;helper的next_inputs回传的finished：trainHelper判断输入sequence是否遍历完，GreedyEmbeddingHelper判断预测token是否为end_token。&lt;/li&gt;
&lt;li&gt;max_iteration：只用于预测，为了避免预测token一直不是end_token导致预测无限循环下去，设置一个最大预测长度，训练时max_iteraion应该为空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sequence_length: 记录实际预测sequence长度，没有finished的sequence+1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;impute_finished: 如果sequence已遍历完, 后面的output补0，后面的state不再计算直接pass through当前state&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def body(time, outputs_ta, state, inputs, finished, sequence_lengths):
  (next_outputs, decoder_state, next_inputs,
   decoder_finished) = decoder.step(time, inputs, state)

  if maximum_iterations is not None:
    next_finished = math_ops.logical_or(
        next_finished, time + 1 &amp;gt;= maximum_iterations)
  next_sequence_lengths = array_ops.where(
      math_ops.logical_and(math_ops.logical_not(finished), next_finished),
      array_ops.fill(array_ops.shape(sequence_lengths), time + 1),
      sequence_lengths)

  # Zero out output values past finish
  if impute_finished:
    emit = nest.map_structure(
        lambda out, zero: array_ops.where(finished, zero, out),
        next_outputs,
        zero_outputs)
  else:
    emit = next_outputs

  # Copy through states past finish
  def _maybe_copy_state(new, cur):
    # TensorArrays and scalar states get passed through.
    if isinstance(cur, tensor_array_ops.TensorArray):
      pass_through = True
    else:
      new.set_shape(cur.shape)
      pass_through = (new.shape.ndims == 0)
    return new if pass_through else array_ops.where(finished, cur, new)

  if impute_finished:
    next_state = nest.map_structure(
        _maybe_copy_state, decoder_state, state)
  else:
    next_state = decoder_state

  outputs_ta = nest.map_structure(lambda ta, out: ta.write(time, out),
                                  outputs_ta, emit)
  return (time + 1, outputs_ta, next_state, next_inputs, next_finished,
          next_sequence_lengths)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;欢迎留言吐槽以及评论哟～&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;h4 id=&quot;skip-thought&quot;&gt;skip-thought&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Ryan Kiros, yukun Zhu. 2015. SKip-Thought Vectors&lt;/li&gt;
&lt;li&gt;Lajanugen logeswaran, Honglak Lee. 2018. An Efficient Framework for Learning Sentence Representations.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64342563&quot;&gt;https://zhuanlan.zhihu.com/p/64342563&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&quot;&gt;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/the-best-document-similarity-algorithm-in-2020-a-beginners-guide-a01b9ef8cf05&quot;&gt;https://towardsdatascience.com/the-best-document-similarity-algorithm-in-2020-a-beginners-guide-a01b9ef8cf05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.floydhub.com/when-the-best-nlp-model-is-not-the-best-choice/&quot;&gt;https://blog.floydhub.com/when-the-best-nlp-model-is-not-the-best-choice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&quot;&gt;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72575806&quot;&gt;https://zhuanlan.zhihu.com/p/72575806&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Scheduled Sampling for Sequence Prediction with Recurrent Neural Networks&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;tensorflow-seq2seq&quot;&gt;tensorflow seq2seq&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/google/seq2seq/tree/master/seq2seq&quot;&gt;https://github.com/google/seq2seq/tree/master/seq2seq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27608348&quot;&gt;https://zhuanlan.zhihu.com/p/27608348&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47929039&quot;&gt;https://zhuanlan.zhihu.com/p/47929039&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/llh_1178/article/details/89322373&quot;&gt;https://blog.csdn.net/llh_1178/article/details/89322373&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 20 Nov 2020 13:46:00 +0000</pubDate>
<dc:creator>风雨中的小七</dc:creator>
<og:description>前一章Doc2Vec里提到，其实Doc2Vec只是通过加入Doc_id捕捉了文本的主题信息，并没有真正考虑语序以及上下文语义，n-gram只能在局部解决这一问题，那么还有别的解决方案么？依旧是通用文本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gogoSandy/p/14009265.html</dc:identifier>
</item>
<item>
<title>【芯片手册开发】Sil9136音频开发详细分析+源码实战 - 李柱明</title>
<link>http://www.cnblogs.com/lizhuming/p/14013201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizhuming/p/14013201.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;默认在开发了视频方面后&lt;/li&gt;
&lt;li&gt;这方面的工作本来可以找技术支持拿个例程参考下，很快就可以的写出来的，因为自己对HDMI协议不太了解，但是技术支持说没有，所以没办法，只能自己搞了&lt;/li&gt;
&lt;li&gt;看手册不难，难的是找资料&lt;/li&gt;
&lt;li&gt;记录一下，也分享一下&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;sil9136寄存器手册：&lt;strong&gt;《Sil-PR-1060-C》&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HDMI协议手册：&lt;strong&gt;《HDMI_1.4》&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CEA标准手册：&lt;strong&gt;《CEA-861-D[安全]》&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用参考例程&lt;/strong&gt;（&lt;em&gt;无音频功能&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;手册使用实战&quot;&gt;手册使用+实战&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以 I2S 接口为例开发&lt;/li&gt;
&lt;li&gt;直接看手册配置相关寄存器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记得输入与输出配对&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;如编码类型&lt;/li&gt;
&lt;li&gt;采样长度&lt;/li&gt;
&lt;li&gt;采样频率&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;《Sil-PR-1060-C》手册，28页起&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085252/202011/2085252-20201120213723759-111667844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;图中说明 sil9136 支持 S/PDIF, I2S or DSD模式，主机可以通过配置TPI选择不同的模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085252/202011/2085252-20201120213731654-61667321.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这个寄存器表比较重要，说明了sil9136的寄存器配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0x26 寄存器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[7:6]
&lt;ul&gt;&lt;li&gt;选择模式，支持
&lt;ul&gt;&lt;li&gt;none&lt;/li&gt;
&lt;li&gt;S/PDIF&lt;/li&gt;
&lt;li&gt;I2S&lt;/li&gt;
&lt;li&gt;DSD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[5]
&lt;ul&gt;&lt;li&gt;通道数，支持
&lt;ul&gt;&lt;li&gt;双通道&lt;/li&gt;
&lt;li&gt;8 通道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[4]
&lt;ul&gt;&lt;li&gt;静音配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[3:0]
&lt;ul&gt;&lt;li&gt;编码类型，有
&lt;ul&gt;&lt;li&gt;Refer to Stream Header&lt;/li&gt;
&lt;li&gt;PCM (&lt;em&gt;本次使用 PCM&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;AC-3&lt;/li&gt;
&lt;li&gt;MPEG1&lt;/li&gt;
&lt;li&gt;MP3&lt;/li&gt;
&lt;li&gt;MPEG2&lt;/li&gt;
&lt;li&gt;AAC&lt;/li&gt;
&lt;li&gt;DTS&lt;/li&gt;
&lt;li&gt;ATRAC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0x27 寄存器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[7:6]
&lt;ul&gt;&lt;li&gt;音频采样比特位长度 &lt;strong&gt;SS&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;Refer to Stream Header&lt;/li&gt;
&lt;li&gt;16 bit&lt;/li&gt;
&lt;li&gt;20 bit&lt;/li&gt;
&lt;li&gt;24 bit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[5:3]
&lt;ul&gt;&lt;li&gt;音频采样频率 &lt;strong&gt;SF&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;Refer to Stream Header&lt;/li&gt;
&lt;li&gt;32 kHz&lt;/li&gt;
&lt;li&gt;44.1 kHz&lt;/li&gt;
&lt;li&gt;48 kHz&lt;/li&gt;
&lt;li&gt;88.2 kHz&lt;/li&gt;
&lt;li&gt;96 kHz&lt;/li&gt;
&lt;li&gt;176.4 kHz&lt;/li&gt;
&lt;li&gt;192 kHz&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;[2]
&lt;ul&gt;&lt;li&gt;是否支持高比特率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：图中说明的 0x24 和 0x25 寄存器只有在 S/PDIF 模式下有效，即是 0x26[7:6]=01 时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;configuring-audio-using-i2s&quot;&gt;Configuring Audio Using I2S&lt;/h3&gt;
&lt;h3 id=&quot;总结实现&quot;&gt;总结实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;得出一下代码，并把一下函数放到热插拔的插入后运行即可&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
  * @brief  setPrivateAudio(void)
  * @param 
  * @retval 
  * @author lzm
  */
void setPrivateAudio(void)
{
        byte Tmp = 0;

        /* Select I2S input mode using TPI 0x26[7:6], with Mute enabled (bit [4] = 1).  */
        SetAudioMute(AUDIO_MUTE_MUTED);
        
        /* Write register TPI 0x20 to select the general incoming SD format.  */
        WriteByteTPI(TPI_I2S_IN_CFG, (SCK_SAMPLE_EDGE | 0x10));
        
        /* Write register TPI 0x1F up to four times, to program each of the SD inputs. */
        do{
                WriteByteTPI(TPI_I2S_EN, 0x80);
                Tmp = ReadByteTPI(TPI_I2S_EN);
        }while(Tmp != 0x80);
        do{
                WriteByteTPI(TPI_I2S_EN, 0x91);
                Tmp = ReadByteTPI(TPI_I2S_EN);
        }while(Tmp != 0x91);
        do{
                WriteByteTPI(TPI_I2S_EN, 0xA2);
                Tmp = ReadByteTPI(TPI_I2S_EN);
        }while(Tmp != 0xA2);
        do{
                WriteByteTPI(TPI_I2S_EN, 0xB3);
                Tmp = ReadByteTPI(TPI_I2S_EN);
        }while(Tmp != 0xB3);
        
//      /* Program register TPI 0x27 with the correct audio about. */
//      WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, AUDIO_SAMPLE_SIZE_24BIT | AUDIO_SAMPLE_FREQ_48KHZ | AUDIO_SAMPLE_HBR_DISABLE);
        /* Program register TPI 0x27[5:3] with the correct audio rate */
        ReadModifyWriteTPI(TPI_AUDIO_SAMPLE_CTRL, 0x38, AUDIO_SAMPLE_FREQ_48KHZ);
        
        /* Program registers TPI 0x21-x25 with the correct header information for the stream that will be sent over HDMI. */
        WriteByteTPI(TPI_I2S_CHST_0, 0x00);
        WriteByteTPI(TPI_I2S_CHST_1, 0x00);
        WriteByteTPI(TPI_I2S_CHST_2, 0x00);
        WriteByteTPI(TPI_I2S_CHST_3, 0x02);
        WriteByteTPI(TPI_I2S_CHST_4, 0x0B);
        
        /* Write registers TPI 0xBF-xCD with the appropriate Audio InfoFrame information. */
        SetAudioInfoFrames(TWO_CHANNELS, 0x00, 0x00, 0x18, 0x00);
        /* Set the audio packet header layout indicator to 2-channel or multi-channel mode as needed using the sequence described below. 
                Note that Audio InfoFrame byte 1 must also have this same setting. */
        
        /* Again write register TPI 0x26 with I2S selected, this time with Mute disabled (bit [4] = 0). */
        WriteByteTPI(TPI_AUDIO_INTERFACE_REG,  AUD_IF_I2S | TWO_CHANNEL_LAYOUT | 0x01);
        SetAudioMute(AUDIO_MUTE_NORMAL);
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Nov 2020 13:43:00 +0000</pubDate>
<dc:creator>李柱明</dc:creator>
<og:description>前言 默认在开发了视频方面后 这方面的工作本来可以找技术支持拿个例程参考下，很快就可以的写出来的，因为自己对HDMI协议不太了解，但是技术支持说没有，所以没办法，只能自己搞了 看手册不难，难的是找资料</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lizhuming/p/14013201.html</dc:identifier>
</item>
<item>
<title>“三剑客”之sed手中有剑 - 一寸HUI</title>
<link>http://www.cnblogs.com/zsql/p/14007099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zsql/p/14007099.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、sed介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　sed是Stream Editor（字符流编辑器）的缩写，简称流编辑器。sed是操作、过滤和转换文本内容的强大工具。常用功能包括对文件实现快速增删改查（增加、删除、修改、查询），其中查询的功能中最常用的两大功能是过滤（过滤指定字符串）、取行（取出指定行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sed通过执行下面的循环来操作输入流中的每一行： 首先，sed读取输入流中的一行，移除该行的尾随换行符，并将其放入到pattern space中。然后对pattern space中的内容执行SCRIPT中的sed命令，每个sed命令都可以关联一个地址：地址是一种条件判断代码，只有符合条件的行才会执行相应的命令。当执行到SCRIPT（指的是我们定义的操作）的尾部时，除非指定了&quot;-n&quot;选项，否则pattern space中的内容将写到标准输出流中，并添加回尾随的换行符。然后进入下一个循环开始处理输入流中的下一行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但有些特殊命令(如&quot;D&quot;命令)会进入多行模式，使得SCRIPT循环结束 时将数据锁在pattern space中不输出也不清空，甚至在SCRIPT循环还没结束时就强行进入下一 轮SCRIPT循环，其实就相当 于在上面的while循环结构中加上了&quot;continue&quot;关键字。此外还有命令(如&quot;d&quot;)可以直接退出 SCRIPT循环进入下一个sed循环，就像是在while循环中加上了&quot;break&quot;一样。甚至还有直接退出 sed循环的命令(只有2个这样的命令：&quot;q&quot;和&quot;Q&quot;)，就像是加上了&quot;exit&quot;一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sed的执行过程是一个循环的过程：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;读取输入流的一行到模式空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对模式空间中的内容进行匹配和处理。（这里一般都是我们进行操作的地方，增删改查等）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动输出模式空间内容。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;清空模式空间内容。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;二、基本选项&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;命令格式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sed的命令格式：sed [options] &lt;span&gt;'&lt;/span&gt;&lt;span&gt;command&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; file(s);
sed的脚本格式：sed [options] &lt;/span&gt;-f scriptfile file(s);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基本选项如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;-&lt;span&gt;e ：直接在命令行模式上进行sed动作编辑，此为默认选项;
&lt;/span&gt;-&lt;span&gt;f ：将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作;
&lt;/span&gt;-&lt;span&gt;i ：直接修改文件内容，sed是通过创建一个临时文件并将输入写入到该临时文件，然后重命名为源文件来实现的
&lt;/span&gt;-&lt;span&gt;n ：只打印模式匹配的行；
&lt;/span&gt;-&lt;span&gt;r ：支持扩展表达式，sed所支持的扩展正则表达式和egrep一样
&lt;/span&gt;-&lt;span&gt;s : 考虑为多个单独的文件，而不是把多个文件作为一个流进行输入
&lt;/span&gt;-h或--&lt;span&gt;help：显示帮助；
&lt;/span&gt;-V或--version：显示版本信息。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实例练习：首先我们准备文件test.txt，内容如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed  -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt&lt;/strong&gt;  #打印第三行
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@lgh test]# &lt;strong&gt;sed  &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt&lt;/strong&gt;  #打印行号
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@lgh test]# &lt;strong&gt;sed  &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-r -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/[a-z]*ing/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt&lt;/strong&gt;  #正则匹配ing字符串
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;、I did my homework and watched TV。 On Sunday morning ，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;三、定址选择&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里所说的地址选择就是我们要处理一个文档中的哪些行？比如第1行到第3行，这就是用来选择匹配我们需要进行处理的行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当sed将输入流中的行读取到模式空间后，就需要对模式空间中的内容进行匹配，如果能匹配就能执行对应的命令，如果不能匹配就直接输出、清空模式空间并进入下一个sed循环读取下一行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;定址表达式有多种，其格式为[ADDR1][,ADDR2]。这可以分为3种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ADDR1和ADDR2都省略时，表示所有行都能被匹配上。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;省略ADDR2时，表示只有被ADDR1表达式匹配上的行才符合条件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不省略ADDR2时，是范围地址。表示从ADDR1匹配成功的行开始，到ADDR2匹配成功的行结束。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;'NUMBER'&lt;/strong&gt;:指定一个行号，sed将仅只匹配该行。(需要注意，除非使用了&quot;-s&quot;或&quot;-i&quot;选项，sed将对所有输入文件的行连续计数。)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'FIRST~STEP'&lt;/strong&gt;:FIRST和STEP都是非负数。该定址表达式表示从第FIRST行开始，每隔STEP行就再取一次。要选择所有的奇数行，使用“1~2”；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'$':&lt;/strong&gt;该符号匹配的是最后一个文件的最后一行，如果指定了&quot;-i&quot;或&quot;-s&quot;，则匹配的是每个文件的最后一行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'/REGEXP/&lt;/strong&gt;':该定址表达式将选择那些能被正则表达式REGEXP匹配的所有行。如果REGEXP中自身包含了字符&quot;/&quot;，则必须使用反斜线进行转义，即&quot;\/&quot;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'/REGEXP/I'&lt;/strong&gt;:正则表达式的修饰符&quot;I&quot;是GNU的扩展功能，表示REGEXP在匹配时不区分大小写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'/REGEXP/M'&lt;/strong&gt;:可以让sed直接匹配多行模式下(multi-line mode)的位置。该修饰符使得正则表达式的元字符&quot;^&quot;和&quot;$&quot;匹配分别匹配每个新行后的空字符和新行前的空字符。还有另外两个特殊的字符序列(\`和\'，分别是反斜线加反引号，反斜线加单引号)，它们总是匹配buffer空间中的起始和结束位置。此外，元字符点&quot;.&quot;不能匹配多行模式下的换行符。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(注：在单行模式下，使用M和不使用M是没有区别的，但在多行模式下各符号匹配的位置将和通常的正则表达式元字符匹配的内容不同，各符号的匹配位置如下图所示)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'0,/REGEXP/'&lt;/strong&gt;:使用行号0作为起始地址也是支持的，就像此处的&quot;0,/REGEXP/&quot;，这时sed会尝试对第一行就匹配REGEXP。换句话说，&quot;0,/REGEXP/&quot;和&quot;1,/REGEXP/&quot;基本是相同的。但以行号0作为起始行时，如果第一行就能被ADDR2匹配，范围搜索立即就结束，因为第二个地址已经搜索到了；如果以行号1作为起始行，会从第二行开始匹配ADDR2，直到匹配成功。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'ADDR1,+N'&lt;/strong&gt;:匹配ADDR1和其后的N行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;'ADDR1,~N'&lt;/strong&gt;:匹配ADDR1和其后的行直到出现N的倍数行，倍数可为随意整数倍。 (注：可以是任意倍，只要N的倍数是最接近且大于ADDR1的即可。如ADDR1=1,N=3匹配1到3行，ADDR1=5,N=4匹配5-8行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：sed采用计数器计算，每读取一行，计数器加1，直到最后一行。因此在读到最后一行前，sed是不知道这次输入流中总共有多上行，也不知道最后一行是第几行。&quot;$&quot;符号表示最后一行，它只是一个特殊的标识符号。当sed读取到输入流的尾部时，sed就会为该行打上该标记。无法使用&quot;$&quot;参与数学运算，例如无法使用$-1表示倒数第二行，因为sed在读到最后一行前，它并不知道这是倒数第二行，此时也还没打&quot;$&quot;标记，因此$-1是错误的定址表达式。另一方面，sed只能通过一次输入流，这意味着已经读取过的行无法再次被读取，所以sed不提供往回取数据的定址表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用的正则匹配模式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;^ 匹配行开始，如：/^sed/&lt;span&gt;匹配所有以sed开头的行;
 $ 匹配行结束，如：&lt;/span&gt;/sed$/&lt;span&gt;匹配所有以sed结尾的行;
 . 匹配一个非换行符的任意字符，如：&lt;/span&gt;/s.d/&lt;span&gt;匹配s后接一个任意字符，最后是d;
 &lt;/span&gt;* 匹配0个或多个字符，如：&lt;span&gt;/*sed/匹配所有模板是一个或多个空格后紧跟sed的行;
 [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed;
 [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行;
 \(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers;
 &amp;amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;amp;**/，love这成**love**;
 \&amp;lt; 匹配单词的开始，如:/&lt;/span&gt;&lt;span&gt;\ 
 \&lt;/span&gt;&amp;gt; 匹配单词的结束，如/love\&amp;gt;/&lt;span&gt;匹配包含以love结尾的单词的行;
 x\{m\} 重复字符x，m次，如：&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;\{&lt;span&gt;5&lt;/span&gt;\}/&lt;span&gt;匹配包含5个0的行;
 x\{m,\} 重复字符x，至少m次，如：&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;\{&lt;span&gt;5&lt;/span&gt;,\}/&lt;span&gt;匹配至少有5个0的行;
 x\{m,n\} 重复字符x，至少m次，不多于n次，如：&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;\{&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;\}/匹配5~10个0的行;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实例 ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed -n &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,3p test.txt #输出1-3行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-&lt;span&gt;n 1p test.txt #输出第一行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;1&lt;/span&gt;,/On/&lt;span&gt;p test.txt #输出第一行到匹配到On字符串的行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;1&lt;/span&gt;,/[a-z]*ing/&lt;span&gt;p test.txt #输出第一行到匹配到ing字符串的行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-r -n &lt;span&gt;1&lt;/span&gt;,/[a-z]*ing/&lt;span&gt;p test.txt
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-r -n &lt;span&gt;1&lt;/span&gt;,+&lt;span&gt;2p test.txt #输出从第一行开始以及后两行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;1&lt;/span&gt;,~&lt;span&gt;2p test.txt #从第一行开始输出到2的倍数行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;3&lt;/span&gt;,~&lt;span&gt;2p test.txt #从第3行开始输出到2的倍数行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;1&lt;/span&gt;~&lt;span&gt;2p test.txt #输出从第一行开始，步长为的2的行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n /on/I,/with/&lt;span&gt;Ip test.txt #输出匹配on到with的行，忽略大小写
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们知道匹配到我们需要操作的行的时候，开始进行我们需要的操作，请继续看下文&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、常用命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;常用命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;a 在当前行下面插入文本;
i 在当前行上面插入文本;
c 把选定的行改为新的文本;
d 删除，删除选择的行;
D 删除模板块的第一行;
s 替换指定字符;
h 拷贝模板块的内容到内存中的缓冲区;
H 追加模板块的内容到内存中的缓冲区;
g 获得内存缓冲区的内容，并替代当前模板块中的文本;
G 获得内存缓冲区的内容，并追加到当前模板块文本的后面;
l 列表不能打印字符的清单;
n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令;
N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码;
p 打印模板块的行。 P(大写) 打印模板块的第一行;
q 退出Sed;
b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾;
r file 从file中读行;
t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾;
T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾;
w file 写并追加模板块到file末尾;
W file 写并追加模板块的第一行到file末尾;
&lt;/span&gt;!&lt;span&gt; 表示后面的命令对所有没有被选定的行发生作用;
&lt;/span&gt;=&lt;span&gt; 打印当前行号;
# 把注释扩展到下一个换行符以前;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1、强制输出命令p&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下sed会输出所有的行，使用-n可以禁用默认的输出，然后使用p指定自己想输出的行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed &lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;,2p test.txt&lt;/strong&gt; &lt;strong&gt; #没事使用-n，所以1,2行重复答应，两种输出模式不冲突
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@lghtest]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,2p test.txt  #输出1,2行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;。 Saturday afternoon，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、删除命令d&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令&quot;d&quot;用于删除整个模式空间中的内容，并立即退出当前SCRIPT循环，进入下一个sed循环，即读取下一行 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed &lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;,5d test.txt  #删除第3行到第5行的数据
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;。 Saturday afternoon，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改test.txt内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash
#test
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lghtest]# &lt;strong&gt;sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/^#/{1!d}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #删除以#开头的行，第一行例外&lt;/strong&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果&quot;d&quot;后面还有命令，在删除模式空间后，这些命令不会执行，因为会立即退出当前SCRIPT循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、退出命令q或者Q&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;q&quot;和&quot;Q&quot;命令的作用是立即退出当前sed程序，使其不再执行后面的命令，也不再读取后面的行。因此，在处理大文件或大量文件时，使用&quot;q&quot;或&quot;Q&quot;命令能提高很大效率。它们之间的不同之处在于&quot;q&quot;命令被执行后还会使用自动输出动作输出模式空间的内容，除非使用了&quot;-n&quot;选项。而&quot;Q&quot;命令则会立即退出，不会输出模式空间内容。另外，可以为它们指定退出状态码，例如&quot;q 1&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #输出钱3行，类似 head -3&lt;/strong&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;bash
#test
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/[a-z]*ing/{p;q}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #找到一条ing的字符串，输出并退出
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;。 Saturday afternoon，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、输出行号=&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;=&quot;命令用于输出最近被读取行的行号。在sed内部，使用行号计数器进行行号计数，每读取一行，行号计数器加1。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/[a-z]*ing/{p;=;q}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #找到一条ing的字符串，输出行并输出行号，然后退出
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、字符一一对应替换命令&quot;y&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该命令和&quot;tr&quot;命令的映射功能一样，都是将字符进行一一替换&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lghtest]# &lt;strong&gt;sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y/ing/ING/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #把文档中的ing一一对应替换成ING&lt;/strong&gt;
#&lt;/span&gt;!/bIN/&lt;span&gt;bash
#test
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekeNd， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、ON Saturday morNING， my classmate aNd I had Math &lt;strong&gt;traINING&lt;/strong&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afterNooN，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I dId my homework aNd watched TV。 ON SuNday &lt;strong&gt;morNING&lt;/strong&gt; ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I weNt to HaNG zhou MeteorolGIcal ExperIeNce Hall wIth my famIly。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fuN 。I had a very happy weekeNd。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6、&lt;strong&gt;读取下一行命令&quot;n&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在sed的循环过程中，每个sed循环的第一步都是读取输入流的下一行到模式空间中，这是我们无法控制的动作。但sed有读取下一行的命令&quot;n&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/[a-z]*ing/{p;n;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #输出匹配到ing字符串的一行和下一行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/[a-z]*ing/{p;n;n;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #输出匹配到ing字符串的一行和下下行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、替换命令s&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令格式：s/REGEXP/REPLACEMENT/FLAGS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能就是替换，首先需要匹配，然后再替换，常用的选项如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;g 表示行内全面替换;
p 表示打印行;
\&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 子串匹配标记;
&lt;/span&gt;&amp;amp; 已匹配字符串标记;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改test.txt的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash
#test test1 test2 test3
#test4 test5 test6 test7
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]#&lt;strong&gt; sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/test/TEST/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #替换并打印，默认替换第一列&lt;/strong&gt;
#TEST test1 test2 test3
#TEST4 test5 test6 test7
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/test/TEST/gp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #全局替换&lt;/strong&gt;
#TEST TEST1 TEST2 TEST3
#TEST4 TEST5 TEST6 TEST7
[root@lgh test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/test/TEST/2p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #指定列替换&lt;/strong&gt;
#test TEST1 test2 test3
#test4 TEST5 test6 test7&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@lgh test]# &lt;strong&gt;sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5,$s/ing/***&amp;amp;***/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #给匹配到的字符串添加*
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morn***ing***， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;、I did my homework and watched TV。 On Sunday morn***ing***&lt;span&gt; ，
[root@lgh test]#&lt;strong&gt; sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5,$s/^/#/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #在第5行到最后一行添加注释&lt;/strong&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
#&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@mvxl2685 test]# &lt;strong&gt;echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cmd1 &amp;amp;&amp;amp; cmd2 || cmd3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s%&amp;amp;&amp;amp;\(.*\)||\(.*\)%\&amp;amp;\&amp;amp;\2||\1%&lt;/span&gt;&lt;span&gt;' #cmd1 &amp;amp;&amp;amp; cmd2 || cmd3&quot;的cmd2和cmd3命令对调个位置&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
cmd1 &lt;/span&gt;&amp;amp;&amp;amp; cmd3|| cmd2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、追加（a）、插入（i）、修改（c）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三种格式是&quot;[a|i|c] TEXT&quot;，表示将TEXT内容队列化到内存中，当有输出流或者说有输出动作的时候，半路追上输出流，分别追加、插入和替换到该输出流然后输出。追加是指追加在输出流的尾部，插入是指插入在输出流的首部，替换是指将整个输出流替换掉。&quot;c&quot;命令和&quot;a&quot;、&quot;i&quot;命令有一丝不同，它替换结束后立即退出当前SCRIPT循环，并进入下一个sed循环，因此&quot;c&quot;命令后的命令都不会被执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@mvxl2685 test]# &lt;strong&gt;sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ing/a good job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #在匹配行后面追加&lt;/strong&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;bash
#test test1 test2 test3
#test4 test5 test6 test7
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
good job
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
good job
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ing/i good job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #在匹配行前面插入&lt;/strong&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;bash
#test test1 test2 test3
#test4 test5 test6 test7
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
good job
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
good job
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ing/c good job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt #修改匹配行&lt;/strong&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;bash
#test test1 test2 test3
#test4 test5 test6 test7
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
good job
good job
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、多行模式命令&quot;N&quot;、&quot;D&quot;、&quot;P&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&quot;N&quot;命令：读取下一行内容追加到模式空间的尾部。其和&quot;n&quot;命令不同之处在于：&quot;n&quot;命令会输出模式空间的内容(除非使用了&quot;-n&quot;选项)并&lt;strong&gt;清空模式空间&lt;/strong&gt;，然后才读取下一行到模式空间，也就是说&quot;n&quot;命令虽然读取了下一行到模式空间，但模式空间仍然是单行数据。而&quot;N&quot;命令在读取下一行前，虽然也有自动输出和清空模式空间的动作，但该命令会把当前模式空间的内容锁住，使得自动输出的内容为空，也无法清空模式空间，然后读取下一行追加到当前模式空间中的尾部。追加时，原有内容和新读取内容使用换行符&quot;\n&quot;分隔，这样在模式空间中就实现了多行数据。即所谓的&quot;多行模式&quot;。 另外，当无法读取到下一行时(到了文件尾部)，将直接退出sed程序，使得&quot;N&quot;命令后的命令不会再执行，这和&quot;n&quot;命令是一样的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;D&quot;命令：删除模式空间中第一个换行符&quot;\n&quot;之前的内容，然后立即回到SCRIPT循环的顶端，即进入下一个SCRIPT循环。如果&quot;D&quot;删除后，模式空间中已经没有内容了，则SCRIPT循环自动退出进入下一个sed循环；如果模式空间还有剩余内容，则继续从头执行SCRIPT循环。也就是说，&quot;D&quot;命令后的命令不会被执行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;P&quot;命令：输出模式空间中第一个换行符&quot;\n&quot;之前的内容&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[root@mvxl2685 test]# &lt;strong&gt;cat test.txt #查看文件内容
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; test.txt&lt;/strong&gt; &lt;br/&gt;&lt;strong&gt;#首先把第一行加载到模式空间，然后执行n，把第二行加载到模式空间，覆盖了第一条，然后执行p进行打印，输出第2条数据，继续自动加载第3条到模式空间，执行n，加载第4条覆盖第3条，输出第4条
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。&lt;/span&gt;&lt;span&gt;
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;N;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt&lt;br/&gt;#加载第一条到模式空间，执行N，把第2条也加载进去，执行p，一起答应两条，然后接着加载3，N命令加载4，p打印两条，接着加载5，N命令执行为空，到了尾部，直接结束sed命令
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$!N;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt&lt;br/&gt;#加载第一条到模式空间，执行N，把第2条也加载进去，执行p，一起答应两条，然后接着加载3，N命令加载4，p打印两条，接着加载5，到了尾部，跳过N命令，执行p，打印第5条
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$!N;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt&lt;br/&gt;#加载第一条到模式空间，执行N，把第2条也加载进去，执行P，这里只打印\n前的数据，也就是第一条，然后接着加载3，覆盖模式空间，N命令加载4，P打印第3条，接着加载5，到了尾部，跳过N命令，执行P，打印第5条
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、Last weekend， I was busy。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;N;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt&lt;br/&gt;#加载第一条到模式空间，执行N，加载第二条到模式空间，D删除\n前面的数据，保留第二条，然后加载第三条，删除第二条，依次类推，
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;5&lt;/span&gt;、It was fun 。I had a very happy weekend。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@mvxl2685 test]# &lt;strong&gt;sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/{N;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #打印匹配行以及下一行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/{N;s/\n//;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt  #合并两行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;。 Saturday afternoon，&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/{N;s/\n//p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt #合并两行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;。 Saturday afternoon，&lt;span&gt;3&lt;/span&gt;、I did my homework and watched TV。 On Sunday morning ，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10、buffer空间数据交换命令&quot;h&quot;、&quot;H&quot;、&quot;g&quot;、&quot;G&quot;、&quot;x&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sed除了维护模式空间(pattern space)，还维护另一个buffer空间：保持空间(hold space)。这两个空间初始状态都是空的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;绝大多数时候，sed仅依靠模式空间就能达到目的，但有些复杂的数据操作则只能借助保持空间来实现。之所以称之为保持空间，是因为它是暂存数据用的，除了仅有的这几个命令外，没有任何其他命令可以操作该空间，因此借助它能实现数据的持久性。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;保持空间的作用很大，它和模式空间之间的数据交换能实现很多看上去不能实现的功能，是实现sed高级功能所必须的，常用的几个命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&quot;h&quot;命令：将当前模式空间中的内容覆盖到保持空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;H&quot;命令：在保持空间的尾部加上一个换行符&quot;\n&quot;，并将当前模式空间的内容追加到保持空间的尾部。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;g&quot;命令：将保持空间的内容覆盖到当前模式空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;G&quot;命令：在模式空间的尾部加上一个换行符&quot;\n&quot;，并将当前保持空间的内容追加到模式空间的尾部。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;x&quot;命令：交换模式空间和保持空间的内容。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意，无论是交换、追加还是覆盖，原空间的内容都不会被删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 可能理解起来不是很好理解，画个图就轻松易懂了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202011/1271254-20201120145110508-344795460.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;254&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@mvxl2685 test]# &lt;strong&gt;sed -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  test.txt #打印匹配的行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/{h;n;G;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  test.txt #打印匹配的行和下一行，并交换位置
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
[root@mvxl2685 test]# &lt;strong&gt;sed &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/training/{h;G;p}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  test.txt #两次打印匹配的行
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@mvxl2685 test]#&lt;strong&gt; sed  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1!G;h;$!d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; test.txt  #逆序打印文件
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;、It was fun 。I had a very happy weekend。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;、I went to Hang zhou Meteorolgical Experience Hall with my family。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;、I did my homework and watched TV。 On Sunday morning ，
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、On Saturday morning， my classmate and I had Math training &lt;span&gt;class&lt;/span&gt;&lt;span&gt;。 Saturday afternoon，
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;、Last weekend， I was busy。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;逆序打印思路如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202011/1271254-20201120151209338-860609223.png&quot; alt=&quot;&quot; width=&quot;796&quot; height=&quot;369&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考地址&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7478188.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7478188.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7488469.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7488469.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.linuxprobe.com/linux-sed-command.html&quot;&gt;https://www.linuxprobe.com/linux-sed-command.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_38149264/article/details/78074300&quot;&gt;https://blog.csdn.net/weixin_38149264/article/details/78074300&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/yangbin1265712/article/details/82994666&quot;&gt;https://blog.csdn.net/yangbin1265712/article/details/82994666&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Nov 2020 12:42:00 +0000</pubDate>
<dc:creator>一寸HUI</dc:creator>
<og:description>一、sed介绍 sed是Stream Editor（字符流编辑器）的缩写，简称流编辑器。sed是操作、过滤和转换文本内容的强大工具。常用功能包括对文件实现快速增删改查（增加、删除、修改、查询），其中查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zsql/p/14007099.html</dc:identifier>
</item>
<item>
<title>07 . 前端工程化(ES6模块化和webpack打包css,less,scss,图片,字体,配置Vue组件加载器和发布项目) - 常见-youmen</title>
<link>http://www.cnblogs.com/you-men/p/14012921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/14012921.html</guid>
<description>&lt;h4 id=&quot;模块化规范&quot;&gt;模块化规范&lt;/h4&gt;
&lt;h5 id=&quot;传统开发模式主要问题&quot;&gt;传统开发模式主要问题&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. 命名冲突
                2. 文件依赖
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通过模块化解决上述问题&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                模块化就是把单独的一个功能封装在一个模块(文件)中,模块之间相互隔离,
                        但是可以通过特定的接口公开内部成员,也可以依赖别的模块.
                
                模块化开发好处:
                                方便代码的重用,从而提高开发效率,并且方便后期的维护
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;浏览器模块化规范&quot;&gt;浏览器模块化规范&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                AMX   (Require.js)
                CMD             (Sea.js)
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;服务器端模块化规范&quot;&gt;服务器端模块化规范&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                CommonJS
                                1.模块分文单文件模块与包
                                2.模块成员导出: module.exports和exports
                                3.模块成员导入: require('模块标识符')
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6模块化&quot;&gt;ES6模块化&lt;/h4&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;在ES6模块化规范之前,Javascript社区已经尝试并提出了AMD,CMD,CommonJS等模块化规范.&lt;/p&gt;
&lt;p&gt;但是,这些社区提出的模块化标准还是存在一定的差异性与局限性,并不是浏览器与服务器通用的模块化标准,例如:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                AMD和CMD适用于浏览器端的JavaScript模块化
                CommonnJS适用于服务器端的JavaScript模块化
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;因此,在ES6语法规范中,在语言层面上定义了ES6模块化规范,是浏览器与服务器端通用的模块化开发规范.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ES6模块化规范中定义&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. 每个js文件都是一个独立的模块
                2. 导入模块成员使用import关键字
                3. 暴露模块成员使用export关键字
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;推荐使用ES6模块化，因为AMD，CMD局限使用与浏览器端，而CommonJS在服务器端使用。 ES6模块化是浏览器端和服务器端通用的规范.&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;nodejs通过babel体验es6模块化&quot;&gt;Node.js通过babel体验ES6模块化&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;1.安装babel&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-node&quot;&gt;npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
npm install --save @babel/polyfill
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;2.创建babel.config.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在项目目录中创建babel.config.js文件。&lt;/code&gt;&lt;br/&gt;&lt;code&gt;编辑js文件中的代码如下&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;        const presets = [
            [&quot;@babel/env&quot;,{
                targets:{
                    edge:&quot;17&quot;,
                    firefox:&quot;60&quot;,
                    chrome:&quot;67&quot;,
                    safari:&quot;11.1&quot;
                }
            }]
        ]
        //暴露
        module.exports = { presets }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;3.创建index.js文件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                在项目目录中创建index.js文件作为入口文件
    在index.js中输入需要执行的js代码，例如：
        console.log(&quot;ok&quot;);
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;4.使用npx执行文件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;打开终端，输入命令：npx babel-node ./index.js&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;默认导出&quot;&gt;默认导出&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认导出语法为export default 默认导出的成员&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;    export default {
        成员A,
        成员B,
        .......
    },如下：
    let num = 100;
    export default{
        num
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Example1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;// 当前文件模块为m1.js

// 定义私有成员a和c
let a = 10
let c = 20
let d = 30

// 外界访问不到变量b,因为他没有被暴露出去
function show() {
    console.log('1111')
}


// 将本模块的私有成员暴露出去,供其他模块使用
export default {
    a,
    c,
    show
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;默认导入&quot;&gt;默认导入&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认导入语法import 接受名称 from '模块标识符'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;// 导入模块成员
import m1 from './m1/m1.js'

console.log(m1)

// 打印输出的结果为:
youmen@bogon Vue_Student_Demo % npx babel-node ./index.js
{ a: 10, c: 20, d: 30, show: [Function: show] }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意: 每个模块中,只允许使用唯一的一次export default,否则会报错&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;按需导出&quot;&gt;按需导出&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;按需导出语法&lt;/p&gt;
&lt;p&gt;Export let s1 = 10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;    export let num = 998;
    export let myName = &quot;jack&quot;;
    export function fn = function(){ console.log(&quot;fn&quot;) }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;// 当前文件模块为m1.js

// 向外按需导出变量为s1
export let s1 = 'aaa'

// 向外按需导出变量为s2
export let s2 = 'ccc'

// 向外按需导出方法 say
export function say = function() {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;按需导入&quot;&gt;按需导入&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;按需导入语法&lt;/p&gt;
&lt;p&gt;Import { s1 } from '模块标识符'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;    import { num,fn as printFn ,myName } from &quot;./test.js&quot;
    // 同时导入默认导出的成员以及按需导入的成员
    import test,{ num,fn as printFn ,myName } from &quot;./test.js&quot;
// 注意：一个模块中既可以按需导入也可以默认导入，一个模块中既可以按需导出也可以默认导出
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Example1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;// 导入模块成员
import {  s1,s2 as ss2, say } from './m1.js'

console.log(s1)  // 打印输出aaa
console.log(s2)  // 打印输出ccc
console.log(say) // 打印输出[Function: say]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;直接导入并执行代码&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;有时候,我们&lt;code&gt;只想单纯执行某个模块的代码,并不需要得到模块中向外暴露的成员&lt;/code&gt;,此时,可以直接导入并执行模块代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;import &quot;./test2.js&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;m1.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;// 当前文件模块为m2.js

// 在当前模块中执行一个for循环操作
for(let i=0;i&amp;lt;3;i++){
        console.log(i)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;webpack概念&quot;&gt;Webpack概念&lt;/h4&gt;
&lt;h5 id=&quot;当前web开发面临的困境&quot;&gt;当前Web开发面临的困境&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                文件依赖关系错综复杂
                静态资源请求效率低
                模块化支持不友好
                浏览器对高级JavaScript特性兼容程度较低
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;webpack是一个流行的前端项目构建工具，可以解决目前web开发的困境。&lt;br/&gt;webpack提供了模块化支持，代码压缩混淆，解决js兼容问题，性能优化等特性，提高了开发效率和项目的可维护性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201120144829266-1263163619.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;webpack的基本使用&quot;&gt;WebPack的基本使用&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
        1.创建列表隔行变色项目
     新建项目空白目录,并运行npm init -y 命令, 初始化包管理配置文件package.json

  2.新建src源代码目录

  3.新建src/index.html首页
  
  4. 初始化首页基本结构
  
  5. 运行 npm install jquery -s 命令,安装jQuery
                导入jQuery
        打开index.js文件，编写代码导入jQuery并实现功能：
        import $ from &quot;jquery&quot;;
        $(function(){
            $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;cyan&quot;);
            $(&quot;li:odd&quot;).css(&quot;background&quot;,&quot;pink&quot;);
        })
  
  6. 通过模块化形式,实现列表隔行变色效果
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意：此时项目运行会有错误，因为import $ from &quot;jquery&quot;;这句代码属于ES6的新语法代码，在浏览器中可能会存在兼容性问题 所以我们需要webpack来帮助我们解决这个问题。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;项目中配置webpack&quot;&gt;项目中配置webpack&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*       
                1).打开项目目录终端，输入命令:
        npm install webpack webpack-cli -D
    
    2).然后在项目根目录中，创建一个 webpack.config.js 的配置文件用来配置webpack
        在 webpack.config.js 文件中编写代码进行webpack配置，如下：
        module.exports = {
            mode:&quot;development&quot;//可以设置为development(开发模式)，production(发布模式)
        }
        补充：mode设置的是项目的编译模式。
        如果设置为development则表示项目处于开发阶段，不会进行压缩和混淆，打包速度会快一些

        如果设置为production则表示项目处于上线发布阶段，会进行压缩和混淆，打包速度会慢一些
   
    3).修改项目中的package.json文件添加运行脚本dev，如下：
        &quot;scripts&quot;:{
            &quot;dev&quot;:&quot;webpack&quot;
        }
        注意：scripts节点下的脚本，可以通过 npm run 运行，如：
        运行终端命令：npm run dev
        将会启动webpack进行项目打包
    
    4).运行dev命令进行项目打包，并在页面中引入项目打包生成的js文件
        打开项目目录终端，输入命令:
        npm run dev
        等待webpack打包完毕之后，找到默认的dist路径中生成的main.js文件，将其引入到html页面中。
        浏览页面查看效果。
*/      
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;设置webpack的打包入口出口&quot;&gt;设置Webpack的打包入口/出口&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                  在webpack 4.x中.
          默认会将src/index.js 作为默认的打包入口js文件
          默认会将dist/main.js 作为默认的打包输出js文件
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果不想使用默认的入口/出口js文件，我们可以通过改变 webpack.config.js 来设置入口/出口的js文件，如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;    const path = require(&quot;path&quot;);  // 导入node.js中专门操作路径的模块
    module.exports = {
        mode:&quot;development&quot;,
        // 设置入口文件路径
        entry: path.join(__dirname,&quot;./src/xx.js&quot;),

        //设置出口文件
        output:{
            //设置输出文件路径
            path:path.join(__dirname,&quot;./dist&quot;),
            //设置输出文件名称
            filename:&quot;res.js&quot;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;webpack的自动打包&quot;&gt;Webpack的自动打包&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. 运行npm install webpack-dev-server -D 命令,安装支持项目自动打包的工具
                
                2. 修改package.json  --&amp;gt; scripts中的dev命令如下
                                &quot;scripts&quot;: {
                                                &quot;dev&quot;: &quot;webpack-dev-server&quot;  // script节点下的脚本,可以通过npm run执行
                                }
                                
                3. 将src --&amp;gt; index.html中,script脚本的引用路径,修改为 &quot;/buldle.js&quot;
                
                4. 运行npm run dev命令, 重新进行打包
                
                5. 浏览器中访问http://localhost:8080地址,查看自动打包效果
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                webpack-dev-server   会启动一个实时打包的http服务器
                webpack-dev-server       打包生成的输出文件,默认放到了项目根目录中,而且是虚拟机的,看不见的
                在自动打包完毕之后，默认打开服务器网页，实现方式就是打开package.json文件，修改dev命令：
    &quot;dev&quot;: &quot;webpack-dev-server --open --host 127.0.0.1 --port 9999&quot;
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置默认预览页面&quot;&gt;配置默认预览页面&lt;/h5&gt;
&lt;blockquote readability=&quot;5.9057591623037&quot;&gt;
&lt;p&gt;使用html-webpack-plugin 可以生成一个预览页面。&lt;br/&gt;因为当我们访问默认的 &lt;a href=&quot;http://localhost:8080/%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AF%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E6%83%B3%E8%A6%81%E6%9F%A5%E7%9C%8B%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B5%E9%9D%A2&quot;&gt;http://localhost:8080/的时候，看到的是一些文件和文件夹，想要查看我们的页面&lt;/a&gt;&lt;br/&gt;还需要点击文件夹点击文件才能查看，那么我们希望默认就能看到一个页面，而不是看到文件夹或者目录。&lt;br/&gt;实现默认预览页面功能的步骤如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;      A.安装默认预览功能的包:html-webpack-plugin
          npm install html-webpack-plugin -D
      B.修改webpack.config.js文件，如下：
          //导入包
          const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
          //创建对象
          const htmlPlugin = new HtmlWebpackPlugin({
              //设置生成预览页面的模板文件
              template:&quot;./src/index.html&quot;,
              //设置生成的预览页面名称,该文件存在于内存中,在目录中不显示
              filename:&quot;index.html&quot;
          })
      C.继续修改webpack.config.js文件中向外暴露的配置对象，添加plugins信息：
          module.exports = {
              ......
              plugins:[ htmlPlugin ]
                                                // plugins数组是webpack打包期间会用到的一些插件列表
          }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;webpack中的加载器&quot;&gt;Webpack中的加载器&lt;/h4&gt;
&lt;h5 id=&quot;通过loader打包非js模块&quot;&gt;通过loader打包非js模块&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过loader打包非js模块：默认情况下，webpack只能打包js后缀名结尾的文件，如果想要打包非js文件，需要调用loader加载器才能打包.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Loader加载器包含&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    1).less-loader:  处理.less相关文件
    2).sass-loader:  处理.scss相关文件
    3).url-loader:  打包处理css中与url路径有关的文件
    4).babel-loader:处理高级js语法的加载器
    5).postcss-loader
    6).css-loader,style-loader
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;loader调用过程&quot;&gt;loader调用过程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201120164512380-1345353585.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;webpack中加载器的基本使用&quot;&gt;webpack中加载器的基本使用&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;打包处理css文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                运行npm i style-loader css-loader -D 命令, 安装处理的css文件的loader
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;2. 在webpack.config.js的module --&amp;gt; rules 数组中,添加loader规则如下&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;//  所有第三方文件模块的匹配规则
        module: {
                rules: [
                        { test: /\.css$/,use: ['style-loader','css-loader'] }
                ]
        }

// 其中, test表示匹配的文件类型, use表示对应要调用的loader
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                use数组中指定的loader顺序是固定的.
                多个loader的调用顺序是: 从后往前调用
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;处理less文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;1).安装包
    npm install less-loader less -D
2).配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
        // 编译模式
        mode: 'development', // development  production
        entry: path.join(__dirname, './src/index.js'),
        output: {
                path: path.join(__dirname, './dist'), // 输出文件的存放路径
                filename: 'bundle.js' // 输出文件的名称
        },
        plugins: [htmlPlguin],
        module: {
                rules: [
                        { test: /\.css$/,use: ['style-loader','css-loader'] },
                        { test: /\.less$/,use: ['style-loader','css-loader','less-loader' ]}
                ]
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打包处理scss文件&quot;&gt;打包处理scss文件&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;npm i sass-loader node-sass -D

// 在webpack.connfig.js的module-&amp;gt;rules数组中,添加loader规则如下
module: {
  rules: {
    { test: /\.scss$/,use: ['style-loader','css-loader','sass-loader'] }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置postcss自动添加css的兼容前缀&quot;&gt;配置postcss自动添加css的兼容前缀&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;1).安装包
    npm install postcss-loader autoprefixer -D
2).在项目根目录创建并配置postcss.config.js文件
const autoprefixer = require(&quot;autoprefixer&quot;);
module.exports = {
    plugins:[ autoprefixer ]
}
3).配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
    ......
    plugins:[ htmlPlugin ],
    module : {
        rules:[
            {
                //test设置需要匹配的文件类型，支持正则
                test:/\.css$/,
                //use表示该文件类型需要调用的loader
                use:['style-loader','css-loader','postcss-loader']
            },
            {
                test:/\.less$/,
                use:['style-loader','css-loader','less-loader']
            },
            {
                test:/\.scss$/,
                use:['style-loader','css-loader','sass-loader']
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打包样式表中的图片以及字体文件&quot;&gt;打包样式表中的图片以及字体文件&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 在样式表css中有时候会设置背景图片和设置字体文件，一样需要loader进行处理
// 使用url-loader和file-loader来处理打包图片文件以及字体文件
1).安装包
    npm install url-loader file-loader -D
2).配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
    ......
    plugins:[ htmlPlugin ],
    module : {
        rules:[
            {
                //test设置需要匹配的文件类型，支持正则
                test:/\.css$/,
                //use表示该文件类型需要调用的loader
                use:['style-loader','css-loader']
            },
            {
                test:/\.less$/,
                use:['style-loader','css-loader','less-loader']
            },
            {
                test:/\.scss$/,
                use:['style-loader','css-loader','sass-loader']
            },{
                test:/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/,
                //limit用来设置字节数，只有小于limit值的图片，才会转换
                //为base64图片
                use:&quot;url-loader?limit=16940&quot;
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打包js高级语法&quot;&gt;打包js高级语法&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    在编写js的时候，有时候我们会使用高版本的js语法
    有可能这些高版本的语法不被兼容，我们需要将之打包为兼容性的js代码
    我们需要安装babel系列的包
    A.安装babel转换器
        npm install babel-loader @babel/core @babel/runtime -D
    B.安装babel语法插件包
        npm install @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D
    C.在项目根目录创建并配置babel.config.js文件
*/
    
    module.exports = {
        presets:[&quot;@babel/preset-env&quot;],
        plugins:[ &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-proposal-class-properties&quot; ]
    }
//   D.配置规则：更改webpack.config.js的module中的rules数组
module.exports = {
        // 编译模式
        mode: 'development', // development  production
        entry: path.join(__dirname, './src/index.js'),
        output: {
                path: path.join(__dirname, './dist'), // 输出文件的存放路径
                filename: 'bundle.js' // 输出文件的名称
        },
        plugins: [htmlPlguin],
        module: {
                rules: [
                  { test: /\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] },
                  { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },
                  { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] },
                  { test: /\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, use: 'url-loader?limit=16941' },
                  { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ }
                ]
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;vue单文件组件&quot;&gt;Vue单文件组件&lt;/h4&gt;
&lt;h5 id=&quot;传统vue组件的缺陷&quot;&gt;传统Vue组件的缺陷&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;全局定义的组件不能重名，字符串模板缺乏语法高亮，不支持css(当html和js组件化时，css没有参与其中) 没有构建步骤限制，只能使用H5和ES5，不能使用预处理器（babel）&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;解决方案&quot;&gt;解决方案&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                使用Vue单文件组件，每个单文件组件的后缀名都是.vue
      每一个Vue单文件组件都由三部分组成
      1).template  组件组成的模板区域
      2).script   组成的业务逻辑区域
      3).style  样式区域
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
    组件代码区域
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    js代码区域
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
    样式代码区域
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;安装Vetur插件可以使得.vue文件中的代码高亮&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;配置vue文件的加载器&quot;&gt;配置.vue文件的加载器&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// A.安装vue组件的加载器
    npm install vue-loader vue-template-compiler -D
// B.配置规则：更改webpack.config.js的module中的rules数组
    const VueLoaderPlugin = require(&quot;vue-loader/lib/plugin&quot;);
    const vuePlugin = new VueLoaderPlugin();
    module.exports = {
        ......
        plugins:[ htmlPlugin, vuePlugin  ],
        module : {
            rules:[
                ...//其他规则
                { 
                    test:/\.vue$/,
                    loader:&quot;vue-loader&quot;,
                }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;webpack中使用vue&quot;&gt;Webpack中使用Vue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;想要让vue单文件组件能够使用，我们必须要安装vue并使用vue来引用vue单文件组件。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    A.安装Vue
        npm install vue -S
    B.在index.js中引入vue：import Vue from &quot;vue&quot;
    C.创建Vue实例对象并指定el，最后使用render函数渲染单文件组件
        const vm = new Vue({
            el:&quot;#first&quot;,
            render:h=&amp;gt;h(app)
        })
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;webpack打包发布项目&quot;&gt;Webpack打包发布项目&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;在项目上线之前，我们需要将整个项目打包并发布&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                A.配置package.json
    &quot;scripts&quot;:{
        &quot;dev&quot;:&quot;webpack-dev-server&quot;,
        &quot;build&quot;:&quot;webpack -p&quot;
    }
                B.在项目打包之前，可以将dist目录删除，生成全新的dist目录       
*/
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Nov 2020 12:40:00 +0000</pubDate>
<dc:creator>常见-youmen</dc:creator>
<og:description>模块化规范 传统开发模式主要问题 /* 1. 命名冲突 2. 文件依赖 */ 通过模块化解决上述问题 /* 模块化就是把单独的一个功能封装在一个模块(文件)中,模块之间相互隔离, 但是可以通过特定的接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/14012921.html</dc:identifier>
</item>
</channel>
</rss>