<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>黑科技抢先尝(续2) - Windows terminal中Powershell Tab的极简美化指南 - dotNET匠人</title>
<link>http://www.cnblogs.com/enjoy233/p/simple_guide_to_beautify_powershells_in_Windows_Terminal.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/simple_guide_to_beautify_powershells_in_Windows_Terminal.html</guid>
<description>&lt;p&gt;接着昨天的文章 &lt;a href=&quot;https://www.cnblogs.com/enjoy233/p/simple_guide_to_WSL_terminals_in_Windows_Terminal.html&quot;&gt;黑科技抢先尝(续) - Windows terminal中WSL Linux 终端的极简美化指南&lt;/a&gt;，&lt;br/&gt;依然假定你安装好了windows terminal预编译版本。&lt;/p&gt;
&lt;p&gt;这次我的&lt;strong&gt;目标&lt;/strong&gt;是将PowerShell美化成下面这样，并在命令提示符中加入&lt;code&gt;Emoji&lt;/code&gt;表情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205114269-817966536.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装python&quot;&gt;安装python&lt;/h2&gt;
&lt;p&gt;由于本文主要是针对Windows terminal上的&lt;code&gt;Powershell Tab&lt;/code&gt;来写，自然是需要使用 windows 10 1903版本的。那此时安装&lt;code&gt;Python&lt;/code&gt;的方法即在&lt;code&gt;Window store&lt;/code&gt;中搜索&lt;code&gt;Python&lt;/code&gt;，购买、安装即可，默认安装上的应该是Python 3.7。&lt;/p&gt;
&lt;p&gt;当然，你也可以去&lt;code&gt;python&lt;/code&gt;官网上下载安装包后进行安装~&lt;/p&gt;
&lt;p&gt;而在后续使用&lt;code&gt;pip&lt;/code&gt;命令的过程中，经常会出现如下提示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;You are using pip version 19.0.3, however version 19.1.1 is available.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;升级 pip&lt;/strong&gt;&lt;br/&gt;这说明我们该升级&lt;code&gt;pip&lt;/code&gt;的版本了，完美解决的解决方法为：输入如下命令&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;pip install --user --upgrade pip&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装git&quot;&gt;安装git&lt;/h2&gt;
&lt;p&gt;安装好git，并保证&lt;code&gt;git&lt;/code&gt;的系统变量没问题，cmd或 PowerShell 中输入&lt;code&gt;git&lt;/code&gt;正常运行。&lt;/p&gt;
&lt;h2 id=&quot;安装powerline字体&quot;&gt;安装powerline字体&lt;/h2&gt;
&lt;p&gt;powershell对字体要求比较严格，因此并不是所有的等宽字体都可以直接在里面使用。&lt;/p&gt;
&lt;p&gt;我们先来安装&lt;code&gt;powerline&lt;/code&gt;字体吧，&lt;a href=&quot;https://github.com/powerline/fonts&quot;&gt;powerline/fonts&lt;/a&gt; 项目的官方安装步骤如下:&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\WINDOWS\system32&amp;gt; git clone &amp;lt;https://github.com/powerline/fonts&amp;gt;
PS C:\WINDOWS\system32&amp;gt; cd C:\Users\Bruce\fonts\
PS C:\Users\Bruce\fonts&amp;gt; ./install.ps1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行这里最后一句 时，会出现权限的问题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205144235-1767910735.png&quot; alt=&quot;permit&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其解决方法是使用管理员权限另开一个 &lt;code&gt;PowerShell&lt;/code&gt; 窗口, 输入:&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce\fonts&amp;gt; set-executionpolicy Bypass &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令可以运行未签名的脚本或者为你的脚本签名。&lt;/p&gt;
&lt;p&gt;执行之，会弹出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205230826-811350658.png&quot; alt=&quot;1558176524594&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要输入&lt;code&gt;a&lt;/code&gt;, 然后再次执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./install.ps1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但我并不建议这样安装，因为这样是将所有的powerfont字体都安装上，需要耗费大量的时间。事实上，我们只需安装符合&lt;code&gt;powerline&lt;/code&gt;规范的字体 &lt;code&gt;Sarasa Mono T SC&lt;/code&gt; (中文叫 等距更纱黑体) 或 &lt;code&gt;Fira code&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;从相应的github项目官网上下载前面这个昨天，特别的慢，我已经上传到:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yanglr/WindowsDevTools/blob/master/awosomeTerminal/fonts-PowerShell/fonts-Sarasa%20Mono%20T%20SC.7z&quot;&gt;https://github.com/yanglr/WindowsDevTools/blob/master/awosomeTerminal/fonts-PowerShell/fonts-Sarasa%20Mono%20T%20SC.7z&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;方便你 &lt;code&gt;git clone&lt;/code&gt; 后使用，拉取完成后，解压后，复制文件到&lt;code&gt;C:/Windows/System/fonts&lt;/code&gt;文件夹，即安装完成。&lt;/p&gt;
&lt;p&gt;当然，你也可以安装后面的&lt;code&gt;Fira code&lt;/code&gt;字体. 而对于默认独立的powershell窗口，只能使用前面的&lt;code&gt;Sarasa Mono T SC&lt;/code&gt; 字体，该昨天在Windows 10之外的Windows系统中也能在界面上选择后使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;windows&lt;/strong&gt;下安装&lt;code&gt;Fira code&lt;/code&gt;字体的方法为:&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装chocolatey&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以管理员权限打开powershell，输入&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后使用chocolatey命令: &lt;code&gt;choco install firacode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在命令行应用之，具体操作是在&lt;code&gt;profiles.json&lt;/code&gt;中把字体设置成它，即可生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205259279-2096059412.png&quot; alt=&quot;1558176251296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tonsky/FiraCode Wiki&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tonsky/FiraCode/wiki&quot; class=&quot;uri&quot;&gt;https://github.com/tonsky/FiraCode/wiki&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题定制&quot;&gt;主题定制&lt;/h2&gt;
&lt;p&gt;此外，如果想更深入地定制&lt;code&gt;powershell&lt;/code&gt;主题，推荐安装&lt;code&gt;oh_my_posh&lt;/code&gt;，对标 &lt;code&gt;Linux&lt;/code&gt;下的 &lt;code&gt;oh-my-zsh&lt;/code&gt; ，下面详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;安装oh-my-posh&quot;&gt;安装oh-my-posh&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;oh-my-posh&lt;/code&gt; 是一个强大的&lt;code&gt;powerline&lt;/code&gt;主题，类似于 &lt;code&gt;Linux&lt;/code&gt;下的 &lt;code&gt;oh-my-zsh&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;相应的&lt;code&gt;github&lt;/code&gt;官方项目中其实有具体的操作步骤，见:&lt;/p&gt;
&lt;p&gt;JanDeDobbeleer/oh-my-posh: A prompt theming engine for Powershell running in ConEmu&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JanDeDobbeleer/oh-my-posh&quot; class=&quot;uri&quot;&gt;https://github.com/JanDeDobbeleer/oh-my-posh&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看策略组的执行权限&quot;&gt;查看策略组的执行权限&lt;/h3&gt;
&lt;p&gt;首先，我们需要查看当前的权限，以便后续正常安装，这也是许多文章忽略的问题。参看微软官方文档中的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/previous-versions/windows/powershell-scripting/hh847748(v=wps.640)&quot;&gt;策略管理方式&lt;/a&gt;，只需在以管理员权限打开的&lt;code&gt;powershell&lt;/code&gt;中这么执行指令：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Get-ExecutionPolicy -List&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们需要输入以下命令，将&lt;strong&gt;CurrentUser&lt;/strong&gt;的&lt;strong&gt;ExecutionPolicy(执行权限)&lt;/strong&gt;从原来的&lt;strong&gt;Undefined&lt;/strong&gt;更改成&lt;strong&gt;RemoteSigned&lt;/strong&gt;，需要输入命令：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Set-ExecutionPolicy RemoteSigned -Scope CurrentUser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按提示输入&lt;code&gt;y&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3 id=&quot;使用choco-安装终端模拟器---conemu&quot;&gt;使用&lt;code&gt;choco&lt;/code&gt; 安装终端模拟器 - ConEmu&lt;/h3&gt;
&lt;p&gt;推荐你使用&lt;code&gt;ConEmu&lt;/code&gt;在Windows上获得出色的终端体验。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce&amp;gt; choco install ConEmu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，你需要使用&lt;code&gt;PowerShell Gallery&lt;/code&gt; 来安装 &lt;code&gt;oh-my-posh&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce&amp;gt; Install-Module posh-git -Scope CurrentUser
PS C:\Users\Bruce&amp;gt; Install-Module oh-my-posh -Scope CurrentUser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都安装好之后，还需要更新配置文件&lt;code&gt;$PROFILE&lt;/code&gt;，类似于Linux Bash的.bashrc, 这是全局修改，而不是临时的设置喔~&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce&amp;gt; $PROFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\Users\Bruce\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续输入:&lt;/p&gt;
&lt;pre class=&quot;power&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce&amp;gt; if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }

PS C:\Users\Bruce&amp;gt; notepad $PROFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在打开的文件中添加内容:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Paradox&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后关闭记事本。&lt;/p&gt;
&lt;p&gt;最后更新配置:&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Bruce&amp;gt; C:\Users\Bruce\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启powershell后会发现已经生效。&lt;/p&gt;
&lt;h3 id=&quot;优化-powershell-的配色&quot;&gt;优化 PowerShell 的配色&lt;/h3&gt;
&lt;p&gt;接下来，我们可以使用微软提供的一个方便更改默认终端配色的工具 &lt;code&gt;colortool&lt;/code&gt;来优化powershell中的颜色，下载地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/terminal/releases/download/1904.29002/ColorTool.zip&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/terminal/releases/download/1904.29002/ColorTool.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个工具也支持读取 iTerm 主题文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，使用上面的地址将 ColorTool 下载至本地，并解压&lt;/li&gt;
&lt;li&gt;打开&lt;code&gt;Windows terminal&lt;/code&gt;的&lt;code&gt;Powershell Tab&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ColorTool 使用非常简单，该工具自带了几种配色主题，我们可以利用下面这个命令进行查看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 注：-s 代表 schemes
colortool -s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.\ColorTool.exe -s&lt;/p&gt;
&lt;p&gt;其中前面列出的几个 &lt;code&gt;.ini&lt;/code&gt; 和 &lt;code&gt;.itermcolors&lt;/code&gt; 就是主题配置文件，我们可以直接通过下面这个命令设置主题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 临时查看
colortool &amp;lt;主题名称&amp;gt;
# 定义默认值
colortool -d &amp;lt;主题名称&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如我们希望将主题配色更换为 &lt;code&gt;OneHalfDark.itermcolors&lt;/code&gt;，只需要输入下面这个命令就可以更换并预览更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\ColorTool.exe OneHalfDark&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我随便使用了几个命令，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205419579-1405468571.png&quot; alt=&quot;1558180193077&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要特别提醒一点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Windows terminal&lt;/code&gt;下使用Powershell Tab, 调用&lt;code&gt;ColorTool&lt;/code&gt;需要使用&lt;code&gt;.\ColorTool.exe&lt;/code&gt;, 如果直接用&lt;code&gt;ColorTool.exe&lt;/code&gt;会报错(如下图所示):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205455079-1795631822.png&quot; alt=&quot;1558180250076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在&lt;code&gt;Windows terminal&lt;/code&gt;以外的独立&lt;code&gt;cmd.exe&lt;/code&gt;或 &lt;code&gt;Powershell&lt;/code&gt; 窗口，&lt;code&gt;.\ColorTool.exe&lt;/code&gt;和&lt;code&gt;ColorTool.exe&lt;/code&gt;都能正常运行。&lt;/p&gt;
&lt;h2 id=&quot;将powershell的提示符改为-emoji&quot;&gt;将&lt;code&gt;powershell&lt;/code&gt;的提示符改为 Emoji&lt;/h2&gt;
&lt;p&gt;终端中插入&lt;code&gt;Emoji&lt;/code&gt;的功能，Mac和Linux几年前都能支持。相比&lt;code&gt;windows&lt;/code&gt;也应该可以支持，请执行以下步骤：&lt;/p&gt;
&lt;p&gt;启动&lt;code&gt;Powershell&lt;/code&gt;或&lt;code&gt;Windows Terminal 的 Powershell Tab&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行&quot;notepad $profile&quot; 或 &quot;code $profile&quot; (推荐使用后者vs code，记得安装时勾选上&lt;code&gt;Add to PATH (available after restart)&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;复制/粘贴此行：function prompt { &quot;PS $pwd&amp;gt;&quot; }&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在你想要的位置插入表情符号, 比如 把&lt;code&gt;function prompt {&quot;PS $pwd ? &amp;gt;&quot; }&lt;/code&gt;中的&lt;code&gt;?&lt;/code&gt;替换为所需要的表情，这里我替换成了: 🔥👽.&lt;/p&gt;
&lt;p&gt;比如，我使用了vs code编辑，操作如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205908708-1768829920.png&quot; alt=&quot;1558182959996&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;文件 - &amp;gt;另存为 - &amp;gt;使用默认文件名，但你必须将编码设置为&lt;code&gt;UTF-16 LE&lt;/code&gt;，因为这是&lt;code&gt;Powershell&lt;/code&gt;对其配置文件所期望的(UTF-8编码不起作用)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存后关闭编辑器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行命令&lt;code&gt;C:\Users\Bruce\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1&lt;/code&gt;(这个文件其实对应的是文件&lt;code&gt;$profile&lt;/code&gt;)，确保新的配置生效&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关闭Powershell / Terminal Windows&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再次打开&lt;code&gt;Powershell&lt;/code&gt;或&lt;code&gt;Windows Terminal&lt;/code&gt;的 &lt;code&gt;Powershell Tab&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时界面为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518205937310-973768936.png&quot; alt=&quot;1558182712467&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，好好享受你的&lt;code&gt;Emoji&lt;/code&gt;表情提示符吧~&lt;/p&gt;
&lt;p&gt;这个功能的给出，得感谢开发&lt;code&gt;Windows terminal&lt;/code&gt;的微软员工，很感激他们的快速响应。&lt;/p&gt;
&lt;p&gt;这是我之前提的一个&lt;code&gt;issue&lt;/code&gt;，地址为:&lt;/p&gt;
&lt;p&gt;Could new Windows Terminal customize prompt using emoji? · Issue #814 · microsoft/terminal&lt;br/&gt;&lt;a href=&quot;https://github.com/microsoft/terminal/issues/814#issuecomment-492907982&quot; class=&quot;uri&quot;&gt;https://github.com/microsoft/terminal/issues/814#issuecomment-492907982&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;不从window-terminal中使用-powershell&quot;&gt;不从Window terminal中使用 PowerShell&lt;/h2&gt;
&lt;p&gt;对于默认独立的powershell窗口，只能使用后面这种字体，windows 10之外的windows系统也能在界面上选择后使用(附图)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518210046863-2060593394.png&quot; alt=&quot;1558176335634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在命令行提示符还没加入&lt;code&gt;Emoji&lt;/code&gt;表情之前，&lt;code&gt;powershell&lt;/code&gt;界面为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201905/436938-20190518210110723-1115235621.png&quot; alt=&quot;1558178104783&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于windows中的utf-8字符和utf-16字符 - 云风&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.codingnow.com/2019/05/windows_utf16.html&quot; class=&quot;uri&quot;&gt;https://blog.codingnow.com/2019/05/windows_utf16.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;告别 Windows 终端的难看难用，从改造 PowerShell 的外观开始 - 少数派&lt;br/&gt;&lt;a href=&quot;https://sspai.com/post/52868&quot; class=&quot;uri&quot;&gt;https://sspai.com/post/52868&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 22:52:00 +0000</pubDate>
<dc:creator>dotNET匠人</dc:creator>
<og:description>接着昨天的文章 [黑科技抢先尝(续) - Windows terminal中WSL Linux 终端的极简美化指南](https://www.cnblogs.com/enjoy233/p/simple</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/simple_guide_to_beautify_powershells_in_Windows_Terminal.html</dc:identifier>
</item>
<item>
<title>数据通讯与网络 第五版第24章 传输层协议-TCP协议部分要点 - mango-jun</title>
<link>http://www.cnblogs.com/mangojun/p/10887057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mangojun/p/10887057.html</guid>
<description>&lt;p&gt;　　上一博客记录了UDP协议的关键要点，这部分记录TCP协议的关键要点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;24.3 传输控制协议（TRANSMISSION CONTROL PROTOCOL）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　TCP（Transmission Control Procotol ）协议是一个面向连接，可靠的协议。TCP为了提供面向连接的服务，专门定义了连接创建，数据传输、连接终止阶段。TCP使用GBN和SR协议来提供可靠性。为了实现可靠性这个目标，TCP使用检验和来进行误差控制、重传来处理数据包丢失和冲突、同时还利用了应答和计数机制。在本节，首先讨论TCP提供的服务，然后讨论TCP的详细特征。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;24.3.1 TCP服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程到进程的通讯（Process-to-Process Communication）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　像UDP一样，TCP使用端口号提供基于进程到进程的通讯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流分发服务（Stream Delivery Service）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　和UDP不同，TCP是面向流的，允许发送进程以字节流的方式发送，然后接收方以字节流的方式接受数据，TCP创建了虚拟的管道环境，从而使得发送进程和接收进程连接起来。图24.4表示了双方数据流的传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519014510012-809149400.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送和接收缓冲区（Sending and Receving Buffers）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为接收方和发送方的读写数据的速度不一样，TCP需要缓冲区进行数据存储。存在两个缓冲区，发送缓冲区和接收缓冲区。缓冲区在TCP的流量控制和误差控制发挥作用，这点稍后将会介绍。一种　　实现缓冲区的方式是使用循环的字节数组，如图24.5所示。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519014615960-1792578293.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图中展示了数据在缓冲区的流动方向，对于发送方，缓冲区可以分成三个部分。白色的部分表示还没装载数据的缓冲区部分，由发送进程来填充，橙色部分存储的是已经发送但还没被接收方应答的字节数据，TCP发送者会保留该区域的数据直到接收到了接收方的应答。黑色部分表示将要发送的数据。橙色部分的数据被应答之后，可以重新由发送进程来填充。&lt;/p&gt;
&lt;p&gt;　　接收方的接收缓冲区的操作会简单一些，环形的缓冲区分为两个部分。白色部分表示还没装载数据的缓冲区部分，橙色部分表示已经接收，可供接收进程进行数据读取的缓冲区部分。当一个字节被接收进程读取之后，整个缓冲区将会循环，同时更新白色缓冲区部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;片段（Segment）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　尽管缓冲区可以处理发送方和接收方处理数据不一致的问题，但是在进行数据发送之前，还需要做一步。向TCP服务的网络层是以数据包的形式发送数据，而不是数据流。在传输层，TCP会封装一定字节的数据成一个数据包，叫片段。TCP将会在每个数据片段加一个头部，然后将数据提交给网络层进行数据传输。数据片段在网络层封装成IP数据报然后传输，对于接收进程，整个过程是透明的。等会还会介绍接收方接收到无序、存在丢失和冲突数据以及重新传输的情况，这些都是由TCP接收方接收进程来处理的。图24.6展示了数据片段是如何由发送缓冲区的字节生成的。需要注意的一点是，片段的长度不是恒定的。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519014732308-2013130651.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全双工通讯（Full-Duplex Communication）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　TCP提供全双工通讯，也就是数据流能同时在两个方向进行传输，每个TCP终端都有一个发送缓冲区和一个接收缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向连接的服务（Connection-Oriented Service）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　和UDP不同，TCP是面向连接的的协议，当A端的一个进程想发送数据或者接收数据到B端另一个进程时，以下三个阶段将会出现：&lt;/p&gt;
&lt;p&gt;　　a.两个TCP创建一条逻辑上连通的传输通道&lt;/p&gt;
&lt;p&gt;　　b.数据在双方双向传输&lt;/p&gt;
&lt;p&gt;　　c.终止连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可靠的服务（Reliable Service）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　TCP是一种可靠的传输协议，使用应答机制来检查数据的传输安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;24.3.2 TCP特征（TCP Feature）&lt;/span&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计数系统（Numbering System）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　尽管TCP软件能够追踪片段的传输和发送，但它不是用片段数来记录数据的发送，而是用序列号和应答号两个字段来记录传输字节数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节数（Byte Number）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　TCP在数据传输过程中记录所有传输的字节数。计数在接收方和发送方是独立的，当TCP接收字节从一个进程时，TCP存储数据在缓冲区，并且记录字节数，计数并不是从0开始的，而是随机选择一个0到（2^23-1）之间的数据。例如，如果初始数据是1057,要发送的数据总长度为6000字节，字节的编号就是1057到7056。字节计数主要用来进行流量控制和误差控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列号（Sequence Number）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　字节编号之后，TCP将会分配一个系列号到每一个将要发送的片段，序列号根据以下规则定义：&lt;/p&gt;
&lt;p&gt;　　1.第一个字段的序列号是初始序列号ISN（Initial sequence number）,也就是一个随机生成的数。&lt;/p&gt;
&lt;p&gt;　　2.其他片段的序列号是上一个片段序列号加上上一个片段传输的字节数。&lt;/p&gt;
&lt;p&gt;　　当一个片段携带用户数据和控制信息时，它需要加上序列号，当一个片段没有携带数据时，不需要定义序列号，序列号字段还是存在的，只是是无效的。需要注意的是，有些片段，虽然只是携带了控制信息，却需要序列号来允许接收方来进行数据应答，这些字段用来进行连接创建，终止，中断。每个这类片段默认是一个数据长度，但是实际中是没有数据的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应答号（Acknowledgment Number）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在通讯过程总，通讯双方都用序列号记录了每个片段携带的第一个数据的编号。同时，接收方和发送方还会用应答号来应答接收的数据。应答号定义了对方下一个要发送的字节的序列号。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;24.3.3 片段（Segment）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　TCP中一个数据包叫片段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式（Format）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　片段的格式如图24.7所示，片段包括一个20-60字节的头部，然后就是数据部分。如果没有其他选项，头部20字节长度，否则，头部是60字节长度。&lt;/p&gt;
&lt;p&gt;　　source port address：定义发送方的端口号。&lt;/p&gt;
&lt;p&gt;　　destination port address: 接收方的端口号。&lt;/p&gt;
&lt;p&gt;　　sequence number :序列号，初始序列号（ISN）随机产生。&lt;/p&gt;
&lt;p&gt;　　acknowledgment number:应答号，定义接收方下一个期望接收的字节数据起始编号，如果接收方已经成功字节编号为X的数据，应答号就是X+1。&lt;/p&gt;
&lt;p&gt;　　header length: 头部长度。&lt;/p&gt;
&lt;p&gt;　　control:该字段包括6个不同的控制位或者控制标志，如图24.8所示。这些位可以用来流量控制，连接创建，连接中断，连接断开。&lt;span&gt;图24.8给出了这些&lt;/span&gt;位的含义。&lt;/p&gt;
&lt;p&gt;　　window size:该字段定义了发送数据的窗口大小，长度为16位，最大数据是65535字节。该值一般用于指接收方的接收窗口大小，发送方必须考虑接收方的接收窗大小。&lt;/p&gt;
&lt;p&gt;　　checknum：校验和，16位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519014855920-1956017616.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519014951672-270579373.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;封装（Encapsulation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　TCP片段封装从应用层提交过来的数据，然后在网络层，TCP片段被封装成IP数据报，进而在数据链路层被封装成帧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;24.3.4 TCP连接过程（A TCP Connection）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　TCP连接包括三个阶段：连接创建、数据传输、连接终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接创建（Connection Establishment）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;　　&lt;/em&gt;三次握手（Three-Way Handshaking）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　TCP创建连接的过程叫做三次握手，试图创建连接的应用程序，一般称为客户端，等待连接的程序，一般称作服务器。&lt;span&gt;图24.10给&lt;/span&gt;出了使用三次握手进行连接创建过程以及创建连接过程中数据的关键字段。连接创建过程的三次握手如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519015144507-2146913027.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.客户端发送第一个片段，称作SYN片段，片段中设置了SYN位为1。该片段用于序列号的同步。客户端随机生成一个数作为初始序列号（ISN），然后发送到服务器。需要注意的是，该片段没有包括应答号，也没有定义窗口大小，当片段中的应答号存在是，窗口大小定义才有效。SYN片段为控制片段，没有携带数据，但是，它还是会消耗一个一个序列号，因为它需要被服务器应答，实际中可以认为SYN片段携带一个虚拟的字节。&lt;/p&gt;
&lt;p&gt;　　2.服务器发送第二个片段，SYN+ACK片段，同时该片段中SYN和ACK位都设为1。该片段有两个目的，第一是初始化从服务端到客户端的通讯，该片段初始化了一个序列号，来记录由服务端发向客户端的的字节号。第二个目的是应答了客户端发送的SYN片段，同时向客户端说明了下一个要接受的片段的序列号。因为数据包需要被应答，所以需要定义接收接收窗体的大小（rwnd）。该片段也需要消耗一个序列号。&lt;/p&gt;
&lt;p&gt;　　3.客户端发送第三个片段，ACK片段，这个仅仅是应答片段，应答第二个片段的接收。该字段设置ACK位为1。需要注意的是，该片段如果没有携带数据时，不需要消耗序列号。该字段允许携带从客户端发送服务端的数据信息，当携带数据时，需要消耗序列号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据传输（data transfer）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;连接创建之后，就可以进行数据传输了。需要注意的问题是，数据传输过程中，如果发送方设置了PUSH位，意味着接收方要尽快的把数据提交到应用层，而不需要等待缓冲区满或者更多数据到来。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接终止（Connection Termination）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;交换数据的双方都可以关闭连接，虽然关闭连接请求往往由客户端初始化。如今很多TCP实现允许两种终止连接方式：三次握手（图24.12）和半关闭的四次握手（图24.13）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　三次握手（Three-Way Handshaking）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.客户端TCP在接收到客户端应用的断开连接命令后，向服务器发送第一个片段，称作FIN片段，该片段中FIN标志位设为1，FIN片段可以携带最后发送给服务器的数据信息，也可以不携带任务信息，仅仅作为一个控制片段。如果是控制片段，就需要消耗一个序列号。&lt;/p&gt;
&lt;p&gt;　　2.服务器TCP接收到FIN片段后，向上层应用通知连接断开，然后发送第二个数据片段，FIN+ACK片段，一方面是中断服务器向客户端发送数据的连接，另一方面是告知客户端已接收到FIN片段。FIN+ACK片段可以携带最后发送给客户端的数据信息，也可以不携带任务信息，仅仅作为一个控制片段。如果是控制片段，就需要消耗一个序列号。&lt;/p&gt;
&lt;p&gt;　　3.客户端TCP发送最后一个片段，ACK片段，证实接收到了FIN+ACK片段，该片段包括应答号，但不携带数据，不消耗序列号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519015555267-1663573844.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;半关闭（Half-Close）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;TCP中，一方可以停止发送数据的同时仍然接收对方发送的数据，这种方式称作半关闭。服务端和客户端都可以发出半关闭请求。半关闭发生在接收方需要接受所有数据之后，交给上层处理，然后再把数据发送给发送方，发送方发完数据之后就可以请求半关闭了。一个比较容易理解的例子就是排序，客户端向服务器发送要排序的数组，服务器把要排序的数据全部接收后，交给上层应用排序好之后，再把排序好的数据发送给客户端，客户端发送完数据之后，就可以发送半关闭的请求了。图24.13就表示了半关闭过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1629318/201905/1629318-20190519015649018-492475528.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 18:07:00 +0000</pubDate>
<dc:creator>mango-jun</dc:creator>
<og:description>上一博客记录了UDP协议的关键要点，这部分记录TCP协议的关键要点。 24.3 传输控制协议（TRANSMISSION CONTROL PROTOCOL） TCP（Transmission Contr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mangojun/p/10887057.html</dc:identifier>
</item>
<item>
<title>PJzhang:lijiejie的敏感目录爆破工具BBScan - PJzhang白话安全</title>
<link>http://www.cnblogs.com/landesk/p/10884391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/landesk/p/10884391.html</guid>
<description>&lt;p&gt;&lt;span&gt;猫宁！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.freebuf.com/sectool/85729.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://segmentfault.com/a/1190000014539449&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个目录爆破工具使用的人也是挺多的，先用他的subdomainsbrute获取子域名，再用BBScan进行路径爆破，简单粗暴，一气呵成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lijiejie的博客：http://www.lijiejie.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BBScan现在已经更新到1.4版本了，最近一次更新是2019.05.13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BBScan github地址：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://github.com/lijiejie/BBScan&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我用的是kali linux系统操作以下内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载下来，采用root用户执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;git clone https://github.com/lijiejie/BBScan.git&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cd /root/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据requirements，可以知道要pip install的python模块，采用python2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BeautifulSoup4&amp;gt;=4.3.2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;py2-ipaddress&amp;gt;=3.4.1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;urllib3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pymongo&lt;/span&gt;&lt;br/&gt;&lt;span&gt;requests&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过执行的时候，python BBScan.py，报错提示还需要安装另外的six.moves.queue python模块，那就安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518005425107-1751192647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pip install six.moves.queue，安装不了，报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518005722056-1403458926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：pip install awscli --upgrade --ignore-installed six&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有遇到这样的问题，那自然更好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后python BBScan.py，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518005847094-1615998098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示帮助文件的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py -h&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对某一个域名进行目录爆破，而且针对的是http的80端口，如果加上--full，可以扫描更多的敏感目录，结果在report文件夹，默认爆破完成后会开启默认浏览器，将所有有结果的都打开展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --host www.baidu.com --full&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518234611675-2051917962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不想打开浏览器可以这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py -nnn --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rule文件夹中的目录字典，有black.list和white.list，黑名单表示爆破目录时根据返回内容要抛弃的，白名单则是要提取出来展示的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518234726304-1955162186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以扫描多个域名，例如扫描2个域名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --host www.baidu.com site.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描www.baidu.com整个C段的IP的目录，http请求形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --host www.baidu.com --network 24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1687889/201905/1687889-20190518235436239-1726382462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --timeout 1 --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scripts文件夹有很多的python脚本，这里表示只调用里面的脚本对域名检测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --scripts-only --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不调用里面的脚本进行扫描域名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --no-scripts --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过返回状态码来判断是不是404界面，而不是通过返回包中特定的内容来检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py --no-check404 --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将最后的报告输出为md格式的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py -md --host www.baidu.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看工具的版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python BBScan.py -v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于爬虫的相关命令参数，可以不用，这个功能不好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;目录爆破工具对于请求域名返回码为403的情况非常适用，lijiejie的这个工具在可用性上低于他的作品子域名爆破工具subdomainsbrute。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把python程序系统的学习一遍，并开发自己的python工具比较好，可以避开一些他人工具的不协调之处，但是他人的工具要多去尝试了解，知己知彼。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 17:41:00 +0000</pubDate>
<dc:creator>PJzhang白话安全</dc:creator>
<og:description>猫宁！！！ 参考链接： https://www.freebuf.com/sectool/85729.html https://segmentfault.com/a/1190000014539449 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/landesk/p/10884391.html</dc:identifier>
</item>
<item>
<title>Go语言入门——数组、切片和映射 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/array-slice-map.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/array-slice-map.html</guid>
<description>&lt;p&gt;## Go语言入门——数组、切片和Map&lt;/p&gt;
&lt;p&gt;按照以往开一些专题的风格，第一篇一般都是“从HelloWorld开始”&lt;/p&gt;
&lt;p&gt;但是对于Go，思来想去，感觉真的从“HelloWorld”说起，压根撑不住一篇的篇幅，因为Go的HelloWorld太简单了。&lt;/p&gt;

&lt;p&gt;### 1、简介&lt;/p&gt;
&lt;p&gt;&amp;gt; Go是什么？&lt;/p&gt;
&lt;p&gt;**Go**（又称**Golang**）是[Google](https://baike.baidu.com/item/Google)开发的一种[静态](https://baike.baidu.com/item/%E9%9D%99%E6%80%81)[强类型](https://baike.baidu.com/item/%E5%BC%BA%E7%B1%BB%E5%9E%8B)、编译型、并发型，并具有垃圾回收功能的[编程语言](https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)。——摘自百度百科&lt;/p&gt;

&lt;p&gt;&amp;gt; Github地址&lt;/p&gt;
&lt;p&gt;&amp;lt;https://github.com/golang/go&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; 官网地址&lt;/p&gt;
&lt;p&gt;[https://golang.org](https://golang.org/)&lt;/p&gt;

&lt;p&gt;&amp;gt; 中文网社区&lt;/p&gt;
&lt;p&gt;[https://studygolang.com](https://studygolang.com/)&lt;/p&gt;
&lt;p&gt;如果需要下载安装包，可以进入&amp;lt;https://studygolang.com/dl&amp;gt;下载，速度较快&lt;/p&gt;
&lt;p&gt;&amp;lt;https://www.golangtc.com/&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; 关键字&lt;/p&gt;
&lt;p&gt;简单，学习曲线低，天然高并发，背景雄厚，大厂拥抱&lt;/p&gt;

&lt;p&gt;### 2、环境搭建&lt;/p&gt;
&lt;p&gt;#### 下载安装&lt;/p&gt;
&lt;p&gt;进入官网或者&amp;lt;https://studygolang.com/dl&amp;gt;下载对应系统的安装包（我的是MacOS系统）&lt;/p&gt;
&lt;p&gt;下载成功后点击安装（无脑下一步即可）&lt;/p&gt;
&lt;p&gt;#### 环境变量配置&lt;/p&gt;
&lt;p&gt;打开命令行执行sudo vi ~/.bash_profile配置GOROOT和GOPATH&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190519010853956-1219046954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190519010902894-71386134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：GOPATH如果不配置，默认在会在用户目录下新建go目录，GOPATH相当于工作空间，有点类似Java开发的workspace。&lt;/p&gt;
&lt;p&gt;配置完成执行go version出现类似&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;go version go1.12.4 darwin/amd64&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;则表示安装成功&lt;/p&gt;

&lt;p&gt;#### 开发工具&lt;/p&gt;
&lt;p&gt;至于开发工具看个人喜好，鉴于做Java开发使用的宇宙第一好用IDE intellij idea确实好用，所以个人还是继续用JetBrain的产品Goland作为开发IDE。&lt;/p&gt;
&lt;p&gt;当然，除此以外，还有Atom，VS code等等。&lt;/p&gt;

&lt;p&gt;下面开始进入正题，说说Go语言中的数组、切片和映射即Map。在此之前还需要介绍几个背景知识，不然第一次看Go的语言可能有点懵~&lt;/p&gt;

&lt;p&gt;### 背景知识&lt;/p&gt;
&lt;p&gt;#### 类型后置&lt;/p&gt;
&lt;p&gt;不同于Java、C++等很多语言，Go采用类型后置的方式声明变量&lt;/p&gt;
&lt;p&gt;比如Java中声明一个int的基本类型是这样的&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;int a = 3;&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;而Go里面其中一种声明方式是这样的&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var a int&lt;br/&gt;a = 3&lt;br/&gt;```&lt;/p&gt;

&lt;p&gt;#### 多样的赋值语句&lt;/p&gt;
&lt;p&gt;Go的声明和初始化方式丰富多样，有点太丰富了，听说2.0版本要稍微收收规范下&lt;/p&gt;
&lt;p&gt;比如如下的方式是正确的&lt;/p&gt;
&lt;p&gt;* 方式1&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var a int&lt;br/&gt;a = 3&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**解读：**初始化语句表明了a是一个int类型&lt;/p&gt;
&lt;p&gt;然后才能对一个int类型进行赋值&lt;/p&gt;

&lt;p&gt;* 方式2&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var a = 3&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**解读：**虽然没有明确表示这是一个int，但是Go可以根据后面的赋值推断出a的类型&lt;/p&gt;

&lt;p&gt;* 方式3&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;a := 3&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**解读：**这是一种简单高效的初始化和赋值方式，`:=`表示初始化一个变量a并同时对其赋值为3&lt;/p&gt;

&lt;p&gt;**以下方式是不正确的**&lt;/p&gt;
&lt;p&gt;* 方式1&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var a&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**解读：**基于这样的信息，a没有赋值，Go编译器是无法知道a的类型，也无法对其进行初始化和赋值了&lt;/p&gt;

&lt;p&gt;* 方式2&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var a int&lt;br/&gt;a := 3&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**解读：**虽然正确的声明了一个int类型的a变量，但是下面的`:=`相当有重新声明了一个变量a，所以重复申明也会编译出错&lt;/p&gt;

&lt;p&gt;有了上面两个背景知识储备，加上自个儿在相关语言上面深厚的积累，开始下面的讲解就没事问题了~&lt;/p&gt;

&lt;p&gt;### 数组&lt;/p&gt;
&lt;p&gt;数组几乎是每个语言必备的数据结构之一，Go也不例外。&lt;/p&gt;
&lt;p&gt;数组也有多种初始化和赋值方式&lt;/p&gt;
&lt;p&gt;* 方式1&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var arr [5]int // 注意这里必须要声明大小，下面要讲的切片这里可以不用声明大小&lt;br/&gt;arr[0] = 0&lt;br/&gt;arr[1] = 1&lt;br/&gt;arr[4] = 4&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式2&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var arr []int&lt;br/&gt;arr = make([]int, 4)&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;该方式通过make指定数组的大小，这里表示数组容量为4，超过4，比如赋值如`arr[4]=4`，则会报错`panic: runtime error: index out of range`&lt;/p&gt;
&lt;p&gt;panic相当于Java里面的Exception&lt;/p&gt;
&lt;p&gt;* 方式3&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var arr [5]int{1,2,3,4,5}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式4&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;arr := [5]int{1,2,3,4,5}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式5&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var arr [...]int{0:1, 3:4, 1:2} // x:y，其中x表示index，y表示值，...表示变长和Java中的变长函数一个道理&lt;br/&gt;```&lt;/p&gt;

&lt;p&gt;### 切片&lt;/p&gt;
&lt;p&gt;切片有些语言里面可能没有这个名词，我记得Python里面有，Java里就没有。&lt;/p&gt;
&lt;p&gt;切片可以看成是一种特殊的数组，该种数组可以变长。其生命和初始化方式也有多种&lt;/p&gt;
&lt;p&gt;* 方式1&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var s []int{1,2,3,4,5}&lt;br/&gt;s := []int{1,2,3,4,5}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式2&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;s := make([]int, 3, 5) // 3所在位置表示切片长度，5所在位置表示容量即最大可能存储的元素个数&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;**注意：**`s[2]=2`该赋值是合法的，但是`s[3]=3`则会报错，因为需要使用append追加元素，类似&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;s = append(s, 3) // 此时len=4， cap=5&lt;br/&gt;s[3] = 10 // 对s[3]重新赋值，合法&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;另外如果赋值时，切片长度没超过定义的切片的长度，返回原来的切片地址，如果超过了长度，切片会扩容进行重新分配地址。&lt;/p&gt;
&lt;p&gt;* 方式3&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;s := arr[1:3] // 表示截取数组一部分成为一个切片，1表示起始位置，3表示结束为止，是一个左闭右开区间&lt;br/&gt;```&lt;/p&gt;

&lt;p&gt;### Map&lt;/p&gt;
&lt;p&gt;map就是键值对，跟Java的没差&lt;/p&gt;
&lt;p&gt;声明好初始化的方式如下&lt;/p&gt;
&lt;p&gt;* 方式1&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;var m map[string]int // string所在位置表示key的类型，int所在位置表示value的类型&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式2&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;m := make(map[string]int, 5) // 5所在位置表示map的容量&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;* 方式3&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;m = map[string]int{&quot;jackie&quot;:1, &quot;zheng&quot;:8}&lt;br/&gt;```&lt;/p&gt;


&lt;p&gt;### 共同点和差异点&lt;/p&gt;
&lt;p&gt;* 数组、切片和Map都可以通过make关键字进行初始化&lt;br/&gt;* 数组、切片和Map都支持在`{}`里面使用`index:value`进行初始化值&lt;/p&gt;
&lt;p&gt;* 数组和切片差别在于数组必须声明数组容量，即使是变长声明类型，也必须列出具体数组元素&lt;br/&gt;* 切片有append函数，涉及到扩容等问题&lt;/p&gt;

&lt;p&gt;### 下篇预告&lt;/p&gt;
&lt;p&gt;1、数组、切片和map的遍历以，切片扩容，map根据key和value排序等&lt;/p&gt;
&lt;p&gt;2、Go和Java使用体验差异&lt;/p&gt;


&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的&lt;strong&gt;“推荐”&lt;/strong&gt;将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/619240/201505/162205410643708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 18 May 2019 17:22:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>Go语言入门介绍，包括数组、切片和Map等常用数据结构和使用方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/array-slice-map.html</dc:identifier>
</item>
<item>
<title>python反编译之字节码 - 公众号python学习开发</title>
<link>http://www.cnblogs.com/c-x-a/p/10847501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/10847501.html</guid>
<description>&lt;p&gt;如果你曾经写过或者用过 Python，你可能已经习惯了看到 Python 源代码文件；它们的名称以.Py 结尾。你可能还见过另一种类型的文件是 .pyc 结尾的，它们就是 Python “字节码”文件。(在 Python3 的时候这个 .pyc 后缀的文件不太好找了,它在一个名为__pycache__的子目录下面。).pyc文件可以防止Python每次运行时都重新解析源代码，该文件大大节省了时间。&lt;/p&gt;
&lt;h3 id=&quot;python是如何工作的&quot;&gt;Python是如何工作的&lt;/h3&gt;
&lt;p&gt;Python 通常被描述为一种解释语言，在这种语言中，你的源代码在程序运行时被翻译成CPU指令，但这只是说对了部分。和许多解释型语言一样，Python 实际上将源代码编译为虚拟机的一组指令，Python 解释器就是该虚拟机的实现。其中这种中间格式称为“字节码”。&lt;/p&gt;
&lt;p&gt;因此，Python留下的这些.pyc文件，是为了让运行的速快变得 “更快”，或者是针对你的源代码的”优化“的版本；它们是 Python 虚拟机上运行的字节码指令。&lt;/p&gt;
&lt;h3 id=&quot;python-虚拟机内幕&quot;&gt;Python 虚拟机内幕&lt;/h3&gt;
&lt;p&gt;CPython使用基于堆栈的虚拟机。也就是说，它完全围绕堆栈数据结构(你可以将项目“推”到结构的“顶部”，或者将项目“弹出”到“顶部”)。&lt;br/&gt;CPython 使用三种类型的栈：&lt;/p&gt;
&lt;p&gt;1.调用堆栈。这是运行中的Python程序的主要结构。对于每个当前活动的函数调用，它都有一个项目一“帧”，堆栈的底部是程序的入口点。每次函数调用都会将新的帧推到调用堆栈上，每次函数调用返回时，它的帧都会弹出&lt;br/&gt;2.在每一帧中，都有一个评估堆栈(也称为数据堆栈)。这个堆栈是执行 Python 函数的地方，执行Python代码主要包括将东西推到这个堆栈上，操纵它们，然后将它们弹出。&lt;br/&gt;3.同样在每一帧中，都有一个块堆栈。Python使用它来跟踪某些类型的控制结构:循环、try /except块，以及 with 块都会导致条目被推送到块堆栈上，每当退出这些结构之一时，块堆栈就会弹出。这有助于Python知道在任何给定时刻哪些块是活动的，例如，continue或break语句可以影响正确的块。&lt;/p&gt;
&lt;p&gt;大多数 Python 字节码指令操作的是当前调用栈帧的计算栈，虽然，还有一些指令可以做其它的事情（比如跳转到指定指令，或者操作块栈）。&lt;/p&gt;
&lt;p&gt;为了更好地理解，假设我们有一些调用函数的代码，比如这个：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;my_function(my_variable,2)。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Python 将转换为一系列字节码指令：&lt;br/&gt;1.一个LOAD_NAME指令，用于查找函数对象 my_function，并将其推送到计算栈的顶部&lt;br/&gt;2.另一个 LOAD_NAME 指令去查找变量 my_variable，并将其推送到计算栈的顶部&lt;br/&gt;3.一个 LOAD_CONST 指令将一个整数 2 推送到计算栈的顶部&lt;br/&gt;4.一个 CALL_FUNCTION 指令&lt;br/&gt;CALL_FUNCTION 指令有2个参数，它表示 Python 需要在堆栈顶部弹出两个位置参数; 然后函数将在它上面进行调用，并且它也同时被弹出（关键字参数的函数，使用指令-CALL_FUNCTION_KW-类似的操作，并配合使用第三条指令CALL_FUNCTION_EX，它适用于函数调用涉及到参数使用 * 或 ** 操作符的情况）&lt;br/&gt;一旦 Python 具备了这些，它将在调用堆栈上分配一个新的帧，填充到函数调用的本地变量，然后运行该帧内的 my_function 的字节码。一旦运行完成，帧将从调用堆栈中弹出，在原始帧中，my_function 的返回值将被推入到计算栈的顶部。&lt;/p&gt;
&lt;p&gt;我们知道了这个东西了，也知道字节码了文件了，但是如何去使用字节码呢？ok不知道也没关系，接下来的时间我们所有的话题都将围绕字节码，在python有一个模块可以通过反编译Python代码来生成字节码这个模块就是今天要说的--dis模块。&lt;/p&gt;
&lt;h3 id=&quot;dis模块的使用&quot;&gt;dis模块的使用&lt;/h3&gt;
&lt;p&gt;dis模块包括一些用于处理 Python 字节码的函数，可以将字节码“反汇编”为更便于人阅读的形式。查看解释器运行的字节码还有助于优化代码。这个模块对于查找多线程中的竞态条件也很有用，因为可以用它评估代码中哪一点线程控制可能切换。参考源码Include/opcode.h，可以找到字节码的正式列表。详细可以看官方文档。注意不同版本的python生成的字节码内容可能不一样,这里我用的Python 3.8.&lt;/p&gt;
&lt;h3 id=&quot;访问和理解字节码&quot;&gt;访问和理解字节码&lt;/h3&gt;
&lt;p&gt;输入如下内容，然后运行它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def hello()
    print(&quot;Hello, World!&quot;)
import dis
dis.dis(hello)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数 dis.dis() 将反汇编一个函数、方法、类、模块、编译过的 Python 代码对象、或者字符串包含的源代码，以及显示出一个人类可读的版本。dis 模块中另一个方便的功能是 distb()。你可以给它传递一个 Python 追溯对象，或者在发生预期外情况时调用它，然后它将在发生预期外情况时反汇编调用栈上最顶端的函数，并显示它的字节码，以及插入一个指向到引发意外情况的指令的指针。&lt;/p&gt;
&lt;p&gt;它也可以用于查看 Python 为每个函数构建的编译后的代码对象，因为运行一个函数将会用到这些代码对象的属性。这里有一个查看 hello() 函数的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; hello.__code__
&amp;lt;code object hello at 0x104e46930, file &quot;&amp;lt;stdin&amp;gt;&quot;, line 1&amp;gt;
&amp;gt;&amp;gt;&amp;gt; hello.__code__.co_consts
(None, 'Hello, World!')
&amp;gt;&amp;gt;&amp;gt; hello.__code__.co_varnames
()
&amp;gt;&amp;gt;&amp;gt; hello.__code__.co_names
('print',)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码对象在函数中可以以属性 __code__ 来访问，并且携带了一些重要的属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;co_consts&lt;/strong&gt; 是存在于函数体内的任意实数的元组&lt;br/&gt;&lt;strong&gt;co_varnames&lt;/strong&gt; 是函数体内使用的包含任意本地变量名字的元组&lt;br/&gt;&lt;strong&gt;co_names&lt;/strong&gt; 是在函数体内引用的任意非本地名字的元组&lt;br/&gt;许多字节码指令--尤其是那些推入到栈中的加载值，或者在变量和属性中的存储值--在这些元组中的索引作为它们参数。&lt;/p&gt;
&lt;p&gt;因此，现在我们能够理解 hello() 函数中所列出的字节码：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;LOAD_GLOBAL&lt;/strong&gt; 0：告诉 Python 通过 co_names （它是 print 函数）的索引 0 上的名字去查找它指向的全局对象，然后将它推入到计算栈&lt;br/&gt;2、&lt;strong&gt;LOAD_CONST&lt;/strong&gt; 1：带入 co_consts 在索引 1 上的字面值，并将它推入（索引 0 上的字面值是 None，它表示在 co_consts 中，因为 Python 函数调用有一个隐式的返回值 None，如果没有显式的返回表达式，就返回这个隐式的值 ）。&lt;br/&gt;3、&lt;strong&gt;CALL_FUNCTION&lt;/strong&gt; 1：告诉 Python 去调用一个函数；它需要从栈中弹出一个位置参数，然后，新的栈顶将被函数调用。&lt;br/&gt;“原始的” 字节码--是非人类可读格式的字节--也可以在代码对象上作为 co_code 属性可用。如果你有兴趣尝试手工反汇编一个函数时，你可以从它们的十进制字节值中，使用列出 dis.opname 的方式去查看字节码指令的名字。&lt;/p&gt;
&lt;h3 id=&quot;基本反汇编&quot;&gt;基本反汇编&lt;/h3&gt;
&lt;p&gt;函数dis()可以打印 Python 源代码(模块、类、方法、函数或代码对象)的反汇编表示。可以通过从命令行运行 dis 来反汇编 dis_simple.py 之类的模块。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dis_simple.py
#!/usr/bin/env python3
# encoding: utf-8
my_dict = {'a': 1}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出按列组织，包含原始源代码行号，代码对象中的指令地址，操作码名称以及传递给操作码的任何参数。&lt;br/&gt;对于简单的代码我们可以通过命令行的形式执行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 -m dis dis_simple.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1           0 LOAD_CONST               0 ('a')
              2 LOAD_CONST               1 (1)
              4 BUILD_MAP                1
              6 STORE_NAME               0 (my_dict)
              8 LOAD_CONST               2 (None)
             10 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里源代码转换为4个不同的操作来创建和填充字典，然后将结果保存到一个局部变量。&lt;br/&gt;首先解释每一行各列参数的含义：&lt;br/&gt;以第一条指令为例：&lt;/p&gt;
&lt;p&gt;第一列 数字（1）表示对应源代码的行数。&lt;br/&gt;第二列（可选）指示当前执行的指令（例如，当字节码来自帧对象时)【这个例子没有】&lt;br/&gt;第三列 一个标签，表示从之前的指令到此可能的JUMP 【这个例子没有】&lt;br/&gt;第四列 数字是字节码中对应于字节索引的地址(这些是2的倍数，因为Python 3.6每条指令使用2个字节，而在以前的版本中可能会有所不同)指令LOAD_CONST在0位置。&lt;br/&gt;第五列 指令本身对应的人类可读的名字这里是&quot;LOAD_CONST&quot;&lt;br/&gt;第六列 Python内部用于获取某些常量或变量，管理堆栈，跳转到特定指令等的指令的参数（如果有的话）。&lt;br/&gt;第七列 计算后的实际参数。&lt;/p&gt;
&lt;p&gt;然后让我们看看这个过程：&lt;br/&gt;由于 Python 解释器是基于栈的，所以前几步是用LOAD_CONST将常量按正确顺序放入到栈中，然后使用 BUILD_MAP 弹出要增加到字典的新键和值。用 STORE_NAME 将所得到的dict对象绑定名为my_dict.&lt;/p&gt;
&lt;h3 id=&quot;反汇编函数&quot;&gt;反汇编函数&lt;/h3&gt;
&lt;p&gt;需要注意的是上面的命令行反编译的形式，不能自动的递归反编译函数，所以我们要使用在文件中导入dis的模式进行反编译，就像下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#dis_function.py
def f(*args):
    nargs = len(args)
    print(nargs, args)

if __name__ == '__main__':
    import dis
    dis.dis(f)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 dis_function.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后得到以下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  2           0 LOAD_GLOBAL              0 (len)
              2 LOAD_FAST                0 (args)
              4 CALL_FUNCTION            1
              6 STORE_FAST               1 (nargs)

  3           8 LOAD_GLOBAL              1 (print)
             10 LOAD_FAST                1 (nargs)
             12 LOAD_FAST                0 (args)
             14 CALL_FUNCTION            2
             16 POP_TOP
             18 LOAD_CONST               0 (None)
             20 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要查看函数的内部，必须把函数传递到dis().因为这里打印的是函数内部的东西，所以没有显示函数的在外层的行编号，而是从2开始的。&lt;/p&gt;
&lt;p&gt;下面解析下每一行指令的含义：&lt;br/&gt;1、LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号，这里是len函数，LOAD_FAST 一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等，这里就是传入参数args。&lt;br/&gt;2、一般是先指定要调用的函数，然后压参数，最后通过 CALL_FUNCTION 调用。&lt;br/&gt;3、STORE_FAST 保存值到局部变量。也就是把结果赋值给 STORE_FAST。&lt;br/&gt;4、下面的print因为2个参数所以LOAD_FAST了2次，POP_TOP删除堆栈顶部(TOS)项。LOAD_CONST加载const变量，比如数值、字符串等等，这里因为是print所以值为None。&lt;br/&gt;5、最后通过RETURN_VALUE来确定函数结尾。&lt;/p&gt;
&lt;p&gt;要打印一个函数的总结信息我们可以使用dis的show_code的方法，它包含使用的参数和名的相关信息，show_code的参数就是这个函数对象，代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(*args):
    nargs = len(args)
    print(nargs, args)

if __name__ == '__main__':
    import dis
    dis.show_code(f)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name:              f
Filename:          dis_function_showcode.py
Argument count:    0
Kw-only arguments: 0
Number of locals:  2
Stack size:        3
Flags:             OPTIMIZED, NEWLOCALS, VARARGS, NOFREE
Constants:
   0: None
Names:
   0: len
   1: print
Variable names:
   0: args
   1: nargs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到返回的内容有函数，方法，参数等信息。&lt;/p&gt;
&lt;h3 id=&quot;反汇编类&quot;&gt;反汇编类&lt;/h3&gt;
&lt;p&gt;上面我们知道了如何反汇编一个函数的内部，同样的我们也可以用类似的方法反汇编一个类。&lt;br/&gt;我们看一个例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import dis

class MyObject:
    &quot;&quot;&quot;Example for dis.&quot;&quot;&quot;

    CLASS_ATTRIBUTE = 'some value'

    def __str__(self):
        return 'MyObject({})'.format(self.name)

    def __init__(self, name):
        self.name = name

if __name__ == '__main__':
    dis.dis(MyObject)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之和得到如下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Disassembly of __init__:
 12           0 LOAD_FAST                1 (name)
              2 LOAD_FAST                0 (self)
              4 STORE_ATTR               0 (name)
              6 LOAD_CONST               0 (None)
              8 RETURN_VALUE

Disassembly of __str__:
  9           0 LOAD_CONST               1 ('MyObject({})')
              2 LOAD_METHOD              0 (format)
              4 LOAD_FAST                0 (self)
              6 LOAD_ATTR                1 (name)
              8 CALL_METHOD              1
             10 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从整体内容来看，结果分为了两部分Disassembly of __init__和Disassembly of __str__，Disassembly就是反汇编的意思。&lt;br/&gt;首先分析__init__部分：&lt;br/&gt;1、然后需要注意的一点是，方法是按照字母的顺序列出的，所以在部分，先看到name再看到self，但是他们都是 LOAD_FAST。&lt;br/&gt;2、STORE_ATTR实现self.name = name。&lt;br/&gt;3、然后LOAD_CONST一个None和RETURN_VALUE标志着函数结束。&lt;br/&gt;接下来分析__str__部分：&lt;br/&gt;1、LOAD_CONST将'MyObject({})'加载到栈&lt;br/&gt;2、然后通过 LOAD_METHOD 调用字符串format方法。这个方法是Python3.7新加入的。&lt;br/&gt;3、LOAD_FAST 也就是到了self了。&lt;br/&gt;4、LOAD_ATTR 一般是调用某个对象的方法时。这里就是self.name的.name操作&lt;br/&gt;5、CALL_METHOD 是 python3.7 新增加的内容，这里是执行方法。&lt;br/&gt;6、RETURN_VALUE表示函数的结束。&lt;br/&gt;上面字符串的拼接我们用了format,之前我一直推荐用f-string,下面就让我们通过字节码来分析，为什么f-string比format要高快。&lt;/p&gt;
&lt;p&gt;代码其他代码不变，把return改成以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;return f'MyObject({self.name})'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次执行，下面我们只看__str__函数的部分。&lt;br/&gt;&lt;code&gt;Disassembly of __str__: 9 0 LOAD_CONST 1 ('MyObject(') 2 LOAD_FAST 0 (self) 4 LOAD_ATTR 0 (name) 6 FORMAT_VALUE 0 8 LOAD_CONST 2 (')') 10 BUILD_STRING 3 12 RETURN_VALUE&lt;/code&gt;对比发现我们这里没有了调用方法的操作LOAD_METHOD,取而代之使用了用于实现fstring的FORMAT_VALUE指令。之后通过BUILD_STRING连接堆栈中的计数字符串并将结果字符串推入堆栈.为什么format慢呢， python中的函数调用具有相当大的开销。 当使用str.format()时,CALL_METHOD 中花费的额外时间是导致str.format()比fstring慢得多。&lt;/p&gt;
&lt;h3 id=&quot;使用反汇编调试&quot;&gt;使用反汇编调试&lt;/h3&gt;
&lt;p&gt;调试一个异常时，有时要查看哪个字节码带来了问题。这个时候就很有用了，要对一个错误周围的代码反汇编，有多种方法。第一种策略是在交互解释器中使用dis()报告最后一个异常。&lt;br/&gt;如果没有向dis()传入任何参数，那么它会查找一个异常，并显示导致这个异常的栈顶元素的反汇编效果。&lt;/p&gt;
&lt;h4 id=&quot;命令行上使用&quot;&gt;命令行上使用&lt;/h4&gt;
&lt;p&gt;打开我的命令行执行如下操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; chennan@chennandeMacBook-Pro-2  ~  python3
Python 3.8.0a3 (v3.8.0a3:9a448855b5, Mar 25 2019, 17:05:20)
[Clang 6.0 (clang-600.0.57)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import dis
&amp;gt;&amp;gt;&amp;gt; j = 4
&amp;gt;&amp;gt;&amp;gt; i = i + 4
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
NameError: name 'i' is not defined
&amp;gt;&amp;gt;&amp;gt; dis.dis()
  1 --&amp;gt;       0 LOAD_NAME                0 (i)
              2 LOAD_CONST               0 (4)
              4 BINARY_ADD
              6 STORE_NAME               0 (i)
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;行号后面的--&amp;gt;就是导致错误的操作码,一个LOAD_NAME指令，由于没有定义变量i，所以无法将与这个名关联的值加载到栈中。&lt;/p&gt;
&lt;h4 id=&quot;代码中使用distb&quot;&gt;代码中使用distb&lt;/h4&gt;
&lt;p&gt;程序还可以打印一个活动的traceback的有关信息，将它传递到distb()方法。&lt;/p&gt;
&lt;p&gt;下面的程序中有个DiviedByZero异常；但是这个公式有两个除法，所以不清楚是哪一部分出错，此时我们就可以使用下面的方法:&lt;br/&gt;dis_traceback.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i = 1
j = 0
k = 3

try:
    result = k * (i / j) + (i / k)
except Exception:
    import dis
    import sys
    exc_type, exc_value, exc_tb = sys.exc_info()
    dis.distb(exc_tb)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1           0 LOAD_CONST               0 (1)
              2 STORE_NAME               0 (i)

  2           4 LOAD_CONST               1 (0)
              6 STORE_NAME               1 (j)

  3           8 LOAD_CONST               2 (3)
             10 STORE_NAME               2 (k)

  5          12 SETUP_FINALLY           24 (to 38)

  6          14 LOAD_NAME                2 (k)
             16 LOAD_NAME                0 (i)
             18 LOAD_NAME                1 (j)
    --&amp;gt;      20 BINARY_TRUE_DIVIDE
             22 BINARY_MULTIPLY
             24 LOAD_NAME                0 (i)
             26 LOAD_NAME                2 (k)
             28 BINARY_TRUE_DIVIDE
...
        &amp;gt;&amp;gt;   96 END_FINALLY
        &amp;gt;&amp;gt;   98 LOAD_CONST               3 (None)
            100 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果反映的字节码很长我们不用全看了，看最开始出现--&amp;gt; 就可以知道错误的位置了。&lt;br/&gt;其中SETUP_FINALLY 字节码的含义是将try块从try-except子句推入块堆栈。&lt;br/&gt;这里可以看出将LOAD_NAME 将j压入栈之后就报错了。所以可以推断出在(i/j)就出错了。&lt;/p&gt;
&lt;p&gt;今天的内容就到这吧，更多精彩内容请关注公众号:python学习开发。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;https://docs.python.org/zh-cn/3.7/library/dis.html#opcode-STORE_FAST&lt;br/&gt;https://opensource.com/article/18/4/introduction-python-bytecode&lt;br/&gt;https://hackernoon.com/a-closer-look-at-how-python-f-strings-work-f197736b3bdb&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 16:23:00 +0000</pubDate>
<dc:creator>公众号python学习开发</dc:creator>
<og:description>如果你曾经写过或者用过 Python，你可能已经习惯了看到 Python 源代码文件；它们的名称以.Py 结尾。你可能还见过另一种类型的文件是 .pyc 结尾的，它们就是 Python “字节码”文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/10847501.html</dc:identifier>
</item>
<item>
<title>Spring Security 表达式(Expressions) - hasRole示例 - 程序猿Knight</title>
<link>http://www.cnblogs.com/xjknight/p/10887791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjknight/p/10887791.html</guid>
<description>&lt;h3 id=&quot;概述&quot;&gt;1.概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Spring Security使用强大的Spring Expression Language（SpEL）提供各种各样的表达&lt;/strong&gt;式。&lt;strong&gt;大多数这些Security表达式是针对上下文对象（当前经过身份验证的主体）进行工作的&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些表达式的评估由SecurityExpressionRoot执行 - 它提供了Web安全性和方法级安全性的基&lt;/strong&gt;础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Security 3.0中引入了使用SpEL表达式作为授权机制的能力&lt;/strong&gt;，并在Spring Security 4.x中继续使用，有关Spring Security中表达式的完整列表，请查看&lt;a href=&quot;https://www.baeldung.com/spring-security-expressions&quot;&gt;本指南&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;web授权&quot;&gt;2.Web授权&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Spring Security提供两种类型的Web授权 - 基于URL保护整页，并根据安全规则有条件地显示JSP页面的各个部分&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;full-page授权示例&quot;&gt;2.1.Full Page授权示例&lt;/h3&gt;
&lt;p&gt;通过为http元素启用表达式，可以按如下方式保护URL模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;http use-expressions = &quot;true&quot;&amp;gt;
    &amp;lt;intercept-url pattern=&quot;/admin/**&quot; access=&quot;hasRole('ROLE_ADMIN')&quot; /&amp;gt;
    ...
&amp;lt;/http&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用java配置&quot;&gt;使用Java配置：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
public class SecSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
          .authorizeRequests()
          .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Spring Security会自动为任何角色添加前缀ROLE_&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此处使用hasRole表达式来检查当前经过身份验证的主体是否具有指定的权限。&lt;/p&gt;
&lt;h3 id=&quot;在页面授权示例&quot;&gt;2.2.在页面授权示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第二种Web授权基于对Security表达式的评估有条件地显示JSP页面的某些部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;让我们在pom.xml中为Spring Security JSP taglib支持添加所需的依赖项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-security-taglibs&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须在页面上启用taglib支持才能使用Security命名空间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ taglib prefix=&quot;security&quot;
  uri=&quot;http://www.springframework.org/security/tags&quot; %&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;现在可以在页面上使用hasRole表达式&lt;/strong&gt;，当页面渲染时，基于经过身份验证的人显示/隐藏HTML元素.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;security:authorize access=&quot;hasRole('ROLE_USER')&quot;&amp;gt;
    This text is only visible to a user
    &amp;lt;br/&amp;gt;
&amp;lt;/security:authorize&amp;gt;
&amp;lt;security:authorize access=&quot;hasRole('ROLE_ADMIN')&quot;&amp;gt;
    This text is only visible to an admin
    &amp;lt;br/&amp;gt;
&amp;lt;/security:authorize&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法级别授权示例---preauthorize&quot;&gt;3.方法级别授权示例 - @PreAuthorize&lt;/h3&gt;
&lt;p&gt;通过使用注释，&lt;strong&gt;Security表达式还可用于在方法级别保护业务功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注&lt;strong&gt;释@PreAuthorize和@PostAuthorize（以及@PreFilter和@PostFilter）支持Spring Expression Language（SpEL）并提供基&lt;/strong&gt;于表达式的访问控制。&lt;/p&gt;
&lt;p&gt;首先，&lt;strong&gt;为了使用方法级安全性，我们需要使用@EnableGlobalMethodSecurity在安全性配置中启用它&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等效的XML配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;global-method-security pre-post-annotations=&quot;enabled&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后，我们可以使用Spring @PreAuthorize注释来保护方&lt;/strong&gt;法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class FooService {
    @PreAuthorize(&quot;hasRole('ROLE_ADMIN')&quot;)
    public List&amp;lt;Foo&amp;gt; findAll() { ... }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，只有具有ADMIN角色的用户才能成功调用findAll方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意，Pre和Post注释是通过代理进行评估和强制执行的 - 如果使用CGLIB代理，则不能将类和公共方法声明为final&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;编程检查角色&quot;&gt;4.编程检查角色&lt;/h3&gt;
&lt;p&gt;如果请求对象可用，还可以在原始Java代码中以编程方式检查用户权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RequestMapping
public void someControllerMethod(HttpServletRequest request) {
    request.isUserInRole(&quot;someAuthority&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，不访问请求，也可以简单的手动校验有特殊权限的已认证通过的用户。可以通过各种方式&lt;a href=&quot;https://www.baeldung.com/get-user-in-spring-security&quot;&gt;从Spring Security上下文中获取用&lt;/a&gt;户。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;5.总结&lt;/h3&gt;
&lt;p&gt;本教程简要&lt;strong&gt;介绍了一般使用Spring Security Expressions，特别是hasRole表达式&lt;/strong&gt; - 快速介绍如何保护应用程序的各个部分。&lt;/p&gt;
&lt;p&gt;有关W&lt;strong&gt;eb授权示例，请查看&lt;a href=&quot;https://github.com/eugenp/tutorials/tree/master/spring-security-mvc-login&quot;&gt;此Github简单教程&lt;/a&gt;。方法级安全性示例&lt;a href=&quot;https://github.com/eugenp/tutorials/tree/master/spring-rest-full&quot;&gt;也在GitHub&lt;/a&gt;上&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 16:03:00 +0000</pubDate>
<dc:creator>程序猿Knight</dc:creator>
<og:description>1.概述 Spring Security使用强大的Spring Expression Language（SpEL）提供各种各样的表达 式。 大多数这些Security表达式是针对上下文对象（当前经过身</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjknight/p/10887791.html</dc:identifier>
</item>
<item>
<title>this解惑 - Raion</title>
<link>http://www.cnblogs.com/raion/p/10887691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raion/p/10887691.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;要正确理解this，首先得理解执行上下文，这里推荐汤姆大叔的&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html&quot;&gt;执行上下文&lt;/a&gt;，因为&lt;code&gt;this&lt;/code&gt;是在运行代码时确认具体指向谁，箭头函数除外。&lt;/p&gt;
&lt;h4 id=&quot;全局作用域中的this&quot;&gt;全局作用域中的this&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;node&lt;/code&gt;&lt;/strong&gt;: 每个&lt;code&gt;javaScript&lt;/code&gt;文件都是一个模块，&lt;code&gt;this&lt;/code&gt;指向空对象（&lt;code&gt;module.exports&lt;/code&gt;）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.a = 1;
console.log(this, module.exports);
// { a: 1 } { a: 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也有些意外，比如下面这种情况:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.a = 1;
module.exports = {}
console.log(this, module.exports);
// { a: 1 } {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;浏览器端&lt;/strong&gt;: &lt;code&gt;this&lt;/code&gt;指向&lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;函数作用域中的this&quot;&gt;函数作用域中的this&lt;/h4&gt;
&lt;p&gt;这里分为两种，一种是全局作用域下直接执行函数，另外一种是被当作某个对象的属性的时候执行。eval的情况这里不作讨论。&lt;/p&gt;
&lt;h5 id=&quot;全局环境下执行&quot;&gt;全局环境下执行&lt;/h5&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function foo() {
  console.log(this); // 此时的执行上下文为全局对象
}
foo();
// node global, 浏览器 window&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然严格模式下有不同，具体区别如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;严格模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;指向&lt;code&gt;undefined&lt;/code&gt;(&lt;code&gt;node&lt;/code&gt; and 浏览器端)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非严格模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;浏览器端&lt;/strong&gt;: &lt;code&gt;this&lt;/code&gt;指向全局变量&lt;code&gt;window&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;node&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;this&lt;/code&gt;指向&lt;code&gt;global&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;被当作属性调用&quot;&gt;被当作属性调用&lt;/h5&gt;
&lt;p&gt;当函数作为一个对象的属性时，&lt;code&gt;node&lt;/code&gt;和浏览器端一致，指向调用该属性的对象&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = {
  name: 'foo',
  foo: function foo() {
    console.log(this);
  }
}

obj.foo();
// { name: 'foo', foo: [Function: foo] }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，做一些升级。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = {
  name: 'foo',
  foo: function foo() {
    console.log(this);
  }
}

var objA = obj.foo;

objA();
// node环境指向global，浏览器端指向window，严格模式下均指向undefined
--------------------------------------------------------------
var obj = {
  name: 'foo',
  foo: function foo() {
    console.log(this);
  }
}

var objA = {
  name: 'objA',
  foo: obj.foo
};

objA.foo();
// { name: 'objA', foo: [Function: foo] }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;callapplybind&quot;&gt;call、apply、bind&lt;/h5&gt;
&lt;p&gt;如果想手动更改函数里的&lt;code&gt;this&lt;/code&gt;指向，可通过上述3个方法。&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;会立即执行，&lt;code&gt;bind&lt;/code&gt;则返回一个绑定好&lt;code&gt;this&lt;/code&gt;指向的函数。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = {
  name: 'foo',
  foo: function foo() {
    console.log(this);
  }
}

var objA = {
  name: 'objA',
  foo: obj.foo
};

obj.foo.call(objA); // 将this指向objA
obj.foo.apply(objA);
obj.foo.bind(objA)(); // bind函数会返回一个绑定好this的函数，可供以后调用
/**
{ name: 'objA', foo: [Function: foo] }
{ name: 'objA', foo: [Function: foo] }
{ name: 'objA', foo: [Function: foo] }
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对上述3个方法进行更细的说明，方便更好的理解之间的差异。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var obj = {
  name: 'foo',
  foo: function foo() {
    console.log(this, arguments); // 通过arguments对象访问函数传入的参数列表，类似数组但不是数组，可通过arguments[0]访问到传入的Tom
  }
}

var objA = {
  name: 'objA',
  foo: obj.foo
};

obj.foo.call(objA, 'Tom', 'Jerry');
obj.foo.apply(objA, ['Tom', 'Jerry']);
obj.foo.bind(objA, 'Tom', 'Jerry')(1);
/**
{ name: 'objA', foo: [Function: foo] } [Arguments] { '0': 'Tom', '1': 'Jerry' }
{ name: 'objA', foo: [Function: foo] } [Arguments] { '0': 'Tom', '1': 'Jerry' }
{ name: 'objA', foo: [Function: foo] } [Arguments] { '0': 'Tom', '1': 'Jerry', '2': 1 }

可以看到call和bind是按序列传参，而apply是按数组传参，bind不会更改传参的顺序
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;new构造&quot;&gt;new构造&lt;/h5&gt;
&lt;p&gt;当函数被当作构造函数调用时，&lt;code&gt;this&lt;/code&gt;指向构造的那个对象。&lt;/p&gt;
&lt;p&gt;注：&lt;code&gt;new&lt;/code&gt;调用中的&lt;code&gt;this&lt;/code&gt;不会被&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;、&lt;code&gt;bind&lt;/code&gt;改变。&lt;/p&gt;
&lt;p&gt;接下来，简单验证一下，由于&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;会立即执行，无法被当作构造函数，只能选择&lt;code&gt;bind&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Foo() {
  console.log(this);
}
var foo = Foo.bind({ name: 'Tom' });
foo();
// { name: 'Tom' }
new foo();
// Foo {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;箭头函数中的this&quot;&gt;箭头函数中的this&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;在定义时，就已经知道其具体指向，因为在运行到声明的箭头函数时，会将&lt;code&gt;this&lt;/code&gt;进行强绑定到外部作用域中的&lt;code&gt;this&lt;/code&gt;，且无法更改。可以理解为继承了外部作用域中的&lt;code&gt;this&lt;/code&gt;。由于箭头函数的&lt;code&gt;this&lt;/code&gt;是确定的，无法更改，因此也无法被当作构造函数调用。&lt;/p&gt;
&lt;p&gt;外部作用域为全局作用域：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var foo = () =&amp;gt; {
  console.log(this);
}
this.a = 1;
foo();
// 或者下面代码
var obj = {
  name: 'obj',
  foo: () =&amp;gt; {
    console.log(this);
  }
}
var foo = obj.foo;
obj.foo();
foo();
foo.call({ name: 'Tom' });
/**
因为obj是在全局作用域下被定义，所以外部作用域为全局对象
node: 指向module.exports
浏览器：指向window
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外部作用域为函数作用域：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function foo() {
  var a = () =&amp;gt; {
    console.log(this); // 继承外部作用域foo函数的this
  };
  a();
}
foo();
foo.call({ name: 'foo' });
new foo();
/**
这里foo函数中的this并不确定，由于调用方式不同，其this指向也不同
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信写ES6类的情况很多，本人经常写&lt;code&gt;React&lt;/code&gt;类组件，刚开始初学者会好奇为什么在类组件里写方法时要用&lt;code&gt;bind&lt;/code&gt;或者箭头函数来强绑定&lt;code&gt;this&lt;/code&gt;。因为一般类组件里的方法，都会设计到&lt;code&gt;this&lt;/code&gt;的处理。比如事件处理函数，当触发相应事件时，调用事件对应的处理函数，此时访问到的&lt;code&gt;this&lt;/code&gt;为&lt;code&gt;undefined&lt;/code&gt;(ES6默认类与模块内就是严格模式)，这就导致不能正确处理该组件的状态，甚至出错(处理函数内可能调用&lt;code&gt;this.setState&lt;/code&gt;方法)。所以在类组件内部声明方法时会需要我们进行强绑定。&lt;/p&gt;
&lt;p&gt;接下来我们看看&lt;code&gt;React&lt;/code&gt;组件渲染流程：&lt;code&gt;new&lt;/code&gt;构造一个组件实例&lt;code&gt;instance&lt;/code&gt;，然后调用其&lt;code&gt;render&lt;/code&gt;方法进行渲染和事件绑定。&lt;code&gt;new&lt;/code&gt;构造的过程，&lt;code&gt;this&lt;/code&gt;已经确定指向构造的组件实例，所以你可以在&lt;code&gt;constructor&lt;/code&gt;进行&lt;code&gt;bind&lt;/code&gt;或直接使用箭头函数，这样函数内部&lt;code&gt;this&lt;/code&gt;就绑定到了&lt;code&gt;instance&lt;/code&gt;。&lt;code&gt;render&lt;/code&gt;函数里之所以能正常访问&lt;code&gt;this&lt;/code&gt;，是因为以&lt;code&gt;instance.render()&lt;/code&gt;进行渲染。&lt;/p&gt;
&lt;p&gt;当然这里不特指&lt;code&gt;React&lt;/code&gt;类组件，只要是ES6类，只能用&lt;code&gt;new&lt;/code&gt;构造调用，否则会报错，所以ES6类里&lt;code&gt;this&lt;/code&gt;指向是确定的，可以放心使用箭头函数。&lt;/p&gt;
&lt;h4 id=&quot;迷惑的代码&quot;&gt;迷惑的代码&lt;/h4&gt;
&lt;p&gt;还有一个比较迷惑的地方，遇到的机会很少，代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;(function(){
    console.log(this); // 运行结果和全局作用域下执行结果一致
})();
// 由于没有以对象属性的方式调用，则被认为是全局环境下调用
--------------------------------------------------------
(function(){
  console.log(this);
}).call({ name: 'Hello World' });
// { name: 'Hello World' }，this指向可以被改变
--------------------------------------------------------
new (function(name){
  this.name = name;
  console.log(this);
})('Tom');
// { name: 'Tom' }，this指向新创建的对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更好的阅读体验在我的&lt;a href=&quot;https://github.com/cy6121/front-notes&quot;&gt;github&lt;/a&gt;，欢迎👏提issue。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:50:00 +0000</pubDate>
<dc:creator>Raion</dc:creator>
<og:description>前言 要正确理解this，首先得理解执行上下文，这里推荐汤姆大叔的 '执行上下文' ，因为 是在运行代码时确认具体指向谁，箭头函数除外。 全局作用域中的this : 每个 文件都是一个模块， 指向空对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raion/p/10887691.html</dc:identifier>
</item>
<item>
<title>HttpUtility.UrlEncode讲解 - 向乾</title>
<link>http://www.cnblogs.com/liweilong/p/10887736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liweilong/p/10887736.html</guid>
<description>&lt;p&gt;hello 大家好，今天讲讲HttpUtility.UrlEncode编码&lt;/p&gt;
&lt;p&gt;HttpUtility.UrlEncode方法有4个重载分别如下&lt;/p&gt;
&lt;p&gt;我们有这么一个字符串&lt;/p&gt;
&lt;p&gt;string str = &quot;http://www.cnblogs.com/a file with spaces.html?a=1&amp;amp;b=博客园#abc&quot;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.使用HttpUtility.UrlEncode(str)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出效果如下：http&lt;span&gt;%3a&lt;/span&gt;&lt;span&gt;%2&lt;span&gt;f&lt;/span&gt;&lt;/span&gt;&lt;span&gt;%2&lt;/span&gt;fwww.cnblogs.com&lt;span&gt;%2f&lt;/span&gt;a&lt;span&gt;+&lt;/span&gt;file&lt;span&gt;+&lt;/span&gt;with&lt;span&gt;+&lt;/span&gt;spaces.html&lt;span&gt;%3f&lt;/span&gt;a&lt;span&gt;%3d&lt;/span&gt;1&lt;span&gt;%26&lt;/span&gt;b&lt;span&gt;%3d&lt;/span&gt;%e5%8d%9a%e5%ae%a2%e5%9b%ad&lt;span&gt;%23&lt;/span&gt;abc&lt;/p&gt;
&lt;p&gt;大家可以看出编码后对url及参数都进行了编码&lt;/p&gt;
&lt;p&gt;冒号(:)：%3a&lt;/p&gt;
&lt;p&gt;斜杠(/)：%2f&lt;/p&gt;
&lt;p&gt;空格：+&lt;/p&gt;
&lt;p&gt;问号(?)：%3f&lt;/p&gt;
&lt;p&gt;等号(=)：%3d&lt;/p&gt;
&lt;p&gt;与号(&amp;amp;)：%26&lt;/p&gt;
&lt;p&gt;井号(#)：%23&lt;/p&gt;
&lt;p&gt;所以呢，这玩意用起来感觉不太适合对URL进行编码，如果参数中有空格并没有转成 %20，而是转成了“+”号，对没有空格的url到是可以用下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.使用HttpUtility.UrlEncode(str, Encoding.UTF8)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出效果如下：http%3a%2f%2fwww.cnblogs.com%2fa+file+with+spaces.html%3fa%3d1%26b%3d%e5%8d%9a%e5%ae%a2%e5%9b%ad%23abc&lt;/p&gt;
&lt;p&gt;多了一个参数，可以指定编码类型而已，看上去和第一个没区别，我们换一个编码类型就有区别了，请看下边&lt;/p&gt;
&lt;p&gt;HttpUtility.UrlEncode(str, Encoding.UTF7)&lt;/p&gt;
&lt;p&gt;http%3a%2f%2fwww.cnblogs.com%2fa+file+with+spaces.html%3fa%2bAD0-1%2bACY-b%2bAD1TWluiVu0AIw-abc&lt;/p&gt;
&lt;p&gt;这下有区别了吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.使用HttpUtility.UrlEncode(byte[] bytes) 将字节数组转换为编码的 URL 字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;byte[] byteArray = Encoding.UTF8.GetBytes(str);获取utf8编码格式的字节数组  &lt;br/&gt;encodeStr = HttpUtility.UrlEncode(byteArray);然后对字节数组进行编码，输入效果等同于第一个&lt;/p&gt;
&lt;p&gt;不信看效果如下：&lt;/p&gt;
&lt;p&gt;http%3a%2f%2fwww.cnblogs.com%2fa+file+with+spaces.html%3fa%3d1%26b%3d%e5%8d%9a%e5%ae%a2%e5%9b%ad%23abc&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.使用HttpUtility.UrlEncode(byte[] bytes, int offset, int count);从数组中指定位置开始，按照指定字节数量，将字节数组转换为 URL 编码的字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;byte[] byteArray = Encoding.UTF8.GetBytes(str);获取utf8编码格式的字节数组  &lt;br/&gt;encodeStr = HttpUtility.UrlEncode(byteArray,0,5);然后对字节数组进行编码，从0位置开始去4个&lt;/p&gt;
&lt;p&gt;不信看效果如下：http%3a&lt;/p&gt;

&lt;p&gt;PS:HttpUtility.UrlEncode既然是编码，对应的肯定也有解码，就是HttpUtility.UrlEncode对应的也有以上4个方法，总不能给了编码之道不给破解之密吧&lt;/p&gt;
&lt;p&gt;好了，今天就到这了。晚安各位&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 15:47:00 +0000</pubDate>
<dc:creator>向乾</dc:creator>
<og:description>hello 大家好，今天讲讲HttpUtility.UrlEncode编码 HttpUtility.UrlEncode方法有4个重载分别如下 我们有这么一个字符串 string str = &quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liweilong/p/10887736.html</dc:identifier>
</item>
<item>
<title>干货：PHP与大数据开发实践 - 懂天明</title>
<link>http://www.cnblogs.com/xinlangboke/p/10887734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinlangboke/p/10887734.html</guid>
<description>&lt;p&gt;    大数据是使用工具和技术处理大量和复杂数据集合的术语。能够处理大量数据的技术称为MapReduce。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677606/201905/1677606-20190518234525891-880031911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;br/&gt;     很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学完往哪方面发展，想深入了解，想学习的同学欢迎加入大数据学习qq群：410391744，有大量干货（零基础以及进阶的经典实战）分享给大家，并且有清华大学毕业的资深大数据讲师给大家免费授课，给大家分享目前国内最完整的大数据高端实战实用学习流程体系。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;何时使用MapReduce&lt;/p&gt;&lt;p&gt;MapReduce特别适合涉及大量数据的问题。它通过将工作分成更小的块，然后可以被多个系统处理。由于MapReduce将一个问题分片并行工作，与传统系统相比，解决方案会更快。&lt;/p&gt;&lt;p&gt;大概有如下场景会应用到MapReduce：&lt;/p&gt;&lt;p&gt;1 计数和统计&lt;br/&gt;2 整理&lt;br/&gt;3 过滤&lt;br/&gt;4 排序 &lt;/p&gt;&lt;p&gt;Apache Hadoop&lt;/p&gt;&lt;p&gt;在本文中，我们将使用Apache Hadoop。&lt;br/&gt; &lt;br/&gt;开发MapReduce解决方案，推荐使用Hadoop，它已经是事实上的标准，同时也是开源免费的软件。&lt;br/&gt;另外在Amazon，Google和Microsoft等云提供商租用或搭建Hadoop集群。&lt;/p&gt;&lt;p&gt;还有其他多个优点：&lt;/p&gt;&lt;p&gt;可扩展：可以轻松清加新的处理节点，而无需更改一行代码&lt;br/&gt;成本效益：不需要任何专门和奇特的硬件，因为软件在正常的硬件都运行正常&lt;br/&gt;灵活：无模式。可以处理任何数据结构 ，甚至可以组合多个数据源，而不会有很多问题。&lt;br/&gt;容错：如果有节点出现问题，其它节点可以接收它的工作，整个集群继续处理。&lt;/p&gt;&lt;p&gt;另外，Hadoop容器还是支持一种称为“流”的应用程序，它为用户提供了选择用于开发映射器和还原器脚本语言的自由度。&lt;/p&gt;&lt;p&gt;本文中我们将使用PHP做为主开发语言。&lt;/p&gt;&lt;p&gt;Hadoop安装 &lt;/p&gt;&lt;p&gt;Apache Hadoop的安装配置超出了本文范围。您可以根据自己的平台，在线轻松找到很多文章。为了保持简单，我们只讨论大数据相关的事。&lt;/p&gt;&lt;p&gt;映射器（Mapper）&lt;/p&gt;&lt;p&gt;映射器的任务是将输入转换成一系列的键值对。比如在字计数器的情况下，输入是一系列的行。我们按单词将它们分开，把它们变成键值对（如key:word,value:1）,看起来像这样：&lt;/p&gt;&lt;p&gt;the       1&lt;br/&gt;water    1&lt;br/&gt;on        1&lt;br/&gt;on        1&lt;br/&gt;water    1&lt;br/&gt;on        1&lt;br/&gt;...         1&lt;/p&gt;&lt;p&gt;然后，这些对然后被发送到reducer以进行下一步骤。&lt;/p&gt;&lt;p&gt;reducer&lt;/p&gt;&lt;p&gt;reducer的任务是检索（排序）对，迭代并转换为所需输出。 在单词计数器的例子中，取单词数（值），并将它们相加得到一个单词（键）及其最终计数。如下：&lt;/p&gt;&lt;p&gt;water 2&lt;br/&gt;the   1&lt;br/&gt;on    3&lt;/p&gt;&lt;p&gt;mapping和reducing的整个过程看起来有点像这样，请看下列之图表：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fwww.21cto.com%2Fuploads%2Farticle%2F20170905%2F95132e057dd12d8ccd5367547386f8b7.jpg&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;diagram.jpg&quot; src=&quot;https://user-gold-cdn.xitu.io/2017/11/16/15fc38c9d2ea2200?imageslim&quot; alt=&quot;diagram.jpg&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2017/11/16/15fc38c9d2ea2200?imageslim&quot; data-width=&quot;1&quot; data-height=&quot;1&quot;/&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;使用PHP做单词计数器&lt;/p&gt;&lt;p&gt;我们将从MapReduce世界的“Hello World”的例子开始，那就是一个简单的单词计数器的实现。 我们将需要一些数据来处理。我们用已经公开的书Moby Dick来做实验。&lt;/p&gt;&lt;p&gt;执行以下命令下载这本书：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget http://www.gutenberg.org/cache ... 1.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;在HDFS（Hadoop分布式文件系统）中创建一个工作目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop dfs -mkdir wordcount
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;我们的PHP代码从mapper开始&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/php
&amp;lt;?php
    // iterate through lines
    while($line = fgets(STDIN)){
        // remove leading and trailing
        $line = ltrim($line);
        $line = rtrim($line);

        // split the line in words
        $words = preg_split('/\s/', $line, -1, PREG_SPLIT_NO_EMPTY);
        // iterate through words
        foreach( $words as $key ) {
            // print word (key) to standard output
            // the output will be used in the
            // reduce (reducer.php) step
            // word (key) tab-delimited wordcount (1)
            printf(&quot;%s\t%d\n&quot;, $key, 1);
        }
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;下面是 reducer 代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/php
&amp;lt;?php
    $last_key = NULL;
    $running_total = 0;

    // iterate through lines
    while($line = fgets(STDIN)) {
        // remove leading and trailing
        $line = ltrim($line);
        $line = rtrim($line);
        // split line into key and count
        list($key,$count) = explode(&quot;\t&quot;, $line);
        // this if else structure works because
        // hadoop sorts the mapper output by it keys
        // before sending it to the reducer
        // if the last key retrieved is the same
        // as the current key that have been received
        if ($last_key === $key) {
            // increase running total of the key
            $running_total += $count;
        } else {
            if ($last_key != NULL)
                // output previous key and its running total
                printf(&quot;%s\t%d\n&quot;, $last_key, $running_total);
            // reset last key and running total
            // by assigning the new key and its value
            $last_key = $key;
            $running_total = $count;
        }
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;你可以通过使用某些命令和管道的组合来在本地轻松测试脚本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;head -n1000 pg2701.txt | ./mapper.php | sort | ./reducer.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在Apache Hadoop集群上运行它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop jar /usr/hadoop/2.5.1/libexec/lib/hadoop-streaming-2.5.1.jar \
 -mapper &quot;./mapper.php&quot;
 -reducer &quot;./reducer.php&quot;
 -input &quot;hello/mobydick.txt&quot;
 -output &quot;hello/result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;输出将存储在文件夹hello / result中，可以通过执行以下命令查看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hdfs dfs -cat hello/result/part-00000

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;计算年均黄金价格&lt;/p&gt;&lt;p&gt;下一个例子是一个更实际的例子，虽然数据集相对较小，但是相同的逻辑可以很容易地应用于具有数百个数据点的集合上。 我们将尝试计算过去五十年的黄金年平均价格。&lt;/p&gt;&lt;p&gt;我们下载数据集：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://raw.githubusercontent. ... a.csv

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;在HDFS（Hadoop分布式文件系统）中创建一个工作目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop dfs -mkdir goldprice&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;将已下载的数据集复制到HDFS&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop dfs -copyFromLocal ./data.csv goldprice/data.csv
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;我的reducer看起来像这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/php
&amp;lt;?php
    // iterate through lines
    while($line = fgets(STDIN)){
        // remove leading and trailing
        $line = ltrim($line);
        $line = rtrim($line);

        // regular expression to capture year and gold value
        preg_match(&quot;/^(.*?)\-(?:.*),(.*)$/&quot;, $line, $matches);

        if ($matches) {
            // key: year, value: gold price
            printf(&quot;%s\t%.3f\n&quot;, $matches[1], $matches[2]);
        }
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;reducer也略有修改，因为我们需要计算项目数量和平均值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/php
&amp;lt;?php
    $last_key = NULL;
    $running_total = 0;
    $running_average = 0;
    $number_of_items = 0;

    // iterate through lines
    while($line = fgets(STDIN)) {
        // remove leading and trailing
        $line = ltrim($line);
        $line = rtrim($line);

        // split line into key and count
        list($key,$count) = explode(&quot;\t&quot;, $line);

        // if the last key retrieved is the same
        // as the current key that have been received
        if ($last_key === $key) {
            // increase number of items
            $number_of_items++;
            // increase running total of the key
            $running_total += $count;
            // (re)calculate average for that key
            $running_average = $running_total / $number_of_items;
        } else {
            if ($last_key != NULL)
                // output previous key and its running average
                printf(&quot;%s\t%.4f\n&quot;, $last_key, $running_average);
            // reset key, running total, running average
            // and number of items
            $last_key = $key;
            $number_of_items = 1;
            $running_total   = $count;
            $running_average = $count;
        }
    }

    if ($last_key != NULL)
        // output previous key and its running average
        printf(&quot;%s\t%.3f\n&quot;, $last_key, $running_average);
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;像单词统计样例一样，我们也可以在本地测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;head -n1000 data.csv | ./mapper.php | sort | ./reducer.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;最终在hadoop集群上运行它&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop jar /usr/hadoop/2.5.1/libexec/lib/hadoop-streaming-2.5.1.jar \
 -mapper &quot;./mapper.php&quot;
 -reducer &quot;./reducer.php&quot;
 -input &quot;goldprice/data.csv&quot;
 -output &quot;goldprice/result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看平均值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hdfs dfs -cat goldprice/result/part-00000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;小奖励：生成图表&lt;/p&gt;&lt;p&gt;我们经常会将结果转换成图表。 对于这个演示，我将使用gnuplot，你可以使用其它任何有趣的东西。&lt;/p&gt;&lt;p&gt;首先在本地返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hdfs dfs -get goldprice/result/part-00000 gold.dat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个gnu plot配置文件（gold.plot）并复制以下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Gnuplot script file for generating gold prices
set terminal png
set output &quot;chart.jpg&quot;
set style data lines
set nokey
set grid
set title &quot;Gold prices&quot;
set xlabel &quot;Year&quot;
set ylabel &quot;Price&quot;
plot &quot;gold.dat&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成图表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gnuplot gold.plot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会生成一个名为chart.jpg的文件。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:46:00 +0000</pubDate>
<dc:creator>懂天明</dc:creator>
<og:description>大数据是使用工具和技术处理大量和复杂数据集合的术语。能够处理大量数据的技术称为MapReduce。 很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinlangboke/p/10887734.html</dc:identifier>
</item>
<item>
<title>在线制作数据库ER模型 - csy2019</title>
<link>http://www.cnblogs.com/csy2019/p/10887724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csy2019/p/10887724.html</guid>
<description>&lt;p&gt;在以往的数据库设计中，我们通过会用到一些数据库的设计工具，有针对Mysql的Mysql workbench, PowerDesign等等工具，可以通过这些工具创建数据库的ER模型图，但是这些都是客户端应用程序需要下载完成，比较麻烦。&lt;/p&gt;
&lt;p&gt;今天搜索到一个在线制图网站，提供了对数据库ER模型进行在线设计而且可以通过导入sql的方式生成ER模型，功能相当实用。制作过程下面简单做一下介绍：&lt;/p&gt;
&lt;p&gt;之后做出图标库显示实体关系的图标，拖动图标就可以进行ER模型的设计，可以拖动一下Entity到视图面板中，看到里面还有实体与实体之间的关系，一对一，一对多，多对多的关系等等 通过一番折腾之后生成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632018/201905/1632018-20190518234234810-1332446892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线ER模型制图工具提供了一个从数据库sql语句中导入生成ER模型的功能，这个功能好，可以将数据库的DDL脚本导入直接生成ER模型&lt;/p&gt;
&lt;p&gt;选择&lt;code&gt;调整图形&lt;/code&gt;-&amp;gt;&lt;code&gt;插入&lt;/code&gt;-&amp;gt;&lt;code&gt;SQL…&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;a title=&quot;在线制图&quot; href=&quot;https://www.freedgo.com/&quot;&gt;&lt;img title=&quot;在线制图&quot; src=&quot;https://oscimg.oschina.net/oscnet/e81303caa0e4999db7f7c1f3bf5cd739776.jpg&quot; alt=&quot;在线制图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在文本框中输入sql内容!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632018/201905/1632018-20190518234330472-1006891512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终效果如下： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632018/201905/1632018-20190518234343768-708630511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:44:00 +0000</pubDate>
<dc:creator>csy2019</dc:creator>
<og:description>在以往的数据库设计中，我们通过会用到一些数据库的设计工具，有针对Mysql的Mysql workbench, PowerDesign等等工具，可以通过这些工具创建数据库的ER模型图，但是这些都是客户端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csy2019/p/10887724.html</dc:identifier>
</item>
</channel>
</rss>