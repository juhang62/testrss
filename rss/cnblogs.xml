<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>‘大案牍术’告诉你为什么《长安十二时辰》这么火！ - 猪哥66</title>
<link>http://www.cnblogs.com/pig66/p/11181571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pig66/p/11181571.html</guid>
<description>&lt;p&gt;这个夏天，《长安十二时辰》火了。&lt;br/&gt;易烊千玺、雷佳音主演；马伯庸同名小说改编。&lt;br/&gt;耗巨资花费七个月时间打造七十多亩长安城。&lt;br/&gt;这部剧史料严谨，造型考究，堪称良心制作。&lt;br/&gt;目前豆瓣评分也达到8.6的高分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190711180623863.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;吐槽下优酷的广告太长了，不过告诉大家一个小道消息，支付宝铂金会员可以使用会员积分兑换一个月优酷会员哦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599951/201907/1599951-20190713180216521-1395812353.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一、需求背景&lt;/h2&gt;
&lt;p&gt;故事主要是讲述了唐天宝三载，上元节当日的帝都长安。在一派歌舞升平的繁华盛景中，一群偷偷潜入的突厥狼卫酝酿着灭城的阴谋。只有一个死囚犯能挽救长安，时限为十二个时辰，进而引发惊心动魄的故事。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190711175645858.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在第一集中便出现了一个让猪哥好奇的专业术语“&lt;strong&gt;大案牍术&lt;/strong&gt;”&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190711230036852.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;于是带着疑问我就去问百度，还别说真有。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190711230326162.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可是，百度百科=白说，然后在弹幕君的指点下才知道这&lt;strong&gt;大案牍术&lt;/strong&gt;就相当于我们今天的大数据分析，最后不忘修改下百度百科。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712155107811.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;然后我便不再对这&lt;strong&gt;大案牍术&lt;/strong&gt;感到好奇，而是对弹幕大军产生兴趣，好奇大家为什么都喜欢看这部剧，大家的共同点在哪里？这部剧有哪些吸引大家的地方？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;二、功能描述&lt;/h2&gt;
&lt;p&gt;因最近刚好我们在讲爬虫与数据分析，所以就想用我们现代的&lt;strong&gt;大案牍术&lt;/strong&gt;来分析一下这不电视剧到底为什么会火，大家都对这部电视剧的评价是什么样的？（所有弹幕最高频的900个词）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713163456950.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;三、技术方案&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;分析某酷弹幕加载方式然后用requests库爬取&lt;/li&gt;
&lt;li&gt;需大量抓取数据，近可能多&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点做数据清洗&lt;/strong&gt;，比如：剧情、人名、高能君弹幕等等&lt;/li&gt;
&lt;li&gt;将弹幕做成云词&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;-&quot;&gt;四、技术实现&lt;/h2&gt;
&lt;p&gt;猪哥将会详细的讲解每一步的过程，希望感兴趣的同学可以认真阅读，然后自己动手实践，这样才能真的学习到知识。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本教程只为学习交流，不得用于商用获利，后果自负！&lt;br/&gt;如有侵权或者对任何公司或个人造成不利影响，请告知删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-url&quot;&gt;1.分析并获取弹幕接口的URL&lt;/h3&gt;
&lt;p&gt;第一步：打开某酷网站，然后点击电视剧播放，在页面中鼠标右键选择检查（或F12）调出浏览器的调试窗口。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712161657935.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第二步：复制任意一条弹幕，然后点击调试窗口按Control+F进行搜索！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712162512560.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第三步：点击该请求的&lt;code&gt;Headers&lt;/code&gt;按钮，查看请求url，并且注意请求头中的&lt;code&gt;Referer&lt;/code&gt;和&lt;code&gt;User-Agent&lt;/code&gt;参数。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712162916294.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;只需通过以上三步弹幕加载的url便被我们找到：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://service.danmu.youku.com/list?jsoncallback=jQuery111205151507831610791_1562918614483&amp;amp;mat=0&amp;amp;mcount=1&amp;amp;ct=1001&amp;amp;iid=1061156738&amp;amp;aid=322943&amp;amp;cid=97&amp;amp;lid=0&amp;amp;ouid=0&amp;amp;_=1562918614486&quot;&gt;https://service.danmu.youku.com/list?jsoncallback=jQuery111205151507831610791_1562918614483&amp;amp;mat=0&amp;amp;mcount=1&amp;amp;ct=1001&amp;amp;iid=1061156738&amp;amp;aid=322943&amp;amp;cid=97&amp;amp;lid=0&amp;amp;ouid=0&amp;amp;_=1562918614486&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.爬取弹幕数据&lt;/h3&gt;
&lt;p&gt;URL找到之后我们便可以开始coding了，还是老规矩：先从一条数据的抓取、提取、保存，这些都没问题之后我们再研究批量抓取。&lt;/p&gt;
&lt;p&gt;这里我们依然是用我们的&lt;code&gt;requests&lt;/code&gt;库来操作，不知道requests库是什么东西的老铁们先看看这篇文章：&lt;a href=&quot;https://blog.csdn.net/u014044812/article/details/94619026&quot;&gt;requests库介绍&lt;/a&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712164851398.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;有了上次的教训，我们这次直接把请求头加上，一次就把弹幕数据爬取到手。&lt;/p&gt;
&lt;h3 id=&quot;3-&quot;&gt;3.数据提取&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步：提取json数据&lt;/strong&gt;&lt;br/&gt;我们观察返回的数据会发现，和上一篇一样，跨域请求都是用的是jsonp，所以我们需要对返回的数据进行稍微的截取，就是将外面的&lt;code&gt;jQuery111203412576115734338_1562833192066(&lt;/code&gt;和最后的&lt;code&gt;)&lt;/code&gt;去掉，只保留中间的json数据。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712173229964.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里我们和上篇做了一个小小的改动：猪哥使用&lt;code&gt;r.text.index('(')&lt;/code&gt;获取到了回调函数的左括号的角标，然后再用这个角标去做切片，这样的好处是可以通用，即使jsonp返回函数名长度改变也不影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：提取弹幕数据&lt;/strong&gt;&lt;br/&gt;得到json之后，我们就来分析弹幕数据在哪里，我们可以在浏览器的调试窗口的&lt;code&gt;Preview&lt;/code&gt;里面查看&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712174711221.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到&lt;strong&gt;result&lt;/strong&gt;字段里面便是弹幕数据，而且他的数据格式是一个列表，列表中是每个弹幕对象，弹幕对象中的&lt;code&gt;content&lt;/code&gt;字段就是实际的弹幕内容，好那我们用json把他们提取并打印出来。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712175647594.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-&quot;&gt;4.数据保存&lt;/h3&gt;
&lt;p&gt;想要的数据提取出来之后，我们就可以把数据保存。数据保存我们还是使用文件来保存，原因是操作方便，满足需求。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712181925620.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-&quot;&gt;5.批量爬取&lt;/h3&gt;
&lt;p&gt;完成一次请求请求的爬取、提取、保存之后，我们来研究下如何批量保存数据。这里和其他批量爬取有所区别：&lt;strong&gt;如何爬取多集的批量数据？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在遇到问题和困难时，猪哥总是喜欢把事情或者工作量化，然后再细化，分步解决！&lt;/p&gt;
&lt;p&gt;这里我们就把批量爬取分为两步：&lt;strong&gt;第一步批量爬取一集的所有弹幕；第二步爬取多集的弹幕！&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：爬取某一集所有弹幕&lt;/strong&gt;&lt;br/&gt;批量爬取的关键就在于找到&lt;strong&gt;分页参数&lt;/strong&gt;，找分页的技巧就是：比较两个请求url的参数，看看有何不同。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712183549268.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们比较&lt;strong&gt;同一集&lt;/strong&gt;的&lt;strong&gt;第一次请求与第二次请求&lt;/strong&gt;的url发现&lt;code&gt;mat&lt;/code&gt;参数不同，而且还是依次递增的趋势，这个参数便是我们寻找的分页参数（其实mat参数表示分钟数，表示获取第几分钟的弹幕），找到分页参数后我们就可以对原方法改造，改造思路：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将原url中分页参数变为可变参数，由方法传入。然后新建一个批量爬取的方法，循环调用单次爬取方法，每次调用传入页数即可！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712205931119.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;第二步：爬取多集的所有弹幕&lt;/strong&gt;&lt;br/&gt;这一步的关键在于找到代表集数的参数，我们可以同样可以使用对比的方法：&lt;strong&gt;比较第一集与第二集的第一个弹幕请求URL&lt;/strong&gt;，从而找到不同参数！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019071221180084.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们发现第一集的&lt;code&gt;iid=1061156738&lt;/code&gt;、第二集的&lt;code&gt;iid=1061112026&lt;/code&gt;，但是这个&lt;code&gt;iid&lt;/code&gt;参数并不是递增，如何找到规律？&lt;/p&gt;
&lt;p&gt;这时候我们还是要回到网页中寻找答案，我们复制第一集的iid值&lt;code&gt;1061156738&lt;/code&gt;到浏览器的调试窗口搜索，找到iid就是某接口的&lt;code&gt;vid&lt;/code&gt;值。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712212606296.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;找到集数参数之后，我们就可以写一个函数将所有集数参数爬取到。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712232527901.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;令牌为空？很奇怪，URL和headers我们都填了为什么还是不行？而浏览器却可以？&lt;/p&gt;
&lt;p&gt;这里需要引入另一个请求头：&lt;code&gt;Cookie&lt;/code&gt;，Cookie是干什么的？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为HTTP协议是无状态协议，也就是说下次再请求服务器并不知道你是谁，所以就用Cookie和Seesion来记录状态，最简单的例子就是用户登录后，服务器就给浏览器遗传一串加密字符串（key），然后服务器自己缓存一个key-value，这样浏览器每次来请求都带上这个key，服务器就知道你是哪个用户！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于篇幅有限今天只给大家简单介绍，考虑其重要性，后面猪哥会专门写一篇文章介绍Cookie。&lt;/p&gt;
&lt;p&gt;那我们去哪里找Cookie呢？答案当然是浏览器咯！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712235042733.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;那这么多Cookie到底哪个才是我们要找的那个？这个谁也不知道，也不用找，我们直接把所有Cookie复制到代码里面就可以。&lt;/p&gt;
&lt;p&gt;但是这种表格形式的根本无法复制，有没有什么小技巧能方便我们复制Cookie吗？当然有，我们点击浏览器调试窗口的&lt;code&gt;Console&lt;/code&gt;按钮，然后输入&lt;code&gt;document.cookie&lt;/code&gt;就可以看到全部Cookie啦，直接复制出来就可以，是不是很方便！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712235656299.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们把Cookie复制到代码里试试吧，注意Cookie有过期时间，尤其是这个token大概十几分钟可能就会过期，过期之后在浏览器中重新复制即可！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712235921697.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们可以观察到返回的数据同样是个jsonp函数，同样需要提取内部的json数据，所以我们可以封装一个公用方法，用于提取jsonp返回的数据转为json对象，这样提高了复用性！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713010015902.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;得到json数据之后没我们通过观察可以得到知其数据结构，然后将vid提取出来并返回，上图猪哥返回了一个生成器！&lt;/p&gt;
&lt;p&gt;代表集数的id拿到了，现在我们就可以双层循环去爬所有的弹幕啦，上代码。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713010846484.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;一共爬取了近30万条的数据，大概用了40分钟，当然如果你觉得时间间隔太长也可缩短，但是建议不要太频繁，不然对人家服务器或者被监控到就不好！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713103645651.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-&quot;&gt;6.数据清洗+生成词云&lt;/h3&gt;
&lt;p&gt;我们要清洗什么数据？其实这个事先很难猜到，所以我们不做数据清洗直接生成云词看看会是什么效果，然后再做调整。关于云词的生成介绍猪哥在上篇&lt;a href=&quot;https://pig66.blog.csdn.net/article/details/95198791&quot;&gt;爬取京东商品评价并生成词云&lt;/a&gt;已经为大家讲过！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713155109328.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们可以看到右侧生成的词云，像：哈哈、不是、这个、什么等这些词比较多，这种单词没有太大的分析价值，所以我们数据清洗便有了方向。（ps：某酷的弹幕没啥内涵。。。）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713161528838.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;猪哥添加了一份清洗词列表，这样就可以将这些词屏蔽掉，然后我们再来看看效果吧！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190713163456950.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-&quot;&gt;7.分析词云图&lt;/h3&gt;
&lt;p&gt;从上面的词云图中我们可以分析出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;此电视剧中的一些主角：张小敬、李必、崔器、龙波、徐斌、竟然还有人喜欢曹破延。&lt;/li&gt;
&lt;li&gt;有人说好看，有人说看不懂，说明剧情可能有点深度&lt;/li&gt;
&lt;li&gt;画风可能有点像刺客信条&lt;/li&gt;
&lt;li&gt;四字弟弟、千玺，说明剧中有易烊千玺&lt;/li&gt;
&lt;li&gt;片尾曲可能有惊喜&lt;/li&gt;
&lt;li&gt;大唐、长安说明了故事背景&lt;/li&gt;
&lt;li&gt;弹幕、智商，可能大家在提醒你：关弹幕，保智商！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前此剧已更新完第一季（20集），真的是一部国产良心剧，画质、服装、礼节、拍摄、剧本、演技都堪称一流，推荐大家看看！&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;我们来从技术层面分析总结一下今天这篇文章，本篇文章看似与上一篇&lt;a href=&quot;https://pig66.blog.csdn.net/article/details/95198791&quot;&gt;爬取京东商品评价并生成词云&lt;/a&gt;流程很类似，但是更难一点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;此次爬取的弹幕不仅要找分页参数，而且要找分集的参数&lt;/li&gt;
&lt;li&gt;这次爬取弹幕需要用到Cookie，而且有过期时间&lt;/li&gt;
&lt;li&gt;此次数据量大，对电脑性能可能会有点考验&lt;/li&gt;
&lt;li&gt;在生成词云时有数据清洗&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;周末、瓜子花生和啤酒 、看剧编程两不误，人生岂不美滋滋！&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/pig6/youku_danmu_spider&quot;&gt;https://github.com/pig6/youku_danmu_spider&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213155258.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jul 2019 00:45:00 +0000</pubDate>
<dc:creator>猪哥66</dc:creator>
<og:description>这个夏天，《长安十二时辰》火了。易烊千玺、雷佳音主演；马伯庸同名小说改编。耗巨资花费七个月时间打造七十多亩长安城。这部剧史料严谨，造型考究，堪称良心制作。目前豆瓣评分也达到8.6的高分。 吐槽下优酷的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pig66/p/11181571.html</dc:identifier>
</item>
<item>
<title>.Net项目中NLog的配置与使用 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11182958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11182958.html</guid>
<description>&lt;h2&gt;引言：&lt;/h2&gt;
&lt;p&gt;　　因为之前在项目开发中一直都是使用的Log4Net作为项目的日志记录框架，最近忽然感觉对它已经有点腻了，所以尝试着使用了NLog作为新项目的日志记录框架（当然作为一名有志向的攻城狮永远都不能只局限于眼前的技术，要不断的使用和学习新的技术）。当然serilog也是一个不错的日志记录框架哟，不过今天主要还是要讲述的是NLog在项目中的配置和使用。&lt;/p&gt;
&lt;p&gt;NLog框架源码：&lt;a href=&quot;https://github.com/NLog/NLog&quot;&gt;https://github.com/NLog/NLog&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、导入NLog NuGet PackAge：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190714033721125-1880755058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190714033815504-1845206656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 二、配置NLog 配置文件：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：在这里我是专门新建了一个NLog.config 配置文件用来进行独立配置，当然你也可以在web.config中完成相应的配置！！&lt;/strong&gt;&lt;br/&gt;NLog详细配置文件信息，请查看官网说明：&lt;a href=&quot;https://github.com/nlog/nlog/wiki/configuration-file&quot; target=&quot;_blank&quot;&gt;https://github.com/nlog/nlog/wiki/configuration-file&lt;/a&gt;&lt;br/&gt;可参考晓晨大佬的NLog配置：&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8504860.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/stulzq/p/8504860.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;a、我的NLog.config 配置代码:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nlog &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;&lt;/span&gt;&lt;span&gt;
      xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;此部分中的所有目标将自动异步&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;asyncFile&quot;&lt;/span&gt;&lt;span&gt; xsi:type&lt;/span&gt;&lt;span&gt;=&quot;AsyncWrapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;项目日志保存文件路径说明fileName=&quot;${basedir}/保存目录，以年月日的格式创建/${shortdate}/${记录器名称}-${单级记录}-${shortdate}.txt&quot;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;log_file&quot;&lt;/span&gt;&lt;span&gt; xsi:type&lt;/span&gt;&lt;span&gt;=&quot;File&quot;&lt;/span&gt;&lt;span&gt;
              fileName&lt;/span&gt;&lt;span&gt;=&quot;${basedir}/ProjectLogs/${shortdate}/${logger}-${level}-${shortdate}.txt&quot;&lt;/span&gt;&lt;span&gt;
              layout&lt;/span&gt;&lt;span&gt;=&quot;${longdate} | ${message} ${onexception:${exception:format=message} ${newline} ${stacktrace} ${newline}&quot;&lt;/span&gt;&lt;span&gt;
              archiveFileName&lt;/span&gt;&lt;span&gt;=&quot;${basedir}/archives/${logger}-${level}-${shortdate}-{#####}.txt&quot;&lt;/span&gt;&lt;span&gt;
              archiveAboveSize&lt;/span&gt;&lt;span&gt;=&quot;102400&quot;&lt;/span&gt;&lt;span&gt;
              archiveNumbering&lt;/span&gt;&lt;span&gt;=&quot;Sequence&quot;&lt;/span&gt;&lt;span&gt;
              concurrentWrites&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
              keepFileOpen&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用可自定义的着色将日志消息写入控制台&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;colorConsole&quot;&lt;/span&gt;&lt;span&gt; xsi:type&lt;/span&gt;&lt;span&gt;=&quot;ColoredConsole&quot;&lt;/span&gt;&lt;span&gt; layout&lt;/span&gt;&lt;span&gt;=&quot;[${date:format=HH\:mm\:ss}]:${message} ${exception:format=message}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;规则配置,final - 最终规则匹配后不处理任何规则&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.*&quot;&lt;/span&gt;&lt;span&gt; minlevel&lt;/span&gt;&lt;span&gt;=&quot;Info&quot;&lt;/span&gt;&lt;span&gt; writeTo&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; final&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt; minlevel&lt;/span&gt;&lt;span&gt;=&quot;Info&quot;&lt;/span&gt;&lt;span&gt; writeTo&lt;/span&gt;&lt;span&gt;=&quot;asyncFile&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt; minlevel&lt;/span&gt;&lt;span&gt;=&quot;Warn&quot;&lt;/span&gt;&lt;span&gt; writeTo&lt;/span&gt;&lt;span&gt;=&quot;colorConsole&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nlog&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;b、NLog配置文件信息简单概述：&lt;/h3&gt;
&lt;h4&gt;1、rules【规则】说明：&lt;/h4&gt;
&lt;p&gt;　　规则是logger具有以下属性的元素：&lt;br/&gt;name - 记录器名称过滤器 - 可能包含通配符（*和？）&lt;br/&gt;minlevel - 记录的最低级别&lt;br/&gt;maxlevel - 记录的最高级别&lt;br/&gt;level - 单级记录&lt;br/&gt;levels - 逗号分隔的记录级别列表&lt;br/&gt;writeTo - 逗号分隔的要写入的目标列表&lt;br/&gt;final - 最终规则匹配后不处理任何规则&lt;br/&gt;enabled- 设置为false禁用规则而不删除它&lt;br/&gt;ruleName- 规则标识符，允许使用Configuration.FindRuleByName和进行规则查找Configuration.RemoveRuleByName。在NLog 4.6.4中引入&lt;br/&gt;注意：虽然命名了规则logger，但它没有定义记录器。它引用一个或多个记录器。&lt;br/&gt;通过将规则name模式与记录器名称匹配，将规则映射到记录器。规则name属性可以包括通配符（*和？），以通过通配符匹配来匹配记录器名称。&lt;br/&gt;* - 匹配0个或更多字符&lt;br/&gt;? - 恰好匹配1个字符&lt;/p&gt;
&lt;h4&gt;2、targets【目标】：&lt;/h4&gt;
&lt;p&gt;　　每个目标由一个target元素表示。每个目标需要两个属性：&lt;br/&gt;name - 目标名称&lt;br/&gt;type - 目标类型 - 例如“文件”，“数据库”，“邮件”。使用名称空间时，此属性已命名xsi:type。&lt;br/&gt;除了这些属性之外，目标通常还接受其他参数，这些参数会影响诊断跟踪的写入方式。每个目标都有一组不同的参数，它们在项目主页上有详细描述，并且它们是上下文相关的。Intellisense也可以在Visual Studio中使用。&lt;br/&gt;例如，File目标接受fileName定义输出文件名的参数，Console目标具有error参数，该参数确定诊断跟踪是否写入标准错误（stderr）而不是进程的标准输出（stdout）。&lt;br/&gt;此示例演示了一个targets定义多个目标的部分：两个文件，一个网络目标和OutputDebugString目标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; targets &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; target &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;f1 ” xsi ：type &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;File ” fileName &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;file1.txt ” &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; target &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;f2 ” xsi ：type &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;File ” fileName &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;file2.txt ” &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; target &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;n1 ” xsi ：type &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;Network ” address &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;tcp：// localhost：4001 ” &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; target &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;ds ” xsi ：type &lt;/span&gt;&lt;span&gt;= “ &lt;/span&gt;&lt;span&gt;OutputDebugString ” &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt; targets &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NLog提供了许多预定义的目标。实际上创建自己的&lt;span&gt;&lt;a href=&quot;https://github.com/nlog/nlog/wiki/Targets&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;非常容易 - 请参阅如何编写&lt;span&gt;&lt;a href=&quot;https://github.com/nlog/nlog/wiki/How-to-write-a-custom-target&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;自定义目标&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;三、NLog使用：&lt;/h2&gt;
&lt;p&gt;　　在这里，我封装了一个NLog使用帮助类，提供给全站调用，这样就可以避免在不同的类中实例化Nlog对象的步骤。&lt;/p&gt;
&lt;p&gt;LoggerHelper.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; nLog使用帮助类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerHelper
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实例化nLog，即为获取配置文件相关信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; NLog.Logger _logger =&lt;span&gt; LogManager.GetCurrentClassLogger();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LoggerHelper _obj;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LoggerHelper _
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt; _obj ?? (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerHelper());
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _obj =&lt;span&gt; value;
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Debug，调试
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Debug(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Debug(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Debug(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Debug(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Info，信息
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Info(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Info(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Info(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Info(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Warn，警告
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Warn(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Warn(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Warn(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Warn(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Trace，追踪
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Trace(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Trace(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Trace(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Trace(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Error，错误
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Error(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Error(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Fatal,致命错误
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Fatal(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            _logger.Fatal(msg);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Fatal(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, Exception err)
        {
            _logger.Fatal(err, msg);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、运行记录结果：&lt;/h2&gt;
&lt;p&gt;　　因为我在NLog.config配置文件中配置的日志存储路径为：ProjectLogs/当前时间（yyyy-MM-dd）/&lt;br/&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190714034540648-994002738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190714034601651-347788623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190714035605850-1090406747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 13 Jul 2019 19:57:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>引言： 因为之前在项目开发中一直都是使用的Log4Net作为项目的日志记录框架，最近忽然感觉对它已经有点腻了，所以尝试着使用了NLog作为新项目的日志记录框架（当然作为一名有志向的攻城狮永远都不能只局</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11182958.html</dc:identifier>
</item>
<item>
<title>简单看看原码、补码和反码 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/11175578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/11175578.html</guid>
<description>&lt;p&gt;　　最近这破事贼多，都没有什么时间写写博客，都好久都没有更新博客了！不过平常看jdk源码的时候有很大的感触，就是基础真的很重要，那什么是基础呢？除了java的基本语法之外，最基础的莫过于原码，反码和补码了以及基本的运算了！&lt;/p&gt;
&lt;p&gt;　　又是我是编程半路出家，最开始的时候学过一点这些东西，当时只是感觉，擦！我是写代码的，这些原码什么的有个鸡儿用，有时间看这个还不如多写点代码！但是现在，看了不少源码，回头一看却突然发现自己基础太薄弱了，赶紧补一下基础，装作基础很扎实的样子@_@&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.原码、反码和补码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　  &lt;/strong&gt;&lt;span&gt;大家应该都知道，数据在计算机中是以二进制的形式存在的，&lt;/span&gt;&lt;/span&gt;比如 byte a = 6;  byte b = -6&lt;/p&gt;
&lt;p&gt;　　分为两种情况来说，一种是正数，一种是负数；对于正数6来说，原码就是0000 0110，反码和补码也是这个；而对于-6来说，原码就是1000 0110，这是为什么呢？因为最高位（最左边的）是表示符号，0表示正数，1表示负数；&lt;/p&gt;
&lt;p&gt;　　不管是byte，short，int还是其他的数字，最高位都是用来表示符号的，所以-6的原码就是1000 0110，负数的反码就是符号不变，其他的取反，就是1111 1001；负数的补码就是在反码的基础上加1就行了，由于是二进制的，是逢2进1，所以补码就是：1111 1010,；&lt;/p&gt;
&lt;p&gt;　　注意：计算机中的加减运算（计算机中只有加法，可以通过加法表示减法，就是用过补码的形式，看下面栗子）指的是补码之间的运算！而且负数在计算机中是以补码的形式存在并参与运算的，如果要变为十进制，就首先需要变为原码然后才能变为十进制或其他进制的数；&lt;/p&gt;
&lt;p&gt;　　那么0怎么表示呢？我们可以简单看看：0 = 6-6 = 6+（-6）= [0000 0110]&lt;sub&gt;补&lt;/sub&gt;+[1111 1010]&lt;sub&gt;补&lt;/sub&gt;=[0000 0000]&lt;sub&gt;补&lt;/sub&gt;=[0000 0000]&lt;sub&gt;原&lt;/sub&gt;，那么有人要问了，补码1000 0000那又表示多少呢？再看一个简单的-1-127=（-1）&lt;/p&gt;
&lt;p&gt;+（-127）= [1000 0001]&lt;sub&gt;原&lt;/sub&gt;+[1111 1111]&lt;sub&gt;原 &lt;/sub&gt;= [1111 1111]&lt;sub&gt;补&lt;/sub&gt;+[1000 0001]&lt;sub&gt;补 &lt;/sub&gt;= [1000 0000]&lt;sub&gt;补=&lt;/sub&gt;[0000 0000]&lt;sub&gt;原&lt;/sub&gt;，两个对比一下，如果都使用原码的话同一个原码[0000 0000]&lt;sub&gt;原&lt;/sub&gt;可以表示两个数0和-128，而用补码的话却可以一个补码对应单独的一个数，很明显，一个补码对应一个数更符合我们的需求！！！&lt;/p&gt;
&lt;p&gt;　　补充一下，对于负数来说，原码和反码之间相互转化，试着理解着记忆：&lt;/p&gt;
&lt;p&gt;　　　　原码------&amp;gt;反码：符号位不变，其他位取反 ；比如 [1000 0001]&lt;sub&gt;原 &lt;/sub&gt;=  [1111 1110]&lt;sub&gt;反&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　原码------&amp;gt;补码：符号位不变，其他位取反，然后+1；比如 [1000 0001]&lt;sub&gt;原 &lt;/sub&gt;=  [1111 1111]&lt;sub&gt;补&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　 　   反码-------&amp;gt;原码：符号位不变，其他位取反；比如 [1111 1110]&lt;sub&gt;反&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;=  [1000 0001]&lt;sub&gt;原&lt;br/&gt;&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　反码-------&amp;gt;补码：+1  ；比如 [1111 1110]&lt;sub&gt;反&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;=  [1111 1111]&lt;sub&gt;补&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　补码-------&amp;gt;原码：符号位不变，其他位取反，然后+1；比如 [1111 1111]&lt;sub&gt;补&lt;/sub&gt; = [1000 0001]&lt;sub&gt;原 &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　　　补码---------&amp;gt;反码：先变为原码，然后变反码；比如 [1111 1111]&lt;sub&gt;补 &lt;/sub&gt;=[1111 1110]&lt;sub&gt;反&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt; 　　这些都是基本的东西，只要记住在计算机中运算的话，都是以补码的形式，而且这里就会涉及到一个过程，画一个简单的图，计算机中运算都是用补码来进行的；而中间的转化过程计算机可以十分迅速的转化，这个就不用我们操心；下面我们就看看那个运算到底包括哪些运算。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201907/1368608-20190713084309100-313257889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.基本的运算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　说起现实中的运算，无非就是四则运算，加减乘除，而对应于计算机中也有加减乘除，加减已经在上面说了，可以用补码的加法来实现加减，但是乘除呢？在这里我们就说说最简单的乘除法啊，乘以2和除以2这种，如果是乘除其他数还是比较复杂的，暂时我也没有什么兴趣研究，有兴趣的小伙伴可以查查计算机中乘除法的实现，你会沉迷其中不可自拔！&lt;/p&gt;
&lt;p&gt;　　以byte类型来举例，byte类型最高位是符号位，所以范围是在1111 1111到01111 1111之间，变成十进制也就是-127到127，加上0000 0000这个原码对应两个数0和-128，所以整个的范围就是-128到127；&lt;/p&gt;
&lt;p&gt;　　乘除也是分为两大块，正数和负数；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.1 正数乘2运算（左移用&amp;lt;&amp;lt;表示）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们看看一个简单的数（这里我正数也写一下补码）：byte a = 5; 5的原码为：[0000 0101]&lt;sub&gt;原&lt;/sub&gt;=[0000 0101]&lt;sub&gt;补&lt;/sub&gt; ；乘以2就等于10,原码为[0000 1010]&lt;sub&gt;原&lt;/sub&gt;=[0000 1010]&lt;sub&gt;补 &lt;br/&gt;&lt;/sub&gt;　　看看这两个补码有什么关系？就是将5的补码最右边添加一个0，最左边去掉一个0！最好是将5的补码看作一个整体，这个整体向左移动一位，左边超过的位数直接去掉，右边空的位置添0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201907/1368608-20190713203925434-417875002.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这个时候会有一个问题，假如二进制补码是0100 0000，也就是64,向左移动一位，你觉得是多少？答案是-128，按理来说应该是正数的128啊，为什么是负的呢？记住，这个移位操作是会覆盖符号位的，往左移动一位的补码是1000 0000，注意，这里千万不要变成原码，在第一节中说过了补码为1000 0000的就是-128（这两个补码一定要注意点，很特殊，0000 0000代表十进制的0，1000 0000代表十进制的-128！千万不要变成原码比较，因为他们的原码都是0000 0000无法区分）&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; num() {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a = 64&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b = (&lt;span&gt;byte&lt;/span&gt;) (a&amp;lt;&amp;lt;1&lt;span&gt;);
        System.out.println(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-128&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.2 正数除2运算（右移用&amp;gt;&amp;gt;表示）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;既然往左移动一位是乘以2，那么往右移动一位肯定是除以2了！但是记住一个规律，往右移动的话，右边超出来的部分去掉，左边空出来的位置添加和符号位相同的数！（记住了规律这个负数的右移一样的）&lt;/p&gt;
&lt;p&gt;　　举个例子，65的补码0100 0001，向右移动一位，补码应该是0010 0000，记住，此时最左边的0是根据符号位是0才添加的0，是正数，右移后的原码和补码一样，那么变成十进制应该是32，这里可以看出一个大于0的奇数右移一位的结果就是除以2然后向下取整，偶数的话直接就是除以2了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; num() {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a = 65&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b = (&lt;span&gt;byte&lt;/span&gt;) (a&amp;gt;&amp;gt;1&lt;span&gt;);
        System.out.println(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;2.3 负数乘2运算（&amp;lt;&amp;lt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　正数其实比较容易，但是负数的话就稍微麻烦一点！例如-127的补码是1000 0001，左移一位的补码0000 0010，由于这个补码是正的，所以原码也是这个，变成十进制就是2，有没有觉得特别有意思，哈哈哈！知道为什么吗？因为byte的范围是-128到127啊，只要是超过了这个范围的就会变成你想不到的数！&lt;/p&gt;
&lt;p&gt;　　再举个没有超过范围的例子，-6的补码是1111 1010，左移一位的补码就是1111 0100，由于是负的，变成原码为1000 1100，也就是对应十进制的-12，这个结果和想象的一样！&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.4 负数除2运算（&amp;gt;&amp;gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　记住在2.2中说的一句话，向右移动的话，最右边超过的部分直接去掉，左边空出来的位置填上和符号位相同的数！说起来很抽象，举个栗子：-6的补码是1111 1010，往右移动一个位置的补码就是1111 1101，是负的，变成原码就知道对应的十进制是多少了。。。。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.5.无符号右移（&amp;gt;&amp;gt;&amp;gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本来都说了正负数的左移和右移应该就说完了，但是呢，还有一个比较特殊的运算方式，就是无符号右移（注意只有无符号右移，没有无符号左移啊！），简单的来说就是不管正数负数，只要是右移的话，最右边超过的部分直接丢掉，左边空出来的位置都添0就ok了！&lt;/p&gt;
&lt;p&gt;　　好像也没什么可说的，简单举个栗子吧！-6的补码是1111 1010，无符号右移一位的补码就是0111 1101，正的，原码和补码一样，所以对应的十进制是应该是125，然而实际情况有点问题，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@org.junit.Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; num() {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a = -6&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b = (&lt;span&gt;byte&lt;/span&gt;) (a&amp;gt;&amp;gt;&amp;gt;1&lt;span&gt;);
        System.out.println(b);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-3&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　打印的结果为什么是-3呢？，这里就有一个小小的细节操作，在进行右移操作的时候，首先会将该byte类型的数变成int类型的，对int类型的变原码，然后变补码，移位操作之后，取后8位变为byte类型，然后变原码，最后转十进制。。。。是不是贼麻烦！还是以上面的-6为栗子，-6要进行无符号右移，所以-6的原码应该是32位的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
10000000 00000000 00000000 00000110  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原码&lt;/span&gt;

11111111 11111111 11111111 11111010&lt;span&gt;//&lt;/span&gt;&lt;span&gt;补码&lt;/span&gt;

011111111 11111111 11111111 1111101&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移一位&lt;/span&gt;

11111101&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取后八位，就是byte类型的补码&lt;/span&gt;

10000011&lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte类型原码，对应十进制是-3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.简单总结一下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于我们是用一个byte类型的为例，这也是为了方便举例子，不然用个int类型的，随便一个数写出原码都是一大串，看着都眼花。。。其实byte类型的移位运算弄清楚了，其他的类型一样的，看了这么多，不知道大家有没有总结出来一点规律，我就说说我的理解吧！&lt;/p&gt;
&lt;p&gt;　　首先，我们要明确当前的数是一个什么类型，进行移位操作之后会不会超出这个类型的范围，如果超出了，我们是不能直接得出乘以2或者除以2这种简单的结论的，会得出一个意想不到的数字；&lt;/p&gt;
&lt;p&gt;　　然后，如果移位操作之后没有超过当前类型的范围，那么就大胆的说左移一位是乘以2，右移一位是除以2向下取整吧！！！&lt;/p&gt;
&lt;p&gt;　　再然后，对于一个正数，左移一位就是最高位去掉，最低位添0；右移一位最高位添加和符号位一样的数，最低位去掉；对于负数而言，也是一样的，就不多说了&lt;/p&gt;
&lt;p&gt;　　最后，就是无符号右移，这里要注意先要变成int类型的二进制原码，变补码，然后进行移位操作，截取后8位为我们需要的byte类型的补码，再变原码，最后就是变成十进制的了。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&quot;或&quot;、&quot;与&quot;、&quot;非&quot;、&quot;异或&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　请注意“或”、“与”、“非”和java中的||、&amp;amp;&amp;amp;、！别弄混淆了，java中的这几个是用来进行逻辑判断的，而我们这里的“或”“与”“异或”这几个是用来计算二进制的，完全没有什么相关，虽然写法有点类似，“或”用一根竖线表示|，与用一个&amp;amp;表示，非用~表示，&quot;异或&quot;用^表示,下面就简单说说他们的作用：&lt;/p&gt;
&lt;p&gt;　　或：在二进制中，两个操作数进行或操作，只要有一个为1，结果就为1，否则就为0；举个例子，-6|3，首先将各自都变为补码，也就是变为（1111 1011）|（0000 0011），根据下图，最后计算的补码为1111 1011，变为原码为1000 0101，对应十进制的-5，所以-6|3的结果就是-5！很简单吧，现在应该知道操作数是什么了吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201907/1368608-20190713225334933-516512274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; num() {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a = -6|3&lt;span&gt;;
        System.out.println(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-5&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　与：两个操作数同时为1,结果才是1，否则为0；&lt;/p&gt;
&lt;p&gt;　　异或：看这个名字就知道了，两个操作数不同结果就是1，否则为0；&lt;/p&gt;
&lt;p&gt;　　非：就是对自己取反（符号位也要取反），用法如下，因为-6的补码是1111 1010，取反之后的补码0000 0101，对应十进制的5&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; num() {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a = -6&lt;span&gt;;
        System.out.println(&lt;/span&gt;~a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.简单练习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果把上面的都看懂了，理解了那么下面这个就很容易了；&lt;/p&gt;
&lt;p&gt;　　直接说一下这个方法的用处，就是你随便输入一个int类型的数，它都会给你返回一个2的次幂数，比如1,2,4,8,16.32.64等这种数（1等于2的零次幂，也是2的次幂数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tableSizeFor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cap) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = cap - 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 2&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 8&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (n &amp;lt; 0) ? 1 :n + 1&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法其实很容易，就是将传进去的int类型的cap首先减一，赋值给n，然后n进行5次无符号右移操作，每次右移之后都和n进行&quot;或&quot;操作，最后判断n如果小于零，就返回1，否则就返回n+1&lt;/p&gt;
&lt;p&gt;　　我们就比如传入5，那么n等于4，无符号右移一位然后与n进行“或”操作，由于位数太多，我就直接写结果了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
00000000 00000000 00000000 00000100&lt;span&gt;//&lt;/span&gt;&lt;span&gt;n的二进制补码&lt;/span&gt;
00000000 00000000 00000000 00000110&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移一位然后和n进行“或”操作&lt;/span&gt;
00000000 00000000 00000000 00000111&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移两位然后和n进行“或”操作&lt;/span&gt;
00000000 00000000 00000000 00000111&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移四位然后和n进行“或”操作&lt;/span&gt;
00000000 00000000 00000000 00000111&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移八位然后和n进行“或”操作&lt;/span&gt;
00000000 00000000 00000000 00000111&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号右移十六位然后和n进行“或”操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后右移16位的n结果应该是7，再到return语句，返回的是n+1,也就是返回8，而8就是2^3，满足前面说的返回一个2的次幂数；有兴趣的可以试试其他的数，返回的结果肯定是2的次幂数，有没有觉得这个算法特别牛逼！简直无敌呀！&lt;/p&gt;
&lt;p&gt;　　如果你看懂了这个方法的话，你可以打开你的Eclipse或者IDEA，用jdk1.8找到一个叫做HashMap的类，你就可以看到这个方法（当然我把最后的return语句稍微变了一点），这个就是HashMap进行扩容的一个方法，所以我们可以知道HashMap初始化以及扩容之后的容量，总是2的幂级数，是不是很容易啊！&lt;/p&gt;
&lt;p&gt;　　当然有的时候面试，面试官会问你为什么HashMap的容量要设置为2的幂级数啊？这个问题就有点东西了，首先你可以把这部分算法给他说一下，玛德！源码就是这样写的啊！你还问我为什么？然后还要说的话，其实也很容易，还涉及到了一个“与”操作，看看这个(n - 1) &amp;amp; hash，hash就是将一个键值对的key通过hash算法得到的一个很大的数，而n就是hashmap长度，也就是2的次幂数，那么(n - 1) &amp;amp; hash代表什么呢？&lt;/p&gt;
&lt;p&gt;　　有兴趣的可以玩一下，其实就是相当于hash%n，就是相当于对n取余，这个余数肯定是小于n，这样首先可以保证得到的数组中的索引不会超过数组，而且用这种方式可以保证数据是均匀的分布在hashmap中的那个数组中，我这里也就是简单提了一下，很容易的！&lt;/p&gt;
&lt;p&gt;　　有兴趣的可以看看这个老哥的一篇博客https://www.iteye.com/topic/539465，这篇博客是说的比较清楚的了！最好看之前先把jdk8的HashMap源码看一遍，哈哈&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jul 2019 16:21:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>最近这破事贼多，都没有什么时间写写博客，都好久都没有更新博客了！不过平常看jdk源码的时候有很大的感触，就是基础真的很重要，那什么是基础呢？除了java的基本语法之外，最基础的莫过于原码，反码和补码了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq1995/p/11175578.html</dc:identifier>
</item>
<item>
<title>Java线程池源码及原理 - 狼爷</title>
<link>http://www.cnblogs.com/powercto/p/11182754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powercto/p/11182754.html</guid>
<description>&lt;p&gt;下面如果有贴出源码，对应的源码是JDK8&lt;br/&gt;主要的源码类&lt;br/&gt;java.util.concurrent.ThreadPoolExecutor、&lt;br/&gt;java.util.concurrent.ThreadPoolExecutor.Worker&lt;br/&gt;java.util.concurrent.AbstractExecutorService&lt;/p&gt;
&lt;h2 id=&quot;类继承图&quot;&gt;1.1类继承图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133883/201907/1133883-20190713235424640-632167552.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133883/201907/1133883-20190713235434860-563777272.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;完整的线程池构造方法&quot;&gt;3.1完整的线程池构造方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ctl&quot;&gt;3.2 ctl&lt;/h2&gt;
&lt;p&gt;内部有重要的成员变量ctl，类型是AtomicInteger，低29位表示线程池中线程数，通过高3位表示线程池的运行状态&lt;br/&gt;COUNT_BITS的值是29&lt;br/&gt;1、RUNNING：-1 &amp;lt;&amp;lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务；&lt;br/&gt;2、SHUTDOWN： 0 &amp;lt;&amp;lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务；&lt;br/&gt;3、STOP ： 1 &amp;lt;&amp;lt; COUNT_BITS，即高3位为001；&lt;br/&gt;4、TIDYING ： 2 &amp;lt;&amp;lt; COUNT_BITS，即高3位为010, 所有的任务都已经终止；&lt;br/&gt;5、TERMINATED： 3 &amp;lt;&amp;lt; COUNT_BITS，即高3位为011, terminated()方法已经执行完成&lt;/p&gt;
&lt;h2 id=&quot;任务的执行&quot;&gt;3.3 任务的执行&lt;/h2&gt;
&lt;p&gt;execute --&amp;gt; addWorker --&amp;gt; Thread.start --&amp;gt; (Thread.run) --&amp;gt; runTask --&amp;gt; getTask&lt;/p&gt;
&lt;h3 id=&quot;executerunnable-command&quot;&gt;3.3.1 execute(Runnable command)&lt;/h3&gt;
&lt;p&gt;大致分三个步骤&lt;br/&gt;1、当前运行的线程数量是否小于corePoolSize，直接尝试addWorker()&lt;br/&gt;2、往阻塞队列里面放入Runnable任务&lt;br/&gt;3、如果队列已经满了，直接尝试addWorker()&lt;/p&gt;
&lt;h3 id=&quot;addworkerrunnable-firsttask-boolean-core&quot;&gt;3.3.2 addWorker(Runnable firstTask, boolean core)&lt;/h3&gt;
&lt;p&gt;1、前置判断线程池的状态&lt;br/&gt;2、通过CAS操作让ctl加1，表示运行线程数增加1个&lt;br/&gt;3、构造一个Worker w，这里要特别注意构造方法里面的这行代码，this.thread = getThreadFactory().newThread(this)，可以看到构造方法内，有一个Thread对象，其使用了ThreadFactory构造了一个新的线程，并且线程的runable是worker本身。&lt;br/&gt;4、执行w.thread.start()，也就是说，当该线程被运行时，Worker中的run方法会被执行&lt;/p&gt;
&lt;h3 id=&quot;runworkerworker-w&quot;&gt;3.3.3 runWorker(Worker w)&lt;/h3&gt;
&lt;p&gt;通过循环调用getTask()获取要执行的任务task&lt;br/&gt;beforeExecute&lt;br/&gt;task.run()&lt;br/&gt;afterExecute&lt;/p&gt;
&lt;h3 id=&quot;gettask&quot;&gt;3.3.4 getTask()&lt;/h3&gt;
&lt;p&gt;直接贴源码了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Runnable getTask() {
    boolean timedOut = false; // 是否最后的 poll() 超时了？
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;    // worker是否需要被淘汰

        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            // 这里会让线程的数量记录减，后面的return null，会导致runWorker没有获取到数据而让run()方法走到尽头，最终当前线程结束
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 如果需要回收一部分线程，那么超时时间keepAliveTime后拿不到就数据就继续循环调用，就可以在下一次循环的时候进行线程结束回收了；否则一直阻塞下去
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;任务执行带返回值的&quot;&gt;4 任务执行，带返回值的&lt;/h2&gt;
&lt;p&gt;直接贴源码了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}
public Future&amp;lt;?&amp;gt; submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较简单，把任务封装成一个既实现Runnable, 也实现Future的接口，这个时候就可以调用execute()进行实现了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/programmer_at/article/details/79799267&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/programmer_at/article/details/79799267&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/liuzhixiong_521/article/details/87856121&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/liuzhixiong_521/article/details/87856121&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jul 2019 16:04:00 +0000</pubDate>
<dc:creator>狼爷</dc:creator>
<og:description>Java线程池的原理，主要参数的作用。ThreadPoolExecutor内部有重要的成员变量ctl，类型是AtomicInteger，低29位表示线程池中线程数，通过高3位表示线程池的运行状态。ad</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powercto/p/11182754.html</dc:identifier>
</item>
<item>
<title>Vue快速学习_第二节 - ~泪小白~</title>
<link>http://www.cnblogs.com/leixiaobai/p/11182630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leixiaobai/p/11182630.html</guid>
<description>&lt;ul&gt;&lt;li&gt;
&lt;h5 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;表单输入绑定(v-model)&lt;/span&gt;&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;code&gt;v-model&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;指令在表单 &lt;span&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;、&lt;span&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;及 &lt;span&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain md-expand&quot;&gt;元素上创建双向数据绑定(注意只在表单这几个可以,实际上就是负责监听用户的输入事件以更新数据)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意:&lt;span&gt;&lt;code&gt;v-model&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;会忽略所有表单元素的 &lt;span&gt;&lt;code&gt;value&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;、&lt;span&gt;&lt;code&gt;checked&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;、&lt;span&gt;&lt;code&gt;selected&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;特性的初始值而总是将 Vue 实例的数据作为数据来源.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;code&gt;v-model&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;在内部为不同的输入元素使用不同的属性并抛出不同的事件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;text 和 textarea 元素使用 &lt;span&gt;&lt;code&gt;value&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;属性和 &lt;span&gt;&lt;code&gt;input&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;事件；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;checkbox 和 radio 使用 &lt;span&gt;&lt;code&gt;checked&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;属性和 &lt;span&gt;&lt;code&gt;change&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;事件；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;select 字段将 &lt;span&gt;&lt;code&gt;value&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;作为 prop 并将 &lt;span&gt;&lt;code&gt;change&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;作为事件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上面的解释来源于官网,感觉不错就拿过来了,好了,接着来实际操作下看看吧&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;下面是v-model使用实例,双向数据绑定&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1.input文本使用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入值&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ msg }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;2.textarea富文本使用,这样一旦一个改变,界面上所有引用的地方都会改变,
    在文本区域插值 (&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;) 并不会生效，应用 v-model 来代替。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;富文本输入&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;3.单个复选框使用,checked选中就是true,没选中就是false&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;label的作用就是for关联对应的id标签,点击label文本就相当于点击了input&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ checked }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;4.多个复选框使用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;c1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;apple&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked_list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;c1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;apple&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;c2&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;banana&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked_list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;c2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;banana&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;c3&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;peach&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked_list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;c3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;peach&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;将选择的value值存入checked_list中&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;多选的是: {{ checked_list }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;5.单选使用,同样是存储value值&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;r1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;apple&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;radio_one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;r1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;apple&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;r2&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;banana&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;radio_one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;r2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;banana&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单选的是: {{ radio_one }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;6.选择框的使用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;v-model 表达式的初始值未能匹配任何选项，&amp;lt;select&amp;gt; 元素将被渲染为“未选中”状态,
        所以建议用下面的方法,第一个为请选择但是设置disabled&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;在v-model下select下的option要设置value=&quot;&quot;才会默认第一个显示&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;disabled value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;有value就会将value值赋值给selected,没有则用文本的B&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;你的选择是: {{ selected }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;7.多选绑定到一个数组&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;data里面selecteds为一个空数组&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;multiple v-model&lt;/span&gt;&lt;span&gt;=&quot;selecteds&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;disabled value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;有value就会将value值赋值给selected,没有则用文本的B&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;你的选择是: {{ selecteds }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;依旧是多选,但是是用v-for动态渲染&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;select_for赋值了A,因此会默认选中value为A的选项&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;select_for&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item, index) in option_list&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; :value&lt;/span&gt;&lt;span&gt;=&quot;item.value&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ item.text }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;8.值的绑定,对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值),
    但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;toggle&quot;&lt;/span&gt;&lt;span&gt; v-bind:value&lt;/span&gt;&lt;span&gt;=&quot;bind_value&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;value的值变成了动态属性bind_value&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{toggle}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;9.修饰符 .lazy,在“change”时而非“input”时更新 ,也就是输入中不改变msg,回车或确定时改变&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model.lazy&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;10.修饰符 .number,自动将用户的输入值转为数值类型&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model.number&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;number&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;11.修饰符 .trim,自动过滤用户输入的首尾空白字符&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model.trim&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多选列表数据&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; options &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [
      { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;One&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
      { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Two&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
      { text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Three&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
    ];
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                msg: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                checked: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                checked_list: [],
                radio_one: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                selected: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                selecteds: [],
                option_list: [],
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化给了A,这样select就会选中value为A的选项&lt;/span&gt;
&lt;span&gt;                select_for: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                toggle: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                bind_value: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;值被绑定了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                age: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
            }
        },
        created(){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.option_list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; options
        }
    })
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;组件化开发&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;全局组件(通用组件可以考虑变成全局组件)&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明全局组件, 第一个参数是组件的名字(Vbtn), 第二个参数是options,声明完之后就可以在其他组件调用,不需要挂载&lt;/span&gt;
    Vue.component('Vbtn'&lt;span&gt;, {
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                msg: &lt;/span&gt;'按钮'&lt;span&gt;
            }
        },
        template:`&lt;/span&gt;&amp;lt;button&amp;gt;{{ msg }}&amp;lt;/button&amp;gt;`
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;21&quot;&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;局部组件&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;遵循三步骤: 声子(创建组件), 挂子(挂载到父组件), 用子(父组件使用子组件),下面代码使用包含全局组件的调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;直接使用App组件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;App&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 注意:如果仅仅是实例化Vue实例化对象中 既有el又有template,如果template中定义模板的内容,
    那么template模板的优先级大于el,就会使用template的内容,没有的话就会使用el的内容 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明全局组件, 第一个参数是组件的名字(Vbtn), 第二个参数是options,声明完之后就可以在其他组件调用,不需要挂载&lt;/span&gt;
&lt;span&gt;    Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vbtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;按钮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过slot插槽分发内容(组件传递内容),就相当于别的组件调用传值会替换slot标签的位置&lt;/span&gt;
&lt;span&gt;        template:`&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;slot&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;button&amp;gt;&lt;/span&gt;
&lt;span&gt;        `
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义App下的header区域,第一步声子,,然后App父组件就可以调用了&lt;/span&gt;
&lt;span&gt;    let Vheader &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                header_login: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                header_reg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;注册&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            }
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义herader区域的模板内容,使用全局组件Vbtn,界面显示登录和注册按钮&lt;/span&gt;
&lt;span&gt;        template:`
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Vbtn&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ header_login }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Vbtn&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Vbtn&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ header_reg }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Vbtn&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;        `
    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.声子, Vue中 组件的名字首字母必须大写(与标签区分),组件中的data必须是一个函数且要有返回值,这里定义一个App&lt;/span&gt;
&lt;span&gt;    let App &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
         data(){
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;liu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
             }
         },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义App组件内容,使用App组件的内容,注意template里面一定是有一个根标签包裹全部标签,使用Vheader&lt;/span&gt;
&lt;span&gt;        template:`
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{ name }}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;h2&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Vheader&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Vbtn&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;Vbtn&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;div&amp;gt;&lt;/span&gt;
&lt;span&gt;        `,
        components: {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 挂载header组件&lt;/span&gt;
&lt;span&gt;             Vheader
        }
    };

    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {

            }
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件挂载&lt;/span&gt;
&lt;span&gt;        components:{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.挂子,如果key和value(App:App)一样可以只写一个(App)&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; App:App&lt;/span&gt;
&lt;span&gt;            App
        }
    })

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;组件的嵌套(单向数据流)&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;父子组件传值&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;平行组件传值&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
注意:A-&amp;gt;B传值,那么B要声明事件,通过$on('事件的名称', &lt;span&gt;function&lt;/span&gt;(){}), A则要触发事件 $emit('B组件中声明的事件名', '值val'),还有记住,前提条件是这两个方法必须绑定在同一个实例化对象中(比如let bus = &lt;span&gt;new&lt;/span&gt; Vue()),同时绑定到bus上
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
let bus = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局组件Test, Test向Vheader传值msg, 因此$emit('Vheader组件中声明的事件名', '值val')&lt;/span&gt;
Vue.component('Test'&lt;span&gt;, {
    data(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            msg: &lt;/span&gt;'我是全局子组件的数据'&lt;span&gt;,
        }
    },
    template:`&lt;/span&gt;&amp;lt;button @click=&quot;clickHandler&quot;&amp;gt;&lt;span&gt;
按钮
&lt;/span&gt;&amp;lt;/button&amp;gt;
&lt;span&gt;`,
    methods:{
        clickHandler(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $emit和$on的事件要一样&lt;/span&gt;
            bus.$emit('testData', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msg)
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vheader组件&lt;/span&gt;
let Vheader =&lt;span&gt; {
    data(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个text接收msg&lt;/span&gt;
            text: ''&lt;span&gt;
        }
    },
    template:`
&lt;/span&gt;&amp;lt;div&amp;gt;
&amp;lt;Test /&amp;gt;
&lt;span&gt;{{ text }}
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;span&gt;`,
    methods: {
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收$emit()传过来的值&lt;/span&gt;
&lt;span&gt;    created(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的是bus调用,this指的是bus,所以要指向Vheader就需要用箭头函数指向父级&lt;/span&gt;
        bus.$on('testData', (val) =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.text =&lt;span&gt; val;
        })
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 13 Jul 2019 15:26:00 +0000</pubDate>
<dc:creator>~泪小白~</dc:creator>
<og:description>表单输入绑定(v-model) v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定(注意只在表单这几个可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leixiaobai/p/11182630.html</dc:identifier>
</item>
<item>
<title>编译原理课程设计词法分析 - RunWsh</title>
<link>http://www.cnblogs.com/chenqiwei/p/RunWsh_word001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqiwei/p/RunWsh_word001.html</guid>
<description>&lt;div readability=&quot;56&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编译原理课程设计词法分析任务书&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713225752755-660296240.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;）参考文献：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）张素琴，吕映芝. 编译原理[M]., 清华大学出版社&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）蒋立源、康慕宁等，编译原理（第2版）[M]，西安：西北工业大学出版社&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;）课程设计进度安排&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1．准备阶段（4学时）：选择设计题目、了解设计目的要求、查阅相关资料&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2．程序模块设计分析阶段（4学时）：程序总体设计、详细设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3．代码编写调试阶段（8学时）：程序模块代码编写、调试、测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4．撰写论文阶段（4学时）：总结课程设计任务和设计内容，撰写课程设计论文&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  学生签名：&lt;span&gt;              &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;      2019 年   5  月  9  日&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;课程设计(论文)&lt;/strong&gt;&lt;strong&gt;评审意见&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）学习态度（20分）：优（　）、良（　）、中（　）、一般（　）、差（　）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）系统设计（20分）：优（  ）、良（　）、中（　）、一般（　）、差（　）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）编程调试（20分）：优（　）、良（　）、中（　）、一般（　）、差（　）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）回答问题（20分）：优（　）、良（　）、中（　）、一般（　）、差（　）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）论文撰写（20分）：优（　）、良（　）、中（　）、一般（　）、差（　）；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;评阅人：&lt;span&gt;    &lt;/span&gt; &lt;span&gt;　　　&lt;/span&gt;&lt;span&gt; &lt;/span&gt;   职称：&lt;span&gt; &lt;/span&gt; &lt;span&gt;讲师&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;2019  年  5  月 10  日&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;中文摘要&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现功能及实现&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　主要实现对文本中的程序进行词法分析,把程序中的单词分为五大类(基本保留字[1]、标识符[2]、常数[3]、运算符[4]、分隔符[5])并与相应的区域数字来对应输出.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　之前利用Java中的BufferedReader缓冲器对象来存储读取程序的文件,在刘立月老师指导下,较大程序文件的时有超时的情况,后更改成一行编译读取方式.利用两个异常处理,文件读取异常和输出异常时打印ERROR.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景和意义&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　词法分析的过程是线性的从头至尾扫描一遍,复杂度较低,易实现。能完成计算机翻译过程的关键阶段,它为后面的语法分析、语义分析做好准备,打好基础,以便快速地、高质量地生成目标语言程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;关键字： 词法分析、文件异常、目标语言程序&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713230049131-1898056940.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;&lt;div readability=&quot;142&quot;&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1、目的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　通过使用一个通用的能够自动根据正规表达式生成词法分析程序的工具程序设计一个简单语言的词法分析器,使学生充分理解课程理论内容和工具软件的使用技巧,掌握所涉及的典型数据结构,算法及方法,为今后在大型软件系统实践中设计性能优良的软件系统打下基础。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;1.2、任务与要求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　【基本要求】&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　编制一个读单词过程，从输入的源程序中，识别出各个具有独立意义的单词，即基本保留字、标识符、常数、运算符、分隔符五大类。并依次输            出各个单词的内部编码及单词符号自身值。（遇到错误时可显示“Error”，然后跳过错误部分继续显示）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;【测试数据】&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如源程序为C语言。输入如下一段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;main(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;  a,b;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;      b = a + &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;测试数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; （&lt;span&gt;2&lt;/span&gt;，”main”）    （&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，”a”）
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; （&lt;span&gt;5&lt;/span&gt;，”（“）      （&lt;span&gt;4&lt;/span&gt;，”=&lt;span&gt;”）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; （&lt;span&gt;5&lt;/span&gt;，”）“）      （&lt;span&gt;3&lt;/span&gt;，”&lt;span&gt;10&lt;/span&gt;&lt;span&gt;”）
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; （&lt;span&gt;5&lt;/span&gt;，”{“）       （&lt;span&gt;5&lt;/span&gt;&lt;span&gt;，”;”）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; （&lt;span&gt;1&lt;/span&gt;，”int”）     （&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，”b”）
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; （&lt;span&gt;2&lt;/span&gt;，”a”）       （&lt;span&gt;4&lt;/span&gt;，”=&lt;span&gt;”）
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; （&lt;span&gt;5&lt;/span&gt;，”,”）       （&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，”a”）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; （&lt;span&gt;2&lt;/span&gt;，”b”）       (&lt;span&gt;4&lt;/span&gt;，”+&lt;span&gt;”）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; （&lt;span&gt;5&lt;/span&gt;，”;”）       （&lt;span&gt;3&lt;/span&gt;，”&lt;span&gt;20&lt;/span&gt;”）
&lt;/pre&gt;&lt;/div&gt;




&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2.1、分析&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　通过修改代码使得自动机能够更多的实现运算符号的识别功能，使用TINY语言调试一个程序，加深同学对词法分析的认识以及理解。另外，同时增强编写和调试程序的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2.2、问题解决&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　对读取的文件进行预处理，从头到尾进行扫描，去除//和/*  */的内容，以及一些无用的、影响程序执行的符号如换行符、回车符、制表符等。但是千万注意不要在这个时候去除空格，因为空格在词法分析中有用，比如说int i=3;这个语句，如果去除空格就变成了“inti=3”,这样就失去了程序的本意，因此不能在这个时候去除空格。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2.3、解决步骤&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　对源文件从头到尾进行扫描了，从头开始扫描，主控程序主要负责系统建立一个文件保存四个表，这四个表分别存储关键字、运算符、界符、过滤符。而标识符和常数则用正则表达式判断。建立了多个布尔类，当系统读取代码时，用空格或制表符作为标志符，当遇到空格就输出之前检索的字符串进行判断（规定每个单词符号之间都有空格），判断字符串时，系统会通过顺序查找依次调用布尔类与之匹配来判断其属性并输出，如没有匹配成功，则说明所检索的字符串不合法，系统则会输出非法字符串。直到最后一个字符串匹配完毕之后系统结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3.1、总体思路分析&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　程序的关键点在于对给出一段程序中的各种单词的分离。在每段程序中，单词种类可以分为：关键字，分界符，算术运算符，关系运算符，标识符和常数。关键字的判断则是通过与已知数组中列出的元素进行对比，得出该单词是否为关键字；分解符，算术运算符，关系运算符的判断与接受到的字符进行比较，得出该字符是否为分解符，算术运算符或者为关系运算符。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;状态图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713230430367-1625277887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图3-1-1:功能模块分解图&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;总控程序流程图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713230503236-692315656.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;433&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图3-1-2:控制流程图&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3.2、设计原理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;主要任务如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;识别出输入的源程序中的单词，输出二元组形式的单词序列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;删除无用的空白字符、回车符等没有实质意义的字符。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713230626948-1077545367.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图3-2:正规式和状态转换图&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;实验步骤&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;PL/0语言文法的EBNF表示如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=begin&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;语句串&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;end
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;语句串&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;语句&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{；&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;语句&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;语句&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;赋值语句&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;赋值语句&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=ID：=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;项&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{+&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;项&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; | -&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;项&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;  
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;项&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;因子&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{*&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;因子&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; | /&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;因子&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;因子&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;：：=ID | NUM | （&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;）
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3.3实现方法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本次实验是设计词法分析器，其中核心函数是cifa()，分析的语言是PL/0，首先，采用循环遍历的方法读取用户输入的一段代码，跳过源程序中的空格字符，然后if语句配合switch语句对读入的代码挨个判断，最后以二元组的形式输出结果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4.1、项目设计步骤&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;a)       &lt;/strong&gt; &lt;strong&gt;创建存放识别程序文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713230905167-998705757.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图4-1:待编译程序文件test.txt&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;b)      &lt;/strong&gt; &lt;strong&gt;读取文件单词并存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;读取文件test.txt文件:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; br = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; FileReader(&quot;tests.txt&quot;));&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;存放构成单词符号的字符串:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; StringBuffer strToken = &lt;span&gt;new&lt;/span&gt; StringBuffer();&lt;/span&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;基本保留字(关键字)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; String [] retainWord = &lt;span&gt;new&lt;/span&gt; String[]{&quot;int&quot;,&quot;if&quot;,&quot;else&quot;,&quot;return&quot;,&quot;main&quot;,&quot;void&quot;,&quot;while&quot;,&quot;break&quot;};&lt;/span&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;c)       &lt;/strong&gt; &lt;strong&gt;识别不同程序单词&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;基本保留字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; retainWord.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否为关键字,,是返回1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;                      &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(strToken.toString().equals(retainWord[i])){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(code == 1){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键字&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;                      System.out.println(&quot;('&quot;+1+&quot;','&quot;+strToken+&quot;')&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;               }
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;标识符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; retainWord.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否为关键字,,是返回1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;                      &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(strToken.toString().equals(retainWord[i])){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;(strToken.length() != 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                     ......
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;               &lt;span&gt;return&lt;/span&gt; 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(code == 2){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非数字,关键字&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                      System.out.println(&quot;('&quot;+2+&quot;','&quot;+strToken+&quot;')&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;  
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;常数
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(strToken.charAt(0)&amp;gt;='0' &amp;amp;&amp;amp; strToken.charAt(0)&amp;lt;='9'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个是否为数字返回3&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;  
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(code == 3){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数字&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                      System.out.println(&quot;('&quot;+3+&quot;','&quot;+strToken+&quot;')&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;               }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ch == 43&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Retract();                
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; System.out.println(&quot;('&quot;+4+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);     
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                         
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ch == 45&lt;span&gt;){                                
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Retract();                              
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; System.out.println(&quot;('&quot;+4+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);     
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                         
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ch == 42&lt;span&gt;){                                
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;Retract();                              
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; System.out.println(&quot;('&quot;+4+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);     
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                         
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ch == 47&lt;span&gt;){                                
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;Retract();                              
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; System.out.println(&quot;('&quot;+4+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;);     
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;                           &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;分隔符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; System.out.println(&quot;('&quot;+5+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((&lt;span&gt;char&lt;/span&gt;) ch == '('&lt;span&gt;){                      
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;              Retract();                          
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; System.out.println(&quot;('&quot;+5+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);                      
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((&lt;span&gt;char&lt;/span&gt;) ch == ')'&lt;span&gt;){                      
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;              Retract();                   
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;       
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; System.out.println(&quot;('&quot;+5+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);                      
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((&lt;span&gt;char&lt;/span&gt;) ch == '{'&lt;span&gt;){                      
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;              Retract();            
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;              
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; System.out.println(&quot;('&quot;+5+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);                      
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((&lt;span&gt;char&lt;/span&gt;) ch == '}'&lt;span&gt;){                      
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;              Retract();                   
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;       
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; System.out.println(&quot;('&quot;+5+&quot;','&quot;+(&lt;span&gt;char&lt;/span&gt;) ch+&quot;')&quot;&lt;span&gt;);                      
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;        }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((&lt;span&gt;char&lt;/span&gt;) ch == ','){         
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;             &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;d)      &lt;/strong&gt; &lt;strong&gt;语言单词编码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713231241045-721035647.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;表4-4:语言单词编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;程序运行环境为Win10系统，在IDEA/ECLIPSE上运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果分析如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5.1、当在文本文件test.txt中输入文法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713231358875-108792579.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;484&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图5-1-1:类型号和单词输出结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5.2输出异常处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;a)       &lt;/strong&gt; &lt;strong&gt;文件路径异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713231451092-2119867457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图5-1-2:获取程序文件异常&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;b)      &lt;/strong&gt; &lt;strong&gt;程序中未识别单词异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201907/1469234-20190713231502065-409600489.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图5-1-3:不能识别程序单词报错&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;心得体会&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个程序实现了课设的所有要求（由于我是31号做第一题词法分析模拟，但同时实现了扩展功能对于注释的文字进行忽视编译），虽然可能还存在些不足，像之前刘立月老师提出的我的程序对于简短的程序是完全可以的,我的读取方式是对象全部读取.但是对于一些比较大的项目来进行对象读取时间比较长.于是在我的程序当中进行了一定量的修改,更改成行的读取.用编译原理的知识自己独立完成这样一个程序我觉得还不错了，毕竟做这样的课设可以学到不少东西.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学习心得：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一开始对编写词法分析毫无头绪，不知如何下手。上网查资料是我们迈开的第一步，然后查阅相关资料，小组里相互讨论帮助，在多次的调试和改进中终于把程序完成了。通过这次的程序实验我对编译原理这门课程有了进一步的深层次了解，而且在自已动手体验的情况下，更加透彻地理解了词法分析的过程。在设计过程中，要发扬团体合作的精神，互帮互助，共同进步。善于发问，善于思考。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[1] 张素琴.编译原理. 北京:清华大学出版社,2005
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[2] 付京周.JAVA 程序设计语言. 北京:人民邮电出版社,2007
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;[3]黄贤英,王珂珂.编译原理及实践教程.北京:清华大学出版社，2008
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;[4]黄贤英,王珂珂，刘洁,曹琼.编译原理重点难点分析.习题解析·实验指导.北京:机械
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;工业出版社，2008
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;[5]陈媛,何波,涂晓红,涂飞算法与数据结构.北京:清华大学出版社，2005[4]刘恒洋,杨宏雨.算法与数据结构.北京:机械工业出版社，2010
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;[6]陈火旺，《程序设计语言编译原理》(第3版)，北京:国防工业出版社.2000.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;[7]美Alfred V. Aho Ravi Sethi Jeffrey D. Ullman著.李建中，姜守旭译.《编译原理》. 北京:机械工业出版社.2003.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;[8]美KennethC. Louden著.冯博琴等译.《编译原理及实践》.北京:机械工业出版社.2002.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;[9]金成植著.《编译程序构造原理和实现技术》.北京:高等教育出版社.2002.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sat, 13 Jul 2019 15:20:00 +0000</pubDate>
<dc:creator>RunWsh</dc:creator>
<og:description>编译原理课程设计词法分析任务书 5）参考文献： （1）张素琴，吕映芝. 编译原理[M]., 清华大学出版社 （2）蒋立源、康慕宁等，编译原理（第2版）[M]，西安：西北工业大学出版社 6）课程设计进度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqiwei/p/RunWsh_word001.html</dc:identifier>
</item>
<item>
<title>Unittest方法 -- 项目实现自动发送邮件 - Teacher涛</title>
<link>http://www.cnblogs.com/Teachertao/p/11182578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Teachertao/p/11182578.html</guid>
<description>&lt;pre readability=&quot;79&quot;&gt;
&quot;&quot;&quot;&lt;br/&gt;1.discover方法里面有三个参数：&lt;br/&gt;-case_dir:这个是待执行用例的目录。&lt;br/&gt;-pattern：这个是匹配脚本名称的规则，test*.py意思是匹配test开头的所有脚本。&lt;br/&gt;-top_level_dir：这个是顶层目录的名称，一般默认等于None就行了。&lt;br/&gt;2.discover加载到的用例是一个list集合，需要重新写入到一个list对象testcase里;&lt;br/&gt;这样就可以用unittest里面的TextTestRunner这里类的run方法去执行。&lt;br/&gt;&quot;&quot;&quot;&lt;p&gt;import unittest&lt;br/&gt;import os,time&lt;br/&gt;import HTMLTestRunner&lt;br/&gt;from tomorrow import threads&lt;br/&gt;import smtplib&lt;br/&gt;from email.mime.text import MIMEText&lt;br/&gt;from email.mime.multipart import MIMEMultipart&lt;/p&gt;&lt;p&gt;#unittest_test目录，下有case和report&lt;br/&gt;cur_path = os.path.dirname(__file__)&lt;/p&gt;&lt;p&gt;def all_case(casename=&quot;case&quot;,rule=&quot;test*.py&quot;):&lt;br/&gt;'''第一加载所有的测试用例'''&lt;br/&gt;case_path = os.path.join(cur_path,casename) #用例路径拼接&lt;br/&gt;#如果不存在case文件夹，自动创建&lt;br/&gt;if not os.path.exists(case_path):os.mkdir(case_path)&lt;br/&gt;discover = unittest.TestLoader().discover(&lt;br/&gt;casename,&lt;br/&gt;pattern=rule,&lt;br/&gt;top_level_dir=None&lt;br/&gt;)&lt;br/&gt;return discover&lt;/p&gt;&lt;p&gt;# def getNowtime():&lt;br/&gt;#     return time.strftime(&quot;%Y-%M-%D %H-%M-%S&quot;,time.localtime(time.time()))&lt;/p&gt;&lt;p&gt;def report():&lt;br/&gt;&quot;&quot;&quot;第二执行所有用例，并把结果写入HTML测试报告中&quot;&quot;&quot;&lt;br/&gt;# now = time.strftime(&quot;%Y-%M-%D %H-%M-%S&quot;)&lt;br/&gt;report_path = os.path.join(cur_path,&quot;report&quot;) #report文件夹&lt;br/&gt;if not os.path.exists(report_path):os.mkdir(report_path)&lt;br/&gt;report_abspath = os.path.join(report_path,&quot;result.html&quot;)  # html报告文件路径&lt;br/&gt;# file = os.path.join(os.path.dirname(__file__), &quot;Report&quot;, &quot;testReport.html&quot;)&lt;br/&gt;# print(&quot;report_path:%s&quot;%report_abspath)&lt;br/&gt;with open(report_abspath, &quot;wb&quot;) as fp:&lt;br/&gt;runner = HTMLTestRunner.HTMLTestRunner(&lt;br/&gt;stream=fp,&lt;br/&gt;title=u'自动化测试报告,测试结果如下：',&lt;br/&gt;description=u'用例执行情况：')&lt;br/&gt;# 调用add_case函数返回值&lt;br/&gt;runner.run(all_case())&lt;br/&gt;return report_abspath&lt;/p&gt;&lt;p&gt;def send_mail():&lt;br/&gt;&quot;&quot;&quot;第三发送测试报告&quot;&quot;&quot;&lt;br/&gt;# ----------1.跟发件相关的参数------&lt;/p&gt;&lt;p&gt;smtpserver = &quot;smtp.163.com&quot;  # 发件服务器&lt;br/&gt;# smtpserver = &quot;smtp.qq.com&quot;&lt;br/&gt;port = 25  # 非SSL协议端口号&lt;br/&gt;# sender = &quot;XXXX&quot; # 账号&lt;br/&gt;sender = &quot;自己163邮箱账号&quot;&lt;br/&gt;psw = &quot;自己的邮箱密码&quot;&lt;br/&gt;# psw = &quot;wmqtqbtnmyamhfjd&quot; # 密码&lt;br/&gt;receiver = &quot;xxxxx@qq.com&quot; # 单个接收人也可以是 list&lt;br/&gt;# receiver = [&quot;xxxxx@qq.com&quot;]  # 多个收件人 list 对象&lt;/p&gt;&lt;p&gt;# ----------2.编辑邮件的内容------&lt;br/&gt;# 读文件&lt;br/&gt;# file_path = &quot;Result.html&quot;&lt;br/&gt;# with open(file_path, &quot;rb&quot;) as fp:&lt;br/&gt;#     mail_body = fp.read()&lt;br/&gt;with open(report(),&quot;rb&quot;) as f:&lt;br/&gt;mail_body = f.read()&lt;br/&gt;msg = MIMEMultipart()&lt;br/&gt;msg[&quot;from&quot;] = sender  # 发件人&lt;br/&gt;msg[&quot;to&quot;] = receiver  # 收件人&lt;br/&gt;# msg[&quot;to&quot;] = &quot;;&quot;.join(receiver) # 多个收件人 list 转 str&lt;br/&gt;msg[&quot;subject&quot;] = &quot;我的主题报告-test&quot;  # 主题&lt;/p&gt;&lt;p&gt;# 正文&lt;br/&gt;body = MIMEText(mail_body, &quot;html&quot;, &quot;utf-8&quot;)&lt;br/&gt;msg.attach(body)&lt;/p&gt;&lt;p&gt;# 附件&lt;br/&gt;att = MIMEText(mail_body, &quot;base64&quot;, &quot;utf-8&quot;)&lt;br/&gt;att[&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;&lt;br/&gt;att[&quot;Content-Disposition&quot;] = 'attachment; filename=&quot;test_report.html&quot;' #附件的名称&lt;br/&gt;msg.attach(att)&lt;/p&gt;&lt;p&gt;# ----------3.发送邮件------&lt;br/&gt;try:&lt;br/&gt;smtp = smtplib.SMTP()&lt;br/&gt;smtp.connect(smtpserver)  # 连服务器&lt;br/&gt;smtp.login(sender, psw)&lt;br/&gt;except:&lt;br/&gt;smtp = smtplib.SMTP_SSL(smtpserver, port) # QQ 邮箱&lt;br/&gt;smtp.login(sender, psw)  # 登录&lt;br/&gt;smtp.sendmail(sender, receiver, msg.as_string())  # 发送&lt;br/&gt;smtp.quit()&lt;/p&gt;&lt;p&gt;def main():&lt;br/&gt;send_mail()&lt;/p&gt;&lt;p&gt;if __name__ == '__main__':&lt;br/&gt;# runner = unittest_1.TextTestRunner()&lt;br/&gt;# runner.run(all_case())&lt;br/&gt;main()&lt;/p&gt;&lt;p&gt;# report_abspath = os.path.join(report_path, &quot;result.html&quot;)  # html报告文件路径&lt;br/&gt;# fp = open(report_abspath, &quot;wb&quot;)&lt;br/&gt;# runner = HTMLTestRunner.HTMLTestRunner(&lt;br/&gt;#     stream=fp,&lt;br/&gt;#     title=u'自动化测试报告,测试结果如下：',&lt;br/&gt;#     description=u'用例执行情况：')&lt;br/&gt;# # 调用add_case函数返回值&lt;br/&gt;# runner.run(all_case())&lt;br/&gt;# fp.close()&lt;/p&gt;&lt;p&gt;有图有真相
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1446880/201907/1446880-20190713231806931-1638627108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jul 2019 15:15:00 +0000</pubDate>
<dc:creator>Teacher涛</dc:creator>
<og:description>&quot;&quot;&quot;1.discover方法里面有三个参数：-case_dir:这个是待执行用例的目录。-pattern：这个是匹配脚本名称的规则，test*.py意思是匹配test开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Teachertao/p/11182578.html</dc:identifier>
</item>
<item>
<title>【带着canvas去流浪（11）】Three.js入门学习笔记 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/11182474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/11182474.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224644265-1220080793.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/threejs-demo/%E5%B8%A6%E7%9D%80canvas%E5%8E%BB%E6%B5%81%E6%B5%AA%EF%BC%8811%EF%BC%89-demo&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-资料推荐及建议&quot;&gt;一. 资料推荐及建议&lt;/h2&gt;
&lt;p&gt;1.官方文档&lt;/p&gt;
&lt;p&gt;很详细，但是API部分单独理解也很难，属于工具书。官方&lt;code&gt;github&lt;/code&gt;仓库里提供了海量的插件和&lt;code&gt;demo&lt;/code&gt;页面。&lt;/p&gt;
&lt;p&gt;2.在&lt;code&gt;CSDN&lt;/code&gt;上找到的一个&lt;a href=&quot;https://blog.csdn.net/qq_30100043/article/category/7003591/5?&quot;&gt;【Three.js系列博文】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容相当全，包括了&lt;code&gt;three.js&lt;/code&gt;的基本知识，官方仓库的实例说明，插件说明等等，是笔者学习的主线。&lt;/p&gt;
&lt;p&gt;3.上面的内容最好是做个大作业实践一下&lt;/p&gt;
&lt;p&gt;4.想要学习底层知识的话，需要学习的资料是&lt;strong&gt;线性代数&lt;/strong&gt;和&lt;strong&gt;WebGL编程指南&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二.-three.js中的基本概念&quot;&gt;二. Three.js中的基本概念&lt;/h2&gt;
&lt;p&gt;官方文档中的新手示例过于简单，所以本节对&lt;code&gt;Three.js&lt;/code&gt;中的概念进行一些补充描述：&lt;/p&gt;
&lt;ul readability=&quot;11.882247992864&quot;&gt;&lt;li readability=&quot;0.82113821138211&quot;&gt;
&lt;p&gt;客观三要素：场景&lt;code&gt;Scene&lt;/code&gt;，相机&lt;code&gt;Camera&lt;/code&gt;，渲染器&lt;code&gt;Renderer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体用法可以看官方文档的&lt;a href=&quot;https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene%3E&quot;&gt;【新手示例Demo】&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;光照&lt;code&gt;Light&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;THREE.js&lt;/code&gt;提供了点光源，射线光源，平行光，环境光的等多种光源来模拟光。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;几何模型&lt;code&gt;Geometry&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成实体的第一步是要建立几何模型&lt;code&gt;geometry&lt;/code&gt;，&lt;code&gt;THREE.js&lt;/code&gt;根据构建数据的数据类型将几何模型分为&lt;code&gt;Geometry&lt;/code&gt;和&lt;code&gt;BufferGeometry&lt;/code&gt;两个大类，每种内置类型都可以使用其中任何一种来实现，&lt;code&gt;BufferGeometry&lt;/code&gt;基于定型数组运作，使用起来要求更严格也更复杂，但性能相对更好。&lt;code&gt;THREE.js&lt;/code&gt;中内置了包含立方体，球体，多面体数十种常见的几何体，也可以将&lt;code&gt;canvas&lt;/code&gt;绘制的平面图形拉伸成为实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;材质&lt;code&gt;Material&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步是为实体选择材质&lt;code&gt;material&lt;/code&gt;，材质是描述几何体表面对于光照的表现的，是像金属表面那种高光，还是像粗糙表面那样会对光进行漫反射的，几何体的不同表面也可以选择不同的材质。材质&lt;code&gt;material&lt;/code&gt;需要和贴图&lt;code&gt;texture&lt;/code&gt;的合理搭配才能使最终的实体效果更加逼真，比如你给一个立方体选择了镜面反射的材料，但是又贴了砖头墙面的纹理，最终效果就会很诡异。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;贴图纹理&lt;code&gt;Texture&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三步是为实体选择贴图纹理&lt;code&gt;texture&lt;/code&gt;，纹理通常是通过引入图片来生成，通过贴图可以让几何体呈现为它所代表的实体模型，比如一个球体，你贴上足球的纹理，它就是足球，贴上篮球纹理，把周围环境作为贴图贴在它表面，它就是水晶球。&lt;code&gt;texture&lt;/code&gt;通常是在&lt;code&gt;material&lt;/code&gt;实例化时通过指定&lt;code&gt;map&lt;/code&gt;参数来关联的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;实体&lt;code&gt;Object&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大多数博文的示例中只使用到了&lt;code&gt;Mesh&lt;/code&gt;（网格实体）这一种类型的实体模型，实际上&lt;code&gt;THREE.js&lt;/code&gt;中还提供了&lt;code&gt;Points&lt;/code&gt;（粒子点集实体）,&lt;code&gt;Line&lt;/code&gt;（线性实体），&lt;code&gt;Skeleton&lt;/code&gt;（骨骼动画实体）等等多种抽象实体模型来构建模型。实体的实例化依赖于&lt;code&gt;geometry&lt;/code&gt;几何模型实例和&lt;code&gt;material&lt;/code&gt;材料实例，最终调用场景的&lt;code&gt;add&lt;/code&gt;方法将实体实例添加进场景中，实体就可以被渲染器&lt;code&gt;renderer&lt;/code&gt;渲染出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动画的更新&lt;/p&gt;
&lt;p&gt;动画的更新实际上和二维动画是一样的，也是通过&lt;code&gt;requestAnimationFrame&lt;/code&gt;和逐帧动画来实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.重点笔记&quot;&gt;三.重点笔记&lt;/h2&gt;
&lt;ul readability=&quot;6.176386913229&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;webGL&lt;/code&gt;中的世界坐标是以屏幕中心为原点(0,0,0)的，面对屏幕时，右为正X，上为正Y，指向屏幕外为正Z。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;dat.GUI&lt;/code&gt;是个非常棒的动态调试工具，官方仓库地址：&lt;a href=&quot;https://github.com/dataarts/dat.gui&quot; class=&quot;uri&quot;&gt;https://github.com/dataarts/dat.gui&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;THREE.CameraHelper&lt;/code&gt;类可以生成相机视锥辅助线，非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;常见材质的区别如下：&lt;code&gt;MeshLambertMaterial&lt;/code&gt;材质适合表现&lt;strong&gt;漫反射表面&lt;/strong&gt;，&lt;code&gt;MeshStandardMaterial&lt;/code&gt;和&lt;code&gt;MeshPhongMaterial&lt;/code&gt;适合表现&lt;strong&gt;镜面反射表面&lt;/strong&gt;,&lt;code&gt;MeshBasicMaterial&lt;/code&gt;是不响应光照的基本材质。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;THREE.PointLight&lt;/code&gt;是真正的点光源，&lt;code&gt;THREE.SpotLight&lt;/code&gt;是射线光源&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;flyControls&lt;/code&gt;控件相当于为相机实现第一人称视角，玩过CS的应该都懂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;材质的基本定义：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224715533-125225966.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生成网格实例时传入&lt;code&gt;wireframe:true&lt;/code&gt;即可以网格形式展示几何体。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;THREE.LatheGeometry&lt;/code&gt;相当于三维建模软件中的“根据样条曲线生成回转体”，构造函数的参数中没有回转轴，此处官方文档中有说明：车削是绕着Y轴来进行旋转的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;THREE.shapeGeometry&lt;/code&gt;,&lt;code&gt;THREE.ExtrudeGeometry&lt;/code&gt;等一类由平面生成&lt;code&gt;3D&lt;/code&gt;实体的模型，感兴趣的可以尝试一下三维建模软件&lt;code&gt;solidworks&lt;/code&gt;，完全是一个路数，对理解这些抽象几何实体很有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三维的动画和二维动画的原理没什么区别，都是通过逐帧动画实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;AnimationMixer&lt;/code&gt;是场景中特定对象的动画播放器，场景中有多个独立动画时，可以为每一个对象使用一个&lt;code&gt;AnimationMixer&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;变形动画的实现过程：获得&lt;code&gt;animationMixer&lt;/code&gt;实例,获得&lt;code&gt;clip&lt;/code&gt;实例，获得&lt;code&gt;action&lt;/code&gt;实例，最后调用&lt;code&gt;action.setDuration().play()&lt;/code&gt;开启动画播放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;morph&lt;/code&gt;和&lt;code&gt;skeleton&lt;/code&gt;动画对比，morph文件更大加载更慢，但实际在网页上计算量更小；骨骼动画文件更小，当在网页上运行时需要进行更多计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;反光表面是通过材质实例化时修改&lt;code&gt;envMap&lt;/code&gt;属性实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;舞台背景&lt;code&gt;scene.background&lt;/code&gt;是可以设置贴图纹理的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调整贴图的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四.补充示例&quot;&gt;四.补充示例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第15节-关于物体阴影&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;后来发现这个问题在第27节有说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;许多demo都无法生成投影，投影不仅需要设置光线和物体的&lt;code&gt;castShadow = true&lt;/code&gt; ,&lt;code&gt;receiveShadow = true&lt;/code&gt;,同时需要选择能够响应光线的材质，另外，&lt;strong&gt;阴影需要独立的相机去拍，默认是一个正交相机，需要正确调整其参数才能够显示阴影&lt;/strong&gt;,参数配置错误时可能会显示一半阴影或者马赛克黑区：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//初始化灯光
function initLight(color) {
  //添加环境光
  ambientLight = new THREE.AmbientLight(0x404040)
  scene.add(ambientLight);

  //添加平衡光
  light = new THREE.DirectionalLight( 0xffffff );
  light.castShadow = true;
  light.shadow.camera.near = 0.1;    // default
  light.shadow.camera.far = 1000;     // default
  light.shadow.camera.left= -5;     // default
  light.shadow.camera.top= 10;     // default
  light.position.set(60,30,0);
  scene.add(light);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224728986-552569656.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，可以通过开启相机辅助功能查看阴影相机的视锥，并配合&lt;code&gt;dat.GUI&lt;/code&gt;等其他工具进行调节：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  shadowCameraHelper = new THREE.CameraHelper( light.shadow.camera );
  scene.add(shadowCameraHelper);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224739252-1729413266.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第46节-关于将svg拉伸为实体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原文中提到的&lt;code&gt;transformSVGPathExposed&lt;/code&gt;函数和官方代码仓lib里的脚本已经找不到了，新版的官方文档中已经听过了&lt;code&gt;SVGLoader&lt;/code&gt;来完成&lt;code&gt;svg&lt;/code&gt;到&lt;code&gt;shape&lt;/code&gt;的转换，具体用法可参考&lt;a href=&quot;https://threejs.org/docs/index.html#examples/zh/loaders/SVGLoader&quot;&gt;SVGLoader文档&lt;/a&gt; ，官方仓库的example中提供了&lt;code&gt;webgl_loader_svg.html&lt;/code&gt;示例文件，我们在其中稍作改动，将转换后的&lt;code&gt;shape&lt;/code&gt;作为参数来得到拉伸体实例&lt;code&gt;THREE.ExtrudeGeometry&lt;/code&gt;，就可以看到读入的&lt;code&gt;svg&lt;/code&gt;被拉伸了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224854540-1643822061.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第58节-重点：用THREE.Raycaster实现交互&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里很重要，是3D模型能响应用户交互行为的关键。后文的&lt;strong&gt;第101节&lt;/strong&gt;也有这部分知识的说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方文档中已经提供了示例代码，平面坐标到3D坐标转换的部分如果不明白，可以看这篇博文&lt;a href=&quot;https://segmentfault.com/a/1190000010490845&quot;&gt;ThreeJS中的点击与交互——Raycaster的用法&lt;/a&gt;,笔者也提供了示例demo供参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201907/1354575-20190713224906052-803355440.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第85节：用morphTargetInfluences实现动画（简称Morph动画）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Morph&lt;/code&gt;动画的基本原理摘抄如下(&lt;a href=&quot;https://blog.csdn.net/jcq521045349/article/details/52829189&quot;&gt;原文链接&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The value is a scalar that determines the effect of a morph target. A morph target is another list of verticies (same length) that go along side the original list of verticies. Say we have a list of size 2 (a line),&lt;br/&gt;var list1 = [0.1, -0.2]&lt;br/&gt;and a morph target:&lt;br/&gt;var list2 = [0.2, -0.3]&lt;br/&gt;the scalar value is used like so:&lt;br/&gt;finalVertexPosition = list1[0] + (list2[0] * scalar);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用时需要在&lt;code&gt;Geometry&lt;/code&gt;实例构造函数的配置项中开启&lt;code&gt;morphTargets: true&lt;/code&gt;,目标几何体的点集&lt;code&gt;vertices&lt;/code&gt;相当于上面的&lt;code&gt;list1&lt;/code&gt;,存放在目标集合体&lt;code&gt;geometry&lt;/code&gt;实例&lt;code&gt;morphTargets&lt;/code&gt;数组中的向量相当于上面的&lt;code&gt;list2&lt;/code&gt;（它可以存放多个），而每一个&lt;code&gt;morphTargets&lt;/code&gt;中的变形向量对原物体的影响系数存放在&lt;code&gt;morphTargetInfluences&lt;/code&gt;数组中，取值为&lt;code&gt;-1&lt;/code&gt;~&lt;code&gt;1&lt;/code&gt;,相当于上面的&lt;code&gt;scalar&lt;/code&gt;，通过连续改变&lt;code&gt;morphTargetInfluences&lt;/code&gt;的值就可以实现变形动画，&lt;code&gt;morphTargetInfluences&lt;/code&gt;是&lt;code&gt;mesh&lt;/code&gt;实例的属性而不是 &lt;code&gt;geometry&lt;/code&gt;的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第101节：3D世界坐标求平面坐标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文中提及的&lt;code&gt;localToWorld&lt;/code&gt;方法实际上继承自&lt;code&gt;Object3D&lt;/code&gt;这个父类，当前版本的方法签名是：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Object3D.localToWorld(target:THREE.Vector3):target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说调用的时候需要传一个空的&lt;code&gt;Vector3&lt;/code&gt;实例，然后结果会被填充在里面，文中那种无参调用的模式会报错。其他的按照原文的方法就可以反求二维空间的坐标了。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jul 2019 14:50:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashnowords/p/11182474.html</dc:identifier>
</item>
<item>
<title>intel FPGA CLKn pin 是否能直接进PLL？ - DeeZeng</title>
<link>http://www.cnblogs.com/DeeZeng/p/11164299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DeeZeng/p/11164299.html</guid>
<description>&lt;p&gt;原创 by DeeZeng&lt;/p&gt;
&lt;p&gt;FPGA的时钟需要从专用的时钟管脚输入，那CLKn 作为Single-End时钟pin时是否能直接进 PLL呢？&lt;/p&gt;
&lt;p&gt;通过查看对应FPGA型号的手册，得出以下结论&lt;/p&gt;
&lt;p&gt;1. Cyclone V, Stratix V 的 CLKn 不能直接进PLL，需要走GCLK，RCLK之后才行&lt;/p&gt;
&lt;p&gt;2. MAX10 ，Arria 10 的 PLL ，CLKn 可以直接进PLL。 （Arria10 的 fPLL  CLKn不能直接走，但 XCVR bank 的一般是 差分时钟输入）&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; 如下以部分FPGA 系列举例&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.  Cyclone V，Stratix V FPGA&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下 Cyclone V, Stratix V手册：&lt;/p&gt;
&lt;p&gt;The CLKn pin is not a dedicated clock input when used as a single-ended PLL clock input.&lt;/p&gt;
&lt;p&gt;The CLKn pin can drive the PLL using the GCLK.&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/332837/201907/332837-20190710153116390-520767367.png&quot; alt=&quot;Cyclone V CLKn &quot; width=&quot;800&quot; height=&quot;324&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;26&quot;&gt;如果quartus工程中，我们直接用 CLKn 的pin 进PLL
&lt;p&gt;那会出现如下报错： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/332837/201907/332837-20190710175550707-572154762.png&quot; alt=&quot;CLKn_errors&quot; width=&quot;1000&quot; height=&quot;55&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（如果实际硬件已经必须用CLKn进 PLL了，可以先用 CLK_CTRL ip 让 CLKn 走GCLK）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.  MAX10 ，Arria10 FPGA&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MAX10 的 CLKp，CLKn 都可以drive  PLL &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/332837/201907/332837-20190710180336327-721082330.png&quot; alt=&quot;MAX10_CLock_PLL&quot; width=&quot;800&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Arria 10 的IOPLL  的 CLKn可以直接进 IOPLL （both the CLKp and CLKn pins hav dedicated ...)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/332837/201907/332837-20190710180632552-1133767118.png&quot; alt=&quot;arria10_IOPLL&quot; width=&quot;450&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Arria 10 的fPLL  的 REFCLK_GXBn 不能直接进 fPLL   （不过 XCVR bank 一般也都是 差分时钟输入，影响不大）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/332837/201907/332837-20190710180443843-597552762.png&quot; alt=&quot;arria10_fPLL&quot; width=&quot;450&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt; 所以我们在设计FPGA 或 做工程的时候需要注意下当前 FPGA系列的 CLK属性。能用专用pin 的就用专用pin&lt;/p&gt;
&lt;p&gt;专用pin GCLK 等的好处， low slew rate , high fan out 等等。 timing 更容易满足 &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 13 Jul 2019 14:49:00 +0000</pubDate>
<dc:creator>DeeZeng</dc:creator>
<og:description>原创 by DeeZeng FPGA的时钟需要从专用的时钟管脚输入，那CLKn 作为Single-End时钟pin时是否能直接进 PLL呢？ 通过查看对应FPGA型号的手册，得出以下结论 1. Cyc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/DeeZeng/p/11164299.html</dc:identifier>
</item>
<item>
<title>模式识别与机器学习(二) - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/11182138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/11182138.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av22128683?from=search&amp;amp;seid=1585731534089752391&quot;&gt;视屏链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类间距离测度方法&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最近距离法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_{kl} = min_{i,j} \lfloor d_{ij}\rfloor {a}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(d_{ij}\)&lt;/span&gt;表示 &lt;span class=&quot;math inline&quot;&gt;\(\vec x_i \in w_k\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\vec x_j \in w_l\)&lt;/span&gt; 之间的距离&lt;br/&gt;用于链式结构分布的数据中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201907/1503464-20190713212300520-774823768.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最远距离法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_{kl} = max_{i,j} \lfloor d_{ij}\rfloor {a}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(d_{ij}\)&lt;/span&gt;表示 &lt;span class=&quot;math inline&quot;&gt;\(\vec x_i \in w_k\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\vec x_j \in w_l\)&lt;/span&gt; 之间的距离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201907/1503464-20190713212312526-1547668940.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;中间距离法&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;$D^2_{kl} = \frac{1}{2} D^2_{kp} + \frac{1}{2} D^2_{kq} - \frac{1}{4}D^2_{pq} $&lt;br/&gt;假设有两类p,q，取p和q的并集为类&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;，p和q的中点记作&lt;span class=&quot;math inline&quot;&gt;\(D_{pq}\)&lt;/span&gt;，集合&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;到集合&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;的距离就为集合&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(D_{pq}\)&lt;/span&gt;的距离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;重心距离法&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;两类之间的重心的距离。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(D^2_{kl} = \frac{n_p}{n_p + n_q}D_{kp}^2+\frac{n_q}{n_p+n_q}D^2_{kq}-\frac{n_p n_q}{(n_p+n_q)^2}D_{pq}^2\)&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(n_p\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(n_q\)&lt;/span&gt;分别为类&lt;span class=&quot;math inline&quot;&gt;\(w_p\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(w_q\)&lt;/span&gt;的样本个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201907/1503464-20190713212322900-2050393571.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;平均距离法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(D^2_{pq} = \frac{1}{n_p n_q} \sum_{\vec x_i \in w_p,\\ \vec x_j \in w_q} d^2_{ij}\)&lt;/span&gt;&lt;br/&gt;两类之间所有点之间距离的均值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201907/1503464-20190713212331719-1468316755.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;离差平方和法&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(s_l = \sum_{\vec x_i \in w_l} (\vec x_i - \vec x_l)^`(\vec x_i - \vec x_l)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_t = w_p \bigcup w_q \\ D^2_{pq} = s_l - s_p - s_q\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\downarrow \downarrow\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(D^2_{pq} = \frac{n_p n_q}{n_p + n_q}(\vec x_p - \vec x_q)^`(\vec x_p - \vec x_q)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\vec x_l \vec x_p \vec x_q\)&lt;/span&gt;分别为对应类的重心，递推公式为：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(D^2_{kl} = \frac{n_k + n_p}{n_k + n_l}D^2_{kp} + \frac{n_k + n_q}{n_k + n_l}D^2_{kq} - \frac{n_k}{n_k + n_l}D^2_{pq}\)&lt;/span&gt;&lt;br/&gt;即：类中的各个模式离均值的偏差的平方和&lt;br/&gt;该定义适用于团状分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;点与集合间的距离&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;第一类: 对集合的分布没有先验知识时，可采用类间距离计算方法进行&lt;/li&gt;
&lt;li&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;第二类: 当知道集合的中点分布的先验知识时，可用相应的模型进行计算(点模型，超平面模型，超球面模型等)&lt;/li&gt;
&lt;li&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;判别分类结果好坏的一般标准:&lt;/span&gt; 类内距离小，类间距离大&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚类的准则函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类内距离准则：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;设有待分类的模式集{&lt;span class=&quot;math inline&quot;&gt;\(\vec{x_1},\vec x_2,...,\vec x_N\)&lt;/span&gt;}在某种相似性测度基础上被划分为&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;类，{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i^{(j)}; j=1,2,...c;i=1,2,...,n_j\)&lt;/span&gt;}类内距离准则函数&lt;span class=&quot;math inline&quot;&gt;\(J_W\)&lt;/span&gt;定义为：(&lt;span class=&quot;math inline&quot;&gt;\(\vec m_j\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;类的模式均值矢量。)&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J_W = \sum^c_{j=1} \sum_{i=1}^{n_j} ||\vec x_i^{(j)} - \vec m_j ||^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类间距离准则&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J_B = \sum_{j=1}^c (\vec m_j - \vec m)^`(\vec m_j - \vec m) =&amp;gt; max \]&lt;/span&gt;&lt;br/&gt;其中,&lt;span class=&quot;math inline&quot;&gt;\(\vec m_j\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;类的模式平均矢量，&lt;span class=&quot;math inline&quot;&gt;\(\vec m\)&lt;/span&gt;为总的模式平均矢量。设&lt;span class=&quot;math inline&quot;&gt;\(n_j\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;类所含模式个数，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \vec m_j = \frac{1}{n_j} \sum_{\vec x_i \in w_j} \vec x_i, \vec m = \frac{1}{N}\sum^N_{i=1} \vec x_i \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于两类问题，类间距离有时取&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J_{B2} = (\vec m_1 - \vec m_2)^`(\vec m_1 - \vec m_2) \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(J_{B2}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(J_{WB}\)&lt;/span&gt;的关系是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J_{WB} = \frac {n_1}{N} \frac{n_2}{N} J_{B2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于类内距离类间距离的准则函数&lt;/span&gt;&lt;br/&gt;我们希望聚类结果使类内距离越小越好，类间距离越大越好。为此构造能同时反映出类内距离和类间距离的准则函数。&lt;br/&gt;设代分类模式集{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i, i=1,2,...,N\)&lt;/span&gt;}，将它们分成&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;类，&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;含&lt;span class=&quot;math inline&quot;&gt;\(n_j\)&lt;/span&gt;个模式，分类后各模式记为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \{ \vec x_i^{(j)}, j = 1,2,...,c;i=1,2,...,n \} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;的类内离差阵定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ S^{(j)}_W = \frac{1}{n_j} \sum_{i=1}^{n_j} (\vec x_i^{(j)} - \vec m_j)(\vec x_i^{(j)} - \vec m_j)^` , (j=1,2,...,c) \]&lt;/span&gt;&lt;br/&gt;式中&lt;span class=&quot;math inline&quot;&gt;\(\vec m_j\)&lt;/span&gt;为类&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;的模式均值矢量&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \vec m_j = \frac{1}{n_j} \sum_{i=1}^{n_j} \vec x_i^j , (j=1,2,...,c) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总的类内离差阵定义为：&lt;span class=&quot;math inline&quot;&gt;\(S_W = \sum^c_{j=1} \frac{n_j}{N}S_W^{(j)}\)&lt;/span&gt;&lt;br/&gt;类间离差阵定义为: &lt;span class=&quot;math inline&quot;&gt;\(S_B = \sum^c_{j=1} \frac{n_j}{N} (\vec m_j - \vec m)(\vec m_j - \vec m)^`\)&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\vec m\)&lt;/span&gt;为所有待分类模式的均值矢量: &lt;span class=&quot;math inline&quot;&gt;\(\vec m = \frac{1}{N} \sum_{i=1}^N \vec x_i\)&lt;/span&gt;&lt;br/&gt;总的离差阵&lt;span class=&quot;math inline&quot;&gt;\(S_r\)&lt;/span&gt;，定义为：&lt;span class=&quot;math inline&quot;&gt;\(S_r = \frac{1}{N} \sum_{i=1}^N(\vec x_i - \vec m)(\vec x_i - \vec m)^`\)&lt;/span&gt;&lt;br/&gt;于是有：&lt;span class=&quot;math inline&quot;&gt;\(S_r = S_W + S_B\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于类内距离类间距离的准则函数&lt;/span&gt;&lt;br/&gt;聚类的基本目的是使&lt;span class=&quot;math inline&quot;&gt;\(Tr[S_B] =&amp;gt; max\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(Tr[S_W] =&amp;gt; min\)&lt;/span&gt;。利用线性代数有关矩阵的迹和行列式的性质，可以定义如下4个聚类的准则函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J_1 = Tr[S^{-1}_W S_B] \\ \\ J_2 = |S^{-1}_W S_B| \\ \\ J_3 = Tr[S^{-1}_W S_T] \\ \\ J_4 = |S^{-1}_W S_T| \]&lt;/span&gt;&lt;br/&gt;为了得到好的聚类结果，应该使这四个准则函数尽量的大。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚类分析&lt;/span&gt;聚类分析算法归纳起来有三大类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按最小距离原则简单聚类方法&lt;/li&gt;
&lt;li&gt;按最小距离原则进行两类合并的算法&lt;/li&gt;
&lt;li&gt;依据准则函数动态聚类的算法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;简单聚类方法&lt;/span&gt;&lt;br/&gt;针对具体问题确定相似性阙值，将模式到各聚类中心间的距离与阙值比较，当大于阙值时，该模式就作为另一类的类心，小于阙值时，按最小距离原则将其划分到某一类中。&lt;br/&gt;该类算法运行中，模式的类别及类的中心一旦确定将不会改变&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按最小距离原则进行两类合并的算法&lt;/span&gt;&lt;br/&gt;首先视各模式自成一类，然后将距离最小的两类合并成一类，不断重复这个过程，直到成为两类为止。&lt;br/&gt;这类算法运行中，类心会不断进行修正，但模式类别一旦指定后就不会再改变，即模式一旦划为一类后就不再被分划开，这类算法也成为谱系聚类法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依据准则函数动态聚类的算法&lt;/span&gt;&lt;br/&gt;设定一些分类的控制参数，定义一个能表征聚类结果优劣的准则函数，聚类过程就是使准则函数取极值的优化过程。&lt;br/&gt;算法运行中，类心不断地修正，各模式的类别的指定也不断地更改。这类算法有--C均值法、ISODATA法等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据相似性阙值的简单聚类方法&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;根据相似性阙值和最小距离原则的简单聚类方法
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;条件及约定&lt;br/&gt;设待分类的模式为{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_1, \vec x_2, ..., \vec x_N\)&lt;/span&gt;}，选定类内距离门限&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;算法思想&lt;br/&gt;计算模式特征矢量到聚类中心距离并和门限&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;比较，决定归属该类或作为新的一类中心。这种算法通常选择欧式距离。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法原理步骤&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;取任意的一个模式特征矢量作为第一个聚类中心。例如，令类&lt;span class=&quot;math inline&quot;&gt;\(w_1\)&lt;/span&gt;的中心 &lt;span class=&quot;math inline&quot;&gt;\(\vec z_1 = \vec x_1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计算下一个模式特征矢量&lt;span class=&quot;math inline&quot;&gt;\(\vec x_2\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1\)&lt;/span&gt;的距离&lt;span class=&quot;math inline&quot;&gt;\(d_{21}\)&lt;/span&gt;。若&lt;span class=&quot;math inline&quot;&gt;\(d_{21} &amp;gt; T\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;为门限，则建立一个新类&lt;span class=&quot;math inline&quot;&gt;\(w_2\)&lt;/span&gt;，其中心为$\vec z_2 = \vec x_2 &lt;span class=&quot;math inline&quot;&gt;\(。若\)&lt;/span&gt;d_21 \leq T&lt;span class=&quot;math inline&quot;&gt;\(，则\)&lt;/span&gt;\vec x_2 \in w_1$&lt;/li&gt;
&lt;li&gt;假设已有聚类中心&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1, \vec z_2, ..., \vec z_k\)&lt;/span&gt;，计算尚未确定类别的模式特征矢量&lt;span class=&quot;math inline&quot;&gt;\(\vec x_1\)&lt;/span&gt;到各聚类中心&lt;span class=&quot;math inline&quot;&gt;\(\vec z_i(j = 1,2,...,k)\)&lt;/span&gt;的距离&lt;span class=&quot;math inline&quot;&gt;\(d_{ij}\)&lt;/span&gt;。如果&lt;span class=&quot;math inline&quot;&gt;\(d_{ij} &amp;gt; T(j=1,2,...,k)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i\)&lt;/span&gt;作为新的一类&lt;span class=&quot;math inline&quot;&gt;\(w_{k+1}\)&lt;/span&gt;的中心，&lt;span class=&quot;math inline&quot;&gt;\(\vec z_{k+1} = \vec x_i\)&lt;/span&gt;；否则，如果&lt;span class=&quot;math inline&quot;&gt;\(d_{ij} = min_j[d_{ij}]\)&lt;/span&gt;，则指判&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i \in w_j\)&lt;/span&gt;。检查是否所有的模式都分划完类别，如果划完了则结束；否则重新进行该部分。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;算法特点&lt;/span&gt;&lt;br/&gt;这类算法的突出特点是算法简单。但聚类过程中，类的中心一旦确定将不会改变，模式一旦指定类后也不再改变。&lt;br/&gt;该算法结果很大程度上依赖于距离门限&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的选取及模式参与分类的次序。如果能有先验知识指导门限&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的选取，通常可以获得比较合理的效果。也可考虑设置不同的&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;和选着不同的次序，最后选择较好的结果进行比较。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;最大最小距离算法
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;条件及约定&lt;/span&gt;&lt;br/&gt;设待分类的模式为{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_1, \vec x_2, ..., \vec x_N\)&lt;/span&gt;}，选定比例系数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法思想&lt;/span&gt;&lt;br/&gt;在模式特征矢量集中以最大距离原则选取新的聚类中心。以最小距离原则进行模式归类。这种方法通常也使用欧式距离。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法原理步骤&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;(1) 任选一模式特征矢量作为第一聚类中心&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1\)&lt;/span&gt;，如&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1 = \vec x_1\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2) 从待分类矢量集中选距离&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1\)&lt;/span&gt;最远的特征矢量作为第二个聚类中心&lt;span class=&quot;math inline&quot;&gt;\(\vec z_2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(3) 计算未被作为聚类中心的各模式特征矢量{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i\)&lt;/span&gt;}与&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1, \vec z_2\)&lt;/span&gt;之间的距离，并求出它们之间的最小值，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d_{ij} = || \vec x_i - \vec z_j || (j = 1,2) \\ d_i = min[d_{i1}, d_{i2}] (i=1,2,...,N) \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(4) 若&lt;span class=&quot;math inline&quot;&gt;\(d_l = max_i[min(d_{i1}, d_{i2})] &amp;gt; \theta||\vec z_1 - \vec z_2||\)&lt;/span&gt;，则相应的特征矢量，&lt;span class=&quot;math inline&quot;&gt;\(\vec x_l\)&lt;/span&gt;作为第三个聚类中心，&lt;span class=&quot;math inline&quot;&gt;\(\vec z_3 = \vec x_l\)&lt;/span&gt;，然后转至(5)，否则转至最后一步(6)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(5) 设存在&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个聚类中心，计算未被作为聚类中心的各特征矢量到各聚类中心的距离&lt;span class=&quot;math inline&quot;&gt;\(d_{ij}\)&lt;/span&gt;，并计算出&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d_l = max_i[min[d_{i1}, d_{i2},...,d_{ik}]] \]&lt;/span&gt;&lt;br/&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(d_l &amp;gt; \theta||\vec z_1 - \vec z_2||\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(\vec z_{k-1} = \vec x_l\)&lt;/span&gt;并转至(5)，否则转至(6)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(6) 当判断出不再有新的聚类中心之后，将模式特征矢量{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_1, \vec x_2,...,\vec x_N\)&lt;/span&gt;}，按最小距离原则分到各类中去，即计算&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d_{ij} = ||\vec x_i - \vec z_j|| (j=1,2,...;i=1,2,...,N) \]&lt;/span&gt;&lt;br/&gt;当&lt;span class=&quot;math inline&quot;&gt;\(d_{il} = min_j[d_{ij}]\)&lt;/span&gt;，则判&lt;span class=&quot;math inline&quot;&gt;\(\vec x_i \in w_l\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;算法特点&lt;/span&gt;&lt;br/&gt;该算法的聚类结果与参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;以及第一个聚类中心的选取有关。如果没有先验知识指导&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1\)&lt;/span&gt;的选择，可适当调整&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\vec z_1\)&lt;/span&gt;，比较多次试探分类结果，选取最合理的一种聚类。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;谱系聚类法&lt;/span&gt;&lt;br/&gt;按最小距离原则不断进行两类合并，也称为层次聚类法，系统聚类法&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;条件及约定&lt;/span&gt;&lt;br/&gt;设待分类的模式特征矢量为{&lt;span class=&quot;math inline&quot;&gt;\(\vec x_1, \vec x_2, ..., \vec x_N\)&lt;/span&gt;}，&lt;span class=&quot;math inline&quot;&gt;\(G_i^{(k)}\)&lt;/span&gt;表示第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次合并时的第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;类。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法思想&lt;/span&gt;&lt;br/&gt;首先将&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个模式视作各自成为一类，然后计算类与类之间的距离，选择距离最小的一对合并成一个新类，计算在新的类别划分下各类之间的距离，再将距离最近的两类合并，直至所有模式聚成两类为止。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;算法原理步骤&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;(1) 初始分类。令&lt;span class=&quot;math inline&quot;&gt;\(k=0\)&lt;/span&gt;，每个模式自成一类，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G_i^{(0)} = \{\vec x_i\}(i = 1,2,...,N) \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(2) 计算各类间的距离&lt;span class=&quot;math inline&quot;&gt;\(D_{ij}\)&lt;/span&gt;，由此生成一个对称矩阵&lt;span class=&quot;math inline&quot;&gt;\(D^{(k)} = (D_{ij})_{m * m}\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;为类的个数,(初始 &lt;span class=&quot;math inline&quot;&gt;\(m = N\)&lt;/span&gt;)。&lt;/li&gt;
&lt;li&gt;(3) 找出在(2)中求得的矩阵&lt;span class=&quot;math inline&quot;&gt;\(D^{(k)}\)&lt;/span&gt;中的最小元素，设它是&lt;span class=&quot;math inline&quot;&gt;\(G_i^{(k)}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(G_j^{(k)}\)&lt;/span&gt;间的距离，将&lt;span class=&quot;math inline&quot;&gt;\(G_i^{(k)}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(G_j^{(k)}\)&lt;/span&gt;两类合并成一类，于是产生新的聚类 &lt;span class=&quot;math inline&quot;&gt;\(G_1^{(k+1)}, G_2^{(k+1)}\)&lt;/span&gt;, ...令 &lt;span class=&quot;math inline&quot;&gt;\(k = k+1, m = m-1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(4) 检查类的个数。如果类数&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;大于2，转至(2)；否则，停止。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/11153892.html&quot;&gt;模式识别与机器学习(一)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jul 2019 13:22:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>模式识别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhhfan/p/11182138.html</dc:identifier>
</item>
</channel>
</rss>