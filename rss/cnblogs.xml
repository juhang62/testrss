<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Bumblebee服务网关之统一请求验证 - 开源微服务(BeetleX)</title>
<link>http://www.cnblogs.com/smark/p/11639280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/11639280.html</guid>
<description>&lt;p&gt;&lt;span&gt;对于微服务网关来说，统一请求验证是一个比较重要和常用的功能，通过网关验证后台服务就无须关注请求验证；对于多语言平台的服务而言制定验证方式和变更验证配置都是一件比较繁琐和工作量大的事情。&lt;code&gt;Bumblebee&lt;/code&gt;提供&lt;code&gt;JWT&lt;/code&gt;验证插件，只需要简单配置即可让网关实现请求统一验证。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;引用插件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Bumblebee&lt;/code&gt;中使用&lt;code&gt;JWT&lt;/code&gt;需要引用两个插件，分别是&lt;code&gt;Bumblebee.Configuration&lt;/code&gt;和&lt;code&gt;Bumblebee.Jwt&lt;/code&gt;。加载启动后就可以通过管理工具进行插件配置.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            g = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Gateway();
            g.HttpOptions(
                o &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    o.Port &lt;/span&gt;= &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
                    o.LogToConsole &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    o.LogLevel &lt;/span&gt;=&lt;span&gt; BeetleX.EventArgs.LogType.Error;
                });
            g.Open();
            g.LoadPlugin(
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Bumblebee.Configuration.Management).Assembly,
                &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Bumblebee.Jwt.JwtPlugin).Assembly
               );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果不想自己编写代码可以下载编译的运行包 &lt;a href=&quot;https://github.com/IKende/Bumblebee/blob/master/bin/Bumblebee1.0.6.zip&quot;&gt;Bumblebee1.0.6&lt;/a&gt;这个版本已经加入了&lt;code&gt;JWT&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;插件管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;运行程序后进行配置管理工具的插件管理页面，可以看到&lt;code&gt;JWT&lt;/code&gt;插件，默认是未启用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081655890-1483882776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据库配置&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Bumblebee.Jwt&lt;/code&gt;的使用需要用到数据库，主要用于接管登陆并生成&lt;code&gt;Token&lt;/code&gt;用。插件默认支持三种数据库，分别是:&lt;code&gt;mssql&lt;/code&gt;,&lt;code&gt;mysql&lt;/code&gt;和&lt;code&gt;pgsql&lt;/code&gt;.相关登陆信息表必须包括以下三个字段：&lt;code&gt;_name&lt;/code&gt;(用户名),&lt;code&gt;_role&lt;/code&gt;(角色)和&lt;code&gt;_password&lt;/code&gt;(密码).mysql脚本如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `_users` (
  `_name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `_password` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `_role` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`_name`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COLLATE&lt;span&gt;=&lt;/span&gt;utf8mb4_0900_ai_ci;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;JWT配置&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;插件使用需要进行配置，可以通过点击插件进入相关配置页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081723835-111740395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例配置如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-json&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Key&quot;: &quot;ExxUqmeDKnAk1eMHV02ICJkwp82RsleM887yRnQS3Gg8OHCxWsLPlzCEAJActCo6y6Mae26JeGDFx7aYkeP7Efl6yh/d1q3XYRCdDLLGbz+kt3vR92H6s78P7JILNgZMiO6XoekKXfT2Qxle7Gyu/1d39NloKhqXgBdgzeobyyo=&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;MD5&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;DBType&quot;: &quot;MYSQL&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;ConnectionString&quot;: &quot;Server=192.168.2.19;Database=world;Uid=root;Pwd=123456;&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;VerifyPaths&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;^/api.*&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;Table&quot;: &quot;_users&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;TokenTimeOut&quot;: 200&lt;span&gt;,
    &lt;/span&gt;&quot;RemoveHeaders&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;Cookie&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;LoginMaxRps&quot;: 200&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Key&lt;/code&gt; JWT处理密钥&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;MD5&lt;/code&gt; 是否要把密码转MD5再查询&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;DBType&lt;/code&gt; 数据类型，分别:MSSQL,MYSQL,PGSQL&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;ConnectionString&lt;/code&gt; 数据库连接字符串&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;VerifyPaths&lt;/code&gt; 需要验证的路径列表，正则表达式。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Table&lt;/code&gt; 用户表名称&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;TokenTimeOut&lt;/code&gt; 凭证超时时间，单位是分钟&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;RemoveHeaders&lt;/code&gt;转发时移走头列表&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;LoginMaxRps&lt;/code&gt;登陆限制，每秒允许并发数，如果设置成零则不限.使用中建议设置一个并发限制，毕竟这个操作涉及到数据库IO处理，容易被恶意调用损耗网关性能。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;JWT相关访问接口&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　　&lt;/code&gt;登陆获取&lt;code&gt;Token&lt;/code&gt;访问Url,&lt;code&gt;cookie&lt;/code&gt;参数表示返回&lt;code&gt;Token&lt;/code&gt;并写入&lt;code&gt;Cookie&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　　&lt;/code&gt;清除&lt;code&gt;Cookie&lt;/code&gt;相应的&lt;code&gt;Token&lt;/code&gt;信息.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;请求Token配置&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果在调用登陆的时候写入了&lt;code&gt;Cookie&lt;/code&gt;那在请求过程中不再需要配置相关&lt;code&gt;Token&lt;/code&gt;信息.在其他调用方式下需要把返回的&lt;code&gt;Token&lt;/code&gt;配置到请求头的&lt;code&gt;Authorization&lt;/code&gt;上。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;应用示例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;直接下来用&lt;code&gt;aspcore&lt;/code&gt;编写一个&lt;code&gt;webapi&lt;/code&gt;服务然后用&lt;code&gt;Bumblebee&lt;/code&gt;进行一个代理并设置安全控制访问。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-cs&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApiController : Controller
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: /&amp;lt;controller&amp;gt;/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ContentResult { Content = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now}|name:{Request.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;jwt_user&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]};role:{Request.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;jwt_role&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Hello(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ContentResult { Content = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello {name} {DateTime.Now}|name:{Request.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;jwt_user&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]};role:{Request.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;jwt_role&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务启动的地址是&lt;code&gt;http://localhost:58387/&lt;/code&gt;,在网关配置相关路由&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081839820-1260017225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;code&gt;JWT&lt;/code&gt;验证关闭后可以正常访问服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081846887-1958538952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于没有经过网关的验证，所以&lt;code&gt;jwt_user&lt;/code&gt;和&lt;code&gt;jwt_role&lt;/code&gt;信息为空。如果开启&lt;code&gt;JWT&lt;/code&gt;验证又会怎样呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081856895-1559272025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是开启的运行结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081906325-1175356385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于请求没有凭证信息，所以被网关拦截并返回了相应的错误。接下来先访问一下登陆接口并获取凭证&lt;code&gt;http://localhost/__system/jwt/login?name=henry&amp;amp;pwd=123456&amp;amp;cookie=true&lt;/code&gt;,当凭证获取后就可以访问服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201910/254151-20191009081915215-162023411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回的结果可以正常获取&lt;code&gt;jwt_user&lt;/code&gt;和&lt;code&gt;jwt_role&lt;/code&gt;信息，因为网关开启jwt后把相关登陆凭让写入到相关信息头传入到相应的服务中。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 09 Oct 2019 00:21:00 +0000</pubDate>
<dc:creator>开源微服务(BeetleX)</dc:creator>
<og:description>对于微服务网关来说，统一请求验证是一个比较重要和常用的功能，通过网关验证后台服务就无须关注请求验证；对于多语言平台的服务而言制定验证方式和变更验证配置都是一件比较繁琐和工作量大的事情。Bumblebe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smark/p/11639280.html</dc:identifier>
</item>
<item>
<title>Vue躬行记（1）——数据绑定 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11254850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11254850.html</guid>
<description>&lt;p&gt;　　Vue.js的核心是通过基于HTML的模板语法声明式地将数据绑定到DOM结构中，即通过模板将数据显示在页面上，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{content}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {　　
      content: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;　
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中&amp;lt;div&amp;gt;元素的内容是一个模板的插值，vm是一个Vue实例。&lt;/p&gt;

&lt;p&gt;　　如果要使用Vue的功能，那么需要通过Vue()构造函数创建一个Vue实例，而Vue实例相当于MVVM模式中的ViewModel。注意，所有的Vue组件（后面篇章将会分析）都是Vue实例。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）选项对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue的构造函数能接收一个选项对象，包含数据、计算属性、方法、模板、生命周期钩子等成员。上面代码中的&lt;span&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/#el&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;el&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是Vue实例的挂载目标，既可以是CSS选择器，也可以是DOM元素；&lt;span&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/#data&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;data&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是Vue实例的数据对象，其属性会被加到Vue的响应式系统中，当修改data的属性时，视图会响应变更而重新渲染，即vm实例的对应属性也会更新，反之亦然，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {
　content: &lt;/span&gt;&quot;strick&quot;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
　el: &lt;/span&gt;&quot;#container&quot;&lt;span&gt;,
　data: data
});
data.content &lt;/span&gt;= &quot;freedom&quot;&lt;span&gt;;
console.log(vm.content);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;span&gt;
vm.content &lt;/span&gt;= &quot;justify&quot;&lt;span&gt;;
console.log(data.content);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;justify&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，如果data属性使用了箭头函数，那么this不会指向vm实例。&lt;/p&gt;
&lt;p&gt;　　在实例被创建之后，就能通过vm.$data访问原来的数据对象，而vm.content是vm.$data.content的简写。注意，被冻结后的对象（即调用了Object.freeze()方法），其属性是无法响应式的。&lt;/p&gt;
&lt;p&gt;　　除了$data属性之外，Vue实例还提供了很多其它的属性和方法，它们都会以“$”符号为前缀，而为了避免与内置的冲突，Vue实例不会代理以“_”或“$”开头的用户自定义的属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue实例的生命周期包括初始化数据、编译模板、挂载、渲染、更新和销毁等，每个阶段都存在对应的钩子，以便执行相关的业务逻辑。由于生命周期钩子都会自动把this和实例绑定在一起，因此不要用箭头函数来声明钩子。&lt;/p&gt;
&lt;p&gt;　　常用的8个生命周期可分为4组（如下所列），每组有一个名称带before前缀，顾名思义，先于另一个钩子执行，图1描绘了实例的生命周期。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201908/211606-20190813160935723-1109881618.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1  Vue实例的生命周期&lt;/p&gt;
&lt;p&gt;　　（1）beforeCreate：实例初始化之后回调，无法访问data、methods、computed等之中的数据或方法。&lt;/p&gt;
&lt;p&gt;　　（2）created：实例创建完成后回调，可访问data、methods、computed等之中的数据或方法，由于还未挂载到DOM中，因此不能成功读取$el。&lt;/p&gt;
&lt;p&gt;　　（3）beforeMount：实例挂载之前回调，将要使用的模板编译成render()函数。&lt;/p&gt;
&lt;p&gt;　　（4）mounted：实例挂载到DOM后回调，已替换模板中的插值，可获取el中的DOM元素，但要注意，不能保证其子组件也已被挂载。&lt;/p&gt;
&lt;p&gt;　　（5）beforeUpdate：数据更新时回调，发生在虚拟DOM之前，可操作现有DOM元素，例如移除其事件监听器等。&lt;/p&gt;
&lt;p&gt;　　（6）updated：DOM重新渲染后回调，可执行依赖于DOM的操作，但要在此期间尽量不要更改状态，以免陷入死循环，并且不能保证其子组件也已被重绘。&lt;/p&gt;
&lt;p&gt;　　（7）beforeDestroy：实例销毁之前回调，此时实例还存在，this仍然能指向它。&lt;/p&gt;
&lt;p&gt;　　（8）destroyed：实例销毁后回调，会解除数据绑定、移除事件、销毁子组件等。&lt;/p&gt;
&lt;p&gt;　　除了这8个钩子之外，还有3个钩子，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）activated：&amp;lt;keep-alive&amp;gt;元素激活时回调。&lt;/p&gt;
&lt;p&gt;　　（2）deactivated：&amp;lt;keep-alive&amp;gt;元素停用时回调。&lt;/p&gt;
&lt;p&gt;　　（3）errorCaptured：捕获到后代组件的错误时回调。&lt;/p&gt;

&lt;p&gt;　　Vue的模板是一段特殊的HTML代码，其语法包括插值、指令和修饰符。虽然Vue的模板语法非常简洁，但是在内部Vue会进行一系列操作，例如将模板编译成虚拟DOM的渲染函数render()，结合响应系统最大程度的优化DOM操作次数以及用最少的代价渲染组件等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）插值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue会以插值的方式将数据传递给模板，而插值可以是文本、HTML代码、特性和表达式。&lt;/p&gt;
&lt;p&gt;　　（1）文本插值是最常见的数据绑定形式，其写法与Mustache中的占位符类似，也需要用两个花括号包裹数据。当和v-once指令配合时，能实现单次插值，即阻止数据变化时的视图更新。如下代码所示，在修改数据对象的text属性后，两个&amp;lt;p&amp;gt;元素所生成的内容会有所不同，具体可参考对应的注释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;strick&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{text}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;text&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{text}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {　
    text: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  };
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: data
  });
  data.text &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）由于模板占位符中的数据会被解释成普通文本（为了预防XSS攻击），因此如果要输出HTML代码，需要使用v-html指令。如下代码所示，第一个&amp;lt;p&amp;gt;元素在输出HTML标签时，它的两个特殊字符都被转义了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;&amp;amp;lt;span&amp;amp;gt;content&amp;amp;lt;/span&amp;amp;gt;&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{html}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;content&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-html&lt;/span&gt;&lt;span&gt;=&quot;html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      html: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;content&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）如果要将数据对象的属性值插到DOM元素的特性（即定义在HTML标签中的标准或非标准属性）中，那么得使用v-bind指令，如下代码所示。注意，当属性值为null、undefined或false时，相应的特性不会被输出到元素中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p id=&quot;row&quot;&amp;gt;&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-bind:id&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      id: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（4）模板占位符还支持表达式运算，如下代码所示。注意，语句是不被允许的，并且在表达式中，只能访问白名单里的全局变量，例如Math和Date。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;success&amp;lt;/p&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{result ? &quot;success&quot; : &quot;failure&quot;}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      result: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue中的指令（Directives）是一组以“v-”为前缀的DOM元素特性，它能接收一个表达式或参数。其职责是告知Vue如何处理提供给它的数据，并且当表达式的结果发生变化时，将其产生的影响反映到DOM上。&lt;/p&gt;
&lt;p&gt;　　指令和参数之间会用冒号隔开，例如前文用于更新DOM元素特性的v-bind。还有一个常用的v-on指令，用于监听事件，如下所示，其中click是事件类型，dot是事件处理程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Vue为v-bind和v-on两个指令提供了专用的缩写（如下所示），分别用“:”和“@”符号表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; v-bind的缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;:id&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; v-on的缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从Vue 2.6.0开始，引入了动态参数的概念，在冒号后面跟一个用方括号包裹的表达式，如下所示，其中type是数据对象的属性，其值会作为参数来使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:[type]&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　动态参数中的表达式会有一些语法约束，例如运算结果得是字符串类型、不能包含空格和引号、避免驼峰方式的变量命名，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:[1234567]&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:[type + &quot;&quot;]&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:[eventType]&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在DOM中使用模板时，eventType会被强制转换成全小写的eventtype，从而就无法在数据对象中读取到它的值了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）修饰符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue的修饰符（Modifier）是一种以“.”开头的特殊后缀，能让指令完成某种特殊行为，例如用.prevent修饰符取消默认操作，即调用事件对象的preventDefault()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;v-on:submit.prevent&lt;/span&gt;&lt;span&gt;=&quot;dot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　过滤器可用来格式化模板中的文本，存在于占位符和v-bind指令中，紧跟在表达式之后，其写法如下所示，name是数据对象的属性，lowercase是一个过滤器，两者用“|”符号隔开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{{ name | lowercase }}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-bind:name&lt;/span&gt;&lt;span&gt;=&quot;name | lowercase&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，自Vue 2.0起，所有的内置过滤器（例如capitalize、uppercase、json等）都已被移除，官方推荐按需加载更专业的库来实现过滤。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue允许用户自定义过滤器，可在实例的filters选项中注册局部过滤器，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  filters: {
    lowercase: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.toLowerCase();
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以在创建Vue实例之前，通过Vue.filter()方法注册全局过滤器，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Vue.filter(&quot;lowercase&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.toLowerCase();
});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt; Vue({...});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当局部过滤器和全局过滤器重名时，会优先采用局部过滤器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）链式调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　多个过滤器可通过“|”符号串联实现链式调用，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ name | lowercase | capitalize }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　lowercase过滤器会接收name的值，然后将其计算结果传给capitalize过滤器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）传递参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于过滤器本质上还是一个函数，因此它支持多个参数的传入，如下所示，compare过滤器会接收三个参数，分别是number和threshold两个数据对象的属性，以及一个常量10。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{number | compare(10, threshold)}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，Vue 2.0取消了用空格来标记过滤器参数的方式，下面的调用是无效的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{number | compare 10 threshold }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在模板中适合简单的声明式逻辑，而应避免频繁的进行复杂计算，这样既不利于维护，也会让模板结构变得臃肿而混乱。为了能合理的执行复杂表达式，Vue引入了计算属性的概念。&lt;/p&gt;
&lt;p&gt;　　计算属性在模板中的数据绑定和普通属性一样，但需要以函数的方式来定义。在下面的代码中，newName是一个计算属性，用来让name属性重复两次再提取末尾两个字符，在它的getter函数中引用了一个指向vm实例的this。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{newName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    computed: {
      newName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.repeat(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;).substr(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
      }
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，计算属性往往会依赖数据对象的属性或其它计算属性，也就是说，当依赖的属性被修改时，计算属性会自动更新。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　计算属性和方法有一个很大的不同，那就是它能被缓存。在下面的代码中，声明了一个getName()方法，虽然它的返回结果和之前的计算属性newName的值相同，但是当依赖的name属性不发生变化时，两者的执行方式会有所不同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  methods: {
    getName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name.repeat(2).substr(-2&lt;span&gt;);
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当多次访问newName时，读取的是其缓存的值，不会执行它的getter函数，而方法每次都会执行一遍。由于计算属性能减少冗余的运算，因此它很适合处理那些耗时且性能开销巨大的操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）写入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　默认情况下只需要定义计算属性的getter函数，不过Vue也为其提供了setter函数，使得计算属性在写入时能处理更为复杂的业务逻辑，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&quot;#container&quot;&lt;span&gt;,
  data: {
    price: &lt;/span&gt;10.2&lt;span&gt;
  },
  computed: {
    total: {
      get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.price * 10&lt;span&gt;;
      },
      set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price = value + Math.round(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.price);
      }
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当为计算属性total赋值时（如下所示），就会调用它的setter函数，并更新vm.price。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vm.total = 10;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Vue采用了非侵入性的响应式系统，当把数据对象传给Vue实例的data属性时，Vue会通过Object.defineProperty()方法将它的每个属性替换成getter和setter两个函数，下面用一个简单的示例展示Vue的基本思路。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const data = {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据对象&lt;/span&gt;
  name: &quot;strick&quot;&lt;span&gt;
};
const proxyData &lt;/span&gt;=&lt;span&gt; {
  name: data.name
};
Object.defineProperty(data, &lt;/span&gt;&quot;name&quot;&lt;span&gt;, {
  get() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入监听逻辑，并在必要时通知变更&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxyData.name;
  },
  set(value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入监听逻辑，并在必要时通知变更&lt;/span&gt;
    proxyData.name =&lt;span&gt; value;
  },
  configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过这波操作后，就能让Vue拥有追踪属性变化的能力，并在属性被访问和修改时通知关联的视图重新渲染。在体验响应式所带来的便利的同时，也要知晓它的一些限制，接下来会分析Vue检测对象和数组发生变动时的注意事项。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于JavaScript无法监听对象属性的添加或删除，因此只有在Vue实例化时才能对数据对象的根属性做getter和setter的替换，即转换成响应式的属性。Vue不允许动态添加根级的响应式属性，这些属性必须预先声明，如下所示，虽然age是vm实例的一个根属性，但它是在实例化后声明的，所以也就无法成为响应式的属性了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    name: &lt;/span&gt;&quot;strick&quot;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应式属性&lt;/span&gt;
&lt;span&gt;  }
});
vm.age &lt;/span&gt;= 28;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非响应式属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了内部的技术限制之外，提前声明响应式属性，也便于开发人员理解代码的意图。对于已创建的实例，有两种方式声明非根级的响应式属性，第一种是用全局的Vue.set()方法或Vue实例的$set()方法，在下面的代码中，为people对象声明了一个响应式的age属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    people: {
      name: &lt;/span&gt;&quot;freedom&quot;&lt;span&gt;
    }
  }
});
Vue.set(vm.people, &lt;/span&gt;&quot;age&quot;, 28);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是用Object.assign()方法，可一次性添加多个属性，如下所示，将原对象和新增的属性合并成一个新对象，再赋给vm.people。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
vm.people = Object.assign({}, vm.people, { age: 28, school: &quot;university&quot; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue无法检测下面两种数组的变动，以vm实例的names属性为例。&lt;/p&gt;
&lt;p&gt;　　（1）通过索引设置数组的元素。&lt;/p&gt;
&lt;p&gt;　　（2）缩短数组的长度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    names: [&lt;/span&gt;&quot;strick&quot;, &quot;freedom&quot;&lt;span&gt;]
  }
});
vm.names[&lt;/span&gt;1] = &quot;justify&quot;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种变动&lt;/span&gt;
vm.names.length = 1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种变动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要检测第一种变动，可以使用Vue.set()方法或数组的splice()方法，而要检测第二种变动，就只能使用splice()方法了，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测第一种变动&lt;/span&gt;
Vue.set(vm.names, 1, &quot;justify&quot;&lt;span&gt;);
vm.names.splice(&lt;/span&gt;1, 1, &quot;justify&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测第二种变动&lt;/span&gt;
vm.names.splice(1, 1);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 09 Oct 2019 00:18:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>Vue.js的核心是通过基于HTML的模板语法声明式地将数据绑定到DOM结构中，即通过模板将数据显示在页面上，如下所示。 其中&amp;lt;div&amp;gt;元素的内容是一个模板的插值，vm是一个Vue实例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11254850.html</dc:identifier>
</item>
<item>
<title>死磕 java线程系列之自己动手写一个线程池 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11639269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11639269.html</guid>
<description>&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191009081525687-804313222.png&quot; alt=&quot;mythreadpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（手机横屏看源码更方便）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）自己动手写一个线程池需要考虑哪些因素？&lt;/p&gt;
&lt;p&gt;（2）自己动手写的线程池如何测试？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;线程池是Java并发编程中经常使用到的技术，那么自己如何动手写一个线程池呢？本文彤哥将手把手带你写一个可用的线程池。&lt;/p&gt;
&lt;h2 id=&quot;属性分析&quot;&gt;属性分析&lt;/h2&gt;
&lt;p&gt;线程池，顾名思义它首先是一个“池”，这个池里面放的是线程，线程是用来执行任务的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，线程池中的线程应该是有类别的，有的是核心线程，有的是非核心线程，所以我们需要两个变量标识核心线程数量coreSize和最大线程数量maxSize。&lt;/p&gt;
&lt;p&gt;为什么要区分是否为核心线程呢？这是为了控制系统中线程的数量。&lt;/p&gt;
&lt;p&gt;当线程池中线程数未达到核心线程数coreSize时，来一个任务加一个线程是可以的，也可以提高任务执行的效率。&lt;/p&gt;
&lt;p&gt;当线程池中线程数达到核心线程数后，得控制一下线程的数量，来任务了先进队列，如果任务执行足够快，这些核心线程很快就能把队列中的任务执行完毕，完全没有新增线程的必要。&lt;/p&gt;
&lt;p&gt;当队列中任务也满了，这时候光靠核心线程就无法及时处理任务了，所以这时候就需要增加新的线程了，但是线程也不能无限制地增加，所以需要控制其最大线程数量maxSize。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，我们需要一个任务队列来存放任务，这个队列必须是线程安全的，我们一般使用BlockingQueue阻塞队列来充当，当然使用ConcurrentLinkedQueue也是可以的（注意ConcurrentLinkedQueue不是阻塞队列，不能运用在jdk的线程池中）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，当任务越来越多而线程处理却不及时，迟早会达到一种状态，队列满了，线程数也达到最大线程数了，这时候怎么办呢？这时候就需要走拒绝策略了，也就是这些无法及时处理的任务怎么办的一种策略，常用的策略有丢弃当前任务、丢弃最老的任务、调用者自己处理、抛出异常等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据上面的描述&lt;/strong&gt;，我们定义一个线程池一共需要这么四个变量：核心线程数coreSize、最大线程数maxSize、阻塞队列BlockingQueue、拒绝策略RejectPolicy。&lt;/p&gt;
&lt;p&gt;另外，为了便于给线程池一个名称，我们再加一个变量：线程池的名称name。&lt;/p&gt;
&lt;p&gt;所以我们得出了线程池的属性及构造方法大概如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThreadPoolExecutor implements Executor {
    /**
     * 线程池的名称
     */
    private String name;
    /**
     * 核心线程数
     */
    private int coreSize;
    /**
     * 最大线程数
     */
    private int maxSize;
    /**
     * 任务队列
     */
    private BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue;
    /**
     * 拒绝策略
     */
    private RejectPolicy rejectPolicy;

    public MyThreadPoolExecutor(String name, int coreSize, int maxSize, BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue, RejectPolicy rejectPolicy) {
        this.name = name;
        this.coreSize = coreSize;
        this.maxSize = maxSize;
        this.taskQueue = taskQueue;
        this.rejectPolicy = rejectPolicy;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;任务流向分析&quot;&gt;任务流向分析&lt;/h2&gt;
&lt;p&gt;根据上面的属性分析，基本上我们已经得到了任务流向的完整逻辑：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，如果运行的线程数小于核心线程数，直接创建一个新的核心线程来运行新的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，如果运行的线程数达到了核心线程数，则把新任务入队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt;，如果队列也满了，则创建新的非核心线程来运行新的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，如果非核心线程数也达到最大了，那就执行拒绝策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191009081525931-2114153084.png&quot; alt=&quot;mythreadpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码逻辑大致如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void execute(Runnable task) {
        // 正在运行的线程数
        int count = runningCount.get();
        // 如果正在运行的线程数小于核心线程数，直接加一个线程
        if (count &amp;lt; coreSize) {
            // 注意，这里不一定添加成功，addWorker()方法里面还要判断一次是不是确实小
            if (addWorker(task, true)) {
                return;
            }
            // 如果添加核心线程失败，进入下面的逻辑
        }

        // 如果达到了核心线程数，先尝试让任务入队
        // 这里之所以使用offer()，是因为如果队列满了offer()会立即返回false
        if (taskQueue.offer(task)) {
            // do nothing，为了逻辑清晰这里留个空if
            // 【本篇文章由公众号“彤哥读源码”原创】
        } else {
            // 如果入队失败，说明队列满了，那就添加一个非核心线程
            if (!addWorker(task, false)) {
                // 如果添加非核心线程失败了，那就执行拒绝策略
                rejectPolicy.reject(task, this);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建线程逻辑分析&quot;&gt;创建线程逻辑分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，创建线程的依据是正在运行的线程数量有没有达到核心线程数或者最大线程数，所以我们还需要一个变量runningCount用来记录正在运行的线程数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，这个变量runningCount需要在并发环境下加加减减，所以这里需要使用到Unsafe的CAS指令来控制其值的修改，用了CAS就要给这个变量加上volatile修饰，为了方便我们这里直接使用AtomicInteger来作为这个变量的类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt;，因为是并发环境中，所以需要判断runningCount &amp;lt; coreSize(或maxSize)（条件一）的同时修改runningCount CAS加一（条件二）成功了才表示可以增加一个线程，如果条件一失败则表示不能再增加线程了直接返回false，如果条件二失败则表示其它线程先修改了runningCount的值，则重试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，创建一个线程并运行新任务，且不断从队列中拿任务来运行【本篇文章由公众号“彤哥读源码”原创】。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191009081526169-329270523.png&quot; alt=&quot;mythreadpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private boolean addWorker(Runnable newTask, boolean core) {
        // 自旋判断是不是真的可以创建一个线程
        for (; ; ) {
            // 正在运行的线程数
            int count = runningCount.get();
            // 核心线程还是非核心线程
            int max = core ? coreSize : maxSize;
            // 不满足创建线程的条件，直接返回false
            if (count &amp;gt;= max) {
                return false;
            }
            // 修改runningCount成功，可以创建线程
            if (runningCount.compareAndSet(count, count + 1)) {
                // 线程的名字
                String threadName = (core ? &quot;core_&quot; : &quot;&quot;) + name + sequence.incrementAndGet();
                // 创建线程并启动
                new Thread(() -&amp;gt; {
                    System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());
                    // 运行的任务
                    Runnable task = newTask;
                    // 不断从任务队列中取任务执行，如果取出来的任务为null，则跳出循环，线程也就结束了
                    while (task != null || (task = getTask()) != null) {
                        try {
                            // 执行任务
                            task.run();
                        } finally {
                            // 任务执行完成，置为空
                            task = null;
                        }
                    }
                }, threadName).start();

                break;
            }
        }

        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;取任务逻辑分析&quot;&gt;取任务逻辑分析&lt;/h2&gt;
&lt;p&gt;从队列中取任务应该使用take()方法，这个方法会一直阻塞直至取到任务或者中断，如果中断了就返回null，这样当前线程也就可以安静地结束了，另外还要注意中断了记得把runningCount减一。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private Runnable getTask() {
        try {
            // take()方法会一直阻塞直到取到任务为止
            return taskQueue.take();
        } catch (InterruptedException e) {
            // 线程中断了，返回null可以结束当前线程
            // 当前线程都要结束了，理应要把runningCount的数量减一
            runningCount.decrementAndGet();
            return null;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里我们自己的线程池就写完了，下面我们一起来想想怎么测试呢？&lt;/p&gt;
&lt;h2 id=&quot;测试逻辑分析&quot;&gt;测试逻辑分析&lt;/h2&gt;
&lt;p&gt;我们再来回顾下自己的写的线程池的构造方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public MyThreadPoolExecutor(String name, int coreSize, int maxSize, BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue, RejectPolicy rejectPolicy) {
        this.name = name;
        this.coreSize = coreSize;
        this.maxSize = maxSize;
        this.taskQueue = taskQueue;
        this.rejectPolicy = rejectPolicy;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name，这个随便传；&lt;/p&gt;
&lt;p&gt;coreSize，我们假设为5；&lt;/p&gt;
&lt;p&gt;maxSize，我们假设为10；&lt;/p&gt;
&lt;p&gt;taskQueue，任务队列，既然我们设置的是有边界的，我们就用最简单的ArrayBlockingQueue好吧，容量设置为15，这样里面最多可以存储15条任务；&lt;/p&gt;
&lt;p&gt;rejectPolicy，拒绝策略，我们假设使用丢弃当前任务的策略，OK，我们来实现一个。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 丢弃当前任务
 */
public class DiscardRejectPolicy implements RejectPolicy {
    @Override
    public void reject(Runnable task, MyThreadPoolExecutor myThreadPoolExecutor) {
        // do nothing
        System.out.println(&quot;discard one task&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，这样一个线程池就创建完成了，下面就是执行任务了，我们假设通过for循环连续不断地添加100个任务好不好。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThreadPoolExecutorTest {
    public static void main(String[] args) {
        Executor threadPool = new MyThreadPoolExecutor(&quot;test&quot;, 5, 10, new ArrayBlockingQueue&amp;lt;&amp;gt;(15), new DiscardRejectPolicy());
        AtomicInteger num = new AtomicInteger(0);

        for (int i = 0; i &amp;lt; 100; i++) {
            threadPool.execute(()-&amp;gt;{
                try {
                    Thread.sleep(1000);
                    System.out.println(&quot;running: &quot; + System.currentTimeMillis() + &quot;: &quot; + num.incrementAndGet());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们分析下这段程序：&lt;/p&gt;
&lt;p&gt;（1）先连续创建了5个核心线程，并执行了新任务；&lt;/p&gt;
&lt;p&gt;（2）后面的15个任务进了队列；&lt;/p&gt;
&lt;p&gt;（3）队列满了，又连续创建了5个线程，并执行了新任务；&lt;/p&gt;
&lt;p&gt;（4）后面的任务就没得执行了，全部走了丢弃策略；&lt;/p&gt;
&lt;p&gt;（5）所以真正执行成功的任务应该是 5 + 15 + 5 = 25 条任务；&lt;/p&gt;
&lt;p&gt;运行之：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread name: core_test2
thread name: core_test5
thread name: core_test3
thread name: core_test4
thread name: core_test1
thread name: test6
thread name: test7
thread name: test8
thread name: test9
discard one task
thread name: test10
discard one task
...省略被拒绝的任务
【本篇文章由公众号“彤哥读源码”原创】
discard one task
running: 1570546871851: 2
running: 1570546871851: 8
running: 1570546871851: 7
running: 1570546871851: 6
running: 1570546871851: 5
running: 1570546871851: 3
running: 1570546871851: 4
running: 1570546871851: 1
running: 1570546871851: 10
running: 1570546871851: 9
running: 1570546872852: 14
running: 1570546872852: 20
running: 1570546872852: 19
running: 1570546872852: 17
running: 1570546872852: 18
running: 1570546872852: 16
running: 1570546872852: 15
running: 1570546872852: 12
running: 1570546872852: 13
running: 1570546872852: 11
running: 1570546873852: 21
running: 1570546873852: 24
running: 1570546873852: 23
running: 1570546873852: 25
running: 1570546873852: 22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，创建了5个核心线程、5个非核心线程，成功执行了25条任务，完成没问题，完美^^。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）自己动手写一个线程池需要考虑的因素主要有：核心线程数、最大线程数、任务队列、拒绝策略。&lt;/p&gt;
&lt;p&gt;（2）创建线程的时候要时刻警惕并发的陷阱；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;我们知道，jdk自带的线程池还有两个参数：keepAliveTime、unit，它们是干什么的呢？&lt;/p&gt;
&lt;p&gt;答：它们是用来控制何时销毁非核心线程的，当然也可以销毁核心线程，具体的分析请期待下一章吧。&lt;/p&gt;
&lt;h2 id=&quot;完整源码&quot;&gt;完整源码&lt;/h2&gt;
&lt;h3 id=&quot;executor接口&quot;&gt;Executor接口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mythreadpoolexecutor线程池实现类&quot;&gt;MyThreadPoolExecutor线程池实现类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 自动动手写一个线程池
 */
public class MyThreadPoolExecutor implements Executor {

    /**
     * 线程池的名称
     */
    private String name;
    /**
     * 线程序列号
     */
    private AtomicInteger sequence = new AtomicInteger(0);
    /**
     * 核心线程数
     */
    private int coreSize;
    /**
     * 最大线程数
     */
    private int maxSize;
    /**
     * 任务队列
     */
    private BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue;
    /**
     * 拒绝策略
     */
    private RejectPolicy rejectPolicy;
    /**
     * 当前正在运行的线程数【本篇文章由公众号“彤哥读源码”原创】
     * 需要修改时线程间立即感知，所以使用AtomicInteger
     * 或者也可以使用volatile并结合Unsafe做CAS操作（参考Unsafe篇章讲解）
     */
    private AtomicInteger runningCount = new AtomicInteger(0);

    public MyThreadPoolExecutor(String name, int coreSize, int maxSize, BlockingQueue&amp;lt;Runnable&amp;gt; taskQueue, RejectPolicy rejectPolicy) {
        this.name = name;
        this.coreSize = coreSize;
        this.maxSize = maxSize;
        this.taskQueue = taskQueue;
        this.rejectPolicy = rejectPolicy;
    }

    @Override
    public void execute(Runnable task) {
        // 正在运行的线程数
        int count = runningCount.get();
        // 如果正在运行的线程数小于核心线程数，直接加一个线程
        if (count &amp;lt; coreSize) {
            // 注意，这里不一定添加成功，addWorker()方法里面还要判断一次是不是确实小
            if (addWorker(task, true)) {
                return;
            }
            // 如果添加核心线程失败，进入下面的逻辑
        }

        // 如果达到了核心线程数，先尝试让任务入队
        // 这里之所以使用offer()，是因为如果队列满了offer()会立即返回false
        if (taskQueue.offer(task)) {
            // do nothing，为了逻辑清晰这里留个空if
        } else {
            // 如果入队失败，说明队列满了，那就添加一个非核心线程
            if (!addWorker(task, false)) {
                // 如果添加非核心线程失败了，那就执行拒绝策略
                rejectPolicy.reject(task, this);
            }
        }
    }

    private boolean addWorker(Runnable newTask, boolean core) {
        // 自旋判断是不是真的可以创建一个线程
        for (; ; ) {
            // 正在运行的线程数
            int count = runningCount.get();
            // 核心线程还是非核心线程
            int max = core ? coreSize : maxSize;
            // 不满足创建线程的条件，直接返回false
            if (count &amp;gt;= max) {
                return false;
            }
            // 修改runningCount成功，可以创建线程
            if (runningCount.compareAndSet(count, count + 1)) {
                // 线程的名字
                String threadName = (core ? &quot;core_&quot; : &quot;&quot;) + name + sequence.incrementAndGet();
                // 创建线程并启动
                new Thread(() -&amp;gt; {
                    System.out.println(&quot;thread name: &quot; + Thread.currentThread().getName());
                    // 运行的任务【本篇文章由公众号“彤哥读源码”原创】
                    Runnable task = newTask;
                    // 不断从任务队列中取任务执行，如果取出来的任务为null，则跳出循环，线程也就结束了
                    while (task != null || (task = getTask()) != null) {
                        try {
                            // 执行任务
                            task.run();
                        } finally {
                            // 任务执行完成，置为空
                            task = null;
                        }
                    }
                }, threadName).start();

                break;
            }
        }

        return true;
    }

    private Runnable getTask() {
        try {
            // take()方法会一直阻塞直到取到任务为止
            return taskQueue.take();
        } catch (InterruptedException e) {
            // 线程中断了，返回null可以结束当前线程
            // 当前线程都要结束了，理应要把runningCount的数量减一
            runningCount.decrementAndGet();
            return null;
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rejectpolicy拒绝策略接口&quot;&gt;RejectPolicy拒绝策略接口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RejectPolicy {
    void reject(Runnable task, MyThreadPoolExecutor myThreadPoolExecutor);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;discardrejectpolicy丢弃策略实现类&quot;&gt;DiscardRejectPolicy丢弃策略实现类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 丢弃当前任务
 */
public class DiscardRejectPolicy implements RejectPolicy {
    @Override
    public void reject(Runnable task, MyThreadPoolExecutor myThreadPoolExecutor) {
        // do nothing
        System.out.println(&quot;discard one task&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试类&quot;&gt;测试类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThreadPoolExecutorTest {
    public static void main(String[] args) {
        Executor threadPool = new MyThreadPoolExecutor(&quot;test&quot;, 5, 10, new ArrayBlockingQueue&amp;lt;&amp;gt;(15), new DiscardRejectPolicy());
        AtomicInteger num = new AtomicInteger(0);

        for (int i = 0; i &amp;lt; 100; i++) {
            threadPool.execute(()-&amp;gt;{
                try {
                    Thread.sleep(1000);
                    System.out.println(&quot;running: &quot; + System.currentTimeMillis() + &quot;: &quot; + num.incrementAndGet());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191009081526347-690234478.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 00:15:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。 （手机横屏看源码更方便） 问题 （1）自己动手写一个线程池需要考虑哪些因素？ （2）自己动手写的线程池如何测试？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11639269.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html</guid>
<description>&lt;p&gt;微软在千禧年推出 .NET战略，并在两年后推出第一个版本的.NET Framework和IDE（Visual Studio.NET 2002，后来改名为Visual Studio），如果你是一个资深的.NET程序员，相信传统的.NET应用的开发方式已经深深地烙印在你的脑子里面。.NET Core带来了全新的开发体验，但开发方式的差异根本不足以成为你快速跨入.NET Core 世界的门槛，因为在.NET Core在很多方面比传统的.NET Framework应用开发要简单。为了消除很多尚未接触过.NET Core的读者对未知世界的恐惧，我们先通过几个简单的Hello World应用让大家感受一下在Windows上的.NET Core全新的开发体验。&lt;/p&gt;

&lt;p&gt;.NET Core的&lt;a href=&quot;https://www.microsoft.com/net/core&quot;&gt;官方站点&lt;/a&gt;介绍了在各种平台下安装开发环境的方式。总的来说，我们在不同的平台下开发.NET Core应用都需要安装相应的SDK和IDE。成功安装SDK之后，我们在本地将自动拥有.NET Core的运行时（CoreCLR）、基础类库以及相应的开发工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dotnet.exe&lt;/strong&gt;是.NET Core SDK为我们提供的一个重要的命令行工具，我们在进行.NET Core应用的开发部署的时候将会频繁地使用它。dotnet.exe提供了很多有用的命令，为了不“节外生枝”，我们就不对它们作系统介绍了，如果后续章节涉及到相关命令，我们再对它们作针对性的介绍。当.NET Core SDK安装结束之后，我们可以运行dotnet命令来确认SDK是否安装成功。如下图所示，我们执行&lt;strong&gt;dotnet --info&lt;/strong&gt;命令查看当前安装的.NET Core SDK的基本信息，显示的信息包含SDK的版本、运行时环境以及本机按照的所有运行时版本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080725633-1542037082.png&quot;&gt;&lt;img width=&quot;675&quot; height=&quot;442&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080726190-2060826014.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;高效的开发自然离不开一个优秀的IDE，在这方面作为一个.NET开发者是幸福的，因为我们拥有宇宙第一的开发神器&lt;strong&gt;Visual Studio&lt;/strong&gt;。虽然Visual Studio Code也不失为一个优秀的IDE，如果Windows依旧是我们主要的开发环境，我个人还是推荐使用Visual Studio。当我在敲这行文字的时候，Visual Studio的最新版本为2019。顺便说一下，Visual Studio已经提供了Mac版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Visual Studio Code&lt;/strong&gt;是一个完全免费并且提供全平台支持（Windows、Mac和Linux）的IDE，我们可以直接在其官网（https://code.visualstudio.com/）上下载。Visual Studio 2019提供了社区版（Community）、专业版（Professional）和企业版（Enterprise），其中社区版是免费的，专业版和企业版需要付费购买。Visual Studio的官网地址为https://www.visualstudio.com/。&lt;/p&gt;
&lt;p&gt;除了Visual Studio和Visual Studio Code，我们还可以使用一款叫做Rider的IDE来开发.NET Core应用。Rider是著名的JetBrains公司开发的一款专门针对.NET的IDE，我们可以利用它来开发ASP.NET、.NET Core、Xmarin以及Unity应用。和Visual Studio Code一样，&lt;strong&gt;Rider&lt;/strong&gt;同样也是个跨平台的IDE，我们可以同时在Windows、Max OS X以及各种桌面版本的Linux Distribution上使用它。不过这不是一款免费的IDE，对它感兴趣的朋友可以在&lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;官方站点&lt;/a&gt;载30天试用版。&lt;/p&gt;

&lt;p&gt;dotnet .exe提供了基于 “脚手架（Scaffolding）”创建初始应用的new命令。如果需要开发某种类型的.NET Core应用，我们一般不会从第一行代码写起，而是利用这个命令帮助我们创建一个具有初始结构的应用程序。除此之外，在开发过程中如果需要添加某种类型的文件（比如各种类型的配置文件、MVC的视图文件等），我们也可以利用该命令来完成，通过这种方式添加的文件具有预定义的初始内容。.NET Core SDK在安装的时候为我们提供了一系列预定义的脚手架模板，我们可以按照如下图所示的方式执行命令行“&lt;strong&gt;dotnet new --list&lt;/strong&gt;”列出当前安装的脚手架模板。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080726603-953263637.png&quot;&gt;&lt;img width=&quot;669&quot; height=&quot;333&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080727017-1624947244.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图列出的就是NET Core SDK安装后提供的预定义的脚手架模板，这些模板大致分为Project Template和Item Template两类，前者为我们创建一个初始项目，后者则在一个现有项目中针对某种项目元素添加一个或者多个对应的文件。细心的读者可以从图2中看到&lt;strong&gt;dotnet new&lt;/strong&gt;命令具有一个&lt;strong&gt;--type&lt;/strong&gt;参数，该参数具有三个预定义的选项（project、item和other），其中前两个分别对应着Project和Item这两种模板类型。&lt;/p&gt;
&lt;p&gt;如果这些预定义的脚手架模板不能满足我们的需求，我们还可以创建自定义的Project或者Item模板，至于自定义模板该如何定义，有兴趣的读者朋友可以参考&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates&quot;&gt;.NET Core官方文档&lt;/a&gt;。自定义模板最终会封装成一个NuGet包，我们可以通过执行&lt;strong&gt;dotnet new -i&lt;/strong&gt;或者&lt;strong&gt;dotnet new --install&lt;/strong&gt;命令对其进行安装。除此之外，对于已经安装的模板，我们可以通过执行&lt;strong&gt;dotnet new -u&lt;/strong&gt;或者&lt;strong&gt;dotnet new --uninstall&lt;/strong&gt;命令将其卸载。&lt;/p&gt;

&lt;p&gt;接下来我们利用&lt;strong&gt;dotnet new&lt;/strong&gt;命令（dotnet new console -n helloworld）按照如下图所示的方式创建一个名为“helloworld”的控制台程序。和传统的.NET Framework应用一样，一个针对C#的.NET Core项目依然由一个对应的.csproj文件来定义，图3所示的helloworld.csproj就是这么一个文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080727344-465663598.png&quot;&gt;&lt;img width=&quot;664&quot; height=&quot;398&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080727657-1609692438.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于传统的.NET Framework应用来说，即使是一个空的C#项目，定义该项目的.csproj文件在内容和结构上都是很复杂的，因为这个.csproj文件的结构并不是面向开发者设计的，我们也不会直接编辑这个文件，而是利用Visual Studio通过设置当前项目的某些属性间接地修改它。但是对于一个.NET Core应用来说，这个.csproj文件的结构变得相对简单并清晰了一些，以至于作为开发人员的我们经常会&lt;strong&gt;直接编辑&lt;/strong&gt;它。对于前面我们执行脚手架命令创建的控制台程序，定义项目的helloworld.csproj文件的完整内容如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Exe&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;netcoreapp3.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，这个helloworld.csproj是一个根节点为&lt;strong&gt;&amp;lt;Project&amp;gt;&lt;/strong&gt;的XML文件，与项目相关的属性可以分组定义在相应的&amp;lt;&lt;strong&gt;PropertyGroup&amp;gt;&lt;/strong&gt;节点下。这个helloworld.csproj文件实际上只定义了两个属性，分别是通过&lt;strong&gt;&amp;lt;OutputType&amp;gt;&lt;/strong&gt;和&lt;strong&gt;&amp;lt;TargetFramework&amp;gt;&lt;/strong&gt;节点表示的编译输出类型和目标框架。由于我们创建的是一个针对.NET Core 3.0的可执行控制台应用，所以目标框架为“netcoreapp3.0”，编译输出为Exe。&lt;/p&gt;
&lt;p&gt;我们执行的dotnet new命令行除了帮助我们创建一个空的控制台程序之外，还会帮助我们生成一些初始化代码，这就是项目目录下的这个Program.cs文件的内容。如下所示的代码片段给出了定义在这个文件的整个C#代码的定义，我们可以看到它定义了代表程序入口点的Main方法，并在这个方法中将字符串“Hello World”打印在控制台上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;    
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; helloworld
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过执行脚手架命令行创建出来应用程序虽然简单，但是它却是一个完整的.NET Core应用，它可以在无需任何修改的情况下直接编译和运行。针对.NET Core应用的编译和运行同样是利用这个dotnet.exe命令行来完成的。如下图所示，在进入当前项目所在目录之后，我们执行&lt;strong&gt;dotnet build&lt;/strong&gt;命令对这个控制台应用实施编译，由于默认采用Debug编译模式，所以编译生成的程序集会保存在&lt;strong&gt;\bin\debug\&lt;/strong&gt;目录下。除此之外，针对不同目标框架编译生成的程序集是不同的，由于我们创建的是针对.NET Core 3.0的应用程序，所以最终生成的程序集被保存在“&lt;strong&gt;\bin\Debug\netcoreapp3.0\&lt;/strong&gt;”目录下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080728005-216644198.png&quot;&gt;&lt;img width=&quot;672&quot; height=&quot;353&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080728486-2073270903.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果查看编译的输出目录，我们会发现两个同名（“helloworld”）的文件，一个是&lt;strong&gt;helloworld.dll&lt;/strong&gt;，另一个是&lt;strong&gt;helloworld.exe&lt;/strong&gt;，后者在尺寸上会大很多。很明显helloworld.exe是一个可以直接运行的可执行文件，而helloworld.dll仅仅是一个单纯的动态链接库，需要借助命令行dotnet.exe才能执行。&lt;/p&gt;
&lt;p&gt;如图5所示，当我们在项目目录下执行&lt;strong&gt;dotnet run&lt;/strong&gt;命令后，编译后的程序随即被执行，程序入口Main方法中指定的“Hello World”字符串被直接打印在控制台上。其实当我们执行dotnet run命令启动程序之前无需显示执行dotnet build对源代码实施编译，因为该命令会自动触发编译操作。在执行dotnet命令启动应用程序集的时候，我们也可以直接指定启动程序集的路径（&lt;strong&gt;dotnet bin\Debug\netcoreapp3.0\helloworld.dll&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080728788-551349601.png&quot;&gt;&lt;img width=&quot;388&quot; height=&quot;199&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191009080729005-1804380787.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Oct 2019 00:07:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>微软在千禧年推出 .NET战略，并在两年后推出第一个版本的.NET Framework和IDE（Visual Studio.NET 2002，后来改名为Visual Studio），如果你是一个资深的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html</dc:identifier>
</item>
<item>
<title>自己动手实现智能家居之温湿度数据采集存储（DHT11，MySql） - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/11636462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/11636462.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;【前言】&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;一个热爱技术的人一定向往有一个科技感十足的环境吧，那何不亲自实践一下属于技术人的座右铭：“技术改变世界”。&lt;/p&gt;
&lt;p&gt;就让我们一步步动手搭建一个属于自己的“智能家居平台”吧（不要对这个名词抬杠啦，技术在手，怎么设计实现因人而异），本文只做抛砖引玉，各路大神如果有更好的想法可以各显神通，当然能在评论区留下更好的想法让大家共同学习是再好不过啦。&lt;/p&gt;
&lt;p&gt;在文章最后附有所有源代码，有需要的可以自行下载，感谢Star~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;系列目录&quot;&gt;【系列目录】&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11420102.html&quot;&gt;树莓派GPIO简介（Python版）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;温湿度数据采集存储（DHT11，MySql）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;温湿度数码管展示（四位共阳数码管）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;构建App展示温湿度报表（ApiCloud，Python Flask）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;普通家用排插集成继电器手工改造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;App远程控制“自制智能”排插&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;使用花生棒内网穿透实现外网访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html#&quot;&gt;App远程监控（摄像头模块集成）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;本节概要&quot;&gt;【本节概要】&lt;/h2&gt;
&lt;p&gt;上一节我们介绍了树莓派以及树莓派的GPIO的简单使用，这一节基于上一节的知识点采集屋内的温度和湿度数据，并且构建python脚本将采集到的数据写入到mysql数据库持久化。&lt;/p&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008220229990-678946534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么接下来我们就一步步讲解这个折腾的过程...&lt;/p&gt;
&lt;h2 id=&quot;硬件采购&quot;&gt;【硬件采购】&lt;/h2&gt;
&lt;p&gt;”某宝“购买一个DHT11模块，大概￥6，为了方便线路灵活连接，我们购买了面包板和杜邦线若干。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008171212924-958261215.png&quot; alt=&quot;DHT11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008171251535-411880372.png&quot; alt=&quot;面包板&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008171324573-956961367.png&quot; alt=&quot;杜邦线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;硬件采购完毕，我们开始搞软件部分~~~&lt;/p&gt;
&lt;h2 id=&quot;dht11模块获取温湿度&quot;&gt;【DHT11模块获取温湿度】&lt;/h2&gt;
&lt;h4 id=&quot;dht11硬件接口&quot;&gt;DHT11硬件接口&lt;/h4&gt;
&lt;p&gt;DHT11有三个IO接口，一个VCC（正极）接3.3v，一个GND接GND，剩下一个DATA接树莓派的任意一个GPIO。在设备上有印刷的字体标明了引脚，可以根据指示接到树莓派上。&lt;/p&gt;
&lt;h4 id=&quot;使用开源类库adafruit_dht获取温湿度&quot;&gt;使用开源类库Adafruit_DHT获取温湿度&lt;/h4&gt;
&lt;p&gt;读取温度和湿度我们可以使用已经封装好的开源库：Adafruit_DHT&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import Adafruit_DHT

# Use read_retry method. This will retry up to 15 times to
# get a sensor reading (waiting 2 seconds between each retry).
# this is bcm code
humidity, temperature = Adafruit_DHT.read_retry(Adafruit_DHT.DHT11, 4)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构建数据存储部分&quot;&gt;构建数据存储部分&lt;/h4&gt;
&lt;p&gt;为了便于我们读写MySql，我们需要一个 MySqlHelper.py，内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
import pymysql
from Utility.Configs import Cfg_MySql

class MySqlHelper:
    conn = None

    def __init__(self, db):
        cfg_mysql = Cfg_MySql()
        self.conn = pymysql.connect(host=cfg_mysql.get('host'), port=int(cfg_mysql.get('port')), user=cfg_mysql.get('user'), passwd=cfg_mysql.get('passwd'), db=db)

    def getConnAndCur(self):
        return self.conn,self.conn.cursor()

    def executeSql(self,sql):
        conn,cur = self.getConnAndCur()
        cur.execute(sql)
        conn.commit()
        cur.close()
        conn.close()

# 用完记得释放
# cur.close()
# conn.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysql的连接信息是通过ini配置文件存储的，我们还需要一个 Configs.py 读写配置文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
import configparser

# 树莓派的ubuntu系统里面如果要使用计划任务，则必须写成绝对路径，意味着这里需要加前缀
# RASPBERRY_PI_PATH = '/7tniy/SevenTiny.SmartHome'

# Windows调试不需要加绝对路径
RASPBERRY_PI_PATH_ROOT = ''

# get configuration
config = configparser.ConfigParser()
config.read(RASPBERRY_PI_PATH_ROOT + 'SmartHome.ini',encoding='UTF-8')


class Cfg_MySql:

    __tag = 'MySql'

    def __init__(self):
        pass

    def get(self, name):
        return config.get(self.__tag, name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的配置文件 SmartHome.ini 放在项目根目录即可。内容如下：&lt;/p&gt;
&lt;pre class=&quot;ini&quot;&gt;
&lt;code&gt;[MySql]
connectionstring = 1
host = 192.168.0.1
port = 3306
user = prod
passwd = 123456xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库表结构：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;/*
Navicat MySQL Data Transfer

Source Server         : 
Source Server Version : 50644
Source Host           : 
Source Database       : SmartHome

Target Server Type    : MYSQL
Target Server Version : 50644
File Encoding         : 65001

Date: 2019-10-08 21:38:09
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for DailyMonitor
-- ----------------------------
DROP TABLE IF EXISTS `DailyMonitor`;
CREATE TABLE `DailyMonitor` (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `DateTime` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  `Year` int(11) DEFAULT NULL,
  `Month` int(11) DEFAULT NULL,
  `Day` int(11) DEFAULT NULL,
  `Hour` int(11) DEFAULT NULL,
  `Temperature` double(255,0) DEFAULT NULL,
  `Humidity` double(255,0) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=1211 DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;主监控脚本-smarthomescreen.py-内容&quot;&gt;主监控脚本 SmartHomeScreen.py 内容&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建mysql连接&lt;/li&gt;
&lt;li&gt;通过DHT11获取温湿度&lt;/li&gt;
&lt;li&gt;将数据异步写入MySql（每小时一次）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
from Utility.MySqlHelper import MySqlHelper
import _thread
import Adafruit_DHT
import time
import datetime
import RPi.GPIO as GPIO
import sys
sys.path.append('..')


def WriteToDb(timenow, year, month, day, hour, temp, humi):
    smartHomeDb = MySqlHelper(&quot;SmartHome&quot;)
    smartHomeDb.executeSql(&quot;INSERT INTO DailyMonitor (DateTime,Year,Month,Day,Hour,Temperature,Humidity) VALUES ('{0}',{1},{2},{3},{4},{5},{6})&quot;.format(
        timenow, year, month, day, hour, temp, humi))

# 已经写入数据库的小时标识，插入数据的同时，修改为下一个小时，用于比较是否需要写入
hasWriteToDbHour = datetime.datetime.now().hour

while(True):
    # time
    timenow = datetime.datetime.now()

    # Use read_retry method. This will retry up to 15 times to
    # get a sensor reading (waiting 2 seconds between each retry).
    # this is bcm code
    humidity, temperature = Adafruit_DHT.read_retry(Adafruit_DHT.DHT11, 4)
    print('time:{0},humidity:{1}%,temperature:{2}*C'.format(
        datetime.datetime.now(), humidity, temperature))

    # 异步将数据写入mysql
    if hasWriteToDbHour == timenow.hour:
        _thread.start_new_thread(WriteToDb, (timenow, timenow.year,
                                             timenow.month, timenow.day, timenow.hour, temperature, humidity))
        if hasWriteToDbHour == 23:
            hasWriteToDbHour = 0
        else:
            hasWriteToDbHour = hasWriteToDbHour + 1

    time.sleep(2)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;温湿度监控&quot;&gt;【温湿度监控】&lt;/h2&gt;
&lt;p&gt;我们通过SSH远程连接到树莓派的终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215011776-883090988.png&quot; alt=&quot;PI&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过FTP将我们的项目上传到树莓派服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215235430-232761352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用后台进程的方式运行我们的主脚本(关闭终端进程不会退出）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;nohup python SmartHomeScreen.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215342568-1506271846.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们的信息采集脚本就一直在工作中了，每小时会采集一次温湿度，并存储到数据库表中。&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;【注意事项】&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;树莓派中默认安装的python版本是2.7，我们的代码是采用python3编写的，可能有不兼容的情况，需要重新安装python3.6以上版本&lt;/li&gt;
&lt;li&gt;我们的GPIO类库是不能在没有GPIO支持的设备上调试的，也就是说在windows本地调试毫无意义，并且安装GPIO的包会出现各种问题，建议直接将代码复制到树莓派调试，无需在本地调试&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;【总结】&lt;/h2&gt;
&lt;p&gt;通过本节内容，我们实现了利用树莓派的GPIO和DHT11温湿度采集模块24小时实时采集环境中的温湿度，并且持久化到了MySql中，作为我们后续监控面板和监控报表的基础数据。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;后续章节我们会介绍利用我们采集的24小时温湿度数据制作温湿度报表... 效果预热：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215717234-1461627393.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;【源码地址】&lt;/h2&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/sevenTiny/SevenTiny.SmartHome&quot;&gt;&lt;span&gt;https://github.com/sevenTiny/SevenTiny.SmartHome&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 23:46:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 一个热爱技术的人一定向往有一个科技感十足的环境吧，那何不亲自实践一下属于技术人的座右铭：“技术改变世界”。 就让我们一步步动手搭建一个属于自己的“智能家居平台”吧（不要对这个名词抬杠啦，技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/7tiny/p/11636462.html</dc:identifier>
</item>
<item>
<title>漫谈 GOF 设计模式在 Spring 框架中的实现 - LiangGzone</title>
<link>http://www.cnblogs.com/lianggzone/p/11639174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lianggzone/p/11639174.html</guid>
<description>&lt;blockquote readability=&quot;7.9896907216495&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.720ui.com/2019/spring5designpatterns&quot;&gt;梁桂钊的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;http://blog.720ui.com/2019/spring5designpatterns/&quot;&gt;http://blog.720ui.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注公众号：「服务端思维」。一群同频者，一起成长，一起精进，打破认知的局限性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在开始正文之前，请你先思考几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你项目中有使用哪些 GOF 设计模式&lt;/li&gt;
&lt;li&gt;说一说 GOF 23 种设计模式的设计理念&lt;/li&gt;
&lt;li&gt;说说 Spring 框架中如何实现设计模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设我是面试官问起了你这些面试题，你该如何回答呢，请先思考一分钟。&lt;/p&gt;
&lt;p&gt;好的，我们开始进入正题。设计模式实践里面提供了许多经久不衰的解决方案和最佳方案。这里，GOF 设计模式主要分为三大类：创建模式、结构模式和行为模式。创建模式对于创建对象实例非常有用。结构模式通过处理类或对象的组合来作用于企业级应用的设计结构，从而降低了应用的复杂性，提高了应用的可重用性和性能。行为模式的意图是一组对象之间的交互作用，以执行单个对象无法自己执行的任务。它描述了类或对象交互以及职责的分配。&lt;/p&gt;
&lt;p&gt;那么，本文的核心话题是 Spring 如何通过使用大量设计模式和良好实践来构建应用程序。&lt;/p&gt;
&lt;h2 id=&quot;工厂方法模式&quot;&gt;工厂方法模式&lt;/h2&gt;
&lt;p&gt;Spring 框架使用工厂模式来实现 Spring 容器的 BeanFactory 和 ApplicationContext 接口。Spring 容器基于工厂模式为 Spring 应用程序创建 bean，并管理着每一个 bean 的生命周期。BeanFactory 和 ApplicationContext 是工厂接口，并且在 Spring 中存在有很多实现类。getBean() 方法是相对应的 bean 的工厂方法。&lt;/p&gt;
&lt;h2 id=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/h2&gt;
&lt;p&gt;在 Spring 框架中，FactoryBean 接口是基于抽象工厂模式设计的。Spring 提供了很多这个接口的实现，比如 ProxyFactoryBean、JndiFactoryBean、LocalSessionFactoryBean、LocalContainerEntityManagerFactoryBean 等。FactoryBean 帮助 Spring 构建它自己无法轻松构建的对象。通常这是用来构造具有许多依赖关系的复杂对象。它也可以根据配置构造高易变的逻辑。例如，在 Spring 框架中，LocalSessionFactoryBean 是 FactoryBean 的一个实现，它用于获取 Hibernate 配置的关联的 bean 的引用。这是一个数据源的特定配置，它在得到 SessionFactory 的对象之前被使用。对此，在一致的情况下可以用 LocalSessionFactoryBean 获取特定的数据源配置。读者可以将 FactoryBean 的 getObject() 方法的返回结果注入到任何其他属性中。&lt;/p&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;
&lt;p&gt;Spring 框架提供了一个单例的 bean 来实现单例模式。它类似于单例模式，但它与 Java 中的单例模式不完全相同。&lt;/p&gt;
&lt;h2 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h2&gt;
&lt;p&gt;Spring 框架中有一些功能实现了建造者模式。以下是 Spring 框架中基于建造者模式的类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EmbeddedDatabaseBuilder&lt;/li&gt;
&lt;li&gt;AuthenticationManagerBuilder&lt;/li&gt;
&lt;li&gt;UriComponentsBuilder&lt;/li&gt;
&lt;li&gt;BeanDefinitionBuilder&lt;/li&gt;
&lt;li&gt;MockMvcWebClientBuilder&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h2&gt;
&lt;p&gt;Spring 框架使用适配器模式来实现很多功能。以下列出的一些在 Spring 框架中使用到适配器模式的类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JpaVendorAdapter&lt;/li&gt;
&lt;li&gt;HibernateJpaVendorAdapter&lt;/li&gt;
&lt;li&gt;HandlerInterceptorAdapter&lt;/li&gt;
&lt;li&gt;MessageListenerAdapter&lt;/li&gt;
&lt;li&gt;SpringContextResourceAdapter&lt;/li&gt;
&lt;li&gt;ClassPreProcessorAgentAdapter&lt;/li&gt;
&lt;li&gt;RequestMappingHandlerAdapter&lt;/li&gt;
&lt;li&gt;AnnotationMethodHandlerAdapter&lt;/li&gt;
&lt;li&gt;WebMvcConfigurerAdapter&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;桥接模式&quot;&gt;桥接模式&lt;/h2&gt;
&lt;p&gt;以下是 Spring 模块中基于桥接模式的实现:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ViewRendererServlet: 它是一个 servlet 桥接 ，主要是对 Portlet MVC 的支持&lt;/li&gt;
&lt;li&gt;桥梁模式: Spring 日志处理使用到桥梁模式&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;装饰器模式&quot;&gt;装饰器模式&lt;/h2&gt;
&lt;p&gt;Spring 框架使用装饰器模式构建重要功能，如事务、缓存同步和与安全相关的任务。让我们看看一些 Spring 实现此模式的功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;织入通知到 Spring 应用程序中。它使用装饰者模式的 CGLib 代理，其通过在运行时生成目标类的子类来工作。&lt;/li&gt;
&lt;li&gt;BeanDefinitionDecorator: 它通过使用自定义属性来增强 bean 的定义。&lt;/li&gt;
&lt;li&gt;WebSocketHandlerDecorator: 它用来增强一个 WebSocketHandler 附加行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;外观模式&quot;&gt;外观模式&lt;/h2&gt;
&lt;p&gt;在企业级应用中，如果使用到 Spring 框架，那么外观模式是常用于应用程序的业务服务层，它用于整合所有服务。 读者也可以在 DAO 的持久层上应用这种模式。&lt;/p&gt;
&lt;h2 id=&quot;代理模式&quot;&gt;代理模式&lt;/h2&gt;
&lt;p&gt;Spring 框架使用 Spring AOP 模块中的代理模式。在 Spring AOP 中，笔者可以创建对象的代理来实现横切关注点。在 Spring 中，其他模块也实现了代理模式，如 RMI、 Spring 的 HTTP 调用、Hessian 和 Burlap。&lt;/p&gt;
&lt;h2 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;Spring Security 项目实现了责任链模式。Spring Security 允许通过使用安全过滤器链在应用程序中实现身份验证和授权功能。这是一个高度可配置的框架。由于使用了责任链设计模式，我们可以在过滤器链上添加自定义过滤器以自定义功能。&lt;/p&gt;
&lt;h2 id=&quot;命令模式&quot;&gt;命令模式&lt;/h2&gt;
&lt;p&gt;Spring MVC 实现了命令模式。在企业级应用中使用到 Spring 框架，读者经常会看到通过使用命令对象来实现命令模式。&lt;/p&gt;
&lt;h2 id=&quot;解释器模式&quot;&gt;解释器模式&lt;/h2&gt;
&lt;p&gt;在 Spring 框架中，解释器模式在 Spring 表达式语言(SpEL)中使用。Spring 从 Spring 3.0 中增加了这个新功能，读者可以在企业级应用程序中通过 Spring 框架使用它。&lt;/p&gt;
&lt;h2 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h2&gt;
&lt;p&gt;Spring 框架还通过 CompositeIterator 类扩展迭代器模式。该模式主要用于 Java 语言的集合框架中，用于按顺序迭代访问元素。&lt;/p&gt;
&lt;h2 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h2&gt;
&lt;p&gt;在 Spring 框架中，观察者模式用于实现 ApplicationContext 的事件处理功能。Spring 为我们提供了 ApplicationEvent 类和 ApplicationListener 接口来启用事件处理。Spring 应用程序中的任何 bean 实现 ApplicationListener 接口，都会接收到 ApplicationEvent 作为事件发布者推送的消息。在这里，事件发布者是主题(Subject) 和实现 ApplicationListener 的 bean 的观察者(Observer)。&lt;/p&gt;
&lt;h2 id=&quot;课后思考&quot;&gt;课后思考&lt;/h2&gt;
&lt;p&gt;你已经知道 GOF 设计模式在 Spring 框架中的常见实现，那么可以说一下 Spring 框架是如何实现单例模式的呢？&lt;/p&gt;
&lt;p&gt;欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。&lt;/p&gt;
&lt;h2 id=&quot;写在末尾&quot;&gt;写在末尾&lt;/h2&gt;
&lt;p&gt;【服务端思维】：我们一起聊聊服务端核心技术，探讨一线互联网的项目架构与实战经验。让所有孤军奋战的研发人员都找到属于自己的圈子，一起交流、探讨。在这里，我们可以认知升级，连接顶级的技术大牛，连接优秀的思维方式，连接解决问题的最短路径，连接一切优秀的方法，打破认知的局限。&lt;/p&gt;
&lt;p&gt;更多精彩文章，尽在「服务端思维」！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/513627/201910/513627-20191009013705258-1500988639.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 17:37:00 +0000</pubDate>
<dc:creator>LiangGzone</dc:creator>
<og:description>原文地址： '梁桂钊的博客' 博客地址： 'http://blog.720ui.com' 欢迎关注公众号：「服务端思维」。一群同频者，一起成长，一起精进，打破认知的局限性。 漫谈 GOF 设计模式在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lianggzone/p/11639174.html</dc:identifier>
</item>
<item>
<title>什么是微服务？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11638979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11638979.html</guid>
<description>&lt;p&gt;什么是微服务？为什么会有微服务？让我们带着这些疑问开始我们的探索。&lt;/p&gt;
&lt;p&gt;我们先看下维基百科和百度百科给出的定义：&lt;/p&gt;
&lt;p&gt;维基百科：2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。&lt;/p&gt;
&lt;p&gt;百度百科：所谓的微服务是SOA架构下的最终产物，该架构的设计目标是为了肢解业务，使得服务能够独立运行。微服务设计原则：1、各司其职 2、服务高可用和可扩展性&lt;/p&gt;
&lt;p&gt;概念还是比较抽象的，接下来，我将从单体应用开始，讲解为什么会有微服务以及什么是微服务。&lt;/p&gt;

&lt;p&gt;在初期，互联网公司的应用技术栈大致分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。两者都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便。&lt;/p&gt;
&lt;p&gt;以 MVC 架构为例，业务通常是通过部署一个 War 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191008224647669-1913130877.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;然而随着业务规模的不断扩大，团队开发人员的不断扩张，单体应用架构就会开始出现问题，大概会有以下几个方面的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署效率低：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要 10 分钟以上。&lt;/li&gt;
&lt;li&gt;团队协作开发成本高：当团队人员扩张，多人修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高。&lt;/li&gt;
&lt;li&gt;系统高可用性差：因为所有的功能开发最后都部署到同一个 War 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。&lt;/li&gt;
&lt;li&gt;线上发布变慢：一旦代码膨胀，服务启动的时间就会变长。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想要解决上面这些问题，服务化的思想也就应运而生。&lt;/p&gt;

&lt;p&gt;服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。在编写业务代码时，对于通用的业务逻辑，把它抽象并独立成为专门的模块，对于代码复用和业务理解有很大的好处。&lt;/p&gt;
&lt;p&gt;以微博系统为例，微博既包含了内容模块，也包含了消息模块和用户模块等。其中消息模块依赖内容模块，消息模块和内容模块又都依赖用户模块。当这三个模块的代码耦合在一起，应用启动时，需要同时去加载每个模块的代码并连接对应的资源。一旦任何模块的代码出现 bug，或者依赖的资源出现问题，整个单体应用都会受到影响。&lt;/p&gt;
&lt;p&gt;为此，首先可以把用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务。微博和消息模块调用用户接口，就从进程内的调用变成远程 RPC 调用。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。进一步的可以再把消息模块也拆分出来作为独立的模块，交由专门的团队来开发和维护。&lt;/p&gt;
&lt;p&gt;可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。&lt;/p&gt;

&lt;p&gt;从 2014 年开始，容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演变为微服务。&lt;/p&gt;
&lt;p&gt;微服务相比于服务化的不同可总结为以下四点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务拆分粒度更细：微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。&lt;/li&gt;
&lt;li&gt;服务独立部署：每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。&lt;/li&gt;
&lt;li&gt;服务独立维护：每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。&lt;/li&gt;
&lt;li&gt;服务治理能力要求高：因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191008232344877-666950742.png&quot; alt=&quot;微服务架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以微博系统为例，可以进一步对内容模块的功能进行拆分，比如内容模块又包含了 feed 模块、评论模块和个人页模块。通过微服务化，将这三个模块变成三个独立的服务，每个服务依赖各自的资源，并独立部署在不同的服务池中，可以由不同的开发人员进行维护。当评论服务需求变更时，只需要修改评论业务相关的代码，并独立上线发布；而 feed 服务和个人页服务不需要变更，也不会受到发布可能带来的变更影响。&lt;/p&gt;
&lt;p&gt;由此可见，微服务化给服务的发布和部署，以及服务的保障带来了诸多好处。&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;进程数&lt;/td&gt;
&lt;td&gt;将所有功能放到同一个进程中&lt;/td&gt;
&lt;td&gt;将功能的每个元素放置到分离的多个服务进程中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;拓展方式&lt;/td&gt;
&lt;td&gt;通过复制整个应用到多台服务器实现拓展&lt;/td&gt;
&lt;td&gt;通过将不同的服务分布于不同的服务器，并按需复制服务的方式实现拓展&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;快速响应变更&lt;/td&gt;
&lt;td&gt;部分更新，都需要重新部署整个应用&lt;/td&gt;
&lt;td&gt;部署和升级都是独立的，有助于大大提高系统变更的敏捷性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;团队结构&lt;/td&gt;
&lt;td&gt;团队结构呈现垂直化，每个团队专门负责专门的一块&lt;/td&gt;
&lt;td&gt;团队结构呈现扁平化，每个团队服务一整个业务能力&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;一个服务的不稳定可能导致整个应用出现问题&lt;/td&gt;
&lt;td&gt;一个服务不稳定，影响范围比较小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;创新性&lt;/td&gt;
&lt;td&gt;很难引入新的技术和框架，所有功能都使用的同一种框架&lt;/td&gt;
&lt;td&gt;每个微服务可以使用不同的语言和框架，引入新技术方便&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;由单体应用进化到服务化拆分部署，随着移动互联网规模的不断扩大，敏捷开发、持续交付、DevOps 理论的发展和实践，以及容器化技术的成熟，微服务架构开始流行。&lt;/p&gt;
&lt;p&gt;微服务的核心在于服务治理，微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的效率。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191009000648748-355850292.png&quot;/&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;0.51639344262295&quot;&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/13882&quot; class=&quot;uri&quot;&gt;https://time.geekbang.org/column/article/13882&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/Microservices&quot; class=&quot;uri&quot;&gt;https://zh.wikipedia.org/zh-cn/Microservices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dwz.cn/YBnkZedT&quot; class=&quot;uri&quot;&gt;https://dwz.cn/YBnkZedT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 08 Oct 2019 16:14:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>什么是微服务？为什么会有微服务？让我们带着这些疑问开始我们的探索。 我们先看下维基百科和百度百科给出的定义： 维基百科：2014年，Martin Fowler 与 James Lewis 共同提出了微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11638979.html</dc:identifier>
</item>
<item>
<title>理解 Redux 的中间件 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/understanding_redux_middleware.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/understanding_redux_middleware.html</guid>
<description>&lt;p&gt;将该思想抽象出来，其实和 Redux 就无关了。问题变成，怎样实现在截获函数的执行，以在其执行前后添加自己的逻辑。&lt;/p&gt;
&lt;p&gt;为了演示，我们准备如下的示例代码来模拟 Redux dispatch action 的场景：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;dispating action:&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, action);
  }
};

&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;FOO&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;BAR&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们最终需要实现的效果是 Redux 中 &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; 的效果，接收一个中间件数据（函数数组），执行真正的 dispatch 前顺次执行这些中间件。&lt;/p&gt;
&lt;p&gt;以打日志为例，我们想在调用 dispatch 时进行日志输出。&lt;/p&gt;
&lt;h2&gt;尝试1 - 手动&lt;/h2&gt;
&lt;p&gt;直接的做法就是手动进行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before dispatch `FOO`&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;FOO&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before dispatch `FOO`&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before dispatch `BAR`&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;BAR&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;before dispatch `BAR`&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但其实这并不算一个系统的解决方案，至少需要摆脱手动这种方式。&lt;/p&gt;
&lt;h2&gt;尝试2 - 包装&lt;/h2&gt;
&lt;p&gt;既然所有 dispatch 操作都会打日志，完全有理由抽取一个方法，将 dispatch 进行包装，在这个方法里来做这些事情。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;dispatchWithLog&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;before dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;(action);
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;after dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但调用的地方也得变，不能直接使用原始的 &lt;code&gt;store.disatch&lt;/code&gt; 而需要使用封装后的 &lt;code&gt;dispatchWithLog&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; store.dispatch({ type: &quot;FOO&quot; });&lt;/span&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; store.dispatch({ type: &quot;BAR&quot; });&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; dispatchWithLog({ type: &quot;FOO&quot; });&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; dispatchWithLog({ type: &quot;BAR&quot; });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;尝试3 - 替换实现/Monkeypatching&lt;/h2&gt;
&lt;p&gt;如果我们直接替换掉原始函数的实现，便可以做到调用的地方不受影响而实现新增的 log 功能，虽然修改别人提供的方法容易引起 bug 且不太科学。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;original&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;before dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-en&quot;&gt;original&lt;/span&gt;(action);
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;after dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
};

&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;FOO&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;BAR&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;尝试4 - 多个函数的截获&lt;/h2&gt;
&lt;p&gt;除了添加 log，如果还想对每次 dispatch 进行错误监控，只需要拿到前面已经替换过实现的 dispatch 方法再次进行替换包装即可。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;original&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;before dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-en&quot;&gt;original&lt;/span&gt;(action);
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;after dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
};

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;report&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;report middleware&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
  } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (error) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;error while dispatching &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以针对单个功能的中间件，我们可以提取出其大概的样子来了：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;middleware&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
  &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 中间件中其他逻辑&lt;/span&gt;
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 中间件中其他逻辑&lt;/span&gt;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改写日志和错误监控为如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
  &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;before dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;after dispatch &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  };
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;report&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;;
  &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;report middleware&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    } &lt;span class=&quot;pl-k&quot;&gt;catch&lt;/span&gt; (error) {
      &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;error while dispatching &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    }
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后按需要应用上述中间件即可：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;log&lt;/span&gt;(store);
&lt;span class=&quot;pl-en&quot;&gt;report&lt;/span&gt;(store);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面中间件的调用可专门编写一个方法来做：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;applyMiddlewares&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;) {
  &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;middleware&lt;/span&gt;(store));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;隐藏 Monkeypatching&lt;/h2&gt;
&lt;p&gt;真实场景下，各中间件由三方编写，如果每个中间件都直接去篡改 &lt;code&gt;store.dispatch&lt;/code&gt; 不太科学也不安全。如此的话，中间件只需要关注新添加的逻辑，将新的 dispatch 返回即可，由框架层面拿到这些中间件后逐个调用并重写原来的 &lt;code&gt;dispatch&lt;/code&gt;，将篡改的操作收敛。&lt;/p&gt;
&lt;p&gt;所以中间件的模式更新成如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
function middleware(store) {
  const next = store.dispatch;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;  store.dispatch = function(action) {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  return function(action) {&lt;/span&gt;
    // 中间件中其他逻辑
    next(action);
    // 中间件中其他逻辑
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改写 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;report&lt;/code&gt; 中间件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
function log(store) {
  const next = store.dispatch;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;  store.dispatch = function(action) {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  return function(action) {&lt;/span&gt;
    console.log(`before dispatch ${action.type}`);
    next(action);
    console.log(`after dispatch ${action.type}`);
  };
}

function report(store) {
  const next = store.dispatch;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;  store.dispatch = function(action) {&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  return function(action) {&lt;/span&gt;
    console.log(&quot;report middleware&quot;);
    try {
      next(action);
    } catch (error) {
      console.log(`error while dispatching ${action.type}`);
    }
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新 &lt;code&gt;applyMiddlewares&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;applyMiddlewares&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;) {
  &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;middleware&lt;/span&gt;(store);
  });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，应用中间件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;applyMiddlewares&lt;/span&gt;(store, [log, report]);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;进一步优化&lt;/h2&gt;
&lt;p&gt;之所以在应用中间件过程中每次都重新给 &lt;code&gt;store.dispatch&lt;/code&gt; 赋值，是想让后续中间件在通过 &lt;code&gt;store.dispatch&lt;/code&gt; 访问时，能够拿到前面中间件修改过的 &lt;code&gt;dispatch&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;如果中间件中不是直接从 &lt;code&gt;store&lt;/code&gt; 身上去获取 &lt;code&gt;store.dispatch&lt;/code&gt;，而是前面已经执行过的中间件将新的 &lt;code&gt;dispatch&lt;/code&gt; 传递给中间件，则可以避免每次对 &lt;code&gt;store.dispatch&lt;/code&gt; 的赋值。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;applyMiddlewares&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;) {
  &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;middlewares&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;reduce&lt;/span&gt;(
    (&lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;middleware&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;middleware&lt;/span&gt;(next),
    &lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;dispatch&lt;/span&gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;忽略掉实际源码中的一些差异，以上，大致就是 Redux 中间件的创建和应用了。&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;m1&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;1 start&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;1 end&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  };
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;m2&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;2 start&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;2 end&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  };
}
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;m3&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;action&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;3 start&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;(action);
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;3 end&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
  };


&lt;span class=&quot;pl-en&quot;&gt;applyMiddlewares&lt;/span&gt;(store, [m1, m2, m3]);
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;FOO&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;span class=&quot;pl-smi&quot;&gt;store&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;dispatch&lt;/span&gt;({ type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;BAR&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; start
&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; start
&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; start
dispating action&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; { type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;FOO&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; }
&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; end
&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; end
&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; end
&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; start
&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; start
&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; start
dispating action&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; { type&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;BAR&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; }
&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; end
&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; end
&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; end
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 08 Oct 2019 15:54:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>将该思想抽象出来，其实和 Redux 就无关了。问题变成，怎样实现在截获函数的执行，以在其执行前后添加自己的逻辑。 为了演示，我们准备如下的示例代码来模拟 Redux dispatch action</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/understanding_redux_middleware.html</dc:identifier>
</item>
<item>
<title>记一次arch滚挂后，更换lts内核 - 不带汽的可乐</title>
<link>http://www.cnblogs.com/Eden-cola/p/11638615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Eden-cola/p/11638615.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;因为arch的滚动升级模式，每天pacman -Syu已经是一种习惯了（虽然我是使用yay的），升级过程中会连内核一起升级，但不会立刻生效，通常要等到下次重启时才会生效。&lt;br/&gt;因为此前使用的是有一点激进的linux内核，而不是linux-lts，所以在国庆节前的某一次不知名的升级中，就出了岔子，然而当时什么都没发现，节后回到公司才发现开机后屏幕不亮了🤣&lt;/p&gt;
&lt;h2 id=&quot;调查过程&quot;&gt;调查过程&lt;/h2&gt;
&lt;p&gt;虽然背景中提到了是因为内核的原因，但在刚发现屏幕不亮时是不知道原因的，只知道屏是黑的，鼠标键盘没有反应，慌作一团。&lt;br/&gt;好在平时会使用ssh远程办公，拿出surface检查了一下发现还能连上，略微放心。&lt;br/&gt;冷静下来后开始按顺序排查，首先排除了硬件线路问题。&lt;br/&gt;然后用journalctl查了一下各个服务启动的日志，看起来一切正常。&lt;br/&gt;尝试禁用sddm，再重启试图进入字符界面，依然失败，看来不是gui的问题，也不是哪个服务启动的问题。&lt;br/&gt;之后使用dmesg查看kernel日志，在日志中发现了一行驱动挂掉的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[    3.507498] RIP: 0010:drm_calc_vbltimestamp_from_scanoutpos+0x30c/0x350 [drm]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在发现是驱动问题了，然而怎么解决并不知道，询问了其他用arch的前辈后，得到了换成lts内核的建议，总之先试试……&lt;/p&gt;
&lt;h2 id=&quot;更换内核操作步骤&quot;&gt;更换内核操作步骤&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;安装linux-lts 和 linux-lts-headers 这两个包，直接pacman即可&lt;/li&gt;
&lt;li&gt;在/boot/loaders/entries里面，复制出arch.conf的文件到arch-lts.conf（也可能叫linux.conf，名字不重要）&lt;/li&gt;
&lt;li&gt;编辑刚刚复制出来的arch-lts.conf，把其中的内核指向修改为lts版本&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;## This is just an example config file.
## Please edit the paths and kernel parameters according to your system.

title   Arch Linux
linux   /vmlinuz-linux
#initrd  /intel-ucode.img
initrd  /initramfs-linux.img
options root=/dev/nvme0n1p2 rw add_efi_memmap rootflags=subvol=@root&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## This is just an example config file.
## Please edit the paths and kernel parameters according to your system.

title   Arch Linux
linux   /vmlinuz-linux-lts
#initrd  /intel-ucode.img
initrd  /initramfs-linux-lts.img
options root=/dev/nvme0n1p2 rw add_efi_memmap rootflags=subvol=@root&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.修改/boot/loader/loader.conf 中的default 为 arch-lts&lt;br/&gt;5.reboot&lt;/p&gt;
&lt;p&gt;这些编辑可以直接用root权限操作，不需要额外配置文件权限&lt;/p&gt;
&lt;h2 id=&quot;至于以后&quot;&gt;至于以后……&lt;/h2&gt;
&lt;p&gt;总之现在问题解决了，之后我大概会长期使用lts版本了吧，反正日常工作用的电脑，稳一点比较重要。&lt;br/&gt;另外……感觉自己好像获得了一个成就，我终于把自己的arch滚挂了一次（虽然不是什么大问题）&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 15:23:00 +0000</pubDate>
<dc:creator>不带汽的可乐</dc:creator>
<og:description>背景 因为arch的滚动升级模式，每天pacman Syu已经是一种习惯了（虽然我是使用yay的），升级过程中会连内核一起升级，但不会立刻生效，通常要等到下次重启时才会生效。 因为此前使用的是有一点激</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Eden-cola/p/11638615.html</dc:identifier>
</item>
<item>
<title>【强化学习】阶段总结 - 虔诚的树</title>
<link>http://www.cnblogs.com/xxxxxxxxx/p/11638593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxxxxxxxx/p/11638593.html</guid>
<description>&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;马尔可夫决策过程 MDP&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; TD vs. MC&lt;/p&gt;

&lt;p&gt;MC 算法试图收敛至一个能够最小化状态价值与实际收获的均方差的解决方案；&lt;/p&gt;
&lt;p&gt;TD 算法收敛到一个根据已有经验构建的最大可能的马尔可夫模型的状态价值，也就是说 TD 算法首先根据已有经验估计状态空间的转移概率，同时估计某一个状态的即时奖励，最后计算该 MDP 的状态函数。&lt;/p&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;p&gt;MC 方法并不利用马尔可夫性质，故在非马尔可夫环境中更有效率；&lt;/p&gt;
&lt;p&gt;TD(0) 利用马尔可夫性质，在马尔可夫环境中更有效率。&lt;/p&gt;

&lt;p&gt;总结以上内容：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MC vs. TD&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Monte-Carlo&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Temporal Difference&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;要等到 episode 结束才能获得 return&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;每一步执行完都能获得一个return  &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;只能使用完整的 episode&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;可以使用不完整的 episode&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;高方差，零偏差&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;低方差，有偏差&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;没有体现出马尔可夫性质&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;体现出了马尔可夫性质&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;hr/&gt;
&lt;p&gt;三种强化学习方法：Monte-Carlo，Temporal-Difference 和 Dynamic Programming，前两种属于 Model-Free 类方法（这其中 MC 需要一个完整的 episode，TD 则不需要完整的 episode），最后一种属于 Model-Based 类方法，它通过计算一个状态 s 所有可能的转移状态 s&lt;sup&gt;′&lt;/sup&gt; 及其转移概率以及对应的即时奖励来计算这个状态 s 的价值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关于是否 Bootstrap：MC  没有引导数据，只使用实际收获；DP 和 TD 都有引导数据；&lt;/li&gt;
&lt;li&gt;关于是否用样本来计算：&lt;span&gt;MC 和 TD&lt;/span&gt; 都是&lt;span&gt;应用样本来估计实际的价值函数&lt;/span&gt;；而 &lt;span&gt;DP&lt;/span&gt; 则是&lt;span&gt;利用模型直接计算得到实际价值函数，没有样本或者采样之说&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;MC 方法使用值函数最原始的定义，该方法利用所有回报的累积和估计值函数；DP 方法和 TD 方法则利用一步预测方法计算当前状态值函数。其共同点是利用了 bootstrapping 方法，不同的是，DP 方法利用模型计算后继状态，而 TD 方法利用试验得到后继状态。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;下面几张提很好的说明了这三类算法的区别：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1705340/201910/1705340-20191008230640995-375260814.jpg&quot; alt=&quot;&quot; width=&quot;360&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1705340/201910/1705340-20191008230648405-2136676899.jpg&quot; alt=&quot;&quot; width=&quot;360&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1705340/201910/1705340-20191008230653650-1579630207.jpg&quot; alt=&quot;&quot; width=&quot;360&quot;/&gt;&lt;/p&gt;



&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;强化学习大一统：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1705340/201910/1705340-20191008231316489-889310136.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们可以发现，MC 和 TD 方法都过于极端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MC 方法需要 episode 走到终止状态才能更新，相当于 ∞-step TD target；&lt;/li&gt;
&lt;li&gt;TD 方法只走一步就更新，相当于 1-step TD target&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常好的方法都是在两个极端之间进行选择，也就是 n-step TD target，这要等到下次才写了。&lt;/p&gt;

</description>
<pubDate>Tue, 08 Oct 2019 15:21:00 +0000</pubDate>
<dc:creator>虔诚的树</dc:creator>
<og:description>马尔可夫决策过程 MDP 基于模型的动态规划方法（Model-Based，DP） 策略搜索 策略迭代 值迭代 无模型的强化学习方法（Model-Free） 蒙特卡洛方法（MC）：效率不高，但是能够展现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xxxxxxxxx/p/11638593.html</dc:identifier>
</item>
</channel>
</rss>