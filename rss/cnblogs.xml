<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2019 AI Bootcamp Guangzhou 参会日记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/CommunityHotspot-AI_Bootcamp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/CommunityHotspot-AI_Bootcamp.html</guid>
<description>&lt;p&gt;2019年的全球AI训练营在北京、上海、广州、杭州、宁波五个地方同时举办！&lt;/p&gt;
&lt;p&gt;12月14日，微软全球AI Bootcamp活动再次驾临广州，本次会议结合 ML.NET 和基于 SciSharp 社区介绍最新的基于 .NET Core 人工智能技术，还有云端人工智能解决方案介绍！&lt;/p&gt;
&lt;h3 id=&quot;net-core-下的人工智能项目scisharp卢建晖&quot;&gt;.NET Core 下的人工智能项目SciSharp（卢建晖）&lt;/h3&gt;
&lt;p&gt;卢老师为我们介绍了基于 .NET Core 的开源解决方案 SciSharp，SciSharp Suite 产品架构，TensorFlow.NET，Keras.NET&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180339166-994224157.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一套基于 .NET Core 的开源解决方案 SciSharp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180403859-1706732329.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SciSharp Suite 产品架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180424359-816392982.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SciSharp 在 .NET 机器学习中有更大的优势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180443969-2075574184.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TensorFlow.NET 介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180502554-1723026436.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TensorFlow.NET 优势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180523331-1245451441.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SciSharp 套件之 TensortFlow .NET 正在被微软的 ML.NET 集成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180543528-1202308462.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Keras.NET 介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180559877-2016781337.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源套件使用情况&lt;/p&gt;
&lt;h3 id=&quot;ml.net-技术分享张善友&quot;&gt;ML.NET 技术分享（张善友）&lt;/h3&gt;
&lt;p&gt;张队为我们介绍了ML.NET 机器学习指南和 Azure Kinect DK .NET 开发概要，ML.NET Open Source Momentum，Azure Kinect DK Sensor&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180620359-1517407691.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ML.NET 机器学习指南和 Azure Kinect DK .NET 开发概要&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180639136-153733495.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ML.NET Open Source Momentum&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180656297-2047955298.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Azure Kinect DK Sensor&lt;/p&gt;
&lt;p&gt;相关文章：&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/12041198.html&quot;&gt;AI Boot Camp 分享之 ML.NET 机器学习指南&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;azure-data-factory-简化etl的混合数据集成服务alan-liu&quot;&gt;Azure Data Factory-简化ETL的混合数据集成服务（Alan Liu）&lt;/h3&gt;
&lt;p&gt;Alan 老师为我们介绍了 Azure 数据规模化分析，Analytics for data-driven apps&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180719490-1064308610.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Azure 数据规模化分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180739777-214509569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Analytics for data-driven apps&lt;/p&gt;
&lt;h3 id=&quot;现场照片&quot;&gt;现场照片&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180801407-352893895.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180813449-1469869012.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;大合照&quot;&gt;大合照&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412316/201912/1412316-20191214180822799-318089681.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： http://www.cnblogs.com/MingsonZheng/ ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 00:20:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>12月14日，微软全球AI Bootcamp活动再次驾临广州，本次会议结合 ML.NET 和基于 SciSharp 社区介绍最新的基于 .NET Core 人工智能技术，还有云端人工智能解决方案介绍！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/CommunityHotspot-AI_Bootcamp.html</dc:identifier>
</item>
<item>
<title>时光时光慢些吧 - rockbean</title>
<link>http://www.cnblogs.com/rockbean/p/12041843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rockbean/p/12041843.html</guid>
<description>&lt;h2 id=&quot;序&quot;&gt;序&lt;/h2&gt;
&lt;p&gt;今天，也就是距离2020年的最后一个月的12月15，清早在深圳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1893564/201912/1893564-20191215080418933-1884171777.png&quot; alt=&quot;rockbean在深圳&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一早听筷子兄弟的父亲，涕泗横流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1893564/201912/1893564-20191215081501906-903866326.png&quot; alt=&quot;追光&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;时光时光慢些吧&quot;&gt;时光时光慢些吧&lt;/h2&gt;
&lt;p&gt;这个相信很多人都听过。词，发自肺腑，情真意切，一针见血。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1893564/201912/1893564-20191215080524191-1605997353.png&quot; alt=&quot;父亲-筷子兄弟&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;但时光真的可以慢吗&quot;&gt;但，时光真的可以慢吗&lt;/h2&gt;
&lt;p&gt;可以的，大兄弟。&lt;/p&gt;
&lt;p&gt;那就是，我们成长得快一些，就是刚。&lt;/p&gt;
&lt;p&gt;没有无缘无故的成功和失败，一次不行就两次，两次不行就三次，三次不行就，可能方向不对，重新思考重新摸索再出发，没有终结性终点和目标，所有的荣誉都仅仅是过去的凭证，代表不了未来，仅仅是阶段性的里程碑，看看父母额头的皱纹和白发，没有空去郁闷和在意别人的眼光。&lt;/p&gt;
&lt;p&gt;我们很多时候的​怨叹，还不够资格。因为努力不够。我们更多地，不是说一直努力不得门道不得法​，而是根本就努力不够，没有资格说自己命不好​。​&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我在努力成为一个指数程序员，你可以争取当一个指数级的XXX，比如理财规划师、财富规划管理师，风险管理师，新媒体人，甚至搬砖师。&lt;br/&gt;只要自己不断进化理念，迭代思维，优化行为，就能让时间慢下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;奔跑吧，少年。时光不等人，但我们可以追时光。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;悟已往之不谏，知来者之可追。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以念念不忘，但不要停留在不忘，计划未来，筹备未来，奋斗未来，动起来，从当下开始。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Dec 2019 00:14:00 +0000</pubDate>
<dc:creator>rockbean</dc:creator>
<og:description>序 今天，也就是距离2020年的最后一个月的12月15，清早在深圳。 一早听筷子兄弟的父亲，涕泗横流。 时光时光慢些吧 这个相信很多人都听过。词，发自肺腑，情真意切，一针见血。 但，时光真的可以慢吗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rockbean/p/12041843.html</dc:identifier>
</item>
<item>
<title>Yii2框架那些折磨人的坑 - 有痣青年</title>
<link>http://www.cnblogs.com/zydj333/p/12038025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zydj333/p/12038025.html</guid>
<description>&lt;h2 id=&quot;_2&quot;&gt;说点闲话&lt;/h2&gt;
&lt;p&gt;距离上次写博客，已经有一年了。在动手写之前，总是带着深深的罪恶感。被它折磨许久，终于，还是，动手了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得庆祝的一件事&lt;/strong&gt;：最近开始健身了。每天动感单车45分钟，游泳45分钟，真的是（生）爽（不）到（如）爆（死）。&lt;/p&gt;
&lt;p&gt;好了，扯淡完毕，步入正题。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;activerecord&quot;&gt;ActiveRecord被莫名写入？&lt;/h2&gt;
&lt;h3 id=&quot;_3&quot;&gt;准备知识&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ActiveRecord&lt;/code&gt;的基本用法。如果不理解，可参考&lt;a href=&quot;http://www.yiiframework.com/doc-2.0/guide-db-active-record.html&quot;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;_4&quot;&gt;代码现场&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @property integer $id
 * @property string $name
 * @property string $detail
 * @property double $price
 * @property integer $area
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; OcRoom &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActivieRecord
{
    &lt;/span&gt;...&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;$room&lt;/span&gt; = OcRoom::find()      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先取出一个对象。&lt;/span&gt;
    -&amp;gt;select(['id'])        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只取出'id'列&lt;/span&gt;
    -&amp;gt;where(['id'=&amp;gt;20&lt;span&gt;])
    &lt;/span&gt;-&amp;gt;&lt;span&gt;one();
&lt;/span&gt;&lt;span&gt;$room&lt;/span&gt;-&amp;gt;save();              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存，会发现此行的其它字段都被写成默认值了。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_5&quot;&gt;总结问题&lt;/h3&gt;
&lt;p&gt;这个例子的问题在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我从数据库中取出了一行，也就是代码中的&lt;code&gt;$room&lt;/code&gt;，但是只取出了&lt;code&gt;id&lt;/code&gt;字段，而其他字段自然就是默认值。&lt;/li&gt;
&lt;li&gt;当我&lt;code&gt;$room-&amp;gt;save()&lt;/code&gt;的时候，那些是默认值的字段也被保存到数据库里去了。what!?&lt;/li&gt;
&lt;li&gt;也就是说，当你想节约资源，不取出所有字段的时候，&lt;strong&gt;一定要注意不能保存，否则，很多数据会被莫名修改为默认值。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;_6&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;然而，我们有什么解决办法呢？提供几种思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自己时刻注意，避免未完全取出的&lt;code&gt;ActiveRecord&lt;/code&gt;的保存。&lt;/li&gt;
&lt;li&gt;修改或继承&lt;code&gt;ActiveRecord&lt;/code&gt;, 使得，当此对象由&lt;code&gt;find()&lt;/code&gt;新建，且字段没有完全取出，调用&lt;code&gt;save()&lt;/code&gt;方法，抛出异常。&lt;/li&gt;
&lt;li&gt;修改或继承&lt;code&gt;ActiveRecord&lt;/code&gt;，使得，当此对象由&lt;code&gt;find()&lt;/code&gt;新建，且字段没有完全取出，调用&lt;code&gt;save()&lt;/code&gt;方法时，只保存取出过的字段，其他字段被忽略。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;h2 id=&quot;transaction&quot;&gt;你的Transaction生效了吗？&lt;/h2&gt;
&lt;h3 id=&quot;_7&quot;&gt;代码现场&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @property integer $id
 * @property string $name
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; OcRoom &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActiveRecord
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rules()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [['name','string','min'=&amp;gt;2,'max'=&amp;gt;10&lt;span&gt;]];
    }
    &lt;/span&gt;...&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; OcHouse &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActiveRecord
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rules()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [['name','string','max'=&amp;gt;10&lt;span&gt;]];
    }
    &lt;/span&gt;...&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OcRoom();
&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;-&amp;gt;name = '';                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;name为空字符串，不满足rules()条件。&lt;/span&gt;

&lt;span&gt;$b&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OcHouse();
&lt;/span&gt;&lt;span&gt;$b&lt;/span&gt;-&amp;gt;name = '我的房间';         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;name合法，可以保存。&lt;/span&gt;

&lt;span&gt;$transaction&lt;/span&gt; = Yii::&lt;span&gt;$app&lt;/span&gt;-&amp;gt;db-&amp;gt;&lt;span&gt;beginTransaction();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;-&amp;gt;save();               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;name字段不合法，无法验证通过，在validate()阶段已经返回false,不会进行数据库存储的步骤，所以也不会抛出异常。&lt;/span&gt;
    &lt;span&gt;$b&lt;/span&gt;-&amp;gt;save();               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;name字段合法，可以正常保存。&lt;/span&gt;

    &lt;span&gt;$transaction&lt;/span&gt;-&amp;gt;commit();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交后，发现$a保存失败，而$b保存成功。&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) 
{
    Yii&lt;/span&gt;::error(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;getTraceAsString(),&lt;span&gt;__METHOD__&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$transaction&lt;/span&gt;-&amp;gt;&lt;span&gt;rollBack();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_8&quot;&gt;问题总结&lt;/h3&gt;
&lt;p&gt;这段代码的问题在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;大家知道&lt;code&gt;$transaction&lt;/code&gt;的存在意义是保证整段数据库存储代码要么全成功，要么全失败。&lt;/li&gt;
&lt;li&gt;显然，在这个例子中，&lt;code&gt;transaction&lt;/code&gt;并没有达到我们想要的效果：&lt;code&gt;$a&lt;/code&gt;因为&lt;code&gt;validate()&lt;/code&gt;都没过，所以&lt;code&gt;$transation-&amp;gt;commit()&lt;/code&gt;的时候并不会报错。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;_9&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;$transation&lt;/code&gt;块内，所有的&lt;code&gt;save()&lt;/code&gt;都要判断下返回值，如果为&lt;code&gt;false&lt;/code&gt;，则直接抛出异常。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;y-m-d&quot;&gt;'Y-m-d'不被识别？&lt;/h2&gt;
&lt;h3 id=&quot;_10&quot;&gt;代码现场&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
OcRenterBill &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActiveRecord
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; rules()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
            [&lt;/span&gt;'start_time','date','format'=&amp;gt;'Y-m-d'],&lt;span&gt;
        ];
    }
}

&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OcRenterBill();
&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt; = '2015-09-12'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;-&amp;gt;save();                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会报错，说格式不对&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_11&quot;&gt;问题总结&lt;/h3&gt;
&lt;p&gt;如果一开始，Yii框架就报错，这个还不算坑。坑的是我在Mac上开发时，这个可以完全正常的工作，而发布到线上环境（Ubuntu）后，就弹出“属性start_time格式无效”的错误。而参考官方文档，发现这种格式是允许的&lt;a href=&quot;http://www.yiiframework.com/doc-2.0/yii-validators-datevalidator.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;啊啊啊。各种试错，最后发现如果改成&lt;code&gt;php:Y-m-d&lt;/code&gt;，世界就清净了。所以，如果你遇到这种问题，感激我吧。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;y-m-d&quot;&gt;内存泄露&lt;/h2&gt;
&lt;h3 id=&quot;_7&quot;&gt;代码现场&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; actionTest() {
        &lt;/span&gt;&lt;span&gt;$total&lt;/span&gt; = 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;('开始内存'.&lt;span&gt;memory_get_usage());
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;$total&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;$ret&lt;/span&gt;=User::findOne(['id'=&amp;gt;910002&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;('end内存'.&lt;span&gt;memory_get_usage());
            &lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$ret&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$total&lt;/span&gt;--&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的内存一直在增长， 按照原本想法来看， 变量被释放了，内存就算增长也不会一直增长。因为每循环一次内存都会被释放。&lt;/p&gt;
&lt;p&gt;分析问题 上面这段代码涉及到了数据库的操作，而我们知道，数据库的很多地方都能引起内存泄漏。 所以先屏蔽数据库相关操作， 我手写了一个原生的数据库查询操作， 发现内存正常，没有问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$dsn&lt;/span&gt; = &quot;mysql:dbname=test;host=localhost&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$db_user&lt;/span&gt; = 'root'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$db_pass&lt;/span&gt; = 'admin'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;
&lt;span&gt;$sql&lt;/span&gt; = &quot;select * from buyer&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;$pdo&lt;/span&gt;-&amp;gt;query(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;$res&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$row&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$row&lt;/span&gt;['username'].'&amp;lt;br/&amp;gt;'&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候答案呼之欲出--- 是yii2框架搞了鬼&lt;/p&gt;
&lt;p&gt;定位问题 既然知道了是yii2 框架的问题那就可以进一步缩小问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; actionTest() {
        &lt;/span&gt;&lt;span&gt;$total&lt;/span&gt; = 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;('开始内存'.&lt;span&gt;memory_get_usage());
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;$total&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;$ret&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;('end内存'.&lt;span&gt;memory_get_usage());
            &lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$ret&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$total&lt;/span&gt;--&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存还是一直增长。 这时候我测试了一个其他的yii2类 发觉内存不增长了。 这就可以联想到是在new 对象的时候yii2内部自己执行了什么操作，然后导致内存泄漏。 什么方法是new 的时候就执行的呢。。。 对的 构造方法 __construct 。 然后 我一步一步的从model 查到object 发觉都没有能引起泄漏的地方。&lt;/p&gt;
&lt;p&gt;这个时候我们不妨换个思路， 既然是yii2框架下出现的泄漏， 那肯定就是yii2独有的功能， 那什么功能是yii2独有的，又是在new 对象的时候就会执行的呢？&lt;/p&gt;
&lt;p&gt;行为（Behavior） 发觉我的模型类里面果然有用了行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; behaviors()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [
            TimestampBehavior&lt;/span&gt;::&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;
        ];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最普通不过的代码。 我们知道 行为最后调用的地方是 yii\base\Component-&amp;gt;attachBehaviors 最后定位到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; attachBehaviorInternal(&lt;span&gt;$name&lt;/span&gt;, &lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(&lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt; instanceof Behavior)) {
            &lt;/span&gt;&lt;span&gt;$behavior&lt;/span&gt; = Yii::createObject(&lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;is_int&lt;/span&gt;(&lt;span&gt;$name&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;$behavior&lt;/span&gt;-&amp;gt;attach(&lt;span&gt;$this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;_behaviors[] = &lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;_behaviors[&lt;span&gt;$name&lt;/span&gt;&lt;span&gt;])) {
                &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;_behaviors[&lt;span&gt;$name&lt;/span&gt;]-&amp;gt;&lt;span&gt;detach();
            }
            &lt;/span&gt;&lt;span&gt;$behavior&lt;/span&gt;-&amp;gt;attach(&lt;span&gt;$this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;_behaviors[&lt;span&gt;$name&lt;/span&gt;] = &lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt;;
        }
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$behavior&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们观察这段代码，发觉他把自己传进去了$behavior-&amp;gt;attach($this); 最后调用的是 yii\base\Behavior-&amp;gt;attach&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; attach(&lt;span&gt;$owner&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;owner = &lt;span&gt;$owner&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;events() &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$event&lt;/span&gt; =&amp;gt; &lt;span&gt;$handler&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;$owner&lt;/span&gt;-&amp;gt;on(&lt;span&gt;$event&lt;/span&gt;, &lt;span&gt;is_string&lt;/span&gt;(&lt;span&gt;$handler&lt;/span&gt;) ? [&lt;span&gt;$this&lt;/span&gt;, &lt;span&gt;$handler&lt;/span&gt;] : &lt;span&gt;$handler&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_11&quot;&gt;问题总结&lt;/h3&gt;
&lt;p&gt;这个时候答案已经呼之欲出， Yii2为了实现行为这一功能， 把自身this传进去，以便能注册事件、触发事件、解除事件。 这就导致了一个循环引用的问题。 所以导致对象refcount一直不为0 一直回收不了。&lt;/p&gt;
&lt;p&gt;接下来就好办了。将查询换成原始的连接试试。果然，内存上升的非常慢了，可以说这才是正常现象。现在的内存也就是50m左右，cpu也稳定在7%左右。 &lt;/p&gt;
&lt;p&gt;代码优化后，再跑脚本，1分钟左右吧，脚本就跑完了。重点是不会再报出内存错误了。所以，以后考虑问题还是要深入。敢于质疑。以后如果遇到这种内存错误，一定要先检查自己的代码是不是有内存泄漏的地方。不要想着先设置php的内存。这样只会治标不治本。&lt;/p&gt;
&lt;h3 id=&quot;_11&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;1、从开发速度方面，借助于gii脚手架，可以快速生成代码，也就是说搭建一个可以增删改查的系统可能一行代码都不用写，而且集成了jquery和bootstrap，特效和样式基本也不需要写了，这对于设计和审美能力普遍较差的后端程序员来说简直是一大福利。不过在前后端完全的分离的趋势下，Yii2前后端的耦合的还是有些重了。&lt;/p&gt;
&lt;p&gt;2、从代码的可读性方面，Yii不会为了刻板地遵照某种设计模式而对代码进行过度的设计。基本上类在IDE里不借助第三方组件是可以跳转阅读源码的。这点上Yii要比Laravel略胜一筹。&lt;/p&gt;
&lt;p&gt;3、从开源生态圈方面，Yii因为人少，稍微偏门一点的资料就很少，需要强大的谷歌能力和阅读英文文档的能力。&lt;/p&gt;
&lt;p&gt;不可否认，Yii是一个优秀的开发框架，值得PHP开发者上手学习，踩坑的过程也是一种成长与积累。最后祝愿PHP小伙伴们都健健康康，事业有成。&lt;/p&gt;

&lt;h2 id=&quot;y-m-d&quot;&gt;&lt;span&gt;END&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Sat, 14 Dec 2019 18:32:00 +0000</pubDate>
<dc:creator>有痣青年</dc:creator>
<og:description>说点闲话 距离上次写博客，已经有一年了。在动手写之前，总是带着深深的罪恶感。被它折磨许久，终于，还是，动手了。 值得庆祝的一件事：最近开始健身了。每天动感单车45分钟，游泳45分钟，真的是（生）爽（不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zydj333/p/12038025.html</dc:identifier>
</item>
<item>
<title>从零开始openGL——三、模型加载及鼠标交互实现 - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/12006050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/12006050.html</guid>
<description>&lt;p&gt; 在&lt;a href=&quot;https://www.cnblogs.com/csu-lmw/p/11759527.html&quot; target=&quot;_blank&quot;&gt;上篇文章&lt;/a&gt;中，介绍了基本图形的绘制。这篇博客中将介绍模型的加载、绘制以及鼠标交互的实现。&lt;/p&gt;

&lt;h2&gt;模型存储&lt;/h2&gt;
&lt;p&gt;要实现模型的读取、绘制，我们首先需要知道模型是如何存储在文件中的。&lt;/p&gt;
&lt;p&gt;通常模型是由网格组成的，且一般为三角网格。原因为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;其它多边形网格可以容易地剖分为三角形&lt;/li&gt;
&lt;li&gt;三点共面：保证平面性&lt;/li&gt;
&lt;li&gt;可以容易地定义内外方向，进行插值等操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1413964/201912/1413964-20191214165259266-316242333.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可采用地数据结构包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;面列表
&lt;ul&gt;&lt;li&gt;存储面中顶点的三元组（v1, v2, v3）&lt;/li&gt;
&lt;li&gt;优点：方便而紧凑，可表达非流行网格&lt;/li&gt;
&lt;li&gt;缺点：不能有效地支持点、面之间的邻接关系查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;邻接矩阵
&lt;ul&gt;&lt;li&gt;优点：支持顶点之间的邻接信息(VV)的高效查询、支持非流行网格&lt;/li&gt;
&lt;li&gt;缺点：没有边的显示表达、不支持VF（vertex to face），VE(vertex to edge)，EV(edge to vertex)，FE(face to edge)，EF(edge to face)的快速查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;半边结构等
&lt;ul&gt;&lt;li&gt;纪律所有的面、边和顶点，包括几何信息、拓扑信息、附属属性，流行于大部分集合建模应用&lt;/li&gt;
&lt;li&gt;优点：所有查询操作时间复杂度均为o(1)，所有编辑操作时间复杂度均为o(1)&lt;/li&gt;
&lt;li&gt;缺点：只能表达流行网格&lt;/li&gt;
&lt;li&gt;常用半边结构实现：CGAL（&lt;a href=&quot;http://www.cgal.org/&quot;&gt;http://www.cgal.org/&lt;/a&gt;），Open Mesh（&lt;a href=&quot;http://www.openmesh.org/&quot;&gt;http://www.openmesh.org/&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这里，我使用的是面列表。&lt;/p&gt;
&lt;p&gt;先定义头文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef OBJ_CLASS
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; OBJ_CLASS&lt;span&gt;

#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cmath&amp;gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Vector3;
Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; + (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;const&lt;/span&gt; Vector3&amp;amp;&lt;span&gt; two);
Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; - (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;const&lt;/span&gt; Vector3&amp;amp;&lt;span&gt; two);
Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; * (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; scale);
Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; / (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; scale);
Vector3 Cross(Vector3&lt;/span&gt;&amp;amp; one, Vector3&amp;amp;&lt;span&gt; two);

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Vector3
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; fX;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; fY;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; fZ;
    Vector3(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;double&lt;/span&gt; y = &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;double&lt;/span&gt; z = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;) : fX(x), fY(y), fZ(z) {}
    Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; +=(&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; v) { &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt; = *&lt;span&gt;this&lt;/span&gt; +&lt;span&gt; v; }
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; Length() { &lt;span&gt;return&lt;/span&gt; sqrt(fX * fX + fY * fY + fZ *&lt;span&gt; fZ); }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Normalize()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归一化&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; fLen =&lt;span&gt; Length();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fLen == &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;)
            fLen &lt;/span&gt;= &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(fLen) &amp;gt; 1e-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
        {
            fX &lt;/span&gt;/=&lt;span&gt; fLen;
            fY &lt;/span&gt;/=&lt;span&gt; fLen;
            fZ &lt;/span&gt;/=&lt;span&gt; fLen;
        }
    }
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Point
{
    Vector3 pos;
    Vector3 normal;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Face
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pts[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
    Vector3 normal;
};

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CObj
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    CObj(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;~CObj(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

    std::vector&lt;/span&gt;&amp;lt;Point&amp;gt; m_pts; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点&lt;/span&gt;
    std::vector&amp;lt;Face&amp;gt; m_faces;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;面&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ReadObjFile(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* pcszFileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入模型文件&lt;/span&gt;

&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; UnifyModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位化模型&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; ComputeFaceNormal(Face&amp;amp; f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算面的法线&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是一些简单的运算符重载以及向量计算&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Obj.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sstream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;

&lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::min;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::max;

Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; + (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; two) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个向量相加&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Vector3(one.fX + two.fX, one.fY + two.fY, one.fZ +&lt;span&gt; two.fZ);
}

Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; - (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; two) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个向量相减&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Vector3(one.fX - two.fX, one.fY - two.fY, one.fZ -&lt;span&gt; two.fZ);
}

Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; * (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;double&lt;/span&gt; scale) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向量与数的乘操作&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Vector3(one.fX * scale, one.fY * scale, one.fZ *&lt;span&gt; scale);
}

Vector3 &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; / (&lt;span&gt;const&lt;/span&gt; Vector3&amp;amp; one, &lt;span&gt;double&lt;/span&gt; scale) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向量与数的除操作&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; one * (&lt;span&gt;1.0&lt;/span&gt; /&lt;span&gt; scale);
}

Vector3 Cross(Vector3&lt;/span&gt;&amp;amp; one, Vector3&amp;amp;&lt;span&gt; two) 
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算两个向量的叉积&lt;/span&gt;
&lt;span&gt;    Vector3 vCross;                                

    vCross.fX &lt;/span&gt;= ((one.fY * two.fZ) - (one.fZ *&lt;span&gt; two.fY));
    vCross.fY &lt;/span&gt;= ((one.fZ * two.fX) - (one.fX *&lt;span&gt; two.fZ));
    vCross.fZ &lt;/span&gt;= ((one.fX * two.fY) - (one.fY *&lt;span&gt; two.fX));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vCross;        
}

CObj::CObj(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
}


CObj::&lt;/span&gt;~CObj(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面来讲讲模型的读取等操作&lt;/p&gt;
&lt;h2&gt;模型读取&lt;/h2&gt;
&lt;p&gt;一般在模型存储文件中会有这么几个标识符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v 表示顶点位置&lt;/li&gt;
&lt;li&gt;vt 表示顶点纹理坐标&lt;/li&gt;
&lt;li&gt;vn 表示顶点法向量&lt;/li&gt;
&lt;li&gt;f 表示一个面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;打开一看，大概是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1413964/201912/1413964-20191214234032859-1189815134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 那么，就可以开始考虑如何读取并将数据存储到列表里面了，读文件还是简单的，fopen(), fgets(), feof()，剩下关键便是将字符串转成数字，c++中还是有现成的函数可以调用的，sstream头文件中的istringstream。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; CObj::ReadObjFile(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pcszFileName) 
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取模型文件&lt;/span&gt;
&lt;span&gt;
    FILE&lt;/span&gt;* fpFile = fopen(pcszFileName, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只读方式打开文件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (fpFile ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    m_pts.clear(); 
    m_faces.clear();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO：将模型文件中的点和面数据分别存入m_pts和m_faces中&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; strLine[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
    Point point;
    Face face;
    std::&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s1;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;feof(fpFile))
    {
        fgets(strLine, &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;, fpFile);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strLine[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strLine[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vn 我使用的文件中没有vn的数据，就没有实现&lt;/span&gt;
&lt;span&gt;                
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;v 点&lt;/span&gt;
&lt;span&gt;                std::istringstream sin(strLine);
                sin &lt;/span&gt;&amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; point.pos.fX &amp;gt;&amp;gt; point.pos.fY &amp;gt;&amp;gt;&lt;span&gt; point.pos.fZ;
                m_pts.push_back(point);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (strLine[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 面&lt;/span&gt;
&lt;span&gt;            std::istringstream sin(strLine);
            sin &lt;/span&gt;&amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; face.pts[&lt;span&gt;0&lt;/span&gt;] &amp;gt;&amp;gt; face.pts[&lt;span&gt;1&lt;/span&gt;] &amp;gt;&amp;gt; face.pts[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
            ComputeFaceNormal(face);
            m_faces.push_back(face);
        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strLine);
    }

    fclose(fpFile);

    UnifyModel(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将模型归一化&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上一篇文章绘制圆环和圆柱，知道了法向量是十分重要的，因此计算每个面的法向量也是不可少的&lt;/p&gt;
&lt;p&gt;原理很简单，叉乘即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; CObj::ComputeFaceNormal(Face&amp;amp;&lt;span&gt; f)
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:计算面f的法向量，并保存&lt;/span&gt;
    f.normal = Cross(m_pts[f.pts[&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;].pos - m_pts[f.pts[&lt;span&gt;0&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;].pos, m_pts[f.pts[&lt;span&gt;2&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;].pos - m_pts[f.pts[&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].pos);
    f.normal.Normalize();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于模型归一化，为何要归一化呢？想象一下，你拿手机拍照，如果拍照对象离摄像头很近，那在手机中展示出来的图像会是什么样？但是如果能不在移动相机和对象之间的距离的情况下该怎么做？把对象等比压缩！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CObj::UnifyModel()
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为统一显示不同尺寸的模型，将模型归一化，将模型尺寸缩放到0.0-1.0之间
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原理：找出模型的边界最大和最小值，进而找出模型的中心
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以模型的中心点为基准对模型顶点进行缩放
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:添加模型归一化代码&lt;/span&gt;
&lt;span&gt;
    Vector3 vec_max, vec_min(1e5, 1e5, 1e5), vec;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m_pts.size(); i++&lt;span&gt;)
    {
        vec_max.fX &lt;/span&gt;=&lt;span&gt; std::max(vec_max.fX, m_pts[i].pos.fX);
        vec_max.fY &lt;/span&gt;=&lt;span&gt; std::max(vec_max.fY, m_pts[i].pos.fY);
        vec_max.fZ &lt;/span&gt;=&lt;span&gt; std::max(vec_max.fZ, m_pts[i].pos.fZ);

        vec_min.fX &lt;/span&gt;=&lt;span&gt; std::min(vec_min.fX, m_pts[i].pos.fX);
        vec_min.fY &lt;/span&gt;=&lt;span&gt; std::min(vec_min.fY, m_pts[i].pos.fY);
        vec_min.fZ &lt;/span&gt;=&lt;span&gt; std::min(vec_min.fZ, m_pts[i].pos.fZ);
    }

    vec.fX &lt;/span&gt;= vec_max.fX -&lt;span&gt; vec_min.fX;
    vec.fY &lt;/span&gt;= vec_max.fY -&lt;span&gt; vec_min.fY;
    vec.fZ &lt;/span&gt;= vec_max.fZ -&lt;span&gt; vec_min.fZ;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m_pts.size(); i++&lt;span&gt;)
    {
        m_pts[i].normal &lt;/span&gt;=&lt;span&gt; m_pts[i].pos;
        m_pts[i].normal.fX &lt;/span&gt;= (m_pts[i].normal.fX - vec_min.fX) / vec.fX - &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
        m_pts[i].normal.fY &lt;/span&gt;= (m_pts[i].normal.fY - vec_min.fY) / vec.fY - &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
        m_pts[i].normal.fZ &lt;/span&gt;= (m_pts[i].normal.fZ - vec_min.fZ) / vec.fZ - &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;m_pts.push_back(vec);&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;模型绘制&lt;/h2&gt;
&lt;p&gt;对于模型的绘制，实现起来十分容易，因为有了各个面片的信息了。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; DrawModel(CObj &amp;amp;&lt;span&gt;model)
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: 绘制模型&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; model.m_faces.size(); i++&lt;span&gt;)
    {
        glBegin(GL_TRIANGLES);
        glNormal3f(model.m_faces[i].normal.fX, model.m_faces[i].normal.fY, model.m_faces[i].normal.fZ);
        glVertex3f(model.m_pts[model.m_faces[i].pts[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fX, model.m_pts[model.m_faces[i].pts[&lt;span&gt;0&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fY, model.m_pts[model.m_faces[i].pts[&lt;span&gt;0&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].normal.fZ);
        glVertex3f(model.m_pts[model.m_faces[i].pts[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fX, model.m_pts[model.m_faces[i].pts[&lt;span&gt;1&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fY, model.m_pts[model.m_faces[i].pts[&lt;span&gt;1&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].normal.fZ);
        glVertex3f(model.m_pts[model.m_faces[i].pts[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fX, model.m_pts[model.m_faces[i].pts[&lt;span&gt;2&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;].normal.fY, model.m_pts[model.m_faces[i].pts[&lt;span&gt;2&lt;/span&gt;] - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].normal.fZ);
        glEnd();
    }

}


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (g_draw_content ==&lt;span&gt; SHAPE_MODEL)
    {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制模型&lt;/span&gt;
&lt;span&gt;        glTranslatef(g_x_offset, g_y_offset, g_z_offset);
        glRotatef(g_rquad_x, &lt;/span&gt;&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;);
        glRotatef(g_rquad_y, &lt;/span&gt;&lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;);
        glScalef(g_scale_size, g_scale_size, g_scale_size);
        DrawModel(g_obj);
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行，加载模型！&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1413964/201912/1413964-20191215000113222-1984917541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，好的，它成功出来了。&lt;/p&gt;
&lt;p&gt;等等！为啥是头对着我的，我怎么调整角度？看起来有点小，我能不能把它放大点？&lt;/p&gt;
&lt;p&gt;下面，将介绍鼠标交互的实现。&lt;/p&gt;

&lt;p&gt;opengl中的鼠标交互还是比较好做的，首先需要的是在初始化的时候注册鼠标输出实现回调函数和鼠标移动事件的回调函数。这些在上篇文章中给的框架代码里都实现了。那剩下的就是如何实现旋转、缩放和拖动了&lt;/p&gt;
&lt;h2&gt;旋转&lt;/h2&gt;
&lt;p&gt;首先我们要注意的是，在给出的代码框架里，摄像机的lookat是这样的&lt;/p&gt;
&lt;p&gt;gluLookAt(0.0, 0.0, 8.0, 0, 0, 0, 0, 1.0, 0);&lt;/p&gt;
&lt;p&gt;该函数定义一个视图矩阵，并与当前矩阵相乘.&lt;br/&gt;第一组eyex, eyey,eyez 相机在世界坐标的位置;第二组centerx,centery,centerz 相机镜头对准的物体在世界坐标的位置;第三组upx,upy,upz 相机向上的方向在世界坐标中的方向。&lt;/p&gt;
&lt;p&gt;所以，这里摄像机是从z轴看下去的，那么初始看到的二维平面分为为x轴和y轴。理解了这个，旋转就很简单了。水平拖动的时候让模型绕y轴转，竖直拖动的时候让模型绕x轴转。按下左键旋转。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (g_xform_mode == TRANSFORM_ROTATE) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转&lt;/span&gt;
    {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:添加鼠标移动控制模型旋转参数的代码&lt;/span&gt;
        g_rquad_x += (x - g_press_x) * &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
        g_rquad_y &lt;/span&gt;+= (y - g_press_y) * &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
        g_press_x &lt;/span&gt;=&lt;span&gt; x;
        g_press_y &lt;/span&gt;=&lt;span&gt; y;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 平移&lt;/h2&gt;
&lt;p&gt;平移的实现十分简单，计算鼠标移动的距离即可，按下右键拖动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(g_xform_mode == TRANSFORM_TRANSLATE) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平移&lt;/span&gt;
    {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:添加鼠标移动控制模型平移参数的代码&lt;/span&gt;
        g_x_offset += (x - g_press_x) * &lt;span&gt;0.002f&lt;/span&gt;&lt;span&gt;;
        g_y_offset &lt;/span&gt;+= -(y - g_press_y) * &lt;span&gt;0.002f&lt;/span&gt;&lt;span&gt;;
        g_press_x &lt;/span&gt;=&lt;span&gt; x;
        g_press_y &lt;/span&gt;=&lt;span&gt; y;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;缩放&lt;/h2&gt;
&lt;p&gt;缩放与平移相似，按下滚轮键滑动鼠标&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(g_xform_mode == TRANSFORM_SCALE) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩放&lt;/span&gt;
    {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:添加鼠标移动控制模型缩放参数的代码&lt;/span&gt;
        g_scale_size += (x - g_press_x) * &lt;span&gt;0.01f&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，我们的鼠标交互也实现完了，下面就来试试效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1413964/201912/1413964-20191215002009899-1063353433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这样，模型的加载及鼠标交互也就介绍完了，但是是不是还缺些什么？好像这个模型跟想象当中的还是有很大区别的，表面的图案呢？？下一篇将介绍纹理贴图和曲线绘制。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 16:29:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 在上篇文章中，介绍了基本图形的绘制。这篇博客中将介绍模型的加载、绘制以及鼠标交互的实现。 模型加载 模型存储 要实现模型的读取、绘制，我们首先需要知道模型是如何存储在文件中的。 通常模型是由网格</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/12006050.html</dc:identifier>
</item>
<item>
<title>Java继承之再谈构造器 - sumerday</title>
<link>http://www.cnblogs.com/summerday152/p/12041632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12041632.html</guid>
<description>&lt;h2 id=&quot;初始化基类&quot;&gt;初始化基类&lt;/h2&gt;
&lt;p&gt;前面提到，继承是子类对父类的拓展。《Thinking in Java》中提到下面一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当创建一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类的对象内部。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在创建子类对象时，调用了父类的构造器，甚至父类的父类构造器。我们知道，构造器用于创建对象，那么突然产生疑惑：&lt;u&gt;关于创建一个子类对象时，是否会先创建父类对象？&lt;/u&gt;&lt;br/&gt;&lt;strong&gt;经过查找资料，得出结论&lt;/strong&gt;：&lt;br/&gt;&lt;strong&gt;并没有&lt;/strong&gt;。在创建子类对象时，会把父类的成员变量和方法加载进内存，既然要加载，便调用父类构造器看看这些数据是如何进行初始化的，仅此而已，并不是创建了父类的对象。&lt;br/&gt;所以，可以看作，子类对象中包含着父类的子对象。我们知道，对象的初始化是至关重要的。那么，这个父类的子对象如何正确初始化呢？对了，就是接下来要说的：&lt;strong&gt;在构造器中调用基类构造器来执行初始化&lt;/strong&gt;。&lt;br/&gt;&lt;u&gt;注意：子类并不能继承父类的构造器，只是单纯调用了基类构造器中的初始化代码。&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&quot;默认构造器&quot;&gt;默认构造器&lt;/h2&gt;
&lt;p&gt;先看一段简单的测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.my.pac13;
/*继承中的构造*/
public class Person {
    Person(){
        System.out.println(&quot;Person()&quot;);
    }
}
class Student extends Person{
    Student(){
        System.out.println(&quot;Student()&quot;);
    }
}
class PrimaryStudent extends Student{
    PrimaryStudent(){
        //super();
        System.out.println(&quot;PrimaryStudent()&quot;);
    }
    public static void main(String[] args) {
        //创建了PrimaryStudent对象
        new PrimaryStudent();
    }
}
/*
 Person()
 Student()
 PrimaryStudent()
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于构造器，我们前面提到，任何没有显式构造器的类都存在着一个无参数的默认构造器。我们上面的例子在默认构造器中加入了打印输出，以便理解。&lt;br/&gt;可以看到的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在创建&lt;code&gt;PrimaryStudent&lt;/code&gt;时，他的直接父类&lt;code&gt;Student&lt;/code&gt;和间接父类&lt;code&gt;Person&lt;/code&gt;中的构造器都被调用了，而且可以看到，是&quot;&lt;strong&gt;自上而下&lt;/strong&gt;&quot;的。&lt;/li&gt;
&lt;li&gt;父类在子类构造器可以访问它之前，就已经完成了初始化的操作。&lt;/li&gt;
&lt;li&gt;若子类没有显式调用父类的构造器，则自动调用父类的默认（无参）构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;带参数的构造器&quot;&gt;带参数的构造器&lt;/h2&gt;
&lt;p&gt;前面的代码中，每个类都含有默认的构造器，创建子类对象时，是自上而下，且子类会默认调用父类的无参构造器。那么，假设父类正好没有无参构造器或者你正想调用父类的带参构造器，这时就需要我们的&lt;strong&gt;super&lt;/strong&gt;关键字。（super关键字之后还会进行总结）&lt;br/&gt;我们直接在原来的基础上稍作修改，并进行测试。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.my.pac13;
/*调用基类构造器是子类构造器中要做的第一件事*/
public class Person {
    //没有默认构造器
    Person(String name){
        System.out.println(&quot;Person()\t&quot;+name);
    }
}
class Student extends Person{
    //也没有默认构造器，且用super显式调用
    Student(String n){
    //super关键字调用父类的构造器
        super(n);
        System.out.println(&quot;一参数Student\t&quot;+n);
    }
    Student(String n,String m){
    //this关键字调用同一类中重载的构造器
        this(n);
        System.out.println(&quot;二参数student()\t&quot;+m);
    }
}
class PrimaryStudent extends Student{
    //隐式调用父类构无参数构造器,但是父类没有，所以要用super显式调用
    PrimaryStudent(){
    //没有下面的语句会报错
        super(&quot;hello&quot;);
        System.out.println(&quot;PrimaryStudent（）&quot;);
    }

}
class ExtendsTest{
    public static void main(String[] args) {
        new Person(&quot;the shy&quot;);
        System.out.println(&quot;***********&quot;);
        new Student(&quot;rookie&quot;);
        System.out.println(&quot;***********&quot;);
        new Student(&quot;the shy&quot;,&quot;rookie&quot;);
        System.out.println(&quot;***********&quot;);
        new PrimaryStudent();
        System.out.println(&quot;***********&quot;);
    }

}
/*
Person()    the shy
***********
Person()    rookie
一参数Student  rookie
***********
Person()    the shy
一参数Student  the shy
二参数student()    rookie
***********
Person()    hello
一参数Student  hello
PrimaryStudent（）
***********
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;this是正在创建的对象，用于&lt;strong&gt;调用同一类中重载的构造器&lt;/strong&gt;，可以参看我之前的文章：&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/12005295.html&quot;&gt;Java关键字之this&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;super在调用构造器时，使用方法和this相似。（但super和this本身有本质的不同，&lt;strong&gt;super并不是一个对象的引用&lt;/strong&gt;！！！）&lt;/li&gt;
&lt;li&gt;super和this语句都必须出现在第一行，也就是说一个构造器中&lt;strong&gt;只能有其中之一&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;子类调用父类构造器&quot;&gt;子类调用父类构造器&lt;/h2&gt;
&lt;p&gt;无论是否使用super语句来调用父类构造器的初始化代码，&lt;strong&gt;子类构造器总是会事先调用父类构造器&lt;/strong&gt;！这是一定要记住的！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类构造器A在第一行显式使用super调用父类构造器B，格式&lt;code&gt;super(参数列表)&lt;/code&gt;,根据参数列表选择对应的父类构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//父类
 Person(String name){
        System.out.println(&quot;Person()\t&quot;+name);
    }
//子类
 Student(String n){
    //super关键字调用父类的构造器
        super(n);
        System.out.println(&quot;一参数Student\t&quot;+n);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;子类构造器A先用this调用本类重载的构造器B，然后B调用父类构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//父类
 Person(String name){
        System.out.println(&quot;Person()\t&quot;+name);
    }
//子类
Student(String n){
    //super关键字调用父类的构造器
        super(n);
        System.out.println(&quot;一参数Student\t&quot;+n);
    }
Student(String n,String m){
//this关键字调用同一类中重载的构造器
    this(n);
    System.out.println(&quot;二参数student()\t&quot;+m);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;子类构造器中没有super和this时，系统会隐式调用父类的无参构造器，要是没有无参的，那就报错。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//隐式调用父类构无参数构造器,但是父类没有，所以要用super显式调用
PrimaryStudent(){
//没有下面的语句会报错
    super(&quot;hello&quot;);
    System.out.println(&quot;PrimaryStudent（）&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;当调用子类构造器对子类对象进行初始化时，&lt;strong&gt;父类构造器总会在子类构造器之前执行&lt;/strong&gt;。甚至，父类的父类会在父类之前执行……一直追溯到所有类的超类Object类的构造器。&lt;/p&gt;
&lt;p&gt;参考书籍：《Thinking in Java》、《疯狂Java讲义》、《Java核心技术卷I》&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 16:10:00 +0000</pubDate>
<dc:creator>sumerday</dc:creator>
<og:description>[toc] Java继承之再谈构造器 初始化基类 前面提到，继承是子类对父类的拓展。《Thinking in Java》中提到下面一段话： 当创建一个导出类的对象时，该对象包含了一个基类的子对象。这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12041632.html</dc:identifier>
</item>
<item>
<title>故事2：本人经历 - 时代乐府</title>
<link>http://www.cnblogs.com/wenghan/p/12041607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenghan/p/12041607.html</guid>
<description>&lt;p&gt;            啊，最近一段时间在学习asp.net mvc ，一直没有接着写了，加上白天工作很忙，每天都很辛苦的哈，那咱接着说上一个故事哈。&lt;/p&gt;
&lt;p&gt;            当时第二天开始复习java面试题，非常的期待，从来没有去过公司，不知道别人公司是怎么样的，因为是实习，总是觉得别人公司的面试不会特别难，当时就业老师第一次给我们介绍了一家公司，在上海的一个创业基地，是的，这是一个&lt;/p&gt;
&lt;p&gt;创业公司，当时我们有5个人去面试，面试的岗位都是Java开发工程师，当时去了，老板和技术老大都非常的热情，因为很热，当时给我们一人来了一杯罐装冰镇雪碧，真的是非常不错的人啊。我们都拿着自己的简历，然后一个一个面试，当时我&lt;/p&gt;
&lt;p&gt;们坐在大会议室，但是面试是在小会议室，当时我们确实有些紧张，毕竟大家都是第一次去公司面试，然后开始一个一个去，基本问的问题，都是差不多的，问的Java的一些基础问题和spring 和spring mvc框架的一些概念性的问题，当时我在学校&lt;/p&gt;
&lt;p&gt;背的滚瓜烂熟了，所以当时面试还不错，我们五个人面试完，感觉被面试上的概率非常大，但是我是最后一个面试的，当时面试官说，我前面有两个加上我，我们三个人技术都很不错，但是他们公司只需要两个人，让我们先自己考虑一下，然后给&lt;/p&gt;
&lt;p&gt;他们打电话哪两个人过去，当时面试完走在回去的路上，然后心里就很纠结，如果我打电话过去，那我前面两个人不就有一个没有工作了啊，心里很纠结，一直到回求职公寓，我都没有给那个公司打电话，后来就业老师马上过来找我，问我为什么&lt;/p&gt;
&lt;p&gt;没有打电话过去，当时和就业老师上了一下情况，很无奈，被就业老师骂了一顿，说别人这个只是为了考验我们，就是那种想去公司实习的一个欲望吧，反正就是一种考验吧，然后说我怎么这么傻，如果我打电话去，我们三个人都会被录用，那个&lt;/p&gt;
&lt;p&gt;公司的老板打电话给我们就业老师，说我们三个人的面试都很不错，让我们就业老师和我们沟通一下，但是还是只能去两个，就这样，我后来还是没有打电话过去，当时真的很后悔，性格可能就是特别老实吧，刚出来，很多地方都很拘谨，不敢太&lt;/p&gt;
&lt;p&gt;主动，哈哈，当时真的是很后悔的啊。但是错过了，就真的错过了啊，不过第一次面试，能得到面试官的肯定，已经很满意了，这也给我后面去面试，多多少少给了一些信心吧。然而万万没想到的是，我面试的第一家公司居然是我遇到的最后一个&lt;/p&gt;
&lt;p&gt;能给我一个实习的公司，啊，真的是没想到啊，因为在第一个星期内，就这一家公司，是真正说想招实习生的，其他的公司，要么就不招人，要么就不是招Java的，当时心里还在回想着我第一家面试的那家公司，一直心里在叹气，心里很急，因为&lt;/p&gt;
&lt;p&gt;很多同学都已经找到工作了，然后都搬离求职公寓了，当时心里就想快点找到工作，奈何现实无奈啊，但是依然不相信，难道真的没有公司招java吗？难道公司都是技术大牛吗？难道就不需要培养新人吗？我就不信这个鞋了，然后第二个星期开始了，&lt;/p&gt;
&lt;p&gt;还是有很多小伙伴没有找到工作，正好，当时上海有一个招聘会，我们的机会（噩梦）来了，当时在就业老师的统一部署之下，大家穿着西装，打着领带，手里拿个简历袋，在就业老师规定的时间内到达招聘会现场。真的，人特别多，还都是穿着西&lt;/p&gt;
&lt;p&gt;装，后来一问，都是从学校刚刚出来的，原来都是同志啊，当时上午去了，把每个公司，不管是外包还是互联网公司，每个面试公司都投了一份简历，然后有一个公司，排一长排人，简历一给别人，别人给一份面试题到专门的会议室做，当时看到别&lt;/p&gt;
&lt;p&gt;人简历看都不看，直接扔旁边的桌子上，有一个还掉地上了，都没有时间捡，我真的很想问，就算我把面试题做完了，我给他了，也没有用啊，搞不好连你的简历都找不到，然而，我还是专门的会议室做面试题了，不进去不知道，一进去才知道，大&lt;/p&gt;
&lt;p&gt;家这些年考试学的技术，都没有白费啊，手机百度的速度，精准度，一个比一个狠啊（俗称作弊），我还想好好的做一下，就没有查手机，当我花了半个小时做了以后，我就在想，别人连简历都没有整理好，这面试题别人收了，也不一定会看啊，再&lt;/p&gt;
&lt;p&gt;说大家都是抄网上的，答案搞不好都是一样的，但是我还是把面试题给了当时给我面试题的面试官，谁知道，别人接过去一把扔桌上了，压根没有时间理我，哎，后来看到那个面试官，接了别人的简历就把前面人的简历压下去了，然后其他的公司要&lt;/p&gt;
&lt;p&gt;么就收了简历就收回去等消息，要么就是会给简历上的邮箱发一份电子面试题，做完再发送回去，啊，以为会找到工作，谁知道还是竹篮打水一场空啊，虽然我连竹篮都没有，就这样，第二个星期还是浪费了，还是没有找到工作，心里越来越着急了，&lt;/p&gt;
&lt;p&gt;毕竟小伙伴越来越少了，很多人都找到工作了，真的好绝望啊，那个时候还在想我第一次面试的公司，心里还是在怪自己，那么很多人可能会想，才两个星期而已，其实时间是一个，更重要的是，没有钱了，我们大部分人家里都只给了3000左右，当&lt;/p&gt;
&lt;p&gt;时交了房租750元，然后又是充地铁卡，吃饭啊，简历打印啊各方面的钱，真的，当时没有多少钱了，然后第二个星期的双休日，没有面试，在求职公寓休息，正好那个时候在下雨，望着窗外的雨，心情不是很好，幸好当时有一个哥们，同校通信班的&lt;/p&gt;
&lt;p&gt;一个同学（叫他A吧），心态非常好，很开朗，每天都过来陪我们聊天，虽然A同学也没有找到，但是A同学心态很好，当时其实还是蛮开心的，陪着我一起看面试题，一起听歌，那个时候就业老师说简历需要再好好的改改，A同学反正也没事，就帮我&lt;/p&gt;
&lt;p&gt;看我的简历，确实给了一些好的建议，还帮我改简历，很谢谢A同学，在我最无助的时候陪着我，身边总有一些好兄弟陪着，虽然没有女朋友，但是身边总有一些好兄弟陪着。当时改简历的时候还互相吐槽，不过真的很开心当时，就是那种苦中作乐吧，&lt;/p&gt;
&lt;p&gt;其实当时在求职公寓还遇到了一些算是短暂的友情吧，认识了几个同校的好兄弟吧，虽然现在已经没有在一起了，哈，今天就写到这了，明天接着写第三篇吧，晚安了各位.....&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 15:55:00 +0000</pubDate>
<dc:creator>时代乐府</dc:creator>
<og:description>啊，最近一段时间在学习asp.net mvc ，一直没有接着写了，加上白天工作很忙，每天都很辛苦的哈，那咱接着说上一个故事哈。 当时第二天开始复习java面试题，非常的期待，从来没有去过公司，不知道别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wenghan/p/12041607.html</dc:identifier>
</item>
<item>
<title>自然语言处理(NLP) - 数学基础(1) - 排列组合 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/NLP-Math-2-permutation-and-combination.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/NLP-Math-2-permutation-and-combination.html</guid>
<description>&lt;p&gt;正如我在&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/NLP-Math-1-summary.html#4456597&quot;&gt;自然语言处理(NLP) - 数学基础(1) - 总述&lt;/a&gt;&amp;gt;一文中所提到的NLP所关联的概率论(Probability Theory)知识点是如此的多, 饭只能一口一口地吃了, 我们先开始最为大家熟知和最基础的知识点吧, 排列组合.&lt;/p&gt;

&lt;p&gt;虽然排列组合这个知识点大家是相当地熟知, 也是相当地基础, 但是却是十分十分十分地重要.&lt;/p&gt;
&lt;p&gt;NLP届掌门人斯坦福大学的Daniel Jurafsky（D. 朱夫斯凯）和科罗拉多大学James H. Martin（J. H. 马丁）在其NLP巨作《&lt;strong&gt;自然语言处理综论&lt;/strong&gt;》一书第二版第5页中提到：“几乎所有的语音处理和语言处理问题都可以这样来表述: 对于某个歧义的输入给出N个可能性, 选择其中概率最高的一个.”&lt;/p&gt;
&lt;p&gt;现在让我们来看看排列组合概念的定义吧: 所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序。所谓组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。&lt;/p&gt;
&lt;p&gt;See, 与掌门人上面这句话相比, 是如此的相似!&lt;/p&gt;

&lt;p&gt;排列组合有两条基本原理组成:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加法原理（分类计数法）- 做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有m2种不同的方法，……，在第n类办法中有mn种不同的方法，那么完成这件事共有N=m1+m2+m3+…+mn种不同方法。每一种方法都能够直接达成目标。&lt;/li&gt;
&lt;li&gt;乘法原理（分步计数法）. 做一件事，完成它需要分成n个步骤，做第一步有m1种不同的方法，做第二步有m2种不同的方法，……，做第n步有mn种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn种不同的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如何区分这两个原理呢? &lt;/p&gt;
&lt;p&gt;要做一件事，完成它若是有n类办法，是分类问题，第一类中的方法都是独立的，则使用加法原理；做一件事，需要分n个步骤，步与步之间是连续的，只有将分成的若干个互相联系的步骤，依次相继完成，这件事才算完成，则使用乘法原理。&lt;/p&gt;
&lt;p&gt;完成一件事的分“类”和“步”是有本质区别的，因此也就将两个原理区分开来了。&lt;/p&gt;

&lt;p&gt;根据以上原理衍生出很多方法, 包括且不限于:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%8F%92%E7%A9%BA%E6%B3%95/4862293&quot;&gt;捆绑法.&lt;/a&gt; 指在解决对于某几个元素要求相邻问题时，先整体考虑，将相邻元素视作一个整体参与排序，然后再单独考虑这个整体内部各元素间顺序。注意：其首要特点是相邻，其次捆绑法一般都应用在不同物体的排序问题中。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%8F%92%E7%A9%BA%E6%B3%95/4862293&quot;&gt;插空法&lt;/a&gt;. 某些元素不相邻的排列组合问题，即不邻问题，可采用插空法，即在解决对于某几个元素要求不相邻的问题时，先将其它元素排好，再将指定的不相邻的元素插入已排好元素的间隙或两端位置，从而将问题解决的策略。用这种方法解题思路清晰、简便易懂。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.baike.com/wiki/%E6%8F%92%E6%9D%BF%E6%B3%95&quot;&gt;插板法&lt;/a&gt;. 指在解决若干相同元素分组，要求每组至少有一个元素，采用将比所需分组数目少1的板插入元素之间形成分组的解题策略。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为本节是第一节, 所以在做习题和代码示例之前, 我们需要去安装&lt;a href=&quot;https://www.python.org/downloads/release/python-352/&quot;&gt;Python&lt;/a&gt; 3和对应的开发工具&lt;a href=&quot;https://code.visualstudio.com/docs/setup/setup-overview&quot;&gt;Visual Studio Code&lt;/a&gt;, 同时建议先照着&lt;a href=&quot;https://code.visualstudio.com/docs/python/python-tutorial&quot;&gt;Getting Started with Python in VS Code&lt;/a&gt;过一遍. (预计耗时要1-3个小时,包括update Xcode, 要注意安排好时间).&lt;/p&gt;
&lt;p&gt;如果是时间赶, 可以使用python online editor去做. &lt;a href=&quot;https://www.tutorialspoint.com/python/index.htm&quot;&gt;https://www.tutorialspoint.com/python/index.htm&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;从学术和参加算法比赛的角度来讲, 我们应该尽量不要用任何库. 然而现在我是从工程的角度出发, 所以我会使用到大名鼎鼎的NLP工具包NLTK以及Python里的数学库&lt;a href=&quot;https://scipy.org/getting-started.html&quot;&gt;Scipy&lt;/a&gt; 和 itertools (虽然本节不会用全三个库, 但是以后的章节会全用到的)&lt;/p&gt;
&lt;p&gt;这点和前文所讲的&quot;AI并不只是调现有云和库API即可&quot;并不冲突, 因为:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;现有云和库API是由各自的厂商和开发者写的, 会有各种差异. 而数学库却是不会有差异的, 用A厂商写出的库去算1+2会等于3, 换了B厂商写出的库去算1+2一样会等于3.&lt;/li&gt;
&lt;li&gt;从下面的习题答案和对应的代码示例看到, 正确的解题思路才是关键, 解题思路对了接下来的求解就可以扔给Python对应的方法了. 然而解题思路却是要穿透现有云和AI库API的.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在开始写代码做习题之前我们先按照如下链接去热身和确认环境是好的:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41185868/article/details/79682406&quot;&gt;https://blog.csdn.net/qq_41185868/article/details/79682406&lt;/a&gt; 安装Python的Scipy包&lt;/p&gt;
&lt;p&gt;如果遇到ssl证书问题则参考这篇文章去解决&lt;a href=&quot;https://www.cnblogs.com/jiyanjiao-702521/p/9960071.html&quot;&gt;https://www.cnblogs.com/jiyanjiao-702521/p/9960071.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如果还是遇到错误, 那就去按照&lt;a href=&quot;https://www.jianshu.com/p/dbf20c6792fe&quot;&gt;https://www.jianshu.com/p/dbf20c6792fe&lt;/a&gt; 这篇文章一劳永逸的解决问题, 不过需要下载Anaconda, 大概要五六百M, 记得是要用bash安装. 安装完之后就可以sudo conda install scipy了, 然后再用Anaconda navigator去lanunch VS Code.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/permutation-and-combination-in-python/&quot;&gt;https://www.geeksforgeeks.org/permutation-and-combination-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.perm.html&quot;&gt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.perm.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html&quot;&gt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nltk.org/api/nltk.html#nltk.probability.ConditionalFreqDist&quot;&gt;https://www.nltk.org/api/nltk.html#nltk.probability.ConditionalFreqDist&lt;/a&gt; 里的nltk.util.&lt;strong&gt;choose&lt;/strong&gt;(&lt;em&gt;n&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;) (本节不会用到, 以后章节会)&lt;/p&gt;

&lt;p&gt;然后开始做题&lt;/p&gt;
&lt;p&gt;捆绑法&lt;/p&gt;
&lt;p&gt;题目: 六个元素进行排列, 其中指定的两个元素必须要排在一起, 总共有多少种排法?&lt;/p&gt;
&lt;p&gt;答案: 这指定的两个元素需要捆绑成一个元素进行排列, 然后这捆绑在一起的元素内部在进行排列. 最后使用分步计数法(即乘法原理)进行相乘. 所以应该是n5.5  X  n2.2 = 240种&lt;/p&gt;
&lt;p&gt;代码实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scipy.special import perm
result =  perm(5, 5, exact=True) * perm(2,2, exact=True)
print(result)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;插空法&lt;/p&gt;
&lt;p&gt;题目: 对6个A元素和4个B元素进行排列, 任意两个B元素不得相邻, 总共有多少种排法?&lt;/p&gt;
&lt;p&gt;答案: 因为B元素不得相邻, 则需要使用插空法, 先排6个A元素A6,6 , 在6+1个空位置中再对4个B元素进行排列 a 4 7, 最后使用分步计数法(即乘法原理)进行相乘得出为604800种&lt;/p&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scipy.special import perm
result = perm(6, 6, exact=True) * perm(7,4, exact=True)
print(result)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;插板法&lt;/p&gt;
&lt;p&gt;题目:将8个完全相同的元素分成3组, 每组至少要有一个元素, 总共有多少排法?&lt;/p&gt;
&lt;p&gt;答案: 首先因为元素是完全相同的, 所以不需要排列, 因此这是个组合问题. 然后使用插板法, 将n个相同元素分成m组, 且每组必须有元素就相当于在n-1个空中插m-1个板, C2,7 共21种 (不是42种是因为是求解组合而不是排列)&lt;/p&gt;
&lt;p&gt;代码实现&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scipy.special import comb
result =  comb(7, 2, exact=True)
print(result)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果时间紧急没有办法装Python环境这怎么办? &lt;/p&gt;
&lt;p&gt;So easy, 使用&lt;a href=&quot;https://www.calculator.net/permutation-and-combination-calculator.html&quot;&gt;https://www.calculator.net/permutation-and-combination-calculator.html&lt;/a&gt; 进行在线求解就行了,.&lt;/p&gt;
&lt;p&gt;或者使用手机或者iPad下载microsoft math resolver去求解即可. &lt;/p&gt;
&lt;p&gt;以上两个事实再次证明了, 正确的解题思路才是关键, 只要解题思路正确了, 后面的求解过程是很方便很easy的. 这点不就是我在&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/12020575.html&quot;&gt;2019年总结&lt;/a&gt;&amp;gt;一文中所说到的”做正确的事情, 然后正确的做事, 比勤劳更重要”的体现吗?&lt;/p&gt;
&lt;p&gt;不过再次提醒学术和要面试的同学们, 不要学我把求解过程扔给计算机, 这样会让你面试挂的. 我是从纯工程角度出发的.&lt;/p&gt;

&lt;p&gt;有用链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://betterexplained.com/articles/easy-permutations-and-combinations/&quot;&gt;https://betterexplained.com/articles/easy-permutations-and-combinations/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.csharp-console-examples.com/loop/foreach-statement/permutation-and-combination-calculator-in-c/&quot;&gt;https://www.csharp-console-examples.com/loop/foreach-statement/permutation-and-combination-calculator-in-c/&lt;/a&gt; 这是一个C#的排列组合的简单示例, &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.beatthegmat.com/mba/2009/10/12/permutations-and-combinations-an-easy-method&quot;&gt;https://www.beatthegmat.com/mba/2009/10/12/permutations-and-combinations-an-easy-method&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://study.com/academy/lesson/permutation-combination-problems-practice.html&quot;&gt;https://study.com/academy/lesson/permutation-combination-problems-practice.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mathplanet.com/education/pre-algebra/probability-and-statistic/combinations-and-permutations&quot;&gt;https://www.mathplanet.com/education/pre-algebra/probability-and-statistic/combinations-and-permutations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.wikihow.com/Calculate-Combinations&quot;&gt;https://www.wikihow.com/Calculate-Combinations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mathsisfun.com/combinatorics/combinations-permutations.html&quot;&gt;https://www.mathsisfun.com/combinatorics/combinations-permutations.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了方便搜索资料, 现在列出本节所用到的英文术语名词:&lt;/p&gt;
&lt;p&gt;概率论 - Probability Theory&lt;/p&gt;
&lt;p&gt;排列组合 - permutation and combination&lt;/p&gt;
&lt;p&gt;加法原理（分类计数法）- Addition rule 或者Addition theorem 或者Addition Principle&lt;/p&gt;
&lt;p&gt;乘法原理（分步计数法）- Multiplication rule 或者Multiplication theorem或者Multiplication Principle&lt;/p&gt;
&lt;p&gt;捆绑法 - bonding method (百度百科上的翻译是错的, 这才是对的)&lt;/p&gt;
&lt;p&gt;插空法 - Interpolation method&lt;/p&gt;
&lt;p&gt;插板法 - plate insertion method (目前尚存疑)&lt;/p&gt;

&lt;p&gt;感悟:&lt;/p&gt;
&lt;p&gt;真的是长江后浪推前浪啊, 现在的本科生直接就用英语原版的数学教材, 一旦毕业再工作个三五年就能秒杀很多十几年经验的人. 中国很多程序员35岁失业其中两个原因就是第一大学教材越到后面越先进, 后来甚至用上了英语原版的教材. 第二就是当年读书的英语教学水平远差于现在的英语教学水平, 从而导致三到五年工作经验的程序员无论是理论基础还是英语水平都超越了十几年工作经验的程序员. &lt;/p&gt;
&lt;p&gt;不过没关系啦, 虽然落后了, 努力再追上不就行了啦&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 15:47:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>NLP届掌门人斯坦福大学的Daniel Jurafsky（D. 朱夫斯凯）和科罗拉多大学James H. Martin（J. H. 马丁）在其NLP巨作《自然语言处理综论》一书第二版第5页中提到：“几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adalovelacer/p/NLP-Math-2-permutation-and-combination.html</dc:identifier>
</item>
<item>
<title>解决pyinstaller在单一文件时无法正确添加权限清单问题，(UAC，uac_admin，manifest，asInvoker，python,requireAdministrator) - 墨水熊</title>
<link>http://www.cnblogs.com/moshuixiong/p/12041527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moshuixiong/p/12041527.html</guid>
<description>&lt;p&gt;&lt;span&gt;做了3天的win10的兼容性测试，大部分时间都卡权限获取这了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下废话很多，想直接找解决方法，请跳至&lt;strong&gt;&lt;span&gt;红字&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，简单说下uac，自vista后windows再次加严了权限管理，uac （账户控制） ，就是程序对访问一些敏感资源时的限制，当程序需要访问限制资源时会弹窗让用户选择。现在系统主要分两种权限管理员权限和标准权限，当你点击一个程序时只会调用标准权限，这时对windows文件夹，Program文件夹和部分关键的注册表的修改都会报错，访问应该还可以。当你需要安装驱动或者程序时可以使用右键后点选管理员身份运行，那程序在系统几乎就能畅行无阻了，这样的确很安全但体验不好，程序员需要提醒用户右键点开以确保程序正常进行，所以有了权限清单，一个xml格式的文件，它可以在程序加载前告诉系统需要怎样的权限，如果需要管理员权限，系统会弹窗警告，让用户选择。这个权限清单在微软的vs工具集中还是很好实现的，毕竟是本家的东西，但在python中就有问题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下权限方面的官方说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/en-us/windows/win32/dxtecharts/user-account-control-for-game-developers&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实pyinstaller是有权限清单功能的，但一直&lt;/span&gt;&lt;span&gt;都有bug，在生成多文件时正常，在生成单一exe时无法正确嵌入清单。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多文件正常是因为权限清单就放在exe旁边，文件名和exe一样，后缀为manifest 那么系统就可以获取到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单文件时pyinstaller会先解压将资源丢在临时目录里，清单也在其内，而系统必须先获得权限清单，了解需要怎样的权限才能正确执行程序，否则一律按标准权限执行，且中途不得更改。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个bug差不多存在4年了，&lt;/span&gt;&lt;span&gt;直到最近19年7月出的最新3.5版，明确表示，该bug修复啦~~ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而并没有修&lt;span&gt;（小声说：麻蛋你不说修复，我也不会花这么长时间去读文档，换py和pyinstaller的各种版本，总觉得自己操作有误）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下pyinstaller版本说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://pyinstaller.readthedocs.io/en/stable/CHANGES.html#id1&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过在网页和实验的海洋里颠鸾倒凤了1天之后我决定解决问题还是要去改代码的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先说下pycharm调试怎么加命令行参数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;菜单栏的run&amp;gt;edit configuration...&amp;gt;选择你要执行的py&amp;gt;parameters 添加就好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：如果没有找到py，请先debug执行下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;在改源码时我参照了国外的这位大神&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://stackoverflow.com/questions/13964909/setting-uac-to-requireadministrator-using-pyinstaller-onefile-option-and-manifes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上我几乎就是原版搬过来的&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;注意：这里未细测，该代码是否会对pyinstaller的其他功能造成影响并不清楚，强烈建议去官网下个3.5版本的pyinstaller对其修改后执行，但请勿安装。&lt;br/&gt;执行方法：解压后直接将pyinstaller.py拖进cmd 后面跟参数即可。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在pyinstaller的api.py内搜索&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
logger.info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Appending archive to EXE %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, self.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其上部添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　import&lt;/span&gt;&lt;span&gt; sys
            manifest_filename_ &lt;/span&gt;= str(sys.argv[1]).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.exe.manifest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.exists(manifest_filename_):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Overriding default manifest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                tmpnm &lt;/span&gt;=&lt;span&gt; tempfile.mktemp()
                shutil.copy2(exe, tmpnm)
                os.chmod(tmpnm, &lt;/span&gt;0755&lt;span&gt;)

                winmanifest.UpdateManifestResourcesFromXMLFile(tmpnm, manifest_filename_, names&lt;/span&gt;=[1&lt;span&gt;],
                                                               languages&lt;/span&gt;=[1033&lt;span&gt;])
                exe &lt;/span&gt;=&lt;span&gt; tmpnm
                trash.append(tmpnm)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; i am too difficult le&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Fall back to just append on end of file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;使用方法：将manifest文件和py文件放在一起，执行 pyinstaller py文件路径 -F --uac-admin 即可&lt;br/&gt;&lt;/span&gt;&lt;span&gt;maifest的命名规则和其内容：先用&lt;/span&gt;&lt;span&gt;pyinstaller对py进行一次多文件打包，也就是 &lt;/span&gt;&lt;span&gt;pyinstaller py文件路径 --uac-admin  在文件夹内可以获取到*.exe.maifest，将其拷贝到py目录下&lt;br/&gt;再执行单文件打包。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;在win10企业版和win7旗舰版测试均能获得管理员权限，但并没有警告弹窗。。why？ 可能是跟UAC的配置有关。sure？ 管他呢。。。能用就得了&lt;br/&gt;以下为测试代码&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
admin_dir &lt;/span&gt;= os.path.join(os.environ.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SystemRoot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\windows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;temp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
os.listdir(admin_dir)
sys.stdin.readline()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将其打包单一文件并执行，不报错即为管理员权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：首先登陆的用户为管理员才能成功获得管理员权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源码改的一般，对&lt;/span&gt;&lt;span&gt;pyinstaller理解不深，欢迎大家修正，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另附：&lt;span&gt;pyinstaller3.5.rar修改完成版 上传中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 14 Dec 2019 15:32:00 +0000</pubDate>
<dc:creator>墨水熊</dc:creator>
<og:description>做了3天的win10的兼容性测试，大部分时间都卡权限获取这了。 以下废话很多，想直接找解决方法，请跳至红字 首先，简单说下uac，自vista后windows再次加严了权限管理，uac （账户控制）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moshuixiong/p/12041527.html</dc:identifier>
</item>
<item>
<title>分布式事务，解决方案 - 王的博客园12</title>
<link>http://www.cnblogs.com/hanks/p/12041494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanks/p/12041494.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html&quot;&gt;聊聊分布式事务，再说说解决方案&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_40533111/article/details/85069536&quot;&gt;分布式事务CAP理解论证-解决方案&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://matt33.com/2018/07/08/distribute-system-consistency-protocol/&quot;&gt;分布式系统的2PC、3PC详细分析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/changmingxie/tcc-transaction&quot;&gt;github tcc示例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/5dda9e7e6fb9a07aae2a3778&quot;&gt;分布式事务、重复消费、顺序消费&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一理论&quot;&gt;一、理论&lt;/h2&gt;
&lt;h3 id=&quot;cap相关&quot;&gt;CAP相关：&lt;/h3&gt;
&lt;p&gt;CAP与BASE相关：&lt;a href=&quot;https://wangyunzhong123.github.io/2019/12/01/%E5%88%86%E5%B8%83%E5%BC%8FCAP%E4%B8%8EBASE%E7%90%86%E8%AE%BA/&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而对于分布式中的问题的解决方案,CAP原则出现,描述如下:&lt;/p&gt;
&lt;p&gt;一致性(Consistency):&lt;/p&gt;
&lt;p&gt;像A节点写入一条信息之后,同一时刻,在其他节点都可以读到这条信息&lt;/p&gt;
&lt;p&gt;可用性(Availability):&lt;/p&gt;
&lt;p&gt;多布一些节点A,B,C…,任何时刻,用户访问,都应该以可预期的结果返回,而不是浏览器报错,404,500,页面丢失…等用户体验不好的情况发生&lt;/p&gt;
&lt;p&gt;分区容忍性(PartitionTolerance):&lt;/p&gt;
&lt;p&gt;当各系统模块间通信出现问题时,设计一个策略,使系统仍可对外提供满足一致性或可用性&lt;/p&gt;
&lt;p&gt;刚接触cap时,有些不理解分区容忍性,我们自己倒推一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为了保证一致性,我们需要各个节点同步消息&lt;/li&gt;
&lt;li&gt;为了保证可用性我们可以多部署节点,部分节点挂了仍可对外提供服务&lt;/li&gt;
&lt;li&gt;为了保证分区容忍性:此刻卡壳了,怎么做?没了一种具体的方式,然而他还是客观存在的。后来发现:进入了思维盲点:只要在分布式场景中,分区必然存在,那么如果不处理分区发生时的情况,节点无法通讯时会发生什么?–此刻如果仍对外提供服务,那么导致无法同步消息,即保证不了强一致性;如果要保证强一致性,那么就需要节点阻塞,一直等待通讯恢复,即保证不了可用性.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以分区容忍性就是:当发生分区问题时,我们使用策略,在一致性和可用性二者间选择&lt;br/&gt;注意: 无法通信包括网络问题,或者节点机器宕机&lt;/p&gt;
&lt;p&gt;误区: CAP理论中说三者不可兼得,但实际情况是,在分布式场景中分区一定存在,即必须有分区容忍性对应的策略,之后才能在一致性和可用性间二者之间选择.所以对主流架构来说不是三选二,而是二选一。&lt;/p&gt;
&lt;h3 id=&quot;对p的理解&quot;&gt;对P的理解&lt;/h3&gt;
&lt;p&gt;很多人可能对分区容忍性不太理解，知乎有一个回答对这个解释的比较清楚&lt;a href=&quot;https://www.zhihu.com/question/54105974&quot;&gt;CAP理论中的P到底是个什么意思？&lt;/a&gt;，这里引用一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。&lt;/li&gt;
&lt;li&gt;当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。&lt;/li&gt;
&lt;li&gt;提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里，容忍性就提高了。&lt;/li&gt;
&lt;li&gt;然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。&lt;/li&gt;
&lt;li&gt;要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。&lt;/li&gt;
&lt;li&gt;总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;xa规范&quot;&gt;XA规范：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jasongj.com/big_data/two_phase_commit/&quot; class=&quot;uri&quot;&gt;http://www.jasongj.com/big_data/two_phase_commit/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhoujinyi/p/5257558.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhoujinyi/p/5257558.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XA规范中，事务管理器主要通过以下的接口对资源管理器进行管理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;xa_open，xa_close：建立和关闭与资源管理器的连接。&lt;/li&gt;
&lt;li&gt;xa_start，xa_end：开始和结束一个本地事务。&lt;/li&gt;
&lt;li&gt;xa_prepare，xa_commit，xa_rollback：预提交、提交和回滚一个本地事务。&lt;/li&gt;
&lt;li&gt;xa_recover：回滚一个已进行预提交的事务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;XA规范：&lt;a href=&quot;https://www.cnblogs.com/wt645631686/p/10882998.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/wt645631686/p/10882998.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_40533111/article/details/85069536&quot;&gt;一些具体实现&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用限制&quot;&gt;使用限制：&lt;/h4&gt;
&lt;p&gt;a. XA事务和本地事务以及锁表操作是互斥的&lt;/p&gt;
&lt;p&gt;开启了xa事务就无法使用本地事务和锁表操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; xa start 't1xa';
Query OK, 0 rows affected (0.04 sec)
mysql&amp;gt; begin;
ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the ACTIVE state
mysql&amp;gt; lock table t1 read;
ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed when global transaction is in the ACTIVE state&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启了本地事务就无法使用xa事务:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)
mysql&amp;gt; xa start 'rrrr';
ERROR 1400 (XAE09): XAER_OUTSIDE: Some work is done outside global transaction&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b. xa start 之后必须xa end， 否则不能执行xa commit 和xa rollback&lt;/p&gt;
&lt;p&gt;所以如果在执行xa事务过程中有语句出错了，你也需要先xa end一下，然后才能xarollback。&lt;/p&gt;
&lt;p&gt;注意事项:&lt;/p&gt;
&lt;p&gt;a. mysql只是提供了xa事务的接口，分布式事务中的mysql实例之间是互相独立的不感知的。 所以用户必须&lt;br/&gt;自己实现分布式事务的调度器&lt;/p&gt;
&lt;p&gt;b. xa事务有一些使用上的bug， 参考http://www.mysqlops.com/2012/02/24/mysql-xa-optimize.html&lt;/p&gt;
&lt;p&gt;主要是:&lt;br/&gt;“MySQL数据库的主备数据库的同步，通过Binlog的复制完成。而Binlog是MySQL数据库内部XA事务的协调者，并且MySQL数据库为binlog做了优化——binlog不写prepare日志，只写commit日志。&lt;br/&gt;所有的参与节点prepare完成，在进行xa commit前crash。crash recover如果选择commit此事务。由于binlog在prepare阶段未写，因此主库中看来，此分布式事务最终提交了，但是此事务的操作并未 写到binlog中，因此也就未能成功复制到备库，从而导致主备库数据不一致的情况出现。&lt;br/&gt;而crash recover如果选rollback, 那么就会出现全局不一致（该分布式事务对应的节点，部分已经提交，无法回滚，而部分节点回滚。最终导致同一分布式事务，在各参与节点，最终状态不一致）”&lt;/p&gt;
&lt;p&gt;参考的那篇blog中给出的办法是修改mysql代码，这个无法在DBScale中使用。 所以可选的替代方案是不使用&lt;br/&gt;主从复制进行备份，而是直接使用xa事务实现同步写来作为备份。&lt;/p&gt;
&lt;h2 id=&quot;二两阶段提交2pc&quot;&gt;二、两阶段提交2PC&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tvax3.sinaimg.cn/large/9ea5011cly1g9hg6hrqy1j20f308r74r.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个角色：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;协调者&lt;/li&gt;
&lt;li&gt;参与者&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阶段一：提交事务请求&lt;/li&gt;
&lt;li&gt;阶段二：执行事务提交&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;牺牲了一部分可用性来换取的一致性。解决方案有：springboot+Atomikos or Bitronix&lt;/p&gt;
&lt;p&gt;优点： 原理简单，实现方便&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同步阻塞：在提交的过程中，所有参与者都处于阻塞状态，大大降低并发度&lt;/li&gt;
&lt;li&gt;单点问题：一旦协调者出现问题，则所有参与者处于锁定状态，无法对外服务&lt;/li&gt;
&lt;li&gt;数据不一致：在阶段二，协调者发送了commit之后，发生了局部网络异常或者协调者尚未发送完commit请求就宕机了，导致部分参与者收到commit，导致系统出现不一致&lt;/li&gt;
&lt;li&gt;太过保守：协调者在阶段一中，参与者出现故障而导致协调者无法获取到所有参与者的响应，协调者只能依靠超时时间来判断是否中断事务。换句话说，没有完善的容错机制。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现&quot;&gt;2. 实现&lt;/h3&gt;
&lt;p&gt;JTA（Java Transaction API）定义了对XA事务的支持。像很多其他的Java规范一样，JTA仅仅定义了接口，具体的实现则是由供应商(如J2EE厂商)负责提供，目前JTA的实现主要有以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;J2EE容器所提供的JTA实现(如JBoss)。&lt;/li&gt;
&lt;li&gt;独立的JTA实现：如JOTM（Java Open Transaction Manager），Atomikos。这些实现可以应用在那些不使用J2EE应用服务器的环境里用以提供分布事事务保证。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL中的XA实现分为：外部XA和内部XA。前者是指我们通常意义上的分布式事务实现；后者是指单台MySQL服务器中，Server层作为TM(事务协调者)，而服务器中的多个数据库实例作为RM，而进行的一种分布式事务，也就是MySQL跨库事务；也就是一个事务涉及到同一条MySQL服务器中的两个innodb数据库(因为其它引擎不支持XA)。&lt;/p&gt;
&lt;h2 id=&quot;三三阶段提交3pc&quot;&gt;三、三阶段提交3PC&lt;/h2&gt;
&lt;p&gt;是二阶段的改进版，将二阶段的提交事务请求过程一分为二，形成了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CanCommit：协调者发送事务询问、参与者反馈&lt;/li&gt;
&lt;li&gt;PreCommit：协调者发送预提交请求、参与者事务预提交（执行事务操作，写undo、redo日志）、参与者响应&lt;/li&gt;
&lt;li&gt;doCommit：协调者发送提交请求、参与者事务提交（事务提交，释放资源）、参与者响应&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在阶段二中，参与者可能会响应no，或者协调者等待超时时间后还无法收到所有参与者的反馈，则中断事务：协调者向所有参与者发送abort请求。参与者无论是收到协调者的abort请求，或者等待协调者请求过程中超时，都会中断事务。&lt;/p&gt;
&lt;p&gt;在阶段三中，如果有任一参与者发送了no，或者等待超时后协调者还没收到所有参与者的反馈，则中断事务。需要注意的事，进入阶段三，可能会有下面两种故障：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协调者出现问题&lt;/li&gt;
&lt;li&gt;协调者、参与者之间的网络出现问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论哪种情况，都会导致参与者无法及时收到来自协调者的doCommit或者abort请求，这种情况，参与者在等待超时后继续进行事务提交。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;降低了参与者的阻塞范围（二阶段中如果参与者与协调者断开，参与者abort；三阶段，提交），并且能够在单点故障后继续达成一致。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;参与者在收到preCommit后出现网络分区，参与者依然会提交事务，会造成不一致。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四实现&quot;&gt;四、实现&lt;/h2&gt;
&lt;p&gt;todo&lt;/p&gt;
</description>
<pubDate>Sat, 14 Dec 2019 15:22:00 +0000</pubDate>
<dc:creator>王的博客园12</dc:creator>
<og:description>'聊聊分布式事务，再说说解决方案' '分布式事务CAP理解论证 解决方案' '分布式系统的2PC、3PC详细分析' 'github tcc示例' '分布式事务、重复消费、顺序消费' 一、理论 CAP相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanks/p/12041494.html</dc:identifier>
</item>
<item>
<title>Spring Security OAuth2 Demo —— 密码模式（Password） - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/12041495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/12041495.html</guid>
<description>&lt;h2 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h2&gt;
&lt;p&gt;前几节分享了OAuth2的流程与授权码模式和隐式授权模式两种的Demo，我们了解到授权码模式是OAuth2四种模式流程最复杂模式，复杂程度由大至小：授权码模式 &amp;gt; 隐式授权模式 &amp;gt; 密码模式 &amp;gt; 客户端模式&lt;/p&gt;
&lt;p&gt;其中密码模式的流程是：让用户填写表单提交到授权服务器，表单中包含用户的用户名、密码、客户端的id和密钥的加密串，授权服务器先解析并校验客户端信息，然后校验用户信息，完全通过返回access_token，否则默认都是401 http状态码，提示未授权无法访问&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;本文目标&lt;/h2&gt;
&lt;p&gt;编写与说明密码模式的Spring Security Oauth2的demo实现，让未了解过相关知识的读者对此授权流程有个更直观的概念&lt;/p&gt;
&lt;p&gt;以下分成授权服务器与资源服务器分别进行解释，只讲关键部分，详情见Github：https://github.com/hellxz/spring-security-oauth2-learn&lt;/p&gt;
&lt;h2 id=&quot;搭建密码模式授权服务器&quot;&gt;搭建密码模式授权服务器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214221925616-991749092.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码结构与之前两个模式相同，这里便不再进行说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SecurityConfig配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.Collections;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser(&quot;hellxz&quot;)
                .password(passwordEncoder().encode(&quot;xyz&quot;))
                .authorities(new ArrayList&amp;lt;&amp;gt;(0));
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //所有请求必须认证
        http.authorizeRequests().anyRequest().authenticated();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本的SpringSecurity的配置，开启Spring Security的Web安全功能，填了一个用户信息，所有资源必须经过授权才可以访问&lt;/p&gt;
&lt;p&gt;AuthorizationConfig授权服务器配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;

@Configuration
@EnableAuthorizationServer
public class AuthorizationConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private AuthenticationManager authenticationManager;//密码模式需要注入认证管理器

    @Autowired
    public PasswordEncoder passwordEncoder;

    //配置客户端
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        //@formatter:off
        clients.inMemory()
                .withClient(&quot;client-a&quot;)
                  .secret(passwordEncoder.encode(&quot;client-a-secret&quot;))
                  .authorizedGrantTypes(&quot;password&quot;) //主要是这里，开始了密码模式
                  .scopes(&quot;read_scope&quot;);
        //@formatter:on
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager);//密码模式必须添加authenticationManager
    }

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.allowFormAuthenticationForClients()
                .checkTokenAccess(&quot;isAuthenticated()&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里开启了授权服务器的功能，与上几篇文章中不同的是注入了AuthenticationManager，以及在configure(AuthorizationServerEndpointsConfigurer endpoints)方法中设置了AuthenticationManager&lt;/p&gt;
&lt;p&gt;application.properties配置sever.port=8080&lt;/p&gt;
&lt;h2 id=&quot;搭建资源服务器&quot;&gt;搭建资源服务器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214224518249-42615227.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的关键就是ResourceConfig，配置比较简单与其它几个模式&lt;strong&gt;完全一致&lt;/strong&gt;，模式的不同主要表现在授权服务器与客户端服务器上，资源服务器只做token的校验与给予资源&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.RemoteTokenServices;

@Configuration
@EnableResourceServer
public class ResourceConfig extends ResourceServerConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Primary
    @Bean
    public RemoteTokenServices remoteTokenServices() {
        final RemoteTokenServices tokenServices = new RemoteTokenServices();
        //设置授权服务器check_token端点完整地址
        tokenServices.setCheckTokenEndpointUrl(&quot;http://localhost:8080/oauth/check_token&quot;);
        //设置客户端id与secret，注意：client_secret值不能使用passwordEncoder加密！
        tokenServices.setClientId(&quot;client-a&quot;);
        tokenServices.setClientSecret(&quot;client-a-secret&quot;);
        return tokenServices;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        //设置创建session策略
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
        //@formatter:off
        //所有请求必须授权
        http.authorizeRequests()
                .anyRequest().authenticated();
        //@formatter:on
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(&quot;resource1&quot;).stateless(true);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ResourceController主要接收一个用户名，返回一个username与email的json串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214224959106-2073414563.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;application.properties设置server.port=8081&lt;/p&gt;
&lt;p&gt;准备工作到这里就差不多了，开始测试&lt;/p&gt;
&lt;h2 id=&quot;测试流程&quot;&gt;测试流程&lt;/h2&gt;
&lt;p&gt;这里客户端使用postman手动发送请求进行演示&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;访问/oauth/token端点，获取token&lt;/p&gt;
&lt;p&gt;http://localhost:8080/oauth/token?username=hellxz&amp;amp;password=xyz&amp;amp;scope=read_scope&amp;amp;grant_type=password&lt;/p&gt;
&lt;p&gt;请求头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214230431419-1823055802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214230514548-2041753474.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;token返回值&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;access_token&quot;: &quot;4a3c351d-770d-42aa-af39-3f54b50152e9&quot;,
    &quot;token_type&quot;: &quot;bearer&quot;,
    &quot;expires_in&quot;: 43199,
    &quot;scope&quot;: &quot;read_scope&quot;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用token调用资源，访问http://localhost:8081/user/hellxz001，注意使用token添加Bearer请求头&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214230758768-721767305.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相当于在Headers中添加 Authorization:Bearer 4a3c351d-770d-42aa-af39-3f54b50152e9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源正确返回&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191214230957107-1310358328.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;尾声&quot;&gt;尾声&lt;/h2&gt;
&lt;p&gt;本文仅说明密码模式的精简化配置，某些部分如资源服务再访问授权服务去校验token这部分生产环境可能会换成Jwt、Redis等tokenStore实现，授权服务器中的用户信息与客户端信息生产环境应从数据库中读取，对应Spring Security的UserDetailsService实现类或用户信息的Provider等&lt;/p&gt;
&lt;p&gt;最近发现博客写得相对较长，一方面有相当大的重复解释代码的部分，另一方面是代码很多不关键的地方也直接全贴出来了，博客长了代码全了，读者容易失去阅读的兴趣与探索实践的欲望。代码不全会直接贴出源码地址，暂时就这样，把这几篇关于OAuth2授权模式demo的文章赶出来&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;代码早就写完了，下周可能要开始加班了，先把这些已经完成的部分写出来，后续有什么新的知识点才有时间记&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 14 Dec 2019 15:22:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>前情回顾 前几节分享了OAuth2的流程与授权码模式和隐式授权模式两种的Demo，我们了解到授权码模式是OAuth2四种模式流程最复杂模式，复杂程度由大至小：授权码模式 隐式授权模式 密码模式 客户端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/12041495.html</dc:identifier>
</item>
</channel>
</rss>