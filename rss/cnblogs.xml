<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL的单表查询 - YJ同心</title>
<link>http://www.cnblogs.com/yjtxin/p/12709359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjtxin/p/12709359.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建表&lt;/span&gt;
&lt;span&gt;create table employee(
id int &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; null unique auto_increment,
emp_name varchar(&lt;/span&gt;20) &lt;span&gt;not&lt;/span&gt;&lt;span&gt; null,
sex enum(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; null default &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
age int(&lt;/span&gt;3) unsigned &lt;span&gt;not&lt;/span&gt; null default 28&lt;span&gt;,
hire_date date &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; null,
post varchar(&lt;/span&gt;50&lt;span&gt;),
post_comment varchar(&lt;/span&gt;100&lt;span&gt;),
salary double(&lt;/span&gt;15,2&lt;span&gt;),
office int,
depart_id int
);

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看表结构&lt;/span&gt;
mysql&amp;gt;&lt;span&gt; desc employee;
&lt;/span&gt;+--------------+-----------------------+------+-----+---------+----------------+
| Field        | Type                  | Null | Key | Default | Extra          |
+--------------+-----------------------+------+-----+---------+----------------+
| id           | int(11)               | NO   | PRI | NULL    | auto_increment |
| emp_name     | varchar(20)           | NO   |     | NULL    |                |
| sex          | enum(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) | NO   |     | male    |                |
| age          | int(3) unsigned       | NO   |     | 28      |                |
| hire_date    | date                  | NO   |     | NULL    |                |
| post         | varchar(50)           | YES  |     | NULL    |                |
| post_comment | varchar(100)          | YES  |     | NULL    |                |
| salary       | double(15,2)          | YES  |     | NULL    |                |
| office       | int(11)               | YES  |     | NULL    |                |
| depart_id    | int(11)               | YES  |     | NULL    |                |
+--------------+-----------------------+------+-----+---------+----------------+
10 rows &lt;span&gt;in&lt;/span&gt; set (0.09&lt;span&gt; sec)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;插入记录&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;三个部门：教学，销售，运营&lt;/span&gt;
&lt;span&gt;insert into employee(emp_name,sex,age,hire_date,post,salary,office,depart_id) values
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;彭哈哈&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20170301&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,7300.33,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;赵晓明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,78,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20150302&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1000000.31,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爱祖国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,81,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20130305&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8300,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;延阻聚&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,73,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20140701&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3500,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;陈继承&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,28,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20121101&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2100,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李小荷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20110211&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9000,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;赵晓明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;19000301&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,30000,401,1&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高富帅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,48,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20101111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;教学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,10000,401,1&lt;span&gt;),

(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;菟丝子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,48,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20150311&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销售&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3000.13,402,2&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张晓敏&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,38,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20101101&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销售&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2000.35,402,2&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;冯小刚&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20110312&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销售&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1000.37,402,2&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;老小月&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20160513&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销售&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3000.29,402,2&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;格格&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,28,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20170127&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销售&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,4000.33,402,2&lt;span&gt;),

(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;彭消息&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,28,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20160311&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运营&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,10000.13,403,3&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;19970312&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运营&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20000,403,3&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小路小&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20130311&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运营&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,19000,403,3&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;罗超&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20150411&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运营&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18000,403,3&lt;span&gt;),
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张罗好&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,18,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20140512&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运营&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,17000,403,3);
&lt;/pre&gt;</description>
<pubDate>Wed, 22 Apr 2020 00:31:00 +0000</pubDate>
<dc:creator>YJ同心</dc:creator>
<og:description>单表查询 单表查询语法： select distinct 字段1,字段2... from 表名 where 条件 group by field having筛选 order by 关键字执行的优先级：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yjtxin/p/12709359.html</dc:identifier>
</item>
<item>
<title>[Abp vNext 入坑分享] - 1.创建初始的项目 - 二B方案程序员</title>
<link>http://www.cnblogs.com/twoBcoder/p/12748037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoBcoder/p/12748037.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、简要说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章主要是跟着官方的文档把项目安装好先，同时了解一下大概的项目结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、具体步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1&lt;/strong&gt;全局安装ABP CLI，直接在cmd中安装即可。如果你之前安装过，这里可以略过：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;dotnet tool install -g Volo.Abp.Cli&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213033001-146976849.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2&lt;/strong&gt;转到你要保存项目的路径中输入cmd指令，回车： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213130394-921260756.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213215460-1957618076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;输入： abp new AbpVnext.Learn -t module --no-ui   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--no-ui表示不包含UI层.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后等待安装完成就可以了，这里首次安装会很慢，有vpn的可以打开vpn安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213225099-1324992533.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3&lt;/strong&gt;然后看到整个项目已经新建立成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213259425-919851438.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;下图:项目安装了一个全局的组件，我个人并不需要这个组件，所以删掉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213307528-99757859.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213317897-1676824920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4&lt;/strong&gt;以下则是整体的项目结构了，关于项目结构：官方文档有比较详细的说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.abp.io/zh-Hans/abp/latest/Startup-Templates/Application&quot;&gt;https://docs.abp.io/zh-Hans/abp/latest/Startup-Templates/Application&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.abp.io/zh-Hans/abp/latest/Best-Practices/Index&quot;&gt;https://docs.abp.io/zh-Hans/abp/latest/Best-Practices/Index&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图则为我自己的一点补充：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200421213326456-1614822773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 Apr 2020 00:18:00 +0000</pubDate>
<dc:creator>二B方案程序员</dc:creator>
<og:description>一、简要说明 本篇文章主要是跟着官方的文档把项目安装好先，同时了解一下大概的项目结构。 二、具体步骤 2.1全局安装ABP CLI，直接在cmd中安装即可。如果你之前安装过，这里可以略过： dotne</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/twoBcoder/p/12748037.html</dc:identifier>
</item>
<item>
<title>那个小白说他还没搞懂类和对象，我一怒之下把这篇文章扔给了他 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12749460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12749460.html</guid>
<description>&lt;blockquote readability=&quot;6.2708333333333&quot;&gt;
&lt;p&gt;二哥，我就是上次说你《教妹学Spring》看不懂的那个小白，没想到你还特意写了一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/s0vUZEGnuXqtEF62-XmkuA&quot;&gt;入门级的 Java 基础知识&lt;/a&gt;，这次真的看懂了，感觉好棒。请原谅我上次的唐突，二哥能够照顾我们这些小白的学习进度，真的是良心了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是读者 KEL 在上一篇基础知识文章发布后特意给我发来的信息，说实话，看完后蛮感动的，良心没有被辜负啊。于是，我愉快地决定了，每隔一两周就写一篇入门级的文章给小白们看。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。&lt;/p&gt;
&lt;p&gt;来，让我来定义一个简单的类给你看看。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String color;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;吃&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String color;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;吃&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，就是多出来的那个 &lt;code&gt;public Pig() {}&lt;/code&gt;，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; Pig pig = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，我们也可以主动添加带参的构造方法。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String color;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;吃&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String color;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;吃&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着无法通过 &lt;code&gt;new Pig()&lt;/code&gt; 来创建对象了——编译器会提醒你追加参数。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;比如说你将代码修改为 &lt;code&gt;new Pig(&quot;纯白色&quot;)&lt;/code&gt;，或者添加无参的构造方法。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String color;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;吃&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;接下来，我们来创建多个 Pig 对象，它的颜色各不相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PigTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Pig pigNoColor = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig();&lt;br/&gt;Pig pigWhite = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;纯白色&quot;&lt;/span&gt;);&lt;br/&gt;Pig pigBlack = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;纯黑色&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。&lt;/p&gt;
&lt;p&gt;那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。&lt;/p&gt;
&lt;p&gt;最好的办法就是为 Pig 类追加 getter/setter 方法，就像下面这样：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getColor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; color;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setColor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;setColor()&lt;/code&gt; 方法来修改，通过 &lt;code&gt;getColor()&lt;/code&gt; 方法获取状态，它们的权限修饰符是 public 的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Pig pigNoColor = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig();&lt;br/&gt;pigNoColor.setColor(&lt;span class=&quot;hljs-string&quot;&gt;&quot;花色&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(pigNoColor.getColor()); &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter/setter 一样的效果了吗？&lt;/p&gt;
&lt;p&gt;因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; age;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;increaseAge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.age++;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，age 就没有 setter 方法，只有一个每年可以调用一次的 &lt;code&gt;increaseAge()&lt;/code&gt; 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。&lt;/p&gt;
&lt;p&gt;访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。&lt;/p&gt;
&lt;p&gt;一个类只能使用 &lt;code&gt;public&lt;/code&gt; 或者 &lt;code&gt;default&lt;/code&gt; 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。&lt;/p&gt;
&lt;p&gt;假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。&lt;/p&gt;
&lt;p&gt;可以通过下面这张图来对比一下四个权限修饰符之间的差别：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;同一个类中，不管是哪种权限修饰符，都可以访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同一个包下，private 修饰的无法访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子类可以访问 public 和 protected 修饰的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;public 修饰符面向世界，哈哈，可以被所有的地方访问到。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/java-class-object-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;好了，我亲爱的读者朋友，本文到此就打算戛然而止了，有什么不满意的，尽管留言，我保证给你上墙的机会。&lt;/p&gt;
&lt;p&gt;我是沉默王二，一枚有趣的程序员，如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。 &lt;strong&gt;原创不易，莫要白票，请你为本文点赞个吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
&lt;blockquote readability=&quot;4.0384615384615&quot;&gt;
&lt;p&gt;本文已同步到 GitHub，欢迎 star，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;传送门~&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 Apr 2020 21:49:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>二哥，我就是上次说你《教妹学Spring》看不懂的那个小白，没想到你还特意写了一篇入门级的 Java 基础知识，这次真的看懂了，感觉好棒。请原谅我上次的唐突，二哥能够照顾我们这些小白的学习进度，真的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12749460.html</dc:identifier>
</item>
<item>
<title>01、WireShark——ARP 协议包分析 - Pluto_H</title>
<link>http://www.cnblogs.com/CSAH/p/12749368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CSAH/p/12749368.html</guid>
<description>&lt;p&gt;&lt;strong&gt; 1. 什么是ARP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   ARP&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Address Resolution Protocol&lt;/span&gt;&lt;span&gt;）协议，即地址解析协议。该协议的功能就是将&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地 址解析成&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   ARP&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Address Resolution Protocol&lt;/span&gt;&lt;span&gt;，地址解析协议）是根据&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址获取物理地址的一个&lt;/span&gt; &lt;span&gt;TCP/IP&lt;/span&gt; &lt;span&gt;协议。由于&lt;/span&gt; &lt;span&gt;OSI&lt;/span&gt; &lt;span&gt;模型把网络工作分为七层，&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址在&lt;/span&gt; &lt;span&gt;OSI&lt;/span&gt; &lt;span&gt;模型的第三层，&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地 址在第二层，彼此不直接通信。在通过以太网发送&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;数据包时，需要先封装第三层（&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;位&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址）、第二层（&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;位&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址）的报头。但由于发送数据包时只知道目标&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址， 不知道其&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址，而又不能跨越第二、三层，所以需要使用地址解析协议。 使用地址解析协议后，计算机可根据网络层&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;数据包包头中的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址信息对应目标硬 件地址（&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址）信息，以保证通信的顺利进行。&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;的基本功能就是负责将一个已知 的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址解析成&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址，以便主机间能正常进行通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. ARP工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   ARP &lt;span&gt;工作过程分为两个阶段，一个是&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求过程，一个是&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;响应过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021432603-1341228192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021439128-2052334680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;   &lt;span&gt;在图&lt;/span&gt;2.2&lt;span&gt;和&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;中，主机&lt;/span&gt;&lt;span&gt;PC1&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址为&lt;/span&gt;&lt;span&gt;192.168.1.1&lt;/span&gt;&lt;span&gt;；主机&lt;/span&gt;&lt;span&gt;PC2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址为&lt;/span&gt;&lt;span&gt;192.168.1.2&lt;/span&gt;&lt;span&gt;。 当主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;和主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;通信时，地址解析协议可以将主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址（&lt;/span&gt;&lt;span&gt;192.168.1.2&lt;/span&gt;&lt;span&gt;）解 析成主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的详细通信过程如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）当主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;想发送数据给主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;时，首先在自己的本地&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表中检查主 机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;匹配的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）如果主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;在缓存中没有找到相应的条目，它将询问主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址， 从而将&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt;&lt;span&gt;请求帧广播到本地网络上的所有主机。该帧中包括源主机&lt;/span&gt;&lt;span&gt;PC1&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址和&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。本地网络上的每台主机都接收到&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求并且检查是否与自己的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址匹配。如果 主机发现请求的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址与自己的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址不匹配，它将会丢弃&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;确定&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求中的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址与自己的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址匹配，则将主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;的地 址和&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址添加到本地缓存表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;将包含其&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址的&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;回复消息直接发送回主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt;&lt;span&gt;（这个数据帧 是单播）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）当主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;收到从主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;发来的&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;回复消息时，会将主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址添加的自己的&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt;&lt;span&gt;缓存表。本机缓存是有生存期的，默认&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt;&lt;span&gt;缓存表的有效期是&lt;/span&gt;&lt;span&gt;120s&lt;/span&gt;&lt;span&gt;。 当超过该有效期后，将再次重复上面的过程。主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址一旦确定，主机&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;将能向主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;发送&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;通信了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. ARP缓存表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）缓存表由来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   ARP &lt;span&gt;缓存中包含一个或多个表，它们用于存储&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址及其经过解析的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。在&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存中的每个表又被称为&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表维护工具&lt;/span&gt;&lt;span&gt;——arp&lt;/span&gt; &lt;span&gt;命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;在计算机中，提供了一个&lt;/span&gt; ARP &lt;span&gt;命令。该命令用于查询本机&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存中的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址和&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址的对应关系、添加或删除静态对应关系等。用户也可以通过使用&lt;/span&gt; &lt;span&gt;arp&lt;/span&gt; &lt;span&gt;命令验证&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓 存条目的生命周期。&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;命令的语法格式如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;arp [-s inet_addr eth_addr [if_addr]] [-d inet_addr [if_addr]] [-a [inet_addr] [-N if_addr]] [-g] [-v]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;以上参数含义如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① -s inet_addr eth_addr [if_addr]&lt;span&gt;：向&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表中添加可将&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt; &lt;span&gt;解析成 物理地址&lt;/span&gt; &lt;span&gt;eth_addr&lt;/span&gt; &lt;span&gt;的静态条目。要向指定接口的表添加静态&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存条目，使用&lt;/span&gt; &lt;span&gt;if_addr&lt;/span&gt; &lt;span&gt;参数，此处的&lt;/span&gt; &lt;span&gt;if_addr&lt;/span&gt; &lt;span&gt;代表指派给该接口的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;② -d inet_addr if_addr&lt;span&gt;：删除指定的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;条目，此处的&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt; &lt;span&gt;代表&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址。对于指定 的接口，要删除表中的某项，使用&lt;/span&gt; &lt;span&gt;if_addr&lt;/span&gt;&lt;span&gt;，此处的&lt;/span&gt; &lt;span&gt;if_addr&lt;/span&gt; &lt;span&gt;代表指派给该接口的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址。要删除所有条目，使用星号（&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;）通配符代替&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;③ -a inet_addr [-N if_addr]&lt;span&gt;：显示所有接口的当前&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表。要显示特定&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址的&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存项，使用带有&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt; &lt;span&gt;参数的&lt;/span&gt; &lt;span&gt;arp -a&lt;/span&gt;&lt;span&gt;，此处的&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt; &lt;span&gt;代表&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址。如 果未指定&lt;/span&gt; &lt;span&gt;inet_addr&lt;/span&gt;&lt;span&gt;，则使用第一个适用的接口。要显示特定接口的&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;缓存表， 将&lt;/span&gt;&lt;span&gt;-N if_addr&lt;/span&gt; &lt;span&gt;与&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt; &lt;span&gt;参数一起使用，此处的&lt;/span&gt; &lt;span&gt;if_addr&lt;/span&gt; &lt;span&gt;代表指派给该接口的&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;span&gt;-N&lt;/span&gt; &lt;span&gt;参数区分大小写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;④ -g&lt;span&gt;：与&lt;/span&gt;&lt;span&gt;-a&lt;/span&gt; &lt;span&gt;相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑤ -v&lt;span&gt;：查看帮助信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;详细的&lt;/span&gt;arp&lt;span&gt;使用命令，可参考我的另一篇博客。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 捕获 ARP 协议包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021452858-292152488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot;&gt;
&lt;p&gt;&lt;strong&gt;PC&amp;gt;ping 192.168.1.3&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;执行以上命令后，将输出如下所示的信息：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;15.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;Ping 192.168.1.3: 32 data bytes, Press Ctrl_C to break&lt;/p&gt;
&lt;p&gt;From 192.168.1.3: bytes=32 seq=1 ttl=128 time=31 ms&lt;/p&gt;
&lt;p&gt;From 192.168.1.3: bytes=32 seq=2 ttl=128 time=31 ms&lt;/p&gt;
&lt;p&gt;From 192.168.1.3: bytes=32 seq=3 ttl=128 time=47 ms&lt;/p&gt;
&lt;p&gt;From 192.168.1.3: bytes=32 seq=4 ttl=128 time=31 ms&lt;/p&gt;
&lt;p&gt;From 192.168.1.3: bytes=32 seq=5 ttl=128 time=47 ms&lt;/p&gt;
&lt;p&gt;--- 192.168.1.3 ping statistics ---&lt;/p&gt;
&lt;p&gt;  5 packet(s) transmitted&lt;/p&gt;
&lt;p&gt;  5 packet(s) received&lt;/p&gt;
&lt;p&gt;  0.00% packet loss&lt;/p&gt;
&lt;p&gt;  round-trip min/avg/max = 31/37/47 ms&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;从输出的信息中，可以看到主机&lt;/span&gt; PC2（192.168.5.2）向主机 PC1（192.168.5.4）发送了 四个数据包。这时候，Wireshark 就捕获到 ARP 数据包了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021522525-1669329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;从该界面的&lt;/span&gt; Protocol &lt;span&gt;列，可以看到捕获到的数据包都是&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议包。其中，&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;帧是&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求包；&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;帧是响应包。由于使用&lt;/span&gt; &lt;span&gt;arp&lt;/span&gt; &lt;span&gt;过滤器，可以仅过滤出&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 分析ARP协议包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;在分析&lt;/span&gt; ARP &lt;span&gt;协议包之前，先介绍一下它的报文格式，以帮助用户更清楚的理解每个包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1) ARP&lt;span&gt;报文格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021533352-21429132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021541773-342070229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     &lt;span&gt;该图中每行长度为&lt;/span&gt; 4 &lt;span&gt;个字节，即&lt;/span&gt; &lt;span&gt;32&lt;/span&gt; &lt;span&gt;位。其中图中蓝色的部分是以太网（指&lt;/span&gt; &lt;span&gt;Ethernet II&lt;/span&gt; &lt;span&gt;类型）的帧头部。这里共三个字段，分别如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;第一个字段是广播类型的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址：&lt;/span&gt;&lt;span&gt;0XFF-FF-FF-FF-FF-FF&lt;/span&gt;&lt;span&gt;，其目标是网络上的 所有主机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;第二个字段是源&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址，即请求地址解析的的主机&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;第三个字段是协议类型，这里用&lt;/span&gt; &lt;span&gt;0X0806&lt;/span&gt; &lt;span&gt;代表封装的上层协议是&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;接下来是&lt;/span&gt; ARP &lt;span&gt;协议报文部分其中各个字段的含义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;硬件类型：表明&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议实现在哪种类型的网络上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;协议类型：表示解析协议（上层协议）。这里一般是&lt;/span&gt; &lt;span&gt;0800&lt;/span&gt;&lt;span&gt;，即&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;硬件地址长度：&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址长度，此处为&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;个字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;协议地址长度：&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址长度，此处为&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;个字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;操作类型：表示&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议数据包类型。&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;表示&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议请求数据包，&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;表示&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议应答数据包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;源&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址：发送端&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;源&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址：表示发送端协议地址（&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址：目标端&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   · &lt;span&gt;目标&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址：表示目的端协议地址（&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   ARP &lt;span&gt;协议应答协议报文和&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议请求协议报文类似。不同的是，此时以太网帧头部 的目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址为发送&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议地址解析请求的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址，而源&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址为被解析的 主机的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。同时，操作类型字段为&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;，表示&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;协议应答数据包，目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址 字段被填充为目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;应答协议报文格式如表&lt;/span&gt; &lt;span&gt;2-2&lt;/span&gt; &lt;span&gt;所示。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot;&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021621418-1329431690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;2）ARP请求包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021627342-2017349253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;span&gt;从图中可以看到，第一个数据包是一个&lt;/span&gt; ARP &lt;span&gt;请求包。用户可以通过在&lt;/span&gt; &lt;span&gt;Wireshark&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;Packet Details&lt;/span&gt; &lt;span&gt;面板中，检查以太网头部来确定该包是否是一个真的广播数据包。下面将详细 介绍&lt;/span&gt; &lt;span&gt;Packet Details&lt;/span&gt; &lt;span&gt;面板中的每行信息。如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Frame 22: 60 bytes on wire (480 bits), 60 bytes captured (480 bits) on interface 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上内容表示这是第&lt;/span&gt; 1 &lt;span&gt;帧数据包的详细信息。其中，该包的大小为&lt;/span&gt; &lt;span&gt;60&lt;/span&gt; &lt;span&gt;个字节。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;Ethernet II, Src: 54:89:98:34:15:33 (54:89:98:34:15:33), Dst: Broadcast (ff:ff:ff:ff:ff:ff)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上内容表示以太网帧头部信息。其中源&lt;/span&gt; MAC &lt;span&gt;地址为&lt;/span&gt; &lt;span&gt;54:89:98:34:15:33&lt;/span&gt;&lt;span&gt;，目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地 址为&lt;/span&gt; &lt;span&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;&lt;span&gt;（广播地址）。这里的目标地址为广播地址，是因为主机&lt;/span&gt; &lt;span&gt;PC2&lt;/span&gt; &lt;span&gt;不知道&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;主机的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。这样，局域网中所以设备都会收到该数据包。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Address Resolution Protocol (request)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上内容表示地址解析协议内容，&lt;/span&gt;request &lt;span&gt;表示该包是一个请求包。在该包中包括有&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;更详细的字段信息，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;Address Resolution Protocol (request)      #ARP &lt;span&gt;请求包     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Hardware type: Ethernet (1)                                                            #&lt;span&gt;硬件类型     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Protocol type: IP (0x0800)                                                               #&lt;span&gt;协议类型     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Hardware size: 6                                                                             #&lt;span&gt;硬件地址     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Protocol size: 4                                                                               #&lt;span&gt;协议长度     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Opcode: request (1)                                                                       #&lt;span&gt;操作码。该值为&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;，表示是个&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求包     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Sender MAC address: 54:89:98:34:15:33 (54:89:98:34:15:33)     #&lt;span&gt;发送端&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Sender IP address: 192.168.1.2 (192.168.1.2)                              #&lt;span&gt;发送端&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Target MAC address: Broadcast (ff:ff:ff:ff:ff:ff)                                #&lt;span&gt;目标&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Target IP address: 192.168.1.3 (192.168.1.3)                               #&lt;span&gt;目标&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;&lt;span&gt;表&lt;/span&gt; 2-3  ARP&lt;span&gt;请求报文格式&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Ethernet(1)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IP(0x0800)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;196&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;238&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;request(1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;54:89:98:34:&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;15:33&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;192.168.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;ff:ff:&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;ff:ff:ff:ff&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;192.168.1.3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;3) ARP响应包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202004/1617215-20200422021654767-1197248760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;在图中的&lt;/span&gt; Packet Details &lt;span&gt;面板中，可以看到第二个数据包是一个&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;响应包。该包中的信息与&lt;/span&gt; &lt;span&gt;ARP&lt;/span&gt; &lt;span&gt;请求包的信息类似。但是也有几处不同。下面将详细介绍，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Frame 23: 60 bytes on wire (480 bits), 60 bytes captured (480 bits) on interface 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上信息表示这是第二个数据包的详细信息。其中，该包的大小为&lt;/span&gt; 60 &lt;span&gt;个字节。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;Ethernet II, Src: 54:89:98:5b:22:9b (54:89:98:5b:22:9b), Dst: 54:89:98:34:15:33 (54:89:98:34:15:33)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上内容是以太网帧头部的信息。其中，源&lt;/span&gt; MAC &lt;span&gt;地址为&lt;/span&gt; 54:89:98:5b:22:9b &lt;span&gt;，目标&lt;/span&gt; MAC &lt;span&gt;地址为&lt;/span&gt; 54:89:98:34:15:33&lt;span&gt;。从该行信息中，可以知道&lt;/span&gt; PC2 &lt;span&gt;获取到了&lt;/span&gt; &lt;span&gt;PC1&lt;/span&gt; &lt;span&gt;主机的&lt;/span&gt; &lt;span&gt;MAC&lt;/span&gt; &lt;span&gt;地址。 这样就可以正常通行了。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Address Resolution Protocol (reply)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   &lt;span&gt;以上内容表示这里一个&lt;/span&gt; ARP &lt;span&gt;响应包。该包中详细内容如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;Address Resolution Protocol (reply)&lt;/p&gt;
&lt;p&gt;   Hardware type: Ethernet (1)                                                                     #&lt;span&gt;硬件类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Protocol type: IP (0x0800)                                                                        #&lt;span&gt;协议类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Hardware size: 6                                                                                      #&lt;span&gt;硬件长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Protocol size: 4                                                                                        #&lt;span&gt;协议长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Opcode: reply (2)                                                                                     #&lt;span&gt;操作码为&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，表示该包是&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt;&lt;span&gt;响应包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Sender MAC address: 54:89:98:5b:22:9b (54:89:98:5b:22:9b)              #&lt;span&gt;发送发&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Sender IP address: 192.168.1.3 (192.168.1.3)                                       #&lt;span&gt;发送发&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Target MAC address: 54:89:98:34:15:33 (54:89:98:34:15:33)                #&lt;span&gt;目标&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Target IP address: 192.168.1.2 (192.168.1.2)                                         #&lt;span&gt;目标&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;&lt;span&gt;表&lt;/span&gt; 2-4  ARP&lt;span&gt;响应报文格式&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Ethernet(1)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;IP(0x0800)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;196&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;238&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;request(2)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;54:89:98:5b:&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;22:9b&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;192.168.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1.3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;330&quot;&gt;
&lt;p align=&quot;center&quot;&gt;54:89:&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;98:34:15:33&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;631&quot;&gt;
&lt;p align=&quot;center&quot;&gt;192.168.1.2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 21 Apr 2020 18:18:00 +0000</pubDate>
<dc:creator>Pluto_H</dc:creator>
<og:description>1. 什么是ARP ARP（Address Resolution Protocol）协议，即地址解析协议。该协议的功能就是将 IP 地 址解析成 MAC 地址。 ARP（Address Resolut</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CSAH/p/12749368.html</dc:identifier>
</item>
<item>
<title>Gradle系列之Groovy基础篇 - 躬行之</title>
<link>http://www.cnblogs.com/jzmanu/p/12749245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jzmanu/p/12749245.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文发于微信公众号 jzman-blog，欢迎关注交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇学习了 Gradle 的入门知识，Gradle 基于 Groovy，今天学习一下 Groovy 的基础知识，Groovy 是基于 JVM 虚拟机的一种动态语言，语法与 Java 语法类似，Groovy 完全兼容 Java，每个 Gradle 文件都是一个 Groovy 脚本文件，Gradle 文件基于 Groovy 语法，而 Groovy 又兼容 Java，故可以在 Gradle 文件中写 Java 代码，在此基础上增加了很多新特性，如支持闭包、DSL等，可以说 Groovy 是一门非常灵活的动态脚本语言，阅读本文之前可以先阅读下面这篇文章：&lt;/p&gt;
&lt;p&gt;下面针对 Gradle 来学习一下 Groovy 的一些基础知识。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;集合&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;JavaBean&lt;/li&gt;
&lt;li&gt;关于闭包&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;
&lt;p&gt;说一个 Groovy 的特性，在 Groovy 中分号不是必须的，其单引号是双引号都定义的是一个字符串常量，不同之处是单引号是纯粹的字符串常量，不会对该字符串里面的表达式做运算，而使用双引号定义的字符串常量可以使用合法表达式做相关运算，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task stringTest{
        //使用def关键字定义变量，
        def str1 = &quot;双引号&quot;
        def str2 = '单引号'
        
        println &quot;双引号定义的字符串：&quot;+str1
        println &quot;双引号定义的字符串：&quot;+str1.class
        println &quot;单引号定义的字符串：&quot;+str2
        
        //变量动态变化
        str1 = true;
        println &quot;双引号定义的字符串：&quot;+str1.class
        
        //使用$运算符
        println &quot;双引号定义的字符串：${str1}&quot;
        //只有一个变量的时候可以省去中括号
        println &quot;双引号定义的字符串：$str1&quot;
        
        //单引号定义的字符串不能使用表达式进行运算
        println '单引号定义的字符串：$str2'
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是执行结果，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy&amp;gt; gradle stringTest

&amp;gt; Configure project :
双引号定义的字符串：双引号
双引号定义的字符串：class java.lang.String
单引号定义的字符串：单引号
双引号定义的字符串：class java.lang.Boolean
双引号定义的字符串：true
双引号定义的字符串：true
单引号定义的字符串：$str2


BUILD SUCCESSFUL in 1s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合&quot;&gt;集合&lt;/h3&gt;
&lt;p&gt;Groovy 中也有集合的概念，主要看一下常用的 List、Map，下面将对 List 和 Map 常用操作进行介绍。&lt;/p&gt;
&lt;p&gt;那么如何在 Groovy 中定义 &lt;strong&gt;List&lt;/strong&gt; 呢，Groovy 中的 List 的定义方式类似于 Java 中的数组，具体操作参考下面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task list{
        //定义List
        def list = [1,2,3,4,5,6];
        def weekList = ['星期一','星期二','星期三','星期四','星期五','星期六','星期日'];
        println &quot;list的类型：&quot;+list.class
        println &quot;weekList的类型：&quot;+weekList.class
        
        //访问集合里面的元素
        println '第一个元素：'+list[0]//访问第一个元素
        println '第二个元素：'+list[1]//访问第二个元素，以此类推
        
        println '最后一个元素：'+list[-1]//访问最后一个元素
        println '倒数第二个元素：'+list[-2]//访问倒数第二个元素，以此类推
        println '某个范围内元素：'+list[2..4]//访问某个范围内元素，以此类推
        
        //使用each遍历集合中的元素
        weekList.each{
                //使用it作为迭代的元素变量，不能写错喔
                println it
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码的执行结果，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\ListMap&amp;gt; gradle list

&amp;gt; Configure project :
list的类型：class java.util.ArrayList
weekList的类型：class java.util.ArrayList
第一个元素：1
第二个元素：2
最后一个元素：6
倒数第二个元素：5
某个范围内元素：[3, 4, 5]
星期一
星期二
星期三
星期四
星期五
星期六
星期日


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何在 Groovy 中定义 &lt;strong&gt;Map&lt;/strong&gt; 呢，Groovy 中的 Map 当然也是键值对，具体定义及操作参考下面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task map{
        
        //定义Map
        def map = ['name':'Groovy', 'age':10];
        println &quot;map的类型：&quot;+map.getClass().name;
        
        //访问Map里面的元素
        println map.name;
        println map['name'];
        
        //遍历Map中的元素
        map.each{
                println &quot;Key:${it.key},value:${it.value}&quot;
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码的执行结果，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\ListMap&amp;gt; gradle map

&amp;gt; Configure project :
map的类型：java.util.LinkedHashMap
Groovy
Groovy
Key:name,value:Groovy
Key:age,value:10


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 Groovy 的集合就了解这么多。&lt;/p&gt;
&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;
&lt;p&gt;Groovy 中的方法和 Java 中的方法类似，只是写法上更加灵活，Groovy 中 return 不是必须的，在不写 return 的时候，Groovy 会将最后一句代码作为该方法的返回值。代码块指的是一段被花括号包围的代码，Groovy 中可将代码块作为一个参数进行传递，可以参考前面关于集合的遍历部分，参考代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task method{
        //方法调用
        methodA(1, 2)
        methodA 1, 2 
        
        //获取方法返回的结果
        def a = methodA 10, 20
        println '获取方法返回的结果：'+a
        
        //代码块作为参数传递
        def list = [1,2,3,4,5];
        list.each(
                //闭包参数
                {
                //      println it
                }
        )
        
        //Groovy规定，如果方法的最后一个参数是闭包，可以直接放到方法外面
        list.each(){
        //      println it
        }
        
        //简写方式
        list.each{
                println it
        }
}

//方法的定义
def methodA(int a, int b){
        println a + b
        //Groovy中return语句不是必须的，默认将最后一句代码的结果作为返回值
        a + b
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\Method&amp;gt; gradle method

&amp;gt; Configure project :
3
3
30
获取方法返回的结果：30
1
2
3
4
5


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;javabean&quot;&gt;JavaBean&lt;/h3&gt;
&lt;p&gt;Groovy 中的 JavaBean 相较 Java 中的比较灵活，可以直接使用 javaBean.属性的方式获取和修改 JavaBean 的属性值，无需使用相应的 Getter、Setter 方法，直接看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task javaBean{
        //Groovy中定义JavaBean
        Student student = new Student()
        student.name = &quot;Groovy&quot;
        student.age = 10
        
        student.setName(&quot;Gradle&quot;)
        println &quot;名字是：&quot;+student.name
        //不能调用Getter方法获取值
//      println &quot;名字是：&quot;+student.getName
        println &quot;年龄是：${student.age}&quot;
        println &quot;分数是：&quot;+student.score
}

class Student{
        private String name
        private int age
        //定义的Getter方法所对应的属性可以直接调用
        public String getScore(){
                100
        }
        
        //属性的Getter、Setter方法
        public String setName(String name){
                this.name = name
        }
        
        public void getName(){
                name
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码的执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\JavaBean&amp;gt; gradle javaBean

&amp;gt; Configure project :
名字是：Gradle
年龄是：10
分数是：100


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;闭包&quot;&gt;闭包&lt;/h3&gt;
&lt;p&gt;闭包是大多数脚本语言具有的一个特性，如 JavaScript、Groovy 等，闭包就是一个使用花括号包围的代码块，下面来学习 Groovy 中的闭包，主要有两部分：闭包及闭包参数传递和闭包委托。&lt;/p&gt;
&lt;h5 id=&quot;闭包及其参数传递&quot;&gt;闭包及其参数传递&lt;/h5&gt;
&lt;p&gt;下面来看一下如何定义一个闭包以及相关参数的传递，直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;task closure{
        //自定义闭包的执行
        mEach{
                println it
        }
        
        //向闭包传递参数
        mEachWithParams{m,n -&amp;gt; //m,n -&amp;gt;将闭包的参数和主体区分离开来
                println &quot;${m} is ${n}&quot;
        }
}

//1.定义一个方法，参数closure用于接收闭包
//2.闭包的执行就是花括号里面代码的执行
//3.闭包接收的参数就是闭包参数closure参数中的i，如果是一个参数默认就是it变量
def mEach(closure){
        for(int i in 1..5){
                closure(i)
        }
}

//向闭包传递参数
def mEachWithParams(closure){
        def map = [&quot;name&quot;:&quot;Groovy&quot;,&quot;age&quot;:10]
        map.each{
                closure(it.key, it.value)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中定义了闭包以及如何进行闭包的参数的传递，当闭包只有一个参数时，默认就是 it，反之闭包有多个参数时，就需要将参数定义出来，具体可参考上述代码，下面是执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\Closure&amp;gt; gradle delegate

&amp;gt; Configure project :
1
2
3
4
5
name is Groovy
age is 10

BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;闭包委托&quot;&gt;闭包委托&lt;/h4&gt;
&lt;p&gt;Groovy 闭包的强大之处在于它支持闭包方法的委托，Groovy 的闭包有三个属性：thisObject、owner、delegate，当在一个闭包中调用定义的方法时，由这三个属性来确定该方法由哪个对象来执行，默认 owner 和 delegate 是相等的，其中 delete 是可以被修改的，Gradle 中闭包的很多功能都是通过修改 delegate 来实现的。下面通过定义一个闭包以及方法，通过打印来说明这三个属性的一些区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;//闭包的委托
task delegate{
        new Delegate().test{
                //Groovy闭包的三个属性：thisObject、owner、delegate
                println &quot;thisObject:${thisObject.getClass()}&quot;
                println &quot;owner:${owner.getClass()}&quot;
                println &quot;delegate:${delegate.getClass()}&quot;
                
                //闭包默认it
                println &quot;闭包默认it:&quot;+it.getClass()
                
                //定义的方法，优先使用thisObject来处理
                method()
                //闭包中的方法
                it.method()
        }
}

def method(){
        println &quot;mththod in root:${this.getClass()}&quot;
}

class Delegate{
        def method(){
                println &quot;mththod in Delegate:${this.getClass()}&quot;
        }
        
        //闭包
        def test(Closure&amp;lt;Delegate&amp;gt; closure){
                closure(this);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码的执行结果，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\Closure&amp;gt; gradle delegate

&amp;gt; Configure project :

thisObject:class build_3ajca04o1rprxygcsq0ajvt7i
owner:class build_3ajca04o1rprxygcsq0ajvt7i$_run_closure2
delegate:class build_3ajca04o1rprxygcsq0ajvt7i$_run_closure2
闭包默认it:class Delegate
mththod in root:class build_3ajca04o1rprxygcsq0ajvt7i
mththod in Delegate:class Delegate


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当在闭包中调用方法 method() 时，发现是 thisObject 调用了 method() 方法，而不是 owner 或 delegate，说明闭包中优先使用 thisObject 来处理方法的执行，同时可以看到 owner 和 delegate 是一致的，但是 owner 比 delegate 的优先级要高，所以闭包中方法的处理顺序是：thisObject &amp;gt; owner &amp;gt; delegate。&lt;/p&gt;
&lt;p&gt;Gradle 中一般会指定 delegate 为当前的 it，这样我们将可以通过 delegate 指定的对象来操作 it 了，下面指定闭包的 delegate 并设置委托优先，让委托的具体对象来执行其方法，下面是测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-groovy&quot;&gt;
task student{
        configStudent{
                println &quot;当前it：${it}&quot;
                
                name = &quot;Groovy&quot;
                age = 10
                getInfo()
        }
}

class Student{
        String name
        int age
        def getInfo(){
                println &quot;name is ${name}, age is ${age}&quot;
        }
}

def configStudent(Closure&amp;lt;Student&amp;gt; closure){
        Student student = new Student()
        //设置委托对象为当前创建的Student实例
        closure.delegate = student
        //设置委托模式优先，如果不设置闭包内方法的处理者是thisObject
        closure.setResolveStrategy(Closure.DELEGATE_FIRST)
        //设置it变量
        closure(student)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上述代码的执行结果，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS E:\Gradle\study\Groovy\Closure&amp;gt; gradle student

&amp;gt; Configure project :

当前it：Student@18f6d755
name is Groovy, age is 10


BUILD SUCCESSFUL in 2s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;学习 Groovy 的目的还是为了加深对 Gradle 构建工具的理解，上面通过五个方面对 Groovy 有了初步的人认识，后续如果有需要在看 Groovy 的高级用法。&lt;/p&gt;
&lt;p&gt;如果感兴趣，可以关注公众号：躬行之(jzman-blog)，一起交流学习。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202004/758808-20200422004241086-1564414170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 16:46:00 +0000</pubDate>
<dc:creator>躬行之</dc:creator>
<og:description>原文发于微信公众号 jzman blog，欢迎关注交流。 上一篇学习了 Gradle 的入门知识，Gradle 基于 Groovy，今天学习一下 Groovy 的基础知识，Groovy 是基于 JVM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jzmanu/p/12749245.html</dc:identifier>
</item>
<item>
<title>java对象头信息和三种锁的性能对比 - 路仁甲</title>
<link>http://www.cnblogs.com/lusaisai/p/12748869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lusaisai/p/12748869.html</guid>
<description>&lt;h2&gt;java头的信息分析&lt;/h2&gt;
&lt;p&gt;首先为什么我要去研究java的对象头呢？ 这里截取一张hotspot的源码当中的注释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421223544052-1917050934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 这张图换成可读的表格如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
|--------------------------------------------------------------------------------------------------------------|
|                                              Object Header (&lt;span&gt;128&lt;/span&gt; bits)                                        |
|--------------------------------------------------------------------------------------------------------------|
|                        Mark Word (&lt;span&gt;64&lt;/span&gt; bits)                                    |      Klass Word (&lt;span&gt;64&lt;/span&gt; bits)    |       
|--------------------------------------------------------------------------------------------------------------|
|  unused:&lt;span&gt;25&lt;/span&gt; | identity_hashcode:&lt;span&gt;31&lt;/span&gt; | unused:&lt;span&gt;1&lt;/span&gt; | age:&lt;span&gt;4&lt;/span&gt; | biased_lock:&lt;span&gt;1&lt;/span&gt; | &lt;span&gt;lock&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; |     OOP to metadata &lt;span&gt;object&lt;/span&gt;   |&lt;span&gt;  无锁
&lt;/span&gt;|----------------------------------------------------------------------|--------|------------------------------|
|  thread:&lt;span&gt;54&lt;/span&gt; |         epoch:&lt;span&gt;2&lt;/span&gt;      | unused:&lt;span&gt;1&lt;/span&gt; | age:&lt;span&gt;4&lt;/span&gt; | biased_lock:&lt;span&gt;1&lt;/span&gt; | &lt;span&gt;lock&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; |     OOP to metadata &lt;span&gt;object&lt;/span&gt;   |&lt;span&gt;  偏向锁
&lt;/span&gt;|----------------------------------------------------------------------|--------|------------------------------|
|                     ptr_to_lock_record:&lt;span&gt;62&lt;/span&gt;                            | &lt;span&gt;lock&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; |     OOP to metadata &lt;span&gt;object&lt;/span&gt;   |&lt;span&gt;  轻量锁
&lt;/span&gt;|----------------------------------------------------------------------|--------|------------------------------|
|                     ptr_to_heavyweight_monitor:&lt;span&gt;62&lt;/span&gt;                    | &lt;span&gt;lock&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; |     OOP to metadata &lt;span&gt;object&lt;/span&gt;   |&lt;span&gt;  重量锁
&lt;/span&gt;|----------------------------------------------------------------------|--------|------------------------------|
|                                                                      | &lt;span&gt;lock&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt; |     OOP to metadata &lt;span&gt;object&lt;/span&gt;   |&lt;span&gt;    GC
&lt;/span&gt;|--------------------------------------------------------------------------------------------------------------|
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是java的对象头在对象的不同状态下会有不同的表现形式，主要有三种状态，无锁状态、加锁状态、gc标记状态。&lt;/p&gt;
&lt;p&gt;那么我可以理解java当中的取锁其实可以理解是给对象上锁，也就是改变对象头的状态，如果上锁成功则进入同步代码块。&lt;/p&gt;
&lt;p&gt;但是java当中的锁有分为很多种，从上图可以看出大体分为偏向锁、轻量锁、重量锁三种锁状态。&lt;/p&gt;
&lt;p&gt;这三种锁的效率 完全不同、关于效率的分析会在下文分析，我们只有合理的设计代码，才能合理的利用锁、那么这三种锁的原理是什么? 所以我们需要先研究这个对象头。&lt;/p&gt;
&lt;h3&gt;java对象的布局以及对象头的布局&lt;/h3&gt;
&lt;p&gt;使用JOL来分析java的对象布局,添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.openjdk.jol&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jol-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JOLExample1 {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;  B b = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jvm的信息&lt;/span&gt;
&lt;span&gt;        out.println(VM.current().details());
        out.println(ClassLayout.parseInstance(b).toPrintable());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421225942187-1885404136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 分析结果1:整个对象一共16B，其中对象头（Object header）12B，还有4B是对齐的字节（因为在64位虚拟机上对象的大小必 须是8的倍数）,&lt;/p&gt;
&lt;p&gt;由于这个对象里面没有任何字段，故而对象的实例数据为0B？&lt;/p&gt;
&lt;p&gt;两个问题&lt;/p&gt;
&lt;p&gt;1、什么叫做对象的实例数据呢？&lt;/p&gt;
&lt;p&gt;2、那么对象头里面的12B到底存的是什么呢？&lt;/p&gt;
&lt;p&gt;首先要明白什么对象的实例数据很简单，我们可以在B当中添加一个boolean的字段，大家都知道boolean字段占 1B，然后再看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421230851372-1749012285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 整个对象的大小还是没有改变一共16B，其中对象头（Object header）12B，boolean字段flag（对象的实例数据）占 1B、剩下的3B就是对齐字节。&lt;/p&gt;
&lt;p&gt;由此我们可以认为一个对象的布局大体分为三个部分分别是:对象头（Object header）、 对象的实例数据和字节对齐&lt;/p&gt;

&lt;p&gt;接下来讨论第二个问题，对象头为什么是12B？这个12B当中分别存储的是什么呢？（不同位数的VM对象头的长度不一 样，这里指的是64bit的vm）&lt;/p&gt;
&lt;p&gt;首先引用openjdk文档当中对对象头的解释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231021465-443060021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上述引用中提到一个java对象头包含了2个word，并且好包含了堆对象的布局、类型、GC状态、同步状态和标识哈 希码，具体怎么包含的呢？又是哪两个word呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231050652-1832572073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; mark word为第一个word根据文档可以知他里面包含了锁的信息，hashcode，gc信息等等，第二个word是什么 呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231106848-636595977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;klass word为对象头的第二个word主要指向对象的元数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231136032-1175815404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;假设我们理解一个对象头主要上图两部分组成（数组对象除外，数组对象的对象头还包含一个数组长度），&lt;/p&gt;
&lt;p&gt;那么 一个java的对象头多大呢？我们从JVM的源码注释中得知到一个mark word一个是64bit，那么klass的长度是多少呢？&lt;/p&gt;
&lt;p&gt;所以我们需要想办法来获得java对象头的详细信息，验证一下他的大小，验证一下里面包含的信息是否正确。&lt;/p&gt;
&lt;p&gt;根据上述利用JOL打印的对象头信息可以知道一个对象头是12B，其中8B是mark word 那么剩下的4B就是klass word了，和锁相关的就是mark word了，&lt;/p&gt;
&lt;p&gt;那么接下来重点分析mark word里面信息 在无锁的情况下markword当中的前56bit存的是对象的hashcode，那么来验证一下&lt;/p&gt;
&lt;p&gt;先上代码:手动计算HashCode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashUtil {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; countHash(Object object) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchFieldException, IllegalAccessException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手动计算HashCode&lt;/span&gt;
        Field field = Unsafe.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;theUnsafe&quot;&lt;span&gt;);
        field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        Unsafe unsafe &lt;/span&gt;= (Unsafe) field.get(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; hashCode = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt; index = 7; index &amp;gt; 0; index--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取Mark Word中的每一个Byte进行计算&lt;/span&gt;
            hashCode |= (unsafe.getByte(object, index) &amp;amp; 0xFF) &amp;lt;&amp;lt; ((index - 1) * 8&lt;span&gt;);
        }
        String code &lt;/span&gt;=&lt;span&gt; Long.toHexString(hashCode);
        System.out.println(&lt;/span&gt;&quot;util-----------0x&quot;+&lt;span&gt;code);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JOLExample2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        B b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
        out.println(&lt;/span&gt;&quot;befor hash&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有计算HASHCODE之前的对象头&lt;/span&gt;
&lt;span&gt;        out.println(ClassLayout.parseInstance(b).toPrintable());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JVM 计算的hashcode&lt;/span&gt;
        out.println(&quot;jvm------------0x&quot;+&lt;span&gt;Integer.toHexString(b.hashCode()));
        HashUtil.countHash(b);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当计算完hashcode之后，我们可以查看对象头的信息变化&lt;/span&gt;
        out.println(&quot;after hash&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(b).toPrintable());

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231342587-1811425078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 分析结果3：&lt;/p&gt;
&lt;p&gt;1-----上面没有进行hashcode之前的对象头信息，可以看到的56bit没有值，打印完hashcode之后就有值了，为什 么是1-7B，不是0-6B呢？因为是&lt;strong&gt;小端存储&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中两行是我们通过hashcode方法打印的结果，第一行是我根据1-7B的信息计算出来的 hashcode，所以可以确定java对象头当中的mark work里面的后七个字节存储的是hashcode信息，&lt;/p&gt;
&lt;p&gt;那么第一个字节当中的八位分别存的 就是分带年龄、偏向锁信息，和对象状态，这个8bit分别表示的信息如下图（其实上图也有信息），这个图会随着对象状态改变而改变， 下图是无锁状态下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421231907446-1781872631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 关于对象状态一共分为五种状态，分别是无锁、偏向锁、轻量锁、重量锁、GC标记，&lt;/p&gt;
&lt;p&gt;那么2bit，如何能表示五种状 态（2bit最多只能表示4中状态分别是：00,01,10,11），&lt;/p&gt;
&lt;p&gt;jvm做的比较好的是把偏向锁和无锁状态表示为同一个状态，然 后根据图中偏向锁的标识再去标识是无锁还是偏向锁状态。&lt;/p&gt;
&lt;p&gt;什么意思呢？写个代码分析一下，&lt;strong&gt;在写代码之前我们先记得 无锁状态下的信息00000001&lt;/strong&gt;，然后写一个偏向锁的例子看看结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public static void main(String[] args) throws Exception {&lt;br/&gt;//-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0&lt;br/&gt;B b = new B();&lt;br/&gt;out.println(&quot;befor lock&quot;);&lt;br/&gt;out.println(ClassLayout.parseInstance(b).toPrintable());&lt;br/&gt;synchronized (b){&lt;br/&gt;out.println(&quot;lock ing&quot;);&lt;br/&gt;out.println(ClassLayout.parseInstance(b).toPrintable());&lt;br/&gt;}&lt;br/&gt;out.println(&quot;after lock&quot;);&lt;br/&gt;out.println(ClassLayout.parseInstance(b).toPrintable());&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421234117980-658020208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 上面这个程序只有一个线程去调用sync方法，故而讲道理应该是偏向锁，但是此时却是轻量级锁&lt;/p&gt;
&lt;p&gt;而且你会发现最后输出的结果（第一个字节）依 然是00000001和无锁的时候一模一样，其实这是因为虚拟机在启动的时候对于偏向锁有延迟，&lt;/p&gt;
&lt;p&gt;比如把上述代码当中加上 睡眠5秒的代码,结果就会不一样了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0&lt;/span&gt;
        Thread.sleep(5000&lt;span&gt;);
        B b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
        out.println(&lt;/span&gt;&quot;befor lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(b).toPrintable());
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (b){
            out.println(&lt;/span&gt;&quot;lock ing&quot;&lt;span&gt;);
            out.println(ClassLayout.parseInstance(b).toPrintable());
        }
        out.println(&lt;/span&gt;&quot;after lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(b).toPrintable());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421234617416-294283078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;结果变成00000101.当然为了方便测试我们也可以直接通过JVM的参数来禁用延迟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421234725981-1440154863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 结果是和睡眠5秒一样的.&lt;/p&gt;
&lt;p&gt;想想为什么偏向锁会延迟？因为启动程序的时候,jvm会有很多操作,包括gc等等,jvm刚运行时存在大量的同步方法,很多都不是偏向锁,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而偏向锁升级为轻/重量级锁的很费时间和资源,因此jvm会延迟4秒左右再开启偏向锁.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么为什么同步之前就是偏向锁呢?我猜想是jvm的原因,目前还不清楚.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的after lock，退出同步后依然保持了偏向信息&lt;/p&gt;

&lt;p&gt;然后看下轻量级锁的对象头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; A a;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();
        out.println(&lt;/span&gt;&quot;befre lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a){
            out.println(&lt;/span&gt;&quot;lock ing&quot;&lt;span&gt;);
            out.println(ClassLayout.parseInstance(a).toPrintable());
        }
        out.println(&lt;/span&gt;&quot;after lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422000927809-1441260057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;关于重量锁首先看对象头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; A a;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.sleep(5000);&lt;/span&gt;
        a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();
        out.println(&lt;/span&gt;&quot;befre lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无锁&lt;/span&gt;
&lt;span&gt;
        Thread t1&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
                        System.out.println(&lt;/span&gt;&quot;t1 release&quot;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t1.start();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        out.println(&lt;/span&gt;&quot;t1 lock ing&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轻量锁&lt;/span&gt;
&lt;span&gt;        sync();
        out.println(&lt;/span&gt;&quot;after lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重量锁&lt;/span&gt;
&lt;span&gt;        System.gc();
        out.println(&lt;/span&gt;&quot;after gc()&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无锁---gc&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; sync() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a){
            System.out.println(&lt;/span&gt;&quot;t1 main lock&quot;&lt;span&gt;);
            out.println(ClassLayout.parseInstance(a).toPrintable());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重量锁&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422001348724-1424237835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422002937449-982312420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt; 由上述实验可总结下图:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200421235848347-1757739244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse(){
        i&lt;/span&gt;++&lt;span&gt;;
        
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JOLExample6.countDownLatch.countDown();&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行1000000000L次++操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JOLExample4 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        A a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用同步方法1000000000L 来计算1000000000L的++，对比偏向锁和轻量级锁的性能
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不出意外，结果灰常明显&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;1000000000L;i++&lt;span&gt;){
            a.parse();
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
        System.out.println(String.format(&lt;/span&gt;&quot;%sms&quot;, end -&lt;span&gt; start));

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时根据上面的测试可知是轻量级锁,看下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422000159049-419098568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 大概16秒&lt;/p&gt;

&lt;p&gt;然后我们让偏向锁启动无延时,在启动一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422000400786-1385525199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 只需要2秒,速度提升了很多&lt;/p&gt;

&lt;p&gt;再看下重量级锁的时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(1000000000&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; A a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用同步方法1000000000L 来计算1000000000L的++，对比偏向锁和轻量级锁的性能
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不出意外，结果灰常明显&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;2;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (countDownLatch.getCount() &amp;gt; 0&lt;span&gt;) {
                        a.parse();
                    }
                }
            }.start();
        }
        countDownLatch.await();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
        System.out.println(String.format(&lt;/span&gt;&quot;%sms&quot;, end -&lt;span&gt; start));

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下结果,大概31秒,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422002019218-1049130859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看出三种锁的消耗是差距很大的,这也是1.5以后synchronized优化的意义&lt;/p&gt;
&lt;h3&gt; 需要注意的是如果对象已经计算了hashcode就不能偏向了&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; A a;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        a&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();
        a.hashCode();
        out.println(&lt;/span&gt;&quot;befor lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (a){
            out.println(&lt;/span&gt;&quot;lock ing&quot;&lt;span&gt;);
            out.println(ClassLayout.parseInstance(a).toPrintable());
        }
        out.println(&lt;/span&gt;&quot;after lock&quot;&lt;span&gt;);
        out.println(ClassLayout.parseInstance(a).toPrintable());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202004/1671142-20200422001939600-1616216571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 Apr 2020 16:22:00 +0000</pubDate>
<dc:creator>路仁甲</dc:creator>
<og:description>java头的信息分析 首先为什么我要去研究java的对象头呢？ 这里截取一张hotspot的源码当中的注释 这张图换成可读的表格如下 | | | Object Header (128 bits) |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lusaisai/p/12748869.html</dc:identifier>
</item>
<item>
<title>一道简单的SQL注入题 - hikonaka</title>
<link>http://www.cnblogs.com/wangyanzhong123/p/12748192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangyanzhong123/p/12748192.html</guid>
<description>&lt;p&gt;这是我真正意义上来说做的第一道SQL题目，感觉从这个题目里还是能学到好多东西的，这里记录一下这个题目的writeup和在其中学到的东西&lt;br/&gt;&lt;code&gt;link&lt;/code&gt;:&lt;a href=&quot;https://www.ichunqiu.com/battalion&quot;&gt;https://www.ichunqiu.com/battalion&lt;/a&gt; Web分类下的SQL&lt;/p&gt;

&lt;p&gt;进入这个模拟环境之后，会得到一个提示为flag在数据库中，这时候查看url栏可以发现&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421213512443-2115045877.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;嗯这个就有SQL注入内味了，然后试一下id=2或者id=3，发现id=2时候可以出来提示为test，然后再往后就什么都不出来了，这时候我先假装id后面的东西是一个数字变量，输入&lt;code&gt;id=1 and 1=1&lt;/code&gt;，发现网页给出提示是这是SQL注入代码，这说明这个网站是有对SQL注入做基本的防护的，所以现在的问题就变成了如何绕过服务器的过滤规则。&lt;/p&gt;
&lt;h2 id=&quot;对过滤or、and、xor、not的绕过&quot;&gt;对过滤or、and、xor、not的绕过&lt;/h2&gt;
&lt;p&gt;对这些的绕过一般的操作是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;and = &amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;or = ||&lt;/li&gt;
&lt;li&gt;xor = | # 异或&lt;/li&gt;
&lt;li&gt;not = !&lt;br/&gt;现在我们换一下把输入变成&lt;code&gt;id=1 &amp;amp;&amp;amp; 1=1&lt;/code&gt;，发现并没有报错，这说明我们成功进行了注入的第一步。这时候我们可以发现，很有可能该数据库仅对我们展示了表中某一列的数据，所以现在就要判断这个表到底有几列，这里使用的方法是&lt;code&gt;order by&lt;/code&gt;。url里输入&lt;code&gt;id=1 order by 1&lt;/code&gt;，报错提示这是sql注入代码，所以现在要进行进一步的绕过&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sql关键字过滤绕过&quot;&gt;SQL关键字过滤绕过&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;改变大小写：例如&lt;code&gt;select&lt;/code&gt;变为&lt;code&gt;SELect&lt;/code&gt;（本题中没用）&lt;/li&gt;
&lt;li&gt;添加内联注释：把一些MYSQL的语句放在&lt;code&gt;/*!...*/&lt;/code&gt;中，例如&lt;code&gt;/*!order*/&lt;/code&gt;（本题中没用）&lt;/li&gt;
&lt;li&gt;双写关键字：一些waf中替换使用的是&lt;code&gt;replace()&lt;/code&gt;函数，因此可以输入&lt;code&gt;selselectect&lt;/code&gt;，在经过waf处理后变为&lt;code&gt;select&lt;/code&gt;（本题中没用）&lt;/li&gt;
&lt;li&gt;空格过滤绕过：有些waf会过滤掉注入中的空格导致无法正常允许，这里可以把空格用&lt;code&gt;/**/&lt;/code&gt;,&lt;code&gt;反单引号&lt;/code&gt;,&lt;code&gt;()&lt;/code&gt;,&lt;code&gt;回车&lt;/code&gt;等进行代替（本题中暂时不用考虑）&lt;/li&gt;
&lt;li&gt;等号绕过：使用like和rlike模拟=的功能，在不添加通配符%时候，&lt;code&gt;like xxx&lt;/code&gt;和&lt;code&gt;rlike xxx&lt;/code&gt;和&lt;code&gt;= xxx&lt;/code&gt;是等价的（本题中暂不用考虑）&lt;/li&gt;
&lt;li&gt;添加&amp;lt;&amp;gt;或者/&lt;strong&gt;/：因为有的waf会对&amp;lt;&amp;gt;或/&lt;/strong&gt;/进行过滤，所里可以利用这一点，使用&lt;code&gt;sel&amp;lt;&amp;gt;ect&lt;/code&gt;进行绕过（本题有用）&lt;br/&gt;现在进行分割，注意分割时候&lt;code&gt;order&lt;/code&gt;不要分割为了&lt;code&gt;or&amp;lt;&amp;gt;der&lt;/code&gt;因为这样又会引入&lt;code&gt;or&lt;/code&gt;，现在我们输入&lt;code&gt;ord&amp;lt;&amp;gt;er by x&lt;/code&gt;进行尝试，发现最多到&lt;code&gt;order by 3&lt;/code&gt;就停止了，这说明这个表只有3列。现在我们就需要找出具体的flag位置，这就涉及到对mysql数据库结构的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mysql数据库&quot;&gt;MYSQL数据库&lt;/h2&gt;
&lt;p&gt;Mysql数据库里面有一个数据库叫information_schema，这个数据库中很多有用的信息都存在这个里面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;schemata表里面存储了不同数据库的信息，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421231836998-2094202124.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;tables表里面存储着每个数据库中包含的所有的表的信息，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421232220708-1539825056.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;columns表里面存储着每个数据库中列的信息，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421232458700-938802.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;查看数据库信息&quot;&gt;查看数据库信息&lt;/h2&gt;
&lt;p&gt;知道这些东西之后，我们现在要找flag，我认为flag多半是在这个数据库里面，首先我们查看一下当先数据库的名称，因为已知查询到的数据是3列，现在我们要计算，输出在前端的到底是哪一列的数据，这里我们构造一个payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,2,3&lt;/code&gt;，发现输出的有2，那么可以肯定输出在前端的就是第二列。&lt;br/&gt;现在我们想要知道这个表在哪个数据库，所以就可以构造一个payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,database(),3&lt;/code&gt;，得到前端的返回结果为&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421233305097-1741186500.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;现在我们就要查找这个sqli数据库中存在哪些表，在前面我们说过，表的信息存在tables中，所以这里构造一个payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,table_name,3 from information_schema.tables whe&amp;lt;&amp;gt;re table_schema='sqli'&lt;/code&gt;，然后可以得到该数据库中有两张表，一个是info，一个是users&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421233722690-1947554946.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;现在我们分别查一下这两个表里面都有哪些列，信息从columns里面查到，这时候我们可以构造payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,column_name,3 from information_schema.columns where table_schema='sqli' an&amp;lt;&amp;gt;d table_name='users'&lt;/code&gt;和&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,column_name,3 from information_schema.columns where table_schema='sqli' an&amp;lt;&amp;gt;d table_name='info'&lt;/code&gt;，分别如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421234339695-515384386.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421234357175-348482626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;找到flag&quot;&gt;找到flag&lt;/h2&gt;
&lt;p&gt;好吧看了一下列名称，竟然都有flag这个东西，那只能一个表一个表找了，首先找一下第一个表&lt;code&gt;users&lt;/code&gt;，这时候我们可以构造payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,flag_9c861b688330,3 fr&amp;lt;&amp;gt;om users&lt;/code&gt;，但是发现并出不来任何东西。。感到疑惑，好吧那就试下一个构造payload为&lt;code&gt;?id=1 un&amp;lt;&amp;gt;ion sel&amp;lt;&amp;gt;ect 1,flAg_T5ZNdrm,3 fr&amp;lt;&amp;gt;om info&lt;/code&gt;,这时候出来结果了，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1619893/202004/1619893-20200421235724999-1626930863.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;然后复制这个flag交差，就ok啦！&lt;/p&gt;

&lt;p&gt;这是第一次做sql注入的题，虽然这个题比较简单，但是总的来说我还是学到了不少东西的，比如Mysql数据库中的表结构和sql注入的绕过等，我觉得还是很有教育意义的。&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 16:12:00 +0000</pubDate>
<dc:creator>hikonaka</dc:creator>
<og:description>这是我真正意义上来说做的第一道SQL题目，感觉从这个题目里还是能学到好多东西的，这里记录一下这个题目的writeup和在其中学到的东西 :https://www.ichunqiu.com/battal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangyanzhong123/p/12748192.html</dc:identifier>
</item>
<item>
<title>引用传参与reference_wrapper - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12747850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12747850.html</guid>
<description>&lt;p&gt;本文是&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/functional_implementation.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;系列&lt;/a&gt;的第3篇。&lt;/p&gt;
&lt;h3 id=&quot;引用传参&quot;&gt;引用传参&lt;/h3&gt;
&lt;p&gt;我有一个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void modify(int&amp;amp; i)
{
    ++i;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为参数类型是&lt;code&gt;int&amp;amp;&lt;/code&gt;，所以函数能够修改传入的整数，而非其拷贝。&lt;/p&gt;
&lt;p&gt;然后我用&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12633621.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;std::bind&lt;/code&gt;&lt;/a&gt;把它和一个&lt;code&gt;int&lt;/code&gt;绑定起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int i = 1;
auto f = std::bind(modify, i);
f();
std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是&lt;code&gt;i&lt;/code&gt;还是&lt;code&gt;1&lt;/code&gt;，为什么呢？原来&lt;code&gt;std::bind&lt;/code&gt;会把所有参数都拷贝，即使它是个左值引用。所以&lt;code&gt;modify&lt;/code&gt;中修改的变量，实际上是&lt;code&gt;std::bind&lt;/code&gt;返回的函数对象中的一个&lt;code&gt;int&lt;/code&gt;，并非原来的&lt;code&gt;i&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们需要&lt;code&gt;std::reference_wrapper&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int j = 1;
auto g = std::bind(modify, std::ref(j));
g();
std::cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;std::ref(j)&lt;/code&gt;返回的就是&lt;code&gt;std::reference_wrapper&amp;lt;int&amp;gt;&lt;/code&gt;对象。&lt;/p&gt;
&lt;h3 id=&quot;reference_wrapper&quot;&gt;reference_wrapper&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;std::reference_wrapper&lt;/code&gt;及其辅助函数大致长成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename T&amp;gt;
class reference_wrapper
{
public:
    template&amp;lt;typename U&amp;gt;
    reference_wrapper(U&amp;amp;&amp;amp; x) : ptr(std::addressof(x)) { }
    
    reference_wrapper(const reference_wrapper&amp;amp;) noexcept = default;
    reference_wrapper&amp;amp; operator=(const reference_wrapper&amp;amp; x) noexcept = default;
 
    constexpr operator T&amp;amp; () const noexcept { return *ptr; }
    constexpr T&amp;amp; get() const noexcept { return *ptr; }
 
    template&amp;lt;typename... Args&amp;gt;
    auto operator()(Args&amp;amp;&amp;amp;... args) const
    {
        return get()(std::forward&amp;lt;Args&amp;gt;(args)...);
    }
    
private:
    T* ptr;
};

template&amp;lt;typename T&amp;gt;
reference_wrapper&amp;lt;T&amp;gt; ref(T&amp;amp; t) noexcept
{
    return reference_wrapper&amp;lt;T&amp;gt;(t);
}
template&amp;lt;typename T&amp;gt;
reference_wrapper&amp;lt;T&amp;gt; ref(reference_wrapper&amp;lt;T&amp;gt; t) noexcept
{
    return t;
}
template&amp;lt;typename T&amp;gt;
void ref(const T&amp;amp;&amp;amp;) = delete;

template&amp;lt;typename T&amp;gt;
reference_wrapper&amp;lt;const T&amp;gt; cref(const T&amp;amp; t) noexcept
{
    return reference_wrapper&amp;lt;const T&amp;gt;(t);
}
template&amp;lt;typename T&amp;gt;
reference_wrapper&amp;lt;const T&amp;gt; cref(reference_wrapper&amp;lt;T&amp;gt; t) noexcept
{
    return reference_wrapper&amp;lt;const T&amp;gt;(t.get());
}
template&amp;lt;typename T&amp;gt;
void cref(const T&amp;amp;&amp;amp;) = delete;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，&lt;code&gt;std::reference_wrapper&lt;/code&gt;不过是包装一个指针罢了。它重载了&lt;code&gt;operator T&amp;amp;&lt;/code&gt;，对象可以隐式转换回原来的引用；它还重载了&lt;code&gt;operator()&lt;/code&gt;，包装函数对象时可以直接使用函数调用运算符；调用其他成员函数时，要先用&lt;code&gt;get&lt;/code&gt;方法获得其内部的引用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::reference_wrapper&lt;/code&gt;的意义在于：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;引用不是对象，不存在引用的引用、引用的数组等，但&lt;code&gt;std::reference_wrapper&lt;/code&gt;是，使得定义引用的容器成为可能；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;模板函数无法辨别你在传入左值引用时的意图是传值还是传引用，&lt;code&gt;std::ref&lt;/code&gt;和&lt;code&gt;std::cref&lt;/code&gt;告诉那个模板，你要传的是引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;尽管&lt;code&gt;std::reference_wrapper&lt;/code&gt;的简单（但是不完整的）实现可以在50行以内完成，GCC的标准库为了实现一个完美的&lt;code&gt;std::reference_wrapper&lt;/code&gt;还是花了300多行（还不包括&lt;code&gt;std::invoke&lt;/code&gt;），其中200多行是为了定义&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;和&lt;code&gt;second_argument_type&lt;/code&gt;这几个在C++17中废弃、C++20中移除的成员类型。如果你是在C++20完全普及以后读到这篇文章的，就当考古来看吧！&lt;/p&gt;
&lt;h4 id=&quot;继承成员类型&quot;&gt;继承成员类型&lt;/h4&gt;
&lt;p&gt;定义这些类型所用的工具是继承，一种特殊的、没有“is-a”含义的&lt;code&gt;public&lt;/code&gt;继承。以&lt;code&gt;_Maybe_unary_or_binary_function&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename _Arg, typename _Result&amp;gt;
  struct unary_function
  {
    typedef _Arg      argument_type;   
    typedef _Result   result_type;  
  };

template&amp;lt;typename _Arg1, typename _Arg2, typename _Result&amp;gt;
  struct binary_function
  {
    typedef _Arg1     first_argument_type; 
    typedef _Arg2     second_argument_type;
    typedef _Result   result_type;
  };

template&amp;lt;typename _Res, typename... _ArgTypes&amp;gt;
  struct _Maybe_unary_or_binary_function { };

template&amp;lt;typename _Res, typename _T1&amp;gt;
  struct _Maybe_unary_or_binary_function&amp;lt;_Res, _T1&amp;gt;
  : std::unary_function&amp;lt;_T1, _Res&amp;gt; { };

template&amp;lt;typename _Res, typename _T1, typename _T2&amp;gt;
  struct _Maybe_unary_or_binary_function&amp;lt;_Res, _T1, _T2&amp;gt;
  : std::binary_function&amp;lt;_T1, _T2, _Res&amp;gt; { };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后&lt;code&gt;std::function&amp;lt;Res(Args...)&amp;gt;&lt;/code&gt;去继承&lt;code&gt;_Maybe_unary_or_binary_function&amp;lt;Res, Args...&amp;gt;&lt;/code&gt;：当&lt;code&gt;sizeof...(Args) == 1&lt;/code&gt;时继承到&lt;code&gt;std::unary_function&lt;/code&gt;，定义&lt;code&gt;argument_type&lt;/code&gt;；当&lt;code&gt;sizeof...(Args) == 2&lt;/code&gt;时继承到&lt;code&gt;std::binary_function&lt;/code&gt;，定义&lt;code&gt;first_argument_type&lt;/code&gt;和&lt;code&gt;second_argument_type&lt;/code&gt;；否则继承一个空的&lt;code&gt;_Maybe_unary_or_binary_function&lt;/code&gt;，什么定义都没有。&lt;/p&gt;
&lt;p&gt;各种模板技巧，tag dispatching、SFINAE等，面对这种需求都束手无策，只有继承管用。&lt;/p&gt;
&lt;h4 id=&quot;成员函数特征&quot;&gt;成员函数特征&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename _Signature&amp;gt;
  struct _Mem_fn_traits;

template&amp;lt;typename _Res, typename _Class, typename... _ArgTypes&amp;gt;
  struct _Mem_fn_traits_base
  {
    using __result_type = _Res;
    using __maybe_type
      = _Maybe_unary_or_binary_function&amp;lt;_Res, _Class*, _ArgTypes...&amp;gt;;
    using __arity = integral_constant&amp;lt;size_t, sizeof...(_ArgTypes)&amp;gt;;
  };

#define _GLIBCXX_MEM_FN_TRAITS2(_CV, _REF, _LVAL, _RVAL)                \
  template&amp;lt;typename _Res, typename _Class, typename... _ArgTypes&amp;gt;       \
    struct _Mem_fn_traits&amp;lt;_Res (_Class::*)(_ArgTypes...) _CV _REF&amp;gt;      \
    : _Mem_fn_traits_base&amp;lt;_Res, _CV _Class, _ArgTypes...&amp;gt;               \
    {                                                                   \
      using __vararg = false_type;                                      \
    };                                                                  \
  template&amp;lt;typename _Res, typename _Class, typename... _ArgTypes&amp;gt;       \
    struct _Mem_fn_traits&amp;lt;_Res (_Class::*)(_ArgTypes... ...) _CV _REF&amp;gt;  \
    : _Mem_fn_traits_base&amp;lt;_Res, _CV _Class, _ArgTypes...&amp;gt;               \
    {                                                                   \
      using __vararg = true_type;                                       \
    };

#define _GLIBCXX_MEM_FN_TRAITS(_REF, _LVAL, _RVAL)              \
  _GLIBCXX_MEM_FN_TRAITS2(              , _REF, _LVAL, _RVAL)   \
  _GLIBCXX_MEM_FN_TRAITS2(const         , _REF, _LVAL, _RVAL)   \
  _GLIBCXX_MEM_FN_TRAITS2(volatile      , _REF, _LVAL, _RVAL)   \
  _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)

_GLIBCXX_MEM_FN_TRAITS( , true_type, true_type)
_GLIBCXX_MEM_FN_TRAITS(&amp;amp;, true_type, false_type)
_GLIBCXX_MEM_FN_TRAITS(&amp;amp;&amp;amp;, false_type, true_type)

#if __cplusplus &amp;gt; 201402L
_GLIBCXX_MEM_FN_TRAITS(noexcept, true_type, true_type)
_GLIBCXX_MEM_FN_TRAITS(&amp;amp; noexcept, true_type, false_type)
_GLIBCXX_MEM_FN_TRAITS(&amp;amp;&amp;amp; noexcept, false_type, true_type)
#endif

#undef _GLIBCXX_MEM_FN_TRAITS
#undef _GLIBCXX_MEM_FN_TRAITS2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_Mem_fn_traits&lt;/code&gt;是成员函数类型的特征（trait）类型，定义了&lt;code&gt;__result_type&lt;/code&gt;、&lt;code&gt;__maybe_type&lt;/code&gt;、&lt;code&gt;__arity&lt;/code&gt;和&lt;code&gt;__vararg&lt;/code&gt;成员类型：&lt;code&gt;__arity&lt;/code&gt;表示元数，&lt;code&gt;__vararg&lt;/code&gt;指示成员函数类型是否是可变参数的（如&lt;code&gt;std::printf&lt;/code&gt;，非变参模板）。&lt;code&gt;... ...&lt;/code&gt;中的前三个点表示变参模板，后三个点表示可变参数，参考：&lt;a href=&quot;https://stackoverflow.com/a/33502576/11764098&quot; target=&quot;_blank&quot;&gt;What are the 6 dots in template parameter packs?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;成员函数类型有&lt;code&gt;const&lt;/code&gt;、&lt;code&gt;volatile&lt;/code&gt;、&lt;code&gt;&amp;amp;&lt;/code&gt;/&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;noexcept&lt;/code&gt;（C++17开始&lt;code&gt;noexcept&lt;/code&gt;成为函数类型的一部分）4个维度，共24种，单独定义太麻烦，所以用了宏。&lt;/p&gt;
&lt;h4 id=&quot;检测成员类型&quot;&gt;检测成员类型&lt;/h4&gt;
&lt;p&gt;一个类模板，当模板参数的类型定义了成员类型&lt;code&gt;result_type&lt;/code&gt;时该类模板也定义它，否则不定义它，如何实现？我刚刚新学到一种方法，用&lt;code&gt;void_t&lt;/code&gt;（即&lt;code&gt;__void_t&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void_t&lt;/code&gt;的定义出奇地简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename...&amp;gt;
using void_t = void;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不就是一个&lt;code&gt;void&lt;/code&gt;嘛，有什么用呢？请看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename _Functor, typename = __void_t&amp;lt;&amp;gt;&amp;gt;
  struct _Maybe_get_result_type
  { };

template&amp;lt;typename _Functor&amp;gt;
  struct _Maybe_get_result_type&amp;lt;_Functor,
                                __void_t&amp;lt;typename _Functor::result_type&amp;gt;&amp;gt;
  { typedef typename _Functor::result_type result_type; };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个定义是第一个定义的特化。当&lt;code&gt;_Functor&lt;/code&gt;类型定义了&lt;code&gt;result_type&lt;/code&gt;时，两个都正确，但是第二个更加特化，匹配到第二个，传播&lt;code&gt;result_type&lt;/code&gt;；反之，第二个在实例化过程中发生错误，根据SFINAE，匹配到第一个，不定义&lt;code&gt;result_type&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void_t&lt;/code&gt;的技巧，本质上还是SFINAE。&lt;/p&gt;
&lt;p&gt;以下两个类同理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename _Tp, typename = __void_t&amp;lt;&amp;gt;&amp;gt;
  struct _Refwrap_base_arg1
  { };

template&amp;lt;typename _Tp&amp;gt;
  struct _Refwrap_base_arg1&amp;lt;_Tp,
                            __void_t&amp;lt;typename _Tp::argument_type&amp;gt;&amp;gt;
  {
    typedef typename _Tp::argument_type argument_type;
  };

template&amp;lt;typename _Tp, typename = __void_t&amp;lt;&amp;gt;&amp;gt;
  struct _Refwrap_base_arg2
  { };

template&amp;lt;typename _Tp&amp;gt;
  struct _Refwrap_base_arg2&amp;lt;_Tp,
                            __void_t&amp;lt;typename _Tp::first_argument_type,
                                     typename _Tp::second_argument_type&amp;gt;&amp;gt;
  {
    typedef typename _Tp::first_argument_type first_argument_type;
    typedef typename _Tp::second_argument_type second_argument_type;
  };
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分类讨论&quot;&gt;分类讨论&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#if __cpp_noexcept_function_type
#define _GLIBCXX_NOEXCEPT_PARM , bool _NE
#define _GLIBCXX_NOEXCEPT_QUAL noexcept (_NE)
#else
#define _GLIBCXX_NOEXCEPT_PARM
#define _GLIBCXX_NOEXCEPT_QUAL
#endif

/**
 *  Base class for any function object that has a weak result type, as
 *  defined in 20.8.2 [func.require] of C++11.
*/
template&amp;lt;typename _Functor&amp;gt;
  struct _Weak_result_type_impl
  : _Maybe_get_result_type&amp;lt;_Functor&amp;gt;
  { };

/// Retrieve the result type for a function type.
template&amp;lt;typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Weak_result_type_impl&amp;lt;_Res(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  { typedef _Res result_type; };

/// Retrieve the result type for a varargs function type.
template&amp;lt;typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Weak_result_type_impl&amp;lt;_Res(_ArgTypes......) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  { typedef _Res result_type; };

/// Retrieve the result type for a function pointer.
template&amp;lt;typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Weak_result_type_impl&amp;lt;_Res(*)(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  { typedef _Res result_type; };

/// Retrieve the result type for a varargs function pointer.
template&amp;lt;typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct
  _Weak_result_type_impl&amp;lt;_Res(*)(_ArgTypes......) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  { typedef _Res result_type; };

// Let _Weak_result_type_impl perform the real work.
template&amp;lt;typename _Functor,
         bool = is_member_function_pointer&amp;lt;_Functor&amp;gt;::value&amp;gt;
  struct _Weak_result_type_memfun
  : _Weak_result_type_impl&amp;lt;_Functor&amp;gt;
  { };

// A pointer to member function has a weak result type.
template&amp;lt;typename _MemFunPtr&amp;gt;
  struct _Weak_result_type_memfun&amp;lt;_MemFunPtr, true&amp;gt;
  {
    using result_type = typename _Mem_fn_traits&amp;lt;_MemFunPtr&amp;gt;::__result_type;
  };

// A pointer to data member doesn't have a weak result type.
template&amp;lt;typename _Func, typename _Class&amp;gt;
  struct _Weak_result_type_memfun&amp;lt;_Func _Class::*, false&amp;gt;
  { };

/**
 *  Strip top-level cv-qualifiers from the function object and let
 *  _Weak_result_type_memfun perform the real work.
*/
template&amp;lt;typename _Functor&amp;gt;
  struct _Weak_result_type
  : _Weak_result_type_memfun&amp;lt;typename remove_cv&amp;lt;_Functor&amp;gt;::type&amp;gt;
  { };

/**
 *  Derives from unary_function or binary_function when it
 *  can. Specializations handle all of the easy cases. The primary
 *  template determines what to do with a class type, which may
 *  derive from both unary_function and binary_function.
*/
template&amp;lt;typename _Tp&amp;gt;
  struct _Reference_wrapper_base
  : _Weak_result_type&amp;lt;_Tp&amp;gt;, _Refwrap_base_arg1&amp;lt;_Tp&amp;gt;, _Refwrap_base_arg2&amp;lt;_Tp&amp;gt;
  { };

// - a function type (unary)
template&amp;lt;typename _Res, typename _T1 _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  : unary_function&amp;lt;_T1, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1) const&amp;gt;
  : unary_function&amp;lt;_T1, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1) volatile&amp;gt;
  : unary_function&amp;lt;_T1, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1) const volatile&amp;gt;
  : unary_function&amp;lt;_T1, _Res&amp;gt;
  { };

// - a function type (binary)
template&amp;lt;typename _Res, typename _T1, typename _T2 _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1, _T2) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  : binary_function&amp;lt;_T1, _T2, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1, typename _T2&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1, _T2) const&amp;gt;
  : binary_function&amp;lt;_T1, _T2, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1, typename _T2&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1, _T2) volatile&amp;gt;
  : binary_function&amp;lt;_T1, _T2, _Res&amp;gt;
  { };

template&amp;lt;typename _Res, typename _T1, typename _T2&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(_T1, _T2) const volatile&amp;gt;
  : binary_function&amp;lt;_T1, _T2, _Res&amp;gt;
  { };

// - a function pointer type (unary)
template&amp;lt;typename _Res, typename _T1 _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(*)(_T1) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  : unary_function&amp;lt;_T1, _Res&amp;gt;
  { };

// - a function pointer type (binary)
template&amp;lt;typename _Res, typename _T1, typename _T2 _GLIBCXX_NOEXCEPT_PARM&amp;gt;
  struct _Reference_wrapper_base&amp;lt;_Res(*)(_T1, _T2) _GLIBCXX_NOEXCEPT_QUAL&amp;gt;
  : binary_function&amp;lt;_T1, _T2, _Res&amp;gt;
  { };

template&amp;lt;typename _Tp, bool = is_member_function_pointer&amp;lt;_Tp&amp;gt;::value&amp;gt;
  struct _Reference_wrapper_base_memfun
  : _Reference_wrapper_base&amp;lt;_Tp&amp;gt;
  { };

template&amp;lt;typename _MemFunPtr&amp;gt;
  struct _Reference_wrapper_base_memfun&amp;lt;_MemFunPtr, true&amp;gt;
  : _Mem_fn_traits&amp;lt;_MemFunPtr&amp;gt;::__maybe_type
  {
    using result_type = typename _Mem_fn_traits&amp;lt;_MemFunPtr&amp;gt;::__result_type;
  };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不说了，看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202004/1734552-20200421234319953-2050889667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的感受：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202004/1734552-20200421234103517-890216626.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;大功告成&quot;&gt;大功告成&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename _Tp&amp;gt;
  class reference_wrapper
  : public _Reference_wrapper_base_memfun&amp;lt;typename remove_cv&amp;lt;_Tp&amp;gt;::type&amp;gt;
  {
    _Tp* _M_data;

  public:
    typedef _Tp type;

    reference_wrapper(_Tp&amp;amp; __indata) noexcept
    : _M_data(std::__addressof(__indata))
    { }

    reference_wrapper(_Tp&amp;amp;&amp;amp;) = delete;

    reference_wrapper(const reference_wrapper&amp;amp;) = default;

    reference_wrapper&amp;amp;
    operator=(const reference_wrapper&amp;amp;) = default;

    operator _Tp&amp;amp;() const noexcept
    { return this-&amp;gt;get(); }

    _Tp&amp;amp;
    get() const noexcept
    { return *_M_data; }

    template&amp;lt;typename... _Args&amp;gt;
      typename result_of&amp;lt;_Tp&amp;amp;(_Args&amp;amp;&amp;amp;...)&amp;gt;::type
      operator()(_Args&amp;amp;&amp;amp;... __args) const
      {
        return std::__invoke(get(), std::forward&amp;lt;_Args&amp;gt;(__args)...);
      }
  };

template&amp;lt;typename _Tp&amp;gt;
  inline reference_wrapper&amp;lt;_Tp&amp;gt;
  ref(_Tp&amp;amp; __t) noexcept
  { return reference_wrapper&amp;lt;_Tp&amp;gt;(__t); }

template&amp;lt;typename _Tp&amp;gt;
  inline reference_wrapper&amp;lt;const _Tp&amp;gt;
  cref(const _Tp&amp;amp; __t) noexcept
  { return reference_wrapper&amp;lt;const _Tp&amp;gt;(__t); }

template&amp;lt;typename _Tp&amp;gt;
  void ref(const _Tp&amp;amp;&amp;amp;) = delete;

template&amp;lt;typename _Tp&amp;gt;
  void cref(const _Tp&amp;amp;&amp;amp;) = delete;

template&amp;lt;typename _Tp&amp;gt;
  inline reference_wrapper&amp;lt;_Tp&amp;gt;
  ref(reference_wrapper&amp;lt;_Tp&amp;gt; __t) noexcept
  { return __t; }

template&amp;lt;typename _Tp&amp;gt;
  inline reference_wrapper&amp;lt;const _Tp&amp;gt;
  cref(reference_wrapper&amp;lt;_Tp&amp;gt; __t) noexcept
  { return { __t.get() }; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后组装一下就好啦！&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 15:47:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>本文是``系列的第3篇。 引用传参 我有一个函数： 因为参数类型是 ，所以函数能够修改传入的整数，而非其拷贝。 然后我用 把它和一个 绑定起来： int i = 1; auto f = std::bi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12747850.html</dc:identifier>
</item>
<item>
<title>Spring IoC getBean 方法详解 - leisurexi</title>
<link>http://www.cnblogs.com/yijinqincai/p/12748963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yijinqincai/p/12748963.html</guid>
<description>&lt;p&gt;本篇文章主要介绍 Spring IoC 容器 &lt;code&gt;getBean()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;下图是一个大致的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006Vpl27gy1ge1rh4g3o5j30pc0p7dh4.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先定义一个简单的 POJO，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
    
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    @Override
    public String toString() {
        return &quot;User{&quot; +
            &quot;id=&quot; + id +
            &quot;, name='&quot; + name + '\'' +
            '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再编写一个 XML 文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;user&quot; class=&quot;com.leisurexi.ioc.domain.User&quot;&amp;gt;
        &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;/&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;leisurexi&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来一个测试类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test(){
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
    reader.loadBeanDefinitions(&quot;META-INF/spring-bean.xml&quot;);
    User user = beanFactory.getBean(&quot;user&quot;, User.class);
    System.out.println(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码还是上篇文章的示例代码，这次我们主要分析 &lt;code&gt;beanFactory.getBean()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;abstractbeanfactorygetbean&quot;&gt;AbstractBeanFactory#getBean&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* @param name             bean的名称
* @param requiredType bean的类型
*/
public &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException {
    // 调用 doGetBean 方法(方法以do开头实际做操作的方法)
    return doGetBean(name, requiredType, null, false);
}

/**
* @param name          bean的名称
* @param requiredType  bean的类型
* @param args          显示传入的构造参数
* @param typeCheckOnly 是否仅仅做类型检查
*/
protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
                        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
    // 获取bean的实际名称，见下文详解
    final String beanName = transformedBeanName(name);
    Object bean;

    // Eagerly check singleton cache for manually registered singletons.
    // 直接尝试从缓存获取或 singletonFactories 中的 ObjectFactory 中获取，见下文详解
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
        if (logger.isTraceEnabled()) {
            if (isSingletonCurrentlyInCreation(beanName)) {
                logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                             &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
            }
            else {
                logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
            }
        }
        // 检查bean是否是FactoryBean的实现。不是直接返回bean，是的话首先检查beanName是否以 &amp;amp; 开头
        // 如果是返回FactoryBean本身，不是调用FactoryBean#getObject()返回对象
        // 见下文详解
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    }

    else {
        // Fail if we're already creating this bean instance:
        // We're assumably within a circular reference.
        // 只有在单例情况下才会去尝试解决循环依赖，原型模式下，如果存在A中有
        // B属性，B中有A属性，那么当依赖注入时，就会产生当A还未创建完的时候
        // 对于B的创建而在此返回创建A，造成循环依赖
        if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        // Check if bean definition exists in this factory.
        // 检查当前bean的BeanDefinition是否在当前的beanFactory，不在递归调用父工厂的getBean()去获取bean
        BeanFactory parentBeanFactory = getParentBeanFactory();
        if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
            // Not found -&amp;gt; check parent.
            String nameToLookup = originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory) {
                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                    nameToLookup, requiredType, args, typeCheckOnly);
            }
            else if (args != null) {
                // Delegation to parent with explicit args.
                return (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            else if (requiredType != null) {
                // No args -&amp;gt; delegate to standard getBean method.
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
            else {
                return (T) parentBeanFactory.getBean(nameToLookup);
            }
        }
        // 如果不是仅仅做类型检查，则是创建bean，这里要进行记录
        if (!typeCheckOnly) {
            // 记录bean已经创建过，见下文详解
            markBeanAsCreated(beanName);
        }

        try {
            // 合并BeanDefinition，见下文详解
            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            // Guarantee initialization of beans that the current bean depends on.
            // 实例化bean前先实例化依赖bean，也就是depends-on属性中配置的beanName
            String[] dependsOn = mbd.getDependsOn();
            if (dependsOn != null) {
                for (String dep : dependsOn) {
                    // 检查是否循环依赖，即当前bean依赖dep，dep依赖当前bean，见下文详解
                    if (isDependent(beanName, dep)) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
                    }
                    // 将dep和beanName的依赖关系放入到缓存中，见下文详解
                    registerDependentBean(dep, beanName);
                    try {
                        // 获取依赖dep对应的bean实例，如果还未创建实例，则先去创建
                        getBean(dep);
                    }
                    catch (NoSuchBeanDefinitionException ex) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
                    }
                }
            }

            // Create bean instance.
            // 如果 bean 的作用域是单例
            if (mbd.isSingleton()) {
                // 创建和注册单例 bean，见下文详解
                sharedInstance = getSingleton(beanName, () -&amp;gt; {
                    try {
                        // 创建 bean 实例，下篇文章详解
                        return createBean(beanName, mbd, args);
                    }
                    catch (BeansException ex) {
                        // Explicitly remove instance from singleton cache: It might have been put there
                        // eagerly by the creation process, to allow for circular reference resolution.
                        // Also remove any beans that received a temporary reference to the bean.
                        destroySingleton(beanName);
                        throw ex;
                    }
                });
                // 上文解释过，这里不再赘述
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
            // bean 的作用域是原型
            else if (mbd.isPrototype()) {
                // It's a prototype -&amp;gt; create a new instance.
                Object prototypeInstance = null;
                try {
                    // 原型 bean 创建前回调，默认实现是将 beanName 保存到 prototypesCurrentlyInCreation 缓存中
                    beforePrototypeCreation(beanName);
                    // 创建 bean 实例，下篇文章详解
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                finally {
                    // 原型 bean 创建后回调，默认实现是将 beanName 从prototypesCurrentlyInCreation 缓存中移除
                    afterPrototypeCreation(beanName);
                }
                // 上文解释过，这里不再赘述
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }
            // 自定义作用域
            else {
                // 获取自定义作用域名称
                String scopeName = mbd.getScope();
                // 获取作用域对象
                final Scope scope = this.scopes.get(scopeName);
                // 如果为空表示作用域未注册，抛出异常
                if (scope == null) {
                    throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
                }
                try {
                    // 其他 Scope 的 bean 创建(新建了一个 ObjectFactory，并且重写了 getObject 方法)
                    Object scopedInstance = scope.get(beanName, () -&amp;gt; {
                        // 原型 bean 创建前回调，默认实现是将 beanName 保存到 prototypesCurrentlyInCreation 缓存中
                        beforePrototypeCreation(beanName);
                        try {
                            // 创建 bean 实例，下篇文章详解
                            return createBean(beanName, mbd, args);
                        }
                        finally {
                            // 原型 bean 创建后回调，默认实现是将 beanName 从 prototypesCurrentlyInCreation 缓存中移除
                            afterPrototypeCreation(beanName);
                        }
                    });
                    // 上文解释过，这里不再赘述
                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                }
                catch (IllegalStateException ex) {
                    throw new BeanCreationException(beanName,
                                                    &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
                                                    &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,ex);
                }
            }
        }
        catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
        }
    }

    // Check if required type matches the type of the actual bean instance.
    // 检查所需的类型是否与实际 bean 实例的类型匹配
    if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
        try {
            // 如果类型不等，进行转换，转换失败抛出异常；转换成功直接返回
            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
            if (convertedBean == null) {
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
            return convertedBean;
        }
        catch (TypeMismatchException ex) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                             ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
            }
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    }
    // 返回 bean 实例
    return (T) bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;abstractbeanfactorytransformedbeanname&quot;&gt;AbstractBeanFactory#transformedBeanName&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected String transformedBeanName(String name) {
    return canonicalName(BeanFactoryUtils.transformedBeanName(name));
}

// BeanFactoryUtils.java
public static String transformedBeanName(String name) {
    Assert.notNull(name, &quot;'name' must not be null&quot;);
    // 如果name不是&amp;amp;开头，直接返回
    if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
        return name;
    }
    // 去除name的&amp;amp;前缀
    return transformedBeanNameCache.computeIfAbsent(name, beanName -&amp;gt; {
        do {
            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
        }
        while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));
        return beanName;
    });
}

// SimpleAliasRegistry.java
public String canonicalName(String name) {
    String canonicalName = name;
    // Handle aliasing...
    String resolvedName;
    // 如果name是别名，则会循环去查找bean的实际名称
    do {
        resolvedName = this.aliasMap.get(canonicalName);
        if (resolvedName != null) {
            canonicalName = resolvedName;
        }
    }
    while (resolvedName != null);
    return canonicalName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码首先去除 &lt;code&gt;FactoryBean&lt;/code&gt; 的修饰符，比如 &lt;code&gt;name=&amp;amp;aa&lt;/code&gt; ，那么会首先去除 &lt;code&gt;&amp;amp;&lt;/code&gt; 使 &lt;code&gt;name=aa&lt;/code&gt;。然后取 &lt;code&gt;alias&lt;/code&gt; 所表示的最终 &lt;code&gt;beanName&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们这里简单介绍什么是 &lt;code&gt;FactoryBean&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一般情况下，Spring 通过反射机制利用 &lt;code&gt;bean&lt;/code&gt; 的 &lt;code&gt;class&lt;/code&gt; 属性指定实现类来实例化 &lt;code&gt;bean&lt;/code&gt;。在某些情况下，实例化 &lt;code&gt;bean&lt;/code&gt; 过程比较复杂，如果按照传统的方式，则需要在 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 中提供大量的配置信息，配置方式的灵活性是受限的，这是采用编码的方式可能会得到一个简单的方案。Spring 为此提供了 &lt;code&gt;org.springframework.bean.factory.FactoryBean&lt;/code&gt; 的工厂类接口，用户可以通过实现该接口定制实例化 &lt;code&gt;bean&lt;/code&gt; 的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FactoryBean&lt;/code&gt; 接口对于 Spring 框架来说占有重要的地位，Spring 自身就提供了70多个 &lt;code&gt;FactoryBean&lt;/code&gt; 的实现。它们隐藏了一下复杂 &lt;code&gt;bean&lt;/code&gt; 的细节，给上层应用带来了便利。下面是该接口的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface FactoryBean&amp;lt;T&amp;gt; {

    // 返回由FactoryBean创建的bean实例，如果isSingleton()返回true，
    // 则该实例会放到Spring容器中单例缓存池中
    @Nullable
    T getObject() throws Exception;
        
    // 返回FactoryBean创建的bean类型
    @Nullable
    Class&amp;lt;?&amp;gt; getObjectType();

    // 返回由FactoryBean创建的bean实例的作用域是singleton还是prototype
    default boolean isSingleton() {
        return true;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当配置文件中 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 的 &lt;code&gt;class&lt;/code&gt; 属性配置的实现类时 &lt;code&gt;FactoryBean&lt;/code&gt; 时，通过 &lt;code&gt;getBean()&lt;/code&gt; 返回的不是 &lt;code&gt;FactoryBean&lt;/code&gt; 本身，而是 &lt;code&gt;FactoryBean#getObject()&lt;/code&gt; 所返回的对象，相当于 &lt;code&gt;FactoryBean#getObject()&lt;/code&gt; 代理了 &lt;code&gt;getBean()&lt;/code&gt;。下面用简单的代码演示一下：&lt;/p&gt;
&lt;p&gt;首先定义一个 &lt;code&gt;Car&lt;/code&gt; 实体类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Car {
        
    private Integer maxSpeed;
    private String brand;
    private Double price;

    public Integer getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(Integer maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的实体类，如果用传统方式配置，每一个属性都会对应一个 &lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 元素标签。如果用 &lt;code&gt;FactoryBean&lt;/code&gt; 的方式实现就会灵活一点，下面通过逗号分隔的方式一次性的为 &lt;code&gt;Car&lt;/code&gt; 的所有属性配置值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CarFactoryBean implements FactoryBean&amp;lt;Car&amp;gt; {
        
    private String carInfo;
        
    @Override
    public Car getObject() throws Exception {
        Car car = new Car();
        String[] infos = carInfo.split(&quot;,&quot;);
        car.setBrand(infos[0]);
        car.setMaxSpeed(Integer.valueOf(infos[1]));
        car.setPrice(Double.valueOf(infos[2]));
        return car;
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return Car.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    public String getCarInfo() {
        return carInfo;
    }

    public void setCarInfo(String carInfo) {
        this.carInfo = carInfo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在 XML 中配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;bean id=&quot;car&quot; class=&quot;com.leisurexi.ioc.domain.CarFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;carInfo&quot; value=&quot;超级跑车,400,2000000&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后看下测试代码和运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void factoryBeanTest() {
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
    reader.loadBeanDefinitions(&quot;META-INF/spring-bean.xml&quot;);
    Car car = beanFactory.getBean(&quot;car&quot;, Car.class);
    System.out.println(car);
    CarFactoryBean carFactoryBean = beanFactory.getBean(&quot;&amp;amp;car&quot;, CarFactoryBean.class);
    System.out.println(carFactoryBean);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006Vpl27gy1gduss8hhfpj30g201rdfw.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到如果 &lt;code&gt;beanName&lt;/code&gt; 前面加上 &lt;code&gt;&amp;amp;&lt;/code&gt; 获取的是 &lt;code&gt;FactoryBean&lt;/code&gt; 本身，不加获取的 &lt;code&gt;getObject()&lt;/code&gt; 返回的对象。&lt;/p&gt;
&lt;h2 id=&quot;abstractbeanfactorygetsingleton&quot;&gt;AbstractBeanFactory#getSingleton&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getSingleton(String beanName) {
    // allowEarlyReference设置为true表示允许早期依赖
    return getSingleton(beanName, true);
}

/**
* @param allowEarlyReference  是否提前创建曝光
*/
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 检查单例传中是否存在
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
        // 如果为空，锁定全局变量进行处理
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
                // 当某些方法需要提前初始化时则会调用addSingletonFactory方法将对应的
                // ObjectFactory 初始化策略存储在 singletonFactories
                ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    // 调用预先设定的getObject()
                    singletonObject = singletonFactory.getObject();
                    // 记录在缓存中，earlySingletonObjects和singletonFactories
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码涉及到循环依赖的检测，首先尝试从 &lt;code&gt;singletonObjects&lt;/code&gt; 里面获取实例，如果获取不到再从 &lt;code&gt;earlySingletonObjects&lt;/code&gt; 里面获取，如果还获取不到，再尝试从 &lt;code&gt;singletonFactories&lt;/code&gt; 里面获取 &lt;code&gt;beanName&lt;/code&gt; 对应的 &lt;code&gt;ObjectFactory&lt;/code&gt;，然后调用这个 &lt;code&gt;ObjectFactory&lt;/code&gt; 的 &lt;code&gt;getObject()&lt;/code&gt; 来创建 &lt;code&gt;bean&lt;/code&gt;，并放到 &lt;code&gt;earlySingletonObjects&lt;/code&gt; 里面去，并且从 &lt;code&gt;singletonFactories&lt;/code&gt; 里面 &lt;code&gt;remove&lt;/code&gt; 掉这个 &lt;code&gt;ObjectFactory&lt;/code&gt; ，而对于后续的所有内存操作都只为了循环依赖检测时候用，也就是在 &lt;code&gt;allowEarlyReference&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的情况下才会使用。&lt;/p&gt;
&lt;p&gt;这里涉及用于存储 &lt;code&gt;bean&lt;/code&gt; 不同的 &lt;code&gt;map&lt;/code&gt;，下面简单解释下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;singletonObjects：&lt;/strong&gt;同于保存 &lt;code&gt;beanName&lt;/code&gt; 和 &lt;code&gt;bean&lt;/code&gt; 实例之间的关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;singletonFactories：&lt;/strong&gt;用于保存 &lt;code&gt;beanName&lt;/code&gt; 和创建 &lt;code&gt;bean&lt;/code&gt; 的工厂之间的关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;earlySingletonObjects：&lt;/strong&gt;也是保存 &lt;code&gt;beanName&lt;/code&gt; 和 &lt;code&gt;bean&lt;/code&gt; 实例之间的关系，与 &lt;code&gt;singletonObjects&lt;/code&gt; 的不同之处在于，当一个单例 &lt;code&gt;bean&lt;/code&gt; 被放到这里后，那么当 &lt;code&gt;bean&lt;/code&gt; 还在创建过程中，就可以通过 &lt;code&gt;getBean()&lt;/code&gt; 获取到了，其目的是用来检测循环引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;registeredSingletons：&lt;/strong&gt;用来保存当前所有已注册的 &lt;code&gt;bean&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;abstractbeanfactorygetobjectforbeaninstance&quot;&gt;AbstractBeanFactory#getObjectForBeanInstance&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object getObjectForBeanInstance(
                        Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

    // Don't let calling code try to dereference the factory if the bean isn't a factory.
    // name 是否以 &amp;amp; 开头
    if (BeanFactoryUtils.isFactoryDereference(name)) {
        // 如果是 null 直接返回
        if (beanInstance instanceof NullBean) {
            return beanInstance;
        }
        // beanName 以 &amp;amp; 开头，但又不是 FactoryBean 类型，抛出异常
        if (!(beanInstance instanceof FactoryBean)) {
            throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());
        }
        // 设置 isFactoryBean 为 true
        if (mbd != null) {
            mbd.isFactoryBean = true;
        }
        // 返回 bean 实例
        return beanInstance;
    }

    // Now we have the bean instance, which may be a normal bean or a FactoryBean.
    // If it's a FactoryBean, we use it to create a bean instance, unless the
    // caller actually wants a reference to the factory.
    // name 不是 &amp;amp; 开头，并且不是 FactoryBean 类型，直接返回
    if (!(beanInstance instanceof FactoryBean)) {
        return beanInstance;
    }

    Object object = null;
    if (mbd != null) {  
        mbd.isFactoryBean = true;
    }
    else {
        // 从缓存中获取实例
        object = getCachedObjectForFactoryBean(beanName);
    }
    if (object == null) {
        // Return bean instance from factory.
        // 将 beanInstance 强转成 FactoryBean
        FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) beanInstance;
        // Caches object obtained from FactoryBean if it is a singleton.
        // 合并 BeanDefinition
        if (mbd == null &amp;amp;&amp;amp; containsBeanDefinition(beanName)) {
            mbd = getMergedLocalBeanDefinition(beanName);
        }
        boolean synthetic = (mbd != null &amp;amp;&amp;amp; mbd.isSynthetic());
        // 获取实例
        object = getObjectFromFactoryBean(factory, beanName, !synthetic);
    }
    return object;
}

// FactoryBeanRegistrySupport.java
protected Object getObjectFromFactoryBean(FactoryBean&amp;lt;?&amp;gt; factory, String beanName, boolean shouldPostProcess) {
    // 如果是单例 bean，并且已经存在缓存中
    if (factory.isSingleton() &amp;amp;&amp;amp; containsSingleton(beanName)) {
        // 加锁
        synchronized (getSingletonMutex()) {
            // 从缓存中获取
            Object object = this.factoryBeanObjectCache.get(beanName);
            if (object == null) {
                // 调用 FactoryBean 的 getObject() 获取实例
                object = doGetObjectFromFactoryBean(factory, beanName);
                // Only post-process and store if not put there already during getObject() call above
                // (e.g. because of circular reference processing triggered by custom getBean calls)
                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
                // 如果该 beanName 已经在缓存中存在，则将 object 替换成缓存中的
                if (alreadyThere != null) {
                    object = alreadyThere;
                }
                else {
                    if (shouldPostProcess) {
                        // 如果当前 bean 还在创建中，直接返回
                        if (isSingletonCurrentlyInCreation(beanName)) {
                            // Temporarily return non-post-processed object, not storing it yet.
                            return object;
                        }
                        // 单例 bean 创建前回调
                        beforeSingletonCreation(beanName);
                        try {
                            // 对从 FactoryBean 获得给定对象后处理，默认按原样返回
                            object = postProcessObjectFromFactoryBean(object, beanName);
                        }
                        catch (Throwable ex) {
                            throw new BeanCreationException(beanName,
                                                            &quot;Post-processing of FactoryBean's singleton object failed&quot;, ex);
                        }
                        finally {
                            // 单例 bean 创建后回调
                            afterSingletonCreation(beanName);
                        }
                    }
                    if (containsSingleton(beanName)) {
                        // 将 beanName 和 object 放到 factoryBeanObjectCache 缓存中
                        this.factoryBeanObjectCache.put(beanName, object);
                    }
                }
            }
            // 返回实例
            return object;
        }
    }
    else {
        // 调用 FactoryBean 的 getObject() 获取实例
        Object object = doGetObjectFromFactoryBean(factory, beanName);
        if (shouldPostProcess) {
            try {
                // 对从 FactoryBean 获得给定对象后处理，默认按原样返回
                object = postProcessObjectFromFactoryBean(object, beanName);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean's object failed&quot;, ex);
            }
        }
        // 返回实例
        return object;
    }
}

// FactoryBeanRegistrySupport.java
private Object doGetObjectFromFactoryBean(final FactoryBean&amp;lt;?&amp;gt; factory, final String beanName) throws BeanCreationException {

    Object object;
    try {
        if (System.getSecurityManager() != null) {
            AccessControlContext acc = getAccessControlContext();
            try {
                object = AccessController.doPrivileged((PrivilegedExceptionAction&amp;lt;Object&amp;gt;) factory::getObject, acc);
            }
            catch (PrivilegedActionException pae) {
                throw pae.getException();
            }
        }
        else {
            // 调用 getObject() 获取实例
            object = factory.getObject();
        }
    }
    catch (FactoryBeanNotInitializedException ex) {
        throw new BeanCurrentlyInCreationException(beanName, ex.toString());
    }
    catch (Throwable ex) {
        throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);
    }

    // Do not accept a null value for a FactoryBean that's not fully
    // initialized yet: Many FactoryBeans just return null then.
    // 如果 object 为 null，并且当前 singleton bean 正在创建中，抛出异常
    if (object == null) {
        if (isSingletonCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(
                beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);
        }
        object = new NullBean();
    }
    // 返回 object 实例
    return object;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码总结起来就是：如果 &lt;code&gt;beanName&lt;/code&gt; 以 &lt;code&gt;&amp;amp;&lt;/code&gt; 开头，直接返回 &lt;code&gt;FactoryBean&lt;/code&gt; 实例；否则调用 &lt;code&gt;getObject()&lt;/code&gt; 方法获取实例，然后执行 &lt;code&gt;postProcessObjectFromFactoryBean()&lt;/code&gt; 回调，可以在回调方法中修改实例，默认按原样返回。&lt;/p&gt;
&lt;h2 id=&quot;abstractbeanfactorygetmergedlocalbeandefinition&quot;&gt;AbstractBeanFactory#getMergedLocalBeanDefinition&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下文将合并后的 &lt;code&gt;BeanDefinition&lt;/code&gt; 简称为 &lt;code&gt;MergedBeanDefinition&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {
    // Quick check on the concurrent map first, with minimal locking.
    // 获取当前bean合并后的BeanDefinition
    RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
    // 如果存在合并后的BeanDefinition，并且不是过期的，直接返回
    if (mbd != null &amp;amp;&amp;amp; !mbd.stale) {
        return mbd;
    }
    // 获取已经注册的BeanDefinition然后去合并
    return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
}

protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)
                throws BeanDefinitionStoreException {
    // 顶级bean获取合并后的BeanDefinition
    return getMergedBeanDefinition(beanName, bd, null);
}

/**
* @param containingBd 如果是嵌套bean该值为顶级bean，如果是顶级bean该值为null
*/
protected RootBeanDefinition getMergedBeanDefinition(
                String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
                throws BeanDefinitionStoreException {

    synchronized (this.mergedBeanDefinitions) {
        // 本次的RootBeanDefinition
        RootBeanDefinition mbd = null;
        // 以前的RootBeanDefinition
        RootBeanDefinition previous = null;

        // Check with full lock now in order to enforce the same merged instance.
        // 如果bean是顶级bean，直接获取合并后的BeanDefinition
        if (containingBd == null) {
            mbd = this.mergedBeanDefinitions.get(beanName);
        }
                // 没有合并后的BeanDefinition || BeanDefinition过期了
        if (mbd == null || mbd.stale) {
            previous = mbd;
            // 如果bean没有parent
            if (bd.getParentName() == null) {
                // Use copy of given root bean definition.
                // 如果bd本身就是RootBeanDefinition直接复制一份，否则创建一个
                if (bd instanceof RootBeanDefinition) {
                    mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
                }
                else {
                    mbd = new RootBeanDefinition(bd);
                }
            }
            else {      
                // Child bean definition: needs to be merged with parent.
                // bean有parent
                BeanDefinition pbd;
                try {
                    // 获取parent bean的实际名称
                    String parentBeanName = transformedBeanName(bd.getParentName());
                    if (!beanName.equals(parentBeanName)) {
                        // 当前beanName不等于它的parent beanName
                        // 获取parent合并后的BeanDefinition
                        pbd = getMergedBeanDefinition(parentBeanName);
                    }
                    else {
                        // 如果父定义的beanName与bd的beanName相同，则拿到父BeanFactory
                        // 只有在存在父BeanFactory的情况下，才允许父定义beanName与自己相同
                        BeanFactory parent = getParentBeanFactory();
                        if (parent instanceof ConfigurableBeanFactory) {
                            // 如果父BeanFactory是ConfigurableBeanFactory
                            // 则通过父BeanFactory获取parent合并后的BeanDefinition
                            pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
                        }
                        else {
                            // 如果父BeanFactory不是ConfigurableBeanFactory，抛出异常
                            throw new NoSuchBeanDefinitionException(parentBeanName,
                                                                    &quot;Parent name '&quot; + parentBeanName + &quot;' is equal to bean name '&quot; + beanName +
                                                                    &quot;': cannot be resolved without an AbstractBeanFactory parent&quot;);
                        }
                    }
                }
                catch (NoSuchBeanDefinitionException ex) {
                    throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
                                                           &quot;Could not resolve parent bean definition '&quot; + bd.getParentName() + &quot;'&quot;, ex);
                }
                // Deep copy with overridden values.
                // 使用父定义pbd构建一个新的RootBeanDefinition对象（深拷贝）
                mbd = new RootBeanDefinition(pbd);
                // 覆盖与parent相同的属性，
                mbd.overrideFrom(bd);
            }
            
            // Set default singleton scope, if not configured before.
            // 如果bean没有设置scope属性，默认是singleton
            if (!StringUtils.hasLength(mbd.getScope())) {
                mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
            }

            // A bean contained in a non-singleton bean cannot be a singleton itself.
            // Let's correct this on the fly here, since this might be the result of
            // parent-child merging for the outer bean, in which case the original inner bean
            // definition will not have inherited the merged outer bean's singleton status.
            // 当前bean是嵌套bean &amp;amp;&amp;amp; 顶级bean的作用域不是单例 &amp;amp;&amp;amp; 当前bean的作用域是单例
            // 这里总结起来就是，如果顶层bean不是单例的，那么嵌套bean也不能是单例的
            if (containingBd != null &amp;amp;&amp;amp; !containingBd.isSingleton() &amp;amp;&amp;amp; mbd.isSingleton()) {
                // 设置当前bean的作用域和顶级bean一样
                mbd.setScope(containingBd.getScope());
            }

            // Cache the merged bean definition for the time being
            // (it might still get re-merged later on in order to pick up metadata changes)
            // 当前bean是顶级bean &amp;amp;&amp;amp; 缓存bean的元数据(该值默认为true)
            if (containingBd == null &amp;amp;&amp;amp; isCacheBeanMetadata()) {
                // 将当前bean合并后的RootBeanDefinition缓存起来
                this.mergedBeanDefinitions.put(beanName, mbd);
            }
        }
        // 以前的RootBeanDefinition不为空，拷贝相关的BeanDefinition缓存
        if (previous != null) {
            copyRelevantMergedBeanDefinitionCaches(previous, mbd);
        }
        return mbd;
    }
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码主要是获取 &lt;code&gt;MergedBeanDefinition&lt;/code&gt; ，主要步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先从缓存中获取 &lt;code&gt;bean&lt;/code&gt; 的 &lt;code&gt;MergedBeanDefinition&lt;/code&gt;，如果存在并且未过期直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不存在或者已过期的 &lt;code&gt;MergedBeanDefinition&lt;/code&gt; ，获取已经注册的 &lt;code&gt;BeanDefinition&lt;/code&gt; 去作为顶级 &lt;code&gt;bean&lt;/code&gt; 合并。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;bean&lt;/code&gt; 没有 &lt;code&gt;parent&lt;/code&gt; (就是 XML 中的 parent 属性)，直接封装成 &lt;code&gt;RootBeanDefinition&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;bean&lt;/code&gt; 有 &lt;code&gt;parent&lt;/code&gt; ，先去获取父 &lt;code&gt;MergedBeanDefinition&lt;/code&gt; ，然后覆盖和合并与 &lt;code&gt;parent&lt;/code&gt; 相同的属性。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：这里只有 &lt;code&gt;abstract&lt;/code&gt;、&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;lazyInit&lt;/code&gt;、&lt;code&gt;autowireMode&lt;/code&gt;、&lt;code&gt;dependencyCheck&lt;/code&gt;、&lt;code&gt;dependsOn&lt;/code&gt; 、&lt;code&gt;factoryBeanName&lt;/code&gt;、&lt;code&gt;factoryMethodName&lt;/code&gt;、&lt;code&gt;initMethodName&lt;/code&gt;、&lt;code&gt;destroyMethodName&lt;/code&gt;会覆盖，而 &lt;code&gt;constructorArgumentValues&lt;/code&gt;、&lt;code&gt;propertyValues&lt;/code&gt;、&lt;code&gt;methodOverrides&lt;/code&gt; 会合并。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果没有设置作用域，默认作用域为 &lt;code&gt;singleton&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;缓存 &lt;code&gt;MergedBeanDefinition&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上文中提到如果 &lt;code&gt;bean&lt;/code&gt; 有 &lt;code&gt;parent&lt;/code&gt;，会合并一些属性，这里我们稍微展示一下合并后的 &lt;code&gt;propertyValues&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;首先定义一个 &lt;code&gt;SuperUser&lt;/code&gt; 继承上面定义的 &lt;code&gt;User&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SuperUser extends User {

    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;SuperUser{&quot; +
            &quot;address='&quot; + address + '\'' +
            '}';
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在 XML 文件中配置一下，如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;bean id=&quot;superUser&quot; class=&quot;com.leisurexi.ioc.domain.SuperUser&quot; parent=&quot;user&quot;&amp;gt;
    &amp;lt;property name=&quot;address&quot; value=&quot;北京&quot;/&amp;gt;
 &amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后下图是我 Debug 的截图，可以看到 &lt;code&gt;superUser&lt;/code&gt; 的 &lt;code&gt;propertyValues&lt;/code&gt; 合并了 &lt;code&gt;user&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006Vpl27gy1gdtqv4ppzxj30g70cjdgv.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上文还提到了嵌套 &lt;code&gt;bean&lt;/code&gt; ，下面我们简单看一下什么是嵌套 &lt;code&gt;bean&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 Spring 中，如果某个 &lt;code&gt;bean&lt;/code&gt; 所依赖的 &lt;code&gt;bean&lt;/code&gt; 不想被 Spring 容器直接访问，可以使用嵌套 &lt;code&gt;bean&lt;/code&gt;。和普通的 &lt;code&gt;bean&lt;/code&gt; 一样，使用 &lt;code&gt;bean&lt;/code&gt; 元素来定义嵌套的 &lt;code&gt;bean&lt;/code&gt;，嵌套 &lt;code&gt;bean&lt;/code&gt; 只对它的外部 &lt;code&gt;bean&lt;/code&gt; 有效，Spring 无法直接访问嵌套 &lt;code&gt;bean&lt;/code&gt; ，因此定义嵌套 &lt;code&gt;bean&lt;/code&gt; 也无需指定 &lt;code&gt;id&lt;/code&gt; 属性。如下配置片段是一个嵌套 &lt;code&gt;bean&lt;/code&gt; 示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006Vpl27gy1gduqtoyjc4j30kg083aax.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用上面的配置形式可以保证嵌套 &lt;code&gt;bean&lt;/code&gt; 不能被容器访问，因此不用担心其他程序修改嵌套 &lt;code&gt;bean&lt;/code&gt;。外部 &lt;code&gt;bean&lt;/code&gt; 的用法和使用结果和以前没有区别。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;嵌套 &lt;code&gt;bean&lt;/code&gt; 提高了 &lt;code&gt;bean&lt;/code&gt; 的内聚性，但是降低了程序的灵活性。只有在确定无需通过 Spring 容器访问某个 &lt;code&gt;bean&lt;/code&gt; 实例时，才考虑使用嵌套 &lt;code&gt;bean&lt;/code&gt; 来定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;defaultsingletonbeanregistryisdependent&quot;&gt;DefaultSingletonBeanRegistry#isDependent&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean isDependent(String beanName, String dependentBeanName) {
    // 加锁
    synchronized (this.dependentBeanMap) {
        // 检测beanName和dependentBeanName是否有循环依赖
        return isDependent(beanName, dependentBeanName, null);
    }
}

private boolean isDependent(String beanName, String dependentBeanName, @Nullable Set&amp;lt;String&amp;gt; alreadySeen) {
    // 如果当前bean已经检测过，直接返回false
    if (alreadySeen != null &amp;amp;&amp;amp; alreadySeen.contains(beanName)) {
        return false;
    }
    // 解析别名
    String canonicalName = canonicalName(beanName);
    // 获取canonicalName所依赖beanName集合
    Set&amp;lt;String&amp;gt; dependentBeans = this.dependentBeanMap.get(canonicalName);
    // 如果为空，两者还未确定依赖关系，返回false
    if (dependentBeans == null) {
        return false;
    }
    // 如果dependentBeanName已经存在于缓存中，两者已经确定依赖关系，返回true
    if (dependentBeans.contains(dependentBeanName)) {
        return true;
    }
    // 循环检查，即检查依赖canonicalName的所有beanName是否被dependentBeanName依赖(即隔层依赖)
    for (String transitiveDependency : dependentBeans) {
        if (alreadySeen == null) {
            alreadySeen = new HashSet&amp;lt;&amp;gt;();
        }
        // 将已经检查过的记录下来，下次直接跳过
        alreadySeen.add(beanName);
        if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;dependentBeanMap&lt;/code&gt; 其实是 &lt;code&gt;beanName&lt;/code&gt; 和其依赖的 &lt;code&gt;dependentBeanName&lt;/code&gt; 反过来存的。比如，A 依赖 B，B 依赖 A；那么首先调用 &lt;code&gt;getBean()&lt;/code&gt; 获取 A，然后到 &lt;code&gt;isDependent()&lt;/code&gt; ，因为是第一次进来所以 &lt;code&gt;dependentBeans&lt;/code&gt; 是空的直接返回 &lt;code&gt;false&lt;/code&gt;，接着到下面 &lt;code&gt;registerDepenndentBean()&lt;/code&gt; ，这里先将 &lt;code&gt;dependentBeanName&lt;/code&gt; 作为 &lt;code&gt;key&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt; 是添加了 &lt;code&gt;beanName&lt;/code&gt; 的 &lt;code&gt;LinkedHashSet&lt;/code&gt; ，添加进 &lt;code&gt;dependentBeanMap&lt;/code&gt;；然后因为依赖 B，所以去实例化 B，又由于 B 依赖 A，到了 &lt;code&gt;isDepnedent()&lt;/code&gt;，接着 &lt;code&gt;dependentBeans.contains(dependentBeanName)&lt;/code&gt; 这行代码会返回 &lt;code&gt;true&lt;/code&gt; (因为在实例化 A 的过程中，已经将 B 作为 &lt;code&gt;key&lt;/code&gt; 放入了 &lt;code&gt;dependentBeanMap&lt;/code&gt;)，最后直接抛出 &lt;strong&gt;循环引用&lt;/strong&gt; 的异常。&lt;/p&gt;
&lt;h2 id=&quot;defaultsingletonbeanregistryregisterdependentbean&quot;&gt;DefaultSingletonBeanRegistry#registerDependentBean&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void registerDependentBean(String beanName, String dependentBeanName) {
    // 解析别名
    String canonicalName = canonicalName(beanName);
    // 加锁
    synchronized (this.dependentBeanMap) {
        // 获取canonicalName依赖beanName集合，如果为空默认创建一个LinkedHashSet当做默认值
        Set&amp;lt;String&amp;gt; dependentBeans =
            this.dependentBeanMap.computeIfAbsent(canonicalName, k -&amp;gt; new LinkedHashSet&amp;lt;&amp;gt;(8));
        // 如果dependentBeanName已经记录过了，直接返回
        if (!dependentBeans.add(dependentBeanName)) {
            return;
        }
    }
    // 加锁
    synchronized (this.dependenciesForBeanMap) {
        // 这里是和上面的dependentBeanMap倒过来，key为dependentBeanName
        Set&amp;lt;String&amp;gt; dependenciesForBean =
            this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&amp;gt; new LinkedHashSet&amp;lt;&amp;gt;(8));
        dependenciesForBean.add(canonicalName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法又引入了一个跟 &lt;code&gt;dependentBeanMap&lt;/code&gt; 类似的缓存 &lt;code&gt;dependenciesForBeanMap&lt;/code&gt;。这两个缓存很容易搞混，这里再举一个简单的例子：A 依赖 B，那么 &lt;code&gt;dependentBeanMap&lt;/code&gt; 存放的是 &lt;code&gt;key&lt;/code&gt; 为 B，&lt;code&gt;value&lt;/code&gt; 为含有 A 的 &lt;code&gt;Set&lt;/code&gt;；而 &lt;code&gt;dependenciesForBeanMap&lt;/code&gt; 存放的是&lt;code&gt;key&lt;/code&gt; 为 A，&lt;code&gt;value&lt;/code&gt; 为含有 B 的 &lt;code&gt;Set&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;defaultsingletonbeanregistrygetsingleton&quot;&gt;DefaultSingletonBeanRegistry#getSingleton&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
    // 加锁
    synchronized (this.singletonObjects) {
        Object singletonObject = this.singletonObjects.get(beanName);
        // 缓存中不存在当前 bean，也就是当前 bean 第一次创建
        if (singletonObject == null) {
            // 如果当前正在销毁 singletons，抛出异常
            if (this.singletonsCurrentlyInDestruction) {
                throw new BeanCreationNotAllowedException(beanName,
                                                          &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                                                          &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
            }
            // 创建单例 bean 之前的回调
            beforeSingletonCreation(beanName);
            boolean newSingleton = false;
            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;();
            }
            try {
                // 获取 bean 实例，在此处才会去真正调用创建 bean 的方法，也就是 createBean 方法
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                // Has the singleton object implicitly appeared in the meantime -&amp;gt;
                // if yes, proceed with it since the exception indicates that state.
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw ex;
                }
            }
            catch (BeanCreationException ex) {
                if (recordSuppressedExceptions) {
                    for (Exception suppressedException : this.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                throw ex;
            }
            finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }
                // 创建单例 bean 之后的回调
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                // 将 singletonObject 放入缓存
                addSingleton(beanName, singletonObject);
            }
        }
        // 返回 bean 实例
        return singletonObject;
    }
}

// 单例 bean 创建前的回调方法，默认实现是将 beanName 加入到当前正在创建 bean 的缓存中
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}

// 单例 bean 创建后的回调方法，默认实现是将 beanName 从当前正在创建 bean 的缓存中移除
protected void afterSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) &amp;amp;&amp;amp; !this.singletonsCurrentlyInCreation.remove(beanName)) {
        throw new IllegalStateException(&quot;Singleton '&quot; + beanName + &quot;' isn't currently in creation&quot;);
    }
}

protected void addSingleton(String beanName, Object singletonObject) {
    synchronized (this.singletonObjects) {
        // 将 bean 实例缓存起来
        this.singletonObjects.put(beanName, singletonObject);
        // 移除 bean 的工厂
        this.singletonFactories.remove(beanName);
        // bean 已经实际创建完毕，这里从早起单例缓存中删除
        this.earlySingletonObjects.remove(beanName);
        // 将 beanName 添加到已注册 bean 缓存中
        this.registeredSingletons.add(beanName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法是单例 &lt;code&gt;bean&lt;/code&gt; 的处理逻辑，主要做的就是创建 &lt;code&gt;bean&lt;/code&gt; 实例，然后将实例放入到缓存中；然后下次再获取该 &lt;code&gt;bean&lt;/code&gt; 是直接从缓存中获取返回。&lt;/p&gt;
&lt;p&gt;在创建 &lt;code&gt;bean&lt;/code&gt; 实例的前后提供了两个扩展点，分别是 &lt;code&gt;beforeSingletonCreation()&lt;/code&gt; 和 &lt;code&gt;afterSingletonCreation()&lt;/code&gt; ，我们可以继承 &lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt; 来扩展这两个方法。&lt;/p&gt;
&lt;h2 id=&quot;自定义作用域示例&quot;&gt;自定义作用域示例&lt;/h2&gt;
&lt;p&gt;我们实现一个 &lt;code&gt;ThreadLocal&lt;/code&gt; 级别的作用域，也就是同一个线程内 &lt;code&gt;bean&lt;/code&gt; 是同一个实例，不同线程的 &lt;code&gt;bean&lt;/code&gt; 是不同实例。首先我们继承 &lt;code&gt;Scope&lt;/code&gt; 接口实现，其中方法。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadLocalScope implements Scope {

    /** scope 名称，在 XML 中的 scope 属性就配置此名称 */
    public static final String SCOPE_NAME = &quot;thread-local&quot;;

    private final NamedThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; threadLocal = new NamedThreadLocal&amp;lt;&amp;gt;(&quot;thread-local-scope&quot;);

    /**
    * 返回实例对象，该方法被 Spring 调用
    */
    @Override
    public Object get(String name, ObjectFactory&amp;lt;?&amp;gt; objectFactory) {
        Map&amp;lt;String, Object&amp;gt; context = getContext();
        Object object = context.get(name);
        if (object == null) {
            object = objectFactory.getObject();
            context.put(name, object);
        }
        return object;
    }

    /**
    * 获取上下文 map
    */
    @NonNull
    private Map&amp;lt;String, Object&amp;gt; getContext() {
        Map&amp;lt;String, Object&amp;gt; map = threadLocal.get();
        if (map == null) {
            map = new HashMap&amp;lt;&amp;gt;();
            threadLocal.set(map);
        }
        return map;
    }

    @Override
    public Object remove(String name) { 
        return getContext().remove(name);
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        // TODO
    }
        
    @Override
    public Object resolveContextualObject(String key) {
        Map&amp;lt;String, Object&amp;gt; context = getContext();
        return context.get(key);
    }

    @Override
    public String getConversationId() {
        return String.valueOf(Thread.currentThread().getId());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 &lt;code&gt;ThreadLocalScope&lt;/code&gt; 重点关注下 &lt;code&gt;get()&lt;/code&gt; 即可，该方法是被 Spring 调用的。&lt;/p&gt;
&lt;p&gt;然后在 XML 中配置 &lt;code&gt;bean&lt;/code&gt; 的 &lt;code&gt;scope&lt;/code&gt; 为 &lt;code&gt;thread-local&lt;/code&gt;。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;bean id=&quot;user&quot; name=&quot;user&quot; class=&quot;com.leisurexi.ioc.domain.User&quot; scope=&quot;thread-local&quot;&amp;gt;
    &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;/&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;leisurexi&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们测试一下。测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test() throws InterruptedException {
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
    // 注册自定义作用域
    beanFactory.registerScope(ThreadLocalScope.SCOPE_NAME, new ThreadLocalScope());
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
    reader.loadBeanDefinitions(&quot;META-INF/spring-bean.xml&quot;);
    for (int i = 0; i &amp;lt; 3; i++) {
        Thread thread = new Thread(() -&amp;gt; {
            User user = beanFactory.getBean(&quot;user&quot;, User.class);
            System.err.printf(&quot;[Thread id :%d] user = %s%n&quot;, Thread.currentThread().getId(), user.getClass().getName() + &quot;@&quot; + Integer.toHexString(user.hashCode()));
            User user1 = beanFactory.getBean(&quot;user&quot;, User.class);
            System.err.printf(&quot;[Thread id :%d] user1 = %s%n&quot;, Thread.currentThread().getId(), user1.getClass().getName() + &quot;@&quot; + Integer.toHexString(user1.hashCode()));
        });
        thread.start();
        thread.join();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一下我们这里的主要思路，新建了三个线程，查询线程内 &lt;code&gt;user bean&lt;/code&gt; 是否相等，不同线程是否不等。&lt;/p&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006Vpl27gy1ge0ng9ixchj30ke04y74v.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍了通过 &lt;code&gt;getBean()&lt;/code&gt; 流程，我们可以重新梳理一下思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取 &lt;code&gt;bean&lt;/code&gt; 实际名称，如果缓存中存在直接取出实际 &lt;code&gt;bean&lt;/code&gt; 返回。&lt;/li&gt;
&lt;li&gt;缓存中不存在，判断当前工厂是否有 &lt;code&gt;BeanDefinition&lt;/code&gt; ，没有递归去父工厂创建 &lt;code&gt;bean&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;合并 &lt;code&gt;BeanDefinition&lt;/code&gt; ，如果 &lt;code&gt;depends-on&lt;/code&gt; 不为空，先去初始化依赖的 &lt;code&gt;bean&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;bean&lt;/code&gt; 的作用域是单例，调用 &lt;code&gt;createBean()&lt;/code&gt; 创建实例，这个方法会执行 &lt;code&gt;bean&lt;/code&gt; 的其它生命周期回调，以及属性赋值等操作；接着执行单例 &lt;code&gt;bean&lt;/code&gt; 创建前后的生命周期回调方法，并放入 &lt;code&gt;singletonObjects&lt;/code&gt; 缓存起来。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;bean&lt;/code&gt; 的作用域是原型，调用 &lt;code&gt;createBean()&lt;/code&gt; 创建实例，并执行原型 &lt;code&gt;bean&lt;/code&gt; 前后调用生命周期回调方法。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;bean&lt;/code&gt; 的作用域是自定义的，获取对应的 &lt;code&gt;Scope&lt;/code&gt; 对象，调用重写的 &lt;code&gt;get()&lt;/code&gt; 获取实例，并执行原型 &lt;code&gt;bean&lt;/code&gt; 前后调用生命周期回调方法。&lt;/li&gt;
&lt;li&gt;最后检查所需的类型是否与实际 &lt;code&gt;bean&lt;/code&gt; 实例的类型匹配，如果不等进行转换，最后返回实例。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;最后，我模仿 Spring 写了一个精简版，代码会持续更新，现在是 &lt;code&gt;0.0.1&lt;/code&gt; 版本。地址：&lt;a href=&quot;https://github.com/leisurexi/tiny-spring&quot;&gt;https://github.com/leisurexi/tiny-spring&lt;/a&gt;。访问新博客地址，观看效果更佳 &lt;a href=&quot;https://leisurexi.github.io/&quot;&gt;https://leisurexi.github.io/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;《Spring 源码深度解析》—— 郝佳&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 21 Apr 2020 15:45:00 +0000</pubDate>
<dc:creator>leisurexi</dc:creator>
<og:description>前言 本篇文章主要介绍 Spring IoC 容器 方法。 下图是一个大致的流程图： 正文 首先定义一个简单的 POJO，如下： 再编写一个 XML 文件。 最后再来一个测试类。 上面的代码还是上篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yijinqincai/p/12748963.html</dc:identifier>
</item>
<item>
<title>Mysql：小主键，大问题 - MageByte-借来方向</title>
<link>http://www.cnblogs.com/WeaRang/p/12748720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WeaRang/p/12748720.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;今日格言：让一切回归原点，回归最初的为什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇讲解 Mysql 的&lt;strong&gt;主键&lt;/strong&gt;问题，从&lt;strong&gt;为什么&lt;/strong&gt;的角度来了解 Mysql 主键相关的知识，并拓展到主键的生成方案问题。再也不怕被问到 Mysql 时只知道 CRUD 了。&lt;/p&gt;
&lt;h2 id=&quot;一、为什么需要主键&quot;&gt;一、为什么需要主键&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;数据记录需具有&lt;strong&gt;唯一性&lt;/strong&gt;(第一范式)&lt;/li&gt;
&lt;li&gt;数据需要关联 &lt;strong&gt;join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数据库底层索引用于检索数据所需&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;以下废话连篇，可以直接跳过到下一节。&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;信息&lt;/strong&gt;是用来消除随机不定性的东西”（香农）。人通过获得、识别自然界和社会的不同信息来区别不同事物，得以认识和改造世界。&lt;strong&gt;数据&lt;/strong&gt;是反映客观事物属性的记录，是信息的具体表现形式。数据经过加工处理之后，就成为信息；而信息需要经过数字化转变成数据才能存储和传输。&lt;strong&gt;数据库&lt;/strong&gt;就是用于存储数据记录的。既已如此，&lt;strong&gt;记录&lt;/strong&gt;便是具有确定性(相对)的信息，其确定性即唯一性。我们得出第一条原因：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.数据记录需具有唯一性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;世界是由客观存在及其关系组成的。&lt;strong&gt;数据&lt;/strong&gt;是数字化和模型化的存在关系。数据除了本身的描述价值外，其价值还在于其相互关联性。为实现关联的准确性，数据需要有对外相互关联的标识。所以体现在数据存储上，&lt;strong&gt;主键&lt;/strong&gt;的第二作用，也是存在的第二因素即：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.数据需要关联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;用于描述客观实在的，本身没有意义。只有在根据主观需求组织之后，通过一定方式满足人认识事物的过程才具有了意义。所以数据需要被检索，被组织。则主键第三个作用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.数据库底层索引用于检索数据所需&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、为什么主键不宜过长&quot;&gt;二、为什么主键不宜过长&lt;/h2&gt;
&lt;p&gt;这个问题的点在&lt;strong&gt;长&lt;/strong&gt;上。那&lt;strong&gt;短&lt;/strong&gt;比&lt;strong&gt;长&lt;/strong&gt;有什么优势？（嘿嘿嘿，内涵）—— 短不占空间。但这么点磁盘空间相对整个数据量来说微不足道，而且我们一般不怎么用到主键列。那么原因应该在&lt;strong&gt;快&lt;/strong&gt;上，而且和原始数据关系不大。以此自然得出和&lt;strong&gt;索引&lt;/strong&gt;相关，而且和索引读取相关。那么为什么长主键在&lt;strong&gt;索引&lt;/strong&gt;中会影响性能？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/mysql/mysql_index.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是 Innodb 的索引数据结构。左边是&lt;strong&gt;聚簇索引&lt;/strong&gt;，通过主键定位数据记录。右边是&lt;strong&gt;二级索引&lt;/strong&gt;，对列数据做索引，通过列数据查找数据主键。如果通过二级索引查询数据，流程如图上所示，先从二级索引树上搜索到&lt;strong&gt;主键&lt;/strong&gt;，然后在聚簇索引上通过主键搜索到数据行。其中二级索引的叶子节点是直接存储的主键值，而不是主键指针。所以如果主键太长，一个二级索引树所能存储的索引记录就会变少，这样在有限的&lt;strong&gt;索引缓冲&lt;/strong&gt;中，需要读取磁盘的次数就会变多，所以性能就会下降。&lt;/p&gt;
&lt;h2 id=&quot;三、为什么建议使用自增-id&quot;&gt;三、为什么建议使用自增 ID&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/mysql/clustered_index.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;InnoDB 使用&lt;strong&gt;聚簇索引&lt;/strong&gt;，如上图所示，数据记录本身被存于主索引（一颗 B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录&lt;strong&gt;按主键顺序存放&lt;/strong&gt;，因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB 默认为 15/16），则开辟一个新的页（节点）。&lt;/p&gt;
&lt;p&gt;如果表使用自增主键，那么每次插入新的记录，记录就会&lt;strong&gt;顺序添加&lt;/strong&gt;到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个&lt;strong&gt;紧凑&lt;/strong&gt;的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上，如下图左侧所示。否则由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置，MySQL 不得不为了将新记录插到合适位置而&lt;strong&gt;移动数据&lt;/strong&gt;，如下图右侧所示，这样就造成了一定的开销。由于此，Mysql 为维护索引可能需要频繁的刷新缓冲，增加了方法磁盘 IO 的次数，而且时常需要对索引结构进行重组织。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/mysql/increment_id.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、业务-key-vs-逻辑-key&quot;&gt;四、业务 Key VS 逻辑 Key&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;业务 Key&lt;/strong&gt;，即使用具有业务意义的 id 作为 Key，比如使用订单流水号作为订单表的主键 Key。&lt;strong&gt;逻辑 Key&lt;/strong&gt;，即无关业务的 Key，按某种规则生成 Key，如自增 Key。&lt;/p&gt;
&lt;h4 id=&quot;业务-key-的优点&quot;&gt;业务 Key 的优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Key 具有业务意义，在查询时可以直接作为搜索关键字使用&lt;/li&gt;
&lt;li&gt;不需要额外的列和索引空间&lt;/li&gt;
&lt;li&gt;可以减少一些 join 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;业务-key-的缺点&quot;&gt;业务 Key 的缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;当业务发生变化时，有时需要变更主键&lt;/li&gt;
&lt;li&gt;涉及多列 Key 时比较难操作&lt;/li&gt;
&lt;li&gt;业务 Key 往往比较长，所占空间更大，导致更大的磁盘 IO&lt;/li&gt;
&lt;li&gt;在 Key 确定前不能持久化数据，有时我们没有在确定数据 Key 时，就想先添加一条记录，之后再更新业务 Key&lt;/li&gt;
&lt;li&gt;设计一个兼具易用和性能的 Key 生成方案比较难&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;逻辑-key-的优点&quot;&gt;逻辑 Key 的优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;不会因为业务的变动而需要修改 Key 逻辑&lt;/li&gt;
&lt;li&gt;操作简单，且易于管理&lt;/li&gt;
&lt;li&gt;逻辑 Key 往往更小，性能更优&lt;/li&gt;
&lt;li&gt;逻辑 Key 更容易保证唯一性&lt;/li&gt;
&lt;li&gt;更易于优化&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;逻辑-key-缺点&quot;&gt;逻辑 Key 缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;查询主键列和主键索引需要额外的磁盘空间&lt;/li&gt;
&lt;li&gt;在插入数据和更新数据时需要额外的 IO&lt;/li&gt;
&lt;li&gt;更多的 join 可能&lt;/li&gt;
&lt;li&gt;如果没有唯一性策略限制，容易出现重复的 Key&lt;/li&gt;
&lt;li&gt;测试环境和正式环境 Key 不一致，不利于排查问题&lt;/li&gt;
&lt;li&gt;Key 的值没有和数据关联，不符合三范式&lt;/li&gt;
&lt;li&gt;不能用于搜索关键字&lt;/li&gt;
&lt;li&gt;依赖不同数据库系统的具体实现，不利于底层数据库的替换&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、主键生成&quot;&gt;五、主键生成&lt;/h2&gt;
&lt;p&gt;一般情况下，我们都使用 Mysql 的自增 ID，来作为表的&lt;strong&gt;主键&lt;/strong&gt;，这样简单，而且从上面讲到的来看，性能也是最好的。但是在分库分表的情况情况下，自增 ID 则不能满足需求。我们可以来看看不同数据库生成 ID 的方式，也看一些分布式 ID 生成方案。利于我们思考甚至实现自己的分布式 ID 生成服务。&lt;/p&gt;
&lt;h3 id=&quot;数据库的实现&quot;&gt;数据库的实现&lt;/h3&gt;
&lt;h4 id=&quot;mysql-自增&quot;&gt;Mysql 自增&lt;/h4&gt;
&lt;p&gt;Mysql 在内存中维护一个&lt;strong&gt;自增计数器&lt;/strong&gt;，每次访问 auto-increment 计数器的时候， InnoDB 都会加上一个名为&lt;strong&gt;AUTO-INC 锁&lt;/strong&gt;直到该语句结束(注意锁只持有到语句结束,不是事务结束)。AUTO-INC 锁是一个特殊的表级别的锁，用来提升包含 auto_increment 列的并发插入性。&lt;/p&gt;
&lt;p&gt;在分布式的情况下，其实可以独立一个服务和数据库来做 id 生成，依旧依赖 Mysql 的表 id 自增能力来为第三方服务统一生成 id。为性能考虑可以不同业务使用不同的表。&lt;/p&gt;
&lt;h4 id=&quot;mongodb-objectid&quot;&gt;Mongodb ObjectId&lt;/h4&gt;
&lt;p&gt;Mongodb 为防止主键冲突，设计了一个 ObjectId 作为主键 id。它由一个 12 字节的十六进制数字组成，其中包含以下几部分：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Time：时间戳。4 字节。秒级。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Machine：机器标识。3 字节。一般是机器主机名的散列值，这样就确保了不同主机生成不同的机器 hash 值，确保在分布式中不造成冲突，同一台机器的值相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;PID：进程 ID。2 字节。上面的 Machine 是为了确保在不同机器产生的 objectId 不冲突，而 pid 就是为了在同一台机器不同的 mongodb 进程产生的 objectId 不冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;INC：自增计数器。3 字节。前面的九个字节保证了一秒内不同机器不同进程生成的 objectId 不冲突，自增计数器，用来确保在同一秒内产生的 objectId 也不会发现冲突，允许 256 的 3 次方等于 16777216 条记录的唯一性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;cassandra-timeuuid&quot;&gt;Cassandra TimeUUID&lt;/h4&gt;
&lt;p&gt;Cassandra 使用下面规则生成一个唯一的 id：&lt;code&gt;time + MAC + sequence&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;方案&quot;&gt;方案&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Zookeeper 自增：通过 zk 的自增机制实现。&lt;/li&gt;
&lt;li&gt;Redis 自增：通过 Redis 的自增机制实现。&lt;/li&gt;
&lt;li&gt;UUID：使用 UUID 字符串作为 Key。&lt;/li&gt;
&lt;li&gt;snowflake 算法：和 Mongodb 的实现类似，&lt;code&gt;1位符号位 + 41位时间戳（毫秒级）+ 10位数据机器位 + 12位毫秒内的序列&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开源实现&quot;&gt;开源实现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;百度 UidGenerator：基于&lt;strong&gt;snowflake&lt;/strong&gt;算法。&lt;/li&gt;
&lt;li&gt;美团 Leaf：同时实现了基于 Mysql 自增（优化）和 snowflake 算法的机制。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;推荐系列&quot;&gt;推荐系列&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247484006&amp;amp;idx=1&amp;amp;sn=43b838d20554d061648338a35a4075c4&amp;amp;chksm=fd2a1804ca5d91123d6f2487841728d78f7d0ea57a8eefd6b86b74b726911346923c3d76b159&amp;amp;token=234560605&amp;amp;lang=zh_CN#rd&quot;&gt;列式存储&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/9ckUy3Lz9GHTNPauNlpV0w&quot;&gt;时间序列数据库(TSDB)初识与选择&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/dGBfQdmD7niW32BXWb2B0g&quot;&gt;十分钟了解 Apache Druid&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247483996&amp;amp;idx=1&amp;amp;sn=23ce4763ce44d6813e434196a53daf4f&amp;amp;chksm=fd2a183eca5d9128f016009ee838725c51700d718bc75a4129d8ebb3bd113745d997d6b451aa#rd&quot;&gt;Apache Druid 底层存储设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247483941&amp;amp;idx=1&amp;amp;sn=a73b5c703b6a257c179bab0fa07683a4&amp;amp;chksm=fd2a1847ca5d9151024be79c5fdbbe5b8bd6f36f82453d04571c9d7f41eb87e08cbbbee32aec#rd&quot;&gt;Apache Druid 的集群设计与工作流程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&amp;amp;mid=2247484021&amp;amp;idx=1&amp;amp;sn=e94f620ce493c966df5ef77145ac4bd8&amp;amp;chksm=fd2a1817ca5d91019cc8ab56e3d1b3cd9486bd13bfeb0732ca078bca692b349063cdab658572&amp;amp;token=747124803&amp;amp;lang=zh_CN#rd&quot;&gt;Mysql 大表问题和解决&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;想了解更多数据存储相关知识，请关注我的公众号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/wechat/Snip20200314_5.png&quot; alt=&quot;MageByte&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 Apr 2020 15:05:00 +0000</pubDate>
<dc:creator>MageByte-借来方向</dc:creator>
<og:description>今日格言：让一切回归原点，回归最初的为什么。 本篇讲解 Mysql 的 主键 问题，从 为什么 的角度来了解 Mysql 主键相关的知识，并拓展到主键的生成方案问题。再也不怕被问到 Mysql 时只知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WeaRang/p/12748720.html</dc:identifier>
</item>
</channel>
</rss>