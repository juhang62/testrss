<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>（译）删除未使用的前端代码 - mr_nan</title>
<link>http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</guid>
<description>&lt;p&gt;&lt;em&gt;注：本文翻译自 &lt;a title=&quot;remove-unused-code&quot; href=&quot;https://web.dev/fast/remove-unused-code&quot; target=&quot;_blank&quot;&gt;https://web.dev/fast/remove-unused-code&lt;/a&gt;，&lt;span class=&quot;web-author-information__written-by&quot;&gt;Written by Houssein Djirdeh&lt;/span&gt;。如有翻译错误请指正。&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　像 &lt;a title=&quot;关于npm&quot; href=&quot;https://docs.npmjs.com/about-npm/index.html&quot; target=&quot;_blank&quot;&gt;npm&lt;/a&gt; 这样的包管理器通过允许任何人轻松地下载和使用超过50万公共包来让JavaScript世界变得更好。但我们经常引入一些没有充分利用的库。为了解决这个问题，可以通过&lt;strong&gt;分析你的&lt;/strong&gt;bundle（即打包后得到的代码包，下文简称为包）来检测未使用的代码。然后，移除&lt;strong&gt;未使用的&lt;/strong&gt;和&lt;strong&gt;非必需的&lt;/strong&gt;库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;分析包&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　查看网络请求大小的最简单方法是打开谷歌浏览器的开发者工具中的 &lt;strong&gt;Network&lt;/strong&gt; 面板，把 &lt;span&gt;Disable Cache&lt;/span&gt; 勾上，然后刷新页面。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228224841083-850922941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开发者工具中的 &lt;strong&gt;Coverage&lt;/strong&gt; 标签页能告诉你有多少你的应用中的CSS和JS代码是未使用的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225011451-1115759413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过 Node CLI 配置一个完整的 Lighthouse 配置，一个“未使用的JavaScript”检查工具 &lt;strong&gt;Audits&lt;/strong&gt; 同样可以用来跟踪你的应用程序附带了多少未使用的代码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225300765-539960573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如果你使用 &lt;a title=&quot;webpack&quot; href=&quot;https://webpack.js.org/&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt; 作为你的打包器，&lt;a title=&quot;webpack-bundle-analyzer&quot; href=&quot;https://github.com/webpack-contrib/webpack-bundle-analyzer&quot; target=&quot;_blank&quot;&gt;Webpack Bundle Analyzer&lt;/a&gt; 将帮助您研究是什么组成了这个包。像引入其它一些插件一样在 webpack 配置中引入这个插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; module.exports =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  plugins: [
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BundleAnalyzerPlugin()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　尽管 webpack 通常用来构建单页应用，但其他打包器，例如 &lt;a title=&quot;parcel&quot; href=&quot;https://parceljs.org/&quot; target=&quot;_blank&quot;&gt;Parcel&lt;/a&gt; 和 &lt;a title=&quot;rollup&quot; href=&quot;https://rollupjs.org/guide/en&quot; target=&quot;_blank&quot;&gt;Rollup&lt;/a&gt; ，同样有可以用来分析包的可视化工具。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　引入这个插件后重新加载页面将呈现整个包的可缩放矩形树图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1326584/201902/1326584-20190228225805897-1223110286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过使用这种可视化工具，你可以查看包的哪些部分比其他部分大，并更好地了解导入的所有库。这有助于识别你是否正在使用一些未使用或不必要的库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;删除未使用的库&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在上面的矩形树图中，在 &lt;span&gt;@firebase&lt;/span&gt; 域中有相当多的包。如果你的网站只需要 firebase 的数据库组件，更改获取该库的 imports：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;import firebase from 'firebase';&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; import firebase from 'firebase/app'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; import 'firebase/database';
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　需要强调的是，对于较大的应用，这个过程要复杂得多。&lt;/p&gt;
&lt;p&gt;　　对于你非常确定没有在任何地方使用的看起来很神秘的包，请后退一步，查看哪些顶级依赖项正在使用它。试着找到一种方法，只从中导入你需要的组件。如果你没有使用一个库，则删除它。如果初始页面加载不需要这个库，则考虑是否可以 &lt;a title=&quot;lazy lodaed&quot; href=&quot;https://web.dev/fast/reduce-javascript-payloads-with-code-splitting&quot; target=&quot;_blank&quot;&gt;lazy loaded（延迟加载）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;删除非必需的库&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　并不是所有的库都可以容易地分解为多个部分并有选择地导入。在这些场景中，考虑是否可以完全删除这个库。构建自定义解决方案或利用更轻量级的替代方案始终是值得考虑的选项。但是，在从应用程序中完全删除一个库之前，必须权衡这两种工作的复杂性和工作量。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　了解更多，并将本指南付诸行动：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;a title=&quot;codelab-remove-unused-code&quot; href=&quot;https://web.dev/fast/remove-unused-code/codelab-remove-unused-code&quot; target=&quot;_blank&quot;&gt;https://web.dev/fast/remove-unused-code/codelab-remove-unused-code&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:29:00 +0000</pubDate>
<dc:creator>mr_nan</dc:creator>
<og:description>注：本文翻译自 https://web.dev/fast/remove-unused-code，Written by Houssein Djirdeh。如有翻译错误请指正。 像 npm 这样的包管理器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-nan/p/remove-unused-code.html</dc:identifier>
</item>
<item>
<title>使用FreeHttp强制登出微信公众号登陆状态（实现~原理） - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/10446739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/10446739.html</guid>
<description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;我们使用的部分网站设计成一旦登录即不允许用户手动退出，现实场景中是没有问题的&lt;/p&gt;
&lt;p&gt;但如果是在测试或调试过程中就会有强制登出的需求&lt;/p&gt;
&lt;p&gt;如果当前使用的是PC浏览器，您或许可以通过调试模式清除保持登录信息的数据实现手动退出。&lt;/p&gt;
&lt;p&gt;但是如果当前使用的手机WEB浏览器，或者其他web嵌入的方式（比如微信公众号）退出是十分困难的&lt;/p&gt;
&lt;p&gt;下面以退出微信公众号下的京东到家为例，说明如何使用FreeHttp实现手动退出登录功能（FreeHttp 说明 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html&lt;/a&gt;）&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;1：您需要为您的移动设备设置Fiddler代理，并安装证书（手机代理及证书的安装您可以通过百度查询到相关文章）&lt;/p&gt;
&lt;p&gt;2：FreeHttp的安装详见（&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#a00&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#a00&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;3：进入微信登录京东到家（测试中使用iphone6s移动设备）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203534674-731770011.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203615654-863426738.png&quot; alt=&quot;&quot; width=&quot;1100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1：这里需要选择一个session，该session包含该站点的登录信息的cookies，您可以逐个查找，当然如果您正在对该站进行测试或调试，您应该很清楚哪条请求包含这些信息&lt;/li&gt;
&lt;li&gt;2：选择完session后，我们使用Quick Rule中的Remove Session Cookies快速创建规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203811457-1676179214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当您选择Remove Session Cookies后会弹出上图对话框，询问您是否需要修改Set-Cookie的属性信息（如果不需要修改直接关闭即可），因为有时候当前URL的域可能不是浏览器中Cookie的Domian，这个时候您可能需要添加一个Domian来手动指定&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3：填写过滤规则，因为能不是每次都需要告诉终端让他清除cookies（事实上只需要一次就可以），这个Url一般都是主页html等关键请求（提示：您可以直接拖动session到输入框中，完成url的输入）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203756381-880777944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完成后您会发现『Response Modific』页Add Head加入了许多Set-Cookie（因为无法确认哪个cookie包含着登录信息，Remove Session Cookies会默认清除所有发现的cookie）&lt;br/&gt;当然大多数情况作为测试或开发人员您是知道页面哪个cookie标识的用户状态，如果是这样您不需要使用Remove Session Cookies删除页面下所有cookie，而可以直接使用delete cookie手动指定需要删除的cookie即可&lt;br/&gt;点击确认并设置规则生效&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;现在您可以在微信里刷新京东到家当前页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227203837851-1943851745.png&quot; alt=&quot;&quot; width=&quot;1100&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在列表中可以看到规则已经被匹配到，查看报表信息可以看到修改已经完成（黄色高亮session表示给请求是一个被FreeHttp修改过的请求）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201902/209007-20190227204143107-1928570293.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个时候再次查看微信公众号里的页面，您会发现当前已经处于未登录状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;因为Http本身是无状态的，如果要维护登录状态就需要应用层面实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般应用会将登录状态放在客户端Cookie中（这样浏览器会帮助管理维护cookie），也有一些服务API会将令牌放在自定义header或查询字符串等其他参数中（这一般出现在需要跨平台的服务中，因为不是所有应用环境都是在浏览器中，有些嵌入式设备根本没有浏览器）。&lt;/p&gt;
&lt;p&gt;这一点很好区分，您只需要对比登录状态下的请求与不登录状态下请求的全部即可&lt;/p&gt;
&lt;p&gt;我们这里是要清除微信公众号应用的登录状态（大部分都是通过cookie来做到的）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后问题变成如何清除指定cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们知道浏览器中的cookie是一般由请求返回头中的Set-Cookie指定的，浏览器接收到该返回头即会为指定站点创建Cookie信息（详细内容可以看这里 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;在有调试模式的浏览器中我们很容易实现，直接右键删除，或通过js删除，不过对于没有调试模式的手机终端前面的方法看起来行不通了。&lt;/p&gt;
&lt;p&gt;查看Set-Cookie规则，我们可以发现Max-Age属性（过期时间），那我们只要把过期时间设置的足够短不就可以骗过浏览器，让它删除我们想要删除的cookie&lt;/p&gt;
&lt;p&gt;注意这里Set-Cookie是响应头，所有必须浏览器先发起一个请求然后我们修改该请求的响应头，把带有Max-Age=1属性的Set-Cookie写入就可以了（Set-Cookie: name=delete by FreeHttp; Max-Age=1;Path=/）&lt;/p&gt;
&lt;p&gt;改响应的操作就直接通过Fiddler上的FreeHttp插件实现即可，操作即上文所述&lt;/p&gt;
&lt;p&gt;FreeHttp详细使用方法见（&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html&lt;/a&gt;）&lt;/p&gt;



&lt;p&gt;不过使用TLS可以对其安全性进行加强（即https），&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>概述 我们使用的部分网站设计成一旦登录即不允许用户手动退出，现实场景中是没有问题的 但如果是在测试或调试过程中就会有强制登出的需求 如果当前使用的是PC浏览器，您或许可以通过调试模式清除保持登录信息的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lulianqi/p/10446739.html</dc:identifier>
</item>
<item>
<title>Android开发如何轻松实现基于Tesseract的Android OCR应用程序 - 九天飞翼</title>
<link>http://www.cnblogs.com/langda/p/10453897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/langda/p/10453897.html</guid>
<description>&lt;p&gt;介绍 此应用程序使用Tesseract 3的Tesseract OCR引擎，该引擎通过识别字符模式（ https://github.com/tesseract-ocr/tesseract ）来工作。 Tesseract具有unicode（UTF-8）支持，可以开箱即用识别100多种语言。 背景 我尝试了Google文本识别API- https://deve&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;此应用程序使用Tesseract 3的Tesseract OCR引擎，该引擎通过识别字符模式（&lt;/span&gt;https://github.com/tesseract-ocr/tesseract&lt;span&gt;&lt;span&gt;）来工作。&lt;/span&gt;&lt;span&gt;Tesseract具有unicode（UTF-8）支持，可以“开箱即用”识别100多种语言。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我尝试了Google文本识别API- &lt;/span&gt;https://developers.google.com/vision/android/text-overview&lt;span&gt;，但它不适合我，所以我找到了这个惊人的引擎。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;开始吧！&lt;/span&gt;&lt;span&gt;在Android studio中创建一个新项目（我使用的是3.2.1版），或者您可以下载源文件并选择：File-New-Import项目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.codesocang.com/uploads/allimg/190228/22595243U-0.png&quot; alt=&quot;Android开发轻松实现基于Tesseract的Android OCR应用程序&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加到&lt;/span&gt;&lt;code&gt;build.gradle&lt;/code&gt;&lt;span&gt;应用程序级别：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot;&gt;
implementation &lt;span class=&quot;code-string&quot;&gt;'&lt;span class=&quot;code-string&quot;&gt;com.jakewharton:butterknife:8.8.1'
annotationProcessor &lt;span class=&quot;code-string&quot;&gt;'&lt;span class=&quot;code-string&quot;&gt;com.jakewharton:butterknife-compiler:8.8.1'

implementation &lt;span class=&quot;code-string&quot;&gt;'&lt;span class=&quot;code-string&quot;&gt;com.rmtheis:tess-two:9.0.0'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;我使用&lt;/span&gt;&lt;code&gt;Butterknife&lt;/code&gt;&lt;span&gt;库，它非常有用，主库是 - ' &lt;/span&gt;&lt;code&gt;tess-two:9.0.0&lt;/code&gt;&lt;span&gt;'' - 它包含一个Android的Tesseract工具（&lt;/span&gt;tesseract-android-tools&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;的分支，&lt;/span&gt;&lt;span&gt;它增加了一些额外的功能。&lt;/span&gt;&lt;span&gt;此外，我们需要相机和写入权限，因此将其添加到&lt;/span&gt;&lt;/span&gt;&lt;em&gt;AndroidManifest.xml&lt;/em&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot;&gt;
&amp;lt;uses-permission android:name=&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&amp;gt;
&amp;lt;uses-feature android:name=&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;android.hardware.camera&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&lt;span class=&quot;code-string&quot;&gt;&quot;&lt;span class=&quot;code-string&quot;&gt;android.permission.CAMERA&quot; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;做一个简单的布局文件&lt;/span&gt;&lt;code&gt;Button&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;TextView&lt;/code&gt;&lt;span&gt;并且&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://www.codesocang.com/kj-imageview/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;code&gt;ImageView&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;notranslate&quot; data-lang-guess=&quot;XML&quot;&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Feb 2019 15:22:00 +0000</pubDate>
<dc:creator>九天飞翼</dc:creator>
<og:description>介绍 此应用程序使用Tesseract 3的Tesseract OCR引擎，该引擎通过识别字符模式（ https://github.com/tesseract-ocr/tesseract ）来工作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/langda/p/10453897.html</dc:identifier>
</item>
<item>
<title>快速排序 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/10449346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/10449346.html</guid>
<description>&lt;h3&gt;首先介绍D&amp;amp;C递归&lt;/h3&gt;
&lt;p&gt;快速排序的思想是：分而治之(divide and conquer，D&amp;amp;C)一种递归式问题解决思路&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里先介绍D&amp;amp;C的工作原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）找出简单的基线条件&lt;/p&gt;
&lt;p&gt;　　2）确定如何缩小问题的规模，使其符合基线条件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组 {2 4 6}，把这些数组相加返回一个结果，使用循环很容易完成。&lt;/p&gt;
&lt;p&gt;但是如果使用递归函数来完成呢。&lt;/p&gt;
&lt;p&gt;第一步：找出基线条件。最简单的数组是什么样呢？如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。&lt;/p&gt;
&lt;p&gt;　　　　因此这就是基线条件。&lt;/p&gt;
&lt;p&gt;第二部：每次递归都必须离空数组更进一步，缩小问题的规模。&lt;/p&gt;
&lt;p&gt;　　　　sum(2,4,6)=2+sum{4,6} 给函数sum传递的数组更短。换言之 这缩小了问题的规模。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数sum的工作原理类似这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接受一个数组&lt;/p&gt;
&lt;p&gt;　　　　如果列表为空就返回0&lt;/p&gt;
&lt;p&gt;　　　　否则，计算表中除第一个数字意外其他数字的总和，将其与第一个数组相加，再返回结果。&lt;/p&gt;
&lt;p&gt;sum(2,4,6)=2+sum{4,6}。sum{4,6}=4+sum(6),&lt;span&gt; &lt;span&gt;sum{6}=6+sum{0}&lt;/span&gt;. sum{0}是基线条件，返回0&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; calSum(&lt;span&gt;int&lt;/span&gt;[] arr,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n&amp;gt;0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arr[n-1]+calSum(arr,n-1&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;快速排序&lt;/h3&gt;
&lt;p&gt;使用快速排序对数组：{3,5,9,6,1}进行排序&lt;/p&gt;
&lt;p&gt;基线条件为数组为空或只包含一个元素，在这种情况下，只需要原样返回数组——根本就不用排序。&lt;/p&gt;
&lt;p&gt;使用D&amp;amp;C将数组进行分解，直到满足基线条件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面介绍快速排序的工作原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）首先从数组中选择一个元素，这个元素被称为基准值(pivot)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）将数组分成两个子数组：小于基准值的元素和大于基准值的元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）对两个子数组进行快速排序。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] arr,&lt;span&gt;int&lt;/span&gt; left ,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; right){
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start =&lt;span&gt; left;
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end =&lt;span&gt; right;
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; key = arr[left];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准值&lt;/span&gt;
         &lt;span&gt;while&lt;/span&gt;(end&amp;gt;&lt;span&gt;start){
             &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;从后往前比较&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(end&amp;gt;start&amp;amp;&amp;amp;arr[end]&amp;gt;=key){&lt;span&gt;//如果不小于基准值 则比较下一个(指针减一)&lt;/span&gt;
                end--&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[end]&amp;lt;key){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比基准值小的则和基准值交换位置&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[end];
                arr[end] &lt;/span&gt;=&lt;span&gt; arr[start];
                arr[start] &lt;/span&gt;=&lt;span&gt; temp;
            }
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;从前往后比较&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(end&amp;gt;start&amp;amp;&amp;amp;arr[start]&amp;lt;=&lt;span&gt;key){
                start&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[start]&amp;gt;&lt;span&gt;key){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[start];
                arr[start] &lt;/span&gt;=&lt;span&gt; arr[end];
                arr[end] &lt;/span&gt;=&lt;span&gt; temp;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次循环后：左边的值都比关键值小，右边的值都比关键值大
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(start&amp;gt;left) sort(arr,left,start-1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边序列。第一个索引位置到关键值索引-1&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(end&amp;lt;right) sort(arr,end+1,right);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边序列。从关键值索引+1到最后一个&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;快速排序的平均情况和最糟情况&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;快速排序的性能高度依赖于你选择的基准值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设你总将第一个元素用作基准值，且要处理的数组是有序的，由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如数组{1,2,3,4,5,6,7,8}进行快速排序，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果选择1作为基准值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结果是数组没有被分成两半，其中一个子数组始终为空，这导致调用栈非常长(栈长为O(n))。整个算法所需要的时间O(n)*O(n)=O(n2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果总是将中间的元素作为基准值，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数组被一份为二，调用栈会短很多(栈长为O(log n))。整个算法所需要的时间为O(n)*O(logn)=O(nlogn)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：快速排序的时候 基准值尽可能的选取中间(大小)值&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 28 Feb 2019 15:20:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<og:description>首先介绍D&amp;C递归 快速排序的思想是：分而治之(divide and conquer，D&amp;C)一种递归式问题解决思路 这里先介绍D&amp;C的工作原理 1）找出简单的基线条件 2）确</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/10449346.html</dc:identifier>
</item>
<item>
<title>没搞懂的package.json - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/package-json.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/package-json.html</guid>
<description>&lt;p&gt;事情是这样的，今天上午，后端同学 clone 了我们的一个小程序项目，希望到自己的电脑上跑起来。&lt;/p&gt;
&lt;p&gt;然而，令人尴尬的是，他在 npm install 之后，项目并没有如愿运行，并抛出一个大大的错误。&lt;/p&gt;
&lt;p&gt;后来， 另一个前端同学灵机一动，将自己的 node_modules 拷给了他，小程序终于如愿在他电脑上跑了起来。此后我们群里有了下面的对话：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201902/1016471-20190228221653260-119869957.jpg&quot; alt=&quot;WechatIMG320.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本人自认为脸皮还算不薄，但是说我们的 node_modules 是祖传的，确实令人难以招架。。痛定思痛，为了防止被后端同学，乃至以后新来的前端同学 diss，我决定好好研究一下 package.json 这个文件。&lt;br/&gt;&lt;img width=&quot;30%&quot; src=&quot;https://ws1.sinaimg.cn/bmiddle/6af89bc8gw1f8nthg9s79j205t05rglx.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在讲解 package.json 之前，首先推荐阮老师的一篇文章，&lt;a href=&quot;http://javascript.ruanyifeng.com/nodejs/packagejson.html&quot;&gt;package.json 文件&lt;/a&gt;, 里面对需要了解的常用字段都有解释，比如 dependencies, devDependencies,scripts,main,version字段等，这里就不讲了。仅谈谈依赖的版本管理。&lt;/p&gt;
&lt;h3 id=&quot;依赖的版本管理&quot;&gt;依赖的版本管理&lt;/h3&gt;
&lt;p&gt;如果一个项目做了不兼容的更改，并发布了一个大版本，你的项目依赖了他的库，安装完成之后，十有八九是要报错的。所以我们要在package.json中告诉npm只能装哪个版本，或者哪几个版本的库。规则如下（摘自上面的文章）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。&lt;/li&gt;
&lt;li&gt;波浪号（tilde ～）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。&lt;/li&gt;
&lt;li&gt;插入号（caret ^）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。&lt;/li&gt;
&lt;li&gt;latest：安装最新版本。&lt;/li&gt;
&lt;li&gt;Patch releases: 1.0 or 1.0.x or ~1.0.4&lt;/li&gt;
&lt;li&gt;Minor releases: 1 or 1.x or ^1.0.4&lt;/li&gt;
&lt;li&gt;Major releases: * or x&lt;br/&gt;以上的表示在pakage.json中都是合法的描述。除此之外，npm官方还提供了一个好用的工具，来告诉我们某个&quot;表达式&quot;会覆盖到哪些版本：&lt;a href=&quot;https://semver.npmjs.com/&quot; class=&quot;uri&quot;&gt;https://semver.npmjs.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201902/1016471-20190228225514659-1464338046.png&quot; alt=&quot;uploading-image-410693.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;改动了依赖里的代码怎么办&quot;&gt;改动了依赖里的代码怎么办&lt;/h3&gt;
&lt;p&gt;这是上面说的那个祖传node_modules的真正原因了，由于当时mpvue一个包实现的问题，以及我们在原生语法写的项目中使用mpvue，我改动了包里的一行代码，这是我们的可以work，而到后端那里就会报错的根源所在。解决办法有这么几个：&lt;/p&gt;
&lt;h4 id=&quot;提交给官方一个pr等待merge&quot;&gt;1.提交给官方一个PR，等待merge&lt;/h4&gt;
&lt;p&gt;这个看官方的情况了，有可能很快merge，也可能快一年了还没个结果。可行性指数：🌟🌟🌟&lt;/p&gt;
&lt;h4 id=&quot;将自己修改过的发一个包&quot;&gt;2. 将自己修改过的发一个包&lt;/h4&gt;
&lt;p&gt;这种方法需要有npm账户，然后熟悉publish package的流程。可行性指数：🌟🌟🌟&lt;/p&gt;
&lt;h4 id=&quot;fork一份到自己的github下修改之后直接让npm从github安装这个包&quot;&gt;3.fork一份到自己的github下，修改之后，直接让npm从github安装这个包&lt;/h4&gt;
&lt;p&gt;此时package.json中的对应的字段应该是这样：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;xxx&quot;: &quot;git+https://github.com/xxx/koatest.git&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可行性指数：🌟🌟🌟🌟&lt;br/&gt;在操作的时候注意一点，修改过的代码merge到master分支上，不然装完了还不能work（完）。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Thu, 28 Feb 2019 15:13:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>事情是这样的，今天上午，后端同学 clone 了我们的一个小程序项目，希望到自己的电脑上跑起来。 然而，令人尴尬的是，他在 npm install 之后，项目并没有如愿运行，并抛出一个大大的错误。 后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/package-json.html</dc:identifier>
</item>
<item>
<title>AI贪吃蛇前瞻——基于Dijkstra算法的最短路径问题 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10453814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10453814.html</guid>
<description>&lt;p&gt;    在贪吃蛇流程结构优化之后，我又不满足于亲自操刀控制这条蠢蠢的蛇，干脆就让它升级成AI，我来看程序自己玩，哈哈。&lt;/p&gt;

&lt;p&gt;作为一种广为人知的单源最短路径算法，Dijkstra用于求解带权有向图的单源最短路径的问题。所谓单源，就是一个源头，也即一个起点。该算法的本质就是一个广度优先搜索，由中心向外层层层拓展，直到遇到终点或者遍历结束。该算法在搜索的过程中需要两个表S及Q，S用来存储已扫描过的节点，Q存储剩下的节点。起点s距离dist[s] = 0;其余点的值为无穷大（具体实现时，表示为某一不可能达到的数字即可）。开始时，从Q中选择一点u，放入S，以u为当前点，修改u周围点的距离。重复上述步骤，直到Q为空。&lt;/p&gt;


&lt;h2&gt;2.1 地图的表示方法&lt;/h2&gt;
&lt;p&gt;    与平时见到的各种连通图问题不同，贪吃蛇游戏中的地图可以看成是标准的矩形，也即，一个二维数组，图中各个相邻节点的权值为1。因此，我们可以用一个边长*边长的二维数组作为算法的主体数据结构，讲地图有关的数据都集成在数组里。既然选择了二维数组，就要考虑数组元素类型的问题，即我们的数组应该存储哪些信息。作为主要的数据结构，我们希望我们的数组能存储自身的坐标，起点到自身的最短路径，因此我们可以定义这样的一个结构体：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; loca{  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}Local;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; unit{  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; value;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Local local;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}Unit;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;    又因为我们需要得到最短路径以求得贪吃蛇下一步的方向，所以在结构体里加一个指针，指向前一个节点的位置。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; loca{  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}Local;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; unit{  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; value;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Local local;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; unit *pre;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}Unit;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设地图为一个正方形，因此创建一个边长*边长大小的二维数组：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;#define N 5&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Unit mapUnit[N][N];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2.2 队列——待处理节点的集合&lt;/h2&gt;
&lt;p&gt;    有了mapUnit之后，我们还需要一个数据结构来存储接下来需要处理的节点的信息。在此我选择了一个队列，由于C语言不提供标准的接口，就自己草草的写了一个。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; queue{  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; head,tail;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Local queue[N*N];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}Queue;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Queue que;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用了一个定长的数组来作为队列结构，所以为了应对所有的结果，将其长度设为N*N。也正因为是定长数组，队列的进队与出队只需操作表示下标值的head与tail即可。这样虽然不节约空间，但胜在实现方便。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; push(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    que.tail++;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    que.queue[que.tail].x = x;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    que.queue[que.tail].y = y;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; pop()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    que.head++;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于push操作有一个自增操作，所以在初始化时需要将tail设为-1，这样在push第一个节点时可保证head与tail指向同一个位置。&lt;/p&gt;

&lt;h2&gt;2.3 console坐标——地图的初始化&lt;/h2&gt;
&lt;p&gt;    在我的贪吃蛇链表实现中，前端展示时通过后台的计算逻辑+Pos函数来实现的，也就是现在后台计算结果，再推动前台的变化。因此Pos()，也就是使光标跳转到控制台某位置的函数就尤为重要，这也直接影响了整个项目各元素的坐标表示方法。&lt;/p&gt;
&lt;p&gt;    简单来说就是console的坐标表示类似于坐标轴中第四象限的表示方法，当然元素都为正值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230305931-1128871467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以对于一个N*N的数组，我们可以这样初始化：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; InitializeMapUnit()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    que.head = 0;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    que.tail = -1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = 0;i&amp;lt;N;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; j = 0;j&amp;lt;N;j++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            mapUnit[i][j].local.x = i;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            mapUnit[i][j].local.y = j;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            mapUnit[i][j].pre = NULL;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            mapUnit[i][j].value = N*N;   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将队列的初始化放在这个函数里实属无奈，这两行语句，又不能在初始化时赋值，又不能在函数体外赋值，放main函数嫌它乱，单独一个函数嫌它慢….就放在地图初始化里了…&lt;/p&gt;


&lt;h2&gt;3.1 设置起点&lt;/h2&gt;
&lt;p&gt;    基础的结构与初始化完成后，就需要开始计算了。在此之前，我们需要一个坐标，来作为路径问题的出发点。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; setOrigin(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    mapUnit[x][y].value = 0;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    push(x,y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将地图上该点位置的值设为0后，将其压入队列中。在第一轮的BFS中，它四周的点，将成为第二轮计算的原点。&lt;/p&gt;

&lt;h2&gt;3.2 BFS框架&lt;/h2&gt;
&lt;p&gt;    在该地图的BFS中，我们将依托队列各个元素，来处理它们的邻接节点。两个循环，可以揭示大体的框架：&lt;/p&gt;
&lt;ol readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; bfs(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; end_x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; end_y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;当前需要处理的节点&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = head;i&amp;lt;=tail;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;//  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;四个方向&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; j = 0;j&amp;lt;4;j++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;span&gt;// &lt;/span&gt;&lt;/span&gt;&lt;span&gt;新节点&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(mapUnit[new_x][new_y].value == N*N)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;设置属性&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;span&gt;//  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;处理过&lt;span&gt;的节点，取小值&lt;/span&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;属性更改&lt;/span&gt;&lt;span&gt;&lt;span&gt;Or&lt;/span&gt;&lt;span&gt;不变&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;下一轮&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    bfs();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.3 变化的队列&lt;/h2&gt;
&lt;p&gt;    BFS的主体循环依赖于队列的head与tail，但是对新节点的push操作改变了tail的值，所以我们需要在循环开始前将此时（上一轮BFS的结果）的队列状态保存下来，避免队列变化对BFS的影响。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; head = que.head;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; tail = que.tail;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前队列&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = head;i&amp;lt;=tail;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;// TODO... &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.4 节点的坐标&lt;/h2&gt;
&lt;p&gt;    在原来写的BFS中，要获取一个节点的下标需要将一个结构体层层剥开，数组的下标是一个结构体某元素的某元素，绕来绕去，可读性早已被献祭了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230307088-1257132986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以这次我吸取了教训，在内循环，也就是处理周围节点时，将其坐标先存储在变量中，用来确保程序的可读性。&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = head;i&amp;lt;=tail;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; base_x = que.queue[i].x;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; base_y = que.queue[i].y;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;//  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;四个&lt;span&gt;方向&lt;/span&gt;&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; j = 0;j&amp;lt;4;j++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; new_x = base_x + direct[j][0];  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; new_y = base_y + direct[j][1];  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;// TODO... &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我们可以构建出这样一个移动的二维数组：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;//          &lt;/span&gt;&lt;span&gt;方向，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; direct[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.4.1 数组越界的处理&lt;/h3&gt;
&lt;p&gt;    在得到了待处理节点的坐标后，需要对其进行判断，确保它在数组内部。&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(stepRight(new_x,new_y) == &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数细节如下：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;span&gt; stepRight(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(x &amp;gt;= N || y &amp;gt;= N ||  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        x &amp;lt; 0 || y &amp;lt; 0)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;3.5 新节点的处理&lt;/h2&gt;
&lt;h3&gt;    终于到了访问邻接坐标的时候。一个节点四周的节点，有可能没有被访问过，也可能以及被访问过。我们在初始化时就将所有节点的值设为了一个MAX，通过对值得判断，可以推断出其是否为新节点。&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(mapUnit[new_x][new_y].value == N*N)  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;取小值&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;// ...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;3.5.1 未处理节点的处理&lt;/h3&gt;
&lt;p&gt;    对于未处理的节点，对其的操作有两部。一是初始化，值的初始化与指针的初始化。由于两点间的距离为1，所以该节点的值为前一个节点的值+1，当然，他的pre指针也指向前一个节点。&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;mapUnit[new_x][new_y].value = mapUnit[base_x][base_y].value +1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;mapUnit[new_x][new_y].pre = &amp;amp;mapUnit[base_x][base_y];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;push(new_x,new_y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.5.2 已处理节点的处理&lt;/h3&gt;
&lt;p&gt;    对于已处理过的节点，需要先将其做一个判断，即寻找最短路径，将其自身的value与前一节点value+1比较，再处理。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;mapUnit[new_x][new_y].value = MIN(mapUnit[new_x][new_y].value,mapUnit[base_x][base_y].value +1);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(mapUnit[new_x][new_y].value != mapUnit[new_x][new_y].value)  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;mapUnit[new_x][new_y].pre = &amp;amp;mapUnit[base_x][base_y];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.6 队列的刷新&lt;/h2&gt;
&lt;p&gt;    在处理完一层节点后，新的节点导致了队列中tail的增加，但是head并没有减少，所以在新一轮BFS前，需要将队列的head移动到真正的头部去。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = head;i&amp;lt;=tail;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    pop();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这儿也需要当前BFS轮数前的队列数据。&lt;/p&gt;

&lt;h2&gt;3.7 最短路径&lt;/h2&gt;
&lt;p&gt;    在地图的遍历完成之后，我们就可以任取一点，得到起点到该点的最短路径。&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; getStep(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Unit *scan = &amp;amp;mapUnit[x][y];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(scan-&amp;gt;pre!= NULL)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x = scan-&amp;gt;local.x;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y = scan-&amp;gt;local.y;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        scan = scan-&amp;gt;pre;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        getStep(scan-&amp;gt;local.x,scan-&amp;gt;local.y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        printf(&lt;span&gt;&quot; -&amp;gt; &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;    printf(&lt;span&gt;&quot;(%d,%d)&quot;&lt;span&gt;,x,y);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    在贪吃蛇中，由于蛇身长度的存在，以及蛇头咬到自身就结束的特例，我们需要在算法中加入障碍的元素。&lt;/p&gt;
&lt;p&gt;    对于这个新加入的元素，我们设置一个坐标结构体的数组，来存储所有的障碍。&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;#define WALL_CNT 3 &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Local Wall[WALL_CNT];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;    用一个函数来设置障碍：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; setWall(&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[0].x = 1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[0].y = 1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[1].x = 1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[1].y = 2;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[2].x = 2;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Wall[2].y = 1;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;    由于这个项目里数据用于模块测试的随机性，所以手动设置每一个坐标。在之后的贪吃蛇AI中，将接受一个数组——蛇身，来自动完成赋值。&lt;/p&gt;
&lt;p&gt;    如果将障碍与地图边界等同来看，就能将障碍的判断整合进stepRight()函数。&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;span&gt; stepRight(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;//  out of map &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(x &amp;gt;= N || y &amp;gt;= N ||  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        x &amp;lt; 0 || y &amp;lt; 0)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;//  wall&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = 0;i&amp;lt;WALL_CNT;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(Wall[i].x == x &amp;amp;&amp;amp; Wall[i].y == y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    完成了上诉的模块后，项目就可以无BUG但是低效的跑了。我们来试一试，在一个5*5的地图中，起点在中间，为（2，2），终点在起点的上上方，为（2，0），设置三面围墙，分别是（1，1），（2，1），（3，1）。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230307765-1145396778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    看看效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230308367-859216854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    图中二维数组打印了各个坐标点的value，即该点到起点的最短路径。25为墙，0为起点。可以看到到终点需要六步，路径是先往左，再往上，左后向右到终点。&lt;/p&gt;
&lt;p&gt;    任务完成，看似不错。把终点换近一些看看，就（1，4）吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230309096-189907098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    喔，问题出来了。我取一个非常近的点，但是整张图都被遍历了，效率太低了，要改进。&lt;/p&gt;
&lt;p&gt;    还有一个问题，如果将起点周围四个点都设置为墙，结果应该是无法得到其余点的最短路径，但现阶段的结果还不尽如人意：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230309542-1809522155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;6.1 遍历的半途结束&lt;/h2&gt;
&lt;p&gt;    在BFS中，如果找到了终点，那就可以退出遍历，直接输出结果。不过这样的一个递归树，要随时终止可不容易。我一开始想到了&quot;万恶之源&quot;goto，不过goto不能跨函数跳转，随后又想到了非本地跳转setjmp与longjmp。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&quot;与刺激的&lt;a href=&quot;https://baike.baidu.com/item/abort/9536155&quot; target=&quot;_blank&quot;&gt;abort&lt;/a&gt;()和exit()相比,&lt;a href=&quot;https://baike.baidu.com/item/goto%E8%AF%AD%E5%8F%A5/7603004&quot; target=&quot;_blank&quot;&gt;goto语句&lt;/a&gt;看起来是处理异常的更可行方案。不幸的是，&lt;a href=&quot;https://baike.baidu.com/item/goto/12755716&quot; target=&quot;_blank&quot;&gt;goto&lt;/a&gt;是本地的：它只能跳到所在函数内部的标号上，而不能将控制权转移到所在程序的任意地点（当然，除非你的所有代码都在main体中）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为了解决这个限制，C函数库提供了setjmp()和longjmp()函数，它们分别承担非局部标号和goto作用。头文件&amp;lt;setjmp.h&amp;gt;申明了这些函数及同时所需的jmp_buf数据类型。&quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;    有了这随时能走的&quot;闪现&quot;功能，跳出复杂嵌套函数还是事儿嘛？&lt;/p&gt;
&lt;ol readability=&quot;13.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;setjmp.h&amp;gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;jmp_buf&lt;/strong&gt;&lt;span&gt; jump_buffer;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; main (&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(setjmp(jump_buffer) == 0)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        bfs(finishing_x,finishing_y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于跳转需要判断当前节点是否为终点，而终点又是一个局部变量，所以需要改变bfs函数，使其携带终点参数。&lt;/p&gt;
&lt;p&gt;再在处理完一个节点后，判断其是否为终点，是则退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = head;i&amp;lt;=tail;i++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;//  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;四个方向&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; j = 0;j&amp;lt;4;j++)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(mapUnit[new_x][new_y].value == N*N)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;取小值&lt;/span&gt;&lt;span&gt; &lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;//...&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(new_x == end_x &amp;amp;&amp;amp; new_y == end_y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            longjmp(jump_buffer, 1);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;6.2 无最短路径时的处理&lt;/h2&gt;
&lt;p&gt;    在判断某一点的路径时，可先判断其是否存在最短路径，存在则输出，否则给出提示信息。&lt;/p&gt;
&lt;ol readability=&quot;19&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; getStepNext(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Unit *scan = &amp;amp;mapUnit[x][y];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(scan-&amp;gt;pre!= NULL)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x = scan-&amp;gt;local.x;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y = scan-&amp;gt;local.y;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        scan = scan-&amp;gt;pre;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        getStepNext(scan-&amp;gt;local.x,scan-&amp;gt;local.y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        printf(&lt;span&gt;&quot; -&amp;gt; &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;    printf(&lt;span&gt;&quot;(%d,%d)&quot;&lt;span&gt;,x,y);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; getStep(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; y,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; orgin_x,&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; orgin_y)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    Unit *scan = &amp;amp;mapUnit[x][y];  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    Pos(0,10);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(scan-&amp;gt;pre == NULL)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;        printf(&lt;span&gt;&quot;NO Path To Point (%d,%d) From Point (%d,%d)!\n&quot;&lt;span&gt;,x,y,orgin_x,orgin_y);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        getStepNext(x,y);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201902/1219242-20190228230309971-1164732735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    算法大体上完成了，将其改为贪吃蛇AI也只需做少量修改。尽量抽个时间把AI写完，不过可能需要一段时间。&lt;/p&gt;
&lt;p&gt;    在最短路径的解法上，Dijkstra算法并不是最理想的解法。盲目搜索的效率很低。考虑到地图上存在着两点间距离等信息，可以使用一种启发式搜索算法，如BFS(Best-First Search)，以及大名鼎鼎的A*算法。在中文互联网我能找到的有关于A*算法的资料不多，将来得花些时间好好研究下。&lt;/p&gt;
&lt;p&gt;    源码地址：&lt;a href=&quot;https://github.com/MagicXyxxx/Algorithms&quot;&gt;https://github.com/MagicXyxxx/Algorithms&lt;/a&gt;    &lt;/p&gt;

</description>
<pubDate>Thu, 28 Feb 2019 15:03:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>在贪吃蛇流程结构优化之后，我又不满足于亲自操刀控制这条蠢蠢的蛇，干脆就让它升级成AI，我来看程序自己玩，哈哈。 一、Dijkstra算法原理 作为一种广为人知的单源最短路径算法，Dijkstra用于求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10453814.html</dc:identifier>
</item>
<item>
<title>CSS学习笔记之float浮动属性 - 路漫漫我不畏</title>
<link>http://www.cnblogs.com/huwt/p/10447421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwt/p/10447421.html</guid>
<description>
&lt;h3&gt;一、前言&lt;/h3&gt;

&lt;p&gt;　　浮动元素以脱离标准流的方式来实现元素的向左或向右浮动。float浮动属性的四个参数：left：元素向左浮动；right：元素向右浮动；none：默认值，元素不浮动；inherit：继承父元素的float属性值。&lt;/p&gt;
&lt;h4&gt;举个栗子&lt;/h4&gt;
&lt;p&gt;父元素是否注意到自己有个浮动的子div呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 400px; height: auto; border: 2px solid black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 50px; height: 100px; background-color: green; float: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    我才不知道有没有浮动框，我只显示文字的高度
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190227230654944-661334154.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从中我们可以发现，处于标准流中的父div并不知道浮动元素的存在，而浮动元素却知道它父元素的边界，它一直向右浮动直到撞到了父框的右边界为止。&lt;/p&gt;

&lt;p&gt;下面我们一起逐步学习CSS中的浮动属性float。&lt;/p&gt;

&lt;h3&gt;二、浮动之于文本&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn/cssref/pr_class_float.asp&quot; target=&quot;_blank&quot;&gt;CSS参考手册&lt;/a&gt;上对float的说明：&lt;/p&gt;
&lt;p&gt;　　float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，&lt;span&gt;使文本围绕在图像周围&lt;/span&gt;，不过在 CSS 中，&lt;span&gt;任何元素都可以浮动。浮动元素会生成一个块级框&lt;/span&gt;，而不论它本身是何种元素。&lt;/p&gt;
&lt;p&gt;　　如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。&lt;/p&gt;

&lt;h4&gt;1.实现文本环绕图像&lt;/h4&gt;
&lt;p&gt;　　浮动框虽然脱离了标准流，但标准流中的文本依旧会做相应的移动，为浮动框留出空间。浮动框旁边的行框被缩短，从而给浮动框留出空间，行框围绕浮动框。&lt;/p&gt;
&lt;p&gt;　　因此，创建浮动框可以使文本围绕图像：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228141718300-960040353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;举个小栗子&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 350px; background-color: #33FFFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://h5ip.cn/ge0w&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 100px; float: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    路飞性格积极乐观，爱憎分明，而且十分重视伙伴，不甘屈居于他人之下，对任何危险的事物都超感兴趣。和其他传统的海贼所不同的是，他并不会为了追求财富而杀戮，而是享受着身为海贼的冒险和自由
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228142543748-223413147.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.任何元素浮动后都将生成块级框&lt;/h4&gt;
&lt;p&gt; 　　首先应当注意块级框不等同于块状元素，块级元素会独占一行而块级框却不会，&lt;span&gt;浮动元素产生的效果类似于行内块元素&lt;/span&gt;。对行内元素设置width和height是无效的，但生成浮动元素之后width和height将有效。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 50px; background-color: #6699FF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    不浮动的span
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 50px; background-color: #33FFFF; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    浮动的span
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228145519069-1556834683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三、浮动之于块 &lt;/h3&gt;

&lt;h4&gt;　　浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。&lt;/h4&gt;

&lt;p&gt;不浮动的div为块级元素，各自独占一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 不浮动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 240px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228152530769-1230925906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 框一右浮 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 240px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: red; float: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228155244662-878771840.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。注意：浮动元素要先写与覆盖元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 框一左浮，覆盖框二 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 240px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: red; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228155104834-1511857485.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框，这时父框的高度为0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 三框左浮 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 240px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: red; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228155020058-1938423892.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 三框左浮，父框太窄 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: red; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228154314046-1656248951.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 三框左浮，框一卡框三 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: auto; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 100px; background-color: red; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框一
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: green; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框二
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 80px; background-color: blue; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        框三
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228154752294-454709299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、浮动的副作用及处理 &lt;/h3&gt;

&lt;p&gt; 　　通过上面的介绍可以总结出浮动的两个副作用：1.页面塌陷，也就是子元素不能将父元素撑开；2.元素覆盖，浮动元素不在标准流中因此可能会覆盖标准流中的元素。四种解决方案如下：&lt;/p&gt;

&lt;h4&gt;1.手动给父元素添加高度&lt;/h4&gt;
&lt;p&gt;　　这种方法用来解决父元素的页面塌陷问题，应当注意的是，为保证父框的高度等于最高浮动元素的高度应当充分考虑浮动元素的边框以内外边距。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对于有边框的浮动子元素，父元素的height = 子元素的height + 2*子元素的边框大小 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: 52px; border: solid 1px black;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: red; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: blue; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228193759789-464292008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式治标不治本，当浮动子元素增加时，页面塌陷问题重现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228194434799-858825426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;2.通过clear属性清除内部和外部浮动&lt;/h4&gt;
&lt;p&gt;　　clear 属性规定元素的哪一侧不允许其他浮动元素。clear属性的四个参数：none（默认值）、left、right、both；如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;添加clear属性之前&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228201104229-1457003006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果后一个div未添加clear属性，它将被红色div覆盖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: auto; border: solid 1px black; clear: both;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: red; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; border: solid 1px #FFF; clear: left; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;添加之后&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228201131379-1303982521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;添加clear前&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228201532053-472839737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在最后增加一个具有clear属性的空div &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: auto; border: solid 1px black; clear: both;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: red; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: blue; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: blue; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot; clear: both;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;添加之后&lt;br/&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228200540596-913418705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;3.给父元素添加overflow属性并结合zoom:1使用&lt;/h4&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用overfloat和zoom代替clear &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: auto; border: solid 1px black; clear: both; overflow: hidden; zoom: 1;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: red; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: blue; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: green; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 80px; height: 50px; background-color: blue; float: left; border: solid 1px #FFF;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228202003702-1483289029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; overflow属性是用来修剪溢出的元素，所以使用此种方案会使溢出元素被截掉&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;使用overflow前&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228225357844-1117263173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: auto; border: solid 1px black; clear: both; padding: 5px; overflow: hidden;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 500px; height: 50px; background-color: red; border: solid 1px #FFF; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;使用后&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228202523293-562293853.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; zoom是IE浏览器专用的属性，通过子元素的高度来设置父元素的高度，添加该属性用来兼容IE浏览器&lt;/p&gt;

&lt;h4&gt;4.给父元素添加浮动&lt;/h4&gt;
&lt;p&gt;　　这是一种”以毒攻毒“的方法，因为父元素浮动后虽然消除了浮动子元素对其的影响，但父元素下面的元素就可能就会受该浮动父元素的影响。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 300px; height: auto; border: solid 1px black; clear: both; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 100px; height: 50px; background-color: red; float: left;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 100px; background-color: blue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538862/201902/1538862-20190228204037917-981488660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这四种常用的清除浮动解决办法可以根据实际情况进行使用，当然还有一些也比较好的解决办法，例如使用before伪类清除浮动，等进一步学习之后再补充。&lt;/p&gt;

&lt;h3&gt; 五、最后&lt;/h3&gt;

&lt;p&gt;　　感谢博主谦行的博客：&lt;a href=&quot;https://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html&quot; target=&quot;_blank&quot;&gt;CSS布局 ——从display，position， float属性谈起&lt;/a&gt;以及&lt;a href=&quot;http://www.w3school.com.cn/css/css_positioning_floating.asp&quot; target=&quot;_blank&quot;&gt;W3School&lt;/a&gt;提供的学习资料！所学不深，如有错误或不足之处还望留言指出，十分感谢！&lt;/p&gt;

</description>
<pubDate>Thu, 28 Feb 2019 14:59:00 +0000</pubDate>
<dc:creator>路漫漫我不畏</dc:creator>
<og:description>一、前言 浮动元素以脱离标准流的方式来实现元素的向左或向右浮动。float浮动属性的四个参数：left：元素向左浮动；right：元素向右浮动；none：默认值，元素不浮动；inherit：继承父元素</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwt/p/10447421.html</dc:identifier>
</item>
<item>
<title>ArcGIS紧凑型切片读取与应用2-webgis动态加载紧凑型切片(附源码) - ATtuing</title>
<link>http://www.cnblogs.com/ATtuing/p/10437979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ATtuing/p/10437979.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     上篇主要讲了一下紧凑型切片的的解析逻辑，这一篇主要讲一下使用openlayers动态加载紧凑型切片的web地图服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上篇已经可以通过切片的x、y、z得对应的切片图片，现在使用asp.net mvc方式提供读取服务，这里有一问题就是频繁打开切文件会存在资源未释放的占用的情况，导致请求失败，这里使用单例模式保证相同切片文件只打开一次，并且提供文件缓存与过期释放机制，加快服务的请求返回速率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.切片请求服务入口，提供基本的参数x、y、z以及紧凑切片文件路径，系统返回对应的切片数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切片请求控制器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; ActionResult GetTile(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; z)
{
     &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
     {
         ArcgisBundleHelper Helper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArcgisBundleHelper(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;G:\feiq\Recv Files\Map_test\map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; Helper.GetTile(x, y, z);
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; File(data, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image/jpeg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     }
     &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
     {
         &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.单例模式实现的切文件缓存类，实现切片文件的新增缓存、过期缓存清除，以及通过索引的方式访问切片文件。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓存切片单例类
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TileCache
{
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取切片文件索引
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; BundleCache &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[bundlx id]
     {
         &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
         {
                 &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (obj)
                 {
                     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AddBundleCache(id);
                 }

        }
     }
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; TileCache instance;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TileCache() { }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程安全单例&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; TileCache Instance
     {
         &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
         {
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instance)
             {
                 &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (obj)
                 {
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instance)
                     {
                         instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TileCache();
                     }
                 }

            }
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
         }
     }
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置最多缓存文件数目
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cacheCount = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 切片文件缓存集合类
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;BundleCache&amp;gt; bundleCacheList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;BundleCache&amp;gt;&lt;span&gt;();
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过id返回切片缓存
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cache&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BundleCache AddBundleCache(bundlx cache)
     {
         &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; cacheid =&lt;span&gt; cache.id;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bundleCacheList.Select(e =&amp;gt;&lt;span&gt; e.BundleId).ToList().Contains(cacheid))
             {
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新最后访问时间&lt;/span&gt;
                 BundleCache tem = bundleCacheList.Where(e =&amp;gt; e.BundleId ==&lt;span&gt; cacheid).FirstOrDefault();
                 tem.LastTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
                 changeCache();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bundleCacheList.Where(e =&amp;gt; e.BundleId ==&lt;span&gt; cacheid).FirstOrDefault();
             }
             &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
             {
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未添加的文件，写入缓存集合&lt;/span&gt;
                 BundleCache bc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BundleCache();
                 bc.BundleId &lt;/span&gt;=&lt;span&gt; cache.id;
                 bc.CTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
                 bc.LastTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
                 &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(cache.bundlxFileName, FileMode.Open))
                 {
                     &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bufferfile = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[file.Length];
                     file.Read(bufferfile, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)file.Length);
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入数据&lt;/span&gt;
                     bc.BundlxData =&lt;span&gt; bufferfile;
                 }
                 &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(cache.bundleFileName, FileMode.Open))
                 {
                     &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bufferfile = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[file.Length];
                     file.Read(bufferfile, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)file.Length);
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入数据&lt;/span&gt;
                     bc.BundleData =&lt;span&gt; bufferfile;
                 }
                 bundleCacheList.Add(bc);
                 changeCache();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bc;
         }
     }
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保证缓存文件数目一定
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeCache()
     {
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bundleCacheList.Count&amp;gt;&lt;span&gt;cacheCount)
         {
             bundleCacheList&lt;/span&gt;= bundleCacheList.OrderByDescending(e =&amp;gt;&lt;span&gt; e.LastTime).ToList().Take(cacheCount).ToList();
         }
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.我们的服务地址为 &quot;/Tile/GetTile?x={x}&amp;amp;y={y}&amp;amp;z={z}&quot;，使用openlayers动态加载紧凑型切片。加载的结果如图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/821154/201902/821154-20190226160222564-1310599011.png&quot;&gt;&lt;img title=&quot;TIM截图20190226151054&quot; src=&quot;https://img2018.cnblogs.com/blog/821154/201902/821154-20190226160224215-1784543379.png&quot; alt=&quot;TIM截图20190226151054&quot; width=&quot;632&quot; height=&quot;381&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
     ViewBag.Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     Layout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;style&amp;gt;&lt;span&gt;

    html, body, #map {
         height: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;;
         width: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;;
         margin: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
         padding: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

&amp;lt;/div&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Content/openlayer4.64/ol.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &lt;span&gt;var&lt;/span&gt; mapurl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Tile/GetTile?x={x}&amp;amp;y={y}&amp;amp;z={z}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maplayer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
         name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testLayer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 瓦片图像数据源&lt;/span&gt;
         source: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.XYZ({
             crossOrigin: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;anonymous&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
             url: mapurl
         }),
         opacity: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
     });
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Map({
         target: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         layers: [
             maplayer
         ],
         view: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.View({
             center: ol.proj.fromLonLat([&lt;/span&gt;&lt;span&gt;104.41&lt;/span&gt;, &lt;span&gt;33.82&lt;/span&gt;&lt;span&gt;]),
             zoom: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
         })
     });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.结束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     上面方法使用动态解析紧凑型切片的方式，实现webgis的实时加载功能，由于是动态解析文件，返回的效率不高，下一篇我们开发一个程序，实现从紧凑型切片批量转为分散型切片的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;百度网盘链接：&lt;a href=&quot;https://pan.baidu.com/s/1I-Bj3EQSN57pQHvKZ2hBUA&quot;&gt;https://pan.baidu.com/s/1I-Bj3EQSN57pQHvKZ2hBUA&lt;/a&gt;   提取码：lliw&lt;/p&gt;
&lt;p&gt;github项目地址：&lt;a title=&quot;https://github.com/HuHongYong/TilerArcgisBundle&quot; href=&quot;https://github.com/HuHongYong/TilerArcgisBundle&quot;&gt;https://github.com/HuHongYong/TilerArcgisBundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：ATtuing&lt;/p&gt;
&lt;p&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/ATtuing&quot;&gt;http://www.cnblogs.com/ATtuing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 14:45:00 +0000</pubDate>
<dc:creator>ATtuing</dc:creator>
<og:description>1.前言 上篇主要讲了一下紧凑型切片的的解析逻辑，这一篇主要讲一下使用openlayers动态加载紧凑型切片的web地图服务。 2.代码实现 上篇已经可以通过切片的x、y、z得对应的切片图片，现在使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ATtuing/p/10437979.html</dc:identifier>
</item>
<item>
<title>C# GDI+编程之绘图 - 阡陌染</title>
<link>http://www.cnblogs.com/forever-Ys/p/10453722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forever-Ys/p/10453722.html</guid>
<description>&lt;p&gt;　　在了解绘图之前，我们先讲几个预备知识&lt;/p&gt;
&lt;h2&gt;一、坐标系&lt;/h2&gt;
&lt;p&gt;　　坐标系是图形设计的基础。GDI+使用三个坐标空间：世界、页面和设备，其中，世界坐标是用于建立特殊图形世界模型的坐标系，也是在.NET Framework中传递给方法的坐标系。而页面坐标系是指绘图图画（如窗体、控件）使用的坐标系。设备坐标系是在其上绘制的物理设别（如屏幕和纸张）所使用的坐标系。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;坐标系总是以左上角为原点（0,0）&lt;/span&gt;，除了原点之外，坐标系还包括横坐标（X轴）和纵坐标（Y轴）&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、像素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　像素全称为图像元素，它是构成图像的基本单位。通常以像素每英寸PPI（pixels per inch）为单位来表示图像分辨率的大小。例如：1024*768分辨率表示水平方向上每英寸长度上的像素数是1024，垂直方向是768&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、绘图&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　3.1 画笔&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　画笔使用Pen类表示，主要用于绘制线条，或者线条组合成的其他几何形状，它的构造函数为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Pen(Color color, &lt;span&gt;float&lt;/span&gt; width)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：color 设置Pen的颜色&lt;/p&gt;
&lt;p&gt;　　　　　　　width 设置Pen的宽度&lt;/p&gt;
&lt;p&gt;　　例如创建一个Pen对象，使其颜色为蓝色，宽度为2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Pen MyPen = &lt;span&gt;new&lt;/span&gt; Pen(Color.Blue, &lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上内容参照自MSDN，详细参考 MSDN &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.drawing.pen?view=netframework-4.7.2&quot; target=&quot;_blank&quot;&gt;Pen Class&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;　　3.2 画刷&lt;/h3&gt;
&lt;p&gt;　　画刷使用Brush类表示，主要用于填充几何图形，如将正方形和圆形填充其他颜色等。&lt;span&gt;它是一个抽象基类，不能实例化。&lt;/span&gt;如果要创建一个画刷对象，需要使用从Brush类派生出的类。&lt;/p&gt;
&lt;p&gt;　　Brush类常用的派生类及说明：&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;派生类&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SolidBrush&lt;/td&gt;
&lt;td&gt;定义单色画刷&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;HatchBrush&lt;/td&gt;
&lt;td&gt;提供一种特定样式的图形，用来制作填满整个封闭区间的绘图效果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LinerGradientBrush&lt;/td&gt;
&lt;td&gt;提供一种渐变色彩的特效，填充图形的内部区域&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TextureBrush&lt;/td&gt;
&lt;td&gt;使用图像来填充图形的内部&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
Brush MyBrush = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolidBrush(Color.BlueViolet);

HatchBrush hb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HatchBrush(HatchStyle.DiagonalBrick, Color.Yellow);

LinearGradientBrush linGrBrush &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinearGradientBrush(
   &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
   &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
   Color.FromArgb(&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;), 
   Color.FromArgb(&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码创建了不同类型的画刷对象，创建后面两个画刷对象是需要引入System.Drawing.Drawing2D命名空间&lt;/p&gt;
&lt;p&gt;　　以上内容来自MSDN，详情参看MSDN &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.drawing.brush?view=netframework-4.7.2&quot; target=&quot;_blank&quot;&gt;Brush Class&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;　　3.3 绘制直线&lt;/h3&gt;
&lt;p&gt;　　调用Graphics类中的DrawLine方法，结合Pen对象可以绘制直线（如果对Graphics类不了解，可以参考我之前写的博客 &lt;a href=&quot;https://www.cnblogs.com/forever-Ys/p/10447617.html&quot; target=&quot;_blank&quot;&gt;C#之Graphics类&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　DrawLine方法有两种构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawLine(Pen pen, Point pt1, Point pt2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明： pt1   Point结构或PointF结构，表示要连接的第一个点　　　　　　pt2 表示要连接的第二个点&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;span&gt;Point和PointF使用方法完全相同，只是Point的X和Y的类型为int，而PointF的X和Y为float，因此PointF通常用于表示坐标不是整数的情况&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawLine(Pen pen, &lt;span&gt;int&lt;/span&gt; x1, &lt;span&gt;int&lt;/span&gt; y1, &lt;span&gt;int&lt;/span&gt; x2, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y2);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawLine(Pen pen, &lt;span&gt;float&lt;/span&gt; x1, &lt;span&gt;float&lt;/span&gt; y1, &lt;span&gt;float&lt;/span&gt; x2, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; y2);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; x1,y1,x2,y2 分别表示第一个点的横纵坐标和第二个点的横纵坐标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　3.4 绘制矩形&lt;/h3&gt;
&lt;p&gt;　　通过Graphics类中的DrawRectangle或者FillRectangle方法可以绘制矩形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawRectangle(Pen pen, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawRectangle(Pen pen, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x，y表示要绘制矩形左上角的x坐标和y坐标
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;width表示要绘制矩形的宽度，height表示高度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillRectangle(Brush brush, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillRectangle(Brush brush, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DrawRectangle和FillRectangle的区别是DrawRectangle只是绘制图形，FillRectangle是对图形进行填充&lt;/p&gt;
&lt;p&gt;下面示例制作一个柱形图，当点击绘制按钮的时候就会开始绘制，使用到了窗体方面的知识&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing.Drawing2D;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; GDI_绘图
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Graphics g &lt;/span&gt;=&lt;span&gt; CreateGraphics();
            Pen MyPen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Pen(Color.Blue, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;10&lt;/span&gt;; i++)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制纵向线条&lt;/span&gt;
&lt;span&gt;            {
                g.DrawLine(MyPen, x, &lt;/span&gt;&lt;span&gt;400&lt;/span&gt;, x, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                x &lt;/span&gt;+= &lt;span&gt;40&lt;/span&gt;&lt;span&gt;;
            }
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程休眠200毫秒，便于观察绘制情况&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;400&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; +&lt;span&gt;10&lt;/span&gt;; i++)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制横向线条 &lt;/span&gt;
&lt;span&gt;            {
                g.DrawLine(MyPen, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, y, &lt;span&gt;550&lt;/span&gt;&lt;span&gt;, y);
                y &lt;/span&gt;-= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
            }
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;);
            x &lt;/span&gt;= &lt;span&gt;110&lt;/span&gt;&lt;span&gt;;
            y &lt;/span&gt;= &lt;span&gt;400&lt;/span&gt;&lt;span&gt;;
            Brush MyBrush &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolidBrush(Color.BlueViolet);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] saleNum = { &lt;span&gt;120&lt;/span&gt;, &lt;span&gt;178&lt;/span&gt;, &lt;span&gt;263&lt;/span&gt;, &lt;span&gt;215&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;, &lt;span&gt;111&lt;/span&gt;, &lt;span&gt;265&lt;/span&gt;, &lt;span&gt;171&lt;/span&gt;, &lt;span&gt;136&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;129&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;saleNum.Length; i++&lt;span&gt;)
            {
                g.FillRectangle(MyBrush, x, y&lt;/span&gt;-saleNum[i], &lt;span&gt;20&lt;/span&gt;, saleNum[i]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制填充矩形&lt;/span&gt;
                x += &lt;span&gt;40&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190228200948282-1918179209.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;355&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 　　3.5 绘制椭圆&lt;/h3&gt;
&lt;p&gt; 　　可以使用Graphics类中的DrawEllipse方法或者FillEllipse方法来绘制椭圆，它的语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DrawEllipse(Pen pen, RectangleF rect)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawEllipse(Pen pen, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DrawEllipse(Pen pen, Rectangle rect)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawEllipse(Pen pen, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它与绘制矩形类似，参数中 rect 是Rectangle结构或RectangleF结构，用来定义椭圆的边界&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FillEllipse(Brush brush, RectangleF rect);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillEllipse(Brush brush, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FillEllipse(Brush brush, Rectangle rect);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillEllipse(Brush brush, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　3.6 绘制圆弧&lt;/h3&gt;
&lt;p&gt;　　通过DrawArc方法，可以绘制圆弧，其语法入下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawArc(Pen pen, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height, &lt;span&gt;int&lt;/span&gt; startAngle, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sweepAngle);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawArc(Pen pen, Rectangle rect, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; sweepAngle);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawArc(Pen pen, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt; height, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; sweepAngle);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawArc(Pen pen, RectangleF rect, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt; sweepAngle);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：startAngle：从X轴到弧线的起始点沿顺时针方向度量的角（以度为单位）&lt;/p&gt;
&lt;p&gt;　　　　　　　sweepAngle： 从startAngle参数到弧线的结束点沿顺时针方向度量的角（以度为单位）&lt;/p&gt;
&lt;p&gt;　　　　　　　其余参数在前面已经讲过了，就不再赘述&lt;/p&gt;

&lt;h3&gt; 　　3.7 绘制扇形&lt;/h3&gt;
&lt;p&gt;　　DrawPie方法和FillPie方法可以绘制扇形，其中DrawPie可以绘制参数指定的扇形，而FillPie则是填充参数指定的扇形，其语法入下　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9bb5e7e4-7558-4bbf-b889-c94002e4884d')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_9bb5e7e4-7558-4bbf-b889-c94002e4884d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9bb5e7e4-7558-4bbf-b889-c94002e4884d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9bb5e7e4-7558-4bbf-b889-c94002e4884d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9bb5e7e4-7558-4bbf-b889-c94002e4884d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     绘制一个扇形，该形状由一个坐标对、宽度、高度以及两条射线所指定的椭圆定义。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   pen:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Pen，它确定扇形的颜色、宽度和样式。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   x:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的左上角的 x 坐标，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   y:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的左上角的 y 坐标，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   width:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的宽度，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   height:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的高度，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   startAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   sweepAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 startAngle 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     pen 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawPie(Pen pen, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt; height, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; sweepAngle);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     绘制由一个 System.Drawing.Rectangle 结构和两条射线所指定的椭圆定义的扇形。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   pen:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Pen，它确定扇形的颜色、宽度和样式。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   rect:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Rectangle 结构，它表示定义该扇形所属的椭圆的边框。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   startAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   sweepAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 startAngle 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     pen 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawPie(Pen pen, Rectangle rect, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; sweepAngle);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     绘制一个扇形，该形状由一个坐标对、宽度、高度以及两条射线所指定的椭圆定义。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   pen:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Pen，它确定扇形的颜色、宽度和样式。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   x:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的左上角的 x 坐标，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   y:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的左上角的 y 坐标，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   width:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的宽度，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   height:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     边框的高度，该边框定义扇形所属的椭圆。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   startAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   sweepAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 startAngle 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     pen 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawPie(Pen pen, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height, &lt;span&gt;int&lt;/span&gt; startAngle, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sweepAngle);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     绘制由一个 System.Drawing.RectangleF 结构和两条射线所指定的椭圆定义的扇形。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   pen:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Pen，它确定扇形的颜色、宽度和样式。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   rect:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.RectangleF 结构，它表示定义该扇形所属的椭圆的边框。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   startAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 x 轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   sweepAngle:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     从 startAngle 参数到扇形的第二条边沿顺时针方向度量的角（以度为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     pen 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawPie(Pen pen, RectangleF rect, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt; sweepAngle);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillPie(Brush brush, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height, &lt;span&gt;int&lt;/span&gt; startAngle, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sweepAngle);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillPie(Brush brush, Rectangle rect, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; sweepAngle);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillPie(Brush brush, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y, &lt;span&gt;float&lt;/span&gt; width, &lt;span&gt;float&lt;/span&gt; height, &lt;span&gt;float&lt;/span&gt; startAngle, &lt;span&gt;float&lt;/span&gt; sweepAngle);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　3.8 绘制多边形&lt;/h3&gt;
&lt;p&gt;　　多边形是指由三条或更多边的闭合图形，如三角形、四边形、五边形等。可以使用DrawPolygon方法或者FillPolygon方法绘制多边形，需要使用Graphics对象，Pen对象和Point（或PointF）对象数组，其语法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DrawPolygon(Pen pen, PointF[] points);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DrawPolygon(Pen pen, Point[] points);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FillPolygon(Brush brush, PointF[] points);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillPolygon(Brush brush, Point[] points);&lt;br/&gt;public void FillPolygon(Brush brush, Point[] points, FillMode fillMode);&lt;br/&gt;public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数中 points为Point或PointF对象数组　　　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　fillMode:  确定填充样式的 System.Drawing.Drawing2D.FillMode 枚举的成员。，使用时要引用System.Drawing.Drawing2D命名空间&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　作为枚举类型，其定义如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FillMode
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指定备用填充模式。&lt;/span&gt;
        Alternate = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指定环绕的填充模式。&lt;/span&gt;
        Winding = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面举个绘制三角形的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button2_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Graphics g &lt;/span&gt;=&lt;span&gt; CreateGraphics();
            Pen myPen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Pen(Color.Green,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            Point p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            Point p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
            Point p3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;90&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
            Point[] points &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
            Brush myBrush &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolidBrush(Color.Green);
            points[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; p1;
            points[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; p2;
            points[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; p3;
            g.FillPolygon(myBrush, points,FillMode.Winding);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1544400/201902/1544400-20190228220403311-1679220467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 　　3.9 绘制图像&lt;/h3&gt;
&lt;p&gt;　　可以使用DrawImage方法绘制图像，该方法有多种形式，常用的语法格式为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawImage(Image image, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawImage(Image image, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt; height);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：img：要绘制的Image&lt;/p&gt;
&lt;p&gt;　　　　　　　x: 所要绘制图像的左上角的X坐标&lt;/p&gt;
&lt;p&gt; 　　　　　　　y: 所要绘制图像的左上角的y坐标&lt;/p&gt;
&lt;p&gt;　　　　　　　width：要绘制图像的宽度&lt;/p&gt;
&lt;p&gt;　　　　　　　height： 要绘制图像的高度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button2_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Graphics g &lt;/span&gt;=&lt;span&gt; CreateGraphics();
            Image img &lt;/span&gt;= Image.FromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            g.DrawImage(img, &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 　　四、颜色&lt;/h2&gt;
&lt;h3&gt;　　4.1 系统定义的颜色&lt;/h3&gt;
&lt;p&gt;　　　　系统定义的颜色使用Color结构的属性来表示，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Color myColor = Color.Red;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　4.2 自定义颜色&lt;/h3&gt;
&lt;p&gt;　　　　可以使用Color结构的FromArgb方法，分别制定R、G、B颜色值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Color FromArgb(&lt;span&gt;int&lt;/span&gt; red, &lt;span&gt;int&lt;/span&gt; green, &lt;span&gt;int&lt;/span&gt; blue);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：red：新的红色分量值 System.Drawing.Color。 有效值为 0 到 255 之间。&lt;/p&gt;
&lt;p&gt;　　　　　　　green：新的绿色分量值 System.Drawing.Color。 有效值为 0 到 255 之间。&lt;/p&gt;
&lt;p&gt;  　　　　　　  blue：新的蓝色分量值 System.Drawing.Color。 有效值为 0 到 255 之间。&lt;/p&gt;

&lt;p&gt;　　也可以制定Alpha透明度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Color FromArgb(&lt;span&gt;int&lt;/span&gt; alpha, &lt;span&gt;int&lt;/span&gt; red, &lt;span&gt;int&lt;/span&gt; green, &lt;span&gt;int&lt;/span&gt; blue);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　alpha：Alpha 分量。 有效值为 0 到 255 之间。　　黑表示透明，白表示不透明，灰表示半透明&lt;/p&gt;

&lt;h2&gt;五、文本输出&lt;/h2&gt;
&lt;h3&gt;　　5.1 字体&lt;/h3&gt;
&lt;p&gt;　　字体使用Font类表示，用来定义特定的文本格式，常用的构造函数有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   family:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     新 System.Drawing.Font 的 System.Drawing.FontFamily。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   emSize:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     新字体的全身大小（以磅为单位）。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   style:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     新字体的 System.Drawing.FontStyle。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     emSize 是小于或等于 0，计算结果为无穷大，或者不是有效的数字。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     family 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Font(FontFamily family, &lt;span&gt;float&lt;/span&gt; emSize, FontStyle style);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Font myFont = &lt;span&gt;new&lt;/span&gt; Font(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, FontStyle.Bold);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中FontStyle使用枚举表示，其成员有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指定应用于文本的样式信息。&lt;/span&gt;
&lt;span&gt;    [Flags]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FontStyle
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     普通文本。&lt;/span&gt;
        Regular = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     显示为粗体文本。&lt;/span&gt;
        Bold = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     斜体文本。&lt;/span&gt;
        Italic = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     带下划线的文本。&lt;/span&gt;
        Underline = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     有一条线穿过中部的文本。&lt;/span&gt;
        Strikeout = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　5.2 输出文本&lt;/h3&gt;
&lt;p&gt;　　通过DrawString方法，可以指定位置以指定的Brush和Font对象绘制指定的文本字符村，其常用语法格式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   s:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     要绘制的字符串。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   font:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Font，它定义字符串的文本格式。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   brush:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     System.Drawing.Brush，它确定所绘制文本的颜色和纹理。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   x:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     所绘制文本的左上角的 x 坐标。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   y:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     所绘制文本的左上角的 y 坐标。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   T:System.ArgumentNullException:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     brush 为 null。 - 或 - s 为 null。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawString(&lt;span&gt;string&lt;/span&gt; s, Font font, Brush brush, &lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt; y);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注：以上内容均参照自&lt;a href=&quot;https://www.cnblogs.com/forever-Ys/p/10447617.html&quot; target=&quot;_blank&quot;&gt;MSDN&lt;/a&gt;及VS 文档，如有雷同，纯属巧合&lt;/p&gt;

</description>
<pubDate>Thu, 28 Feb 2019 14:41:00 +0000</pubDate>
<dc:creator>阡陌染</dc:creator>
<og:description>在了解绘图之前，我们先讲几个预备知识 一、坐标系 坐标系是图形设计的基础。GDI+使用三个坐标空间：世界、页面和设备，其中，世界坐标是用于建立特殊图形世界模型的坐标系，也是在.NET Framewor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forever-Ys/p/10453722.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（八） 优先级队列 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10421560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10421560.html</guid>
<description>&lt;h2&gt;1.1 优先级队列&lt;/h2&gt;
&lt;p&gt;　　有时在调度任务时，我们会想要先处理优先级更高的任务。例如，对于同一个柜台，在决定队列中下一个服务的用户时，总是倾向于优先服务VIP用户，而让普通用户等待，即使普通的用户是先加入队列的。&lt;/p&gt;
&lt;p&gt;　　优先级队列和普通的先进先出FIFO的队列类似，最大的不同在于，优先级队列中优先级最高的元素总是最先出队的，而不是遵循先进先出的顺序。&lt;/p&gt;
&lt;h2&gt;1.2 堆&lt;/h2&gt;
&lt;p&gt;　　优先级队列的接口要求很简单。从逻辑上来说，&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/9977275.html&quot; target=&quot;_blank&quot;&gt;向量&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/10021291.html&quot; target=&quot;_blank&quot;&gt;链表&lt;/a&gt;或者&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/10371676.html&quot; target=&quot;_blank&quot;&gt;平衡二叉搜索树&lt;/a&gt;等数据结构都可用于实现优先级队列。但考虑到时间和空间的效率，就必须仔细斟酌和考量了。而一种被称为&lt;strong&gt;堆&lt;/strong&gt;的数据结构非常适合实现优先级队列。’&lt;/p&gt;
&lt;p&gt;　　堆和二叉搜索树类似，存储的元素在&lt;strong&gt;逻辑上&lt;/strong&gt;是按照层次排放的，在全局任意地方其上层元素优先级大于下层元素，这一顺序性也被称为堆序性，而其中优先级最大的元素被放在最高的层级(&lt;strong&gt;大顶堆&lt;/strong&gt;)。和二叉搜索树的排序方式不同的是，堆中元素的顺序并不是完全的排序，而只是维护了一种偏序关系，被称为&lt;strong&gt;堆序性&lt;/strong&gt;。在这种偏序关系下，元素之间的顺序性比较疏散，维护堆序性的代价比较低，因而在实现优先级队列时，堆的效率要高于平衡二叉搜索树。&lt;/p&gt;
&lt;h2&gt;1.3 完全二叉堆&lt;/h2&gt;
&lt;p&gt;　　完全二叉堆是堆的一种，其元素在逻辑上是以完全二叉树的形式存放的，但实际却是存储在向量（数组）中的。在这里，我们使用完全二叉堆来实现优先级队列。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190225194731287-1781799363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 优先级队列 ADT接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; PriorityQueue &amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入新数据
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newData 新数据
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(E newData);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得优先级最大值（窥视） 不删数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  当前优先级最大的数据
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peekMax();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得并且删除当前优先级最大值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  被删除的 当前优先级最大的数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E popMax();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前优先级队列 元素个数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 当前优先级队列 元素个数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否为空
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true  队列为空
     *         false 队列不为空
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;3.1 基础属性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;完全二叉堆内部使用之前封装好的向量作为基础。和二叉搜索树类似，用户同样可以通过传入Comparator比较器来指定堆中优先级大小比较的逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompleteBinaryHeap&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; PriorityQueue&amp;lt;E&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部向量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;&lt;span&gt; innerArrayList;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前堆的逻辑大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;构造方法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 无参构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompleteBinaryHeap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defaultCapacity 指定的初始容量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultCapacity){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(defaultCapacity);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量和比较器的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defaultCapacity 指定的初始容量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(&lt;span&gt;int&lt;/span&gt; defaultCapacity, Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(defaultCapacity);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将指定数组 转换为一个完全二叉堆
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 指定的数组
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompleteBinaryHeap(E[] array){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(array);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; array.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量建堆&lt;/span&gt;
&lt;span&gt;        heapify();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将指定数组 转换为一个完全二叉堆
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 指定的数组
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(E[] array, Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(array);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; array.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量建堆&lt;/span&gt;
&lt;span&gt;        heapify();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.2 辅助方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　由于完全二叉堆在逻辑上等价于一颗完全二叉树，但实际上却采用了一维的向量数据结构来存储元素。因而我们需要实现诸如getParentIndex、getLeftChildIndex、getRightChildIndex等方法来进行完全二叉树和向量表示方法的转换。&lt;/p&gt;
&lt;p&gt;　　这里，定义了一些私有方法来封装常用的逻辑，用以简化代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 双亲节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getParentIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex - 1)/2&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 左孩子节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getLeftChildIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex * 2) + 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 右孩子节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getRightChildIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex + 1) * 2&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得末尾下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLastIndex(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.size - 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得最后一个非叶子节点下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLastInternal(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size()/2) - 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 交换向量中两个元素位置
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a 某一个元素的下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; b 另一个元素的下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现暂存a、b下标元素的值&lt;/span&gt;
        E aData = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(a);
        E bData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(b);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换位置&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.set(a,bData);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.set(b,aData);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 进行比较
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(E t1, E t2){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代器不存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖对象本身的 Comparable，可能会转型失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((Comparable) t1).compareTo(t2);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过迭代器逻辑进行比较&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.comparator.compare(t1,t2);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.3 插入和上滤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当新元素插入完全二叉堆时，我们直接将其插入向量末尾(堆底最右侧)，此时新元素的优先级可能会大于其双亲元素甚至祖先元素，破坏了堆序性，因此我们需要对插入的新元素进行一次&lt;strong&gt;上滤操作&lt;/strong&gt;，使完全二叉堆&lt;strong&gt;恢复堆序性&lt;/strong&gt;。由于堆序性只和双亲和孩子节点相关，因此堆中新插入元素的非祖先元素的堆序性不会受到影响，&lt;strong&gt;上滤只是一个局部性的行为&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上滤操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;上滤的元素不断的和自己的双亲节点进行优先级的比较：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　&lt;strong&gt;1.&lt;/strong&gt; 如果上滤元素的优先级较大，则与双亲节点交换位置，继续向上比较。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt; 如果上滤元素的优先级较小(等于)，堆序性恢复，终止比较，结束上滤操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;特别的&lt;/strong&gt;，当上滤的元素被交换到树根节点时(向量下标第0位)，此时由于上滤的元素是堆中的最大元素，终止上滤操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上滤操作的时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上滤操作时，上滤元素进行比较的次数正比于上滤元素的&lt;strong&gt;深度&lt;/strong&gt;。因此，&lt;strong&gt;上滤操作的时间复杂度为O(logN)&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(E newData) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先插入新数据到 向量末尾&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.add(newData);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得向量末尾元素下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex =&lt;span&gt; getLastIndex();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对向量末尾元素进行上滤，以恢复堆序性&lt;/span&gt;
&lt;span&gt;        siftUp(lastIndex);
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 上滤操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 需要上滤的元素下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; siftUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index &amp;gt;= 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前节点&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; parentIndex =&lt;span&gt; getParentIndex(index);

            E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);
            E parentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(parentIndex);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前元素 大于 双亲元素&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(compare(currentData,parentData) &amp;gt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换当前元素和双亲元素的位置&lt;/span&gt;
&lt;span&gt;                swap(index,parentIndex);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续向上迭代&lt;/span&gt;
                index =&lt;span&gt; parentIndex;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素没有违反堆序性，直接返回&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.4 删除和下滤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当优先级队列中极值元素出队时，需要在满足堆序性的前提下，选出新的极值元素。&lt;/p&gt;
&lt;p&gt;　　我们简单的将当前向量末尾的元素放在堆顶，堆序性&lt;strong&gt;很有可能&lt;/strong&gt;被破坏了。此时，我们需要对当前的堆顶元素进行一次下滤操作，使得整个完全二叉堆恢复堆序性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下滤操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下滤的元素不断的和自己的左、右孩子节点进行优先级的比较：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.&lt;/strong&gt; 双亲节点最大，堆序性恢复，终止下滤。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt; 左孩子节点最大，当前下滤节点和自己的左孩子节点交换，继续下滤。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3. &lt;/strong&gt;右孩子节点最大，当前下滤节点和自己的右孩子节点交换，继续下滤。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4. 特别的&lt;/strong&gt;，当下滤的元素抵达堆底时(成为叶子节点)，堆序性已经恢复，终止下滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下滤操作时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下滤操作时，下滤元素进行比较的次数正比于下滤元素的&lt;strong&gt;高度&lt;/strong&gt;。因此，下&lt;strong&gt;滤操作的时间复杂度为O(logN)&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E popMax() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;当前完全二叉堆为空&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前向量末尾的元素和堆顶元素交换位置&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex =&lt;span&gt; getLastIndex();
        swap(&lt;/span&gt;0&lt;span&gt;,lastIndex);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂存被删除的最大元素（之前的堆顶最大元素被放到了向量末尾）&lt;/span&gt;
        E max = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(lastIndex);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对当前堆顶元素进行下滤，以恢复堆序性&lt;/span&gt;
        siftDown(0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 下滤操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 需要下滤的元素下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; siftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 叶子节点不需要下滤&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; half = size &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index &amp;lt;&lt;span&gt; half){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftIndex =&lt;span&gt; getLeftChildIndex(index);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightIndex =&lt;span&gt; getRightChildIndex(index);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rightIndex &amp;lt;&lt;span&gt; size){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子存在 (下标没有越界)&lt;/span&gt;
&lt;span&gt;
                E leftData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(leftIndex);
                E rightData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(rightIndex);
                E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较左右孩子大小&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(compare(leftData,rightData) &amp;gt;= 0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左孩子更大，比较双亲和左孩子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(compare(currentData,leftData) &amp;gt;= 0&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲最大，终止下滤&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三者中，左孩子更大，交换双亲和左孩子的位置&lt;/span&gt;
&lt;span&gt;                        swap(index,leftIndex);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                        index =&lt;span&gt; leftIndex;
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子更大，比较双亲和右孩子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(compare(currentData,rightData) &amp;gt;= 0&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲最大，终止下滤&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三者中，右孩子更大，交换双亲和右孩子的位置&lt;/span&gt;
&lt;span&gt;                        swap(index,rightIndex);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                        index =&lt;span&gt; rightIndex;
                    }
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子不存在 (下标越界)&lt;/span&gt;
&lt;span&gt;
                E leftData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(leftIndex);
                E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点 大于 左孩子&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(compare(currentData,leftData) &amp;gt;= 0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终止下滤&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换 左孩子和双亲的位置&lt;/span&gt;
&lt;span&gt;                    swap(index,leftIndex);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                    index =&lt;span&gt; leftIndex;
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.5 批量元素建堆&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;有时，我们需要将一个无序的元素集合数组转换成一个完全二叉堆，这一操作被称为批量建堆。&lt;/p&gt;
&lt;p&gt;　　一个朴素的想法是：将无序集合中的元素依次插入一个空的完全二叉堆，对每一个新插入的元素进行上滤操作。使用上滤操作实现的对N个元素进行批量建堆的算法，其时间复杂度为O(n.logn)，比较直观。&lt;/p&gt;
&lt;p&gt;　　但还存在一种效率更加高效的批量建堆算法，是以下滤操作为基础实现的，被称为&lt;strong&gt;Floyd建堆算法&lt;/strong&gt;。下滤操作可以看做是将两个较小的堆合并为一个更大堆的过程(&lt;strong&gt;单个元素可以被视为一个最小的堆&lt;/strong&gt;)，通过从底到高不断的下滤操作，原本无序的元素集合将通过不断的合并建立较小的堆，最终完成整个集合的建堆过程。&lt;/p&gt;
&lt;p&gt;　　Floyd建堆算法的时间复杂度的证明较为复杂，其时间复杂度比起以上滤为基础的朴素算法效率高一个数量级，为&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　简单的一种解释是：在完全二叉树中，&lt;strong&gt;低层元素的数量要远远少于高层的数量&lt;/strong&gt;。高层元素的高度较高而深度较低；底层元素的高度较低而深度较高。由于上滤操作的时间复杂度正比于高度，对于存在大量底层元素的完全二叉堆很不友好，使得基于上滤的批量建堆算法效率较低。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201902/1506329-20190225195942958-215273210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 批量建堆（将内部数组转换为完全二叉堆）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; heapify(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下标最大的 内部非叶子节点&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastInternalIndex =&lt;span&gt; getLastInternal();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Floyd建堆算法 时间复杂度&quot;O(n)&quot;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从lastInternalIndex开始向前遍历，对每一个元素进行下滤操作，从小到大依次合并&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=lastInternalIndex; i&amp;gt;=0; i--&lt;span&gt;){
            siftDown(i);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;堆排序主要分为两步进行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.&lt;/strong&gt; 堆排序首先将传入的数组转化为一个堆(floyd建堆算法，时间复杂度O(n))。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt; 和选择排序类似，堆排序每次都从未排序的区间中选择出一个极值元素置入已排序区域，在堆中极值元素就是堆顶元素，可以通过popMax方法(时间复杂度O(logN))获得。从数组末尾向前遍历，循环往复直至排序完成，总的时间复杂度为O(N logN)。&lt;/p&gt;
&lt;p&gt;　　综上所述，堆排序的渐进时间复杂度为O(N logN)。同时由于堆排序能够在待排序数组中&lt;strong&gt;就地&lt;/strong&gt;的进行排序，因此空间效率很高，空间复杂度为(O(1))。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; heapSort(T[] array){
        CompleteBinaryHeap&lt;/span&gt;&amp;lt;T&amp;gt; completeBinaryHeap = &lt;span&gt;new&lt;/span&gt; CompleteBinaryHeap&amp;lt;&amp;gt;&lt;span&gt;(array);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=array.length-1; i&amp;gt;=0; i--&lt;span&gt;){
            array[i] &lt;/span&gt;=&lt;span&gt; completeBinaryHeap.popMax();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;优先级队列ADT接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f4766c81-5585-4300-85a2-a01498c3919f')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f4766c81-5585-4300-85a2-a01498c3919f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f4766c81-5585-4300-85a2-a01498c3919f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f4766c81-5585-4300-85a2-a01498c3919f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f4766c81-5585-4300-85a2-a01498c3919f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 优先级队列 ADT接口
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; PriorityQueue &amp;lt;E&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * 插入新数据
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newData 新数据
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(E newData);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 获得优先级最大值（窥视）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  当前优先级最大的数据
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    E peekMax();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 获得并且删除当前优先级最大值
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  被删除的 当前优先级最大的数据
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    E popMax();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 获得当前优先级队列 元素个数
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 当前优先级队列 元素个数
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * 是否为空
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 队列为空
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     *          false 队列不为空
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;完全二叉堆实现:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('37b35f75-a9e7-42e8-b197-a499050abcb5')&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_37b35f75-a9e7-42e8-b197-a499050abcb5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_37b35f75-a9e7-42e8-b197-a499050abcb5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('37b35f75-a9e7-42e8-b197-a499050abcb5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_37b35f75-a9e7-42e8-b197-a499050abcb5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 完全二叉堆 实现优先级队列
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompleteBinaryHeap&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; PriorityQueue&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =========================================成员属性===========================================&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部向量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;&lt;span&gt; innerArrayList;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前堆的逻辑大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ===========================================构造函数========================================&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 无参构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompleteBinaryHeap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defaultCapacity 指定的初始容量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultCapacity){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(defaultCapacity);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定初始容量和比较器的构造函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defaultCapacity 指定的初始容量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(&lt;span&gt;int&lt;/span&gt; defaultCapacity, Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(defaultCapacity);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将指定数组 转换为一个完全二叉堆
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 指定的数组
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CompleteBinaryHeap(E[] array){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(array);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; array.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量建堆&lt;/span&gt;
&lt;span&gt;        heapify();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将指定数组 转换为一个完全二叉堆
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 指定的数组
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 指定的比较器逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CompleteBinaryHeap(E[] array, Comparator&amp;lt;E&amp;gt;&lt;span&gt; comparator){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(array);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; array.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量建堆&lt;/span&gt;
&lt;span&gt;        heapify();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ==========================================外部方法===========================================&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(E newData) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先插入新数据到 向量末尾&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.add(newData);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得向量末尾元素下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex =&lt;span&gt; getLastIndex();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对向量末尾元素进行上滤，以恢复堆序性&lt;/span&gt;
&lt;span&gt;        siftUp(lastIndex);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekMax() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部数组第0位 即为堆顶max&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.innerArrayList.get(0&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E popMax() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;当前完全二叉堆为空&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前向量末尾的元素和堆顶元素交换位置&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex =&lt;span&gt; getLastIndex();
        swap(&lt;/span&gt;0&lt;span&gt;,lastIndex);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂存被删除的最大元素（之前的堆顶最大元素被放到了向量末尾）&lt;/span&gt;
        E max = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(lastIndex);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对当前堆顶元素进行下滤，以恢复堆序性&lt;/span&gt;
        siftDown(0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.size() == 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空列表&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::列表起始使用&quot;[&quot;&lt;/span&gt;
        StringBuilder s = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;[&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从第一个到倒数第二个元素之间&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;size-1; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::使用&quot;, &quot;进行分割&lt;/span&gt;
            s.append(&lt;span&gt;this&lt;/span&gt;.innerArrayList.get(i)).append(&quot;,&quot;).append(&quot; &quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::最后一个元素使用&quot;]&quot;结尾&lt;/span&gt;
        s.append(&lt;span&gt;this&lt;/span&gt;.innerArrayList.get(size-1)).append(&quot;]&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.toString();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; heapSort(T[] array){
        CompleteBinaryHeap&lt;/span&gt;&amp;lt;T&amp;gt; completeBinaryHeap = &lt;span&gt;new&lt;/span&gt; CompleteBinaryHeap&amp;lt;&amp;gt;&lt;span&gt;(array);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=array.length-1; i&amp;gt;=0; i--&lt;span&gt;){
            array[i] &lt;/span&gt;=&lt;span&gt; completeBinaryHeap.popMax();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =========================================内部辅助函数===========================================&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 上滤操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 需要上滤的元素下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; siftUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index &amp;gt;= 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前节点&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; parentIndex =&lt;span&gt; getParentIndex(index);

            E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);
            E parentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(parentIndex);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前元素 大于 双亲元素&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(compare(currentData,parentData) &amp;gt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换当前元素和双亲元素的位置&lt;/span&gt;
&lt;span&gt;                swap(index,parentIndex);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续向上迭代&lt;/span&gt;
                index =&lt;span&gt; parentIndex;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素没有违反堆序性，直接返回&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 下滤操作
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index 需要下滤的元素下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; siftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 叶子节点不需要下滤&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; half = size &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index &amp;lt;&lt;span&gt; half){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftIndex =&lt;span&gt; getLeftChildIndex(index);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightIndex =&lt;span&gt; getRightChildIndex(index);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rightIndex &amp;lt;&lt;span&gt; size){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子存在 (下标没有越界)&lt;/span&gt;
&lt;span&gt;
                E leftData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(leftIndex);
                E rightData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(rightIndex);
                E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较左右孩子大小&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(compare(leftData,rightData) &amp;gt;= 0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左孩子更大，比较双亲和左孩子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(compare(currentData,leftData) &amp;gt;= 0&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲最大，终止下滤&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三者中，左孩子更大，交换双亲和左孩子的位置&lt;/span&gt;
&lt;span&gt;                        swap(index,leftIndex);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                        index =&lt;span&gt; leftIndex;
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子更大，比较双亲和右孩子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(compare(currentData,rightData) &amp;gt;= 0&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双亲最大，终止下滤&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三者中，右孩子更大，交换双亲和右孩子的位置&lt;/span&gt;
&lt;span&gt;                        swap(index,rightIndex);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                        index =&lt;span&gt; rightIndex;
                    }
                }
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右孩子不存在 (下标越界)&lt;/span&gt;
&lt;span&gt;
                E leftData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(leftIndex);
                E currentData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(index);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点 大于 左孩子&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(compare(currentData,leftData) &amp;gt;= 0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终止下滤&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换 左孩子和双亲的位置&lt;/span&gt;
&lt;span&gt;                    swap(index,leftIndex);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续下滤操作&lt;/span&gt;
                    index =&lt;span&gt; leftIndex;
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 批量建堆（将内部数组转换为完全二叉堆）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; heapify(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下标最大的 内部非叶子节点&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastInternalIndex =&lt;span&gt; getLastInternal();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Floyd建堆算法 时间复杂度&quot;O(n)&quot;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从lastInternalIndex开始向前遍历，对每一个元素进行下滤操作，从小到大依次合并&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=lastInternalIndex; i&amp;gt;=0; i--&lt;span&gt;){
            siftDown(i);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 双亲节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getParentIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex - 1)/2&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 左孩子节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getLeftChildIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex * 2) + 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得逻辑上 右孩子节点下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 当前下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getRightChildIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (currentIndex + 1) * 2&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前向量末尾下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLastIndex(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.size - 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得最后一个非叶子节点下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLastInternal(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size()/2) - 1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 交换向量中两个元素位置
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a 某一个元素的下标
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; b 另一个元素的下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现暂存a、b下标元素的值&lt;/span&gt;
        E aData = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(a);
        E bData &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.get(b);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换位置&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.set(a,bData);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerArrayList.set(b,aData);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 进行比较
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(E t1, E t2){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代器不存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖对象本身的 Comparable，可能会转型失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((Comparable) t1).compareTo(t2);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过迭代器逻辑进行比较&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.comparator.compare(t1,t2);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;本系列博客的代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Feb 2019 14:40:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.优先级队列介绍 1.1 优先级队列 有时在调度任务时，我们会想要先处理优先级更高的任务。例如，对于同一个柜台，在决定队列中下一个服务的用户时，总是倾向于优先服务VIP用户，而让普通用户等待，即使普</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10421560.html</dc:identifier>
</item>
</channel>
</rss>