<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes对象之Job - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/10992533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/10992533.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;job是什么&quot;&gt;job是什么&lt;/h2&gt;
&lt;p&gt;对于ReplicaSet、ReplicationController等类型的控制器而言，它希望pod保持预期数目、持久运行下去，除非用户明确删除，否则这些对象一直存在，它们针对的是耐久性任务，如web服务等。对于非耐久性任务，比如压缩文件，任务完成后，pod需要结束运行，不需要pod继续保持在系统中，这个时候就要用到Job。因此说Job是对ReplicaSet、ReplicationController等持久性控制器的补充。&lt;/p&gt;
&lt;h2 id=&quot;job与其它控制器的细微差别&quot;&gt;Job与其它控制器的细微差别&lt;/h2&gt;
&lt;p&gt;Job定义方法与ReplicaSet等控制器相似，只有细微差别，如下：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Job中的restart policy必需是&quot;Never&quot;或者&quot;OnFailure&quot;，这个很好理解，因为pod要运行到结束，而不是反复重新启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Job不需要选择器，其中的pod也不需要标签，系统在创建Job时会自动添加相关内容。当然用户也可以出于资源组织的目的添加标签，但这个与Job本身的实现没有关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Job新增加两个字段：.spec.completions、.spec.parallelism。详细用法在示例中说明&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;backoffLimit字段：示例中说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;h3 id=&quot;非并发job&quot;&gt;&lt;strong&gt;非并发Job&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;非并发Job的含义是，Job启动后，只运行一个pod，pod运行结束后整个Job也就立刻结束。&lt;/p&gt;
&lt;p&gt;以下是简单的Job配置文件，只包含一个pod，输出圆周率小数点后2000位，运行时间大概为10s：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]
      restartPolicy: Never
  backoffLimit: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上示例无需设置选择器、pod标签。无需设置.spec.completions、.spec.parallelism，这两个字段的默认值都是1。backoffLimit=4，表示允许pod失败的次数。将以上内容保存成文件并创建Job：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl create -f https://k8s.io/examples/controllers/job.yaml
job &quot;pi&quot; created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确认Job状态：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ kubectl describe jobs/pi
Name:             pi
Namespace:        default
Selector:         controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
Labels:           controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                  job-name=pi
Annotations:      &amp;lt;none&amp;gt;
Parallelism:      1
Completions:      1
Start Time:       Tue, 07 Jun 2016 10:56:16 +0200
Pods Statuses:    0 Running / 1 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                job-name=pi
  Containers:
   pi:
    Image:      perl
    Port:
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:        &amp;lt;none&amp;gt;
    Mounts:             &amp;lt;none&amp;gt;
  Volumes:              &amp;lt;none&amp;gt;
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  1m           1m          1        {job-controller }                Normal      SuccessfulCreate  Created pod: pi-dtn4q&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上输出可以看到系统自动添加的Selector、Pod labels。注意Events的输出，全程只创建了一个pod。&lt;/p&gt;
&lt;p&gt;列出Job的所有pod：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath={.items..metadata.name})
$ echo $pods
pi-aiw0a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看Pod的输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl logs $pods
3.14159265358979323846264......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是最简单的Job应用示例，输出圆周率小数点后2000位。但是，考虑另外一种情况，假如我们需要计算圆周率小数点后3000、4000、5000位怎么办？一种方案是先将上例中的2000改成3000，创建并运行。然后再改成4000，再创建并运行，一直到5000。显然这种方案并不高明：麻烦、资源利用率低。另外一种方法是同时创建4个Job，分别计算2000、3000、4000、5000。注意4个Job的name字段不能冲突分别是pi-2000、pi-3000、pi-4000、pi-5000，&lt;br/&gt;文件名分别为pi-2000.yaml、pi-3000.yaml、pi-4000.yaml、pi-5000.yaml，并保存在目录/tmp/pi下。利用kubectl对目录的支持一次性创建4个Job：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ kubectl create -f /tmp/pi
job &quot;pi-2000&quot; created
job &quot;pi-3000&quot; created
job &quot;pi-4000&quot; created
job &quot;pi-5000&quot; created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法是伪并发，只适用于任务量少的情况。假如我们需要处理的任务是从pi-1到pi-10000，那么以上方法就不适用了：&lt;/p&gt;
&lt;h3 id=&quot;粗并发job&quot;&gt;&lt;strong&gt;粗并发Job&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;本例创建一个Job，但Job要创建多个pod。了解完示例后就明白为什么叫“粗并发”。&lt;/p&gt;
&lt;p&gt;本示例需要一个消息队列服务的配合，不详细描述如何部署、填充消息队列服务。假设我们有一个RabbitMQ服务，集群内访问地址为：amqp://guest:guest@rabbitmq-service:5672。其有一个名为job1的队列，队列内有apple banana cherry date fig grape lemon melon共8个成员。&lt;/p&gt;
&lt;p&gt;另外假设我们有一个名为gcr.io//job-wq-1的image，其功能是从队列中读取出一个元素并打印到标准输出，然后结束。注意，它只处理一个元素就结束了。接下来创建如下Job：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: batch/v1
kind: Job
metadata:
  name: job-wq-1
spec:
  completions: 8
  parallelism: 2
  template:
    metadata:
      name: job-wq-1
    spec:
      containers:
      - name: c
        image: gcr.io/&amp;lt;project&amp;gt;/job-wq-1
        env:
        - name: BROKER_URL
          value: amqp://guest:guest@rabbitmq-service:5672
        - name: QUEUE
          value: job1
      restartPolicy: OnFailure&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，completions的值为8，等于job1队列中元素的个数。因为每个成功的pod处理一个元素，所以需要成功8次，job1中的所有成员就会被处理完成。在粗并发模式下，completions的值必需指定，否则其默认值为1，整个Job只处理一个成员就结束了。&lt;/p&gt;
&lt;p&gt;上例中，parallelism的值是2。虽然需要pod成功8次，但在同一时间，只允许有两个pod并发。一个成功结束后，再启动另一个。这个参数的主要目的是控制并发pod的个数，可根据实际情况调整。当然可以不指定，那么默认的并发个数就是1。&lt;/p&gt;
&lt;p&gt;env中的内容告诉image如何访问队列。&lt;/p&gt;
&lt;p&gt;将以上内容保存在job.yaml文件中，运行Job：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl create -f ./job.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍等片刻Job运行完成，查看结果：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ kubectl describe jobs/job-wq-1
Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &amp;lt;none&amp;gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2017 16:42:02 +0800
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      gcr.io/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &amp;lt;none&amp;gt;
  Volumes:              &amp;lt;none&amp;gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看Events，可以看到总共创建了8个pod。在本例中，每处理队列中的一个成员都需要创建一个pod，开销很大。如果队列中的成员个数非常庞大，那么这种处理方式就不适用。我们希望少创建pod、每个pod能处理多条记录,请看下面示例&lt;/p&gt;
&lt;h3 id=&quot;细并发job&quot;&gt;&lt;strong&gt;细并发Job&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;redis:6379&amp;gt; lrange job2 0 -1
1) &quot;apple&quot;
2) &quot;banana&quot;
3) &quot;cherry&quot;
4) &quot;date&quot;
5) &quot;fig&quot;
6) &quot;grape&quot;
7) &quot;lemon&quot;
8) &quot;melon&quot;
9) &quot;orange&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来创建image，详细过程不描述。只需确定这个image运行如下名为worker.py的python程序&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#!/usr/bin/env python
 
import time
import rediswq
 
host=&quot;redis&quot;
# Uncomment next two lines if you do not have Kube-DNS working.
# import os
# host = os.getenv(&quot;REDIS_SERVICE_HOST&quot;)
 
q = rediswq.RedisWQ(name=&quot;job2&quot;, host=&quot;redis&quot;)
print(&quot;Worker with sessionID: &quot; +  q.sessionID())
print(&quot;Initial queue state: empty=&quot; + str(q.empty()))
while not q.empty():
  item = q.lease(lease_secs=10, block=True, timeout=2) 
  if item is not None:
    itemstr = item.decode(&quot;utf=8&quot;)
    print(&quot;Working on &quot; + itemstr)
    time.sleep(10) # Put your actual work here instead of sleep.
    q.complete(item)
  else:
    print(&quot;Waiting for work&quot;)
print(&quot;Queue empty, exiting&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先连接到redis的job2队列。然后是一个while循环，每次读job2中的一条记录并输出，然后sleep 10s。循环退出的条件是job2队列为空。这个image与示例2不同，示例2只处理一条记录这就结束，而这个可以处理多条一直到队列为空。&lt;/p&gt;
&lt;p&gt;接下来定义Job：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: batch/v1
kind: Job
metadata:
  name: job-wq-2
spec:
  parallelism: 2
  template:
    metadata:
      name: job-wq-2
    spec:
      containers:
      - name: c
        image: gcr.io/myproject/job-wq-2
      restartPolicy: OnFailure&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，无需像示例2一样指定 completions的值，因为结束条件是job2为空，已经内嵌在image的逻辑中。parallelism=2表示可以并发两个pod，不设置默认为1，在实际应用中可据实际情况自行调整。&lt;/p&gt;
&lt;p&gt;运行Job：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl create -f ./job.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过一会查看Job运行状况：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ kubectl describe jobs/job-wq-2
Name:             job-wq-2
Namespace:        default
Selector:         controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-2
Annotations:      &amp;lt;none&amp;gt;
Parallelism:      2
Completions:      &amp;lt;unset&amp;gt;
Start Time:       Mon, 11 Jan 2016 17:07:59 -0800
Pods Statuses:    1 Running / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                job-name=job-wq-2
  Containers:
   c:
    Image:              gcr.io/exampleproject/job-wq-2
    Port:
    Environment:        &amp;lt;none&amp;gt;
    Mounts:             &amp;lt;none&amp;gt;
  Volumes:              &amp;lt;none&amp;gt;
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  33s          33s         1        {job-controller }                Normal      SuccessfulCreate  Created pod: job-wq-2-lglf8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然允许的最大并发数是2，但Events显示只创建成功一个pod，这个是正常情况，最大并非必需，可能系统因为资源问题达不到最大。&lt;/p&gt;
&lt;p&gt;查看pod输出：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;$ kubectl logs pods/job-wq-2-7r7b2
Worker with sessionID: bbd72d0a-9e5c-4dd6-abf6-416cc267991f
Initial queue state: empty=False
Working on banana
Working on date
Working on lemon&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细并发相比与粗并发，减少了创建pod的开销，使每个pod能处理多条记录，但是pod要自己决定退出条件，如果不退出，那么Job永远无法结束。&lt;/p&gt;
&lt;h2 id=&quot;关于资源回收&quot;&gt;关于资源回收&lt;/h2&gt;
&lt;p&gt;Job创建的pod在结束运行后，无论是成功还是失败，不会默认删除，仍然保留在系统中，这样用户才可以查看其日志、状态信息、排除错误。用户需要手动运行kubectl delete删除所有运行结束的pod，为了方便组织资源，一次性删除会部pod，可以被pod自定义标签。Job在运行完成后也仍然保留在系统中，由用户删除。所以使用Job，用户应注意资源回收，避免资源被耗尽。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Jun 2019 00:24:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' job是什么 对于ReplicaSet、ReplicationController等类型的控制器而言，它希望pod保持预期数目、持久运行下去，除非用户明确删除，否则这些对象一直存在，它们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/10992533.html</dc:identifier>
</item>
<item>
<title>CSharpGL(56)[译]Vulkan入门 - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/csharpgl-56-introduction-to-vulkan.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/csharpgl-56-introduction-to-vulkan.html</guid>
<description>&lt;p&gt;&lt;span&gt;CSharpGL(56)[译]Vulkan入门&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文是对（&lt;a href=&quot;http://ogldev.atspace.co.uk/www/tutorial50/tutorial50.html&quot;&gt;http://ogldev.atspace.co.uk/www/tutorial50/tutorial50.html&lt;/a&gt;）的翻译，作为学习Vulkan的一次尝试。&lt;/p&gt;
&lt;p&gt;不翻译的话，每次都在看第一句，那就学不完了。 &lt;/p&gt;

&lt;p&gt;You've probably heard by now quite a bit about &lt;a href=&quot;https://www.khronos.org/vulkan/&quot;&gt;Vulkan&lt;/a&gt;, the new Graphics API from Khronos (the non profit organization responsible for the development of OpenGL).&lt;/p&gt;
&lt;p&gt;你可能听过Vulkan，Khronos创建的新的图形API。Khronos是负责开发OpenGL的非盈利组织。&lt;/p&gt;
&lt;p&gt;Vulkan was announced in Feb-2016 and after 24 years with OpenGL it is a completely new standard and a departure from the current model.&lt;/p&gt;
&lt;p&gt;在OpenGL出现24年后，Vulkan于2016年2月被发布。它放弃了当前的模型，它是全新的标准。&lt;/p&gt;
&lt;p&gt;I won't go into many details about the various features of Vulkan only to say that in comparison to OpenGL it is much more low level and provides a lot of power and performance opportunities for the developer.&lt;/p&gt;
&lt;p&gt;我不会上来就抛出一堆新的特性的细节。简单来说，相比OpenGL，Vulkan底层得多，给开发者提供了巨大的能量和提升性能的机会。&lt;/p&gt;
&lt;p&gt;But with great power comes great responsibility.&lt;/p&gt;
&lt;p&gt;但是能力越大，责任就越大。&lt;/p&gt;
&lt;p&gt;The developer has to take charge of various aspects such as command buffer, synchronization and memory management that were previously the sole responsibility of the driver.&lt;/p&gt;
&lt;p&gt;开发者必须负责各种方面，例如命令缓存、同步、内存管理，这些之前都是驱动的责任。&lt;/p&gt;
&lt;p&gt;Through the unique knowledge that the developer has about the way the application is structured, the usage of the Vulkan API can be tailored in a way to increase the overall performance of the system.&lt;/p&gt;
&lt;p&gt;基于开发者对应用程序结构的知识，他可以调整Vulkan API的用法，获得更高的系统性能。&lt;/p&gt;

&lt;p&gt;The thing that surprises people the most, IMHO, about Vulkan is the amount of code that must be written only to get the first triangle on the screen.&lt;/p&gt;
&lt;p&gt;最让人吃惊的，恕我直言，是在屏幕上显示第一个三角形所需的巨大代码量。&lt;/p&gt;
&lt;p&gt;Comparing this to the few lines we had to write in OpenGL in the first few tutorials this is a major change and becomes a challenge when one tries to write a tutorial about it.&lt;/p&gt;
&lt;p&gt;相比在最初的教程中我们写的那几行OpenGL代码，这是很大的改变，也是写Vulkan教程的难点。&lt;/p&gt;
&lt;p&gt;Therefore, as always with OGLDEV, I'll try to present the material step by step.&lt;/p&gt;
&lt;p&gt;因此，像OGLDEV往常一样，我将一步一步地展开本教程。&lt;/p&gt;
&lt;p&gt;We will develop our first triangle demo in a few tutorials, making additional progress in each one.&lt;/p&gt;
&lt;p&gt;我们将在多个教程中完成第一个三角形示例，在每个教程中进展一点点。&lt;/p&gt;
&lt;p&gt;In addition, instead of laying out the dozens of APIs in one long piece of code I'll present a simple software design that I hope will make it simpler for you to understand without imposing too much restrictions on your future apps.&lt;/p&gt;
&lt;p&gt;另外，我不展示一大段API，而是展示有设计思路的软件。我希望这能便于读者理解。&lt;/p&gt;
&lt;p&gt;Consider this an educational design which you are free to throw away later.&lt;/p&gt;
&lt;p&gt;这个设计以教学为目的，等你学会了，就可以扔掉了。&lt;/p&gt;

&lt;p&gt;We will study the core components of Vulkan one by one as we make progress through the code so at this point I just want to present a diagram of the general picture:&lt;/p&gt;
&lt;p&gt;随着代码，我们将一个个地学习Vulkan核心组件。现在我们先看一下概览图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190609030429624-893698932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This diagram is by all means not a complete representation.&lt;/p&gt;
&lt;p&gt;当然这个图并没有展示所有的组件。&lt;/p&gt;
&lt;p&gt;It includes only the major components that will probably be present in most applications.&lt;/p&gt;
&lt;p&gt;它只包含会在大部分应用程序中使用的主要组件。&lt;/p&gt;
&lt;p&gt;The connectors between the objects represent the dependencies between them at creation or enumeration time.&lt;/p&gt;
&lt;p&gt;对象之间的连线表示在创建或枚举时的依赖关系。&lt;/p&gt;
&lt;p&gt;For example, in order to create a surface you need an instance object and when you enumerate the physical devices on your system you also need an instance.&lt;/p&gt;
&lt;p&gt;例如，为了创建一个surface，你需要一个instance对象；当你枚举你系统上的物理设备时，你也需要一个instance对象。&lt;/p&gt;
&lt;p&gt;The two colors roughly describe the software design that we will use.&lt;/p&gt;
&lt;p&gt;两种颜色粗略地描述了我们将使用的软件设计方案。&lt;/p&gt;
&lt;p&gt;The dark red objects will go into something I call the &quot;core&quot; and the light green objects will go into the &quot;app&quot;.&lt;/p&gt;
&lt;p&gt;暗红色对象将属于“core”，浅绿色对象将属于“app”。&lt;/p&gt;
&lt;p&gt;We will later see why this makes sense.&lt;/p&gt;
&lt;p&gt;我们稍后再看为什么是这样。&lt;/p&gt;
&lt;p&gt;The application code that you will write will actually inherit from &quot;app&quot; and all of its members will be available for you for further use.&lt;/p&gt;
&lt;p&gt;应用程序代码将继承自app，app的所有成员以后都将可用。&lt;/p&gt;
&lt;p&gt;I hope this design will provide a solid base to develop future Vulkan tutorials.&lt;/p&gt;
&lt;p&gt;我希望这样的设计能提供一个坚实的基础，用于开发将来的Vulkan教程。&lt;/p&gt;


&lt;p&gt;The first thing we need to do is to make sure your system supports Vulkan and get everything ready for development.&lt;/p&gt;
&lt;p&gt;我们要做的第一件事，是确保你的系统支持Vulkan，准备好开发所需的一切。&lt;/p&gt;
&lt;p&gt;You need to verify that your graphics card supports Vulkan and install the latest drivers for it.&lt;/p&gt;
&lt;p&gt;你需要验证你的图形卡是否支持Vulkan，并安装最新的驱动程序。&lt;/p&gt;
&lt;p&gt;Since Vulkan is still new it's best to check for drivers updates often because hardware vendors will probably fix a lot of bugs before everything stabilizes.&lt;/p&gt;
&lt;p&gt;由于Vulkan还很新，最好经常检查驱动更新，因为硬件厂商可能会在驱动稳定前修复很多bug。&lt;/p&gt;
&lt;p&gt;Since there are many GPUs available I can't provide much help here.&lt;/p&gt;
&lt;p&gt;由于有太多种GPU，我这里爱莫能助。&lt;/p&gt;
&lt;p&gt;Updating/installing the driver on Windows should be fairly simple.&lt;/p&gt;
&lt;p&gt;在Windows上更新/安装驱动应该相当简单。&lt;/p&gt;
&lt;p&gt;On Linux the process may be a bit more involved.&lt;/p&gt;
&lt;p&gt;在Linux上，就有点难缠。&lt;/p&gt;
&lt;p&gt;My main development system is Linux Fedora and I have a GT710 card by NVIDIA.&lt;/p&gt;
&lt;p&gt;我的开发系统是Linux的Fedora版本，显卡是NVIDIA的GT710。&lt;/p&gt;
&lt;p&gt;NVIDIA provide a binary run file which can only be installed from the command line.&lt;/p&gt;
&lt;p&gt;NVIDIA提供一个二进制运行文件，只能从命令行安装。&lt;/p&gt;
&lt;p&gt;Other vendors have their own processes.&lt;/p&gt;
&lt;p&gt;其他厂商有各自的方式。&lt;/p&gt;
&lt;p&gt;On Linux you can use the 'lspci' to scan your system for devices and see what GPU you have.&lt;/p&gt;
&lt;p&gt;在Linux上你可以用'lspci'命令扫描你的系统，看看有哪些设备，用的什么GPU。&lt;/p&gt;
&lt;p&gt;You can use the '-v', '-vv' and '-vvv' options to get increasingly more info on your devices.&lt;/p&gt;
&lt;p&gt;你可以用'-v'、'-vv'、'-vvv'来得到你的设备的越来越详细的信息。&lt;/p&gt;

&lt;p&gt;The second thing we need is the Vulkan SDK by Khronos, available &lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;第二件事，我们需要Khronos的Vulkan SDK，可在此下载。&lt;/p&gt;
&lt;p&gt;The SDK includes the headers and libraries we need as well as many samples that you can use to get more info beyond what this tutorial provides.&lt;/p&gt;
&lt;p&gt;SDK包含头文件和库文件，很多示例，比本教程多得多的信息。&lt;/p&gt;
&lt;p&gt;At the time of writing this the latest version is 1.0.30.0 and I urge you to update often because the SDK is in active development.&lt;/p&gt;
&lt;p&gt;写作本文时最新版本是1.0.30.0，我推荐读者时常更新，因为SDK还处于活跃地开发中。&lt;/p&gt;
&lt;p&gt;That version number will be used throughout the next few sections so make sure you change it according to the version you have.&lt;/p&gt;
&lt;p&gt;接下来的章节都将使用这个版本号，所以，根据你的版本号，相应地替换之。&lt;/p&gt;

&lt;h2&gt;Linux&lt;/h2&gt;
&lt;p&gt;Khronos provides a package only for Ubuntu in the form of an executable run file.&lt;/p&gt;
&lt;p&gt;Khronos只给Ubuntu提供了一个可执行文件。&lt;/p&gt;
&lt;p&gt;Executing this file should install everything for you but on Fedora I encoutered some difficulties so I used the following procedure (which is also forward looking in terms of writing the code later):&lt;/p&gt;
&lt;p&gt;执行这个文件就可以安装所需的一切。但是在Fedora上我遇到了一些困难，所以我用下述步骤（也是预览一下代码）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bash$ chmod +x vulkansdk-linux-x86_64-1.0.30.0.run&lt;/li&gt;
&lt;li&gt;base$ ./vulkansdk-linux-x86_64-1.0.30.0.run &lt;strong&gt;--target&lt;/strong&gt; VulkanSDK-1.0.30.0 &lt;strong&gt;--noexec&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;base$ ln -s ~/VulkanSDK-1.0.30/1.0.30.0 ~/VulkanSDK&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The above commands extract the contents of the package without running its internal scripts.&lt;/p&gt;
&lt;p&gt;上述命令提取出包的内容，并执行里面的脚本。&lt;/p&gt;
&lt;p&gt;After extraction the directory VulkanSDK-1.0.30.0 will contain a directory called 1.0.30.0 where the actual content of the package will be located.&lt;/p&gt;
&lt;p&gt;提取完成后，文件夹VulkanSDK-1.0.30.0会包含一个子文件夹1.0.30.0，里面是实际的内容。&lt;/p&gt;
&lt;p&gt;Let's assume I ran the above commands in my home directory (a.k.a in bash as '~') so we should end up with a '~/VulkanSDK' symbolic link to the directory with the actual content (directories such as 'source', 'samples', etc).&lt;/p&gt;
&lt;p&gt;假定我是在home文件夹下运行的上述命令（即'~'），那么会有一个'~/VulkanSDK'符号链接到实际内容（文件夹'source'、'samples'等）。&lt;/p&gt;
&lt;p&gt;This link makes it easier to switch your development environment to newer versions of the SDK.&lt;/p&gt;
&lt;p&gt;这个链接使得切换到SDK的新版本更容易。&lt;/p&gt;
&lt;p&gt;It points to the location of the headers and libraries that we need.&lt;/p&gt;
&lt;p&gt;它指向我们需要的头文件和库文件的位置。&lt;/p&gt;
&lt;p&gt;We will see later how to connect them to the rest of the system. Now do the following:&lt;/p&gt;
&lt;p&gt;稍后我们将看到如何将它们连接到系统的其他部分。现在执行下述命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bash$ cd VulkanSDK/1.0.30.0&lt;/li&gt;
&lt;li&gt;bash$ ./build_examples.sh&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If everything went well the examples were built into &lt;strong&gt;'examples/build'&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;如果一切顺利，示例会出现在文件夹&lt;strong&gt;'examples/build'&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;To run the examples you must first cd into that directory.&lt;/p&gt;
&lt;p&gt;为运行示例，你首先要进入这个文件夹。&lt;/p&gt;
&lt;p&gt;You can now run './cube' and './vulkaninfo' to make sure Vulkan runs on your system and get some useful information on the driver.&lt;/p&gt;
&lt;p&gt;你现在可以运行'./cube'和'./vulkaninfo'命令来确认Vulkan跑在你的系统上了，还可以得到一些驱动的有用信息。&lt;/p&gt;
&lt;p&gt;Hopefully everything is OK so far so we want to create some symbolic links that will make the files we need for development easily accessible from our working environment.&lt;/p&gt;
&lt;p&gt;单元一切顺利，目前我们想创建一些符号链接，方便我们使用开发过程中会用到的文件。&lt;/p&gt;
&lt;p&gt;Change to the root user (by executing 'su' and entering the root password) and execute the following:&lt;/p&gt;
&lt;p&gt;跳到root用户（执行'su'命令，输入root密码），执行下述命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bash# ln -s /home/&amp;lt;your username&amp;gt;/VulkanSDK/x86_x64/include/vulkan /usr/include&lt;/li&gt;
&lt;li&gt;base# ln -s /home/&amp;lt;your username&amp;gt;/VulkanSDK/x86_x64/lib/libvulkan.so.1 /usr/lib64&lt;/li&gt;
&lt;li&gt;base# ln -s /usr/lib64/libvulkan.so.1 /usr/lib64/libvulkan.so&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;What we did in the above three commands is to create a symbolic link from /usr/include to the vulkan header directory.&lt;/p&gt;
&lt;p&gt;上述3个命令，创建了一个从/usr/include到Vulkan头文件夹的符号链接。&lt;/p&gt;
&lt;p&gt;We also created a couple of symbolic links to the shared object files against which we are going to link our executables.&lt;/p&gt;
&lt;p&gt;我们还创建了一些共享对象的符号链接，今后会将我们的程序链接到这些共享对象。&lt;/p&gt;
&lt;p&gt;From now one whenever we download a new version of the SDK we just need to change the symbolic link '~/VulkanSDK' to the new location in order to keep the entire system up to date.&lt;/p&gt;
&lt;p&gt;从现在开始，无论何时我们下载了新版本的SDK，我们只需将符号链接'~/VulkanSDK'修改为指向新位置，就可以让整个系统更新完毕。&lt;/p&gt;
&lt;p&gt;To emphasis: the procedure as the root user must only be executed once.&lt;/p&gt;
&lt;p&gt;强调一点：root用户执行的过程必须只执行一次。&lt;/p&gt;
&lt;p&gt;When you get a newer version of the SDK you will only need to extract it and update the symbolic link from your home directory.&lt;/p&gt;
&lt;p&gt;当你得到了新版SDK，你只需提取它的内容，从你的home文件夹更新符号链接。&lt;/p&gt;
&lt;p&gt;You are free to place that link anywhere you want but the code I provide will assume it is in the home directory so you will need to fix that.&lt;/p&gt;
&lt;p&gt;你可以将这个链接房子任何你喜欢的地方，但是我提供的代码中都假定它在home文件夹。所以你需要相应地修改之。&lt;/p&gt;

&lt;h2&gt;Windows&lt;/h2&gt;
&lt;p&gt;Installation on Windows is simpler than on Linux.&lt;/p&gt;
&lt;p&gt;在Windows上按照比在Linux上简单。&lt;/p&gt;
&lt;p&gt;You just need to get the latest version from &lt;a href=&quot;https://vulkan.lunarg.com/sdk/home#windows&quot;&gt;here&lt;/a&gt;, double click the executable installer and after agreeing to the license agreement and selecting the target directory you are done.&lt;/p&gt;
&lt;p&gt;你只需从这里下载最新的版本，双击安装包，同意license，选择目标文件夹，万事大吉。&lt;/p&gt;
&lt;p&gt;I suggest you install the SDK under c:\VulkanSDK to make it compatible with the Visual Studio solution that I provide, but it is not a must. If you install it somewhere else make sure you update the include and link directories in the project files.&lt;/p&gt;
&lt;p&gt;我建议将SDK按照到文件夹c:\VulkanSDK，这样和我提供的Visual Studio解决方案兼容，但不是必须这样。如果你把它安装到其他位置，确保你更新了项目文件中的include和link文件夹。&lt;/p&gt;
&lt;p&gt;See details in the next section.&lt;/p&gt;
&lt;p&gt;详见下一节。&lt;/p&gt;

&lt;h2&gt;Linux&lt;/h2&gt;
&lt;p&gt;My main development environment on Linux is &lt;a href=&quot;http://www.netbeans.org/&quot;&gt;Netbeans&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在Linux上我的主要开发环境是Netbeans。&lt;/p&gt;
&lt;p&gt;The source code that accompanies all my tutorials contains project files which can be used with the C/C++ Netbeans download bundle.&lt;/p&gt;
&lt;p&gt;本教程的源代码包含项目文件，可以用C/C++Netbeans打开。&lt;/p&gt;
&lt;p&gt;If you followed the above system setup procedure then these projects should work out of the box for you (and please let me know if there are any problems).&lt;/p&gt;
&lt;p&gt;如果你遵循上述系统建设步骤，那么， 这些项目应该立即可用了（如果有困难请联系我）。&lt;/p&gt;
&lt;p&gt;If you are using a different build system you need to make sure to add the following:&lt;/p&gt;
&lt;p&gt;如果你在用不同的系统，你需要确保添加下述步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;To the compile command: &lt;strong&gt;-I&amp;lt;path to VulkanSDK/1.0.30.0/x86_64/include&amp;gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;加入编译命令：&lt;strong&gt;-I&amp;lt;path to VulkanSDK/1.0.30.0/x86_64/include&amp;gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;To the link command: &lt;strong&gt;-L&amp;lt;path to VulkanSDK/1.0.30.0/x86_64/lib&amp;gt; -lxcb -lvulkan'&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;加入链接命令：&lt;strong&gt;-L&amp;lt;path to VulkanSDK/1.0.30.0/x86_64/lib&amp;gt; -lxcb -lvulkan'&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Even if you don't use Netbeans I suggest you go into 'ogldev/tutorial50' after you unzip the &lt;a href=&quot;http://ogldev.org/ogldev-source.zip&quot;&gt;tutorial source package&lt;/a&gt; and run 'make'.&lt;/p&gt;
&lt;p&gt;即使你不使用Netbeans，我也建议你解压&lt;a href=&quot;http://ogldev.org/ogldev-source.zip&quot;&gt;tutorial source package&lt;/a&gt;后，打开文件夹'ogldev/tutorial50'，运行'make'。&lt;/p&gt;
&lt;p&gt;I provide the makefiles that Netbeans generates so you can check whether your system is able to build them or something is missing.&lt;/p&gt;
&lt;p&gt;我提供Netbeans生成的makefile，这样你就可以检查你的系统能建设它们，或是缺少什么。&lt;/p&gt;
&lt;p&gt;If everything was ok you can now run '&lt;strong&gt;dist/Debug/GNU-Linux-x86/tutorial50&lt;/strong&gt;' from within '&lt;strong&gt;ogldev/tutorial50&lt;/strong&gt;'.&lt;/p&gt;
&lt;p&gt;如果一切顺利， 现在你可以运行文件夹'&lt;strong&gt;ogldev/tutorial50&lt;/strong&gt;'下的'&lt;strong&gt;dist/Debug/GNU-Linux-x86/tutorial50&lt;/strong&gt;'。&lt;/p&gt;
&lt;h2&gt;Windows&lt;/h2&gt;
&lt;p&gt;If you installed the SDK under 'c:\VulkanSDK' then the Visual Studio project files I supply should work out of the box.&lt;/p&gt;
&lt;p&gt;如果你将SDK安装在文件夹'c:\VulkanSDK'，那么我提供的Visual Studio项目文件就已经可用了。&lt;/p&gt;
&lt;p&gt;If you haven't or you want to setup a Visual Studio project from scratch then follow the steps below.&lt;/p&gt;
&lt;p&gt;如果不是，或者你想从零开始设置Visual Studio项目，那么遵循以下步骤。&lt;/p&gt;

&lt;p&gt;To update the include directory right click on the project in the solution explorer, go to &lt;strong&gt;'Properties'&lt;/strong&gt; and then to &lt;strong&gt;'Configuration Properties -&amp;gt; C/C++ -&amp;gt; General'&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;更新include文件夹：在solution explorer面板的项目上右键，点击&lt;strong&gt;'Properties'&lt;/strong&gt;，选择&lt;strong&gt;'Configuration Properties -&amp;gt; C/C++ -&amp;gt; General'&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Now you must add &lt;strong&gt;'c:\VulkanSDK\&amp;lt;version&amp;gt;\Include'&lt;/strong&gt; to &lt;strong&gt;'Additional Include Directories'&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在，必须将&lt;strong&gt;'c:\VulkanSDK\&amp;lt;version&amp;gt;\Include'&lt;/strong&gt;添加到&lt;strong&gt;'Additional Include Directories'&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;See example below:&lt;/p&gt;
&lt;p&gt;示例如下：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190609030506989-1070189001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;To update the link directory right click on the project in the solution explorer, go to &lt;strong&gt;'Properties'&lt;/strong&gt; and then to &lt;strong&gt;'Configuration Properties -&amp;gt; Link -&amp;gt; General'&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;更新link文件夹：在solution explorer面板的项目上右键，点击&lt;strong&gt;'Properties'&lt;/strong&gt;，选择&lt;strong&gt;'Configuration Properties -&amp;gt; Link -&amp;gt; General'&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Now you must add &lt;strong&gt;'c:\VulkanSDK\&amp;lt;version&amp;gt;\Bin32'&lt;/strong&gt; to &lt;strong&gt;'Additional Library Directories'&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在，必须将&lt;strong&gt;'c:\VulkanSDK\&amp;lt;version&amp;gt;\Bin32'&lt;/strong&gt;添加到&lt;strong&gt;'Additional Library Directories'&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;See example below:&lt;/p&gt;
&lt;p&gt;示例如下：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190609030521296-1526536789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;While you are still in the linker settings go to &lt;strong&gt;'Input'&lt;/strong&gt; (just one below 'General') and add &lt;strong&gt;'vulkan-1.lib'&lt;/strong&gt; to &lt;strong&gt;'Additional Dependencies&quot;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;趁你还在链接器设置面板，选择&lt;strong&gt;'Input'&lt;/strong&gt;（在'General'下面一个），添加&lt;strong&gt;'vulkan-1.lib'&lt;/strong&gt;到&lt;strong&gt;'Additional Dependencies&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;General Comments 基础命令&lt;/h3&gt;
&lt;p&gt;Before we get going I have a few comments about some of my design choices with regard to Vulkan:&lt;/p&gt;
&lt;p&gt;正式开始前，我要对我关于Vulkan的设计选择作几点说明：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;Many Vulkan functions (particularly the ones used to create objects) take a structure as one of the parameters.&lt;br/&gt;很多Vulkan函数（特别是创建对象的函数）接收一个struct作为参数之一。&lt;br/&gt;This structure usually serve as a wrapper for most of the parameters the function needs and it helps in keeping the number of parameters to the function low.&lt;br/&gt;这个struct一般用于封装函数需要的大多数参数，利于使函数的参数数量保持在比较低的水平。&lt;br/&gt;The Vulkan architects decided to place a member called &lt;strong&gt;sType&lt;/strong&gt; as the first member in all these structures.&lt;br/&gt;Vulkan架构决定将所有这些struct的第一个参数设置为名为&lt;strong&gt;sType&lt;/strong&gt;的成员。&lt;br/&gt;This member is of an enum type and every structure has its own code.&lt;br/&gt;这个成员是个枚举类型，每个struct都有自己的枚举值。&lt;br/&gt;This allows the driver to identify the type of the structure using only its address.&lt;br/&gt;这可以让驱动程序只需知道struct的地址就可以确定它的类型。&lt;br/&gt;All of these enum code have a &lt;strong&gt;VK_STRUCTURE_TYPE_&lt;/strong&gt; prefix.&lt;br/&gt;所有这些枚举值都有前缀&lt;strong&gt;VK_STRUCTURE_TYPE_&lt;/strong&gt;。&lt;br/&gt;For example, the code for the structure used in the creation of the instance is called &lt;strong&gt;VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO&lt;/strong&gt;.&lt;br/&gt;例如，在创建instance中使用的struct的枚举值名字是&lt;strong&gt;VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO&lt;/strong&gt;。&lt;br/&gt;Whenever I declare a variable of one of these structure types the first member I update will be sType.&lt;br/&gt;无论何时我声明一个这样的struct变量，第一个更新的成员都是sType。&lt;br/&gt;To save time I won't comment about it later in the source walkthrough.&lt;br/&gt;为节省时间，我以后不会提及这一点。&lt;/li&gt;
&lt;li&gt;Another comment on these Vulkan structures - they contain quite a lot of stuff which we don't need in our first few steps.&lt;br/&gt;关于这些Vulkan的struct的另一个说明——它们包含很多我们初期不需要的东西。&lt;br/&gt;To keep the code as short as possible (as well as the text here...) I always initialize the memory of all structures to zero (using the &lt;strong&gt;struct = {}&lt;/strong&gt; notation) and I will only set and describe the structure members that cannot be zero.&lt;br/&gt;为了让代码和文字尽可能短，我总是将所有成员初始化为0（使用struct = {}概念），只会描述不能为0的成员。&lt;br/&gt;I will discuss the stuff that I skipped in future tutorials as they become relevant.&lt;br/&gt;我将在以后的教程中讨论这里跳过的东西，等需要用它们的时候。&lt;/li&gt;
&lt;li&gt;Vulkan functions are either void or they return a &lt;strong&gt;VkResult&lt;/strong&gt; which is the error code.&lt;br/&gt;Vulkan函数要么返回void要么返回一个&lt;strong&gt;VkResult&lt;/strong&gt;，表示错误码。&lt;br/&gt;The error code is an enum where &lt;strong&gt;VK_SUCCESS&lt;/strong&gt; is zero and everything else is greater than zero.&lt;br/&gt;错误码是个枚举类型，其中&lt;strong&gt;VK_SUCCESS&lt;/strong&gt; 是0，其他枚举值都大于0。&lt;br/&gt;When it is possible I check the return value for errors.&lt;br/&gt;可能的话我会检查返回值，看看有没有错误。&lt;br/&gt;If an error occured I print a message to the console (on Windows there should be a message box) and exit.&lt;br/&gt;如果发生错误，我打印一个消息到控制台（在Windows上应该有个消息盒），然后退出程序。&lt;br/&gt;Error handling in real world applications tend to make the code more complex and I want to keep it as simple as possible.&lt;br/&gt;真实世界应用程序的错误处理代码，会更加复杂。作为教程，我希望它尽可能简单。&lt;/li&gt;
&lt;li&gt;Many Vulkan functions (particularly of creation type) can take a pointer to an allocator function.&lt;br/&gt;很多Vulkan函数（特别是创建型的）接收一个指针作为allocator函数。&lt;br/&gt;These allocators allow you to control the process of allocating memory that the Vulkan functions need.&lt;br/&gt;这些allocator允许你控制Vulkan函数需要的内存被分配的过程。&lt;br/&gt;I consider this as an advanced topic and will not discuss it.&lt;br/&gt;我认为这是个高级话题，就不讨论它了。&lt;br/&gt;We will pass NULL as the allocators so the driver will use its default.&lt;br/&gt;我们将NULL传给allocator，这样驱动会用默认的allocator。&lt;/li&gt;
&lt;li&gt;Vulkan does not guarantee that its functions will be automatically exposed by the implementing library.&lt;br/&gt;Vulkan不保证它的函数会被自动地被实现库暴露。&lt;br/&gt;This means that on some platforms you might get a segmentation fault when you call a Vulkan function because it turns out to be a NULL.&lt;br/&gt;这意味着在某些平台上你在调用Vulkan函数时可能遇到段错误，因为函数指针实际上是NULL。&lt;br/&gt;In these cases you have to use &lt;strong&gt;vkGetInstanceProcAddr()&lt;/strong&gt; to get the function address before it is used (remember that with OpenGL we had GLEW to save us from all this hassle).&lt;br/&gt;此时你必须在使用函数前用&lt;strong&gt;vkGetInstanceProcAddr()&lt;/strong&gt;得到函数地址。（回忆在OpenGL中我们用GLEW拯救自己于这些困扰中）&lt;br/&gt;My personal experience with my driver was that only vkCreateDebugReportCallbackEXT() was not available.&lt;br/&gt;我对我的驱动的经验是，只有vkCreateDebugReportCallbackEXT()不可用。&lt;br/&gt;This function is only required for the optional validation layer.&lt;br/&gt;这个函数只在可选验证层需要。&lt;br/&gt;Therefore, I decided to take a risk and release the tutorial without fetching the addresses for all the functions that I used.&lt;br/&gt;因此，我决定冒险放出这些教程，不保证所有的函数都能找到地址。&lt;br/&gt;If readers will report problems on their platforms I will update the code.&lt;br/&gt;如果读者反馈他们平台上遇到的问题，我将更新我的代码。&lt;/li&gt;
&lt;li&gt;Every serious software has to deal with object deallocation or it will eventually run out of memory.&lt;br/&gt;每个正经软件都要处理对象释放问题，否则最终会内存不足。&lt;br/&gt;In this tutorial I'm keeping things simple and not destroying any of the objects that I allocate.&lt;br/&gt;本教程中一切从简，不负责销毁申请的内存。&lt;br/&gt;They are destroyed anyway when the program shuts down.&lt;br/&gt;反正程序关闭时它们都会被销毁。&lt;br/&gt;I will probably revisit this topic in the future but for now just remember that almost every &amp;lt;&lt;strong&gt;vkCreate*()&lt;/strong&gt; function has a corresponding &lt;strong&gt;vkDestroy*()&lt;/strong&gt; and you need to be careful if you are destroying stuff while the program is running.&lt;br/&gt;将来我可能会重提这个话题，但现在就记住几乎所有函数都有对应的函数，如果你要在程序运行时销毁对象，要十分小心。&lt;br/&gt;You can find more information about it &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/xhtml/vkspec.html#fundamentals-objectmodel-overview&quot;&gt;here&lt;/a&gt;.&lt;br/&gt;你可以在此找到更多信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Code Structure 代码结构&lt;/h3&gt;
&lt;p&gt;Here's a short summary of the files that contain the code that we are going to review.&lt;/p&gt;
&lt;p&gt;先概述一下我们即将遇到的代码文件。&lt;/p&gt;
&lt;p&gt;The path relates to the root of the ogldev software package:&lt;/p&gt;
&lt;p&gt;路径是相对ogldev软件包的根目录的：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;&lt;strong&gt;tutorial50/tutorial50.cpp&lt;/strong&gt; - location of the main() function.&lt;br/&gt;&lt;strong&gt;tutorial50/tutorial50.cpp&lt;/strong&gt; - main()函数的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;include/ogldev_vulkan.h&lt;/strong&gt; - primary header for all of our Vulkan code.&lt;br/&gt;&lt;strong&gt;include/ogldev_vulkan.h&lt;/strong&gt; -我们的Vulkan代码的主要头文件。&lt;br/&gt;This is the only place where the Vulkan headers by Khronos are included.&lt;br/&gt;唯一包含Khronos的Vulkan头文件的地方。&lt;br/&gt;You can enable the validation layer here by uncommenting &lt;strong&gt;ENABLE_DEBUG_LAYERS&lt;/strong&gt;.&lt;br/&gt;你可以通过取消注释&lt;strong&gt;ENABLE_DEBUG_LAYERS&lt;/strong&gt;来启用验证层。&lt;br/&gt;This file contains a few Vulkan helper functions and macros as well as the definition of the &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; class.&lt;br/&gt;这个文件包含一些Vulkan辅助函数、宏定义和类型&lt;strong&gt;VulkanWindowControl&lt;/strong&gt;的定义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Common/ogldev_vulkan.cpp&lt;/strong&gt; - implementation of the functions defined in ogldev_vulkan.h&lt;br/&gt;&lt;strong&gt;Common/ogldev_vulkan.cpp&lt;/strong&gt; – 在ogldev_vulkan.h中定义的函数的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;include/ogldev_vulkan_core.h&lt;/strong&gt; - declaration of the &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; which is the primary class that we will develop.&lt;br/&gt;&lt;strong&gt;include/ogldev_vulkan_core.h&lt;/strong&gt; - &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt;的声明，是我们要开发的主要类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Common/ogldev_vulkan_core.cpp&lt;/strong&gt; - implementation of the &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; class.&lt;br/&gt;&lt;strong&gt;Common/ogldev_vulkan_core.cpp&lt;/strong&gt; -类型&lt;strong&gt;OgldevVulkanCore&lt;/strong&gt;的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;include/ogldev_xcb_control.h&lt;/strong&gt; - declaration of the &lt;strong&gt;XCBControl&lt;/strong&gt; class that creates a window surface on Linux.&lt;br/&gt;&lt;strong&gt;include/ogldev_xcb_control.h&lt;/strong&gt; -在Linux上创建窗口的类型&lt;strong&gt;XCBControl&lt;/strong&gt;的声明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Common/ogldev_xcb_control.cpp&lt;/strong&gt; - implementation of &lt;strong&gt;XCBControl&lt;/strong&gt;.&lt;br/&gt;&lt;strong&gt;Common/ogldev_xcb_control.cpp&lt;/strong&gt; -类型&lt;strong&gt;XCBControl&lt;/strong&gt;的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;include/ogldev_win32_control.h&lt;/strong&gt; - declaration of the &lt;strong&gt;Win32Control&lt;/strong&gt; class that creates a window surface on Windows.&lt;br/&gt;&lt;strong&gt;include/ogldev_win32_control.h&lt;/strong&gt; -在Windows上场景窗口表面的类型&lt;strong&gt;Win32Control&lt;/strong&gt; 的声明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Common/ogldev_win32_control.cpp&lt;/strong&gt; - implementation of &lt;strong&gt;Win32Control&lt;/strong&gt;.&lt;br/&gt;&lt;strong&gt;Common/ogldev_win32_control.cpp&lt;/strong&gt; -类型&lt;strong&gt;Win32Control&lt;/strong&gt;的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Note that on both Netbeans and Visual Studio the files are divided between the 'tutorial50' and 'Common' projects.&lt;/p&gt;
&lt;p&gt;注意，在Netbeans和Visual Studio中这些文件被分到'tutorial50'和'Common'项目中。&lt;/p&gt;
&lt;h3&gt;Source walkthru 源代码浏览&lt;/h3&gt;
&lt;p&gt;I hope that you successfully completed the above procedures and you are now ready to dive into the internals of Vulkan itself.&lt;/p&gt;
&lt;p&gt;我希望你已经成功地完成了上述步骤，现在你可以深入Vulkan内部了。&lt;/p&gt;
&lt;p&gt;As I said, we are going to develop our first demo in several steps.&lt;/p&gt;
&lt;p&gt;我说过，我们计划分几步来开发第一个示例。&lt;/p&gt;
&lt;p&gt;The first step will be to setup four important Vulkan objects: the instance, surface, physical device and logical device.&lt;/p&gt;
&lt;p&gt;第一步是建设4个重要的Vulkan对象：instance，surface，physical device和logical device。（译者注：关键名词我就不翻译了，这样反而更便于理解。）&lt;/p&gt;
&lt;p&gt;I'm going to describe this by walking through my software design but you are welcomed to throw this away and just follow the Vulkan calls themselves.&lt;/p&gt;
&lt;p&gt;我计划在介绍我的软件设计过程中描述这些对象，但是你完全可以扔掉这一思路，直接面对Vulkan函数。&lt;/p&gt;
&lt;p&gt;The first thing we need to do is to include the Vulkan headers.&lt;/p&gt;
&lt;p&gt;首先，我们要include一下Vulkan头文件。&lt;/p&gt;
&lt;p&gt;I've added ogldev_vulkan.h as the primary Vulkan include file in my projects.&lt;/p&gt;
&lt;p&gt;我已经在项目的ogldev_vulkan.h中加入了Vulkan的基础include文件。&lt;/p&gt;
&lt;p&gt;This will be the only place where I will include the Vulkan header files and everything else will just include this file.&lt;/p&gt;
&lt;p&gt;这是我唯一include了Vulkan头文件的地方，其他位置都只include这个文件。（从而间接incdlue的Vulkan头文件）&lt;/p&gt;
&lt;p&gt;Here's the relevant piece of code:&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#ifdef _WIN32
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; VK_USE_PLATFORM_WIN32_KHR
&lt;span&gt;3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vulkan/vulkan.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vulkan/vk_sdk_platform.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; VK_USE_PLATFORM_XCB_KHR
&lt;span&gt;7&lt;/span&gt; #include &amp;lt;vulkan/vulkan.h&amp;gt;
&lt;span&gt;8&lt;/span&gt; #include &amp;lt;vulkan/vk_sdk_platform.h&amp;gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we define different _PLATFORM_ macros for Windows and Linux.&lt;/p&gt;
&lt;p&gt;注意，我们为Windows和Linux定义了不同的_PLATFORM_宏。&lt;/p&gt;
&lt;p&gt;These macros enable the extensions that support the windowing systems in each OS.&lt;/p&gt;
&lt;p&gt;这些宏定义启用了支持各个操作系统的窗口的扩展。&lt;/p&gt;
&lt;p&gt;The reason that we include the headers like that is that on Linux they are installed in a system directory ( &lt;strong&gt;/usr/include/vulkan&lt;/strong&gt; ) whereas on Windows they are installed in a standard directory.&lt;/p&gt;
&lt;p&gt;我们这样include头文件的原因，是在Linux上它们位于系统文件夹（&lt;strong&gt;/usr/include/vulkan&lt;/strong&gt; ）而在Windows上它们位于标准文件夹。&lt;/p&gt;
&lt;p&gt;Let's start by reviewing the class &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; whose job is to create and maintain the core objects (note that I'm using red in order to mark all Vulkan structs, enums, functions, etc):&lt;/p&gt;
&lt;p&gt;开始时，我们来了解一下&lt;strong&gt;OgldevVulkanCore&lt;/strong&gt;类型，它负责创建和维护核心对象（注意，我用红色标记所有Vulkan的struct，enum，函数等）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OgldevVulkanCore
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    OgldevVulkanCore(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pAppName);
    &lt;/span&gt;~&lt;span&gt;OgldevVulkanCore();
    
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Init(VulkanWindowControl*&lt;span&gt; pWindowControl);
              
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;VkPhysicalDevice&lt;/span&gt;&amp;amp; GetPhysDevice() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;VkSurfaceFormatKHR&lt;/span&gt;&amp;amp; GetSurfaceFormat() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;VkSurfaceCapabilitiesKHR&lt;/span&gt; GetSurfaceCaps() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;VkSurfaceKHR&lt;/span&gt;&amp;amp; GetSurface() &lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_surface; }
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; GetQueueFamily() &lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_gfxQueueFamily; }
    
    &lt;span&gt;VkInstance&lt;/span&gt;&lt;/span&gt;&amp;amp; GetInstance() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_inst; }
    
    &lt;span&gt;VkDevice&lt;/span&gt;&lt;/span&gt;&amp;amp; GetDevice() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_device; }
    
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateInstance();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateSurface();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SelectPhysicalDevice();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateLogicalDevice();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vulkan objects&lt;/span&gt;
&lt;span&gt;    VkInstance m_inst;
    VkDevice m_device;
    VkSurfaceKHR m_surface;
    VulkanPhysicalDevices m_physDevices;
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Internal stuff&lt;/span&gt;
    std::&lt;span&gt;string&lt;/span&gt;&lt;span&gt; m_appName;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_gfxDevIndex;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_gfxQueueFamily;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This class has three pure Vulkan members (m_inst, surface and m_device) as well as a vector of Vulkan objects called m_physDevices (see the definition below).&lt;/p&gt;
&lt;p&gt;这个类型有3个纯Vulkan成员（m_inst、surface和m_device），一个Vulkan对象的列表m_physDevices。&lt;/p&gt;
&lt;p&gt;In addition, we have members to keep the application name, an index to the physical device we will be using and an index to the queue family.&lt;/p&gt;
&lt;p&gt;另外，我们分别用一个成员记录应用程序名，对physical device的索引和对queue family的索引。&lt;/p&gt;
&lt;p&gt;The class also contains a few getter functions and an Init() function that set's everything up.&lt;/p&gt;
&lt;p&gt;这个类还包含几个getter函数和一个初始化函数Init()。&lt;/p&gt;
&lt;p&gt;Let's see what it does.&lt;/p&gt;
&lt;p&gt;我们看看它做了什么。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OgldevVulkanCore::Init(VulkanWindowControl*&lt;span&gt; pWindowControl)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     std::vector&amp;lt;VkExtensionProperties&amp;gt;&lt;span&gt; ExtProps;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    VulkanEnumExtProps(ExtProps);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    CreateInstance();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#ifdef WIN32
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     assert(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     m_surface = pWindowControl-&amp;gt;&lt;span&gt;CreateSurface(m_inst);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    assert(m_surface);          
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Surface created\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    VulkanGetPhysicalDevices(m_inst, m_surface, m_physDevices);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    SelectPhysicalDevice();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    CreateLogicalDevice();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function takes a pointer to a VulkanWindowControl object.&lt;/p&gt;
&lt;p&gt;这个函数接收一个VulkanWindowControl类型的对象指针。&lt;/p&gt;
&lt;p&gt;We will review this object later.&lt;/p&gt;
&lt;p&gt;我们稍后会得到这个对象。&lt;/p&gt;
&lt;p&gt;For now it suffices to say that this is an OS specific class whose job is to create a window surface where rendering will take place.&lt;/p&gt;
&lt;p&gt;现在这里就可以说明，这是个操作系统相关的类型，它的工作是创建一个窗口表面，是渲染的场所。&lt;/p&gt;
&lt;p&gt;As in OpenGL, the Vulkan core spec does not include windowing.&lt;/p&gt;
&lt;p&gt;和OpenGL中一样，Vulkan核心不包含窗口。&lt;/p&gt;
&lt;p&gt;This task is left to extensions and we have windowing extensions for all major operating systems.&lt;/p&gt;
&lt;p&gt;这个任务留给了扩展，我们有各个主流操作系统的扩展。&lt;/p&gt;
&lt;p&gt;An extension is simply an addition to Vulkan which is not part of the core spec.&lt;/p&gt;
&lt;p&gt;扩展，是一个Vulkan的附加内容，不属于其核心。&lt;/p&gt;
&lt;p&gt;Members of Khronos can publish their own extensions and add them to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/&quot;&gt;registry&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Khronos的成员可以发布他们自己的扩展，并添加到registry。&lt;/p&gt;
&lt;p&gt;Driver vendors can decide which extension they want to implement.&lt;/p&gt;
&lt;p&gt;驱动程序开发商可以决定他们想实现哪些扩展。&lt;/p&gt;
&lt;p&gt;The developer can then query for the list of available extensions during runtime and proceed accordingly.&lt;/p&gt;
&lt;p&gt;开发者可以在运行时查询可用扩展，然后据此开展工作。&lt;/p&gt;

&lt;p&gt;We start by enumerating all these extensions.&lt;/p&gt;
&lt;p&gt;我们从枚举所有扩展开始。&lt;/p&gt;
&lt;p&gt;This is done in the following wrapper function:&lt;/p&gt;
&lt;p&gt;这通过下述封装函数完成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; VulkanEnumExtProps(std::vector&amp;amp;&lt;span&gt; ExtProps)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;uint&lt;/span&gt; NumExt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VkResult res = vkEnumerateInstanceExtensionProperties(NULL, &amp;amp;&lt;span&gt;NumExt, NULL);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkEnumerateInstanceExtensionProperties error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Found %d extensions\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NumExt);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ExtProps.resize(NumExt);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     res = vkEnumerateInstanceExtensionProperties(NULL, &amp;amp;NumExt, &amp;amp;ExtProps[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkEnumerateInstanceExtensionProperties error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);        
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; NumExt ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance extension %d - %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ExtProps[i].extensionName);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The above function is a wrapper to the Vulkan API vkEnumerateInstanceExtensionProperties() which returns the extensions available on the system.&lt;/p&gt;
&lt;p&gt;上述函数封装了Vulkan函数vkEnumerateInstanceExtensionProperties()，它返回系统上可用的扩展。&lt;/p&gt;
&lt;p&gt;The way we use this function is very common in Vulkan.&lt;/p&gt;
&lt;p&gt;使用这个函数的这种方式，在Vulkan中很常见。&lt;/p&gt;
&lt;p&gt;The first call returns the number of extensions which we use to resize the extension vector.&lt;/p&gt;
&lt;p&gt;第一个函数调用返回扩展的数目，我们据此修改数组的长度。&lt;/p&gt;
&lt;p&gt;The second call retrieves the extensions themselves.&lt;/p&gt;
&lt;p&gt;第二个函数调用获取扩展本身。&lt;/p&gt;
&lt;p&gt;The first parameter can be used to select a specific layer.&lt;/p&gt;
&lt;p&gt;第一个参数可用于选择个特定的层。&lt;/p&gt;
&lt;p&gt;Vulkan is structured in a way that allows vendors to add logic layers that do stuff like validation, extra logging, etc.&lt;/p&gt;
&lt;p&gt;Vulkan的结构，支持厂商添加逻辑层，做一些例如验证、额外日志等事情。&lt;/p&gt;
&lt;p&gt;You can decide at runtime which layer you want to enable.&lt;/p&gt;
&lt;p&gt;你可以决定在运行时你想启用哪个层。&lt;/p&gt;
&lt;p&gt;For example, while developing your application you can enable the validation layer and when distributing it to your users - disable it.&lt;/p&gt;
&lt;p&gt;例如，在开发过程中你可以启用验证层，在发布时则禁用它。&lt;/p&gt;
&lt;p&gt;Since we are interested in all the extensions we use NULL as the layer.&lt;/p&gt;
&lt;p&gt;由于我们对所有扩展都有兴趣，我们用NULL为层参数。&lt;/p&gt;

&lt;p&gt;Once we get the extension list we just print it.&lt;/p&gt;
&lt;p&gt;一旦得到了扩展，就打印出来。&lt;/p&gt;
&lt;p&gt;If you want to do some additional logic on the extension list you can do it here.&lt;/p&gt;
&lt;p&gt;如果你想对扩展列表做点别的什么，现在就可以。&lt;/p&gt;
&lt;p&gt;The reason that we print it is to make sure the extensions we enable in the next function are included.&lt;/p&gt;
&lt;p&gt;打印出来的目的是确保我们要在下一个函数中启用的扩展是存在的。&lt;/p&gt;
&lt;p&gt;Next in the initialization process is the creation of the Vulkan instance:&lt;/p&gt;
&lt;p&gt;接下来，要做的初始化工作是创建Vulkan的instance：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OgldevVulkanCore::CreateInstance()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     VkApplicationInfo appInfo =&lt;span&gt; {};       
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     appInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_APPLICATION_INFO;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     appInfo.pApplicationName =&lt;span&gt; m_appName.c_str();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     appInfo.engineVersion = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     appInfo.apiVersion =&lt;span&gt; VK_API_VERSION_1_0;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* pInstExt[] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#ifdef ENABLE_DEBUG_LAYERS
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;        
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        VK_KHR_SURFACE_EXTENSION_NAME,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#ifdef _WIN32    
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;    
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        VK_KHR_XCB_SURFACE_EXTENSION_NAME
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;            
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#ifdef ENABLE_DEBUG_LAYERS    
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* pInstLayers[] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VK_LAYER_LUNARG_standard_validation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;    
&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     VkInstanceCreateInfo instInfo =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     instInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     instInfo.pApplicationInfo = &amp;amp;&lt;span&gt;appInfo;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#ifdef ENABLE_DEBUG_LAYERS    
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     instInfo.enabledLayerCount =&lt;span&gt; ARRAY_SIZE_IN_ELEMENTS(pInstLayers);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     instInfo.ppEnabledLayerNames =&lt;span&gt; pInstLayers;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;    
&lt;span&gt;34&lt;/span&gt;     instInfo.enabledExtensionCount =&lt;span&gt; ARRAY_SIZE_IN_ELEMENTS(pInstExt);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     instInfo.ppEnabledExtensionNames =&lt;span&gt; pInstExt;         
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     VkResult res = vkCreateInstance(&amp;amp;instInfo, NULL, &amp;amp;&lt;span&gt;m_inst);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkCreateInstance %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#ifdef ENABLE_DEBUG_LAYERS
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the address to the vkCreateDebugReportCallbackEXT function&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     my_vkCreateDebugReportCallbackEXT = reinterpret_cast(vkGetInstanceProcAddr(m_inst, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkCreateDebugReportCallbackEXT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the debug callback&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    VkDebugReportCallbackCreateInfoEXT callbackCreateInfo;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     callbackCreateInfo.sType       =&lt;span&gt; VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     callbackCreateInfo.pNext       =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     callbackCreateInfo.flags       = VK_DEBUG_REPORT_ERROR_BIT_EXT |
&lt;span&gt;49&lt;/span&gt;                                      VK_DEBUG_REPORT_WARNING_BIT_EXT |
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                                     VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     callbackCreateInfo.pfnCallback = &amp;amp;&lt;span&gt;MyDebugReportCallback;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     callbackCreateInfo.pUserData   =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    VkDebugReportCallbackEXT callback;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     res = my_vkCreateDebugReportCallbackEXT(m_inst, &amp;amp;callbackCreateInfo, NULL, &amp;amp;&lt;span&gt;callback);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     CheckVulkanError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my_vkCreateDebugReportCallbackEXT error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;    
&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to initialize the Vulkan library we must create an VkInstance object.&lt;/p&gt;
&lt;p&gt;为了初始化Vulkan库，我们必须创建一个VkInstance对象。&lt;/p&gt;
&lt;p&gt;This object carries all the state of the application.&lt;/p&gt;
&lt;p&gt;这个对象持有应用程序的所有状态。&lt;/p&gt;
&lt;p&gt;The function that creates it is called vkCreateInstance() and it takes most of its parameters in a VkInstanceCreateInfo structure.&lt;/p&gt;
&lt;p&gt;创建它的函数是vkCreateInstance()，此函数的参数大部分都在VkInstanceCreateInfo 这个struct里。&lt;/p&gt;
&lt;p&gt;The parameters that we are interested in are the extensions and (optionally) the layers we want to enable.&lt;/p&gt;
&lt;p&gt;我们感兴趣的参数是需要启用的扩展和层（如果有的话）。&lt;/p&gt;
&lt;p&gt;The extensions are the generic surface extension and the OS specific surface extension.&lt;/p&gt;
&lt;p&gt;扩展是通用表面扩展和操作系统相关的表面扩展。&lt;/p&gt;
&lt;p&gt;The extensions and layers are identified by their name strings and for some of them the Khronos SDK provides a macro. &lt;/p&gt;
&lt;p&gt;扩展和层由字符串格式的名字标识，其中有的由Khronos的SDK提供宏定义。&lt;/p&gt;
&lt;p&gt;VkInstanceCreateInfo also takes a pointer to a VkApplicationInfo structure.&lt;/p&gt;
&lt;p&gt;VkInstanceCreateInfo还接收一个VkApplicationInfo结构体的指针。&lt;/p&gt;
&lt;p&gt;This structure describes the application and allows the developer to put in the application name and some internal engine version.&lt;/p&gt;
&lt;p&gt;这个结构体描述了应用程序，允许开发者放进应用程序名和一些内部机器版本。&lt;/p&gt;
&lt;p&gt;An important field of VkApplicationInfo is apiVersion.&lt;/p&gt;
&lt;p&gt;VkApplicationInfo的一个重要字段是apiVersion。&lt;/p&gt;
&lt;p&gt;This is the Vulkan version that the application is requesting and if the driver doesn't support it the call will fail.&lt;/p&gt;
&lt;p&gt;这是应用程序请求的Vulkan版本，如果驱动不支持此版本，请求就会失败。&lt;/p&gt;
&lt;p&gt;We are requesting version 1.0 so it should be ok.&lt;/p&gt;
&lt;p&gt;我们要请求的版本是1.0，应该没问题。&lt;/p&gt;
&lt;p&gt;Once we get the handle of the instance object we can register a function in the validation layer that will print warning and error messages.&lt;/p&gt;
&lt;p&gt;一旦我们得到instance对象的句柄，我们就可以在验证层注册一个函数，用于打印警告和错误信息。&lt;/p&gt;
&lt;p&gt;We must first get a pointer to a function called vkCreateDebugReportCallbackEXT, then we populate a VkDebugReportCallbackCreateInfoEXT structure with flags for the stuff we want the driver to notify us about and a pointer to our debug function.&lt;/p&gt;
&lt;p&gt;我们首先必须得到函数vkCreateDebugReportCallbackEXT的指针，然后传入结构体VkDebugReportCallbackCreateInfoEXT （标记着我们想要驱动通知我们的内容）和一个调试函数。&lt;/p&gt;
&lt;p&gt;The actual registration is done by calling the function whose pointer we previously acquired.&lt;/p&gt;
&lt;p&gt;实际注册通过调用函数（通过函数指针）来完成。&lt;/p&gt;
&lt;p&gt;We define the pointer to vkCreateDebugReportCallbackEXT and our debug callback as follows:&lt;/p&gt;
&lt;p&gt;我们这样定义vkCreateDebugReportCallbackEXT的指针和我们的调试回调函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; PFN_vkCreateDebugReportCallbackEXT my_vkCreateDebugReportCallbackEXT =&lt;span&gt; NULL; 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;VKAPI_ATTR VkBool32 VKAPI_CALL MyDebugReportCallback(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    VkDebugReportFlagsEXT       flags,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    VkDebugReportObjectTypeEXT  objectType,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     uint64_t                    &lt;span&gt;object&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    size_t                      location,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    int32_t                     messageCode,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;                 pLayerPrefix,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;                 pMessage,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;*&lt;span&gt;                       pUserData)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pMessage);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; VK_FALSE;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Since we don't want to fail the original call&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next step is to create a window surface and for that we use the &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; object that the Init() function got as a pointer parameter.&lt;/p&gt;
&lt;p&gt;下一步，要创建窗口surface，为此，我们使用&lt;strong&gt;VulkanWindowControl&lt;/strong&gt;对象，它是Init()函数的参数&lt;/p&gt;
&lt;p&gt;We will review this class later so let's skip it for now (note that we need an instance in order to create a surface so this is why we do stuff in this order).&lt;/p&gt;
&lt;p&gt;我们稍后将细说这个类型，暂时先跳过（注意，我们需要用instatnce来创建surface，这是我们按此顺序做事的原因）。&lt;/p&gt;
&lt;p&gt;Once we have an instance and a surface we are ready to get all the information we need on the physical devices on your system.&lt;/p&gt;
&lt;p&gt;一旦我们有了instance和surface，我们就可以获取你的系统上的physical device的所有信息。&lt;/p&gt;
&lt;p&gt;A physical device is either a discrete or an integrated graphics card on the platform.&lt;/p&gt;
&lt;p&gt;一个physical device是平台上的一个独立显卡或继承显卡。&lt;/p&gt;
&lt;p&gt;For example, your system may have a couple of NVIDIA cards in a SLI formation and an Intel HD graphics GPU integrated into the CPU.&lt;/p&gt;
&lt;p&gt;例如，你的系统里可能有2个NIVDIA显卡（构成SLI阵型）和1个Intel高清图形GPU，集成到CPU上。&lt;/p&gt;
&lt;p&gt;In this case you have three physical devices.&lt;/p&gt;
&lt;p&gt;这样你就又3个physical device。&lt;/p&gt;
&lt;p&gt;The function below retrieves all the physical devices and some of their characteristics and populates the &lt;strong&gt;VulkanPhysicalDevices&lt;/strong&gt; structure.&lt;/p&gt;
&lt;p&gt;下面的函数检索所有的physical device及其特性，还给出&lt;strong&gt;VulkanPhysicalDevices&lt;/strong&gt;结构体。&lt;/p&gt;
&lt;p&gt;This structure is essentially a database of physical devices and their properties.&lt;/p&gt;
&lt;p&gt;这个结构体本质上是physical device及其属性的数据库。&lt;/p&gt;
&lt;p&gt;It is made up of several vectors (sometimes vectors of vectors) of various Vulkan objects.&lt;/p&gt;
&lt;p&gt;它由若干数组（有时是数组的数组）组成，元素为各种Vulkan对象。&lt;/p&gt;
&lt;p&gt;In order to access a specific device you simply go to one of the members and index into that vector using the physical device index.&lt;/p&gt;
&lt;p&gt;为了使用某个特定的device，你只需通过physical device索引找到某个成员和向量的索引。&lt;/p&gt;
&lt;p&gt;So to get all the information on physical device 2 access m_device[2], m_devProps[2], etc.&lt;/p&gt;
&lt;p&gt;即，为得到physical device2的信息，只需使用m_device[2]、m_devProps[2]等。&lt;/p&gt;
&lt;p&gt;The reason I structured it like that (and not a structure per device with all the info inside it) is because it matches the way the Vulkan APIs work.&lt;/p&gt;
&lt;p&gt;我这样设计它的原因是，这样和Vulkan的API风格匹配。&lt;/p&gt;
&lt;p&gt;You provide an array of XYZ and get all the XYZ objects for all physical devices.&lt;/p&gt;
&lt;p&gt;你提供XYZ数组，就得到所有physical device的XYZ对象。&lt;/p&gt;
&lt;p&gt;Here's the definition of that database structure:&lt;/p&gt;
&lt;p&gt;下面是数据库结构体的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; VulkanPhysicalDevices {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     std::vector&amp;lt;VkPhysicalDevice&amp;gt;&lt;span&gt; m_devices;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     std::vector&amp;lt;VkPhysicalDeviceProperties&amp;gt;&lt;span&gt; m_devProps;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     std::vector&amp;lt; std::vector&amp;lt;VkQueueFamilyProperties&amp;gt; &amp;gt;&lt;span&gt; m_qFamilyProps;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     std::vector&amp;lt; std::vector&amp;lt;VkBool32&amp;gt; &amp;gt;&lt;span&gt; m_qSupportsPresent;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     std::vector&amp;lt; std::vector&amp;lt;VkSurfaceFormatKHR&amp;gt; &amp;gt;&lt;span&gt; m_surfaceFormats;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     std::vector&amp;lt;VkSurfaceCapabilitiesKHR&amp;gt;&lt;span&gt; m_surfaceCaps;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's take a look at the function that populates the database.&lt;/p&gt;
&lt;p&gt;现在来看看用于填充数据库的函数。&lt;/p&gt;
&lt;p&gt;The first two parameters are the instance and surface.&lt;/p&gt;
&lt;p&gt;前2个参数是instance和surface。&lt;/p&gt;
&lt;p&gt;The third parameter is where the result will go to.&lt;/p&gt;
&lt;p&gt;第三个参数是结果保存的位置。&lt;/p&gt;
&lt;p&gt;We will review this function step by step.&lt;/p&gt;
&lt;p&gt;我们一步步地观察这个函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; VulkanGetPhysicalDevices(&lt;span&gt;const&lt;/span&gt; VkInstance&amp;amp; inst, &lt;span&gt;const&lt;/span&gt; VkSurfaceKHR&amp;amp; Surface, VulkanPhysicalDevices&amp;amp;&lt;span&gt; PhysDevices)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;uint&lt;/span&gt; NumDevices = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     
&lt;span&gt;5&lt;/span&gt;     VkResult res = vkEnumeratePhysicalDevices(inst, &amp;amp;&lt;span&gt;NumDevices, NULL);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkEnumeratePhysicalDevices error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Num physical devices %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, NumDevices);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first thing we do is get the number of physical devices. Again we see the usage of dual call - first to get the number of items and then to get the items themselves.&lt;/p&gt;
&lt;p&gt;我们要做的第一件事，是获取physical device的数量。我们再次看到了“先获取项目数量，再获取项目内容”的用法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    PhysDevices.m_devices.resize(NumDevices);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    PhysDevices.m_devProps.resize(NumDevices);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    PhysDevices.m_qFamilyProps.resize(NumDevices);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    PhysDevices.m_qSupportsPresent.resize(NumDevices);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    PhysDevices.m_surfaceFormats.resize(NumDevices);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     PhysDevices.m_surfaceCaps.resize(NumDevices);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now resize our database so that we will have enough space to retrieve the info on all devices.&lt;/p&gt;
&lt;p&gt;我们现在可以设置数据库的大小，让它有足够的空间来检索所有device的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     res = vkEnumeratePhysicalDevices(inst, &amp;amp;NumDevices, &amp;amp;PhysDevices.m_devices[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkEnumeratePhysicalDevices error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, res);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We do the same call again, this time providing the address of a vector in VkPhysicalDevice as the result.&lt;/p&gt;
&lt;p&gt;我们调用了相同的函数，这次提供了VkPhysicalDevice里的数组地址，用于保存结果。&lt;/p&gt;
&lt;p&gt;Using STL vectors is handly because they function the same way as standard arrays, so the address of the first element is the address of the array.&lt;/p&gt;
&lt;p&gt;使用STL数组很方便，因为它们和标准数组功能相同，所以第一个元素的地址就是数组的地址。&lt;/p&gt;
&lt;p&gt;From our point of view VkPhysicalDevice is just a handle that represents the identity of the physical device.&lt;/p&gt;
&lt;p&gt;从我们的角度看，VkPhysicalDevice 只是一个代表physical device的句柄。&lt;/p&gt;
&lt;p&gt;Now we begin a loop over the number of physical devices where we will extract more info for one device at a time.&lt;/p&gt;
&lt;p&gt;现在我们开始一个循环，对每个physical device，我们提取更多的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; NumDevices ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;const&lt;/span&gt; VkPhysicalDevice&amp;amp; PhysDev =&lt;span&gt; PhysDevices.m_devices[i];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         vkGetPhysicalDeviceProperties(PhysDev, &amp;amp;PhysDevices.m_devProps[i]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We start by getting the properties of the current device.&lt;/p&gt;
&lt;p&gt;开始，我们获取当前device的属性。&lt;/p&gt;
&lt;p&gt;m_devProps is a vector of VkPhysicalDeviceProperties.&lt;/p&gt;
&lt;p&gt;m_devProps是VkPhysicalDeviceProperties的数组。&lt;/p&gt;
&lt;p&gt;This structure contains information about the device such as a name, versions, IDs, etc.&lt;/p&gt;
&lt;p&gt;这个struct包含device的信息，例如名字，版本，编号，等。&lt;/p&gt;
&lt;p&gt;We print some of these properties in the next couple of printf statements:&lt;/p&gt;
&lt;p&gt;我们打印出一些属性来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Device name: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PhysDevices.m_devProps[i].deviceName);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         uint32_t apiVer =&lt;span&gt; PhysDevices.m_devProps[i].apiVersion;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    API version: %d.%d.%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, VK_VERSION_MAJOR(apiVer),
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                                          VK_VERSION_MINOR(apiVer),
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                                           VK_VERSION_PATCH(apiVer));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next we get the properties of all the queue families that the physical device supports.&lt;/p&gt;
&lt;p&gt;下一步，我们得到physical device支持的所有queue family的属性。&lt;/p&gt;
&lt;p&gt;There are four categories of operations that a GPU can perform :&lt;/p&gt;
&lt;p&gt;一个GPU能施展的操作有4种：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;Graphics - 2D/3D rendering (same as OpenGL).&lt;br/&gt;图形 - 2D/3D渲染（和OpenGL相同）&lt;/li&gt;
&lt;li&gt;Compute - general processing work which is not rendering in nature. This can be scientific calculations that need the parallel power of the GPU but not the 3D pipeline.&lt;br/&gt;计算 - 通用处理工作，不限于渲染。可以是科学计算（需要GPU的并行计算能力而不需要3D管道）。&lt;/li&gt;
&lt;li&gt;Transfer - copying of buffers and images.&lt;br/&gt;转移 - 复制缓存和图像。&lt;/li&gt;
&lt;li&gt;Sparse Memory Management - sparse resources are non continguous. This category includes operations to process them.&lt;br/&gt;稀疏内存管理 - 稀疏资源是不连续的。这类操作用来处理它们。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;The work that we send to the device is executed in a queue.&lt;/p&gt;
&lt;p&gt;我们发送到device的工作会在一个queue里执行。&lt;/p&gt;
&lt;p&gt;A device exposes one or more queue families and each family contains one or more queues.&lt;/p&gt;
&lt;p&gt;一个device暴露一个或多个queue family，每个family包含一个或多个queue。&lt;/p&gt;
&lt;p&gt;Each family supports some combination of the four categories above.&lt;/p&gt;
&lt;p&gt;每个family都支持这4种操作的组合。&lt;/p&gt;
&lt;p&gt;The queues in each family all support the family functionality.&lt;/p&gt;
&lt;p&gt;一个family的queue支持此family的全部功能。&lt;/p&gt;
&lt;p&gt;For example, my GPU has two families.&lt;/p&gt;
&lt;p&gt;例如，我的GPU有2个family。&lt;/p&gt;
&lt;p&gt;The first one contains 16 queues that support all the four categories and the other has just one queue that only supports transfer.&lt;/p&gt;
&lt;p&gt;第一个包含16个queue，它们支持所有4种操作；另一个只有1个queue，它只支持转移操作。&lt;/p&gt;
&lt;p&gt;You can take advantage of the specific architecture of the device at runtime in order to tailor the behavior of your app in order to increase performance.&lt;/p&gt;
&lt;p&gt;你可以利用device的特定架构，在运行时定制你的app的行为，从而提升性能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;uint&lt;/span&gt; NumQFamily = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;         
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         
&lt;span&gt; 3&lt;/span&gt;         vkGetPhysicalDeviceQueueFamilyProperties(PhysDev, &amp;amp;&lt;span&gt;NumQFamily, NULL);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    Num of family queues: %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NumQFamily);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        PhysDevices.m_qFamilyProps[i].resize(NumQFamily);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        PhysDevices.m_qSupportsPresent[i].resize(NumQFamily);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         vkGetPhysicalDeviceQueueFamilyProperties(PhysDev, &amp;amp;NumQFamily, &amp;amp;(PhysDevices.m_qFamilyProps[i][&lt;span&gt;0&lt;/span&gt;]));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the code above we get the number of family properties for the current device, resize m_qFamilyProps and m_qSupportsPresent (note that both are vectors of vectors so we must first index into the current device) and after that we get a vector of properties and store it in the database.&lt;/p&gt;
&lt;p&gt;上述代码中，我们得到了当前device的family属性的数目，修正m_qFamilyProps和m_qSupportsPresent的大小（注意，它们都是数组的数组，所以必须先索引到当前device），然后我们得到了属性数组，将其保存到数据库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; q = &lt;span&gt;0&lt;/span&gt; ; q &amp;lt; NumQFamily ; q++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             res = vkGetPhysicalDeviceSurfaceSupportKHR(PhysDev, q, Surface, &amp;amp;&lt;span&gt;(PhysDevices.m_qSupportsPresent[i][q]));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkGetPhysicalDeviceSurfaceSupportKHR error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While we are still on the queue family subject let's query each family and check whether it supports presentation. &lt;/p&gt;
&lt;p&gt;既然我们孩子讨论queu family，我们查询一下每个family，检查它是否支持presentation。&lt;/p&gt;
&lt;p&gt;vkGetPhysicalDeviceSurfaceSupportKHR() takes a physical device, a surface and a queue family index and returns a boolean value which indicates whether this combination of device and family can present on the specified surface.&lt;/p&gt;
&lt;p&gt;函数vkGetPhysicalDeviceSurfaceSupportKHR()接收一个physical device，一个surface和一个queue family索引为参数，返回一个boolean值，表示这个组合是否能表示一个特定的surface。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;uint&lt;/span&gt; NumFormats = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         vkGetPhysicalDeviceSurfaceFormatsKHR(PhysDev, Surface, &amp;amp;&lt;span&gt;NumFormats, NULL);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         assert(NumFormats &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        PhysDevices.m_surfaceFormats[i].resize(NumFormats);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt;         res = vkGetPhysicalDeviceSurfaceFormatsKHR(PhysDev, Surface, &amp;amp;NumFormats, &amp;amp;(PhysDevices.m_surfaceFormats[i][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkGetPhysicalDeviceSurfaceFormatsKHR error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt; ; j &amp;lt; NumFormats ; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;const&lt;/span&gt; VkSurfaceFormatKHR&amp;amp; SurfaceFormat =&lt;span&gt; PhysDevices.m_surfaceFormats[i][j];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    Format %d color space %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, SurfaceFormat.format , SurfaceFormat.colorSpace);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next up is the surface format.&lt;/p&gt;
&lt;p&gt;接下来是surface的格式。&lt;/p&gt;
&lt;p&gt;Each surface can support one or more formats.&lt;/p&gt;
&lt;p&gt;每个surface都可以支持一个或多个格式。&lt;/p&gt;
&lt;p&gt;A format is simply the way data is arranged on the surface.&lt;/p&gt;
&lt;p&gt;格式是数据在surface上安排的方式。&lt;/p&gt;
&lt;p&gt;In general, a format specifies the channels in each pixel and the type of each channel (float, int, etc).&lt;/p&gt;
&lt;p&gt;一般的，格式描述了每个像素的通道和每个通道的类型（float、int，等）。&lt;/p&gt;
&lt;p&gt;For example, VK_FORMAT_R32G32B32_SFLOAT is a surface format with three channels (red, green and blue) of the 32bit floating point type.&lt;/p&gt;
&lt;p&gt;例如，VK_FORMAT_R32G32B32_SFLOAT这个surface格式，有3个通道（RGB），每个都是32位的浮点型数。&lt;/p&gt;
&lt;p&gt;The format of the surface is critical because it determines the way data on the surface is converted or interpreted before various operations (e.g. displaying it to the screen).&lt;/p&gt;
&lt;p&gt;Surface的格式是严格的，因为它决定了数据在surface上的转换和翻译方式（例如在显示到屏幕时）。&lt;/p&gt;
&lt;p&gt;To get the format we need both the physical device and the surface itself because the devices may not be compatible in terms of the surface formats that they can work with.&lt;/p&gt;
&lt;p&gt;为了得到格式，我们需要physical device和surface作为参数，因为device可能不兼容surface的格式。&lt;/p&gt;
&lt;p&gt;There can be multiple surface formats available which is why again we have a vector of vectors here.&lt;/p&gt;
&lt;p&gt;Surface的格式可能有多个，所以我们需要用数组的数组。&lt;/p&gt;
&lt;p&gt;We will need the surface format later which is why it is part of the database. Now we query the surface capabilities:&lt;/p&gt;
&lt;p&gt;稍后我们将需要surface格式，所以它是数据库的一部分。现在我们查询surface的capabilities：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         res = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(PhysDev, Surface, &amp;amp;&lt;span&gt;(PhysDevices.m_surfaceCaps[i]));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkGetPhysicalDeviceSurfaceCapabilitiesKHR error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;        
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        VulkanPrintImageUsageFlags(PhysDevices.m_surfaceCaps[i].supportedUsageFlags);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The VkSurfaceCapabilitiesKHR structure describes the capabilities of the physical device when working with a specific surface.&lt;/p&gt;
&lt;p&gt;VkSurfaceCapabilitiesKHR 结构体描述了physical device与特定surface合作时的capabilities。&lt;/p&gt;
&lt;p&gt;This includes the minimum and maximum images that can be created on the swap chain, the minimum and maximum extents (size of the area that can be rendered), supported rotation, etc.&lt;/p&gt;
&lt;p&gt;这包含交换链上可创建的最小和最大图像，最小和最大扩展（可被渲染的大小），支持的旋转，等。&lt;/p&gt;
&lt;p&gt;There is one such structure for each combination of a physical device and surface and we store it in the m_surfaceCaps vector.&lt;/p&gt;
&lt;p&gt;每个physical device和surface的组合都有一个这样的结构体，我们将其保存到m_surfaceCaps数组。&lt;/p&gt;
&lt;p&gt;We completed getting all the information on the physical devices! (note that some of it is specific to the combination of a device and surface).&lt;/p&gt;
&lt;p&gt;我们完全获取了physical device的所有信息！（注意，某些是针对特定的device和surface组合的）&lt;/p&gt;
&lt;p&gt;The next step in the Init() function is to select one of the physical devices and one of the queues to do the processing.&lt;/p&gt;
&lt;p&gt;函数Init()中的下一步是，选择一个physical device和一个queue。&lt;/p&gt;
&lt;p&gt;The following function does exactly that:&lt;/p&gt;
&lt;p&gt;下述函数实现了这个步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OgldevVulkanCore::SelectPhysicalDevice()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; m_physDevices.m_devices.size() ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt; ; j &amp;lt; m_physDevices.m_qFamilyProps[i].size() ; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             VkQueueFamilyProperties&amp;amp; QFamilyProp =&lt;span&gt; m_physDevices.m_qFamilyProps[i][j];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             
&lt;span&gt; 8&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Family %d Num queues: %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, j, QFamilyProp.queueCount);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             VkQueueFlags flags =&lt;span&gt; QFamilyProp.queueFlags;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    GFX %s, Compute %s, Transfer %s, Sparse binding %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     (flags &amp;amp; VK_QUEUE_GRAPHICS_BIT) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     (flags &amp;amp; VK_QUEUE_COMPUTE_BIT) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     (flags &amp;amp; VK_QUEUE_TRANSFER_BIT) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     (flags &amp;amp; VK_QUEUE_SPARSE_BINDING_BIT) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; VK_QUEUE_GRAPHICS_BIT) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;m_physDevices.m_qSupportsPresent[i][j]) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Present is not supported\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;                 m_gfxDevIndex =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 m_gfxQueueFamily =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using GFX device %d and queue family %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, m_gfxDevIndex, m_gfxQueueFamily);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (m_gfxDevIndex == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No GFX device found!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         assert(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a more advanced application you can have multiple queues on multiple devices but we are keeping it very simple.&lt;/p&gt;
&lt;p&gt;在高级应用程序中你可以使用多个device上的多个queue，但是我们这里就简单为上。&lt;/p&gt;
&lt;p&gt;The nested loop in this function traverses the list of devices and the list of queue families for each device.&lt;/p&gt;
&lt;p&gt;函数中的嵌套循环遍历device数组及其每个queue family数组。&lt;/p&gt;
&lt;p&gt;We are searching for a physical device with a queue family that support graphics functionality as well as being able to present on the surface for which the database was initialized.&lt;/p&gt;
&lt;p&gt;我们要找这样一个physical device及其queue family——它支持图形功能，且能在初始化了数据库的surface上显示。&lt;/p&gt;
&lt;p&gt;When we find such device and family we store their corresponding indices and quit the loop.&lt;/p&gt;
&lt;p&gt;当我们找到这样的device和family时，我们保存它们的索引，退出循环。&lt;/p&gt;
&lt;p&gt;This device and family pair is going to serve us throughout this tutorial.&lt;/p&gt;
&lt;p&gt;这个device和family对将为我们整个教程服务。&lt;/p&gt;
&lt;p&gt;If no such pair is found the application aborts.&lt;/p&gt;
&lt;p&gt;如果没有这样的对，应用程序就中止。&lt;/p&gt;
&lt;p&gt;It means the system doesn't meet the minimum requirements to run the code.&lt;/p&gt;
&lt;p&gt;这意味着系统不支持运行此代码所需的最低要求。&lt;/p&gt;
&lt;p&gt;The last thing we need to do to initialiaze our core object is to create a logical device:&lt;/p&gt;
&lt;p&gt;关于初始化核心对象，最后要做的是创建logical device：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OgldevVulkanCore::CreateLogicalDevice()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; qPriorities = &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VkDeviceQueueCreateInfo qInfo =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     qInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     qInfo.queueFamilyIndex =&lt;span&gt; m_gfxQueueFamily;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     qInfo.queueCount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     qInfo.pQueuePriorities = &amp;amp;&lt;span&gt;qPriorities;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* pDevExt[] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        VK_KHR_SWAPCHAIN_EXTENSION_NAME
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     VkDeviceCreateInfo devInfo =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     devInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     devInfo.enabledExtensionCount =&lt;span&gt; ARRAY_SIZE_IN_ELEMENTS(pDevExt);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     devInfo.ppEnabledExtensionNames =&lt;span&gt; pDevExt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     devInfo.queueCreateInfoCount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     devInfo.pQueueCreateInfos = &amp;amp;&lt;span&gt;qInfo;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        
&lt;span&gt;21&lt;/span&gt;     VkResult res = vkCreateDevice(GetPhysDevice(), &amp;amp;devInfo, NULL, &amp;amp;&lt;span&gt;m_device);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkCreateDevice error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;    
&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Device created\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Vulkan architecture separates the concept of a physical device which is part of the real system and the logical device which is an abstraction on top of it.&lt;/p&gt;
&lt;p&gt;Vulkan架构区分了physical device和logical device，一个是真实的系统的一部分，另一个是在此基础上的抽象。&lt;/p&gt;
&lt;p&gt;The logical device is what we use in the application to create most of the objects that are below the device level (queues, swap chains, etc).&lt;/p&gt;
&lt;p&gt;logical device是我们在应用程序中用于创建大多数属于device层对象（queue，交换链，等）的工具。&lt;/p&gt;
&lt;p&gt;This design choice enables flexibility in the management of device resource as well as configuration of device behavior to fit our needs.&lt;/p&gt;
&lt;p&gt;这个设计决策增加了可扩展性，使得device资源管理和行为配置能灵活适应我们的需求。&lt;/p&gt;
&lt;p&gt;The logical device allows us to expose only parts of the physical device.&lt;/p&gt;
&lt;p&gt;且logical device允许我们只暴露physical device的一部分。&lt;/p&gt;
&lt;p&gt;For example, if the physical device supports both graphics and compute we can expose only graphics via the logical device.&lt;/p&gt;
&lt;p&gt;例如，如果physical device同时支持图形和计算，我们可以通过logical device来只暴露图形部分。&lt;/p&gt;

&lt;p&gt;In order to create the device we need one VkDeviceCreateInfo structure and one or more VkDeviceQueueCreateInfo structures. &lt;/p&gt;
&lt;p&gt;为创建device，我们需要1个VkDeviceCreateInfo 结构体和若干VkDeviceQueueCreateInfo 结构体。&lt;/p&gt;
&lt;p&gt;VkDeviceCreateInfo is the main point of device definition.&lt;/p&gt;
&lt;p&gt;VkDeviceCreateInfo 是device定义的主要部分。&lt;/p&gt;
&lt;p&gt;In that struct we set a pointer to an array of extensions we want to enable.&lt;/p&gt;
&lt;p&gt;这个结构体中，我们设置一个需要启用的扩展的数组的指针。&lt;/p&gt;
&lt;p&gt;We need to enable the swap chain which is defined as part of an extension and not part of the core spec.&lt;/p&gt;
&lt;p&gt;我们需要启用交换链，它是扩展的一部分，不是核心。&lt;/p&gt;
&lt;p&gt;A swap chain is an array of surface images that can be presented.&lt;/p&gt;
&lt;p&gt;交换链是surface图像数组，可以被显示。&lt;/p&gt;
&lt;p&gt;We also need the size of the extension array.&lt;/p&gt;
&lt;p&gt;我们还需要扩展数组的大小。&lt;/p&gt;
&lt;p&gt;The second thing we need is a pointer to an array of VkDeviceQueueCreateInfo structs (and the size of that array).&lt;/p&gt;
&lt;p&gt;我们需要的第二个是VkDeviceQueueCreateInfo 结构体数组的指针（及其大小）。&lt;/p&gt;
&lt;p&gt;For each queue family we want to enable we must have one VkDeviceQueueCreateInfo struct which describes it.&lt;/p&gt;
&lt;p&gt;想启用一个queue family，就必须有一个描述它的VkDeviceQueueCreateInfo 结构体。&lt;/p&gt;
&lt;p&gt;This struct specifies the index of the queue family (which we got earlier in SelectPhysicalDevice()), the number of queues we want to create from that family and for each queue we can specify a different priority.&lt;/p&gt;
&lt;p&gt;这个结构体记录了queue family的索引（我们之前在SelectPhysicalDevice()中得到了），我们希望从此family中创建的queue的数量，对每个queue我们都可以指定一个不同的优先级。&lt;/p&gt;
&lt;p&gt;In this tutorial we we won't deal with priorities.&lt;/p&gt;
&lt;p&gt;本教程中我们不会处理优先级的问题。&lt;/p&gt;
&lt;p&gt;We have just one queue and we set the priority to 1.0.&lt;/p&gt;
&lt;p&gt;我们只有1个queue，将其优先级设置为1.0。&lt;/p&gt;
&lt;p&gt;This completes the initialization process of our &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; class, but to actually call the Init() function we need a &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; which is a class I created to wrap the management of the window surface.&lt;/p&gt;
&lt;p&gt;至此&lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; 类型的初始化就完成了。 但是想调用Init()函数，我们需要一个&lt;strong&gt;VulkanWindowControl&lt;/strong&gt; 类型，这是我创建的峰值了窗口surface的管理工作的类型。&lt;/p&gt;
&lt;p&gt;Remember that this job is not part of the core Vulkan spec and since every operating system needs entirely different code here I found that it makes sense to separate all window management to a different class and implement OS specific versions in the derivatives of this class.&lt;/p&gt;
&lt;p&gt;记住，这个工作不是Vulkan核心的一部分。由于每种操作系统都需要完全不同的代码，我任务应该将窗口管理单独成立一个类，然后继承之，针对各个操作系统实现特定的程序。&lt;/p&gt;
&lt;p&gt;This class is actually an interface and it is defined as follows:&lt;/p&gt;
&lt;p&gt;这个类实际上是个接口，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VulkanWindowControl
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    VulkanWindowControl() {};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     ~&lt;span&gt;VulkanWindowControl() {};
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Init(&lt;span&gt;uint&lt;/span&gt; Width, &lt;span&gt;uint&lt;/span&gt; Height) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; VkSurfaceKHR CreateSurface(VkInstance&amp;amp; inst) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, this class is very simple.&lt;/p&gt;
&lt;p&gt;如你所见，这个类很简单。&lt;/p&gt;
&lt;p&gt;It doesn't have any members.&lt;/p&gt;
&lt;p&gt;它没有任何成员。&lt;/p&gt;
&lt;p&gt;Its constructor and destructor are protected so you can't create an instance of this class directly.&lt;/p&gt;
&lt;p&gt;它的构造函数和析构函数都是protected，所以你不能直接创建此类的实例。&lt;/p&gt;
&lt;p&gt;You can only create an instance of a derived class.&lt;/p&gt;
&lt;p&gt;你只能创建它的继承类的实例。&lt;/p&gt;
&lt;p&gt;There are two public methods.&lt;/p&gt;
&lt;p&gt;有2个public的方法。&lt;/p&gt;
&lt;p&gt;One to initialize the object and one to create a Vulkan surface.&lt;/p&gt;
&lt;p&gt;一个是初始化对象，另一个是创建Vulkan的surface。&lt;/p&gt;
&lt;p&gt;So for every OS we are free to do OS specific stuff but we have to return a VkSurfaceKHR which is a handle to the window surface.&lt;/p&gt;
&lt;p&gt;所以，对每种操作系统，我们可以自由地做特定操作系统的事情，但是必须返回一个VkSurfaceKHR 对象，它是窗口surface的句柄。&lt;/p&gt;
&lt;p&gt;Note that CreateSurface() takes an VkInstance reference as a parameter which means we can init this class before we create our &lt;strong&gt;VulkanCoreObject&lt;/strong&gt; but we have to initialize the &lt;strong&gt;VulkanCoreObject&lt;/strong&gt; before we call CreateSurface().&lt;/p&gt;
&lt;p&gt;注意，函数CreateSurface()接收一个VkInstance 参数，这意味着我们可以在创建&lt;strong&gt;VulkanCoreObject&lt;/strong&gt;之前初始化这个类，但是我们必须在调用函数CreateSurface()之前初始化&lt;strong&gt;VulkanCoreObject&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;We will review this again when we get to the main() function so don't worry about it.&lt;/p&gt;
&lt;p&gt;我们将重审这一点，当我们涉及main()函数的时候。所以不用担心它。&lt;/p&gt;
&lt;p&gt;The concrete classes which implements &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; are &lt;strong&gt;XCBControl&lt;/strong&gt; on Linux and &lt;strong&gt;Win32Control&lt;/strong&gt; on Windows.&lt;/p&gt;
&lt;p&gt;实现&lt;strong&gt;VulkanWindowControl&lt;/strong&gt; 的具体类型，在Linux上是&lt;strong&gt;XCBControl&lt;/strong&gt; ，在Windows上是&lt;strong&gt;Win32Control&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;We will review Linux first and then Windows:&lt;/p&gt;
&lt;p&gt;我们先来看Linux上的，然后再看Windows上的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XCBControl : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VulkanWindowControl
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    XCBControl();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     ~&lt;span&gt;XCBControl();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Init(&lt;span&gt;uint&lt;/span&gt; Width, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; Height);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; VkSurfaceKHR CreateSurface(VkInstance&amp;amp;&lt;span&gt; inst);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:    
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     xcb_connection_t*&lt;span&gt; m_pXCBConn;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     xcb_screen_t*&lt;span&gt; m_pXCBScreen;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    xcb_window_t m_xcbWindow;           
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;XWindow is the most common windowing system on Unix and Linux.&lt;/p&gt;
&lt;p&gt;XWindow是Unix和Linux上最常见的窗口系统。&lt;/p&gt;
&lt;p&gt;It works in a client/server model.&lt;/p&gt;
&lt;p&gt;它以客户端/服务器模式工作。&lt;/p&gt;
&lt;p&gt;The server manages the screen, keyboard and mouse.&lt;/p&gt;
&lt;p&gt;服务器管理屏幕，键盘和鼠标。&lt;/p&gt;
&lt;p&gt;The client is an application that wants to display something on the server.&lt;/p&gt;
&lt;p&gt;客户端是应用程序，它想要显示服务器的上的某些东西。&lt;/p&gt;
&lt;p&gt;It connects to the server via the X11 protocol and sends it requests to create a window, control the mouse/keyboard, etc.&lt;/p&gt;
&lt;p&gt;它通过X11协议与服务器链接，向一个窗口发送请求，控制鼠标键盘，等。&lt;/p&gt;
&lt;p&gt;The two most common implementations of the X11 protocol is Xlib and XCB and Vulkan provides extensions to use both. &lt;/p&gt;
&lt;p&gt;X11协议的最常见的2种实现是Xlib和XCB，Vulkan提供了扩展来使用这2种实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/XCB&quot;&gt;XCB&lt;/a&gt; is more modern so this is what we will use on Linux. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/XCB&quot;&gt;XCB&lt;/a&gt; 更现代化，所以我们将在Linux上用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XCBControl&lt;/strong&gt; implements the &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; class using XCB calls.&lt;/p&gt;
&lt;p&gt;通过调用XCB，&lt;strong&gt;XCBControl&lt;/strong&gt; 实现了&lt;strong&gt;VulkanWindowControl&lt;/strong&gt; 类。&lt;/p&gt;
&lt;p&gt;Remember that the target of this object is to create an OS specific window and connect it to a Vulkan surface so that Vulkan will be able to render to it.&lt;/p&gt;
&lt;p&gt;记住，这个对象的目标，是创建操作系统特定的窗口，链接到Vulkan的surface，以便Vulkan能在它上面渲染。&lt;/p&gt;
&lt;p&gt;Let's start by creating the window.&lt;/p&gt;
&lt;p&gt;开始，让我们来创建窗口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; XCBControl::Init(&lt;span&gt;uint&lt;/span&gt; Width, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; Height)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     m_pXCBConn =&lt;span&gt; xcb_connect(NULL, NULL);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; error =&lt;span&gt; xcb_connection_has_error(m_pXCBConn);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;  (error) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error opening xcb connection error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         assert(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XCB connection opened\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first thing we need to do is to connect to the XWindow server.&lt;/p&gt;
&lt;p&gt;首先要做的，是链接到XWindow服务器。&lt;/p&gt;
&lt;p&gt;You are probably running on a GUI environment so the server is already running in the background.&lt;/p&gt;
&lt;p&gt;你可能政治运行一个GUI环境，所以服务器已经启动了。&lt;/p&gt;
&lt;p&gt;xcb_connect() opens a connection to that server.&lt;/p&gt;
&lt;p&gt;函数xcb_connect()会打开一个到服务器的链接。&lt;/p&gt;
&lt;p&gt;It takes two parameters - the name of the server and a pointer to a preferred screen number (which will be populated by the XCB library).&lt;/p&gt;
&lt;p&gt;它接收2个参数——服务器名字和屏幕编号的指针（由XCB库提供）。&lt;/p&gt;
&lt;p&gt;XWindow is very flexible.&lt;/p&gt;
&lt;p&gt;XWindow可扩展性很强。&lt;/p&gt;
&lt;p&gt;For example, it allows you to run the server on one machine and the client on another.&lt;/p&gt;
&lt;p&gt;例如，它允许你在一台机器上运行服务器，在领另一台机器上运行客户端。&lt;/p&gt;
&lt;p&gt;You can also run multiple instances of the same server on the same machine.&lt;/p&gt;
&lt;p&gt;你也可以在同一台机器上运行服务器的多个实例。&lt;/p&gt;
&lt;p&gt;To connect remotely you need to specify the name or IP as well as a display number in some specific string format and provide it in the first parameter.&lt;/p&gt;
&lt;p&gt;为了链接到远程服务器，你需要标明服务器名字或IP地址以及显示编号到第一个参数（字符串格式）里。&lt;/p&gt;
&lt;p&gt;To run the application locally it is enough to use NULL for both parameters.&lt;/p&gt;
&lt;p&gt;如果是在本地运行应用程序，使用NULL为参数值即可。&lt;/p&gt;
&lt;p&gt;xcb_connect() returns a connection pointer which we store in the class.&lt;/p&gt;
&lt;p&gt;xcb_connect()返回链接指针，我们将其保存到类里。&lt;/p&gt;
&lt;p&gt;It always returns something so we have to check for errors using xcb_connectionn_has_error() in the manner that we see above.&lt;/p&gt;
&lt;p&gt;它总会返回一些东西，所以我们必须检查是否有错误。方法是，用类似上文的方式，使用函数xcb_connectionn_has_error()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; xcb_setup_t *pSetup =&lt;span&gt; xcb_get_setup(m_pXCBConn);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     xcb_screen_iterator_t iter =&lt;span&gt; xcb_setup_roots_iterator(setup);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     
&lt;span&gt;5&lt;/span&gt;     m_pXCBScreen =&lt;span&gt; iter.data;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     
&lt;span&gt;7&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XCB screen %p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, m_pXCBScreen);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A XWindow server can control multiple monitors and potentially run multiple screens on each monitor.&lt;/p&gt;
&lt;p&gt;一个XWindow服务器可以控制多个显示器，在每个显示器上都可以运行多个窗口。&lt;/p&gt;
&lt;p&gt;A screen is where applications are eventually executed.&lt;/p&gt;
&lt;p&gt;一个窗口是应用程序执行（显示）的地方。&lt;/p&gt;
&lt;p&gt;It is defined by a width and height, a color depth, etc.&lt;/p&gt;
&lt;p&gt;它由宽度，高度，颜色深度，等定义。&lt;/p&gt;
&lt;p&gt;We want to get a handle to the current screen and there are two steps that we need to do.&lt;/p&gt;
&lt;p&gt;我们想要得到当前窗口的句柄，这需要2步。&lt;/p&gt;
&lt;p&gt;The first one is to use the xcb_get_setup() function to get access to the xcb_setup_t structure of the connection.&lt;/p&gt;
&lt;p&gt;第一步是使用xcb_get_setup()函数得到链接的结构体xcb_setup_t。&lt;/p&gt;
&lt;p&gt;This struct contains a lot of info about the server.&lt;/p&gt;
&lt;p&gt;这个结构体包括服务器的很多信息。&lt;/p&gt;
&lt;p&gt;One of the things it includes is a list of screens.&lt;/p&gt;
&lt;p&gt;其中之一是窗口列表。&lt;/p&gt;
&lt;p&gt;To access this list we setup an iterator using the xcb_setup_roots_iterator() function.&lt;/p&gt;
&lt;p&gt;为读取这个列表，我们用xcb_setup_roots_iterator()函数设置一个枚举器。&lt;/p&gt;
&lt;p&gt;On a more robust piece of code what you will now see is a loop that traverses the list of screens, searching for the one the applications wants.&lt;/p&gt;
&lt;p&gt;在一个更健壮的程序中，你将看到的是，在一个循环里遍历窗口列表，搜索应用程序需要的那个。&lt;/p&gt;
&lt;p&gt;In our case it is enough to extract the first screen.&lt;/p&gt;
&lt;p&gt;在我们的例子中，只需突起第一个窗口即可。&lt;/p&gt;
&lt;p&gt;The screen can be retrieved from the 'data' member of the iterator.&lt;/p&gt;
&lt;p&gt;窗口可以通过成员'data'来得到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;      m_xcbWindow = xcb_generate_id(m_pXCBConn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We are now ready to create the actual window.&lt;/p&gt;
&lt;p&gt;我们现在可以创建实际的窗口了。&lt;/p&gt;
&lt;p&gt;The first step to do that is to generate a &lt;em&gt;XID&lt;/em&gt; for it.&lt;/p&gt;
&lt;p&gt;首先要生成一个XID。&lt;/p&gt;
&lt;p&gt;The XID is an unsigned integer identifier of many XWindow resources.&lt;/p&gt;
&lt;p&gt;XID是个无符号整数的标识符，用于标记很多XWindow资源。&lt;/p&gt;
&lt;p&gt;When the client connects to a server it allocates a range of XIDs for it from a global range in the server.&lt;/p&gt;
&lt;p&gt;当客户端链接到服务器时，它在服务器全局范围内申请若干XID。&lt;/p&gt;
&lt;p&gt;When the client wants to create some resource on the server it starts by locally allocating an XID from the range it was given.&lt;/p&gt;
&lt;p&gt;当客户端想在服务器上创建某资源时，它从这若干XID上开始。&lt;/p&gt;
&lt;p&gt;The following function calls can use that XID to identify the resource to be created.&lt;/p&gt;
&lt;p&gt;下述函数可以使用XID来标志创建的资源。&lt;/p&gt;
&lt;p&gt;This is somewhat unique in the approach where the server doesn't say &quot;here's your new resource and its identifer is XYZ&quot;.&lt;/p&gt;
&lt;p&gt;这和那种服务器说“这是你的心资源，它的标识符是XYZ”的方式不同。&lt;/p&gt;
&lt;p&gt;Instead, the client says &quot;hey server - I want to create a resource and here's the identifier for it&quot;.&lt;/p&gt;
&lt;p&gt;相反，是客户端说“嘿服务器，我想创建一个资源，这是它的标识符”。&lt;/p&gt;
&lt;p&gt;xcb_generate_id() generates the XID for the window and we store it in the member variable m_xcbWindow.&lt;/p&gt;
&lt;p&gt;xcb_generate_id()函数为窗口生成XID，我们将其保存到成员变量m_xcbWindow中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     xcb_create_window( m_pXCBConn,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the connection to the XWindow server&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;                        XCB_COPY_FROM_PARENT,                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; color depth - copy from parent window&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;                        m_xcbWindow,                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; XID of the new window&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                        m_pXCBScreen-&amp;gt;root,                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; parent window of the new window&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                        &lt;span&gt;0&lt;/span&gt;,                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; X coordinate&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                        &lt;span&gt;0&lt;/span&gt;,                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Y coordinate&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                        Width,                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window width&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                        Height,                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window height&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                        &lt;span&gt;0&lt;/span&gt;,                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; border width&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                        XCB_WINDOW_CLASS_INPUT_OUTPUT,            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window class - couldn't find any documentation on it&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                        m_pXCBScreen-&amp;gt;root_visual,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the visual describes the color mapping&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                        &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                        &lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;xcb_create_window() does the window creation and takes no less than 13 parameters.&lt;/p&gt;
&lt;p&gt;函数xcb_create_window()执行了创建窗口的任务，它接收不少于13个参数。&lt;/p&gt;
&lt;p&gt;I have some comments on the parameters above and most of them are self-explanatory.&lt;/p&gt;
&lt;p&gt;我给了这些参数注释，其中有些参数是自说明的。&lt;/p&gt;
&lt;p&gt;I won't go deeper than that.&lt;/p&gt;
&lt;p&gt;我就不再深入了。&lt;/p&gt;
&lt;p&gt;You can google for more info.&lt;/p&gt;
&lt;p&gt;你可以百度到更多信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    xcb_map_window(m_pXCBConn, m_xcbWindow);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    xcb_flush (m_pXCBConn);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to make the window visible we have to map it and flush the connection which is exactly what the above calls do.&lt;/p&gt;
&lt;p&gt;为了让窗口可见，我们必须把它映射和推进链接（译者注：我也看不懂）。上述代码就是做这些的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    VkSurfaceKHR XCBControl::CreateSurface(VkInstance&amp;amp;&lt;span&gt; inst)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     VkXcbSurfaceCreateInfoKHR surfaceCreateInfo =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     surfaceCreateInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     surfaceCreateInfo.connection =&lt;span&gt; m_pXCBConn;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     surfaceCreateInfo.window =&lt;span&gt; m_xcbWindow;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    VkSurfaceKHR surface;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     VkResult res = vkCreateXcbSurfaceKHR(inst, &amp;amp;surfaceCreateInfo, NULL, &amp;amp;&lt;span&gt;surface);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkCreateXcbSurfaceKHR error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; surface;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The last function from the &lt;strong&gt;XCBControl&lt;/strong&gt; class which we want to review is CreateSurface().&lt;/p&gt;
&lt;p&gt;我们要评析的&lt;strong&gt;XCBControl&lt;/strong&gt; 类的最后一个函数是CreateSurface()。&lt;/p&gt;
&lt;p&gt;This is basically a wrapper around the Vulkan function from the XCB extension vkCreateXcbSurfaceKHR().&lt;/p&gt;
&lt;p&gt;它基本上是对来自XCB扩展的vkCreateXcbSurfaceKHR()函数的封装。&lt;/p&gt;
&lt;p&gt;We populate the VkXcbSurfaceCreateInfoKHR struct with the XWindow server connection pointer and the window which we created earlier.&lt;/p&gt;
&lt;p&gt;我们填入VkXcbSurfaceCreateInfoKHR 结构体，XWindow服务器链接指针和之前创建的窗口。&lt;/p&gt;
&lt;p&gt;In return we get a generic handle to a Vulkan surface which we return back to the caller.&lt;/p&gt;
&lt;p&gt;我们得到的是一个Vulkan的surface句柄，我们将其返回给调用者。&lt;/p&gt;
&lt;p&gt;Now let's review the corresponding class for Windows:&lt;/p&gt;
&lt;p&gt;现在我们来评析Windows对应的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Win32Control : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VulkanWindowControl
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     Win32Control(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pAppName);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     ~&lt;span&gt;Win32Control();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Init(&lt;span&gt;uint&lt;/span&gt; Width, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; Height);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; VkSurfaceKHR CreateSurface(VkInstance&amp;amp;&lt;span&gt; inst);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:    
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    HINSTANCE   m_hinstance;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    HWND        m_hwnd;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    std::wstring m_appName;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, the interface is very similar for both operating systems.&lt;/p&gt;
&lt;p&gt;如你所见，两种操作系统的接口很相似。&lt;/p&gt;
&lt;p&gt;In fact, Init() and CreateSurface() are identical because they are virtual functions.&lt;/p&gt;
&lt;p&gt;实际上，Init()函数和CreateSurface()函数是相同的，因为它们都是虚函数。&lt;/p&gt;
&lt;p&gt;We also have private members to store two Windows specific handles - HINSTANE and HWND.&lt;/p&gt;
&lt;p&gt;我们还用private成员保存2个Windows特有的句柄——HINSTNACE和HWND。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Win32Control::Win32Control(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pAppName) 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     m_hinstance =&lt;span&gt; GetModuleHandle(NULL);;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    assert(m_hinstance);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     m_hwnd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;strong&gt;std::&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s(pAppName);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;7&lt;/span&gt;     m_appName =&lt;strong&gt;&lt;span&gt; std::wstring(s.begin(), s.end())&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Above you can see the constructor for the &lt;strong&gt;Win32Control&lt;/strong&gt; class and I'm only showing it here so that you can see the way that the app name which is provided as an array of char is transformed into a std::wstring.&lt;/p&gt;
&lt;p&gt;如上述代码所示，你可以看到&lt;strong&gt;Win32Control&lt;/strong&gt; 类的构造函数。我将其展示在此，是为了让你看到app的名字是如何由char数组转换为字符串std::string的。&lt;/p&gt;
&lt;p&gt;We do this for the CreateWindowEx() function below that needs a window name parameter with the LPCTSTR type.&lt;/p&gt;
&lt;p&gt;我们为CreateWindowEx()函数搞这么一出，它需要LPCTSTR类型的名称作参数。&lt;/p&gt;
&lt;p&gt;The standard wstring class helps us with that.&lt;/p&gt;
&lt;p&gt;标准wstring类帮助我们完成这一任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DefWindowProc(hwnd, uMsg, wParam, lParam);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Win32Control::Init(&lt;span&gt;uint&lt;/span&gt; Width, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; Height)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     WNDCLASSEX wndcls =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     wndcls.cbSize = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(wndcls);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     wndcls.lpfnWndProc =&lt;span&gt; WindowProc;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     wndcls.hInstance =&lt;span&gt; m_hinstance; 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     wndcls.hbrBackground =&lt;span&gt; (HBRUSH)GetStockObject(WHITE_BRUSH);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     wndcls.lpszClassName = L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ogldev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!RegisterClassEx(&amp;amp;&lt;span&gt;wndcls)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         DWORD error =&lt;span&gt; GetLastError();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         OGLDEV_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RegisterClassEx error %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     m_hwnd = CreateWindowEx(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                             L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ogldev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; class name&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                            m_appName.c_str(),        
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             WS_OVERLAPPEDWINDOW | WS_VISIBLE, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window style&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                             &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;,                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window start&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                            Width, 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                            Height, 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            NULL,          
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                            NULL,          
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                            m_hinstance,   
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                            NULL);  
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (m_hwnd == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         DWORD error =&lt;span&gt; GetLastError();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         OGLDEV_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreateWindowEx error %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    ShowWindow(m_hwnd, SW_SHOW);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code above is straightforward window creation stuff which I got from MSDN so I won't go too deeply into it.&lt;/p&gt;
&lt;p&gt;上述代码一目了然，是创建窗口相关的东西，我从MSDN拿来的，所以我就不深入了。&lt;/p&gt;
&lt;p&gt;We have to register the window class using RegisterClassEx().&lt;/p&gt;
&lt;p&gt;我们必须用RegisterClassEx()函数注册窗口。&lt;/p&gt;
&lt;p&gt;This class will be associated with the WindowProc() function that serve as the event handler for our window.&lt;/p&gt;
&lt;p&gt;这个类将和WindowProc()函数关联，它用作窗口的事件处理器。&lt;/p&gt;
&lt;p&gt;Right now we are just calling the default handler of the system but on the next tutorial we will add more details to it.&lt;/p&gt;
&lt;p&gt;目前我们调用系统默认的处理器，下个教程我们将添加更多细节。&lt;/p&gt;
&lt;p&gt;The window is then created using CreateWindowEx() and finally displayed using ShowWindow().&lt;/p&gt;
&lt;p&gt;现在窗口就被CreateWindowEx()创建好了，通过ShowWindow()显示了出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; VkSurfaceKHR Win32Control::CreateSurface(VkInstance&amp;amp;&lt;span&gt; inst)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     VkWin32SurfaceCreateInfoKHR surfaceCreateInfo =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     surfaceCreateInfo.sType =&lt;span&gt; VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     surfaceCreateInfo.hinstance =&lt;span&gt; m_hinstance;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     surfaceCreateInfo.hwnd =&lt;span&gt; m_hwnd;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    VkSurfaceKHR surface;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     VkResult res = vkCreateWin32SurfaceKHR(inst, &amp;amp;surfaceCreateInfo, NULL, &amp;amp;&lt;span&gt;surface);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     CHECK_VULKAN_ERROR(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vkCreateXcbSurfaceKHR error %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; surface;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CreateSurface() is also very similar to its Linux counterpart.&lt;/p&gt;
&lt;p&gt;函数也和它的Linux版本很像。&lt;/p&gt;
&lt;p&gt;The surfaceCreateInfo param just takes the instance instead of the XCB connection (and of course - the window handles are of different types).&lt;/p&gt;
&lt;p&gt;参数接收instance，而不是XCB链接（当然还有不同类型的窗口句柄）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;**&lt;span&gt; argv)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     VulkanWindowControl* pWindowControl =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#ifdef WIN32
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     pWindowControl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Win32Control(pAppName);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;            
&lt;span&gt; 7&lt;/span&gt;     pWindowControl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XCBControl();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;    
&lt;span&gt; 9&lt;/span&gt;     pWindowControl-&amp;gt;&lt;span&gt;Init(WINDOW_WIDTH, WINDOW_HEIGHT);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     OgldevVulkanCore core(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tutorial 50&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    core.Init(pWindowControl);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At last, we have reached the glue code in the form of the main() function.&lt;/p&gt;
&lt;p&gt;最后，我们抵达了main()函数中的胶水代码。&lt;/p&gt;
&lt;p&gt;If you are interested, you may start here and create the building blocks step by step so that you can check the return values of each Vulkan function call one at a time.&lt;/p&gt;
&lt;p&gt;如果你有兴趣，你可以从此开始，一步步创建building block，这样就可以检查每个Vulkan函数的返回值了。&lt;/p&gt;
&lt;p&gt;What happens in this function has already been generally discussed.&lt;/p&gt;
&lt;p&gt;这个函数中的事我们已经讨论过了。&lt;/p&gt;
&lt;p&gt;We allocate a derivative of the &lt;strong&gt;VulkanWindowControl&lt;/strong&gt; class (be it Linux or Windows).&lt;/p&gt;
&lt;p&gt;我们申请一个&lt;strong&gt;VulkanWindowControl&lt;/strong&gt; 类的子类（根据在Linux还是Windows上）。&lt;/p&gt;
&lt;p&gt;We initialize it (thus creating the OS specific window) and then create and init the &lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; object.&lt;/p&gt;
&lt;p&gt;我们初始化它（即创建操作系统特定的窗口），然后创建和初始化&lt;strong&gt;OgldevVulkanCore&lt;/strong&gt; 对象。&lt;/p&gt;
&lt;p&gt;We now have a Vulkan surface connected to an OS window, a Vulkan instance and device and a database with all the physical devices in the system.&lt;/p&gt;
&lt;p&gt;我们现在有了Vulkan的surface（链接到操作系统窗口），Vulkan的instance、device和系统中所有physical device的数据库。&lt;/p&gt;

&lt;p&gt;I hope you will find this tutorial useful.&lt;/p&gt;
&lt;p&gt;我希望你发现这个教程有用。&lt;/p&gt;
&lt;p&gt;The T-shirt that should go along with it says &quot;I've written tons of Vulkan code and all I got was this lousy window&quot;.&lt;/p&gt;
&lt;p&gt;T恤上写着“我已经写了成吨的Vulkan代码，只得到了这个糟糕的窗口”。&lt;/p&gt;
&lt;p&gt;Indeed, we have accomplished a lot but we didn't get any rendering in return.&lt;/p&gt;
&lt;p&gt;确实，我们做了很多，但是没有得到任何渲染结果。&lt;/p&gt;
&lt;p&gt;But don't despair.&lt;/p&gt;
&lt;p&gt;但是不要绝望。&lt;/p&gt;
&lt;p&gt;You now have a basic structure with a few of the core Vulkan objects.&lt;/p&gt;
&lt;p&gt;你现在有了一些基础结构，游龙Vulkan核心对象。&lt;/p&gt;
&lt;p&gt;On the next tutorials we will build on this further so stay tuned.&lt;/p&gt;
&lt;p&gt;下一篇教程我们将走得更远，所以敬请关注。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Jun 2019 20:00:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>CSharpGL(56)[译]Vulkan入门 本文是对（http://ogldev.atspace.co.uk/www/tutorial50/tutorial50.html）的翻译，作为学习Vulk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bitzhuwei/p/csharpgl-56-introduction-to-vulkan.html</dc:identifier>
</item>
<item>
<title>kill 命令在Java应用中使用注意事项 - 冬眠的山谷</title>
<link>http://www.cnblogs.com/lgjlife/p/10992395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgjlife/p/10992395.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;我们都知道，kill在linux系统中是用于杀死进程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
kill pid [..]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill命令可将指定的信号发送给相应的进程或工作。 kill命令默认使用信号为15，用于结束进程或工作。如果进程或工作忽略此信号，则可以使用信号9，强制杀死进程或作业.&lt;/p&gt;
&lt;p&gt;因此，如果确保将进程杀死，可以使用-9参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
kill -9 pid [..]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而使用-3参数，可以　打印进程的执行日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
kill -3 pid
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;在Java中的应用&lt;/h2&gt;
&lt;h3&gt;创建一个SpringBoot的web应用&lt;/h3&gt;
&lt;p&gt;启动类如下，添加了一个钩子函数，当进程关闭时，将会调用该钩子函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){

        SpringApplication.run(WebApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,args);

        Runtime.getRuntime().addShutdownHook(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;do ShutdownHook.......... &quot;&lt;span&gt;);
            }
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 使用maven打包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn &lt;span&gt;package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;测试kill -3　&lt;/h3&gt;
&lt;p&gt;启动应用&lt;/p&gt;
&lt;p&gt;这里注意，如果使用相对路径启动应用，则jps看到的进程名称为jar，使用绝对路径如下则显示完整的jar名称:web-1.0.jar。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
java -jar ~/aProject/web/target/web-&lt;span&gt;1.0&lt;/span&gt;.jar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看进程pid&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
lgj@lgj-Lenovo-G470:~/aProject/web/target$ jps | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; web
&lt;/span&gt;&lt;span&gt;21060&lt;/span&gt; web-&lt;span&gt;1.0&lt;/span&gt;.jar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用kill -3 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
lgj@lgj-Lenovo-G470:~/aProject/web/target$ &lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;3&lt;/span&gt; &lt;span&gt;21060&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到启动界面打印了Java应用的堆栈信息。打印的是收到-3信号时刻的线程信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1404294/201906/1404294-20190609011233190-1775023315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用以下方式启动应用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nohup java -jar ~/aProject/web/target/web-&lt;span&gt;1.0&lt;/span&gt;.jar   &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lgj@lgj-Lenovo-G470:~/aProject/web/target$ &lt;span&gt;ls&lt;/span&gt; -l |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; nohup.out 
&lt;/span&gt;-rw------- &lt;span&gt;1&lt;/span&gt; lgj lgj    &lt;span&gt;22811&lt;/span&gt; Jun  &lt;span&gt;9&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; nohup.out
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到启动所在的目录多了一个文件nohup.out。该文件记录了应用启动运行过程中的日志。&lt;/p&gt;
&lt;p&gt;nohup 命令　&amp;amp; ;&lt;/p&gt;
&lt;p&gt;表示以后台方式运行应用。&lt;/p&gt;
&lt;p&gt;此时使用kill -3。打印的线程信息可以到该nohup.out中查看。&lt;/p&gt;
&lt;h3&gt;测试kill 和kill -9&lt;/h3&gt;
&lt;p&gt;启动应用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
java -jar ~/aProject/web/target/web-&lt;span&gt;1.0&lt;/span&gt;.jar
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用kill pid杀死进程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lgj@lgj-Lenovo-G470:~/aProject/web/target$ jps | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; web
&lt;/span&gt;&lt;span&gt;21470&lt;/span&gt; web-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar
lgj@lgj&lt;/span&gt;-Lenovo-G470:~/aProject/web/target$ &lt;span&gt;kill&lt;/span&gt; &lt;span&gt;21470&lt;/span&gt;&lt;span&gt;
lgj@lgj&lt;/span&gt;-Lenovo-G470:~/aProject/web/target$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到输出日志中输出了钩子函数中所打印的&lt;/p&gt;
&lt;pre&gt;
do&lt;span&gt; ShutdownHook.......... &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;28.610&lt;/span&gt;  INFO &lt;span&gt;21470&lt;/span&gt; --- [           main] com.demo.web.WebApplication              : Started WebApplication &lt;span&gt;in&lt;/span&gt; &lt;span&gt;4.585&lt;/span&gt; seconds (JVM running &lt;span&gt;for&lt;/span&gt; &lt;span&gt;5.274&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; ShutdownHook.......... 
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;41.381&lt;/span&gt;  INFO &lt;span&gt;21470&lt;/span&gt; --- [       Thread-&lt;span&gt;3&lt;/span&gt;] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService &lt;span&gt;'&lt;/span&gt;&lt;span&gt;applicationTaskExecutor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用kill  -9  pid杀死进程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lgj@lgj-Lenovo-G470:~/aProject/web/target$ jps | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; web
&lt;/span&gt;&lt;span&gt;21568&lt;/span&gt; web-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar
lgj@lgj&lt;/span&gt;-Lenovo-G470:~/aProject/web/target$ &lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;9&lt;/span&gt; &lt;span&gt;21568&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后的日志并没有输出钩子函数中的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37.579&lt;/span&gt;  INFO &lt;span&gt;21568&lt;/span&gt; --- [           main] o.s.b.&lt;span&gt;w&lt;/span&gt;.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): &lt;span&gt;8452&lt;/span&gt; (http) with context path &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37.585&lt;/span&gt;  INFO &lt;span&gt;21568&lt;/span&gt; --- [           main] com.demo.web.WebApplication              : Started WebApplication &lt;span&gt;in&lt;/span&gt; &lt;span&gt;4.171&lt;/span&gt; seconds (JVM running &lt;span&gt;for&lt;/span&gt; &lt;span&gt;4.812&lt;/span&gt;&lt;span&gt;)
Killed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;在使用kill操作java应用时&lt;/p&gt;
&lt;p&gt;1.kill -3 pid可以打印当前进程的线程信息，&lt;strong&gt;但是不会关闭Java应用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.kill pid 也就是kill -15 pid ,将会&lt;strong&gt;调用钩子函数ShutdownHook&lt;/strong&gt;，一般ShutdownHook中会进行一些操作，比如保存数据，关闭连接等。&lt;/p&gt;
&lt;p&gt;3.kill  -9 pid.&lt;strong&gt;不会调用钩子函数ShutdownHook&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 17:25:00 +0000</pubDate>
<dc:creator>冬眠的山谷</dc:creator>
<og:description>前言 我们都知道，kill在linux系统中是用于杀死进程。 kill命令可将指定的信号发送给相应的进程或工作。 kill命令默认使用信号为15，用于结束进程或工作。如果进程或工作忽略此信号，则可以使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lgjlife/p/10992395.html</dc:identifier>
</item>
<item>
<title>.NET工程师的书单 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10962112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10962112.html</guid>
<description>&lt;p&gt;短暂的假期里抽空整理了一份书单，以个人的见解这些应该是值得.NET工程师至少去看一遍的书籍。但所罗列的仅包括国内目前已出版的国外书籍的英文版，并不包含中文翻译及相关领域的中文书籍。这里没有任何歧视之意，只是更推荐工程师具备熟练阅读英文文献的能力，尤其是.NET方向的工程师——考虑到国内的.NET生态圈，所以需要更广大的视野。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Essential C# 7.0&lt;br/&gt;C# 7.0本质论，作为历年来深受各层次开发人员欢迎的C#权威指南，本书讨论了从C# 3.0到7.0的最重要特性，包含了现代编程模式，可以帮助读者编写简洁、强大、健壮、安全和易于维护的C#代码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608221454564-746210972.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Effective C#: 50 Specific Ways to Improve Your C#&lt;br/&gt;Effective C#：编写高质量C#代码的50条有效方法——第3版，本书围绕一些关于C#和.NET的重要主题，包括C#语言元素、.NET资源管理、使用C#表达设计、创建二进制组件和使用框架等，讲述了最常见的50个问题的解决方案，为程序员提供了改善C#和.NET程序的方法。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608222132072-829028659.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Effective SQL: 61 Specific Ways to Write Better SQL&lt;br/&gt;Effective SQL：编写高质量SQL语句的61条有效方法，本书通过对案例问题的分析与解决方案的实现，向读者展示了如何通过SQL编写解决复杂问题，以及如何通过数据库设计简化数据管理。这是一本将SQL高级功能实践与SQL实际应用示例完美结合的、面向所有版本SQL方言（其中包括IBM DB2、Access、SQL Server、MySQL、Oracle、PostgreSQL）的编程指南。此外，SQL语法只是本书的一小部分内容，从数据库设计与优化，到分层数据与元数据管理，本书都有所涉及。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608222338414-278831629.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;NoSQL Distilled&lt;br/&gt;NoSQL精粹，本书由世界级软件开发大师和软件开发“教父”Martin Fowler与Jolt生产效率大奖图书作者Pramod J. Sadalage共同撰写。全方位比较了关系型数据库与NoSQL数据库的异同；分别以Riak、MongoDB、Cassandra和Neo4J为代表，详细讲解了键值数据库、文档数据库、列族数据库和图数据库这4大类NoSQL数据库的优劣势、用法和适用场合；深入探讨了实现NoSQL数据库系统的各种细节，以及与关系型数据库的混用。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608223016879-118390611.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Algorithm Design&lt;br/&gt;算法设计，这是一本关于算法设计和分析的经典教材。本书围绕算法设计进行组织，对每种算法技术选择了多个典型范例进行分析，把算法的理论跟实际存在的问题结合起来，具有很大的启发性。本书侧重算法设计思路，每章都从实际问题出发，经过深入具体的分析引出相应算法的设计思想，并对算法的正确性和复杂性进行合理的分析和论证。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608223552931-63218360.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Head First Design Patterns&lt;br/&gt;深入浅出设计模式，本书的编写运用许多最新的研究，包括神经生物学、认知科学以及学习理论，这使得其能够将这些设计模式深深地烙印在你的脑海中，不容易被遗忘。你将会更擅长于解决软件设计中的问题，并能够和你的团队成员用模式的语言来更好地沟通。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608223909014-1095958090.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Implementing Domain-Driven Design&lt;br/&gt;实现领域驱动设计，本书分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的优秀实践、设计准则和对一些问题的折中性讨论。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608224057444-953233884.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Clean Architecture:A Craftsman's Guide to Software Structure and Design&lt;br/&gt;Clean Architecture：软件架构与设计匠艺，通过合理运用软件架构的通用法则，可以显著提升开发者在所有软件系统全生命周期内的生产力。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608224412597-1496814939.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Designing Data-Intensive Applications&lt;br/&gt;设计数据密集型应用，书中包含以下内容：深入分析你已经在使用的系统，并学习如何更高效地使用和运维这些系统；通过识别不同工具的优缺点，作出更明智的决策；了解一致性、可伸缩性、容错性和复杂度之间的权衡；理解分布式系统研究，这些研究是现代数据库构建的基石；走到一些主流在线服务的幕后，学习它们的架构。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608224913129-786706155.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Refactoring: Improving the Design of Existing Code&lt;br/&gt;重构：改善既有代码的设计，软件开发的不朽经典；生动阐述重构原理和具体做法；普通程序员进阶到编程高手必须修炼的秘笈。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608225454224-1829620333.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation&lt;br/&gt;持续交付：发布可靠软件的系统方法，本书讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608225646791-541866458.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Git for Teams&lt;br/&gt;用于团队协作的Git，本书是一本软件团队协作指南，采用以人为本的方式讲解版本控制，强调如何利用Git促进团队协作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608225802484-1148513907.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;The Mythical Man-Month: Essays on Software Engineering&lt;br/&gt;人月神话，本书内容源于作者Brooks在IBM公司任System/360计算机系列以及其庞大的软件系统OS/360项目经理时的实践经验。在本书中，Brooks为人们管理复杂项目提供了最具洞察力的见解，既有很多发人深省的观点，又有大量软件工程的实践，为每个复杂项目的管理者给出了自己的真知灼见。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608230023183-1743332200.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Peopleware&lt;br/&gt;人件，在软件管理领域，很少有著作能够与本书媲美。作为经久不衰的畅销书，本书深刻地洞察到软件开发的最大问题不在于技术，而在于人。人的因素并不容易解决，一旦解决了，你将更有可能获得成功。本书是软件管理领域的传奇经典，被誉为“对美国软件业影响最大的一本书”。全书从管理人力资源、创建健康的办公环境、雇用并留用正确的人、高效团队形成、改造企业文化和快乐工作等多个角度阐释了如何思考和管理软件开发的最大问题——人（而不是技术），以得到高效的项目和团队。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201906/991496-20190608230249398-1914667243.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 08 Jun 2019 15:11:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>短暂的假期里抽空整理了一份书单，以个人的见解这些应该是值得.NET工程师至少去看一遍的书籍。但所罗列的仅包括国内目前已出版的国外书籍的英文版，并不包含中文翻译及相关领域的中文书籍。这里没有任何歧视之意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/10962112.html</dc:identifier>
</item>
<item>
<title>重构代码，你真的准备好了吗 - ChaosYang1987</title>
<link>http://www.cnblogs.com/chaosyang/p/are-you-ready-for-refactoring.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaosyang/p/are-you-ready-for-refactoring.html</guid>
<description>&lt;p&gt;我相信每个接受过老项目的程序员可能都吐槽过“前人的代码都是屎”。一个已经有些年头的项目，几乎肯定可以看到——到处拷贝来拷贝去的代码，随处可见的拼写错误，头重脚轻的函数……再看一看当年的提交者，可能是公司里的元老，甚至是大boss，不禁心里暗暗的鄙视，怀疑是否自己进错了公司。&lt;/p&gt;
&lt;p&gt;而你被分配到接管这坨“屎”一般的代码，并且要在上面添加更多的功能，每次的增删代码都让你如履薄冰，每次遇到原来代码里的bug都让你的发际线再次上扬。&lt;/p&gt;
&lt;p&gt;终于有一天，你忍不住了，脑子里面满满都是一个念头——我要重写这个代码。然后你真的这么做了，花了整整一个晚上/天/星期的时间，把代码改成了你心中满意的模样。然后代码上线了：&lt;/p&gt;
&lt;p&gt;Happy Ending：重构的代码获得了同事的交口称赞，大家纷纷夸你代码比以前好写多了。&lt;/p&gt;
&lt;p&gt;Normal Ending：过了几个月，你发现重构的代码又不行了，加一个新功能费死劲了，于是你又在筹划下一次重构。&lt;/p&gt;
&lt;p&gt;Bad Ending：重构的代码上线后，bug不断，老板夺命连环call让你连夜修补，你发现老代码这么写不是没有道理的。&lt;/p&gt;
&lt;p&gt;这样的故事每个经手过老项目的程序员可能都多少有类似的体会，在我的职业生涯中也经历了屈指可数的几次重构，然而每一次的重构经历几乎都踩到了各种各样的坑。&lt;/p&gt;
&lt;h2 id=&quot;你真的需要重构吗&quot;&gt;你真的需要重构吗&lt;/h2&gt;
&lt;p&gt;在重构项目之前，一定要再三的问自己（和自己的组员）这个问题：我们真的需要重构吗？&lt;/p&gt;
&lt;p&gt;重构项目，在只是重构的前提下，对于公司的收益来说是——0，因为你的产品的用户，他们并不会为你的重构行为来买账，对于他们来说，你的源代码写的好看与否根本无所谓，对他们重要的是产品本身有没有改进。对于公司来说，重构行为不但没有带来任何利益，反而消耗了程序员资源，对于公司来说是损失。&lt;/p&gt;
&lt;p&gt;一个互联网产品的生命周期可能就只有短短的几年，放长一点看，现在写的代码可能过几年就会毫无用处，在这样的前提下，现有项目的重构，一定是建立在项目本身还十分有前景的基础上，这个项目将来还有多少潜力，值不值得去重构？如果这个产品本身并没有什么可做的了，那么是否还值得花时间去重构它？&lt;/p&gt;
&lt;h2 id=&quot;为什么需要进行项目重构&quot;&gt;为什么需要进行项目重构&lt;/h2&gt;
&lt;p&gt;每个项目重构的理由各不相同，但个人总结来主要是以下两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原来的项目漏洞太多，或者稳定性太差，当前的框架很难彻底根治。&lt;/li&gt;
&lt;li&gt;新的项目需求，原有的程序框架已经无法满足。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假设你的项目没有很多bug，稳定性也很好，或者暂时没有在现有框架下很难实现的新的需求，那么不建议进行项目重构。&lt;/p&gt;
&lt;p&gt;我在上一家公司的SEM组工作时，经历的第一次重构，是将后台的竞价计算出的竞价的结果，由数据库的表（Table）存储改成了推送到队列系统（RabbitMQ）。后台竞价程序算出的竞价结果需要由另一个上传程序上传到Adwords等竞价平台，我们在过去的做法是在数据库建立了一张表，竞价程序将算出的新竞价存储在其中，上传程序则定期的去查询表中的新加入的记录，将其成批上传，并在上传后删除。那么为何要进行这次重构？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随着公司的投放的广告词增加，单一上传程序实例很难在短时间内上传所有的竞价，但是如果运行多个上传程序的实例，则会出现多个示例同时查询新加入竞价并上传，删除同一记录造成数据库死锁。（&lt;strong&gt;1. 原来的项目漏洞太多，或者稳定性太差，当前的框架很难彻底根治。&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;新业务需求需要计算另一种格式的竞价，如果继续使用数据库表来存储，则要么需要对已有的表进行字段扩容/修改，要么建立新的表单。但是当时已经预见将来可能会支持更多格式的竞价，于是数据库表的存储方式将不再灵活。（&lt;strong&gt;2. 新的项目需求，原有的程序框架已经无法满足。&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;重构项目&quot;&gt;重构项目&lt;/h2&gt;
&lt;p&gt;经过再三衡量，我们终于还是决定重构项目，恭喜你，你将有一段踩坑之旅。&lt;/p&gt;
&lt;h3 id=&quot;重构项目之前&quot;&gt;重构项目之前&lt;/h3&gt;
&lt;p&gt;重构项目的第一步是要了解项目。&lt;/p&gt;
&lt;p&gt;重构时最容易发生的一类错误是没有能够完全的将原来的功能忠实的重现出来。很多开发者并不是手头的项目的原作者，并且项目也经过了很长时间的迭代，当代码越滚越大的时候，几乎没有人（包括原作者和产品经理）能够完全了解项目到底包含了哪些内容。当你看到重构后的功能和原来一模一样，并且测试人员也没有测出问题的时候，说不定哪个猴年马月添加进来的特殊功能，悄悄的被你干掉了。等到上线后，这个特殊功能的用户突然发现功能没了，于是过来投诉。&lt;/p&gt;
&lt;h3 id=&quot;重构ing-测试&quot;&gt;重构ING —— 测试&lt;/h3&gt;
&lt;p&gt;如果说什么是重构中最重要的第一步， 我认为是测试。&lt;/p&gt;
&lt;p&gt;如果原来的代码没有单元测试、集成测试，有条件的话一定要补充上。为什么测试如此重要？打一个比好，重构就好像对着一把老钥匙来配新钥匙，而测试代码则是老钥匙的模子，我们做出来的新钥匙要能够和这个模子全对上。这个模子越详细，则新钥匙可以正常开锁的概率越大。&lt;/p&gt;
&lt;p&gt;回想我在过去的重构中出现的一次重大失误，便是在重构过程中，有一个原来的单元测试出现了错误，原本的断言是结果为NULL，但是我的结果是0，当时觉得可能两种结果都可以，于是错误的选择了将单元测试的结果“改正”，结果在代码上线后，0的结果造成了程序输出和之前相比大不相同。总结一下：1. 如果有集成测试，则这样的错误可以在上线之前发现。2. 应该相信原来的单元测试集，而不应该“想当然”的去认为自己重构的逻辑正确。&lt;/p&gt;
&lt;h3 id=&quot;重构ing-分支&quot;&gt;重构ING —— 分支&lt;/h3&gt;
&lt;p&gt;代码重构的过程中，一定不建议先删除代码全部重写。比较推荐的是先拷贝出一个新的函数/文件/文件夹，然后写全新的代码。为什么要这么做？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在写新代码的时候可以一边写一边参照原来的代码。&lt;/li&gt;
&lt;li&gt;新代码的代码审查（Code Review）会比较干净。&lt;/li&gt;
&lt;li&gt;项目管理工具（Git，SVN）的历史比较干净。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回到我上面说的由数据库的表（Table）存储改成了推送到队列系统（RabbitMQ）的重构，当时我的做法是，在竞价程序端，重新实现了输出的函数，使得竞价结果可以改为推送到队列系统。而在上传程序端，则重新实现了一个新的程序，只从消息队列中消费推送的消息，然后上传到Adwords等广告平台。原有的旧上传程序则没有改动丝毫。&lt;/p&gt;
&lt;h3 id=&quot;重构项目的上线-开关&quot;&gt;重构项目的上线 —— 开关&lt;/h3&gt;
&lt;p&gt;稍微大一些的重构，我会比较推荐使用程序开关，使用一些控制参数来控制逻辑入口是用老代码还是新代码，这样在线上出现了问题，可以及时的调整控制参数，迅速的回滚到老的逻辑。&lt;/p&gt;
&lt;p&gt;如果程序运行的结果本身就是不确定的，不容易看出重构的错误，甚至推荐在重构的入口处设置A/B测试，这样在线上让一部分流量先走重构后的逻辑，同时将新/老逻辑的流量标记成不同的测试bucket，可以在数据测量平台上看到新老代码的表现如何。如果新代码的表现合理，则可以不断加大新代码的流量覆盖，直到100%。&lt;/p&gt;
&lt;p&gt;在我上面提到的重构中，我选择在竞价程序计算段创建了一个新的A/B测试，对照组采用将竞价结果写到数据库的方法，实验组则将竞价结果发送到消息队列。同时在生产环境中，旧的和新的上传程序都在同时运行。在刚上线的时候，我选择将1%的竞价结果推送到消息队列中，然后观察新的上传程序能否将消息队列中的消息消耗掉。同时，在产品的监视页面，对对照组和实验组的竞价结果进行分析，确认两个组的竞价结果并没有明显的差别。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结一下个人的重构心得，重构前是否必要，重构中做好测试、分支、开关。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 13:45:00 +0000</pubDate>
<dc:creator>ChaosYang1987</dc:creator>
<og:description>我相信每个接受过老项目的程序员可能都吐槽过“前人的代码都是屎”。一个已经有些年头的项目，几乎肯定可以看到——到处拷贝来拷贝去的代码，随处可见的拼写错误，头重脚轻的函数……再看一看当年的提交者，可能是公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaosyang/p/are-you-ready-for-refactoring.html</dc:identifier>
</item>
<item>
<title>RabbitMQ 从入门到精通（二） - 丁可乐</title>
<link>http://www.cnblogs.com/dwlovelife/p/10991371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dwlovelife/p/10991371.html</guid>
<description>&lt;h2 id=&quot;消息如何保障百分之百的投递成功&quot;&gt;1. 消息如何保障百分之百的投递成功?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是生产端的可靠性投递？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保障消息的成功发出&lt;/li&gt;
&lt;li&gt;保障MQ节点的成功接收&lt;/li&gt;
&lt;li&gt;发送端收到MQ节点（Broker）确认应答&lt;/li&gt;
&lt;li&gt;完善的进行消息补偿机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果想保障消息百分百投递成功，只做到前三步不一定能够保障。有些时候或者说有些极端情况，比如生产端在投递消息时可能就失败了，或者说生产端投递了消息，MQ也收到了，MQ在返回确认应答时，由于网络闪断导致生产端没有收到应答，此时这条消息就不知道投递成功了还是失败了，所以针对这些情况我们需要做一些补偿机制。&lt;/p&gt;

&lt;h3 id=&quot;方案一消息落库对消息状态进行打标&quot;&gt;1.1 方案一：消息落库，对消息状态进行打标&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608184922836-1133279571.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;进行数据的入库，比如我们要发送一条订单消息，首先得把业务数据也就是订单信息存库，然后生成一条消息，把消息也进行入库，这条消息应该包含消息状态属性 Create_Date（创建时间），并设置初始标志 比如0，表示消息创建成功，正在发送中&lt;/li&gt;
&lt;li&gt;首先要保证第一步消息都存储成功了，没有出现任何异常情况，然后生产端再进行消息发送。如果失败了就进行快速失败机制&lt;/li&gt;
&lt;li&gt;MQ把消息收到的结果应答&lt;code&gt;(confirm)&lt;/code&gt;给生产端&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;生产端有一个&lt;code&gt;Confirm Listener&lt;/code&gt;，去异步的监听&lt;code&gt;Broker&lt;/code&gt;回送的响应，从而判断消息是否投递成功，如果成功，去数据库查询该消息，并将消息状态更新为1，表示消息投递成功&lt;br/&gt; &lt;br/&gt;&lt;strong&gt;假设第二步OK了，在第三步回送响应时，网络突然出现了闪断，导致生产端的Listener就永远收不到这条消息的confirm应答了，也就是说这条消息的状态就一直为0了&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;此时我们需要设置一个规则，比如说消息在入库时候设置一个临界值timeout，5分钟之后如果还是0的状态那就需要把消息抽取出来。这里我们使用的是分布式定时任务，去定时抓取DB中距离消息创建时间超过5分钟的且状态为0的消息。&lt;/li&gt;
&lt;li&gt;把抓取出来的消息进行重新投递&lt;code&gt;(Retry Send)&lt;/code&gt;，也就是从第二步开始继续往下走&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当然有些消息可能就是由于一些实际的问题无法路由到Broker，比如routingKey设置不对，对应的队列被误删除了，那么这种消息即使重试多次也仍然无法投递成功，所以需要对重试次数做限制，比如限制3次，如果投递次数大于三次，那么就将消息状态更新为2，表示这个消息最终投递失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这种情况如何去做补偿呢，可以有一个补偿系统去查询这些最终失败的消息，然后给出失败的原因，当然这些可能都需要人工去操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种可靠性投递，在高并发的场景下是否适合？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于第一种方案，我们需要做两次数据库的持久化操作，在高并发场景下显然数据库存在着性能瓶颈。其实在我们的核心链路中只需要对业务进行入库就可以了，消息就没必要先入库了，我们可以做消息的延迟投递，做二次确认，回调检查。&lt;/p&gt;
&lt;p&gt;当然这种方案不一定能保障百分百投递成功，但是基本上可以保障大概99.9%的消息是OK的，有些特别极端的情况只能是人工去做补偿了，或者使用定时任务去做都可以。&lt;/p&gt;

&lt;h3 id=&quot;方案二消息的延迟投递做二次确认回调检查&quot;&gt;1.2 方案二：消息的延迟投递，做二次确认，回调检查&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608185015804-1188705041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Upstream Service&lt;/code&gt;上游服务也就是生产端，&lt;code&gt;Downstream service&lt;/code&gt;下游服务也就是消费端，&lt;code&gt;Callback service&lt;/code&gt;就是回调服务。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;先将业务消息进行入库，然后生产端将消息发送出去&lt;/li&gt;
&lt;li&gt;在发送消息之后，紧接着生产端再次发送一条消息&lt;code&gt;(Second Send Delay Check)&lt;/code&gt;，即延迟消息投递检查，这里需要设置一个延迟时间，比如5分钟之后进行投递。&lt;/li&gt;
&lt;li&gt;消费端去监听指定队列，将收到的消息进行处理。&lt;/li&gt;
&lt;li&gt;处理完成之后，发送一个&lt;code&gt;confirm&lt;/code&gt;消息，也就是回送响应，但是这里响应不是正常的ACK，而是重新生成一条消息，投递到MQ中。&lt;/li&gt;
&lt;li&gt;上面的&lt;code&gt;Callback service&lt;/code&gt;是一个单独的服务，其实它扮演了第一种方案的存储消息的DB角色，它通过MQ去监听下游服务发送的&lt;code&gt;confirm&lt;/code&gt;消息，如果&lt;code&gt;Callback service&lt;/code&gt;收到&lt;code&gt;confirm&lt;/code&gt;消息，那么就对消息做持久化存储，即将消息持久化到DB中。&lt;/li&gt;
&lt;li&gt;5分钟之后延迟消息发送到MQ了，然后&lt;code&gt;Callback service&lt;/code&gt;还是去监听延迟消息所对应的队列，收到Check消息后去检查DB中是否存在消息，如果存在，则不需要做任何处理，如果不存在或者消费失败了，那么&lt;code&gt;Callback service&lt;/code&gt;就需要主动发起RPC通信给上游服务，告诉它延迟检查的这条消息我没有找到，你需要重新发送，生产端收到信息后就会重新查询业务消息然后将消息发送出去。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这么做的目的是少做了一次DB的存储，在高并发场景下，最关心的不是消息100%投递成功，而是一定要保证性能，保证能抗得住这么大的并发量。所以能节省数据库的操作就尽量节省，可以异步的进行补偿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其实在主流程里面是没有这个Callback service的，它属于一个补偿的服务，整个核心链路就是生产端入库业务消息，发送消息到MQ，消费端监听队列，消费消息。其他的步骤都是一个补偿机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种方案也是互联网大厂更为经典和主流的解决方案。但是若对性能要求不是那么高，第一种方案要更简单&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;幂等性&quot;&gt;2. 幂等性&lt;/h2&gt;
&lt;h3 id=&quot;幂等性是什么&quot;&gt;2.1 幂等性是什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单来说就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以借鉴数据库的乐观锁机制来举个例子：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先为表添加一个版本字段version&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在执行更新操作前呢，会先去数据库查询这个version&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后执行更新语句，以version作为条件，例如：&lt;/p&gt;
&lt;p&gt;UPDATE T_REPS SET COUNT = COUNT -1，VERSION = VERSION + 1 WHERE VERSION = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果执行更新时有其他人先更新了这张表的数据，那么这个条件就不生效了，也就不会执行操作了，通过这种乐观锁的机制来保障幂等性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;消息端幂等性保障&quot;&gt;2.2 消息端幂等性保障&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;重复消费问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当消费者消费完消息时，在给生产端返回ack时由于网络中断，导致生产端未收到确认信息，该条消息会重新发送并被消费者消费，但实际上该消费者已成功消费了该条消息，这就是重复消费问题。&lt;/p&gt;

&lt;h4 id=&quot;唯一id指纹码机制&quot;&gt;2.2.1 唯一ID+指纹码机制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;唯一ID：&lt;/strong&gt;业务表唯一的主键，如商品ID&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指纹码：&lt;/strong&gt;为了区别每次正常操作的码，每次操作时生成指纹码；可以用时间戳+业务编号或者标志位（具体视业务场景而定）&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;唯一ID+指纹码机制，利用数据库主键去重&lt;/li&gt;
&lt;li&gt;SELECT COUNT(1) FROM T_ORDER WHERE ID = 唯一ID and IS_CONSUM= 指纹码&lt;/li&gt;
&lt;li&gt;好处：实现简单&lt;/li&gt;
&lt;li&gt;坏处：高并发下有数据库写入的性能瓶颈&lt;/li&gt;
&lt;li&gt;解决方案：根据ID进行分库分表算法路由&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个思路就是首先我们需要根据消息生成一个全局唯一的ID，然后还需要加上一个指纹码。这个指纹码它并不一定是系统去生成的，而是一些外部的规则或者内部的业务规则去拼接，它的目的就是为了保障这次操作是绝对唯一的。&lt;/p&gt;
&lt;p&gt;将ID + 指纹码拼接好的值作为数据库主键，就可以进行去重了。即在消费消息前呢，先去数据库查询这条消息的指纹码标识是否存在，没有就执行insert操作，如果有就代表已经被消费了，就不需要管了。&lt;/p&gt;

&lt;h4 id=&quot;利用redis的原子性去实现&quot;&gt;2.2.2 利用Redis的原子性去实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;这里只提用Redis的原子性去解决MQ幂等性重复消费的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：MQ的幂等性问题 根本在于的是生产端未正常接收ACK，可能是网络抖动、网络中断导致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我的方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MQ消费端在消费开始时 将 ID放入到Redis的BitMap中，MQ生产端每次生产数据时，从Redis的BitMap对应位置若不能取出ID，则生产消息发送，否则不进行消息发送。&lt;/p&gt;
&lt;p&gt;但是有人可能会说，万一消费端，生产端Redis命令执行失败了怎么办，虽然又出现重复消费又出现Redis非正常执行命令的可能性极低，但是万一呢？&lt;/p&gt;
&lt;p&gt;OK，我们可以在Redis命令执行失败时，将消息落库，每日用定时器，对这种极特殊的消息进行处理。&lt;/p&gt;

&lt;h2 id=&quot;confirm机制&quot;&gt;3. Confirm机制&lt;/h2&gt;
&lt;h3 id=&quot;如何理解&quot;&gt;3.1 如何理解？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答&lt;/li&gt;
&lt;li&gt;生产者进行接收应答，用来确定这条消息是否正常的发送到Broker，这种方式也是消息的可靠性投递&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;的核心保障&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确认机制流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生产端发送消息到Broker，然后Broker接收到了消息后，进行回送响应，生产端有一个&lt;code&gt;Confirm Listener&lt;/code&gt;，去监听应答，当然这个操作是异步进行的，生产端将消息发送出去就可以不用管了，让内部监听器去监听Broker给我们的响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608185036667-894383591.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;怎么实现&quot;&gt;3.2 怎么实现？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第一步，在channel上开启确认模式：&lt;code&gt;channel.confirmSelect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步，在channel上添加监听：&lt;code&gt;addConfirmListener&lt;/code&gt;，监听成功和失败的返回结果，根据具体的结果对消息进行重新发送、或记录日志等后续处理！&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer {
    public static void main(String[] args) throws Exception {
        
        //创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.244.11&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        connectionFactory.setHandshakeTimeout(20000);

        
        //获取Connection
        Connection connection = connectionFactory.newConnection();
        
        //通过connection创建一个新的Channel
        Channel channel = connection.createChannel();
        
        //指定我们的消息投递模式
        channel.confirmSelect();
        
        String exchangeName = &quot;test_confirm_exchange&quot;;
        String routingkey = &quot;confirm.save&quot;;
        
        //发送一条信息
        String msg = &quot;Hello RabbitMQ Send confirm message!&quot;;
        channel.basicPublish(exchangeName, routingkey, null, msg.getBytes());
        
        //添加一个确认监听
        channel.addConfirmListener(new ConfirmListener() {
            
            @Override
            public void handleNack(long deliveryTag, boolean multiple)
                    throws IOException {
                System.out.println(&quot;-------no ack!---------&quot;);
            }
            
            @Override
            public void handleAck(long deliveryTag, boolean multiple)
                    throws IOException {
                System.out.println(&quot;--------ack!----------&quot;);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer {
    public static void main(String[] args) throws Exception{
        //创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.244.11&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        connectionFactory.setHandshakeTimeout(20000);

        
        //获取Connection
        Connection connection = connectionFactory.newConnection();
        
        //通过connection创建一个新的Channel
        Channel channel = connection.createChannel();
        
        String exchangeName = &quot;test_confirm_exchange&quot;;
        String routingkey = &quot;confirm.#&quot;;
        String queueName = &quot;test_confirm_queue&quot;; 
        
        //声明交换机和队列 然后进行绑定和 设置 最后制定路由key
        channel.exchangeDeclare(exchangeName, &quot;topic&quot;,true);
        channel.queueDeclare(queueName, true, false, false, null);
        
        channel.queueBind(queueName, exchangeName, routingkey);
        
        //创建消费者
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
        channel.basicConsume(queueName, true,queueingConsumer); 
        
        while(true){
            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.out.println(&quot;消费端：&quot; + msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先启动消费端，访问管控台：http://ip:15672，检查Exchange和Queue是否设置OK，然后启动生产端，消息被消费端消费，生产端也成功监听到了ACK响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608185059920-1425363865.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;return机制&quot;&gt;4. Return机制&lt;/h2&gt;
&lt;h3 id=&quot;如何理解-1&quot;&gt;4.1 如何理解？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Return Listener&lt;/code&gt; 用于处理一些不可路由的消息！&lt;/li&gt;
&lt;li&gt;我们的消息生产者，通过指定一个Exchange 和Routingkey，把消息送达到某一个队列中去， 然后我们的消费者监听队列，进行消费处理操作！&lt;/li&gt;
&lt;li&gt;但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候如果我们需要监听这种不可达的消息，就要使用&lt;code&gt;Return Listener&lt;/code&gt;!&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608185120436-1860730331.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何实现&quot;&gt;4.2 如何实现?&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;添加return监听：&lt;code&gt;addReturnListener&lt;/code&gt;，生产端去监听这些不可达的消息，做一些后续处理，比如说，记录下消息日志，或者及时去跟踪记录，有可能重新设置一下就好了&lt;/li&gt;
&lt;li&gt;发送消息时，设置&lt;code&gt;Mandatory&lt;/code&gt;：如果为true，则监听器会接收到路由不可达的消息，然后进行后续处理，如果为false，那么broker端自动删除该消息！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReturnProducer {
     public static void main(String[] args) throws Exception {
            //1 创建ConnectionFactory
            ConnectionFactory connectionFactory = new ConnectionFactory();
            connectionFactory.setHost(&quot;192.168.244.11&quot;);
            connectionFactory.setPort(5672);
            connectionFactory.setVirtualHost(&quot;/&quot;);
            connectionFactory.setHandshakeTimeout(20000);
            //2 获取Connection
            Connection connection = connectionFactory.newConnection();
            //3 通过Connection创建一个新的Channel
            Channel channel = connection.createChannel();
            
            String exchange = &quot;test_return_exchange&quot;;
            //String routingKey = &quot;return.save&quot;;
            String routingKeyError = &quot;abc.save&quot;;
            
            String msg = &quot;Hello RabbitMQ Return Message&quot;;
            //添加return监听
            channel.addReturnListener(new ReturnListener() {
                @Override
                public void handleReturn(int replyCode, String replyText, String exchange,
                        String routingKey, BasicProperties properties, byte[] body) throws IOException {
                    //replyCode：响应码    replyText：响应信息
                    System.err.println(&quot;---------handle  return----------&quot;);
                    System.err.println(&quot;replyCode: &quot; + replyCode);
                    System.err.println(&quot;replyText: &quot; + replyText);
                    System.err.println(&quot;exchange: &quot; + exchange);
                    System.err.println(&quot;routingKey: &quot; + routingKey);
                    //System.err.println(&quot;properties: &quot; + properties);
                    System.err.println(&quot;body: &quot; + new String(body));
                }

                
            });
            //5 发送一条消息，第三个参数mandatory：必须设置为true
            channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());
        }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReturnConsumer {
    
    public static void main(String[] args) throws Exception {
        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.244.11&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        connectionFactory.setHandshakeTimeout(20000);
        //2 获取Connection
        Connection connection = connectionFactory.newConnection();
        //3 通过Connection创建一个新的Channel
        Channel channel = connection.createChannel();
        
        String exchangeName = &quot;test_return_exchange&quot;;
        String routingKey = &quot;return.#&quot;;
        String queueName = &quot;test_return_queue&quot;;
        //4 声明交换机和队列，然后进行绑定设置路由Key
        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);
        
        //5 创建消费者 
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
        channel.basicConsume(queueName, true, queueingConsumer);
        
        while(true){
            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.err.println(&quot;消费者: &quot; + msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先启动消费端，访问管控台：http://ip:15672，检查Exchange和Queue是否设置OK，然后启动生产端。&lt;br/&gt;由于生产端设置的是一个错误的路由key，所以消费端没有任何打印，而生产端打印了如下内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201906/1348730-20190608185138680-1786836493.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将 &lt;code&gt;Mandatory&lt;/code&gt; 属性设置为false，对于不可达的消息会被Broker直接删除，那么生产端就不会进行任何打印了。如果我们的路由key设置为正确的，那么消费端能够正确消费，生产端也不会进行任何打印。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 10:56:00 +0000</pubDate>
<dc:creator>丁可乐</dc:creator>
<og:description>[TOC] 1. 消息如何保障百分之百的投递成功? 什么是生产端的可靠性投递？ 保障消息的成功发出 保障MQ节点的成功接收 发送端收到MQ节点（Broker）确认应答 完善的进行消息补偿机制 如果想保</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dwlovelife/p/10991371.html</dc:identifier>
</item>
<item>
<title>理解serverless无服务架构原理(一) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10991363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10991363.html</guid>
<description>&lt;p&gt;一：什么是serverless无服务？&lt;/p&gt;
&lt;p&gt;serverless中文的含义是 &quot;无服务器&quot;，但是它真正的含义是开发者再也不用过多考虑服务器的问题，但是并不代表完全去除服务器，而是我们依靠第三方资源服务器后端，比如使用 Amazon Web Services(AWS) Lambda. 计算服务来执行代码，那么Serverless架构分为 Backend as a Service(BaaS) 和 Functions as a Service(FaaS) 两种技术，Serverless 它是由开发者实现的服务端逻辑运行在无状态的计算容器中，它是由事件触发，完全被第三方管理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是BaaS?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Baas 的英文翻译成中文的含义：后端即服务，它的应用架构由大量第三方云服务器和API组成的，使应用中关于服务器的逻辑和状态都由服务提供方来管理的。比如我们的典型的单页应用SPA和移动APP富客户端应用，前后端交互主要是以&lt;a href=&quot;https://www.leancloud.cn/docs/rest_api.html&quot; target=&quot;_blank&quot;&gt;RestAPI&lt;/a&gt;调用为主。只需要调用服务提供方的API即可完成相应的功能，比如常见的身份验证，云端数据/文件存储，消息推送，应用数据分析等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是FaaS?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FaaS可以被叫做：函数即服务。开发者可以直接将服务业务逻辑代码部署，运行在第三方提供的无状态计算容器中，开发者只需要编写业务代码即可，无需关注服务器，并且代码的执行它是由事件触发的。其中AWS Lambda是目前最佳的FaaS实现之一。&lt;/p&gt;
&lt;p&gt;Serverless的应用架构是将BaaS和FaaS组合在一起的应用，用户只需要关注应用的业务逻辑代码，编写函数为粒度将其运行在FaaS平台上，并且和BaaS第三方服务整合在一起，最后就搭建了一个完整的系统。整个系统过程中完全无需关注服务器。&lt;/p&gt;

&lt;p&gt;二：与传统模式架构区别？&lt;/p&gt;
&lt;p&gt;传统的架构模式是使用C/S架构的，在典型的web应用程序中，服务器接收前端的HTTP请求处理，在保存或查询数据库之前，数据可能会经过多个应用层，最终后端会返回一个响应。比如它可以是JSON形式或其他格式等。然后他会将响应返回给客户端，比如如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190608184327368-118195710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统开发模式中，开发流程：设计师设计页面 -&amp;gt; 服务端开发 和 前端分别开发，服务器开发完成后，-&amp;gt; 服务部署 -&amp;gt;服务部署完成后，就是前后端联调 -&amp;gt; 前后端联调 -&amp;gt; 前后端联调完成后就是测试了，-&amp;gt; 测试， 测试完成需要上线，因此 -&amp;gt; 上线，上线完成后，需要运维维护，因此 -&amp;gt; 运维。在传统开发模式中，开发一个应用程序，从开始到上线需要不同的角色来做不同的事情，沟通成本非常大，并且运维过程中需要考虑到 服务器的负载均衡、事务、集群、缓存、&lt;br/&gt;消息传递和数据冗余等等这些事情，在目前传统模式中存在如上问题。可以使用如下示意图来看下如上流程。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190608184404847-1916724448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Serverless架构中，应用业务逻辑是基于FaaS架构形成多个相互独立的功能组件的。并且以API服务的形式向外提供服务，在FaaS中，后端的应用被拆分成为一个个函数，我们只需要编写完成函数后部署到serverless服务即可。后续我们也不用关心任何服务器的操作。那么整个流程就只需要我们一个前端工程师的角色来完成所有的开发工作，那么沟通成本降低了。因此我们可以使用如下示意图来表示项目流程，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190608184430820-1050082110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前端工程师是居于serverless去写后端服务的，典型的就是居于 AWS Lambda 中编写代码，AWS中支持不同的语言。&lt;br/&gt;Lambda计算服务它能够以大规模并行的方式执行代码来响应事件。通过使用Lambda以及使用各种功能强大的API和Web服务，开发者可以快速的构建松耦合，可扩展性及高效的架构体系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;Lambda是什么？它是一种计算服务，它在AWS基础上执行用javascript、node.js、Python、C#或java编写的代码，源代码将被打包并部署到孤立的容器中，该容器有单独分配的内存、磁盘空间和处理器。代码、配置和依赖项的组合被称作为Lambda函数。&lt;/p&gt;

&lt;p&gt;三：serverless优缺点？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点有如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 降低创业公司启动成本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一家创业公司的时候，在开发web的时候，我们需要版本管理服务器、持续集成服务器、测试服务器、应用版本管理仓库等作为基础服务。&lt;br/&gt;线上运行的时候，为了应对大量的请求，我们还需要一个好的数据库服务器。当我们应用面向普通的用户时，我们需要：&lt;/p&gt;
&lt;p&gt;1.1 邮件服务，用于发送提醒，注册等服务。&lt;br/&gt;1.2 短信服务，用于注册，登录等用户授权操作。&lt;/p&gt;
&lt;p&gt;如上一些对于大公司来讲，都有现成的基础设施。可是对于创业公司来讲。这都需要一些启动成本。但是如果我们使用serverless就可以降低这些成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 减少运营成本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于创业公司来讲，他们没有基础设施，没有财力，也可能没有能力去建设基础设施，采用云服务是最好的选择，可以为他们节省大量的资金。&lt;br/&gt;他们只要将精力放在对用户价值的产品之上即可，他们不需要自己去搭建服务器，因此会有更多的时间去开发业务功能。而采用函数计算的serverless与云服务器最大的区别是：云服务器需要一直运行，比如说月费或年费要多少钱租，但是serverless是按需计费的，如果有请求到来的时候，才运行函数，否则的话，是不需要钱的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 降低开发成本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;serverless会提供一系列的配套服务，比如 我们只需要在配置文件上写下数据库的表名，那么数据就会存储到对应的数据库里面，并且会提供一系列的函数计算模板，我们只需要写好我们的配置即可，那么这一系列的东西都可以自动，高效的完成任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 实现快速上线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些传统项目来讲，我们在本地开发需要部署环境，到开发环境或测试环境，我们还是需要部署环境。但是serverless可以在部署上有优势，并且很轻松的实现上线。因为serverless内部相当于有 内建自动化部署功能，并且在该里面都是由供应商提供的功能，每次我们写完业务代码后，我们只需要运行下即可，在AWS Lambda 函数计算里面，函数一般在上传后几秒钟内，就能做好调用准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 系统安全性更高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要保持服务器一直运行不是件容易的事情，并且还需要考虑黑客不同类型的攻击，但是有serverless后，我们不需要考虑这些问题了，这些问题第三方供应商已经会帮我解决这些问题的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 能适应微服务架构和扩展性能力强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serverless 的背后是 诸如 AWS Lambda 这样的 FaaS（Function as a Services）。&lt;/p&gt;
&lt;p&gt;对于传统应用来说，要应对更多的请求的方式，就是部署更多的实例。然而，这个时候往往已经来不及了。而对于 FaaS 来说，我们并不需要这么做，FaaS 会自动的扩展。它可以在需要时尽可能多地启动实例副本，而不会发生冗长的部署和配置延迟。&lt;/p&gt;
&lt;p&gt;以亚马逊的AWS Lambda为案例，Lambda能让我们不用思考任何服务器，也就是说，不用我们处理服务器上的部署，服务器的容量和服务器的扩展和失败容错，还有服务器上选择什么OS操作系统，语言的更新，日志等等问题。你的应用程序只需要和多个第三方的API或服务打交道，也可以自我创建一个无服务器的&lt;br/&gt;API。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点有如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 不适合长时间运行应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;serverless 在请求到来的时候才运行，当应用不运行的时候会进入 &quot;休眠状态&quot;，下次当请求来临时，应用将会需要一个启动时间，可以叫 冷启动，如果我们的应用需要一直长期不间断的运行，处理大量的请求，那么可能就不适合使用serverless来架构了，如果这种情况下，我们需要使用像EC2这样的云服务器会是一个更好的选择。&lt;/p&gt;
&lt;p&gt;EC2相当于我们自己买了一辆车，在Lambda 相当于我们租了一辆车。如果我们长期租车的话，那么肯定比买车更贵，但是租车可以减少一部分车维护成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 完全会依赖于第三方服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们所有和应用相关的服务放在第三方服务上的话，就可能会涉及到安全性问题，因此我们可以将不重要的API或服务放在serverless上。&lt;br/&gt;当然如果我们自己有服务设施的话，那肯定使用自己的设施服务的，当我们自己使用serverless架构的时候，那么我们就已经和供应商绑定了。&lt;br/&gt;如果这个时候我们将服务迁到别的云服务商上就没有那么容易了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 缺乏调式和开发工具，排查问题困难。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 无法用于高并发运用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每个请求启动一个进程开销太高，流量瞬间爆发容易超时。比如淘宝的双十一支付宝高峰期，每秒处理交易笔数8万多笔，也就意味着我们的系统内每秒有8万多个进程创建又被销毁。那么这样就会造成系统开销很大。解释和第一点一样的原理。&lt;/p&gt;

&lt;p&gt;四：使用serverless的应用场景有哪些？&lt;/p&gt;
&lt;p&gt;Serverless 适合构建比较简单的应用，比如上传一张图片，对一段音频/视频进行编码或解码，对请求返回一小段数据等。&lt;/p&gt;
&lt;p&gt;Serverless架构主要有以下特点：&lt;/p&gt;
&lt;p&gt;1. 实现了细粒度的计算资源分配。&lt;br/&gt;2. 不需要预分配资源。&lt;br/&gt;3. 具备真正意义上的高度扩容和弹性。&lt;br/&gt;4. 按需使用，按需计费。&lt;/p&gt;
&lt;p&gt;因此以下应用将可能使用serverless架构：&lt;/p&gt;
&lt;p&gt;1. 静态网站的管理。&lt;br/&gt;2. 替代WordPress(Serverless Blog Project)&lt;br/&gt;3. 个人媒体服务器(less!)&lt;br/&gt;4. 物联网Iot或家庭自动框架或项目 (使用 AWS IoT)&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 10:49:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>理解serverless无服务架构原理(一)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/10991363.html</dc:identifier>
</item>
<item>
<title>笨办法理解动态规划算法 - nullzx</title>
<link>http://www.cnblogs.com/nullzx/p/10991305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullzx/p/10991305.html</guid>
<description>&lt;p&gt;&lt;span&gt;动态规划在编程中有着广泛的应用，对于某些问题我们可以通过动态规划显著的降低程序的时间复杂度。本质上动态规划并不是一种算法，而是解决一类问题的思想。本篇博客通过一些非常简单而又经典的问题（比如数塔、0-1背包、完全背包、走楼梯问题、最长公共子序列等）来帮助大家理解动态规划的一般套路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎探讨，如有错误敬请指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如需转载，请注明出处&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/nullzx/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/nullzx/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h4&gt;&lt;span&gt;1. 动态规划的基本思想&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果我们解决一个问题的时候能将一个大问题转换成一个或者若干个规模较小的同等性质的问题，当我们求解出这些小问题的答案后，大问题的答案很容易解决,对于这样的情况，显然我们可以递归（或者说分治）的方式解决问题。如果在求解这些小问题的过程中发现有些小问题我们需要重复计算多次，那么我们就干脆把已经求解过的小问题的答案记录下来放在一张表中，这样下次遇到这个小问题，我们只需要查表就可以直接得到结果，这个就是动态规划的白话讲解。动态规划的难点在于如何定义问题及子问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2. 笨办法的套路&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）如果可以将一个规模较大的问题转换成一个或若干个规模较小的子问题，也就是能找到递推关系，这个时候我们不妨先将程序写成递归的形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）如果使用递归求解规模较小的问题上存在子问题重复求解的现象，那么我们就建立一张表（有可能这个表只有一行）记录需要重复求解的子问题。填表的过程和将大问题划分为子问题的方式相反，我们会从最简单的子问题开始填表。现在我们就利用这个套路解决下面这些经典的问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3. 利用套路解题&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;3.1 菲波那切数列&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;问题描述：菲波那契数列的定义f(n) = f(n-1) + f(n-2)， 且f(1)=1, f(2) = 1，求f(n)的值。斐波那契数列的定义本身就是将大问题转换成两个同性质的子问题，所以我们可以直接根据定义写成递归形式。&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static int recursion(int n) {
                
                if (n &amp;lt; 0) {
                        return 0;
                }
                
                if (n == 1 || n == 2) {
                        return 1;
                }
                
                return recursion(n-1) + recursion(n-2);
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;我们以f(6)为例现在把递归的过程画出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608181855804-2030246561.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608181856500-1497798070.png&quot; alt=&quot;clip_image002&quot; width=&quot;529&quot; height=&quot;562&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现在求解F(6)时，需要求解F(2)四次，求解F(1)三次，求解F(3)三次，F(4)两次，所以说我们的算法的效率是很低的。提高效率的办法就是将F(1)，F(2)，F(3) ….的结果放在表中，下次要计算这些问题的时候我们直接从表中获取就好了，这就是一个最简单的动态规划的例子。现在我们按照套路，从最小的子问开始填表就好了。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static int dynamic(int n) {
                
                int[] table = new int[n+1];
                
                table[1] = 1;
                table[2] = 1;
                
                /*从小到大填表*/
                for (int i = 3; i &amp;lt; table.length; i++) {
                        table[i] = table[i-1] + table[i-2];
                }
                
                return table[n];
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;需要说明的是，这个例子只是一个入门的例子，实际上它不存在最优子结构的问题，而且也不需要长度为n+1的table数组，只需要两个变量即可（可以理解为动态规划的优化版本），而我们之所以这样讲解只是为了让大家从动态规划的角度去理解问题。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.2 走楼梯问题&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;问题描述：总共有n个楼梯，每次可以走2个台阶，或者每次走3个台阶，或者每次走5个台阶，请问这n个楼梯总共有几种走法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n个阶梯的问题，可以分解成三个小问题，即n-2个阶梯有几种走法，n-3个阶梯有几种走法，n-5个阶梯有几种走法，而n个阶梯的走法就是这三种走法的和。或者可以反过来思考，你已经站在最后一个台阶上了，那么到达最后一个台阶的情况只能是三种情况，最后一步恰好走2个台阶恰好到达，最后一步恰好走3个台阶恰好到达，最后一步恰好走5个台阶恰好到达。通过这个思想，我们就可以写出递归形式的代码。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static int recursion(int n) { 
                
                if (n &amp;lt; 0) {
                        return 0;
                }
                
                if (n == 0) {
                        return 1;
                }
                
                return recursion(n - 5) + recursion(n - 3) + recursion(n - 2);
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;显然上面递归的处理方式需要重复计算很多子问题，画出递归调用的图就一目了然，由于该图和上一个问题的图很类似，这里就省略了。因此就创建一张表，把子问题的结果都记录下来，dp[i]表示走到第i个阶梯有多少种走法。按照套路，我们应该从小的阶梯数开始填表。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static int dynamic(int n) {
                
                int[] record = new int[n+1];
                
                record[0] = 1;
                
                for (int i = 0; i &amp;lt; record.length; i++) {
                        
                        int n2 = i - 2 &amp;gt;= 0 ? record[i-2] : 0;
                        int n3 = i - 3 &amp;gt;= 0 ? record[i-3] : 0;
                        int n5 = i - 5 &amp;gt;= 0 ? record[i-5] : 0;
                        
                        record[i] = n2 + n3 + n5;
                }
                
                return record[n];
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;同样，这里例子中也不存在最优问题。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.3&lt;/span&gt; 数塔问题&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;问题描述：从顶部出发在每一个节点可以选择向下或者向右下走，一直走到底层，要求找出一条路径，使得路径上的数字之和最大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183351636-1366353782.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image002[6]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183352223-1939115968.png&quot; alt=&quot;clip_image002[6]&quot; width=&quot;364&quot; height=&quot;327&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于上图所示的数塔：最大值为379, 绿色的的数字就是被选择的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题不能使用贪心算法，请大家自己用三层的阶梯列举出反例。我们现在试着将这个问题分解成子问题，如下图所示。想求得最大值，我们只要选择的红色边框数塔最大值和蓝色边框数塔的最大值中更大的那个，然后加上32，就整个数塔的最大值。这样我们就将一个大的问题转化成了两个规小的问题，然后这两个规模较小的问题还可以继续分解成更小的子问题。根据这个思路，我们可以得到如下递归形式的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183352815-1535800808.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183353454-907669711.png&quot; alt=&quot;clip_image004&quot; width=&quot;419&quot; height=&quot;351&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   /*我们用一个二维数组的左下半数组表示数塔*/
        public static int recursion(int[][] a){
                return recursion(a, 0, 0);
        }
        
        /*参数i表示所在的行，j表示所在的列*/
        private static int recursion(int[][] a, int i, int j){
                
                /*
                 * 当分解问题到最下一层时，
                 * (a.length - 1, j)位置为顶点的数塔实际上数塔只有一个元素，
                 * 直接返回
                */
                if (i == a.length - 1){
                        return a[i][j];
                }
                
                /*求（i+1, j）位置为顶点的数塔最大值*/
                int r1 = recursion(a, i+1, j);
                
                /*求（i+1, j+1）位置为顶点的数塔最大值*/
                int r2 = recursion(a, i+1, j+1);
                
                /*返回（i,j）为顶点位置的数塔的最大值*/
                return Math.max(r1, r2) + a[i][j];
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;上述代码能够得到正确的结果，但是我们发现计算大一点的数塔计算会很费时间，这主要是重复计算的问题，我们现在来分析一下为什么会出现重复计算的问题。&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183354104-902508650.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image002[8]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183354767-1855120123.png&quot; alt=&quot;clip_image002[8]&quot; width=&quot;413&quot; height=&quot;417&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的紫色边框数塔既存在于红色边框数塔中，也存在于蓝色边框数塔中，会重复计算两次。实际上，我们使用递归时重复计算的问题显然不止这一个，所以效率不高。为此我们应该创建一张和数塔形状一样的三角形表用来记录更小的数塔的最大值。我们table表示这个表，表中table[i][j]位置的值表示以（i，j）为顶点的数塔的最大值。我们用a[i][j]表示数塔中第i行，第j列的值。那么table[i][j] = a[i][j] + Math.max(table[i-1][j], table[i-1][j-1])。按照套路，我们应该从最小的数塔开始填表。按照table[i][j]的定义，table表的最下面一行就应该等于数塔表中的最下面一行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183355392-1772146198.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image004[4]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183355939-425877681.png&quot; alt=&quot;clip_image004[4]&quot; width=&quot;416&quot; height=&quot;375&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照定义，我们就可以填倒数第二行的dp[i][j]。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
table[4][0] = 79 + Math.max(0, 71) = 150
table[4][1] = 69 + Math.max(71, 51) = 140
table[4][2] = 78 + Math.max(51, 82) = 160
table[4][3] = 29 + Math.max(82, 91) = 120
table[4][4] = 63 + Math.max(91, 64) = 154
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;填入到table表的倒数第二行，如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183356493-1715263603.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image002[10]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608183357134-39710061.png&quot; alt=&quot;clip_image002[10]&quot; width=&quot;416&quot; height=&quot;375&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了倒数第二行，我们就可以推出倒数第三行，依次类推，我们就可以得到最上面table [0][0]的数值，它就表示了整个数塔的最大值。除了最大值，如果我们还需要知道走了哪些路径，我们还应该定义一个path表，在填table[i][j]时，同时填写path[i][j]。path[i][j]表示了以（i, j）为顶点的数塔的最大值是由两个子数塔（table[i-1][j]为顶点的数塔和table[i-1][j+1]为顶点的数塔）中的哪一个得到的。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class NumbericalTower {

        /*最大值对应的各个顶点位置*/
        private LinkedList&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; pathList;
                
        /*存储整个数塔的最大值*/
        private int result;

        public NumbericalTower(int[][] a) {

                pathList = new LinkedList&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt;();
                dynamic(a);
        }

        
        private void dynamic(int[][] a){

                final int N = a.length;
                
                /*path[i][j] 表示（i+1, j）为顶点的数塔和（i+1,j+1)为顶点的数塔
                 *中较大的那个*/
                int[][] path = new int[N][N];
                
                /*动态规划对应的表*/
                int[][] table = new int[N][N];

                /*从最小的数塔开始填表*/
                for (int i = N - 1; i &amp;gt;= 0; i--) {
                        
                        /*根据下层数塔的最大值计算上层的数塔的最大值*/
                        for (int j = 0; j &amp;lt;= i; j++) {
                                
                                if (i == N - 1) {
                                        table[i][j] = a[i][j];
                                        path[i][j] = -1;
                                        
                                }else if (table[i+1][j] &amp;gt; table[i+1][j+1]) {
                                        table[i][j] = table[i+1][j] + a[i][j];
                                        path[i][j] = j;
                                }else{
                                        table[i][j] = table[i+1][j+1] + a[i][j];
                                        path[i][j] = j+1;
                                }
                        }
                }
                
                result = table[0][0];
                
                /*记录最大值对应的顶点*/
                int i = 0, j = 0;
                pathList.add(new SimpleEntry&amp;lt;Integer, Integer&amp;gt;(0, 0));
                
                while (true) {
                        j = path[i][j];
                        i = i + 1;
                        pathList.add(new SimpleEntry&amp;lt;Integer, Integer&amp;gt;(i, j));
                        
                        if (path[i][j] == -1) {
                                break;
                        }
                }
        }
        
        int max(){
                return result;
        }
        
        List&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; path(){
                return pathList;
        }
        
        public static void main(String[] args) {
                int[][] a = {
                        {32},
                        {83, 68},
                        {40, 37, 47},
                        { 5,  4, 67, 22},
                        {79, 69, 78, 29, 63},
                        { 0, 71, 51, 82, 91, 64}
                };

                NumbericalTower nt = new NumbericalTower(a);
                int max = nt.max();
                List&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; path = nt.path();
                System.out.println(&quot;最大值：&quot; + max);
                System.out.println(&quot;\n\n路径为：&quot;);
                for (Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : path) {
                        int r = entry.getKey();
                        int c = entry.getValue();
                        System.out.println(&quot;行 : &quot; + r + &quot;, 列：&quot;+ c);
                }
        }
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
最大值：379

路径为：
行 : 0, 列：0
行 : 1, 列：0
行 : 2, 列：1
行 : 3, 列：2
行 : 4, 列：2
行 : 5, 列：3
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.4&lt;/span&gt;&lt;/span&gt; &lt;span&gt;零-壹背包问题&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;问题描述：有n 个物品，它们有各自的重量（weight）和价值（value），现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和此时背包中的物品？一个物品只有不拿和拿两种情况，可以用0和1表示，所以称之为0-1背包问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看一个具体的例子。假设有如下物品：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184027008-1795338184.jpg&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184027705-650502476.jpg&quot; alt=&quot;clip_image002&quot; width=&quot;226&quot; height=&quot;203&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求背包容量在10的时候的能装物品的最大价值，以及装了哪些物品?&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.4.1 解决背包的最大价值&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;我们可能首先想到的是贪心算法，我们算出每种物品的单位重量价值（weight/value）,然后按照单位重量价值排序。我们放入物品时首先选择单位重量价值高的物品,直到放不下为止。但是很遗憾，这样得不到最优解。我们不妨列举一个极端的例子，假设只有两个物品，A的value = 2.9， weight = 2.1；B的value = 3， weight = 3，显然物品A的单位重量价值要大于B的单位重量价值，但对于容量为3的背包，我们应该选择物品B，所以贪心算法失效。对于0-1背包问题，贪心选择之所以不能得到最优解是因为：它无法保证最终能将背包装满，而部分闲置的背包空间使每公斤背包空间的价值降低了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到上面具体的这个问题，它可以表述为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxValue{宝石、剃须刀、ipad、充电宝、iphone &lt;strong&gt;|&lt;/strong&gt; 背包容量10}，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个物品只有选和不选两种结果，我们不妨从第一个物品开始。&lt;strong&gt;如果选了宝石&lt;/strong&gt;，那么问题转化为当前背包已有价值为50，并在剩下的背包容量（10 - 4）的前提下，再剩下的物品中（即剃须刀、ipad、充电宝、iphone）选取出最大的价值；&lt;strong&gt;如果不选宝石&lt;/strong&gt;，那么问题转化为当前背包价值为0，并在剩下的背包容量10的前提下，在剩下的物品中（即剃须刀、ipad、充电宝、iphone）选取出最大的价值。我们只需要选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;50&lt;/span&gt; + maxValue{剃须刀、ipad、充电宝、iphone | 背包容量&lt;span&gt;6&lt;/span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt; + maxValue{剃须刀、ipad、充电宝、iphone | 背包容量&lt;span&gt;10&lt;/span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中较大的那个。而这就直接转化成两个子问题的求解，显然我们已经可以用分治的方式解决这个问题了。我们不妨把递归树（或者说分治树）画出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608220618269-478471263.png&quot;&gt;&lt;img title=&quot;clip_image004[6]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184030353-573888120.png&quot; alt=&quot;clip_image004[6]&quot; width=&quot;800&quot; height=&quot;437&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图就是0-1背包问题的递归树，图左文字边表示当前可选的物品，节点中的值表示背包的容量。我们没有把整个递归树全部都画出来，因为图中我们就已经发现了需要重复计算的子问题。如果背包容量变大，物品种类变多，那么需要重复计算的子问题就越多。需要说明的是上图中有三个背包容量为7的子问题，但是只有被标记的两个子问题才是重复的子问题，因为这两个子问题的背包容量一样，可选物品一样。为了避免子问题的重复求解，我们就建立一张动态规划表，下次遇到重复的子问题，我们就直接查表。下图表示了动态规划表和递归树之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184031358-979691314.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184032293-1492940796.png&quot; alt=&quot;clip_image006&quot; width=&quot;872&quot; height=&quot;647&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们现在的主要问题就变成了如何填这样一张表。我们用一个名为dp的二维数组表示这张表，dp[0]行需要单独初始化，从dp[1]行开始填表，规则：从左到右，从上到下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608220619241-1699869197.jpg&quot;&gt;      &lt;/a&gt; &lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608220620330-1198016334.jpg&quot;&gt;&lt;img title=&quot;clip_image008&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184034739-10851083.jpg&quot; alt=&quot;clip_image008&quot; width=&quot;800&quot; height=&quot;152&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[i][j]表示前i个物品（包括物品i），在背包容量为j时能装的最大价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[i][j]为下面两者的最大值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）物品i不放入背包中：背包容量为j时，前i-1个物品组合出的最大价值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）物品i放入背包中：物品i的价值 + 除去物品i占用的重量后，剩余背包容量j-weight(i)由前i-1个物品组合出的最大价值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用公式表示为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184035296-934638317.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image010&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184035937-1062965318.png&quot; alt=&quot;clip_image010&quot; width=&quot;530&quot; height=&quot;90&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.4.2 解决背包有哪些物品&lt;/span&gt;&lt;/h5&gt;
&lt;h5&gt;&lt;span&gt;&lt;span&gt;通过dp表，我们还可以知道哪些物品放入了背包中。从表格的右下角开始（第0个物品要单独处理）：&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/span&gt;如果dp[i][j] &amp;gt; dp[i-1][j]，说明该物品i被放入到了背包中，令i = i – 1, j = j – weight[i]，然后重复步骤1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/span&gt;如果dp[i][j] == dp[i-1][j]，且只想得到背包最大价值的其中一种的物品一种组合方式，不妨认为该物品i没有被放入到了背包中，令i = i – 1, 重复步骤1）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184036716-1432241070.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image012&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608184037514-1954048285.jpg&quot; alt=&quot;clip_image012&quot; width=&quot;873&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于步骤2），如果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[i][j] == dp[i-1][j] &amp;amp;&amp;amp; dp[i][j – weight(i)] + value(i) == dp[i][j]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明物品i可以放入背包中（令i = i – 1, j = j – weight[i]），也可以不用放入背包中（令i = i - 1）。这里就产生分支,说明放入背包中的物品组合方式不唯一，为了简单起见，我们找到一种物品的组合方式即可。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
package demo;

import java.util.LinkedList;
import java.util.List;


public class KnapsacProblem {
        /*动态规划表*/
        private int[][] dp;
        
        /*背包装的最大价值*/
        private int maxVal;
        
        /*背包最大价值时对应的商品编号*/
        private List&amp;lt;Integer&amp;gt; goodsNumber; 
        
        public KnapsacProblem(int[] weight, int[] values, int capacity){
                
                if ( weight.length != values.length ){
                        throw new IllegalArgumentException();
                }
                
                int goodsLen = weight.length;
                
                /*第0列不使用*/
                this.dp = new int[goodsLen][capacity + 1];
                
                goodsNumber = new LinkedList&amp;lt;Integer&amp;gt;();
                
                
                /*单独初始化第0行*/
                for ( int j = 1; j &amp;lt; capacity + 1; j++){
                        if (j &amp;gt;= weight[0]){
                                dp[0][j] = values[0];
                        }
                }
                
                /*填dp表*/
                for ( int i = 1; i &amp;lt; goodsLen; i++ ) {
                        for ( int j = 1; j &amp;lt; capacity + 1; j++ ) {
                                if ( weight[i] &amp;lt;= j ) {
                                        dp[i][j] = Math.max(dp[i-1][j], values[i] + dp[i-1][j - weight[i]]);
                                } else {
                                        dp[i][j] = dp[i-1][j];
                                }
                        }
                }
                
                maxVal = dp[goodsLen - 1][capacity - 1];
                
                /*找出使用了哪些物品*/
                int j = capacity;
                for (int i = goodsLen - 1; i &amp;gt; 0; i-- ) {
                        if ( dp[i][j] &amp;gt; dp[i-1][j] ) {
                                goodsNumber.add(i);
                                j = j - weight[i];
                        }
                }
                
                /*单独处理第0行，回退到第0行时发现背包中还有物品，说明物品0在背包中*/
                if (j &amp;gt; 0){
                        goodsNumber.add(0);
                }
        }
        
        public int  getPackageMaxValue(){
                return this.maxVal;
        }
        
        public List&amp;lt;Integer&amp;gt; getGoodsNumber(){
                return this.goodsNumber;
        }
        
        public static void main(String[] args){
                
                int[] weight = {4, 5, 2, 1, 2};
                int[] values = {50, 40, 60, 20, 30};
                int capacity = 10;
                
                KnapsacProblem kp = new KnapsacProblem(weight, values, capacity);
                
                System.out.println(kp.getPackageMaxValue());
                System.out.println(kp.getGoodsNumber());
        }

}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
160
[4, 3, 2, 0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们仅仅需要知道最大的价值，不需要知道装了哪些物品，我们就可以对空间复杂度进行优化，动态规划表只需要一维，因为dp[i][?]仅和dp[i-1][?]有关。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.5 切分“和相等”的子集&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;Given a &lt;strong&gt;non-empty&lt;/strong&gt; array containing &lt;strong&gt;only positive integers&lt;/strong&gt;, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Note:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Each of the array element will not exceed 100.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. The array size will not exceed 200.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Example 1:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Input: [1, 5, 11, 5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Output: true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Explanation: The array can be partitioned as [1, 5, 5] and [11].&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Example 2:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Input: [1, 2, 3, 5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Output: false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Explanation: The array cannot be partitioned into equal sum subsets.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是LeetCode的原题。这个问题本质上还是0-1背包问题，背包容量是数组之和的一半，物品的价值和体积是1比1的关系，额外条件是需要把背包装满。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.6 完全背包问题&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;问题描述：有n 种物品，它们有各自的重量（weight）和价值（value），现有给定容量的背包，每种物品可以拿任意多个，如何让背包里装入的物品具有最大的价值，以及每种物品装了几个？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190154929-230448333.jpg&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190155696-254647278.jpg&quot; alt=&quot;clip_image002&quot; width=&quot;226&quot; height=&quot;203&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设，我们还是利用0-1背包中的物品,背包容量为11。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完全背包问题也可以转化成0-1背包问题。因为第i个物品最多拿“背包重量/（物品i的重量）”个，也就是说在0-1背包问题中每个物品i占一行，完全背包问题中，每个物品占“背包重量/（物品i的重量）” 个行，按照这个思路显然已经能够解决这个问题。现在我们不把这个问题转化为0-1背包问题，而从这个问题的根源直接思考。&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;3.6.1  解决背包的最大价值&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;完全背包问题可以表述为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxValue{宝石、剃须刀、ipad、充电宝、iphone &lt;strong&gt;|&lt;/strong&gt; 背包容量10}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每个物品只有选和不选两种结果，我们不妨从第一个物品开始。&lt;strong&gt;如果选了宝石&lt;/strong&gt;，那么问题转化为当前背包已有价值为50，并在剩下的背包容量（10 - 4）的前提下，继续在{&lt;strong&gt;宝石&lt;/strong&gt;、剃须刀、ipad、充电宝、iphone}选取出最大的价值；&lt;strong&gt;如果不选宝石&lt;/strong&gt;，那么我们就在{剃须刀、ipad、充电宝、iphone}中选择一种，那么问题转化为当前背包价值为0，并在剩下的背包容量10的前提下，再剩下的物品中即{剃须刀、ipad、充电宝、iphone }选取出最大的价值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此我们只需要选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;50&lt;/span&gt; + maxValue{&lt;span&gt;宝石&lt;/span&gt;、剃须刀、ipad、充电宝、iphone &lt;strong&gt;|&lt;/strong&gt; 背包容量&lt;span&gt;6&lt;/span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt; + maxValue{剃须刀、ipad、充电宝、iphone &lt;strong&gt;|&lt;/strong&gt; 背包容量&lt;span&gt;10&lt;/span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中较大的那个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而这就直接转化成两个子问题的求解，显然我们已经可以用分治的方式解决这个问题了。我们同样可以把递归树画出来，同样还会发现存在需要重复求解的子问题，为了避免子问题的重复求解，我们还是建立一张动态规划表，下次遇到重复的子问题，我们就直接查表。这里我们直接给出动态规划表，我们用一个名为dp的二维数组表示这张表，dp[0]行单独初始化，从dp[1]行开始填表，规则：从左到右，从上到下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190156578-171878885.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190157289-1991243414.jpg&quot; alt=&quot;clip_image004&quot; width=&quot;871&quot; height=&quot;165&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[i][j]表示前i个物品（包括物品i），在背包容量为j时能装的最大价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dp[i][j]为下面二者的最大值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190157782-2093550643.png&quot;&gt;&lt;img title=&quot;clip_image006[4]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190158381-1399193877.png&quot; alt=&quot;clip_image006[4]&quot; width=&quot;466&quot; height=&quot;114&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190159228-329419800.jpg&quot;&gt;&lt;img title=&quot;clip_image008[5]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190200186-456463569.jpg&quot; alt=&quot;clip_image008[5]&quot; width=&quot;872&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.6.2 解决背包中物品的种类和个数&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;同样，从dp表中我们还可以知道哪些物品被选择了，选择多少次。我们还是从右下角开始回溯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）dp[i][j] &amp;gt; dp[i-1][j] 说明i号物品被选择了，j = j – weight[i]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）dp[i][j] == dp[i-1][j] 为了简单起见，我们认为i号物品没有被选择，令i = i -1（实际上这里同样可能存在分支，即最大价值时物品的组合方式和数量并不唯一，我们这里为了简单处理，就不考虑这个问题了）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190201040-917133978.jpg&quot;&gt;&lt;img title=&quot;clip_image009&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190201963-1532231875.jpg&quot; alt=&quot;clip_image009&quot; width=&quot;872&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
package demo;

import java.util.AbstractMap.SimpleEntry;
import java.util.LinkedList;

public class AllKnapsacProblem {
        
        private int maxVal;
        
        private LinkedList&amp;lt;SimpleEntry&amp;lt;Integer, Integer&amp;gt;&amp;gt; goodsIdCount;
        
        public int getPackageMaxValue(){
                return maxVal;
        }
        
        public LinkedList&amp;lt;SimpleEntry&amp;lt;Integer, Integer&amp;gt;&amp;gt; getGoodsCount(){
                return goodsIdCount;
        }
        
        public AllKnapsacProblem(int[] weight, int[] values, int capacity){
                /*处理最大价值问题============================================*/

                if ( weight.length != values.length ){
                        throw new IllegalArgumentException();
                }
                
                int goodsLen = weight.length;
                
                /*第0列不使用*/
                int[][] dp = new int[goodsLen][capacity + 1];
                
                /*第0行单独处理*/
                for (int j = weight[0]; j &amp;lt;= capacity; j++){
                        dp[0][j] = dp[0][j - weight[0]] + values[0];
                }
                
                for (int i = 1; i &amp;lt; goodsLen; i++){
                        
                        for (int j = 1; j &amp;lt;= capacity; j++){
                                
                                int max1 = dp[i-1][j];
                int max2 = j - weight[i] &amp;gt;= 0 ? values[i] + dp[i][j - weight[i]] : 0;
                
                dp[i][j] = Math.max(max1, max2);
                        }
                }
                
                maxVal = dp[goodsLen-1][capacity];
                
                /*处理物品种类和个数问题问题============================================*/
                
                /*SimpleEntry&amp;lt;Integer, Integer&amp;gt;:key表示物品编号，value表示物品个数*/
                goodsIdCount = new LinkedList&amp;lt;SimpleEntry&amp;lt;Integer, Integer&amp;gt;&amp;gt;();
                
                int i = goodsLen - 1;
                int j = capacity;
                
                SimpleEntry&amp;lt;Integer, Integer&amp;gt; entry = new SimpleEntry&amp;lt;Integer, Integer&amp;gt;(i, 0);
                while (i &amp;gt; 0){
                        
                        if (dp[i][j] &amp;gt; dp[i-1][j]){
                                int n = entry.getValue();
                                entry.setValue(n+1);
                                j = j - weight[i];
                        }
                        
                        if (dp[i][j] == dp[i-1][j]){
                                if (entry.getValue() &amp;gt; 0) {                                  
                                        goodsIdCount.add(entry);
                                }
                                i--;
                                entry = new SimpleEntry&amp;lt;Integer, Integer&amp;gt;(i, 0);
                        }
                }
                                
                /*单独处理第0行*/
                if (j &amp;gt; 0) {
                        goodsIdCount.add(new SimpleEntry&amp;lt;Integer, Integer&amp;gt;(0, j/weight[0]));
                }
        }
        
        public static void main(String[] args){
                
                int[] values = {50, 40, 60, 20, 30};
                int[] weight = {4,   5,  2,  1, 2};
                int capacity = 11;
                
                AllKnapsacProblem ap = new AllKnapsacProblem(weight, values, capacity);
                
                System.out.println(&quot;背包价值&quot; + ap.getPackageMaxValue());
                for (SimpleEntry&amp;lt;Integer, Integer&amp;gt; entry : ap.goodsIdCount) {
                        System.out.printf(&quot;物品%d : %d个\n&quot;, entry.getKey(), entry.getValue());
                }
                
        }
        
}
&lt;/pre&gt;
&lt;h5&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
320
物品3 : 1个
物品2 : 5个
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;&lt;span&gt;3.7 找零钱问题&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;You are given coins of different denominations ([dɪˌnɑ:mɪˈneɪʃn] 面额) and a total amount of money &lt;em&gt;amount&lt;/em&gt;. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Example 1:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Input:&lt;/strong&gt; coins = [1, 2, 5], amount = 11&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Output:&lt;/strong&gt; 3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Explanation:&lt;/strong&gt; 11 = 5 + 5 + 1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Example 2:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Input:&lt;/strong&gt; coins = [2], amount = 3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Output:&lt;/strong&gt; -1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这道题目是LeetCode上面的原题。假设在一堆面值为 1,2,5,11面值的硬币，问最少需要多少个硬币才能找出总值为以兑换15元。面对这个问题我们也会首先想到贪心算法，但是贪心算法给出的组合方案为{11,1,1,1,1}，但其实最优方案为{5,5,5}。如果使用枚举算法，每种硬币都有选0个，选1个，选2个，选…,这样时间复杂度太高。这个问题本质上还是完全背包问题，物品的价值和重量比是1比1，额外条件是需要把背包装满，所以我们可以使用动态规划算法去解决它，代码这里就不给出了。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;3.8 最长公共子序列&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;我们首先看一下子序列的定义。假设给定一个字符串，我们抽取任意多个不超过字符串长度的字符，并保持它们的前后关系，这样的字符我们称之为子序列。对于字符串ABCDEFG而言， BEF、C、AG等等都是它的一个子序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Longest common sequence问题：给定两个字符串s1和s2，求这两个字符串中最长的公共子序列。比如给定两个字符串s1：bdcaba和s2：abcbdab，它们的公共子序列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;长度为4，最长公共子序列是：bcba。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串s1的长度用n表示,字符产s2的长度用m表示，字符串s1和s2的最长公共字串用lcs（n，m）。那么这个问题可以转化为三个子问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）求lcs(n-1, m-1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）求lcs(n-1, m)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）求lcs(n, m-1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们求的上述三个子问题的答案，那么lcs(n, m)的结果就可以通过如下方式得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果s1[n] == s2[m]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    lcs(n, m) = lcs(n-1, m-1)+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果s1[n] ！= s2[m] ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    lcs(n, m) = max{ &lt;span&gt;lcs(n-1, m-1)&lt;/span&gt;, lcs(n-1, m), lcs(n, m-1) }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是实际上lcs（n，m）只要转化成两个子问题lcs(n-1, m)和lcs(n, m-1)就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而子问题lcs(n-1, m-1)是没有必要的，因为lcs(n-1, m-1)必定小于等于lcs(n-1, m)和lcs(n, m-1)中的en任意一个。从常理上来说很好理解，不可能两个字符串中的任意一个变长了，公共子序列反而减少了。而本质上是由于lcs(n-1, m-1)也是lcs(n-1, m)和lcs(n, m-1)这两个问题的子问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面的分析，我们把大的问题转化成小的问题，就可以通过递归（或者说分治）的方式把问题解决了，下面就是递归对应的代码。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static void recursion (char[] s1, char[] s2) {
                maxLen = recursion0 (s1, s1.length-1, s2, s2.length-1);
        }
        
        private static int recursion0 (char[] s1, int idx1, char[] s2, int idx2){
                
                if(idx1 &amp;lt; 0 || idx2 &amp;lt; 0){
                        return 0;
                }
                
                int max1, max2;
                
                max1 = recursion0 (s1, idx1, s2, idx2 - 1);
                max2 = recursion0 (s1, idx1 - 1, s2,  idx2);
                
                if (s1[idx1] == s2[idx2]){
                        return Math.max(max1, max2) + 1;
                }else{
                        return Math.max(max1, max2);
                }
        }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;显然上述也同样存在很多重复计算的子问题，为了降低时间复杂度，要一张二维表记录重复计算的子问题的结果，这张表我们用dp表示， dp[i][j]就表示以s1[i]和s2[j]结尾的字符串最长公共子序列。按照套路填表规则要从最小的子问题开始，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190202865-541931578.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image002[3]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190203506-1787981450.jpg&quot; alt=&quot;clip_image002[3]&quot; width=&quot;327&quot; height=&quot;189&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第0行，表示“b”和“bdcaba”的公共子序列，可以单独处理，同理第0列也可以单独处理，填表完成后如上图所示。从第二行开始，dp表按照从上到下，从左到右的填表顺序填表。根据子递归中子问题的定义，dp[i][j]的取值如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608215100731-1374286667.png&quot;&gt;&lt;img title=&quot;clip_image002[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608215101232-709484219.png&quot; alt=&quot;clip_image002[1]&quot; width=&quot;641&quot; height=&quot;113&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190205273-784829616.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image006[4]&quot; src=&quot;https://img2018.cnblogs.com/blog/834468/201906/834468-20190608190205964-744304779.jpg&quot; alt=&quot;clip_image006[4]&quot; width=&quot;338&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当填完整张表时，右下角的值就是公共子序列的最大长度。如果我们还需要知道公共子序列是什么，那么我们可以从右下角开始回溯，如果dp[i][j] &amp;gt; dp[i-1][j] 且 dp[i][j] &amp;gt; dp[i][j-1], 说明s1[i]或者s2[j]是公共子序列，否则选择走dp[i-1][j]和dp[i][j-1]中较大的那个,同样第0行要单独处理。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
package demo;

public class LongestCommonSequence {
        
        private int[][] dp;
        private int maxLen;
        private String lcs;
        
        private char[] s1, s2;
                
        public int maxLen(){
                return maxLen;
        }
        
        public String getLCS() {
                return lcs;
        }
        
        public LongestCommonSequence(String str1, String str2) {
                s1 = str1.toCharArray();
                s2 = str2.toCharArray();
                dynamic();
                getString();
        }
        
        /*动态规划算法*/
        private void dynamic(){
                
                dp = new int[s1.length][s2.length];
                
                /*单独处理第0行*/
                for(int j = 0, x = 0; j &amp;lt; s2.length; j++){
                        if (s1[0] == s2[j]){
                                x = 1;
                        }
                        dp[0][j] = x;
                }
                
                /*单独处理第0列*/
                for (int i = 0, x = 0; i &amp;lt; s1.length; i++) {
                        if (s2[0] == s1[i]){
                                x = 1;
                        }
                        dp[i][0] = x;
                }
                
                for (int i = 1; i &amp;lt; s1.length; i++) {
                        
                        for(int j = 1; j &amp;lt; s2.length; j++){
                                
                                if(s1[i] == s2[j]){
                                        dp[i][j] = 1 + dp[i-1][j-1];
                                }else{
                                        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                                }
                        }
                }
                
                maxLen = dp[s1.length - 1][s2.length - 1];
                
        }
        
        /*回溯求出公共子序列*/
        private void getString(){
                
                int cnt = maxLen;
                StringBuffer sb = new StringBuffer();
                
                int i = s1.length - 1, j = s2.length - 1;
                
                while (i &amp;gt; 0 &amp;amp;&amp;amp; j &amp;gt; 0){
                        if (dp[i][j] &amp;gt; dp[i-1][j] &amp;amp;&amp;amp; dp[i][j] &amp;gt; dp[i][j-1]){
                                sb.append(s1[i]);
                                i--;
                                j--;
                                cnt--;
                        }else{
                                if (dp[i-1][j] &amp;gt; dp[i][j-1]){
                                        i--;
                                }else{
                                        j--;
                                }
                        }
                }
                
                /*单独处理第0行, i和j必然有一个为0*/
                if (cnt &amp;gt; 0){
                        
                        while (true){
                                
                                if (s1[i] == s2[j]){
                                        sb.append(s1[i]);
                                        break;
                                }
                                
                                if (i &amp;gt; 0){
                                        i--;
                                }
                                
                                if (j &amp;gt; 0){
                                        j--;
                                }
                        }
                        
                        cnt--;
                }
                
                lcs = sb.reverse().toString();
        }
        
        public static void main(String[] args){
                LongestCommonSequence lcs = new LongestCommonSequence(&quot;bcba&quot;, &quot;bdcaba&quot;);
                System.out.println(lcs.maxLen);
                System.out.println(lcs.getLCS());
        }

}
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;4. 动态规划算法总结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;枚举算法：如果为了方便的解决这个问题，我们需要将大问题化简成小问题，将&lt;strong&gt;所有&lt;/strong&gt;小问题中的最优解作为我们解决大问题的基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;贪心算法：如果为了方便的解决这个问题，我们需要将大问题化简成小问题，在&lt;strong&gt;所有&lt;/strong&gt;小问题中，仅选择对当前最有利的小问题作为我们解决大问题的基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态规划：如果为了方便的解决这个问题，我们需要将大问题化简成小问题，&lt;strong&gt;记录已解决过的小问题&lt;/strong&gt;，将&lt;strong&gt;所有&lt;/strong&gt;小问题中的最优解作为我们解决大问题的基础。换句话说，能用贪心算法解决的，动态规划算法也肯定能解决，反之不成立。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;能用动规解决的问题的特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5. 参考内容&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;[1].&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/GodA/p/5180560.html&quot;&gt;&lt;span&gt;动态规划：最长上升子序列（LIS）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2]. 什么是&lt;/span&gt;&lt;a href=&quot;https://www.zhihu.com/question/23995189&quot;&gt;&lt;span&gt;动态规划&lt;/span&gt;&lt;/a&gt;&lt;span&gt;？动态规划的意义是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[3].&lt;/span&gt; &lt;a href=&quot;http://www.sohu.com/a/153858619_466939&quot;&gt;&lt;span&gt;漫画：什么是动态规划？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 10:19:00 +0000</pubDate>
<dc:creator>nullzx</dc:creator>
<og:description>动态规划在编程中有着广泛的应用，对于某些问题我们可以通过动态规划显著的降低程序的时间复杂度。本质上动态规划并不是一种算法，而是解决一类问题的思想。本篇博客通过一些非常简单而又经典的问题（比如数塔、0-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nullzx/p/10991305.html</dc:identifier>
</item>
<item>
<title>描述符(__get__,__set__,__delete__) - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/10991295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/10991295.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_103-%E6%8F%8F%E8%BF%B0%E7%AC%A6(__get__,__set__,__delete__)-%E9%A2%84%E8%AD%A6.gif&quot; alt=&quot;103-描述符(get,set,delete)-预警.gif&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Foo:  # 在python3中Foo是新式类，它实现了__get__()，__set__()，__delete__()中的一个三种方法的一个，这个类就被称作一个描述符
    def __get__(self, instance, owner):
        pass

    def __set__(self, instance, value):
        pass

    def __delete__(self, instance):
        pass&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;描述符是干什么的：描述符的作用是用来代理另外一个类的属性的，必须把描述符定义成这个类的类属性，不能定义到构造函数中&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Foo:
    def __get__(self, instance, owner):
        print('触发get')

    def __set__(self, instance, value):
        print('触发set')

    def __delete__(self, instance):
        print('触发delete')


f1 = Foo()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;包含这三个方法的新式类称为描述符，由这个类产生的实例进行属性的调用/赋值/删除，并不会触发这三个方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f1.name = 'nick'
f1.name
del f1.name&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;何时何地会触发这三个方法的执行&quot;&gt;何时，何地，会触发这三个方法的执行&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Str:
    &quot;&quot;&quot;描述符Str&quot;&quot;&quot;

    def __get__(self, instance, owner):
        print('Str调用')

    def __set__(self, instance, value):
        print('Str设置...')

    def __delete__(self, instance):
        print('Str删除...')


class Int:
    &quot;&quot;&quot;描述符Int&quot;&quot;&quot;

    def __get__(self, instance, owner):
        print('Int调用')

    def __set__(self, instance, value):
        print('Int设置...')

    def __delete__(self, instance):
        print('Int删除...')


class People:
    name = Str()
    age = Int()

    def __init__(self, name, age):  # name被Str类代理，age被Int类代理
        self.name = name
        self.age = age


# 何地？：定义成另外一个类的类属性

# 何时？：且看下列演示

p1 = People('alex', 18)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Str设置...
Int设置...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;描述符Str的使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.name
p1.name = 'nick'
del p1.name&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Str调用
Str设置...
Str删除...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;描述符Int的使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.age
p1.age = 18
del p1.age&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Int调用
Int设置...
Int删除...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们来瞅瞅到底发生了什么&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(p1.__dict__)
print(People.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{}
{'__module__': '__main__', 'name': &amp;lt;__main__.Str object at 0x107a86940&amp;gt;, 'age': &amp;lt;__main__.Int object at 0x107a863c8&amp;gt;, '__init__': &amp;lt;function People.__init__ at 0x107ba2ae8&amp;gt;, '__dict__': &amp;lt;attribute '__dict__' of 'People' objects&amp;gt;, '__weakref__': &amp;lt;attribute '__weakref__' of 'People' objects&amp;gt;, '__doc__': None}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(type(p1) == People)  # type(obj)其实是查看obj是由哪个类实例化来的
print(type(p1).__dict__ == People.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;True
True&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;数据描述符&quot;&gt;数据描述符&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;至少实现了__get__()和__set__()&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Foo:
    def __set__(self, instance, value):
        print('set')

    def __get__(self, instance, owner):
        print('get')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;非数据描述符&quot;&gt;非数据描述符&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;没有实现__set__()&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Foo:
    def __get__(self, instance, owner):
        print('get')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_103-%E6%8F%8F%E8%BF%B0%E7%AC%A6(__get__,__set__,__delete__)-%E6%B3%A8%E6%84%8F.jpg&quot; alt=&quot;103-描述符(get,set,delete)-注意.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;描述符本身应该定义成新式类，被代理的类也应该是新式类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;必须把描述符定义成这个类的类属性，不能为定义到构造函数中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;要严格遵循该优先级，优先级由高到底分别是&lt;/p&gt;
&lt;p&gt;1.类属性&lt;/p&gt;
&lt;p&gt;2.数据描述符&lt;/p&gt;
&lt;p&gt;3.实例属性&lt;/p&gt;
&lt;p&gt;4.非数据描述符&lt;/p&gt;
&lt;p&gt;5.找不到的属性触发__getattr__()&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;众所周知，python是弱类型语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;牛刀小试&quot;&gt;牛刀小试&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Str:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


class People:
    name = Str('name')

    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


p1 = People('nick', 18, 3231.3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x107a86198&amp;gt; nick&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(p1.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'name': 'nick', 'age': 18, 'salary': 3231.3}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(p1.name)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;get---&amp;gt; &amp;lt;__main__.People object at 0x107a86198&amp;gt; &amp;lt;class '__main__.People'&amp;gt;
nick&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(p1.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'name': 'nick', 'age': 18, 'salary': 3231.3}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.name = 'nicklin'
print(p1.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x107a86198&amp;gt; nicklin
{'name': 'nicklin', 'age': 18, 'salary': 3231.3}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(p1.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'name': 'nicklin', 'age': 18, 'salary': 3231.3}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;del p1.name
print(p1.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;delete---&amp;gt; &amp;lt;__main__.People object at 0x107a86198&amp;gt;
{'age': 18, 'salary': 3231.3}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拔刀相助&quot;&gt;拔刀相助&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Str:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


class People:
    name = Str('name')

    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


# 疑问：如果我用类名去操作属性呢
try:
    People.name  # 报错，错误的根源在于类去操作属性时，会把None传给instance
except Exception as e:
    print(e)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;get---&amp;gt; None &amp;lt;class '__main__.People'&amp;gt;
'NoneType' object has no attribute '__dict__'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修订__get__方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Str:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


class People:
    name = Str('name')

    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


print(People.name)  # 完美，解决&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;get---&amp;gt; None &amp;lt;class '__main__.People'&amp;gt;
&amp;lt;__main__.Str object at 0x107a86da0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;磨刀霍霍&quot;&gt;磨刀霍霍&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Str:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        if not isinstance(value, self.expected_type):  # 如果不是期望的类型，则抛出异常
            raise TypeError('Expected %s' % str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


class People:
    name = Str('name', str)  # 新增类型限制str

    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


try:
    p1 = People(123, 18, 3333.3)  # 传入的name因不是字符串类型而抛出异常
except Exception as e:
    print(e)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x1084cd940&amp;gt; 123
Expected &amp;lt;class 'str'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;大刀阔斧&quot;&gt;大刀阔斧&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        if not isinstance(value, self.expected_type):
            raise TypeError('Expected %s' % str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


class People:
    name = Typed('name', str)
    age = Typed('name', int)
    salary = Typed('name', float)

    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


try:
    p1 = People(123, 18, 3333.3)
except Exception as e:
    print(e)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x1082c7908&amp;gt; 123
Expected &amp;lt;class 'str'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
    p1 = People('nick', '18', 3333.3)
except Exception as e:
    print(e)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x1078dd438&amp;gt; nick
set---&amp;gt; &amp;lt;__main__.People object at 0x1078dd438&amp;gt; 18
Expected &amp;lt;class 'int'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1 = People('nick', 18, 3333.3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;set---&amp;gt; &amp;lt;__main__.People object at 0x1081b3da0&amp;gt; nick
set---&amp;gt; &amp;lt;__main__.People object at 0x1081b3da0&amp;gt; 18
set---&amp;gt; &amp;lt;__main__.People object at 0x1081b3da0&amp;gt; 3333.3&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;大刀阔斧之后我们已然能实现功能了，但是问题是，如果我们的类有很多属性，你仍然采用在定义一堆类属性的方式去实现，low，这时候我需要教你一招：独孤九剑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_103-%E6%8F%8F%E8%BF%B0%E7%AC%A6(__get__,__set__,__delete__)-%E7%8B%AC%E5%AD%A4%E4%B9%9D%E5%89%91.jpg&quot; alt=&quot;103-描述符(get,set,delete)-独孤九剑.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;类的装饰器无参&quot;&gt;类的装饰器:无参&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def decorate(cls):
    print('类的装饰器开始运行啦------&amp;gt;')
    return cls


@decorate  # 无参：People = decorate(People)
class People:
    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


p1 = People('nick', 18, 3333.3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;类的装饰器开始运行啦------&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类的装饰器有参&quot;&gt;类的装饰器:有参&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def typeassert(**kwargs):
    def decorate(cls):
        print('类的装饰器开始运行啦------&amp;gt;', kwargs)
        return cls

    return decorate


@typeassert(
    name=str, age=int, salary=float
)  # 有参：1.运行typeassert(...)返回结果是decorate，此时参数都传给kwargs 2.People=decorate(People)
class People:
    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


p1 = People('nick', 18, 3333.3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;类的装饰器开始运行啦------&amp;gt; {'name': &amp;lt;class 'str'&amp;gt;, 'age': &amp;lt;class 'int'&amp;gt;, 'salary': &amp;lt;class 'float'&amp;gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;刀光剑影&quot;&gt;刀光剑影&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, owner):
        print('get---&amp;gt;', instance, owner)
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        print('set---&amp;gt;', instance, value)
        if not isinstance(value, self.expected_type):
            raise TypeError('Expected %s' % str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        print('delete---&amp;gt;', instance)
        instance.__dict__.pop(self.name)


def typeassert(**kwargs):
    def decorate(cls):
        print('类的装饰器开始运行啦------&amp;gt;', kwargs)
        for name, expected_type in kwargs.items():
            setattr(cls, name, Typed(name, expected_type))
        return cls

    return decorate


@typeassert(
    name=str, age=int, salary=float
)  # 有参：1.运行typeassert(...)返回结果是decorate，此时参数都传给kwargs 2.People=decorate(People)
class People:
    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary


print(People.__dict__)
p1 = People('nick', 18, 3333.3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;类的装饰器开始运行啦------&amp;gt; {'name': &amp;lt;class 'str'&amp;gt;, 'age': &amp;lt;class 'int'&amp;gt;, 'salary': &amp;lt;class 'float'&amp;gt;}
{'__module__': '__main__', '__init__': &amp;lt;function People.__init__ at 0x10797a400&amp;gt;, '__dict__': &amp;lt;attribute '__dict__' of 'People' objects&amp;gt;, '__weakref__': &amp;lt;attribute '__weakref__' of 'People' objects&amp;gt;, '__doc__': None, 'name': &amp;lt;__main__.Typed object at 0x1080b2a58&amp;gt;, 'age': &amp;lt;__main__.Typed object at 0x1080b2ef0&amp;gt;, 'salary': &amp;lt;__main__.Typed object at 0x1080b2c18&amp;gt;}
set---&amp;gt; &amp;lt;__main__.People object at 0x1080b22e8&amp;gt; nick
set---&amp;gt; &amp;lt;__main__.People object at 0x1080b22e8&amp;gt; 18
set---&amp;gt; &amp;lt;__main__.People object at 0x1080b22e8&amp;gt; 3333.3&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;描述符是可以实现大部分python类特性中的底层魔法，包括@classmethod，@staticmethd，@property甚至是__slots__属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;描述父是很多高级库和框架的重要工具之一，描述符通常是使用到装饰器或者元类的大型框架中的一个组件.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_103-%E6%8F%8F%E8%BF%B0%E7%AC%A6(__get__,__set__,__delete__)-%E7%A7%81%E4%BA%BA%E8%AE%A2%E5%88%B6.jpg&quot; alt=&quot;103-描述符(get,set,delete)-私人订制.jpg&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;利用描述符原理完成一个自定制@property，实现延迟计算（本质就是把一个函数属性利用装饰器原理做成一个描述符：类的属性字典中函数名为key，value为描述符类产生的对象）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;property回顾&quot;&gt;property回顾&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Room:
    def __init__(self, name, width, length):
        self.name = name
        self.width = width
        self.length = length

    @property
    def area(self):
        return self.width * self.length


r1 = Room('alex', 1, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(r1.area)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定制property-1&quot;&gt;自定制property&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Lazyproperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        print('这是我们自己定制的静态属性，r1.area实际是要执行r1.area()')
        if instance is None:
            return self
        return self.func(instance)  # 此时你应该明白，到底是谁在为你做自动传递self的事情


class Room:
    def __init__(self, name, width, length):
        self.name = name
        self.width = width
        self.length = length

    @Lazyproperty  # area=Lazyproperty(area) 相当于定义了一个类属性,即描述符
    def area(self):
        return self.width * self.length


r1 = Room('alex', 1, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(r1.area)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现延迟计算功能&quot;&gt;实现延迟计算功能&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Lazyproperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        print('这是我们自己定制的静态属性，r1.area实际是要执行r1.area()')
        if instance is None:
            return self
        else:
            print('---&amp;gt;')
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)  # 计算一次就缓存到实例的属性字典中
            return value


class Room:
    def __init__(self, name, width, length):
        self.name = name
        self.width = width
        self.length = length

    @Lazyproperty  # area=Lazyproperty(area) 相当于'定义了一个类属性,即描述符'
    def area(self):
        return self.width * self.length


r1 = Room('alex', 1, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(r1.area)  # 先从自己的属性字典找,没有再去类的中找,然后出发了area的__get__方法&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
---&amp;gt;
1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(r1.area)  # 先从自己的属性字典找,找到了,是上次计算的结果,这样就不用每执行一次都去计算&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;一个小的改动，延迟计算的美梦就破碎了&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Lazyproperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        print('这是我们自己定制的静态属性，r1.area实际是要执行r1.area()')
        if instance is None:
            return self
        else:
            value = self.func(instance)
            instance.__dict__[self.func.__name__] = value
            return value
        # return self.func(instance) # 此时你应该明白,到底是谁在为你做自动传递self的事情
    def __set__(self, instance, value):
        print('hahahahahah')


class Room:
    def __init__(self, name, width, length):
        self.name = name
        self.width = width
        self.length = length

    @Lazyproperty  # area=Lazyproperty(area) 相当于定义了一个类属性,即描述符
    def area(self):
        return self.width * self.length&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(Room.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'__module__': '__main__', '__init__': &amp;lt;function Room.__init__ at 0x107d53620&amp;gt;, 'area': &amp;lt;__main__.Lazyproperty object at 0x107ba3860&amp;gt;, '__dict__': &amp;lt;attribute '__dict__' of 'Room' objects&amp;gt;, '__weakref__': &amp;lt;attribute '__weakref__' of 'Room' objects&amp;gt;, '__doc__': None}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;r1 = Room('alex', 1, 1)
print(r1.area)
print(r1.area)
print(r1.area)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
1
这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
1
这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(
    r1.area
)  #缓存功能失效,每次都去找描述符了,为何,因为描述符实现了set方法,它由非数据描述符变成了数据描述符,数据描述符比实例属性有更高的优先级,因而所有的属性操作都去找描述符了&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这是我们自己定制的静态属性，r1.area实际是要执行r1.area()
1&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ClassMethod:
    def __init__(self, func):
        self.func = func

    def __get__(
            self, instance,
            owner):  #类来调用,instance为None,owner为类本身,实例来调用,instance为实例,owner为类本身,
        def feedback():
            print('在这里可以加功能啊...')
            return self.func(owner)

        return feedback


class People:
    name = 'nick'

    @ClassMethod  # say_hi=ClassMethod(say_hi)
    def say_hi(cls):
        print('你好啊,帅哥 %s' % cls.name)


People.say_hi()

p1 = People()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
你好啊,帅哥 nick&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.say_hi()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
你好啊,帅哥 nick&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;疑问,类方法如果有参数呢,好说,好说&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ClassMethod:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner
                ):  # 类来调用,instance为None,owner为类本身,实例来调用,instance为实例,owner为类本身,
        def feedback(*args, **kwargs):
            print('在这里可以加功能啊...')
            return self.func(owner, *args, **kwargs)

        return feedback


class People:
    name = 'nick'

    @ClassMethod  # say_hi=ClassMethod(say_hi)
    def say_hi(cls, msg):
        print('你好啊,帅哥 %s %s' % (cls.name, msg))


People.say_hi('你是那偷心的贼')

p1 = People()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
你好啊,帅哥 nick 你是那偷心的贼&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.say_hi('你是那偷心的贼')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
你好啊,帅哥 nick 你是那偷心的贼&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class StaticMethod:
    def __init__(self, func):
        self.func = func

    def __get__(
            self, instance,
            owner):  # 类来调用，instance为None，owner为类本身，实例来调用，instance为实例，owner为类本身
        def feedback(*args, **kwargs):
            print('在这里可以加功能啊...')
            return self.func(*args, **kwargs)

        return feedback


class People:
    @StaticMethod  # say_hi = StaticMethod(say_hi)
    def say_hi(x, y, z):
        print('------&amp;gt;', x, y, z)


People.say_hi(1, 2, 3)

p1 = People()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
------&amp;gt; 1 2 3&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;p1.say_hi(4, 5, 6)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;在这里可以加功能啊...
------&amp;gt; 4 5 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_103-%E6%8F%8F%E8%BF%B0%E7%AC%A6(__get__,__set__,__delete__)-%E6%94%BE%E5%81%87.jpg&quot; alt=&quot;103-描述符(get,set,delete)-放假.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 10:13:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>[TOC] 预警.gif) 描述符 描述符是什么：描述符本质就是一个新式类，在这个新式类中，至少实现了\_\_get\_\_()，\_\_set\_\_()，\_\_delete\_\_()中的一个，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nickchen121/p/10991295.html</dc:identifier>
</item>
<item>
<title>性能测试浅谈 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10982665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10982665.html</guid>
<description>&lt;p&gt;早期的性能测试更关注后端服务的处理能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235624519-2097999132.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个用户去访问一个页面的请求过程，如上图。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据传输时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当你从浏览器输入网址，敲下回车，开始...&lt;/p&gt;
&lt;p&gt;真实的用户场景请不要忽视数据传输时间，想想你给远方的朋友写信，信件需要经过不同的交通运输工具送到朋友手上；当你的朋友写好了信，再次通过不同的交通工具送到你的手上。&lt;/p&gt;
&lt;p&gt;性能测试过程中的请求与响应过程也类似，当我们发送一个请求，到服务器接收到这个请求需要时间，系统处理完后将处理结果返回给我们也需要时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端处理时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从我们的浏览器得到响应数据开始...&lt;/p&gt;
&lt;p&gt;真实的用户场景不要忽略客户端的处理时间，你拿到信是不是就知道内容了？当然不是，你得拆开信封，把信的内容读一篇吧。&lt;/p&gt;
&lt;p&gt;我们的浏览器也是如些，浏览器拿到的只有一些HTML、JS、CSS、图片... 的资源，更底层当然是二进制数据，需要花费时间把他们渲染成我们想要的网页。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统处理时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从当系统得到请求后开始...&lt;/p&gt;
&lt;p&gt;这是我们的性能测试主要关心的时间，当系统得到请求后，需要对请求进行处理，可能需要查询数据库服务，也可能需要调用其它的服务，最终生成处理结果并返回给客户端。&lt;/p&gt;
&lt;p&gt;然而，我们在LoadRunner、JMeter进行性能测试的时候，是没有客户端处理时间的，你当然可以同时开100个网页（可以用多线程+Selenium实现）访问某网站试试，这没对服务器产生多少压力，先把自己的电脑搞挂了。&lt;/p&gt;
&lt;p&gt;网络传输时间往往也很难模拟真实的场景，因为你网站的用户来可能来自世界各地，我们总不能在世界各地都搞一个客户端，就算可以，我们通过什么方式让他们“同时”发请求给服务器呢？&lt;/p&gt;
&lt;p&gt;各位读者，我们约定明天早上8点一起出发去北京全聚德买一只烤鸭，把全聚德搞断货，这可能吗？虽然，我们的出发时间是一样的，但因为距离不一样，到达时间肯定不一样，根本对全聚德够不成并发压力嘛！。所以，我们的性能测试都是放到局域网进行的，就是为了尽量降低传输时间，模拟并发。&lt;/p&gt;
&lt;p&gt;理解了这些，我们知道，我们所做的性能测试是无法模拟真实的情况，网络的传输时间太过复杂，客户端处理时间取决于用户的设备。我们能做的就是尽量保证服务器端的处理时间，以及在一定的时间可以支撑的并发量。&lt;/p&gt;
&lt;p&gt;随着，技术的发展，越来越多的系统开始做前后端分离。后端，服务只提供接口，前端在不同的设备上以不同的方式展示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235657835-295374475.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这样的架构下，我们的性能测试也划分为后端性能和前端性能。&lt;/p&gt;
&lt;p&gt;后端性能其实就是接口性能。我们更多的时候不再设计模拟用户场景，而是针对单个或一组关联接口进行性能测试，这其实一定程度降低了测试的难度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235722884-137907895.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，不管是否为前后端分离的架构，大多时候他们走的都是HTTP协议。如果是前后端不分离，当你发送一个请求时，它会返回一堆数据：HTML、JS、CSS、图片、音视频...等，如果是前后端分离的架构，那么后端API返回的数据就单纯的多了，一般为JSON格式的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235745875-1032476505.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然只做后端性能是不够的，当用户看到一个页面时，不单单只有后端返回的接口数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235758359-1081320320.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我在访问一个页面时候得到的所有数据。在你的后端服务没有达到最大并发的前提下，那么影响用户体验的就两方面，一个是请求的个数，另一个是请求的文件大小。&lt;/p&gt;
&lt;p&gt;这其实很好理解，你在群里来喊了一声，请大家吃饭，结果稀稀拉拉来了100多人，从前一天晚上喝到第二下午，你肯定受不了；而且，其中还有几个哥们特能喝，“一直喝”就是不倒，你是不是更受不了了。 如果只来了三、五个好友，大家随意小酌几杯各自回家，不是很好！？&lt;/p&gt;
&lt;p&gt;所以，减少请求的个数，比如有些JS文件可以做合并；减少请求的大小，比如，有些图片做压缩处理。做好这两点，自然用户体验就会好很多，前端性能其实不需要通过“并发”来测试的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201906/311516-20190605235831814-115887491.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图为性能一款App使用的性能指标，这里的侧重点在于App拿到接口数据之后如何更快的把页面渲染出来，以及在渲染的过程中对硬件资源的消耗情况，还有用户在不同页面的切换的流畅度。&lt;/p&gt;
&lt;p&gt;谁让手机硬件一直跟不上App的需求，所以，我们才需要关心App对移动设备的CPU、内存、FPS、耗电、流量的使用情况。&lt;/p&gt;
&lt;p&gt;~~~~&lt;br/&gt;为什么要写这么一篇文章，因为有一个同学说，他们老大让他用JMeter测试系统的性能，还要计算页面完全加载完成的时间，我想你读了这篇文章之后应该就不会再提这样的“要求”了。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Jun 2019 09:50:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>浅谈性能测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/10982665.html</dc:identifier>
</item>
</channel>
</rss>