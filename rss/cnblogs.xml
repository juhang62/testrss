<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux基础命令---mkdir - 一生有你llx</title>
<link>http://www.cnblogs.com/wj78080458/p/10034594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj78080458/p/10034594.html</guid>
<description>&lt;p&gt;&lt;strong&gt;mkdir&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      如果目录不存在，那么就创建目录。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      此命令的适用范围：RedHat、RHEL、Ubuntu、CentOS、SUSE、openSUSE、Fedora。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      mkdir [&lt;/strong&gt;&lt;strong&gt;选项]  dir&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、选项列表&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;--version&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;显示命令版本信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;--help&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;显示帮助文档&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;-m | --mode=MODE&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;设置目录的权限&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;-p | --parents&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建多层目录的时候，如果父目录不存在，那么首先创建父目录&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28%&quot;&gt;
&lt;p&gt;-v | --vervose&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71%&quot;&gt;
&lt;p&gt;显示执行过程&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      1）创建一个最大权限的目录 &lt;/p&gt;
&lt;table class=&quot;a&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;836&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]#&lt;strong&gt; mkdir -m 777 test&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]# &lt;strong&gt;ls -l&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总用量&lt;/code&gt;&lt;code&gt; 360&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-rw-r--r-- 1 root root      0 9&lt;/code&gt;&lt;code&gt;月&lt;/code&gt;&lt;code&gt;   7 09:11 1.c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-rw-r--r-- 1 root root 358400 9&lt;/code&gt;&lt;code&gt;月&lt;/code&gt;&lt;code&gt;   7 15:46 my.iso&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;drwxrwxrwx 2 root root   4096 9&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;月&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;  10 11:33 test&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;      2）创建目录及其父目录 &lt;/p&gt;
&lt;table class=&quot;a&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;836&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]# &lt;strong&gt;mkdir -v test01/test           //&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;test01&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;不存在，无法在其下创建&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;test&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir: &lt;/code&gt;&lt;code&gt;无法创建目录&lt;/code&gt;&lt;code&gt;&quot;test01/test&quot;: &lt;/code&gt;&lt;code&gt;没有那个文件或目录&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[root@localhost weijie]# &lt;strong&gt;mkdir -p -v test01/test         //&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;使用选项&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;-p&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;，当目录&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;test01&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;不存在的时候，首先创建&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;&lt;strong&gt;test01&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir: &lt;/code&gt;&lt;code&gt;已创建目录&lt;/code&gt;&lt;code&gt;&quot;test01&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir: &lt;/code&gt;&lt;code&gt;已创建目录&lt;/code&gt;&lt;code&gt;&quot;test01/test&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;You have new mail in /var/spool/mail/root&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Sat, 08 Dec 2018 23:12:00 +0000</pubDate>
<dc:creator>一生有你llx</dc:creator>
<og:description>mkdir 如果目录不存在，那么就创建目录。 此命令的适用范围：RedHat、RHEL、Ubuntu、CentOS、SUSE、openSUSE、Fedora。 1、语法 mkdir [选项]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj78080458/p/10034594.html</dc:identifier>
</item>
<item>
<title>js基础梳理-如何理解作用域和作用域链？ - 炼心</title>
<link>http://www.cnblogs.com/hezhi/p/10090151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezhi/p/10090151.html</guid>
<description>&lt;p&gt;本文重点是要梳理执行上下文的生命周期中的建立作用域链，在此之前，先回顾下关于作用域的一些知识。&lt;/p&gt;
&lt;h2 id=&quot;什么是作用域scope&quot;&gt;1.什么是作用域(scope)？&lt;/h2&gt;
&lt;p&gt;在《JavaScritp高级程序设计》中并没有找到确切的关于作用域的定义，只是在“4.2执行环境及作用域”中简单说了下执行环境（execution context）的概念。而执行环境其实就是之前&lt;a href=&quot;https://www.cnblogs.com/hezhi/p/10014996.html&quot;&gt;博客：js基础梳理-究竟什么是执行上下文栈（执行栈），执行上下文(可执行代码）？&lt;/a&gt;中的执行上下文。&lt;/p&gt;
&lt;p&gt;而在《JavaScript权威指南》中，对作用域的描述为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;变量作用域：一个变量的作用域（scope）是程序源代码中定义这个变量的区域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在《你不知道的Javascript·上卷》中对作用域的描述则为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;负责收集并维护由所有生命的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来讲，作用域（scope）就是&lt;strong&gt;变量访问规则的有效范围&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作用域外，无法引用作用域内的变量；&lt;/li&gt;
&lt;li&gt;离开作用域后，作用域的变量的内存空间会被清除，比如执行完函数或者关闭浏览器&lt;/li&gt;
&lt;li&gt;作用域与执行上下文是完全不同的两个概念。我曾经也混淆过他们，但是一定要仔细区分。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说得很深奥的样子，其实上面这段话重点用函数作用域与函数执行上下文来区分是最好不过的了。函数作用域是在函数声明的时候就已经确定了，而函数执行上下文是在函数调用时创建的。假如一个函数被调用多次，那么它就会创建多个函数执行上下文，但是函数作用域显然不会跟着函数被调用的次数而发生什么变化。&lt;/p&gt;
&lt;h4 id=&quot;全局作用域&quot;&gt;1.1 全局作用域&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;var foo = 'foo';
console.log(window.foo);   // =&amp;gt; 'foo' &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在浏览器环境中声明变量，该变量会默认成为window对象下的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function foo() {
    name = &quot;bar&quot;
}
foo();
console.log(window.name) // bar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在函数中，如果不加 var 声明一个变量，那么这个变量会默认被声明为全局变量，如果是严格模式，则会报错。&lt;/p&gt;
&lt;p&gt;全局变量会造成命名污染，如果在多处对同一个全局变量进行操作，那么久会覆盖全局变量的定义。同时全局变量数量过多，非常不方便管理。&lt;/p&gt;
&lt;p&gt;这也是为什么jquery要在全局建立&lt;span class=&quot;math inline&quot;&gt;\(变量，其余私有方法属性挂在\)&lt;/span&gt;下的原因。&lt;/p&gt;
&lt;h4 id=&quot;函数作用域&quot;&gt;1.2 函数作用域&lt;/h4&gt;
&lt;p&gt;假如在函数中定义一个局部变量，那么该变量只可以在该函数作用域中被访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function doSomething () {
    var thing = '吃早餐';
}
console.log(thing); // Uncaught ReferenceError: thing is not defined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嵌套函数作用域：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function outer () {
    var thing = '吃早餐';
    function inner () {
        console.log(thing);
    }
    inner();
}

outer();  // 吃早餐&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在外层函数中，嵌套一个内层函数，那么这个内层函数可以向上访问到外层函数中的变量。&lt;/p&gt;
&lt;p&gt;既然内层函数可以访问到外层函数的变量，那如果把内层函数return出来会怎样？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function outer () {
    var thing = '吃早餐';
    
    function inner () {
        console.log(thing);
    }
    
    return inner;
}

var foo = outer();
foo();  // 吃早餐&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面提到，函数执行完后，函数作用域的变量就会被垃圾回收。而这段代码看出当返回了一个访问了外部函数变量的内部函数，最后外部函数的变量得以保存。&lt;/p&gt;
&lt;p&gt;这种当变量存在的函数已经执行结束，但扔可以再次被访问到的方式就是“闭包”。后期会继续对闭包进行梳理。&lt;/p&gt;
&lt;h4 id=&quot;块级作用域&quot;&gt;1.3 块级作用域&lt;/h4&gt;
&lt;p&gt;很多书上都有一句话，javascript没有块级作用域的概念。所谓块级作用域，就是{}包裹的区域。但是在ES6出来以后，这句话并不那么正确了。因为可以用 let 或者 const 声明一个块级作用域的变量或常量。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (let i = 0; i &amp;lt; 10; i++) {
    // ...
}
console.log(i); // Uncaught ReferenceError: i is not defined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现这个例子就会和函数作用域中的第一个例子一样的错误提示。因为变量i只可以在 for循环的{ }块级作用域中被访问了。&lt;/p&gt;
&lt;p&gt;扩散思考：&lt;/p&gt;
&lt;p&gt;究竟什么时候该用let？什么时候该用const？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认使用 const，只有当确实需要改变变量的值的时候才使用let。因为大部分的变量的值在初始化之后不应再改变，而预料之外的变量的修改是很多bug的源头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;词法作用域&quot;&gt;1.4 词法作用域&lt;/h4&gt;
&lt;p&gt;词法作用域，也可以叫做静态作用域。意思是无论函数在哪里调用，词法作用域都只在由函数被声明时所处的位置决定。&lt;br/&gt;既然有静态作用域，那么也有动态作用域。&lt;br/&gt;而动态作用域的作用域则是由函数被调用时执行的位置所决定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var a = 123;
function fn1 () {
    console.log(a);
}
function fn2 () {
    var a = 456;
    fn1();
}
fn2();   // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，最后输出结果 a 的值，来自于 fn1 声明时所在位置访问到的 a 值 123。&lt;br/&gt;所以JS的作用域是静态作用域，也叫词法作用域。&lt;/p&gt;
&lt;p&gt;上面的1.1-1.3可以看做作用域的类型。而这一小节，其实跟上面三小节还是有差别的，并不属于作用域的类型，只是关于作用域的一个补充说明吧。&lt;/p&gt;
&lt;h2 id=&quot;什么是作用域链scope-chain&quot;&gt;2. 什么是作用域链（scope chain）&lt;/h2&gt;
&lt;p&gt;在JS引擎中，通过标识符查找标识符的值，会从当前作用域向上查找，直到作用域找到第一个匹配的标识符位置。就是JS的作用域链。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var a = 1;
function fn1 () {
    var a = 2;
    function fn2 () {
        var a = 3;
        console.log(a);
    }
    fn2 ();
}
fn1(); // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;console.log(a)&lt;/strong&gt; 语句中，JS在查找 a变量标识符的值的时候，会从 fn2 内部向外部函数查找变量声明，它发现fn2内部就已经有了a变量，那么它就不会继续查找了。那么最终结果也就会打印3了。&lt;/p&gt;
&lt;h2 id=&quot;作用域链与执行上下文&quot;&gt;3. 作用域链与执行上下文&lt;/h2&gt;
&lt;p&gt;在此前的&lt;a href=&quot;https://www.cnblogs.com/hezhi/p/10014996.html&quot;&gt;博客：js基础梳理-究竟什么是执行上下文栈（执行栈），执行上下文(可执行代码）？&lt;/a&gt;中讲到执行上下文的生命周期:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;执行上下文的生命周期&quot;&gt;3.执行上下文的生命周期&lt;/h2&gt;
&lt;h4 id=&quot;创建阶段&quot;&gt;3.1 创建阶段&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;生成变量对象（Variable object, VO）&lt;/li&gt;
&lt;li&gt;建立作用域链（Scope chain）&lt;/li&gt;
&lt;li&gt;确定this指向&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;执行阶段&quot;&gt;3.2 执行阶段&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;变量赋值&lt;/li&gt;
&lt;li&gt;函数引用&lt;/li&gt;
&lt;li&gt;执行其他代码&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;上面做了那么多铺垫，其实重点是想梳理这一小节。&lt;br/&gt;下面，以一个函数的创建和激活两个时期来讲解作用域链是如何创建及变化的。&lt;/p&gt;
&lt;h4 id=&quot;函数创建阶段&quot;&gt;3.1函数创建阶段&lt;/h4&gt;
&lt;p&gt;上文中讲到，函数的作用域在函数定义的时候就决定了。&lt;/p&gt;
&lt;p&gt;这是因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，但是注意：此时[[scope]]并不代表完整的作用域链，因为在创建阶段，它还没有包括自己的作用域。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function foo () {
    function bar () {
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数创建时，各自的[[scope]]为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foo.[[scope]] = [
    globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.AO
];&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数激活阶段&quot;&gt;3.2 函数激活阶段&lt;/h4&gt;
&lt;p&gt;当函数激活时，进入函数上下文，创建VO/AO后，就会将活动对象添加到作用域链的前端。&lt;/p&gt;
&lt;p&gt;这时候执行上下文的作用域链，命名为 Scope:&lt;/p&gt;
&lt;p&gt;Scope = [AO].concat([[scope]]);&lt;/p&gt;
&lt;p&gt;至此，作用域链创建完毕。&lt;/p&gt;
&lt;h4 id=&quot;举个栗子&quot;&gt;3.3 举个栗子&lt;/h4&gt;
&lt;p&gt;以下面的例子为例，结合之前的变量对象，活动对象和执行上下文栈，总结一下函数执行上下文中作用域链和变量对象的创建过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var x = 10;
 
function foo() {
  var y = 20;
 
  function bar() {
    var z = 30;
    console.log(x +  y + z);
  }
 
  bar();
}
 
foo(); // 60&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家肯定都知道打印结果会是60。但是从第一行代码开始到最后一行代码结束，整个代码的执行上下文栈以及作用域链是怎样变化的呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 第一步：进入全局上下文，此时的执行上下文栈是这样：
ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    }
];

// 第二步：foo函数被创建，此时的执行上下文栈没有变化，但是创建了foo函数的作用域，保存作用域链到内部属性[[scope]]。
ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    }
];
foo.[[scope]] = [
    globalContext.VO
];

// 第三步：foo函数执行，进入foo函数上下文的创建阶段
// 这个阶段它做了三件事：
// 1.复制之前的foo.[[scope]]属性到foo函数上下文下，创建foo函数的作用域链；
// 2. 创建foo函数上下文的变量对象,并初始化变量对象，依次加入形参，函数声明，变量声明
// 3. 把foo函数上下文的变量对象加入到第一步创建的foo函数作用域链的最前面。
// 最终，经过这三个步骤之后，整个执行上下文栈是这样

ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    },
    &amp;lt;foo&amp;gt;functionContext: {
        VO: {
            arguments: {
                length: 0
            },
            bar: &amp;lt;reference to function bar() {}&amp;gt;,
            y: undefined
        },
        Scope: [foo.VO, globalContext.VO]
    }
];

foo.[[scope]] = [
    foo.VO,
    globalContext.VO
];

// 第四步：foo函数执行，进入foo函数上下文的执行阶段。
// 这个阶段又做了以下2件事：
// 1. 把foo执行上下文的变量对象VO改成了活动对象AO，并且修改AO中变量的值
// 2. 发现创建了一个 bar函数，就保存了bar函数的所有父变量对象到bar函数的[[scope]]属性上。


ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    },
    &amp;lt;foo&amp;gt;functionContext: {
        AO: {
            arguments: {
                length: 0
            },
            bar: &amp;lt;reference to function bar() {}&amp;gt;,
            y: 20
        },
        Scope: [foo.AO, globalContext.VO]
    }
];

foo.[[scope]] = [
    foo.AO,
    globalContext.VO
];

bar.[[scope]] = [
    foo.AO,
    globalContext.VO
];

// 第五步，bar函数执行，进入bar函数上下文的创建阶段
// 与第三步类似，也做了三件事，只不过主体变成了bar
// 1.复制之前的bar.[[scope]]属性到bar函数上下文下，创建foo函数的作用域链；
// 2. 创建bar函数上下文的变量对象,并初始化变量对象，依次加入形参，函数声明，变量声明
// 3. 把bar函数上下文的变量对象加入到第一步创建的bar函数作用域链的最前面。
// 最终，经过这三个步骤之后，整个执行上下文栈是这样

ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    },
    &amp;lt;foo&amp;gt;functionContext: {
        AO: {
            arguments: {
                length: 0
            },
            bar: &amp;lt;reference to function bar() {}&amp;gt;,
            y: 20
        },
        Scope: [foo.AO, globalContext.VO]
    },
    &amp;lt;bar&amp;gt;functionContext: {
        VO: {
            arguments: {
                length: 0
            },
            z: undefined
        },
        Scope: [bar.VO, foo.AO, globalContext.VO]
    }
];

foo.[[scope]] = [
    foo.AO,
    globalContext.VO
];

bar.[[scope]] = [
    bar.VO,
    foo.AO,
    globalContext.VO
];

// 第六步：bar函数执行，进入bar函数上下文的执行阶段
// 与第四步类似。不过此时bar函数里面不会再创建新的函数上下文了
// 1. 把bar执行上下文的变量对象VO改成了活动对象AO，并且修改AO中变量的值
ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    },
    &amp;lt;foo&amp;gt;functionContext: {
        AO: {
            arguments: {
                length: 0
            },
            bar: &amp;lt;reference to function bar() {}&amp;gt;,
            y: 20
        },
        Scope: [foo.AO, globalContext.VO]
    },
    &amp;lt;bar&amp;gt;functionContext: {
        AO: {
            arguments: {
                length: 0
            },
            z: 30
        },
        Scope: [bar.AO, foo.AO, globalContext.VO]
    }
];

foo.[[scope]] = [
    foo.AO,
    globalContext.VO
];

bar.[[scope]] = [
    bar.AO,
    foo.AO,
    globalContext.VO
];

// 第七步：执行bar函数中的console.log(x + y +z)，查找x,y,z三个标识符

- &quot;x&quot;
-- &amp;lt;bar&amp;gt;functionContext.AO   // 没找到,继续到foo.AO中找
-- &amp;lt;foo&amp;gt;functionContext.AO   // 还没找到，再往globalContext.VO中找
-- globalContext.VO     // 找到了，值为 10

- &quot;y&quot;
-- &amp;lt;bar&amp;gt;functionContext.AO   // 没找到,继续到foo.AO中找
-- &amp;lt;foo&amp;gt;functionContext.AO   // 找到了，值为20

-- &quot;z&quot;
-- &amp;lt;bar&amp;gt;functionContext.AO   // 找到了，值为 30

打印结果： 60。

// 第八步：bar函数执行完毕，将其从执行上下文栈中弹出，foo函数执行完毕，将其从执行上下文栈中弹出。最终，执行上下文栈，只剩下globalContext

ECStack = [
    globalContext: {
        VO: {
            foo: &amp;lt;reference to function foo() {}&amp;gt;,
            x: 10
        }
    }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉其实可以简化理解一下，把第三四步，第五六步分别分成一个步骤。&lt;/p&gt;
&lt;p&gt;打算每周定一个小主题，可能是基础知识巩固，也可能是自己学习新知识的记录。在下一篇博文中，将对this指向问题进行梳理。如果你也感兴趣，也可以去搜集下相关资料，到时候大家共同学习探讨一下。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 22:10:00 +0000</pubDate>
<dc:creator>炼心</dc:creator>
<og:description>本文重点是要梳理执行上下文的生命周期中的建立作用域链，在此之前，先回顾下关于作用域的一些知识。 1.什么是作用域(scope)？ 在《JavaScritp高级程序设计》中并没有找到确切的关于作用域的定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hezhi/p/10090151.html</dc:identifier>
</item>
<item>
<title>今日头条Marketing API小工具(.Net Core版本) - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/10055384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/10055384.html</guid>
<description>&lt;p&gt;　　由于工作原因，需要用到今日头条的Marketing API做一些广告投放的定制化开发。然后看现在网上也没多少关于头条Marketing API的文章，于是便就有了该篇文章。&lt;/p&gt;
&lt;p&gt;　　头条Marketing API主页地址：&lt;a href=&quot;https://ad.toutiao.com/openapi/index.html&quot; target=&quot;_blank&quot;&gt;https://ad.toutiao.com/openapi/index.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　头条Marketing API开发文档：&lt;a href=&quot;https://ad.toutiao.com/openapi/doc/index.html&quot; target=&quot;_blank&quot;&gt;https://ad.toutiao.com/openapi/doc/index.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;　　典型的OAuth2.0授权流程：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181202213542967-871905117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　1. 首先需要去&lt;a href=&quot;https://ad.toutiao.com/openapi/index.html&quot; target=&quot;_blank&quot;&gt;主页&lt;/a&gt;注册一个开发者账号，并申请一个APPID，设置好回调地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181208113759718-2014828937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　因为从头条重定向回自己的站点只是浏览器行为，所有回调地址填写本机可访问的地址即可（不需要头条能访问），这里是http://localhost:5000/api/auth/callback。&lt;/p&gt;

&lt;p&gt;　　2. 在appsettings.json中设置APPID + Secret&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
    }
  },
  &lt;/span&gt;&quot;AllowedHosts&quot;: &quot;*&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;toutiao&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;appId&quot;: &quot;{Your appId}&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;secret&quot;: &quot;{Your secret}&quot;&lt;span&gt;
  } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 启动项目，即可直接在swagger中使用&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181208220531220-1090097774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209013005512-1004737948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　1. 在launchsettings.json中设置启动地址为http://localhost:5000/api/auth&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&quot;ToutiaoApi&quot;&lt;span&gt;: {
  &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&quot;launchUrl&quot;: &quot;api/auth&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:5000&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 浏览器访问地址http://localhost:5000/api/auth，会重定向到今日头条的认证地址，并且拼接好参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Redirect()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://ad.toutiao.com/openapi/audit/oauth.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redirectUrl = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Request.Scheme}://{Request.Host}/api/auth/callback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{authUrl}?app_id={_setting.AppId}&amp;amp;state=&amp;amp;scope=[\&quot;ad_service\&quot;,\&quot;report_service\&quot;,\&quot;dmp_service\&quot;,\&quot;account_service\&quot;]&amp;amp;redirect_uri={redirectUrl}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Redirect(url);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 跳转到今日头条的认证地址并点击“同意授权”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209014150125-1426783461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　4. 重定向回http://localhost:5000/api/auth/callback并带回了auth_code参数&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209014743503-613204220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5. 利用AuthCode + AppId + Secret调用头条认证API获取AccessToken，并把AccessToken缓存到内存中，然后重定向回swagger&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;callback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Callback([FromQuery(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auth_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; authCode)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://ad.toutiao.com/open_api/oauth2/access_token/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthRequest
    {
        AppId &lt;/span&gt;=&lt;span&gt; _setting.AppId,
        Secret &lt;/span&gt;=&lt;span&gt; _setting.Secret,
        AuthCode &lt;/span&gt;=&lt;span&gt; authCode
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; _restClient.PostAsync&amp;lt;AuthResponse&amp;gt;&lt;span&gt;(url, request);
    response.EnsureSuccess();

    _cache.Set(ToutiaoCacheKey.AccessToken, response.Data.AccessToken);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　0. 示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取广告计划（新版）
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;advertiserId&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;广告主ID&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;page&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;页数，默认值: 1&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pageSize&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;页面大小，默认值: 10，最大值：100&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Get([FromQuery] &lt;span&gt;string&lt;/span&gt; advertiserId, [FromQuery]&lt;span&gt;int&lt;/span&gt; page = &lt;span&gt;1&lt;/span&gt;, [FromQuery]&lt;span&gt;int&lt;/span&gt; pageSize = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://ad.toutiao.com/open_api/2/ad/get/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?advertiser_id=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + advertiserId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;page=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + page + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;page_size=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; pageSize;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; _restClient.GetAsync&amp;lt;DynamicResponse&amp;gt;(url, _cache.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(ToutiaoCacheKey.AccessToken));
    response.EnsureSuccess();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(response);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1. 根据文档拼接对应参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://ad.toutiao.com/open_api/2/ad/get/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?advertiser_id=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + advertiserId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;page=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + page + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;page_size=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + pageSize;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 从缓存中取出之前得到的AccessToken&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_cache.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(ToutiaoCacheKey.AccessToken)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 构造请求头信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
client.DefaultRequestHeaders.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Access-Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, accessToken);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4. 调用API，并把返回的json反序列化为dynamic类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; _restClient.GetAsync&amp;lt;DynamicResponse&amp;gt;(url, _cache.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(ToutiaoCacheKey.AccessToken));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 输出结果到浏览器&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;说明：示例中只有查询类API，没有操作类型的API，主要是考虑到操作可能会影响到现有业务。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;　　代码调用操作类型的API时，可能需要构建请求json对应的实体，这里可以使用Visual Studio的选择性编辑功能，快速生成对象。&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　1. 拷贝json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;advertiser_id&quot;: 0&lt;span&gt;,
    &lt;/span&gt;&quot;campaign_name&quot;: &quot;xxx&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;budget&quot;: 1000&lt;span&gt;,
    &lt;/span&gt;&quot;landing_type&quot;: &quot;LINK&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;budget_mode&quot;: &quot;BUDGET_MODE_DAY&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 新建一个cs文件，点击Visual Studio菜单栏的“编辑” -&amp;gt; “选择性编辑” -&amp;gt; “保存json为类”&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209021221915-1549811598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209022515962-715941662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. 设置JsonProperty（可选，规范、美观考虑）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201812/182190-20181209021803824-2139966841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其实，头条的开发文档中有提供操作API的示例json，但是示例json的字段有些不全，而请求API的结果基本包含了操作API的字段。&lt;/p&gt;
&lt;p&gt;　　因此，可以使用操作API的返回json来生成操作请求。同时，这个小工具也可以做一些前期的简单查询。&lt;/p&gt;


&lt;p&gt;　　&lt;a href=&quot;https://github.com/ErikXu/ToutiaoApi&quot; target=&quot;_blank&quot;&gt;https://github.com/ErikXu/ToutiaoApi&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 08 Dec 2018 18:29:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<og:description>前言 由于工作原因，需要用到今日头条的Marketing API做一些广告投放的定制化开发。然后看现在网上也没多少关于头条Marketing API的文章，于是便就有了该篇文章。 头条Marketin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/10055384.html</dc:identifier>
</item>
<item>
<title>用户认证：基于jwt和session的区别和优缺点 - yuanrw</title>
<link>http://www.cnblogs.com/yuanrw/p/10089796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanrw/p/10089796.html</guid>
<description>&lt;h2 class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;背景知识：&lt;/h2&gt;
&lt;h3 id=&quot;f3ce&quot; class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;Authentication和Authorization的区别：&lt;/h3&gt;
&lt;p id=&quot;f3ce&quot; class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;Authentication：用户认证，指的是验证用户的身份，例如你希望以小A的身份登录，那么应用程序需要通过用户名和密码确认你真的是小A。&lt;/p&gt;
&lt;p id=&quot;f3ce&quot; class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;Authorization：授权，指的是确认你的身份之后提供给你权限，例如用户小A可以修改数据，而用户小B只能阅读数据。&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;由于http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态。&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;目前主流的用户认证方法有基于token和基于session两种方式。&lt;/p&gt;

&lt;p&gt;基于session的认证流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201812/1500605-20181208212640810-374114842.png&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;code&gt;1. 用户输入其登录信息&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;2. 服务器验证信息是否正确，并创建一个session，然后将其存储在数据库中&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;3. 服务器为用户生成一个sessionId，将具有sesssionId的Cookie将放置在用户浏览器中&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;4. 在后续请求中，会根据数据库验证sessionID，如果有效，则接受请求&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;5. 一旦用户注销应用程序，会话将在客户端和服务器端都被销毁&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;最常用的是JSON Web Token（jwt）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201812/1500605-20181208214418102-1938938567.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1. 用户输入其登录信息&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2. 服务器验证信息是否正确，并返回已签名的token&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3. token储在客户端，例如存在local storage或cookie中&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4. 之后的HTTP请求都将token添加到请求头里&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5. 服务器解码JWT，并且如果令牌有效，则接受请求&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;6. 一旦用户注销，令牌将在客户端被销毁，不需要与服务器进行交互一个关键是，令牌是无状态的。后端服务器不需要保存令牌或当前session的记录。&lt;/code&gt;&lt;/p&gt;


&lt;h3&gt;jwt的认证原理：&lt;/h3&gt;
&lt;p&gt;一个jwt实际上就是一个字符串，它由三部分组成，&lt;strong&gt;头部&lt;/strong&gt;、&lt;strong&gt;载荷&lt;/strong&gt;与&lt;strong&gt;签名&lt;/strong&gt;，这三个部分都是json格式。&lt;/p&gt;

&lt;p&gt;头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JWT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HS256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，我们说明了这是一个JWT，并且我们所用的签名算法是HS256算法。&lt;/p&gt;

&lt;h4 id=&quot;载荷（Payload）&quot;&gt;载荷（Payload）&lt;/h4&gt;
&lt;p&gt;载荷可以用来放一些不敏感的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John Wu JWT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1441593502&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1441594722&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jrocket@example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from_user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target_user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面的前五个字段都是由JWT的标准所定义的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;iss&lt;/code&gt;: 该JWT的签发者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sub&lt;/code&gt;: 该JWT所面向的用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aud&lt;/code&gt;: 接收该JWT的一方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exp&lt;/code&gt;(expires): 什么时候过期，这里是一个Unix时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iat&lt;/code&gt;(issued at): 在什么时候签发的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把头部和载荷分别进行Base64编码之后得到两个字符串，然后再将这两个编码后的字符串用英文句号&lt;code&gt;.&lt;/code&gt;连接在一起（头部在前），形成新的字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;签名（&lt;span class=&quot;keyword&quot;&gt;signature&lt;/span&gt;）&lt;/h4&gt;
&lt;p&gt;最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。加密后的内容也是一个字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的jwt。header部分和payload部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的signature部分，服务端也就无法通过，在jwt中，消息体是透明的，使用签名可以保证消息不被篡改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
&lt;/pre&gt;&lt;/div&gt;


&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;基于session和基于jwt的方式的主要区别就是用户的状态保存的位置，session是保存在服务端的，而jwt是保存在客户端的。&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;jwt的优点：&lt;/h3&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;1. 可扩展性好&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要。&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;2. 无状态&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt;jwt不在服务端存储任何状态。RESTful API的原则之一是无状态，发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。另外jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。&lt;/p&gt;
&lt;p class=&quot;graf graf--h3 graf--leading graf--title&quot;&gt; &lt;/p&gt;
&lt;h3&gt;jwt的缺点：&lt;/h3&gt;
&lt;p&gt;1. 安全性&lt;/p&gt;
&lt;p&gt;由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。&lt;/p&gt;
&lt;p&gt;2. 性能&lt;/p&gt;
&lt;p&gt;jwt太长。由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。并且用户在系统中的每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。&lt;/p&gt;
&lt;p&gt;3. 一次性&lt;/p&gt;
&lt;p&gt;无状态是jwt的特点，但也导致了这个问题，jwt是一次性的。想修改里面的内容，就必须签发一个新的jwt。&lt;/p&gt;
&lt;p&gt;（1）无法废弃&lt;/p&gt;
&lt;p&gt;通过上面jwt的验证机制可以看出来，一旦签发一个jwt，在到期之前就会始终有效，无法中途废弃。例如你在payload中存储了一些信息，当信息需要更新时，则重新签发一个jwt，但是由于旧的jwt还没过期，拿着这个旧的jwt依旧可以登录，那登录后服务端从jwt中拿到的信息就是过时的。为了解决这个问题，我们就需要在服务端部署额外的逻辑，例如设置一个黑名单，一旦签发了新的jwt，那么旧的就加入黑名单（比如存到redis里面），避免被再次使用。&lt;/p&gt;
&lt;p&gt;（2）续签&lt;/p&gt;
&lt;p&gt;如果你使用jwt做会话管理，传统的cookie续签方案一般都是框架自带的，session有效期30分钟，30分钟内如果有访问，有效期被刷新至30分钟。一样的道理，要改变jwt的有效时间，就要签发新的jwt。最简单的一种方式是每次请求刷新jwt，即每个http请求都返回一个新的jwt。这个方法不仅暴力不优雅，而且每次请求都要做jwt的加密解密，会带来性能问题。另一种方法是在redis中单独会每个jwt设置过期时间，每次访问时刷新jwt的过期时间。&lt;/p&gt;

&lt;p&gt;可以看出想要破解jwt一次性的特性，就需要在服务端存储jwt的状态。但是引入 redis 之后，就把无状态的jwt硬生生变成了有状态了，违背了jwt的初衷。而且这个方案和session都差不多了。&lt;/p&gt;


&lt;p&gt;适合使用jwt的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有效期短&lt;/li&gt;
&lt;li&gt;只希望被使用一次&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。这种场景就适合使用jwt。&lt;/p&gt;
&lt;p&gt;而由于jwt具有一次性的特性。单点登录和会话管理非常不适合用jwt，如果在服务端部署额外的逻辑存储jwt的状态，那还不如使用session。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Dec 2018 16:56:00 +0000</pubDate>
<dc:creator>yuanrw</dc:creator>
<og:description>背景知识： Authentication和Authorization的区别： Authentication：用户认证，指的是验证用户的身份，例如你希望以小A的身份登录，那么应用程序需要通过用户名和密码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanrw/p/10089796.html</dc:identifier>
</item>
<item>
<title>理解JSON Web Token (一) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10089894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10089894.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一：理解单系统登录的原理及实现？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;web应用采用的 browser/server 架构的，http是无状态协议的，也就是说用户从A页面跳转到B页面会发起http请求，当服务器返回响应后，当用户A继续访问其他页面的时候，服务器端无法获知该状态，因此会使用cookie/session来记录用户状态的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;session认证状态的基本原理：&lt;/strong&gt;当客户端向服务器端请求时，会创建一个session标识存在客户端的cookie当中，每次请求的时候会将该标识随cookie一起发送到服务器端，服务器端会首先检查这个客户端的请求里面是否包含了一个session的标识，如果已经包含了，那么服务器端就会根据该session标识来判断用户的状态，否则的话，服务器端会创建一个新的session标识传给客户端的cookie当中，以后每次客户端请求的时候，会从cookie中获取该标识传递过去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：理解单点登录的原理？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面使用session/cookie 可以实现单个系统的登录，那如果是多个系统的话，怎么办？难道需要用户一个个去登录? 一个个去注销？我们需要做的是，无论系统有多少个，我们只需要登录一次就够了，其他的相关的系统都可以登录/注销一次即可。&lt;/p&gt;
&lt;p&gt;单系统登录解决方案的核心是cookie，cookie会携带服务器端返回的sessionId, 在浏览器与服务器端维护会话状态。但是我们知道cookie是有限制的，cookie有域的概念，浏览器发送http请求时会自动匹配该本站点的cookie域。而不是所有的cookie。&lt;/p&gt;
&lt;p&gt;那么既然这样，我们很容易想到的是，我们可以把所有子系统的域名都放在一个顶级域名下不就可以了？比如 &quot;*.taobao.com&quot;,然后将他们的cookie域设置为 &quot;taobao.com&quot;， 但是这种并不好：&lt;/p&gt;
&lt;p&gt;第一：因为所有系统的域名需要统一，比如淘宝和天猫的域名就不相同；&lt;br/&gt;第二：应用群各个系统所使用的技术需要相同，比如tomcat服务器叫JESSIONID， 其他的服务器可能不叫这个标识。&lt;br/&gt;第三：cookie的安全性不高的。&lt;/p&gt;
&lt;p&gt;因此我们需要一种全新的方式来实现多系统应用群的登录，这就是单点登录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是单点登录？&lt;/strong&gt;单点登录的全称是 Single Sign On (可以简称为SSO), 在多个系统中只要登录一次，便可以在其他所有系统中得到授权而无需再次登录。&lt;/p&gt;
&lt;p&gt;SSO有一个独立的认证中心，认证中心它可以接受用户的用户名密码等安全信息，其他的地方不接受登录入口，只接受认证中心的间接授权，间接授权它是通过令牌实现的。授权令牌作为参数会发送到各个子系统，子系统拿到令牌，因此会得到了授权，因此就可以创建了局部的会话。局部会话和单系统登录的原理很类似的。&lt;/p&gt;
&lt;p&gt;下面我们来打个比方理解&lt;strong&gt;单点登录的基本原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步：我想登录A系统，A系统发现用户未登录，因此我们需要他们跳转到SSO认证中心(且将自己请求的地址作为参数传递过去)。SSO认证中心发现未登录，会将用户引导到登录页面。&lt;/p&gt;
&lt;p&gt;第二步：用户输入用户名和密码提交申请登录，SSO认证中心会检测用户名和密码信息，如果用户名和密码正确的话，那么用户和SSO认证中心之间会创建一个局部会话，并且创建一个授权令牌。sso认证中心会带着该令牌跳转到A系统那个请求的地址去。&lt;/p&gt;
&lt;p&gt;第三步：A系统会检测该令牌，如果有效的话，就会跳到用户输入的地址页面去，否则，还是返回登录页面，提示错误信息。&lt;/p&gt;
&lt;p&gt;第四步：用户访问系统B，系统B发现用户未登录，会跳转到SSO认证中心(将自己请求的地址作为参数传递过去)，sso认证中心发现用户已经登录了，会跳转回系统B的那个地址去，并带上令牌，系统B拿到令牌，就会去sso认证中心去校验该令牌是否有效。&lt;br/&gt;如果有效的话，说明认证成功了，就会跳转到系统B访问地址的页面上去。&lt;/p&gt;
&lt;p&gt;用户现在已经登录成功了，sso认证中心会与各个子系统建立会话，用户与sso认证中心建立的会话被称为全局会话，用户与各个&lt;br/&gt;子系统建立的会话被称为局部会话，局部会话建立之后，用户访问子系统资源后就不会再通过sso认证中心了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：什么是JSON Web Token？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSON Web Token 是一个开放标准协议，它定义了一种紧凑和自包含的方式，它用于各方之间作为JSON对象安全地传输信息。&lt;/p&gt;
&lt;p&gt;它有如下优点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 可以适用于分布式的单点登录场景。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 可以使用跨域认证解决方案。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3. jwt实现自动刷新token的方案(待认证)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON Web Token，它定义了一种紧凑和自包含的方式，如何理解紧凑和自包含呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;紧凑：就是说这个数据量比较少，并且能通过url参数，http请求提交的数据以及http header的方式来传递。&lt;br/&gt;自包含：这个串可以包含很多信息，比如用户id，订单号id等，如果其他人拿到该信息，就可以拿到关键业务信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1）JWT的基本原理，基本流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 客户端使用账号和密码请求登录接口。&lt;br/&gt;2. 登录成功后服务器使用签名密钥生成JWT，然后返回JWT给客户端。&lt;br/&gt;3. 客户端再次向服务端请求其他接口时会带上JWT。&lt;br/&gt;4. 服务器接收到JWT后验证签名的有效性，对客户端做出相应的响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2）JWT与session的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   session是基于cookie来传输的，session信息是存储在服务器端中，客户端向服务器端发请求时，服务器端会返回一个jessionId给客户端中的cookie中，以后每次请求都会从cookie中的jessionid传递过去，服务器通过cookie中的sessionid获取到当前会话的用户，对于单系统来讲这是没有问题的，但是对于多个系统的话就涉及到session如何共享的问题了，并且随着认证用户增多的话，session会占用大量服务器内存。&lt;/p&gt;
&lt;p&gt;JWT是存储在客户端的，服务器端不需要存储JWT，JWT含有用户id，服务器拿到jwt验证后就可以拿到用户信息了，jwt是无状态的，它不与任何机器绑定的，只要签名密钥足够的安全就能保证jwt的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3）JWT中的token与session中的token安全性比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;session 中安全性问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器端执行session机制的时候会生成session的口令，在Tomcat服务器中，默认会采用 jsessionid 这个值，但是在其他服务器上会有所不同，比如Connect默认会叫 connect_uid， 我们一般把一些敏感的信息放在cookie中是不可取的，但是将口令放在cookie中还是可以的，如果口令被篡改了的话，就丢失了映射关系，也无法修改服务器端存在的数据，并且session的有效期一般为20/30分钟，如果在该时间之内客户端和服务器端没有产生任何交互，服务器端会自动将session自动清空，因此session中想要维护用户一直登陆的状态的话，需要客户端每隔20分钟使用setInterval自动发一个请求给服务器端，这样的话，前后端就有交互，所以就可以一直保持登陆状态。否则的话，每次20分钟后，登陆状态就会失效，每隔20分钟用户需要重新登录，用户体验将会变得不好。session这样做的最主要的是为了安全性考虑，有效期的时间非常短，防止黑客攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JWT方案中安全性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jwt是存储在客户端的，服务器端不需要存储jwt的，客户端每次发送请求时会携带该token，然后到服务器端会验证token是否正确，是否过期了，然后会通过解码出携带的用户的信息的，但是如果token在传输的过程中被攻击者截取了的话，那么对方就可以伪造请求，利用窃取到的token模拟正常请求，实现用户的正常操作，而服务器端完全不知道，因为JWT在服务器端是无状态的，且服务器端不存储jwt的。其实jwt解决的问题是认证和授权的问题，对于安全性的话，还是建议对外公布的接口使用https.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：理解JWT的基本数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本的JWT的数据结构是如下这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoia29uZ3poaSIsImlhdCI6MTU0Mzc1MzczNX0.h1XmQo017udxlFsH-8US9Lg8dJ0IDsSbRbjEN5Nq0l4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上它是由三部分组成的，中间使用 . 分割成三个部分，它是有 Header(头部)， PayLoad(负载)，Signature(签名)组成的。&lt;br/&gt;如：Header.Payload.Signature&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 Header&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Header部分是一个JSON对象，描述JWT的元数据，一般是如下的样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;typ&quot;: &quot;JWT&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;alg&quot;: &quot;HS256&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上json代码，alg属性表示签名的算法，默认是 HMAC SHA256 (缩写为：HS256); typ属性表示这个令牌(token)的类型为JWT. 最后将上面的JSON对象使用 Base64URL的算法转成字符串。&lt;br/&gt;我们可以使用在线的base64编码转下(&lt;a href=&quot;http://tool.oschina.net/encrypt?type=3&quot; target=&quot;_blank&quot;&gt;http://tool.oschina.net/encrypt?type=3&lt;/a&gt;)，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001035774-235227270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上 alg 部分，默认加密的算法是 HMAC SHA256, 当然我们也可以选择下面的加密算法，加密算法有如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001056367-1837637355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 Payload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Payload部分也是一个JSON对象，用来存放实际需要传递的数据，官方提供了7个字段，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;iss(issuer): 签发人
exp (expiration time): 过期时间
sub (subject): 主题
aud (audience): 受众
nbf (Not Before): 生效时间
iat (Issued At): 签发时间
jti (JWT ID): 编号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;payload的中文含义是载荷，它可以理解为存放有效信息的地方。这些有效信息一般包含如下三个部分：&lt;/p&gt;
&lt;p&gt;4.2.1）标准中注册的声明：(如上就是官方提供的7个字段)。&lt;/p&gt;
&lt;p&gt;4.2.2）公共的声明：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但是不建议添加敏感信息，&lt;br/&gt;因为该部分在客户单可解密。&lt;/p&gt;
&lt;p&gt;4.2.3）私有的声明：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，该部分信息&lt;br/&gt;可以理解为明文信息。&lt;/p&gt;
&lt;p&gt;那么定义一个简单的 payload 可以如下结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;sub&quot;: '123456'&lt;span&gt;,
  &lt;/span&gt;&quot;name&quot;: &quot;kongzhi&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;admin&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还是使用如上的base64编码，会编码成如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001204040-1968266581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3 Signature&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Signature 是对前面两部分的签名，防止数据被篡改。签名是把Header和payload对应的json结构进行base64 编码之后得到的两个串用英文句点号拼接起来的，然后会根据header里面的alg指定的前面算法(默认是 HMAC SHA256)生成出来的。&lt;br/&gt;如上header部分使用的是 HS256(即HMAC和SHA256),HMAC是用于生成摘要的，SHA256是用于对摘要进行数字签名的。因此使用HMACSHA256实现signature实现的算法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HMACSHA256(
  base64UrlEncode(header) &lt;/span&gt;+ '.' +&lt;span&gt; 
  base64UrlEncode(payload),
  secret
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上是 Signature 签名算法，最后一个 secret 是加密的密钥的含义。因此通过如上的用法我们就可以拿到JWT了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4 JWT实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JWT的格式是由三个点分割的base64-URL字符串，可以在html或http环境中传递，我们可以简单的使用 &lt;a href=&quot;https://jwt.io/&quot; target=&quot;_blank&quot;&gt;https://jwt.io/&lt;/a&gt; 官网来生成一个JWT了，如下是我前面定义的部分数据：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001352301-505609386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五：node中使用JWT的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nodejs实现的jwt的github代码(&lt;a href=&quot;https://github.com/auth0/node-jsonwebtoken&quot; target=&quot;_blank&quot;&gt;https://github.com/auth0/node-jsonwebtoken&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;它主要有3个方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1 jwt.sign(payload, secretOrPrivateKey, [options, callback])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;payload 参数&lt;/strong&gt;必须是一个object、Buffer、或 string.&lt;br/&gt;注意：exp(过期时间) 只有当payload是object字面量时才可以设置。如果payload不是buffer或string，它会被强制转换为使用的字符串JSON.stringify()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;secretOrPrivateKey 参数&lt;/strong&gt; 是包含HMAC算法的密钥或RSA和ECDSA的PEM编码私钥的string或buffer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;options 参数有如下值：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;algorithm：加密算法（默认值：HS256）
expiresIn：以秒表示或描述时间跨度zeit &lt;/span&gt;/ ms的字符串。如60，&quot;2 days&quot;，&quot;10h&quot;，&quot;7d&quot;&lt;span&gt;，含义是：过期时间
notBefore：以秒表示或描述时间跨度zeit &lt;/span&gt;/ ms的字符串。如：60，&quot;2days&quot;，&quot;10h&quot;，&quot;7d&quot;&lt;span&gt;
audience：Audience，观众
issuer：Issuer，发行者
jwtid：JWT ID
subject：Subject，主题
noTimestamp
header&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法如果是异步方法，则会提供回调，如果是同步的话，则将会 JsonWebToken返回为字符串。&lt;br/&gt;在expiresIn, notBefore, audience, subject, issuer没有默认值时，可以直接在payload中使用 exp, nbf, aud, sub 和 iss分别表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果在jwts中没有指定 noTimestamp的话，在jwts中会包含一个iat，它的含义是使用它来代替实际的时间戳来计算的。&lt;/p&gt;
&lt;p&gt;下面我们在项目中使用node中jsonwebtoken来生成一个JWT的demo了，在index.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个token&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);

const secret &lt;/span&gt;= 'abcdef'&lt;span&gt;;

let token &lt;/span&gt;=&lt;span&gt; jwt.sign({
  name: &lt;/span&gt;'kongzhi'&lt;span&gt;
}, secret, (err, token) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(token);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们进入项目中的目录，执行 node index.js 执行后看到命令行中会打印中的token了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001629557-1685547791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我们也可以设置token的过期时间，比如设置token的有效期为1个小时，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个token&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);

const secret &lt;/span&gt;= 'abcdef'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置token为一个小时有效期&lt;/span&gt;
let token =&lt;span&gt; jwt.sign({
  name: &lt;/span&gt;'kongzhi'&lt;span&gt;,
  exp: Math.floor(Date.now() &lt;/span&gt;/ 1000) + (60 * 60&lt;span&gt;)
}, secret, (err, token) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(token);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.2 jwt.verify(token, secretOrPrivateKey, [options, callback])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法是验证token的合法性&lt;/p&gt;
&lt;p&gt;比如上面生成的token设置为1个小时，生成的token为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoia29uZ3poaSIsImlhdCI6MTU0Mzc2MjYzOSwiZXhwIjoxNTQzNzY2MjM5fQ.6idR7HPpjZIfZ_7j3B3eOnGzbvWouifvvJfeW46zuCw'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们使用 jwt.verify来验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);
const token &lt;/span&gt;= 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoia29uZ3poaSIsImlhdCI6MTU0Mzc2MjYzOSwiZXhwIjoxNTQzNzY2MjM5fQ.6idR7HPpjZIfZ_7j3B3eOnGzbvWouifvvJfeW46zuCw'&lt;span&gt;;
const secret &lt;/span&gt;= 'abcdef'&lt;span&gt;;
jwt.verify(token, secret, (error, decoded) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (error) {
    console.log(error.message);
  }
  console.log(decoded);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行node index.js 代码后，生成如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001750629-334298438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们再来生成一个token，假如该token的有效期为30秒，30秒后，我再使用刚刚生成的token，再去使用 verify去验证下，看是否能验证通过吗？(理论上token失效了，是不能验证通过的，但是我们还是来实践下)。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个token&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);

const secret &lt;/span&gt;= 'abcdef'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置token为30秒的有效期&lt;/span&gt;
let token =&lt;span&gt; jwt.sign({
  name: &lt;/span&gt;'kongzhi'&lt;span&gt;,
  exp: Math.floor(Date.now() &lt;/span&gt;/ 1000) + 30&lt;span&gt;
}, secret, (err, token) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(token);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命令行中生成 jwt为： 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoia29uZ3poaSIsImV4cCI6MTU0Mzc2MzU1MywiaWF0IjoxNTQzNzYzNTIzfQ.79rH3h_ezayYBeNQ2Wj8fGK_wqsEqEPgRTG9uGmvD64';&lt;/p&gt;
&lt;p&gt;然后我们现在使用该token去验证下，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个token&lt;/span&gt;
const jwt = require('jsonwebtoken'&lt;span&gt;);

const token &lt;/span&gt;= 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoia29uZ3poaSIsImV4cCI6MTU0Mzc2MzU1MywiaWF0IjoxNTQzNzYzNTIzfQ.79rH3h_ezayYBeNQ2Wj8fGK_wqsEqEPgRTG9uGmvD64'&lt;span&gt;;
const secret &lt;/span&gt;= 'abcdef'&lt;span&gt;;
jwt.verify(token, secret, (error, decoded) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (error) {
    console.log(error.message);
  }
  console.log(decoded);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行命令，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201812/561794-20181209001857497-716887072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上可以看到token的有效期为30秒，30秒后再执行的话，就会提示jwt过期了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.3 jwt.decode(token, [, options])&lt;/strong&gt;&lt;br/&gt;该方法是 返回解码没有验证签名是否有效的payload。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 16:20:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>理解JSON Web Token (一)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/10089894.html</dc:identifier>
</item>
<item>
<title>AutoCAD 凸度（bulge）的概念及使用WPF函数画图 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;  凸度（bulge）是AutoCAD 中一个非常重要的概念，凸度控制着两点之间弧度大小，弧度的方向。各种复杂的图像有可能就是成百上千的弧线组成的。从AutoCAD中导出的数据也有该值，一般的形式为两个点坐标、一个凸度值。所以理解凸度的概念是处理AutoCAD 文件重要的前提。本文会简要介绍一下凸度的概念，同时会给出如何根据点坐标和凸度划线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凸度演示程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208212055007-1826644492.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 凸度的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;凸度有两个作用控制顶点弧度的大小和弧度的方向。如果通过两个坐标点画弧，会有无数种可能性，所以必须引入第三个参数，来确定经过这两点的唯一弧线，这个参数就是凸度。&lt;/p&gt;
&lt;p&gt;凸度反应了两点之间对应弧度的大小，它的具体值为这段弧所包含角度的&lt;span lang=&quot;en-us&quot;&gt;1/4角度的正切值。两点对应的弧度最大值为无限接近360度，凸度对应的值为接近90度的正切值，所以凸度最大值为无穷大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208205538306-904323122.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208210624300-1124327694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察上图，图B的弧度大于图A的弧度，但是图B的半径小于图A。&lt;/p&gt;
&lt;p&gt;为什么引入凸度值就能唯一确定弧线了？当凸度确定了，其实弧度对应的半径就确定了。考察一下图C，红线标识的部分为一个等腰三角形，等腰三角形底边长度和顶点角度确定了，就能唯一确定一个三角形大小（属于初中几何知识）。等腰三角形的两个腰长度就是圆的半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 根据凸度计算及画图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208211307983-685455345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的画图函数需要的参数也不同，我这里根据具体的画图函数来讲解，如何画图。&lt;/p&gt;
&lt;p&gt;WPF绘图上下文类为DrawingContext，这个类有一个绘图函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DrawGeometry(Brush brush, Pen pen, Geometry geometry);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数很简单，但是这个函数可以画任意图形；因为Geometry 类功能太强大了，这个类可以描述任意几何形状。看一下如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;void&lt;/span&gt; AddArc(PathGeometry pathGeometry, System.Windows.Point point1, System.Windows.Point point2,  &lt;span&gt;double&lt;/span&gt; bulge, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; radius)
        {
            PathFigure pathFigure &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathFigure();
            pathFigure.StartPoint &lt;/span&gt;= point1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起点&lt;/span&gt;
&lt;span&gt;
            ArcSegment arcSegment &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArcSegment();
            arcSegment.Point &lt;/span&gt;= point2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;终点
      
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;半径&lt;/span&gt;
            arcSegment.Size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Size(radius, radius);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应的角度&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; radian = Math.Atan(bulge) * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; angle = radian * &lt;span&gt;180&lt;/span&gt; /&lt;span&gt; Math.PI;
            arcSegment.RotationAngle &lt;/span&gt;=&lt;span&gt;Math.Abs(angle); 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弧度的方向 顺时针还是逆时针&lt;/span&gt;
            arcSegment.SweepDirection = bulge&amp;gt;&lt;span&gt;0&lt;/span&gt;?&lt;span&gt; SweepDirection.Clockwise:SweepDirection.Counterclockwise;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否大于180度&lt;/span&gt;
            arcSegment.IsLargeArc = Math.Abs(bulge) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            pathFigure.Segments.Add(arcSegment);

            pathGeometry.Figures.Add(pathFigure);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上述代码根据两点、凸度、圆半径来实现画图。（半径是根据前三个计算出来的，后面会讲该算法）&lt;/p&gt;
&lt;p&gt;一个&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.media.pathgeometry?view=netframework-4.7.2&quot; data-linktype=&quot;relative-path&quot;&gt;PathGeometry&lt;/a&gt;由一个或多个图形暨PathFigure组成。PathFigure 就是一系列封闭或不封闭的线段或弧线组成。ArcSegment 代表一个弧线，将其加入到PathFigure，再将PathFigure加入到Geometry ，这样就可以根据DrawGeometry画出弧线了。函数有注释，非常容易理解。&lt;/p&gt;
&lt;p&gt;ArcSegment 还有一个参数就是圆的半径。其实根据两点、’凸度就可推导出半径，不知道为什么ArcSegment 不替我们计算出来。下面讲一下如何计算半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 根据凸度计算半径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; CalBulgeRadius(System.Windows.Point point1, System.Windows.Point point2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; bulge)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算顶点角度&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; cicleAngle = Math.Atan(bulge) * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两点之间的距离&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; pointLen =&lt;span&gt; ImageHelper.CalPointLen(point1, point2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据正玄值反推&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; radius = (pointLen / &lt;span&gt;2&lt;/span&gt;) / Math.Sin(cicleAngle / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.Abs(radius);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208215051532-1733350881.png&quot; alt=&quot;&quot;/&gt;看左图，可知：顶点对应的角度的一半的正玄值就是 两点之间的长度除以半径。根据这一点就可以算出半径。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 计算圆点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上述函数虽然可以画出圆弧，但是我们还是不知道圆心坐标。这里将一下如何推导出圆心坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208220438277-509831970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里有一个概念就是旋转，将求解圆心坐标分为两个步骤。第一步在两点之间取一点（点3），该点到点1的长度为半径；第二步，将此点旋转一定角度，就得到圆心坐标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求点3：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两点之间的距离&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; pointLen =&lt;span&gt; ImageHelper.CalPointLen(point1, point2);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;半径与两点之间距离的比值&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; lenRate = radius /&lt;span&gt; pointLen;
            System.Windows.Point midPoint &lt;/span&gt;=&lt;span&gt; ImageHelper.GetMidPoint(point1, point2, lenRate);
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; System.Windows.Point GetMidPoint(System.Windows.Point pt1, System.Windows.Point pt2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; lenRate)
        {
            Debug.Assert(lenRate&lt;/span&gt;&amp;gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lenRate == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pt2;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lenRate == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pt1;

            System.Windows.Point result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Windows.Point();
            result.X &lt;/span&gt;= pt1.X + lenRate * (pt2.X -&lt;span&gt; pt1.X);
            result.Y &lt;/span&gt;= pt1.Y + lenRate * (pt2.Y -&lt;span&gt; pt1.Y);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201812/245753-20181208221453675-1397661121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据几何知识，可以得知：半径与两点之间的比率与点3的X坐标与两点的X坐标比率一样，这样就能求出X坐标。同理，可以求出Y坐标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旋转：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点3以点1位圆心，旋转一定角度，点3就落在圆心上了。旋转的角度不难计算，顶点角度已知，又是等腰三角形，所以三角形的底角很容易算出。&lt;/p&gt;
&lt;p&gt;旋转计算涉及二维向量运算，不过.NET为我们提供了类Matrix。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; System.Drawing.Point RotationAt(System.Drawing.Point pointMove, System.Drawing.Point removeAt, 
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; rotateAngle, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; clockwise)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rotateAngle == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pointMove;

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (matrix)
            {
                matrix.Reset();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置旋转的角度&lt;/span&gt;
                matrix.Rotate((&lt;span&gt;float&lt;/span&gt;)(clockwise ? rotateAngle : -&lt;span&gt;rotateAngle));

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于removeAt旋转&lt;/span&gt;
                System.Drawing.Point pt2 = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(pointMove.X - removeAt.X, pointMove.Y -&lt;span&gt; removeAt.Y);
                System.Drawing.Point[] pts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; System.Drawing.Point[] { &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.Point(pt2.X, pt2.Y) };
                matrix.TransformPoints(pts);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再变换到圆点位置&lt;/span&gt;
                System.Drawing.Point result = &lt;span&gt;new&lt;/span&gt; System.Drawing.Point(pts[&lt;span&gt;0&lt;/span&gt;].X + removeAt.X, pts[&lt;span&gt;0&lt;/span&gt;].Y +&lt;span&gt; removeAt.Y);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 后记：&lt;/strong&gt;在二维坐标上画图，需要有一定的几何基础和空间想象能力。初始接触这类编程，还是有一定难度的。就需要我们补充一些几何知识，同时多思考，总有一天会感觉豁然开朗。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 14:37:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 凸度（bulge）是AutoCAD 中一个非常重要的概念，凸度控制着两点之间弧度大小，弧度的方向。各种复杂的图像有可能就是成百上千的弧线组成的。从AutoCAD中导出的数据也有该值，一般的形式为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/autocad_bulge.html</dc:identifier>
</item>
<item>
<title>python中的tcp - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;tcp简介&quot;&gt;TCP简介&lt;/h2&gt;
&lt;h3 id=&quot;tcp介绍&quot;&gt;TCP介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）&lt;/strong&gt;是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。&lt;/p&gt;
&lt;p&gt;TCP通信需要经过&lt;strong&gt;创建连接、数据传送、终止连接&lt;/strong&gt;三个步骤。&lt;/p&gt;
&lt;p&gt;TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;&quot;&lt;/p&gt;
&lt;h3 id=&quot;tcp特点&quot;&gt;TCP特点&lt;/h3&gt;
&lt;h4 id=&quot;面向连接&quot;&gt;1. 面向连接&lt;/h4&gt;
&lt;p&gt;通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。&lt;/p&gt;
&lt;p&gt;双方间的数据传输都可以通过这一个连接进行。&lt;/p&gt;
&lt;p&gt;完成数据交换后，双方必须断开此连接，以释放系统资源。&lt;/p&gt;
&lt;p&gt;这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。&lt;/p&gt;
&lt;h4 id=&quot;可靠传输&quot;&gt;2. 可靠传输&lt;/h4&gt;
&lt;p&gt;1）&lt;strong&gt;TCP采用发送应答机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;超时重传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。&lt;/p&gt;
&lt;p&gt;TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;错误校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。&lt;/p&gt;
&lt;p&gt;4) &lt;strong&gt;流量控制和阻塞管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制用来避免主机发送得过快而使接收方来不及完全收下。&lt;/p&gt;
&lt;h3 id=&quot;tcp与udp的不同点&quot;&gt;TCP与UDP的不同点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;面向连接（确认有创建三方交握，连接已创建才作传输。）&lt;/li&gt;
&lt;li&gt;有序数据传输&lt;/li&gt;
&lt;li&gt;重发丢失的数据包&lt;/li&gt;
&lt;li&gt;舍弃重复的数据包&lt;/li&gt;
&lt;li&gt;无差错的数据传输&lt;/li&gt;
&lt;li&gt;阻塞/流量控制&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;udp通信模型&quot;&gt;udp通信模型&lt;/h3&gt;
&lt;p&gt;udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，&quot;写信&quot;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208132247209-1884260035.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tcp通信模型&quot;&gt;TCP通信模型&lt;/h3&gt;
&lt;p&gt;udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，&quot;打电话&quot;&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208132327134-1165817946.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp客户端&quot;&gt;tcp客户端&lt;/h2&gt;
&lt;p&gt;tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多&lt;/p&gt;
&lt;p&gt;python创建tcp客户端的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def main():
        # 1.创建套接字socket
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # 2.连接服务器
        dest_ip = input(&quot;请输入服务器ip：&quot;)
        dest_port = int(input(&quot;请输入服务器port：&quot;))
        dest_addr = (dest_ip, dest_port)
        tcp_socket.connect(dest_addr)

        # 3. 接收/发送数据
        send_data = input(&quot;请输入要发送的数据：&quot;)
        tcp_socket.send(send_data.encode(&quot;utf-8&quot;))    
    
        # 接收服务器发送的数据
        recv_data = tcp_socket.recv(1024)
        print(recv_data.decode(&quot;utf-8&quot;))    

        # 4. 关闭套接字socket
        tcp_socket.close()

if __name__ == &quot;__main__&quot;:

        main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208135059008-1036457250.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络调试助手中启动tcp服务器进行交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208135212083-1150520552.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp服务器&quot;&gt;tcp服务器&lt;/h2&gt;
&lt;p&gt;在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;socket创建一个套接字&lt;/li&gt;
&lt;li&gt;bind绑定ip和port&lt;/li&gt;
&lt;li&gt;listen使套接字变为可以被动链接&lt;/li&gt;
&lt;li&gt;accept等待客户端的链接&lt;/li&gt;
&lt;li&gt;recv/send接收发送数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def main():
        # 1.创建套接字
        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
        # 2.绑定端口
        addr = (&quot;&quot;, 8866)
        tcp_server_socket.bind(addr)

        # 3.监听链接
        tcp_server_socket.listen(128)

        # 4.接收别人的连接
        # client_socket用来为这个客户端服务
        client_socket, client_addr = tcp_server_socket.accept() 
    
        # 5.接收对方发送的数据
        recv_data = client_socket.recv(1024)    
        print(&quot;接收到的数据：%s&quot; % recv_data.decode(&quot;utf-8&quot;))
    
        # 6.给对方发送数据
        client_socket.send(&quot;hahaha&quot;.encode(&quot;utf-8&quot;))    

        # 7.关闭套接字 
        client_socket.close()
        tcp_server_socket.close()


if __name__ == &quot;__main__&quot;:
        main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ubuntu的终端上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208212901839-1290589772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络调试助手中启动tcp服务器进行交互：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181208212925845-1369644616.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp注意点&quot;&gt;tcp注意点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器&lt;/li&gt;
&lt;li&gt;tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机&lt;/li&gt;
&lt;li&gt;tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的&lt;/li&gt;
&lt;li&gt;当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信&lt;/li&gt;
&lt;li&gt;当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务&lt;/li&gt;
&lt;li&gt;listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的&lt;/li&gt;
&lt;li&gt;关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。&lt;/li&gt;
&lt;li&gt;关闭accept返回的套接字意味着这个客户端已经服务完毕&lt;/li&gt;
&lt;li&gt;当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 08 Dec 2018 14:23:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] TCP简介 TCP介绍 TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-tcp-learn.html</dc:identifier>
</item>
<item>
<title>我是如何从通信转到Java软件开发工程师的？ - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/10087931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/10087931.html</guid>
<description>&lt;p&gt;我的读者里面有绝大部分都是在校学生，有本科的，也有专科的，我在微信里收到很多读者的提问，大部分问题都跟如何学习编程有关，有换专业自学的、有迷茫不知道如何学习的、有报培训班没啥效果的等等，我能感受到他们的诚意和焦虑，所以我觉得我很有必要写下这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 本科的脚踏实地&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高考之后填志愿，那时候其实我也不懂，就觉得电子信息工程好像还不错，于是就填了。在大学四年，除了学校学了C语言之外，我没有学习任何第二门编程语言，而且C语言也只是初级的水平。我在大学都干了啥？&lt;/p&gt;
&lt;p&gt;我在大一，就决定读研，所以我一直在努力学习，高等数学、线性代数、概率论、大学物理、还有一些数电、模电、信号与系统、通信原理等等专业课。老实说，我非常认真，一部分是因为自己的学习习惯，另一部分也是因为自己要读研，所以我每一步都走的很踏实。在我的同龄人里，执行力和毅力能跟我比的，没几个，这点我不吹牛逼。&lt;/p&gt;
&lt;p&gt;大学没少拿奖学金，最起码可以抵消我四年的学费，单片机也玩了不少，51、52到后面的ARM9都玩过，当时还买了好几块板子，写程序跑，那时候对嵌入式还蛮感兴趣的。&lt;/p&gt;
&lt;p&gt;但是毕业后，我有点后悔。为什么呢？我没怎么学编程啊！除了会写一些简单的C代码，其他编程技能为零。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 研究生的觉悟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;考入同济之后，我的专业是电子与通信工程。从研一开始，我很明确我自己想要什么，研究生也是要上课的，基础课、专业课等等。研究生也有课题，需要看各种论文，需要写论文，其实还是蛮忙的。&lt;/p&gt;
&lt;p&gt;我研究生对自己的唯一要求就是提升自己的编程技能。一开始我在看C++，语法看完了之后，看了一点基于C++的数据结构和算法。我真正开始决定学Java是在研一下学期，当时在eBay跟一些大佬们聊了蛮多，倒不是学到了什么牛逼的技术，而是开拓了自己的视野，开始有了自己的一些想法。&lt;/p&gt;
&lt;p&gt;后来我在实验室里闷头苦学了一年左右，从Java语法基础开始，到集合框架源码（那时候还是基于JDK1.7的）、到网络编程（基础）、到数据结构和算法，学完了这些基础知识后，开始学习Servlet/jsp（现在已经不直接用了）、再到Spring、Struts2、Hibernate（SSH框架，现在企业里用的也不多了）、再到Spring、SpringMVC、Mybatis（SSM框架，这个现在还在用）、再到Java并发基础、再到一些中间件等等，再到后面我开始学习微服务相关的东东，学习Spring Boot，Spring Cloud等等。这期间，我做了4个项目实战。我是如何自学的？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 我是如何自学Java的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果要说自学Java，我觉得我有资格说上几句。我一开始看了一个星期左右的书，然后我把书扔在了一边，看不进去啊！我自认为自己的脑袋瓜还算可以，但是我看不进去。这也是初学者的通病，有好多读者也跟我说：武哥，我书也看了，可是感觉还是不会。我TM也是这么过来的，哈哈。&lt;/p&gt;
&lt;p&gt;所以我当时看了视频，我看的是毕向东的Java视频，现在已经有更加新的视频了。找一个好视频，从头到尾认认真真跟着学一遍，做好笔记，那也是我开始写博客的开始。&lt;/p&gt;
&lt;p&gt;人都有个尿性，如果你做一件事情，一直看不到明显的效果，你就会慢慢懈怠，慢慢怀疑自己到底对不对，适不适合。编程也一样，为什么我不建议初学者上来就抱着别人跟你推荐的所谓的经典书籍去啃？什么《Thinking in Java》、《Effective Java》等等，你啃的了吗？你啃不了是对的，否则你就是神了。你啃不了，你就会放弃。我就很讨厌那些贴吧论坛里一上来就给一些初学者推荐很多经典书籍的人，显得自己很博学很牛逼的样子，其实没啥卵用。&lt;/p&gt;
&lt;p&gt;包括Java并发、SSH、SSM框架、组件等等，我全部看的视频。当然，一些源码我是自己啃的。当你有了基础，上路了，你再去看书，不仅仅就是看懂看不懂的问题了，那是真正的提升。&lt;/p&gt;
&lt;p&gt;但是这些还不够，你学了这些东西不能派上用场。必须要项目实战，网上有很多免费的实战视频，但是我觉得不好，因为那时候我已经有基础了，我知道如何去选择我的学习资源了，我在这还是要强调一点，不要吝啬给自己投资，我当时也买了好几个项目实战视频跟着学习，提升很多实战经验。&lt;/p&gt;
&lt;p&gt;当然了，我这边也有很多优质的视频资源，也许已经大家够用了，不用像我当初那样去花钱了，我那时候自学，就没有遇到像我这样懂得分享的人。所以缺视频资源的读者，可以找我要，我就是单纯的分享，为了帮助更多的朋友。&lt;/p&gt;
&lt;p&gt;但是有很多人坚持不下来。我在文章的开头也说了，在同龄人里，执行力和毅力能和我比的没几个，我也是从小白一步步过来的，花了整整一年左右的时间去自学。我做了好几个项目，我敢说我在学校这一年学到的东西，不比别人在外面工作两年的能力差。所以有很多人觉得工作年限长就牛逼，见识多，但是在我看来，这不一定。&lt;/p&gt;
&lt;p&gt;我曾经好几个月直接睡实验室里，每天除了看论文，完成导师的任务，其他时间全部用来学习，晚上搞到十一二点，否则一年时间不可能学那么多东西，而且我大部分还写成了博客，要知道，写博客是很花时间的。如果你能像我这样坚持，这样严格要求自己，我不相信学不会一个东西。你就算今天学不会，你一个月之后呢？一个月不行，你一年总行了吧？就像马云爸爸说的：今天很残酷，明天更残酷，后天很美好。但是很多人都坚持不过明天，他永远看不到美好。就像我考研一样，没有坚持付出，哪来的结果？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 遇到选择，我如何取舍？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我当初研究生刚毕业，是去了华为，我的岗位就是Java软件开发，结果进去之后做通信了。我就纳闷，我研究生读的是通信，我特地自己自学Java，结果又回到做通信，这就很尴尬了。&lt;/p&gt;
&lt;p&gt;所以后来我还是走了，有些读者问我，你为何放弃华为的高薪？我说自己的兴趣不在通信，我有自己的打算，决定从华为离开的，肯定不是为了钱。最起码，我现在过的比在华为好，我相信以后也会。&lt;/p&gt;
&lt;p&gt;职场遇到选择的时候，我个人觉得还是要结合自己的兴趣，人生最重要的几年可能就是刚毕业那几年，那几年也在绝大程度上决定我们以后从事的行业，所以在做选择的时候，需要结合自己的兴趣，综合各方面因素权衡好。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 总结一下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;自学一门技术，首先要会用，要先建立兴趣，再想着去提升，去内化，否则，你坚持不下去。&lt;/p&gt;
&lt;p&gt;自学一门技术，要有规划，最起码要知道你接下来要学哪些东西，不能走一步看一步。有了规划就得有计划，有了计划，就得有执行。&lt;/p&gt;
&lt;p&gt;学习的过程中，永远不要吝啬投资自己，该花钱就花钱，现在是知识付费时代，像CSDN GitChat达人课、极客时间等，里面一些课程还是挺不错的，还有些培训机构的视频也不错。花钱提升自己，本来就没毛病。&lt;/p&gt;
&lt;p&gt;做任何事，离开了坚持二字，那都是扯淡。如果随随便便就能成功的，就能做好的事情，是个人都可以的话，那你也没有什么竞争力。有句话说的好：小聪明不如傻坚持。&lt;/p&gt;
&lt;p&gt;不懂就要多问，不管我们是什么样的人，不管问谁，不管别人比自己牛逼或者弱，都得放低自己的姿态，虚心一点。如果哪天我们有点影响力了，那么尽量以一个低姿态去多帮助那些初学者，帮助更多的人，因为我们也是那样过来的，比自己牛逼的人，满大街都是。人，不要膨胀，要懂得韬光养晦。&lt;/p&gt;
&lt;p&gt;希望这篇文章能够给那些初学者，或者有自学困惑的人带来一点帮助，也希望我的读者能从我这里获得一些正能量。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 14:13:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>我的读者里面有绝大部分都是在校学生，有本科的，也有专科的，我在微信里收到很多读者的提问，大部分问题都跟如何学习编程有关，有换专业自学的、有迷茫不知道如何学习的、有报培训班没啥效果的等等，我能感受到他们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/10087931.html</dc:identifier>
</item>
<item>
<title>使用PrefView监测.NET程序性能（三）：分组 - wyman25</title>
<link>http://www.cnblogs.com/lwhkdash/p/10040052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwhkdash/p/10040052.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/lwhkdash/p/9969215.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;博客中，我们通过Perfview帮助文件中自带的代码来简单使用了Perfview，了解了基本操作。现在来看看Perfview中的分组操作（Grouping）。分组功能都旨将记录到的各种函数调用堆栈以指定的规则进行分组，帮助你组织和找到更关心的数据。&lt;/p&gt;
&lt;h2&gt;为什么需要分组&lt;/h2&gt;
&lt;p&gt; 在实际使用中，PerfView通常会收集到非常多的函数调用栈数据，包括我们关心的程序的函数调用信息，及一大堆我们不关心的其他函数调用信息，例如windows系统的底层函数。这么多有用没用的条目都列出在列表视图上，令人眼花缭乱。如何将我们不需要的数据分组归纳呢？Perfview提供分组功能。&lt;/p&gt;
&lt;p&gt;分组功能使用类似于正则的匹配功能，将函数全名（一个函数的全名包含了程序集，命名空间，类名和函数名，例如&quot;mscorlib.n!System.DateTime.get_Now()&quot;）进行匹配，并替换成自定义的分组名称。例如，可以对所有在Debug目录下的程序集的函数单独显示，而其他函数则分组成“OTHER”，这样，我们就可以只看见我们程序里的函数调用。其实这就是默认的[Just My App]分组规则的作用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208145601157-630711534.png&quot; alt=&quot;&quot; width=&quot;1015&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;通配符&lt;/h2&gt;
&lt;p&gt;那么，分组功能如何使用呢？&lt;/p&gt;
&lt;p&gt;在使用分组之前，先看看PerfView定义的几个&quot;通配符&quot;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* :&lt;/span&gt;匹配任意数量的字符&lt;/p&gt;
&lt;p&gt;%：匹配任意数量的数字和英文字母和点号(&quot;.&quot;)，等于.NET正则中的 [\w\d.]*&lt;/p&gt;
&lt;p&gt;^ ：匹配开头&lt;/p&gt;
&lt;p&gt;|：“或”操作&lt;/p&gt;
&lt;p&gt;{}：代表一个分组，等于.NET正则里的小括号&lt;/p&gt;

&lt;h2&gt;分组规则&lt;/h2&gt;
&lt;p&gt;PerfView中有两种分组操作，分别是 PAT-&amp;gt;GROUP 和 PAT=&amp;gt;GROUP。在这里“PAT”代表需要匹配的模式(Pattern)，“GROUP”代表你自定义的组名。 而这两种分组方式区别就在于中间的“-&amp;gt;”和&quot;=&amp;gt;&quot;，前者表示忽略入口函数，后者则会将入口函数显示在分组中。有时我们希望知道一个分组里的函数最初是由哪个函数开始调用的，这时候就可以使用后者了。除此之外，两种分组方式没有其他不同。&lt;/p&gt;
&lt;p&gt; 我们看看具体的分组规则的使用：&lt;/p&gt;
&lt;p&gt;1. PAT-&amp;gt;GROUP形式&lt;/p&gt;
&lt;p&gt;如上述，PAT-&amp;gt;GROUP形式是简单地将一个函数的全名称中包含&quot;PAT&quot;字眼的条目都分到“GROUP”组中，例如，在不分组的情况下，我们收集到的函数调用数据列表是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208151559531-748658494.png&quot; alt=&quot;&quot; width=&quot;1032&quot; height=&quot;596&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有我们Tutorial.exe的函数，例如，tutorial!Program.SpinForASecond()和tutorial!Program.RecSpin()，同时也有很多.NET的内部函数，例如 mscorlib.n!System.get_Now()和mscorlib.n!System.TimeSpan.get_TotalSeconds()，等等。假设我们只关心tutorial.exe自身的函数，而不希望被.NET内部函数所干扰，我们则可以设置一个分组规则“mscorlib-&amp;gt;.NET”，这样，所有包含“mscorlib”字眼的方法全名称的条目都会被分组进“.NET”组，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208152321502-1656354194.png&quot; alt=&quot;&quot; width=&quot;1031&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是清爽了很多？这样的分组能使我们快速地过滤掉mscorlib有关的函数，只剩下tutorial自己的函数（和一些其他函数，当然如果你愿意，也可以将其他的函数&quot;分组&quot;掉）&lt;/p&gt;

&lt;p&gt;2. {*}=&amp;gt;$1&lt;/p&gt;
&lt;p&gt;该形式的规则意思是： 花括号里匹配到的条目会被分组，而组名正是是花括号里的匹配到的内容，“$1”是一个占位符，对应的是花括号“{}”里的内容。假设有两个函数：tutorial!Program.SpinForASecond()和tutorial!Program.RecSpin()， 而应用的规则是“{tutorial!}-&amp;gt;My APP $1”，则分组后，这两个函数被分进一组，并且组名为“My App tutorial!”&lt;/p&gt;
&lt;p&gt;Perfview还支持同时设置多个规则，例如设置规则为“&lt;span&gt;{tutorial!}-&amp;gt;My APP $1&lt;/span&gt;;&lt;span&gt;{mscorlib.ni!}-&amp;gt;Internal $1&lt;/span&gt;”，这里有两个规则，一个是蓝色部分，另一个是红色部分，中间用分号(;)隔开。如果函数全名中有&quot;tutorial!&quot;的就分进名为“My APP tutorial!”组，而有“mscorlib.ni!”字眼的就分进“Internal mscorlib.ni!”组。&lt;/p&gt;

&lt;p&gt;3.PAT=&amp;gt;GROUP&lt;/p&gt;
&lt;p&gt;最后来看看入口点规则分组(Entry Point Grouping)。前边提到过，“PAT=&amp;gt;GROUP”与“PAT-&amp;gt;GROUP”的不同在于，后者会忽略掉该组的入口函数，意味着你很难知道某个分组里的函数是从哪个函数执行进去的，而前者则会包含入口点函数信息。我们通过图例来看看实际效果。&lt;/p&gt;
&lt;p&gt;下图中，使用“mscorlib-&amp;gt;System Functions”规则来对mscorlib的函数进行分组，组名为“System Functions”,但除非你展开这个分组的明细，查找每个函数调用树，否则你不知道是什么函数调用了这组函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208213730850-599436695.png&quot; alt=&quot;&quot; width=&quot;981&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而现在使用“mscorlib=&amp;gt;System Functions”，看看有什么不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201812/43206-20181208214202774-831136545.png&quot; alt=&quot;&quot; width=&quot;980&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;System Functions组明确指示了该组的函数的入口点是“mscorlib.ni!System.DateTime.get_Now()”函数，即DateTime.Now导致了这些函数的执行。&lt;/p&gt;

&lt;p&gt;以上便是PerfView的分组功能。但其实这只是分组功能中的一部分。通过规则的搭配可以有更强大的效果。而最全面的说明其实是在PerfView自带的F1帮助文件。这里只作一个抛砖引玉的简要说明。因此如果需要了解更全面的分组技巧，可以去帮助文件里搜索相关主题。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Dec 2018 13:54:00 +0000</pubDate>
<dc:creator>wyman25</dc:creator>
<og:description>在上一篇博客中，我们通过Perfview帮助文件中自带的代码来简单使用了Perfview，了解了基本操作。现在来看看Perfview中的分组操作（Grouping）。分组功能都旨将记录到的各种函数调用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwhkdash/p/10040052.html</dc:identifier>
</item>
<item>
<title>F#周报2018年第49期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10089267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10089267.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;ML.NET 0.8——Machine Learning for .NET&quot; &quot;.NET Core 3预览 1以及开源Windows桌面框架&quot; &quot;.NET Core 2.2&quot; &quot;尝试C 8.0&quot; &quot;.NET Framework 4.8早期可用编译包3694&quot; &quot;WPF，WinForms和Wi</description>
<pubDate>Sat, 08 Dec 2018 13:51:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10089267.html</dc:identifier>
</item>
</channel>
</rss>