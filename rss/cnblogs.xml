<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java反射，注解，以及动态代理 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/10306968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/10306968.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;基础&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;最近在准备实习面试，被学长问到了Java反射，注解和动态代理的内容，发现有点自己有点懵，这几天查了很多资料，就来说下自己的理解吧【如有错误，望指正】&lt;/p&gt;

&lt;h2&gt;Java反射&lt;/h2&gt;
&lt;p&gt;首先，我们得弄清一个，什么是反射(Reflection)。简单的来说，反射就是让我们在程序运行的时候能够查看到类的信息，获取并调用类的任意方法和属性。&lt;/p&gt;
&lt;p&gt;在Java运行时，系统会将所有的对象维护一个被称为运行是的类型标识，然后这个信息跟踪这每个对象所属的类，我们可以和根据Java专门的类访问这些信息，这个类就是&lt;code&gt;Class&lt;/code&gt;【实际上Class对象表示的是一个类型，它不一定是类，可能是基本数据类型，比如int】。&lt;/p&gt;

&lt;h3&gt;Class获取方法&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;通过getClass()获取&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Student stu = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Student;
Class c =  stu.getClass();


System.out.println(c.getName());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用forName获取&lt;br/&gt;同样，我们也可以使用静态方法&lt;code&gt;forName&lt;/code&gt;获得Class对象。例如：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;String className= &lt;span class=&quot;hljs-string&quot;&gt;&quot;java.util.Random&quot;&lt;/span&gt;;
Class c2 = Class.forName(className);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，className必须为接口或者类名才能成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;直接获取&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Class c3 = Student.class;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;由Class得到对象&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;使用Class对象的newInstance()方法来创建Class对象&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Class c3 = Test.class;
Object o = c3.newInstance();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中newInstance()会根据类的&lt;code&gt;默认构造器【无参构造器】&lt;/code&gt;创建新的对象，如果没有默认的构造器，就会报错。假如我们的构造器里面有参数怎么办，这时候我们就需要使用&lt;code&gt;java.lang.reflect.Constructor&lt;/code&gt;中的&lt;code&gt;newInstance()&lt;/code&gt;方法了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;使用Constructor类中的newInstance()&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;
Constructor constructor = c3.getConstructor(String.class);
Object o = constructor.newInstance(&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好&quot;&lt;/span&gt;);  

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;java反射中最重要的内容——检查类的结构&lt;/h3&gt;
&lt;p&gt;在Java的java.lang.reflect中有三个类：Field、Method、Constructor分别来描述类的域【也就是变量】，方法和构造器。&lt;/p&gt;
&lt;ol readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Field的获取以及方法&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Class textClass = Test.class;


Field[] fields = textClass.getDeclaredFields();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单的来说，通过Field可以获得：&lt;/p&gt;
&lt;p&gt;变量的&lt;code&gt;权限&lt;/code&gt;——getModifiers()，返回int，然后通过Modifier.toString(int)获得访问权限&lt;/p&gt;
&lt;p&gt;获得变量的&lt;code&gt;类型&lt;/code&gt;——getType()&lt;/p&gt;
&lt;p&gt;变量的&lt;code&gt;名字&lt;/code&gt;——getName()&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;21.5&quot;&gt;
&lt;p&gt;Method的获取以及方法&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Class textClass = Test.class;

Method[] methods = textClass.getMethods();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过Method可以获取：&lt;/p&gt;
&lt;p&gt;方法的&lt;code&gt;权限&lt;/code&gt;——getgetModifiers()&lt;/p&gt;
&lt;p&gt;方法的&lt;code&gt;返回值类型&lt;/code&gt;——getReturnType(),方法返回类型为&lt;code&gt;Class&lt;/code&gt;，然后你懂得。&lt;/p&gt;
&lt;p&gt;方法的&lt;code&gt;所有参数&lt;/code&gt;——Parameter[] parameters = method.getParameters()；&lt;/p&gt;
&lt;p&gt;方法的&lt;code&gt;执行&lt;/code&gt;——invoke()。在获取一个方法后，我们可以使用&lt;code&gt;invoke()&lt;/code&gt;来调用这个方法。&lt;/p&gt;
&lt;p&gt;Object invoke（Object obj,Object...args），obj为实例化后的对象【对于静态方法可以被设置null】，args为方法调用的参数&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String msg)&lt;/span&gt;&lt;/span&gt;{
        System.out.println(msg);
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &lt;/span&gt;{

        Class c = Test.class;
        
        Method method = c.getMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say&quot;&lt;/span&gt;, String.class);
        Object o = c.newInstance();
        method.invoke(o,&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好&quot;&lt;/span&gt;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Constructor的获取以及方法&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;Class textClass = Test.class;

Constructor[] constructors = aClass.getConstructors();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法的的使用和Method差不多，但是它没有getReturnType()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些方法我只是简单的介绍了一下，详细信息可以参考API。&lt;/p&gt;

&lt;h2&gt;神奇的Java注解&lt;/h2&gt;
&lt;p&gt;Java注解可以很简单的说，就是为方法或者其他数据提供描述的东西。&lt;/p&gt;
&lt;p&gt;它的本质就是一个接口,一个继承了Annotation的接口。&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基本java注解的类型&lt;br/&gt;【元注解】：也就是在自定义一个注解时，可以注解在注解上面，有以下几个元注解——&amp;gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;@Target：注解的作用目标，用来指明注解可以作用的目标是谁，例如类，方法或者字段属性,里面的value【为一个ElementType数组】可以指明值如下：&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上&lt;/p&gt;
&lt;p&gt;ElementType.FIELD：允许作用在属性字段上&lt;/p&gt;
&lt;p&gt;ElementType.METHOD：允许作用在方法上&lt;/p&gt;
&lt;p&gt;ElementType.PARAMETER：允许作用在方法参数上&lt;/p&gt;
&lt;p&gt;ElementType.CONSTRUCTOR：允许作用在构造器上&lt;/p&gt;
&lt;p&gt;ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上&lt;/p&gt;
&lt;p&gt;ElementType.ANNOTATION_TYPE：允许作用在注解上&lt;/p&gt;
&lt;p&gt;ElementType.PACKAGE：允许作用在包上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;@Retention：注解的生命周期，里面的value【枚举类型】可以指明值如下：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件&lt;/p&gt;
&lt;p&gt;RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件&lt;/p&gt;
&lt;p&gt;RetentionPolicy.RUNTIME：永久保存，可以反射获取&lt;br/&gt;- @Documented：注解是否应当被包含在 JavaDoc 文档中&lt;br/&gt;- @Inherited：是否允许子类继承该注解&lt;br/&gt;- @Repeatable：重复注解，允许这个注解在某个方法和其他数据上面重复使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【Java内置三大注解】：除了上述元注解，Java还内置了另外三种注解——&amp;gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Override：子类重写父类的方法时，会使用该注解。用于检查父类是否包含该注解&lt;/li&gt;
&lt;li&gt;@Deprecated：当某一方法和字段不推荐使用时，使用该注解标注。&lt;/li&gt;
&lt;li&gt;@SuppressWarnings：压制Java的警告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;Java注解的自定义以及实现&lt;/p&gt;
&lt;p&gt;Java注解的自定义如下&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Target&lt;/span&gt;(value = {ElementType.METHOD,ElementType.TYPE}) 
&lt;span class=&quot;hljs-meta&quot;&gt;@Retention&lt;/span&gt;(value = RetentionPolicy.RUNTIME)  
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-meta&quot;&gt;@interface&lt;/span&gt; TestAnnotation {
    &lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;hljs-title&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &quot;这是个类&quot;&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们该如果如何使用注解发挥作用呢？我们可以想想，如果我们能够获得注解的信息，那么我们是不是就可以根据注解的信息来对方法做适当的调整。这时候，当然是大名鼎鼎的反射出马了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.lang.Package.getAnnotation(Class&amp;lt;A&amp;gt; annotationClass) 获得这个指令类型的注解。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用如下：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@TestAnnotation&lt;/span&gt;(time = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;hljs-meta&quot;&gt;@TestAnnotation&lt;/span&gt;(name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;这是个方法&quot;&lt;/span&gt;,time = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &lt;/span&gt;{
        
        TestAnnotation classAnnotation = Test.class.getAnnotation(TestAnnotation.class);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;类的名字为：&quot;&lt;/span&gt;+classAnnotation.name()+&lt;span class=&quot;hljs-string&quot;&gt;&quot;------类的时间是&quot;&lt;/span&gt;+classAnnotation.time());
        Method method = Test.class.getMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say&quot;&lt;/span&gt;);

        
        TestAnnotation methodAnnotation = method.getAnnotation(TestAnnotation.class);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;方法的名字是：&quot;&lt;/span&gt;+methodAnnotation.name()+&lt;span class=&quot;hljs-string&quot;&gt;&quot;------方法的时间是&quot;&lt;/span&gt;+methodAnnotation.time());
    }
}




&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们知道如何进行自定义注解的使用了，那么我们怎么能够根据注释内容的不同去改变方法的执行呢？这时候，我们我们就可以使用&lt;code&gt;invoke()&lt;/code&gt;方法了。&lt;/p&gt;
&lt;p&gt;举个最简单的栗子：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@TestAnnotation&lt;/span&gt;(name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;你好&quot;&lt;/span&gt;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String msg)&lt;/span&gt;&lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;信息是：&quot;&lt;/span&gt;+msg);
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &lt;/span&gt;{

        Method method = Test.class.getMethod(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say&quot;&lt;/span&gt;,String.class);
        
        TestAnnotation methodAnnotation = method.getAnnotation(TestAnnotation.class);
        
        method.invoke(Test.class.newInstance(),methodAnnotation.name());
    }
    
    
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代理&lt;/h2&gt;
&lt;p&gt;代理就是给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。&lt;br/&gt;代理分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态代理：代理类是在编译时就已经实现好了，成为了一个class文件&lt;/li&gt;
&lt;li&gt;动态代理：是在程序运行时动态地生成类字节码，然后加载到JVM中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有几个概念：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;抽象角色：接口类&lt;/li&gt;
&lt;li&gt;实现角色：实现类&lt;/li&gt;
&lt;li&gt;代理角色：代理实现的类，最终使用的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;静态代理&lt;/h3&gt;
&lt;p&gt;在说动态代理之前，我们先说一下静态代理，静态代理很简单，就是工厂模式。&lt;/p&gt;
&lt;p&gt;那么就让我们来实现一下静态代理吧&lt;/p&gt;
&lt;p&gt;抽象角色：接口类&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestService&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现角色：实现类&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestServiceImpl&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestService&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;说话乎&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;浪的飞起&quot;&lt;/span&gt;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理类&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestService&lt;/span&gt;&lt;/span&gt;{

    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; TestService testService;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(TestService testService)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.testService = testService;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;开始说话&quot;&lt;/span&gt;);
        testService.say();
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;结束说话&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;开始浪&quot;&lt;/span&gt;);
        testService.play();
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;是个狼人&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        TestServiceImpl testImpl = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TestServiceImpl();
        Test test = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Test(testImpl);
        test.play();
        test.say();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里面，我们可以看到，从外表看起来&lt;code&gt;say()&lt;/code&gt;和&lt;code&gt;play()&lt;/code&gt;方法都是由&lt;code&gt;test&lt;/code&gt;这个代理来完成的，但实际上，真正的执行者是&lt;code&gt;TestServiceImpl&lt;/code&gt;来完成的，&lt;code&gt;test&lt;/code&gt;只是在执行的时候加了一些事务逻辑。&lt;/p&gt;
&lt;p&gt;既然有了静态代理，为什么我们还需要动态代理呢？从代码中可以看出，代理类和实现类是一一对应的，如果我们有N个实现类，都要在方法执行前加一样的逻辑，那么我们不得不创建N个代理类。这时候，我们就需要使用动态代理了。&lt;/p&gt;

&lt;h2&gt;动态代理&lt;/h2&gt;
&lt;p&gt;本次动态代理是针对JDK动态代理进行探讨。&lt;/p&gt;
&lt;p&gt;正如前面所说，如果我们要在很多类使用同一种逻辑时，会心态爆炸，那么我们怎么去解决这个问题呢，这时候，我们可以想一想反射。&lt;/p&gt;
&lt;p&gt;在使用的动态代理的过程中，有两个关键的东东，一个是&lt;code&gt;InvocationHandler&lt;/code&gt;接口，一个是&lt;code&gt;Proxy&lt;/code&gt;类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InvocationHandler&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;Object invoke(Object proxy, Method method, Object[] args) throws Throwable&lt;/p&gt;
&lt;p&gt;proxy:　　指代我们所代理的那个真实对象,也就是&lt;code&gt;实现类&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;method:　　指代的是我们所要调用真实对象的某个方法的Method对象&lt;/p&gt;
&lt;p&gt;args:　　指代的是调用真实对象某个方法时接受的参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Proxy这个类的作用就是用来动态创建一个代理对象的类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中我们使用最多是&lt;code&gt;newProxyInstance()&lt;/code&gt;去创建代理类&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&lt;/p&gt;
&lt;p&gt;loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载&lt;/p&gt;
&lt;p&gt;interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了&lt;/p&gt;
&lt;p&gt;h：一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建一个代理类，实现方法调用前或后的逻辑&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestHandler&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;InvocationHandler&lt;/span&gt;&lt;/span&gt;{

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Object object;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestHandler&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object object)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.object = object;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;hljs-title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;开始方法执行&quot;&lt;/span&gt;);
        Object o = method.invoke(object,args);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;方法结束&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; o;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例化代理类，并&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{

    
    TestService testService = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TestServiceImpl();

    
    TestHandler testHandler = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TestHandler(testService);
    
    TestService service = (TestService) Proxy.newProxyInstance(testService.getClass().getClassLoader(),
            testService.getClass().getInterfaces(),testHandler);
    service.play();
    service.say();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反射，注解，以及动态代理就简单地介绍完了，可以这样说反射是注解以及动态代理的基础，注解的实现和动态代理都要靠反射发挥作用。&lt;/p&gt;
&lt;p&gt;还是多读下书吧，面试实习是把杀猪刀&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201901/1439869-20190123032458771-623526547.jpg&quot; alt=&quot;&quot; name=&quot;images/2.jpeg&quot; data-src=&quot;images/2.jpeg&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201901/1439869-20190123032459124-602898358.jpg&quot; alt=&quot;&quot; name=&quot;images/1.jpeg&quot; data-src=&quot;images/1.jpeg&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 22 Jan 2019 19:25:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>Java反射，注解，以及动态代理 基础 最近在准备实习面试，被学长问到了Java反射，注解和动态代理的内容，发现有点自己有点懵，这几天查了很多资料，就来说下自己的理解吧【如有错误，望指正】 Java反</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuiduan/p/10306968.html</dc:identifier>
</item>
<item>
<title>Spring：（二）DI依赖注入方式 - JYRoy</title>
<link>http://www.cnblogs.com/jyroy/p/10304533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyroy/p/10304533.html</guid>
<description>&lt;h2 id=&quot;di-依赖注入&quot;&gt;DI 依赖注入&lt;/h2&gt;
&lt;p&gt;　　DI（Dependency Injection）依赖注入，说简单一点就将类里面的属性在创建类的过程中给属性赋值，即将对象依赖属性（简单值，集合，对象）通过配置设值给该对象。&lt;/p&gt;

&lt;h2 id=&quot;依赖注入的方式&quot;&gt;属性注入的方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;　构造方法的方式&lt;/li&gt;
&lt;li&gt;　set方法的方式&lt;/li&gt;
&lt;li&gt;　工厂方法注入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　主要学习前两种方式&lt;/p&gt;
&lt;h3&gt;构造方法的方式&lt;/h3&gt;
&lt;p&gt;　　当是构造方法时注入Bean的属性值（简单值，集合，对象）&lt;/p&gt;
&lt;p&gt;　　利用&amp;lt;constructor-arg&amp;gt;标签进行属性的注入&lt;/p&gt;
&lt;p&gt;　　　　name：被设置属性的名&lt;/p&gt;
&lt;p&gt;　　　　value：被设置属性的值&lt;/p&gt;
&lt;p&gt;　编写用构造方法的pojo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring_test1.pojo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserConstructor {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; UserConstructor(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User_constructor [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XML配置编写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
            http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring构造方法注入 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user_cons&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;spring_test1.pojo.UserConstructor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Roy&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1001&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编写测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring_test1.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; org.junit.Assert.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring_test1.pojo.UserConstructor;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserConstructorTest {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Spring的工厂&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         ApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到User对象&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         UserConstructor userConstructor = (UserConstructor) applicationContext.getBean(&quot;user_cons&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        System.out.println(userConstructor);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201901/1378215-20190122161349189-1150875357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;set方法的方式&lt;/h3&gt;
&lt;p&gt; 　　我在&lt;a href=&quot;https://www.cnblogs.com/jyroy/p/10289930.html&quot; target=&quot;_blank&quot;&gt;Spring：（一）&lt;/a&gt;那一篇中的第一个Spring程序便是set方法时的属性注入方式&lt;/p&gt;
&lt;p&gt;　　利用&amp;lt;property&amp;gt;标签&lt;/p&gt;
&lt;p&gt;　　　　name：被设置属性的名&lt;/p&gt;
&lt;p&gt;　　　　value：被设置属性的值&lt;/p&gt;
&lt;h4&gt;标准XML格式&lt;/h4&gt;
&lt;p&gt;编写pojo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring_test1.pojo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jyroy
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编写XML配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
            http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Spring的set方法的属性注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;spring_test1.pojo.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;李东&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1007&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

        
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编写测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring_test1.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring_test1.pojo.User;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserTest {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Spring的工厂&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         ApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到User对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         User user = (User) applicationContext.getBean(&quot;user&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378215/201901/1378215-20190122161736943-1945228538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;p命名空间的方式&lt;/h4&gt;
&lt;p&gt;　　看上面的XML配置，似乎用&amp;lt;property/&amp;gt;标签还是比较臃肿。&lt;/p&gt;
&lt;p&gt;　　于是从2.0开始，Spring支持使用名称空间的可扩展配置格式。这些名称空间都是基于一种XML Schema定义。p命名空间就可以用bean 元素的属性代替&amp;lt;property/&amp;gt;元素。&lt;/p&gt;
&lt;p&gt;　　还需要在使用p命名空间时先声明使用对应的命名空间，即在bean元素上添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1        &lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; p命名空间的方式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring_test1.pojo.User&quot;&lt;/span&gt;&lt;span&gt; p:name&lt;/span&gt;&lt;span&gt;=&quot;Roy&quot;&lt;/span&gt;&lt;span&gt; p:id&lt;/span&gt;&lt;span&gt;=&quot;1004&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;c命名空间的方式&lt;/h4&gt;
&lt;p&gt;　　C命名空间与p命名空间类似，但是使用c命名空间可以用内联的构造参数代替嵌套的constructor-arg元素&lt;/p&gt;
&lt;p&gt;　　同样先声明使用对应的命名空间，即在bean元素上添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:c&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/c&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 标准XML格式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;x.y.Foo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bar&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bar&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;baz&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;baz&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;foo@bar.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; c命名空间格式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;x.y.Foo&quot;&lt;/span&gt;&lt;span&gt; c:bar-ref&lt;/span&gt;&lt;span&gt;=&quot;bar&quot;&lt;/span&gt;&lt;span&gt; c:baz-ref&lt;/span&gt;&lt;span&gt;=&quot;baz&quot;&lt;/span&gt;&lt;span&gt; c:email&lt;/span&gt;&lt;span&gt;=&quot;foo@bar.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 还可以使用c命名空间的参数索引格式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;x.y.Foo&quot;&lt;/span&gt;&lt;span&gt; c:_0-ref&lt;/span&gt;&lt;span&gt;=&quot;bar&quot;&lt;/span&gt;&lt;span&gt; c:_1-ref&lt;/span&gt;&lt;span&gt;=&quot;baz&quot;&lt;/span&gt;&lt;span&gt; c:_2&lt;/span&gt;&lt;span&gt;=&quot;foo@bar.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;spel表达式方式&quot;&gt;SpEL表达式方式&lt;/h3&gt;
&lt;p&gt;　　Spring 表达式语言 （Spring Expression Language），打算整理完整的一篇&lt;/p&gt;

&lt;h2&gt;集合类型属性注入&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;collectionBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.roy.spring.demo5.CollectionBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数组类型 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;arrs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;数组一&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;数组二&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入list集合类型 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;list一&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;list二&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入set集合类型&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;set&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;set一&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;set二&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入Map集合 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;aaa&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;111&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;bbb&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;222&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ccc&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;333&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入property集合 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;value1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;value2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;value3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 22 Jan 2019 15:50:00 +0000</pubDate>
<dc:creator>JYRoy</dc:creator>
<og:description>DI 依赖注入 DI（Dependency Injection）依赖注入，说简单一点就将类里面的属性在创建类的过程中给属性赋值，即将对象依赖属性（简单值，集合，对象）通过配置设值给该对象。 属性注入的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyroy/p/10304533.html</dc:identifier>
</item>
<item>
<title>简述组件化解决方案CTMediator与MGJRouter的主要思想 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10306657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10306657.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;简述CTMediator&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CTMediator按照功能的结构来讲，使用时需要实现CTMediator的个三部分。&lt;/p&gt;
&lt;p&gt;1.CTMediator类：承担总枢纽，总调度的责任&lt;/p&gt;
&lt;p&gt;2.Target_(ModuleName)类：承担组件对外暴漏接口功能，组件要提供什么服务，主要在它的接口声明上进行体现&lt;/p&gt;
&lt;p&gt;3.CTMediator+(ModuleName)分类：主要供客户端使用，里面声明了可以调用的组件接口。&lt;/p&gt;
&lt;p&gt;下面详细讲解&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;

&lt;p&gt;&lt;strong&gt;Part1: CTMediator核心功能实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CTMediator主要采用target-action的方式实现组件间解耦合，本身功能完全独立，不依赖任何组件模块。&lt;/p&gt;
&lt;p&gt;主要结构如下：&lt;/p&gt;
&lt;p&gt;CTMediator作为中介者，是各个组件的进行信息通讯的中枢。&lt;/p&gt;
&lt;p&gt;主要实现方案分两种情况：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;1.首先利用runtime进行反射，将类字符串和方法字符串转换成类和SEL方法选择子：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SEL action = NSSelectorFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Action_response:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
NSObject &lt;/span&gt;*target = [[NSClassFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Target_NoTargetAction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) alloc] init];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后调用cocoa touch框架提供的方法直接调用&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[target performSelector:action withObject:&lt;span&gt;params&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.或者使用cocoa touch提供的命令模式，将消息和消息接受者封装成一个对象，进行执行。&lt;/p&gt;
&lt;p&gt;首先，利用target-action生成方法签名&lt;/p&gt;
&lt;p&gt;然后，创建NSInvocation对象，进行执行invoke。并拿到返回的结果。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;利用方法签名，NSInvocation实现&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
NSMethodSignature* methodSig =&lt;span&gt; [target methodSignatureForSelector:action];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(methodSig ==&lt;span&gt; nil) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil;
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* retType =&lt;span&gt; [methodSig methodReturnType];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strcmp(retType, @encode(&lt;span&gt;void&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
    NSInvocation &lt;/span&gt;*invocation =&lt;span&gt; [NSInvocation invocationWithMethodSignature:methodSig];
    [invocation setArgument:&lt;/span&gt;&amp;amp;&lt;span&gt;params&lt;/span&gt; atIndex:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    [invocation setSelector:action];
    [invocation setTarget:target];
    [invocation invoke];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Part2: 组件对外服务接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果组件需要对外提供服务，就需要创建自己的接收动作类&lt;/p&gt;
&lt;p&gt;比如ModuleA要对外提供服务。那么就要创建一个&lt;/p&gt;
&lt;p&gt;Target_A类，然后在Target_A类的.h文件中声明对外服务的接口，并在.m文件中进行实现。&lt;/p&gt;
&lt;p&gt;注意：Target_A类是依赖组件的。它属于组件的一部分。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; Target_Mine : NSObject
&lt;/span&gt;- (&lt;span&gt;id&lt;/span&gt;)Action_nativeFetchSportsResultVC:(NSDictionary *&lt;span&gt;)param;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)Action_remoteAlertSportsResultVC:(NSDictionary *&lt;span&gt;)param;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; Target_Mine
&lt;/span&gt;- (&lt;span&gt;id&lt;/span&gt;)Action_nativeFetchSportsResultVC:(NSDictionary *&lt;span&gt;)param {
    UIViewController &lt;/span&gt;*vc = [[FZMineCoordinator sharedFZMineCoordinator] targetVCWithClassName:NSStringFromClass([FZSportsResultVC &lt;span&gt;class&lt;/span&gt;&lt;span&gt;])];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([vc isKindOfClass:[FZSportsResultVC &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]]) {
        [(FZSportsResultVC &lt;/span&gt;*)vc configContent:param[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vc;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)Action_remoteAlertSportsResultVC:(NSDictionary *&lt;span&gt;)param {
    UIViewController &lt;/span&gt;*vc = [[FZMineCoordinator sharedFZMineCoordinator] targetVCWithClassName:NSStringFromClass([FZSportsResultVC &lt;span&gt;class&lt;/span&gt;&lt;span&gt;])];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([vc isKindOfClass:[FZSportsResultVC &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]]) {
        [(FZSportsPlanVC &lt;/span&gt;*)vc configContent:param[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]];
    }
    
    &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;lt;UIApplicationDelegate&amp;gt; appDelegate = [UIApplication sharedApplication].&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;;
    UITabBarController &lt;/span&gt;*rootVC =&lt;span&gt; [[appDelegate window] rootViewController];
    [rootVC.childViewControllers[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] pushViewController:vc animated:YES];
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Part3: CTMediator+ModuleA组件通讯实际使用类&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;p&gt;为了实现完全解耦，这个类所有使用的所有参数全部是cocoa touch框架中定义的基本类型。&lt;/p&gt;
&lt;p&gt;像：NSDictionary，NSString， UIImage等。&lt;/p&gt;
&lt;p&gt;里面按照作用分，可以分为：&lt;/p&gt;
&lt;p&gt;模块名称字符串，模块本地调用方法名称字符串，模块远程调用方法名称字符串&lt;/p&gt;
&lt;p&gt;在CTMediator+ModuleA分类文件的.h文件中，定义了供其他模块使用的接口&lt;/p&gt;
&lt;p&gt;在CTMediator+ModuleA分类文件的.m文件中，实现供其他模块使用的接口，调用用CTMediator的runtime机制进行实现。&lt;/p&gt;

&lt;p&gt;CTMediator提供的方案是我认为最好的，巧妙的使用了cocoaTouch提供的反射机制，方法签名与命令模式，简单又完美的解决了组件间的解耦问题。&lt;/p&gt;
&lt;p&gt;同时因为实现是基于Object-C的特性，稳定性靠谱。&lt;/p&gt;
&lt;p&gt;在方案不同作用类分工上，简单明了。实现了从形式到实质上完全的解耦，同时提供了对外部appURL调用的支持。是非常完美的方案。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- (IBAction)goSportsPlanDetail:(UIButton *&lt;span&gt;)sender {
    UIViewController &lt;/span&gt;*vc = [[CTMediator sharedInstance] Mediator_fetchSportsPlanVC:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[sender currentTitle]}];
    [self.navigationController pushViewController:vc animated:YES];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;CTMediator提供的方案是我认为最好的，巧妙的使用了cocoaTouch提供的反射机制，方法签名与命令模式，简单又完美的解决了组件间的解耦问题。&lt;/p&gt;
&lt;p&gt;同时因为实现是基于Object-C的特性，稳定性靠谱。&lt;/p&gt;
&lt;p&gt;在方案不同作用类分工上，简单明了。实现了从形式到实质上完全的解耦，同时提供了对外部appURL调用的支持。是非常完美的方案。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;简述MGJRouter&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;21.732103321033&quot;&gt;
&lt;p&gt;蘑菇街组件化方案，采用了url-block加protocal-class的方案，url-block用于页面跳转，protocal-class用于组件跳转&lt;/p&gt;
&lt;p&gt;下面对MGJRouter的主要思路进行分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MGJRouter核心功能实现&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;Part1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MGJRouter的url-block实现方案思路为，在路由中心维护着一张路由表，url为key, block为value。&lt;/p&gt;
&lt;p&gt;注册路由表时，将key和value对应保存到路由表routes中&lt;/p&gt;
&lt;p&gt;使用时，根据URL拿到对应的block进行执行。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (NSMutableDictionary *&lt;span&gt;)routes
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_routes) {
        _routes &lt;/span&gt;=&lt;span&gt; [[NSMutableDictionary alloc] init];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _routes;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是URL对应像UIImage,NSData这样的非常规对象是很难传递的。&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Part2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;蘑菇街的protocal-class实现方案思路为：&lt;/p&gt;
&lt;p&gt;在ModuleManager内维护着一张映射表，以protocol为key,以Class为Value。&lt;/p&gt;
&lt;p&gt;注册映射表&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ModuleManager registerClass:ClassA forProtocol:ProtocolA]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用映射表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ModuleManager classForProtocol:ProtocolA]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：上面一一对应的关系中，类是实现了对应的协议的。所以通过协议拿到的类是可以按照protocol中声明的方法自由使用的。&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;10.772271016311&quot;&gt; 
&lt;p&gt;&lt;strong&gt;注册步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.url-block方案注册：&lt;/p&gt;
&lt;p&gt;在模块对应要展示的页面中，在load方法中进行注册&lt;/p&gt;
&lt;div readability=&quot;11.732432432432&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load {
    [MGJRouter registerURLPattern:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;engineer://SportsPlanVC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; toObjectHandler:^&lt;span&gt;id&lt;/span&gt;(NSDictionary *&lt;span&gt;routerParameters) {
        FZSportsPlanVC &lt;/span&gt;*planVC = [FZSportsPlanVC &lt;span&gt;new&lt;/span&gt;&lt;span&gt;];
        [planVC configContent:routerParameters[&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;MGJRouterParameterUserInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]];
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; planVC;
    }];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.protocal-class方案注册：&lt;/p&gt;
&lt;p&gt;在模块的协议实现类中进行注册：&lt;/p&gt;
&lt;div readability=&quot;10.677619893428&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
+ (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load {
    [[FZProtocolMediator sharedFZProtocolMediator] registerProtocol:NSProtocolFromString(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;FZModuleMineProtocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) forClass:[FZModuleMineProtocolImplete &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据对应的单例获取方式，获取既可。&lt;/p&gt;
&lt;div readability=&quot;14.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- (IBAction)mgj_goSportsPlanDetail:(UIButton *&lt;span&gt;)sender {
    UIViewController &lt;/span&gt;*vc = [MGJRouter objectForURL:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;engineer://SportsPlanVC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; withUserInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[sender currentTitle]}];
    [self.navigationController pushViewController:vc animated:YES];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (IBAction)protocol_class_goSportsPlanDetail:(UIButton *&lt;span&gt;)sender {
    Class&lt;/span&gt;&amp;lt;FZModuleMineProtocol&amp;gt; &lt;span&gt;class&lt;/span&gt; = [[FZProtocolMediator sharedFZProtocolMediator] classForProtocol:NSProtocolFromString(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;FZModuleMineProtocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)];
    UIViewController &lt;/span&gt;*vc = [&lt;span&gt;class&lt;/span&gt;&lt;span&gt; fetchSportsPlanVC:sender.currentTitle];
    [self.navigationController pushViewController:vc animated:YES];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MGJRouter实现方案上有些复杂，使得新手学习上有些困难，同时两张表也增加了维护成本。&lt;/p&gt;
&lt;p&gt;不过不可否认的是url-block和protocal-class都是非常巧妙的解耦方案。&lt;/p&gt;

&lt;p&gt;使用效果如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190122230947402-801113765.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190122231002649-2036408301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 22 Jan 2019 15:13:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>简述CTMediator CTMediator按照功能的结构来讲，使用时需要实现CTMediator的个三部分。 1.CTMediator类：承担总枢纽，总调度的责任 2.Target_(Module</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10306657.html</dc:identifier>
</item>
<item>
<title>Python+Selenium爬取动态加载页面（2） - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/10306429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/10306429.html</guid>
<description>&lt;blockquote readability=&quot;5.2077087794433&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 上一篇&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10304350.html&quot;&gt;《Python+Selenium爬取动态加载页面（1）》&lt;/a&gt;讲了基本地如何获取动态页面的数据，这里再讲一个稍微复杂一点的数据获取&lt;a href=&quot;http://xxfb.hydroinfo.gov.cn/ssIndex.html&quot;&gt;全国水雨情网&lt;/a&gt;。数据的获取过程跟人手动获取过程类似，所以也不会对服务器造成更大负荷。本文的代码见&lt;a href=&quot;https://cloud.tsinghua.edu.cn/d/fcb82707948c4d609a40/&quot;&gt;Selenium获取动态页面数据2.ipynb或Selenium获取动态页面数据2.py&lt;/a&gt;。同样在开始前需要准备环境，具体环境准备&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10304350.html#_label0&quot;&gt;参考上一篇&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全国水雨情网的数据同样是动态加载出来的，在浏览中&lt;a href=&quot;http://xxfb.hydroinfo.gov.cn/ssIndex.html&quot;&gt;打开网页后http://xxfb.hydroinfo.gov.cn/ssIndex.html&lt;/a&gt;，可以看到回下图1-1所示的页面。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig1-1-web_analysis_fig2&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/9df02d6e51a14fedbda8/?dl=1&quot;/&gt;&lt;p&gt;图1-1 全国水雨情网&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，其中并没有显示任何的数据，如果我们需要查看数据，还需要点击一下其中的几个按钮。比如，我们需要得到其中大型水库的数据，那么需要点击&lt;code&gt;大型水库&lt;/code&gt;按钮，得到如下图1-2所示的结果。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig1-2-web_analysis_fig3&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/441182464c2846b18fc2/?dl=1&quot;/&gt;&lt;p&gt;图1-2 全国水雨情信息-大型水库&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;得到这个页面后，就可以从其中的&lt;span&gt;HTML页面源码&lt;/span&gt;中解析数据了。&lt;/p&gt;

&lt;h2 id=&quot;打开网页&quot;&gt;2.1 打开网页&lt;/h2&gt;
&lt;p&gt;运行下面代码，会自动弹出Chrome浏览器的窗口；如果用的&lt;code&gt;browser = webdriver.PhantomJS()&lt;/code&gt;，则没有窗口出来。浏览器的窗口出来后，可以看到，它加载出我们的页面了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
import pandas as pd
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC

# 打开chrome浏览器（需提前安装好chromedriver）
browser = webdriver.Chrome()
# browser = webdriver.PhantomJS()
# 这里经常出现加载超的异常，后面需要处理一下：捕获异常后，刷新浏览器
browser.get(&quot;http://xxfb.hydroinfo.gov.cn/ssIndex.html&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查找目标数据&quot;&gt;2.2 查找目标数据&lt;/h2&gt;
&lt;p&gt;页面加载完成后，接下需要定位我们的&lt;code&gt;大型水库&lt;/code&gt;按钮，通过按浏览器的&lt;code&gt;F12&lt;/code&gt;查看源码，可以得到这个按钮的&lt;span&gt;xpath&lt;/span&gt;：&lt;span&gt;//*[@id=&quot;sscontent&quot;]/table/tbody/tr/td/table/tbody/tr[1]/td/table/tbody/tr/td[3]/a&lt;/span&gt;，如图2-1所示。&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;fig2-1-web_xpath_select1&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/03d9d19fd2384a90a748/?dl=1&quot;/&gt;&lt;p&gt;图2-1 xpath定位&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;定位到按钮后，需要再点击一下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 找到大型水库的按钮---通过xpath
btn_water_xpath = &quot;//*[@id=\&quot;sscontent\&quot;]/table/tbody/tr/td/table/tbody/tr[1]/td/table/tbody/tr/td[3]/a&quot;
# 等待响应完成
wait = WebDriverWait(browser, 10)
wait.until(EC.presence_of_element_located((By.XPATH, btn_water_xpath)))
# 查找目标按钮
btn_water = browser.find_element_by_xpath(btn_water_xpath)
# 找到按钮后单击
btn_water.click()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;得到页面源码&quot;&gt;2.2 得到页面源码&lt;/h2&gt;
&lt;p&gt;数据定位完成后，接下来得到页面源码。按照上面同样的方法，我们需要定位其中的数据表，并等待其加载完成，加载完成后，我们才能读取其页面源码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 大型水库的数据表--xpath
water_table_xpath = &quot;//*[@id=\&quot;sktable\&quot;]/table/tbody&quot;
# 得到新的页面，并等待其数据表加载完成
wait = WebDriverWait(browser, 10)
wait.until(EC.presence_of_element_located(
    (By.XPATH, water_table_xpath)))

soup = BeautifulSoup(browser.page_source, 'lxml')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;提取数据&quot;&gt;2.3 提取数据&lt;/h2&gt;
&lt;p&gt;得到页面源码后，可直接利用Pandas的&lt;code&gt;read_html&lt;/code&gt;方法得以其中的表格数据，非常方便。同时我们还需要定位它的表头信息，来得到我们的表头。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 表头信息
table_head_csel = &quot;#skcontent&amp;gt;table:nth-child(3)&amp;gt;tbody&amp;gt;tr&quot;
table_head = soup.select(table_head_csel)[0]

# 通过css选择器，找到水库表信息
table_css_select = &quot;#sktable&quot;
table_content = soup.select(table_css_select)[0]

df_table = pd.read_html(str(table_content))[0]
df_table.columns = [h.text for h in table_head.find_all(&quot;td&quot;)]
# df_table.columns = ['流域', '行政区', '河名', '库名', '库水位(米)', \
#                     '蓄水量(亿米3)', '入库(米3/秒)', '堤顶高程(米)']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看提取数据的前5行，如表2.1所示。&lt;/p&gt;
&lt;p&gt;表2.1 提取数据前5行&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;流域&lt;/th&gt;
&lt;th&gt;行政区&lt;/th&gt;
&lt;th&gt;河名&lt;/th&gt;
&lt;th&gt;库名&lt;/th&gt;
&lt;th&gt;库水位(米)&lt;/th&gt;
&lt;th&gt;蓄水量(亿米3)&lt;/th&gt;
&lt;th&gt;入库(米3/秒)&lt;/th&gt;
&lt;th&gt;堤顶高程(米)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;其他流域&lt;/td&gt;
&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;乌伦古河&lt;/td&gt;
&lt;td&gt;福海水库&lt;/td&gt;
&lt;td&gt;575.14 ↓&lt;/td&gt;
&lt;td&gt;1.756&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;579.00&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;其他流域&lt;/td&gt;
&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;卡浪古尔河&lt;/td&gt;
&lt;td&gt;喀浪古尔水库&lt;/td&gt;
&lt;td&gt;988.26 —&lt;/td&gt;
&lt;td&gt;0.126&lt;/td&gt;
&lt;td&gt;1.23&lt;/td&gt;
&lt;td&gt;1007.50&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;其他流域&lt;/td&gt;
&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;三屯河&lt;/td&gt;
&lt;td&gt;三屯河水库&lt;/td&gt;
&lt;td&gt;1024.49 —&lt;/td&gt;
&lt;td&gt;0.078&lt;/td&gt;
&lt;td&gt;1.982&lt;/td&gt;
&lt;td&gt;1039.60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;其他流域&lt;/td&gt;
&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;头屯河&lt;/td&gt;
&lt;td&gt;头屯河水库&lt;/td&gt;
&lt;td&gt;986.52 —&lt;/td&gt;
&lt;td&gt;0.108&lt;/td&gt;
&lt;td&gt;1.75&lt;/td&gt;
&lt;td&gt;995.20&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;其他流域&lt;/td&gt;
&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;乌鲁木齐河&lt;/td&gt;
&lt;td&gt;红雁池水库&lt;/td&gt;
&lt;td&gt;995.54 ↓&lt;/td&gt;
&lt;td&gt;0.234&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1009.00&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;保存数据&quot;&gt;2.4 保存数据&lt;/h2&gt;
&lt;p&gt;数据提取完成后，下面还将其表格的时间提取出来，以作为文件名，防止数据重复。这里利用了一个简单的正则表达式提时间信息，然后利用&lt;span&gt;pandas&lt;/span&gt;的&lt;code&gt;to_csv&lt;/code&gt;方法，得到两种编码格式的&lt;code&gt;.csv&lt;/code&gt;文件。其中&lt;code&gt;rvr_tab_2019_1_22_ch.csv&lt;/code&gt;为中文编码格式，可直接用excel打开，如图2-2所示。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 找到水库信息的时间
table_time_csel = &quot;#skdate&quot;
time_text = soup.select(table_time_csel)[0].text
time_info = re.search(r&quot;(\d{4})年(\d{1,2})月(\d{1,2})&quot;, time_text).groups()

df_table.to_csv(&quot;rvr_tab_%s_%s_%s.csv&quot; % time_info, index=None)
# 换一个编码方式，此文件可以直接用excel打开，不会出现乱码
df_table.to_csv(&quot;rvr_tab_%s_%s_%s_ch.csv&quot; % time_info,encoding=&quot;GB18030&quot;, index=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;div&gt;&lt;img alt=&quot;fig2-2_web_data_excel2&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/dd79e7934d284acf8280/?dl=1&quot;/&gt;&lt;p&gt;图2-2 获取的数据&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;本文的方法与上一篇&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10304350.html&quot;&gt;《Python+Selenium爬取动态加载页面（1）》&lt;/a&gt;的方法类似，只是多一个按钮点击的过程。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 14:16:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>注： 上一篇 '《Python+Selenium爬取动态加载页面（1）》' 讲了基本地如何获取动态页面的数据，这里再讲一个稍微复杂一点的数据获取 '全国水雨情网' 。数据的获取过程跟人手动获取过程类似</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/10306429.html</dc:identifier>
</item>
<item>
<title>美赛LaTeX急救指南 - 黑山雁</title>
<link>http://www.cnblogs.com/xjtu-blacksmith/p/10306189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjtu-blacksmith/p/10306189.html</guid>
<description>&lt;p&gt;一年一度的美国大学生数学建模竞赛（MCM/ICM）又要开始了。在比赛中，将有一部分同学选择用&lt;code&gt;LaTeX&lt;/code&gt;排版论文，以使论文获得更好的视觉效果；但是，就既往经验来看，其中的很大一部分同学，还并没有熟练地掌握&lt;code&gt;LaTeX&lt;/code&gt;的相关技巧，只是比较生硬的套用网上所给的论文模板（例如通行的&lt;code&gt;mcmthesis&lt;/code&gt;，以及本站发布的&lt;code&gt;easymcm&lt;/code&gt;），一旦出现一些小问题就会&lt;strong&gt;不知所措&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此份文档，是要为各位同学提供一份比较详细的&lt;code&gt;LaTeX&lt;/code&gt;排版问答集锦，内容集中于比赛时可能出现的种种情况，对其他情形下的常见问题则并不叙述。主要着眼于本站发布的&lt;code&gt;easymcm&lt;/code&gt;宏包，对于&lt;code&gt;mcmthesis&lt;/code&gt;文档类在使用时的常见问题也有少量的论述。读者可将此份文档存留、收藏，待遇到问题无法自行解决时，再来到这份文档中查找解决方案。&lt;/p&gt;
&lt;p&gt;此份文档将根据我所了解到的问题继续&lt;strong&gt;补充&lt;/strong&gt;。作者有将此文档转化为&lt;code&gt;pdf&lt;/code&gt;文档（用&lt;code&gt;LaTeX&lt;/code&gt;撰写）的打算，但暂无时间进行此项工作。本文的&lt;code&gt;markdown&lt;/code&gt;源码已发布于&lt;code&gt;GitHub&lt;/code&gt;上，&lt;a href=&quot;https://github.com/xjtu-blacksmith/cnblogs-source/blob/master/blog-mcmaid/mcmaid.md&quot;&gt;戳这里看看&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;关于easymcm宏包的基本信息以及编译系统的若干问题&quot;&gt;1 关于&lt;code&gt;easymcm&lt;/code&gt;宏包的基本信息，以及编译系统的若干问题&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q1.1&lt;/strong&gt;: 目前通行的&lt;code&gt;mcmthesis&lt;/code&gt;是一个“文档类”，而本站发布的&lt;code&gt;easymcm&lt;/code&gt;是一个“宏包”。请问这二者有何区别？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;strong&gt;文档类&lt;/strong&gt;（文件后缀名为&lt;code&gt;.cls&lt;/code&gt;）是一整套预定义的文档样式，其决定了诸如标题样式、纸张大小、章节格式等属性，相当于是文档的“框架”。由&lt;code&gt;LaTeX&lt;/code&gt;定义的基本文档类包括&lt;code&gt;article&lt;/code&gt;、&lt;code&gt;book&lt;/code&gt;、&lt;code&gt;report&lt;/code&gt;等。而&lt;strong&gt;宏包&lt;/strong&gt;（文件后缀名为&lt;code&gt;.sty&lt;/code&gt;）如同编程语言中的“库文件”，可为文档提供若干补充的命令、功能和设置。这是一般的情况。不过，在实际使用时，文档类和宏包却可以发挥类同的作用，这主要是因为&lt;code&gt;LaTeX&lt;/code&gt;系统对文档类/宏包文件的内容、格式未做太过严格的限定，因此许多功能既可以通过文档类实现，也可以通过宏包实现。&lt;code&gt;mcmthesis&lt;/code&gt;采用的文档类样式，实现较复杂，但更为精细。本站的&lt;code&gt;easymcm&lt;/code&gt;宏包二次开发自&lt;code&gt;mcmthesis&lt;/code&gt;的老版本，仍然是一个宏包文件，结构简单，便于使用。&lt;/p&gt;
&lt;p&gt;在实际使用时，文档类通过&lt;code&gt;\documentclass&lt;/code&gt;命令确定，宏包通过&lt;code&gt;\usepackage&lt;/code&gt;命令引用。一份可编译的&lt;code&gt;tex&lt;/code&gt;文档可以引用多个宏包，也可以不引用任何宏包，但&lt;strong&gt;必须&lt;/strong&gt;确定&lt;strong&gt;一种&lt;/strong&gt;文档类。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q1.2&lt;/strong&gt;: 我在编译宏包时出现了以下报错信息，请问是什么问题？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! LaTeX Error: Environment abstract undefined.&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;code&gt;ABSTRACT.tex&lt;/code&gt;文件是不能编译的，其已通过&lt;code&gt;\input&lt;/code&gt;命令嵌入于&lt;code&gt;PAPER.tex&lt;/code&gt;文件之中了。请编译&lt;code&gt;PAPER.tex&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作为补充，需要提醒的是：一份可以编译的&lt;code&gt;LaTeX&lt;/code&gt;源代码，至少要具有以下&lt;strong&gt;两个要素&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;文档类&lt;/strong&gt;的声明（&lt;code&gt;\documentclass&lt;/code&gt;命令）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document&lt;/code&gt;主环境（一段由&lt;code&gt;\begin{document}&lt;/code&gt;与&lt;code&gt;\end{document}&lt;/code&gt;括起来的区域）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果一份文档中缺少以上两个要素，说明其是作为&lt;strong&gt;分支文档&lt;/strong&gt;被嵌入到其他&lt;code&gt;tex&lt;/code&gt;代码中去了，不能用以编译。还不熟悉&lt;code&gt;LaTeX&lt;/code&gt;文档结构的用户，可以此为依据，避免再次出错。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q1.3&lt;/strong&gt;: 我在编译宏包时出现了以下报错信息，请问是什么问题？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! Missing \endcsname inserted.&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 这是由于您不慎编译了&lt;code&gt;easymcm.sty&lt;/code&gt;宏包文件，其是不能编译的。请编译&lt;code&gt;PAPER.tex&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q1.4&lt;/strong&gt;: 看起来&lt;code&gt;easymcm&lt;/code&gt;中不支持中文（相反，&lt;code&gt;mcmthesis&lt;/code&gt;是支持的），请问如何解决这一问题呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 请问您为什么要在美赛论文中插入中文？虽然现在美赛的评委里中国人越来越多了，但美赛论文还是不能用中文写的。&lt;/p&gt;
&lt;p&gt;（补充：若您使用&lt;code&gt;pdflatex&lt;/code&gt;编译文件，请特别注意，一定不要在论文中插入任何&lt;strong&gt;中文符号&lt;/strong&gt;。否则，论文中将会生成类似于某类拉丁字符的乱码，难以检查出来，会影响论文的最终效果。如果您&lt;strong&gt;无法保证&lt;/strong&gt;自己在来回切换输入法的过程中不会误敲中文符号，请使用&lt;code&gt;UTF-8&lt;/code&gt;版本的美赛模板，并使用&lt;code&gt;xelatex&lt;/code&gt;或&lt;code&gt;lualatex&lt;/code&gt;进行编译。这样，不慎敲入的中文符号能够正常显示出来——尽管这仍然影响论文的美观性。）&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Q1.5: 我使用&lt;code&gt;CTeX&lt;/code&gt;套装进行排版，编译时系统报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! LaTeX Error: File ` lastpage.sty ' not found.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是缺少宏包吗？应如何解决呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 就实际经验来说，您使用的应该是非完整版的&lt;code&gt;CTeX&lt;/code&gt;套装，缺少宏包且不能自动联网安装。在安装时，应下载带有&lt;code&gt;Full&lt;/code&gt;字样的安装包，如下图所示（截图来自&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/ctex/legacy/2.9/&quot;&gt;清华镜像&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xjtu-blacksmith/1245580/o_tsinghuaCTeX.jpg&quot; alt=&quot;CTeX下载&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，补充说明：尽管大多数资深的&lt;code&gt;LaTeX&lt;/code&gt;用户都不推荐大家使用老旧的&lt;code&gt;CTeX&lt;/code&gt;套装（我作为一个初级的&lt;code&gt;LaTeX&lt;/code&gt;用户也不推荐），但&lt;code&gt;easymcm&lt;/code&gt;宏包的更新过程中仍将充分考虑与&lt;code&gt;CTeX&lt;/code&gt;套装的兼容性。许多新手仍然先接触到&lt;code&gt;CTeX&lt;/code&gt;套装，这是不以人的意志为转移的现状。&lt;/p&gt;
&lt;h2 id=&quot;图片表格数学公式网址的处理&quot;&gt;2 图片、表格、数学公式、网址的处理&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q2.1&lt;/strong&gt;: 我还不太会插入图标和表格，怎么办怎么办！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;code&gt;easymcm&lt;/code&gt;的发行版本中附带有一份&lt;strong&gt;样例论文&lt;/strong&gt;，其源码中有大量的图、表插入命令，可供参考。另外，您也可参考一般的&lt;code&gt;LaTeX&lt;/code&gt;教程。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q2.2&lt;/strong&gt;: 较大的表格，不易用&lt;code&gt;LaTeX&lt;/code&gt;命令编写。请问是否有解决方案？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 一般而言，有两种解决方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用有关工具将&lt;code&gt;Excel&lt;/code&gt;、&lt;code&gt;Matlab&lt;/code&gt;等表格（矩阵）格式转换为&lt;code&gt;LaTeX&lt;/code&gt;命令，或直接在&lt;strong&gt;可视化界面&lt;/strong&gt;中编辑表格并转换为&lt;code&gt;LaTeX&lt;/code&gt;命令。一个可用的工具是&lt;code&gt;Excel2LaTeX&lt;/code&gt;（LaTeXStudio上的&lt;a href=&quot;http://www.latexstudio.net/archives/6992.html&quot;&gt;中文介绍与下载&lt;/a&gt;、&lt;code&gt;CTAN&lt;/code&gt;上的&lt;a href=&quot;https://ctan.org/tex-archive/support/excel2latex/&quot;&gt;发布页面&lt;/a&gt;），另一个可以&lt;strong&gt;在线转换&lt;/strong&gt;的网页是&lt;code&gt;TablesGenerator&lt;/code&gt;（&lt;a href=&quot;http://www.tablesgenerator.com/latex_tables&quot;&gt;点此进入&lt;/a&gt;，我推荐这一方式）。其中的若干门道，这里就不再介绍了，用户可以自行尝试。&lt;/li&gt;
&lt;li&gt;将表格截图后以图片形式插入到&lt;code&gt;LaTeX&lt;/code&gt;中。这是最方便的做法，问题在于截图是&lt;strong&gt;位图格式&lt;/strong&gt;的，对文档的显示效果可能有一定的影响。同时，在插入截图时，还应采取这样的“&lt;strong&gt;古怪&lt;/strong&gt;”方式：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\begin{table}[!htbp]
\centering
\caption{Name of the table}\label{tb:XXX}
\includegraphics[width=Xcm]{XXX.jpg}
\end{table}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此，显示出的标题将是“Table X: Name of the table”，而不是“Figure”。原理上，&lt;code&gt;figure&lt;/code&gt;环境与&lt;code&gt;table&lt;/code&gt;环境都是浮动对象，没有本质上的区别，主要区别就在其标题名称（也即&lt;code&gt;\caption&lt;/code&gt;命令的效果）上。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q2.3&lt;/strong&gt;: &lt;code&gt;easymcm&lt;/code&gt;自带的样例论文中，所有的表格几乎都是&lt;strong&gt;三线表&lt;/strong&gt;。不能使用更复杂的样式吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 三线表是科技论文中的通用表格形式，简洁明快，在美赛论文中的确不推荐用其他类型的表格。但是，如果需要处理&lt;strong&gt;特别复杂&lt;/strong&gt;的表格，必须在表格中用若干竖线分隔（&lt;strong&gt;这是三线表中不应该出现的！&lt;/strong&gt;），则还是用&lt;strong&gt;默认&lt;/strong&gt;的表格样式为好。不建议新手自己用代码写复杂表格，请按照&lt;strong&gt;Q2.2&lt;/strong&gt;中所提供的解决方案来生成复杂表格的&lt;code&gt;LaTeX&lt;/code&gt;代码。关于三线表的更多信息，可以查看三线表宏包&lt;code&gt;booktabs&lt;/code&gt;的&lt;a href=&quot;http://mirrors.ctan.org/macros/latex/contrib/booktabs/booktabs.pdf&quot;&gt;说明文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q2.4&lt;/strong&gt;: &lt;code&gt;LaTeX&lt;/code&gt;中的公式代码太繁琐了，记不住、用不熟，怎么破？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 如果您已经比较熟悉&lt;code&gt;LaTeX&lt;/code&gt;中数学公式的基本语法，以及若干的数学环境，只是对具体的符号代码感到苦恼，可以准备一份&lt;strong&gt;公式代码表&lt;/strong&gt;在手头以供查阅。各种纸质的、在线的&lt;code&gt;LaTeX&lt;/code&gt;教程中，都有这样的公式符号代码表。我的&lt;a href=&quot;https://xjtu-blacksmith.github.io/sharing-page/&quot;&gt;资源分享页面&lt;/a&gt;中所引用的两种电子版教程（&lt;em&gt;A Primer&lt;/em&gt;以及&lt;code&gt;lshort&lt;/code&gt;）中，也有这样的表可供查阅。&lt;/p&gt;
&lt;p&gt;如果您对基本的公式语法都感到陌生，则建议您利用其他&lt;strong&gt;可视化编辑器&lt;/strong&gt;生成&lt;code&gt;LaTeX&lt;/code&gt;代码。使用&lt;code&gt;Office&lt;/code&gt;套装处理文档的用户，应该比较熟悉&lt;code&gt;MathType&lt;/code&gt;&lt;strong&gt;公式编辑器&lt;/strong&gt;了，其内置有生成&lt;code&gt;TeX&lt;/code&gt;代码的模块，具体的配置方法可在网上容易地找到（前提是，您使用的是完整版的&lt;code&gt;MathType&lt;/code&gt;，不是在试用期结束后残存的“&lt;em&gt;精简版&lt;/em&gt;”）。另外，还有一个较好的&lt;a href=&quot;https://www.codecogs.com/latex/eqneditor.php&quot;&gt;在线公式编辑器&lt;/a&gt;，语言可调整为中文，使用十分便捷，同时也可以充当一个&lt;strong&gt;公式表&lt;/strong&gt;：如果您遗忘了某些符号，或记不清矩阵、积分号等的使用方法，可直接在界面上寻找对应按钮，点击就能生成规范的&lt;code&gt;LaTeX&lt;/code&gt;代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q2.5&lt;/strong&gt;: 插入由&lt;code&gt;\texttt&lt;/code&gt;引导的网址时，出现了&lt;strong&gt;不能换行&lt;/strong&gt;的问题。如何解决？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 打字机字族&lt;code&gt;ttfamily&lt;/code&gt;在&lt;code&gt;TeX&lt;/code&gt;的底层定义中，默认是&lt;strong&gt;不能换行&lt;/strong&gt;的。（参考这个知乎上的&lt;a href=&quot;https://www.zhihu.com/question/53129242&quot;&gt;回答&lt;/a&gt;）解决方案不少，本站提供的&lt;code&gt;easymcm&lt;/code&gt;宏包中是用&lt;code&gt;url&lt;/code&gt;宏包下&lt;code&gt;\UrlBreaks&lt;/code&gt;命令定义换行字符来解决的。不幸的是，我目前所提供的样例论文中并没有应用这一方案——那时我和队友还在学习&lt;code&gt;LaTeX&lt;/code&gt;论文排版，采用的手段还是手动换行。为了自动换行，请在论文正文及参考文献区采用&lt;code&gt;\url&lt;/code&gt;命令将需要引用的网址括起来，例如一个含网址的&lt;code&gt;bibitem&lt;/code&gt;应写成这样：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\bibitem{XXX}Easymcm: A useful template for MCM/ICM. 2019.1.22. \url{https://www.cnblogs.com/xjtu-blacksmith/p/9737960.html}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图所示，可见自动换行的问题已解决了。特别注意，&lt;code&gt;\url&lt;/code&gt;是一个&lt;strong&gt;抄录环境&lt;/strong&gt;——也就是说，在其中不需要将&lt;code&gt;_&lt;/code&gt;、&lt;code&gt;^&lt;/code&gt;、&lt;code&gt;$&lt;/code&gt;等字符做&lt;strong&gt;转义&lt;/strong&gt;处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xjtu-blacksmith/1245580/o_url.jpg&quot; alt=&quot;url命令的使用&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;样式字体字号段落的设置&quot;&gt;3 样式、字体字号、段落的设置&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q3.1: 我想将论文字体调整为&lt;code&gt;Times New Roman&lt;/code&gt;，请问如何做？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 首先，美赛官方未要求论文字体，仅要求论文的字号不小于12号，因此任何字体都是可以的。其次，如果您一定要使用一般情况下的规范字体&lt;code&gt;Times New Roman&lt;/code&gt;，首先应将&lt;code&gt;PAPER.tex&lt;/code&gt;导言区中的&lt;code&gt;\usepackage{palatino}&lt;/code&gt;去掉，然后再在原位置引用另一宏包：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\usepackage{mathptmx}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次编译即可。&lt;code&gt;mathptmx&lt;/code&gt;宏包提供了一种可用的&lt;code&gt;Times New Roman&lt;/code&gt;字体。详细内容，可以参考LaTeXStudio上的&lt;a href=&quot;http://www.latexstudio.net/archives/9323.html&quot;&gt;一篇介绍&lt;/a&gt;），读者也可以尝试该页面上所提供的其他方案。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q3.2&lt;/strong&gt;: 如何调整&lt;strong&gt;段间距&lt;/strong&gt;？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 在&lt;code&gt;easymcm&lt;/code&gt;宏包目前版本（&lt;code&gt;v5.02&lt;/code&gt;）的模板文件夹内，&lt;code&gt;ABSTRACT.tex&lt;/code&gt;文件中，有一段已经被注释掉的命令：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;% 下面的语句可调整全文行距为标准值的0.6倍，请自行使用
% \renewcommand{\baselinestretch}{0.6}\normalsize&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将下面命令的注释号去掉，即可使之生效；修改其倍数，即可调整段落间距的大小（设为&lt;code&gt;0&lt;/code&gt;则表示不需要段间距）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q3.3&lt;/strong&gt;: 为调整页边距，我在导言区加载了&lt;code&gt;geometry&lt;/code&gt;宏包后页面显示有问题，请问哪里出了问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;code&gt;easymcm&lt;/code&gt;中已经加载过&lt;code&gt;geometry&lt;/code&gt;宏包了，再次加载会出错（有如在&lt;code&gt;C++&lt;/code&gt;程序中多次引用头文件的错误）。不推荐用户修改相关参数。如一定要修改，则应打开&lt;code&gt;easymcm.sty&lt;/code&gt;并修改引用&lt;code&gt;geometry&lt;/code&gt;宏包时所设定的参数。&lt;/p&gt;
&lt;p&gt;特别说明：论文排版时常用的各类宏包，诸如&lt;code&gt;geometry&lt;/code&gt;、&lt;code&gt;hyperref&lt;/code&gt;、&lt;code&gt;booktabs&lt;/code&gt;、&lt;code&gt;fontspec&lt;/code&gt;、&lt;code&gt;fancyhdr&lt;/code&gt;、&lt;code&gt;xcolor&lt;/code&gt;、&lt;code&gt;graphicx&lt;/code&gt;等，全部都在&lt;code&gt;easymcm&lt;/code&gt;之中加载过了，切不可在论文正文的导言区&lt;strong&gt;再次加载&lt;/strong&gt;。如果要修改加载这些宏包时所设置的参数，请使用宏包所提供的设置接口，或直接到&lt;code&gt;easymcm.sty&lt;/code&gt;的对应位置修改。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q3.4&lt;/strong&gt;: 如何修改目录、正文标题的样式？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;strong&gt;不推荐&lt;/strong&gt;用户修改。如果您有能力轻松地修改这些样式，那何必过来用&lt;code&gt;easymcm&lt;/code&gt;这样的入门级模板呢？如您一定要定制自己的论文样式，可以参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24501131&quot;&gt;这个页面&lt;/a&gt;（但注意，请不要在美赛论文中使用&lt;code&gt;\ctexset&lt;/code&gt;之类的中文处理命令，&lt;code&gt;easymcm&lt;/code&gt;中并未添加对中文的支持！），也可参考&lt;code&gt;titlesec&lt;/code&gt;宏包的&lt;a href=&quot;http://mirrors.ctan.org/macros/latex/contrib/titlesec/titlesec.pdf&quot;&gt;说明文档&lt;/a&gt;——处理目录、标题样式的&lt;code&gt;titlesec&lt;/code&gt;、&lt;code&gt;titletoc&lt;/code&gt;宏包均已在&lt;code&gt;easymcm&lt;/code&gt;中加载过了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q3.5&lt;/strong&gt;: 我使用的美赛模板是&lt;code&gt;mcmthesis&lt;/code&gt;文档类，默认的论文样式中有多余的&lt;strong&gt;摘要页&lt;/strong&gt;。请问如何去除？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 使用&lt;code&gt;mcmthesis&lt;/code&gt;自带的设置命令：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\mcmsetup{CTeX = false, tcn = 1234567, problem = A,%
  sheet = true, titleinsheet = true, keywordsinsheet = true,%
  titlepage = false, abstract = false}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可将其调整到符合美赛论文规范的程度（队伍控制号&lt;code&gt;tcn&lt;/code&gt;和选题&lt;code&gt;problem&lt;/code&gt;需根据实际情况再做调整）。其他问题，请用户参考&lt;code&gt;mcmthesis&lt;/code&gt;自带的&lt;a href=&quot;http://static.latexstudio.net/article/2019/0120/mcmthesis-guide.pdf&quot;&gt;说明文档&lt;/a&gt;（原则上，如果您安装的是完整版的&lt;code&gt;TeX&lt;/code&gt;发行版，则可以直接用本地搜索引擎搜索到&lt;code&gt;mcmthesis.pdf&lt;/code&gt;这份参考文档）。您也可直接联系&lt;code&gt;mcmthesis&lt;/code&gt;目前的维护者，在[LaTeXStudio]上您可以找到其站长（&lt;code&gt;mcmthesis&lt;/code&gt;目前的维护者）的联系方式。&lt;/p&gt;
&lt;h2 id=&quot;目录交叉引用的相关问题&quot;&gt;4 目录、交叉引用的相关问题&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q4.1&lt;/strong&gt;: 编译后，生成了空白的目录，请问发生了什么？！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;strong&gt;重复编译&lt;/strong&gt;几次即可。别慌。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q4.2&lt;/strong&gt;: 如何自己定义目录上各条目的样式？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 请参考问题&lt;strong&gt;Q3.4&lt;/strong&gt;的回答。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q4.3&lt;/strong&gt;: 我的论文章节太多，导致目录生成了两页。如何将其压缩到一页以内？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 美赛论文理应短小精悍、结构突出，一篇20页的论文不应有太过繁密的章节划分。目录应当控制在一页以内，因此&lt;code&gt;easymcm&lt;/code&gt;宏包中未考虑目录超出一页的情形。如果目录&lt;strong&gt;被迫&lt;/strong&gt;超出一页（&lt;em&gt;即实在无法删减章节&lt;/em&gt;），有下列解决方案：&lt;/p&gt;
&lt;p&gt;(1) 将目录页上的&lt;strong&gt;字号&lt;/strong&gt;改小，方法是到&lt;code&gt;easymcm.sty&lt;/code&gt;的第125行左右，加入一条&lt;strong&gt;缩小字号&lt;/strong&gt;的命令：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;%=========目录的制作==========
\renewcommand\tableofcontents{%
\centerline{\normalfont\Large\bfseries\contentsname%
\@mkboth{%
\MakeUppercase\contentsname}{\MakeUppercase\contentsname}}%
\vskip 3ex%
\small% 这条命令是新加入的
\@starttoc{toc}%
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法对于目录内容仅微微多于一页的情形是适用的。&lt;/p&gt;
&lt;p&gt;(2) 不显示三级标题，只显示二级标题。方法是到&lt;code&gt;easymcm.sty&lt;/code&gt;的第48行，将原来的&lt;code&gt;\setcounter{tocdepth}{3}&lt;/code&gt;改成&lt;code&gt;\setcounter{tocdepth}{2}&lt;/code&gt;。（也可在不修改&lt;code&gt;sty&lt;/code&gt;文件的前提下，直接在&lt;code&gt;PAPER.tex&lt;/code&gt;的导言区声明&lt;code&gt;\setcounter{tocdepth}{2}&lt;/code&gt;，以覆盖之前的计数器。）&lt;/p&gt;
&lt;p&gt;(3) 定制目录样式，去掉目录中&lt;code&gt;section&lt;/code&gt;级别标题的默认顶部间距。方法在网上可查到，但&lt;strong&gt;不推荐&lt;/strong&gt;，因目录样式定制不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;如您坚持认为自己的论文&lt;strong&gt;必须&lt;/strong&gt;有两页目录，请参考一位博友所引用的解决方案：&lt;a href=&quot;https://www.zhihu.com/question/28067948/answer/312184585&quot;&gt;知乎页面&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q4.4&lt;/strong&gt;: 我设置了正确的&lt;code&gt;\label&lt;/code&gt;&amp;amp;&lt;code&gt;\ref&lt;/code&gt;引用，但输出的论文中却显示出“??”，这是什么情况？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: 请参考&lt;strong&gt;Q4.1&lt;/strong&gt;的回答。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 13:24:00 +0000</pubDate>
<dc:creator>黑山雁</dc:creator>
<og:description>一年一度的美国大学生数学建模竞赛（MCM/ICM）又要开始了。在比赛中，将有一部分同学选择用 排版论文，以使论文获得更好的视觉效果；但是，就既往经验来看，其中的很大一部分同学，还并没有熟练地掌握 的相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjtu-blacksmith/p/10306189.html</dc:identifier>
</item>
<item>
<title>Linux中删除特殊名称文件的多种方式 - 守望先生</title>
<link>http://www.cnblogs.com/bianchengzhuji/p/10305781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengzhuji/p/10305781.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今日分享：我们在肉体的疾病方面花了不少钱，精神的病害方面却没有花什么，现在已经到了时候，我们应该有不平凡的学校。--《瓦尔登湖》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们都知道，在linux删除一个文件可以使用rm命令，但是有一些特殊名称的文件使用普通的rm方式却没法删除，本文介绍linux中删除特殊名称文件的多种方式。&lt;/p&gt;
&lt;h2 id=&quot;hlinux&quot;&gt;linux文件命名规则&lt;/h2&gt;
&lt;p&gt;在介绍之前，简单说明一下linux中文件命名规则。文件或目录名由除“/”和空字符“\0”之外的任意ASCII字符序列组成。当然很多操作系统允许更多类型的字符组成文件名。但对于我们来说，从来不建议使用一些特殊字符来命名文件。不幸的是，我们可能无意中创建了一些特殊名称的文件，或者由程序意外的创建了一些由特殊字符组成的文件。这个时候，要删除它们，似乎没有想象中的那么简单。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;删除时带上路径&lt;/h2&gt;
&lt;p&gt;假设有一个名为-static文件，我们使用普通方式将它删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm -static&lt;br/&gt;rm: invalid option -- 's'&lt;br/&gt;Try 'rm ./-static' to remove the file '-static'.&lt;br/&gt;Try 'rm --help' for more information.&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常可惜，这种方式提示出错，并不能成功地删除-static文件。这是为什么？我们知道在linux中，通常以-开头，后面跟一些字符，作为一个命令的选项，而不巧的，-static就被rm命令认为是一个参数选项，更不幸的是，实际上并没有该选项，因此最终提示invalid option -- 's'，导致-static文件无法删除。&lt;/p&gt;
&lt;p&gt;那么有没有什么办法删除呢？我们注意到，除了提示非法选项外，还让我们尝试rm ./-static，是否可以呢？我们试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm ./-static&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终发现，我们将-static文件成功删除了。因此得到我们的第一种方式，&lt;strong&gt;删除文件时带上路径&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;删除时使用 --&lt;/h2&gt;
&lt;p&gt;前面除了提示让我们使用rm ./-static之外，还让我们使用rm --help获取更多信息，那么我们就看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm --&lt;span class=&quot;hljs-built_in&quot;&gt;help&lt;br/&gt;(省略部分内容)&lt;br/&gt;To remove a file whose name starts with a '-', for example '-foo',&lt;br/&gt;use one of these commands:&lt;br/&gt;rm -- -foo&lt;br/&gt;rm ./-foo&lt;br/&gt;(省略部分内容)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容较多，但是可以注意到上面的内容，对于以-开头的文件，提供了两种删除方式，第二种是前面提到的，而第二种，是在删除的文件前面再加--：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm -- -static&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现这种方式也是可以删除以-开头的文件。&lt;/p&gt;
&lt;h2 id=&quot;h-3&quot;&gt;删除时用引号引起来&lt;/h2&gt;
&lt;p&gt;对于特殊字符，如&amp;lt;&amp;gt;!*等组成的文件如何删除呢？例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm &amp;lt;&amp;gt;\!*&lt;br/&gt;rm: missing operand&lt;br/&gt;Try 'rm --help' for more information.&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这种类型的文件，我们需要用引号将文件名包含起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;&amp;gt;\!*&quot;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以删除掉了，但是这种方式并不能针对所有该类型的文件，例如，文件名为!*的文件就不能通过这样的方式删除，因为!*是有其他含义的，具体可参看《&lt;a href=&quot;https://www.huyanbing.me/2018/12/22/40915.html&quot;&gt;linux中！的惊叹用法&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&quot;h-4&quot;&gt;增加转义字符删除文件&lt;/h2&gt;
&lt;p&gt;既然!*无法通过加引号的方式删除，那还有什么办法吗？有！删除时，增加转义字符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm \!*&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样便可以删除。在linux中，很多字符有着特殊的含义，因此当你需要把它当普通字符使用时，就需要在前面加上\转义字符，这和C语言中的转义有点类似。再举个例子，要删除以空格开头的abc文件，可以使用下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; rm \ abc&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可成功删除。&lt;/p&gt;
&lt;h2 id=&quot;hi&quot;&gt;按照i节点号删除&lt;/h2&gt;
&lt;p&gt;很多时候，文件名压根没法输入，因为它们都是一堆乱码。因此也完全无法通过前面介绍的方法进行删除，那还有办法吗？有！通过查找文件的i节点，按照i节点进行删除。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;span class=&quot;bash&quot;&gt; ls -i &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于find命令用法，可参考《&lt;a href=&quot;https://www.huyanbing.me/2018/12/15/21083.html&quot;&gt;find命令高级用法&lt;/a&gt;》。这种通过i节点号进行删除的方式适用于前面所提到的任何类型文件。&lt;/p&gt;
&lt;p&gt;这里扩展说几句。在操作系统中，它是如何识别一个文件的呢？它并不是通过文件名，而是通过一个iNode号，即i节点号来识别不同的文件，文件名不过是这个文件其中的一个属性而已。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;使用通配符删除&lt;/h2&gt;
&lt;p&gt;不多解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;$ rm *.pdf&lt;br/&gt;$ &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这种方式可能存在误删，因为只要文件名结尾为.pdf就会被删除，因此根据实际情况慎重使用。&lt;/p&gt;
&lt;h2 id=&quot;h-6&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;删除特殊文件名称的方法有很多，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除时带上路径&lt;/li&gt;
&lt;li&gt;删除时使用 --&lt;/li&gt;
&lt;li&gt;删除时用引号引起来&lt;/li&gt;
&lt;li&gt;使用转义字符辅助删除&lt;/li&gt;
&lt;li&gt;按照i节点号删除&lt;/li&gt;
&lt;li&gt;使用通配符删除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同类型文件可选择使用上面所提较方便的方式进行删除。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;微信公众号【编程珠玑】：专注但不限于分享计算机编程基础，Linux，C语言，C++，算法，数据库等编程相关[原创]技术文章，号内包含大量经典电子书和视频学习资源。欢迎一起交流学习，一起修炼计算机“内功”，知其然，更知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 22 Jan 2019 11:57:00 +0000</pubDate>
<dc:creator>守望先生</dc:creator>
<og:description>我们都知道，在linux删除一个文件可以使用rm命令，但是有一些特殊名称的文件使用普通的rm方式却没法删除，该怎么办呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengzhuji/p/10305781.html</dc:identifier>
</item>
<item>
<title>SpringMVC中session使用&amp;&amp;拦截器&amp;&amp;乱码处理&amp;&amp;异常处理 - Top丶赵立全</title>
<link>http://www.cnblogs.com/topzhao/p/10305715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/topzhao/p/10305715.html</guid>
<description>&lt;p&gt;### 1. 使用Session&lt;/p&gt;
&lt;p&gt;通常，会在Session中存放：&lt;/p&gt;
&lt;p&gt;1. 客户端（用户）的身份标识，通常是用户的id；&lt;br/&gt;2. 使用频率非常高的数据，例如显示在页面中的用户名、头像等；&lt;br/&gt;3. 其它的不便于使用其它存储方案来存取或传递的数据。&lt;/p&gt;
&lt;p&gt;关于Session的使用，和`ModelMap`几乎一样，即在处理请求的方法中添加`HttpSession`参数，并在方法体中操作该参数对象即可。&lt;/p&gt;
&lt;p&gt;### 2. 拦截器：Interceptor&lt;/p&gt;
&lt;p&gt;Spring MVC中的拦截器(Interceptor)与Java EE中的过滤器(Filter)比较相似，可以对某些请求尝试拦截，由开发者自行编写拦截的逻辑，使得某些请求可以执行，而某些请求将不允许执行，实现统一管理的效果。&lt;/p&gt;
&lt;p&gt;在使用时，必须先自定义拦截器类，实现`HandlerInterceptor`接口，然后在Spring的配置文件中进行配置。&lt;/p&gt;
&lt;p&gt;当实现`HandlerInterceptor`接口后，需要重写3个未实现的方法，其中，`public boolean preHandle()`方法是起到拦截作用的，在运行在控制器之前的，该方法的返回值是boolean类型的，表示是否放行，即返回true则放行，返回false则拦截！一旦拦截，控制器方法将不会被执行，并且拦截器中剩下的2个方法也不会被执行，如果通过浏览器进行访问，界面将显示一片空白！&lt;/p&gt;
&lt;p&gt;注意：即使执行重定向语法，如果拦截器`return true;`，依然会执行控制器中的方法和拦截器中另2个方法，则没有拦截效果，所以，当符合拦截条件时，应该`return false;`。&lt;/p&gt;
&lt;p&gt;关于拦截器的配置大致如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器链 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第1个拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/index.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.tedu.spring.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第2个拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第3个拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第N个拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即：SpringMVC是支持**拦截器链**的，在同一个项目中，允许存在多个拦截器，形成拦截器链，多个拦截器的执行先后顺序取决于配置的先后顺序。&lt;/p&gt;
&lt;p&gt;在配置每一个拦截器的`&amp;lt;mvc:interceptor&amp;gt;`节点中，`&amp;lt;mvc:mapping&amp;gt;`节点用于配置需要拦截的路径，该节点可以存在若干个，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/index.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/logout.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.tedu.spring.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且，在配置路径时，是支持通配符的，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即：例如`/user/reg.do`、`/user/login.do`、`/user/handle_reg.do`等这些路径都在拦截范围之内！&lt;/p&gt;
&lt;p&gt;但是，需要注意的是：1个星号表示的通配符只能匹配1层路径，例如`/user/*`不可以匹配到`/user/news/list.do`这样的路径！如果要匹配若干层路径，可以使用2个星号，例如配置为`/user/**`。&lt;/p&gt;
&lt;p&gt;除此以外，在配置时，还可以添加`&amp;lt;mvc:exclude-mapping&amp;gt;`节点，以配置例外，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加例外 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/reg.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/login.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/handle_reg.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/user/handle_login.do&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;关于`&amp;lt;mvc:exclude-mapping&amp;gt;`的配置方式，与`&amp;lt;mvc:mapping&amp;gt;`相同，也可以使用通配符。&lt;/p&gt;
&lt;p&gt;以上`&amp;lt;mvc:mapping&amp;gt;`也可以理解为**拦截名单**，而`&amp;lt;mvc:exclude-mapping&amp;gt;`就是**白名单**。&lt;/p&gt;
&lt;p&gt;以上配置是必须有先后顺序的，`&amp;lt;mvc:mapping&amp;gt;`必须在最前，其次是`&amp;lt;mvc:exclude-mapping&amp;gt;`，最后是拦截器`&amp;lt;bean&amp;gt;`。&lt;/p&gt;
&lt;p&gt;仅在拦截范围之内的，才会触发拦截器执行（无论最终是拦截还是放行），如果某路径不在拦截范围之内（包含被添加到例外的），将根本就不触发拦截器的执行。&lt;/p&gt;
&lt;p&gt;### 3. SpringMVC项目的乱码解决方案&lt;/p&gt;
&lt;p&gt;整个SpringMVC框架默认使用的编码都是ISO-8859-1，是不支持中文的，所以，在`DispatcherServlet`接收到请求的那一刻起，数据的编码就已经是ISO-8859-1，为了修改编码，只能通过过滤器(Filter)来设置，在SpringMVC中也定义好了`CharacterEncodingFilter`，用于设置字符编码，所以，当使用SpringMVC时，应该在`web.xml`中配置该过滤器，并为这个过滤器类的`encoding`属性设置编码值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;utf-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;### 4. SpringMVC处理异常&lt;/p&gt;
&lt;p&gt;控制器是向客户端进行响应的组件，如果在控制器中的代码运行时出现异常，应该进行处理，如果不处理异常，则会按照默认的方式处理，有几处问题：&lt;/p&gt;
&lt;p&gt;1. 对于没有计算机开发相关基础的用户而言，体验很差（界面上显示的错误完全看不懂）；&lt;br/&gt;2. 对于掌握了计算机开发相关技术的用户而言，可能从中获取当前项目的某些实现细节（异常的跟踪信息中会显示某些类、方法的名称等），导致项目的部分内容外泄；&lt;br/&gt;3. 其它问题。&lt;/p&gt;
&lt;p&gt;所以，在控制器中，应该对可能存在的异常进行处理！注意：此处的“处理”不包括使用`throw`抛出，而是通过`try...catch`类似的方式捕获并在`catch`代码块中进行处理，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;null.do&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String showNull(
            String username, ModelMap modelMap) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            username.length();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
            String message &lt;/span&gt;= &quot;您的操作有误，未提交必要的参数，请&amp;lt;a href=input.do&amp;gt;重新提交&amp;lt;/a&amp;gt;！&quot;&lt;span&gt;;
            modelMap.addAttribute(&lt;/span&gt;&quot;msg&quot;&lt;span&gt;, message);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于异常出现的频率可能较高，或者，在多个不同的请求中都可能出现，那么，在每个方法中都进行处理，是不现实的，也不便于代码的管理！&lt;/p&gt;
&lt;p&gt;在SpringMVC中，提供了2种统一处理异常的做法：&lt;/p&gt;
&lt;p&gt;**1. 通过SimpleMappingExceptionResolver**&lt;/p&gt;
&lt;p&gt;在Spring的配置文件中，对`SimpleMappingExceptionResolver`进行配置，确定异常与转发的页面的映射即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 处理异常 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;exceptionMappings&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;java.lang.NullPointerException&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;error&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;java.lang.StringIndexOutOfBoundsException&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;oob&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;java.lang.RuntimeException&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;runtime&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;使用这种做法时，如果出现异常，框架将自动转发到对应的页面，开发者难以对异常出现的原因作出针对性的处理！所以，这种做法只适合比较粗糙的、大概的处理异常！&lt;/p&gt;
&lt;p&gt;同时，这种做法固定使用转发来显示错误提示页面，无法更改为其它方式的响应！&lt;/p&gt;
&lt;p&gt;**2. 使用@ExceptionHandler**&lt;/p&gt;
&lt;p&gt;在控制器类中，可以自定义处理异常的方法，并在方法之前添加`@ExceptionHandler`注解，该方法的设计规则与处理请求的方法大致相同，区别在于参数不可以随便写，必须包含1个异常类型的参数，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @ExceptionHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String handleException(Exception e) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; NullPointerException) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; StringIndexOutOfBoundsException) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;oob&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;exception&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt; 使用`@ExceptionHandler`之前，必须保证在Spring配置文件中已经配置了注解驱动，即`&amp;lt;mvc:annotation-driven /&amp;gt;`。&lt;/p&gt;
&lt;p&gt;在使用`@ExceptionHandler`注解时，可以在注解中添加属性的配置，以确定所处理的异常的范围，例如：&lt;/p&gt;
&lt;p&gt;@ExceptionHandler(IndexOutOfBoundsException.class)&lt;/p&gt;
&lt;p&gt;经过以上配置，仅`IndexOutOfBoundsException`及其子孙类异常会被接下来的方法进行处理，而其它异常的出现，并不会导致对应的方法被执行！&lt;/p&gt;
&lt;p&gt;在控制器中，允许同时存在多个处理异常的方法！&lt;/p&gt;
&lt;p&gt;处理异常的方法仅能作用于当前控制器类中的请求！如果某个处理异常的方法的代码希望被通用，可以将这个处理异常的方法写在控制器类的基类中。&lt;/p&gt;
&lt;p&gt;以上两种统一处理异常的方式是可以同时存在的！且第2种方式的优先级高于第1种方式。&lt;/p&gt;
&lt;p&gt;**附：常见异常**&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    Throwable
        Error
            OutOfMemoryError
        Exception
            SqlException
            IOException
                FileNotFoundException
            RuntimeException
                NullPointException
                ClassCastException
                ArithmeticException
                IndexOutOfBoundsException
                    ArrayIndexOutOfBoundsException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;### 【附】 拦截器和过滤器的区别&lt;/p&gt;
&lt;p&gt;过滤器(Filter)是Java EE体系中的，而拦截器(Interceptor)是SpringMVC中的；&lt;/p&gt;
&lt;p&gt;过滤器是在所有的Servlet之前执行的，而拦截器的初次执行是在DispatcherServlet之后、在Controller之前执行的；&lt;/p&gt;
&lt;p&gt;过滤器的过滤范围只能在web.xml中通过&amp;lt;url-pattern&amp;gt;这1个节点来配置，而拦截器可以配置多个拦截路径，且可以添加例外，配置更加灵活；&lt;/p&gt;
&lt;p&gt;所有的请求都可以被过滤器进行处理，却只有交由DispatcherServlet分发的请求才可能被拦截器处理！&lt;/p&gt;
&lt;p&gt;### 【附】 字符编码问题 / 出错时的乱码问题&lt;/p&gt;
&lt;p&gt;在不考虑某些编码不支持中文的情况下，使用了支持中文的编码，仍会出现乱码的原因只有1个：存和取的时候使用了不同的编码。&lt;/p&gt;
&lt;p&gt;所以，解决方案就是：整个项目涉及的所有位置全部使用相同的编码！&lt;/p&gt;
&lt;p&gt;通常，需要指定编码的位置有：&lt;br/&gt;1. 项目的源代码，例如某个String类型数据的值；&lt;br/&gt;2. 显示界面的组件所使用的编码，例如HTML/JSP使用的编码；&lt;br/&gt;3. 数据存储位置使用的编码，例如数据库中的编码；&lt;br/&gt;4. 数据传输过程中使用的编码，例如请求、响应，或数据库连接的URL。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 11:41:00 +0000</pubDate>
<dc:creator>Top丶赵立全</dc:creator>
<og:description>### 1. 使用Session 通常，会在Session中存放： 1. 客户端（用户）的身份标识，通常是用户的id；2. 使用频率非常高的数据，例如显示在页面中的用户名、头像等；3. 其它的不便于使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/topzhao/p/10305715.html</dc:identifier>
</item>
<item>
<title>一次 Java 内存泄漏的排查 - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/10305428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/10305428.html</guid>
<description>&lt;h2 id=&quot;由来&quot;&gt;由来&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;前些日子小组内安排值班，轮流看顾我们的服务，主要做一些报警邮件处理、Bug 排查、运营 issue 处理的事。工作日还好，无论干什么都要上班的，若是轮到周末，那这一天算是毁了。&lt;/p&gt;
&lt;p&gt;不知道是公司网络广了就这样还是网络运维组不给力，网络总有问题，不是这边交换机脱网了就是那边路由器坏了，还偶发地各种超时，而我们灵敏地服务探测服务总能准确地抓住偶现的小问题，给美好的工作加点料。好几次值班组的小伙伴们一起吐槽，商量着怎么避过服务保活机制，偷偷停了探测服务而不让人发现（虽然也并不敢）。&lt;/p&gt;
&lt;p&gt;前些天我就在周末处理了一次探测服务的锅。&lt;/p&gt;
&lt;p&gt;转载随意，文章会持续修订，请注明来源地址：&lt;a href=&quot;https://zhenbianshu.github.io/&quot;&gt;https://zhenbianshu.github.io&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;网络问题&quot;&gt;网络问题？&lt;/h4&gt;
&lt;p&gt;晚上七点多开始，我就开始不停地收到报警邮件，邮件显示探测的几个接口有超时情况。 多数执行栈都在：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;n&quot;&gt;java&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;io&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;BufferedReader&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;readLine&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;371&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;java&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;io&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;BufferedReader&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;readLine&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;BufferReader&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;389&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;java_io_BufferedReader$readLine&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;call&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;Unknown &lt;span class=&quot;n&quot;&gt;Source&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;com&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;domain&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;detect&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;http&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;HttpClient&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;getResponse&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;HttpClient&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;122&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;com&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;domain&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;detect&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;http&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;HttpClient&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;this&lt;span class=&quot;err&quot;&gt;$&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;n&quot;&gt;$getResponse&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;HttpClient&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个线程栈的报错我见得多了，我们设置的 HTTP DNS 超时是 1s， connect 超时是 2s， read 超时是 3s，这种报错都是探测服务正常发送了 HTTP 请求，服务器也在收到请求正常处理后正常响应了，但数据包在网络层层转发中丢失了，所以请求线程的执行栈会停留在获取接口响应的地方。这种情况的典型特征就是能在服务器上查找到对应的日志记录。而且日志会显示服务器响应完全正常。 与它相对的还有线程栈停留在 Socket connect 处的，这是在建连时就失败了，服务端完全无感知。&lt;/p&gt;
&lt;p&gt;我注意到其中一个接口报错更频繁一些，这个接口需要上传一个 4M 的文件到服务器，然后经过一连串的业务逻辑处理，再返回 2M 的文本数据，而其他的接口则是简单的业务逻辑，我猜测可能是需要上传下载的数据太多，所以超时导致丢包的概率也更大吧。&lt;/p&gt;
&lt;p&gt;根据这个猜想，群登上服务器，使用请求的 request_id 在近期服务日志中搜索一下，果不其然，就是网络丢包问题导致的接口超时了。&lt;/p&gt;
&lt;p&gt;当然这样 leader 是不会满意的，这个结论还得有人接锅才行。于是赶紧联系运维和网络组，向他们确认一下当时的网络状态。网络组同学回复说是我们探测服务所在机房的交换机老旧，存在未知的转发瓶颈，正在优化，这让我更放心了，于是在部门群里简单交待一下，算是完成任务。&lt;/p&gt;
&lt;h4 id=&quot;问题爆发&quot;&gt;问题爆发&lt;/h4&gt;
&lt;p&gt;本以为这次值班就起这么一个小波浪，结果在晚上八点多，各种接口的报警邮件蜂拥而至，打得准备收拾东西过周日单休的我措手不及。&lt;/p&gt;
&lt;p&gt;这次几乎所有的接口都在超时，而我们那个大量网络 I/O 的接口则是每次探测必超时，难道是整个机房故障了么。&lt;/p&gt;
&lt;p&gt;我再次通过服务器和监控看到各个接口的指标都很正常，自己测试了下接口也完全 OK，既然不影响线上服务，我准备先通过探测服务的接口把探测任务停掉再慢慢排查。&lt;/p&gt;
&lt;p&gt;结果给暂停探测任务的接口发请求好久也没有响应，这时候我才知道没这么简单。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;内存泄漏&quot;&gt;内存泄漏&lt;/h4&gt;
&lt;p&gt;于是赶快登陆探测服务器，首先是 &lt;code class=&quot;highlighter-rouge&quot;&gt;top free df&lt;/code&gt; 三连，结果还真发现了些异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/detect_cpu_exception.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的探测进程 CPU 占用率特别高，达到了 900%。&lt;/p&gt;
&lt;p&gt;我们的 Java 进程，并不做大量 CPU 运算，正常情况下，CPU 应该在 100~200% 之间，出现这种 CPU 飙升的情况，要么走到了死循环，要么就是在做大量的 GC。&lt;/p&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jstat -gc pid [interval]&lt;/code&gt; 命令查看了 java 进程的 GC 状态，果然，FULL GC 达到了每秒一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/jstat.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么多的 FULL GC，应该是内存泄漏没跑了，于是 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jstack pid &amp;gt; jstack.log&lt;/code&gt; 保存了线程栈的现场，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jmap -dump:format=b,file=heap.log pid&lt;/code&gt; 保存了堆现场，然后重启了探测服务，报警邮件终于停止了。&lt;/p&gt;
&lt;h4 id=&quot;jstat&quot;&gt;jstat&lt;/h4&gt;
&lt;p&gt;jstat 是一个非常强大的 JVM 监控工具，一般用法是： &lt;code class=&quot;highlighter-rouge&quot;&gt;jstat [-options] pid interval&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它支持的查看项有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-class 查看类加载信息&lt;/li&gt;
&lt;li&gt;-compile 编译统计信息&lt;/li&gt;
&lt;li&gt;-gc 垃圾回收信息&lt;/li&gt;
&lt;li&gt;-gcXXX 各区域 GC 的详细信息 如 -gcold&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用它，对定位 JVM 的内存问题很有帮助。&lt;/p&gt;
&lt;h2 id=&quot;排查&quot;&gt;排查&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;问题虽然解决了，但为了防止它再次发生，还是要把根源揪出来。&lt;/p&gt;
&lt;h4 id=&quot;分析栈&quot;&gt;分析栈&lt;/h4&gt;
&lt;p&gt;栈的分析很简单，看一下线程数是不是过多，多数栈都在干嘛。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;nb&quot;&gt;grep &lt;span class=&quot;s1&quot;&gt;'java.lang.Thread.State' jstack.log  | wc &lt;span class=&quot;nt&quot;&gt;-l
&lt;span class=&quot;o&quot;&gt;&amp;gt; 464
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;才四百多线程，并无异常。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;nb&quot;&gt;grep &lt;span class=&quot;nt&quot;&gt;-A 1 &lt;span class=&quot;s1&quot;&gt;'java.lang.Thread.State' jstack.log  | &lt;span class=&quot;nb&quot;&gt;grep &lt;span class=&quot;nt&quot;&gt;-v &lt;span class=&quot;s1&quot;&gt;'java.lang.Thread.State' | sort | uniq &lt;span class=&quot;nt&quot;&gt;-c |sort &lt;span class=&quot;nt&quot;&gt;-n

     10         at java.lang.Class.forName0&lt;span class=&quot;o&quot;&gt;(Native Method&lt;span class=&quot;o&quot;&gt;)
     10         at java.lang.Object.wait&lt;span class=&quot;o&quot;&gt;(Native Method&lt;span class=&quot;o&quot;&gt;)
     16         at java.lang.ClassLoader.loadClass&lt;span class=&quot;o&quot;&gt;(ClassLoader.java:404&lt;span class=&quot;o&quot;&gt;)
     44         at sun.nio.ch.EPollArrayWrapper.epollWait&lt;span class=&quot;o&quot;&gt;(Native Method&lt;span class=&quot;o&quot;&gt;)
    344         at sun.misc.Unsafe.park&lt;span class=&quot;o&quot;&gt;(Native Method&lt;span class=&quot;o&quot;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;线程状态好像也无异常，接下来分析堆文件。&lt;/p&gt;
&lt;h4 id=&quot;下载堆-dump-文件&quot;&gt;下载堆 dump 文件。&lt;/h4&gt;
&lt;p&gt;堆文件都是一些二进制数据，在命令行查看非常麻烦，Java 为我们提供的工具都是可视化的，Linux 服务器上又没法查看，那么首先要把文件下载到本地。&lt;/p&gt;
&lt;p&gt;由于我们设置的堆内存为 4G，所以 dump 出来的堆文件也很大，下载它确实非常费事，不过我们可以先对它进行一次压缩。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gzip&lt;/code&gt; 是个功能很强大的压缩命令，特别是我们可以设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1 ~ -9&lt;/code&gt; 来指定它的压缩级别，数据越大压缩比率越大，耗时也就越长，推荐使用 -6~7， -9 实在是太慢了，且收益不大，有这个压缩的时间，多出来的文件也下载好了。&lt;/p&gt;
&lt;h4 id=&quot;使用-mat-分析-jvm-heap&quot;&gt;使用 MAT 分析 jvm heap&lt;/h4&gt;
&lt;p&gt;MAT 是分析 Java 堆内存的利器，使用它打开我们的堆文件（将文件后缀改为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.hprof&lt;/code&gt;）, 它会提示我们要分析的种类，对于这次分析，果断选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;memory leak suspect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/heap_pie.png&quot; alt=&quot;&quot;/&gt;从上面的饼图中可以看出，绝大多数堆内存都被同一个内存占用了，再查看堆内存详情，向上层追溯，很快就发现了罪魁祸首。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/heap_object.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析代码&quot;&gt;分析代码&lt;/h4&gt;
&lt;p&gt;找到内存泄漏的对象了，在项目里全局搜索对象名，它是一个 Bean 对象，然后定位到它的一个类型为 Map 的属性。&lt;/p&gt;
&lt;p&gt;这个 Map 根据类型用 ArrayList 存储了每次探测接口响应的结果，每次探测完都塞到 ArrayList 里去分析，由于 Bean 对象不会被回收，这个属性又没有清除逻辑，所以在服务十来天没有上线重启的情况下，这个 Map 越来越大，直至将内存占满。&lt;/p&gt;
&lt;p&gt;内存满了之后，无法再给 HTTP 响应结果分配内存了，所以一直卡在 readLine 那。而我们那个大量 I/O 的接口报警次数特别多，估计跟响应太大需要更多内存有关。&lt;/p&gt;
&lt;p&gt;给代码 owner 提了 PR，问题圆满解决。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;其实还是要反省一下自己的，一开始报警邮件里还有这样的线程栈：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;n&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;json&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;internal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;decodeValueInternal&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;166&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;json&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;internal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;decodeJsonObject&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;132&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;json&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;internal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;decodeValueInternal&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;186&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;json&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;internal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;decodeJsonObject&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;132&lt;span class=&quot;o&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;groovy&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;json&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;internal&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;decodeValueInternal&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;n&quot;&gt;JsonParserCharArray&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;java&lt;span class=&quot;o&quot;&gt;:&lt;span class=&quot;mi&quot;&gt;186&lt;span class=&quot;o&quot;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;看到这种报错线程栈却没有细想，要知道 TCP 是能保证消息完整性的，况且消息没有接收完也不会把值赋给变量，这种很明显的是内部错误，如果留意后细查是能提前查出问题所在的，查问题真是差了哪一环都不行啊。&lt;/p&gt;
&lt;p&gt;关于本文有什么疑问可以在下面留言交流，如果您觉得本文对您有帮助，欢迎关注我的 &lt;a href=&quot;https://weibo.com/u/5715965217&quot;&gt;微博&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/zhenbianshu/&quot;&gt;GitHub&lt;/a&gt; 。您也可以在我的 &lt;a href=&quot;https://github.com/zhenbianshu/zhenbianshu.github.io&quot;&gt;博客REPO&lt;/a&gt; 右上角点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;Watch&lt;/code&gt; 并选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;Releases only&lt;/code&gt; 项来 &lt;code class=&quot;highlighter-rouge&quot;&gt;订阅&lt;/code&gt; 我的博客，有新文章发布会第一时间通知您。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 11:00:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<og:description>由来 前些日子小组内安排值班，轮流看顾我们的服务，主要做一些报警邮件处理、Bug 排查、运营 issue 处理的事。工作日还好，无论干什么都要上班的，若是轮到周末，那这一天算是毁了。 不知道是公司网络</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/10305428.html</dc:identifier>
</item>
<item>
<title>Django+JWT实现Token认证 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/10305437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/10305437.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对外提供API不用django rest framework（DRF）就是旁门左道吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于Token的鉴权机制越来越多的用在了项目中，尤其是对于纯后端只对外提供API没有web页面的项目，例如我们通常所讲的前后端分离架构中的纯后端服务，只提供API给前端，前端通过API提供的数据对页面进行渲染展示或增加修改等，我们知道HTTP是一种无状态的协议，也就是说后端服务并不知道是谁发来的请求，那么如何校验请求的合法性呢？这就需要通过一些方式对请求进行鉴权了&lt;/p&gt;
&lt;p&gt;先来看看传统的登录鉴权跟基于Token的鉴权有什么区别&lt;/p&gt;
&lt;p&gt;以Django的账号密码登录为例来说明传统的验证鉴权方式是怎么工作的，当我们登录页面输入账号密码提交表单后，会发送请求给服务器，服务器对发送过来的账号密码进行验证鉴权，验证鉴权通过后，把用户信息记录在服务器端（django_session表中），同时返回给浏览器一个sessionid用来唯一标识这个用户，浏览器将sessionid保存在cookie中，之后浏览器的每次请求都一并将sessionid发送给服务器，服务器根据sessionid与记录的信息做对比以验证身份&lt;/p&gt;
&lt;p&gt;Token的鉴权方式就清晰很多了，客户端用自己的账号密码进行登录，服务端验证鉴权，验证鉴权通过生成Token返回给客户端，之后客户端每次请求都将Token放在header里一并发送，服务端收到请求时校验Token以确定访问者身份&lt;/p&gt;
&lt;p&gt;session的主要目的是给无状态的HTTP协议添加状态保持，通常在浏览器作为客户端的情况下比较通用。而Token的主要目的是为了鉴权，同时又不需要考虑CSRF防护以及跨域的问题，所以更多的用在专门给第三方提供API的情况下，客户端请求无论是浏览器发起还是其他的程序发起都能很好的支持。所以目前基于Token的鉴权机制几乎已经成了前后端分离架构或者对外提供API访问的鉴权标准，得到广泛使用&lt;/p&gt;
&lt;p&gt;JSON Web Token（JWT)是目前Token鉴权机制下最流行的方案，网上关于JWT的介绍有很多，这里不细说，只讲下Django如何利用JWT实现对API的认证鉴权，搜了几乎所有的文章都是说JWT如何结合DRF使用的，如果你的项目没有用到DRF框架，也不想仅仅为了鉴权API就引入庞大复杂的DRF框架，那么可以接着往下看&lt;/p&gt;
&lt;p&gt;我的需求如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同一个view函数既给前端页面提供数据，又对外提供API服务，要同时满足基于账号密码的验证和JWT验证&lt;/li&gt;
&lt;li&gt;项目用了Django默认的权限系统，既能对账号密码登录的进行权限校验，又能对基于JWT的请求进行权限校验&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要实现上边的需求1，我们首先得引入JWT模块，python下有现成的PyJWT模块可以直接用，先看下JWT的简单用法&lt;/p&gt;
&lt;h5 id=&quot;安装pyjwt&quot;&gt;安装PyJWT&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;$ pip install pyjwt&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;利用pyjwt生成token&quot;&gt;利用PyJWT生成Token&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import jwt
&amp;gt;&amp;gt;&amp;gt; encoded_jwt = jwt.encode({'username':'运维咖啡吧','site':'https://ops-coffee.cn'},'secret_key',algorithm='HS256')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里传了三部分内容给JWT，&lt;/p&gt;
&lt;p&gt;第一部分是一个Json对象，称为Payload，主要用来存放有效的信息，例如用户名，过期时间等等所有你想要传递的信息&lt;/p&gt;
&lt;p&gt;第二部分是一个秘钥字串，这个秘钥主要用在下文Signature签名中，服务端用来校验Token合法性，这个秘钥只有服务端知道，不能泄露&lt;/p&gt;
&lt;p&gt;第三部分指定了Signature签名的算法&lt;/p&gt;
&lt;h5 id=&quot;查看生成的token&quot;&gt;查看生成的Token&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(encoded_jwt)
b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Ilx1OGZkMFx1N2VmNFx1NTQ5Nlx1NTU2MVx1NTQyNyIsInNpdGUiOiJodHRwczovL29wcy1jb2ZmZWUuY24ifQ.fIpSXy476r9F9i7GhdYFNkd-2Ndz8uKLgJPcd84BkJ4'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JWT生成的Token是一个用两个点（.）分割的长字符串&lt;/p&gt;
&lt;p&gt;点分割成的三部分分别是Header头部，Payload负载，Signature签名：&lt;code&gt;Header.Payload.Signature&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;JWT是不加密的，任何人都可以读的到其中的信息，其中第一部分Header和第二部分Payload只是对原始输入的信息转成了base64编码，第三部分Signature是用header+payload+secret_key进行加密的结果&lt;/p&gt;
&lt;p&gt;可以直接用base64对Header和Payload进行解码得到相应的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import base64
&amp;gt;&amp;gt;&amp;gt; base64.b64decode('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9')
b'{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}'

&amp;gt;&amp;gt;&amp;gt; base64.b64decode('eyJ1c2VybmFtZSI6Ilx1OGZkMFx1N2VmNFx1NTQ5Nlx1NTU2MVx1NTQyNyIsInNpdGUiOiJodHRwczovL29wcy1jb2ZmZWUuY24ifQ==')
# 这里最后加=的原因是base64解码对传入的参数长度不是2的对象，需要再参数最后加上一个或两个等号=&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为JWT不会对结果进行加密，所以不要保存敏感信息在Header或者Payload中，服务端也主要依靠最后的Signature来验证Token是否有效以及有无被篡改&lt;/p&gt;
&lt;h5 id=&quot;解密token&quot;&gt;解密Token&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; jwt.decode(encoded_jwt,'secret_key',algorithms=['HS256'])
{'username': '运维咖啡吧', 'site': 'https://ops-coffee.cn'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端在有秘钥的情况下可以直接对JWT生成的Token进行解密，解密成功说明Token正确，且数据没有被篡改&lt;/p&gt;
&lt;p&gt;当然我们前文说了JWT并没有对数据进行加密，如果没有secret_key也可以直接获取到Payload里边的数据，只是缺少了签名算法无法验证数据是否准确，pyjwt也提供了直接获取Payload数据的方法，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; jwt.decode(encoded_jwt, verify=False)
{'username': '运维咖啡吧', 'site': 'https://ops-coffee.cn'}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Django要兼容session认证的方式，还需要同时支持JWT，并且两种验证需要共用同一套权限系统，该如何处理呢？我们可以参考Django的解决方案：装饰器，例如用来检查用户是否登录的&lt;code&gt;login_required&lt;/code&gt;和用来检查用户是否有权限的&lt;code&gt;permission_required&lt;/code&gt;两个装饰器，我们可以自己实现一个装饰器，检查用户的认证模式，同时认证完成后验证用户是否有权限操作&lt;/p&gt;
&lt;p&gt;于是一个&lt;code&gt;auth_permission_required&lt;/code&gt;的装饰器产生了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf import settings
from django.http import JsonResponse
from django.contrib.auth import get_user_model
from django.core.exceptions import PermissionDenied

UserModel = get_user_model()


def auth_permission_required(perm):
    def decorator(view_func):
        def _wrapped_view(request, *args, **kwargs):
            # 格式化权限
            perms = (perm,) if isinstance(perm, str) else perm

            if request.user.is_authenticated:
                # 正常登录用户判断是否有权限
                if not request.user.has_perms(perms):
                    raise PermissionDenied
            else:
                try:
                    auth = request.META.get('HTTP_AUTHORIZATION').split()
                except AttributeError:
                    return JsonResponse({&quot;code&quot;: 401, &quot;message&quot;: &quot;No authenticate header&quot;})

                # 用户通过API获取数据验证流程
                if auth[0].lower() == 'token':
                    try:
                        dict = jwt.decode(auth[1], settings.SECRET_KEY, algorithms=['HS256'])
                        username = dict.get('data').get('username')
                    except jwt.ExpiredSignatureError:
                        return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;Token expired&quot;})
                    except jwt.InvalidTokenError:
                        return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;Invalid token&quot;})
                    except Exception as e:
                        return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;Can not get user object&quot;})

                    try:
                        user = UserModel.objects.get(username=username)
                    except UserModel.DoesNotExist:
                        return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;User Does not exist&quot;})

                    if not user.is_active:
                        return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;User inactive or deleted&quot;})

                    # Token登录的用户判断是否有权限
                    if not user.has_perms(perms):
                        return JsonResponse({&quot;status_code&quot;: 403, &quot;message&quot;: &quot;PermissionDenied&quot;})
                else:
                    return JsonResponse({&quot;status_code&quot;: 401, &quot;message&quot;: &quot;Not support auth type&quot;})

            return view_func(request, *args, **kwargs)

        return _wrapped_view

    return decorator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在view使用时就可以用这个装饰器来代替原本的&lt;code&gt;login_required&lt;/code&gt;和&lt;code&gt;permission_required&lt;/code&gt;装饰器了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@auth_permission_required('account.select_user')
def user(request):
    if request.method == 'GET':
        _jsondata = {
            &quot;user&quot;: &quot;ops-coffee&quot;,
            &quot;site&quot;: &quot;https://ops-coffee.cn&quot;
        }
        
        return JsonResponse({&quot;state&quot;: 1, &quot;message&quot;: _jsondata})
    else:
        return JsonResponse({&quot;state&quot;: 0, &quot;message&quot;: &quot;Request method 'POST' not supported&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要一个生成用户Token的方法，通过给User model添加一个token的静态方法来处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class User(AbstractBaseUser, PermissionsMixin):
    create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    update_time = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    username = models.EmailField(max_length=255, unique=True, verbose_name='用户名')
    fullname = models.CharField(max_length=64, null=True, verbose_name='中文名')
    phonenumber = models.CharField(max_length=16, null=True, unique=True, verbose_name='电话')
    is_active = models.BooleanField(default=True, verbose_name='激活状态')

    objects = UserManager()

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = []

    def __str__(self):
        return self.username

    @property
    def token(self):
        return self._generate_jwt_token()

    def _generate_jwt_token(self):
        token = jwt.encode({
            'exp': datetime.utcnow() + timedelta(days=1),
            'iat': datetime.utcnow(),
            'data': {
                'username': self.username
            }
        }, settings.SECRET_KEY, algorithm='HS256')

        return token.decode('utf-8')

    class Meta:
        default_permissions = ()

        permissions = (
            (&quot;select_user&quot;, &quot;查看用户&quot;),
            (&quot;change_user&quot;, &quot;修改用户&quot;),
            (&quot;delete_user&quot;, &quot;删除用户&quot;),
        )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接通过用户对象来生成Token：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from accounts.models import User
&amp;gt;&amp;gt;&amp;gt; u = User.objects.get(username='admin@ops-coffee.cn')
&amp;gt;&amp;gt;&amp;gt; u.token
'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NDgyMjg3NzksImlhdCI6MTU0ODE0MjM3OSwiZGF0YSI6eyJ1c2VybmFtZSI6ImFkbWluQDE2My5jb20ifX0.akZNU7t_z2kwPxDJjmc-QxtNdICK0yhnwWmKxqqXKLw'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的Token给到客户端，客户端就可以拿这个Token进行鉴权了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import requests
&amp;gt;&amp;gt;&amp;gt; token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1NDgyMjg4MzgsImlhdCI6MTU0ODE0MjQzOCwiZGF0YSI6eyJ1c2VybmFtZSI6ImFkbWluQDE2My5jb20ifX0.oKc0SafgksMT9ZIhTACupUlz49Q5kI4oJA-B8-GHqLA'
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; r = requests.get('http://localhost/api/user', headers={'Authorization': 'Token '+token})
&amp;gt;&amp;gt;&amp;gt; r.json()
{'username': 'admin@ops-coffee.cn', 'fullname': '运维咖啡吧', 'is_active': True}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个&lt;code&gt;auth_permission_required&lt;/code&gt;方法就可以搞定上边的全部需求了，简单好用。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img alt=&quot;长按关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有帮助，请点右下角【好看】。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 11:00:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>对外提供API不用django rest framework（DRF）就是旁门左道吗？ 基于Token的鉴权机制越来越多的用在了项目中，尤其是对于纯后端只对外提供API没有web页面的项目，例如我们通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/10305437.html</dc:identifier>
</item>
<item>
<title>Python+Selenium爬取动态加载页面（1） - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/10304350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/10304350.html</guid>
<description>&lt;blockquote readability=&quot;5.7985611510791&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 最近有一小任务，需要收集水质和水雨信息，找了两个网站：&lt;a href=&quot;http://123.127.175.45:8082/&quot;&gt;国家地表水水质自动监测实时数据发布系统&lt;/a&gt;和&lt;a href=&quot;http://xxfb.hydroinfo.gov.cn/ssIndex.html&quot;&gt;全国水雨情网&lt;/a&gt;。由于这两个网站的数据都是动态加载出来的，所以我用了Selenium来完成我的数据获取。数据的获取过程跟人手动获取过程类似，所以也不会对服务器造成更大负荷。这是我写的第1个爬虫，初次接触，还请各位多多指教。本文的代码见&lt;a href=&quot;https://cloud.tsinghua.edu.cn/d/fcb82707948c4d609a40/&quot;&gt;Selenium获取动态页面数据1.ipynb或Selenium获取动态页面数据1.py&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;工欲善其事，必先装好环境，耐心地把下面的环境装好。&lt;/p&gt;
&lt;ul readability=&quot;2.193685202639&quot;&gt;&lt;li&gt;建议安装Python3的版本，一般来说越新越好。这是官网&lt;a href=&quot;https://www.python.org/getit/&quot;&gt;下载安装&lt;/a&gt;，或者网上其它&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=0&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=Python%E5%AE%89%E8%A3%85&quot;&gt;教程&lt;/a&gt;。&lt;/li&gt;
&lt;li readability=&quot;0.86036960985626&quot;&gt;
&lt;p&gt;安装Selenium和其一些必要的包：&lt;/p&gt;
&lt;pre class=&quot;batch&quot;&gt;
&lt;code&gt;pip install pandas
pip install bs4
pip install selenium&lt;/code&gt;
&lt;/pre&gt;
&lt;code&gt;pandas&lt;/code&gt;自不必多说，非常强大的数据分析库，&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=0&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=Pandas%E5%85%A5%E9%97%A8&quot;&gt;网上教程非常丰富&lt;/a&gt;。&lt;code&gt;bs4&lt;/code&gt;是一个比较方便的html页面解析的包，详细的可以自由百度教程，网上有很多，当然也有它的&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot;&gt;Beautiful Soup官网文档&lt;/a&gt;，这是中文的，比较良心。&lt;code&gt;selenium&lt;/code&gt;能够用于自动测试我们的网页，模拟我们的浏览器，也很强大，它的&lt;a href=&quot;https://selenium-python.readthedocs.io/installation.html#introduction&quot;&gt;说明文档在此&lt;/a&gt;。&lt;/li&gt;
&lt;li readability=&quot;1.8112244897959&quot;&gt;
&lt;p&gt;最后我们需要安装浏览器的支持，如果电脑上已安装有&lt;code&gt;Chrome&lt;/code&gt;浏览器，则还需下载&lt;a href=&quot;http://chromedriver.storage.googleapis.com/index.html&quot;&gt;chromedirver&lt;/a&gt;，注意需要安装与浏览器对应的版本，下载完成后，需要将其添加至系统的&lt;code&gt;Path&lt;/code&gt;中。也可以安装&lt;a href=&quot;http://phantomjs.org/download.html&quot;&gt;PhantomJS&lt;/a&gt;，这是一个无界面的浏览器，速度更快一些，体积也不大。同样，下载好后，需要将其添加至&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=0&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=%E6%B7%BB%E5%8A%A0%E8%87%B3%E7%B3%BB%E7%BB%9FPath&quot;&gt;系统的&lt;code&gt;Path&lt;/code&gt;中&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.8955223880597&quot;&gt;
&lt;p&gt;另外，关于Python的学习环境，建议安装一个&lt;a href=&quot;https://www.baidu.com/s?ie=utf-8&amp;amp;f=8&amp;amp;rsv_bp=0&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=Jupyer%E5%AE%89%E8%A3%85&quot;&gt;Jupyter&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分析待爬取网页&quot;&gt;2.1 分析待爬取网页&lt;/h2&gt;
&lt;p&gt;打开我们的&lt;a href=&quot;http://123.127.175.45:8082/&quot;&gt;国家地表水水质自动监测实时数据发布系统：http://123.127.175.45:8082/&lt;/a&gt;如下图2-1所示，我们可以看到它的数据是动态地在更新，每次只显示了十多条数据，但是这只是一个假象，其实在我们打开页面，加载完成后，所有的数据已经加载过来了，只是没有显示出来，不信我们可以按F12，&lt;code&gt;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt;标签下的数据就是加载完成后的数据，共100条数据（有时候也只有99条）。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig2-1-web_analysis_fig1.png&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/7587235be1da4780977f/?dl=1&quot;/&gt;&lt;p&gt;图2-1 国家地表水水质自动监测实时数据发布系统&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;利用selenium提取数据&quot;&gt;2.2 利用Selenium提取数据&lt;/h2&gt;
&lt;h3 id=&quot;打开网页&quot;&gt;（1）打开网页&lt;/h3&gt;
&lt;p&gt;运行下面代码，会自动弹出Chrome浏览器的窗口；如果用的&lt;code&gt;browser = webdriver.PhantomJS()&lt;/code&gt;，则没有窗口出来。浏览器的窗口出来后，可以看到，它加载出我们的页面了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import datetime
import pandas as pd
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC

# 打开chrome浏览器（需提前安装好chromedriver）
browser = webdriver.Chrome()
# browser = webdriver.PhantomJS()
print(&quot;正在打开网页...&quot;)
browser.get(&quot;http://123.127.175.45:8082/&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;得到页面源码&quot;&gt;（2）得到页面源码&lt;/h3&gt;
&lt;p&gt;网页完成后打开完成后，还需要等待一下它的加载，只有等数据加载完成，我们才能去获取它的&lt;span&gt;HTML页面源码&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(&quot;等待网页响应...&quot;)
# 需要等一下，直到页面加载完成
wait = WebDriverWait(browser, 10)
wait.until(EC.presence_of_element_located((By.CLASS_NAME, &quot;grid&quot;)))

print(&quot;正在获取网页数据...&quot;)
soup = BeautifulSoup(browser.page_source, &quot;lxml&quot;)
browser.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定位数据&quot;&gt;（3）定位数据&lt;/h3&gt;
&lt;p&gt;通过&lt;span&gt;CSS选择器&lt;/span&gt;定位到我们的表头数据和表数据，如下图2-2和图2-3所示&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig2-2-web_css_select1.png&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/ed730bed7e334d00b1ca/?dl=1&quot;/&gt;&lt;p&gt;图2-2 CSS选择(.panel-heading)表头&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig2-3-web_css_select2.png&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/7c601c087cfc40e29506/?dl=1&quot;/&gt;&lt;p&gt;图2-3 CSS选择(.grid)表数据&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 表头和表数据
data_head = soup.select(&quot;.panel-heading&quot;)[0]
grid_data = soup.select(&quot;.grid&quot;)[0]

# 得到表头数据
data_colhead = data_head.findAll(&quot;td&quot;)
data_rows = grid_data.findAll(&quot;tr&quot;)

# 据表头生成数据表
water_df = pd.DataFrame(columns=[c.text for c in data_colhead])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们查看&lt;code&gt;water_df&lt;/code&gt;可以得到如下数据表头：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;断面名称&lt;/th&gt;
&lt;th&gt;测量时间&lt;/th&gt;
&lt;th&gt;pH&lt;/th&gt;
&lt;th&gt;溶解氧&lt;/th&gt;
&lt;th&gt;氨氮&lt;/th&gt;
&lt;th&gt;高锰酸盐指数&lt;/th&gt;
&lt;th&gt;总有机碳&lt;/th&gt;
&lt;th&gt;水质类别&lt;/th&gt;
&lt;th&gt;断面属性&lt;/th&gt;
&lt;th&gt;站点情况&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&lt;h3 id=&quot;提取数据&quot;&gt;（4）提取数据&lt;/h3&gt;
&lt;p&gt;上面我们从表数据中的&lt;code&gt;tr&lt;/code&gt;标签获得所有数据行后，将其所有数据提取出来，添加到我们前面定义好的&lt;code&gt;water_df&lt;/code&gt;中。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(&quot;提取网页数据中...&quot;)
for i, data_row in enumerate(data_rows):
    # 以名字为地名和时间标识符，以防止数据重复
    water_loc = water_df.iloc[:, 0].values
    water_date = water_df.iloc[:, 1].values

    row_dat = [r.text for r in data_row]
    water_df.loc[i] = row_dat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看我获取的数据前5行，如下表&lt;/p&gt;
&lt;p&gt;表2.1 获取的数据表前5行&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;断面名称&lt;/th&gt;
&lt;th&gt;测量时间&lt;/th&gt;
&lt;th&gt;pH&lt;/th&gt;
&lt;th&gt;溶解氧&lt;/th&gt;
&lt;th&gt;氨氮&lt;/th&gt;
&lt;th&gt;高锰酸盐指数&lt;/th&gt;
&lt;th&gt;总有机碳&lt;/th&gt;
&lt;th&gt;水质类别&lt;/th&gt;
&lt;th&gt;断面属性&lt;/th&gt;
&lt;th&gt;站点情况&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;四川攀枝花龙洞&lt;/td&gt;
&lt;td&gt;2019-01-22 12:00&lt;/td&gt;
&lt;td&gt;7.98&lt;/td&gt;
&lt;td&gt;10.72&lt;/td&gt;
&lt;td&gt;0.05&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;仪器故障&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;四川宜宾凉姜沟&lt;/td&gt;
&lt;td&gt;2019-01-22 12:00&lt;/td&gt;
&lt;td&gt;7.75&lt;/td&gt;
&lt;td&gt;10.77&lt;/td&gt;
&lt;td&gt;0.07&lt;/td&gt;
&lt;td&gt;2.18&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;II&lt;/td&gt;
&lt;td&gt;入长江前&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;云南红河州河口&lt;/td&gt;
&lt;td&gt;2019-01-22 12:00&lt;/td&gt;
&lt;td&gt;7.41&lt;/td&gt;
&lt;td&gt;9.09&lt;/td&gt;
&lt;td&gt;0.21&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;II&lt;/td&gt;
&lt;td&gt;中-越出境&lt;/td&gt;
&lt;td&gt;仪器故障&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;云南昆明观音山&lt;/td&gt;
&lt;td&gt;2019-01-22 12:00&lt;/td&gt;
&lt;td&gt;8.51819&lt;/td&gt;
&lt;td&gt;8.69207&lt;/td&gt;
&lt;td&gt;0.27&lt;/td&gt;
&lt;td&gt;7.51&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;IV&lt;/td&gt;
&lt;td&gt;湖体&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;云南昆明西苑隧道&lt;/td&gt;
&lt;td&gt;2019-01-22 12:02&lt;/td&gt;
&lt;td&gt;7.9&lt;/td&gt;
&lt;td&gt;8.7&lt;/td&gt;
&lt;td&gt;0.24&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;II&lt;/td&gt;
&lt;td&gt;湖体&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;保存数据&quot;&gt;（5）保存数据&lt;/h3&gt;
&lt;p&gt;得到数据后，一般要保存我们的数据，&lt;code&gt;pandas&lt;/code&gt;给我们提供了非常方便的方法，可以保存为各种常见格式的数据，下面我们将其保存为&lt;code&gt;.csv&lt;/code&gt;文件格式，由于这里面有中文编码，所以另外还保存了一个&lt;code&gt;GB18030&lt;/code&gt;编码格式的文件，这样直接用excel打开，不会出现乱码。平时如果处理数据，还里建议用下面的&lt;code&gt;utf-8&lt;/code&gt;编码的文件。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data_str = datetime.datetime.now().strftime('%Y_%m_%d')

water_df.to_csv(&quot;data_water_%s_ch.csv&quot; % (data_str),
                index=None, encoding=&quot;GB18030&quot;)

water_df.to_csv(&quot;data_water_%s.csv&quot; % (data_str), index=None)
print(&quot;数据提取完成！！&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据提取完成后，可以看到下面2个文件：&lt;span&gt;data_water_2019_01_22.csv、data_water_2019_01_22_ch.csv&lt;/span&gt;，直接用&lt;code&gt;excel&lt;/code&gt;打开第2个文件，可以看到如下图2-4。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig2-4-web_data_excel&quot; src=&quot;https://cloud.tsinghua.edu.cn/f/4bc29755d6454e609d2b/?dl=1&quot;/&gt;&lt;p&gt;图2-4 最终获取的数据&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这次，我们主要用&lt;code&gt;selenium&lt;/code&gt;模型浏览器得到动态加载的HTML页面源码，然后利用&lt;code&gt;BeautifulSoup&lt;/code&gt;解析其中的数据，最后利用&lt;code&gt;Pandas&lt;/code&gt;处理我们数据。&lt;/p&gt;
&lt;p&gt;这也是我第1次写爬虫，还请各位不吝赐教。此次数据的获取还比较简单，下一篇&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10306429.html&quot;&gt;《Python+Selenium爬取动态加载页面（2）》&lt;/a&gt;再来写一下要点击按钮的，稍微复杂一点点。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 10:51:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>注： 最近有一小任务，需要收集水质和水雨信息，找了两个网站： '国家地表水水质自动监测实时数据发布系统' 和 '全国水雨情网' 。由于这两个网站的数据都是动态加载出来的，所以我用了Selenium来完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/10304350.html</dc:identifier>
</item>
</channel>
</rss>