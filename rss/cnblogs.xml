<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>cocos creator主程入门教程（十一）—— 行为树 - 五邑隐侠</title>
<link>http://www.cnblogs.com/niudanshui/p/10464786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niudanshui/p/10464786.html</guid>
<description>&lt;p&gt;&lt;span&gt;五邑隐侠，本名关健昌，10年游戏生涯，现隐居五邑。本系列文章以TypeScript为介绍语言。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本篇介绍行为树。在RPG游戏中，地图上存在一些剧情NPC，不同的剧情下，NPC的行为会不一样。这些NPC的行为可以通过行为树进行管理。行为树是在固有行为集下，进行行为抉择的AI算法。行为树包括数据解析、逻辑控制、行为执行三部分。&lt;/p&gt;
&lt;p&gt;行为树数据由节点组成，每个节点有对应的行为类型、参数、返回值。节点有一个子节点数组，通过这种方式将节点组织成树状。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export class BehaviorNode {
    private type: number = 0;
    private params: any = null;
    private retVal: any = null;
    private subBehaviors: Array&amp;lt;BehaviorNode&amp;gt; = [];
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;逻辑控制节点都有子节点，逻辑控制指的是跟编程类似的if条件判断、while循环、串行执行、并行执行等。if行为如果返回true，执行子节点行为，子行为结束则整体行为结束。while行为如果返回true，执行子节点行为，如果子节点结束，重置子节点重新执行。串行行为，子节点一条一条的依次执行，子节点结束则整体结束。并行行为，子节点同时执行，子节点结束则整体结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/137210/201903/137210-20190303151853880-1088951075.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;行为树的叶节点是实际行为执行的节点，在开发一款RPG游戏时，需要根据剧情需要，提炼出角色的细粒行为，例如行走、对话、播放表情、切换动画、触发战斗等。一般地，RPG都会开发一个对应的剧情编辑器，对地图上的NPC进行行为设定，导出对应行为的参数。游戏加载这些数据，解析生成行为树，NPC每帧执行行为树，叶节点行为有对应的执行方法，方法的参数为行为节点的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
private _parseWalkData(): BehaviorNode {
    // TODO 二进制数据解析为json
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
public execBehavior(b: BehaviorNode): void {
    if (!b) {
        return;
    }

    switch(b.type) {
        case BehaviorType.WALK:
            this.execWalk(b);
            break;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
private _execWalk(b: BehaviorNode): void {
    let actorId = b.params.id;
    let destGridX = b.params.destGridX;
    let destGridY = b.params.destGridY;
    
    let actor = map.getActor(actorId);
    let curGridX = actor.gridX;
    let curGridY = actor.gridY;
    let loadGrids = AStar.findLoad(curGridX, curGridY, destGridX, destGridY);
    actor.setLoad(loadGrids);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般地，游戏地图中的物件都可以挂载行为树，地图本身、角色、地图物品等，将一个剧情的复杂行为，分拆到每一个地图物件上，通过剧情任务作为条件区分触发，简化行为的组织。程序员只负责将策划的设定提取出细粒行为，编写对应的数据解析和执行方法，由策划使用编辑器编辑数据，由数据驱动剧情的推进。&lt;/p&gt;

&lt;p&gt;行为树先说到这里，下一篇我们将介绍有限状态机。&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 07:41:00 +0000</pubDate>
<dc:creator>五邑隐侠</dc:creator>
<og:description>五邑隐侠，本名关健昌，10年游戏生涯，现隐居五邑。本系列文章以TypeScript为介绍语言。 本篇介绍行为树。在RPG游戏中，地图上存在一些剧情NPC，不同的剧情下，NPC的行为会不一样。这些NPC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niudanshui/p/10464786.html</dc:identifier>
</item>
<item>
<title>设计模式---代理模式 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10463649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10463649.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;背景：&lt;/strong&gt;&lt;/span&gt;听说Java设计模式中的代理模式是进入BAT的必经之路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、代理模式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给某一对象提供一个代理对象，并由代理对象控制对原对象的引用；简而言之，就是在不改变源代码的情况下，实现对目标功能的扩展；比如，你计划下个月结婚，当然你可以自己筹划婚礼的过程，那样太闹腾了，于是你就把筹备婚礼的过程交由婚庆公司布置，并且只需要在婚礼当天使用婚庆公司筹划婚礼的结果即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、代理模式的结构：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a、抽象对象角色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明了目标对象和代理对象的共同接口，那么在任何可以使用目标对象的地方也均可使用代理对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b、目标对象角色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了代理对象所代表的目标对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c、代理对象角色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代理对象内部包含目标对象的引用，So可以自由地操作目标对象，代理对象提供一个与目标对象相同的接口，So可以在任何时候替换目标对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、静态代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从JVM加载类的角度看，静态代理和动态代理本质上是一样的，二者都是在原有类的基础上，加入一些多出的行为，甚至完全替换原有的行为；而静态代理采用的方式是我们手动的将某些行为进行替换，产生一个新的与原有类接口相同却行为不同的类型；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以淘宝网为例，模拟访问网站的场景；如今大家都经常访问淘宝网，几乎所有的Web项目尤其是像淘宝这样的大型网站，是不可能采用集中式的架构，使用的一定是分布式架构，而分布式架构对于用户来说，当我们发起链接的时候，链接指向的并不是最终的应用服务器，而是代理服务器如Nginx，用作负载均衡[用户访问淘宝网 --&amp;gt; 代理服务器 --&amp;gt; 最终服务器]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个服务器Server，以及用于获取页面标题的方法getPageTitle：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; *  用于获取网站数据的服务器接口
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Server {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据url获取页面标题&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPageTitle(String url);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;访问淘宝网的TaobaoServer，传入url，获取页面标题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 淘宝服务器
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TaobaoServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Server{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPageTitle(String url) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的if..else判断&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;http://www.taobao.com&quot;&lt;span&gt;.equals(url)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;淘宝首页&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;http://www.tianmao.taobao.com&quot;&lt;span&gt;.equals(url)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;淘宝-天猫商城&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;空空如也&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;a、若是不使用代理，那么用户访问就相当于直接 new TaobaoServer()并且调用&lt;span&gt;getPageTitle()方法即可；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b、而由于分布式架构的存在，因此需要一个NginxProxy类作为代理，到时候用户直接访问的就是NginxProxy而不直接与TaobaoServer打交道，由&lt;span&gt;NginxProxy&lt;/span&gt;负责与最终的&lt;span&gt;TaobaoServer&lt;/span&gt;打交道；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NginxProxy代理类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.collect.Lists;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Nginx代理
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NginxProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Server{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;淘宝服务器列表&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; TAOBAO_SERVER_ADDRESSES = Lists.newArrayList(&quot;127.0.0.1&quot;,&quot;127.0.0.2&quot;,&quot;127.0.0.3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Server server;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  NginxProxy(Server server) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.server =&lt;span&gt; server;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPageTitle(String url) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;UUID模拟请求原始Ip，正常情况下是传入Request的&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         String remoteIp =&lt;span&gt; UUID.randomUUID().toString();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由选择的算法，这里简单的定义为对remoteIp的Hash之的绝对值取模&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = Math.abs(remoteIp.hashCode()) %&lt;span&gt; TAOBAO_SERVER_ADDRESSES.size();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择淘宝服务器IP&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         String realTaobaoIp =&lt;span&gt; TAOBAO_SERVER_ADDRESSES.get(index);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;【页面标题: &quot; + server.getPageTitle(url) + &quot;】, 【来源IP: &quot; + realTaobaoIp + &quot;】&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用于测试，简单设计服务器列表几个IP，同时由于只是传入一个url而不是具体的Request，每次随机一个UUID并且对其hashCode的绝对值取模，模拟该请求被路由到哪台服务器上：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 静态代理测试类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticProxyTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问淘宝服务器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         TaobaoServer taobaoServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaobaoServer();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问Nginx代理&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         NginxProxy nginxProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NginxProxy(taobaoServer);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(nginxProxy.getPageTitle(&quot;http://www.taobao.com&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于淘宝服务器和代理服务器实际上都是服务器，So它们可以使用相同的接口Server；用户不和最终目标对象角色TaobaoServer打交道，而是与代理对象角色NginxProxy打交道，由代理对象角色NginxProxy控制用户的访问；多次运行来源IP会改变，其结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201903/1580332-20190303123050185-1400294436.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、静态代理的缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态代理的的特点是静态代理的代理类是由程序猿创建的，在程序运行之前静态代理的.class文件就已经存在了；静态代理在代理量较小时还OK，但是代理量增加就会存在两个比较明显的缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a、静态代理的内容，即NginxProxy路由的选择这几段代码，只能服务一路Server该接口，而不能服务于其他接口，若是其他接口想要使用这几行代码如新增一个代理类，而不断的新增，又由于静态代理的内容无法复用，则必然会造成静态代理类过于庞大；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b、Server接口中若是新增了一个方法，如getPageInfo(String url)方法，而实际对象实现了这个方法，代理对象也必须新增getPageInfo(String url)方法，为其增加代理内容；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、动态代理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于静态代理的局限性，孕育而生了动态代理；静态代理是死的，在我们编译期间即按下CTRL+S的那一刻就给被代理对象生成了一个不可动态改变的代理类，而动态代理就是在运行期间动态生成代理类的一种更为灵活的代理模式；动态代理是JDK自带的功能，它需要实现一个InvocationHandler接口，并调用Proxy的静态方法产生代理类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nginx InvocationHandler：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.collect.Lists;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Nginx InvocationHandler
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NginxInvovationHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;淘宝服务器列表&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; TAOBAO_SERVER_ADDRESSES = Lists.newArrayList(&quot;127.0.0.1&quot;,&quot;127.0.0.2&quot;,&quot;127.0.0.3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object object;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NginxInvovationHandler(Object object) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.object =&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         String remoteIp =&lt;span&gt; UUID.randomUUID().toString();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = Math.abs(remoteIp.hashCode()) %&lt;span&gt; TAOBAO_SERVER_ADDRESSES.size();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         String realTaobaoIp =&lt;span&gt; TAOBAO_SERVER_ADDRESSES.get(index);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行速度：StringBuilder &amp;gt; StringBuffer &amp;gt; String&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         sb.append(&quot; 【页面标题: &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        sb.append(method.invoke(object, args));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         sb.append(&quot;】,【来源Ip: &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        sb.append(realTaobaoIp);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         sb.append(&quot;】&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的动态代理NginxInvovationHandler 将选择服务器的逻辑抽象成广告的代码，因为调用的是Object中的method，而Object又是所有类的超类/父类，So并不只限定于接口Server，任意的其他接口都可以使用该服务，因此该NginxInvovationHandler可以灵活的各处复用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态代理测试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 动态代理测试类
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxyTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDynamicProxy(String url) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         TaobaoServer taobaoServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaobaoServer();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         InvocationHandler invocationHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NginxInvovationHandler(taobaoServer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Proxy的newProxyInstance方法可以产生对目标接口对一个代理，代理内容则由InvocationHandler实现&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         Server proxy = (Server)Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.getClass().getClassLoader(), &lt;span&gt;new&lt;/span&gt; Class[] {Server.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}, invocationHandler);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        System.out.println(proxy.getPageTitle(url));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         String url = &quot;http://www.taobao.com&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         DynamicProxyTest dynamicProxyTest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DynamicProxyTest();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        dynamicProxyTest.testDynamicProxy(url);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     
&lt;span&gt;21&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;动态代理程序运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201903/1580332-20190303135954570-593067980.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、动态代理的优/缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a、减少了类的数量，看起来比较直观；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b、代理内容可以复用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c、最重要的是动态代理可以在不修改源代码的基础上在源代码上进行操作，如在吐司上抹果酱的AOP原理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其最大的缺点就是只能针对接口生成代理，不能针对某一个类生成代理，如我们在调用Proxy的newProxyInstance方法时，第二个参数传入的是某个具体类的getClass()，程序就会抛出如下错误：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: proxy.DynamicHelloWorldImpl is not an &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是因为java.lang.reflect.Proxy 的newProxyInstance 方法会判断传入的Class是不是一个接口，源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  * Verify that the Class object actually represents an
  * interface.
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;interfaceClass.isInterface()) {
 &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
    interfaceClass.getName() &lt;/span&gt;+ &quot; is not an interface&quot;&lt;span&gt;);
}
...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而在实际编程中，要为某一个单独的类实现代理很正常，这种情况下我们就可以使用CGLIB(一种字节码增强技术)来为某一个类实现代理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、GCLIB动态代理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HelloService业务类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 没有实现任何接口的业务类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloService {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloService() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;HelloService构造&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法不被覆盖，cglib无法代理由final修饰的方法&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayOthers(String name) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;HelloService : sayOthers &amp;gt;&amp;gt; &quot; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         System.out.println(&quot;HelloService : sayHello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自定义MethodInterceptor类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 自定义MethodInterceptor
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyMethodInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * sub: cglib生成的代理对象
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * method: 被代理对象方法
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * objects: 方法入参
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * methodProxy: 代理方法
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;插入前置通知&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Object object =&lt;span&gt; methodProxy.invokeSuper(sub, objects);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;插入后置通知&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;CGLIB代理对象调用目标方法:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.assertj.core.internal.cglib.core.DebuggingClassWriter;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * CGLIB代理对象调用目标方法
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理类class文件存入本地磁盘，方便反编译查看源码&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;/TJT/Code&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过cglib动态代理 获取代理对象的过程&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置enhance 对象的父类&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         enhancer.setSuperclass(HelloService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置enhance 的回调对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         enhancer.setCallback(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyMethodInterceptor());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理对象&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         HelloService proxy =&lt;span&gt; (HelloService)enhancer.create();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过代理对象调用目标方法&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        proxy.sayHello();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sayOthers() 被fianl修饰不能被cglib代理&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         proxy.sayOthers(&quot;涛姐涛哥&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        proxy.sayHello();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     
&lt;span&gt;28&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;CGLIB动态代理程序运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201903/1580332-20190303150547455-76628189.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 07:26:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：听说Java设计模式中的代理模式是进入BAT的必经之路。 1、代理模式： 给某一对象提供一个代理对象，并由代理对象控制对原对象的引用；简而言之，就是在不改变源代码的情况下，实现对目标功能的扩展；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10463649.html</dc:identifier>
</item>
<item>
<title>欧拉公式详解-震惊，小学生也能看懂？ - 绍兴土匪</title>
<link>http://www.cnblogs.com/kcfzyhq/p/10465766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kcfzyhq/p/10465766.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天博主在b站上看完了一个&lt;a href=&quot;https://www.bilibili.com/video/av27550005/?spm_id_from=333.788.videocard.1&quot;&gt;视频&lt;/a&gt;。此视频介绍了欧拉从定义&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;、以欧拉命名、伯努利发明的数&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(sin\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(cos\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(e^i\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;的泰勒展开式以及虚数&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;。&lt;br/&gt;这是一篇学习笔记，有错误的话，感谢评论里指出。&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;前置知识&lt;/h2&gt;
&lt;h3 id=&quot;幂法则&quot;&gt;幂法则&lt;/h3&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(f(x)=x^n\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(f'(x)=nx^{n-1}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;证明&quot;&gt;证明&lt;/h4&gt;
&lt;p&gt;新的函数值是&lt;span class=&quot;math inline&quot;&gt;\(f(x+\mathrm{d}x)=(x+\mathrm{d}x)^n=(x+\mathrm{d}x)(x+\mathrm{d}x)(x+\mathrm{d}x)\cdots(x+\mathrm{d}x)\)&lt;/span&gt;&lt;br/&gt;可以由二项式定理得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+\mathrm{d}x)^n=\sum^{n}_{i=0}\left(\begin{array}{c}i\\ n\end{array}\right)x^{n-i}(\mathrm{d}x)^i=\left(\begin{array}{c}0\\ n\end{array}\right)x^n+\left(\begin{array}{c}1\\ n\end{array}\right)x^{n-1}\mathrm{d}x+\left(\begin{array}{c}2\\ n\end{array}\right)x^{n-2}(\mathrm{d}x)^2\cdots\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[df=f(x+\mathrm{d}x)-f(x)=x^{n-1}\mathrm{d}x+x^{n-2}(\mathrm{d}x)^2\cdots\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{df}{dx}=x^{n-1}+\frac{n(n-1)}{2}x^{n-2}dx+\frac{n(n-1)(n-2)}{6}x^{n-2}dx\cdots\]&lt;/span&gt;&lt;br/&gt;因为&lt;span class=&quot;math inline&quot;&gt;\(dx\)&lt;/span&gt;趋向&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;,所以可以忽略含有&lt;span class=&quot;math inline&quot;&gt;\(dx\)&lt;/span&gt;的项,&lt;span class=&quot;math inline&quot;&gt;\(\frac{df}{dx}=x^{n-1}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;加法则&quot;&gt;加法则&lt;/h3&gt;
&lt;p&gt;两个函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\((f(x)+g(x))'=f'(x)+g'(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;积法则&quot;&gt;积法则&lt;/h3&gt;
&lt;p&gt;两个函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\((f(x)g(x))'=f(x)g'(x)+f'(x)g(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;证明-1&quot;&gt;证明&lt;/h4&gt;
&lt;p&gt;由于相乘想到面积来可视化过程，设一个矩形长宽分别为&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;，设&lt;span class=&quot;math inline&quot;&gt;\(h(x)=(f(x)g(x))'\)&lt;/span&gt;&lt;br/&gt;如图所示：&lt;br/&gt;&lt;img src=&quot;https://blog.luojinyao.top/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F/20190107065842612.png&quot;/&gt;&lt;br/&gt;显然增加的面积就是三块有颜色面积的小矩形，绿红黄他们的面积之和为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(x)\mathrm{d}(g(x))+g(x)\mathrm{d}(f(x))+\mathrm{d}(f(x))\mathrm{d}(g(x))=h'(x)\mathrm{d}x\Rightarrow\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(x)g'(x)\mathrm{d}x+g(x)f'(x)\mathrm{d}x+g'(x)\mathrm{d}xf'(x)\mathrm{d}x=h'(x)\mathrm{d}x\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(\frac{h'(x)}{dx}=f(x)g'(x)+g(x)f'(x)+g'(x)f'(x)\mathrm{d}x\)&lt;/span&gt;&lt;br/&gt;发现尾项与&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{d}x\)&lt;/span&gt;有关，当&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{d}x\)&lt;/span&gt;趋向&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;的时候可以忽略。&lt;/p&gt;
&lt;h3 id=&quot;链式法则&quot;&gt;链式法则&lt;/h3&gt;
&lt;p&gt;两个函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(f'(g(x))=f'(g(x))g'(x)\)&lt;/span&gt;，也就是&lt;span class=&quot;math inline&quot;&gt;\(\frac{\mathrm{d}f}{\mathrm{d}x}=\frac{\mathrm{d}f}{\mathrm{d}g}\frac{\mathrm{d}g}{\mathrm{d}x}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;证明-2&quot;&gt;证明&lt;/h4&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;变化量为&lt;span class=&quot;math inline&quot;&gt;\(dx\)&lt;/span&gt;的时候,&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;函数变化量是&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{d}(g(x))\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;函数的变化量为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathrm{d}(f(g(x)))=f'(g(x))\mathrm{d}(g(x))=f'(g(x))g'(x)\mathrm{d}x\Rightarrow \frac{\mathrm{d}(f(g(x))}{\mathrm{d}x}=f'(g(x))g'(x)\]&lt;/span&gt;&lt;br/&gt;最后一步是由导数的定义得来的。&lt;/p&gt;
&lt;h3 id=&quot;通过幂法则链式法则推到商法则&quot;&gt;通过幂法则、链式法则推到商法则&lt;/h3&gt;
&lt;h3 id=&quot;三角函数的导数&quot;&gt;三角函数的导数&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sin'(x)=cos(x)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cos'(x)=-sin(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;证明-3&quot;&gt;证明&lt;/h4&gt;
&lt;h3 id=&quot;高阶导数&quot;&gt;高阶导数&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f^{(n)}(x)\)&lt;/span&gt;指的是&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;阶导数。我自己的理解：描述&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的变化函数是&lt;span class=&quot;math inline&quot;&gt;\(f'(x)\)&lt;/span&gt;，描述&lt;span class=&quot;math inline&quot;&gt;\(f'(x)\)&lt;/span&gt;的变化函数&lt;span class=&quot;math inline&quot;&gt;\(f''(x)\)&lt;/span&gt;，也就是&lt;span class=&quot;math inline&quot;&gt;\(f^{(n)}\)&lt;/span&gt;的变化受到&lt;span class=&quot;math inline&quot;&gt;\(f^{(n+1)}\)&lt;/span&gt;的控制，如果控制&lt;span class=&quot;math inline&quot;&gt;\(f^1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(f^2\)&lt;/span&gt;···他们的函数都相等，那么&quot;理论上&quot;这两个函数是相等的。下面泰勒级数就用到这个思想。&lt;/p&gt;
&lt;h3 id=&quot;拓展无关本文&quot;&gt;拓展（无关本文)&lt;/h3&gt;
&lt;h4 id=&quot;指数函数求导&quot;&gt;指数函数求导&lt;/h4&gt;
&lt;h5 id=&quot;尝试求导&quot;&gt;尝试求导&lt;/h5&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(M(t)=2^t\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\mathrm{d}M}{\mathrm{d}t}=\frac{2^{t+\mathrm{d}t}-2^t}{\mathrm{d}t}=2^t\underbrace{(\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t})}_{dt\to0}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t}\)&lt;/span&gt;趋向于一个常数&lt;span class=&quot;math inline&quot;&gt;\(0.69314718056\cdots\)&lt;/span&gt;&lt;br/&gt;同样函数&lt;span class=&quot;math inline&quot;&gt;\(M(t)=3^t\)&lt;/span&gt;同样的方法，后半部分将趋向于&lt;span class=&quot;math inline&quot;&gt;\(1.09861228867\cdots\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(M(t)=8^t\to 2.07944154168\cdots\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(1.09861228867\cdots{\times3}=2.07944154168\cdots\)&lt;/span&gt;&lt;br/&gt;从指数上&lt;span class=&quot;math inline&quot;&gt;\(8=2^3\)&lt;/span&gt;，说明这个常数是对于对某个数求对数函数得到的。&lt;br/&gt;有没有哪个底数能是的这个系数为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;呢？&lt;br/&gt;即&lt;span class=&quot;math inline&quot;&gt;\((a^t)'=a^t\)&lt;/span&gt;？&lt;/p&gt;
&lt;h5 id=&quot;e的出现&quot;&gt;e的出现&lt;/h5&gt;
&lt;p&gt;这个底数就是&lt;span class=&quot;math inline&quot;&gt;\(e=2.71828\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;ax的导数&quot;&gt;a^x的导数&lt;/h5&gt;
&lt;p&gt;由上面得到&lt;span class=&quot;math inline&quot;&gt;\((a^x)'=a^x\ln(a)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{d(e^{ct})}{\mathrm{d}t}=ce^{ct}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;是常数，由复合函数求导。&lt;br/&gt;所有指数函数&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;写作&lt;span class=&quot;math inline&quot;&gt;\(e^{\ln(2)}\)&lt;/span&gt;&lt;br/&gt;代入上式得到：&lt;span class=&quot;math inline&quot;&gt;\(a^x=e^{\ln(a)t}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;隐函数求导&quot;&gt;隐函数求导&lt;/h4&gt;
&lt;p&gt;圆的方程式&lt;span class=&quot;math inline&quot;&gt;\(x^2+y^2=r\)&lt;/span&gt;，这很显然，如果我们要对它求导怎么办？此时输入一个&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;不一定输出一个&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;。很显然这个函数是可以求导的，也就是求&lt;span class=&quot;math inline&quot;&gt;\((x,y)\)&lt;/span&gt;这个坐标的斜率。&lt;/p&gt;
&lt;h2 id=&quot;泰勒级数&quot;&gt;泰勒级数&lt;/h2&gt;
&lt;h3 id=&quot;由来&quot;&gt;由来&lt;/h3&gt;
&lt;p&gt;一个函数可以写成&lt;span class=&quot;math inline&quot;&gt;\(f(x)=\sum^n_{i=0}{a_ix^i}=a_0+a_1x_1+a_2x_2+\cdots\)&lt;/span&gt;&lt;br/&gt;在高阶导数的时候说过，如果两个函数每一阶导数都相等，那么&quot;理论上&quot;两个函数是相等的。&lt;br/&gt;因为我们有&lt;span class=&quot;math inline&quot;&gt;\(cos'(x)=-sin(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(cos''(x)=-cos(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(cos'''(x)=sin(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(cos''''(x)=cos(x)\)&lt;/span&gt;&lt;br/&gt;此后就是&lt;span class=&quot;math inline&quot;&gt;\(-sin(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(-cos(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(sin(x)\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(cos(x)\)&lt;/span&gt;循环，求导次数&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，其&lt;span class=&quot;math inline&quot;&gt;\(x \mod\ 4=1\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;的时候分别对应这四个。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(cos(0)=1\Rightarrow f(x)=a_0+\sum_{i=1}^n{a_i\cdot0}=a_0=1\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(cos'(0)=0\Rightarrow f'(x)=1\cdot a_1+\sum_{i=2}^n{(i-1)a_i\cdot0}=1!\cdot a_1=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cos''(0)=-1\Rightarrow f''(x)=1\cdot2\cdot a_2+\sum_{i=3}^n{(i-1)\cdot(i-2)a_i}=2!\cdot a_2=-1\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(cos'''(0)=0\Rightarrow f'''(x)=1\cdot2\cdot3 a_3+\sum_{i=4}^n{(i-1)\cdot(i-2)\cdot(i-3)a_i}=3!\cdot a_3=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(cos''''(0)=1\Rightarrow f''''(x)=1\cdot2\cdot3\cdot4 a_4+\sum_{i=5}^n{(i-1)\cdot(i-2)\cdot(i-3)\cdot(i-4)a_i}=4!\cdot a_4=1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以发现规律了，假设取了&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;次导数，且有&lt;span class=&quot;math inline&quot;&gt;\(i=2n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;也就是&lt;span class=&quot;math inline&quot;&gt;\(cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^4}{8!}-\cdots\)&lt;/span&gt;&lt;br/&gt;同样的思路可以证明&lt;span class=&quot;math inline&quot;&gt;\(\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;证明&lt;span class=&quot;math inline&quot;&gt;\(e^x=\cdots\)&lt;/span&gt;比这更容易，根据定义&lt;span class=&quot;math inline&quot;&gt;\((e^x)'=e^x\)&lt;/span&gt;，重复上述过程即可。&lt;/p&gt;
&lt;h3 id=&quot;麦克劳林展开式&quot;&gt;麦克劳林展开式&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(e^x=\sum^\infty_{i=0}{\frac{x^i}{i!}}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+\cdots\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdots\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cos(x)=\sum^{\infty}_{i=2n,n\in N}(-1)^n\frac{x^i}{i!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;本文正题&quot;&gt;本文正题&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(e^{ix}=1+\frac{(ix)^1}{1!}+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\frac{(ix)^5}{5!}=1+\frac{ix}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把带有&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;的提出来有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(e^{ix}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!})=cos(x)+i\times sin(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当&lt;span class=&quot;math inline&quot;&gt;\(x=\pi\)&lt;/span&gt;的时候&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(e^{i\pi}=\cos(\pi)+i\times \sin(\pi)=-1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以&lt;span class=&quot;math inline&quot;&gt;\(e^{i\pi}+1=0\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 07:10:00 +0000</pubDate>
<dc:creator>绍兴土匪</dc:creator>
<og:description>@[toc] 欧拉公式 前言 今天博主在b站上看完了一个 '视频' 。此视频介绍了欧拉从定义$\pi$、以欧拉命名、伯努利发明的数$e$、$sin$和$cos$以及$e^i$、$e$的泰勒展开式以及虚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kcfzyhq/p/10465766.html</dc:identifier>
</item>
<item>
<title>google tensorflow bert代码分析 - Earendil</title>
<link>http://www.cnblogs.com/earendil/p/10465637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/earendil/p/10465637.html</guid>
<description>&lt;p&gt;参考网上博客阅读了bert的代码，记个笔记。代码是 bert_modeling.py&lt;/p&gt;
&lt;p&gt;参考的博客地址：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_39470744/article/details/84401339&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/2a3872148766&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主要分为三部分：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、输入数据处理，将词（中文的字）转换为对应的embeddging，增加positional embeddding 和token type embedding.&lt;/p&gt;
&lt;p&gt;positional embedding 是词的位置信息，词在句子中的位置。token type embedding表示是哪个句子中的词。&lt;/p&gt;
&lt;p&gt;输出的数据格式是[batch_size,seq_length;width], width是词向量的长度。&lt;/p&gt;
&lt;p&gt;2、encoder部分主要是使用transformer对句子进行编码，transformer的主要结构是来自 attention is all you need，但是和论文中的结构有些小区别。&lt;/p&gt;
&lt;p&gt;3、decoder部分主要是解码部分。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先介绍数据处理部分：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、bert模型输入的文本处理之后封装为InputExample类，这个类包扩 guid,text_a，text_b，label&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
这些内容会被转换成一下的格式。##表示被mark的词，[CLS]起始第一个，在分类任务中表示句子的 sentence vector
&lt;/pre&gt;
&lt;pre&gt;
[seq]表示句子的分隔符，如果只有一个句子text_b可以为空&lt;br/&gt;tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]&lt;br/&gt;#  type_ids: 0     0  0    0    0     0       0 0     1  1  1  1   1 1
&lt;/pre&gt;
&lt;p&gt;这里的输入句子会限定一个最大输入长度，不足的补0，这个0是指词对应的token_id。处理完成之后，将词的ID序列&lt;/p&gt;
&lt;p&gt;转化为词向量的序列。&lt;/p&gt;
&lt;p&gt;词ID序列到词向量序列的代码如下：&lt;/p&gt;
&lt;pre&gt;
# Perform embedding lookup on the word ids.&lt;br/&gt;(self.embedding_output, self.embedding_table) = embedding_lookup(&lt;br/&gt;input_ids=input_ids,&lt;br/&gt;vocab_size=config.vocab_size,&lt;br/&gt;embedding_size=config.hidden_size,&lt;br/&gt;initializer_range=config.initializer_range,&lt;br/&gt;word_embedding_name=&quot;word_embeddings&quot;,&lt;br/&gt;use_one_hot_embeddings=use_one_hot_embeddings)
&lt;/pre&gt;
&lt;p&gt;下面代码在词向量序列上增加了 positional embeddings 和  token type embeddings。embedding_postprocessor 它包括token_type_embedding和position_embedding。也就是图中的Segement Embeddings和Position Embeddings。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646174/201903/646174-20190303123818490-323399573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
##配置项 这部分代码注释写的非常详细，embedding_postprocessor的具体实现可以看源码的注释，Bert的position Embedding是作为参数学习得到的，&lt;br/&gt;transformer的论文里是计算得到的。
&lt;/pre&gt;
&lt;pre&gt;
self.embedding_output = embedding_postprocessor(&lt;br/&gt;input_tensor=self.embedding_output,&lt;br/&gt;use_token_type=True,&lt;br/&gt;token_type_ids=token_type_ids,&lt;br/&gt;token_type_vocab_size=config.type_vocab_size,&lt;br/&gt;token_type_embedding_name=&quot;token_type_embeddings&quot;,&lt;br/&gt;use_position_embeddings=True,&lt;br/&gt;position_embedding_name=&quot;position_embeddings&quot;,&lt;br/&gt;initializer_range=config.initializer_range,&lt;br/&gt;max_position_embeddings=config.max_position_embeddings,&lt;br/&gt;dropout_prob=config.hidden_dropout_prob)&lt;br/&gt;特别说明一下，最后的输出增加了 norm和dropout  output = layer_norm_and_dropout(output, dropout_prob)
&lt;/pre&gt;
&lt;p&gt;2、Encoder部分代码&lt;/p&gt;
&lt;p&gt;首先是对输入做了个attention_mask的处理&lt;/p&gt;
&lt;p&gt;attention_mask = create_attention_mask_from_input_mask(input_ids, input_mask)&lt;/p&gt;
&lt;p&gt;这个主要是减少对于mask的词和填充部分的词的关注。mask部分和填充部分在计算attention的时候分数自然应该很低才对。&lt;/p&gt;
&lt;p&gt;然后是transformer_model，这部分主要是transformer，关于transformer可以参考 attention is all you need,这篇博客写的也不错，https://blog.csdn.net/yujianmin1990/article/details/85221271，这是翻译的一篇。&lt;/p&gt;
&lt;pre&gt;
self.all_encoder_layers = transformer_model(&lt;br/&gt;input_tensor=self.embedding_output,&lt;br/&gt;attention_mask=attention_mask,&lt;br/&gt;hidden_size=config.hidden_size,&lt;br/&gt;num_hidden_layers=config.num_hidden_layers,&lt;br/&gt;num_attention_heads=config.num_attention_heads,&lt;br/&gt;intermediate_size=config.intermediate_size,&lt;br/&gt;intermediate_act_fn=get_activation(config.hidden_act),&lt;br/&gt;hidden_dropout_prob=config.hidden_dropout_prob,&lt;br/&gt;attention_probs_dropout_prob=config.attention_probs_dropout_prob,&lt;br/&gt;initializer_range=config.initializer_range,&lt;br/&gt;do_return_all_layers=True)&lt;br/&gt;&lt;span&gt;&lt;strong&gt;接下来详细写写transformer_model的代码&lt;/strong&gt;&lt;br/&gt;函数定义如下：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
def transformer_model(input_tensor,&lt;br/&gt;attention_mask=None,&lt;br/&gt;hidden_size=768,&lt;br/&gt;num_hidden_layers=12,&lt;br/&gt;num_attention_heads=12,&lt;br/&gt;intermediate_size=3072,&lt;br/&gt;intermediate_act_fn=gelu,&lt;br/&gt;hidden_dropout_prob=0.1,&lt;br/&gt;attention_probs_dropout_prob=0.1,&lt;br/&gt;initializer_range=0.02,&lt;br/&gt;do_return_all_layers=False):&lt;br/&gt;input_tensor是[batch_size, seq_length, hidden_size]&lt;br/&gt;attention_mask就是之前提过的用于处理padding部分和mask部分attention值的 形状[batch_size, seq_length,&lt;em&gt;&lt;em&gt;seq_length]&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
hidden_size这个是transformer的隐层的大小
&lt;/pre&gt;
&lt;pre&gt;
num_hidden_layers：transformer有多少层，也就是blocks的数目。一个block的结构如下：&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646174/201903/646174-20190303131904812-925566645.png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;287&quot;/&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
num_attention_heads： transformer中attention heads的个数，比如bert设置的是12，多头机制中head数。
&lt;/pre&gt;
&lt;pre&gt;
intermediate_size：feed forward中间层的大小&lt;br/&gt;接下来开始介绍代码，开始判断了一下hidden_size是否是num_attention_size的整数倍
&lt;/pre&gt;
&lt;pre readability=&quot;11&quot;&gt;
对输入由三维改为二维，避免处理过程中多次tensor的变相，提高效率。&lt;br/&gt;这一步将[batch_size,seq_len,width]改为[batch_size*seq_len,width]&lt;br/&gt;prev_output = reshape_to_matrix(input_tensor)&lt;p&gt;接下来是 attention layer，这个是计算self-attention,当然如果 query和key一样的话，就是self-attention&lt;br/&gt;首先第一步是计算query_layer，key_layer，value_layer。&lt;br/&gt;这里把attention的计算抽象为 query,key和value三部分，通常key和value是一样的，然后根据query来计算不同的key 其value贡献的大小。&lt;br/&gt;比如如果RNN这种seq2seq的话（encoder和decoder都是RNN）,query是decoder前一时刻的输出，key和value是encoder RNN各个时刻的状态。&lt;br/&gt;在计算时query_layer=W*query ，其他key value类似
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;11&quot;&gt;
# `query_layer` = [B*F, N*H]&lt;br/&gt;query_layer = tf.layers.dense(&lt;br/&gt;from_tensor_2d,&lt;br/&gt;num_attention_heads * size_per_head,&lt;br/&gt;activation=query_act,&lt;br/&gt;name=&quot;query&quot;,&lt;br/&gt;kernel_initializer=create_initializer(initializer_range))&lt;p&gt;# `key_layer` = [B*T, N*H]&lt;br/&gt;key_layer = tf.layers.dense(&lt;br/&gt;to_tensor_2d,&lt;br/&gt;num_attention_heads * size_per_head,&lt;br/&gt;activation=key_act,&lt;br/&gt;name=&quot;key&quot;,&lt;br/&gt;kernel_initializer=create_initializer(initializer_range))
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
# `value_layer` = [B*T, N*H]&lt;br/&gt;value_layer = tf.layers.dense(&lt;br/&gt;to_tensor_2d,&lt;br/&gt;num_attention_heads * size_per_head,&lt;br/&gt;activation=value_act,&lt;br/&gt;name=&quot;value&quot;,&lt;br/&gt;kernel_initializer=create_initializer(initializer_range))
&lt;/pre&gt;
&lt;pre&gt;
然后是计算attention的分数，这个和transformer论文中的计算方式一致，
&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
attention_scores = tf.matmul(query_layer, key_layer, transpose_b=True)&lt;br/&gt;attention_scores = tf.multiply(attention_scores,&lt;br/&gt;1.0 / math.sqrt(float(size_per_head)))&lt;p&gt;这部分代码中tensor的形状变化，和矩阵乘法的应用比较巧妙，可以推一下看看，代码写的很简洁。
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;22&quot;&gt;
这个部分是对attention mask的使用，如果是之前被mask和padding的部分，对应的分数设置为-10000，然后使用softmax计算分数&lt;br/&gt;if attention_mask is not None:&lt;br/&gt;# `attention_mask` = [B, 1, F, T]&lt;br/&gt;attention_mask = tf.expand_dims(attention_mask, axis=[1])&lt;p&gt;# Since attention_mask is 1.0 for positions we want to attend and 0.0 for&lt;br/&gt;# masked positions, this operation will create a tensor which is 0.0 for&lt;br/&gt;# positions we want to attend and -10000.0 for masked positions.&lt;br/&gt;adder = (1.0 - tf.cast(attention_mask, tf.float32)) * -10000.0&lt;/p&gt;&lt;p&gt;# Since we are adding it to the raw scores before the softmax, this is&lt;br/&gt;# effectively the same as removing these entirely.&lt;br/&gt;attention_scores += adder&lt;br/&gt;# Normalize the attention scores to probabilities.&lt;br/&gt;# `attention_probs` = [B, N, F, T]&lt;br/&gt;attention_probs = tf.nn.softmax(attention_scores)&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;attention的分数这部分也有dropout&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;# This is actually dropping out entire tokens to attend to, which might&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;# seem a bit unusual, but is taken from the original Transformer paper.&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;attention_probs = dropout(attention_probs, attention_probs_dropout_prob)&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
接下来就是value_layer乘以attention_probs&lt;em&gt;&lt;em&gt;&lt;br/&gt;attention_layer最后的输出是&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
[B*F, N*V]或者&lt;em&gt;[B, F, N*V]&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
# Scalar dimensions referenced here:&lt;br/&gt;#   B = batch size (number of sequences)&lt;br/&gt;#   F = `from_tensor` sequence length&lt;br/&gt;#   T = `to_tensor` sequence length&lt;br/&gt;#   N = `num_attention_heads`&lt;br/&gt;#   H = `size_per_head`&lt;p&gt;对于多头机制，每个head都计算完attention_layer之后，将这些结果全都拼接起来。
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
attention_output = tf.concat(attention_heads, axis=-1)
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;注意这里attention_output最后一维的维度和&lt;/em&gt;layer_input一样的
&lt;/pre&gt;
&lt;pre&gt;
attention_output = dropout(attention_output, hidden_dropout_prob)&lt;br/&gt;attention_output = layer_norm(attention_output + layer_input)&lt;br/&gt;这个是加上残差链接。&lt;br/&gt;两个全连接层，最后加上dropout和 layer_norm
&lt;/pre&gt;
&lt;pre readability=&quot;11&quot;&gt;
# The activation is only applied to the &quot;intermediate&quot; hidden layer.&lt;br/&gt;with tf.variable_scope(&quot;intermediate&quot;):&lt;br/&gt;intermediate_output = tf.layers.dense(&lt;br/&gt;attention_output,&lt;br/&gt;intermediate_size,&lt;br/&gt;activation=intermediate_act_fn,&lt;br/&gt;kernel_initializer=create_initializer(initializer_range))&lt;p&gt;# Down-project back to `hidden_size` then add the residual.&lt;br/&gt;with tf.variable_scope(&quot;output&quot;):&lt;br/&gt;layer_output = tf.layers.dense(&lt;br/&gt;intermediate_output,&lt;br/&gt;hidden_size,&lt;br/&gt;kernel_initializer=create_initializer(initializer_range))&lt;br/&gt;layer_output = dropout(layer_output, hidden_dropout_prob)&lt;br/&gt;layer_output = layer_norm(layer_output + attention_output)&lt;br/&gt;prev_output = layer_output&lt;br/&gt;all_layer_outputs.append(layer_output)
&lt;/p&gt;&lt;/pre&gt;

</description>
<pubDate>Sun, 03 Mar 2019 06:44:00 +0000</pubDate>
<dc:creator>Earendil</dc:creator>
<og:description>参考网上博客阅读了bert的代码，记个笔记。代码是 bert_modeling.py 参考的博客地址： https://blog.csdn.net/weixin_39470744/article/de</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/earendil/p/10465637.html</dc:identifier>
</item>
<item>
<title>java.util.Collection源码分析和深度讲解 - FOEVERYANG</title>
<link>http://www.cnblogs.com/lsgspace/p/10464757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsgspace/p/10464757.html</guid>
<description>&lt;h2&gt;写在开头&lt;/h2&gt;
&lt;p&gt;　　java.util.Collection 作为Java开发最常用的接口之一，我们经常使用，今天我带大家一起研究一下Collection&lt;span&gt;接口&lt;/span&gt;，希望对大家以后的编程以及系统设计能有所帮助，本文所研究的jdk版本为jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;明确一下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　Collection是接口，其继承了Iterable接口&lt;/li&gt;
&lt;li&gt;　　Collection属于&lt;span&gt;单值类型集合，&lt;span&gt;重点&lt;/span&gt;&lt;/span&gt;子接口&lt;span&gt;List接口&lt;/span&gt;和&lt;span&gt;Set接口&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303112736732-1895213635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Java.util.List接口(有序、不唯一)&lt;/h2&gt;
&lt;h3&gt;   ArraryList&lt;/h3&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303113313035-1322999445.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;43&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ArrayList 是一个&lt;strong&gt;数组队列&lt;/strong&gt;，相当于 &lt;strong&gt;动态数组&lt;/strong&gt;。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。ArrayList&lt;span&gt;是非同步的&lt;/span&gt;，效率高但是线程不安全，Collections.sychromiziedList(new ArraryList&amp;lt;&amp;gt;());可以让那个ArrayList变成线程安全类&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;ArrayList是基于动态数组实现的，在增删时候，需要数组的拷贝复制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;删除元素时不会减少容量，若希望减少容量则调用trimToSize()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;它不是线程安全的。它能存放null值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;   LinkedList&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303120551881-2004918823.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;52&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LinkedList是一个双向循环列表队列&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;/li&gt;
&lt;li&gt;LinkedList 实现 List 接口，能对它进行队列操作。&lt;/li&gt;
&lt;li&gt;LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;/li&gt;
&lt;li&gt;LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;/li&gt;
&lt;li&gt;LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;/li&gt;
&lt;li&gt;LinkedList 是&lt;span&gt;非同步的&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;   Vector&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Vector所有方法都是&lt;span&gt;同步&lt;/span&gt;，&lt;strong&gt;有性能损失&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;Vector初始length是10 超过length时 以100%比率增长，&lt;strong&gt;相比于ArrayList更多消耗内存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;参考资料：https://www.zhihu.com/question/31948523/answer/113357347&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　总的来说：查询多用ArrayList，增删多用LinkedList。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　ArrayList增删慢不是绝对&lt;/strong&gt;的(&lt;strong&gt;&lt;span&gt;在数量大的情况下，会有例外&lt;/span&gt;&lt;/strong&gt;)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　如果增加元素一直是使用&lt;code&gt;add()&lt;/code&gt;(增加到末尾)的话，并且不扩容的情况下）&lt;/li&gt;
&lt;li class=&quot;_mce_tagged_br&quot;&gt;　　一直&lt;strong&gt;删除末尾的元素也是ArrayList要快&lt;/strong&gt;【不用复制移动位置】&lt;/li&gt;
&lt;li class=&quot;_mce_tagged_br&quot;&gt;　　至于如果&lt;strong&gt;删除的是中间的位置的话，还是ArrayList要快&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　但一般来说：&lt;strong&gt;增删多还是用LinkedList，因为上面的情况是极端的~&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Java.util.Set接口(无序、唯一)&lt;/h2&gt;
&lt;p&gt;                                  |——SortedSet接口——TreeSet实现类&lt;/p&gt;
&lt;p&gt;               Set接口——|——HashSet实现类                &lt;/p&gt;
&lt;p&gt;                                   |——LinkedHashSet实现类&lt;/p&gt;
&lt;h3&gt;  hashSet&lt;/h3&gt;
&lt;p&gt;　　hashSet&lt;span&gt;底层基于hashMap实现，&lt;span&gt;如图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303125538552-318748179.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;37&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　hashSet中的add()方法，是将对象E放入hashMap中的key的位置，value位置存放的是一个固定的Object,如图：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303125945998-1415661011.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/763441/201903/763441-20190303130018832-2087638703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　HashSet是无序唯一的，当元素为自定义对象时，两者的hashCode不同，被认为是不同的元素从而被允许放入HashSet中，但这不符合实际的生产意义，因此需要让其判定位相等，就要重写hashCode(),然而重写HashCode(),会出现重码的bug，因此需要重写equals()来解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　添加元素的时候，如果key(也对应的Set集合的元素)相等，那么则修改value值。而在Set集合中，value值仅仅是一个Object对象罢了(该对象对Set本身而言是无用的)。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;span&gt;Set集合如果添加的元素相同时，是根本没有插入的(仅修改了一个无用的value值)&lt;/span&gt;，从源码(HashMap)中也看出来，==和equals()方法都有使用，具体过程如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;　　新元素的hsah是否等于老元素的hash，如果不相等，则元素不同，如果相等，那么进行第二部比较&lt;/li&gt;
&lt;li&gt;　　新元素与老元素用“==”进行比较，如果相等，则为同一元素，若不同则进行第三部比较&lt;/li&gt;
&lt;li&gt;　　新元素和老元素用equals()方法判定是否相等，如果不等则不是同一元素，如果相等那么结果为：两个元素不是同一个对象，程序想把它们当成同一个对象，因此重写了equals方法；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;  TreeSet&lt;/h3&gt;
&lt;p&gt;   与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。&lt;/p&gt;
&lt;p&gt;TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，&lt;span&gt;自然排序&lt;/span&gt; 和&lt;span&gt;定制排序&lt;/span&gt;，其中自然排序为默认的排序方式。向  TreeSet中加入的应该是同一个类的对象。&lt;/p&gt;
&lt;h3&gt;  LinkedHashSet &lt;/h3&gt;
&lt;p&gt;   LinkedHashSet是HashSet的一个“扩展版本”，HashSet并不管什么顺序，不同的是LinkedHashSet会维护“插入顺序”。HashSet内部使用HashMap对象来存储它的元素，而LinkedHashSet内部使用LinkedHashMap对象来存储和处理它的元素&lt;/p&gt;















</description>
<pubDate>Sun, 03 Mar 2019 05:27:00 +0000</pubDate>
<dc:creator>FOEVERYANG</dc:creator>
<og:description>写在开头 java.util.Collection 作为Java开发最常用的接口之一，我们经常使用，今天我带大家一起研究一下Collection接口，希望对大家以后的编程以及系统设计能有所帮助，本文所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsgspace/p/10464757.html</dc:identifier>
</item>
<item>
<title>通过 Azure Pipelines 实现持续集成之docker容器化 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/10464507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/10464507.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Azure DevOps Pipeline 现在对于公开的项目完全免费，这对于开源项目来讲无疑是个巨大的好消息，在 Github 的 Marketplace 里有个 Azure Pipeline，就是微软的 Azure DevOps Pipeline。&lt;/p&gt;
&lt;h2 id=&quot;实现-docker-容器化的持续集成&quot;&gt;实现 Docker 容器化的持续集成&lt;/h2&gt;
&lt;p&gt;实现的目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push 代码自动打包 docker 镜像并上传至docker hub&lt;/li&gt;
&lt;li&gt;ssh 自动部署到虚拟机上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了docker image 之后后面就可以按照自己的需求加以定制了，比如通过ssh部署到服务器或者进行服务通知等。&lt;/p&gt;
&lt;h2 id=&quot;新建-pipeline&quot;&gt;新建 Pipeline&lt;/h2&gt;
&lt;p&gt;可以在 Azure 的 devops 新建一个 pipelines 的项目来专门管理 Github 上的pipeline&lt;/p&gt;
&lt;p&gt;新建一个pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-e43edb14d84f9453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次使用的话，会需要进行授权&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-9e6061de13489b03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;授权之后就可以选择 Github 上的项目了，选择要配置的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-e8d1ddcc8cf21198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以基于模板创建也可以选择下面基于已有的 yaml 文件创建&lt;/p&gt;
&lt;h2 id=&quot;azure-pipeline-config&quot;&gt;Azure pipeline config&lt;/h2&gt;
&lt;p&gt;这里提供一份示例，源代码在&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/azure-pipelines.yml&quot;&gt;这里&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# Docker image
# Build a Docker image to deploy, run, or push to a container registry.
# Add steps that use Docker Compose, tag images, push to a registry, run an image, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

pool:
  vmImage: 'Ubuntu 16.04'

variables:
  imageName: '$(dockerId)/activityreservation'

steps:

- script: |
    docker build -f Dockerfile -t $(imageName) .
    docker login -u $(dockerId) -p $(pswd)
    docker push $(imageName)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;pipeline-配置解析&quot;&gt;pipeline 配置解析&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;agent pool 配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过 vmImage 来指定要用来执行 build 任务的 agent&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;pool:
  vmImage: 'Ubuntu 16.04'&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;variables&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以通过 variables 来指定一些全局变量，这里我用了一个 imageName 的变量来设置 docker 镜像的名称&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;variables:
  imageName: 'activityreservation'&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;敏感信息的存储&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;要上传 docker 镜像，我这里是直接上传到 docker hub 上，需要 docker 的用户名以及密码，pipeline 可以设置一些不配置在 pipeline 配置文件里的其它配置,一些敏感信息就可以这样配置来保证安全访问&lt;/p&gt;
&lt;p&gt;可以将 pipeline 独有的一些配置放在 &lt;code&gt;Pipeline Variables&lt;/code&gt; 里，一些比较通用的，别的 pipeline 也会使用的变量可以放到一个 &lt;code&gt;Variable groups&lt;/code&gt;，然后在 pipeline 的 variables 里 link 一下对应的 Variable Group 就可以使用 group 里配置的变量了，我把 docker 的 username 和 password 配置在了一个 docker 的 Variable Group 里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-70c18b01b4aea8a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;pipeline settings&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-d2017cc9dee9358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-88cb33897f2a5e8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-a555d0b616aee16a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;docker 镜像的打包以及上传&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置 pipeline 的 step，step 对应的就是需要 build agent 去执行的task&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;steps:

- script: |
    docker build -f Dockerfile -t $(imageName) .
    docker login -u $(dockerId) -p $(pswd)
    docker push $(imageName)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置上面的脚本我们就可以自动 build 并 push docker 镜像了。&lt;/p&gt;
&lt;p&gt;build 完成之后再去 docker hub 上查看对应的 docker 镜像就会发现 docker 镜像已经更新了。&lt;/p&gt;
&lt;h2 id=&quot;在-vm-上自动部署-docker-镜像&quot;&gt;在 vm 上自动部署 docker 镜像&lt;/h2&gt;
&lt;p&gt;首先要在 pipeline 上新建一个 SSH 的 Service Connection&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-ec3f71d1c1db31aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-1812c5b8200a8591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-841ea687c42286ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;steps:

- script: |
    docker build -f Dockerfile -t $(imageName) .
    docker login -u $(dockerId) -p $(pswd)
    docker push $(imageName)

- task: SSH
  displayName: 'Run shell inline on remote machine'
  inputs:
    sshEndpoint: 'weihanli-vm'
    runOptions: inline

    inline: |
     containers=$(docker ps -q --filter name=activityreservation)
     if test -n &quot;$containers&quot;; then
      docker stop $(docker ps -q --filter name=activityreservation) &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
      rc=$?
      if [[ $rc != 0 ]];
      then
       echo 'failed to stop container...'
       exit $rc;
      fi
     fi
     
     containers1=$(docker ps -q -a --filter name=activityreservation)
     if test -n &quot;$containers1&quot;; then
      docker rm $(docker ps -q -a --filter name=activityreservation) &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
      rc=$?
      if [[ $rc != 0 ]];
      then
       echo 'failed to remove container...'
       exit $rc;
      fi
     fi
     
     
     docker pull $(imageName):latest &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
     rc=$?
     if [[ $rc != 0 ]];
     then
      echo 'failed to pull container...'
      exit $rc;
     fi
     
     docker run -d -p 7010:80 --name activityreservation --link redis:redis-server $(imageName):latest &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
     rc=$?
     if [[ $rc != 0 ]];
     then
      echo 'failed to run container...'
      exit $rc;
     fi
     
     danglings=$(docker images -f &quot;dangling=true&quot; -q)
     if test -n &quot;$danglings&quot;; then
      docker rmi $(docker images -f &quot;dangling=true&quot; -q) &amp;gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1
      rc=$?
      if [[ $rc != 0 ]];
      then
       echo 'failed to remove danglings container...'
       exit $rc;
      fi
     fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sshEndpoint 设置为连接的名称，inline 后面是在远程执行的脚本，大概流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查是否有指定名称的 container 在运行，如果有 stop 并 remove&lt;/li&gt;
&lt;li&gt;拉取最新的 docker 镜像&lt;/li&gt;
&lt;li&gt;运行 docker 容器&lt;/li&gt;
&lt;li&gt;移除可能的悬挂镜像（名称为 none 的中间镜像）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;验证&quot;&gt;验证&lt;/h2&gt;
&lt;p&gt;配置完成之后我们就可以提交代码，就会自动出发 build，自动执行我们定义的 pipeline 任务，按照上面的配置的话，就会先 build 并 push Docker 镜像到 docker hub，然后 SSH 到远程服务器，远程过去之后执行脚本，停掉并移除指定的 docker 容器（如果有）然后拉取并部署最新的docker镜像，最后清理资源，删除 docker 悬挂镜像。&lt;/p&gt;
&lt;h2 id=&quot;示例项目&quot;&gt;示例项目&lt;/h2&gt;
&lt;p&gt;现在有两个项目是这种模式去自动化部署的，源代码以及 pipeline 的配置都在 Github 上&lt;/p&gt;
&lt;p&gt;现在这两个项目的部署模式是这样的，以活动室预约系统为例：&lt;/p&gt;
&lt;p&gt;前面一个 nginx 作为反向代理，后面是直接跑在 docker 容器里&lt;/p&gt;
&lt;p&gt;nginx 示例配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
      listen 80;
      listen 443;
      if ($scheme = http) {
          return  301 https://$host$request_uri;
      }
      server_name reservation.weihanli.xyz;

      location / {
         proxy_pass http://localhost:7010;
         proxy_set_header X-Real-IP $remote_addr;
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会把 &lt;code&gt;reservation.weihanli.xyz&lt;/code&gt; 的请求转发到 &lt;code&gt;localhost:7010&lt;/code&gt; ，也就是这个 docker 镜像映射的本地端口&lt;/p&gt;
&lt;h2 id=&quot;memo&quot;&gt;Memo&lt;/h2&gt;
&lt;p&gt;如果有什么问题或建议，欢迎与我联系&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 03:42:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>通过 Azure Pipelines 实现持续集成之docker容器化 Intro Azure DevOps Pipeline 现在对于公开的项目完全免费，这对于开源项目来讲无疑是个巨大的好消息，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/10464507.html</dc:identifier>
</item>
<item>
<title>Java线程池，你了解多少？ - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/10117878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/10117878.html</guid>
<description>&lt;p&gt; 　　随着业务的发展，单线程已经远远不能满足，随即就有多线程的出现。多线程虽然能解决单线程解决不了的事情，但是它也会给你带来额外的问题。比如成千上万甚至上百万的线程时候，你系统就会出现响应延迟、卡机、甚至直接卡死的情况。为什么会出现这样的原因呢？&lt;strong&gt;因为为每个请求创建一个新线程的开销很大：在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。在一个 JVM里创建太多的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”。所以为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目。而线程池为线程生命周期开销问题和资源不足问题提供了解决方案。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、降低资源消耗，防止资源不足&lt;/strong&gt;。合理配置线程池中的线程大小，防止请求线程猛增；另外通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;strong&gt;2、提高响应速度。&lt;/strong&gt;线程池可以通过对多个任务重用线程，在请求到达时线程已经存在（如果有空闲线程时），所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;strong&gt;3、&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。使用线程池可以统一分配、调优和监控线程。&lt;/p&gt;
&lt;p&gt;　　上面知道了线程池的作用，那么线程池它是如何工作的呢？其使用核心类是哪一个呢？所以要做到合理利用线程池，必须对其实现原理了如指掌。&lt;/p&gt;

&lt;p&gt;　　java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，所以必须了解这个类的用法及其内部原理，下面我们来看下ThreadPoolExecutor类的具体源码解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1  继承关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;通过类的继承关系可以得知哪些方法源于哪里（具体请看代码），下面直接给出类的继承结构的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201903/690169-20190302232407583-1192736063.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2 构造方法&lt;/span&gt;&lt;/strong&gt; 　　&lt;/p&gt;
&lt;p&gt;　　在ThreadPoolExecutor类中提供了四个构造方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8717d16b-3e39-49bb-81c2-18f36952c6a7')&quot; readability=&quot;51.5&quot;&gt;&lt;img id=&quot;code_img_closed_8717d16b-3e39-49bb-81c2-18f36952c6a7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8717d16b-3e39-49bb-81c2-18f36952c6a7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8717d16b-3e39-49bb-81c2-18f36952c6a7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8717d16b-3e39-49bb-81c2-18f36952c6a7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 五个参数的构造函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadPoolExecutor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractExecutorService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;             Executors.defaultThreadFactory(), defaultHandler);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 六个参数的构造函数-1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                              ThreadFactory threadFactory) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;             threadFactory, defaultHandler);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;六个参数的构造函数 -2&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                              RejectedExecutionHandler handler) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;             Executors.defaultThreadFactory(), handler);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 七个参数的构造函数&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                              ThreadFactory threadFactory,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                              RejectedExecutionHandler handler) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||
&lt;span&gt;41&lt;/span&gt;             maximumPoolSize &amp;lt;= 0 ||
&lt;span&gt;42&lt;/span&gt;             maximumPoolSize &amp;lt; corePoolSize ||
&lt;span&gt;43&lt;/span&gt;             keepAliveTime &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从源代码中发现前面三个构造器都是调用的第四个构造器进行的初始化工作，那就以第四个构造函数为例，解释下其中各个参数的含义（留意源码中每个字段上的注释）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;int corePoolSize&lt;/strong&gt;：&lt;strong&gt;核心线程数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在创建了线程池后，&lt;strong&gt;默认情况下线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当提交一个任务到线程池时，线程池会创建一个线程来执行任务&lt;/strong&gt;，即使有其他空闲的基本线程能够执行新任务也会创建线程（比方说：coreSize=5时，一开始只有一个任务会创建一个线程，等执行完后又来了一个任务时，依然会创建一个线程不会使用第一个线程）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当线程池中的线程数目达到corePoolSize后就不再创建线程，会把到达的任务放到缓存队列当中等待执行&lt;/strong&gt;。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程，另外prestartCoreThread方法也会启动核心线程，不过每次只能启动一个。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　2. &lt;strong&gt;int maximumPoolSize&lt;/strong&gt;：&lt;strong&gt;线程池允许创建的最大线程数。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　3. &lt;strong&gt;long&lt;/strong&gt; &lt;strong&gt;keepAliveTime&lt;/strong&gt;：&lt;strong&gt;空闲线程等待超时的时间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，&lt;strong&gt;只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用&lt;/strong&gt;，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。&lt;/li&gt;
&lt;li&gt;但是如果&lt;strong&gt;调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用&lt;/strong&gt;，直到线程池中的空闲线程数为0；&lt;/li&gt;
&lt;li&gt;如果任务很多且每个任务执行的时间比较短，则可以调大时间，提高线程利用率。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　4. &lt;strong&gt;TimeUnit unit&lt;/strong&gt;：&lt;strong&gt;参数keepAliveTime的时间单位。&lt;/strong&gt;共有七种单位，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f8140f3b-aa35-4842-a0f6-123ee1e0d532')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_f8140f3b-aa35-4842-a0f6-123ee1e0d532&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f8140f3b-aa35-4842-a0f6-123ee1e0d532&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f8140f3b-aa35-4842-a0f6-123ee1e0d532',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f8140f3b-aa35-4842-a0f6-123ee1e0d532&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; TimeUnit {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 纳秒=千分之一微妙
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NANOSECONDS {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 微妙=千分之一毫秒
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MICROSECONDS {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 毫秒
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MILLISECONDS {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 秒
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    SECONDS {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分钟
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MINUTES {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 小时
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    HOURS {...},

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 天
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    DAYS {...};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　5. &lt;strong&gt;BlockingQueue&amp;lt;Runnable&amp;gt; workQueue:&lt;/strong&gt; &lt;strong&gt;任务队列，用于保存等待执行任务的阻塞队列。&lt;/strong&gt;队列也有好几种详细请看&lt;a href=&quot;http://ifeve.com/java-blocking-queue/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，这里就不做解释了。&lt;/p&gt;
&lt;p&gt;　　6. &lt;strong&gt;ThreadFactory threadFactory：线程工厂，主要用于创建线程。其中可以指定线程名字（千万别忽略这件小事，有意义的名字能让你快速定位到源码中的线程类）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　7. &lt;strong&gt;RejectedExecutionHandler handler：饱和策略，&lt;/strong&gt;当队列和线程池都满了，说明线程处于饱和状态，那么后续进来的任务需要一种策略处理。默认情况下是AbortPolicy:表示无法处理新任务时抛出异常。线程池框架提供了以下4中策略（当然也可以自己自定义策略：通过实现RejectedExecutionHandler接口自定义策略）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy：不处理新任务，抛出异常&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：只用调用者所在的线程来运行任务。&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务， 并执行当前任务。&lt;/li&gt;
&lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3.3 重要参数方法和方法解读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;1.&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;线程池状态&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始值 -536870912&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始值 29&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COUNT_BITS = Integer.SIZE - 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始值 536870911&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RUNNING状态：接受新任务并处理排队任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SHUTDOWN状态：不接受新任务，但处理排队任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STOP状态：不接受新任务，不处理排队任务，并中断正在进行的任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; All tasks have terminated, workerCount is zero,  the thread transitioning to state TIDYING will run the terminated() hook method&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TERMINATED: terminated() has completed&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池状态，取前三位&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runStateOf(&lt;span&gt;int&lt;/span&gt; c)     { &lt;span&gt;return&lt;/span&gt; c &amp;amp; ~&lt;span&gt;CAPACITY; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前正在工作的worker,主要是取后面29位&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt; c)  { &lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成ctl&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ctlOf(&lt;span&gt;int&lt;/span&gt; rs, &lt;span&gt;int&lt;/span&gt; wc) { &lt;span&gt;return&lt;/span&gt; rs | wc; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当创建线程池后，初始时，线程池处于RUNNING状态；&lt;/p&gt;
&lt;p&gt;　　RUNNING -&amp;gt; SHUTDOWNN：如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；&lt;/p&gt;
&lt;p&gt;　　(RUNNING or SHUTDOWN) -&amp;gt; STOP：如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；&lt;/p&gt;
&lt;p&gt;　　SHUTDOWN -&amp;gt; TIDYING or STOP -&amp;gt; TIDYING :当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. 线程池中的线程初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在说corePoolSize参数时有说到初始化线程池的两个方法，其实在默认情况下，创建线程池之后线程池中是没有线程的，需要提交任务之后才会创建线程。所以如果想在创建线程池之后就创建线程的话，可以通过下面两个方法创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    * 单个创建核心线程
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; prestartCoreThread() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; workerCountOf(ctl.get()) &amp;lt; corePoolSize &amp;amp;&amp;amp;&lt;span&gt;
            addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    * 启动所有核心线程
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; prestartAllCoreThreads() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加工作线程&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (addWorker(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;++&lt;span&gt;n;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3. 创建线程：addWorker()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
        retry:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取运行状态&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 如果当前的线程池的状态&amp;gt;SHUTDOWN 那么拒绝Worker的add 如果=SHUTDOWN
             * 那么此时不能新加入不为null的Task，如果在WorkCount为empty的时候不能加入任何类型的Worker，
             * 如果不为empty可以加入task为null的Worker,增加消费的Worker
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                    ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                            firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                            !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;


            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取有效线程数，并判断&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前的数量超过了CAPACITY，或者超过了corePoolSize和maximumPoolSize（试core而定），则直接返回&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                        wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS尝试增加线程数，如果失败，证明有竞争，那么重新到retry。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
                c &lt;/span&gt;= ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继续判断当前线程池的运行状态&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 新建任务
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Worker w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
        Thread t &lt;/span&gt;=&lt;span&gt; w.thread;

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * rs!=SHUTDOWN ||firstTask!=null
             *
             * 同样检测当rs&amp;gt;SHUTDOWN时直接拒绝减小Wc，同时Terminate，如果为SHUTDOWN同时firstTask不为null的时候也要Terminate
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                    (rs &lt;/span&gt;&amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                            ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                                    firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))) {
                decrementWorkerCount();
                tryTerminate();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            workers.add(w);

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }

        t.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Stop或线程Interrupt的时候要中止所有的运行的Worker&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (runStateOf(ctl.get()) == STOP &amp;amp;&amp;amp; !&lt;span&gt; t.isInterrupted())
            t.interrupt();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上面可以看出：&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;　在rs&amp;gt;SHUTDOWN时，拒绝一切线程的增加，因为STOP是会终止所有的线程，同时移除Queue中所有的待执行的线程的，所以也不需要增加first=null的Worker了。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;　　　　其次，在SHUTDOWN状态时，是不能增加first！=null的Worker的，同时即使first=null，但是此时Queue为Empty也是不允许增加Worker的，SHUTDOWN下增加的Worker主要用于消耗Queue中的任务。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;　　　　SHUTDOWN状态时，是不允许向workQueue中增加线程的，isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command) 每次在offer之前都要做状态检测，也就是线程池状态变为&amp;gt;=SHUTDOWN时不允许新线程进入线程池了。&lt;/strong&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;4、执行任务：execute()&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         * 原注释已经讲的很清楚了，主要分三步进行：
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、如果线程数小于基本线程数，则创建线程并执行当前任务&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            c &lt;/span&gt;=&lt;span&gt; ctl.get();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、如果任务可以排队，则会重新检查看是否可以启动新的任务还是拒绝任务&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
                reject(command);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
                addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、如果我们无法排队任务，那么我们尝试添加一个新线程。 如果失败，我们知道我们已关闭或饱和，因此拒绝该任务。&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
            reject(command);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意：该方法是没有返回值的，如果想获取线程执行后的结果可以调用submit方法（当然它底层也是调用execute()方法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5、线程池关闭：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务&lt;/li&gt;
&lt;li&gt;shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;　　1、创建线程或线程池时请指定有意义的线程名称，方便回溯。&lt;/strong&gt;来源《阿里巴巴 Java开发手册》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　2、线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/strong&gt;&lt;/strong&gt;来源《阿里巴巴 Java开发手册》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/strong&gt;说明：Executors 返回的线程池对象的弊端如下：&lt;/p&gt;
&lt;p&gt;　　　　1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;/p&gt;
&lt;p&gt;　　　　 2）CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3、合理配置线程池大小，&lt;/strong&gt;可以从以下几个角度来进行分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;任务的性质：CPU密集型任务，IO密集型任务和混合型任务。&lt;/li&gt;
&lt;li&gt;任务的优先级：高，中和低。&lt;/li&gt;
&lt;li&gt;任务的执行时间：长，中和短。&lt;/li&gt;
&lt;li&gt;任务的依赖性：是否依赖其他系统资源，如数据库连接。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　比方说：如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 &lt;em&gt;N&lt;/em&gt;&lt;sub&gt;CPU&lt;/sub&gt;+1； &lt;/p&gt;
&lt;p&gt;　　　　如果是IO密集型任务，参考值可以设置为2*&lt;em&gt;N&lt;/em&gt;&lt;sub&gt;CPU。&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　注意：以上值仅供参考，需要根据具体实际情况而定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;4、合理设置空闲线程等待时间。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;如果任务很多且每个任务执行的时间比较短，则可以调大时间，提高线程利用率。&lt;/p&gt;

&lt;p&gt;　　上面说了这么多还是需要实践才能知道其具体的作用印象才会更深刻，本想写个案例出来的（后续补上），没时间想个好点例子。&lt;/p&gt;
&lt;p&gt;　　下面推荐学习资料:&lt;/p&gt;
&lt;p&gt;　　书籍：《java并发编程的艺术》&lt;/p&gt;
&lt;p&gt;　　视频：通过我下面分享的视频，购买有返现。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201903/690169-20190302235730127-813719868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;https://www.cnblogs.com/dolphin0520/p/3932921.html&lt;/p&gt;
&lt;p&gt;http://ifeve.com/java-threadpool/&lt;/p&gt;
&lt;p&gt;《Java并发编程的艺术》&lt;/p&gt;
&lt;p&gt;《阿里巴巴Java开发手册》&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 02:57:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一、前言 随着业务的发展，单线程已经远远不能满足，随即就有多线程的出现。多线程虽然能解决单线程解决不了的事情，但是它也会给你带来额外的问题。比如成千上万甚至上百万的线程时候，你系统就会出现响应延迟、卡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/10117878.html</dc:identifier>
</item>
<item>
<title>fhqtreap入门 - henry_y</title>
<link>http://www.cnblogs.com/henry-1202/p/10464231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henry-1202/p/10464231.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;fhqtreap为利用分裂和合并来满足平衡树的性质，&lt;strong&gt;不需要旋转操作&lt;/strong&gt;的一种平衡树。&lt;br/&gt;并且利用函数式编程可以极大的简化代码量。&lt;/p&gt;
&lt;h2 id=&quot;核心操作&quot;&gt;核心操作&lt;/h2&gt;
&lt;p&gt;（均为按位置分裂合并）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct fhq {
    int lc, rc, siz, rnd, val;
        //lc为左子树，rc为右子树，siz为子树大小（位置分裂即按siz分裂），rnd为随机值，val为该节点储存的值
}t[N];
#define lc (t[rt].lc)
#define rc (t[rt].rc)
//下方用到的宏定义&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;split(rt,l,r,k) 把一个根为rt的子树split成一个根为l和一个根为r的子树(以第k大为界限)&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void split(int rt, int &amp;amp;l, int &amp;amp;r, int k) {
    if(!k) l = 0, r = rt;
    else if(t[rt].siz == k) l = rt, r = 0;
    else if(k &amp;lt;= t[lc].siz) r = rt, split(lc, l, lc, k), up(rt);
    else l = rt, split(rc, rc, r, k - t[lc].siz - 1), up(rt);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;merge(rt,l,r) 把根为l和根为r的子树merge成一个根为rt的子树&lt;br/&gt;merge默认子树l的权值比子树r的权值小&lt;br/&gt;merge满足小根堆性质(对rnd)&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void merge(int &amp;amp;rt, int l, int r) {
    if(!l || !r) rt = l + r;
    else if(t[l].rnd &amp;lt; t[r].rnd) rt = l, merge(rc, rc, r), up(rt);
    else rt = r, merge(lc, l, lc), up(rt);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fhqtreap也有一种按权值分裂的做法，但用处不大，如果要用位置分裂实现权值分裂，可以将序列构造成一个递增的序列，写一个rank求一下插入的数的在序列中的位置，插入到那里就行了（这样就能搞权值分裂能搞的东西了）、&lt;br/&gt;区间操作打懒标记的话，在split和merge的时候下传即可。&lt;/p&gt;
&lt;h2 id=&quot;常用操作&quot;&gt;常用操作&lt;/h2&gt;
&lt;p&gt;里面的sum即为上方提到的val。&lt;br/&gt;建新节点&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int build(int val) {
    t[++tot].rnd = rand() &amp;lt;&amp;lt; 15 | rand();
    t[tot].siz = 1;
    t[tot].sum = val;
    return tot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查排名（上方提到的rank，这个是&lt;span class=&quot;math inline&quot;&gt;\(logn\)&lt;/span&gt;的）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int rank(int rt, int val) {
    if(!rt) return 0;
    if(t[rt].sum &amp;gt;= val) return rank(lc, val);
    return rank(rc, val) + t[lc].siz + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline void insert(int val) {
    int rk = rank(root, val), x, y;
    split(root, x, y, rk);
    int z = build(val);
    merge(x, x, z); merge(root, x, y);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline void del(int val) {
    int rk = rank(root, val) + 1, x, y, z;
    split(root, x, y, rk);
    split(x, x, z, rk - 1);
    merge(root, x, y);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他操作均类似。&lt;br/&gt;要注意的一个问题：&lt;strong&gt;merge和split均针对的是根为rt的子树，所以对应的k也是他们子树中的第k大。&lt;/strong&gt;可以看看下面的代码。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline int find(int rk) {//找排名为rk的数
    int x, y, z, ans;
    split(root, x, y, rk - 1);
    split(y, y, z, 1);
    ans = t[y].sum;
    merge(y, y, z); merge(root, x, y);
    return ans;
    /*
    split(root, x, y, rk); split(x, z, x, rk - 1);
    ans = t[x].sum;
    merge(x, z, x), merge(root, x, y);
    return ans;
    */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即在一整个根为root的树中找第rk大，可以有两种实现：1.分裂成前rk大和剩下的，并将前rk大分裂成rk-1大和第rk大。2.分裂成前rk-1大和剩下的，将剩下的那部分，分裂成&lt;strong&gt;第一大（不要弄成rk+1!）&lt;/strong&gt;和后面的&lt;/p&gt;
&lt;h2 id=&quot;模板题&quot;&gt;模板题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3369&quot;&gt;LuoguP3369 【模板】普通平衡树&lt;/a&gt;&lt;br/&gt;就是平衡树的常见操作，可以直接写权值分裂，也可以写位置分裂（构造成递增数列）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;deque&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;

#define ll long long
const int inf = 2e9 + 10;
typedef unsigned long long ull;

namespace io {

#define in(a) a = read()
#define out(a) write(a)
#define outn(a) out(a), putchar('\n')

#define I_int int
inline I_int read() {
    I_int x = 0, f = 1;
    char c = getchar();
    while (c &amp;lt; '0' || c &amp;gt; '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
char F[200];
inline void write(I_int x) {
    if (x == 0) return (void) (putchar('0'));
    I_int tmp = x &amp;gt; 0 ? x : -x;
    if (x &amp;lt; 0) putchar('-');
    int cnt = 0;
    while (tmp &amp;gt; 0) {
        F[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while (cnt &amp;gt; 0) putchar(F[--cnt]);
}
#undef I_int

}
using namespace io;

using namespace std;

#define N 500010

#define lc (t[rt].l)
#define rc (t[rt].r)
struct fhq {
    int l, r, sum, siz, rnd;
} t[N];
int tot = 0, root = 0;
void up(int rt) {
    if(!rt) return;
    t[rt].siz = 1 + t[lc].siz + t[rc].siz;
}
void split(int rt, int &amp;amp;l, int &amp;amp;r, int k) {
    //把根为rt的子树，以第k个为界限split成两个子树
    //第k个可以是位置，也可以是权值
    //这里的k是位置
    if(!k) l = 0, r = rt;
    else if(k == t[rt].siz) l = rt, r = 0;
    else if(k &amp;lt;= t[lc].siz) r = rt, split(lc, l, lc, k), up(rt);
    else l = rt, split(rc, rc, r, k - t[lc].siz - 1), up(rt);
}
void merge(int &amp;amp;rt, int l, int r) {
    //把l子树和r子树merge为一棵根为rt的子树 
    if(!l || !r) rt = l + r;
    else if(t[l].rnd &amp;lt; t[r].rnd) rt = l, merge(t[rt].r, t[rt].r, r), up(rt);
    else rt = r, merge(t[rt].l, l, t[rt].l), up(rt);
}
int build(int val) {
    t[++tot].rnd = rand() &amp;lt;&amp;lt; 15 | rand();
    t[tot].siz = 1;
    t[tot].sum = val;
    return tot;
}
int rank(int rt, int val) {
    if(!rt) return 0;
    if(t[rt].sum &amp;gt;= val) return rank(lc, val);
    return rank(rc, val) + t[lc].siz + 1;
}
inline void insert(int val) {
    int rk = rank(root, val), x, y;
    split(root, x, y, rk);
    int z = build(val);
    merge(x, x, z); merge(root, x, y);
}
inline void del(int val) {
    int rk = rank(root, val) + 1, x, y, z;
    split(root, x, y, rk);
    split(x, x, z, rk - 1);
    merge(root, x, y);
}
inline int find(int rk) {
    int x, y, z, ans;
    split(root, x, y, rk - 1);
    split(y, y, z, 1);
    ans = t[y].sum;
    merge(y, y, z); merge(root, x, y);
    return ans;
    /*
    split(root, x, y, rk); split(x, z, x, rk - 1);
    ans = t[x].sum;
    merge(x, z, x), merge(root, x, y);
    return ans;
    */
}
inline int pre(int val) {
    int x, y, z, ans, rk = rank(root, val);
    split(root, x, y, rk);
    split(x, z, x, rk - 1);
    ans = t[x].sum;
    merge(x, z, x); merge(root, x, y);
    return ans;
}
inline int succ(int val) {
    int x, y, z, ans, rk = rank(root, val + 1);
    split(root, x, y, rk + 1); split(x, z, x, rk);
    ans = t[x].sum;
    merge(x, z, x); merge(root, x, y);
    return ans;
}
int main() {
#ifndef ONLINE_JUDGE
    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);
#endif 
    srand((unsigned)time(0));
    t[0].rnd = t[0].sum = inf;
    int n = read();
    for(int i = 1; i &amp;lt;= n; ++i) {
        int op = read(), x = read();
        if(op == 1) insert(x);
        if(op == 2) del(x);
        if(op == 3) printf(&quot;%d\n&quot;, rank(root, x) + 1);
        if(op == 4) printf(&quot;%d\n&quot;, find(x));
    if(op == 5) printf(&quot;%d\n&quot;, pre(x));
    if(op == 6) printf(&quot;%d\n&quot;, succ(x));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;例题&quot;&gt;例题&lt;/h2&gt;
&lt;p&gt;咕。以后再补。&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 02:47:00 +0000</pubDate>
<dc:creator>henry_y</dc:creator>
<og:description>介绍 fhqtreap为利用分裂和合并来满足平衡树的性质， 不需要旋转操作 的一种平衡树。 并且利用函数式编程可以极大的简化代码量。 核心操作 （均为按位置分裂合并） split(rt,l,r,k)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henry-1202/p/10464231.html</dc:identifier>
</item>
<item>
<title>设计一个可靠的连接池 - smark</title>
<link>http://www.cnblogs.com/smark/p/10464226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10464226.html</guid>
<description>&lt;p&gt;&lt;span&gt;在应用中连接池的使用非常普遍，如访问数据库，Redis等等网络产品的&lt;code&gt;Client&lt;/code&gt;都集成了连接池机制；由于最近在编写微服务网关因此涉及到连接池的编写，在这里分享一下实现一个可靠连接池的心得。其实编写一个连接池并不因难，基础的&lt;code&gt;Stack&lt;/code&gt;结构就能满足需要；但在设计的时候有些情况是需要考虑的，怎样使连接池的效益最大化，特别是如何设计连接池的最大负载，当超过最大负载后应该怎么做这些问题都衡量一个连接池好坏的标准。接下来通过代码的方式一步一步地实现它。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;基础实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConnectionPool&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : IDisposable, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentStack&amp;lt;T&amp;gt; mPool = &lt;span&gt;new&lt;/span&gt; ConcurrentStack&amp;lt;T&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Pop()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!mPool.TryPop(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; T item))
            {
                item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();

            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Push(T item)
        {
            mPool.Push(item);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是一个最简单对象池，当然这个对象池是不能真的投入生产，只是大概了解基础原理；因为它是无限量增长的对象池，不过用来做对象池免强还是可以的，用在连接池上那就不太可行了，毕竟大量的连接不仅增加自己的损耗还增加了对端的损耗。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;增加最大限制&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConnectionPool&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : IDisposable, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConnectionPool(&lt;span&gt;int&lt;/span&gt; max = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
        {
            mMaxCount &lt;/span&gt;=&lt;span&gt; max;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentStack&amp;lt;T&amp;gt; mPool = &lt;span&gt;new&lt;/span&gt; ConcurrentStack&amp;lt;T&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mMaxCount;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mCount;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Pop()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!mPool.TryPop(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; T item))
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = System.Threading.Interlocked.Increment(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; mCount);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mCount &amp;gt;&lt;span&gt; mMaxCount)
                {
                    System.Threading.Interlocked.Decrement(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; mCount);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
                }
                item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Push(T item)
        {
            mPool.Push(item);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上增加了最大数限制，但在使用上就要面对一个问题，当池负载满了返回为空的时候程序又要怎样处理呢？直接抛异常？自旋或&lt;code&gt;sleep&lt;/code&gt;指定次数后还是获取为空再报异常？对于调用者来说最不想看到的肯是异常，就算延时能处理也相对是一件不错的方法；但当在满负载的情况大量的线程自旋或&lt;code&gt;sleep&lt;/code&gt;又只会让系统变得更糟糕！所以以上两种方式并不算是一个好的解决方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;引入事件驱动&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果请求者要等待使用自旋或&lt;code&gt;sleep&lt;/code&gt;基本上是不可行，这种方法容易损耗CPU资源；接下来引入基于&lt;code&gt;事件驱动&lt;/code&gt;的方法模式，听上去是不是很高大上，其实设计方式比较简单就是在&lt;code&gt;Push&lt;/code&gt;引入一个事件通知机制，让后面等待的请求进行处理；这样就不用通过自旋或&lt;code&gt;sleep&lt;/code&gt;来完成这个功能。一说到事件驱动相信很多朋友感觉一下子变成了非常复杂，但.net core提供给我们一个好东西&lt;code&gt;async/await&lt;/code&gt;语法糖轻易解决这一问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConnectionPool&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : IDisposable, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConnectionPool(&lt;span&gt;int&lt;/span&gt; max = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
        {
            mMaxCount &lt;/span&gt;=&lt;span&gt; max;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mWaitQueueLength = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Stack&amp;lt;T&amp;gt; mPool = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;T&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Queue&amp;lt;TaskCompletionSource&amp;lt;T&amp;gt;&amp;gt; mWaitQueue = &lt;span&gt;new&lt;/span&gt; Queue&amp;lt;TaskCompletionSource&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mMaxCount;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mCount;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; mLockPool = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;T&amp;gt;&lt;span&gt; Pop()
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (mLockPool)
            {
                TaskCompletionSource&lt;/span&gt;&amp;lt;T&amp;gt; result = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource&amp;lt;T&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPool.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    result.SetResult(mPool.Pop());
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    mCount&lt;/span&gt;++&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mCount &amp;lt;&lt;span&gt; mMaxCount)
                    {
                        result.SetResult(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; T());
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mWaitQueue.Count &amp;gt;=&lt;span&gt; mWaitQueueLength)
                        {
                            result.SetResult(&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T));
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            mWaitQueue.Enqueue(result);
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.Task;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Push(T item)
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (mLockPool)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mWaitQueue.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; waitItem =&lt;span&gt; mWaitQueue.Dequeue();
                    Task.Run(() &lt;/span&gt;=&amp;gt;&lt;span&gt; waitItem.SetResult(item));
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    mPool.Push(item);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在对象池中引入了一个队列，当负载满的时候请求会扔到队列中，当对象回归后会检测队列并触发请求的状态机代码执行。注意：一定要通过线程隔离这个执行，毕竟这代码还在一个锁的代码块里，如果不用线程隔离有能可能会导致下一次其它调用进来时产生死锁的情况。加入了事件驱动使用代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; item = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Pool.Pop();
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(item==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; System busy
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    run item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;缩减&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;池在负载的时候有增长，那在空闲的时候自然也应该有缩减的设计才算合理，同样这个缩减也可以在Push中设计一下，代码就留给大家了，简单的方法是获取当前Pool的Pop的并发量，如果并发量少于当前池中的对象数量，那Push的时候就不是回归到池里，而是释放掉了（不过这个方法并不算太好）。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Mar 2019 02:33:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>在应用中连接池的使用非常普遍，如访问数据库，Redis等等网络产品的Client都集成了连接池机制；由于最近在编写微服务网关因此涉及到连接池的编写，在这里分享一下实现一个可靠连接池的心得。其实编写一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/10464226.html</dc:identifier>
</item>
<item>
<title>【Python3爬虫】常见反爬虫措施及解决办法（三） - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/10454884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/10454884.html</guid>
<description>&lt;p&gt; &lt;span&gt;上一篇博客的末尾说到全网代理IP的端口号是经过加密混淆的，而这一篇博客就将告诉你如何破解！如果觉得有用的话，不妨点个推荐哦~&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;首先进入&lt;a href=&quot;http://www.goubanjia.com/&quot; target=&quot;_blank&quot;&gt;全网代理IP&lt;/a&gt;，打开开发者工具，点击查看端口号，看起来貌似没有什么问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301092055634-900050136.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你已经爬取过这个网站的代理，你就会知道事情并非这么简单。如果没爬过呢？也很简单，点击鼠标右键然后查看网页源代码，搜索”port“，可以找到如下内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301092435461-1993832577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显这不是网页上显示的端口号了，那我们要怎么才能得到真正的端口号呢？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;解决办法：&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;首先需要找到一个JS文件：&lt;a href=&quot;http://www.goubanjia.com/theme/goubanjia/javascript/pde.js?v=1.0&quot; target=&quot;_blank&quot;&gt;http://www.goubanjia.com/theme/goubanjia/javascript/pde.js?v=1.0&lt;/a&gt;，点开后可以看到如下内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301093302459-1949430209.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这么复杂的JS代码看得人头都大了，不过我们发现这个JS代码是一个eval函数，那我们能不能把它解码一下呢？这时候你需要一个工具--&lt;a href=&quot;http://tools.jb51.net/password/evalencode&quot; target=&quot;_blank&quot;&gt;脚本之家在线工具&lt;/a&gt;，把这些JS代码复制进去：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301093726893-1075882899.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 然后点击解码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301093925857-167165555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是一个eval函数，所以再次解码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301094010531-986131486.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这一步，已经比最开始的代码简洁多了，但是还易读性还是很差，所以我们需要先格式化一下：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;var _$ = [&lt;br/&gt;&quot;\x2e\x70\x6f\x72\x74&quot;,&lt;br/&gt;&quot;\x65\x61\x63\x68&quot;,&lt;br/&gt;&quot;\x68\x74\x6d\x6c&quot;,&lt;br/&gt;&quot;\x69\x6e\x64\x65\x78\x4f\x66&quot;,&lt;br/&gt;&quot;\x2a&quot;,&lt;br/&gt;&quot;\x61\x74\x74\x72&quot;,&lt;br/&gt;&quot;\x63\x6c\x61\x73\x73&quot;,&lt;br/&gt;&quot;\x73\x70\x6c\x69\x74&quot;,&lt;br/&gt;&quot;\x20&quot;,&lt;br/&gt;&quot;&quot;,&lt;br/&gt;&quot;\x6c\x65\x6e\x67\x74\x68&quot;,&lt;br/&gt;&quot;\x70\x75\x73\x68&quot;,&lt;br/&gt;&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x5a&quot;,&lt;br/&gt;&quot;\x70\x61\x72\x73\x65\x49\x6e\x74&quot;,&lt;br/&gt;&quot;\x6a\x6f\x69\x6e&quot;,&lt;br/&gt;&quot;&quot;&lt;br/&gt;];&lt;br/&gt;$(function() {&lt;br/&gt;$(_$[0])[_$[1]](function() {&lt;br/&gt;var a = $(this)[_$[2]]();&lt;br/&gt;if (a[_$[3]](_$[4]) != -0x1) {&lt;br/&gt;return;&lt;br/&gt;}&lt;br/&gt;var b = $(this)[_$[5]](_$[6]);&lt;br/&gt;try {&lt;br/&gt;b = b[_$[7]](_$[8])[0x1];&lt;br/&gt;var c = b[_$[7]](_$[9]);&lt;br/&gt;var d = c[_$[10]];&lt;br/&gt;var f = [];&lt;br/&gt;for (var g = 0x0; g &amp;lt; d; g++) {&lt;br/&gt;f[_$[11]](_$[12][_$[3]](c[g]));&lt;br/&gt;}&lt;br/&gt;$(this)[_$[2]](window[_$[13]](f[_$[14]](_$[15])) &amp;gt;&amp;gt; 0x3);&lt;br/&gt;} catch (e) {}&lt;br/&gt;});&lt;br/&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;可以看到有一个列表和一个函数，而这个函数应该就是混淆的函数了，但是这列表里的数据都是十六进制的，还需要解码一下（这一步可以用Python来做）：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;38&quot;&gt;
&lt;pre&gt;
_ = [&quot;\x2e\x70\x6f\x72\x74&quot;, &quot;\x65\x61\x63\x68&quot;, &quot;\x68\x74\x6d\x6c&quot;, &quot;\x69\x6e\x64\x65\x78\x4f\x66&quot;, &quot;\x2a&quot;,&lt;br/&gt;&quot;\x61\x74\x74\x72&quot;, &quot;\x63\x6c\x61\x73\x73&quot;, &quot;\x73\x70\x6c\x69\x74&quot;, &quot;\x20&quot;, &quot;&quot;, &quot;\x6c\x65\x6e\x67\x74\x68&quot;,&lt;br/&gt;&quot;\x70\x75\x73\x68&quot;, &quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x5a&quot;, &quot;\x70\x61\x72\x73\x65\x49\x6e\x74&quot;,&lt;br/&gt;&quot;\x6a\x6f\x69\x6e&quot;, &quot;&quot;&lt;br/&gt;]&lt;br/&gt;_ = [i.encode('utf-8').decode('utf-8') for i in _]&lt;br/&gt;print(_)&lt;br/&gt;# ['.port', 'each', 'html', 'indexOf', '*', 'attr', 'class', 'split', ' ', '', 'length', 'push', 'ABCDEFGHIZ', 'parseInt', 'join', '']
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;然后把这个列表里的元素添加到上面的JS函数中，可以得到如下结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; $(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   $(&quot;.port&quot;)[&quot;each&quot;](&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = $(&lt;span&gt;this&lt;/span&gt;)[&quot;html&quot;&lt;span&gt;]();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (a[&quot;indexOf&quot;](&quot;*&quot;) != -0x1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; b = $(&lt;span&gt;this&lt;/span&gt;)[&quot;attr&quot;](&quot;class&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       b = b[&quot;split&quot;](&quot; &quot;)[0x1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; c = b[&quot;split&quot;](&quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; d = c[&quot;length&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; f =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; g = 0x0; g &amp;lt; d; g++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         f[&quot;push&quot;](&quot;ABCDEFGHIZ&quot;[&quot;indexOf&quot;&lt;span&gt;](c[g]));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       $(&lt;span&gt;this&lt;/span&gt;)[&quot;html&quot;](window[&quot;parseInt&quot;](f[&quot;join&quot;](&quot;&quot;)) &amp;gt;&amp;gt; 0x3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到这段JS代码就是先找到每个端口节点，然后把端口的class值提取出来，再进行拆分字符串，然后获取每个字母在”ABCDEFGHIZ“中的下标值，并把这些值拼接成字符串，再转为整型数据，最后把这个整型数据向右移3位。比如”GEA“对应的下标组成的字符串是”640“，转为整型数据后向右移3位的结果就是80，也就是真实的端口值了。最后附上用Python解密端口号的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; et =&lt;span&gt; etree.HTML(html)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; port_list = et.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[contains(@class,&quot;port&quot;)]/@class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; port &lt;span&gt;in&lt;/span&gt;&lt;span&gt; port_list:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     port = port.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;)[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     num = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; port:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         num += str(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABCDEFGHIZ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.index(i))
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(int(num) &amp;gt;&amp;gt; 3)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;之前就有人评论说有的网站使用图片代替文字以实现反爬虫，然后我这次就找到了一个网站--&lt;a href=&quot;https://www.newegg.cn/&quot; target=&quot;_blank&quot;&gt;新蛋网&lt;/a&gt;，随意点击一个商品查看一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301103225399-327942995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开开发者工具，然后点击查看价格，想不到价格居然是通过图片来显示的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1450803/201903/1450803-20190301103332437-777860834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;解决办法：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 我找到两个可以得到价格的办法，一个简单的，一个难一点的。简单的方法是用正则表达式，因为在源码中的其他地方是包含商品的基本信息的，比如名称和价格，所以我们可以使用正则表达式进行匹配，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.newegg.cn/Product/A36-125-E5L.htm?neg_sp=Home-_-A36-125-E5L-_-CountdownV1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; res =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; result = re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name:'(.+?)', price:'(.+?)'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res.text)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;难一点的方法是把图片下载到本地之后进行识别，由于这个图片的清晰度很高，也没有扭曲或者加入干扰线什么的，所以可以直接使用OCR进行识别。但是用这种方法的话需要安装好Tesseract-OCR，这个工具的安装过程还是比较麻烦的。用这种&lt;/span&gt;&lt;span&gt;方法破解的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pytesseract
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.newegg.cn/Product/A36-125-E5L.htm?neg_sp=Home-_-A36-125-E5L-_-CountdownV1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; res =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; et =&lt;span&gt; etree.HTML(res.text)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; img_url = et.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;priceValue&quot;]/span/strong/img/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     f.write(requests.get(img_url).content)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; pytesseract.pytesseract.tesseract_cmd = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:/Python/Tesseract-OCR/tesseract.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; text = pytesseract.image_to_string(Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(text)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6999.00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 03 Mar 2019 02:09:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>上一篇博客的末尾说到全网代理IP的端口号是经过加密混淆的，而这一篇博客就将告诉你如何破解！如果觉得有用的话，不妨点个推荐哦~ 一、全网代理IP的JS混淆 首先进入全网代理IP，打开开发者工具，点击查看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TM0831/p/10454884.html</dc:identifier>
</item>
</channel>
</rss>