<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vim  操作 - 奇迹969</title>
<link>http://www.cnblogs.com/qj696/p/12258330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qj696/p/12258330.html</guid>
<description>&lt;p&gt;1.单行复制19次    esc+yy+19p&lt;/p&gt;
&lt;p&gt;2esc+:+u      回退                 ctrl+r&lt;/p&gt;
&lt;p&gt;3vim  文件名   +行数     ：打开文件定义指定行数&lt;/p&gt;
&lt;p&gt;4set number   显示行号&lt;/p&gt;
&lt;p&gt;5异常处理    vi被强行退出  要删除佳欢文件才可继续执行&lt;/p&gt;
&lt;p&gt;6vim 3种工作模式         命令模式 （复制粘贴翻页删除等）      末行模式（保存退出）    编辑模式（编辑文字）&lt;/p&gt;
&lt;p&gt;命令      i     编辑   esc  命令                            命令       ：   末行     esc     命令&lt;/p&gt;
&lt;p&gt;7vim   命令&lt;/p&gt;
&lt;p&gt;h j k l 左 下 上 右&lt;/p&gt;
&lt;p&gt;行内移动   w 后移一个&lt;span&gt;单词（不是字母）&lt;/span&gt;   b前移   0行首     ^行首    $行尾&lt;/p&gt;
&lt;p&gt;行数移动   gg文件顶部   G文件尾部     &lt;/p&gt;
&lt;p&gt;数字gg   /数字G / 数字  移动到数字对应行 &lt;/p&gt;
&lt;p&gt;屏幕移动  ctrl+b上翻页    ctrl+f 下翻页    H屏幕顶部   M屏幕中间    L屏幕底部&lt;/p&gt;

&lt;p&gt;段落移动 （以空行为准）   {上一段                  }下一段&lt;/p&gt;
&lt;p&gt;括号切换   %     成对括号之间来回切换&lt;/p&gt;
&lt;p&gt;选中文本命令（3种） v        V           ctrl+v&lt;/p&gt;
&lt;p&gt;u 撤销上次命令      ctrl+r  恢复撤销的命令&lt;/p&gt;
&lt;p&gt;删除文本  x:删出光标所在字符或选中文件     d 删除移动命令对应的内容   dd删除光标所在行，ndd复制多行    D删除至尾行&lt;/p&gt;

&lt;p&gt;复制和粘贴&lt;/p&gt;
&lt;p&gt;y复制     yy复制一行     nyy复制多行       p粘贴&lt;/p&gt;

&lt;p&gt;替换命令&lt;/p&gt;
&lt;p&gt;r替换当前字符                    R替换当前行光标后的字符&lt;/p&gt;
&lt;p&gt;缩排和重复执行   &amp;gt;&amp;gt; 向右增加缩进      &amp;lt;&amp;lt;向左减少缩进        &lt;span&gt;. &lt;/span&gt;重复上次命令&lt;/p&gt;

&lt;p&gt;查找命令   /str    查找str        n向下找   N向上找                                          光标在单词 * 向下找     #向上找&lt;/p&gt;

&lt;p&gt;查找并替换     ：%s/就文本/新文本/g&lt;/p&gt;
&lt;p&gt;可视区域范围替换  ：s///g&lt;/p&gt;
&lt;p&gt;确认替换   ：%s///g                y n   a-all   q-quit    l-last       ^E向下滚屏    ^Y向上滚屏&lt;/p&gt;
&lt;p&gt;插入命令   O上面插入一行   o下面插入一行   I行首插入   i字符前插入   a字符后插入   A行末插入&lt;/p&gt;

&lt;p&gt;末行命令扩展 &lt;/p&gt;
&lt;p&gt;：e。 浏览文件      ：n 文件名    新建文件    ：w  文件名    另存为&lt;/p&gt;

&lt;p&gt;分屏命令：&lt;/p&gt;
&lt;p&gt;：sp[文件名]   横向分屏                  ：vsp[文件名]纵向分屏&lt;/p&gt;
&lt;p&gt;切换窗口 ctrl+w&lt;/p&gt;
&lt;p&gt;w切换下一个窗口r 互换窗口c关闭当前窗口q退出当前窗口o关闭其他窗口&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 00:41:00 +0000</pubDate>
<dc:creator>奇迹969</dc:creator>
<og:description>1.单行复制19次 esc+yy+19p 2esc+:+u 回退 ctrl+r 3vim 文件名 +行数 ：打开文件定义指定行数 4set number 显示行号 5异常处理 vi被强行退出 要删除佳</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qj696/p/12258330.html</dc:identifier>
</item>
<item>
<title>响应国家号召，在家撸码之React迁移记 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12017473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12017473.html</guid>
<description>&lt;p&gt;　　最近这段时间新型冠状病毒肆虐，上海确诊人数每天都在增加，人人提心吊胆，街上都没人了。为了响应国家号召，近期呆在家里撸码，着手将项目迁移到React中，项目比较朴素，是一张线索提交页面，包含表单、图片滚动等功能。&lt;/p&gt;

&lt;p&gt;　　项目基于Create React App构建而成，简单的做了下二次封装，src目录的结构如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── src
│   ├── __tests__ &lt;/span&gt;----------------------&lt;span&gt; 测试文件
│   ├── common &lt;/span&gt;-------------------------&lt;span&gt; 通用功能
│   ├── component &lt;/span&gt;----------------------&lt;span&gt; 组件
│   ├── img &lt;/span&gt;----------------------------&lt;span&gt; 图片
│   ├── page &lt;/span&gt;---------------------------&lt;span&gt; 页面
│   ├── router &lt;/span&gt;-------------------------&lt;span&gt; 路由
│   ├── store &lt;/span&gt;--------------------------&lt;span&gt; 状态容器
│   ├── index.scss &lt;/span&gt;---------------------&lt;span&gt; 公共样式
│   ├── index.js &lt;/span&gt;----------------------- 入口文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在index.js中会引入公共样式、路由、统计脚本、通用功能等。index.scss集合的公共样式包括重置、布局、字体、间距等。common中的通用功能包括通信、加载第三方脚本、微信配置等。&lt;/p&gt;

&lt;p&gt;　　在本项目中组件都以函数的形式出现，并且其最小的粒度是控件，也就是文本框（Input）、选择框（Select）、复选框（Checkbox）和单选框（Radio），然后是表单（Form）和三级联动（Chain），其目录如下所示，一定会包含index两个文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── component
│   ├── Input &lt;/span&gt;--------------------------&lt;span&gt; 控件
│   │   ├── index.scss &lt;/span&gt;-----------------&lt;span&gt; 样式
│   │   ├── index.js &lt;/span&gt;------------------- 脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Form组件中，会包含其它组件，并且会传递相关数据给它们。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）文本框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一般会将文本框的type、placeholder和name传进来，当没有属性时，就直接返回一个只包含基本样式的文本框。在Input组件中，通过useState()钩子初始化状态，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Input(props) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!props) &lt;span&gt;return&lt;/span&gt; &amp;lt;input className=&quot;input&quot; /&amp;gt;;             //空的文本框
  const [value, setValue] = useState(props.value || &quot;&quot;&lt;span&gt;);
  const inputProps &lt;/span&gt;=&lt;span&gt; {
    type: props.type,
    placeholder: props.placeholder,
    name: props.name
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input className=&quot;input&quot; {...inputProps} /&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Form组件中可传递的数据如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const txt =&lt;span&gt; {
  type: &lt;/span&gt;&quot;text&quot;&lt;span&gt;,
  placeholder: &lt;/span&gt;&quot;姓名&quot;&lt;span&gt;,
  name: &lt;/span&gt;&quot;name&quot;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）单选框和复选框&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　单选框和复选框接收的props是一个数组，而不是对象，在Form组件中可传递的数据如下所示，其中defaultChecked属性用于设置默认的选中项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
const radios =&lt;span&gt; [
  {type:&lt;/span&gt;&quot;radio&quot;, name:&quot;gender&quot;, value:1, text:&quot;man&quot;&lt;span&gt;},
  {type:&lt;/span&gt;&quot;radio&quot;, name:&quot;gender&quot;, value:2, text:&quot;woman&quot;, defaultChecked:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}
];
const checkboxs &lt;/span&gt;=&lt;span&gt; [
  {type:&lt;/span&gt;&quot;checkbox&quot;, name:&quot;color&quot;, value:1, text:&quot;红&quot;&lt;span&gt;},
  {type:&lt;/span&gt;&quot;checkbox&quot;, name:&quot;color&quot;, value:2, text:&quot;绿&quot;, defaultChecked:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;},
  {type:&lt;/span&gt;&quot;checkbox&quot;, name:&quot;color&quot;, value:3, text:&quot;蓝&quot;, defaultChecked:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Radio组件中，选中项保存在checked变量中，通过ES6新增的find()方法获取，如下所示。组件为每个单选框注册了Change事件，事件处理程序中调用的callback()方法将在后文讲解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Radio(props) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!props) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  const radios &lt;/span&gt;= props.items ||&lt;span&gt; [],
    checked &lt;/span&gt;= radios.find(item =&amp;gt; item.defaultChecked) ||&lt;span&gt; {},
    [value, setValue] &lt;/span&gt;= useState(checked.value || &quot;&quot;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handle(e) {
    props.callback(e.target.value);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; radios.map(item =&amp;gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;label className={&quot;ui-&quot; + item.type} key={item.value}&amp;gt;
      &amp;lt;input {...item} onChange={handle} /&amp;gt;
&lt;span&gt;      {item.text}
    &lt;/span&gt;&amp;lt;/label&amp;gt;
&lt;span&gt;  ));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Checkbox组件中，选中项可以是多个，保存在checkeds数组中，通过filter()和map()获取。同样为每个复选框都注册了一个Change事件，在事件处理程序中会过滤掉当前值，当选中时，再添加到选中数组中，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt; Checkbox(props =&lt;span&gt; []) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (props.length == 0) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  const checkboxs &lt;/span&gt;= props.items ||&lt;span&gt; [],
    checkeds &lt;/span&gt;=&lt;span&gt; checkboxs
      .filter(item &lt;/span&gt;=&amp;gt;&lt;span&gt; item.defaultChecked)
      .map(item &lt;/span&gt;=&amp;gt;&lt;span&gt; item.value),
    [values, setValues] &lt;/span&gt;=&lt;span&gt; useState(checkeds);
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handle(e) {
    const { checked, value } &lt;/span&gt;=&lt;span&gt; e.target;
    const current &lt;/span&gt;= values.filter(item =&amp;gt; item !=&lt;span&gt; value);
    checked &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; current.push(value);
    props.callback(current);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; checkboxs.map(item =&amp;gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;label className={&quot;ui-&quot; + item.type} key={item.value}&amp;gt;
      &amp;lt;input {...item} onChange={handle} /&amp;gt;
&lt;span&gt;      {item.text}
    &lt;/span&gt;&amp;lt;/label&amp;gt;
&lt;span&gt;  ));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）快照测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在做快照测试时，需要传递事件对象，为简便起见，直接用一个普通对象模拟它，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
it(&quot;Radio-Snapshot&quot;, () =&amp;gt;&lt;span&gt; {
  const radios &lt;/span&gt;=&lt;span&gt; [
    { type: &lt;/span&gt;&quot;radio&quot;, name: &quot;gender&quot;, value: 1, text: &quot;man&quot;&lt;span&gt; },
    { type: &lt;/span&gt;&quot;radio&quot;, name: &quot;gender&quot;, value: 2, text: &quot;woman&quot;, defaultChecked: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }
  ];
  const component &lt;/span&gt;= renderer.create(&amp;lt;Radio items={radios} /&amp;gt;);
  let tree =&lt;span&gt; component.toJSON();
  expect(tree).toMatchSnapshot();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟Change事件&lt;/span&gt;
  const event = { target: { value: 1&lt;span&gt; } };
  act(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    tree[&lt;/span&gt;0].children[0&lt;span&gt;].props.onChange(event);
  });
  tree &lt;/span&gt;=&lt;span&gt; component.toJSON();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，为了测试时更接近React在浏览器中的工作方式，需要在act()方法中运行组件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在表单中需要搜集控件的值，此时会涉及父子之间的通信。如果要在父组件中读取子组件的状态，那么有两种方式实现。&lt;/p&gt;
&lt;p&gt;　　第一种是通过事件对象，也就是在表单的Submit事件中读取事件对象的target属性，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; submit(e) {
  console.log(e.target.name.value);     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取控件值&lt;/span&gt;
&lt;span&gt;  e.preventDefault();
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
  &lt;/span&gt;&amp;lt;form id=&quot;appointment&quot; name=&quot;appointment&quot; className=&quot;form&quot; onSubmit={submit}&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li className=&quot;ui-mb30 ui-flex ui-flex-column-center&quot;&amp;gt;
        &amp;lt;Input {...txt} /&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;ui-mb30 ui-flex ui-flex-column-center&quot;&amp;gt;
        &amp;lt;Input items={radios} /&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;ui-mb30 ui-flex ui-flex-column-center&quot;&amp;gt;
        &amp;lt;Input items={checkboxs} /&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/form&amp;gt;
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是通过回调函数，也就是在表单中传递一个函数到组件内。如果一个个传递，维护成本会巨大，而以高阶组件的方式，会简洁许多，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高阶组件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; HOC(Wrapped, data) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子组件向父组件传递信息&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; callback(value) {
    data.currentValue &lt;/span&gt;=&lt;span&gt; value;
  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Enhanced(props) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Wrapped callback={callback} {...props} /&amp;gt;;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Enhanced;
}
const InputHOC &lt;/span&gt;=&lt;span&gt; HOC(Input, txt),
  RadioHOC &lt;/span&gt;=&lt;span&gt; HOC(Radio, radios),
  CheckboxHOC &lt;/span&gt;= HOC(Checkbox, checkboxs);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在控件中读取的值都得经过验证后，才能提交到服务器中。目前的做法比较粗暴，封装性和扩展性都不友好，将验证逻辑直接放置在Form组件中，如下所示，包含三组验证规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const methods =&lt;span&gt; {
  required: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value) {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; value.length &amp;gt; 0 || &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  },
  name: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value) {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; /^[\u4e00-\u9fa5]+$/&lt;span&gt;.test(value);
  },
  mobile: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value) {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机号码验证&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; /^1[0-9]{10}$/&lt;span&gt;.test(value);
  },
  checked: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value = &quot;&quot;&lt;span&gt;, data) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!data.rules || !&lt;span&gt;data.messages) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    const rules &lt;/span&gt;= data.rules.split(&quot;|&quot;&lt;span&gt;),
      messages &lt;/span&gt;= data.messages.split(&quot;|&quot;&lt;span&gt;),
      length &lt;/span&gt;=&lt;span&gt; rules.length;
    let i &lt;/span&gt;= 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; length) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[rules[i]](value)) {
        i&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
      alert(messages[i]);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要验证的渲染数据会多两个属性：rules和messages，以竖线分隔，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const txt =&lt;span&gt; {
  type: &lt;/span&gt;&quot;text&quot;&lt;span&gt;,
  placeholder: &lt;/span&gt;&quot;姓名&quot;&lt;span&gt;,
  name: &lt;/span&gt;&quot;name&quot;&lt;span&gt;,
  rules: &lt;/span&gt;&quot;required|name&quot;&lt;span&gt;,
  messages: &lt;/span&gt;&quot;请输入姓名|请输入正确的姓名&quot;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）Redux&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本来还尝试使用Redux来处理组件的状态，但还没有完全理解其精髓，在实际操作时有点力不从心。例如在Store.js容器文件中只是想处理状态，但是得引入要关联的Input组件（如下所示），这与我的初衷有偏差。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import React from &quot;react&quot;&lt;span&gt;;
import { createStore } from &lt;/span&gt;&quot;redux&quot;&lt;span&gt;;
import { connect, Provider } from &lt;/span&gt;&quot;react-redux&quot;&lt;span&gt;;
import { Input } from &lt;/span&gt;&quot;../component/Input/index&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Actions&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addName(name) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    type: &lt;/span&gt;&quot;ADD_NAME&quot;&lt;span&gt;,
    name
  };
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Reducers&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; caculate(previousState, action) {
  let state &lt;/span&gt;=&lt;span&gt; Object.assign({}, previousState);
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;ADD_NAME&quot;&lt;span&gt;:
      state.name &lt;/span&gt;=&lt;span&gt; action.name;
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
}

const store &lt;/span&gt;=&lt;span&gt; createStore(caculate);
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapStateToProps(state) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
}
const SmartInput &lt;/span&gt;=&lt;span&gt; connect(mapStateToProps, { addName })(Input);
const Store &lt;/span&gt;=&lt;span&gt; (
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;SmartInput /&amp;gt;
  &amp;lt;/Provider&amp;gt;
&lt;span&gt;);
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Store;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Input组件也需要修改，在Change事件中回调传递过来的addName()方法，触发Redux更新状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Input(props) {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handle(e) {
    props.addName(e.target.value);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input className=&quot;input&quot; onChange={handle} /&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　保存的状态会以Context方式传递，在接收时需要通过&lt;span&gt;&lt;a href=&quot;https://react-redux.js.org/api/provider&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ReactReduxContext.Consumer&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import { ReactReduxContext } from 'react-redux'&lt;span&gt;;
render() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;ReactReduxContext.Consumer&amp;gt;&lt;span&gt;
      {({ store }) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something with the store here&lt;/span&gt;
&lt;span&gt;      }}
    &lt;/span&gt;&amp;lt;/ReactReduxContext.Consumer&amp;gt;
&lt;span&gt;  )
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Form组件中可以像下面这样引用容器，但其实我只是想在当前读取到子组件的状态，目前的逻辑并没有解决该问题，有待修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import Store from '../../store/index'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Form() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;form id=&quot;appointment&quot; name=&quot;appointment&quot; className=&quot;form&quot; onSubmit={submit}&amp;gt;&lt;span&gt;
      {Store}
    &lt;/span&gt;&amp;lt;/form&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Swiper是流行的触摸滑动插件，但没有找到官方的React版本。如果使用其它相关的React插件，需要增加集成的时间成本，并且还有未知BUG，可能影响上线时间，因此还是决定使用Swiper，进行二次封装，组件目录如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── Swiper
│   ├── img &lt;/span&gt;----------------------------&lt;span&gt; 图片
│   ├── index.js &lt;/span&gt;-----------------------&lt;span&gt; 脚本
│   ├── index.scss &lt;/span&gt;---------------------&lt;span&gt; 样式
│   ├── swiper.js &lt;/span&gt;----------------------&lt;span&gt; 插件脚本
│   ├── swiper.scss &lt;/span&gt;-------------------- 插件样式
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在组件中引入了useEffect()钩子，并且将图像作为资源引入，如下代码所示。useEffect()会在componentDidMount()和componentDidUpdate()触发，此时DOM结构中已包含Swiper容器，可以将其初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { useEffect } from &quot;react&quot;&lt;span&gt;;
import &lt;/span&gt;&quot;./index.scss&quot;&lt;span&gt;;
import Swiper from &lt;/span&gt;&quot;./swiper&quot;&lt;span&gt;;
import img1 from &lt;/span&gt;&quot;./img/1.png&quot;&lt;span&gt;;
import img2 from &lt;/span&gt;&quot;./img/2.png&quot;&lt;span&gt;;
import img3 from &lt;/span&gt;&quot;./img/3.png&quot;&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ReactSwiper(props) {
  useEffect(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Swiper(&quot;#slide&quot;&lt;span&gt;, {
      loop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    });
  });
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;section className=&quot;ui-rel&quot;&amp;gt;
      &amp;lt;div id=&quot;slide&quot; className=&quot;swiper-container&quot;&amp;gt;
        &amp;lt;article className=&quot;swiper-wrapper&quot;&amp;gt;
          &amp;lt;section className=&quot;swiper-slide&quot;&amp;gt;
            &amp;lt;img src={img1} className=&quot;img-slider&quot; /&amp;gt;
          &amp;lt;/section&amp;gt;
          &amp;lt;section className=&quot;swiper-slide&quot;&amp;gt;
            &amp;lt;img src={img2} className=&quot;img-slider&quot; /&amp;gt;
          &amp;lt;/section&amp;gt;
          &amp;lt;section className=&quot;swiper-slide&quot;&amp;gt;
            &amp;lt;img src={img3} className=&quot;img-slider&quot; /&amp;gt;
          &amp;lt;/section&amp;gt;
        &amp;lt;/article&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　省市经销商三级联动是本项目的一个特殊业务，类似于常规的省市区三级联动。三级联动的数据来源于一个静态文件，数据格式如下所示，保存在shops.js中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;let&lt;/span&gt; poi =&lt;span&gt; [ {
    name: &lt;/span&gt;&quot;北京&quot;&lt;span&gt;,
    citys: [ {
        name: &lt;/span&gt;&quot;北京&quot;&lt;span&gt;,
        dealer: [
          { dealerName: &lt;/span&gt;&quot;北京汽车销售有限公司&quot;&lt;span&gt; },
          { dealerName: &lt;/span&gt;&quot;北京商贸有限公司&quot;&lt;span&gt; }
        ]
    }]
}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Chain组件中的状态是一个对象，与之前不同，在调用更新函数时，不能直接传初始化的变量，得改用对象解构复制一个对象，再传这个副本，否则无法触发组件的渲染，如下所示，省略了部分逻辑代码和两个选择框。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
import React, {useState} from 'react'&lt;span&gt;;
import &lt;/span&gt;'./index.scss'&lt;span&gt;;
import {poi} from &lt;/span&gt;'./shops'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Chain(props) {
  let initData &lt;/span&gt;=&lt;span&gt; {
    provinces: [],
    province: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
    cities: [],
    shops: [],
    poiHash: {}
  };
  initData.provinces &lt;/span&gt;=&lt;span&gt; setOption(poi);
  poi.forEach(value &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    initData.poiHash[value.proName] &lt;/span&gt;=&lt;span&gt; value.citys;
  });

  const [data, setData] &lt;/span&gt;=&lt;span&gt; useState(initData);
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; clearOptions(name) {
    data[name] &lt;/span&gt;=&lt;span&gt; [];
    setData({ ...data });
  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; options(name, list) {
    clearOptions(name);
    data[name] &lt;/span&gt;=&lt;span&gt; setOption(list);
    setData({ ...data });         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象解构&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;setData(data);            //错误 无法触发渲染&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; provinceChange(e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; e.target.value;
    data.province &lt;/span&gt;=&lt;span&gt; val;
    options(&lt;/span&gt;&quot;cities&quot;&lt;span&gt;, data.poiHash[val]);
    clearOptions(&lt;/span&gt;&quot;shops&quot;&lt;span&gt;);
  }

 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;&amp;gt;
      &amp;lt;label className=&quot;select-container ui-mb20&quot;&amp;gt;
        &amp;lt;select onChange={provinceChange}&amp;gt;
          &amp;lt;option value=&quot;&quot;&amp;gt;省份&amp;lt;/option&amp;gt;
          {data.provinces.map(item =&amp;gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;option value={item.value} key={item.value}&amp;gt;&lt;span&gt;
              {item.text}
            &lt;/span&gt;&amp;lt;/option&amp;gt;
&lt;span&gt;          ))};
        &lt;/span&gt;&amp;lt;/select&amp;gt;
      &amp;lt;/label&amp;gt;
&lt;span&gt;      ......
    &lt;/span&gt;&amp;lt;/&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 04 Feb 2020 00:37:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>最近这段时间新型冠状病毒肆虐，上海确诊人数每天都在增加，人人提心吊胆，街上都没人了。为了响应国家号召，近期呆在家里撸码，着手将项目迁移到React中，项目比较朴素，是一张线索提交页面，包含表单、图片滚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12017473.html</dc:identifier>
</item>
<item>
<title> 如何快速融入团队并成为团队核心(四) - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12258324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12258324.html</guid>
<description>&lt;p&gt;不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团队易于使人加入”的问题。&lt;/p&gt;
&lt;p&gt;这其实首先是个组织建设的问题，表现出来就是“使命”、“愿景”、“价值观”、“企业文化”、“企业基因”、“江湖规矩”，其次就是一个团队建设的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200204083331495-1471185813.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;团队建设，其实无处不在，他在每一天无时无刻都在开展，如果说企业文化建设是构建企业赖以为生的精神食粮，那么团队建设就是为了增强体魄。团队建设好不好，并非是某些部门的事、也并非领导个人的事，实际上是大家都在参与的事情。一支拥有战斗力的团队，并非仅仅惠及领导或企业，实际上也在惠及团队中参与的每个人。&lt;/p&gt;
&lt;p&gt;从某种意义上讲，团队建设的目的，并非仅仅是为了构建团队，更是为了让团队中的每个人都能在所谓“建设”中得到成长。华为致力于打造狼性的团队文化，显然不仅仅是为了商业层面的战斗力提升，而是通过让狼性的团队文化深入到团队每一个人的灵魂中，让团队中的每个人都成为值得彼此信赖的人，并最终实现了企业在商业层面的巨大成功。当然，华为人同样也有离职或跳槽的，当他们离开华为，前往其他公司时，也把从华为汲取到的宝贵财富带动了其他团队，进而促进了其他团队的进一步发展。这恰好说明，团队建设的目的，并非是为了建设一个单个团队，而是先建设好个人，其次才能建设好团队。&lt;/p&gt;
&lt;p&gt;“三人行，必有我师焉”，我们曾经一度以为，学习是从课堂中学习开始、再学习我们的长辈、学习我们的主管领导、或者学习我们的老板，其实并非如此，学习是发生在每一瞬间，是人类有别于其他生物的一种本能，我们无时无刻不在学习，而在企业中共处时，我们的学习行为也本身就是团队建设的一部分。团队中的每个人，都能成为我们值得学习的一部分，也许他们在某些点上看不出优点，但是往往在其他点上散发出灼热的光芒。&lt;/p&gt;
&lt;p&gt;每个人并非生来就是完美的人，而是经过数十年的成长，在日常生活、人际交往、职场中吸取到我们身边其他人身上的优点，然后用其他人的优点构成自己的优点和灵魂，并最终趋于个体健全。同时，我们也把自己的优点投影到其他人的世界中，也在促进其他人的成长。&lt;/p&gt;
&lt;p&gt;事实上团队不仅仅是公司的一个部门，我们的一个社区、家庭、或者一个关系融洽的小组织，其实都是一个团队。而当我们加入这一的小组织时，团队建设就已经开始了，我们的一言一行，既对别人产生了影响，而别人的一言一行，也同样对我们产生了影响。&lt;/p&gt;
&lt;p&gt;有时每个人都期待与最优秀的人为伍，总觉得那些优秀的人一定无时无刻都在散发着主角的光辉，我们只需从他们散发的光辉中，汲取那么一点点就足以使我们成为一个优秀的个体。其实往往我们应该相信，我们所加入的每个团队其实都是优秀的团队，我们自身每个人都是优秀的个体，只需采取适当的引导措施，都能创造出足够优秀的成绩。&lt;/p&gt;

&lt;p&gt;布鲁斯·塔克曼将团队建设的过程划分为五个阶段，虽然这个理论已经诞生已经快50年了，但是迄今依然散发着蓊郁的芬芳，可以称为团队建设领域的一块丰碑。他将团队建设划分为“形成期”、“震荡期”、“稳定期”、“规范期”、“稳定期”，他认为每个阶段都是必须、不可逾越的，每个团队的组建过程往往都必须经过这五个阶段。&lt;/p&gt;
&lt;p&gt;当然，塔克曼的团队发展阶段理论主要使用于小型团队，但在本文中主要借用来形容一个团队的发展阶段，并非本文的主要内容。&lt;/p&gt;
&lt;h2 id=&quot;形成期&quot;&gt;形成期&lt;/h2&gt;
&lt;p&gt;团队初步建立，人员刚刚加入、或有新的人员加入，还需要对彼此进行认识，了解团队和组织的文化，逐步建立起团队基本的信任过程。在这个阶段人员间往往会比较独立，无法开诚布公的交流问题。团队存在焦虑心理，对团队的发展比较迷茫、甚至不稳定。&lt;/p&gt;
&lt;h2 id=&quot;震荡期&quot;&gt;震荡期&lt;/h2&gt;
&lt;p&gt;初步形成了各种观念，并逐步的认识彼此，但是会存在震荡和观点上的碰撞，甚至由于某些技术性的观点会产生一定的冲突。而冲突实际上是说明团队间已经开始寻找彼此沟通的方式，并逐步的适应对方。&lt;/p&gt;
&lt;h2 id=&quot;规范期&quot;&gt;规范期&lt;/h2&gt;
&lt;p&gt;形成了团队的沟通方式和团队文化，团队成员都逐步认识自己在团队中所能承担的角色，并能够为了完成一致的目标而做出自己的努力，在这个阶段彼此间能够流畅自如的进行沟通和任务的执行，并能表现出所具有的一定的自治性。&lt;/p&gt;
&lt;h2 id=&quot;稳定期&quot;&gt;稳定期&lt;/h2&gt;
&lt;p&gt;团队运作如同一个整体，彼此沟通融洽，团队能量凝聚一起，彼此间形成的团队能力能够顺利的对任务进行解读并完成目标，同时团队由于已经建立了基本的沟通规则，在一般的事务性问题上已经能够非常独立自治的解决问题。这也是一个战斗力强的团队所具有的基本形态。事实上如果在这个阶段再引入新来的成员，也将重新尽力从形成期开始的阶段。&lt;/p&gt;
&lt;h2 id=&quot;解散期&quot;&gt;解散期&lt;/h2&gt;
&lt;p&gt;又称为“休整期”，任务完成后，团队即将解散，彼此非常珍惜过去来之不易的相处时光，也难免产生失落感。一部分成员将离开团队，团队的战斗力将造成一定的影响，成员对于未来的不确定性将开始逐步占上风。&lt;/p&gt;

&lt;p&gt;某种意义上上讲，一个团队的形成，有时候像“三个和尚挑水喝”的古老谚语，毋庸置疑，人越少越容易团结、越容易管理、也容易形成自己的团队文化，而团队规模的逐渐增长，也看似会引发这样或那样的问题。尤其是中国人的典型特点，也曾经是在个体时往往具备非常不错的单兵作战能力，但是以集体的形式，会比较难以磨合。&lt;/p&gt;
&lt;p&gt;尤其是如果奢望在一个团队中，都是一群优秀的人，其实不太现实，过于优秀的单兵能力凝聚起来，就像是三体星一样，能够维持短期的稳定，却也暗含着不稳定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200204083339873-1751810804.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来自《DotNET骚操作》公众号，博主说等30秒钟就能看到三体星溃散的效果了。）&lt;/p&gt;
&lt;p&gt;而且有时候又渴望通过一定的控制力来维系团队的平衡，其实不见得能产生很好的效果，在一个看似稳定的组织中，引入一些强有力的措施，有时或许会产生下面的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200204083414099-1581778990.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即在一个稳定的平面空间中，引入了一个重量级的“太阳”，自然而然会对空间和时间产生扭曲力，从而破坏原来平等的局面。&lt;/p&gt;
&lt;p&gt;当然，有时候引入“太阳”是必要的。&lt;/p&gt;

&lt;p&gt;团队建设者不应该奢求依托强大的“组织机器”的力量来维系组织的平衡，有时候团队建设更是应该使用“上善若水”的精神，用如水般柔和的力量为团队间营造一种积极交流、互相倾听的文化，让彼此间能够成为对方的信赖。&lt;/p&gt;
&lt;p&gt;例如2019年听闻的“滴滴”北京团队组团游野长城，结果被困的消息，大概体现了团队建设者操之过急的团队建设心态吧。&lt;/p&gt;
&lt;p&gt;而同样作为团队建设者的我曾经在组织中实践过一种这样的方法，由于我们小团队的人员来源于不同的公司，年龄也有不同，（30岁居多），所以我试图利用每天给大家倒开水泡枸杞这个小细节来建立起团队基本的沟通方式，除此之外，也建立了一系列操作手法，使得不同经验的人都能够在团队中把自己的有点表现出来，从而使得团队间易于破冰，并打造出了一个具有战斗力的小团队。&lt;/p&gt;
&lt;p&gt;团队建设不拘泥于形式，每一个细节其实都可以表现出来。每天上班的一声问候、饭局上的互相寒暄，有意无意的引导，以及适度的积极倾听，把团队的每个人都当做你的家庭成员，可以用的方法太多了。&lt;/p&gt;
&lt;p&gt;不要再动不动就选择吃饭了。。多俗气啊~&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 00:36:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一 引子 不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12258324.html</dc:identifier>
</item>
<item>
<title>android开发实战-记账本APP（一） - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/12258104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/12258104.html</guid>
<description>&lt;p&gt;&lt;span&gt;记账本开发流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个记账本的初步开发而言，我实现的功能有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①实现一个记账本的页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②可以添加数据并更新到页面中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③可以将数据信息以图表的形式展现&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（一）首先，制作一个记账本的页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①在系统自动创建的content_main.xml文件中添加listview&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ListView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/lv_main&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②创建一个list_item.xml来实现见记账本的页面布局，一共需要三个组件，一个是记账信息，记账时间，记账金额&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;80dp&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tv_title&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;150dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;80dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;&lt;span&gt;=&quot;10dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_alignParentLeft&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;
        android:singleLine&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:textSize&lt;/span&gt;&lt;span&gt;=&quot;35sp&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;costTitle&quot;&lt;/span&gt;&lt;span&gt;
        android:ellipsize&lt;/span&gt;&lt;span&gt;=&quot;marquee&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tv_date&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;80dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_toRightOf&lt;/span&gt;&lt;span&gt;=&quot;@+id/tv_title&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_marginLeft&lt;/span&gt;&lt;span&gt;=&quot;15dp&quot;&lt;/span&gt;&lt;span&gt;
        android:textSize&lt;/span&gt;&lt;span&gt;=&quot;20sp&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;costDate&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tv_cost&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;80dp&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;
        android:textSize&lt;/span&gt;&lt;span&gt;=&quot;30sp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_marginRight&lt;/span&gt;&lt;span&gt;=&quot;20dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_alignParentRight&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;页面截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200203232716224-613826158.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;435&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; ③编写适配器并进行测试，因此我们需要建立一个CostListAdapter.java，还需要建立我们的bean对象，因此需要在建立一个CostBean来存储我们的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记账信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.xlfbook;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.LayoutInflater;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.ViewGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.BaseAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CostListAdapter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseAdapter {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;CostBean&amp;gt;&lt;span&gt; mlist;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Context mContext;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LayoutInflater mlayoutInflater;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CostListAdapter(Context context,List&amp;lt;CostBean&amp;gt;&lt;span&gt; list){
        mContext&lt;/span&gt;=&lt;span&gt;context;
        mlist&lt;/span&gt;=&lt;span&gt;list;
        mlayoutInflater&lt;/span&gt;=&lt;span&gt;LayoutInflater.from(context);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mlist.size();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object getItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mlist.get(position);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getItemId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; position;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; View getView(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(convertView==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            viewHolder&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewHolder();
            convertView&lt;/span&gt;=mlayoutInflater.inflate(R.layout.list_item,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            viewHolder.mTvCostTitle&lt;/span&gt;=&lt;span&gt;convertView.findViewById(R.id.tv_title);
            viewHolder.mTvCostDate&lt;/span&gt;=&lt;span&gt;convertView.findViewById(R.id.tv_date);
            viewHolder.mTvCostMoney&lt;/span&gt;=&lt;span&gt;convertView.findViewById(R.id.tv_cost);
            convertView.setTag(viewHolder);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            viewHolder&lt;/span&gt;=&lt;span&gt;(ViewHolder) convertView.getTag();
        }
        CostBean bean&lt;/span&gt;=&lt;span&gt;mlist.get(position);
        viewHolder.mTvCostTitle.setText(bean.costTitle);
        viewHolder.mTvCostDate.setText(bean.costDate);
        viewHolder.mTvCostMoney.setText(bean.costMoney);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertView;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewHolder{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextView mTvCostTitle;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextView mTvCostDate;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TextView mTvCostMoney;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;CostBean，这里implements的意义是为了一会的intent数据传递。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.xlfbook;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CostBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String costTitle;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String costDate;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String costMoney;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;CostBean{&quot; +
                &quot;costTitle='&quot; + costTitle + '\'' +
                &quot;, costDate='&quot; + costDate + '\'' +
                &quot;, costMoney='&quot; + costMoney + '\'' +
                '}'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCostDate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; costDate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCostDate(String costDate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.costDate =&lt;span&gt; costDate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCostMoney() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; costMoney;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCostMoney(String costMoney) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.costMoney =&lt;span&gt; costMoney;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCostTitle() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; costTitle;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCostTitle(String costTitle) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.costTitle =&lt;span&gt; costTitle;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;④再然后在主程序中获取ListView并设置adapter，并进行适配器的测试。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（二）进行数据库的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①建立数据库实现增/删/查的方法实现。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.xlfbook;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.ContentValues;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.Cursor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteDatabase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteOpenHelper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.annotation.Nullable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DatabaseHelper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SQLiteOpenHelper {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String COST_TITLE = &quot;cost_title&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String COST_DATE = &quot;cost_date&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String COST_MONEY = &quot;cost_money&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String IMOOC_COST = &quot;imooc_cost&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DatabaseHelper(@Nullable Context context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(context, &quot;imooc_daily&quot;, &lt;span&gt;null&lt;/span&gt;, 1&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(SQLiteDatabase db) {
        db.execSQL(&lt;/span&gt;&quot;create table if not exists IMOOC_COST(&quot;+
                &quot;id integer primary key, &quot;+
                &quot;cost_title varchar, &quot;+
                &quot;cost_date varchar, &quot;+
                &quot;cost_money varchar)&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insertCost(CostBean costBean)
    {
        SQLiteDatabase database&lt;/span&gt;=&lt;span&gt;getWritableDatabase();
        ContentValues cv&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentValues();
        cv.put(COST_TITLE,costBean.costTitle);
        cv.put(COST_DATE,costBean.costDate);
        cv.put(COST_MONEY,costBean.costMoney);
        database.insert(IMOOC_COST,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,cv);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cursor getAllCostData(){
        SQLiteDatabase database&lt;/span&gt;=&lt;span&gt;getWritableDatabase();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; database.query(&quot;IMOOC_COST&quot;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&quot;COST_DATE &quot;+&quot; ASC&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteAllData(){
        SQLiteDatabase database&lt;/span&gt;=&lt;span&gt;getWritableDatabase();
        database.delete(&lt;/span&gt;&quot;IMOOC_COST&quot;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onUpgrade(SQLiteDatabase db, &lt;span&gt;int&lt;/span&gt; oldVersion, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newVersion) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这里新建了一个“imooc_daily”的数据库和“imooc_cost”表，并对他们以及数据信息（cost_title,cost_date,cost_money）进行了常量定义，以便其他程序的使用，并写了简单的增加、删除和查询数据的功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天开发就到这里，明天继续开发实现“添加页面的显示与更新”以及“图表的实现”，最后会发布到github里。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Feb 2020 15:47:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>记账本开发流程： 对于一个记账本的初步开发而言，我实现的功能有： ①实现一个记账本的页面 ②可以添加数据并更新到页面中 ③可以将数据信息以图表的形式展现 （一）首先，制作一个记账本的页面。 ①在系统自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/12258104.html</dc:identifier>
</item>
<item>
<title>JVM第一弹 - 趣学程序</title>
<link>http://www.cnblogs.com/upuptop/p/12257968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upuptop/p/12257968.html</guid>
<description>&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;JVM是可运行java代码的假想计算机，包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收、堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。&lt;/p&gt;
&lt;h2 id=&quot;运行过程&quot;&gt;运行过程&lt;/h2&gt;
&lt;p&gt;我们都知道Java代码源文件，通过编译器能够产生相应的.Class字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码。&lt;/p&gt;
&lt;p&gt;① Java源文件 ——&amp;gt; 编译器 ——&amp;gt; 字节码文件&lt;br/&gt;② 字节码文件 ——&amp;gt; JVM ——&amp;gt; 机器码&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每种平台的解释器是不同的，但是虚拟机是相同的，这也就是java为什么能够跨平台的原因了。当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序 启动就会存在多个虚拟机实例。&lt;br/&gt;程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;类加载器&quot;&gt;类加载器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580741939468_f0cbfe12-5fae-4a9b-abcc-1895fe7a9a15.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;什么是类的加载？&lt;br/&gt;类的加载是指将类的字节码文件数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。&lt;br/&gt;类的加载的最终产品是位于堆区内中的Class对象，Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类加载器包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动类加载器（BootStrap）&lt;br/&gt;——主要有C++进行实现的。用来加载jdk安装目录下的：jre/lib下的可执行jar包。&lt;br/&gt;也可以通过设置 -XbootClasspath来动态指定jar包位置。在java代码中无法获取到该对象。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;
String str = new String(&quot;HelloWorld&quot;);
System.out.println(str.getClass().getClassLoader());

//控制台打印null&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;扩展类加载器（ExtClassLoader）&lt;/p&gt;
&lt;p&gt;——是java代码实现的，用来加载java安装目录下 jre/lib/ext 目录中的可执行jar包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;应用程序类加载器（AppClassLoader）&lt;/p&gt;
&lt;p&gt;——是java代码实现的，用来加载用户编写的代码。我们新建一个类，获取其类加载器就是AppClassLoader&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class MyClassLoaderTest {

    public static void main(String[] args) {
        String str = new String(&quot;HelloWorld&quot;);
        // 打印null
        System.out.println(str.getClass().getClassLoader());


        // 打印sun.misc.Launcher$AppClassLoader@18b4aac2
        System.out.println(MyClassLoaderTest.class.getClassLoader());
        // 打印sun.misc.Launcher$ExtClassLoader@4554617c
        System.out.println(MyClassLoaderTest.class.getClassLoader().getParent());
        // 打印null
        System.out.println(MyClassLoaderTest.class.getClassLoader().getParent().getParent());

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述代码可见: &lt;strong&gt;AppClassLoader extend ExtClassLoader extend BootstrapClassLoader&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户自定义类加载器&lt;br/&gt;—— 用户编写类继承自 java.lang.ClassLoader&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了防止用户自定义类与jdk自带的类冲突，jdk内有双亲委派机制和沙箱机制。&lt;/p&gt;
&lt;h3 id=&quot;双亲委派机制&quot;&gt;双亲委派机制&lt;/h3&gt;
&lt;p&gt;上述过程中，我们认识到了类加载器之间的继承关系。当java在加载类的时候，由&lt;code&gt;AppClassLoader&lt;/code&gt;委派其父类&lt;code&gt;ExtClassLoader&lt;/code&gt;进行加载，&lt;code&gt;ExtClassLoader&lt;/code&gt;会再次委派其父类&lt;code&gt;BootStrapClassLoader&lt;/code&gt;进行加载，&lt;br/&gt;如果&lt;code&gt;BootStrapClassLoader&lt;/code&gt;找到该类那么加载该类返回该类的Class对象，但是，如果此时&lt;code&gt;BootStrapClassLoader&lt;/code&gt;没有找到该类，&lt;br/&gt;那么就需要&lt;code&gt;ExtClassLoader&lt;/code&gt;自身进行加载，如果&lt;code&gt;ExtClassLoader&lt;/code&gt;找到该类那么加载该类返回该类的Class对象，&lt;br/&gt;但是，如果&lt;code&gt;ExtClassLoader&lt;/code&gt;也没有找到该类，那么就要由&lt;code&gt;AppClassLoader&lt;/code&gt;进行加载。&lt;br/&gt;如果最后&lt;code&gt;AppClassLoader&lt;/code&gt;也没有找到该类，那么就会抛出 &lt;code&gt;ClassNotFoundException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;类加载器没有向下寻找，没有getChild只有getParent&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你自己定义了一个与jdk自带类名包名一致的类，那么java也不会去加载该类。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;jvm结构&quot;&gt;JVM结构&lt;/h2&gt;
&lt;p&gt;JVM内存区域主要分为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程私有区域&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法区&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;线程共享区域&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Java堆&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;直接内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580741966795_43e38112-8fd9-49bf-81c9-706964c52d51.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁。&lt;/li&gt;
&lt;li&gt;线程共享区域随着虚拟机的启动/关闭 而 创建/销毁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行时线程私有的内存区域。&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方法区&lt;br/&gt;主要存放静态变量，常量，Class类模板(接口定义，构造函数)，运行时常量池。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。又被称作为运行时数据区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;程序计数器（Program Counter Register），是一块比较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。每个线程都有一个私有的，可以理解为它是一个指针，指向方法字节码地址，用来标记下一个要执行的方法字节码地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同，线程结束栈内存也就释放了，对于栈来说不存在来及回收的问题。主要保存八大基本数据类型的变量、对象的引用变量以及实例方法。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;本地方法栈（Native Method Stacks）,与c/c++交互的一块区域，本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;垃圾回收器&quot;&gt;垃圾回收器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。&lt;/li&gt;
&lt;li&gt;ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。&lt;/li&gt;
&lt;li&gt;Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。&lt;/li&gt;
&lt;li&gt;Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法&lt;/li&gt;
&lt;li&gt;CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。&lt;/li&gt;
&lt;li&gt;G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;调优命令&quot;&gt;调优命令&lt;/h2&gt;
&lt;p&gt;Sun JDK监控和故障处理命令有 &lt;code&gt;jps&lt;/code&gt;、&lt;code&gt;jstat&lt;/code&gt;、&lt;code&gt;jmap&lt;/code&gt;、&lt;code&gt;jhat&lt;/code&gt;、&lt;code&gt;jstack&lt;/code&gt;、&lt;code&gt;jinfo&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。&lt;/li&gt;
&lt;li&gt;jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。&lt;/li&gt;
&lt;li&gt;jmap，JVM Memory Map命令用于生成heap dump文件&lt;/li&gt;
&lt;li&gt;jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看&lt;/li&gt;
&lt;li&gt;jstack，用于生成java虚拟机当前时刻的线程快照。&lt;/li&gt;
&lt;li&gt;jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;调优工具&quot;&gt;调优工具&lt;/h2&gt;
&lt;p&gt;常用调优工具分为两类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jdk自带监控工具：jconsole和jvisualvm&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控&lt;/li&gt;
&lt;li&gt;jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;第三方有：MAT(Memory Analyzer Tool)、GChisto。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗&lt;/li&gt;
&lt;li&gt;GChisto，一款专业分析gc日志的工具&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;你知道哪些jvm性能调优&quot;&gt;你知道哪些JVM性能调优&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设定堆内存大小&lt;br/&gt;&lt;code&gt;-Xmx&lt;/code&gt;：堆内存最大限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;设定新生代大小。&lt;br/&gt;新生代不宜太小，否则会有大量对象涌入老年代&lt;br/&gt;&lt;code&gt;-XX:NewSize&lt;/code&gt;：新生代大小&lt;br/&gt;&lt;code&gt;-XX:NewRatio&lt;/code&gt; 新生代和老生代占比&lt;br/&gt;&lt;code&gt;-XX:SurvivorRatio&lt;/code&gt;：伊甸园空间和幸存者空间的占比&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设定垃圾回收器&lt;br/&gt;年轻代用 &lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;&lt;br/&gt;年老代用&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么时候出现栈溢出&quot;&gt;什么时候出现栈溢出&lt;/h2&gt;
&lt;p&gt;递归操作，程序没有出口会一直进行压栈操作&lt;/p&gt;
&lt;h2 id=&quot;为什么会出现栈溢出&quot;&gt;为什么会出现栈溢出&lt;/h2&gt;
&lt;p&gt;栈的深度不够了&lt;/p&gt;
&lt;h2 id=&quot;堆内存&quot;&gt;堆内存&lt;/h2&gt;
&lt;p&gt;逻辑上分为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生区&lt;/li&gt;
&lt;li&gt;养老区&lt;/li&gt;
&lt;li&gt;永久区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;物理上分为&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;新生区 、 养老区、 永久区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又将新生区分为了三个区&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;伊甸园区(80%)&lt;/li&gt;
&lt;li&gt;幸存者from区(10%)&lt;/li&gt;
&lt;li&gt;幸存者to区(10%)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;新new的对象都放在伊甸园区，存活率2%，其他对象都被垃圾回收器回收&lt;br/&gt;没有被垃圾回收幸存下来的对象将会保存到幸存者区&lt;br/&gt;当伊甸园区内存不足时，会进行轻量级（minor GC）垃圾回收，将幸存者from区和伊甸园区的还在用的对象移动到幸存者to区，&lt;br/&gt;然后清空幸存者from区和伊甸园区，幸存者from区清空之后会交换from区和to区，保证to区始终是空的。&lt;strong&gt;注意&lt;/strong&gt;from区向to区移动之前会判断对象的年龄，&lt;br/&gt;如果大于15，直接移动到养老区。年龄计数的原理:垃圾回收器回收一次，幸存活一次加一岁。&lt;br/&gt;如果养老区的内存也不够用了，就会触动重量级GC（full GC）将养老区和新生区全量级回收垃圾对象。如果FullGC之后养老区的内存还是不够用，那么会引发OOM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果程序一开始就new了一个比伊甸园区大的对象，伊甸园区没有足够的空间存放应该如何存放呢？此时会将对象存放到养老区，如果养老区也不够存储，那么会引发OOM。&lt;/p&gt;
&lt;h3 id=&quot;对象分配规则&quot;&gt;对象分配规则&lt;/h3&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。&lt;/p&gt;
&lt;p&gt;大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。&lt;/p&gt;
&lt;p&gt;长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。&lt;/p&gt;
&lt;p&gt;动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。&lt;br/&gt;空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;产生oom的原因&quot;&gt;产生OOM的原因？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;java设置的堆内存不够，可以通过设置 -Xms -Xmx 来调整堆内存的大小&lt;/li&gt;
&lt;li&gt;java内存中创建了大量的大对象，并且长时间不能被垃圾回收器回收&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java8与元数据&quot;&gt;java8与元数据&lt;/h2&gt;
&lt;p&gt;在java8中，永久代已经移除了，被“元数据”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代的最大区别在于：&lt;br/&gt;&lt;strong&gt;元空间并不在虚拟机中，而是使用本地内存。&lt;/strong&gt;因此，默认情况下，元空间的大小仅受本地内存限制。&lt;br/&gt;类的源数据放入本定内存中，字符串和类的静态变量放到java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。&lt;/p&gt;
&lt;h2 id=&quot;垃圾回收与算法&quot;&gt;垃圾回收与算法&lt;/h2&gt;
&lt;h3 id=&quot;如果确定垃圾&quot;&gt;如果确定垃圾&lt;/h3&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;引用计数法&lt;br/&gt;在java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，一个简单的方法就是通过引用计数来判断一个对象是否可以回收。简单来说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可达性分析&lt;br/&gt;为了解决引用计数法的循环引用问题，java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索，如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 不可达并不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍是可回收对象，则将面临回收。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标记清楚算法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最基础的垃圾回收算法，分为两个阶段：&lt;strong&gt;标记&lt;/strong&gt;和&lt;strong&gt;清楚&lt;/strong&gt;。标记阶段是标记出来所有要回收的对象，清楚阶段回收被标记的对象所占的空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580741992155_24c51b44-301b-46fc-98d4-7e8b0bfce471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该算法的缺点：&lt;br/&gt;内存碎片化严重，垃圾清理完成后，造成很多内存空间不连续。后续可能发生大对象不能找到可利用的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MajorGC使用该算法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;复制算法&lt;br/&gt;为了解决标记清楚算法内存碎片化的缺陷而提出的算法。按照内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清理掉。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580742003504_9ce2edf6-c3ba-482b-b477-593df4e54796.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MinorGC使用该算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点：&lt;br/&gt;这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可以用内存被压缩到了原本的一半。且存活对象增多的话，copying算法的效率也大大降低。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标记整理算法&lt;br/&gt;结合以上两个算法，为了避免缺陷而提出。标记阶段和标记清楚算法相同，&lt;strong&gt;标记后不是清理对象，而是将存活对象移向内存的一端。然后清楚端边界的对象.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580742013838_133e0288-5d89-4a53-839f-d01846d2b195.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分代收集算法&lt;br/&gt;分代收集算法是目前大部分JVM所采用的方法，其核心思想是根据对象村花的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代和新生代。老生代的特点是每次垃圾回收只有少量对象需要被回收，新生代的特点是每次垃圾回收是都有大量垃圾需要被回收，因此可以根据不同区域采用不同的算法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;6.1. 新生代与复制算法&lt;/p&gt;
&lt;p&gt;目前大部分的JVM的GC对于新生代都采取了copying方法，因为新生代中每次垃圾回收都要回收大部分对象，&lt;br/&gt;即要复制的操作比较少，但通常并不是按照1:1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个比较小的Surviror空间（FromSpace，ToSpace),每次使用Eden空间和其中的一块Surivor空间，当进行回收时，将该两块空间中还存活的对象复制到另外一块Survivor空间中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://quxuecx.gitee.io/TypechoBlogImg//img/2020_02_03/1580742027030_81b54a7c-a8cd-4852-a0e8-7ba56dbb14b0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.2 老年代与标记复制算法&lt;br/&gt;而老年代因为每次只回收少量的对象，因此采用Mark-Compact算法。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;JAVA虚拟机提到过的处于方法区的永生带，它用来存储class类，常量、方法描述等。对永生代的回收主要包括废弃常量和无用的类&lt;/li&gt;
&lt;li&gt;对象的内存分配主要在新生代的EdenSpace和SurvivorSpace的FormSpace（Survivor目前存放对象的那一块），少数情况会直接分配到老生代。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当新生代的EdenSpace和FromSpace空间不足时就会发生一次GC，进行GC后，EdenSpace和FromSpace区的存活对象会被移动到ToSpace，然后将EdenSpace和FromSpace进行清理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果ToSpace无法足够存储某个对象，则将这个对象存储到老生代。&lt;/li&gt;
&lt;li&gt;进行GC后，使用的便是EdenSpace和ToSpace了，如此反复循环。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄达到15的对象就会移动到老生代中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;java中的四种引用&quot;&gt;Java中的四种引用&lt;/h2&gt;
&lt;h3 id=&quot;强引用&quot;&gt;强引用&lt;/h3&gt;
&lt;p&gt;在Java中最常见的就是强引用，&lt;strong&gt;把一个对象赋值给一个引用变量，这个引用变量就是一个强引用。&lt;/strong&gt;&lt;br/&gt;当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收。因此强引用是造成Java内存泄漏主要原因之一。&lt;/p&gt;
&lt;h3 id=&quot;软引用&quot;&gt;软引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;软引用需要使用SoftReference类来实现&lt;/strong&gt;，对于只有软引用的对象来说，当系统内存足够时他不会被回收，当系统内存足够用时，它不会被回收，当系统内存不足时它会被回收。软引用通常用在对内存敏感的程序中。&lt;/p&gt;
&lt;h3 id=&quot;弱引用&quot;&gt;弱引用&lt;/h3&gt;
&lt;p&gt;弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间足够，总会回收该对象占用的内存。&lt;/p&gt;
&lt;h3 id=&quot;虚引用&quot;&gt;虚引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。&lt;/strong&gt;虚引用的主要作用是跟踪对象被垃圾回收的状态。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Feb 2020 15:08:00 +0000</pubDate>
<dc:creator>趣学程序</dc:creator>
<og:description>JVM学习记录，JVM学习总结。JVM面试，JVM知识点总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/upuptop/p/12257968.html</dc:identifier>
</item>
<item>
<title>解决Idea的Generate Sources无法生成QueryDSL问题 - 栖息之鹰</title>
<link>http://www.cnblogs.com/roostinghawk/p/12257785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roostinghawk/p/12257785.html</guid>
<description>&lt;p&gt;今天是2020年第一天在家办公，就出现了跟在公司不一样的现象，deploy项目到maven库时失败，之前一直成功。&lt;/p&gt;
&lt;p&gt;查到原因在于QueryDSL类没有生成，但为何在公司可以而在家里就不行呢？&lt;/p&gt;
&lt;p&gt;鉴于Idea的“Generate Sources And Update Folders”操作一闪即过，信息太少，所以不得先从原理上追溯&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 首先的疑问是：当执行Idea的“Generate Sources And Update Folders”操作时，都发生了什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  参考stackoverflow，解释如下  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
In order to get generated sources automatically imported as source folders configure corresponding plugins &lt;br/&gt;so that they put them into target/generated-sources/, where subdir is any folder name you prefer. &lt;br/&gt;The subdir folder is necessary to distinguish sources from different tools and also to exclude some special generated sources (e.g. groovy stubs).&lt;br/&gt;Please note that even if you manually configure some source folders under target/generated-sources of this folder itself, &lt;br/&gt;IDEA will rewrite them according to your pom.xml.

Any time you want to generate sources you simply execute the corresponding goal, &lt;br/&gt;bound for generation (usually generate-sources, generate-test-sources). After that IDEA will pick up new folders and set them up.&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;As you can see Generate Sources action runs the &lt;code&gt;generate-sources&lt;/code&gt; Maven phase for any plug-ins in your &lt;code&gt;pom.xml&lt;/code&gt; that do generate any sources.&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;“Generate Source”实际上是用所有可以生成source的插件执行Maven的generate-sources步骤&lt;/span&gt;&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要了解的是Maven的phase都有哪些？generate-sources是什么时机执行的？&lt;/p&gt;
&lt;p&gt;答案是generates阶段会在validate和compile阶段之间执行，详细可&lt;a href=&quot;https://www.runoob.com/maven/maven-build-life-cycle.html&quot; target=&quot;_blank&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 那么第二个问题来了，我们的项目中哪些plugin可以执行generate sources&lt;/span&gt;？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     很容易找到下面的配置（此插件&lt;a href=&quot;https://github.com/querydsl/apt-maven-plugin/&quot; target=&quot;_blank&quot;&gt;开源在github上&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;strong&gt;com.mysema.maven&lt;/strong&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;strong&gt;apt-maven-plugin&lt;/strong&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;process&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;target/generated-sources/java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;processor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;processor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.querydsl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;querydsl-apt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.1.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  github的解释很简单：apt-maven-plugin provides Maven integration of the Java 6 APT functionality.&lt;/p&gt;
&lt;p&gt;  这里有必要了解下什么是Java APT？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
APT(Annotation Process Tool)，是一种在代码编译时处理注解，按照一定的规则，生成相应的java文件，多用于对自定义注解的处理，&lt;br/&gt;目前比较流行的Dagger2, ButterKnife, EventBus3都是采用APT技术，对运行时的性能影响很小&lt;br/&gt;&lt;span&gt;&lt;strong&gt;也就是说，APT是用代码生成代码的工具，会在process过程生成java文件，那么为什么我们最终生成的往往只有class文件呢？这是因为很多插件都做了第二步的清理操作。&lt;br/&gt;&lt;/strong&gt;&lt;span&gt;至于Java8之后APT被“&quot;Pluggable Annotation Processing API&quot;.”替换，那就是后话了&lt;/span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  另外，此插件依赖querydsl，所以querydsl也有必要了解下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
QueryDSL仅仅是一个通用的查询框架，专注于通过Java API构建类型安全的SQL查询。借助QueryDSL可以在任何支持的ORM框架或者SQL平台上以一种通用的API方式来构建查询。&lt;br/&gt;目前QueryDSL支持的平台包括JPA,JDO,SQL,Java Collections,RDF,Lucene,Hibernate Search。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;所以说我们项目中所用的QueryDSL是在JPA之上的，是为了补充JPA的复杂查询支持不足而引入的&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 那么如何手动单独执行此APT的process呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    这样考虑的目的其实就是为了得到更多信息，此步骤可以用Idea的此选项右键执行，或者在command中执行“&lt;strong&gt;mvn apt:process&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/337940/202002/337940-20200203223544098-1341164391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  会发现输出log中输出以下警告&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
'build.plugins.plugin.version' for com.mysema.maven:apt-maven-plugin is missing. @ line 46, column 21
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  于是就在pom配置中添加plugin的最新version&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;lt;version&amp;gt;1.1.3&amp;lt;/version&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次generate，生成成功！&lt;/p&gt;

&lt;p&gt;通过解决此问题得到一点感触：&lt;span&gt;每一次出现问题不好解决时，尝试从原理层面做一个快速全面的了解，这样不单会有助于使自己对于技术“知其所以然”，而且会反过来触发解决问题的新思路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/54868822/generate-sources-and-update-folders-for-all-projects&quot;&gt;https://stackoverflow.com/questions/54868822/generate-sources-and-update-folders-for-all-projects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/maven/maven-build-life-cycle.html&quot;&gt;https://www.runoob.com/maven/maven-build-life-cycle.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/querydsl/apt-maven-plugin/&quot;&gt;https://github.com/querydsl/apt-maven-plugin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fengxingzhe001/article/details/78520298&quot;&gt;https://blog.csdn.net/fengxingzhe001/article/details/78520298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fortitude/p/10936386.html&quot;&gt;https://www.cnblogs.com/fortitude/p/10936386.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QueryDSL和JPA的配合&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenglc/p/11230755.html&quot;&gt;https://www.cnblogs.com/chenglc/p/11230755.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24778422&quot;&gt;https://zhuanlan.zhihu.com/p/24778422&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Feb 2020 14:55:00 +0000</pubDate>
<dc:creator>栖息之鹰</dc:creator>
<og:description>今天是2020年第一天在家办公，就出现了跟在公司不一样的现象，deploy项目到maven库时失败，之前一直成功。 查到原因在于QueryDSL类没有生成，但为何在公司可以而在家里就不行呢？ 鉴于Id</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/roostinghawk/p/12257785.html</dc:identifier>
</item>
<item>
<title>在python开发工具PyCharm中搭建QtPy环境（详细） - 漂在远方</title>
<link>http://www.cnblogs.com/cqkangle/p/12257788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqkangle/p/12257788.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;在&lt;/span&gt;python&lt;span&gt;开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中搭建&lt;/span&gt;QtPy&lt;span&gt;环境&lt;/span&gt;（详细）&lt;/p&gt;
&lt;p&gt;       在Python&lt;span&gt;的开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中安装&lt;/span&gt;&lt;span&gt;QtPy5(&lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;span&gt;5)&lt;/span&gt;&lt;span&gt;：打开“&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;Settings&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;Project Interpreter&lt;/span&gt;&lt;span&gt;”，点击窗口中右侧点添加按钮，然后在弹出的窗口添加&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;模块包，单击&lt;/span&gt;&lt;span&gt;Install Package&lt;/span&gt;&lt;span&gt;按钮，如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222519428-457054975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;安装好安装&lt;/span&gt;PyQt5&lt;span&gt;后，需要用同样的方法安装&lt;/span&gt;&lt;span&gt;pyqt5-tools&lt;/span&gt;&lt;span&gt;，安装&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;后没有&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;就是因为没有安装&lt;/span&gt;&lt;span&gt;pyqt5-tools&lt;/span&gt;&lt;span&gt;。安装好&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;后，&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;可执行程序时不在&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;中的根目录的，而是在“&lt;/span&gt;&lt;span&gt;./Python/Lib/site-packages\pyqt5_tools\Qt\bin&lt;/span&gt;&lt;span&gt;”目录中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       安装好PyQt5&lt;span&gt;模块包好后，在开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中配置&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;工具（该配置主要有两个作用，一个是用来在开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中能直接启动&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;，一个是在开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中将&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;.ui&lt;/span&gt;&lt;span&gt;文件转换&lt;/span&gt;&lt;span&gt;.py&lt;/span&gt;&lt;span&gt;文件）：在开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;打开“&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;Settings&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;Tools&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;External Tools&lt;/span&gt;&lt;span&gt;”在右侧单击添加按钮，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222657907-293629363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;配置在&lt;/span&gt;PyCharm&lt;span&gt;中能直接启动&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在弹出的窗口中添加启动&lt;/span&gt;Qt Designer&lt;span&gt;的快捷工具，首先在&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写工具名称为&lt;/span&gt;&lt;span&gt;Qt Designer&lt;/span&gt;&lt;span&gt;，然后在&lt;/span&gt;&lt;span&gt;Program&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;开发工具的安装路径（在安装的时候要主要看安装的路径在哪里），最后在&lt;/span&gt;&lt;span&gt;Working directory&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写&lt;/span&gt;&lt;span&gt;$ProjectFileDir$&lt;/span&gt;&lt;span&gt;，该值代表项目文件目录，单击&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;按钮即可，如下图所示（注意：在&lt;/span&gt;&lt;span&gt;Program&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写自己的&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;开发工具安装路径，记得尾部需要填写&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;），另外，还需要注意的是，安装好&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;后，&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;可执行程序时不在&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;中的根目录的，而是在“&lt;/span&gt;&lt;span&gt;./Python/Lib/site-packages\pyqt5_tools\Qt\bin&lt;/span&gt;&lt;span&gt;”目录中，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222723709-731629451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;PyCharm&lt;span&gt;中将&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;.ui&lt;/span&gt;&lt;span&gt;文件转换&lt;/span&gt;&lt;span&gt;.py&lt;/span&gt;&lt;span&gt;文件：&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;配置好&lt;/span&gt;Qt Designer&lt;span&gt;的快捷工具后，根据同样的方法，添加将&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;生成的&lt;/span&gt;&lt;span&gt;ui&lt;/span&gt;&lt;span&gt;文件转换为&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;文件的快捷工具，在&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写工具名称为&lt;/span&gt;&lt;span&gt;PyUIC&lt;/span&gt;&lt;span&gt;，然后在&lt;/span&gt;&lt;span&gt;Program&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;的安装路径，再在&lt;/span&gt;&lt;span&gt;Arguments&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写将&lt;/span&gt;&lt;span&gt;ui&lt;/span&gt;&lt;span&gt;文件转换为&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;文件的&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;代码（&lt;/span&gt;&lt;span&gt;-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py&lt;/span&gt;&lt;span&gt;），在&lt;/span&gt;&lt;span&gt;Working directory&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写&lt;/span&gt;&lt;span&gt;$FileDir$&lt;/span&gt;&lt;span&gt;，该值为文件目录，单击&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;按钮即可，如下图所示（注意：在&lt;/span&gt;&lt;span&gt;Program&lt;/span&gt;&lt;span&gt;所对应的编辑框中填写自己的&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;安装路径，记得尾部需要填写&lt;/span&gt;&lt;span&gt;python.exe&lt;/span&gt;&lt;span&gt;），如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222752120-140840924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     PyQt5&lt;span&gt;工具有两种启动方法，一种是在&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;开发工具&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;中启动，一种是在&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;的安装目录中找到&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;直接启动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法一：在&lt;/span&gt;PyCharm&lt;span&gt;中启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PyCharm&lt;span&gt;需要启动&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;的项目中点击鼠标右键，“&lt;/span&gt;&lt;span&gt;External Tools&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;Qt Designer&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;刚才在&lt;/span&gt;&lt;span&gt;PyCharm&lt;/span&gt;&lt;span&gt;配置的名字&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;即可，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222850327-1929631649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法二：&lt;/span&gt;PyQt5&lt;span&gt;的安装目录中直接启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PyQt5&lt;span&gt;的安装路径中找到&lt;/span&gt;&lt;span&gt;designer.exe&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;./Python/Lib/site-packages\pyqt5_tools\Qt\bin&lt;/span&gt;&lt;span&gt;），双击打开添加住窗体，然后根据实际项目开发需要添加相关按钮进行程序界面布局即可（即见即可得），如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222926238-1432415239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222937379-1968247286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在&lt;/span&gt;PyQt5&lt;span&gt;的&lt;/span&gt;&lt;span&gt;designer&lt;/span&gt;&lt;span&gt;工具中完成窗体设计后，按快捷键&lt;/span&gt;&lt;span&gt;Ctrl+S&lt;/span&gt;&lt;span&gt;保存窗体设计文件名为&lt;/span&gt;&lt;span&gt;Window.ui&lt;/span&gt;&lt;span&gt;，然后需要将该文件保存在当前项目的目录当中，再在该文件右键菜单中选择“&lt;/span&gt;&lt;span&gt;External Tools&lt;/span&gt;&lt;span&gt;”——“&lt;/span&gt;&lt;span&gt;PyUIC&lt;/span&gt;&lt;span&gt;”命令，将窗体设计的&lt;/span&gt;&lt;span&gt;ui&lt;/span&gt;&lt;span&gt;文件转换为&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;文件，转换后的&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;文件将显示在当前的目录中。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203222956587-1861683906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     打开&lt;/span&gt;py&lt;span&gt;文件后，可以看到自动生成的代码中已经导入了&lt;/span&gt;&lt;span&gt;PyQt5&lt;/span&gt;&lt;span&gt;以及其内部常用的模块。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1605681/202002/1605681-20200203223016458-303724808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 03 Feb 2020 14:32:00 +0000</pubDate>
<dc:creator>漂在远方</dc:creator>
<og:description>在python开发工具PyCharm中搭建QtPy环境（详细） 在Python的开发工具PyCharm中安装QtPy5(版本5)：打开“File”——“Settings”——“Project Inte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cqkangle/p/12257788.html</dc:identifier>
</item>
<item>
<title>Java 数据持久化系列之池化技术 - 程序员历小冰</title>
<link>http://www.cnblogs.com/remcarpediem/p/12257559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/remcarpediem/p/12257559.html</guid>
<description>&lt;p&gt;在上一篇文章&lt;a href=&quot;http://remcarpediem.net/article/8c16d4e4/&quot;&gt;《Java 数据持久化系列之JDBC》&lt;/a&gt;中，我们了解到使用 JDBC 创建 Connection 可以执行对应的SQL，但是创建 Connection 会消耗很多资源，所以 Java 持久化框架中往往不直接使用 JDBC，而是在其上建立数据库连接池层。&lt;/p&gt;
&lt;p&gt;今天我们就先来了解一下池化技术的必要性、原理；然后使用 Apache-common-Pool2实现一个简单的数据库连接池；接着通过实验，对比简单连接池、HikariCP、Druid 等数据库连接池的性能数据，分析实现高性能数据库连接池的关键；最后分析 Pool2 的具体源代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214647584-1906989150.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象不是你想要想要就能要&quot;&gt;对象不是你想要，想要就能要&lt;/h3&gt;
&lt;p&gt;你我单身狗们经常调侃可以随便 New 出一个对象，用完就丢。但是有些对象创建的代价比较大，比如线程、tcp连接、数据库连接等对象。对于这些创建耗时较长，或者资源占用较大(占据操作系统资源，比如说线程，网络连接等)的对象，往往会引入池化来管理，减少频繁创建对象的次数，避免创建对象时的耗时，提高性能。&lt;/p&gt;
&lt;p&gt;我们就以数据库连接 Connection 对象为例，详细说明一下创建该对象花费的时间和资源。下面是MySQL Driver 创建 Connection 对象的方法，在调用 connect 方法创建 Connection 时，会与 MySQL 进行网络通讯，建立 TCP 连接，这是极其消耗时间的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;connection = driver.connect(URL, props);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-apache-common-pool2实现简易数据库连接池&quot;&gt;使用 Apache-Common-Pool2实现简易数据库连接池&lt;/h3&gt;
&lt;p&gt;下面，我们以 Apache-Common-Pool2为例来看一下池化技术相关的抽象结构。&lt;/p&gt;
&lt;p&gt;首先了解一下Pool2中三元一体的 ObjectPool，PooledObject 和 PooledObjectFactory，对他们的解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ObjectPool 就是对象池，提供了 &lt;code&gt;borrowObject&lt;/code&gt; 和 &lt;code&gt;returnObject&lt;/code&gt; 等一系列函数。&lt;/li&gt;
&lt;li&gt;PooledObject 是池化对象的封装类，负责记录额外信息，比如说对象状态，对象创建时间，对象空闲时间，对象上次使用时间等。&lt;/li&gt;
&lt;li&gt;PooledObjectFactory 是负责管理池化对象生命周期的工厂类，提供 &lt;code&gt;makeObject&lt;/code&gt;，&lt;code&gt;destroyObject&lt;/code&gt;，&lt;code&gt;activateObject&lt;/code&gt; 和 &lt;code&gt;validateObject&lt;/code&gt; 等一系列函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述三者都有其基础的实现类，分别是 GenericObjectPool，DefaultPooledObject 和 BasePooledObjectFactory。上一节实验中的 SimpleDatasource 就是使用上述类实现的。&lt;/p&gt;
&lt;p&gt;首先，你要实现一个继承 BasePooledObjectFactory 的工厂类，提供管理池化对象生命周期的具体方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;makeObject：创建池化对象实例，并且使用 PooledObject 将其封装。&lt;/li&gt;
&lt;li&gt;validateObject：验证对象实例是否安全或者可用，比如说 Connection 是否还保存连接状态。&lt;/li&gt;
&lt;li&gt;activateObject：将池返回的对象实例进行重新初始化，比如说设置 Connection是否默认AutoCommit等。&lt;/li&gt;
&lt;li&gt;passivateObject：将返回给池的对象实例进行反初始化，比如说 Connection 中未提交的事务进行 Rollback等。&lt;/li&gt;
&lt;li&gt;destroyObject：销毁不再被池需要的对象实例，比如说 Connection不再被需要时，调用其 close 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的实现源码如下所示，每个方法都有详细的注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleJdbcConnectionFactory extends BasePooledObjectFactory&amp;lt;Connection&amp;gt; {
    ....
    @Override
    public Connection create() throws Exception {
        // 用于创建池化对象
        Properties props = new Properties();
        props.put(&quot;user&quot;, USER_NAME);
        props.put(&quot;password&quot;, PASSWORD);
        Connection connection = driver.connect(URL, props);
        return connection;
    }

    @Override
    public PooledObject&amp;lt;Connection&amp;gt; wrap(Connection connection) {
        // 将池化对象进行封装，返回DefaultPooledObject，这里也可以返回自己实现的PooledObject
        return new DefaultPooledObject&amp;lt;&amp;gt;(connection);
    }

    @Override
    public PooledObject&amp;lt;Connection&amp;gt; makeObject() throws Exception {
        return super.makeObject();
    }

    @Override
    public void destroyObject(PooledObject&amp;lt;Connection&amp;gt; p) throws Exception {
        p.getObject().close();
    }

    @Override
    public boolean validateObject(PooledObject&amp;lt;Connection&amp;gt; p) {
        // 使用 SELECT 1 或者其他sql语句验证Connection是否可用，ConnUtils代码详见Github中的项目
        try {
            ConnUtils.validateConnection(p.getObject(), this.validationQuery);
        } catch (Exception e) {
            return false;
        }
        return true;
    }


    @Override
    public void activateObject(PooledObject&amp;lt;Connection&amp;gt; p) throws Exception {
        Connection conn = p.getObject();
        // 对象被借出，需要进行初始化，将其 autoCommit进行设置
        if (conn.getAutoCommit() != defaultAutoCommit) {
            conn.setAutoCommit(defaultAutoCommit);
        }
    }

    @Override
    public void passivateObject(PooledObject&amp;lt;Connection&amp;gt; p) throws Exception {
        // 对象被归还，进行回收或者处理，比如将未提交的事务进行回滚
        Connection conn = p.getObject();
        if(!conn.getAutoCommit() &amp;amp;&amp;amp; !conn.isReadOnly()) {
            conn.rollback();
        }
        conn.clearWarnings();
        if(!conn.getAutoCommit()) {
            conn.setAutoCommit(true);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，你就可以使用 BasePool 来从池中获取对象，使用后归还给池。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Connection connection = pool.borrowObject(); // 从池中获取连接对象实例
Statement statement = connection.createStatement();
statement.executeQuery(&quot;SELECT * FROM activity&quot;);
statement.close();
pool.returnObject(connection); // 使用后归还连接对象实例到池中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们就使用 Apache Common Pool2 实现了一个简易的数据库连接池。下面，我们先来使用 benchmark 验证一下这个简易数据库连接池的性能，再分析 Pool2 的具体源码实现，&lt;/p&gt;
&lt;h3 id=&quot;性能试验&quot;&gt;性能试验&lt;/h3&gt;
&lt;p&gt;至此，我们分析完了 Pool2的相关原理和实现，下面就修改 Hikari-benchmark 对我们编写的建议数据库连接池进行性能测试。修改后的 benchmark 的地址为 https://github.com/ztelur/HikariCP-benchmark。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214713862-1191678609.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 hikari 和 Druid 两个数据库连接池的性能是最优的，而我们的简易数据库连接池性能排在末尾。在后续系列文章中会对比我们的简易数据库分析 Hikari 和 Druid 高性能的原因。下面我们先来看一下简易数据库连接池的具体实现。&lt;/p&gt;
&lt;h3 id=&quot;apache-common-pool2-源码分析&quot;&gt;Apache Common Pool2 源码分析&lt;/h3&gt;
&lt;p&gt;我们来简要分析 Pool2 的源码( 2.8.0版本 )实现，了解池化技术的基本原理，为后续了解和分析 HikariCP 和 Druid 打下基础，三者在设计思路具有互通之处。&lt;/p&gt;
&lt;p&gt;通过前边的实例，我们知道通过 &lt;code&gt;borrowObject&lt;/code&gt; 和 &lt;code&gt;returnObject&lt;/code&gt; 从对象池中接取或者归还对象，进行这些操作时，封装实例 PooledObject 的状态也会发生变化，下面就沿着 PooledObject 状态机的状态变化路线来讲解相关的代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214726218-844347381.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 PooledObject 的状态机示意图，蓝色元素代表状态，红色代表 ObjectPool的相关方法。PooledObject 的状态有 IDLE、ALLOCATED、RETURNING、ABANDONED、INVALID、EVICTION 和 EVICTION_RETURN_TO_HEAD(所有状态定义在 PooledObjectState 类中，有些状态暂时未被使用，这里不进行说明)。&lt;/p&gt;
&lt;p&gt;主要涉及三部分的状态变化，分别是 1、2、3的借出归还状态变化，4，5的标记抛弃删除状态变化以及6,7,8的检测驱除状态变化。后续会分小节详细介绍这三部分的状态变化。&lt;/p&gt;
&lt;p&gt;在这些状态变化过程中，不仅涉及 ObjectPool 的方法，也会调用 PooledObjectFactory 的方法进行相关操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214738298-1160929491.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图表明了在 PooledObject 状态变化过程中涉及的 PooledObjectFactory 的方法。按照前文对 PooledObjectFactory 方法的描述，可以很容易的对应起来。比如说，在编号 1 的对象被借出过程中，先调用 invalidateObject 判断对象可用性，然后调用 activeObject 将对象默认配置初始化。&lt;/p&gt;
&lt;h4 id=&quot;借出归还状态变化&quot;&gt;借出归还状态变化&lt;/h4&gt;
&lt;p&gt;我们从 GenericObjectPool 的 borrowObject 方法开始了解。该方法可以传入最大等待时间为参数，如果不传则使用配置的默认最大等待时间，borrowObject 的源码如下所示(为了可读性，对代码进行删减)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
    // 1 根据 abandonedConfig 和其他检测判断是否要调用 removeAbandoned 方法进行标记删除操作
    ....
    PooledObject&amp;lt;T&amp;gt; p = null;
    // 当暂时无法获取对象时是否阻塞
    final boolean blockWhenExhausted = getBlockWhenExhausted();
    while (p == null) {
        create = false;
        // 2 先从 idleObjects 队列中获取, pollFisrt 是非阻塞的
        p = idleObjects.pollFirst();
        // 3 没有则调用 create 方法创建一个新的对象
        if (p == null) {
            p = create();
        }
        // 4 blockWhenExhausted 为true，则根据 borrowMaxWaitMillis 进行阻塞操作
        if (blockWhenExhausted) {
            if (p == null) {
                if (borrowMaxWaitMillis &amp;lt; 0) {
                    p = idleObjects.takeFirst(); // 阻塞到获取对象为止
                } else {
                    p = idleObjects.pollFirst(borrowMaxWaitMillis,
                            TimeUnit.MILLISECONDS); // 阻塞到最大等待时间或者获取到对象
                }
            }
        }
        // 5 调用 allocate 进行状态变化
        if (!p.allocate()) {
            p = null;
        }
        if (p != null) {
            // 6 调用 activateObject 进行对象默认初始化，如果出现问题则调用 destroy 
            factory.activateObject(p);
            // 7 如果配置了 TestOnBorrow，则调用 validateObject 进行可用性校验，如果不通过则调用 destroy
            if (getTestOnBorrow()) {
                validate = factory.validateObject(p);
            }
        }
    }
    return p.getObject();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;borrowObject 方法主要做了五步操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步是根据配置判断是否要调用 removeAbandoned 方法进行标记删除操作，这个后续小节再细讲。&lt;/li&gt;
&lt;li&gt;第二步是尝试获取或创建对象，由源码中2，3，4 步骤组成。&lt;/li&gt;
&lt;li&gt;第三步是调用 allocate 进行状态变更，转换为 ALLOCATED 状态，如源码中的 5 步骤。&lt;/li&gt;
&lt;li&gt;第四步是调用 factory 的 activateObject 进行对象的初始化，如果出错则调用 destroy 方法销毁对象，如源码中的 6 步骤。&lt;/li&gt;
&lt;li&gt;第五步是根据 TestOnBorrow 配置调用 factory 的 validateObject 进行对象可用性分析，如果不可用，则调用 destroy 方法销毁对象，如源码中的 7 步骤。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214752898-49267714.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对第二步进行一下细致的分析。idleObjects 是存储着所有 IDLE状态 (也有可能是 EVICTION 状态) PooledObject 的 LinkedBlockingDeque 对象。第二步中先调用其 pollFirst 方法从队列头获取 PooledObject，如果未获取到则调用 create 方法创建一个新的。&lt;/p&gt;
&lt;p&gt;create 也可能未创建成功，则当 blockWhenExhausted 为 true 时，未获取到对象需要一直阻塞，所以根据最大等待时间 borrowMaxWaitMillis 来调用 takeFirst 或者 pollFirst(time) 方法进行阻塞式获取；当 blockWhenExhausted 为 false 时，则直接抛出异常返回。&lt;/p&gt;
&lt;p&gt;create 方法会判断当前状况下是否应该创建新的对象，主要是要防止创建的对象数量超过最大池对象数量。如果可以创建新对象，则调用 PooledObjectFactory 的 makeObject 方法进行新对象创建，然后根据 testOnCreate 配置来判断是否调用 validateObject 方法进行校验，源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private PooledObject&amp;lt;T&amp;gt; create() throws Exception {
    int localMaxTotal = getMaxTotal(); // 获取池对象最大数量
    final long localStartTimeMillis = System.currentTimeMillis();
    final long localMaxWaitTimeMillis = Math.max(getMaxWaitMillis(), 0); // 获取最大等待时间
    Boolean create = null;
    // 一直等待到 create 被赋值，true代表要创建新对象，false代表不能创建
    while (create == null) {
        synchronized (makeObjectCountLock) {
            final long newCreateCount = createCount.incrementAndGet();
            if (newCreateCount &amp;gt; localMaxTotal) {
                // pool已经满或者正在创建的足够达到最大数量的对象。
                createCount.decrementAndGet();
                if (makeObjectCount == 0) {
                    // 目前没有其他的 makeObject 方法被调用，直接返回false
                    create = Boolean.FALSE;
                } else {
                    // 目前有其他的 makeObject 方法被调用，但是可能失败，所以等待一段时间再试试
                    makeObjectCountLock.wait(localMaxWaitTimeMillis);
                }
            } else {
                // pool未满 可以创建对象。
                makeObjectCount++;
                create = Boolean.TRUE;
            }
        }

        // 执行超过 maxWaitTimeMillis 则返回false
        if (create == null &amp;amp;&amp;amp;
            (localMaxWaitTimeMillis &amp;gt; 0 &amp;amp;&amp;amp;
                System.currentTimeMillis() - localStartTimeMillis &amp;gt;= localMaxWaitTimeMillis)) {
            create = Boolean.FALSE;
        }
    }
    // 如果 create 为false，返回 NULL
    if (!create.booleanValue()) {
        return null;
    }

    final PooledObject&amp;lt;T&amp;gt; p;
    try {
        // 调用 factory 的 makeObject 进行对象创建，并且按照 testOnCreate 配置调用 validateObject 方法
        p = factory.makeObject();
        if (getTestOnCreate() &amp;amp;&amp;amp; !factory.validateObject(p)) {
            // 这里代码有问题，校验不通过的对象没有进行销毁？
            createCount.decrementAndGet();
            return null;
        }
    } catch (final Throwable e) {
        createCount.decrementAndGet();
        throw e;
    } finally {
        synchronized (makeObjectCountLock) {
            // 减少 makeObjectCount
            makeObjectCount--;
            makeObjectCountLock.notifyAll();
        }
    }
    allObjects.put(new IdentityWrapper&amp;lt;&amp;gt;(p.getObject()), p);
    return p;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 create 方法创建的对象并没有第一时间加入到 idleObjects 队列中，该对象将会在后续使用完毕调用 returnObject 方法时才会加入到队列中。&lt;/p&gt;
&lt;p&gt;接下来，我们看一下 returnObject 方法的实现。该方法主要做了六步操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步是调用 markReturningState 方法将状态变更为 RETURNING。&lt;/li&gt;
&lt;li&gt;第二步是根据 testOnReturn 配置调用 PooledObjectFactory 的 validateObject 方法进行可用性校验。如果未通过校验，则调用 destroy 消耗该对象，然后调用 ensureIdle 确保池中有 IDLE 状态对象可用，如果没有会调用 create 方法创建新的对象。&lt;/li&gt;
&lt;li&gt;第三步是调用 PooledObjectFactory 的 passivateObject 方法进行反初始化操作。&lt;/li&gt;
&lt;li&gt;第四步是调用 deallocate 将状态变更为 IDLE。&lt;/li&gt;
&lt;li&gt;第五步是检测是否超过了最大 IDLE 对象数量，如果超过了则销毁当前对象。&lt;/li&gt;
&lt;li&gt;第六步是根据 LIFO (last in, first out) 配置将对象放置到队列的首部或者尾部。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public void returnObject(final T obj) {
    final PooledObject&amp;lt;T&amp;gt; p = allObjects.get(new IdentityWrapper&amp;lt;&amp;gt;(obj));
    // 1 将状态转换为 RETURNING
    markReturningState(p);

    final long activeTime = p.getActiveTimeMillis();
    // 2 根据配置，对实例进行可用性校验
    if (getTestOnReturn() &amp;amp;&amp;amp; !factory.validateObject(p)) {
        destroy(p);
        // 因为删除了一个对象，需要确保池内还有对象，如果没有改方法会创建新对象
        ensureIdle(1, false); 
        updateStatsReturn(activeTime);
        return;
    }
    // 3 调用 passivateObject 将对象反初始化。
    try {
        factory.passivateObject(p);
    } catch (final Exception e1) {
         .... // 和上边 validateObject 校验失败相同操作。
    }
    // 4 将状态变更为 IDLE
    if (!p.deallocate()) {
        throw new IllegalStateException(
                &quot;Object has already been returned to this pool or is invalid&quot;);
    }

    final int maxIdleSave = getMaxIdle();
    // 5 如果超过最大 IDLE 数量，则进行销毁
    if (isClosed() || maxIdleSave &amp;gt; -1 &amp;amp;&amp;amp; maxIdleSave &amp;lt;= idleObjects.size()) {
        .... // 同上边 validateObject 校验失败相同操作。
    } else {
        // 6 根据 LIFO 配置，将归还的对象放置在队列首部或者尾部。 这边源码拼错了。
        if (getLifo()) {
            idleObjects.addFirst(p);
        } else {
            idleObjects.addLast(p);
        }
    }
    updateStatsReturn(activeTime);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图介绍了第六步两种入队列的场景，LIFO 为 true 时防止在队列头部；LIFO 为 false 时，防止在队列尾部。要根据不同的池化对象选择不同的场景。但是放置在尾部可以避免并发热点，因为借对象和还对象都需要操作队列头，需要进行并发控制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214811067-602301618.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;标记删除状态变化&quot;&gt;标记删除状态变化&lt;/h4&gt;
&lt;p&gt;标记删除状态变化操作主要通过 removeAbandoned 实现，它主要是检查已经借出的对象是否需要删除，防止对象被借出长时间未使用或者归还所导致的池对象被耗尽的情况。&lt;/p&gt;
&lt;p&gt;removeAbandoned 根据 AbandonedConfig 可能会在 borrowObject 或者 检测驱除对象的 evict 方法执行时被调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
    
    final AbandonedConfig ac = this.abandonedConfig;
    // 当配置了 removeAbandonedOnBorrow 并且 当前 idle 对象数量少于2，活跃对象数量只比最大对象数量少3.
    if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;
            (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;
            (getNumActive() &amp;gt; getMaxTotal() - 3) ) {
        removeAbandoned(ac);
    }
    ....
}

public void evict() throws Exception {
    ....
    final AbandonedConfig ac = this.abandonedConfig;
        // 设置了 removeAbandonedOnMaintenance
        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnMaintenance()) {
            removeAbandoned(ac);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;removeAbandoned 使用典型的标记删除策略：标记阶段是先对所有的对象进行遍历，如果该对象是 ALLOCATED 并且上次使用时间已经超过超时时间，则将其状态变更为 ABANDONED 状态，并加入到删除队列中；删除阶段则遍历删除队列，依次调用 invalidateObject 方法删除并销毁对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void removeAbandoned(final AbandonedConfig ac) {
    // 收集需要 abandoned 的对象
    final long now = System.currentTimeMillis();
    // 1 根据配置的时间计算超时时间
    final long timeout =
            now - (ac.getRemoveAbandonedTimeout() * 1000L);
    final ArrayList&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; remove = new ArrayList&amp;lt;&amp;gt;();
    final Iterator&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; it = allObjects.values().iterator();
    while (it.hasNext()) {
        final PooledObject&amp;lt;T&amp;gt; pooledObject = it.next();
        // 2 遍历所有的对象，如果它是已经分配状态，并且该对象的最近一次使用时间小于超时时间
        synchronized (pooledObject) {
            if (pooledObject.getState() == PooledObjectState.ALLOCATED &amp;amp;&amp;amp;
                    pooledObject.getLastUsedTime() &amp;lt;= timeout) {
                // 3 将对象状态更改为 ABANDONED,并加入到删除队列
                pooledObject.markAbandoned();
                remove.add(pooledObject);
            }
        }
    }

    // 4 遍历删除队列
    final Iterator&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; itr = remove.iterator();
    while (itr.hasNext()) {
        final PooledObject&amp;lt;T&amp;gt; pooledObject = itr.next();
        // 5 调用 invalidateObject 方法删除对象
        invalidateObject(pooledObject.getObject());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;invalidateObject 方法直接调用了 destroy 方法，destroy 方法在上边的源码分析中也反复出现，它主要进行了四步操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 将对象状态变更为 INVALID。&lt;/li&gt;
&lt;li&gt;2 将对象从队列和集合中删除。&lt;/li&gt;
&lt;li&gt;3 调用 PooledObjectFactory 的 destroyObject 方法销毁对象。&lt;/li&gt;
&lt;li&gt;4 更新统计数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private void destroy(final PooledObject&amp;lt;T&amp;gt; toDestroy) throws Exception {
    // 1 将状态变更为 INVALID
    toDestroy.invalidate();
    // 2 从队列和池中删除
    idleObjects.remove(toDestroy);
    allObjects.remove(new IdentityWrapper&amp;lt;&amp;gt;(toDestroy.getObject()));
    // 3 调用 destroyObject 回收对象
    try {
        factory.destroyObject(toDestroy);
    } finally {
        // 4 更新统计数据
        destroyedCount.incrementAndGet();
        createCount.decrementAndGet();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;检测驱除状态变化&quot;&gt;检测驱除状态变化&lt;/h4&gt;
&lt;p&gt;检测驱除状态变化主要由 evict 方法操作，在后台线程中独立完成，主要检测池中的 IDLE 状态的空闲对象是否需要驱除，超时时间通过 EvictionConfig 进行配置。&lt;/p&gt;
&lt;p&gt;驱逐者 Evictor,在 BaseGenericObjectPool 中定义，本质是由 java.util.TimerTask 定义的定时任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final void startEvictor(final long delay) {
    synchronized (evictionLock) {
        if (delay &amp;gt; 0) {
            // 定时执行 evictor 线程
            evictor = new Evictor();
            EvictionTimer.schedule(evictor, delay, delay);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Evictor 线程中会调用 evict 方法，该方法主要是遍历所有的 IDLE 对象，然后对每个对象执行检测驱除操作，具体源码如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 startEvictionTest 方法将状态更改为 EVICTED。&lt;/li&gt;
&lt;li&gt;根据驱除策略和对象超时时间判断是否要驱除。&lt;/li&gt;
&lt;li&gt;如果需要被驱除则调用 destroy 方法销毁对象。&lt;/li&gt;
&lt;li&gt;如果设置了 testWhileIdle 则调用 PooledObject 的 validateObject 进行可用性校验。&lt;/li&gt;
&lt;li&gt;调用 endEvictionTest 将状态更改为 IDLE。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public void evict() throws Exception {
    if (idleObjects.size() &amp;gt; 0) {
        ....
        final EvictionPolicy&amp;lt;T&amp;gt; evictionPolicy = getEvictionPolicy();
        synchronized (evictionLock) {
            for (int i = 0, m = getNumTests(); i &amp;lt; m; i++) {
                // 1 遍历所有 idle 的对象
                try {
                    underTest = evictionIterator.next();
                } catch (final NoSuchElementException nsee) {
                }
                // 2 调用 startEvictionTest 将状态变更为 EVICTED
                if (!underTest.startEvictionTest()) {
                    continue;
                }
                // 3 根据驱除策略判断是否要驱除
                boolean evict = evictionPolicy.evict(evictionConfig, underTest,
                        idleObjects.size());

                if (evict) {
                    // 4 进行驱除
                    destroy(underTest);
                    destroyedByEvictorCount.incrementAndGet();
                } else {
                    // 5 如果需要检测，则进行可用性检测
                    if (testWhileIdle) {
                        factory.activateObject(underTest);
                        factory.validateObject(underTest));
                        factory.passivateObject(underTest);
                        }
                    // 5 变更状态为 IDLE
                    if (!underTest.endEvictionTest(idleObjects)) {
                    }
                }
            }
        }
    }
    .... // abandoned 相关的操作
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;后续会分析 Hikari 和 Druid 数据库连接池的实现，请大家多多关注。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://remcarpediem.net/article/d5009955/&quot;&gt;个人博客，欢迎来玩&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/202002/1816118-20200203214830053-1219392489.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32204303&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/32204303&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5af026a06fb9a07ac47ff282&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5af026a06fb9a07ac47ff282&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;高性能连接池的技术细节 https://yq.aliyun.com/articles/59497&lt;/li&gt;
&lt;li&gt;apache common的通用池 http://www.victorchu.info/2019/01/05/%E4%BB%8Eapache-common-pool%E7%9C%8B%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%B1%A0/&lt;/li&gt;
&lt;li&gt;如何设计一个连接池：commons-pool2源码分 https://throwsnew.com/2017/06/12/commons-pool/&lt;/li&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/32204303&lt;/li&gt;
&lt;li&gt;https://yq.aliyun.com/articles/59497](https://yq.aliyun.com/articles/59497&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 03 Feb 2020 13:49:00 +0000</pubDate>
<dc:creator>程序员历小冰</dc:creator>
<og:description>今天我们就先来了解一下池化技术的必要性、原理；然后使用 Apache-common-Pool2实现一个简单的数据库连接池；接着通过实验，对比简单连接池、HikariCP、Druid 等数据库连接池的性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/remcarpediem/p/12257559.html</dc:identifier>
</item>
<item>
<title>一次完整的OCR实践记录 - |旧市拾荒|</title>
<link>http://www.cnblogs.com/xiaoyh/p/12183339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyh/p/12183339.html</guid>
<description>&lt;h2&gt;一、任务介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这次的任务是对两百余张图片里面特定的编号进行识别，涉及保密的原因，这里就不能粘贴出具体的图片了，下面粘贴出一张类似需要识别的图片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112165402848-1274943445.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假如说我的数据源如上图所示，那么我需要做的工作就是将上面图片里面标红的数字给&lt;span&gt;识别&lt;/span&gt;出来。&lt;/p&gt;
&lt;p&gt;　　我采用的算法是&lt;a href=&quot;https://github.com/YCG09/chinese_ocr&quot;&gt;https://github.com/YCG09/chinese_ocr&lt;/a&gt;，这是基于Tensorflow和keras框架采用ctpn+densenet+CTC算法来完成对图片指定内容的字符识别。&lt;/p&gt;
&lt;h2&gt;二、 图像标注&lt;/h2&gt;
&lt;p&gt;　　既然要进行OCR识别，那么一定要对已有的数据源进行图像标注工作，这里采用的工具是&lt;span&gt;labelImg&lt;/span&gt;，相信大家如果有搞深度学习这块的话一定对这个工具不会陌生。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112170211310-401798184.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对图像具体的标注流程，我这里就不做说明了，网上有很多资料可以查找。这里需要作特别说明的是，对于ctpn的训练，label的名字为&lt;span&gt;text&lt;/span&gt;，对于densenet的训练来说的话，就需要把标注框里面的内容当作label。&lt;/p&gt;
&lt;p&gt;　　然后就是&lt;span&gt;数据增强&lt;/span&gt;这块，这里需要记录的有两点，一就是原始的数据源比较少就必须做数据增强，不然做出来的效果肯定不太行，二就是怎么做数据增强，由于这里的数据比较简单，需要识别的内容也是有规律可行的，那这里就用不着采用比较复杂的数据增强，所以我做的数据增强就是对图像随机进行裁剪和倾斜，当然这里裁剪的尺寸和倾斜的角度一定要控制好，不然就会影响图片的质量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import cv2
import numpy as np
import random
import os
from PIL import Image

# 数据增强的代码

img_path = r&quot;*****************&quot;
save_path = r&quot;****************&quot;

# 随机倾斜图片
def rotate_ima(img_path,save_path):
    for file in os.listdir(img_path):
        img = cv2.imread(os.path.join(img_path,file),0)
        rows,cols = img.shape

        # cols-1 and rows-1 are the coordinate limits.
        # 每张图片倾斜4张
        for i in range(4):
            a = random.randint(2,6)
            print(a)
            # 指定左右倾斜
            for j in range(2):
                a = -a
                M = cv2.getRotationMatrix2D(((cols-1)/2.0,(rows-1)/2.0),a,1)
                dst = cv2.warpAffine(img,M,(cols,rows))

                #cv2.imshow('img',img)
                #cv2.imshow('dst',dst)
                cv2.imwrite(os.path.join(save_path,'rot_'+str(i)+'_'+str(j)+file),dst)
                #cv2.waitKey(0)
                cv2.destroyAllWindows()
    
    
# 随机裁剪图片
def cut_img(img_path,save_path):
    all_file=[]
    for file in os.listdir(img_path):
        all_file.append(file)
    file1=random.sample(all_file,2)
    for x in file1:
        im=Image.open(os.path.join(img_path,x))
        crop_all=[]
        for c in range(5):  # 对每张图片随机生成5张
            for i in range(4):
                a=random.randint(100,400)
                crop_all.append(a)
            region=im.crop((crop_all[0],crop_all[1],im.size[0]-crop_all[2],im.size[1]-crop_all[3]))
            region.save(os.path.join(save_path,'cut_'+str(c)+'_'+x))
            
#rotate_ima(img_path,save_path)
cut_img(img_path,save_path)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我大概生成了3000张左右的图片就开始进行数据标注了，标注了大概六七个小时才把这些数据标注给完成。&lt;/p&gt;
&lt;p&gt;　　有了这些标注数据过后，就可以正式开始训练了。&lt;/p&gt;
&lt;h2&gt;三、CTPN训练&lt;/h2&gt;
&lt;p&gt;　　关于CTPN训练流程在&lt;a href=&quot;https://github.com/YCG09/chinese_ocr/tree/master/ctpn&quot;&gt;https://github.com/YCG09/chinese_ocr/tree/master/ctpn&lt;/a&gt;的readme已经说的很清楚了。但是我这里就列出我&lt;span&gt;所踩的坑&lt;/span&gt;吧。&lt;/p&gt;
&lt;p&gt;　　最开始我直接把标注的数据制作成VOC2007数据集的格式丢进去训练，然后训练出来的效果并不好，后面我才在周围同事的提醒下有一个关键的步骤忘了做。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112172642244-176406935.png&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为CTPN是进行文字检测并不同于普通的目标检测，它的&lt;span&gt;检测原理&lt;/span&gt;是对单个的字符进行检测然后拼接在一起。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112173007658-1842303293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为我们在进行数据标注的时候是对一整行文本进行拉框标注，但是如果要进行CTPN训练的话就需要对这个框划分成很多个矩形小框，划分的方法就是上面的split_label.py程序。&lt;/p&gt;
&lt;p&gt;　　但是要进行上面一步的前提就是需要更改标注文件，使用labelImg标注出来的文件是一个图像对应一个xml文件，但是这里需要更改成&lt;span&gt;一个图像对应一个txt文件&lt;/span&gt;，txt里面存放的是标注框的四个坐标，共计八个点（&lt;span&gt;注意坐标点的顺序&lt;/span&gt;）。如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
410,1554,1723,1554,1723,1736,410,1736
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在运行split_label.py，接着ToVoc.py，这里面的代码细节需要自行更改，这里就不做说明了。&lt;/p&gt;
&lt;p&gt;　　然后就可以正式开始训练了，截图如下：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112174209078-1318331679.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里粘贴出一个错误需要&lt;span&gt;注意&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200119191058343-710282068.png&quot; alt=&quot;&quot; width=&quot;952&quot; height=&quot;229&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解决方案就是&lt;span&gt;删除cache&lt;/span&gt;文件夹&lt;/p&gt;
&lt;h2&gt;四、DenseNet+CTC训练&lt;/h2&gt;
&lt;p&gt;　　DenseNet+CTC训练主要分为两个步骤，一是图像处理，二是txt文件处理。&lt;/p&gt;
&lt;p&gt;　　图像处理的话，在我们拿到标注好的数据之后需要对原始图像进行裁剪工作，就是根据标注的坐标裁剪出具体的图像，就拿上面的图像来说，我们需要的图像如下所示。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112174824075-708059000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后再对裁剪后的图像进行&lt;span&gt;resize工作&lt;/span&gt;，resize成(280,32)，这样的话图像处理这一部分就算完成了。&lt;/p&gt;
&lt;p&gt;　　txt处理的话，这里我们需要对xml文件进行一系列处理来达到下面的效果。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112181853652-2120455887.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前面card_900.jpg代表图像名称，后面这一串字符代表需要识别的字符在下面这个文件里面的&lt;span&gt;位置索引&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112175504743-1292856997.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意这里txt里面存放的是&lt;span&gt;所有图像&lt;/span&gt;里面待识别字符的编号，不是一个图像对应一个txt。&lt;/p&gt;
&lt;p&gt;　　做到这一步过后，在把生成的txt划分成训练集和测试集，就算成功制作出来训练DenseNet的数据集了。&lt;/p&gt;
&lt;p&gt; 　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112175823923-1017081638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就可以开始训练了，截图如下：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1126989/202001/1126989-20200112175915906-1362249675.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、总结&lt;/h2&gt;
&lt;p&gt;　　这次这个小的OCR项目历时大概十天左右，从数据标注再到训练模型，里面踩了很多坑，也做了很多次尝试，也查阅了很多资料，也向周围同事请教了很多次，总算功夫不负有心人，总算完成了这次项目。&lt;/p&gt;
&lt;p&gt;　　这个记录只是记录了大概的流程，很多代码细节并不方便透露，更多详情参阅上面给出的GitHub地址。记录下这个更多是方便自己以后查阅。&lt;/p&gt;

</description>
<pubDate>Mon, 03 Feb 2020 12:53:00 +0000</pubDate>
<dc:creator>|旧市拾荒|</dc:creator>
<og:description>一、任务介绍 这次的任务是对两百余张图片里面特定的编号进行识别，涉及保密的原因，这里就不能粘贴出具体的图片了，下面粘贴出一张类似需要识别的图片。 假如说我的数据源如上图所示，那么我需要做的工作就是将上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyh/p/12183339.html</dc:identifier>
</item>
<item>
<title>BERT模型总结 - ffjsls</title>
<link>http://www.cnblogs.com/ffjsls/p/12257158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ffjsls/p/12257158.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​ BERT是在Google论文《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》中被提出的，是一个面向NLP的无监督预训练模型，并在多达11个任务上取得了优秀的结果。这个模型的最大意义是使得NLP任务可以向CV一样使用与训练模型，这极大的方便了一个新的任务开始，因为在NLP领域，海量数据的获取还是有难度的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模型概述：&lt;/strong&gt;BERT是一个无监督的NLP与训练模型，结构上是Transformer的编码部分，每个block主要由多头self-Attention、标准化(Norm)、残差连接、Feed Fordawrd组成。在具体任务中，主要分为模型预训练和模型微调两个阶段。在模型预训练阶段，因为模型参数巨大，通常是上千万乃至上亿的数量级，所以需要大量的数据训练，所幸这时候模型是无监督的，只需要爬取或使用开源数据集即可；在模型微调阶段，需要针对具体的任务来微调模型，已达到较好的效果。&lt;/p&gt;
&lt;h2 id=&quot;模型整体结构&quot;&gt;1. 模型整体结构&lt;/h2&gt;
&lt;p&gt;​ Bert就是Transformer的编码部分，下图是Transformer的具体结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401308/202002/1401308-20200203201647617-492946927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 上图左侧为Transformer的编码部分，右侧为Transformer的解码部分，本文主要以编码部分详细讲解Bert的结构。左侧的编码部分包括输入，添加位置编码，以self-Attention、Add&amp;amp;Norm、Feed Fordward的block。下面就每个具体细节进行具体分析。&lt;/p&gt;
&lt;h2 id=&quot;位置编码&quot;&gt;2. 位置编码&lt;/h2&gt;
&lt;p&gt;​ 位置编码是用来捕获文本之间的时序关联性的，例如打开现在热度第一的新闻的第一句话：“重庆主城区一栋30层的居民楼发生大火，造成百余名群众被困，重庆市政府迅速调集消防、公安、卫生等数百名人员赶赴现场施救。”其中，“重庆市”与“主城区”相关度最高，位置最近。当对NLP文本处理时，位置更近的文本一般相关性更大，所以将位置编码融入到数据中是很有必要的。需要要说明的是与Bert这种全部基于Attention不同的是，之前基于RNN的模型在模型结构上已经可以将这种时序信息考虑在内。&lt;/p&gt;
&lt;p&gt;​ 在具体处理方式上，采用的是Embedding+Positional的方法，将数据之间的关联性融入到数据中。Embedding是嵌入到相应维度的文本数据，Positional在论文中使用了&lt;span class=&quot;math inline&quot;&gt;\(sine\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(cosine\)&lt;/span&gt;函数的线性变换来提供模型的位置信息，公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ PE_{(pos,2i)}=sin(pos/10000^{2i/d_{model}})\\PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_{model}}) \tag{1} \]&lt;/span&gt;&lt;br/&gt;​ 那为何加了位置编码就能获取数据间位置的特征呢？在self-attention的结构中，在对每维数据计算权重时，是采用点积的形式，本质上就是计算向量之间的相关性。而位置编码将临近的数据加上频率接近的位置编码，就是增加了相邻数据的相关性。下图是位置编码向量的热图，可以看出距离越近，频率就更加接近。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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%0A&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;self-attention&quot;&gt;3. self-Attention&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;self-attention&lt;/strong&gt;是BERT的重要思想，其与位置编码结合，解决了文本数据的时序相关性的问题，从而一举结束了依靠RNN、LSTM、GRU等之前一直用来解决时序问题的网络模型。&lt;strong&gt;self-attention&lt;/strong&gt;通俗的说就是信息向前传播时动态的计算权重的一种方式，与CNN常见的MaxPooling、MeanPooling不同的是，attention模型是经过训练，当不同信息传入时，自动的调整权重的一种结构。&lt;strong&gt;self-attention&lt;/strong&gt;的具体结构如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401308/202002/1401308-20200203201541921-1102074962.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;具体的，将上图的过程进行详细的解释，主要是拆分成4个步骤：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 1）&lt;span class=&quot;math inline&quot;&gt;\(x^1, x^2, x^3, x^4\)&lt;/span&gt;代表的是经过embedding的4条时序文本信息，首先将4条信息加上位置向量，得到&lt;span class=&quot;math inline&quot;&gt;\(a^1, a^2,a^3, a^4\)&lt;/span&gt;，这样做的目的上文已经说过，是为了获取文本的时序相关性。&lt;/p&gt;
&lt;p&gt;​ 2) 对每条信息分配三个权重&lt;span class=&quot;math inline&quot;&gt;\(W_Q, W_K, W_V (embed.dim*embed.dim)\)&lt;/span&gt;，分别与&lt;span class=&quot;math inline&quot;&gt;\(a^1, a^2, a^3, a^4\)&lt;/span&gt;相乘后形成3个矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q, K, V\)&lt;/span&gt;也就是上图的&lt;span class=&quot;math inline&quot;&gt;\(q^i, k^i, v^i\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Q = Linear(a^1) = a^iW^Q\\ K = Linear(a^1) = a^iW^K \\ V = Linear(a^1) = a^iW^V \]&lt;/span&gt;&lt;br/&gt;​ 3) 将&lt;span class=&quot;math inline&quot;&gt;\(q_1\)&lt;/span&gt;分别与&lt;span class=&quot;math inline&quot;&gt;\(k^1, k^2, ...,k^i\)&lt;/span&gt;点乘，得到&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{1, i}\)&lt;/span&gt;，再有softmax的计算公式，计算得&lt;span class=&quot;math inline&quot;&gt;\(\hat\alpha_{1, i}\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \alpha_{1, i} = q^1*k^i\\ \hat\alpha_{1, i} = exp(\alpha_{1, i})/\sum_j{exp(\alpha_{1, j})} \]&lt;/span&gt;&lt;br/&gt;​ 4）最后按照softmax输出的权重对&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;进行加权，计算得&lt;span class=&quot;math inline&quot;&gt;\(b^1\)&lt;/span&gt;。使用同样的方法计算得&lt;span class=&quot;math inline&quot;&gt;\(b^2, b^3, ...,b^i\)&lt;/span&gt;。将&lt;span class=&quot;math inline&quot;&gt;\(b^1, b^2, b^3, ...,b^i\)&lt;/span&gt;进行合并，完成&lt;strong&gt;self-attention&lt;/strong&gt;。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ b^1 = \sum_i\hat{\hat\alpha_{1, i}*v^i} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;残差连接&quot;&gt;4. 残差连接&lt;/h2&gt;
&lt;p&gt;​ 残差连接是训练深层模型时惯用的方法，主要是为了避免模型较深时，在进行反向传播时，梯度消失等问题。具体实现时，当网络进行前向传播时，不仅仅时按照网络层数进行逐层传播，还会由当前层隔一层或多层向前传播，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401308/202002/1401308-20200203201157291-750245688.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型实现&quot;&gt;5. 模型实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401308/202002/1401308-20200203201610037-1152574151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 以上是BERT的整体结构，Input输入的是文本数据，经过Embedding加上位置向量Positional Encoding。Multi-Head Atention为多头的self-Attention，实际上就是将self-attention的Q、K、V均分成n份，分别进行计算。Add&amp;amp;Norm为残差计算和标准化；Feedward为全连接层，进行前向传播。其中&lt;span class=&quot;math inline&quot;&gt;\(N_x\)&lt;/span&gt;为基本单元的个数，是可以条调整的超参数。&lt;/p&gt;
&lt;h2 id=&quot;bert模型预训练策略&quot;&gt;6. Bert模型预训练策略&lt;/h2&gt;
&lt;p&gt;​ 在预训练Bert模型时，论文提供了两种策略：&lt;/p&gt;
&lt;h4 id=&quot;masked-lm&quot;&gt;(1) Masked LM&lt;/h4&gt;
&lt;p&gt;​ 在BERT中, Masked LM(Masked language Model)构建了语言模型, 这也是BERT的预训练中任务之一, 简单来说, 就是&lt;strong&gt;随机遮盖或替换&lt;/strong&gt;一句话里面任意字或词, 然后让模型通过上下文的理解预测那一个被遮盖或替换的部分, 之后&lt;strong&gt;做&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=Loss&amp;amp;mode=inline&quot; alt=&quot;Loss&quot;/&gt;的时候只计算被遮盖部分的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=Loss&amp;amp;mode=inline&quot; alt=&quot;Loss&quot;/&gt;&lt;/strong&gt;, 其实是一个很容易理解的任务, 实际操作方式如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随机把一句话中&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=15%20%5C%25&amp;amp;mode=inline&quot; alt=&quot;$15 % $&quot;/&gt;的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;替换成以下内容:&lt;br/&gt;1) 这些&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;有&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=80%20%5C%25&amp;amp;mode=inline&quot; alt=&quot;$80 % $&quot;/&gt;的几率被替换成&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bmask%5D&amp;amp;mode=inline&quot; alt=&quot;[mask]&quot;/&gt;;&lt;br/&gt;2) 有&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=10%20%5C%25&amp;amp;mode=inline&quot; alt=&quot;10 \%&quot;/&gt;的几率被替换成任意一个其他的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;;&lt;br/&gt;3) 有&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=10%20%5C%25&amp;amp;mode=inline&quot; alt=&quot;10 \%&quot;/&gt;的几率原封不动.&lt;/li&gt;
&lt;li&gt;之后让模型&lt;strong&gt;预测和还原&lt;/strong&gt;被遮盖掉或替换掉的部分, 模型最终输出的隐藏层的计算结果的维度是:&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=X_%7Bhidden%7D%3A%20%5Bbatch%5C_size%2C%20%5C%20seq%5C_len%2C%20%5C%20%20embedding%5C_dim%5D&amp;amp;mode=inline&quot; alt=&quot;X_{hidden}: [batch\_size, \ seq\_len, \ embedding\_dim]&quot;/&gt;&lt;br/&gt;我们初始化一个映射层的权重&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=W_%7Bvocab%7D&amp;amp;mode=inline&quot; alt=&quot;W_{vocab}&quot;/&gt;:&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=W_%7Bvocab%7D%3A%20%5Bembedding%5C_dim%2C%20%5C%20vocab%5C_size%5D&amp;amp;mode=inline&quot; alt=&quot;W_{vocab}: [embedding\_dim, \ vocab\_size]&quot;/&gt;&lt;br/&gt;我们用&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=W_%7Bvocab%7D&amp;amp;mode=inline&quot; alt=&quot;W_{vocab}&quot;/&gt;完成隐藏维度到字向量数量的映射, 只要求&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=X_%7Bhidden%7D&amp;amp;mode=inline&quot; alt=&quot;X_{hidden}&quot;/&gt;和&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=W_%7Bvocab%7D&amp;amp;mode=inline&quot; alt=&quot;W_{vocab}&quot;/&gt;的矩阵乘(点积):&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=X_%7Bhidden%7DW_%7Bvocab%7D%3A%20%5Bbatch%5C_size%2C%20%5C%20seq%5C_len%2C%20%5C%20vocab%5C_size%5D&amp;amp;mode=inline&quot; alt=&quot;$X_{hidden}W_{vocab}: [batch_size,  seq_len,  vocab_size] $&quot;/&gt; 之后把上面的计算结果在&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=vocab%5C_size&amp;amp;mode=inline&quot; alt=&quot;vocab\_size&quot;/&gt;(最后一个)维度做&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=softmax&amp;amp;mode=inline&quot; alt=&quot;softmax&quot;/&gt;归一化, 是每个字对应的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=vocab%5C_size&amp;amp;mode=inline&quot; alt=&quot;vocab\_size&quot;/&gt;的和为&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=1&amp;amp;mode=inline&quot; alt=&quot;1&quot;/&gt;, 我们就可以通过&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=vocab%5C_size&amp;amp;mode=inline&quot; alt=&quot;vocab\_size&quot;/&gt;里概率最大的字来得到模型的预测结果, 就可以和我们准备好的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=Label&amp;amp;mode=inline&quot; alt=&quot;Label&quot;/&gt;做损失(&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=Loss&amp;amp;mode=inline&quot; alt=&quot;Loss&quot;/&gt;)并反传梯度了.&lt;br/&gt;注意做损失的时候, 只计算在第1步里当句中&lt;strong&gt;随机遮盖或替换&lt;/strong&gt;的部分, 其余部分不做损失, 对于其他部分, 模型输出什么东西, 我们不在意.&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;next-sentence-predictnsp&quot;&gt;(2) Next Sentence Predict(NSP)&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;首先我们拿到属于上下文的一对句子, 也就是两个句子, 之后我们要在这两段连续的句子里面加一些特殊&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;:&lt;span class=&quot;math inline&quot;&gt;\([cls]\)&lt;/span&gt;上一句话，&lt;span class=&quot;math inline&quot;&gt;\([sep]\)&lt;/span&gt;下一句话&lt;span class=&quot;math inline&quot;&gt;\([sep]\)&lt;/span&gt;。&lt;br/&gt;也就是在句子开头加一个&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt;, 在两句话之中和句末加&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;, 具体地就像下图一样:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/aespresso/a_journey_into_math_of_ml/raw/e081b67d51a8dc74daa55bb0de35de86acdaa536/04_transformer_tutorial_2nd_part/BERT_tutorial/imgs/embeddings.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们看到上图中两句话是&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt; my dog is cute &lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt; he likes playing &lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;, &lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt;我的狗很可爱&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;他喜欢玩耍&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;, 除此之外, 我们还要准备同样格式的两句话, 但他们不属于上下文关系的情况;&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt;我的狗很可爱&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;企鹅不擅长飞行&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;, 可见这属于上下句不属于上下文关系的情况;&lt;br/&gt;在实际的训练中, 我们让上面两种情况出现的比例为&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=1%3A1&amp;amp;mode=inline&quot; alt=&quot;1:1&quot;/&gt;, 也就是一半的时间输出的文本属于上下文关系, 一半时间不是.&lt;/li&gt;
&lt;li&gt;我们进行完上述步骤之后, 还要随机初始化一个可训练的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=segment%20%5C%20embeddings&amp;amp;mode=inline&quot; alt=&quot;segment \ embeddings&quot;/&gt;, 见上图中, 作用就是用&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=embeddings&amp;amp;mode=inline&quot; alt=&quot;embeddings&quot;/&gt;的信息让模型分开上下句, 我们一把给上句全&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=0&amp;amp;mode=inline&quot; alt=&quot;0&quot;/&gt;的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;, 下句啊全&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=1&amp;amp;mode=inline&quot; alt=&quot;1&quot;/&gt;的&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=token&amp;amp;mode=inline&quot; alt=&quot;token&quot;/&gt;, 让模型得以判断上下句的起止位置, 例如:&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt;我的狗很可爱&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;企鹅不擅长飞行&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bsep%5D&amp;amp;mode=inline&quot; alt=&quot;[sep]&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=0%20%5Cquad%20%20%5C%20%200%20%5C%20%5C%200%20%5C%20%5C%20%200%20%5C%20%5C%200%20%5C%20%5C%200%20%5C%20%5C%200%20%5C%20%5C%20%200%20%5C%20%5C%20%5C%201%20%5C%20%5C%20%201%20%5C%20%5C%201%20%5C%20%5C%201%20%5C%20%5C%201%20%5C%20%5C%201%20%5C%20%5C%201%20%5C%20%5C%201&amp;amp;mode=inline&quot; alt=&quot;$0 \quad   0   0    0   0   0   0    0    1    1   1   1   1   1   1   1 $&quot;/&gt;&lt;br/&gt;上面&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=0&amp;amp;mode=inline&quot; alt=&quot;0&quot;/&gt;和&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=1&amp;amp;mode=inline&quot; alt=&quot;1&quot;/&gt;就是&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=segment%20%5C%20embeddings&amp;amp;mode=inline&quot; alt=&quot;segment \ embeddings&quot;/&gt;.&lt;/li&gt;
&lt;li&gt;还记得我们上节课说过的, 注意力机制就是, 让每句话中的每一个字对应的那一条向量里, 都融入这句话所有字的信息, 那么我们在最终隐藏层的计算结果里, 只要取出&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5Dtoken&amp;amp;mode=inline&quot; alt=&quot;[cls]token&quot;/&gt;所对应的一条向量, 里面就含有整个句子的信息, 因为我们期望这个句子里面所有信息都会往&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5Dtoken&amp;amp;mode=inline&quot; alt=&quot;[cls]token&quot;/&gt;所对应的一条向量里汇总:&lt;br/&gt;模型最终输出的隐藏层的计算结果的维度是:&lt;br/&gt;我们&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=X_%7Bhidden%7D%3A%20%5Bbatch%5C_size%2C%20%5C%20seq%5C_len%2C%20%5C%20%20embedding%5C_dim%5D&amp;amp;mode=inline&quot; alt=&quot;X_{hidden}: [batch\_size, \ seq\_len, \ embedding\_dim]&quot;/&gt;&lt;br/&gt;我们要取出&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5Dtoken&amp;amp;mode=inline&quot; alt=&quot;[cls]token&quot;/&gt;所对应的一条向量, &lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Bcls%5D&amp;amp;mode=inline&quot; alt=&quot;[cls]&quot;/&gt;对应着&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5C%20seq%5C_len&amp;amp;mode=inline&quot; alt=&quot;\ seq\_len&quot;/&gt;维度的第&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=0&amp;amp;mode=inline&quot; alt=&quot;0&quot;/&gt;条:&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=cls%5C_vector%20%3D%20X_%7Bhidden%7D%5B%3A%2C%20%5C%200%2C%20%5C%20%3A%5D&amp;amp;mode=inline&quot; alt=&quot;cls\_vector = X_{hidden}[:, \ 0, \ :]&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=cls%5C_vector%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bbatch%5C_size%2C%20%5C%20%20embedding%5C_dim%7D&amp;amp;mode=inline&quot; alt=&quot;cls\_vector \in \mathbb{R}^{batch\_size, \ embedding\_dim}&quot;/&gt;&lt;br/&gt;之后我们再初始化一个权重, 完成从&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=embedding%5C_dim&amp;amp;mode=inline&quot; alt=&quot;embedding\_dim&quot;/&gt;维度到&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=1&amp;amp;mode=inline&quot; alt=&quot;1&quot;/&gt;的映射, 也就是逻辑回归, 之后用&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=sigmoid&amp;amp;mode=inline&quot; alt=&quot;sigmoid&quot;/&gt;函数激活, 就得到了而分类问题的推断.&lt;br/&gt;我们用&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%5Chat%7By%7D&amp;amp;mode=inline&quot; alt=&quot;\hat{y}&quot;/&gt;来表示模型的输出的推断, 他的值介于&lt;img src=&quot;https://render.githubusercontent.com/render/math?math=%280%2C%20%5C%201%29&amp;amp;mode=inline&quot; alt=&quot;(0, \ 1)&quot;/&gt;之间:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{y} = sigmoid(Linear(cls\_vector)) \quad \hat{y} \in (0, \ 1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考内容：&lt;/p&gt;
&lt;p&gt;[1] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[C]//Advances in neural information processing systems. 2017: 5998-6008.&lt;/p&gt;
&lt;p&gt;[2] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://github.com/aespresso/a_journey_into_math_of_ml&quot; class=&quot;uri&quot;&gt;https://github.com/aespresso/a_journey_into_math_of_ml&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Feb 2020 12:18:00 +0000</pubDate>
<dc:creator>ffjsls</dc:creator>
<og:description>BERT模型总结 前言 ​ BERT是在Google论文《BERT: Pre training of Deep Bidirectional Transformers for Language Unde</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ffjsls/p/12257158.html</dc:identifier>
</item>
</channel>
</rss>