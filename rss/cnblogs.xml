<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>学习 Vue ，从入门到放弃 - 一 定 会 去 旅 行</title>
<link>http://www.cnblogs.com/jying/p/11203138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jying/p/11203138.html</guid>
<description>
&lt;p&gt;最近项目刚完成，手上工作稍微轻松些，准备储备下技术，为未来挑战做好准备。&lt;/p&gt;

&lt;p&gt;之前项目用的较多的是angulajs，不过版本较老，还停留在1.5x系，虽然结合了webpack，es2015等前沿技术，但理解并不深入。也做个两个react的项目和一个react-native小东西，都是不懂现查资料，没有系统学习过。三大前端框架就没接触过Vue了，所以打算拿它从小白学起，也顺便写个完整学习心得。&lt;/p&gt;

&lt;p&gt;以前学习angularjs是在菜鸟教程学的，看了2天直接上了项目，第一个项目用的还是原始方式，html文件中引入css和js，所以上手比较快。后来项目改进到结合webpack和es2015，自动化构建，热刷新等，不过是在别人基础上搭建的后续开发，边做边学，还算OK。&lt;/p&gt;

&lt;p&gt;这次学习Vue打算从官网入手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717174858721-1676713678.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717174908367-422083877.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717174916920-860955726.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717174922657-1968355492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上图片为官网首页点击“起步”进入链接的左侧导航栏，因为有之前的前端经验，所以第一部分觉得还是蛮简单的，基本都看懂了；第二部分就有一些特殊逻辑了，但基本上也都能理解；第三部分内容都较少，但都给到了额外的链接，链接里面的内容都是单独的知识点，后面会重点说；第四部分无关紧要了，没有要迁移升级的项目，看了下与其他框架的对比，大体意思就是，Vue灵感来自angularjs，但要比它进步的多，React能做到的功能Vue基本也都能做，React无非就是比较早，整个生态系统比较完善，但是Vue也不差，而且Vue没有React的那些缺点！虽然语气都比较谦和，但总归是要传递一个信息：Vue是最牛逼的！这也无可厚非，不然谁还学~~ ：）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6fac2bc3-e31b-4da6-9a78-0b703c9a8531')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_6fac2bc3-e31b-4da6-9a78-0b703c9a8531&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6fac2bc3-e31b-4da6-9a78-0b703c9a8531&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6fac2bc3-e31b-4da6-9a78-0b703c9a8531',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6fac2bc3-e31b-4da6-9a78-0b703c9a8531&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;缩写：
v&lt;/span&gt;-bind: =&amp;gt;&lt;span&gt; :
v&lt;/span&gt;-on: =&amp;gt;&lt;span&gt; @ 
v&lt;/span&gt;-slot: =&amp;gt;&lt;span&gt; #

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _date = { a : &lt;span&gt;1&lt;/span&gt; , data : &lt;span&gt;2&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: _data
})
app.$data &lt;/span&gt;!=&lt;span&gt; app.data ,app.data 为_data.data
app.$data &lt;/span&gt;===&lt;span&gt; _data
app.a &lt;/span&gt;=&lt;span&gt; _data.a


Object.freeze(_data); 阻止修改_data

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监控&lt;/span&gt;
app.$witch(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,function(n,o){})


生命周期：create &lt;/span&gt;-&amp;gt; mount -&amp;gt; update -&amp;gt;&lt;span&gt; destroy
生命周期：init Event &lt;/span&gt;-&amp;gt; beforeCreate -&amp;gt; init Injections -&amp;gt; created -&amp;gt;&lt;span&gt; compile 
            &lt;/span&gt;-&amp;gt; beforeMount -&amp;gt; create $el -&amp;gt; mounted -&amp;gt; beforeUpdate -&amp;gt; &lt;span&gt;virtual&lt;/span&gt; dom -&amp;gt; updated -&amp;gt; beforeDestroy -&amp;gt;&lt;span&gt; destroyed


v&lt;/span&gt;-&lt;span&gt;html 注意防止xss攻击


表达式
指令
动态参数 v&lt;/span&gt;-bind:[] v-&lt;span&gt;on:[]
修饰符 v&lt;/span&gt;-on:submit.prevent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;onSubmit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

计算属性：computed 缓存
方法：methods 不缓存
监听器：watch 或 app.$watch



自定义控件：Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,{
    template:`html内容`
})


绑定class使用v&lt;/span&gt;-bind:&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[className1,className2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
绑定style使用v&lt;/span&gt;-bind:style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[styleName1,styleName2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;


v&lt;/span&gt;-&lt;span&gt;if&lt;/span&gt; v-&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
v&lt;/span&gt;-&lt;span&gt;else&lt;/span&gt;-&lt;span&gt;if&lt;/span&gt;&lt;span&gt;
取消复用：独立key


v&lt;/span&gt;-show不支持&amp;lt;template&amp;gt;元素，也不支持v-&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

不推荐同时使用v&lt;/span&gt;-if和v-&lt;span&gt;for&lt;/span&gt; ，详情查看风格指南：https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81&lt;/span&gt;
&lt;span&gt;

v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(item, index) in items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item of items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 包含index？
v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value in object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 遍历对象object
v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(value,name) in object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 遍历对象object
v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(value,name,index) in object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 遍历对象object
建议尽可能在使用v&lt;/span&gt;-&lt;span&gt;for时提供key


替换数组match有点懵逼。。。

app.arrayList[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，不能检测到变动，貌似ng可以。。。
vue可以使用的方法是：Vue.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(vm.items, indexOfItem, newValue) 或 app.$&lt;span&gt;set&lt;/span&gt;(vm.items, indexOfItem, newValue) 或 app.items.splice(indexOfItem, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, newValue)

Vue.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;, propertyName, value) 方法向&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;嵌套对象&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加响应式属性。



修饰符：
v&lt;/span&gt;-&lt;span&gt;on:click.prevent.stop.self.once.capture.passive

v&lt;/span&gt;-&lt;span&gt;on:keyup.enter
@keyup.ctrl.enter

v&lt;/span&gt;-&lt;span&gt;on:click.ctrl.exact
@click.exact

v&lt;/span&gt;-&lt;span&gt;on:click.left.right.middle

v&lt;/span&gt;-&lt;span&gt;model.lazy
v&lt;/span&gt;-&lt;span&gt;model.number 
v&lt;/span&gt;-&lt;span&gt;model.trim


复选框：
&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checebox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toggel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;-value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;-value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;

组件中的data必须是函数；
全局注册：Vue.component
局部注册：&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#el&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    component:{
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;component-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{}
    }
})

组件的特殊使用：
v&lt;/span&gt;-bind:&lt;span&gt;is&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已注册组件的名称或一个组件的选项对象&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 如用于tab
&lt;/span&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr &lt;span&gt;is&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;组件名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;span&gt;

局部注册的组件在其子组件中不可用，但可以在组件中定义再次引用组件。

为了防止大小写敏感，请全部使用xiaoxie_xiaoxie命名。

在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;以上是做的一些笔记，还跟着传统方式（html引入css和js）测试了几个语法，都很简单。&lt;/p&gt;

&lt;p&gt;然后第三部分的内容，先看了路由，因为在之前的项目里也有用到路由。页面的内容看懂了，但是给了一个 &lt;a href=&quot;https://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router链接文档 &lt;/a&gt; 又是一堆内容 ↓↓↓&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717181219935-997451456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;状态管理，React中有Redux作为最流行的Flux实现，一脸懵逼&lt;a href=&quot;https://facebook.github.io/flux/&quot; target=&quot;_blank&quot;&gt;Flux&lt;/a&gt;是啥？ 而Vue中有相同功能的&lt;a href=&quot;https://github.com/vuejs/vuex&quot; target=&quot;_blank&quot;&gt;Vuex&lt;/a&gt;，虽然官网页面的简单实例看懂了，因为之前React项目中知道有store、stage、prop这些东西。但是感觉Vuex没这么简单。。。&lt;/p&gt;
&lt;p&gt;服务器渲染目前应该可以先不用看。&lt;/p&gt;
&lt;p&gt;单文件组件中又列了几个名词：&lt;/p&gt;
&lt;p&gt;　　   其来自 &lt;a href=&quot;https://vue-loader-v14.vuejs.org/zh-cn/&quot; target=&quot;_blank&quot;&gt;Vue Loader &lt;/a&gt; 又是单独的一堆知识点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717183704287-100810840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单元测试你可以先不用看，但里面介绍到Vue自家的单元测试组件&lt;a href=&quot;https://vue-test-utils.vuejs.org/zh/&quot; target=&quot;_blank&quot;&gt; Vue Test Utils&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717183823898-135491455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;TypeScript 这种前沿技术 Vue也当然不会缺席，好在之前项目有用到，文件后缀是ts的，简单点说就是javaScript的升级版，但假如是新手小白的话，你可能还要去了解下 &lt;a href=&quot;https://www.typescriptlang.org/&quot; target=&quot;_blank&quot;&gt;TypeScript&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717184439158-1626114733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生产部署相关内容可以先不看。&lt;/p&gt;
&lt;p&gt;以上多个内容中都提到 &lt;a href=&quot;https://cli.vuejs.org/zh/guide&quot; target=&quot;_blank&quot;&gt;Vue CLI &lt;/a&gt;这么个东西，它是啥呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362679/201907/362679-20190717184820710-1532195962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单说Vue CLI就是Vue给自家封装的快速搭建一个Vue项目的工具，甚至可以通过类似桌面视图方式搭建。安装完Vue CLI后通过vue creat 或vue ui 就可以搭建啦，听起来好简单的。但要深入了解下边的内容，就发现远没有那么简单，你熟悉&lt;a href=&quot;https://webpack.github.io/&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt;吗？假如你已经知道了webpack，那你了解 &lt;a href=&quot;https://github.com/mozilla-neutrino/webpack-chain&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;webpack-chain&lt;/a&gt; 吗？ 静态资源可不是直接html中添加引用那么简单了，你需要知道 url-loader、file-loader、style-loader、css-loader等等loader ；还有插件、预设配置也要了解；环境变量和模式里一堆新名词；构建你也要知道。。。&lt;/p&gt;

&lt;p&gt;好了，到现在我还没有开始搭建第一个现代前端的Vue项目，因为我要先看这么多的文档。。。&lt;/p&gt;

&lt;p&gt;对于新手来说，现在学习前端已经不再是以前的简单易上手了，即使对于传统的前端程序猿要学习新技术也需要花费不少的功夫，以前可能简单了解过html，js，css的后端开发人员也能上手一些简单前端开发，但是现在就很难了。尤其对于已工作的上班族，可能更没有集中的时间来学习，所以学习的时间会更久一些，难度会更大一些。&lt;/p&gt;
&lt;p&gt;但是有一些是相通的东西，比如你在这里学过webpack了，那学习react和angular就可以不用学习这块了。&lt;/p&gt;

&lt;p&gt;忽然想起来之前收藏的一篇关于新前端的讨论，笔者用对话的方式诙谐幽默的写出了学习新前端的代价和装逼之处，大家可以一块乐呵乐呵：&lt;/p&gt;



&lt;p&gt;因为之前开发用的版本较低，而学习Vue用的较新版本，本地webpack和node肯定都过时了，为了避免与原有项目冲突，还又安装了虚拟机，然后安装开发环境，vscode是不能少的~~&lt;/p&gt;

&lt;p&gt;虽然学的有点累，但是不想放弃，希望大家留言讨论下正确的学习Vue 姿势 （从哪里开始，从哪里进阶，多长时间可以玩转项目）~~感觉官网有点像词典 ㄒoㄒ，最好是有阮一峰老师那种风格的~~&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jul 2019 00:57:00 +0000</pubDate>
<dc:creator>一 定 会 去 旅 行</dc:creator>
<og:description>最近项目刚完成，手上工作稍微轻松些，准备储备下技术，为未来挑战做好准备。 之前项目用的较多的是angulajs，不过版本较老，还停留在1.5x系，虽然结合了webpack，es2015等前沿技术，但理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jying/p/11203138.html</dc:identifier>
</item>
<item>
<title>python对Excel的读取 - Tynam.Yang</title>
<link>http://www.cnblogs.com/tynam/p/11204895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tynam/p/11204895.html</guid>
<description>&lt;p&gt;　　在python自动化中，经常会遇到对数据文件的操作，比如添加多名员工，但是直接将员工数据写在python文件中，不但工作量大，要是以后再次遇到类似批量数据操作还会写在python文件中吗？&lt;/p&gt;
&lt;p&gt;　　应对这一问题，可以将数据写excel文件，针对excel 文件进行操作，完美解决。&lt;/p&gt;
&lt;p&gt;　　本文仅介绍python对excel的操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装xlrd 库&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　xlrd库 官方地址：&lt;a href=&quot;https://pypi.org/project/xlrd/&quot;&gt;https://pypi.org/project/xlrd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　pip install xlrd&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359074/201907/1359074-20190718083408211-549150187.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　笔者在安装时使用了 pip3 install xlrd&lt;/p&gt;
&lt;p&gt;　　原因：笔者同时安装了python2 和 python3&lt;/p&gt;
&lt;p&gt;　　如果pip的话会默认将库安装到python2中，python3中不能直接调用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　那么到底是使用pip 还是pip3进行安装呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　如果系统中只安装了Python2，那么就只能使用pip。&lt;br/&gt;　　　　如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的。&lt;br/&gt;　　　　如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Xlrd 库简单的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以如下excel文件为例进行操作&lt;/p&gt;
&lt;p&gt;　　文件名为demo，有两个sheet，名为工作表1和工作表2&lt;/p&gt;
&lt;p&gt;　　工作表1中有如下数据&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359074/201907/1359074-20190718083447874-1729143442.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;简单的使用　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开文件&lt;/span&gt;
data = xlrd.open_workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file/demo.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看工作表&lt;/span&gt;
&lt;span&gt;data.sheet_names()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sheets：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(data.sheet_names()))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过文件名获得工作表,获取工作表1&lt;/span&gt;
table = data.sheet_by_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作表1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印data.sheet_names()可发现，返回的值为一个列表，通过对列表索引操作获得工作表1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; table = data.sheet_by_index(0)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取行数和列数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 行数：table.nrows&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 列数：table.ncols&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总行数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(table.nrows))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总列数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(table.ncols))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取整行的值 和整列的值，返回的结果为数组&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 整行值：table.row_values(start,end)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 整列值：table.col_values(start,end)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数 start 为从第几个开始打印，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; end为打印到那个位置结束，默认为none&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;整行值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str(table.row_values(0)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;整列值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(table.col_values(1&lt;span&gt;)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取某个单元格的值，例如获取B3单元格值&lt;/span&gt;
cel_B3 = table.cell(3,2&lt;span&gt;).value
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第三行第二列的值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + cel_B3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359074/201907/1359074-20190718083603156-1815268764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;项目中使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获得所有的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_xlrd(excelFile):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     data =&lt;span&gt; xlrd.open_workbook(excelFile)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     table =&lt;span&gt; data.sheet_by_index(0)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; rowNum &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(table.nrows):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         rowVale =&lt;span&gt; table.row_values(rowNum)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; colNum &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(table.ncols):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; rowNum &amp;gt; 0 &lt;span&gt;and&lt;/span&gt; colNum ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(int(rowVale[0]))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(rowVale[colNum])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if判断是将 id 进行格式化&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;未格式化Id的数据：&quot;)&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(table.cell(1, 0))&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果：number:1001.0&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     excelFile = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;file/demo.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     read_xlrd(excelFile=excelFile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359074/201907/1359074-20190718083657043-314110262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果在项目中使用则可将内容方法稍为做修改，获得所有的数据后，将每一行数据作为数组进行返回　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_xlrd(excelFile):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     data =&lt;span&gt; xlrd.open_workbook(excelFile)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     table =&lt;span&gt; data.sheet_by_index(0)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     dataFile =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; rowNum &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(table.nrows):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if 去掉表头&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; rowNum &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            dataFile.append(table.row_values(rowNum))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataFile
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     excelFile = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;file/demo.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(read_xlrd(excelFile=excelFile))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1359074/201907/1359074-20190718083741618-712283565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 00:38:00 +0000</pubDate>
<dc:creator>Tynam.Yang</dc:creator>
<og:description>在python自动化中，经常会遇到对数据文件的操作，比如添加多名员工，但是直接将员工数据写在python文件中，不但工作量大，要是以后再次遇到类似批量数据操作还会写在python文件中吗？ 应对这一问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tynam/p/11204895.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Alibaba | Sentinel: 分布式系统的流量防卫兵初探 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11201945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11201945.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.6.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如无特殊说明，本系列文章全采用以上版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sentinel-是什么&quot;&gt;1. Sentinel 是什么？&lt;/h2&gt;
&lt;p&gt;Sentinel 是阿里中间件团队研发的面向分布式服务架构的轻量级高可用流量控制组件，最近正式开源。Sentinel 主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。讲到这里，可能很多人会有疑问：Sentinel 和之前常用的熔断降级库 Netflix Hystrix 有什么异同呢？如果不清楚什么是Hystrix的，可以看我签名的文章&lt;a href=&quot;https://blog.csdn.net/meteor_93/article/details/94498650&quot;&gt;跟我学SpringCloud | 第四篇：熔断器Hystrix&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面我们通过一张表格来了解一下Sentinel和Hystrix的区别：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;隔离策略&lt;/td&gt;
&lt;td&gt;基于并发数&lt;/td&gt;
&lt;td&gt;线程池隔离/信号量隔离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;熔断降级策略&lt;/td&gt;
&lt;td&gt;基于响应时间或失败比率&lt;/td&gt;
&lt;td&gt;基于失败比率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;实时指标实现&lt;/td&gt;
&lt;td&gt;滑动窗口&lt;/td&gt;
&lt;td&gt;滑动窗口（基于 RxJava）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;规则配置&lt;/td&gt;
&lt;td&gt;支持多种数据源&lt;/td&gt;
&lt;td&gt;支持多种数据源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;扩展性&lt;/td&gt;
&lt;td&gt;多个扩展点&lt;/td&gt;
&lt;td&gt;插件的形式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;基于注解的支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;调用链路信息&lt;/td&gt;
&lt;td&gt;支持同步调用&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;限流&lt;/td&gt;
&lt;td&gt;基于 QPS / 并发数，支持基于调用关系的限流&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;流量整形&lt;/td&gt;
&lt;td&gt;支持慢启动、匀速器模式&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;系统负载保护&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;实时监控 API&lt;/td&gt;
&lt;td&gt;各式各样&lt;/td&gt;
&lt;td&gt;较为简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;控制台&lt;/td&gt;
&lt;td&gt;开箱即用，可配置规则、查看秒级监控、机器发现等&lt;/td&gt;
&lt;td&gt;不完善&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;常见框架的适配&lt;/td&gt;
&lt;td&gt;Servlet、Spring Cloud、Dubbo、gRPC 等&lt;/td&gt;
&lt;td&gt;Servlet、Spring Cloud Netflix&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单看下来，Sentinel明显比Hystrix功能更为强大。&lt;/p&gt;
&lt;p&gt;Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性，所以被称为&lt;strong&gt;分布式系统的流量防卫兵&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;sentinel-的特征&quot;&gt;2. Sentinel 的特征:&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;丰富的应用场景：&lt;/strong&gt; Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完备的实时监控：&lt;/strong&gt; Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广泛的开源生态：&lt;/strong&gt; Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完善的 SPI 扩展点：&lt;/strong&gt; Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Sentinel 的主要特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/alibaba/sentinel/sentinel1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sentinel-的开源生态&quot;&gt;3. Sentinel 的开源生态：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/alibaba/sentinel/sentinel2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sentinel 分为两个部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。&lt;/li&gt;
&lt;li&gt;控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简单使用&quot;&gt;4. 简单使用&lt;/h2&gt;
&lt;h3 id=&quot;项目依赖pom.xml&quot;&gt;4.1 项目依赖pom.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-core --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sentinel-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.6.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义资源&quot;&gt;4.2 定义资源&lt;/h3&gt;
&lt;p&gt;接下来，我们把需要控制流量的代码用 Sentinel API SphU.entry(&quot;HelloWorld&quot;) 和 entry.exit() 包围起来即可。在下面的例子中，我们将 System.out.println(&quot;hello wolrd&quot;); 作为资源，用 API 包围起来。参考代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    initFlowRules();
    while (true) {
        Entry entry = null;
        try {
            entry = SphU.entry(&quot;HelloWorld&quot;);
            /*业务逻辑 - 开始*/
            System.out.println(&quot;hello world&quot;);
            /*业务逻辑 - 结束*/
        } catch (BlockException e1) {
            /*流控逻辑处理 - 开始*/
            System.out.println(&quot;block!&quot;);
            /*流控逻辑处理 - 结束*/
        } finally {
            if (entry != null) {
                entry.exit();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成以上两步后，代码端的改造就完成了。&lt;/p&gt;
&lt;h3 id=&quot;定义规则&quot;&gt;4.3 定义规则&lt;/h3&gt;
&lt;p&gt;接下来，通过规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void initFlowRules(){
    List&amp;lt;FlowRule&amp;gt; rules = new ArrayList&amp;lt;&amp;gt;();
    FlowRule rule = new FlowRule();
    rule.setResource(&quot;HelloWorld&quot;);
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    // Set limit QPS to 20.
    rule.setCount(20);
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成上面 3 步，Sentinel 就能够正常工作了。&lt;/p&gt;
&lt;h3 id=&quot;demo运行&quot;&gt;4.4 Demo运行&lt;/h3&gt;
&lt;p&gt;Demo 运行之后，我们可以在日志 ~/logs/csp/${appName}-metrics.log.xxx 里看到下面的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|--timestamp-|------date time----|-resource-|p |block|s |e|rt
1563351614000|2019-07-17 16:20:14|HelloWorld|20|560|20|0|2|0
1563351615000|2019-07-17 16:20:15|HelloWorld|20|1441|20|0|0|0
1563351616000|2019-07-17 16:20:16|HelloWorld|20|2724|20|0|0|0
1563351617000|2019-07-17 16:20:17|HelloWorld|20|2348|20|0|0|0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 p 代表通过的请求, block 代表被阻止的请求, s 代表成功执行完成的请求个数, e 代表用户自定义的异常, rt 代表平均响应时长。&lt;/p&gt;
&lt;p&gt;可以看到，这个程序每秒稳定输出 &quot;hello world&quot; 20 次，和规则中预先设定的阈值是一样的。&lt;/p&gt;
&lt;p&gt;Sentinel的简单使用就到这里结束了，更多的进阶使用欢迎关注后续的博客，谢谢。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/Alibaba/simple-sentinel&quot;&gt;Github-示例代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D&quot;&gt;https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/623424&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/623424&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 00:37:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>Spring Cloud Alibaba | Sentinel: 分布式系统的流量防卫兵初探 Springboot: 2.1.6.RELEASE SpringCloud: Greenwich.SR1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11201945.html</dc:identifier>
</item>
<item>
<title>.net持续集成cake篇之cake介绍及简单示例 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11204862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11204862.html</guid>
<description>&lt;h2 id=&quot;cake介绍&quot;&gt;cake介绍&lt;/h2&gt;
&lt;p&gt;Cake 是.net平台下的一款自动化构建工具,可以完成对.net项目的编译,打包,运行单元测试,集成测试甚至发布项目等等.如果有些特征&lt;code&gt;Cake&lt;/code&gt;没有实现,我们还可以很容易地通过扩展Cake来实现我们想要的功能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cake&lt;/code&gt;有以下特点&lt;/p&gt;
&lt;p&gt;1) 使用c#语言编写,可以在Cake脚本里使用C#语言来实现我们想要达到的功能.&lt;/p&gt;
&lt;p&gt;2) 跨平台,可以运行在windows,linux 和macos上.&lt;/p&gt;
&lt;p&gt;3)易于扩展,c#开发者很容易使用已有的&lt;code&gt;c#&lt;/code&gt;语言知识对&lt;code&gt;Cake&lt;/code&gt;进行扩展,甚至可以让&lt;code&gt;Cake&lt;/code&gt;支持Java,Python等语言的构建&lt;/p&gt;
&lt;p&gt;4) 易于和常见CI/CD平台结合,&lt;code&gt;Cake&lt;/code&gt;很容易和常见的CI/CD平台,例如 &lt;code&gt;Jenkins&lt;/code&gt;,&lt;code&gt;AppVeyor&lt;/code&gt;, &lt;code&gt;TeamCity&lt;/code&gt;, &lt;code&gt;TFS&lt;/code&gt;, &lt;code&gt;VSTS&lt;/code&gt;,&lt;code&gt;Azure PipeLine&lt;/code&gt;等结合&lt;/p&gt;
&lt;p&gt;5) 插件丰富,Cake官网和第三方开发者提供了丰富的Cake扩展工具,方便开箱即用.&lt;/p&gt;
&lt;h2 id=&quot;新建一个cake-helloworld示例&quot;&gt;新建一个Cake HelloWorld示例&lt;/h2&gt;
&lt;p&gt;本节我们通过一个HelloWorld示例讲解如何制作Cake文件,下载启动脚本以及如何安装Cake visualstudio插件&lt;/p&gt;
&lt;h3 id=&quot;一.新建一个cake文件&quot;&gt;一.新建一个Cake文件&lt;/h3&gt;
&lt;p&gt;我们新建一个.net项目(可以是类库,控制台或者web项目),这里我们创建一个控制台项目,然后在项目&lt;code&gt;sln&lt;/code&gt;所在目录下新建一个名为&lt;code&gt;build.cake&lt;/code&gt;的文件.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;读者可以新建一个文本文件,然后的后缀改为cake,把文件名改为build,这样也能完成一个&lt;code&gt;build.cake&lt;/code&gt;的创建.当然也可以通过执行&lt;code&gt;Powershell&lt;/code&gt;命令&lt;code&gt;New-Item build.cake&lt;/code&gt;来创建一个build.cake文件,使用powershell创建时一定要注意在当前项目所在目录下打开powershell,不然以上命令合建的文件可能路径并不是我们期待的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;有些读者可能有疑问是不是这个文件一定要命名为&lt;code&gt;build.cake&lt;/code&gt;呢,答案是否定的,其实这个文件可以随意命令,但是作为初体验,强烈建议读者不要随便命令,而是跟着讲解做,以免造成不必要的麻烦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二.编辑build.cake文件&quot;&gt;二.编辑&lt;code&gt;build.cake&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;我们新建build.cake后,用词本(或者其它自己熟悉的编辑器打开它),添加以下代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var target = Argument(&quot;target&quot;, &quot;Default&quot;);
var configuration = Argument(&quot;configuration&quot;, &quot;Release&quot;);



Setup(ctx =&amp;gt;
{
    // Executed BEFORE the first task.
    Information(&quot;Running tasks...&quot;);
});

Teardown(ctx =&amp;gt;
{
    // Executed AFTER the last task.
    Information(&quot;Finished running tasks.&quot;);
});

Task(&quot;Default&quot;)
.Does(() =&amp;gt; {
    Information(&quot;Hello World!&quot;);
});

RunTarget(target);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三.下载启动脚本&quot;&gt;三.下载启动脚本&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cake&lt;/code&gt;在windows下启动脚本为&lt;code&gt;build.ps1&lt;/code&gt;(当然也可以是其它名字),在linux和macos下为&lt;code&gt;build.sh&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是虽然Cake在macos和linux下启动脚本都是&lt;code&gt;build.sh&lt;/code&gt;但是并不是一模一样的,不同平台要下载针对本平台的启动脚本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于我是在windows下运行的,因此下载windows平台对应的启动脚本&lt;code&gt;build.ps1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在项目&lt;code&gt;build.cake&lt;/code&gt;所在目录下,我们打开powershell,然后执行以下命令&lt;code&gt;Invoke-WebRequest http://cakebuild.net/download/bootstrapper/windows -OutFile build.ps1&lt;/code&gt; 即可下载启动脚本&lt;/p&gt;
&lt;blockquote readability=&quot;2.3913043478261&quot;&gt;
&lt;p&gt;linux平台下载方式:curl -Lsfo build.sh &lt;a href=&quot;http://cakebuild.net/download/bootstrapper/linux&quot; class=&quot;uri&quot;&gt;http://cakebuild.net/download/bootstrapper/linux&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.3863636363636&quot;&gt;
&lt;p&gt;mac平台下载方式 curl -Lsfo build.sh &lt;a href=&quot;http://cakebuild.net/download/bootstrapper/osx&quot; class=&quot;uri&quot;&gt;http://cakebuild.net/download/bootstrapper/osx&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;需要注意的是,一定要在当前目录(sln所在目录或者自已指定的其它目录),如果是从开始菜单中启动的powershell,一定要通过cd命令进入到目标目录.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190718081518967-1681920028.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;windows 10可以在文件夹左上角点击&lt;code&gt;文件&lt;/code&gt;在弹出菜单中找到powershell,这样启动的powershell目录就是在当前文件夹所在目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四.执行构建&quot;&gt;四.执行构建&lt;/h2&gt;
&lt;p&gt;我们在当前目录打开powershell,通过powershell,在powershell命令窗口里输入&lt;code&gt;.\build.ps1&lt;/code&gt;执行刚下载的ps1脚本,过一分后我们可以看到输出的构建信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190718081509913-1545408487.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五.build.cake文件解析&quot;&gt;五.build.cake文件解析&lt;/h3&gt;
&lt;p&gt;初接触&lt;code&gt;build.cake&lt;/code&gt;我们可能对它很陌生,不过不要害怕,它完全是用c#语言写的,只是方法是自定义的.&lt;/p&gt;
&lt;p&gt;build.cake里共有三个任务,Setup,TearDown和Default,其中&lt;code&gt;Setup&lt;/code&gt;任务会在所有任务执行之前执行,&lt;code&gt;TearDown&lt;/code&gt;任务会在所有任务执行后执行,非常类似于&lt;code&gt;Nunit&lt;/code&gt;里的Setup和TearDown方法.有些时候我们想在所有方法执行之前执行一些初始化工作,在所有任务执行完之后执行一些收尾工具,我们可以把相应代码写在&lt;code&gt;Setup&lt;/code&gt;和&lt;code&gt;TearDown&lt;/code&gt;里&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Setup&lt;/code&gt;,&lt;code&gt;TearDown&lt;/code&gt;和&lt;code&gt;Default&lt;/code&gt;里接收的都是一个委托,我们可在在委托里写自己的代码,委托里的参数由于目前我们没有使用到,这里不再讲解.大家只要知道它的格式就行了.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;Setup&lt;/code&gt;,&lt;code&gt;TearDown&lt;/code&gt;是两个特殊的任务,由cake自动调用,而Default任务需要显地调用才能执行,我们编写其它任务时,可以模仿Default任务.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;在这里,有些童鞋可能会有疑问,以上任务通过脚本也能完成,为什么还要这么麻烦来使用工具呢,其实使用脚本有很多弊端,我们前面介绍了一个完整的.net web项目在测试环境的持续集成方案,其中使用到了数十个脚本和工具,如果我们的脚本编写不够严谨往往会造成生产环境的损失.并且从实践上来看,脚本数量过多时往往容易失控.部署在服务器中脚本很多时候成为烫手山芋,不熟悉的人既不想看,也不想改,更重要的是不敢轻易改.也不敢轻易把它移除或者删除掉.另外一个不可忽视的问题是脚本往往背后调用的是工具,工具又对运行环境有依赖.我们在精心配置的一台服务器上可能运行良好,但是换更换到其它的服务器上往往会因为各种条件不满足造成各种问题,在人手不足的情况下这么问题尤为凸显.开发和运维都苦不堪言,开发脚本的初衷往往是为了提高效率,结果由于维护问题加深开发和运维之间的矛盾.而cake则由自身管理各种依赖,很大程度上解决了以上问题.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Jul 2019 00:29:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>cake介绍 Cake 是.net平台下的一款自动化构建工具,可以完成对.net项目的编译,打包,运行单元测试,集成测试甚至发布项目等等.如果有些特征 没有实现,我们还可以很容易地通过扩展Cake来实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11204862.html</dc:identifier>
</item>
<item>
<title>.Net微信网页开发之JSSDK使用步骤和配置信息timestamp(时间戳)，nonceStr(随机串)，signature(签名)，access_token(接口调用凭据)的生成获取讲解 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11124092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11124092.html</guid>
<description>&lt;h2&gt; 前言：&lt;/h2&gt;
&lt;p&gt;　　因为接下来会有几篇关于微信JS-SDK功能使用的文章，主要会对微信分享，获取设备信息，获取地理位置，微信扫一扫这几个功能进行讲解。而这几个功能都是围绕着微信JS-SDK实现的，首先使用微信JS-SDK时我们需要生成对应的配置信息，才能够成功的调用微信JS-SDK。看了下微信官方文档对于accessToken和jsapi_ticket的生成示例代码并没有看到咱们大.Net的，所以为了帮助那些刚接触微信开发的同学，在这里我会把自己在使用微信JS-SDK的一些步骤和配置信息生成的方法展示出来，希望能够和大家相互学习共同进步。&lt;/p&gt;
&lt;p&gt;微信JS-SDK详情说明请移步微信官方文档：&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&quot;&gt;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;JSSDK使用步骤：&lt;/h2&gt;
&lt;h3&gt;步骤一、绑定安全域名：&lt;/h3&gt;
&lt;p&gt;先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190703150349866-1987761292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;步骤二、引入JS文件：&lt;/h3&gt;
&lt;p&gt;在需要调用JS接口的页面引入如下JS文件，（支持https）：&lt;a href=&quot;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&gt;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目中: &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;步骤三、通过config接口注入权限验证配置：　　&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用,目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
wx.config({
    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
    appId: '', // 必填，公众号的唯一标识
    timestamp: , // 必填，生成签名的时间戳
    nonceStr: '', // 必填，生成签名的随机串
    signature: '',// 必填，签名
    jsApiList: [] // 必填，需要使用的JS接口列表，如需要调用分享给朋友的话我们填写为[&quot;onMenuShareTimeline&quot;]
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;步骤四、通过ready接口处理成功验证：&lt;/h3&gt;
&lt;p&gt;注意：假如需要在页面加载时就调用的话，需要把对应的执行函数放到wx.ready(function(){})；方法里面加载执行，之前我调用加载就获取地理位置的接口就是因为没有放到这里面所以一直没有获取到用户当前经纬度坐标&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
wx.ready(function(){
    // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。
});　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;步骤五、通过error接口处理失败验证：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
wx.error(function(res){
    // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口调用说明请查看微信开发文档：&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&quot;&gt;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&lt;/a&gt;　&lt;/p&gt;
&lt;h2&gt;获取access_token(公众号的全局唯一接口调用凭据):&lt;/h2&gt;
&lt;p&gt;详细概述：&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140183&quot;&gt;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过接口获取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取微信公众号全局唯一接口凭证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; RequestAccessToken()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置参数&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; appid =WxAppId;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三方用户唯一凭证&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; appsecret =WxAppSecret;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三方用户唯一凭证密钥，即appsecret
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求接口获取&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; _url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + appid + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;secret=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; appsecret;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            HttpWebRequest request &lt;/span&gt;= WebRequest.Create(_url) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebRequest;
            CookieContainer cookieContainer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieContainer();
            request.CookieContainer &lt;/span&gt;=&lt;span&gt; cookieContainer;
            request.AllowAutoRedirect &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            request.Method &lt;/span&gt;=&lt;span&gt; method;
            request.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求并获取相应回应数据&lt;/span&gt;
            HttpWebResponse response = request.GetResponse() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebResponse;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直到request.GetResponse()程序才开始向目标网页发送Post请求&lt;/span&gt;
            Stream responseStream =&lt;span&gt; response.GetResponseStream();
            StreamReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(responseStream, Encoding.UTF8);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取返回过来的结果&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; content =&lt;span&gt; sr.ReadToEnd();

            &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; resultContent=JsonConvert.DeserializeObject(content,&lt;span&gt;new&lt;/span&gt; { access_token=&lt;span&gt;&quot;&quot;&lt;/span&gt;, expires_in=&lt;span&gt;&quot;&quot;&lt;/span&gt;, errcode=&lt;span&gt;&quot;&quot;&lt;/span&gt;, errmsg=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; }.GetType());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resultContent.errcode == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;errcode为0时表示请求成功&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; resultContent.access_token;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回请求唯一凭证&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败，返回为空&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;获取jsapi_ticket微信公众号调用微信JS接口的临时票据（前提是：获取到了公众号全局唯一接口调用凭据）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取jsapi_ticket微信公众号调用微信JS接口的临时票据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;accessToken&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;微信公众号的全局唯一接口调用凭证&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RequestJsapi_ticket(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; accessToken)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO：注意api_ticket 是用于调用微信卡券JS API的临时票据，有效期为7200 秒，通过access_token 来获取。&lt;/span&gt;

                &lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + accessToken + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;type=jsapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                HttpWebRequest request &lt;/span&gt;= WebRequest.Create(url) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebRequest;
                CookieContainer cookieContainer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieContainer();
                request.CookieContainer &lt;/span&gt;=&lt;span&gt; cookieContainer;
                request.AllowAutoRedirect &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                request.Method &lt;/span&gt;=&lt;span&gt; method;
                request.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                request.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求并获取相应回应数据&lt;/span&gt;
                HttpWebResponse response = request.GetResponse() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebResponse;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直到request.GetResponse()程序才开始向目标网页发送Post请求&lt;/span&gt;
                Stream responseStream =&lt;span&gt; response.GetResponseStream();
                StreamReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(responseStream, Encoding.UTF8);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取返回过来的结果&lt;/span&gt;
                content =&lt;span&gt; sr.ReadToEnd();
                &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; resultStr = JsonConvert.DeserializeObject(content,&lt;span&gt;new&lt;/span&gt; { errcode=&lt;span&gt;&quot;&quot;&lt;/span&gt;, errmsg=&lt;span&gt;&quot;&quot;&lt;/span&gt;,ticket=&lt;span&gt;&quot;&quot;&lt;/span&gt;, expires_in=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;}.GetType());

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (resultStr.errcode==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;amp;&amp;amp;resultStr.errmsg==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    content&lt;/span&gt;=&lt;span&gt;resultStr.ticket;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    content &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                }
               
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; content;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                content &lt;/span&gt;=&lt;span&gt; ex.Message;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; content;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成签名的随机串（nonceStr）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 随机字符串数组集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] NonceStrings = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[]
                                    {
                                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                    };

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成签名的随机串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CreateNonceStr()
        {
            Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; NonceStrings.Length;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成15位数的随机字符串，当然也可以通过控制对应字符串大小生成，但是至多不超过32位&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;15&lt;/span&gt;; i++&lt;span&gt;)
            {
                sb.Append(NonceStrings[random.Next(length &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;)]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过random获得的随机索引到，NonceStrings数组中获取对应数组值&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成签名时间戳（timestamp）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取当前时间戳
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetCurrentUinxTime()
        {
            DateTime currentDate &lt;/span&gt;= DateTime.Now;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前时间
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转化为时间戳&lt;/span&gt;
            DateTime localTime = TimeZone.CurrentTimeZone.ToLocalTime(&lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;.Parse((currentDate - localTime).TotalSeconds.ToString().Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;获取当前网页URL:&lt;/h2&gt;
&lt;p&gt;注意：一定要是在安全域名内，否则生成的是无效的签名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;获取当前网页URL&lt;/span&gt;
&lt;span&gt;        string&lt;/span&gt; currentWebUrl = Request.Url.ToString();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成签名（signature）：&lt;/h2&gt;
&lt;p&gt;微信JS-SDK使用权限签名算法详细概述：&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&quot;&gt;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421141115&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取签名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;jsapi_ticket&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;微信公众号调用微信JS临时票据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;nonceStr&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;随机串&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timestamp&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;时间戳&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;当前网页URL&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetSignature(&lt;span&gt;string&lt;/span&gt; jsapi_ticket, &lt;span&gt;string&lt;/span&gt; nonceStr, &lt;span&gt;long&lt;/span&gt; timestamp, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; string1Builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里参数名必须全部小写，且必须有序&lt;/span&gt;
            string1Builder.Append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsapi_ticket=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Append(jsapi_ticket).Append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                          .Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;noncestr=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Append(nonceStr).Append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                          .Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Append(timestamp).Append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                          .Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Append(url.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt;= &lt;span&gt;0&lt;/span&gt; ? url.Substring(&lt;span&gt;0&lt;/span&gt;, url.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) : url);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Sha1(string1Builder.ToString(),Encoding.UTF8);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 签名加密，使用SHA加密所得
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;content&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;签名加密参数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;encode&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;编码UTF-8&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sha1(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; content, Encoding encode)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                SHA1 sha1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SHA1CryptoServiceProvider();
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytesIn =&lt;span&gt; encode.GetBytes(content);
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytesOut =&lt;span&gt; sha1.ComputeHash(bytesIn);
                sha1.Dispose();
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; BitConverter.ToString(bytesOut);
                result &lt;/span&gt;= result.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SHA1加密出错：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;　　最后要总结一下关于对接第三方的一些心得，有的时候我们在实际项目开发中也许会对接一些我们之前从来都没有对接过的第三方软件公司的一些功能比如最为常见的是微信，支付宝，QQ等，在对接之前我们第一步要做的是明确自己的需求，有目的性的去阅读第三方对接开发文档，因为一般对接文档都是有对应的功能详细说明，你不可能把所有的文档都看完了再去对接，这样的话你的项目开发进度肯定是会延期的。学会使用第三方提供的demo示例，因为这将会在很大的程度上帮助你了解功能的实现原理。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 00:19:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 因为接下来会有几篇关于微信JS-SDK功能使用的文章，主要会对微信分享，获取设备信息，获取地理位置，微信扫一扫这几个功能进行讲解。而这几个功能都是围绕着微信JS-SDK实现的，首先使用微信JS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11124092.html</dc:identifier>
</item>
<item>
<title>简易数据分析 06 | 如何导入别人已经写好的 Web Scraper 爬虫 - 卤代烃实验室</title>
<link>http://www.cnblogs.com/web-scraper/p/import_export_sitemap.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/web-scraper/p/import_export_sitemap.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190708214016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是简易数据分析系列的&lt;strong&gt;第 6 篇&lt;/strong&gt;文章。&lt;/p&gt;
&lt;p&gt;上两期我们学习了如何通过 Web Scraper 批量抓取豆瓣电影 TOP250 的数据，内容都太干了，今天我们说些轻松的，讲讲 Web Scraper 如何导出导入 Sitemap 文件。&lt;/p&gt;
&lt;p&gt;前面也没有说，SItemap 是个什么东西，其实它就是我们&lt;strong&gt;操作 Web Scraper 后生成的爬虫文件&lt;/strong&gt;，相当于 python 爬虫的源代码，导入 Web Scraper 一运行就可以爬取数据。学习了这一章节，就可以分享我们的设置好的爬虫文件了。&lt;/p&gt;

&lt;p&gt;导出 Sitemap 很简单，比如说我们创建的 top250 Sitemap，点击 &lt;code&gt;Sitemap top250&lt;/code&gt;，在下拉菜单里选择 &lt;code&gt;Export Sitemap&lt;/code&gt;，就会跳到一个新的面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707182901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新的面板里有我们创建的 top250 的 Sitemap 信息，我们把它复制下来，再新建一个 TXT 文件，粘贴保存就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707182903.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;导入 Sitemap 也很简单，在创建新的 Sitemap 时，点击 &lt;code&gt;Import Sitemap&lt;/code&gt; 就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707182900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在新的面板里，在 &lt;code&gt;Sitemap JSON&lt;/code&gt; 里把我们导出的文字复制进去，&lt;code&gt;Rename Sitemap&lt;/code&gt; 里取个名字，最后点击 &lt;code&gt;Import Sitemap&lt;/code&gt; 按钮就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707182902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这期我们介绍了 Web Scraper 如何导入导出 Sitemap 爬虫文件，下一期我们对&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_douban_top250_movie.html&quot;&gt;上一期&lt;/a&gt;的内容进行扩展，不单单抓取 250 个电影名，还要抓取每个电影对应的排名，名字，评分和一句话影评。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190630172950.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_douban_top250_movie.html&quot;&gt;Web Scraper 翻页——控制链接批量抓取数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_first_scrape_douban.html&quot;&gt;简易数据分析 04 | Web Scraper 初尝--抓取豆瓣高分电影&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1717181/201907/1717181-20190718075941935-563744428.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
<dc:creator>卤代烃实验室</dc:creator>
<og:description>这是简易数据分析系列的 第 6 篇 文章。 上两期我们学习了如何通过 Web Scraper 批量抓取豆瓣电影 TOP250 的数据，内容都太干了，今天我们说些轻松的，讲讲 Web Scraper 如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/web-scraper/p/import_export_sitemap.html</dc:identifier>
</item>
<item>
<title>JAVA面试题 手写ArrayList的实现，在笔试中过关斩将? - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11204338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11204338.html</guid>
<description>&lt;p&gt;面试官Q1：可以手写一个ArrayList的简单实现吗？&lt;/p&gt;
&lt;p&gt;我们都知道ArrayList是基于数组实现，如果让你实现JDK源码ArrayList中add()、remove()、get()方法，你知道如何实现吗？这一节，我们不看源码，我们想想如何简单的实现ArrayList几个基本方法？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确定数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，ArrayList中无论什么数据都能放，是不是意味着它是一个Object类型，既然是数组，那么是不是Object[]数组类型的？所以我们定义的数据结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private Object[] elementData;  
private int size;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置自定义的MyArrayList的长度为10&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public MyArrayList(){
         this(10);
 }
 
public MyArrayList(int initialCapacity){
      if(initialCapacity&amp;lt;0){
             try {
                 throw new Exception();
             } catch (Exception e) {
                e.printStackTrace();
            }
        }
        elementData = new Object[initialCapacity];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了存放数据的位置，接下来，我们想想如何将数据放入数组？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;添加数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void add(Object obj){
        elementData[size++]=obj;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每添加一个元素，size就会自增1，我们定义的数组长度为10，当我们添加到11个元素的时候，显然没有地方存放新添加的数据，这个时候我们需要对数组进行扩容处理对上面代码做如下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public void add(Object obj){
         if(size==elementData.length){
            //创建一个新的数组，并且这个数组的长度是原数组长度的2倍
             Object[] newArray = new Object[size*2];
            //使用底层拷贝，将原数组的内容拷贝到新数组
             System.arraycopy(elementData, 0, newArray, 0, elementData.length);
            //并将新数组赋值给原数组的引用
             elementData = newArray;
         }
        //新来的元素，直接赋值
        elementData[size++]=obj;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用一张图来表示就是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190717230755985-119525386.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public Object get(int index){
        return elementData[index];
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;删除数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着我们看一下删除的操作。ArrayList支持两种删除方式：&lt;/p&gt;
&lt;p&gt;对于ArrayList来说，这两种删除的方法差不多，都是调用的下面一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public void remove(int index){
         //删除指定位置的对象
         //a b d e
         int numMoved = size - index - 1;
         if (numMoved &amp;gt; 0){
             System.arraycopy(elementData, index+1, elementData, index,
                     numMoved);
         }
         elementData[--size] = null; // Let gc do its work
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实做的事情就是两件:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把指定元素后面位置的所有元素，利用System.arraycopy方法整体向前移动一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后一个位置的元素指定为null，这样让gc可以去回收它&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用图表示是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190717230934806-2135213099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定位置添加数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把从指定位置开始的所有元素利用System,arraycopy方法做一个整体的复制，向后移动一个位置（当然先要用ensureCapacity方法进行判断，加了一个元素之后数组会不会不够大），然后指定位置的元素设置为需要插入的元素，完成了一次插入的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void add(int index,Object obj){
        ensureCapacity();  //数组扩容
        System.arraycopy(elementData, index, elementData, index + 1,
                 size - index);
        elementData[index] = obj;
        size++;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用图表示这个过程是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190717231057696-1423737631.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的几个过程总结一下ArrayList的特点：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ArrayList底层以数组实现，是一种随机访问模式，通过下标索引定位数据，所以查找非常快&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已(这里指的末尾添加数据)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当删除元素的时候，涉及到一次元素复制移位，如果要复制的元素很多，那么就会比较耗费性能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当插入元素的时候，涉及到一次元素复制移位，如果要复制的元素很多，那么就会比较耗费性能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，ArrayList比较适合顺序添加、随机访问的场景。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jul 2019 23:37:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官Q1：可以手写一个ArrayList的简单实现吗？ 我们都知道ArrayList是基于数组实现，如果让你实现JDK源码ArrayList中add()、remove()、get()方法，你知道如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11204338.html</dc:identifier>
</item>
<item>
<title>手把手教你完成数字动态变化显示效果 - 三人行工作室</title>
<link>http://www.cnblogs.com/timeddd/p/11204774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timeddd/p/11204774.html</guid>
<description>&lt;h2 id=&quot;目标&quot;&gt;1.目标&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以液晶电子表样式，&lt;strong&gt;动态变化&lt;/strong&gt;的在&lt;strong&gt;指定元素&lt;/strong&gt;内显示&lt;strong&gt;数字&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;目标关键词&lt;/strong&gt;：动态变化（定时器），指定元素（DOM元素ID），数字（number）&lt;br/&gt;&lt;strong&gt;效果&lt;/strong&gt;：多个页面元素中，均以动态效果显示不同的数字，可正可负。并动态改变至少一个元素内的数据。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;2.基本原理&lt;/h2&gt;
&lt;p&gt;（1） &lt;strong&gt;液晶电子表样式&lt;/strong&gt;，找一种&lt;strong&gt;液晶电子表字体&lt;/strong&gt;即可，无须使用别的绘制技巧。&lt;br/&gt;（2） &lt;strong&gt;动态变化&lt;/strong&gt;则通过使用定时器任务来完成，动态显示要确保变化足够的时长，因此，步长需要根据变化量来进行计算，本文默认变化频率为 50 毫秒一次，动态过程 2 秒（即 2000 毫秒），则变化次数为 40 次，因此步长为变化量除以 40 得到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577842/201907/577842-20190718072804917-1649327667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其余则均为规则约束与控制，如支持多元素隔离，动态变化的结束条件，步长计算的方向与时长控制等。&lt;/p&gt;
&lt;h2 id=&quot;步步实现&quot;&gt;3.步步实现&lt;/h2&gt;
&lt;h3 id=&quot;下载字体定义字体名称&quot;&gt;3.1下载字体定义字体名称&lt;/h3&gt;
&lt;p&gt;最后提供的源码会包含字体文件。在css中定义字体名称以便样式引用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@font-face {
    font-family: LEDFont;
    src: url(&quot;./UnidreamLED.ttf&quot;);  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来定义显示数字的元素样式，其中便使用到刚定义的字体名称 LEDFont。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.dynanum{
    font-family: LEDFont;
    font-size: 48px;
    color:red;
    padding:10px;
    margin:10px;
    display:inline-block;
    width:200px;
    text-align:right;
    border:1px solid #bbbbff;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接口定义&quot;&gt;3.2接口定义&lt;/h3&gt;
&lt;p&gt;使用者能提供的就是有显示的 &lt;strong&gt;DOM元素ID&lt;/strong&gt;，和要显示的&lt;strong&gt;数值&lt;/strong&gt;，那这里向外提供的接口方法就出来了，形如：&lt;code&gt;function (elementId, number)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;支持多元素操作&quot;&gt;3.3支持多元素操作&lt;/h3&gt;
&lt;p&gt;为了支持多元素的简易操作，这里定义DOM元素ID与对象的映射变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var DynamicNumber = {};
DynamicNumber.NumberList = {};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;绘制的实现&quot;&gt;3.4绘制的实现&lt;/h3&gt;
&lt;p&gt;直接代码说话。嗯，这里说明一下重点。对于实际绘制的对象，接口中以匿名函数的方式创建，在首次涉及到某DOM元素ID时进行创建。如果已经创建，则直接调用 render 方法，调用之前，除了设置新的目标数值，还会清除步长 step，表示需要重新计算步长，当然这些都是封装在接口内部，调用者不需要关心。&lt;/p&gt;
&lt;p&gt;对于绘制方法 render，它所完成的是一步变化的绘制，期间进行结束条件的判断，并在 step 为 0 时进行步长的首次计算工作，最后再使用 setTimeout 启动下一步的定时任务。&lt;/p&gt;
&lt;p&gt;详细代码及注释如下，欢迎留言交流。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
    * 在指定的 DOM 元素中动态显示数值
    * 作者：triplestudio@sina.com
    *
    * @param elementId  :      DOM 元素ID
    * @param number     :      数值
    */
DynamicNumber.show = function (elementId, number) {
    // 1. 已建立过对象直接调用
    var dynaNum = this.NumberList[elementId];
    if (dynaNum) {
        dynaNum.step = 0;
        dynaNum.desNumber = number;
        dynaNum.render();
        return;
    }

    // 2. 创建动态数字绘制对象
    dynaNum = new function (_elementId) {
        this.elementId = _elementId;
        this.preNumber = 0; // 变化过程值
        this.desNumber = 0; // 目标数值，最终显示值

        this.step = 0;      // 变化步长，支持正向反向
        // 绘制过程
        this.render = function () {
            // （1）结束条件
            if (this.preNumber == this.desNumber) {
                this.step = 0;
                return;
            }

            // （2）步长设置（计划 2 秒完成 40*50=2000）
            if (this.step == 0) {
                this.step = Math.round((this.desNumber - this.preNumber) / 40);
                if (this.step == 0) this.step = (this.desNumber - this.preNumber &amp;gt; 0) ? 1 : -1;
            }

            // （3）走一步
            this.preNumber += this.step;
            if (this.step &amp;lt; 0) {
                if (this.preNumber &amp;lt; this.desNumber) this.preNumber = this.desNumber;
            } else {
                if (this.preNumber &amp;gt; this.desNumber) this.preNumber = this.desNumber;
            }

            // （4）显示
            document.getElementById(this.elementId).innerHTML = this.preNumber;

            // （5）每秒绘制 20 次（非精确值）
            var _this = this;
            setTimeout(function () { _this.render(); }, 50);
        };
    } (elementId);

    // 3. 登记绑定元素ID 
    DynamicNumber.NumberList[elementId] = dynaNum;

    // 4. 调用绘制
    dynaNum.step = 0;
    dynaNum.desNumber = number;
    dynaNum.render();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;4.使用方式&lt;/h2&gt;
&lt;p&gt;如接口所定义，使用者只需要关心DOM元素ID与数值即可。这里，我们再用一个定时器，每5秒钟改变一个数值来看看值变化时的动态效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DynamicNumber.show(&quot;num1&quot;, 128);
DynamicNumber.show(&quot;num2&quot;, 12345);
DynamicNumber.show(&quot;num3&quot;, -8769);
DynamicNumber.show(&quot;num4&quot;, 987102);
DynamicNumber.show(&quot;num5&quot;, -30);
// 每 5 秒把 num1 中的数值改变
setInterval(function () { 
    DynamicNumber.show(&quot;num1&quot;, DynamicNumber.NumberList[&quot;num1&quot;].desNumber + 300);
}, 5000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577842/201907/577842-20190718074056070-1155752829.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;5.源码下载：&lt;/h2&gt;
&lt;p&gt;关注时间维度公众号，回复&quot;动态数字&quot;即可获得。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 23:29:00 +0000</pubDate>
<dc:creator>三人行工作室</dc:creator>
<og:description>1.目标 以液晶电子表样式， 动态变化 的在 指定元素 内显示 数字 。 目标关键词 ：动态变化（定时器），指定元素（DOM元素ID），数字（number） 效果 ：多个页面元素中，均以动态效果显示不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/timeddd/p/11204774.html</dc:identifier>
</item>
<item>
<title>数据结构-树以及深度、广度优先遍历（递归和非递归，python实现） - 浩然haoran</title>
<link>http://www.cnblogs.com/dongyangblog/p/11204612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongyangblog/p/11204612.html</guid>
<description>&lt;p&gt;前面我们介绍了队列、堆栈、链表，你亲自动手实践了吗？今天我们来到了树的部分，树在数据结构中是非常重要的一部分，树的应用有很多很多，树的种类也有很多很多，今天我们就先来创建一个普通的树。其他各种各样的树将来我将会一一为大家介绍，记得关注我的文章哦~&lt;/p&gt;
&lt;p&gt;首先，树的形状就是类似这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12169235-7b2f2072d59dcd24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一棵树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它最顶上面的点叫做树的根节点，一棵树也只能有一个根节点，在节点下面可以有多个子节点，子节点的数量，我们这里不做要求，而没有子节点的节点叫做叶子节点。&lt;/p&gt;
&lt;p&gt;好，关于树的基本概念就介绍到这里了，话多千遍不如动手做一遍，接下来我们边做边学，我们来创建一棵树：&lt;/p&gt;
&lt;h2 id=&quot;树&quot;&gt;树&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 定义一个普通的树类
class Tree:
    def __init__(self, data):
        self.data = data
        self.children = []

    def get(self):
        return self.data
    
    def set(self):
        return self.data

    def addChild(self, child):
        self.children.append(child)

    def getChildren(self):
        return self.children&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是我们定义好的树类了，并给树添加了三个方法，分别是获取节点数据、设置节点数据、添加子节点、获取子节点。&lt;/p&gt;
&lt;p&gt;这里的树类其实是一个节点类，很多个这样的节点可以构成一棵树，而我们就用根节点来代表这颗树。&lt;/p&gt;
&lt;p&gt;接下来我们实例化一棵树：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 初始化一个树
tree = Tree(0)
# 添加三个子节点
tree.addChild(Tree(1))
tree.addChild(Tree(2))
tree.addChild(Tree(3))
children = tree.getChildren()
# 每个子节点添加两个子节点
children[0].addChild(Tree(4))
children[0].addChild(Tree(5))
children[1].addChild(Tree(6))
children[1].addChild(Tree(7))
children[2].addChild(Tree(8))
children[2].addChild(Tree(9))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们实例化好的树大概是这个样子的：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12169235-e5daea9fd4eff585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，我们的树已经实例化好了，我们先来对它分别采用递归和非递归的方式进行广度优先遍历:&lt;/p&gt;
&lt;h3 id=&quot;广度优先遍历&quot;&gt;广度优先遍历&lt;/h3&gt;
&lt;p&gt;广度优先遍历，就是从上往下，一层一层从左到右对树进行遍历。&lt;/p&gt;
&lt;p&gt;在用非递归方式进行广度优先遍历的时候，我们需要用到前面介绍过的队列类型，所以我们来定义一个队列类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 用以实现广度优先遍历
class Queue():
    def __init__(self):
        self.__list = list()

    def isEmpty(self):
        return self.__list == []

    def push(self, data):
        self.__list.append(data)
    
    def pop(self):
        if self.isEmpty():
            return False
        return self.__list.pop(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用队列实现广度优先遍历&quot;&gt;用队列实现广度优先遍历&lt;/h4&gt;
&lt;p&gt;利用队列我们只要在节点出队的时候让该节点的子节点入队即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 广度优先遍历
def breadthFirst(tree):
    queue = Queue()
    queue.push(tree)
    result = []
    while not queue.isEmpty():
        node = queue.pop()
        result.append(node.data)
        for c in node.getChildren():
            queue.push(c)
    return result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(breadthFirst(tree))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归实现广度优先遍历&quot;&gt;递归实现广度优先遍历&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 递归方式实现广度优先遍历
def breadthFirstByRecursion(gen, index=0, nextGen=[], result=[]):
    
    if type(gen) == Tree:
        gen = [gen]
    result.append(gen[index].data)
    
    children = gen[index].getChildren()
    
    nextGen += children
    if index == len(gen)-1:
        if nextGen == []:
            return
        else:
            gen = nextGen
            nextGen = []
            index = 0
    else:
        index += 1
    breadthFirstByRecursion(gen, index, nextGen,result)

    return result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(breadthFirstByRecursion(tree))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;深度优先遍历&quot;&gt;深度优先遍历&lt;/h3&gt;
&lt;p&gt;深度优先遍历，就是从上往下，从左到右，先遍历节点的子节点再遍历节点的兄弟节点。&lt;/p&gt;
&lt;p&gt;采用非递归方式实现深度优先遍历呢，我们需要用到前面介绍过的堆栈结构，所以我们现在定义一个堆栈类吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 用以实现深度优先遍历
class Stack():
    def __init__(self):
        self.__list = list()

    def isEmpty(self):
        return self.__list == []

    def push(self, data):
        self.__list.append(data)
    
    def pop(self):
        if self.isEmpty():
            return False
        return self.__list.pop()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;利用堆栈实现深度优先遍历&quot;&gt;利用堆栈实现深度优先遍历&lt;/h4&gt;
&lt;p&gt;实现深度优先遍历，我们只要在节点出栈的时候把该节点的子节点从左到右压入堆栈即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 深度优先遍历
def depthFirst(tree):
    stack = Stack()
    stack.push(tree)
    result = []
    while not stack.isEmpty():
        node = stack.pop()
        result.append(node.data)
        children = node.getChildren()
        children = reversed(children)
        for c in children:
            stack.push(c)
    return result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 深度优先遍历
print(depthFirst(tree))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;code&gt;[0, 1, 4, 5, 2, 6, 7, 3, 8, 9]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归实现深度优先遍历&quot;&gt;递归实现深度优先遍历&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 递归方式实现深度优先遍历
def depthFirstByRecursion(tree, result=[]):
    result.append(tree.data)
    children = tree.getChildren()
    for c in children:
        depthFirstByRecursion(c, result)
    return result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(depthFirstByRecursion(tree))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;code&gt;[0, 1, 4, 5, 2, 6, 7, 3, 8, 9]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;好啦，今天我们的树就介绍到这里了，对于广度优先遍历的递归实现，你有更好的方法吗？请留言告诉我吧。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 17:08:00 +0000</pubDate>
<dc:creator>浩然haoran</dc:creator>
<og:description>前面我们介绍了队列、堆栈、链表，你亲自动手实践了吗？今天我们来到了树的部分，树在数据结构中是非常重要的一部分，树的应用有很多很多，树的种类也有很多很多，今天我们就先来创建一个普通的树。其他各种各样的树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongyangblog/p/11204612.html</dc:identifier>
</item>
<item>
<title>Java开发IDEA插件推荐 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/11204565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/11204565.html</guid>
<description>&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;



&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;IDEA插件推荐&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在我的manjarog更新软件的时候，我发现我IDEA所有插件全部消失了。这篇博客主要是用来记录我常用的一些插件。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Alibaba Java Coding Guidelines&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;相信看过《阿里巴巴Java开发规范》的同学们，都感觉到一种莫名的爽意了吧，从此告别随意命名。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;为了让开发者更加方便、快速将规范推动并实行起来，阿里巴巴基于手册内容，研发了一套自动化的IDE检测插件（IDEA、Eclipse）。该插件在扫描代码后，将不符合规约的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，我们还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能，如此爽心悦目的功能是不是很值得拥有？提升代码质量，提高团队研发效能，插件将会一路同行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;MyBatisCodeHelper-Pro&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;刚开始我是使用免费版的，然后也不觉得免费版的与付费版有什么区别，后来感觉这个插件挺好用的，觉得要去支持一下作者，就买了1年的激活码（价格：29元2个激活码一年），然后就发现再也回不去了。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;下面是免费版与付费版本的区别：&lt;/p&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能点&lt;/th&gt;
&lt;th&gt;未激活版&lt;/th&gt;
&lt;th&gt;激活版&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;接口与xml互相跳转 更换图标&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口方法名重构&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;一键添加param&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;xml中的 param的自动提示 if test的自动提示 resultMap refid 等的自动提示&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;resultMap中的property的自动提示&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;检测没有使用的xml 可一键删除&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;检测mybatis接口中方法是否有实现，没有则报红 可创建一个空的xml方法块&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;检测resultmap的property是否有误&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;支持spring 将mapper注入到spring中 intellij的spring注入不再报错 支持springboot&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;一键生成分页查询&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;一键添加resultMap中未被使用的属性&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;一键生成mybatis接口的testcase&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通过方法名生成sql&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;通过数据库生成crud代码&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;通过java类生成crud代码&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;xml collection中的 param提示&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;识别mybatis的标签 全自动sql补全&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;检测#{中的参数是否正确&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;if test when test foreach collection $中的OGNL支持&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;param重构功能(2.7.2)&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Lombok&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;相信大家写Java bean的时候一定写过很多的getter和setter或者说toString，尽管在IDEA中，我们可以一键生成，但是这样会导致代码很臃肿。而在Lombok中使用简单的@Data便可以解决这个问题。 怎么使用我就不说了，大家可以看这里。&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://zhuanlan.zhihu.com/p/32779910&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;GsonFormat&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;当我们需要根据json去生成实体对象时，使用 GsonFormat就可以一键生成了。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;按住Alt+S打开GsonFormat，然后输入json数据，点击OK 选择需要的变量，即可一键生成相应的实体对象了。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;AceJump&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;解放你的鼠标， 如何不用来快速i定位你的光标位置，AceJump是你的不二选择。它允许您快速将光标导航到编辑器中可见的任何位置！只需点击“ctrl +;”，然后输入一个你想要跳转到的字符，就可以进行跳转了。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Statistic&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;想看自己代码写了多少行，使用Statistic轻轻松松统计。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190718003403391-311710775.png&quot; alt=&quot;&quot; name=&quot;stati.png&quot; data-src=&quot;./stati.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Translation&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;作用不解释，装完之后会在右上角有两个翻译的图标。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190718003408043-1725509347.png&quot; alt=&quot;&quot; name=&quot;深度截图_选择区域_20190718001353.png&quot; data-src=&quot;./%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190718001353.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;Grep console&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;如何让日志有颜色，不再是白色与红色，Grep console了解下。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;CodeGlance&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;让你的IDEAE也拥有小地图。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190718003414086-1199147085.png&quot; alt=&quot;&quot; name=&quot;深度截图_选择区域_20190718002129.png&quot; data-src=&quot;./%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190718002129.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;当我发现有好的插件时，我会更新这篇博客,同时欢迎在评论区留言 。我们之所以花时间去找插件和装插件，是为了更好的去开发写代码。正所谓磨刀不误砍柴工，当我们选择的插件解放我们的重复劳动力时，我们才能有更多的时间去思考，而不是一味的做重复且枯燥的事情。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 16:34:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>IDEA插件推荐 Alibaba Java Coding Guidelines MyBatisCodeHelper-Pro Lombok GsonFormat AceJump Statistic Tr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/11204565.html</dc:identifier>
</item>
</channel>
</rss>