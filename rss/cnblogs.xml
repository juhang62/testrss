<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何用Java8 Stream API找到心仪的女朋友 - 逃离沙漠</title>
<link>http://www.cnblogs.com/demingblog/p/12375663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demingblog/p/12375663.html</guid>
<description>&lt;p&gt;传统的的Java 集合操作是有些啰嗦的，当我们需要对结合元素进行过滤，排序等操作的时候，通常需要写好几行代码以及定义临时变量。&lt;br/&gt;而Java8 Stream API 可以极大简化这一操作，代码行数少，且易读。&lt;/p&gt;
&lt;p&gt;我们以“找女朋友”为例来看看Java8的Stream API相比传统写法有多香。假设我们定义了一个女朋友类，具有几个关键的指标：姓名，身高，体重，颜值。如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Girl {
    private String name;
    private int height;
    private int weight;
    private int score;
    // 省略get,set及hashCode等方法
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们有一批适龄女青年名单，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static List&amp;lt;Girl&amp;gt; initGirlList(){
    List&amp;lt;Girl&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    result.add(new Girl(&quot;赵小花&quot;,170,60,6));
    result.add(new Girl(&quot;钱小花&quot;,171,62,7));
    result.add(new Girl(&quot;孙小花&quot;,172,59,8));
    // 省略.... 
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;心仪女朋友的筛选条件&quot;&gt;心仪女朋友的筛选条件&lt;/h2&gt;
&lt;p&gt;假设心仪的女朋友是：体重，身高适中，颜值越高越好。本次设置的条件是找出：身高&amp;gt;=162 并且 体重&amp;lt;=53的女孩，然后按颜值排序前三名。&lt;/p&gt;
&lt;h2 id=&quot;java7的写法&quot;&gt;Java7的写法&lt;/h2&gt;
&lt;h3 id=&quot;数据去重&quot;&gt;数据去重&lt;/h3&gt;
&lt;p&gt;由于数据可能有重复，这会干扰我们的筛选，因此，第一步先去掉重复数据。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Girl&amp;gt; girlList = initGirlList();// 初始化一批数据
// 数据去重
List&amp;lt;Girl&amp;gt; distinctGirl = new ArrayList&amp;lt;&amp;gt;();
for (Girl g: girlList){
    if(!distinctGirl.contains(g)){
        distinctGirl.add(g);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里new了一个新的&lt;code&gt;distinctGirl&lt;/code&gt;来存放去重之后的数据，代码很简单，没啥可说的。&lt;/p&gt;
&lt;h3 id=&quot;筛选数据&quot;&gt;筛选数据&lt;/h3&gt;
&lt;p&gt;下面我们要去掉不合格的数据，本次筛选条件是身高&amp;gt;=162 并且 体重&amp;lt;=53，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 过滤身高，体重不符合的
List&amp;lt;Girl&amp;gt; girlTemp = new ArrayList&amp;lt;&amp;gt;();
for(Girl g: distinctGirl){
    if(g.getHeight() &amp;gt;= 162 &amp;amp;&amp;amp; g.getWeight() &amp;lt;= 53){
        girlTemp.add(g);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里运用上一步中去重之后的&lt;code&gt;distinctGirl&lt;/code&gt;,遍历，并将符合条件的放入新的list &lt;code&gt;girlTemp&lt;/code&gt;，这里又创建了一个中间list。&lt;/p&gt;
&lt;h3 id=&quot;数据排序&quot;&gt;数据排序&lt;/h3&gt;
&lt;p&gt;经过上面啰嗦的两步，我们得到了符合我们要求的数据，现在我们需要根据颜值高低进行排名，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collections.sort(girlTemp, new Comparator&amp;lt;Girl&amp;gt;() {
    @Override
    public int compare(Girl g1, Girl g2) {
        BigDecimal score1 = new BigDecimal(g1.getScore());
        BigDecimal score2 = new BigDecimal(g2.getScore());
        return score2.subtract(score1).intValue();
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了&lt;code&gt;Collections&lt;/code&gt;工具类的&lt;code&gt;sort&lt;/code&gt;方法，传递了一个匿名类，并在其&lt;code&gt;compare&lt;/code&gt;方法中实现了排序的逻辑，这依然是传统集合排序的操作。&lt;/p&gt;
&lt;h3 id=&quot;输出结果&quot;&gt;输出结果&lt;/h3&gt;
&lt;p&gt;经过上面的几步传统的Java集合操作，我们终于得到了想要的数据。现在我们要输出前三名。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int i = 1;
for (Girl g : girlTemp) {
    if(i&amp;gt;=3){
        break;
    }
    System.out.println(g.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，至此我们的程序输出了筛选的结果。上面的写法，貌似逻辑很清晰，一步步徐徐渐进。是的，这种传统的写法，Java程序员们已经乐呵呵的写了很多年了。&lt;br/&gt;一看这个代码足足有20多行！可是实现的逻辑并没有太复杂啊？过阵子你回头看这个代码的话，你多半忘记了这么一大段代码是干嘛的。如果有注释还好，你大概扫一一眼能帮助你快速理清代码做了啥。如果没有注释，你需要逐行去读完这20多行代码，才能明白其逻辑。&lt;/p&gt;
&lt;h2 id=&quot;java8-stream-api的写法&quot;&gt;Java8 Stream API的写法&lt;/h2&gt;
&lt;p&gt;这里我们在回顾一下，我们的目标：从一个girlList中找出：身高&amp;gt;=162 并且 体重&amp;lt;=53的女孩，然后按颜值排序前三名。Java8的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Girl&amp;gt; girlList = initGirlList();
girlList.stream()
        .filter( g -&amp;gt; g.getHeight() &amp;gt;= 162 &amp;amp;&amp;amp; g.getWeight() &amp;lt;= 53)
        .distinct()
        .sorted(Comparator.comparing(Girl::getScore).reversed())
        .limit(3)
        .forEach( g -&amp;gt; System.out.println(g.toString()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码6行！并且即使不了解Stream API，且你第一次看这个代码也能猜出是什么意思，filter-过滤，distinct-去重，sort-排序，limit-限制条数，forEach-遍历，就这么简单。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;Java 这么老语言，如今都Java13了，然而，最具影响的版本我认为还是Java8。我上学那会儿，学校用Java6的写法教学。工作之后开始写Java7的&lt;code&gt;try-with-resource&lt;/code&gt;、钻石语法等。一直到现在，市面上很多项目都是Java7。有一次有同事给我说他在前公司写Java8被项目经理说了一顿，我问为啥。他说因为项目经理认为写Java7好维护，团队人人都会写Java7，写Java8的人不多……无语凝噎。&lt;/p&gt;
&lt;p&gt;如果你还没用上Java8，但愿本文中的小例子已经成功的勾起了你用上Java8的兴致。问卷：&lt;a href=&quot;https://wj.qq.com/s2/5539533/b113/&quot;&gt;你现在使用的版本是多少？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/demingblog/1407293/o_taolishamo.jpg&quot; alt=&quot;alt 逃离沙漠公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>逃离沙漠</dc:creator>
<og:description>传统的的Java 集合操作是有些啰嗦的，当我们需要对结合元素进行过滤，排序等操作的时候，通常需要写好几行代码以及定义临时变量。 而Java8 Stream API 可以极大简化这一操作，代码行数少，且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/demingblog/p/12375663.html</dc:identifier>
</item>
<item>
<title>曹工说Spring Boot源码（20）-- 码网灰灰，疏而不漏，如何记录Spring RedisTemplate每次操作日志 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12375656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12375656.html</guid>
<description>&lt;p&gt;相关背景及资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12044199.html&quot;&gt;曹工说Spring Boot源码（1）-- Bean Definition到底是什么，附spring思维导图分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12051957.html&quot;&gt;曹工说Spring Boot源码（2）-- Bean Definition到底是什么，咱们对着接口，逐个方法讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12070377.html&quot;&gt;曹工说Spring Boot源码（3）-- 手动注册Bean Definition不比游戏好玩吗，我们来试一下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12078673.html&quot;&gt;曹工说Spring Boot源码（4）-- 我是怎么自定义ApplicationContext，从json文件读取bean definition的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12093929.html&quot;&gt;曹工说Spring Boot源码（5）-- 怎么从properties文件读取bean&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12114604.html&quot;&gt;曹工说Spring Boot源码（6）-- Spring怎么从xml文件里解析bean的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12151809.html&quot;&gt;曹工说Spring Boot源码（7）-- Spring解析xml文件，到底从中得到了什么（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12158935.html&quot;&gt;曹工说Spring Boot源码（8）-- Spring解析xml文件，到底从中得到了什么（util命名空间）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12189842.html&quot;&gt;曹工说Spring Boot源码（9）-- Spring解析xml文件，到底从中得到了什么（context命名空间上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12199334.html&quot;&gt;曹工说Spring Boot源码（10）-- Spring解析xml文件，到底从中得到了什么（context:annotation-config 解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12203743.html&quot;&gt;曹工说Spring Boot源码（11）-- context:component-scan，你真的会用吗（这次来说说它的奇技淫巧）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12214408.html&quot;&gt;曹工说Spring Boot源码（12）-- Spring解析xml文件，到底从中得到了什么（context:component-scan完整解析)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12228958.html&quot;&gt;曹工说Spring Boot源码（13）-- AspectJ的运行时织入（Load-Time-Weaving），基本内容是讲清楚了（附源码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12283544.html&quot;&gt;曹工说Spring Boot源码（14）-- AspectJ的Load-Time-Weaving的两种实现方式细细讲解，以及怎么和Spring Instrumentation集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12288391.html&quot;&gt;曹工说Spring Boot源码（15）-- Spring从xml文件里到底得到了什么（context：load-time-weaver 完整解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12314954.html&quot;&gt;曹工说Spring Boot源码（16）-- Spring从xml文件里到底得到了什么（aop：config完整解析【上】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12317612.html&quot;&gt;曹工说Spring Boot源码（17）-- Spring从xml文件里到底得到了什么（aop：config完整解析【中】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12322587.html&quot;&gt;曹工说Spring Boot源码（18）-- Spring AOP源码分析三部曲，终于快讲完了 (aop：config完整解析【下】)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12359963.html&quot;&gt;曹工说Spring Boot源码（19）-- Spring 带给我们的工具利器，创建代理不用愁（ProxyFactory）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/spring-boot-first-version-learn&quot;&gt;工程代码地址&lt;/a&gt; &lt;a href=&quot;https://www.processon.com/view/link/5deeefdee4b0e2c298aa5596&quot;&gt;思维导图地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工程结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191215144930717-1919774390.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本篇是独立的，和前面几篇aop相关分析没有特别关联，但是使用了上一篇提到的工具类。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12359963.html&quot;&gt;曹工说Spring Boot源码（19）-- Spring 带给我们的工具利器，创建代理不用愁（ProxyFactory）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前也使用类似的思路，实现过完整sql日志记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12130803.html&quot;&gt;曹工杂谈--使用mybatis的同学，进来看看怎么在日志打印完整sql吧，在数据库可执行那种&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两天在搬砖，有个需求，是统计类的。一般来说，统计类的东西，比如要统计：用户总数，用户的新增总数，当天每个小时为维度的新增数量，各个渠道的新增用户数量；这些，可能都得在redis里维护，然后某个用户注册时，去把所有这些redis结构+1。&lt;/p&gt;
&lt;p&gt;但这种代码，一般入口很多，修改这些值的地方很多，编码时很容易发生遗漏，或者编码错误，导致最后统计数据不准确。数据不准确，当然是bug，问题是，这种bug还不好排查。&lt;/p&gt;
&lt;p&gt;如果能够记录下redis操作日志就好了。&lt;/p&gt;
&lt;p&gt;以下，是我已经实现的效果，这是一次请求中的一次redis操作，可以看到，是put方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202002/519126-20200228081057455-1436295322.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们用的是spring boot 2.1.7，直接集成的RedisTemplate。当然，只要是使用RedisTemplate即可，和spring boot没多大关系。&lt;/p&gt;
&lt;p&gt;我看了下我们平时是怎么去操作redis 的hash结构的，大概代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
@Qualifier(&quot;redisTemplate&quot;)
private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;

HashOperations&amp;lt;String, HK, HV&amp;gt; ops = redisTemplate.opsForHash();
ops.put(key, hashKey,fieldValue);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般就是，先通过opsForHash，拿到HashOperations，再去操作hash结构。&lt;/p&gt;
&lt;p&gt;我现在的想法就是，在执行类似ops的put的方法之前，把那几个参数记录到日志里。&lt;/p&gt;
&lt;p&gt;要想让ops记录我们的日志，我们只能拦截其每个方法，这一步就得使用一个代理对象，去替换掉真实的对象。&lt;/p&gt;
&lt;p&gt;但是，怎么才能让redisTemplate.opsForHash()返回的ops，是我们代理过的对象呢？&lt;/p&gt;
&lt;p&gt;所以，这一步，还得在生成redisTemplate的地方下功夫，让其生成一个redisTemplate的代理对象，这个代理对象，拦截opsForHash方法。&lt;/p&gt;
&lt;p&gt;总结下，需要做两件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对redisTemplate做代理，拦截opsForHash方法；&lt;/li&gt;
&lt;li&gt;在拿到第一步的原有的ops对象后，对ops对象做代理，拦截其put方法等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;原有代码&quot;&gt;原有代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String,Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setValueSerializer(new CustomGenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new CustomHashKeyRedisSerializer());
        template.setKeySerializer(RedisSerializer.string());
        template.setHashValueSerializer(new CustomGenericJackson2JsonRedisSerializer());

        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代理redistemplate&quot;&gt;代理RedisTemplate&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
    public RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String,Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setValueSerializer(new CustomGenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new CustomHashKeyRedisSerializer());
        template.setKeySerializer(RedisSerializer.string());
        template.setHashValueSerializer(new CustomGenericJackson2JsonRedisSerializer());

        template.setConnectionFactory(redisConnectionFactory);

        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.setTarget(template);
        proxyFactory.setProxyTargetClass(true);
        proxyFactory.addAdvice(new MethodInterceptor() {
            @Override
            public Object invoke(MethodInvocation invocation) throws Throwable {
                //拦截opsForHash
                boolean b = invocation.getMethod().getName().equals(&quot;opsForHash&quot;);
                if (b) {
                    // todo，下一步再完善这里
                }

                return invocation.proceed();
            }
        });
        //这里获取到针对template的代理对象，并返回
        Object proxy = proxyFactory.getProxy();
        return (RedisTemplate&amp;lt;String, Object&amp;gt;) proxy;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以仔细看上面的代码，利用了前一讲我们学习了的ProxyFactory，来生成代理；使用它呢，比较方便，不用管底层它是用jdk动态代理，还是cglib代理，spring已经帮我们处理好了。&lt;/p&gt;
&lt;p&gt;总之，上面这段，就是把redisTemplate给换了。我们具体要在拦截了opsForHash里，做什么动作呢？我们再看。&lt;/p&gt;
&lt;h2 id=&quot;代理opsforhash的返回结果&quot;&gt;代理opsForHash的返回结果&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
    public RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String,Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setValueSerializer(new CustomGenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new CustomHashKeyRedisSerializer());
        template.setKeySerializer(RedisSerializer.string());
        template.setHashValueSerializer(new CustomGenericJackson2JsonRedisSerializer());

        template.setConnectionFactory(redisConnectionFactory);

        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.setTarget(template);
        proxyFactory.setProxyTargetClass(true);
        proxyFactory.addAdvice(new MethodInterceptor() {
            @Override
            public Object invoke(MethodInvocation invocation) throws Throwable {
                boolean b = invocation.getMethod().getName().equals(&quot;opsForHash&quot;);
                if (b) {
                    // 1. 这一步，拿到原有的opsForHash的返回结果
                    HashOperations hashOperations = (HashOperations) invocation.proceed();
                    
                    //2. 下边，对hashOperations进行代理
                    ProxyFactory proxyFactory = new ProxyFactory();
                    proxyFactory.setTarget(hashOperations);
                    proxyFactory.setProxyTargetClass(false);
                    proxyFactory.setInterfaces(HashOperations.class);
                    //3. 我们这个代理干什么事呢，就是加了一个方法前的拦截器，记录日志
                    proxyFactory.addAdvice(new MethodBeforeAdviceInterceptor(new MethodBeforeAdvice() {
                        // 使用fastjson格式化了参数，并记录到日志
                        @Override
                        public void before(Method method, Object[] args, Object target) {
                            log.info(&quot;method:{},args:{}&quot;,method.getName(),
                                    JSON.toJSONString(args, SerializerFeature.PrettyFormat));
                        }
                    }));
                   // 这里返回针对hashOperations的代理
                    return proxyFactory.getProxy();
                }

                return invocation.proceed();
            }
        });
        Object proxy = proxyFactory.getProxy();

        return (RedisTemplate&amp;lt;String, Object&amp;gt;) proxy;
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我这个拦截比较粗，现在是把get类的日志也打出来了。大家可以判断下method的名称，来自行过滤掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/202002/519126-20200228083132374-1411938924.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，本篇先到这里。下讲继续讲Spring ProxyFactory的内容。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 00:39:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>写在前面的话 相关背景及资源： &amp;quot;曹工说Spring Boot源码（1） Bean Definition到底是什么，附spring思维导图分享&amp;quot; &amp;quot;曹工说Spring B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12375656.html</dc:identifier>
</item>
<item>
<title>Django 博客单元测试：测试评论应用 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12372401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12372401.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200213202051843-983322874.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zmrenwu.com&quot;&gt;HelloGitHub-追梦人物&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4666666666667&quot;&gt;
&lt;p&gt;文中所涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;评论应用的测试和博客应用测试的套路是一样的。&lt;/p&gt;
&lt;p&gt;先来建立测试文件的目录结构。首先在 comments 应用的目录下建立一个名为 tests 的 Python 包，&lt;strong&gt;然后删除 comments 应用下 django 自动生成的 tests.py 文件，防止和 tests 包冲突&lt;/strong&gt;，再根据需要测试的内容，创建相应的 Python 模块。最终 tests 目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;comments\
    templatetags\
    models.py
    ...
    tests\
        __init__.py
        base.py
        test_models.py
        test_templatetags.py
        test_views.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 base.py 用于存放各个测试用例的公共的数据初始化基类。&lt;/p&gt;
&lt;h2 id=&quot;数据基类&quot;&gt;数据基类&lt;/h2&gt;
&lt;p&gt;由于评论必须和文章关联，因此我们首先来写一个数据基类，用于初始化生成文章数据，其它测试类继承这个数据基类，从而不用在每个测试类里都写一遍创建文章数据的代码了。&lt;/p&gt;
&lt;p&gt;数据基类写在 base.py 模块里：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;comments/tests/base.py

from django.apps import apps
from django.contrib.auth.models import User
from django.test import TestCase

from blog.models import Category, Post


class CommentDataTestCase(TestCase):
    def setUp(self):
        apps.get_app_config('haystack').signal_processor.teardown()
        self.user = User.objects.create_superuser(
            username='admin',
            email='admin@hellogithub.com',
            password='admin'
        )
        self.cate = Category.objects.create(name='测试')
        self.post = Post.objects.create(
            title='测试标题',
            body='测试内容',
            category=self.cate,
            author=self.user,
        )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意创建文章数据时，使用 &lt;code&gt;apps.get_app_config('haystack').signal_processor.teardown()&lt;/code&gt; 断开创建索引的信号。&lt;/p&gt;

&lt;p&gt;Comment Model 的代码逻辑比较简单，测试起来也很简单：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;comments/tests/test_models.py

from .base import CommentDataTestCase
from ..models import Comment


class CommentModelTestCase(CommentDataTestCase):
    def setUp(self):
        super().setUp()
        self.comment = Comment.objects.create(
            name='评论者',
            email='a@a.com',
            text='评论内容',
            post=self.post,
        )

    def test_str_representation(self):
        self.assertEqual(self.comment.__str__(), '评论者: 评论内容')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试视图函数&quot;&gt;测试视图函数&lt;/h2&gt;
&lt;p&gt;我们只有一个发表评论的视图函数，根据视图函数的逻辑，需要测试以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只处理 POST 请求，其它请求将返回 405 Method Not Allowed 错误码。&lt;/li&gt;
&lt;li&gt;如果评论的文章不存在，返回 404 错误码。&lt;/li&gt;
&lt;li&gt;如果提交的评论内容有错误（例如 email 格式不正确），将渲染 preview.html 预览页面，并且预览页面显示评论出错的消息提醒和评论表单中包含的错误。&lt;/li&gt;
&lt;li&gt;提交的内容合法，则创建评论，用户被重定向回被评论文章的详情页，页面中包含评论成功的消息提醒。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体代码如下（省略掉了一些简单的一看就懂的测试用例）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;comments/tests/test_views.py

from django.urls import reverse

from .base import CommentDataTestCase
from ..models import Comment


class CommentViewTestCase(CommentDataTestCase):
    def setUp(self):
        super().setUp()
        self.url = reverse('comments:comment', kwargs={'post_pk': self.post.pk})
    
    # 省略掉了一看就懂的测试用例...

    def test_invalid_comment_data(self):
        invalid_data = {
            'email': 'invalid_email',
        }
        response = self.client.post(self.url, invalid_data)
        self.assertTemplateUsed(response, 'comments/preview.html')
        self.assertIn('post', response.context)
        self.assertIn('form', response.context)
        form = response.context['form']
        for field_name, errors in form.errors.items():
            for err in errors:
                self.assertContains(response, err)
        self.assertContains(response, '评论发表失败！请修改表单中的错误后重新提交。')

    def test_valid_comment_data(self):
        valid_data = {
            'name': '评论者',
            'email': 'a@a.com',
            'text': '评论内容',
        }
        response = self.client.post(self.url, valid_data, follow=True)
        self.assertRedirects(response, self.post.get_absolute_url())
        self.assertContains(response, '评论发表成功！')
        self.assertEqual(Comment.objects.count(), 1)
        comment = Comment.objects.first()
        self.assertEqual(comment.name, valid_data['name'])
        self.assertEqual(comment.text, valid_data['text'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看到 &lt;code&gt;test_invalid_comment_data&lt;/code&gt; 测试用例。这个测试用例中，我们构造了一个缺失评论内容、评论人名字且邮箱格式不正确的数据，然后将其提交了评论。接着就是对预期结果的断言。这里关键的一点是，渲染的预览页面应该包含提示用户的表单错误。所以我们从响应的上下文变量中取得表单 form 这个模板变量。接着使用如下代码获取表单的错误并断言响应中是否包含了这些错误：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for field_name, errors in form.errors.items():
    for err in errors:
        self.assertContains(response, err)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦表单绑定了数据，并且 &lt;code&gt;is_valid&lt;/code&gt; 方法被调用，就会有一个 &lt;code&gt;errors&lt;/code&gt; 属性（参考评论视图函数中表单的处理逻辑）。&lt;code&gt;errors&lt;/code&gt; 属性是一个类字典对象，如果表单数据不包含错误，则为空；如果包含错误数据，则其键为包含错误数据的字段名称，值为该字段错误提示构成的列表（一个字段可能包含多个错误，所以是一个列表）。例如这里的 &lt;code&gt;form.errors&lt;/code&gt;，如果将其打印出来（使用 &lt;code&gt;print(repr(form.errors))&lt;/code&gt;，&lt;code&gt;str&lt;/code&gt; 方法返回的内容是经渲染的 ul 列表），可以看到它的内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;{'name': ['这个字段是必填项。'], 'email': ['输入一个有效的 Email 地址。'], 'text': ['这个字段是必填项。']}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test_valid_comment_data&lt;/code&gt; 中，我们构造合法的评论内容并提交，预期结果是评论提交成功后重定向到被评论文章的详情页，所以使用了 &lt;code&gt;assertRedirects&lt;/code&gt; 进行断言。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;self.client.post(self.url, valid_data, follow=True)&lt;/code&gt; 传入的 &lt;code&gt;follow=True&lt;/code&gt; 参数。由于评论成功后需要重定向，因此传入 &lt;code&gt;follow=True&lt;/code&gt;，表示跟踪重定向，因此返回的响应，是最终重定向之后返回的响应（即被评论文章的详情页），如果传入 False，则不会追踪重定向，返回的响应就是一个响应码为 302 的重定向前响应。&lt;/p&gt;
&lt;p&gt;对于重定向响应，使用 &lt;code&gt;assertRedirects&lt;/code&gt; 进行断言，这个断言方法会对重定向的整个响应的过程进行检测，默认检测的是响应码从 302 变为 200。&lt;/p&gt;
&lt;h2 id=&quot;测试模板标签&quot;&gt;测试模板标签&lt;/h2&gt;
&lt;p&gt;上一篇中介绍过模板标签的测试方法。基本套路就是代替 django 视图函数自动渲染模板内容的过程，手工构造一个包含待测试模板标签的模板，然后手工渲染其内容，断言渲染后的内容是否包含预期的内容。具体代码请看源代码，这里不再一一讲解，只将涉及的几个新的表单操作进行一个简单介绍。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CommentExtraTestCase(CommentDataTestCase):
        # ...省略其它测试用例的代码
    
    def test_show_comment_form_with_invalid_bound_form(self):
        template = Template(
            '{% load comments_extras %}'
            '{% show_comment_form post form %}'
        )
        invalid_data = {
            'email': 'invalid_email',
        }
        form = CommentForm(data=invalid_data)
        self.assertFalse(form.is_valid())
        context = Context(show_comment_form(self.ctx, self.post, form=form))
        expected_html = template.render(context)
        
        for field in form:
            label = '&amp;lt;label for=&quot;{}&quot;&amp;gt;{}：&amp;lt;/label&amp;gt;'.format(field.id_for_label, field.label)
            self.assertInHTML(label, expected_html)
            self.assertInHTML(str(field), expected_html)
            self.assertInHTML(str(field.errors), expected_html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到循环表单 form 的语句：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for field in form:
    label = '&amp;lt;label for=&quot;{}&quot;&amp;gt;{}：&amp;lt;/label&amp;gt;'.format(field.id_for_label, field.label)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里使用了 &lt;code&gt;field&lt;/code&gt; 的两个属性，&lt;code&gt;id_for_label&lt;/code&gt; 和 &lt;code&gt;id_for_label&lt;/code&gt;，分别是 django 表单自动生成的表单字段 label 的 id 和 label 名。别的就没什么好说的了，就是不停地断言页面包含预期的 HTML 内容。&lt;/p&gt;
&lt;p&gt;至此，我们完成了对 blog 应用和 comment 应用这两个核心 app 的测试。现在，我们想知道的是，到底我们的测试效果怎么样呢？测试充分吗？测试全面吗？还有没有没有测到的地方呢？&lt;/p&gt;
&lt;p&gt;单凭肉眼观察难以回答上面的问题，接下来我们就借助一个工具，从代码覆盖率的角度来检测一下我们的测试效果究竟如何。&lt;/p&gt;
&lt;h2 id=&quot;hellodjango-往期回顾&quot;&gt;HelloDjango 往期回顾：&lt;/h2&gt;
&lt;p&gt;第 29 篇：&lt;a href=&quot;https:////www.cnblogs.com/xueweihan/p/12336462.html&quot;&gt;编写 Django 应用单元测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第 28 篇：&lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/12304983.html&quot;&gt;Django Haystack 全文检索与关键词高亮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第 27 篇：&lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/12171812.html&quot;&gt;开启 Django 博客实现简单的全文搜索&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200213201956024-782757549.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 00:37:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub 追梦人物&amp;quot; 文中所涉及的示例代码，已同步更新到 &amp;quot;HelloGitHub Team 仓库&amp;quot; 评论应用的测试和博客应用测试的套路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12372401.html</dc:identifier>
</item>
<item>
<title>诡异的并发之可见性 - 淼淼之森</title>
<link>http://www.cnblogs.com/mmzs/p/12357918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmzs/p/12357918.html</guid>
<description>&lt;p&gt;可见性的定义是：一个线程对共享变量的修改，另外一个线程能够立刻看到&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;211.55834475668&quot;&gt;
&lt;p&gt;我们都知道，随着祖国越来越繁荣昌盛，随着科技的进步，设备的更新换代，计算机体系结构、操作系统、编译程序都在不断地改革创新，但始终有一点是不变的（我对鸭血粉丝的热爱忠贞不渝）：那就是下面三者的性能耗时：CPU &amp;lt; 内存 &amp;lt; I/O&lt;/p&gt;
&lt;p&gt;但也正因为这些改变，也就在并发程序中出现了一些诡异的问题，而其中最昭著的三大问题就是：可见性、有序性、原子性。&lt;/p&gt;
&lt;p&gt;今天我们就主要来学习一下三者中的可见性。&lt;/p&gt;
&lt;h2 id=&quot;零可见性的阐述&quot;&gt;零、可见性的阐述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可见性&lt;/strong&gt; 的定义是：一个线程对共享变量的修改，另外一个线程能够立刻看到。&lt;/p&gt;
&lt;p&gt;在单核时代，所有线程都在一个CPU上执行，所以一个线程的写，一定是对其它线程可见的。就好比，一个总经理下面就一个项目负责人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200222144516135-857539479.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，项目经理查看到任务G后，分配给员工A和员工B，那么这个任务的进度就能随时掌握在项目经理手中了；每个员工都能从项目经理处得知最新的项目进度。&lt;/p&gt;
&lt;p&gt;而在多核时代后，每个CPU都有自己的缓存，这就出现了可见性问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200222144334177-712524556.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，两个项目经理同时查看到任务G后，各自分配给自己下属员工，那么这个任务的进度就只能掌握在各自项目经理手中了，因为所有员工的工作进度并不是汇报给同一个项目经理；那么，每个员工只能得知自己项目组员工的工作进度，并不能得知其他项目组的工作进度。所以，当多个项目经理在做同一个任务时，就可能出现任务配比不均、任务进度拖延、任务重复进行等多种问题。&lt;/p&gt;
&lt;p&gt;总结上面的例子来讲，就是因为进度的不及时更新，导致数据不是最新，导致决策失误。所以，我们隐约可以看出，内存并不直接与Cpu打交道，而是通过高速缓存与Cpu打交道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cpu  &amp;lt;——&amp;gt; 高速缓存  &amp;lt;———&amp;gt;  内存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过一张图片来表示就是（多核）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200225124948561-724696062.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下文我们的阐述，若无特殊说明，都是基于多核的。&lt;/p&gt;
&lt;h2 id=&quot;一导致共享变量在线程之间不可见的原因&quot;&gt;一、导致共享变量在线程之间不可见的原因：&lt;/h2&gt;
&lt;p&gt;可见性问题都是由Cpu缓存不一致为并发编程带来，而其中的主要有下面三种情况：&lt;/p&gt;
&lt;h3 id=&quot;线程交叉执行&quot;&gt;1.1、线程交叉执行&lt;/h3&gt;
&lt;p&gt;线程交叉执行多数情况是由于线程切换导致的，例如下图中的线程A在执行过程中切换到线程B执行完成后，再切换回线程A执行剩下的操作；此时线程B对变量的修改不能对线程A立即可见，这就导致了计算结果和理想结果不一致的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224132425849-1959676069.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重排序结合线程交叉执行&quot;&gt;1.2、重排序结合线程交叉执行&lt;/h3&gt;
&lt;p&gt;例如下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    int a = 0;    //行1
    int b = 0;    //行2
    a = b + 10;   //行3
    b = a + 9;    //行4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果行1和行2在编译的时候改变顺序，执行结果不会受到影响；&lt;/p&gt;
&lt;p&gt;如果将行3和行4在变异的时候交换顺序，执行结果就会受到影响，因为b的值得不到预期的19；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224154551028-1975376146.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图知：由于编译时改变了执行顺序，导致结果不一致；而两个线程的交叉执行又导致线程改变后的结果也不是预期值，简直雪上加霜!&lt;/p&gt;
&lt;h3 id=&quot;共享变量更新后的值没有在工作内存及主存间及时更新&quot;&gt;1.3、共享变量更新后的值没有在工作内存及主存间及时更新&lt;/h3&gt;
&lt;p&gt;因为主线程对共享变量的修改没有及时更新，子线程中不能立即得到最新值，导致程序不能按照预期结果执行。&lt;/p&gt;
&lt;p&gt;例如下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itquan.service.share.resources.controller;

import java.time.LocalDateTime;

/**
 * @author ：mmzsblog
 * @description：共享变量在线程间的可见性测试
 */
public class VisibilityDemo {

    // 状态标识flag
    private static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        System.out.println(LocalDateTime.now() + &quot;主线程启动计数子线程&quot;);
        new CountThread().start();

        Thread.sleep(1000);
        // 设置flag为false，使上面启动的子线程跳出while循环，结束运行
        VisibilityDemo.flag = false;
        System.out.println(LocalDateTime.now() + &quot;主线程将状态标识flag被置为false了&quot;);
    }

    static class CountThread extends Thread {
        @Override
        public void run() {
            System.out.println(LocalDateTime.now() + &quot;计数子线程start计数&quot;);
            int i = 0;
            while (VisibilityDemo.flag) {
                i++;
            }
            System.out.println(LocalDateTime.now() + &quot;计数子线程end计数，运行结束：i的值是&quot; + i);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200222170050154-969337207.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从控制台的打印结果可以看出，因为主线程对flag的修改，对计数子线程没有立即可见，所以导致了计数子线程久久不能跳出while循环，结束子线程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/juJaZOmCY12Qu4FDr7tRmg&quot;&gt;欢迎关注公众号&quot;Java学习之道&quot;，查看更多干货！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于这种情况，当然不能忍，所以就引出了下一个问题：如何解决线程间不可见性&lt;/p&gt;
&lt;h2 id=&quot;二如何解决线程间不可见性&quot;&gt;二、如何解决线程间不可见性&lt;/h2&gt;
&lt;p&gt;为了保证线程间可见性我们一般有3种选择:&lt;/p&gt;
&lt;h3 id=&quot;volatile只保证可见性&quot;&gt;2.1、volatile:只保证可见性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;关键字能保证可见性，但也只能保证可见性，在此处就能保证flag的修改能立即被计数子线程获取到。&lt;/p&gt;
&lt;p&gt;此时纠正上面例子出现的问题，只需在定义全局变量的时候加上&lt;code&gt;volatile&lt;/code&gt;关键字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 状态标识flag
    private static volatile boolean flag = true;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;atomic相关类保证可见性和原子性&quot;&gt;2.2、Atomic相关类:保证可见性和原子性&lt;/h3&gt;
&lt;p&gt;将标识状态flag在定义的时候使用Atomic相关类来进行定义的话，就能很好的保证flag属性的可见性以及原子性。&lt;/p&gt;
&lt;p&gt;此时纠正上面例子出现的问题，只需在定义全局变量的时候将变量定义成Atomic相关类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 状态标识flag
    private static AtomicBoolean flag = new AtomicBoolean(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过值得注意的一点是，此时原子类相关的方法设置新值和得到值的放的是有点变化，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 设置flag的值
    VisibilityDemo.flag.set(false);
    
    // 获取flag的值
    VisibilityDemo.flag.get()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lock-保证可见性和原子性&quot;&gt;2.3、Lock: 保证可见性和原子性&lt;/h3&gt;
&lt;p&gt;此处我们使用的是Java常见的synchronized关键字。&lt;/p&gt;
&lt;p&gt;此时纠正上面例子出现的问题，只需在为计数操作&lt;code&gt;i++&lt;/code&gt;添加&lt;code&gt;synchronized&lt;/code&gt;关键字修饰&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    synchronized (this) {
        i++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面三种方式，我们都能得到类似如下的期望结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224144334595-2132098515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，接下来我们要对其中的&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;关键字做一番较为详细的解释。欢迎关注公众号&quot;&lt;a href=&quot;https://mp.weixin.qq.com/s/juJaZOmCY12Qu4FDr7tRmg&quot;&gt;Java学习之道&lt;/a&gt;&quot;，查看更多干货！&lt;/p&gt;
&lt;h2 id=&quot;三可见性-volatile&quot;&gt;三、可见性-volatile&lt;/h2&gt;
&lt;p&gt;Java内存模型对volatile关键字定义了一些特殊的访问规则，当一个变量被volatile修饰后，它将具备两种特性，或者说volatile具有下列两层语义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一、保证了不同线程对这个变量进行读取时的可见性。即一个线程修改了某个变量的值， 这个新值对其他线程来说是立即可见的。 (volatile解决了线程间共享变量的可见性问题)。&lt;/li&gt;
&lt;li&gt;第二、禁止进行指令重排序， 阻止编译器对代码的优化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对第一点，volatile保证了不同线程对这个变量进行读取时的可见性，具体表现为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1： 使用 volatile 关键字会强制将在某个线程中修改的共享变量的值立即写入主内存。&lt;/li&gt;
&lt;li&gt;2： 使用 volatile 关键字的话， 当线程 2 进行修改时， 会导致线程 1 的工作内存中变量的缓存行无效（反映到硬件层的话， 就是 CPU 的 L1或者 L2 缓存中对应的缓存行无效);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附一张CPU缓存模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224151241730-959404926.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3： 由于线程 1 的工作内存中变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。基于这一点，所以我们经常会看到文章中或者书本中会说volatile 能够保证可见性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;：就是用volatile修饰的变量，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。&lt;/p&gt;
&lt;p&gt;使用volatile无法保障线程安全，那么volatile的作用是什么呢？&lt;/p&gt;
&lt;p&gt;其中之一：（对状态量进行标记，保证其它线程看到的状态量是最新值）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224152247701-396470285.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;volatile关键字是Java虚拟机提供的最轻量级的同步机制，很多人由于对它理解不够（其实这里你想理解透的话可以看看happens-before原则），而往往更愿意使用synchronized来做同步。&lt;/p&gt;
&lt;h2 id=&quot;四可见性synchronized&quot;&gt;四、可见性synchronized&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196304/202002/1196304-20200224161850050-2034511919.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;作用域&quot;&gt;4.1、作用域&lt;/h3&gt;
&lt;p&gt;synchronized关键字的作用域有二种：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;1）是某个对象实例内，&lt;code&gt;synchronized aMethod(){}&lt;/code&gt;可以防止多个线程同时访问这个对象的synchronized方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;因为当修饰非静态方法的时候，锁定的是当前实例对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2）是某个类的范围，&lt;code&gt;synchronized static aStaticMethod{}&lt;/code&gt;防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;因为当修饰静态方法的时候，锁定的是当前类的 Class 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;可用于方法中的某个区块中&quot;&gt;4.2、可用于方法中的某个区块中&lt;/h3&gt;
&lt;p&gt;除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。&lt;/p&gt;
&lt;p&gt;用法是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;synchronized(this){
    /*区块*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的作用域是当前对象；&lt;/p&gt;
&lt;h3 id=&quot;不能继承&quot;&gt;4.3、不能继承&lt;/h3&gt;
&lt;p&gt;synchronized关键字是不能继承的，也就是说，基类的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;synchronized f(){
    // 具体操作
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在继承类中并不自动是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;synchronized f(){
    // 具体操作  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而是变成了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f(){
    // 具体操作
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承类需要你显式的指定它的某个方法为synchronized方法；&lt;/p&gt;
&lt;p&gt;综上3点所述：synchronized关键字主要有以下这3种用法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;修饰实例方法&lt;/strong&gt;：作用于当前实例加锁，进入同步代码前要获得当前实例的锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修饰静态方法&lt;/strong&gt;：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt;：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三种用法就基本保证了共享变量在读取的时候，读取到的是最新的值。&lt;/p&gt;
&lt;h3 id=&quot;jvm关于synchronized的两条规定&quot;&gt;4.4、JVM关于synchronized的两条规定：&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程解锁前，必须把共享变量的最新值刷新到主内存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程加锁时，将清空工作内存中共享变量的值，从而是使用共享变量时，需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的这两条规则也可以看出，这种方式保证了内存中的共享变量一定是最新值。&lt;/p&gt;
&lt;p&gt;但我们在使用synchronized保证可见性的时候也要注意以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象；而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。&lt;/li&gt;
&lt;li&gt;B．每个对象只有一个锁（lock）与之相关联。Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的，毕竟忘记解锁 unlock() 可是个致命的 Bug（意味着其他线程只能死等下去了）。&lt;/li&gt;
&lt;li&gt;C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上内容就是我对并法中的可见性的一点理解与总结了，下期我们接着叙述并发中的有序性。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1、极客时间的Java并发编程实战&lt;/li&gt;
&lt;li&gt;2、https://www.jianshu.com/p/89a8fa8ffe39&lt;/li&gt;
&lt;li&gt;3、https://www.cnblogs.com/xiaonantianmen/p/9970368.html&lt;/li&gt;
&lt;li&gt;4、https://www.lagou.com/lgeduarticle/78722.html&lt;/li&gt;
&lt;li&gt;5、https://blog.csdn.net/evankaka/article/details/44153709&lt;/li&gt;
&lt;li&gt;6、https://juejin.im/post/5d52abd1e51d4561e6237124&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Fri, 28 Feb 2020 00:33:00 +0000</pubDate>
<dc:creator>淼淼之森</dc:creator>
<og:description>可见性的定义是：一个线程对共享变量的修改，另外一个线程能够立刻看到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmzs/p/12357918.html</dc:identifier>
</item>
<item>
<title>只有努力了，你才能成为想要的样子 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12375647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12375647.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;94&quot;&gt;
&lt;p&gt;记得初二上半学期，也是我唯一一次考过全年级第 3 名的时候，其余考试，无一例外得的都是第 4 名——这也是我对 4 这个数字并不排斥的真正原因，甚至以为它就是我的幸运数字，公众号定时发文的时间，我也会情不自禁地挑个带 4 的——有些读者询问过这个原因，这下真相大白了。&lt;/p&gt;
&lt;p&gt;初中的学生很杂，有好的，有坏的。我们村的一个邻村，叫牛头村，毫无疑问盛产坏的学生。他们就喜欢干一些缺德的事，并且是成群结队、拉帮结派的，势力很大，我们这些势力单的都怕他们，甚至老师都怕他们。&lt;/p&gt;
&lt;p&gt;这些坏学生都干过什么缺德事呢？趁月黑风高的时候打老师，由于这些家伙总是下黑手，老师在这方面可没少吃亏；趁没人注意的时候撬同学的书桌，有时候不小心撬了势力更大的组织，弄不好还要来一场火拼；趁星期前去自行车棚挨个拔气门芯，我就经常遭殃，每逢星期五下午回家的时候，总要先推自行车走一段路，找一家修理自行车的，补个新的。&lt;/p&gt;
&lt;p&gt;师傅是个好人，我们俩都混熟了，每次看我垂头丧气，就替我打抱不平：“哪个鬼孙子又干了缺德事？！”&lt;/p&gt;
&lt;p&gt;还有更恶心人的，半夜偷被子，由于是集体宿舍，大家都睡一张大床板上，这就给一些居心叵测的家伙创造了条件，冬天里，半夜被冻醒来去找被子的同学有不少，我就在这个不幸的名单上。&lt;/p&gt;
&lt;p&gt;遭受过这样恶劣环境的人，就会变成两种状态，其一就是变坏，坏的更坏；其二就是想尽一切办法脱离苦海。我属于后者。&lt;/p&gt;
&lt;p&gt;假如有些同学有条件到学校外面的亲戚家住宿，假如我们之间的关系还不错，我就请求他给我一个栖身之处——他的脚头。往往这些住的地方离学校都很远很远，但我无怨无悔，能离那群傻瓜远一点我就能多开心一点。&lt;/p&gt;
&lt;p&gt;在没有找到这个办法之前，我选择了另外一条路：穿好衣服，躲到教室里，点着自制的煤油灯，开始了一段我人生当中最努力的旅程。&lt;/p&gt;
&lt;p&gt;那时候，家里的词典里没有“富裕”、“小康”、“温饱”这些词，点蜡烛是一件奢侈的事情，而我在制作煤油灯这件事上颇有心得。油瓶用的是墨水瓶，当然是墨水用光掉的那种；灯芯用的是母亲纳鞋底的线，在这方面，母亲是慷慨的；煤油呢，自然是家里的，每家每户都有。&lt;/p&gt;
&lt;p&gt;这样的煤油灯，虽然比不上冰心的小桔灯富含温情，但的确是我记忆里为数不多值得珍藏的宝贝。&lt;/p&gt;
&lt;p&gt;教室里是有灯泡的，但不敢开，因为有巡夜的值班老师，要是被逮住了，还要受处分的。就连这小小的煤油灯，也要时刻警惕着，若有手电筒的灯光扫射过来，立马要吹灭。但常在河边走哪有不湿鞋的，有一次，还是被逮到了。&lt;/p&gt;
&lt;p&gt;当老师推开教室门的时候，我才后知后觉，但这时候再吹灭煤油灯的话，就有点掩耳盗铃的意思，于是，我就僵在了那里，等候他的发落。&lt;/p&gt;
&lt;p&gt;当老师发现那个点着煤油灯的学生就是我（我发现那班主任）时，也没多说话。应该是说了几句话的，但往事如烟，我到现在也记不得了。&lt;/p&gt;
&lt;p&gt;期中考试，我得了全年级的第三名。这，是我想要的结果。而那时的我，恐怕就是我 30 年来最努力的样子了。&lt;/p&gt;
&lt;p&gt;遗憾的是，求知欲望最强烈的时候，并没有多少新鲜的知识。课外读物是我喜欢的，还有两本更让我喜欢的，一本是中华上下五千年，一本是金庸新著的武侠小说。&lt;/p&gt;
&lt;p&gt;可惜，这两本书都没啥好的结果。中华上下五千年被英语老师不顾情面地收了去，并且义正言辞地拒绝了我的求情。他不知道，我就住在借我这本书的同学的亲戚家。假如这本书还不上，那我也就失去了朋友之间的信义，毕竟人家搞本书不容易。&lt;/p&gt;
&lt;p&gt;我总觉得，《中华上下五千年》算不上学校该禁的书，毕竟它对我的历史大有帮助。看在我英语成绩还不错的情面上，英语老师应该网开一面，但他选择了固执。当然了，错不在英语老师，错在我不应该在上英语课的时候偷偷地读这本书。&lt;/p&gt;
&lt;p&gt;至于金庸新的那本书，更惨，被我父亲撕成碎屑扔在了柴火堆里。对待这本书，我其实蛮小心翼翼的，是躲在被窝里拿手电筒读的，只可惜仍然被“福尔摩斯”般的父亲发现了。&lt;/p&gt;
&lt;p&gt;如果我没记错的话，有个叫六神磊磊的，就是靠着解读金庸的作品发财的。没有对比就没有伤害，我把这件事说给了父亲听，他反驳到，“你上大学那会我可没管你，我可没跑到学校撕你的书。”（看来这件事赖不到他头上）&lt;/p&gt;
&lt;p&gt;是的，我在学业上努力了一个学期，取得了想要的结果，但自己真正的兴趣其实还是在读书写作上。可惜当时没什么条件，可读的书除了课本，就只剩下几本同学们之间流传的禁书；可写的题材除了作文，就只剩下和女同学之间的几封见不得人的情书。&lt;/p&gt;
&lt;p&gt;初中时期的我是努力该有的样子，因为成绩一直前四，高中也是保送的。但高中时期的我就不是努力该有的样子，因为高考成绩很差，还把感兴趣的读书和写作弄丢了。也就是说，如果你的努力没有持之以恒的话，就会前功尽弃。&lt;/p&gt;
&lt;p&gt;最近，我开始了一段新的努力，就是原创日更，带来的变化是有目共睹的：文章阅读量在悄然攀升，读者的订阅数也在逐步攀升——套用我老婆的一句话就是，这才是努力该有的样子。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 28 Feb 2020 00:26:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>记得初二上半学期，也是我唯一一次考过全年级第 3 名的时候，其余考试，无一例外得的都是第 4 名——这也是我对 4 这个数字并不排斥的真正原因，甚至以为它就是我的幸运数字，公众号定时发文的时间，我也会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12375647.html</dc:identifier>
</item>
<item>
<title>Nginx之常用基本配置（一） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12374456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12374456.html</guid>
<description>&lt;p&gt;　　上一篇博客我们大概介绍了一下nginx，nginx的架构，nginx编译安装和nginx命令的用法，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12366808.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12366808.html&lt;/a&gt;；今天我们来配置简单的配置下nginx和一些简单指令说明。&lt;/p&gt;
&lt;p&gt;　　nginx和httpd类似都是高度模块化的软件，不同的模块有着不同的功能，想要把nginx配置好，首先我们需要了解各个模块的用法以及模块选项的用法和说明。首先我们来了解下nginx用yum安装后，程序环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# rpm -ql nginx
/etc/logrotate.d/nginx
/etc/nginx/fastcgi.conf
/etc/nginx/fastcgi.conf.default
/etc/nginx/fastcgi_params
/etc/nginx/fastcgi_params.default
/etc/nginx/koi-utf
/etc/nginx/koi-win
/etc/nginx/mime.types
/etc/nginx/mime.types.default
/etc/nginx/nginx.conf
/etc/nginx/nginx.conf.default
/etc/nginx/scgi_params
/etc/nginx/scgi_params.default
/etc/nginx/uwsgi_params
/etc/nginx/uwsgi_params.default
/etc/nginx/win-utf
/usr/bin/nginx-upgrade
/usr/lib/systemd/system/nginx.service
/usr/lib64/nginx/modules
/usr/sbin/nginx
/usr/share/doc/nginx-1.16.1
……省略部分内容
/var/lib/nginx
/var/lib/nginx/tmp
/var/log/nginx
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的显示，我们大概可以了解到nginx的主配置文件是/etc/ngxin/ngxin.conf,nginx.conf.default是默认配置文件，从这个文件中我们可以了解到nginx的默认配置是怎么配置的；主程序是/usr/sbin/nginx，日志文件路径是/var/log/nginx,Unit File是nginx.service；/etc/nginx/fastcgi.conf和fastcgi_parems,这两个文件一个是fastcig协议的配置文件，一个是变量配置文件。了解了nginx 的程序环境，我们在来看看主配置文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# cat /etc/nginx/nginx.conf
# For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
#    server {
#        listen       443 ssl http2 default_server;
#        listen       [::]:443 ssl http2 default_server;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;
#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;
#        ssl_session_cache shared:SSL:1m;
#        ssl_session_timeout  10m;
#        ssl_ciphers HIGH:!aNULL:!MD5;
#        ssl_prefer_server_ciphers on;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        location / {
#        }
#
#        error_page 404 /404.html;
#            location = /40x.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#            location = /50x.html {
#        }
#    }

}

[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：主配置文件结构大致可以分为main段（全局配置段）和http配置段或者mail配置段或者stream段，后面的http配置段或mail配置段或stream配置段，主要看nginx用于什么功能，如果单纯的用于web服务器，那么后面的mail和stream配置段就可以不要了，也就是说有关web的配置我们必须要在http配置段配置；同样的如果nginx用于邮件代理我们就需要把有关邮件代理的配置放到mail配置段，如果用于四层负载均衡，我们需要把对应的配置写到stream配置段；我们先说一下全局配置段吧&lt;/p&gt;
&lt;p&gt;　　user指令：表示指定运行worker进程的用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# head /etc/nginx/nginx.conf
  For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
[root@www ~]# ps aux |grep nginx
root       1425  0.0  0.0 120832  2244 ?        Ss   19:49   0:00 nginx: master process nginx
nginx      1426  0.0  0.0 121228  3132 ?        S    19:49   0:00 nginx: worker process
nginx      1427  0.0  0.0 121228  3132 ?        S    19:49   0:00 nginx: worker process
nginx      1428  0.0  0.0 121228  3132 ?        S    19:49   0:00 nginx: worker process
nginx      1429  0.0  0.0 121228  3132 ?        S    19:49   0:00 nginx: worker process
root       1439  0.0  0.0 112660   968 pts/0    S+   19:51   0:00 grep --color=auto nginx
[root@www ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通常情况都不建议nginx用root运行；如果是集群环境建议统一进程运行用户，其次必须统一时间&lt;/p&gt;
&lt;p&gt;　　worker_processes ：指定worker进程的数量，一般是和运行nginx主机的CUP核心数来定，一般都是小于或者等于物理cpu核心数，auto表示自动去匹配cup核心数来启动worker进程数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# lscpu 
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                4
On-line CPU(s) list:   0-3
Thread(s) per core:    1
Core(s) per socket:    2
Socket(s):             2
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 158
Model name:            Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
Stepping:              9
CPU MHz:               3599.644
CPU max MHz:           0.0000
CPU min MHz:           0.0000
BogoMIPS:              7200.06
Hypervisor vendor:     VMware
Virtualization type:   full
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              8192K
NUMA node0 CPU(s):     0-3
Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid rtm rdseed adx smap xsaveopt xsavec xgetbv1 dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp
[root@www ~]# ps aux |grep nginx
root       1425  0.0  0.1 121500  5272 ?        Ss   19:49   0:00 nginx: master process nginx
nginx      1453  0.0  0.0 121748  3668 ?        S    19:56   0:00 nginx: worker process
nginx      1454  0.0  0.0 121748  3668 ?        S    19:56   0:00 nginx: worker process
nginx      1455  0.0  0.0 121748  3668 ?        S    19:56   0:00 nginx: worker process
nginx      1456  0.0  0.0 121748  3668 ?        S    19:56   0:00 nginx: worker process
root       1465  0.0  0.0 112660   972 pts/0    S+   19:57   0:00 grep --color=auto nginx
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　error_log表示指定nginx错误日志存放文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# ll /var/log/nginx/error.log 
-rw-r--r-- 1 root root 120 Feb 27 19:56 /var/log/nginx/error.log
[root@www ~]# cat /var/log/nginx/error.log
2020/02/27 19:52:18 [notice] 1442#0: signal process started
2020/02/27 19:56:47 [notice] 1452#0: signal process started
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　pid表示指定pid文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# ps aux |grep nginx
root       1567  0.0  0.0 120832  2248 ?        Ss   20:05   0:00 nginx: master process /usr/sbin/nginx
nginx      1568  0.0  0.0 121228  3336 ?        S    20:05   0:00 nginx: worker process
nginx      1569  0.0  0.0 121228  3336 ?        S    20:05   0:00 nginx: worker process
nginx      1570  0.0  0.0 121228  3336 ?        S    20:05   0:00 nginx: worker process
nginx      1571  0.0  0.0 121228  3136 ?        S    20:05   0:00 nginx: worker process
root       1574  0.0  0.0 112660   972 pts/0    S+   20:05   0:00 grep --color=auto nginx
[root@www ~]# ll /var/run/nginx.pid 
-rw-r--r-- 1 root root 5 Feb 27 20:05 /var/run/nginx.pid
[root@www ~]# nginx -s stop
[root@www ~]# ll /var/run/nginx.pid 
ls: cannot access /var/run/nginx.pid: No such file or directory
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：pid文件就是存放nginx主控进程的进程号的，如果nginx没有运行或者停止了服务，那么pid文件也会跟着消失；这里提示一下在centos7上/var/run 和/run是同一文件夹 ，它俩做的是硬链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# ll -id /var/run/
1150 drwxr-xr-x 22 root root 620 Feb 27 20:07 /var/run/
[root@www ~]# ll -id /run
1150 drwxr-xr-x 22 root root 620 Feb 27 20:07 /run
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：两个文件夹的inode号都是同一个&lt;/p&gt;
&lt;p&gt;　　include此指令表示把某些地方的配置导入到此地；这个指定配置的时候需要注意放的位置；正因为有了这个功能，我们就可以把很多不同功能的配置用专有的文件来配置，这样既方便管理，也很容易读；&lt;/p&gt;
&lt;p&gt;　　events此配置段表示配置有关事件驱动相关的配置&lt;/p&gt;
&lt;p&gt;　　worker_connections ：每个worker进程所能够打开的最大并发连接数；&lt;/p&gt;
&lt;p&gt;　　use method：指定并发请求的处理方法；如use epoll；&lt;/p&gt;
&lt;p&gt;　　accept_mutex on|off：处理新的连接请求的方法；on表示各worker进程轮流处理新请求，off表示每来一个新请求就会通知所有的worker进程&lt;/p&gt;
&lt;p&gt;　　有关性能优化的全局配置&lt;/p&gt;
&lt;p&gt;　　worker_cpu_affinity cpumask：手动或自动绑定cpu,默认情况下是没有绑定cpu的，这意味着worker进程会在每个CPU上来会调度的，这样一来在cpu就存在频繁的切换，影响性能；我们可以手动把每个进程绑定到不同的CPU上。禁止worker进程在每个CPU上来回切换&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1503305/202002/1503305-20200227215014848-1155298308.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在没有绑定cpu时，我们对nginx worker进程发起并发连接请求，可以看到4个worker进程在不同的CUP上来回切换，很显然这无疑在给系统多余的开销，我们可以绑定nginx 的worker线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# grep worker_cpu /etc/nginx/nginx.conf
worker_cpu_affinity 0001 0010 0100 1000;
[root@www ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www ~]# nginx -s reload
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果你有的CPU是八核的，那么就需要用8个0来表示，其中第一个进程对应最右侧的0，如果需要绑定到该cpu核心上，则对应位为1即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1503305/202002/1503305-20200227221557722-647197736.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：绑定cpu我们也可以直接使用worker_cpu_affinity auto;来指定，让其自动绑定到每个cpu核心上去&lt;/p&gt;
&lt;p&gt; 　　worker_priority number：指定worker进程的nice值，设定worker进程优先级；[-20,19]&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# grep &quot;worker_priority&quot; /etc/nginx/nginx.conf
worker_priority -5;
[root@www ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www ~]# nginx -s reload                             
[root@www ~]# ps axo comm,pid,nice,psr|grep nginx
nginx             2583   0   0
nginx            31567  -5   0
nginx            31568  -5   1
nginx            31569  -5   2
nginx            31570  -5   3
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是常用的全局配置段指令的说明和使用，详细请参考nginx官方文档&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html&quot; target=&quot;_blank&quot;&gt;http://nginx.org/en/docs/ngx_core_module.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　http协议的相关配置&lt;/p&gt;
&lt;p&gt;　　在主配置文件中我们可以看到有一个以http开头的配置段，这个配置段主要配置nginx工作成web服务的配置&lt;/p&gt;
&lt;p&gt;　　server:这个指令表示定义个虚拟主机类似httpd里的virtualhost，这也是一个http里的一个子配置段，里面有server_name指令 root等等&lt;/p&gt;
&lt;p&gt;　　　　server_name：表示指定虚拟主机名称；指明虚拟主机的主机名称；后可跟多个由空白字符分隔的字符串；支持*通配任意长度的任意字符；支持~起始的字符做正则表达式模式匹配；&lt;/p&gt;
&lt;p&gt;　　　　　　匹配机制：首先是字符串精确匹配；其次是左侧*通配符，然后右侧*通配符，最后是正则表达式&lt;/p&gt;
&lt;p&gt;　　　　root：设置web资源路径映射；用于指明用户请求的url所对应的本地文件系统上的文档所在目录路径；可用的位置：http, server, location, if in location；&lt;/p&gt;
&lt;p&gt;　　　　listen：指定虚拟主机监听的地址和端口，如果只指定端口未指定地址，表示监听服务器上的所有地址，如果在server里没有指定端口，对应的虚拟主机将监听在默认端口80上&lt;/p&gt;
&lt;p&gt;　　　　　　listen address[:port] [default_server] [ssl] [http2 | spdy]  [backlog=number] [rcvbuf=size] [sndbuf=size]&lt;/p&gt;
&lt;p&gt;　　　　　　　　default_server:设定为默认虚拟主机；&lt;/p&gt;
&lt;p&gt;　　　　　　　　ssl：限制仅能通过ssl连接该服务&lt;/p&gt;
&lt;p&gt;　　　　　　　　backlog=number：指定后援队列长度&lt;/p&gt;
&lt;p&gt;　　　　　　　　sndbuf=size：指定发送缓冲区大小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200227225236090-359207597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　提示：我们这样配置后，在hosts文件中添加对应的解析后，用浏览器访问www.ilinux.io，此时它就会把默认主机里的映射路径下的资源响应我们&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# echo &quot;this is default path &quot; &amp;gt; /usr/share/nginx/html/test.html
[root@www ~]# cat /usr/share/nginx/html/test.html
this is default path 
[root@www ~]# curl http://www.ilinux.io/test.html
this is default path 
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　tcp_nodelay on|off ：在keepalived模式下的连接是否启用TCP_NODELAY选项；&lt;/p&gt;
&lt;p&gt;　　　　tcp_nopush on|off：在sendfile模式下，是否启用TCP_CORK选项；&lt;/p&gt;
&lt;p&gt;　　　　sendfile on|off：是否启用sendfile功能；&lt;/p&gt;
&lt;p&gt;　　通常情况下以上三项都是打开的，TCP_NODELAY主要是发送报文延时问题，如果开启了该功能选项，表示不管数据包多小都及时发送，如果关闭了，通常会等到一定量的数据报文一起发送，对于小报文延时就很高，TCP_CORK主要是解决小包问题，它和TCP_NODELAY相反，启用表示要到一定量的数据包后才发送，关闭表示不用等一定量的数据报文再发送，它们两者都是解决小包问题，前者应用在长连接模式下，后者应用在sendfile模式下；sendfile模式解决了内核到用户应用程序，用户应用程序到内核的重复过程，它可将数据报文直接从内核加载到网卡socket缓存区，直接发送出去；这三项都和性能相关，通常都是开启的；&lt;/p&gt;
&lt;p&gt;　　location：此指令用于实现从uri到文件系统的路径映射；ngnix会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置；在一个server中location配置段可存在多个；&lt;/p&gt;
&lt;p&gt;　　　　语法：location [ = | ~ | ~* | ^~ ] uri { ... }&lt;/p&gt;
&lt;p&gt;　　　　　　=：对URI做精确匹配；&lt;/p&gt;
&lt;p&gt;　　　　　　^~：对URI的左半部分做匹配检查，不区分字符大小写；&lt;/p&gt;
&lt;p&gt;　　　　　　~：对URI做正则表达式模式匹配，区分字符大小写；&lt;/p&gt;
&lt;p&gt;　　　　　　~*：对URI做正则表达式模式匹配，不区分字符大小写；&lt;/p&gt;
&lt;p&gt;　　　　　　不带符号：匹配起始于此uri的所有的url；&lt;/p&gt;
&lt;p&gt;　　　　　　匹配优先级：=, ^~, ～/～*，不带符号；&lt;/p&gt;
&lt;p&gt; 　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：如果是用户请求uri是/ 那么在以上location中将匹配到A，如果是/index 将匹配到B，如果是/documents/index将匹配到C，如果是/images/1.jpg将匹配到D和E，但是D的优先级高于E，所有应用D的配置，如果是/document/1.jpg将匹配到C和E，但是E的优先级高于C，所以会应用E的配置；&lt;/p&gt;
&lt;p&gt;　　alias path：定义资源路径别名，仅用于location中；它和root定义资源路径不同的是，root定义的资源路径应用在/uri/左侧的'/',而alias定义的资源路径应用在/uri/的右侧'/';&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# cat /etc/nginx/conf.d/test.conf
server {

        listen 80;
        server_name www.ilinux.io;

        location  /test/ {
                root /data/web/html/;

                allow all;
        }
}
[root@www ~]# cat /data/web/html/index.html 
this is /data/web/html/index.html
[root@www ~]# cat /data/web/html/index.html 
this is /data/web/html/index.html
[root@www ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www ~]# nginx -s reload
[root@www ~]# curl http://www.ilinux.io/test/index.html
this is /data/web/html/test/index.html
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们用root来指定资源路径时，我们访问/test/.index.html 它返回的是/data/web/html/test/index.html，就相当于把location左侧的“/”更换成root定义的路径，用户访问资源的真实路径就是/data/web/html/test/index.html;换句话讲，root指定资源路径，匹配用户URI最左侧“/”,真实路径是root指定的路径+用户URI（不带左侧&quot;/&quot;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www ~]# cat /etc/nginx/conf.d/test.conf 
server {

        listen 80;
        server_name www.ilinux.io;

        location  /test/ {
                alias /data/web/html/;

                allow all;
        }
}
[root@www ~]# cat /data/web/html/index.html 
this is /data/web/html/index.html
[root@www ~]# cat /data/web/html/test/index.html 
this is /data/web/html/test/index.html
[root@www ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www ~]# nginx -s reload
[root@www ~]# curl http://www.ilinux.io/test/index.html
this is /data/web/html/index.html
[root@www ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：用alias 指定资源路径时，我们访问/test/index.html，它返回/data/web/html/index.html，相当于alias 指定的资源路径覆盖了用户请求的URI最右侧的“/”，换句话说用户URI最右侧的“/”就是alias所指定的资源路径，用户访问/test/index.html 就相当于访问/data/web/html/index.html；这里还需要注意一点的是 alias 指定资源路径时，必须是“/”结尾，如果不以“/”结尾，资源将无法找到；对于root来讲是不是“/”结尾这个无要求；&lt;/p&gt;
&lt;p&gt;　　index file:指定默认主页，可配置在http, server, location；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www html]# cat /etc/nginx/conf.d/test.conf 
server {

        listen 80;
        server_name www.ilinux.io;
        location  /test/ {
                alias /data/web/html/;
                index test.html;
                allow all;
        }
}
[root@www html]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www html]# nginx -s reload
[root@www html]# curl http://www.ilinux.io/test/
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;403 Forbidden&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;403 Forbidden&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.16.1&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@www html]# echo &quot;this is default page&quot; &amp;gt; /data/web/html/test.html
[root@www html]# curl http://www.ilinux.io/test/                       
this is default page
[root@www html]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　error_page code ... [=[response]] uri：指定错误页面，匹配指定的状态码，返回指定的URL&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@www html]# cat /etc/nginx/conf.d/test.conf
server {

        listen 80;
        server_name www.ilinux.io;
        location  /test/ {
                alias /data/web/html/;
                index test.html;
                allow all;
        }
        error_page 404 403 /error.html;

        location /error.html {
                root /data/web/html/error;
        }
}
[root@www html]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@www html]# nginx -s reload
[root@www html]# mkdir /data/web/html/error/
[root@www html]# echo &quot;error page&quot; &amp;gt; /data/web/html/error/error.html
[root@www html]# curl http://www.ilinux.io/abc/
error page
[root@www html]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通过指定错误页面，我们可以自定义错误页面，也可以对错误页面用专有的location来做配置；&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 18:35:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>上一篇博客我们大概介绍了一下nginx，nginx的架构，nginx编译安装和nginx命令的用法，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/1236680</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12374456.html</dc:identifier>
</item>
<item>
<title>基于 React 实现一个 Transition 过渡动画组件 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/12375357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/12375357.html</guid>
<description>&lt;p&gt;过渡动画使 UI 更富有表现力并且易于使用。如何使用 React 快速的实现一个 Transition 过渡动画组件？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;339.23940471411&quot;&gt;
&lt;p&gt;过渡动画使 UI 更富有表现力并且易于使用。如何使用 React 快速的实现一个 Transition 过渡动画组件？&lt;/p&gt;
&lt;h3 id=&quot;基本实现&quot;&gt;基本实现&lt;/h3&gt;
&lt;p&gt;实现一个基础的 CSS 过渡动画组件，通过切换 CSS 样式实现简单的动画效果，也就是通过添加或移除某个 class 样式。因此需要给 Transition 组件添加一个 toggleClass 属性，标识要切换的 class 样式，再添加一个 action 属性实现样式切换，action 为 true 时添加 toggleClass 到动画元素上，action 为 false 时移除 toggleClass。&lt;/p&gt;
&lt;p&gt;安装 classnames 插件：&lt;/p&gt;
&lt;pre class=&quot;static&quot;&gt;
&lt;code&gt;npm install classnames --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JedWatson/classnames&quot;&gt;classnames&lt;/a&gt; 是一个简单的JavaScript实用程序，用于有条件地将 className 连接在一起。&lt;/p&gt;
&lt;p&gt;在 components 目录下新建一个 Transition 文件夹，并在该文件夹下新建一个 Transition.jsx 文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react'
import classnames from 'classnames'

/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {
  render() {
    const { children } = this.props
    const transition = (
      &amp;lt;div
        className={
          classnames({
            transition: true
          })
        }
        style={
          {
            position: 'relative',
            overflow: 'hidden'
          }
        }
      &amp;gt;
        &amp;lt;div
          className={
            classnames({
              'transition-wrapper': true
            })
          }
        &amp;gt;
          { children }
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
    return transition
  }
}

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了 &lt;a href=&quot;https://react.docschina.org/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt;，在 JSX 中，使用 camelCase（小驼峰命名）来定义属性的名称，使用大括号“{}”嵌入任何有效的 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript 表达式&lt;/a&gt;。&lt;br/&gt;如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const name = 'Josh Perez';
const element = &amp;lt;h1&amp;gt;Hello, {name}&amp;lt;/h1&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const element = &amp;lt;h1&amp;gt;Hello, Josh Perez&amp;lt;/h1&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。&lt;br/&gt;例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，在 React 中，&lt;a href=&quot;https://zh-hans.reactjs.org/docs/glossary.html#propschildren&quot;&gt;props.children&lt;/a&gt;&lt;br/&gt;包含组件所有的子节点，即组件的开始标签和结束标签之间的内容（与 Vue 中 slot 插槽相似）。例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;Button&amp;gt;默认按钮&amp;lt;/Button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Button 组件中获取 props.children，就可以得到字符串“默认按钮”。&lt;/p&gt;
&lt;p&gt;接下来，在 Transition 文件夹下新建一个 index.js，导出 Transition 组件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import Transition from './Transition.jsx'

export { Transition }

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在 Transition.jsx 文件中为组件添加 props 检查并设置 action 的默认值：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import PropTypes from 'prop-types'

const propTypes = {
  /** 执行动画 */
  action: PropTypes.bool,
  /** 切换的css动画的class名称 */
  toggleClass: PropTypes.string
}

const defaultProps = {
  action: false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了 &lt;a href=&quot;https://github.com/facebook/prop-types&quot;&gt;prop-types&lt;/a&gt; 实现运行时类型检查。&lt;/p&gt;
&lt;blockquote readability=&quot;5.4754098360656&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;prop-types 是一个运行时类型检查工具，也是 &lt;a href=&quot;https://create-react-app.dev/docs/adding-a-sass-stylesheet/&quot;&gt;create-react-app&lt;/a&gt; 脚手架默认配置的运行时类型检查工具，使用时直接引入即可，无需安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整的 Transition 组件代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'

const propTypes = {
  /** 执行动画 */
  action: PropTypes.bool,
  /** 切换的css动画的class名称 */
  toggleClass: PropTypes.string
}

const defaultProps = {
  action: false
}

/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  static propTypes = propTypes

  static defaultProps = defaultProps

  render() {
    const {
      className,
      action,
      toggleClass,
      children
    } = this.props
    const transition = (
      &amp;lt;div
        className={
          classnames({
            transition: true
          })
        }
        style={
          {
            position: 'relative',
            overflow: 'hidden'
          }
        }
      &amp;gt;
        &amp;lt;div
          className={
            classnames({
              'transition-wrapper': true,
              [className]: className,
              [toggleClass]: action &amp;amp;&amp;amp; toggleClass
            })
          }
        &amp;gt;
          { children }
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
    return transition
  }
}

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，可以使用我们的 Transition 组件了。&lt;/p&gt;
&lt;p&gt;CSS 代码如下：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.fade {
  transition: opacity 0.15s linear;
}

.fade:not(.show) {
  opacity: 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JS 代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react';
import Transition from './Transition';

class Anime extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      action: true
    }
  }
  
  render () {
    const btnText = this.state.action ? '淡出' : '淡入'
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Transition
          className=&quot;fade&quot;
          toggleClass=&quot;show&quot;
          action={ this.state.action }
        &amp;gt;
          淡入淡出
        &amp;lt;/Transition&amp;gt;
        &amp;lt;button
          style={{ marginTop: '20px' }}
          onClick={() =&amp;gt; this.setState({ action: !this.state.action })}
        &amp;gt;
          { btnText }
        &amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在你需要该动画的地方使用 Anime 组件即可。&lt;/p&gt;
&lt;h3 id=&quot;实现-animate.css-兼容&quot;&gt;实现 Animate.css 兼容&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/daneden/animate.css&quot;&gt;Animate.css&lt;/a&gt; 是一款强大的预设 CSS3 动画库。接下来，实现在 Transition 组件中使用 Animate.css 实现强大的 CSS3 动画。&lt;/p&gt;
&lt;p&gt;由于 Animate.css 动画在进入动画和离开动画通常使用两个效果相反的 class 样式，因此，需要给 Transition 组件添加 enterClass 和 leaveClass 两个属性，实现动画切换。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'

const propTypes = {
  /** 执行动画 */
  action: PropTypes.bool,
  /** 切换的css动画的class名称 */
  toggleClass: PropTypes.string,
  /** 进入动画的class名称，存在 toggleClass 时无效 */
  enterClass: PropTypes.string,
  /** 离开动画的class名称，存在 toggleClass 时无效 */
  leaveClass: PropTypes.string
}

const defaultProps = {
  action: false
}

/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  static propTypes = propTypes

  static defaultProps = defaultProps

  render() {
    const {
      className,
      action,
      toggleClass,
      enterClass,
      leaveClass,
      children
    } = this.props
    return (
      &amp;lt;div
        className={
          classnames({
            transition: true
          })
        }
        style={
          {
            position: 'relative',
            overflow: 'hidden'
          }
        }
      &amp;gt;
        &amp;lt;div
          className={
            classnames({
              'transition-wrapper': true,
              [className]: className,
              [toggleClass]: action &amp;amp;&amp;amp; toggleClass,
              [enterClass]: !toggleClass &amp;amp;&amp;amp; action &amp;amp;&amp;amp; enterClass,
              [leaveClass]: !toggleClass &amp;amp;&amp;amp; !action &amp;amp;&amp;amp; leaveClass,
            })
          }
        &amp;gt;
          { children }
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;由于 toggleClass 适用于那些进入动画与离开动画切换相同 class 样式的情况，而 enterClass 和 leaveClass 适用于那些进入动画与离开动画切换不同的 class 样式的情况，所以，他们与 toggleClass 不能共存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，就可以试一试加入 Animate.css 后的 Transition 组件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react';
import 'animate.css';

class Anime extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      action: true
    }
  }
  
  render () {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Transition
          className=&quot;animated&quot;
          enterClass=&quot;bounceInLeft&quot;
          leaveClass=&quot;bounceOutLeft&quot;
          action={ this.state.action }
        &amp;gt;
          弹入弹出
        &amp;lt;/Transition&amp;gt;
        &amp;lt;utton
          style={{ marginTop: '20px' }}
          onClick={() =&amp;gt; this.setState({ action: !this.state.action })}
        &amp;gt;
          { this.state.action ? '弹出' : '弹入' }
        &amp;lt;/utton&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能扩展&quot;&gt;功能扩展&lt;/h3&gt;
&lt;p&gt;通过上面的实现，Transition 组件能适用大部分场景，但是功能不够丰富。因此，接下来就需要扩展 Transition 的接口。动画通常可以设置延迟时间，播放时长，播放次数等属性。因此，需要给 Transition 添加这些属性，来丰富设置动画。&lt;/p&gt;
&lt;p&gt;添加如下 props 属性，并设置默认值：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const propTypes = {
  ...,
  /** 动画延迟执行时间 */
  delay: PropTypes.string,
  /** 动画执行时间长度 */
  duration: PropTypes.string,
  /** 动画执行次数，只在执行 CSS3 动画时有效 */
  count: PropTypes.number,
  /** 动画缓动函数 */
  easing: PropTypes.oneOf([
    'linear',
    'ease',
    'ease-in',
    'ease-out',
    'ease-in-out'
  ]),
  /** 是否强制轮流反向播放动画，count 为 1 时无效 */
  reverse: PropTypes.bool
}

const defaultProps = {
  count: 1,
  reverse: false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据 props 设置样式：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 动画样式
const styleText = (() =&amp;gt; {
  let style = {}
  // 设置延迟时长
  if (delay) {
    style.transitionDelay = delay
    style.animationDelay = delay
  }
  // 设置播放时长
  if (duration) {
    style.transitionDuration = duration
    style.animationDuration = duration
  }
  // 设置播放次数
  if (count) {
    style.animationIterationCount = count
  }
  // 设置缓动函数
  if (easing) {
    style.transitionTimingFunction = easing
    style.animationTimingFunction = easing
  }
  // 设置动画方向
  if (reverse) {
    style.animationDirection = 'alternate'
  }
  return style
})()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'

const propTypes = {
  /** 执行动画 */
  action: PropTypes.bool,
  /** 切换的css动画的class名称 */
  toggleClass: PropTypes.string,
  /** 进入动画的class名称，存在 toggleClass 时无效 */
  enterClass: PropTypes.string,
  /** 离开动画的class名称，存在 toggleClass 时无效 */
  leaveClass: PropTypes.string,
  /** 动画延迟执行时间 */
  delay: PropTypes.string,
  /** 动画执行时间长度 */
  duration: PropTypes.string,
  /** 动画执行次数，只在执行 CSS3 动画时有效 */
  count: PropTypes.number,
  /** 动画缓动函数 */
  easing: PropTypes.oneOf([
    'linear',
    'ease',
    'ease-in',
    'ease-out',
    'ease-in-out'
  ]),
  /** 是否强制轮流反向播放动画，count 为 1 时无效 */
  reverse: PropTypes.bool
}

const defaultProps = {
  action: false,
  count: 1,
  reverse: false
}

/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  static propTypes = propTypes

  static defaultProps = defaultProps

  render() {
    const {
      className,
      action,
      toggleClass,
      enterClass,
      leaveClass,
      delay,
      duration,
      count,
      easing,
      reverse,
      children
    } = this.props

    // 动画样式
    const styleText = (() =&amp;gt; {
      let style = {}
      // 设置延迟时长
      if (delay) {
        style.transitionDelay = delay
        style.animationDelay = delay
      }
      // 设置播放时长
      if (duration) {
        style.transitionDuration = duration
        style.animationDuration = duration
      }
      // 设置播放次数
      if (count) {
        style.animationIterationCount = count
      }
      // 设置缓动函数
      if (easing) {
        style.transitionTimingFunction = easing
        style.animationTimingFunction = easing
      }
      // 设置动画方向
      if (reverse) {
        style.animationDirection = 'alternate'
      }
      return style
    })()

    return (
      &amp;lt;div
        className={
          classnames({
            transition: true
          })
        }
        style={
          {
            position: 'relative',
            overflow: 'hidden'
          }
        }
      &amp;gt;
        &amp;lt;div
          className={
            classnames({
              'transition-wrapper': true,
              [className]: className,
              [toggleClass]: action &amp;amp;&amp;amp; toggleClass,
              [enterClass]: !toggleClass &amp;amp;&amp;amp; action &amp;amp;&amp;amp; enterClass,
              [leaveClass]: !toggleClass &amp;amp;&amp;amp; !action &amp;amp;&amp;amp; leaveClass,
            })
          }
          style={ styleText }
        &amp;gt;
          { children }
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为 Transition 增加了以下设置属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;delay&lt;/strong&gt;：规定在动画开始之前的延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;duration&lt;/strong&gt;：规定完成动画所花费的时间，以秒或毫秒计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;count&lt;/strong&gt;：规定动画应该播放的次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;easing&lt;/strong&gt;：规定动画的速度曲线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reverse&lt;/strong&gt;：规定是否应该轮流反向播放动画。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前，Transition 的功能已经相当丰富，可以很精细的控制 CSS3 动画。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;
&lt;p&gt;这一步，我们需要针对 Transition 组件进一步优化，主要包括动画结束的监听、卸载组件以及兼容。&lt;/p&gt;
&lt;p&gt;添加以下 props 属性，并设置默认值：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const propTypes = {
  ...,
  /** 动画结束的回调 */
  onEnd: PropTypes.func,
  /** 离开动画结束时卸载元素 */
  exist: PropTypes.bool
}

const defaultProps = {
  ...,
  reverse: false,
  exist: false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理动画结束的监听事件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  ...

  onEnd = e =&amp;gt; {
    const { onEnd, action, exist } = this.props
    if (onEnd) {
      onEnd(e)
    }
    // 卸载 DOM 元素
    if (!action &amp;amp;&amp;amp; exist) {
      const node = e.target.parentNode
      node.parentNode.removeChild(node)
    }
  }

  /**
   * 对动画结束事件 onEnd 回调的处理函数
   *
   * @param {string} type - 事件解绑定类型: add - 绑定事件，remove - 移除事件绑定
   */
  handleEndListener (type = 'add') {
    const el = ReactDOM.findDOMNode(this).querySelector('.transition-wrapper')
    const events = ['animationend', 'transitionend']
    events.forEach(ev =&amp;gt; {
      el[`${type}EventListener`](ev, this.onEnd, false)
    })
  }

  componentDidMount () {
    this.handleEndListener()
  }

  componentWillUnmount () {
    const { action, exist } = this.props
    if (!action &amp;amp;&amp;amp; exist) {
      this.handleEndListener('remove')
    }
  }

  render () {
    ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用到两个生命周期函数 componentDidMount 和 componentWillUnmount，关于 React 生命周期的介绍请移步&lt;a href=&quot;https://react.docschina.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class&quot;&gt;组件生命周期&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://react.docschina.org/docs/react-dom.html&quot;&gt;react-dom&lt;/a&gt; 提供了可在 React 应用中使用的 DOM 方法。&lt;/p&gt;
&lt;p&gt;获取兼容性的 animationend 事件和 transitionend 事件。不同的浏览器要求使用不同的前缀，因为火狐和IE都已经支持了这两个事件，因此，只需针对 webkit 内核浏览器进行兼容的 webkitTransitionEnd 事件检测。检测函数代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 浏览器兼容事件检测函数
 *
 * @param {node} el - 触发事件的 DOM 元素
 * @param {array} events - 可能的事件类型
 * @returns {*}
 */
const whichEvent = (el, events) =&amp;gt; {
  const len = events.length
  for (var i = 0; i &amp;lt; len; i++) {
    if (el.style[i]) {
      return events[i];
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 handleEndListener 函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  ...

  /**
   * 对动画结束事件 onEnd 回调的处理函数
   *
   * @param {string} type - 事件解绑定类型: add - 绑定事件，remove - 移除事件绑定
   */
  handleEndListener (type = 'add') {
    const el = ReactDOM.findDOMNode(this).querySelector('.transition-wrapper')
    const events = ['AnimationEnd', 'TransitionEnd']
    events.forEach(ev =&amp;gt; {
      const eventType = whichEvent(el, [ev.toLowerCase(), `webkit${ev}`])
      el[`${type}EventListener`](eventType, this.onEnd, false)
    })
  }

  ...

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们完成了整个 Transition 组件的开发，完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import React from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import ReactDOM from 'react-dom'

const propTypes = {
  /** 执行动画 */
  action: PropTypes.bool,
  /** 切换的css动画的class名称 */
  toggleClass: PropTypes.string,
  /** 进入动画的class名称，存在 toggleClass 时无效 */
  enterClass: PropTypes.string,
  /** 离开动画的class名称，存在 toggleClass 时无效 */
  leaveClass: PropTypes.string,
  /** 动画延迟执行时间 */
  delay: PropTypes.string,
  /** 动画执行时间长度 */
  duration: PropTypes.string,
  /** 动画执行次数，只在执行 CSS3 动画时有效 */
  count: PropTypes.number,
  /** 动画缓动函数 */
  easing: PropTypes.oneOf([
    'linear',
    'ease',
    'ease-in',
    'ease-out',
    'ease-in-out'
  ]),
  /** 是否强制轮流反向播放动画，count 为 1 时无效 */
  reverse: PropTypes.bool,
  /** 动画结束的回调 */
  onEnd: PropTypes.func,
  /** 离开动画结束时卸载元素 */
  exist: PropTypes.bool
}

const defaultProps = {
  action: false,
  count: 1,
  reverse: false,
  exist: false
}

/**
 * 浏览器兼容事件检测函数
 *
 * @param {node} el - 触发事件的 DOM 元素
 * @param {array} events - 可能的事件类型
 * @returns {*}
 */
const whichEvent = (el, events) =&amp;gt; {
  const len = events.length
  for (var i = 0; i &amp;lt; len; i++) {
    if (el.style[i]) {
      return events[i];
    }
  }
}

/**
 * css过渡动画组件
 *
 * @visibleName Transition 过渡动画
 */
class Transition extends React.Component {

  static propTypes = propTypes

  static defaultProps = defaultProps

  onEnd = e =&amp;gt; {
    const { onEnd, action, exist } = this.props
    if (onEnd) {
      onEnd(e)
    }
    // 卸载 DOM 元素
    if (!action &amp;amp;&amp;amp; exist) {
      const node = e.target.parentNode
      node.parentNode.removeChild(node)
    }
  }

  /**
   * 对动画结束事件 onEnd 回调的处理函数
   *
   * @param {string} type - 事件解绑定类型: add - 绑定事件，remove - 移除事件绑定
   */
  handleEndListener (type = 'add') {
    const el = ReactDOM.findDOMNode(this).querySelector('.transition-wrapper')
    const events = ['AnimationEnd', 'TransitionEnd']
    events.forEach(ev =&amp;gt; {
      const eventType = whichEvent(el, [ev.toLowerCase(), `webkit${ev}`])
      el[`${type}EventListener`](eventType, this.onEnd, false)
    })
  }

  componentDidMount () {
    this.handleEndListener()
  }

  componentWillUnmount() {
    const { action, exist } = this.props
    if (!action &amp;amp;&amp;amp; exist) {
      this.handleEndListener('remove')
    }
  }

  render () {
    const {
      className,
      action,
      toggleClass,
      enterClass,
      leaveClass,
      delay,
      duration,
      count,
      easing,
      reverse,
      children
    } = this.props

    // 动画样式
    const styleText = (() =&amp;gt; {
      let style = {}
      // 设置延迟时长
      if (delay) {
        style.transitionDelay = delay
        style.animationDelay = delay
      }
      // 设置播放时长
      if (duration) {
        style.transitionDuration = duration
        style.animationDuration = duration
      }
      // 设置播放次数
      if (count) {
        style.animationIterationCount = count
      }
      // 设置缓动函数
      if (easing) {
        style.transitionTimingFunction = easing
        style.animationTimingFunction = easing
      }
      // 设置动画方向
      if (reverse) {
        style.animationDirection = 'alternate'
      }
      return style
    })()

    const transition = (
      &amp;lt;div
        className={
          classnames({
            transition: true
          })
        }
        style={
          {
            position: 'relative',
            overflow: 'hidden'
          }
        }
      &amp;gt;
        &amp;lt;div
          className={
            classnames({
              'transition-wrapper': true,
              [className]: className,
              [toggleClass]: action &amp;amp;&amp;amp; toggleClass,
              [enterClass]: !toggleClass &amp;amp;&amp;amp; action &amp;amp;&amp;amp; enterClass,
              [leaveClass]: !toggleClass &amp;amp;&amp;amp; !action &amp;amp;&amp;amp; leaveClass,
            })
          }
          style={ styleText }
        &amp;gt;
          { children }
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )

    return transition
  }
}

export default Transition&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://wanshi.netlify.com/2020/02/26/2020-02-27-%E5%9F%BA%E4%BA%8E%20react%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20transition%20%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E7%BB%84%E4%BB%B6#more&quot;&gt;基于 React 实现一个 Transition 过渡动画组件&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 27 Feb 2020 16:00:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<og:description>过渡动画使 UI 更富有表现力并且易于使用。如何使用 React 快速的实现一个 Transition 过渡动画组件？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jofun/p/12375357.html</dc:identifier>
</item>
<item>
<title>Java synchronized 关键字详解 - SuperMaskv</title>
<link>http://www.cnblogs.com/supermaskv/p/12375331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/supermaskv/p/12375331.html</guid>
<description>&lt;h2 id=&quot;前置技能点&quot;&gt;前置技能点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;进程和线程的概念&lt;/li&gt;
&lt;li&gt;线程创建方式&lt;/li&gt;
&lt;li&gt;线程的状态状态转换&lt;/li&gt;
&lt;li&gt;线程安全的概念&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;synchronized-关键字的几种用法&quot;&gt;synchronized 关键字的几种用法&lt;/h2&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;修饰非静态成员方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized public void sync(){

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修饰静态成员方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized public static void sync(){

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类锁代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (类.class){

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象锁代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (this|对象){

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;synchronized 修饰非静态方法时可以看做是锁 this 对象，修饰静态方法时可以看做是锁方法所在的类。&lt;/p&gt;
&lt;h2 id=&quot;synchronized-关键字的根本机制&quot;&gt;synchronized 关键字的根本机制&lt;/h2&gt;
&lt;p&gt;各个线程想要访问被 synchronized 修饰的代码块，就要取得 synchronized 声明的锁。如果两个线程的目标是同一个锁，就会出现阻塞的现象，所以两个线程不能同时访问同一个锁下的代码，保证了多线程在执行时最终结果不会出错。这与共享变量是否为静态无关。&lt;/p&gt;
&lt;h2 id=&quot;几个例子&quot;&gt;几个例子&lt;/h2&gt;
&lt;h3 id=&quot;对象锁&quot;&gt;对象锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadDemo extends Thread {
    @Override
    public synchronized void run() {
        for (int i = 0; i &amp;lt; 10000; i++) {
            Main.i++;
        }
        System.out.println(&quot;执行完成&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接将继承的 run() 方法标记为 synchronized ，作用是对 Main 类中的 i 变量做 10000 次累加操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {
    static int i = 0;

    public static void main(String[] args) throws InterruptedException {
        ThreadDemo threadDemo=new ThreadDemo();
        Thread t1 = new Thread(threadDemo);
        Thread t2 = new Thread(threadDemo);
        Thread t3 = new Thread(threadDemo);
        Thread t4 = new Thread(threadDemo);

        t1.start();
        t2.start();
        t3.start();
        t4.start();

        t1.join();
        t2.join();
        t3.join();
        t4.join();
        System.out.println(i);
    }
}
//输出结果：
//执行完成
//执行完成
//执行完成
//执行完成
//40000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到当4个线程全部执行完毕之后，变量 i 成功的累加了 40000 次，没有出现丢失操作的情况。&lt;/p&gt;
&lt;p&gt;如果我们将 main() 方法修改如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {
    Thread t1 = new ThreadDemo();
    Thread t2 = new ThreadDemo();
    Thread t3 = new ThreadDemo();
    Thread t4 = new ThreadDemo();

    t1.start();
    t2.start();
    t3.start();
    t4.start();

    t1.join();
    t2.join();
    t3.join();
    t4.join();
    System.out.println(i);
}
//输出结果：
//执行完成
//执行完成
//执行完成
//执行完成
//27579&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到丢失了不少的累加操作。观察前后两个 main() 方法创建线程的方式可以发现，前面的 main() 方法是使用了同一个对象来创建了4个不同的线程，而后一个 main() 方法使用了4个不同的 ThreadDemo 对象创建了4个线程。我们用 synchronized 修饰的是一个非静态成员函数，相当于对该方法创建了 this 的对象锁。在第一个 main() 方法中使用同一个对象来创建 4 个不同线程就会让 4 个线程争夺同一个对象锁，这样，在同一时间内，仅能有一个线程能访问 synchronized 修饰的方法。而在第二种 main() 方法中，4 个线程各自对应一个对象锁，4 个线程之间没有竞争关系，对象锁自然无法生效。&lt;/p&gt;
&lt;h3 id=&quot;类锁&quot;&gt;类锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadDemo extends Thread {
    @Override
    public void run() {
        synchronized (ThreadDemo.class) {
            for (int i = 0; i &amp;lt; 10000; i++) {
                Main.i++;
            }
            System.out.println(&quot;执行完成&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将修饰方法的 synchronized 改为对 ThreadDemo.class 上锁的代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadDemo2 extends Thread {
    @Override
    public void run() {
        synchronized (ThreadDemo2.class) {
            for (int i = 0; i &amp;lt; 10000; i++) {
                Main.i++;
            }
            System.out.println(&quot;执行完成&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建一个相同的类命名为 ThreadDemo2 ，与 ThreadDemo 不同的是，ThreadDemo2 中，synchronized 对 ThreadDemo2.class 上锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {
    Thread t1 = new ThreadDemo();
    Thread t2 = new ThreadDemo();
    Thread t3 = new ThreadDemo2();
    Thread t4 = new ThreadDemo2();

    t1.start();
    t2.start();
    t3.start();
    t4.start();

    t1.join();
    t2.join();
    t3.join();
    t4.join();
    System.out.println(i);
}
//输出结果：
//执行完成
//执行完成
//执行完成
//执行完成
//33054&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4 个线程分别由 ThreadDemo 和 ThreadDemo2 来创建，显然得到的结果与预期的 40000 不符。如果我们将 ThreadDemo2 中的 synchronized 改为对 ThreadDemo.class 上锁：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadDemo2 extends Thread {
    @Override
    public void run() {
        synchronized (ThreadDemo.class) {
            for (int i = 0; i &amp;lt; 10000; i++) {
                Main.i++;
            }
            System.out.println(&quot;执行完成&quot;);
        }
    }
}
//输出结果：
//执行完成
//执行完成
//执行完成
//执行完成
//40000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，虽然是声明在两个不同的类中的 synchronized 代码块，但是由于都是对 ThreadDemo.class 上锁，所以 4 个线程之间还是建立了竞争关系，同时只能有一个线程访问被 synchronized 修饰的代码。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;所以 synchronized 关键字的本质是限制线程访问一段代码，而限制的条件就是，在所有被加上相同锁的代码上，同一时间，只能有一个线程在运行。这与你要修改什么样的共享变量无关。在我刚接触到的时候以为类锁和对象锁是分别针对静态共享变量和非静态共享变量的，但事实上锁的是要执行的代码块，而不是代码块将要访问的共享变量。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 15:52:00 +0000</pubDate>
<dc:creator>SuperMaskv</dc:creator>
<og:description>Java synchronized 关键字详解 前置技能点 进程和线程的概念 线程创建方式 线程的状态状态转换 线程安全的概念 synchronized 关键字的几种用法 1. 修饰非静态成员方法 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/supermaskv/p/12375331.html</dc:identifier>
</item>
<item>
<title>并发编程之线程池ThreadPoolExecutor - 烟雨星空</title>
<link>http://www.cnblogs.com/starry-skys/p/12375166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starry-skys/p/12375166.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在我们平时自己写线程的测试demo时，一般都是用new Thread的方式来创建线程。但是，我们知道创建线程对象，就会在内存中开辟空间，而线程中的任务执行完毕之后，就会销毁。&lt;/p&gt;
&lt;p&gt;单个线程的话还好，如果线程的并发数量上来之后，就会频繁的创建和销毁对象。这样，势必会消耗大量的系统资源，进而影响执行效率。&lt;/p&gt;
&lt;p&gt;所以，线程池就应运而生。&lt;/p&gt;
&lt;h2 id=&quot;线程池threadpoolexecutor&quot;&gt;线程池ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;可以通过idea先看下线程池的类图，了解一下它的继承关系和大概结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231441112-2139693756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它继承自AbstractExecutorService类，这是一个抽象类，不过里边的方法都是已经实现好的。然后这个类实现了ExecutorService接口，里边声明了各种方法，包括关闭线程池，以及线程池是否已经终止等。此接口继承自父接口Executor，里边只声明了一个execute方法。&lt;/p&gt;
&lt;p&gt;线程池就是为了解决单个线程频繁的创建和销毁带来的性能开销。同时，可以帮我们自动管理线程。并且不需要每次执行新任务都去创建新的线程，而是重复利用已有的线程，大大提高任务执行效率。&lt;/p&gt;
&lt;p&gt;我们打开 ThreadPoolExecutor的源码，可以看到总共有四个构造函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231441343-1023270084.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，前三个最终都会调用到最后一个构造函数。我们来看下这个构造函数都有哪些参数。（其实，多看下参数的英文解释就能明白其中的含义，看来英语对程序员来说是真的重要呀）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//核心构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
        if (corePoolSize &amp;lt; 0 ||
            maximumPoolSize &amp;lt;= 0 ||
            maximumPoolSize &amp;lt; corePoolSize ||
            keepAliveTime &amp;lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）corePoolSize&lt;/p&gt;
&lt;p&gt;代表核心线程数。每当新的任务提交过来的时候，线程池就会创建一个核心线程来执行这个任务，&lt;strong&gt;即使已经有其他的核心线程处于空闲状态。&lt;/strong&gt; 而当需要执行的任务数大于核心线程数时，将不再创建新的核心线程。&lt;/p&gt;
&lt;p&gt;其实，我们可以看下JDK提供的官方注释说明。even if they are idle，就照应上边的加粗字体。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231441500-819157257.png&quot;/&gt;&lt;br/&gt;此外，最后一句话说，除非allowCoreThreadTimeOut 这个参数被设置了值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231441650-2125158169.png&quot;/&gt;&lt;br/&gt;什么意思呢，可以去看下这个参数默认值是false，代表当核心线程在空闲状态时，即没有任务在执行，就会一直存活，不会销毁。而设置为true之后，就会有线程存活时间，即假如设置存活时间60秒，则60秒之后，如果没有新的可执行任务，则核心线程也会自动销毁。&lt;/p&gt;
&lt;p&gt;2）maximumPoolSize&lt;/p&gt;
&lt;p&gt;线程所允许的最大数量。即，当阻塞队列已满的时候，并且已经创建的线程数小于最大线程数，则会创建新的线程去执行任务。所以，这个参数只有在阻塞队列满的情况下才有意义。因此，对于无界队列，这个参数将会失去效果。&lt;/p&gt;
&lt;p&gt;3）keepAliveTime&lt;/p&gt;
&lt;p&gt;代表线程空闲后，保持存活的时间。也就是说，超过一定的时间没有任务执行，线程就会自动销毁。&lt;/p&gt;
&lt;p&gt;注意，这个参数，是针对大于核心线程数，小于最大线程数的那部分非核心线程来说的。如果是任务数量特别多的情况下，可以适当增加这个参数值的大小。以保证，在下个任务到来之前，此线程不会立即销毁，从而避免线程的重新创建。&lt;/p&gt;
&lt;p&gt;4）unit&lt;/p&gt;
&lt;p&gt;这个是描述存活时间的时间单位。可以使用TimeUnit里边的枚举值。&lt;/p&gt;
&lt;p&gt;5）workQueue&lt;/p&gt;
&lt;p&gt;代表阻塞队列，存储所有等待执行的任务。&lt;/p&gt;
&lt;p&gt;6）threadFactory&lt;/p&gt;
&lt;p&gt;代表用来创建线程的工厂。可以自定义一个工厂，传参进来。如果不指定的话，就会使用默认工厂（Executors类里边的 DefaultThreadFactory）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231442005-520949970.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，会给每个线程的名字指定一个有规律的前缀。并且每个线程都设置相同的优先级（优先级总共有三个，1、5、10）。优先级可以理解为，优先级高的线程被执行的概率会更高，但是不代表优先级高的线程一定会先执行。&lt;/p&gt;
&lt;p&gt;7）handler&lt;/p&gt;
&lt;p&gt;这个参数代表，拒绝策略。当阻塞队列和线程池都满了，即达到了最大线程数，会用什么策略来处理。一共有四种策略可供选择，分别对应四个内部类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy：直接拒绝，并抛出异常，这也是默认的策略。&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：直接让调用execute方法的线程去执行此任务。&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃最老的未处理的任务，然后重新尝试执行当前的新任务。&lt;/li&gt;
&lt;li&gt;DiscardPolicy：直接丢弃当前任务，但是不抛异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下线程池的执行过程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当线程数量未达到corePoolSize的时候，就会创建新的线程来执行任务。&lt;/li&gt;
&lt;li&gt;当核心线程数已满，就会把任务放到阻塞队列。&lt;/li&gt;
&lt;li&gt;当队列已满，并且未达到最大线程数，就会新建非核心线程来执行任务。&lt;/li&gt;
&lt;li&gt;当队列已满，并且达到了最大线程数，则选择一种拒绝策略来执行。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程池常用的一些方法&quot;&gt;线程池常用的一些方法&lt;/h2&gt;
&lt;p&gt;我们一般用 execute 方法来提交任务给线程池。当线程需要返回值时，可以使用submit 方法。&lt;/p&gt;
&lt;p&gt;shutdown方法用来关闭线程池。注意，此时不再接受新提交的任务，但是，会继续处理正在运行的任务和阻塞队列里边的任务。&lt;/p&gt;
&lt;p&gt;shutdownNow也会关闭线程池。但是，它不再接受新任务，并且会尝试终止正在运行的任务。&lt;/p&gt;
&lt;h2 id=&quot;用executors创建线程池&quot;&gt;用Executors创建线程池&lt;/h2&gt;
&lt;p&gt;了解了线程池工作流程之后，那么我们怎样去创建它呢。&lt;/p&gt;
&lt;p&gt;Executors类提供了四种常用的方法。可以发现它们最终都调用了线程池的构造方法。都有两种创建方式，其中一种可以传自定义的线程工厂。此处，只贴出不带工厂的方法便于理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1714084/202002/1714084-20200227231442199-1016590461.png&quot;/&gt;&lt;br/&gt;①newFixedThreadPool&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个固定大小的线程池。核心线程数和最大线程数相等。当线程数量达到核心线程数时，新任务就会放到阻塞队列里边等待执行。&lt;/p&gt;
&lt;p&gt;②newSingleThreadExecutor&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个核心线程数和最大线程数都是1的线程池。即线程池中只会存在一个正在执行的线程，若线程空闲则执行，否则把任务放到阻塞队列。&lt;/p&gt;
&lt;p&gt;③ newCachedThreadPool&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个可根据实际情况调整线程个数的线程池。这句话，可以理解为，有多少任务同时进来，就会创建同等数量的线程去执行任务。当然，这是在线程数不能超过Integer最大值的前提下。&lt;/p&gt;
&lt;p&gt;当再来一个新任务时，若有空闲线程则执行任务。否则，等线程空闲60秒之后，就会自动回收。&lt;/p&gt;
&lt;p&gt;当没有新任务，就不会创建新的线程。&lt;/p&gt;
&lt;p&gt;④newScheduledThreadPool&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
}
    
public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个可指定核心线程数的线程池。这个线程池可以执行周期性的任务。&lt;br/&gt;如果本文对你有用，欢迎点赞，评论，转发。&lt;/p&gt;
&lt;p&gt;学习是枯燥的，也是有趣的。我是「烟雨星空」，欢迎关注，可第一时间接收文章推送。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 15:15:00 +0000</pubDate>
<dc:creator>烟雨星空</dc:creator>
<og:description>前言 在我们平时自己写线程的测试demo时，一般都是用new Thread的方式来创建线程。但是，我们知道创建线程对象，就会在内存中开辟空间，而线程中的任务执行完毕之后，就会销毁。 单个线程的话还好，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/starry-skys/p/12375166.html</dc:identifier>
</item>
<item>
<title>猴子都能懂的数据库避坑指南 - 小二十七</title>
<link>http://www.cnblogs.com/xiao2shiqi/p/12375139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao2shiqi/p/12375139.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;工作的这些年发现一个比较奇怪的现象就是身边无论是工作十多年的老兵，还是初级刚入行的程序员，在高谈阔论技术和趋势的时候都是人工智能，大数据，区块链，各种框架，语言，算法，AI，BI，CI，DI…… 等等，倒是发现很少有人关注数据库，不知道是因为数据库感觉太低端还是太低调，总是不容易被人提起&lt;/p&gt;
&lt;p&gt;技术就是这样，不太关注的地方就不会重视，越是不被重视的地方，掉进坑里的概率就会越大，所以就在这里给大家简单聊聊在使用数据库过程中有哪些防掉坑指南，也可以对刚入行的小朋友有一个提醒的作用，万丈高楼平地起，一定要先打好基础再去考虑上层的建筑，不要舍本逐末&lt;/p&gt;
&lt;p&gt;本章主要分以下四个小节（预计读完 5 分钟左右）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库为什么重要&lt;/li&gt;
&lt;li&gt;数据库有哪些使用技巧&lt;/li&gt;
&lt;li&gt;数据库有哪些容易掉进去的坑？&lt;/li&gt;
&lt;li&gt;深入学习数据库的建议&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;数据库为什么重要&quot;&gt;数据库为什么重要&lt;/h3&gt;
&lt;p&gt;很多人在开发过程中不太关注数据库，对于表结构的设计也没什么讲究大多属于“能用就行”，但是根据作者将近十年的开发经验来看的话，只要你是从事 Web 相关领域开发你就无法避免不和数据库打交道，&lt;strong&gt;在Web开发中大多功能操作本质上都是对数据库进行操作&lt;/strong&gt;，不管你用是 Pythod，Java，Ruby 等语言进行 Web 开发，你其实都是在面向数据库进行编程，很多 Web 框架作者为了避免程序员接触数据库的相关知识甚至还封装了一层 ORM （Object Relational Mapping 对象关系映射），把数据库当做一个黑盒子，然后通过操作对象的形式来操作数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230931419-1105673796.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然某种意义上是简化的开发，对此我是持有保留意见的，因为对于程序员来说很有必要了解你的 SQL 语言在数据库是怎么执行的，你不仅需要使用 explain 执行计划来查看你的 SQL 是否高效（扫描行数，命中索引，回表，排序等），对比不同 SQL 的写法外，你还需要知道如何使用 show index 来查看你的索引是否高效（通过 Cardinality 由数据库评估），这些技巧很大程度依赖你对 SQL 的了解，&lt;strong&gt;SQL 对于程序员来说也是一门非常重要的技能&lt;/strong&gt;，没错 SQL 就是操作数据库的语言，据我了解大多数的公司在面试的时候都会考察程序员的 SQL 功底，扎实的 SQL 功底不仅可以让你写出高性能的查询语言外，对于数据分析，报表统计也是有非常大的帮助&lt;/p&gt;
&lt;p&gt;大多数商业公司的核心资产其实就是数据库里面的数据，是非常宝贵的财富，程序和系统挂了，最多就是一段时间不可用，大多是情况重启就可以恢复，但是是数据库不小心被误删了，如果是运维能力差的中小企业可能会面临倒闭的地步，从商业角度上来说数据库大多数软件公司的核心&lt;/p&gt;
&lt;p&gt;很多程序员从菜鸟成长到高手，接触的项目从学校的&quot;某某管理系统&quot;到刚加入公司内部系统，然后再到大型分布式系统，在大型系统中，大多数人程序员通常遇到的第一个问题通常不是线程不够用，不是CPU负载过高，不是内存不够快，通常都是数据库扛不住压力了，为什么呢？数据库本身就基于磁盘的文件系统，每次读取数据都是通过 I/O 去访问磁盘，了解计算机原理的同学应该都知道，在冯诺依曼计算机体系结构里磁盘 I/O 号称是最慢的 I/O （毫秒级），通常在你的系统只有几千上万的数据量时，全表扫描通常不会有很大的延迟感，但是当你的存量数据达到百万千万时，那么一次普通的查询就会把你的数据库服务器撑爆，做过应用的人都知道，数据库挂了，不管是什么分布式，微服务的牛逼架构都基本没啥用了，唠唠叨叨说到这里，相信大家应该已经知道数据库的重要性的，后面我们再从数据库设计的角度来看下问题&lt;/p&gt;
&lt;h5 id=&quot;数据库设计对系统的影响&quot;&gt;数据库设计对系统的影响&lt;/h5&gt;
&lt;p&gt;这里我们简单做一个对比，良好的数据库设计可以为你带来什么 ？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少数据冗余，避免数据维护异常&lt;/li&gt;
&lt;li&gt;节省存储空间，高效的访问速度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;糟糕的设计 ？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;大量数据冗余插入，更新，删除异常&lt;/li&gt;
&lt;li&gt;浪费存储空间，低效的访问速度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230931712-1928949843.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;糟糕的设计（图）&lt;/p&gt;
&lt;p&gt;比如说对于一个简单的年龄字段，严谨来说应该使用 tinyint（1字节）或者 smallint(2字节)，但是你偏偏要用 int (4字节) 这就属于糟糕的字段选择，看到这里很多刚入门的同学就可能就会反驳了，这么在意空间利用是不是有点矫枉过正？包括存储已经很便宜了，还这么斤斤计较般的选择，反正最终实现的功能都是相同的，别人也看不出什么差别呀。对于这种观点其实我想反驳一下，这是典型的新手思维，你只在看到在单个字段上的空间节省，但是没有考虑过数据也是在持续增长，糟糕的设计越到后期增长成本会越高（这里就类似于 Java 的经典面试题，集合类 ArrayList 和 LinkedList 在少量数据对比时看不出时间上的差距，但是随着计算数据量的上升，消耗数据的差距也会越拉越大），等到了千万级数据量的时候，可能你设计的表和别人设计的表是相同的内容，但是你的表无端的多出几百G的存储空间，如果你的应用还是多数据中心的话，那么这种无端的空间浪费还会被拷贝几十倍到不同的数据中心，而且只要你的应用还在线上运行，那么这种增长所带来的成本还会持续上升，这里也仅仅只是说对空间的浪费，下面在分析表结构存储上，还会具体说一下糟糕的设计对于性能会有多大的影响，这对企业来说就是边际成本的递增，从技术和架构上来说就会让你的系统不具备可扩展性&lt;/p&gt;
&lt;h3 id=&quot;数据库的使用技巧&quot;&gt;数据库的使用技巧&lt;/h3&gt;
&lt;h5 id=&quot;存储引擎的注意事项&quot;&gt;存储引擎的注意事项&lt;/h5&gt;
&lt;p&gt;MySQL 的开放性架构设计兼容了很多不种类的存储引擎（要是你足够厉害的话，也可以自己写一套存储引擎），存储引擎的设计初衷就是应对不同类型的数据仓库，工作中有见过不管什么表都直接用 Innodb（MySQL 5.0 的默认存储引擎，虽然大多数场景是不错的选择，但不是所有类型的表结构都适用）也见过根本不知道什么是存储引擎的同学，如果这些同学来设计数据库的话，那么你的系统就很容易踩到坑，出现很多你自己的预料不到的问题，合理的存储引擎的选择是应该结合实际业务场景，从目前最主流的 MySQL 来说，最常用的存储引擎主要是 MyISAM， Innodb，当然还有很多其他的存储引擎，例如 NDB(集群存储引擎)，Memory（基于内存的存储引擎），Archive（归档存储引擎），因为这些平时使用不多，并不主流，工作中也很少用得到，意义不大，所以就不展开来讲，这里主要简单将下 MyISAM，Innodb 的区别，主要有以下特点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无事务机制，表级锁，自带计数功能（count 全表毫秒级响应）&lt;/li&gt;
&lt;li&gt;主要面向 OLAP 型应用，适合存储报表日志等类型数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Innodb&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;行级别，高并发，支持事务，四种事务隔离级别（MySQL 5.0+ 默认是读已提交）&lt;/li&gt;
&lt;li&gt;主要面向 OLTP 型应用，适合存储小量的事务型数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230932178-318839215.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;字段类型的注意事项&quot;&gt;字段类型的注意事项&lt;/h5&gt;
&lt;p&gt;因为不了解数据库的基本原理，所以很多初级程序员在选择数据库字段类型的时候比较迷茫，主要还是没有明确指导原则，工作中我见过在只有十几条数据的基础信息表中使用 long（8字节）作为 id 主键类型，还有就像上面说的状态类型字段只有 0，1 值的字段使用 int （4字节），还见过字符类型字段统一使用 varchar(255)，数值类型字段统一使用 int，这种不基于数据库原理规则去随意选择字段的行为也只会出现在你 LocalHost 里的一些小项目或者玩具，基本上不了什么大台面&lt;/p&gt;
&lt;p&gt;据我所知，主流的数据库大多都提供非常丰富的字段类型给开发者使用，老司机都是基于业务类型的判断从而选择合适的字段类型，最终收获的是性能（时间）和存储（空间）都非常低的高性能数据库，具体数据库有哪些字段类型，文章里面就不多数了，这方面的资料简直太多了，有兴趣的小伙伴可以自己去搜索，例如这里 &lt;a href=&quot;https://www.tutorialrepublic.com/sql-reference/mysql-data-types.php&quot;&gt;MySQL Data Types&lt;/a&gt;，那么对于新手而言如何选择字段类型呢？&lt;/p&gt;
&lt;p&gt;简单的基本原则如下：（后面会具体将原因）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优先数字型字段（比如尽量使用 int 作为数据库主键 id 的类型而不是 varchar）&lt;/li&gt;
&lt;li&gt;在满足需求的前提下，字段类型尽量足够的小（例如 age 字段应该考虑使用 tinyint 而不是 int 或者 long 类型）&lt;/li&gt;
&lt;li&gt;时间字段考虑 timestamp （4字节，支持 UTC）而不是 datetime（8字节，不支持 UTC）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;遵循基本规范能带来什么好处？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;节省存储的开销，避免空间浪费（如果1条数据造成的空间开销n，那么随着数据增长，浪费空间的比例也就是 n * n）&lt;/li&gt;
&lt;li&gt;最好的性能（用户体验，另一种角度的节省资源-算力）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么要把“选择尽可能小的字段”作为基本原则？我们可以先看下 innodb 的逻辑存储结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230933003-350290973.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;innodb 逻辑存储结构（图）&lt;/p&gt;
&lt;p&gt;innodb 的存储结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表空间（Tablespace）&lt;/li&gt;
&lt;li&gt;段（Segment）：表空间由多个段组成&lt;/li&gt;
&lt;li&gt;区（Extent）：单个区由 64 个连续页（Page）组成&lt;/li&gt;
&lt;li&gt;页（Page）：磁盘的最小单位，默认大小 16 KB&lt;/li&gt;
&lt;li&gt;行（Row）：每条记录，也称行数据，数据存储在页中 Page&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上图可以看到读取最小单元 Page，匹配的数据都是从 Page 里面取出，按照这个简单的逻辑来说页中存储的行数据越多，数据库的性能就越高，怎么算出来的呢？按最小类型 2B 来计算 Row，那么 Page 的默认大小（16KB）是可以匹配到 7992 行记录，相反，如果你的 Row 行数据过大，假如一行 32 KB，那么数据库就需要 2 个连续的 Page 来保存你一行的数据，那么性能可想而知会有多低，&lt;strong&gt;前后性能差距差不多 1.6 万倍&lt;/strong&gt;，这块也不深入讲了，有兴趣的小伙伴推荐去阅读经典书籍，这里的内容也只是书里的冰山一角&lt;/p&gt;
&lt;h5 id=&quot;选择索引的注意事项&quot;&gt;选择索引的注意事项&lt;/h5&gt;
&lt;p&gt;索引是一种用空间换时间的优化手段，是数据库最重要的优化手段，也是最后的杀手锏，索引是否高效取决数据库设计是否良好，字段类型选择是否合理，索引是一把双刃剑，在提升检索速度的时候，也会减低插入，修改的性能（维护索引树的开销），在工作中这些年面试了不下几百人发现能把数据库索引原理讲明白的候选人非常的少，大多数情况下我们说索引通常默认指的是 BTREE 索引，BTREE 结构是特意为磁盘 I/O 这种缓慢的读取存储设计的数据结构，是一棵多路多叉树，和二叉树相反，每层的元素非常多，但是树的高度很矮（通常不会超过三层），从而可以保证最多不超过三次磁盘 I/O 即可定位到匹配的元素，所以说 BTREE 是一种非常适合磁盘的数据结构，也是 MySQL 默认索引类型是 BREE 的原因，如果能把这块吃透的话，那么去面试肯定是很大的加分项，索引在数据库可以简单参考下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230934646-1402354702.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单说了下索引的结构，那么新手程序员在使用数据库所以的时候可以遵循以下原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;明白索引不是越多越好，过多的索引会降低读/写效率&lt;/li&gt;
&lt;li&gt;数据小和选择性低的列没有必要建索引（就像没必要为只有几页的书建目录）&lt;/li&gt;
&lt;li&gt;定期维护索引（移除不必要的索引，索引的最左匹配原则）&lt;/li&gt;
&lt;li&gt;谨慎使用全文索引，哈希索引，谨慎使用 FORCE INDEX 强制索引（强制会干扰优化器对索引选择的判断）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;索引这块可以玩的还有很多，例如如何通过 SHOW INDEX 查看数据库为索引做出的评级（通过 Cardinality 统计），通过 Explain 查看 SQL 是否命中索引，rows 列可以看到 SQL 扫描的数据行数，Extra 列还可以查看索引匹配的类型，例如 Using index 代表完全匹配索引（无需回到 Primary Key 表查询数据，也称回表，甚至直接使用索引的排序，无需排序）往往说明性能不错，Using temporary 代表查询有使用临时表，一般出现于排序，多表 join 的情况，查询效率不高，建议优化&lt;/p&gt;
&lt;h3 id=&quot;还有哪些要避开的坑&quot;&gt;还有哪些要避开的坑？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230935049-1912481134.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人生总会遇到很多坑，与其自己去踩坑不如去总结别人踩过的坑，自己少走一些弯路也许可以更快的成功，这里是最后一章，不想把文章拉的太长，所以我在这里就直接抛出结论，不会再说明原因，如果对数据库有兴趣推荐看到最后我推荐的书籍&lt;/p&gt;
&lt;p&gt;避免使用触发器/存储过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用存储过程写逻辑会导致代码非常的复杂难懂，并且难以定位问题&lt;/li&gt;
&lt;li&gt;降低数据库的性能（数据库不应该执行除 SQL 外的其他逻辑操作）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;避免使用预留字段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法准确预测字段类型&lt;/li&gt;
&lt;li&gt;增加后期维护成本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;反范式设计&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不必完全遵守古板的三大范式，对范式进行违反，用空间换时间&lt;/li&gt;
&lt;li&gt;对数据进行有计划的冗余，可以达到减少关联，提高性能和效率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽量避免使用 Null 字段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Null 值会导致索引失效，让统计函数更加复杂，另外 Null 还会占用额外的空间（数据库需要额外标记）&lt;/li&gt;
&lt;li&gt;对于 Null 值，数据库程序通常都会进行额外的逻辑处理，奖励数据库性能&lt;/li&gt;
&lt;li&gt;从数据库中取出 Null 值容易造成程序出错，还会增加很多 if != null 的重复模板代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最后-end&quot;&gt;最后 end&lt;/h3&gt;
&lt;p&gt;这篇文章写了三天（空闲时间），主要覆盖篇幅比较广，但是每个主题都是在幼儿园的入门水平，主要是给很多新手程序员一个简单的参考，我个人认为看文章分享只是为了点燃兴趣，就像一道开胃菜，最终的形成自己的知识体系，熟悉知识完整的结构还是推荐去阅读经典的书籍，这才是学习的正确姿势，数据库的书我读的不是很多，但还是可以简单推荐两本我读过的并且感觉非常不错的，并且本篇文章都是大量参考了书中的内容，非常值得推荐：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《MySQL 技术内幕 InnoDB 存储引擎》：这本书主要偏向对存储引擎的分析，对不同存储引擎的性能，存储结构和适用场景做了横向对比，作者最后还在表分区，约束和索引等技术上给出自己的见解，我在看这本书的时候无不佩服作者对存储引擎的了解程度&lt;/li&gt;
&lt;li&gt;《高性能 MySQL》：这本可以说是 MySQL 的百科全书，内容覆盖非常全面，是公认 MySQL 领域的圣经级教科书，唯一的缺点就是太厚了，第三版都已经快 800 页了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230936143-720119247.jpg&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230938081-82290193.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得推荐的书就以上两本，如果觉得看书不过瘾可以再推荐看看极客时间的 《MySQL 实战 45 讲》是由鼎鼎大名的数据库大神丁奇所写的专栏，如果用开药来比喻的话，看书就是内服，看专栏就等于外敷，总结就是，内服 + 外敷 疗效可能会好一些，最后打一波广告：如果要买极客时间专栏可以加我微信，我有推荐二维码并且返现红包，666666&lt;br/&gt;更多技术咨询，请关注公众号，find me !&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840117/202002/840117-20200227230938931-1811848728.jpg&quot; alt=&quot;alt 微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 15:10:00 +0000</pubDate>
<dc:creator>小二十七</dc:creator>
<og:description>前言 工作的这些年发现一个比较奇怪的现象就是身边无论是工作十多年的老兵，还是初级刚入行的程序员，在高谈阔论技术和趋势的时候都是人工智能，大数据，区块链，各种框架，语言，算法，AI，BI，CI，DI……</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiao2shiqi/p/12375139.html</dc:identifier>
</item>
</channel>
</rss>