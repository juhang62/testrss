<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小书MybatisPlus第6篇-主键生成策略精讲 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13364279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13364279.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200723084132880-1154005138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文为mybatis系列文档的第6篇，前5篇请访问下面的网址。&lt;/p&gt;
&lt;p&gt;Mybatis Plus 为我们提供了三种设置 主键生成策略的方式。它们的优先级顺序是：局部注解 &amp;gt; 全局 &amp;gt; 默认(雪花算法)。下面我们来一一介绍&lt;/p&gt;
&lt;h2 id=&quot;一、默认主键生成策略：雪花算法&quot;&gt;一、默认主键生成策略：雪花算法&lt;/h2&gt;
&lt;p&gt;Mybatis Plus如果不做任何主键策略配置，默认使用的是雪花算法。该策略会根据雪花算法生成主键ID，主键类型为Long或String（具体到MySQL数据库就是BIGINT和VARCHAR），该策略使用接口IdentifierGenerator的方法nextId（默认实现类为DefaultIdentifierGenerator雪花算法）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;snowflake算法是Twitter开源的分布式ID生成算法，结果是一个long类型的ID 。其核心思想：使用41bit作为毫秒数，10bit作为机器的ID（5bit数据中心，5bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每个毫秒可以产生4096个ID），最后还有一个符号位，永远是0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、自定义主键策略&quot;&gt;二、自定义主键策略&lt;/h2&gt;
&lt;p&gt;mybatis-plus3.3.0以后，主要有五种主键生成策略。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum IdType {
    /**
     * 数据库ID自增,数据库需要支持主键自增(如MySQL)，并设置主键自增
     */
    AUTO(0),

    /**
     * 该类型为未设置主键类型,默认使用雪花算法生成
     */
    NONE(1),

    /**
     * 用户输入ID,数据类型和数据库保持一致就行
     * &amp;lt;p&amp;gt;该类型可以通过自己注册自动填充插件进行填充&amp;lt;/p&amp;gt;
     */
    INPUT(2),

    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 全局唯一ID (idWorker),数值类型  数据库中也必须是数值类型 否则会报错
     */
    ID_WORKER(3),
    /**
     * 全局唯一ID (UUID，不含中划线)
     */
    UUID(4),
    /**
     * 字符串全局唯一ID (idWorker 的字符串表示)，数据库也要保证一样字符类型
     */
    ID_WORKER_STR(5);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、局部注解配置策略&quot;&gt;三、局部注解配置策略&lt;/h2&gt;
&lt;p&gt;我们针对主键设置主键策略使用注解方式为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@TableId(type = IdType.AUTO)
private long userId;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、全局配置策略&quot;&gt;四、全局配置策略&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mybatis-plus:
  global-config:
    db-config:
      id-type: auto
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、扩展使用&quot;&gt;五、扩展使用&lt;/h2&gt;
&lt;h3 id=&quot;51input用户输入id策略的用法&quot;&gt;5.1.INPUT用户输入ID策略的用法&lt;/h3&gt;
&lt;p&gt;其中需要和大家特殊介绍的是：Input（用户输入ID），这个ID来源可以有两种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户自己设置ID，并在insert之前SET主键的值&lt;/li&gt;
&lt;li&gt;一些有序列的数据库，比如Oracle，SQLServer等，针对这些数据库我们可以通过序列填充ID字段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mybatis-Plus 内置了如下数据库主键序列（如果内置支持不满足你的需求，可实现 IKeyGenerator 接口来进行扩展）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DB2KeyGenerator&lt;/li&gt;
&lt;li&gt;H2KeyGenerator&lt;/li&gt;
&lt;li&gt;KingbaseKeyGenerator&lt;/li&gt;
&lt;li&gt;OracleKeyGenerator&lt;/li&gt;
&lt;li&gt;PostgreKeyGenerator&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以Oracle 的Sequence使用方法为例，使用方法如下：&lt;br/&gt;首先添加@Bean&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @Bean
    public OracleKeyGenerator oracleKeyGenerator(){
        return new OracleKeyGenerator();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后实体类配置主键 Sequence，指定主键策略为 IdType.INPUT 即可,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@KeySequence(value = &quot;SEQ_USER&quot; , clazz = Long.class)
public class User {

    @TableId(value = &quot;ID&quot;,type = IdType.INPUT)
    private Integer id;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jul 2020 00:42:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文为mybatis系列文档的第6篇，前5篇请访问下面的网址。 小书MybatisPlus第1篇-整合SpringBoot快速开始增删改查 小书MybatisPlus第2篇-条件构造器的应用及总结 小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13364279.html</dc:identifier>
</item>
<item>
<title>Python 简明教程 --- 25，Python 目录操作 - 码农充电站</title>
<link>http://www.cnblogs.com/codeshell/p/13364276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codeshell/p/13364276.html</guid>
<description>&lt;blockquote readability=&quot;3.1875&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信公众号：码农充电站pro&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;个人主页：&lt;a href=&quot;https://codeshellme.github.io&quot;&gt;https://codeshellme.github.io&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;做技术一定要一颗恒心，这样才不会半途而废。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200721190921345.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一节我们介绍了文件相关的操作，本节我们来介绍&lt;code&gt;目录&lt;/code&gt;相关的操作。&lt;/p&gt;
&lt;h3 id=&quot;1，os-模块&quot;&gt;1，&lt;code&gt;os&lt;/code&gt; 模块&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;os&lt;/code&gt; 模块是Python 中的内建模块，该模块中包含许多系统相关的操作。我们要介绍的目录相关的操作，也都包含在该模块中。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;dir(os)&lt;/code&gt; 来查看该模块中所有属性和函数，共有几百个属性和函数。这里我们只介绍一部分函数，可以使用&lt;code&gt;help(os.函数名)&lt;/code&gt; 来查看某个函数的帮助手册。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;os.linesep&lt;/code&gt;：获取当前系统的行的&lt;code&gt;换行符&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;：获取当前工作目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.listdir(path=None)&lt;/code&gt;：列出&lt;code&gt;path&lt;/code&gt; 路径中的所有&lt;code&gt;文件&lt;/code&gt;和&lt;code&gt;目录&lt;/code&gt;。&lt;code&gt;path&lt;/code&gt; 为&lt;code&gt;None&lt;/code&gt; 时，表示当前目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.abspath(path)&lt;/code&gt;：获取&lt;code&gt;path&lt;/code&gt; 的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isfile(path)&lt;/code&gt;：判断&lt;code&gt;path&lt;/code&gt; 是否是一个文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isdir(path)&lt;/code&gt;：如果&lt;code&gt;path&lt;/code&gt; 存在且为目录，则返回&lt;code&gt;True&lt;/code&gt;，否则返回&lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isabs(path)&lt;/code&gt;：判断&lt;code&gt;path&lt;/code&gt; 是否是一个绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.exists(path)&lt;/code&gt;：判断&lt;code&gt;path&lt;/code&gt; 是否存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.split(file)&lt;/code&gt;：返回&lt;code&gt;file&lt;/code&gt; 的路径名与文件名，返回值是一个元组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.splitext(file)&lt;/code&gt;：返回&lt;code&gt;file&lt;/code&gt; 的&lt;code&gt;路径&lt;/code&gt;与&lt;code&gt;扩展名&lt;/code&gt;，返回值是一个元组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.dirname(path)&lt;/code&gt;：返回&lt;code&gt;path&lt;/code&gt;的目录 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.basename(path)&lt;/code&gt;：返回&lt;code&gt;path&lt;/code&gt; 的文件名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.rename(old, new)&lt;/code&gt;： 将文件或目录&lt;code&gt;old&lt;/code&gt; 重命名为&lt;code&gt;new&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.mkdir(dir)&lt;/code&gt;：创建目录，&lt;code&gt;dir&lt;/code&gt; 只能是单级目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.makedirs(dir)&lt;/code&gt;：创建目录，&lt;code&gt;dir&lt;/code&gt; 可以是单级目录，也可以是多级目录 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.rmdir(dir)&lt;/code&gt;：删除目录，&lt;code&gt;dir&lt;/code&gt; 只能是空目录，否则抛出异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.remove(path)&lt;/code&gt;：删除文件，如果出现错误将抛出&lt;code&gt;异常&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.removedirs(path)&lt;/code&gt;：删除目录，且该目录中不能有其它文件或目录，也就是该目录必须为空，否则将出现异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.stat(path)&lt;/code&gt;：获取文件或目录的状态信息，比如创建时间，大小等。其返回值为&lt;code&gt;os.stat_result&lt;/code&gt;类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.getsize(file)&lt;/code&gt;：返回&lt;code&gt;file&lt;/code&gt; 的大小 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.chmod(file)&lt;/code&gt;：修改&lt;code&gt;file&lt;/code&gt; 的访问权限。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.chdir(path)&lt;/code&gt;：从&lt;code&gt;当前目录&lt;/code&gt;切换到目录&lt;code&gt;path&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2，shutil-模块&quot;&gt;2，&lt;code&gt;shutil&lt;/code&gt; 模块&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;shutil&lt;/code&gt; 模块主要是用来操作文件和目录的。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;help(shutil)&lt;/code&gt; 查看该模块的帮助文档，使用&lt;code&gt;dir(shutil)&lt;/code&gt; 查看其支持的所有&lt;code&gt;类&lt;/code&gt;，&lt;code&gt;属性&lt;/code&gt;和&lt;code&gt;方法&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; dir(shutil)
['Error', 'ExecError', 'ReadError', 
'RegistryError', 'SameFileError', 
'SpecialFileError', '_ARCHIVE_FORMATS', 
'_BZ2_SUPPORTED', '_LZMA_SUPPORTED', 
'_UNPACK_FORMATS', '_ZLIB_SUPPORTED', 
'__all__', '__builtins__', '__cached__', 
'__doc__', '__file__', '__loader__', 
'__name__', '__package__', '__spec__', 
'_basename', '_check_unpack_options', 
'_copyxattr', '_destinsrc', 
'_ensure_directory', '_find_unpack_format', 
'_get_gid', '_get_uid', '_make_tarball', 
'_make_zipfile', '_ntuple_diskusage', 
'_rmtree_safe_fd', '_rmtree_unsafe', 
'_samefile', '_unpack_tarfile', 
'_unpack_zipfile', '_use_fd_functions', 
'chown', 'collections', 'copy', 'copy2', 
'copyfile', 'copyfileobj', 'copymode', 
'copystat', 'copytree', 'disk_usage', 
'errno', 'fnmatch', 'get_archive_formats', 
'get_terminal_size', 'get_unpack_formats', 
'getgrnam', 'getpwnam', 'ignore_patterns', 
'make_archive', 'move', 'os', 
'register_archive_format', 
'register_unpack_format', 
'rmtree', 'stat', 'sys', 'unpack_archive', 
'unregister_archive_format', 
'unregister_unpack_format', 'which']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3.6/library/shutil&quot;&gt;这里&lt;/a&gt;是该模块的官方文档，本节中我们只介绍少数几个操作，其它函数的用法，可参考其官方文档。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;shutil.copyfile(oldfile, newfile)&lt;/code&gt;：将文件&lt;code&gt;oldfile&lt;/code&gt;复制一份到&lt;code&gt;newfile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.copy(oldfile, new)&lt;/code&gt; ：将文件&lt;code&gt;oldfile&lt;/code&gt;复制一份到&lt;code&gt;new&lt;/code&gt;，返回新的文件名。&lt;code&gt;new&lt;/code&gt; 可以是文件，也可以是目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.copytree(olddir, newdir)&lt;/code&gt;：将整个目录&lt;code&gt;olddir&lt;/code&gt; ，递归拷贝到&lt;code&gt;newdir&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.move(src, dst)&lt;/code&gt;：将&lt;code&gt;src&lt;/code&gt; 移动到&lt;code&gt;dst&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree(dir)&lt;/code&gt;：删除整个目录树&lt;code&gt;dir&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（完。）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeshell/p/13197968.html&quot;&gt;Python 简明教程 --- 20，Python 类中的属性与方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeshell/p/13233821.html&quot;&gt;Python 简明教程 --- 21，Python 继承与多态&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeshell/p/13237874.html&quot;&gt;Python 简明教程 --- 22，Python 闭包与装饰器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeshell/p/13332048.html&quot;&gt;Python 简明教程 --- 23，Python 异常处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/codeshell/p/13344988.html&quot;&gt;Python 简明教程 --- 24，Python 文件读写&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注作者公众号，获取更多技术干货。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200505082843773.png?#pic_center&quot; alt=&quot;码农充电站pro&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Jul 2020 00:41:00 +0000</pubDate>
<dc:creator>码农充电站</dc:creator>
<og:description>微信公众号：码农充电站pro 个人主页：https://codeshellme.github.io 做技术一定要一颗恒心，这样才不会半途而废。 目录 上一节我们介绍了文件相关的操作，本节我们来介绍目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codeshell/p/13364276.html</dc:identifier>
</item>
<item>
<title>自已动手作图搞清楚AVL树 - 智慧zhuhuix</title>
<link>http://www.cnblogs.com/zhuhuix/p/13364271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuhuix/p/13364271.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;h4 id=&quot;一、背景&quot;&gt;一、背景&lt;/h4&gt;
&lt;p&gt;二叉树是一种常用的数据结构，更是实现众多算法的一把利器。（可参考&lt;a href=&quot;https://blog.csdn.net/jpgzhu/article/details/106943607&quot;&gt;《自己动手作图深入理解二叉树、满二叉树及完全二叉树》&lt;/a&gt;）&lt;br/&gt;&lt;span&gt;二分搜索树（Binary Search Tree）&lt;/span&gt;做为一种能实现快速定位查找的二叉树也得到了广泛应用（底层实现可参考&lt;a href=&quot;https://blog.csdn.net/jpgzhu/article/details/106921196&quot;&gt;《用一个图书库实例搞懂二分搜索树的底层原理》&lt;/a&gt;）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;1 二分搜索树是一颗二叉树&lt;br/&gt;2 二分搜索树每个节点的左子树的值都小于该节点的值，每个节点右子树的值都大于该节点的值&lt;br/&gt;3 任意一个节点的每棵子树都满足二分搜索树的定义&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623140545408.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;但二分搜索树也有其局限性：比如我们给定[1，2，3，4，5，6，7]这样的数据并按顺序构成的二分搜索树就褪化成了线性链表，二分搜索树极度偏向右侧，且深度达到7级，&lt;strong&gt;查找搜索的时间复杂度也从O(logn)褪化成了O(n)&lt;/strong&gt;.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200718092142124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二、平衡二分搜索树---avl树&quot;&gt;二、平衡二分搜索树---AVL树&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了解决二分搜索树的不平衡性，科学家创造一种自平衡的二分搜索树，这种树也被简称为AVL（G. M. &lt;span&gt;A&lt;/span&gt;delson-&lt;span&gt;V&lt;/span&gt;elsky和E. M. &lt;span&gt;L&lt;/span&gt;andis）树，以下的图即为一棵AVL树：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200718094247526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;21-avl树的基本概念&quot;&gt;2.1 AVL树的基本概念&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个&lt;strong&gt;结点&lt;/strong&gt;的左右子树的&lt;strong&gt;高度&lt;/strong&gt;之差（&lt;strong&gt;平衡因子&lt;/strong&gt;）不大于1的二分搜索树，即为AVL树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;结点&quot;&gt;结点&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;结点是组成二叉树的最小单元。&lt;br/&gt;-- 用图形表示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200718094821470.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;-- 用代码表示&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       // 结点
        class Node&amp;lt;E&amp;gt; {
        E e;
        Node left, right;

        Node(E e) {
            this.e= e;
            this.left = null;
            this.right = null;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;高度&quot;&gt;高度&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;叶子结点高度默认为1；非叶子结点的高度为该结点能到达的左子树或右子树的叶子结点的最大跨度。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200720104637689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;-- 用代码描述&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       class Node&amp;lt;E&amp;gt; {
        E e;
        Node left, right;
        // 高度
        int height;

        Node(E e) {
            this.e = e;
            this.left = null;
            this.right = null;
            // 叶子结点高度默认为1
            this.height = 1;
        }
    }
        // 获得节点node的高度
    private int getHeight(Node node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }
        // 计算结点的高度
    private void setHeight(Node node) {
        node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;平衡因子&quot;&gt;平衡因子&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;叶子结点的平衡因子为0；非叶子结点的平衡因子为该结点的左子结点或右子结点的高度差。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200720110351470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;-- 用代码描述&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       class Node&amp;lt;E&amp;gt; {
        E e;
        Node left, right;
        // 高度
        int height;

        Node(E e) {
            this.e = e;
            this.left = null;
            this.right = null;
            // 叶子结点高度默认为1
            this.height = 1;
        }
    }
        // 获得节点node的高度
    private int getHeight(Node node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }

        // 获得节点node的平衡因子
    private int getBalanceFactor(Node node){
        if(node == null)
            return 0;
        return getHeight(node.left) - getHeight(node.right);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;22-avl树的验证&quot;&gt;2.2 AVL树的验证&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200721080710145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按AVL的定义，判断一棵二叉树是否为AVL树
&lt;ul&gt;&lt;li&gt;首先需判断这棵二叉树是否为二分搜索树：&lt;strong&gt;即从根结点开始中序遍历该二叉树，形成的遍历序列一定是按从小到大有序排列的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;其实判断该二分搜索树的&lt;strong&gt;每个结点的平衡因子的绝对值是否超过1&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;-- 用代码描述&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * AVL树
 * @param &amp;lt;E&amp;gt; 泛型元素
 * @author zhuhuix
 * @date 2020-07-21
 */
public class AVL&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; {

    // 私有内部类-树结点
    private class Node&amp;lt;E&amp;gt; {
        E e;
        Node left, right;
        // 高度
        int height;

        Node(E e) {
            this.e = e;
            this.left = null;
            this.right = null;
            this.height = 1;
        }

    }

    // 根结点
    private Node root;

    // 获得节点node的高度
    private int getHeight(Node node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }

    // 计算结点的高度
    private int setHeight(Node node) {
        return node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
    }

    // 获得节点node的平衡因子
    private int getBalanceFactor(Node node) {
        if (node == null) {
            return 0;
        }
        return getHeight(node.left) - getHeight(node.right);
    }

    // 增加元素
    public void add(E e) {
        root = addNode(root, e);
    }

    // 通过递归算法遍历现有结点，将新结点插入到合适的位置
    private Node addNode(Node node, E element) {

        if (node == null) {
            System.out.println(&quot;新增元素[&quot; + element + &quot;] height=1&quot;);
            return new Node(element);
        }

        // 新加入元素小于结点值，往左子树增加
        if (element.compareTo((E) node.e) &amp;lt; 0) {
            node.left = addNode(node.left, element);
            // 新加入元素大于结点值，往右子树增加
        } else if (element.compareTo((E) node.e) &amp;gt; 0) {
            node.right = addNode(node.right, element);
        } else // element.compareTo(node.e) == 0
        {
            node.e = element;
        }
        // 更新height
        node.height = setHeight(node);
        System.out.println(&quot;元素[&quot; + node.e + &quot;] 更新高度： height=&quot; + node.height);
        return node;
    }

    // 判断二叉树是否为二分搜索树:从根结点中序遍历形成的序列是否从小到大有序排列
    public boolean isBST() {
        ArrayList&amp;lt;E&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
        InOrderTraversal(root, arrayList);
        for (int i = 0; i &amp;lt; arrayList.size() - 1; i++) {
            // 相邻两个元素比较，如果前一个元素大于后一个元素，则不为二分搜索树
            if (arrayList.get(i).compareTo(arrayList.get(i + 1)) &amp;gt; 0) {
                return false;
            }
        }
        System.out.println(&quot;中序遍历：&quot; + arrayList.toString());
        return true;
    }

    // 通过中序遍历形成序列
    private void InOrderTraversal(Node node, ArrayList&amp;lt;E&amp;gt; arrayList) {
        if (node == null) {
            return;
        }
        InOrderTraversal(node.left, arrayList);
        arrayList.add((E) node.e);
        InOrderTraversal(node.right, arrayList);
    }

    // 判断是否是一棵平衡二叉树
    public boolean isBalancedTree() {
        return isBalanced(root);
    }

    // 通过递归遍历判断是否为平衡二叉树：判断每个结点的平衡因子的绝对值是否有大于1的存在
    private boolean isBalanced(Node node) {

        if (node == null) {
            return true;
        }
        // 获取该结点的平衡因子，并判断平衡因子的绝对值是否大于1
        int balanceFactor = getBalanceFactor(node);
        if (Math.abs(balanceFactor) &amp;gt; 1) {
            System.out.println(&quot;元素[&quot;+node.e + &quot;] 平衡因子=&quot; + balanceFactor+&quot;，超过1&quot;);
            System.out.println(&quot;元素[&quot;+node.e+ &quot;] 左子树的高度=&quot;+node.left.height+ &quot;,右子树的高度=&quot;+node.right.height);
            return false;
        }
        // 遍历判断结点的左子树和右子树的各个结点
        return isBalanced(node.left) &amp;amp;&amp;amp; isBalanced(node.right);
    }

    public static void main(String[] args) {
        // 定义一个数组
        Integer[] arr = {48, 30, 66, 21, 34, 57, 78, 14};
        // 将该数组构建成一个二分搜索树
        AVL&amp;lt;Integer&amp;gt; avl = new AVL&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; arr.length; i++) {
            avl.add(arr[i]);
        }
        // 判断当前的二叉树是否满足二分搜索树的定义
        boolean isBST = avl.isBST();
        boolean isBalance = avl.isBalancedTree();
        // 判断当前的树是否满足AVL定义
        if (isBST &amp;amp;&amp;amp; isBalance) {
            System.out.println(&quot;该二叉树满足二分搜索树及平衡的条件，是AVL树!!!&quot;);
        } else {
            System.out.println(&quot;该二叉树不是AVL树;&quot; + &quot;是否满足二分搜索树条件：&quot; + isBST + &quot; ;是否满足平衡条件:&quot; + isBalance);
        }

        // 给该AVL树加上一个结点，再次判断是否判断
        avl.add(10);
        // 判断当前的二叉树是否满足二分搜索树的定义
        isBST = avl.isBST();
        isBalance = avl.isBalancedTree();
        // 判断当前的树是否满足AVL定义
        if (isBST &amp;amp;&amp;amp; isBalance) {
            System.out.println(&quot;该二叉树满足二分搜索树及平衡的条件，是AVL树!!!&quot;);
        } else {
            System.out.println(&quot;该二叉树不是AVL树;&quot; + &quot;是否满足二分搜索树条件：&quot; + isBST + &quot; ;是否满足平衡条件:&quot; + isBalance);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通过{48, 30, 66, 21, 34, 57, 78, 14}构建AVL树&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200721102558877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;给以上AVL树增加一个结点10,再次判断该树是否满足AVL的定义&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200721102621220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;三、旋转操作&quot;&gt;三、旋转操作&lt;/h4&gt;
&lt;p&gt;往AVL树中添加结点很可能会导致失去平衡，所以我们需要在每次插入结点后进行平衡的维护。破坏平衡性有如下四种情况：&lt;/p&gt;
&lt;h5 id=&quot;31--l-l--需要通过右旋操作&quot;&gt;3.1 &lt;span&gt;L&lt;/span&gt; &lt;span&gt;L&lt;/span&gt;--需要通过右旋操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在结点的左子树(&lt;span&gt;L&lt;/span&gt;)的左孩子(&lt;span&gt;L&lt;/span&gt;)添加新的结点，会导致失去平衡：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722114028483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;通过右旋操作（顺时针转）将平衡因子大于1的结点进行调整&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722114434683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完整动画演示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722120512959.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;代码处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 右旋（顺时针转）
    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T = x.right;

        // 向右旋转过程
        x.right = y;
        y.left = T;

        // 更新height
        y.height = setHeight(y);
        System.out.println(&quot;元素[&quot; + y.e + &quot;] 右旋后更新高度： height=&quot; + y.height);
        x.height = setHeight(x);
        System.out.println(&quot;元素[&quot; + x.e + &quot;] 更新高度： height=&quot; + x.height);

        return x;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;32--r-r--需要通过左旋操作&quot;&gt;3.2 &lt;span&gt;R&lt;/span&gt; &lt;span&gt;R&lt;/span&gt;--需要通过左旋操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在结点的右子树(&lt;span&gt;R&lt;/span&gt;)的右孩子(&lt;span&gt;R&lt;/span&gt;)添加新的结点，会导致失去平衡：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722123123974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过左旋操作（逆时针转）将平衡因子大于1的结点进行调整&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722123515318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;完整动画演示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722161958101.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;代码处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; // 左旋(逆时针转)
    private Node leftRotate(Node y) {
        Node x = y.right;
        Node T = x.left;

        // 向左旋转过程
        x.left = y;
        y.right = T;

        // 更新height
        y.height = setHeight(y);
        System.out.println(&quot;元素[&quot; + y.e + &quot;] 左旋后更新高度： height=&quot; + y.height);
        x.height = setHeight(x);
        System.out.println(&quot;元素[&quot; + x.e + &quot;] 更新高度： height=&quot; + x.height);

        return x;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;33--l-r--需要先通过左旋再右旋操作&quot;&gt;3.3 &lt;span&gt;L&lt;/span&gt; &lt;span&gt;R&lt;/span&gt;--需要先通过左旋再右旋操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在结点的左子树(&lt;span&gt;L&lt;/span&gt;)的右孩子(&lt;span&gt;R&lt;/span&gt;)添加新的结点，会导致失去平衡：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722163855491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;先通过左子结点的左旋操作（逆时针转）转成LL形式，再通过右旋操作（顺时针转）将平衡因子大于1的结点进行调整&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722164830743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;完整动画演示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722171754211.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;24--r-l--需要先通过右旋再左旋操作&quot;&gt;2.4 &lt;span&gt;R&lt;/span&gt; &lt;span&gt;L&lt;/span&gt;--需要先通过右旋再左旋操作&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在结点的右子树(&lt;span&gt;R&lt;/span&gt;)的左孩子(&lt;span&gt;L&lt;/span&gt;)添加新的结点，会导致失去平衡：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722172257827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;先通过右子结点的右旋操作（顺时针转）转成RR形式，再通过左旋操作（逆时针转）将平衡因子大于1的结点进行调整&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722173040365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;完整动画演示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722175102738.gif&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;四、avl树完整代码实现&quot;&gt;四、AVL树完整代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * AVL树
 *
 * @param &amp;lt;E&amp;gt; 元素
 * @author zhuhuix
 * @date 2020-07-21
 */
public class AVL&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; {

    // 私有内部类-树结点
    private class Node&amp;lt;E&amp;gt; {
        E e;
        Node left, right;
        // 高度
        int height;

        Node(E e) {
            this.e = e;
            this.left = null;
            this.right = null;
            this.height = 1;
        }

    }

    // 根结点
    private Node root;

    // 获得节点node的高度
    private int getHeight(Node node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }

    // 计算结点的高度
    private int setHeight(Node node) {
        return node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
    }

    // 获得节点node的平衡因子
    private int getBalanceFactor(Node node) {
        if (node == null) {
            return 0;
        }
        return getHeight(node.left) - getHeight(node.right);
    }

    // 右旋（顺时针转）
    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T = x.right;

        // 向右旋转过程
        x.right = y;
        y.left = T;

        // 更新height
        y.height = setHeight(y);
        System.out.println(&quot;元素[&quot; + y.e + &quot;] 右旋后更新高度： height=&quot; + y.height);
        x.height = setHeight(x);
        System.out.println(&quot;元素[&quot; + x.e + &quot;] 更新高度： height=&quot; + x.height);

        return x;
    }

    // 左旋(逆时针转)
    private Node leftRotate(Node y) {
        Node x = y.right;
        Node T = x.left;

        // 向左旋转过程
        x.left = y;
        y.right = T;

        // 更新height
        y.height = setHeight(y);
        System.out.println(&quot;元素[&quot; + y.e + &quot;] 左旋后更新高度： height=&quot; + y.height);
        x.height = setHeight(x);
        System.out.println(&quot;元素[&quot; + x.e + &quot;] 更新高度： height=&quot; + x.height);

        return x;
    }

    // 增加元素
    public void add(E e) {
        root = addNode(root, e);
    }

    // 通过递归算法遍历现有结点，将新结点插入到合适的位置
    private Node addNode(Node node, E element) {

        if (node == null) {
            System.out.println(&quot;新增元素[&quot; + element + &quot;] height=1&quot;);
            return new Node(element);
        }

        // 新加入元素小于结点值，往左子树增加
        if (element.compareTo((E) node.e) &amp;lt; 0) {
            node.left = addNode(node.left, element);
            // 新加入元素大于结点值，往右子树增加
        } else if (element.compareTo((E) node.e) &amp;gt; 0) {
            node.right = addNode(node.right, element);
        } else // element.compareTo(node.e) == 0
        {
            node.e = element;
        }
        // 更新height
        node.height = setHeight(node);
        System.out.println(&quot;元素[&quot; + node.e + &quot;] 更新高度： height=&quot; + node.height);

        // 计算平衡因子
        int balanceFactor = getBalanceFactor(node);
        if (node != null) {
            System.out.println(&quot;元素[&quot; + node.e + &quot;] &quot;
                    + &quot;左子结点为:[&quot; + (node.left == null ? &quot;&quot; : node.left.e) + &quot;]&quot;
                    + &quot;右子结点为:[&quot; + (node.right == null ? &quot;&quot; : node.right.e) + &quot;]&quot;
                    + &quot;,balanceFactor=&quot; + balanceFactor);
        }

        // 平衡维护
        if (balanceFactor &amp;gt; 1 &amp;amp;&amp;amp; getBalanceFactor(node.left) &amp;gt;= 0) {
            System.out.println(&quot;元素[&quot; + node.e + &quot;] balanceFactor=&quot; + balanceFactor + &quot;,进行右旋&quot;);
            return rightRotate(node);
        }

        if (balanceFactor &amp;lt; -1 &amp;amp;&amp;amp; getBalanceFactor(node.right) &amp;lt;= 0) {
            System.out.println(&quot;元素[&quot; + node.e + &quot;] balanceFactor=&quot; + balanceFactor + &quot;,进行左旋&quot;);
            return leftRotate(node);
        }

        if (balanceFactor &amp;gt; 1 &amp;amp;&amp;amp; getBalanceFactor(node.left) &amp;lt; 0) {
            System.out.print(&quot;元素[&quot; + node.e + &quot;] balanceFactor=&quot; + balanceFactor + &quot; 先将[&quot; + node.e + &quot;的左子结点&quot; + node.left.e + &quot;] 进行左旋&quot;);
            node.left = leftRotate(node.left);
            System.out.println(&quot;再将元素[&quot; + node.e + &quot;] 进行右旋&quot;);
            return rightRotate(node);
        }

        if (balanceFactor &amp;lt; -1 &amp;amp;&amp;amp; getBalanceFactor(node.right) &amp;gt; 0) {
            System.out.print(&quot;元素[&quot; + node.e + &quot;] balanceFactor=&quot; + balanceFactor + &quot; 先将[&quot; + node.e + &quot;的右子结点&quot; + node.right.e + &quot;] 进行右旋&quot;);
            node.right = rightRotate(node.right);
            System.out.println(&quot;再将元素[&quot; + node.e + &quot;] 进行左旋&quot;);
            return leftRotate(node);
        }

        return node;
    }

    // 判断二叉树是否为二分搜索树:从根结点中序遍历形成的序列是否从小到大有序排列
    public boolean isBST() {
        ArrayList&amp;lt;E&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
        InOrderTraversal(root, arrayList);
        for (int i = 0; i &amp;lt; arrayList.size() - 1; i++) {
            // 相邻两个元素比较，如果前一个元素大于后一个元素，则不为二分搜索树
            if (arrayList.get(i).compareTo(arrayList.get(i + 1)) &amp;gt; 0) {
                return false;
            }
        }
        System.out.println(&quot;中序遍历：&quot; + arrayList.toString());
        return true;
    }

    // 通过中序遍历形成序列
    private void InOrderTraversal(Node node, ArrayList&amp;lt;E&amp;gt; arrayList) {
        if (node == null) {
            return;
        }
        InOrderTraversal(node.left, arrayList);
        arrayList.add((E) node.e);
        InOrderTraversal(node.right, arrayList);
    }

    // 前序遍历打印
    public void preOrderTraversal() {
        ArrayList&amp;lt;E&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
        preOrderTraversal(root, arrayList);
        System.out.println(&quot;前序遍历&quot; + arrayList);
    }

    // 通过前序遍历形成序列
    private void preOrderTraversal(Node node, ArrayList&amp;lt;E&amp;gt; arrayList) {
        if (node == null) {
            return;
        }
        arrayList.add((E) node.e);
        preOrderTraversal(node.left, arrayList);
        preOrderTraversal(node.right, arrayList);
    }

    // 判断是否是一棵平衡二叉树
    public boolean isBalancedTree() {
        return isBalanced(root);
    }

    // 通过递归遍历判断是否为平衡二叉树：判断每个结点的平衡因子的绝对值是否有大于1的存在
    private boolean isBalanced(Node node) {

        if (node == null) {
            return true;
        }
        // 获取该结点的平衡因子，并判断平衡因子的绝对值是否大于1
        int balanceFactor = getBalanceFactor(node);
        if (Math.abs(balanceFactor) &amp;gt; 1) {
            System.out.println(&quot;元素[&quot; + node.e + &quot;] 平衡因子=&quot; + balanceFactor + &quot;，超过1&quot;);
            System.out.println(&quot;元素[&quot; + node.e + &quot;] 左子树的高度=&quot; + node.left.height + &quot;,右子树的高度=&quot; + node.right.height);
            return false;
        }
        // 遍历判断结点的左子树和右子树的各个结点
        return isBalanced(node.left) &amp;amp;&amp;amp; isBalanced(node.right);
    }

    public static void main(String[] args) {
        // 定义一个数组
        Integer[] arr = {48, 30, 66, 21, 34, 57, 78, 14};
        // 将该数组构建成一个二分搜索树
        AVL&amp;lt;Integer&amp;gt; avl = new AVL&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; arr.length; i++) {
            avl.add(arr[i]);
        }
        // 判断当前的二叉树是否满足二分搜索树的定义
        boolean isBST = avl.isBST();
        boolean isBalance = avl.isBalancedTree();
        // 判断当前的树是否满足AVL定义
        if (isBST &amp;amp;&amp;amp; isBalance) {
            System.out.println(&quot;该二叉树满足二分搜索树及平衡的条件，是AVL树!!!&quot;);
        } else {
            System.out.println(&quot;该二叉树不是AVL树;&quot; + &quot;是否满足二分搜索树条件：&quot; + isBST + &quot; ;是否满足平衡条件:&quot; + isBalance);
        }


        // 给该AVL树加上一个结点，再次判断是否判断
        avl.add(10);
        // 判断当前的二叉树是否满足二分搜索树的定义
        isBST = avl.isBST();
        isBalance = avl.isBalancedTree();
        // 判断当前的树是否满足AVL定义
        if (isBST &amp;amp;&amp;amp; isBalance) {
            System.out.println(&quot;该二叉树满足二分搜索树及平衡的条件，是AVL树!!!&quot;);
        } else {
            System.out.println(&quot;该二叉树不是AVL树;&quot; + &quot;是否满足二分搜索树条件：&quot; + isBST + &quot; ;是否满足平衡条件:&quot; + isBalance);
        }

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构建AVL树过程&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722175432200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;添加结点AVL树平衡过程&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200722175529408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 23 Jul 2020 00:39:00 +0000</pubDate>
<dc:creator>智慧zhuhuix</dc:creator>
<og:description>@ 一、背景 二叉树是一种常用的数据结构，更是实现众多算法的一把利器。（可参考《自己动手作图深入理解二叉树、满二叉树及完全二叉树》） 二分搜索树（Binary Search Tree）做为一种能实现快</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuhuix/p/13364271.html</dc:identifier>
</item>
<item>
<title>Flutter 实现酷炫的3D效果 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13364197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13364197.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074731495-116626143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;老孟导读：此文讲解3个酷炫的3D动画效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是要实现的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074733127-1561674722.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter 中3D效果是通过 &lt;strong&gt;Transform&lt;/strong&gt; 组件实现的，没有变换效果的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TransformDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('3D 变换Demo'),
      ),
      body: Container(
        alignment: Alignment.center,
        color: Colors.white,
        child: Text('3D 变换Demo'),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074733499-647204349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;GestureDetector&lt;/strong&gt; 组件添加滑动事件监听：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: Text('3D 变换Demo'),
    ),
    body: GestureDetector(
      onPanUpdate: (details) {
        print('$details');
      },
      child: Container(
        alignment: Alignment.center,
        color: Colors.white,
        child: Text('3D 变换Demo'),
      ),
    ),
  );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加 &lt;strong&gt;Transform&lt;/strong&gt; 对组件进入旋转：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return Transform(
      transform: Matrix4.identity()
        ..setEntry(3, 2, 0.001)
        ..rotateX(pi/6)
        ..rotateY(pi/6),
      alignment: Alignment.center,
      child: Scaffold(
        appBar: AppBar(
          title: Text('3D 变换Demo'),
        ),
        body: GestureDetector(
          onPanUpdate: (details) {
          },
          child: Container(
            alignment: Alignment.center,
            color: Colors.white,
            child: Text('3D 变换Demo'),
          ),
        ),
      ));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074733687-335547638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将滑动的偏移和旋转进行关联：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TransformDemo extends StatefulWidget {
  @override
  _TransformDemoState createState() =&amp;gt; _TransformDemoState();
}

class _TransformDemoState extends State&amp;lt;TransformDemo&amp;gt; {
  double _rotateX = .0;
  double _rotateY = .0;

  @override
  Widget build(BuildContext context) {
    return Transform(
        transform: Matrix4.identity()
          ..rotateX(_rotateX)
          ..rotateY(_rotateY),
        alignment: Alignment.center,
        child: Scaffold(
          appBar: AppBar(
            title: Text('3D 变换Demo'),
          ),
          body: GestureDetector(
            onPanUpdate: (details) {
              setState(() {
                _rotateX += details.delta.dy * .01;
                _rotateY += details.delta.dx * -.01;
              });
            },
            child: Container(
              alignment: Alignment.center,
              color: Colors.white,
              child: Text('3D 变换Demo'),
            ),
          ),
        ));
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074734167-1429347073.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本已经实现了3D效果，但效果比较生硬，尤其垂直方向旋转的时候远点和近点在屏幕上的宽度是一样，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074734447-1509563077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加近大远小的效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Transform(
    transform: Matrix4.identity()
      ..setEntry(3, 2, 0.001)
      ..rotateX(_rotateX)
      ..rotateY(_rotateY),
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074734669-1854523234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;翻书效果&quot;&gt;翻书效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074735086-268867462.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的效果类似于翻书的效果。&lt;/p&gt;
&lt;p&gt;实现的原理：&lt;/p&gt;
&lt;p&gt;将图片左右切割为两部分，两张图片共分割为4个新的组件，如下图，分别为1、2、3、4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074735379-62324672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_child1 = ClipRect(
  child: Align(
    alignment: Alignment.centerLeft,
    widthFactor: 0.5,
    child: child1,
  ),
);
_child2 = ClipRect(
  child: Align(
    alignment: Alignment.centerRight,
    widthFactor: 0.5,
    child: child1,
  ),
);

_child3 = ClipRect(
  child: Align(
    alignment: Alignment.centerLeft,
    widthFactor: 0.5,
    child: child2,
  ),
);

_child4 = ClipRect(
  child: Align(
    alignment: Alignment.centerRight,
    widthFactor: 0.5,
    child: child2,
  ),
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将第一张图片放在第二种图片的上面，先旋转 &lt;strong&gt;组件2&lt;/strong&gt; 从 0度到 90度，然后再旋转 &lt;strong&gt;组件3&lt;/strong&gt; 从 -90度到0度，代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Row(
  mainAxisAlignment: MainAxisAlignment.center,
  children: &amp;lt;Widget&amp;gt;[
    Stack(
      children: [
        _child1,
        Transform(
          alignment: Alignment.centerRight,
          transform: Matrix4.identity()
            ..setEntry(3, 2, 0.001)
            ..rotateY(_animation1.value),
          child: _child3,
        ),
      ],
    ),
    Container(
      width: 3,
      color: Colors.white,
    ),
    Stack(
      children: [
        _child4,
        Transform(
          alignment: Alignment.centerLeft,
          transform: Matrix4.identity()
            ..setEntry(3, 2, 0.001)
            ..rotateY(_animation.value),
          child: _child2,
        )
      ],
    )
  ],
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动画控制器设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
void initState() {
  init();
  _controller =
      AnimationController(vsync: this, duration: Duration(seconds: 5))
        ..addListener(() {
          setState(() {});
        });
  _animation = Tween(begin: .0, end: pi / 2)
      .animate(CurvedAnimation(parent: _controller, curve: Interval(.0, .5)));
  _animation1 = Tween(begin: -pi / 2, end: 0.0).animate(
      CurvedAnimation(parent: _controller, curve: Interval(.5, 1.0)));
  _controller.forward();
  super.initState();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 child1, child2为两种图片，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_FlipUpDemoState(
    Container(
      width: 300,
      height: 400,
      child: Image.asset(
        'assets/images/b.jpg',
        fit: BoxFit.cover,
      ),
    ),
    Container(
      width: 300,
      height: 400,
      child: Image.asset(
        'assets/images/c.jpeg',
        fit: BoxFit.cover,
      ),
    ))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后生成的效果就是开始的翻书效果。&lt;/p&gt;
&lt;p&gt;上面是左右翻页效果，同理换成上下翻页效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(),
    body: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: &amp;lt;Widget&amp;gt;[
        Stack(
          children: [
            _upperChild1,
            Transform(
              alignment: Alignment.bottomCenter,
              transform: Matrix4.identity()
                ..setEntry(3, 2, 0.003)
                ..rotateX(_animation1.value),
              child: _upperChild2,
            ),
          ],
        ),
        SizedBox(
          height: 2,
        ),
        Stack(
          children: [
            _lowerChild2,
            Transform(
              alignment: Alignment.topCenter,
              transform: Matrix4.identity()
                ..setEntry(3, 2, 0.003)
                ..rotateX(_animation.value),
              child: _lowerChild1,
            )
          ],
        )
      ],
    ),
  );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074735555-521669980.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074735839-964881535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200723074736033-1688523699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 22 Jul 2020 23:48:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：此文讲解3个酷炫的3D动画效果。 下面是要实现的效果： Flutter 中3D效果是通过 Transform 组件实现的，没有变换效果的实现： class TransformDemo ext</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13364197.html</dc:identifier>
</item>
<item>
<title>什么情况下不能使用最坏情况评估算法的复杂度？ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13364195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13364195.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202007/1648938-20200723074403579-196942323.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。&lt;/p&gt;
&lt;p&gt;上一节，我们从最坏、平均、最好三种情况分析了算法的复杂度，得出结论，通常来说，使用最坏情况来评估算法的复杂度完全够用了。&lt;/p&gt;
&lt;p&gt;但是，有些算法是不能使用最坏情况来评估算法的复杂度的。&lt;/p&gt;
&lt;p&gt;那么，有哪些算法呢？&lt;/p&gt;
&lt;p&gt;本节，我们将从动态数组以及快速排序这两个个例入手来分析不能使用最坏情况评估复杂度的情形。&lt;/p&gt;

&lt;p&gt;动态数组，对应于Java中的ArrayList，在插入元素时，分成两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组未满，元素放在size下标的位置即可；&lt;/li&gt;
&lt;li&gt;数组满了，需要扩容，一般扩容为N倍大小，Java里面是1.5倍，扩容时需要创建一个新的数组，并把原来的元素一个一个地拷贝到新的数组中，再插入新的元素；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我简单地写一段代码，你可以感受下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DynamicArray {
    private int[] array;
    private int size;

    public DynamicArray(int capacity) {
        this.array = new int[capacity];
        this.size = 0;
    }

    // 插入元素，时间复杂度为多少呢？
    public void add(int element) {
        // 判断是否需要扩容
        if (size &amp;gt;= array.length) {
            int newCapacity = array.length + (array.length &amp;gt;&amp;gt; 1);
            int[] newArray = new int[newCapacity];
            for (int i = 0; i &amp;lt; array.length; i++) {
                newArray[i] = array[i];
            }
            this.array = newArray;
        }
        array[size++] = element;
    }

    public int[] getArray() {
        return array;
    }

    public static void main(String[] args) {
        DynamicArray dynamicArray = new DynamicArray(4);
        dynamicArray.add(1);
        dynamicArray.add(2);
        dynamicArray.add(3);
        dynamicArray.add(4);
        dynamicArray.add(5);
        dynamicArray.add(6);

        for (int element : dynamicArray.getArray()) {
            System.out.println(element);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，对于动态数组，它的插入元素方法的时间复杂度是多少呢？&lt;/p&gt;
&lt;p&gt;按照上一节的说法，按照最坏情况来评估，最坏情况是插入元素时正好数组满了需要扩容的时候，此时，需要创建一个额外的数组，同时有一个遍历原数组的过程。&lt;/p&gt;
&lt;p&gt;所以，在最坏情况下，动态数组插入元素的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;但是，这样合理吗？&lt;/p&gt;
&lt;p&gt;显然是不合理的，我插入前面(n-1)个元素的时候，它的时间复杂度都是O(1)，就只有插入第n个元素的时候它的时间复杂度才是O(n)，所以，这样来评估动态数组插入元素的时间复杂度明显不合理。&lt;/p&gt;
&lt;p&gt;那么，如果我把第n个元素插入所需要的时间均摊到所有元素上会怎么样呢？&lt;/p&gt;
&lt;p&gt;这样的话，前面每个元素的插入时间只需要加1，变成O(2)，忽略常数项，就还是O(1)，这样明显是要合理一些。&lt;/p&gt;
&lt;p&gt;这种方式跟计算平均时间复杂度有点类似，但是，它不是平均时间复杂度，它有一个专门的名称叫做&lt;strong&gt;均摊时间复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;均摊时间复杂度，即对一批样本中出现的个例情况，将它们耗费的时间均摊到所有样本上，算出来的一个时间复杂度。&lt;/p&gt;
&lt;p&gt;你可以把它和平均时间复杂度对比一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;平均时间复杂度的计算中没有个例，所有样本是同等看待的，想一下线性查找的过程；&lt;/li&gt;
&lt;li&gt;均摊时间复杂度的计算中有个例，这种个例往往就是最坏的情况，想一下动态数组插入元素的过程；&lt;/li&gt;
&lt;li&gt;线性查找第n个元素不是个例，不能把它的时间均摊到所有元素上；&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这两个概念严格来说是有区别的，如果无法理解，当成一样的也问题不大，比如，这里如果按平均时间复杂度计算的话，结果为 (1+1+1+...+n)/n = (n-1+n)/n = (2n-1)/n=2-1/n，忽略常数项和低阶项，最终的结果也是O(1)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，那么，我们再来看一下动态数组插入元素时的额外空间复杂度。&lt;/p&gt;
&lt;p&gt;是不是一样的道理？数组未满时额外空间复杂度为O(1)，数组满时额外空间复杂度为O(n)，均摊一下变成O(1)。&lt;/p&gt;
&lt;p&gt;所以，对于动态数组插入元素的过程，它的均摊时间复杂度和均摊额外空间复杂度都是O(1)。&lt;/p&gt;

&lt;p&gt;大家都知道经典的快速排序的时间复杂度是O(nlogn)，那么，它的最坏时间复杂度是不是也是O(nlogn)呢？&lt;/p&gt;
&lt;p&gt;让我们来看下面这个数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202007/1648938-20200723074403789-1189838235.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个有序数组，如果此时用经典快速排序来对其进行排序会怎样呢？&lt;/p&gt;
&lt;p&gt;我们取最右边的元素为轴（Pivot），也就是12，将小于12的放在它的左边，大于12的放在它的右边，发现没有比12大的，所以，右边没有元素，经过此步，12的位置固定不变了。&lt;/p&gt;
&lt;p&gt;接着，将12左右两边的元素再各取最右边的元素为轴，12的右边没有元素，所以，只需要处理左边就可以了，以10为轴，比10小的放在它的左边，比10大的放在它的右边，发现10的右边也没有元素（12已经固定了），经过此步，10的位置固定了。&lt;/p&gt;
&lt;p&gt;同样地，最后一步到1这里，排序完成。&lt;/p&gt;
&lt;p&gt;让我们来分析一下整个过程的复杂度：&lt;/p&gt;
&lt;p&gt;第一步，需要遍历(n-1)个元素；&lt;/p&gt;
&lt;p&gt;第二步，需要遍历(n-2)个元素；&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;最后一步，需要遍历0个元素；&lt;/p&gt;
&lt;p&gt;这种情况下的时间复杂度为：(n-1) + (n-2) + ... + 1 + 0 = (n-1)n/2 = n^2/2 - n/2，忽略常数项和低阶项，它的时间复杂度为O(n^2)。&lt;/p&gt;
&lt;p&gt;所以，对于有序数组，使用经典快速排序，它的时间复杂度为O(n^2)，这也是最坏的情况。&lt;/p&gt;
&lt;p&gt;但是，似乎从来没有人告诉你，经典快速排序的时间复杂度为O(n^2)，而是O(nlog2)，这是为什么呢？&lt;/p&gt;
&lt;p&gt;那是因为有序数组相对于经典快速排序，也是属于个例，穷举无限多的样本之后，有序数组的可能性实在是太小，所以，我们一般说经典快速排序的时间复杂度为O(nlogn)，而不是以最坏情况来评估它的时间复杂度。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们这里说的是经典快速排序，为什么要加“经典”两个字呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，本节，我们通过两个案例来说明了并不是所有的算法都使用最坏情况来评估它的复杂度。&lt;/p&gt;
&lt;p&gt;到现在为止，我们都是使用的大O来表示算法的复杂度，但是，在其它书籍中，你可能还见过Θ、Ω等表示法，它们又是什么意思呢？&lt;/p&gt;
&lt;p&gt;下一节，我们接着聊。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公众号“彤哥读源码”，解锁更多源码、基础、架构知识！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 22 Jul 2020 23:44:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。 上一节，我们从最坏、平均、最好三种情况分析了算法的复杂度，得出结论，通常来说，使用最坏情况来评估算法的复杂度完全够用了。 但是，有些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13364195.html</dc:identifier>
</item>
<item>
<title>归并排序 - Ruby_Lu</title>
<link>http://www.cnblogs.com/afei-24/p/13343137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/13343137.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;什么是归并？&lt;/strong&gt;即将两个有序的数组归并成一个更大的有序数组。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;什么是归并排序？&lt;/strong&gt;先将要排序的数组递归地分成两半分别排序，然后将结果归并起来。&lt;/p&gt;
&lt;p&gt;　　归并排序能够保证将任意大小为 N 的数组排序所需的时间和  N logN 成正比；缺点是它所需的额外空间和 N 成正比。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.原地归并的抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　实现归并的一种直截了当的方法是，创建一个适当大小的数组然后将两个输入数组中的元素从小到大放入这个数组。因为会多次归并，防止每次归并时都创建一个数组，创建数组要放在递归的外面。&lt;/p&gt;
&lt;p&gt;　　而原地归并可以在数组移动元素而不需要使用额外的空间，但是实现非常复杂。下面的归并方法是非原地归并：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Merge(IComparable[] a, &lt;span&gt;int&lt;/span&gt; lo, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hi)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(lo+&quot;,&quot;+mid+&quot;,&quot;+hi);&lt;/span&gt;
            
            &lt;span&gt;int&lt;/span&gt; i = lo; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边部分索引&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; j = mid + &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边部分索引

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制一份数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = lo; k &amp;lt;= hi; k++&lt;span&gt;)
            {
                aux[k] &lt;/span&gt;=&lt;span&gt; a[k];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Count++;&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * 一开始拿左边部分和右边部分比较，哪边小就将小的值一次放入数组 a,并将小的索引 + 1
             *      表示拿下一个和另一部分比较
             * 当某一部分取完时，取另一部分循环放入数组
             * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = lo; k &amp;lt;= hi; k++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;&lt;span&gt; mid)
                    a[k] &lt;/span&gt;= aux[j++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (j &amp;gt;&lt;span&gt; hi)
                    a[k] &lt;/span&gt;= aux[i++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Less(aux[j], aux[i]))
                    a[k] &lt;/span&gt;= aux[j++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    a[k] &lt;/span&gt;= aux[i++&lt;span&gt;];
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Merge 方法先将 a[lo ... hi]  复制到 aux[],即第一个循环。然后开始归并（第二个循环），拿左边部分和右边部分比较，哪边小就将小的值一次放入数组 a,并将小的索引 + 1。当某一部分取完时，取另一部分循环放入数组。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200720080348207-2049383221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.自顶而下的归并排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面的算法通过上面的 Merge 方法实现了自顶而下的归并排序，这个算法设计使用了分治思想。要对  a[lo ... hi] 排序，先将它分为 a[lo ... mid] 和 a[mid+1 ... hi] 两部分，分别通过递归调用单独对它们排序，最后将有序的子数组归并为最终的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSort : BaseSort
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IComparable[] aux = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; usedTimes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MergeSort()
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sort(IComparable[] a)
        {
            Stopwatch timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
            timer.Start();
            aux &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IComparable[a.Length];
            Sort(a, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,a.Length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            timer.Stop();
            usedTimes &lt;/span&gt;=&lt;span&gt; timer.ElapsedMilliseconds;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数组a[lo ... hi]排序&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sort(IComparable[] a, &lt;span&gt;int&lt;/span&gt; lo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hi)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归调用Sort(IComparable[] a, int lo, int hi)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (hi&amp;lt;=&lt;span&gt;lo)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = lo + (hi-lo)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            Sort(a,lo,mid);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将左边部分排序(递归调用)&lt;/span&gt;
            Sort(a,mid+&lt;span&gt;1&lt;/span&gt;,hi);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将右边部分排序(递归调用)


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归并排序后的两部分&lt;/span&gt;
&lt;span&gt;            Merge(a,lo,mid,hi);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Merge(IComparable[] a, &lt;span&gt;int&lt;/span&gt; lo, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hi)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(lo+&quot;,&quot;+mid+&quot;,&quot;+hi);&lt;/span&gt;
            
            &lt;span&gt;int&lt;/span&gt; i = lo; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边部分索引&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; j = mid + &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边部分索引

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制一份数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = lo; k &amp;lt;= hi; k++&lt;span&gt;)
            {
                aux[k] &lt;/span&gt;=&lt;span&gt; a[k];
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Count++;&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * 一开始拿左边部分和右边部分比较，哪边小就将小的值一次放入数组 a,并将小的索引 + 1
             *      表示拿下一个和另一部分比较
             * 当某一部分取完时，取另一部分循环放入数组
             * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = lo; k &amp;lt;= hi; k++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;&lt;span&gt; mid)
                    a[k] &lt;/span&gt;= aux[j++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (j &amp;gt;&lt;span&gt; hi)
                    a[k] &lt;/span&gt;= aux[i++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Less(aux[j], aux[i]))
                    a[k] &lt;/span&gt;= aux[j++&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    a[k] &lt;/span&gt;= aux[i++&lt;span&gt;];
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200720080454264-2049061829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上轨迹所示，要将 a[1...15] 排序，Sort() 方法会调用自己将 a[0...7] 排序，再在其中调用自己将 a[0...3] 和 a[0...1] 排序。在将 a[0] 和 a[1] 分别排序之后，才会开始将 a[0] 和 a[1]  归并。第二次归并是 a[2] 和 a[3] ，一次类推。&lt;/p&gt;
&lt;p&gt;　　用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200721075225323-755456692.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　每个结点表示一个 Sort() 方法通过 Merge 方法归并而成的子数组。这棵树正好有 n(n = logN) 层。对于0 到 n-1 之间的任意 k ，自顶而下的第 k 层有 2^k 个数组，每个数组的长度为 2^ n-k，由 Merge 方法中比较的代码可知比较次数为 2^ n-k。&lt;strong&gt;因此每层比较次数为 2^k * 2^n-k = 2^n，n 层总共为 n* 2^n = N logN。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于并不是每次一分为二子数组不一定均分，总比较次数小于等于 N logN，大于等于 1/2 N logN。&lt;/p&gt;
&lt;p&gt;　　每一层最多需要 6*N 次访问数组，2N 次用来复制数组（读和写），2N 次用来将排好序的元素移动回去，另外最多比较 2N 次（应该最多N+1次），&lt;strong&gt;总共最多访问数组 6NlogN 次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由上可知，归并排序所需的时间和 NlogN 成正比。主要缺点是需要额外空间和 N 大小成正比。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 对于小规模数组，递归会使小规模问题中方法的调用过于频繁，可以在处理小规模问题时使用插入排序。一般可以将归并排序的运行时间缩短 10% 左右。&lt;/p&gt;
&lt;p&gt;　　2. 在调用 Merge 之前可以增加判断 ，如果 a[mid] 小于 a[mid+1] ，说明数组已经有序了不需要 Merge 。这个改动不影响排序的调用，但是对于有序的子数组算法的运行时间就变成线性了。&lt;/p&gt;
&lt;p&gt;　　3.不将元素复制到辅助数组，可以节省将数组复制到辅助数组的时间。需要调用两种排序方法：一种将数据从输入数组排序到辅助数组，另一种将数据从辅助数组排序到输入数组。（待确认）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.自底向上的归并排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　自顶而下的归并排序是将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。&lt;/p&gt;
&lt;p&gt;　　尽管我们考虑的是归并两个大数组，实际上我们归并的数组大部分都很小。所以我们可以使用另外一种排序方法自底向上，先归并那些小数组，然后再成对归并得到的子数组，最终会将整个数组归并到一起。先两两归并，然后四四归并...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSortBu: MergeSort
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;static IComparable[] aux = null;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; usedTimes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sort(IComparable[] a)
        {
            Stopwatch timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
            timer.Start();
            aux &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IComparable[a.Length];
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; a.Length;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * sz = 1，进行两两归并,归并次数 N/2^1  ；sz = 2,四四归并,归并次数 N/2^2...
             * 要注意检查是否超出索引，N 不一定是 sz 的倍数
             * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sz = &lt;span&gt;1&lt;/span&gt;; sz &amp;lt; n; sz = sz +&lt;span&gt; sz)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; lo = &lt;span&gt;0&lt;/span&gt;; lo &amp;lt; n - sz; lo += sz+&lt;span&gt;sz)
                    Merge(a,lo,lo&lt;/span&gt;+sz-&lt;span&gt;1&lt;/span&gt;,Math.Min(lo+sz+sz-&lt;span&gt;1&lt;/span&gt;,n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
            }

            timer.Stop();
            usedTimes &lt;/span&gt;=&lt;span&gt; timer.ElapsedMilliseconds;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;自底向上归并排序的比较次数同样小于等于 N logN，大于等于 1/2 N logN。最多访问数组次数 6NlogN 次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当数组长度是 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他情况可能会有所不同。&lt;/p&gt;
&lt;p&gt;　　自底向上的归并排序比较适合用链表组织的数据。因为链表可以原地排序，不需要额外的空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　没有任何基于比较的算法能够保证使用少于 lg( N! ) ~ N lg N 次比较将长度为 N 的数组排序。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 Jul 2020 23:34:00 +0000</pubDate>
<dc:creator>Ruby_Lu</dc:creator>
<og:description>什么是归并？即将两个有序的数组归并成一个更大的有序数组。 什么是归并排序？先将要排序的数组递归地分成两半分别排序，然后将结果归并起来。 归并排序能够保证将任意大小为 N 的数组排序所需的时间和 N l</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/afei-24/p/13343137.html</dc:identifier>
</item>
<item>
<title>字符串学习笔记 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13364158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13364158.html</guid>
<description>&lt;h2 id=&quot;一、字符串哈希&quot;&gt;一、字符串哈希&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;字符串哈希实质上就是把每个不同的字符串转成不同的整数&lt;br/&gt;这样相对于存储整个字符串来说占用的空间更少，而且也便于比较&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;我们可以把每一个字符想象成一个数字，然后确立一个进制&lt;span class=&quot;math inline&quot;&gt;\(bas\)&lt;/span&gt;&lt;br/&gt;比如一个字符串&lt;span class=&quot;math inline&quot;&gt;\(abc\)&lt;/span&gt;&lt;br/&gt;我们可以把它表示为&lt;span class=&quot;math inline&quot;&gt;\((c-a+1)\times bas^{0} + (b-a+1)\times bas^{1} +(a-a+1)\times bas^{2}\)&lt;/span&gt;&lt;br/&gt;这里有几个需要注意的地方&lt;br/&gt;首先进制的选择要大于字符的种类数，否则会有很大的概率出现冲突&lt;br/&gt;还有就是我们在把字符转成整形的时候，可以直接使用它的&lt;span class=&quot;math inline&quot;&gt;\(ASCII\)&lt;/span&gt;码值，也可以用它减去一个字符&lt;br/&gt;但是在使用第二种方法的时候，减去一个字符后要加上一个&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，否则会出现错误&lt;br/&gt;比如字符串&lt;span class=&quot;math inline&quot;&gt;\(aaa\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(aa\)&lt;/span&gt;，如果我们将每一个字符减去&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;后不把它加上&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的话&lt;br/&gt;最后两个字符串的哈希值都会变成&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，也就是说会把这两个字符串判成相等，会出现错误的结果&lt;br/&gt;由于字符串的长度可能很大，因此如果我们一直把它的哈希值累加的话，很有可能会溢出&lt;br/&gt;因此，我们要对某个字符串的哈希值取模，方法有两种&lt;br/&gt;一种是选取一个较大的质数&lt;br/&gt;比如&lt;span class=&quot;math inline&quot;&gt;\(19260817\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(19660813\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(1222827239\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(212370440130137957\)&lt;/span&gt;&lt;br/&gt;另一种是使用&lt;span class=&quot;math inline&quot;&gt;\(unsigned long long\)&lt;/span&gt;使其自然溢出&lt;br/&gt;其实后一种方法就相当于对&lt;span class=&quot;math inline&quot;&gt;\(2^{64}-1\)&lt;/span&gt;取模&lt;br/&gt;还有一种操作是取出字符串中某一段字符&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(hash\)&lt;/span&gt;值&lt;br/&gt;这时我们要用到一个公式&lt;span class=&quot;math inline&quot;&gt;\(ha[r]-ha[l-l]*pw[r-l+1]\)&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(ha[i]\)&lt;/span&gt;为该字符串前&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;位的&lt;span class=&quot;math inline&quot;&gt;\(hash\)&lt;/span&gt;值，&lt;span class=&quot;math inline&quot;&gt;\(pw[i]\)&lt;/span&gt;为进制&lt;span class=&quot;math inline&quot;&gt;\(bas\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;次方&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;我们拿洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P3370&quot;&gt;P3370&lt;/a&gt;来举例子&lt;br/&gt;这里我用的是自然溢出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef unsigned long long ll;
const int maxn=1e5+5;
ll f[maxn];
ll bas=233,cnt=0;
ll get_hash(char s[]){
    ll ans=0,len=strlen(s);
    for(ll i=0;i&amp;lt;len;i++){
        ans=ans*bas+s[i];
    }
    return ans;
}
char s[maxn];
int main(){
    int n;
    scanf(&quot;%d&quot;,&amp;amp;n);
    while(n--){
        scanf(&quot;%s&quot;,s);
        f[++cnt]=get_hash(s);
    }
    sort(f+1,f+1+cnt);
    int now=1;
    for(ll i=2;i&amp;lt;=cnt;i++){
        if(f[i]!=f[i-1]) now++;
    }
    printf(&quot;%d\n&quot;,now);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、kmp字符串匹配&quot;&gt;二、KMP字符串匹配&lt;/h2&gt;
&lt;h3 id=&quot;定义-2&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(KMP\)&lt;/span&gt;算法是一种改进的字符串匹配算法，由&lt;span class=&quot;math inline&quot;&gt;\(D.E.Knuth，J.H.Morris\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V.R.Pratt\)&lt;/span&gt;提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称&lt;span class=&quot;math inline&quot;&gt;\(KMP\)&lt;/span&gt;算法）。&lt;span class=&quot;math inline&quot;&gt;\(KMP\)&lt;/span&gt;算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个&lt;span class=&quot;math inline&quot;&gt;\(next()\)&lt;/span&gt;函数实现，函数本身包含了模式串的局部匹配信息。&lt;span class=&quot;math inline&quot;&gt;\(KMP\)&lt;/span&gt;算法的时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(m+n)\)&lt;/span&gt;&lt;br/&gt;通俗的来说就是在需要匹配的那个串上给每个位置一个失配指针&lt;span class=&quot;math inline&quot;&gt;\(fail[j]\)&lt;/span&gt;，表示在当前位置j失配的时候需要返回到&lt;span class=&quot;math inline&quot;&gt;\(fail[j]\)&lt;/span&gt;位置继续匹配，而这就是KMP算法优秀复杂度的核心。&lt;/p&gt;
&lt;h3 id=&quot;实现-2&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;我们设&lt;span class=&quot;math inline&quot;&gt;\(fail[i]\)&lt;/span&gt;为第&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;-第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;位中前缀与后缀相同的部分最长是多长。&lt;br/&gt;这样，即可以理解为，若第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;位失配了，则至少要往前跳多少步，才可能重新匹配得上。&lt;br/&gt;我们拿实际的图来演示一下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996139/202007/1996139-20200722210326571-2016082392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;目前，我们匹配到了&lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt;的位置，&lt;span class=&quot;math inline&quot;&gt;\(fail[i-1]=j\)&lt;/span&gt;&lt;br/&gt;即图中划黄色线的部分完全相同&lt;br/&gt;我们拿当前的&lt;span class=&quot;math inline&quot;&gt;\(fail[i-1]\)&lt;/span&gt;去继续匹配&lt;br/&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(s[i]=s[j+1]\)&lt;/span&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(fail[i]\)&lt;/span&gt;更新为&lt;span class=&quot;math inline&quot;&gt;\(j+1\)&lt;/span&gt;即可&lt;br/&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(s[i] \neq s[j+1]\)&lt;/span&gt;那么如果按照暴力的思路，我们会把&lt;span class=&quot;math inline&quot;&gt;\(j--\)&lt;/span&gt;继续匹配&lt;br/&gt;但是实际上，我们可以直接从&lt;span class=&quot;math inline&quot;&gt;\(fial[j]\)&lt;/span&gt;的位置开始匹配&lt;br/&gt;因为图中两个蓝色的部分完全相等，而根据黄色的部分完全相等&lt;br/&gt;我们又可以知道从&lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt;开始也有一个蓝色的部分和它相等&lt;br/&gt;这时我们只需要判断&lt;span class=&quot;math inline&quot;&gt;\(s[i]\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(s[fail[j]+1]\)&lt;/span&gt;的关系就可以了&lt;br/&gt;如果不存在，则继续跳&lt;span class=&quot;math inline&quot;&gt;\(fail\)&lt;/span&gt;&lt;br/&gt;易证当前一定是次优解&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;我们拿洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P3375&quot;&gt;P3375&lt;/a&gt;来举例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=1e6+5;
char s[maxn],s1[maxn];
int f[maxn];
int main(){
    scanf(&quot;%s%s&quot;,s+1,s1+1);
    int l=strlen(s+1);
    int l1=strlen(s1+1);
    for(int i=2,j=0;i&amp;lt;=l1;i++){
        while(j &amp;amp;&amp;amp; s1[i]!=s1[j+1]) j=f[j];
        if(s1[i]==s1[j+1]) f[i]=++j;
    }
    for(int i=1,j=0;i&amp;lt;=l;i++){
        while(j &amp;amp;&amp;amp; s[i]!=s1[j+1]) j=f[j];
        if (s[i]==s1[j+1]) j++;
        if(j==l1){
            printf(&quot;%d\n&quot;,i-l1+1);
            j=f[j];
        }
    }
    for(int i=1;i&amp;lt;=l1;i++){
        printf(&quot;%d &quot;,f[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、manacher算法&quot;&gt;三、manacher算法&lt;/h2&gt;
&lt;h3 id=&quot;定义-3&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;马拉车&lt;span class=&quot;math inline&quot;&gt;\(（Manacher）\)&lt;/span&gt;算法是在&lt;span class=&quot;math inline&quot;&gt;\(O（n）\)&lt;/span&gt;时间内解决寻找源字符串的最长回文子串&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;的问题的算法。&lt;/p&gt;
&lt;h3 id=&quot;实现-3&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;首先我们要知道，回文串分为奇回文串和偶回文串&lt;br/&gt;像&lt;span class=&quot;math inline&quot;&gt;\(aaaa\)&lt;/span&gt;这样的就是偶回文串，而&lt;span class=&quot;math inline&quot;&gt;\(aba\)&lt;/span&gt;则是奇回文串&lt;br/&gt;不难发现，奇回文串都有一个回文中心，因此在查找时可以由中心向两边扩展&lt;br/&gt;但是偶回文串则没有这一个性质，因此查找起来不如奇回文串方便&lt;br/&gt;为了使查找更方便，我们可以让所有的偶回文串都变成奇回文串&lt;br/&gt;操作实现也很简单，就是将原字符串的首部和尾部以及每两个字符之间插入一个特殊字符，这个字符是什么不重要，不会影响最终的结果&lt;br/&gt;同时还要在队首之前再插入另一种特殊字符，防止运算时越界&lt;br/&gt;比如&lt;span class=&quot;math inline&quot;&gt;\(abaca\)&lt;/span&gt;扩展后变为&lt;span class=&quot;math inline&quot;&gt;\(#*a*b*a*c*a*\)&lt;/span&gt;&lt;br/&gt;在进行马拉车算法时，我们要维护一个已经确定的右侧最靠右的回文串的右边界&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;和回文中心&lt;span class=&quot;math inline&quot;&gt;\(mids\)&lt;/span&gt;&lt;br/&gt;同时定义一个数组&lt;span class=&quot;math inline&quot;&gt;\(f[i]\)&lt;/span&gt;为以&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;为中心的最大回文半径&lt;br/&gt;当我们遍历到&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;时，如果&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;在右边界之内&lt;br/&gt;那么根据对称性，有&lt;span class=&quot;math inline&quot;&gt;\(f[i]=f[s*mids-i]\)&lt;/span&gt;&lt;br/&gt;同时，&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;所扩展的范围必须在&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;之内，因此结果还要与&lt;span class=&quot;math inline&quot;&gt;\(r-i+1\)&lt;/span&gt;取&lt;span class=&quot;math inline&quot;&gt;\(min\)&lt;/span&gt;&lt;br/&gt;扩展完已知的区域，我们再向两边扩展未知的区域&lt;br/&gt;最后我们更新&lt;span class=&quot;math inline&quot;&gt;\(mids\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;即可&lt;br/&gt;最后的答案就是最大回文半径减去一，手模一下即可&lt;/p&gt;
&lt;h3 id=&quot;代码实现-3&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;我们拿洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P3805&quot;&gt;P3805&lt;/a&gt;来举例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=22e6+5;
char s1[maxn],s[maxn];
int f[maxn],ans,n,cnt;
int main(){
    scanf(&quot;%s&quot;,s1+1);
    n=strlen(s1+1);
    cnt=2*n+1;
    for(int i=1;i&amp;lt;=cnt;i++){
        if(i&amp;amp;1) s[i]='&amp;amp;';
        else s[i]=s1[i/2];
    }
    s[0]='%';
    for(int i=1,mids=0,r=0;i&amp;lt;=cnt;i++){
        if(i&amp;lt;=r) f[i]=min(f[2*mids-i],r-i+1);
        while(s[i+f[i]]==s[i-f[i]]) f[i]++;
        if(i+f[i]&amp;gt;r) r=i+f[i]-1,mids=i;
        if(f[i]&amp;gt;ans) ans=f[i];
    }
    printf(&quot;%d\n&quot;,ans-1);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 22 Jul 2020 21:55:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>一、字符串哈希 定义 字符串哈希实质上就是把每个不同的字符串转成不同的整数 这样相对于存储整个字符串来说占用的空间更少，而且也便于比较 实现 我们可以把每一个字符想象成一个数字，然后确立一个进制$ba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13364158.html</dc:identifier>
</item>
<item>
<title>工程能力UP | LightGBM的调参干货教程与并行优化 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13364071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13364071.html</guid>
<description>&lt;p&gt;这是个人在竞赛中对LGB模型进行调参的详细过程记录，主要包含下面六个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;大学习率，确定估计器参数&lt;code&gt;n_estimators/num_iterations/num_round/num_boost_round&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;确定&lt;code&gt;num_leaves&lt;/code&gt;和&lt;code&gt;max_depth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确定&lt;code&gt;min_data_in_leaf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确定&lt;code&gt;bagging_fraction+bagging_freq&lt;/code&gt;和&lt;code&gt;feature_fraction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确定L1L2正则&lt;code&gt;reg_alpha&lt;/code&gt;和&lt;code&gt;reg_lambda&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;降低学习率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;【这里必须说一下，lightbg的参数的同义词实在太多了，很多不同的参数表示的是同一个意思，不过本文中使用“/”分开】&lt;/p&gt;

&lt;p&gt;主要有两种feature parallel特征并行和data parallel数据并行。具体的过程我不也不了解，因为我没有多个CPU给我耍（穷）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;feature parallel：每个worker有全部的训练数据，但是他们只用部分特征进行训练，然后不同worker之间交流他们的局部最优特征和分裂点,比较出来哪一个是全局最优的。&lt;/li&gt;
&lt;li&gt;data parallel: 每一个worker有部分的样本，然后绘制局部特征直方图。彼此交流之后，得到全局直方图进行训练。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【虽然具体的机制不太了解，但是最重要的是：&lt;strong&gt;小数据用feature parallel，大数据用data parallel&lt;/strong&gt;】&lt;/p&gt;

&lt;p&gt;不管怎么样，我们先把学习率先定一个较高的值，这里取 &lt;code&gt;learning_rate = 0.1&lt;/code&gt;，其次确定估计器&lt;code&gt;boosting/boost/boosting_type&lt;/code&gt;的类型，不过默认都会选&lt;code&gt;gbdt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里可以体现，虽然LGB和XGB经常拿来和GBDT比较，但是其本质都还是GBDT的boost思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了确定估计器的数目，也就是boosting迭代的次数，也可以说是残差树的数目，参数名为&lt;code&gt;n_estimators/num_iterations/num_round/num_boost_round&lt;/code&gt;。我们可以先将该参数设成一个较大的数，然后在cv结果中查看最优的迭代次数，具体如代码。&lt;/p&gt;
&lt;p&gt;在这之前，我们必须给其他重要的参数一个初始值。初始值的意义不大，只是为了方便确定其他参数。下面先给定一下初始值：&lt;/p&gt;
&lt;p&gt;以下参数根据具体项目要求定：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;'boosting_type'/'boosting': 'gbdt'
'objective': 'regression'
'metric': 'rmse'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下参数我选择的初始值，你可以根据自己的情况来选择：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;'max_depth': 6     ###   根据问题来定咯，由于我的数据集不是很大，所以选择了一个适中的值，其实4-10都无所谓。
'num_leaves': 50  ###   由于lightGBM是leaves_wise生长，官方说法是要小于2^max_depth
'subsample'/'bagging_fraction':0.8           ###  数据采样
'colsample_bytree'/'feature_fraction': 0.8  ###  特征采样
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我是用LightGBM的cv函数进行演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params = {
    'boosting_type': 'gbdt', 
    'objective': 'regression', 

    'learning_rate': 0.1, 
    'num_leaves': 50, 
    'max_depth': 6,

    'subsample': 0.8, 
    'colsample_bytree': 0.8, 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data_train = lgb.Dataset(df_train, y_train, silent=True)
cv_results = lgb.cv(
    params, data_train, num_boost_round=1000, nfold=5, stratified=False, shuffle=True, metrics='rmse',
    early_stopping_rounds=50, verbose_eval=50, show_stdv=True, seed=0)

print('best n_estimators:', len(cv_results['rmse-mean']))
print('best cv score:', cv_results['rmse-mean'][-1])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[50] cv_agg's rmse: 1.38497 + 0.0202823
best n_estimators: 43
best cv score: 1.3838664241
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们得到了结果，在学习率0.1的时候，有43个估计器的时候效果最好。所以现在我们已经调整好了一个参数了：&lt;code&gt;n_estimators/num_iterations/num_round/num_boost_round=43&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;【在硬件设备允许的条件下，学习率还是越小越好】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这是提高精确度的最重要的参数。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;max_depth&lt;/code&gt;:设置树深度，深度越大可能过拟合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;num_leaves&lt;/code&gt;:因为 LightGBM 使用的是 leaf-wise 的算法，因此在调节树的复杂程度时，使用的是 num_leaves 而不是 max_depth。大致换算关系：num_leaves = 2^(max_depth)，但是它的值的设置应该小于 2^(max_depth)，否则可能会导致过拟合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【这里虽然说了num_leaves与max_depth之间的关系，但是并不是严格的，大概在这个左右就好了。】&lt;/p&gt;
&lt;p&gt;接下来同时对这两个参数调优，引入&lt;code&gt;sklearn&lt;/code&gt;中的&lt;code&gt;GridSearchCV()&lt;/code&gt;函数进行网格搜索，当然也可以使用贝叶斯搜索，贝叶斯这个之前在个人博客讲过，之后我有空了再搬运到公众号好了。&lt;/p&gt;
&lt;p&gt;不过这个搜索过程，非常耗时间，非常消耗精力。对于大数据集的话，建议贝叶斯，或者就简单调整下就行了。一般这种参数优化的空间非常有限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.model_selection import GridSearchCV
### 我们可以创建lgb的sklearn模型，使用上面选择的(学习率，评估器数目)
model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=50,
                              learning_rate=0.1, n_estimators=43, max_depth=6,
                              metric='rmse', bagging_fraction = 0.8,feature_fraction = 0.8)

params_test1={
    'max_depth': range(3,8,2),
    'num_leaves':range(50, 170, 30)
}
gsearch1 = GridSearchCV(estimator=model_lgb, param_grid=params_test1, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;gsearch1.fit(df_train, y_train)
gsearch1.grid_scores_, gsearch1.best_params_, gsearch1.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看下运行的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 12 candidates, totalling 60 fits


[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:  2.0min
[Parallel(n_jobs=4)]: Done  60 out of  60 | elapsed:  3.1min finished


([mean: -1.88629, std: 0.13750, params: {'max_depth': 3, 'num_leaves': 50},
  mean: -1.88629, std: 0.13750, params: {'max_depth': 3, 'num_leaves': 80},
  mean: -1.88629, std: 0.13750, params: {'max_depth': 3, 'num_leaves': 110},
  mean: -1.88629, std: 0.13750, params: {'max_depth': 3, 'num_leaves': 140},
  mean: -1.86917, std: 0.12590, params: {'max_depth': 5, 'num_leaves': 50},
  mean: -1.86917, std: 0.12590, params: {'max_depth': 5, 'num_leaves': 80},
  mean: -1.86917, std: 0.12590, params: {'max_depth': 5, 'num_leaves': 110},
  mean: -1.86917, std: 0.12590, params: {'max_depth': 5, 'num_leaves': 140},
  mean: -1.89254, std: 0.10904, params: {'max_depth': 7, 'num_leaves': 50},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 80},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 110},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 140}],
 {'max_depth': 7, 'num_leaves': 80},
 -1.8602436718814157)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里运行了12个参数组合，得到的最优解是在&lt;code&gt;max_depth&lt;/code&gt;为7，&lt;code&gt;num_leaves&lt;/code&gt;为80的情况下，分数为-1.860。&lt;/p&gt;
&lt;p&gt;这里必须说一下，sklearn模型评估里的scoring参数都是采用的&lt;strong&gt;higher return values are better than lower return values&lt;/strong&gt;（较高的返回值优于较低的返回值）。&lt;/p&gt;
&lt;p&gt;但是，我采用的metric策略采用的是均方误差(rmse)，越低越好，所以sklearn就提供了&lt;code&gt;neg_mean_squared_error&lt;/code&gt;参数，也就是返回metric的负数，所以就均方差来说，也就变成负数越大越好了。&lt;/p&gt;
&lt;p&gt;所以，可以看到，最优解的分数为-1.860，转化为均方差为np.sqrt(-(-1.860)) = 1.3639，明显比step1的分数要好很多。(之前用的是rmse均方根误差，要开方)&lt;/p&gt;
&lt;p&gt;至此，我们将我们这步得到的最优解代入第三步。其实，我这里只进行了粗调，如果要得到更好的效果，可以将max_depth在7附近多取几个值，num_leaves在80附近多取几个值。千万不要怕麻烦，虽然这确实很麻烦。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params_test2={
    'max_depth': [6,7,8],
    'num_leaves':[68,74,80,86,92]
}

gsearch2 = GridSearchCV(estimator=model_lgb, param_grid=params_test2, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
gsearch2.fit(df_train, y_train)
gsearch2.grid_scores_, gsearch2.best_params_, gsearch2.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 15 candidates, totalling 75 fits


[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:  2.8min
[Parallel(n_jobs=4)]: Done  75 out of  75 | elapsed:  5.1min finished


([mean: -1.87506, std: 0.11369, params: {'max_depth': 6, 'num_leaves': 68},
  mean: -1.87506, std: 0.11369, params: {'max_depth': 6, 'num_leaves': 74},
  mean: -1.87506, std: 0.11369, params: {'max_depth': 6, 'num_leaves': 80},
  mean: -1.87506, std: 0.11369, params: {'max_depth': 6, 'num_leaves': 86},
  mean: -1.87506, std: 0.11369, params: {'max_depth': 6, 'num_leaves': 92},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 68},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 74},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 80},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 86},
  mean: -1.86024, std: 0.11364, params: {'max_depth': 7, 'num_leaves': 92},
  mean: -1.88197, std: 0.11295, params: {'max_depth': 8, 'num_leaves': 68},
  mean: -1.89117, std: 0.12686, params: {'max_depth': 8, 'num_leaves': 74},
  mean: -1.86390, std: 0.12259, params: {'max_depth': 8, 'num_leaves': 80},
  mean: -1.86733, std: 0.12159, params: {'max_depth': 8, 'num_leaves': 86},
  mean: -1.86665, std: 0.12174, params: {'max_depth': 8, 'num_leaves': 92}],
 {'max_depth': 7, 'num_leaves': 68},
 -1.8602436718814157)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见最大深度7是没问题的，但是看细节的话，发现在最大深度为7的情况下，叶结点的数量对分数并没有影响。&lt;/p&gt;

&lt;p&gt;说到这里，就该降低过拟合了。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;min_data_in_leaf&lt;/code&gt;是一个很重要的参数, 也叫min_child_samples，它的值取决于训练数据的样本个树和num_leaves. 将其设置的较大可以避免生成一个过深的树, 但有可能导致欠拟合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;min_sum_hessian_in_leaf&lt;/code&gt;：也叫min_child_weight，使一个结点分裂的最小海森值之和，真拗口（Minimum sum of hessians in one leaf to allow a split. Higher values potentially decrease overfitting）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于第二个参数，其实我不是非常的明白，因为不太了解hessian值和hessian矩阵？之后有空抽个时间好好学习一下，我学习的过程就是这样查漏补缺2333。&lt;strong&gt;请大家关注公众号，这样不会错过每一个干货&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们采用跟上面相同的方法进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params_test3={
    'min_child_samples': [18, 19, 20, 21, 22],
    'min_child_weight':[0.001, 0.002]
}
model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=80,
                              learning_rate=0.1, n_estimators=43, max_depth=7, 
                              metric='rmse', bagging_fraction = 0.8, feature_fraction = 0.8)
gsearch3 = GridSearchCV(estimator=model_lgb, param_grid=params_test3, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
gsearch3.fit(df_train, y_train)
gsearch3.grid_scores_, gsearch3.best_params_, gsearch3.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 10 candidates, totalling 50 fits


[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:  2.9min
[Parallel(n_jobs=4)]: Done  50 out of  50 | elapsed:  3.3min finished


([mean: -1.88057, std: 0.13948, params: {'min_child_samples': 18, 'min_child_weight': 0.001},
  mean: -1.88057, std: 0.13948, params: {'min_child_samples': 18, 'min_child_weight': 0.002},
  mean: -1.88365, std: 0.13650, params: {'min_child_samples': 19, 'min_child_weight': 0.001},
  mean: -1.88365, std: 0.13650, params: {'min_child_samples': 19, 'min_child_weight': 0.002},
  mean: -1.86024, std: 0.11364, params: {'min_child_samples': 20, 'min_child_weight': 0.001},
  mean: -1.86024, std: 0.11364, params: {'min_child_samples': 20, 'min_child_weight': 0.002},
  mean: -1.86980, std: 0.14251, params: {'min_child_samples': 21, 'min_child_weight': 0.001},
  mean: -1.86980, std: 0.14251, params: {'min_child_samples': 21, 'min_child_weight': 0.002},
  mean: -1.86750, std: 0.13898, params: {'min_child_samples': 22, 'min_child_weight': 0.001},
  mean: -1.86750, std: 0.13898, params: {'min_child_samples': 22, 'min_child_weight': 0.002}],
 {'min_child_samples': 20, 'min_child_weight': 0.001},
 -1.8602436718814157)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是我经过粗调后细调的结果，可以看到，&lt;code&gt;min_data_in_leaf&lt;/code&gt;的最优值为20，而&lt;code&gt;min_sum_hessian_in_leaf&lt;/code&gt;对最后的值几乎没有影响。且这里调参之后，最优的结果还是-1.86024，没有提升。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这两个参数都是为了降低过拟合的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;feature_fraction&lt;/code&gt;参数来进行特征的子抽样。这个参数可以用来防止过拟合及提高训练速度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bagging_fraction+bagging_freq&lt;/code&gt;参数必须同时设置，bagging_fraction相当于subsample样本采样，可以使bagging更快的运行，同时也可以降拟合。bagging_freq默认0，表示bagging的频率，0意味着没有使用bagging，k意味着每k轮迭代进行一次bagging。&lt;/p&gt;
&lt;p&gt;不同的参数，同样的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params_test4={
    'feature_fraction': [0.5, 0.6, 0.7, 0.8, 0.9],
    'bagging_fraction': [0.6, 0.7, 0.8, 0.9, 1.0]
}
model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=80,
                              learning_rate=0.1, n_estimators=43, max_depth=7, 
                              metric='rmse', bagging_freq = 5,  min_child_samples=20)
gsearch4 = GridSearchCV(estimator=model_lgb, param_grid=params_test4, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
gsearch4.fit(df_train, y_train)
gsearch4.grid_scores_, gsearch4.best_params_, gsearch4.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 25 candidates, totalling 125 fits


[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:  2.6min
[Parallel(n_jobs=4)]: Done 125 out of 125 | elapsed:  7.1min finished


([mean: -1.90447, std: 0.15841, params: {'bagging_fraction': 0.6, 'feature_fraction': 0.5},
  mean: -1.90846, std: 0.13925, params: {'bagging_fraction': 0.6, 'feature_fraction': 0.6},
  mean: -1.91695, std: 0.14121, params: {'bagging_fraction': 0.6, 'feature_fraction': 0.7},
  mean: -1.90115, std: 0.12625, params: {'bagging_fraction': 0.6, 'feature_fraction': 0.8},
  mean: -1.92586, std: 0.15220, params: {'bagging_fraction': 0.6, 'feature_fraction': 0.9},
  mean: -1.88031, std: 0.17157, params: {'bagging_fraction': 0.7, 'feature_fraction': 0.5},
  mean: -1.89513, std: 0.13718, params: {'bagging_fraction': 0.7, 'feature_fraction': 0.6},
  mean: -1.88845, std: 0.13864, params: {'bagging_fraction': 0.7, 'feature_fraction': 0.7},
  mean: -1.89297, std: 0.12374, params: {'bagging_fraction': 0.7, 'feature_fraction': 0.8},
  mean: -1.89432, std: 0.14353, params: {'bagging_fraction': 0.7, 'feature_fraction': 0.9},
  mean: -1.88088, std: 0.14247, params: {'bagging_fraction': 0.8, 'feature_fraction': 0.5},
  mean: -1.90080, std: 0.13174, params: {'bagging_fraction': 0.8, 'feature_fraction': 0.6},
  mean: -1.88364, std: 0.14732, params: {'bagging_fraction': 0.8, 'feature_fraction': 0.7},
  mean: -1.88987, std: 0.13344, params: {'bagging_fraction': 0.8, 'feature_fraction': 0.8},
  mean: -1.87752, std: 0.14802, params: {'bagging_fraction': 0.8, 'feature_fraction': 0.9},
  mean: -1.88348, std: 0.13925, params: {'bagging_fraction': 0.9, 'feature_fraction': 0.5},
  mean: -1.87472, std: 0.13301, params: {'bagging_fraction': 0.9, 'feature_fraction': 0.6},
  mean: -1.88656, std: 0.12241, params: {'bagging_fraction': 0.9, 'feature_fraction': 0.7},
  mean: -1.89029, std: 0.10776, params: {'bagging_fraction': 0.9, 'feature_fraction': 0.8},
  mean: -1.88719, std: 0.11915, params: {'bagging_fraction': 0.9, 'feature_fraction': 0.9},
  mean: -1.86170, std: 0.12544, params: {'bagging_fraction': 1.0, 'feature_fraction': 0.5},
  mean: -1.87334, std: 0.13099, params: {'bagging_fraction': 1.0, 'feature_fraction': 0.6},
  mean: -1.85412, std: 0.12698, params: {'bagging_fraction': 1.0, 'feature_fraction': 0.7},
  mean: -1.86024, std: 0.11364, params: {'bagging_fraction': 1.0, 'feature_fraction': 0.8},
  mean: -1.87266, std: 0.12271, params: {'bagging_fraction': 1.0, 'feature_fraction': 0.9}],
 {'bagging_fraction': 1.0, 'feature_fraction': 0.7},
 -1.8541224387666373)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这里可以看出来，&lt;code&gt;bagging_feaction&lt;/code&gt;和&lt;code&gt;feature_fraction&lt;/code&gt;的理想值分别是1.0和0.7，一个很重要原因就是，我的样本数量比较小(4000+)，但是特征数量很多(1000+)。所以，这里我们取更小的步长，对feature_fraction进行更细致的取值。&lt;/p&gt;
&lt;p&gt;下面微调一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params_test5={
    'feature_fraction': [0.62, 0.65, 0.68, 0.7, 0.72, 0.75, 0.78 ]
}
model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=80,
                              learning_rate=0.1, n_estimators=43, max_depth=7, 
                              metric='rmse',  min_child_samples=20)
gsearch5 = GridSearchCV(estimator=model_lgb, param_grid=params_test5, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
gsearch5.fit(df_train, y_train)
gsearch5.grid_scores_, gsearch5.best_params_, gsearch5.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 7 candidates, totalling 35 fits


[Parallel(n_jobs=4)]: Done  35 out of  35 | elapsed:  2.3min finished


([mean: -1.86696, std: 0.12658, params: {'feature_fraction': 0.62},
  mean: -1.88337, std: 0.13215, params: {'feature_fraction': 0.65},
  mean: -1.87282, std: 0.13193, params: {'feature_fraction': 0.68},
  mean: -1.85412, std: 0.12698, params: {'feature_fraction': 0.7},
  mean: -1.88235, std: 0.12682, params: {'feature_fraction': 0.72},
  mean: -1.86329, std: 0.12757, params: {'feature_fraction': 0.75},
  mean: -1.87943, std: 0.12107, params: {'feature_fraction': 0.78}],
 {'feature_fraction': 0.7},
 -1.8541224387666373)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，feature_fraction就是0.7了&lt;/p&gt;

&lt;p&gt;正则化参数lambda_l1(reg_alpha), lambda_l2(reg_lambda)，毫无疑问，是降低过拟合的，两者分别对应l1正则化和l2正则化。我们也来尝试一下使用这两个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params_test6={
    'reg_alpha': [0, 0.001, 0.01, 0.03, 0.08, 0.3, 0.5],
    'reg_lambda': [0, 0.001, 0.01, 0.03, 0.08, 0.3, 0.5]
}
model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=80,
                              learning_rate=0.b1, n_estimators=43, max_depth=7, 
                              metric='rmse',  min_child_samples=20, feature_fraction=0.7)
gsearch6 = GridSearchCV(estimator=model_lgb, param_grid=params_test6, scoring='neg_mean_squared_error', cv=5, verbose=1, n_jobs=4)
gsearch6.fit(df_train, y_train)
gsearch6.grid_scores_, gsearch6.best_params_, gsearch6.best_score_
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;Fitting 5 folds for each of 49 candidates, totalling 245 fits


[Parallel(n_jobs=4)]: Done  42 tasks      | elapsed:  2.8min
[Parallel(n_jobs=4)]: Done 192 tasks      | elapsed: 10.6min
[Parallel(n_jobs=4)]: Done 245 out of 245 | elapsed: 13.3min finished


([mean: -1.85412, std: 0.12698, params: {'reg_alpha': 0, 'reg_lambda': 0},
  mean: -1.85990, std: 0.13296, params: {'reg_alpha': 0, 'reg_lambda': 0.001},
  mean: -1.86367, std: 0.13634, params: {'reg_alpha': 0, 'reg_lambda': 0.01},
  mean: -1.86787, std: 0.13881, params: {'reg_alpha': 0, 'reg_lambda': 0.03},
  mean: -1.87099, std: 0.12476, params: {'reg_alpha': 0, 'reg_lambda': 0.08},
  mean: -1.87670, std: 0.11849, params: {'reg_alpha': 0, 'reg_lambda': 0.3},
  mean: -1.88278, std: 0.13064, params: {'reg_alpha': 0, 'reg_lambda': 0.5},
  mean: -1.86190, std: 0.13613, params: {'reg_alpha': 0.001, 'reg_lambda': 0},
  mean: -1.86190, std: 0.13613, params: {'reg_alpha': 0.001, 'reg_lambda': 0.001},
  mean: -1.86515, std: 0.14116, params: {'reg_alpha': 0.001, 'reg_lambda': 0.01},
  mean: -1.86908, std: 0.13668, params: {'reg_alpha': 0.001, 'reg_lambda': 0.03},
  mean: -1.86852, std: 0.12289, params: {'reg_alpha': 0.001, 'reg_lambda': 0.08},
  mean: -1.88076, std: 0.11710, params: {'reg_alpha': 0.001, 'reg_lambda': 0.3},
  mean: -1.88278, std: 0.13064, params: {'reg_alpha': 0.001, 'reg_lambda': 0.5},
  mean: -1.87480, std: 0.13889, params: {'reg_alpha': 0.01, 'reg_lambda': 0},
  mean: -1.87284, std: 0.14138, params: {'reg_alpha': 0.01, 'reg_lambda': 0.001},
  mean: -1.86030, std: 0.13332, params: {'reg_alpha': 0.01, 'reg_lambda': 0.01},
  mean: -1.86695, std: 0.12587, params: {'reg_alpha': 0.01, 'reg_lambda': 0.03},
  mean: -1.87415, std: 0.13100, params: {'reg_alpha': 0.01, 'reg_lambda': 0.08},
  mean: -1.88543, std: 0.13195, params: {'reg_alpha': 0.01, 'reg_lambda': 0.3},
  mean: -1.88076, std: 0.13502, params: {'reg_alpha': 0.01, 'reg_lambda': 0.5},
  mean: -1.87729, std: 0.12533, params: {'reg_alpha': 0.03, 'reg_lambda': 0},
  mean: -1.87435, std: 0.12034, params: {'reg_alpha': 0.03, 'reg_lambda': 0.001},
  mean: -1.87513, std: 0.12579, params: {'reg_alpha': 0.03, 'reg_lambda': 0.01},
  mean: -1.88116, std: 0.12218, params: {'reg_alpha': 0.03, 'reg_lambda': 0.03},
  mean: -1.88052, std: 0.13585, params: {'reg_alpha': 0.03, 'reg_lambda': 0.08},
  mean: -1.87565, std: 0.12200, params: {'reg_alpha': 0.03, 'reg_lambda': 0.3},
  mean: -1.87935, std: 0.13817, params: {'reg_alpha': 0.03, 'reg_lambda': 0.5},
  mean: -1.87774, std: 0.12477, params: {'reg_alpha': 0.08, 'reg_lambda': 0},
  mean: -1.87774, std: 0.12477, params: {'reg_alpha': 0.08, 'reg_lambda': 0.001},
  mean: -1.87911, std: 0.12027, params: {'reg_alpha': 0.08, 'reg_lambda': 0.01},
  mean: -1.86978, std: 0.12478, params: {'reg_alpha': 0.08, 'reg_lambda': 0.03},
  mean: -1.87217, std: 0.12159, params: {'reg_alpha': 0.08, 'reg_lambda': 0.08},
  mean: -1.87573, std: 0.14137, params: {'reg_alpha': 0.08, 'reg_lambda': 0.3},
  mean: -1.85969, std: 0.13109, params: {'reg_alpha': 0.08, 'reg_lambda': 0.5},
  mean: -1.87632, std: 0.12398, params: {'reg_alpha': 0.3, 'reg_lambda': 0},
  mean: -1.86995, std: 0.12651, params: {'reg_alpha': 0.3, 'reg_lambda': 0.001},
  mean: -1.86380, std: 0.12793, params: {'reg_alpha': 0.3, 'reg_lambda': 0.01},
  mean: -1.87577, std: 0.13002, params: {'reg_alpha': 0.3, 'reg_lambda': 0.03},
  mean: -1.87402, std: 0.13496, params: {'reg_alpha': 0.3, 'reg_lambda': 0.08},
  mean: -1.87032, std: 0.12504, params: {'reg_alpha': 0.3, 'reg_lambda': 0.3},
  mean: -1.88329, std: 0.13237, params: {'reg_alpha': 0.3, 'reg_lambda': 0.5},
  mean: -1.87196, std: 0.13099, params: {'reg_alpha': 0.5, 'reg_lambda': 0},
  mean: -1.87196, std: 0.13099, params: {'reg_alpha': 0.5, 'reg_lambda': 0.001},
  mean: -1.88222, std: 0.14735, params: {'reg_alpha': 0.5, 'reg_lambda': 0.01},
  mean: -1.86618, std: 0.14006, params: {'reg_alpha': 0.5, 'reg_lambda': 0.03},
  mean: -1.88579, std: 0.12398, params: {'reg_alpha': 0.5, 'reg_lambda': 0.08},
  mean: -1.88297, std: 0.12307, params: {'reg_alpha': 0.5, 'reg_lambda': 0.3},
  mean: -1.88148, std: 0.12622, params: {'reg_alpha': 0.5, 'reg_lambda': 0.5}],
 {'reg_alpha': 0, 'reg_lambda': 0},
 -1.8541224387666373)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，看来我多此一举了。&lt;/p&gt;

&lt;p&gt;回到第一步，不过我们使用的是已经优化好的参数值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;params = {
    'boosting_type': 'gbdt', 
    'objective': 'regression', 

    'learning_rate': 0.005, 
    'num_leaves': 80, 
    'max_depth': 7,
    'min_data_in_leaf': 20,

    'subsample': 1, 
    'colsample_bytree': 0.7, 
    }

data_train = lgb.Dataset(df_train, y_train, silent=True)
cv_results = lgb.cv(
    params, data_train, num_boost_round=10000, nfold=5, stratified=False, shuffle=True, metrics='rmse',
    early_stopping_rounds=50, verbose_eval=100, show_stdv=True)

print('best n_estimators:', len(cv_results['rmse-mean']))
print('best cv score:', cv_results['rmse-mean'][-1])
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[100]        cv_agg's rmse: 1.52939 + 0.0261756
[200]   cv_agg's rmse: 1.43535 + 0.0187243
[300]   cv_agg's rmse: 1.39584 + 0.0157521
[400]   cv_agg's rmse: 1.37935 + 0.0157429
[500]   cv_agg's rmse: 1.37313 + 0.0164503
[600]   cv_agg's rmse: 1.37081 + 0.0172752
[700]   cv_agg's rmse: 1.36942 + 0.0177888
[800]   cv_agg's rmse: 1.36854 + 0.0180575
[900]   cv_agg's rmse: 1.36817 + 0.0188776
[1000]  cv_agg's rmse: 1.36796 + 0.0190279
[1100]  cv_agg's rmse: 1.36783 + 0.0195969
best n_estimators: 1079
best cv score: 1.36772351783
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.2cto.com/kf/201607/528771.html&quot;&gt;https://www.2cto.com/kf/201607/528771.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30627440&quot;&gt;https://zhuanlan.zhihu.com/p/30627440&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/b4ac0596e5ef&quot;&gt;https://www.jianshu.com/p/b4ac0596e5ef&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/bjwu/p/9307344.html&quot;&gt;https://www.cnblogs.com/bjwu/p/9307344.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlQTAlODclRTklQTIlOThfJUU1JThBJUE4JUU2JTgwJTgxJUU1JTg4JTg2JUU1JTg5JUIyJUU3JUJBJUJGXzIwMjAtMDctMjAtMC5naWY&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy93cF9lZGl0b3JfbWRfMzEyZGQyZDliYmNmZmNiZDk0Y2YwODlkYTE4YzVjNGEuanBn?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hlbGxvd29ybGQyMDIwLm5ldC93cC1jb250ZW50L3VwbG9hZHMvMjAyMC8wNy8lRTklQkIlOTglRTglQUUlQTQlRTYlOTYlODclRTQlQkIlQjYxNTk1MjUxNjIxMTEyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Jul 2020 17:02:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>这是个人在竞赛中对LGB模型进行调参的详细过程记录，主要包含下面六个步骤： 大学习率，确定估计器参数n_estimators/num_iterations/num_round/num_boost_ro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13364071.html</dc:identifier>
</item>
<item>
<title>说一说结构化思维 - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13364052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13364052.html</guid>
<description>&lt;h2 id=&quot;什么是结构化思维&quot;&gt;什么是结构化思维&lt;/h2&gt;
&lt;p&gt;先看看 &lt;code&gt;结构化思维&lt;/code&gt; 这几个字，拆解一下这个词语：&lt;br/&gt;结构：把整体拆解开来，分为各个部分，这各个部分就是每个结构。&lt;/p&gt;
&lt;p&gt;比如把人体拆解开来，可以分为头部、身体、手、脚、躯干等部分，这些部分的组合就形成了一个人，变成了一个整体。&lt;/p&gt;
&lt;p&gt;结构化思维，我的理解就是把整体拆解开，分成部分，然后对这些部分进行思考，研究，各个部分之间的关系。&lt;/p&gt;
&lt;p&gt;然后也可以把各部分按某种方式连接起来，形成一个整体。&lt;br/&gt;总 -&amp;gt; 分 -&amp;gt; 总。&lt;/p&gt;
&lt;h2 id=&quot;怎么运用结构化思维&quot;&gt;怎么运用结构化思维&lt;/h2&gt;
&lt;h3 id=&quot;学习某项技术&quot;&gt;学习某项技术&lt;/h3&gt;
&lt;p&gt;假如学习java方面的知识，以前我们没有使用过java技术，有其他语言技术基础，现在从零开始学习java语言。&lt;/p&gt;
&lt;p&gt;怎么学习？从哪里开始入门呢？&lt;br/&gt;首先从基础开始。去找一本比较薄的java基础书籍，先看它的目录，书肯定是把java技术这个整体分成一部分一部分来讲解，比如：&lt;br/&gt;基础部分：&lt;br/&gt;java语法、数据类型、运算符、控制流程，&lt;br/&gt;接着可能就是对象和类：封装、继承、多态，类，抽象类，接口，内部类等&lt;br/&gt;在接下来：异常和错误处理&lt;br/&gt;接下来：各种I/O，文件操作&lt;br/&gt;接下来：各种集合的学习&lt;/p&gt;
&lt;p&gt;高级一点的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;泛型&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;等等，其他部分就不一一列举了，java肯定还有很多其他的知识需要学习。&lt;/p&gt;
&lt;p&gt;你看，把java基础部分需要学习的一一分解为小的技术点，一个一个来学习。把整体分解为各个细小的部分，然后各个来学习。 这就是一种结构化分解思维方式。&lt;/p&gt;
&lt;h3 id=&quot;软件开发流程&quot;&gt;软件开发流程&lt;/h3&gt;
&lt;p&gt;软件开发流程这是一个整体，但是开发时候，会把它分解为业务分析，需求分析，产品功能，技术开发，测试，上线等等一个一个部分，把任务分解给不同的人。&lt;br/&gt;这也可以看作是一个结构化分解的过程。&lt;/p&gt;
&lt;h3 id=&quot;用户体验要素&quot;&gt;用户体验要素&lt;/h3&gt;
&lt;p&gt;比如用户体验要素的5层模型，表现层，框架层，架构层，范围层，战略层。这个分解度比较大，以层为维度来进行分解。我觉得也可以看做是一种结构化的分解。&lt;br/&gt;所以这种结构化分解，然后进行思考的方法，使用的非常广泛。&lt;/p&gt;
&lt;h2 id=&quot;金字塔原理&quot;&gt;金字塔原理&lt;/h2&gt;
&lt;p&gt;这本书相信很多人看过，它里面也有很多结构化思考的方法。&lt;br/&gt;4个构建金子塔基本原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结论先行&lt;/li&gt;
&lt;li&gt;以下统上&lt;/li&gt;
&lt;li&gt;归类分组&lt;/li&gt;
&lt;li&gt;逻辑递进&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;有什么工具辅助结构化思维呢？&lt;br/&gt;思维导图工具。&lt;/p&gt;
&lt;p&gt;比如我们上面说的java基础学习，就可以用思维导图把这些知识点列出来。看着思维导图学习，就一目了然，学完一个可以打一个勾。&lt;/p&gt;
&lt;p&gt;现在很多人总结知识的时候都会用这个工具，比如xxx知识图谱，xxx技术图谱，xxx知识思维导图。&lt;/p&gt;
&lt;p&gt;这些知识图的总结都是运用了结构化思维这种思维方式。然后用图来进行可视化。&lt;br/&gt;这种方式也是值得学习。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Jul 2020 16:41:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>什么是结构化思维 先看看 结构化思维 这几个字，拆解一下这个词语： 结构：把整体拆解开来，分为各个部分，这各个部分就是每个结构。 比如把人体拆解开来，可以分为头部、身体、手、脚、躯干等部分，这些部分的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13364052.html</dc:identifier>
</item>
<item>
<title>OFDM通信系统的MATLAB仿真(2) - 羽扇纶巾o0</title>
<link>http://www.cnblogs.com/gjblog/p/13363995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gjblog/p/13363995.html</guid>
<description>&lt;p&gt;关于OFDM系统的MATLAB仿真实现的第二篇随笔，在第一篇中，我们讨论的是信号经过AWGN信道的情况，只用添加固定噪声功率的高斯白噪声就好了。但在实际无线信道中，信道干扰常常是加性噪声、多径衰落的结合。今天我们准备再进一步，让信号经过多径瑞利衰落信道。在这种信道条件下，信号具体是怎么怎么变化的呢？下面将讲解系统仿真的各个部分以及实现多径衰落的方法。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：为了整个系统的完整性，第一篇随笔中的每个步骤这里也都又写了一遍，但省略了补充知识部分，在第一篇的基础上添加了实现多径衰落的部分。想要看信噪比计算和噪声功率计算的同学可以去看第一篇随笔。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于OFDM系统我目前参考的是《MIMO-OFDM无线通信技术及MATLAB实现》这本书，这里将将作者实现OFDM系统的思路及其代码重新理顺一遍。注意这篇文章我没有一来就贴公式，巴拉巴拉讲原理，那样不就和老师上课念PPT一样了吗。其实我更喜欢直接学习大佬的仿真代码，先对过程有个个大概思路再去推导细节和公式。这里因为我理解的水平也有限，有不对的地方希望大佬能帮忙指正。如果是没怎么接触过OFDM的萌新，这篇文章可以帮助你对OFDM符号级的仿真有个粗浅的了解XD。&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;首先画一个我个人认为特别好理解的OFDM符号变化图来帮助理解代码，多径瑞利衰落在步骤4到步骤5之间，在添加AWGN的前面。接下来我会详细的介绍每个步骤在干什么。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202007/2048856-20200721175600435-2002070607.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤0&quot;&gt;步骤0&amp;gt;&lt;/h2&gt;
&lt;p&gt;照例假装前景摘要一下。本OFDM系统仿真用到的技术主要有：&lt;code&gt;16QAM调制解调 IFFT与FFT 多径瑞利信道 添加AWGN噪声&lt;/code&gt;，没用到的有：&lt;code&gt;信道编码 扩频 交织 信道估计&lt;/code&gt;等等，哇，越难的技术越不想学(主要是&lt;s&gt;学不懂&lt;/s&gt;)。这些技术的数学理论推导确实很难，但是在MATLAB仿真中往往用几个自带的函数就能解决问题，所以要实现一个简单的OFDM系统还是很容易的，不要被天花乱坠般恐怖的数学公式吓跑了(所以我最喜欢的就是直接看代码的运行过程，然后有时间再去研究数学推导23333)。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;步骤1&quot;&gt;步骤1&amp;gt;&lt;/h2&gt;
&lt;p&gt;这个仿真好像暂时没有时间的概念，单位是按照采样点来的。假设一帧有三个OFDM符号，每个符号长度为64(刚好在步骤3做IFFT时长度也为64，满足2的幂次方)。我们首先生成数字基带信号，信号长度为192个采样点，由于要进行16QAM调制，我们直接随机生成192个16进制的数作为基带信号X(K)，然后再将X(K)经过16QAM星座图映射便完成了调制。&lt;strong&gt;注意调制完输出的X_mod是复信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外在步骤1我们还要进行信噪比的一些初始化，便于计算噪声幅度和最后的计算比特误码率。&lt;/p&gt;
&lt;h3 id=&quot;增加部分：&quot;&gt;增加部分：&lt;/h3&gt;
&lt;p&gt;在步骤1中，我们增加对信道特征的初始化工作。主要是假设多径信道个数和信道功率，以及各信道的时延，为之后信号通过多径信道的计算做准备。&lt;/p&gt;
&lt;h3 id=&quot;代码：&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;clc; clear all; clode all
NFRAME = 3;                         % 每一帧的OFDM符号数
NFFT = 64;                          % 每帧FFT长度
NCP = 16;                           % 循环前缀长度
NSYM = NFFT + NCP;                  % OFDM符号长度
M = 16; K = 4;                      % M:调制阶数，K:log2(M)

EbN0 = 0;                           % 设出比特信噪比(dB)
snr = EbN0 + 10 * log10(K);         % 由公式推出snr(dB)表达式
BER(1 : length(EbN0)) = 0;          % 初始化误码率

P_hdB = [0 -8 -17 -21 -25];         % 各信道功率特性(dB)
D_h = [0 3 5 6 8];                  % 各信道延迟(采样点)
P_h = 10 .^ (P_hdB / 10);           % 各信道功率特性
NH = length(P_hdB);                 % 多径信道个数
LH = D_h(end)+1;                    % 信道长度(延迟过后)

X = randi([0,15],1,NFFT * NFRAME);  % 生成数字基带信号

X_mod = qammod(X,M,'gray') / (sqrt(10)); % 16QAM调制，格雷码星座图，并归一化
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤2、3、4&quot;&gt;步骤2、3、4&amp;gt;&lt;/h2&gt;
&lt;p&gt;接下来的三个步骤分别如下，注意都是一个符号一个符号处理的，可回去看最开始的符号变化图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将每个OFDM符号的前一半和后一半交换，至于为什么要做交换，我仍然不是很懂。有大佬知道的话希望能在评论区指导一下，感激不尽！&lt;/li&gt;
&lt;li&gt;对交换过后的每个OFDM符号做IFFT，记录输出为x1(n)。&lt;/li&gt;
&lt;li&gt;对每个OFDM符号添加循环前缀CP，实际操作很简单，因为这里设的CP的长度NCP为16。就是把每个符号的后16个采样点添加到当前符号的最前面来，每个符号因此就变成了64+16=80个采样点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于这三个步骤都是在一个循环里处理的，所以我也就把步骤2、3、4写到一起了。&lt;/p&gt;
&lt;h3 id=&quot;代码：-2&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;x(1 : NFFT * NFRAME) = 0;           % 预分配x数组
xt(1 : (NFFT + NCP) * NFRAME) = 0;  % 预分配x_t数组

len_a = 1 : NFFT;                   % 处理的X位置
len_b = 1 : (NFFT + NCP);           % 处理的X位置(加上CP的长度)
len_c = 1 : NCP;
len_left = 1 : (NFFT / 2); len_right = (NFFT / 2 + 1) : NFFT; % 每一符号分为左右两边

for frame = 1 : NFRAME              % 对于每个OFDM符号都要翻转和IFFT
    x(len_a) = ifft([X_mod(len_right), X_mod(len_left)]); % 左右翻转再ifft
    xt(len_b) = [x(len_c + NFFT - NCP), x(len_a)]; % 添加CP后的信号数组

    len_a = len_a + NFFT;           % 更新找到下一个符号起点位置
    len_b = len_b + NFFT + NCP;     % 更新找到下一个符号起点位置(CP开头)
    len_c = len_c + NFFT;
    len_left = len_left + NFFT; len_right = len_right + NFFT;
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;增加步骤：&quot;&gt;增加步骤：&lt;/h2&gt;
&lt;p&gt;如前面所说的，我们在步骤4和步骤5之间仿真信号xt经过多径衰落信道。听起来一头雾水，说那么多有的没的，其实就是做个卷积啦，就是拿信号xt与信道冲激响应h做卷积运算就OK了(终于有数字信号处理内味儿了~)。如何求信道冲激响应呢？这需要小小推导一下。&lt;/p&gt;
&lt;p&gt;离散多径衰落信道的一个简单数学模型如下：&lt;/p&gt;
&lt;p&gt;\[\begin{align} y(n) &amp;amp; = a_1(n)\cdot x(n-\tau_1(n)) + a_2(n)\cdot x(n-\tau_2(n)) + ... + a_N(n)\cdot x(n-\tau_N(n))\notag\\ &amp;amp; = \sum_{i = 1}^{N} a_i(n)x(n-\tau_i(n))\tag{1}\\ \end{align}\]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(x(n)\)&lt;/span&gt;表示输入信号，&lt;span class=&quot;math inline&quot;&gt;\(a_i(n)\)&lt;/span&gt;表示第i条路径上的衰减系数，&lt;span class=&quot;math inline&quot;&gt;\(\tau_i(n)\)&lt;/span&gt;为第i条路经上的传播时延。&lt;/p&gt;&lt;p&gt;由于表示的信道是线性信道，故可以用在&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;时刻对&lt;span class=&quot;math inline&quot;&gt;\(n-\tau\)&lt;/span&gt;时刻发射的冲激的响应&lt;span class=&quot;math inline&quot;&gt;\(h(\tau,n)\)&lt;/span&gt;来表示。我们已知用&lt;span class=&quot;math inline&quot;&gt;\(h(\tau,n)\)&lt;/span&gt;表示的经过信道的输入\输出为卷积关系：&lt;/p&gt;
&lt;p&gt;\[y(n) =\sum_\tau h(\tau,n) \cdot x(n-\tau) \tag{2} \]&lt;/p&gt;
&lt;p&gt;于是由上述两个公式我们可以推得多径衰落信道冲激响应的数学表达式为：&lt;/p&gt;
&lt;p&gt;\[h(\tau,n) =a_i(n) \cdot \delta(\tau - \tau_i(n)) \tag{3} \]&lt;/p&gt;
&lt;h3 id=&quot;瑞利随机变量产生补充：&quot;&gt;瑞利随机变量产生补充：&lt;/h3&gt;
&lt;p&gt;在一般的衰落环境中，无线衰落信道可以由复高斯随机变量&lt;span class=&quot;math inline&quot;&gt;\(W1 + jW2\)&lt;/span&gt;表示，其中&lt;span class=&quot;math inline&quot;&gt;\(W1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W2\)&lt;/span&gt;都是均值为0，方差为&lt;span class=&quot;math inline&quot;&gt;\(\delta^2\)&lt;/span&gt;的独立同分布(i.i.d.)高斯随机变量。&lt;/p&gt;
&lt;p&gt;如何产生瑞利随机变量呢？首先通过MATLAB内置函数randn()产生均值为0，方差为1的两个i.i.d.高斯随机变量&lt;span class=&quot;math inline&quot;&gt;\(W1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W2\)&lt;/span&gt;。瑞利随机变量X为：&lt;/p&gt;
&lt;p&gt;\[X = \delta \cdot \sqrt{W1^2 + W2^2} \tag{4} \]&lt;/p&gt;
&lt;p&gt;所以一旦通过内置函数randn()生成好了&lt;span class=&quot;math inline&quot;&gt;\(W1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W2\)&lt;/span&gt;，就可以由公式(4)生成平均功率为&lt;span class=&quot;math inline&quot;&gt;\(E(X^2) = 2\delta^2\)&lt;/span&gt;的瑞利随机变量。&lt;/p&gt;
&lt;p&gt;在仿真中我们已经提前给出了瑞利信道平均功率&lt;span class=&quot;math inline&quot;&gt;\(P_h\)&lt;/span&gt;，所以有&lt;span class=&quot;math inline&quot;&gt;\(2\delta^2 = p_h\)&lt;/span&gt;，推出：&lt;/p&gt;
&lt;p&gt;\[\delta = \sqrt{p_h / 2} \tag{5} \]&lt;/p&gt;
&lt;h3 id=&quot;代码：-3&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;A_h = (randn(1,NH) + 1i * randn(1,NH)) .* sqrt(P_h / 2); % 由公式(4)(5)生成瑞利随机变量

h = zeros(1,LH);        % 初始化信道冲激响应模型
h(D_h + 1) = A_h;       % 信道冲激响应(同时体现出衰减系数和信道时延)，公式(3)的代码体现
xt1 = conv(xt,h);       % 卷积，输出通过该信道的信号，公式(2)的代码体现
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤5&quot;&gt;步骤5&amp;gt;&lt;/h2&gt;
&lt;p&gt;经过上一步的处理，现在考虑仿真添加高斯白噪声。由于snr在程序开头就已经确定好了，所以我们要根据snr计算噪声功率(噪声方差)从而添加噪声。&lt;strong&gt;注意由于卷积过后输出信号长度会变长，计算信号功率时记得只取原本的长度。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码：-4&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;xt2 = xt1(1 : NSYM * NFRAME); % 只取卷积过后属于OFDM符号的部分
P_s = xt2 * xt2' ./ NSYM ./ NFRAME; % 计算信号功率

A_n = sqrt(10 .^ (-snr(i) / 10) * P_s / 2); % 计算噪声标准差
yr = xt1 + A_n * (randn(size(xt1)) + 1i * randn(size(xt1))); % 根据噪声标准差添加噪声
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤6、7&quot;&gt;步骤6、7&amp;gt;&lt;/h2&gt;
&lt;p&gt;现在的信号已经是经过多径瑞利衰落并且添加了高斯白噪声的信号，不容易啊！我们的仿真已经完成了一半。接下来的两个步骤与步骤2、3、4是呈镜像，倒着实现一遍就行了。步骤分别如下，注意都是一个符号一个符号处理的，可回去看最开始的符号变化图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对每个OFDM符号去除循环前缀CP，就是把每个符号的前16个采样点去掉就好。&lt;/li&gt;
&lt;li&gt;对每个OFDM符号做FFT，然后将将每个OFDM符号的前一半和后一半交换，记录输出为Y(K)。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码：-5&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;y(1 : NFFT * NFRAME) = 0; % 预分配y数组
Y(1 : NFFT * NFRAME) = 0; % 预分配Y数组

len_a = 1 : NFFT; % 处理的y位置
len_b = 1 : NFFT; % 处理的y位置
len_left = 1 : (NFFT / 2); len_right = (NFFT / 2 + 1) : NFFT; % 每一符号分为左右两边

for frame = 1 : NFRAME % 对于每个OFDM符号先去CP，再FFT再翻转
    y(len_a) = yr(len_b + NCP); % 去掉CP

    Y(len_a) = fft(y(len_a)); % 先fft再翻转
    Y(len_a) = [Y(len_right), Y(len_left)];

    len_a = len_a + NFFT;
    len_b = len_b + NFFT + NCP;
    len_left = len_left + NFFT; len_right = len_right + NFFT;
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤8&quot;&gt;步骤8&amp;gt;&lt;/h2&gt;
&lt;p&gt;16QAM解调，这里是直接用的官方自带函数&lt;/p&gt;
&lt;h3 id=&quot;代码：-6&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Yr = qamdemod(Y * sqrt(10),M,'gray');
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;步骤9&quot;&gt;步骤9&amp;gt;&lt;/h2&gt;
&lt;p&gt;16QAM解调完毕后，其实我们已经可以自己在工作区里对比解调得到的信号Yr和我们的基带数字信号X了。但作为&lt;s&gt;严谨的&lt;/s&gt;打工仔，怎么能不进行误码率分析呢？于是当前步骤我们研究一下怎么分析误码率。其实也很简单，计算一下Yr和X有几比特不相同，再计算一下总共有几比特，把它们相除就得到了我们的比特误码率(BER)。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的一点是，既然是误比特率，就要把16进制的信号转换成2进制，以比特为单位计算错误数&lt;/p&gt;
&lt;h3 id=&quot;代码：-7&quot;&gt;代码：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Neb = sum(sum(de2bi(Yr,K) ~= de2bi(X,K))); % 转为2进制，计算具体有几bit错误
Ntb = NFFT * NFRAME * K;  % 仿真的总比特数
BER = Neb / Ntb;
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;完整代码：&quot;&gt;完整代码：&lt;/h2&gt;
&lt;p&gt;最后贴一个完整代码，代码是参考的《MIMO-OFDM无线通信技术及MATLAB实现》这本书。我是一行一行自己重新实现了一遍并且加上了详细的中文注释，希望能对像我这样的刚入门的萌新有所启发。对了，后面有个与理论值相比较的作图函数有点占位置，我就暂时不放到这篇文章中了XD。&lt;strong&gt;注意在包含多径衰落信道的仿真的时候，如果想要仿真不同信噪比时的误码率，务必要生成一个状态种子，保持衰落信道参数在每一次仿真中都不变。&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Version 3.1
%%% 16QAM调制(官方函数)
%%% IFFT(官方函数)
%%% 添加循环前缀
%%% 经过多径瑞利衰减信道
%%% 添加AWGN
%%% 去除循环前缀
%%% FFT(官方函数)
%%% 16QAM解调(官方函数)
%%% BER分析
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;close all;clc;
%% 基带数字信号及一些初始化
NFRAME = 3;      % 每一帧的OFDM符号数
NFFT = 64;         % 每帧FFT长度
NCP = 16;          % 循环前缀长度
NSYM = NFFT + NCP; % OFDM符号长度
M = 16; K = 4;     % M:调制阶数，K:log2(M)

P_hdB = [0 -8 -17 -21 -25];     % 各信道功率特性(dB)
D_h = [0 3 5 6 8];              % 各信道延迟(采样点)
P_h = 10 .^ (P_hdB / 10);       % 各信道功率特性
NH = length(P_hdB);             % 多径信道个数
LH = D_h(end)+1;                % 信道长度(延迟过后)

EbN0 = 0:1:20;              % 设出比特信噪比(dB)
snr = EbN0 + 10 * log10(K); % 由比特信噪比计算出snr(dB)
BER(1 : length(EbN0)) = 0;  % 初始化误码率

file_name=['OFDM_BER_NCP' num2str(NCP) '.dat'];
fid=fopen(file_name, 'w+');

X = randi([0,15],1,NFFT * NFRAME); % 生成基带数字信号
%%
for i = 1 : length(EbN0) % 对于每一种比特信噪比，计算该通信环境下的误码率
    
    randn('state',0); % 很重要！！保持信道参数在每一次仿真中都不变
    rand('state',0); 
    
    %% 16QAM调制(官方函数)
    X_mod = qammod(X,M,'gray') / (sqrt(10)); % 16QAM调制，格雷码星座图，并归一化
    %% IFFT与循环前缀添加
    x(1 : NFFT * NFRAME) = 0; % 预分配x数组
    xt(1 : (NFFT + NCP) * NFRAME) = 0; % 预分配xt数组

    len_a = 1 : NFFT; % 处理的X位置
    len_b = 1 : (NFFT + NCP); % 处理的X位置(加上CP的长度)
    len_c = 1 : NCP;
    len_left = 1 : (NFFT / 2); len_right = (NFFT / 2 + 1) : NFFT; % 每一符号分为左右两边？？

    for frame = 1 : NFRAME % 对于每个OFDM符号都要翻转和IFFT
        x(len_a) = ifft([X_mod(len_right), X_mod(len_left)]); % 左右翻转再ifft
        xt(len_b) = [x(len_c + NFFT - NCP), x(len_a)]; % 添加CP后的信号数组

        len_a = len_a + NFFT; % 更新找到下一个符号起点位置
        len_b = len_b + NFFT + NCP; % 更新找到下一个符号起点位置(CP开头)
        len_c = len_c + NFFT;
        len_left = len_left + NFFT; len_right = len_right + NFFT;
    end
    %% 经过多径瑞利衰减信道
    A_h = (randn(1,NH) + 1i * randn(1,NH)) .* sqrt(P_h / 2); % 生成瑞利随机变量
    h = zeros(1,LH); % 初始化信道冲激响应模型
    h(D_h + 1) = A_h; % 信道冲激响应(同时体现出衰减系数和信道时延)
    xt1 = conv(xt,h); % 卷积，输出通过该信道的信号
    %% 由snr计算噪声幅度并加噪
    xt2 = xt1(1 : NSYM * NFRAME); % 只取卷积过后属于OFDM符号的部分
    P_s = xt2 * xt2' ./ NSYM ./ NFRAME; % 计算信号功率
    
    A_n = sqrt(10 .^ (-snr(i) / 10) * P_s / 2); % 计算噪声标准差
    yr = xt1 + A_n * (randn(size(xt1)) + 1i * randn(size(xt1))); % 根据噪声标准差添加噪声
    %% 去除循环前缀并且FFT
    y(1 : NFFT * NFRAME) = 0; % 预分配y数组
    Y(1 : NFFT * NFRAME) = 0; % 预分配Y数组

    len_a = 1 : NFFT; % 处理的y位置
    len_b = 1 : NFFT; % 处理的y位置
    len_left = 1 : (NFFT / 2); len_right = (NFFT / 2 + 1) : NFFT; % 每一符号分为左右两边

     H= fft([h zeros(1,NFFT-LH)]); % 信道频率响应
     H_shift(len_a)= [H(len_right) H(len_left)]; 
    
    for frame = 1 : NFRAME % 对于每个OFDM符号先去CP，再FFT再翻转
        y(len_a) = yr(len_b + NCP); % 去掉CP

        Y(len_a) = fft(y(len_a)); % 先fft再翻转
        Y(len_a) = [Y(len_right), Y(len_left)] ./ H_shift; % //

        len_a = len_a + NFFT;
        len_b = len_b + NFFT + NCP;
        len_left = len_left + NFFT; len_right = len_right + NFFT;
    end
    %% 16QAM解调(官方函数)
    Yr = qamdemod(Y * sqrt(10),M,'gray');
    %% BER计算(多次迭代算均值会更准确)
    Neb = sum(sum(de2bi(Yr,K) ~= de2bi(X,K))); % 转为2进制，计算具体有几bit错误
    Ntb = NFFT * NFRAME * K;  %[Ber,Neb,Ntb]=ber(bit_Rx,bit,Nbps); 
    BER(i) = Neb / Ntb;
    fprintf('EbN0 = %3d[dB], BER = %4d / %8d = %11.3e\n', EbN0(i),Neb,Ntb,BER(i))
    fprintf(fid, '%d %11.3e\n', EbN0(i),BER(i));
end
%% BER作图分析
fclose(fid);
disp('Simulation is finished');
plot_ber(file_name,K);
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h2 id=&quot;参考文献：&quot;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;[1] Tse D, Viswanath P. Fundamentals of wireless communication[M]. Cambridge university press, 2005.&lt;/p&gt;&lt;p&gt;[2] Cho Y S, Kim J, Yang W Y, et al. MIMO-OFDM wireless communications with MATLAB[M]. John Wiley &amp;amp; Sons, 2010.&lt;/p&gt;&lt;p&gt;[3] Goldsmith A. Wireless communications[M]. Cambridge university press, 2005.&lt;/p&gt;
</description>
<pubDate>Wed, 22 Jul 2020 16:12:00 +0000</pubDate>
<dc:creator>羽扇纶巾o0</dc:creator>
<og:description>关于OFDM系统的MATLAB仿真实现的第二篇随笔，在第一篇中，我们讨论的是信号经过AWGN信道的情况，只用添加固定噪声功率的高斯白噪声就好了。但在实际无线信道中，信道干扰常常是加性噪声、多径衰落的结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gjblog/p/13363995.html</dc:identifier>
</item>
</channel>
</rss>