<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>死磕 java线程系列之ForkJoinPool深入解析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11824018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11824018.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011138816-1203175669.png&quot; alt=&quot;forkjoinpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（手机横屏看源码更方便）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;注：java源码分析部分如无特殊说明均基于 java8 版本。&lt;/p&gt;
&lt;p&gt;注：本文基于ForkJoinPool分治线程池类。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;随着在硬件上多核处理器的发展和广泛使用，并发编程成为程序员必须掌握的一门技术，在面试中也经常考查面试者并发相关的知识。&lt;/p&gt;
&lt;p&gt;今天，我们就来看一道面试题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何充分利用多核CPU，计算很大数组中所有整数的和？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;剖析&quot;&gt;剖析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;单线程相加？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们最容易想到就是单线程相加，一个for循环搞定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池相加？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果进一步优化，我们会自然而然地想到使用线程池来分段相加，最后再把每个段的结果相加。&lt;/p&gt;
&lt;p&gt;Yes，就是我们今天的主角——ForkJoinPool，但是它要怎么实现呢？似乎没怎么用过哈^^&lt;/p&gt;
&lt;h2 id=&quot;三种实现&quot;&gt;三种实现&lt;/h2&gt;
&lt;p&gt;OK，剖析完了，我们直接来看三种实现，不墨迹，直接上菜。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 计算1亿个整数的和
 */
public class ForkJoinPoolTest01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 构造数据
        int length = 100000000;
        long[] arr = new long[length];
        for (int i = 0; i &amp;lt; length; i++) {
            arr[i] = ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE);
        }
        // 单线程
        singleThreadSum(arr);
        // ThreadPoolExecutor线程池
        multiThreadSum(arr);
        // ForkJoinPool线程池
        forkJoinSum(arr);

    }

    private static void singleThreadSum(long[] arr) {
        long start = System.currentTimeMillis();

        long sum = 0;
        for (int i = 0; i &amp;lt; arr.length; i++) {
            // 模拟耗时，本文由公从号“彤哥读源码”原创
            sum += (arr[i]/3*3/3*3/3*3/3*3/3*3);
        }

        System.out.println(&quot;sum: &quot; + sum);
        System.out.println(&quot;single thread elapse: &quot; + (System.currentTimeMillis() - start));

    }

    private static void multiThreadSum(long[] arr) throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();

        int count = 8;
        ExecutorService threadPool = Executors.newFixedThreadPool(count);
        List&amp;lt;Future&amp;lt;Long&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; count; i++) {
            int num = i;
            // 分段提交任务
            Future&amp;lt;Long&amp;gt; future = threadPool.submit(() -&amp;gt; {
                long sum = 0;
                for (int j = arr.length / count * num; j &amp;lt; (arr.length / count * (num + 1)); j++) {
                    try {
                        // 模拟耗时
                        sum += (arr[j]/3*3/3*3/3*3/3*3/3*3);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                return sum;
            });
            list.add(future);
        }

        // 每个段结果相加
        long sum = 0;
        for (Future&amp;lt;Long&amp;gt; future : list) {
            sum += future.get();
        }

        System.out.println(&quot;sum: &quot; + sum);
        System.out.println(&quot;multi thread elapse: &quot; + (System.currentTimeMillis() - start));
    }

    private static void forkJoinSum(long[] arr) throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
        // 提交任务
        ForkJoinTask&amp;lt;Long&amp;gt; forkJoinTask = forkJoinPool.submit(new SumTask(arr, 0, arr.length));
        // 获取结果
        Long sum = forkJoinTask.get();

        forkJoinPool.shutdown();

        System.out.println(&quot;sum: &quot; + sum);
        System.out.println(&quot;fork join elapse: &quot; + (System.currentTimeMillis() - start));
    }

    private static class SumTask extends RecursiveTask&amp;lt;Long&amp;gt; {
        private long[] arr;
        private int from;
        private int to;

        public SumTask(long[] arr, int from, int to) {
            this.arr = arr;
            this.from = from;
            this.to = to;
        }

        @Override
        protected Long compute() {
            // 小于1000的时候直接相加，可灵活调整
            if (to - from &amp;lt;= 1000) {
                long sum = 0;
                for (int i = from; i &amp;lt; to; i++) {
                    // 模拟耗时
                    sum += (arr[i]/3*3/3*3/3*3/3*3/3*3);
                }
                return sum;
            }

            // 分成两段任务，本文由公从号“彤哥读源码”原创
            int middle = (from + to) / 2;
            SumTask left = new SumTask(arr, from, middle);
            SumTask right = new SumTask(arr, middle, to);

            // 提交左边的任务
            left.fork();
            // 右边的任务直接利用当前线程计算，节约开销
            Long rightResult = right.compute();
            // 等待左边计算完毕
            Long leftResult = left.join();
            // 返回结果
            return leftResult + rightResult;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;彤哥偷偷地告诉你，实际上计算1亿个整数相加，单线程是最快的，我的电脑大概是100ms左右，使用线程池反而会变慢。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所以，为了演示ForkJoinPool的牛逼之处，我把每个数都&lt;code&gt;/3*3/3*3/3*3/3*3/3*3&lt;/code&gt;了一顿操作，用来模拟计算耗时。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;来看结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sum: 107352457433800662
single thread elapse: 789
sum: 107352457433800662
multi thread elapse: 228
sum: 107352457433800662
fork join elapse: 189&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，ForkJoinPool相对普通线程池还是有很大提升的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：普通线程池能否实现ForkJoinPool这种计算方式呢，即大任务拆中任务，中任务拆小任务，最后再汇总？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011139072-811331392.png&quot; alt=&quot;forkjoinpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以试试看(-᷅_-᷄)&lt;/p&gt;
&lt;p&gt;OK，下面我们正式进入ForkJoinPool的解析。&lt;/p&gt;
&lt;h2 id=&quot;分治法&quot;&gt;分治法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基本思想&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把一个规模大的问题划分为规模较小的子问题，然后分而治之，最后合并子问题的解得到原问题的解。&lt;/p&gt;
&lt;p&gt;（1）分割原问题：&lt;/p&gt;
&lt;p&gt;（2）求解子问题：&lt;/p&gt;
&lt;p&gt;（3）合并子问题的解为原问题的解。&lt;/p&gt;
&lt;p&gt;在分治法中，子问题一般是相互独立的，因此，经常通过递归调用算法来求解子问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;典型应用场景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）二分搜索&lt;/p&gt;
&lt;p&gt;（2）大整数乘法&lt;/p&gt;
&lt;p&gt;（3）Strassen矩阵乘法&lt;/p&gt;
&lt;p&gt;（4）棋盘覆盖&lt;/p&gt;
&lt;p&gt;（5）归并排序&lt;/p&gt;
&lt;p&gt;（6）快速排序&lt;/p&gt;
&lt;p&gt;（7）线性时间选择&lt;/p&gt;
&lt;p&gt;（8）汉诺塔&lt;/p&gt;
&lt;h2 id=&quot;forkjoinpool继承体系&quot;&gt;ForkJoinPool继承体系&lt;/h2&gt;
&lt;p&gt;ForkJoinPool是 java 7 中新增的线程池类，它的继承体系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011139355-1945861823.png&quot; alt=&quot;forkjoinpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ForkJoinPool和ThreadPoolExecutor都是继承自AbstractExecutorService抽象类，所以它和ThreadPoolExecutor的使用几乎没有多少区别，除了任务变成了ForkJoinTask以外。&lt;/p&gt;
&lt;p&gt;这里又运用到了一种很重要的设计原则——开闭原则——对修改关闭，对扩展开放。&lt;/p&gt;
&lt;p&gt;可见整个线程池体系一开始的接口设计就很好，新增一个线程池类，不会对原有的代码造成干扰，还能利用原有的特性。&lt;/p&gt;
&lt;h2 id=&quot;forkjointask&quot;&gt;ForkJoinTask&lt;/h2&gt;
&lt;h3 id=&quot;两个主要方法&quot;&gt;两个主要方法&lt;/h3&gt;
&lt;p&gt;fork()方法类似于线程的Thread.start()方法，但是它不是真的启动一个线程，而是将任务放入到工作队列中。&lt;/p&gt;
&lt;p&gt;join()方法类似于线程的Thread.join()方法，但是它不是简单地阻塞线程，而是利用工作线程运行其它任务。当一个工作线程中调用了join()方法，它将处理其它任务，直到注意到目标子任务已经完成了。&lt;/p&gt;
&lt;h3 id=&quot;三个子类&quot;&gt;三个子类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;RecursiveAction&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无返回值任务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RecursiveTask&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有返回值任务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CountedCompleter&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无返回值任务，完成任务后可以触发回调。&lt;/p&gt;
&lt;h2 id=&quot;forkjoinpool内部原理&quot;&gt;ForkJoinPool内部原理&lt;/h2&gt;
&lt;p&gt;ForkJoinPool内部使用的是“工作窃取”算法实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011139581-1366779920.png&quot; alt=&quot;forkjoinpool&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）每个工作线程都有自己的工作队列WorkQueue；&lt;/p&gt;
&lt;p&gt;（2）这是一个双端队列，它是线程私有的；&lt;/p&gt;
&lt;p&gt;（3）ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头，工作线程将以LIFO的顺序来处理工作队列中的任务；&lt;/p&gt;
&lt;p&gt;（4）为了最大化地利用CPU，空闲的线程将从其它线程的队列中“窃取”任务来执行；&lt;/p&gt;
&lt;p&gt;（5）从工作队列的尾部窃取任务，以减少竞争；&lt;/p&gt;
&lt;p&gt;（6）双端队列的操作：push()/pop()仅在其所有者工作线程中调用，poll()是由其它线程窃取任务时调用的；&lt;/p&gt;
&lt;p&gt;（7）当只剩下最后一个任务时，还是会存在竞争，是通过CAS来实现的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011140070-1461076347.png&quot; alt=&quot;forkjoinpool&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;forkjoinpool最佳实践&quot;&gt;ForkJoinPool最佳实践&lt;/h2&gt;
&lt;p&gt;（1）最适合的是计算密集型任务，本文由公从号“彤哥读源码”原创；&lt;/p&gt;
&lt;p&gt;（2）在需要阻塞工作线程时，可以使用ManagedBlocker；&lt;/p&gt;
&lt;p&gt;（3）不应该在RecursiveTask的内部使用ForkJoinPool.invoke()/invokeAll()；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ForkJoinPool特别适合于“分而治之”算法的实现；&lt;/p&gt;
&lt;p&gt;（2）ForkJoinPool和ThreadPoolExecutor是互补的，不是谁替代谁的关系，二者适用的场景不同；&lt;/p&gt;
&lt;p&gt;（3）ForkJoinTask有两个核心方法——fork()和join()，有三个重要子类——RecursiveAction、RecursiveTask和CountedCompleter；&lt;/p&gt;
&lt;p&gt;（4）ForkjoinPool内部基于“工作窃取”算法实现；&lt;/p&gt;
&lt;p&gt;（5）每个线程有自己的工作队列，它是一个双端队列，自己从队列头存取任务，其它线程从尾部窃取任务；&lt;/p&gt;
&lt;p&gt;（6）ForkJoinPool最适合于计算密集型任务，但也可以使用ManagedBlocker以便用于阻塞型任务；&lt;/p&gt;
&lt;p&gt;（7）RecursiveTask内部可以少调用一次fork()，利用当前线程处理，这是一种技巧；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ManagedBlocker怎么使用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：ManagedBlocker相当于明确告诉ForkJoinPool框架要阻塞了，ForkJoinPool就会启另一个线程来运行任务，以最大化地利用CPU。&lt;/p&gt;
&lt;p&gt;请看下面的例子，自己琢磨哈^^。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 斐波那契数列
 * 一个数是它前面两个数之和
 * 1,1,2,3,5,8,13,21
 */
public class Fibonacci {

    public static void main(String[] args) {
        long time = System.currentTimeMillis();
        Fibonacci fib = new Fibonacci();
        int result = fib.f(1_000).bitCount();
        time = System.currentTimeMillis() - time;
        System.out.println(&quot;result，本文由公从号“彤哥读源码”原创 = &quot; + result);
        System.out.println(&quot;test1_000() time = &quot; + time);
    }

    public BigInteger f(int n) {
        Map&amp;lt;Integer, BigInteger&amp;gt; cache = new ConcurrentHashMap&amp;lt;&amp;gt;();
        cache.put(0, BigInteger.ZERO);
        cache.put(1, BigInteger.ONE);
        return f(n, cache);
    }

    private final BigInteger RESERVED = BigInteger.valueOf(-1000);

    public BigInteger f(int n, Map&amp;lt;Integer, BigInteger&amp;gt; cache) {
        BigInteger result = cache.putIfAbsent(n, RESERVED);
        if (result == null) {

            int half = (n + 1) / 2;

            RecursiveTask&amp;lt;BigInteger&amp;gt; f0_task = new RecursiveTask&amp;lt;BigInteger&amp;gt;() {
                @Override
                protected BigInteger compute() {
                    return f(half - 1, cache);
                }
            };
            f0_task.fork();

            BigInteger f1 = f(half, cache);
            BigInteger f0 = f0_task.join();

            long time = n &amp;gt; 10_000 ? System.currentTimeMillis() : 0;
            try {

                if (n % 2 == 1) {
                    result = f0.multiply(f0).add(f1.multiply(f1));
                } else {
                    result = f0.shiftLeft(1).add(f1).multiply(f1);
                }
                synchronized (RESERVED) {
                    cache.put(n, result);
                    RESERVED.notifyAll();
                }
            } finally {
                time = n &amp;gt; 10_000 ? System.currentTimeMillis() - time : 0;
                if (time &amp;gt; 50)
                    System.out.printf(&quot;f(%d) took %d%n&quot;, n, time);
            }
        } else if (result == RESERVED) {
            try {
                ReservedFibonacciBlocker blocker = new ReservedFibonacciBlocker(n, cache);
                ForkJoinPool.managedBlock(blocker);
                result = blocker.result;
            } catch (InterruptedException e) {
                throw new CancellationException(&quot;interrupted&quot;);
            }

        }
        return result;
        // return f(n - 1).add(f(n - 2));
    }

    private class ReservedFibonacciBlocker implements ForkJoinPool.ManagedBlocker {
        private BigInteger result;
        private final int n;
        private final Map&amp;lt;Integer, BigInteger&amp;gt; cache;

        public ReservedFibonacciBlocker(int n, Map&amp;lt;Integer, BigInteger&amp;gt; cache) {
            this.n = n;
            this.cache = cache;
        }

        @Override
        public boolean block() throws InterruptedException {
            synchronized (RESERVED) {
                while (!isReleasable()) {
                    RESERVED.wait();
                }
            }
            return true;
        }

        @Override
        public boolean isReleasable() {
            return (result = cache.get(n)) != RESERVED;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201911/1648938-20191109011140377-1452016528.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 17:12:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>（手机横屏看源码更方便） 注：java源码分析部分如无特殊说明均基于 java8 版本。 注：本文基于ForkJoinPool分治线程池类。 简介 随着在硬件上多核处理器的发展和广泛使用，并发编程成为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11824018.html</dc:identifier>
</item>
<item>
<title>Alibaba Java Coding Guidelines，以后我的Java代码规范，就靠它了 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/11823957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/11823957.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       对于Java代码规范，业界有统一的标准，不少公司对此都有一定的要求。但是即便如此，庞大的Java使用者由于经验很水平的限制，未必有规范编码的意识，而且即便经验丰富的老Java程序员也无法做到时刻将规范牢记于心。所以对于代码规范扫描工具，一经问世就广受青睐，阿里巴巴出品的Alibaba Java Coding Guidelines（阿里巴巴Java代码规约扫描，以下简称为AJCG）插件便是其中之一。与很多其它流行的同类工具（如FindBugs，Lint等）相比，它更专注于Java代码规范，而且默认采用中文，对于英文没那么好的开发者而言，这无疑是一种福利。本文将结合Android Studio（以下简称AS），介绍一下该插件的使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、AJCG简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       为了让开发者更加方便、并且达到快速规范代码格式的目的并实行起来，阿里巴巴基于《阿里巴巴Java开发规约》手册内容，研发了一套自动化的IDE检测插件，它就是Alibaba Java Coding Guidelines 插件。2017年10月14日杭州云栖大会，AJCG全球首发仪式正式启动，规范正式以插件形式公开走向业界，引领Java语言的规范之路。该插件在扫描代码后，将不符合规约的代码按Blocker/Critical/Major三个等级显示出来，并且大部分可以自动修复。它还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、在AS中安装AJCG插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       与其它的插件一样，AJCG插件也提供了直接在AS的仓库中安装和手动离线安装两种方式。&lt;/p&gt;
&lt;p&gt;  1、直接从AS的插件库下载安装&lt;/p&gt;
&lt;p&gt;       至于如何在AS插件库中安装插件，在我的另外一篇介绍FindBugs的文章【&lt;a href=&quot;https://www.cnblogs.com/andy-songwei/p/11820564.html&quot;&gt;https://www.cnblogs.com/andy-songwei/p/11820564.html&lt;/a&gt;】中已经介绍过了，这里就不赘述了。简单说一下就是&lt;/p&gt;
&lt;p&gt;  File &amp;gt; Settings &amp;gt; Plugins &amp;gt; Browse repositories 搜索 “Alibaba Java Coding Guidelines”，按照提示进行安装，然后重启即可。&lt;/p&gt;
&lt;p&gt;  2、手动下载并从磁盘安装&lt;/p&gt;
&lt;p&gt;       请从如下地址获取离线安装包：&lt;/p&gt;
&lt;p&gt;       链接：https://pan.baidu.com/s/19MPJ-CVfZvf4K_PVXY8g6Q&lt;/p&gt;
&lt;p&gt;       提取码：it10 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、使用AJCG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1、启动AJCG扫描 &lt;/p&gt;
&lt;p&gt;       大致可以通过如下两种方式启动AJCG进行扫描（好像还有别的启动方式，咱们知道这两种方式就够了）：&lt;/p&gt;
&lt;p&gt;    （1）可以Tools &amp;gt; 阿里编码规约 &amp;gt; 编码规约扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108194846875-682000196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）在编辑界面或者AS左边的项目区域点击右键，在右键菜单中选择“编码规约扫描”即可。  &lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108195014738-137534239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、菜单功能&lt;/p&gt;
&lt;p&gt;       第一种启动方式比第二张多一项功能，这三项列表功能如下：&lt;/p&gt;
&lt;p&gt;    （1）编码规约扫描：开始扫描代码。&lt;/p&gt;
&lt;p&gt;    （2）打开/关闭实时检测功能：实时检测代码，顾名思义，对代码进行实时检测。一般机器性能比较好的话可以开启这项功能，如果已经开启，这里会显示“关闭实时检测功能”。&lt;/p&gt;
&lt;p&gt;    （3）切换语言至英文：中英文切换。&lt;/p&gt;
&lt;p&gt;  3、执行结果 &lt;/p&gt;
&lt;p&gt;       扫描完成后显示结果如下（如果当前鼠标点击的是最终项，右边区域显示的是其它的内容，后面会再讲到）： &lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108201949710-1557406546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  4、指定区域搜索同一类问题&lt;/p&gt;
&lt;p&gt;       当点击③处的按钮时，会弹出如下按钮：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108201825303-833378032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里选择扫描区域，来扫描鼠标选中的同类问题。如果按照默认选择，那么运行后的结果就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108202709816-717283565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里我们可以看到，显示了整个Project中的所有该类的问题。&lt;/p&gt;
&lt;p&gt;  5、预览具体的不规范代码&lt;/p&gt;
&lt;p&gt;       在第3点的执行结果中，如果点击的是最终的问题点或者问题所在的类文件，那显示的就是如下界面，预览该处不规范的代码。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108204017201-1676396258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、工具栏功能介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       工具栏的这些功能经常会用到，这里简单对每一个功能简单介绍一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108205331396-1905428578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  （1）Rerun Inspection： 重新运行一次扫描&lt;/p&gt;
&lt;p&gt;  （2）Close：关闭真个AJCG面板&lt;/p&gt;
&lt;p&gt;  （3）Expand All：展开结果的树状结构，整个结果是树状结构的。&lt;/p&gt;
&lt;p&gt;  （4）Collapse All：收起结果的树状结构&lt;/p&gt;
&lt;p&gt;  （5）Go Pre Problem：选择上一个问题&lt;/p&gt;
&lt;p&gt;  （6）Go Next Problem：选择下一个问题&lt;/p&gt;
&lt;p&gt;  （7）Help：帮助&lt;/p&gt;
&lt;p&gt;  （8）Group by Serverity：（不知道如何描述）&lt;/p&gt;
&lt;p&gt;  （9）Group by derectory：按目录分组/按类名分组间切换&lt;/p&gt;
&lt;p&gt;  （10）Filter resoled items：过滤掉已经解决的项&lt;/p&gt;
&lt;p&gt;  （11）Autoscroll to Source：自动滚动到源码&lt;/p&gt;
&lt;p&gt;  （12）Export：导出，可以导出为XML和HTML两种格式&lt;/p&gt;
&lt;p&gt;  （13）Edit Settings：编辑设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、扫描结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       该部分区域显示了执行结果，由于是设置的中文版，所以这里显示的都是中文，这看起来非常爽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191108193729572-1469463005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们可以看到Blocker（阻挡者）、Critical（严重问题）、Major（主要的）三个大类，他们表示的是问题的严重程度，严重程度由高到低为：Blocker &amp;gt; Critical &amp;gt; Major。至于每一类中都会包含什么样的问题，图中的中文已经说明了一切，这里就不赘述了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       这提供一份《阿里巴巴Java开发手册（纪念版）》电子文档&lt;/p&gt;
&lt;p&gt;       链接：&lt;a href=&quot;https://pan.baidu.com/s/1z2u1ITJGJvgsJqrgq_AYwQ&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1z2u1ITJGJvgsJqrgq_AYwQ&lt;/a&gt;&lt;a href=&quot;https://pan.baidu.com/s/1DLvLGBmow6MulW7EFOk6hQ%20&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       提取码：v9ja&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本文只介绍了AJCG常见的一些使用方法，一定还有很多很牛的功能，希望读者们多多探索，多多交流，共同进步，谢谢！&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 16:15:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>为了让开发者更加方便、并且达到快速规范代码格式的目的并实行起来，阿里巴巴基于《阿里巴巴Java开发规约》手册内容，研发了一套自动化的IDE检测插件，它就是Alibaba Java Coding Gui</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/11823957.html</dc:identifier>
</item>
<item>
<title>DP动态规划学习笔记 - LightHouseOfficial</title>
<link>http://www.cnblogs.com/light-house/p/11817439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/light-house/p/11817439.html</guid>
<description>&lt;p&gt;&lt;span&gt;作为考察范围最广，考察次数最多的算法，当然要开一篇博客来复习啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子曰：温故而知新，可以为师矣&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我复习DP时有一些自己对DP的理解，也就分享出来吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——正片开始——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态规划算法，即Dynamic Programming(以下简称为DP)，是解决多阶段决策过程最优化问题的高效数学方法。自从1999年IOI出了一道名为&quot;数字三角形&quot;的题后，DP题就在OI竞赛中广为流传。而上面提到的&quot;数字三角形&quot;，现在就是DP的一道入门题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递推和DP的关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人会混淆递推和DP，递推只是DP的一种实现方式。我们提到的DP是一种高效的算法，实现方式主要是递推和记忆化搜索，但是DP和递推很像的一点就是，它们都是利用子问题来搞定原问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我举一个例子，斐波那契数列，相信大家都不陌生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道Fib的递推式：F(x) = F(x-1) + F(x-2)，可以通过第x-1项和第x-2项推出第x项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们从DP的角度来看Fib，我们可以把求第x项看成原问题，然后我们把求第x-1项和求第x-2项看成子问题，我们就把&quot;求第x项&quot;这个原问题划分成了&quot;求第x-1项&quot;和&quot;求第x-2项&quot;两个子问题，然后继续划分子问题并求解，最后利用所有的子问题得到原问题的解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多DP的入门博客都会仔细详解DP的三个基本性质，解题步骤和使用DP的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不明白这些的，我从@mengmengdastyle的blog中摘取了这一段给你们看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2） 动态规划包含三个重要的概念：&lt;br/&gt;- 最优子结构&lt;br/&gt;- 边界&lt;br/&gt;- 状态转移方程&lt;br/&gt;（3）解题的一般步骤是：&lt;br/&gt;1. 找出最优解的性质，刻画其结构特征和最优子结构特征；&lt;br/&gt;2. 递归地定义最优值，刻画原问题解与子问题解间的关系；&lt;br/&gt;3. 以自底向上的方式计算出各个子问题、原问题的最优值，并避免子问题的重复计算；&lt;br/&gt;4. 根据计算最优值时得到的信息，构造最优解。&lt;br/&gt;（4）使用动态规划特征：&lt;br/&gt;1. 求一个问题的最优解&lt;br/&gt;2. 大问题可以分解为子问题，子问题还有重叠的更小的子问题&lt;br/&gt;3. 整体问题最优解取决于子问题的最优解（状态转移方程）&lt;br/&gt;4. 从上往下分析问题，从下往上解决问题&lt;br/&gt;5. 讨论底层的边界问题&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文注重思路和解题技巧，对于基本知识不多赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先来分析一道题，通过这道题让你明白DP是用来干什么的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给你一个高度为x(1&amp;lt;=x&amp;lt;=2x10^5)的楼梯，每次可以向上走1级或者2级，问你走到顶一共有多少种走法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入样例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10&lt;br/&gt;输出样例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;89&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来分析一下这道题，假如x=1，答案你可以很轻松的得到，等于1，如果x=2呢？答案是2，也很容易得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我们的x是可以很大的，我们不可能对于每个x都手算出结果存下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我们考虑分解问题，将原问题分解成若干子问题，然后对于每个子问题也分解下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;“大事化小，小事化了。”&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们怎么分解这个问题呢？如果我们要求走3级的走法数，首先我们看看能否用走1级和走2级的方案数凑出走3级的方案数。于是，我们发现，确实可以。我们走3级的走法数就是走1级的走法数+走2级的走法数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此这个问题得解了：走x级的走法数=走x-1级的走法数+走x-2级的走法数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这题就是求一个斐波那契数列，我们利用递推得到答案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;介绍更困难的题目前，我打算讲一讲DP本身。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在OI竞赛中，我们使用计算机计算答案。但是我们用计算机只能记录下一些状态，我们需要利用记录下来的状态去求解，于是我们要尝试把问题定义成一个状态。很多人在讲DP的时候，说需要“递归”的定义状态。对于这种说法，我们一般用两个字来形容：扯淡。我们确实需要定义状态，但是，每个问题都可以被定义成状态，我们要做的首先就是思考怎么去定义它，一般来说就是思考我们存什么变量，算什么变量，用这些变量怎么得出解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们一般把问题划分成不同阶段，每个阶段有不同状态。但是，我们并不需要算出所有状态存下来，我们每一步只需要存最优的答案就行了，这就是DP用来求最优解的原因。既然问题都是可以划分成阶段和状态的，那么，某一阶段的最优解就一定可以通过之前阶段的最优解得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，如果我们仅通过前一个阶段的答案算不出当前阶段的答案呢？如果我们需要前面所有阶段的答案呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在问题的每个阶段，一个状态都可以转移到下一个阶段的多个状态，那我们计算解的时间复杂度就是指数级别的，也就是说我们并不能用DP来解决这个问题。这种，前面的决策会影响后面的情况，就被称为&lt;strong&gt;有后效性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得DP的三个要素之一吗？无后效性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记得搜索的入门题吗？01迷宫。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们要找到从起点到终点的最短路径，我们可以只保存当前阶段的状态吗？显然不行。想想我们当时做的时候保存的状态？{x,y,step}，以及一个vis数组。由于题目要求我们求的路径最短，我们必须知道之前走过的所有位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使我们当前在同一个位置，我们之前走的路线不同，也是会影响到我们后面选择走的路径的，&lt;strong&gt;因为我们不会走已经标记vis过的格子了&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们必须保存每个阶段经历过的所有状态才能得到下一个阶段的解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是有后效性的问题的一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们需要记录之前所有的状态，我们的复杂度就是指数级的，但是DP呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们并不需要记录之前的所有状态，我们当前的决策并不受之前状态的组合的影响了，就可以多项式时间内出答案了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用一段@X丶dalao的blog：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个阶段只有一个状态-&amp;gt;递推；&lt;br/&gt;每个阶段的最优状态都是由上一个阶段的最优状态得到的-&amp;gt;贪心；&lt;br/&gt;每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&amp;gt;搜索；&lt;br/&gt;每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&amp;gt;动态规划。&lt;/p&gt;
&lt;p&gt;每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到&lt;br/&gt;这个性质叫做最优子结构；&lt;/p&gt;
&lt;p&gt;而不管之前这个状态是如何得到的&lt;br/&gt;这个性质叫做无后效性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，现在我们讲题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上各种什么，让你彻底学懂DP啊，特别的DP入门教程啊，其实都不如自己多写点DP题来的实在...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我将从几道例题开始，从易到难慢慢打开DP的大门。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 石子合并：&lt;br/&gt;有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们来划分阶段，我们有一坨长度为n的石子堆，我们每次合并后，石子堆的数量都会减少，那我们就从这里切入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直观地想，我们可能会这样划分阶段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们要合并石子，肯定就要找一个地方，把它两边的石子合并起来。              &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设f[x]表示合并了x次的最小总代价。立刻就能发现不对...我们选定不同的地方来合并，每次的答案时不同的，也就是说f[x]的值不定，这时肯定是得不到最优解的。有人可能会有疑问，f[x]不是定义成了最小定义的代价了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那你回去仔细看看上面说的关于状态定义的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们需要重新定义状态，这里给出一种划分方法，我们用f[i,j]表示合并区间左端点为i，右端点为j的这段区间合并成一堆石子的最优值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么这么定义呢？这就涉及到一类问题：&lt;strong&gt;区间DP&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于区间DP，我们利用区间长度作为阶段，用左右端点表示状态。这种定义方法可以解决大部分的区间DP问题了，但是遇到一些难题，我们还需要加维度来解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们上面提到过，要合并两堆石子，我们就要循环一个分界点，我们定义一个分界点k，枚举这个分界点找最优解。这个过程我们称之为——决策！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们利用决策转移状态（用子问题求解出原问题）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面这个式子就是我们常听到的“状态转移方程”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f[i,j] = f[i][k] + f[k+1][j] + cost(i,j)，其中cost(i,j)表示合并两堆石子的代价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们思考一下状态的可选范围，i表示左端点，j表示右端点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i: 1~n-len+1，j：i+len-1，这样我们就保证了既不超出边界，又能保证我们的阶段是区间长度len。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阶段就是len：2~n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种做法时间复杂度是O(n^4)，我们发现没法简化定义了，于是我们O(n^3)预处理出cost(i,j)，再O(n^3)DP得出答案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;伪代码大概是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(i,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,n)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(j,i,n)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(k,i,j)
            cost(i,j)&lt;/span&gt;+=&lt;span&gt;w[k]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(len,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,n)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i,&lt;span&gt;1&lt;/span&gt;,n-len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        j&lt;/span&gt;=i+len-&lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(k,i,j)
            f[i][j]&lt;/span&gt;=min(f[i][j],f[i][k]+f[k+&lt;span&gt;1&lt;/span&gt;][r]+cost(i,j))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果还是不太理解的可以仔细去看看这道题的题解，博主这一篇博客只打算讲思路，不仔细讲例题。&lt;/span&gt;&lt;span&gt;接下来我们看这样一道题：&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1352&quot; target=&quot;_blank&quot;&gt;没有上司的舞会&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;题目描述已经说了，它们的关系像一棵有根树，那我们就在树上DP。这种依赖树形结构的DP我们也把它们划分为一类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;树形DP&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候可能就有人想问了，既然也是一类DP，它的阶段划分是不是也和区间DP一样，有套路呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没错。树形DP依赖树形结构，那么我们很容易想到树的性质，父亲和子节点的关系一一对应，我们可以通过子节点的信息计算父节点的信息。也就是，这类题已经帮我们划分好阶段了，节点从深到浅的顺序就是我们的阶段，我们用一个从上到下的遍历来进行DP，对于每个子节点x先往下递归在它的每个子节点进行DP，再在回溯的时候从子节点向节点x转移状态。这样我们需要做的就是定义状态了。定义状态也很容易，我们一般选择每个节点的编号x作为状态的第一维，再根据不同题目的需求加维进行DP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到这道题目上来，我们根据上面的内容，先定义第一维为节点编号，然后我们会发现，一个节点的信息值只与它参不参加舞会有关系，于是我们定义f[x][0/1]为它参加/不参加时的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;题目也明确说了，如果一个人的直接上司参加了舞会他就不会参加，那我们就可以轻松的得到状态转移方程：&lt;br/&gt;f[x][0]+=max(f[y][0],f[y][1])，f[x][1]+=f[y][0]，y∈son(x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后递归求解就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写到这里我发现我实在是讲不完所有的DP类型了，于是我们后面会跳过几种DP分为下一篇来谈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放到下一篇讲的DP（状压DP，计数DP，数位DP，概率与期望DP，所有优化方法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们就回过来讲DP中一类很特殊的问题：背包问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是背包问题？我们先从基础的0/1背包开始，逐步分析背包问题的模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给你n个物品，其中，第i个物品的体积为wi，价值为vi。再给你一个容积为m的背包，现在让你在不超过容积的范围内选出一些物品装入背包让价值尽可能大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们可能会想到用贪心来解决这道题目，但是贪心很显然是错误的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们贪心的策略很显然是每次选择“性价比”最高的物品，也就是wi/vi最大的物品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，对于0/1背包问题，贪心选择之所以不能得到最优解是因为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;明白这一点后，我们考虑用DP求解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何划分阶段呢？很显然，我们依次考虑是否选择每件物品，然后我们还需要知道现在背包用了多少容积。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们就设f[i][j]为前i件物品中装了j体积的物品的最大价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们用另外一种思路来想转移方程式，我们不分解这个问题，我们直接考虑状态怎么推进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们前i件物品中装j体积的最大价值很显然是由前i-1件物品装了某体积的物品，再考虑选不选择当前这件物品转移过来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们很容易就可以得到如下的转移方程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f[i][j]=max(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　f[i-1][j],//选这件物品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if(j&amp;gt;=wi)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　f[i-1][j-wi]+v[i] //不选这件物品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　f[i-1][j] //选不了这件物品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阶段：前i件物品(i∈[1,n])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;状态：当前的容积(j∈[m,0])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样我们的空间复杂度是O(n^2)的，考虑优化空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现第一位是可以省略的（我们按顺序依次考虑每个物品即可）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是...就变成了这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)

　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=m;j&amp;gt;=w[i];j--&lt;span&gt;)

　　　　f[j]&lt;/span&gt;=max(f[j],f[j-w[i]]+v[i]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;我们每个物品只能放一次，而我们的f[j]要通过f[j-w[i]]计算得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果，我们使用正序循环，从w[i]到m，那么我们可能出现这种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f[j]被f[j-wi]+vi更新过，当我们j增加到j+w[i]时，f[j+w[i]]又有可能被f[j]+vi更新，而同时它们都处于阶段i，也就是说，我们在一个阶段内的两个状态间发生了转移，相当于第i个物品被使用了多次（如果后面又更新了），不符合0/1背包的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们要倒序循环，这样我们的j会一直缩小，不会出现“同阶段间转移”的情况，所以，问题至此得解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们要讲完全背包，思考这样一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给你n种物品，每种物品有无数个，其中，第i种物品的体积为wi，价值为vi。再给你一个容积为m的背包，现在让你在不超过容积的范围内选出一些物品装入背包让价值尽可能大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意它和0/1背包问题的区别，0/1背包每种物品只有一个，而完全背包有无数个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;细心的读者可能发现了，我们上面说，当我们正序循环时，相当于一个物品被使用了多次，符合完全背包的要求...那我们只要正序循环，是不是就？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是太想当然了啊，当然没错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们讲讲&lt;strong&gt;多重背包&lt;/strong&gt;吧，还是一个类似的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给你n种物品，每种物品有ci个，其中，第i种物品的体积为wi，价值为vi。再给你一个容积为m的背包，现在让你在不超过&lt;/span&gt;&lt;span&gt;容积的范围内选出一些物品装入背包让价值尽可能大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每种物品从无数个变成了ci个，也就是有了限制，怎么做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;水题啊！我们把每种物品看成ci个不同的物品不就好了？然后跑一遍0/1背包，问题不久得解了咩？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天真啊，这样的时间复杂度可是 $O(m*\sum\limits_{i=1}^nc_i)$ 的啊&lt;span&gt;（第一次用Latex有点不习惯）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那咋整啊？我们又延伸出了：&lt;strong&gt;单调队列优化DP。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DP的种类真是数不胜数...不过优化DP是下一篇的内容，这里不再叙述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不想用单调队列优化DP来解决多重背包的话，我们可以&lt;strong&gt;二进制拆分多重背包。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们大概是这样一个拆分思路，把每一种物品拆成log个不同物品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大概是这样拆：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; cnt=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,c;
    cin&lt;/span&gt;&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=c;j&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
        v[&lt;/span&gt;++cnt]=j*a,w[cnt]=j*&lt;span&gt;b;
        c&lt;/span&gt;-=&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;剩下拆不掉的部分，直接当新物品&lt;/span&gt;
        v[++cnt]=c*a,w[cnt]=c*&lt;span&gt;b;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;思路还是很简单的，但是很巧妙。拆完就是一个0/1背包了，很水。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我佛了...还有个&lt;strong&gt;分组背包&lt;/strong&gt;没讲...这篇博客都写了2天了QuQ，DP真难讲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;限于篇幅和时间，树上的背包问题我留到下一篇的开头...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出分组背包的模型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给你n组物品，每组物品有ci个，其中，第i组第j个物品的体积为wi,j，价值为vi,j。再给你一个容积为m的背包，现在让你在不超过容积的范围内每组至多选一个物品装入背包让价值尽可能大。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分组背包是一类树形DP的很重要的组成Part，所以熟练掌握它还是很重要滴。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题我们怎么做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑用线性DP解决（...雾），我们要满足“每组至多选择一个物品”的要求，就可以利用“阶段”线性增长的特性，把物品组数作为阶段，只要选了一个第i组的物品，就转移状态到下一个阶段就好了^-^。然后仿照0/1背包的做法，设f[i][j]表示从前i组中选出总体积为j的物品放入了背包，物品的最大价值和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f[i,j]=max{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　f[i-1,j],//不选第i组的物品喵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　max{f[i-1,j-wik]+vik},(1&amp;lt;=k&amp;lt;=ci)//选第i组的某个物品k喵-&amp;gt;是做决策哒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面那东西不是我敲的...&lt;em&gt;&lt;span&gt;但是她不让我删掉&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们还是可以省略掉第一维，&lt;span&gt;&lt;em&gt;别问，问就是这是背包问题&lt;/em&gt;&lt;/span&gt;。为什么呢？因为我们可以用j的倒序循环来控制阶段i的状态只能由阶段i-1转移得到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;至此问题得解，给出代码：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=m;j&amp;gt;=&lt;span&gt;0&lt;/span&gt;;j--&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k=&lt;span&gt;1&lt;/span&gt;;k&amp;lt;=c[i];k++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j&amp;gt;=&lt;span&gt;w[i][k])
                f[j]&lt;/span&gt;=max(f[j],f[j-w[i][k]+v[i][k]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;总结一下，这篇博客我们接触并初步学习了动态规划算法，并对DP的本质有了一定的了解，明白了设计DP算法求解问题的一般思路。没错，设计DP算法，DP算法迷人的地方就在于，对于每道DP题，都需要自己去设计一个合理且高效的DP算法去解决问题，这也是DP难的地方。除此之外，我们还学习了几种常见的DP模型，加深了对“阶段，状态，决策”的理解。DP题要难可以难上天，要简单可以一眼秒，但是本质上看它们都是考察同一个东西：脑子。DP题其实不难&lt;span&gt;&lt;em&gt;个鬼&lt;/em&gt;&lt;/span&gt;，只要你理解了DP的基本实现方法，稍加思考，把问题转化一下，就很容易想到如何用DP去求解答案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于这种依靠思维的题目，其实不用写很多题。虽然刷题是必不可缺的，但是对于写过的每道DP题，都确保自己理解了思路，明白了为什么这样设计DP，就可以总结出一套自己应对DP题的方法和技巧，每个人写DP题的方法都是不尽相同的。希望通过这篇博客，能让你喜欢上动态规划算法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更深层次难度更高的DP，我会在下一篇博客里讨论。不过就连这篇博客我都写了整整两天，下一篇可能我要写挺久了。&lt;/span&gt;&lt;span&gt;&lt;span&gt;除非我够肝&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你们的点赞就是我最大的动力（其实我就是想自己整理整理...），感谢你们的支持。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 08 Nov 2019 16:13:00 +0000</pubDate>
<dc:creator>LightHouseOfficial</dc:creator>
<og:description>作为考察范围最广，考察次数最多的算法，当然要开一篇博客来复习啦。 子曰：温故而知新，可以为师矣 我复习DP时有一些自己对DP的理解，也就分享出来吧。 ——正片开始—— 动态规划算法，即Dynamic</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/light-house/p/11817439.html</dc:identifier>
</item>
<item>
<title>【原创】基于.NET的轻量级高性能 ORM - TZM.XFramework 之让代码更优雅 - TANZAME</title>
<link>http://www.cnblogs.com/yiting/p/11823878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiting/p/11823878.html</guid>
<description>&lt;p&gt;&lt;span&gt; 【前言】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　大家好，我是TANZAME。出乎意料的，我们在立冬的前一天又见面了，天气慢慢转凉，朋友们注意添衣保暖，愉快撸码。距离 &lt;a title=&quot;基于.NET的轻量级高性能 ORM - TZM.XFramework&quot; href=&quot;https://www.cnblogs.com/yiting/p/10952302.html&quot; target=&quot;_blank&quot;&gt;TZM.XFramework&lt;/a&gt; 的首秀已数月有余，期间收到不少朋友的鼓励、建议和反馈，在此致以深深的感谢。&lt;/p&gt;
&lt;p&gt;　　不少围观的朋友经常问题我，.NET 体系下优秀的 O/RM 官方的有EF，第三方的有&lt;a href=&quot;https://github.com/linq2db/linq2db&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;linq2db&lt;/a&gt; (国外)、&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;StackExchange/Dapper&lt;/a&gt; (国外)、&lt;a href=&quot;http://nhibernate.info/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;NHibernate&lt;/a&gt; (国外)、&lt;a href=&quot;https://github.com/CollaboratingPlatypus/PetaPoco&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;PetaPoco&lt;/a&gt; (国外)、&lt;a href=&quot;https://github.com/2881099/FreeSql&quot; target=&quot;_blank&quot;&gt;Freesql&lt;/a&gt; (国内)等等，What's your problem？Ok，咱们就用一分钟的时间聊聊 What's my &lt;strong&gt;Advantage&lt;/strong&gt;，聊聊如何用 ORM 让代码变得更优雅更加清爽。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 【正文】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　相信朋友们都遇到过这样的场景：要插入/删除/修改的数据来自外键表，怎么办？先查出来再进行接下的操作吗，别这样老铁，至少两次以上的数据库访问，从性能角度来说并不是最优的做法。手撸纯 SQL吗，看起来还行至少不会那么令人不舒服。如果有 ORM 能帮我们撸这种 SQL，岂不更痛快？来看看我们的 ORM 是怎么操作的：&lt;/p&gt;

&lt;p&gt;　　1. 多表关联更新　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 更新本表值等于别表的字段值
var query =
    from a in context.GetTable&amp;lt;Model.Client&amp;gt;()
    join b in context.GetTable&amp;lt;Model.CloudServer&amp;gt;() on a.CloudServerId equals b.CloudServerId
    join c in context.GetTable&amp;lt;Model.ClientAccount&amp;gt;() on a.ClientId equals c.ClientId
    where c.AccountId == &quot;1&quot;
    select a;
context.Update&amp;lt;Model.Client, Model.CloudServer, Model.ClientAccount&amp;gt;((a, b, c) =&amp;gt; new
{
    CloudServerId = b.CloudServerId,
    Qty = c.Qty &amp;gt; 0 ? c.Qty : 1,
}, query);
context.SubmitChanges();

-- 产生的SQL
--UPDATE t0 SET
--t0.[CloudServerId] = t1.[CloudServerId],
--t0.[Qty] = (CASE WHEN t2.[Qty] &amp;gt; @p1 THEN t2.[Qty] ELSE @p2 END)
--FROM [Bas_Client] AS [t0]
--INNER JOIN [Sys_CloudServer] t1 ON t0.[CloudServerId] = t1.[CloudServerId]
--INNER JOIN [Bas_ClientAccount] t2 ON t0.[ClientId] = t2.[ClientId]
--WHERE t2.[AccountId] = @p3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　仔细观察查询语义和对应的 SQL 不难发现，from a in context.GetTable 这一句正是对应了 UPDAE *** FROM TABLE 这一句，接下来就是关联到外键表也即是 INNER JOIN TABLE，最后是我们熟悉的 WHERE 语句。有一个特别的地方就是 Oracle 它没有 UPDATE FROM 这种语法，只能用 MERGE INTO 来代替。来看看源码是怎么实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 预先解析表别名，将查询语义中出现的如a,b,c这些变量表达成 t0,t1,t2的形式
TableAliasCache aliases = this.PrepareAlias&amp;lt;T&amp;gt;(uQueryInfo.SelectInfo, token);
ExpressionVisitorBase visitor = null;
// 解析UPDATE的字段
visitor = new UpdateExpressionVisitor(this, aliases, uQueryInfo.Expression);
visitor.Write(builder);
// FROM 片段
builder.AppendNewLine();
builder.Append(&quot;FROM &quot;);
builder.AppendMember(typeRuntime.TableName, !typeRuntime.IsTemporary);
builder.AppendAs(&quot;t0&quot;);

var cmd2 = new MappingCommand(this, aliases, token) { HasMany = uQueryInfo.SelectInfo.HasMany };
// 解析外键表
visitor = new JoinExpressionVisitor(this, aliases, uQueryInfo.SelectInfo.Joins);
visitor.Write(cmd2.JoinFragment);
// 解析WHERE条件
visitor = new WhereExpressionVisitor(this, aliases, uQueryInfo.SelectInfo.WhereExpression);
visitor.Write(cmd2.WhereFragment);
cmd2.AddNavMembers(visitor.NavMembers);
// 最后合并所有的片断形成最终SQL语句
builder.Append(cmd2.CommandText);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 多表关联插入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 多表关联批量新增
var query =
    from a in context.GetTable&amp;lt;Model.Client&amp;gt;()
    join b in context.GetTable&amp;lt;Model.CloudServer&amp;gt;() on a.CloudServerId equals b.CloudServerId
    where a.ClientId &amp;lt;= 5 &amp;amp;&amp;amp; b.CloudServerId != 0
    select new Model.Client
    {
        ClientId = DbFunction.RowNumber&amp;lt;int&amp;gt;(x =&amp;gt; a.ClientId) + (maxClientId + 2),
        ClientCode = &quot;ABC2&quot;,
        ClientName = &quot;啊啵呲2&quot;,
        CloudServerId = b.CloudServerId,
        State = 2,
        ActiveDate = DateTime.Now
    };
context.Insert(query);

-- 产生的SQL
--INSERT INTO [Bas_Client]([ClientId],[ClientCode],[ClientName],[CloudServerId],[State],[ActiveDate])
--SELECT 
--ROW_NUMBER() Over(Order By t0.[ClientId]) + @p17 + @p18 AS [ClientId],
--@p19 AS [ClientCode],
--@p20 AS [ClientName],
--t1.[CloudServerId] AS [CloudServerId],
--@p21 AS [State],
--@p22 AS [ActiveDate]
--FROM [Bas_Client] t0 
--INNER JOIN [Sys_CloudServer] t1 ON t0.[CloudServerId] = t1.[CloudServerId]
--WHERE t0.[ClientId] &amp;lt;= @p23 AND t1.[CloudServerId] &amp;lt;&amp;gt; @p24
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从产生的 SQL 可以看出，除去第一行的 INSERT，剩下的就是整个 SELECT 语句，也就是上面示例代码中 query 变量表示的查询语义。这里需要注意的是在解析 SELECT 语句的同时要把所的字段记录下来，INSERT INTO 语句需要拼接上这些字段。来看看代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// INSERT INTO 片断
builder.Append(&quot;INSERT INTO &quot;);
builder.AppendMember(typeRuntime.TableName, !typeRuntime.IsTemporary);
builder.Append('(');

// 解析 SELECT 块
MappingCommand cmd2 = this.ParseSelectCommand(nQueryInfo.SelectInfo, 0, true, token) as MappingCommand;
int i = 0;
// 拼接 INSERT INTO 字段
foreach (Column column in cmd2.PickColumns)
{
    builder.AppendMember(column.NewName);
    if (i &amp;lt; cmd2.PickColumns.Count - 1) builder.Append(',');
    i++;
}
builder.Append(')');
// 最后合并所有的片断形成最终SQL语句
builder.AppendNewLine();
builder.Append(cmd2.CommandText);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 多表关联删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// Query 关联批量删除
var query =
    from a in context.GetTable&amp;lt;Model.Client&amp;gt;()
    join b in context.GetTable&amp;lt;Model.ClientAccount&amp;gt;() on a.ClientId equals b.ClientId
    join c in context.GetTable&amp;lt;Model.ClientAccountMarket&amp;gt;() on new { b.ClientId, b.AccountId } equals new { c.ClientId, c.AccountId }
    where c.ClientId &amp;gt; 100 &amp;amp;&amp;amp; c.AccountId == &quot;1&quot; &amp;amp;&amp;amp; c.MarketId == 1
    select a;
context.Delete&amp;lt;Model.Client&amp;gt;(query1);

-- 产生的SQL
--DELETE t0 FROM [Bas_Client] t0 
--INNER JOIN [Bas_ClientAccount] t1 ON t0.[ClientId] = t1.[ClientId]
--INNER JOIN [Bas_ClientAccountMarket] t2 ON t1.[ClientId] = t2.[ClientId] AND t1.[AccountId] = t2.[AccountId]
--WHERE t2.[ClientId] &amp;gt; @p2 AND t2.[AccountId] = @p3 AND t2.[MarketId] = @p4&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　删除跟更新的更新的原理是一样的，无非是 UPDATE 换成了 DELETE。另外 Oracle 也没有 DELETE FROM 语法，我们换一种取巧一下，用 ROWID 一样能达到关联删除的效果。来看看最后的代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// DELETE FROM 片断
builder.Append(&quot;DELETE t0 FROM &quot;);
builder.AppendMember(typeRuntime.TableName, !typeRuntime.IsTemporary);
builder.Append(&quot; t0 &quot;);
// 预先解析表别名，将查询语义中出现的如a,b,c这些变量表达成 t0,t1,t2的形式
TableAliasCache aliases = this.PrepareAlias&amp;lt;T&amp;gt;(dQueryInfo.SelectInfo, token);
var cmd2 = new MappingCommand(this, aliases, token) { HasMany = dQueryInfo.SelectInfo.HasMany };
// 解析外键表
ExpressionVisitorBase visitor = new JoinExpressionVisitor(this, aliases, dQueryInfo.SelectInfo.Joins);
visitor.Write(cmd2.JoinFragment);
// 解析WHERE条件
visitor = new WhereExpressionVisitor(this, aliases, dQueryInfo.SelectInfo.WhereExpression);
visitor.Write(cmd2.WhereFragment);
cmd2.AddNavMembers(visitor.NavMembers);
// 最后合并所有的片断形成最终SQL语句
builder.Append(cmd2.CommandText);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 【结语】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　经过大半月的努力，TZM.XFramework 也已正式支持 SQLite了，托管地址：GitHub托管地址：&lt;a title=&quot;XFramework&quot; href=&quot;https://github.com/TANZAME/XFramework&quot; target=&quot;_blank&quot;&gt;https://github.com/TANZAME/XFramework&lt;/a&gt; 。最后借用某公众号上面的一句话与大家共勉，有趣和好奇心是为了取悦自己，然后才能有意思和有用是去取悦别人。撸码不易，不喜轻喷，有不同看法老友欢迎加群交流。&lt;/p&gt;
&lt;p&gt;　　技术交流群:816425449&lt;/p&gt;

</description>
<pubDate>Fri, 08 Nov 2019 15:34:00 +0000</pubDate>
<dc:creator>TANZAME</dc:creator>
<og:description>【前言】 大家好，我是TANZAME。出乎意料的，我们在立冬的前一天又见面了，天气慢慢转凉，朋友们注意添衣保暖，愉快撸码。距离 TZM.XFramework&amp;#160;的首秀已数月有余，期间收到不少朋</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yiting/p/11823878.html</dc:identifier>
</item>
<item>
<title>线程以及多线程开发 - Gyyyang</title>
<link>http://www.cnblogs.com/gyyyblog/p/11823842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gyyyblog/p/11823842.html</guid>
<description>&lt;h2 id=&quot;进程和线程&quot;&gt;进程和线程&lt;/h2&gt;
&lt;p&gt;在学习线程之前，首先要理解什么是进程。打开你的任务管理器，导航栏第一个清清楚楚的写着&lt;strong&gt;进程&lt;/strong&gt;，点进去会发现是许许多多的你在运行的程序，这就是一个进程。&lt;/p&gt;
&lt;p&gt;like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231431793-1371578165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现代操作系统都可以同时执行多个程序，这就是多任务。线程时建立在进程的基础上的，比如&lt;strong&gt;QQ音乐&lt;/strong&gt;这个进程可以同时在执行播放、下载、传输等动作。这就叫多线程，每个线程在执行不同的功能。&lt;br/&gt;在单核CPU系统中，也可以同时运行多个程序，程序运行是抢占式的，&lt;code&gt;QQ&lt;/code&gt;运行&lt;code&gt;0.001S&lt;/code&gt;,&lt;code&gt;chrome&lt;/code&gt;运行&lt;code&gt;0.01s&lt;/code&gt;,这个时间人是感知不出来的，我们就会觉得在同时执行。所以为了提高效率，现在的手机、电脑都是非常多核的。&lt;/p&gt;
&lt;p&gt;进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。&lt;/p&gt;
&lt;p&gt;操作系统调度的最小任务单位其实不是进程，而是线程。&lt;/p&gt;
&lt;h2 id=&quot;进程-vs-线程&quot;&gt;进程 VS 线程&lt;/h2&gt;
&lt;p&gt;进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由线程实现，还可以混合多进程+多线程。&lt;/p&gt;
&lt;p&gt;和多线程相比，多进程的缺点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建进程比创建线程开销大很多，尤其是在Windows上&lt;/li&gt;
&lt;li&gt;进程间通信比线程要慢，因为线程见通信就是读写同一个变量，速度很快&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多进程的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多进程稳定性比多线程高，因为在多进程情况下，一个进程的崩溃不会影响其他进程，任何一个线程崩溃会导致整个进程崩溃。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建线程&quot;&gt;创建线程&lt;/h3&gt;
&lt;h4 id=&quot;thread&quot;&gt;1. Thread&lt;/h4&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {  // 线程的主体类
    @Override
    public void run(){  
       System.out.println(&quot;Thread is starting&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;MyThread&lt;/code&gt;类继承&lt;code&gt;Thread&lt;/code&gt;,覆写了&lt;code&gt;run&lt;/code&gt;方法。一个类只要继承了此类，就表示这个类为线程的主体类。&lt;code&gt;run()&lt;/code&gt;是线程的主方法,多线程要执行的方法都在这写。&lt;br/&gt;但是&lt;code&gt;run()&lt;/code&gt;方法是不能被直接调用的，这牵涉到系统的资源调度问题，想要启动多线程，必须用&lt;code&gt;start()&lt;/code&gt;完成。&lt;/p&gt;
&lt;h5 id=&quot;调用线程&quot;&gt;调用线程&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadDemo {
    public static void main(String[] args) {
     new MyThread().start();
        // 启动新线程
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;java语言内置了多线程支持。当Java程序启动的时候其实是启动了一个JVM进程。JVM启动主线程来执行&lt;code&gt;main()&lt;/code&gt;方法，在&lt;code&gt;main()&lt;/code&gt;方法中可以启动其他线程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;start()&lt;/code&gt; 只能由 &lt;code&gt;Thread&lt;/code&gt;类型实例调用，表示启动一个线程。&lt;/p&gt;
&lt;h5 id=&quot;执行结果&quot;&gt;执行结果&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&quot;C:\Program Files\Java\jdk1.8.0_221\bin\java.exe&quot;

Thread is starting&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，线程创建成功&lt;/p&gt;
&lt;p&gt;那么创建一个多线程呢？&lt;/p&gt;
&lt;h5 id=&quot;创建多线程&quot;&gt;创建多线程&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;// 多线程主体类
public class MyThread extends Thread {
    private String title;
    public MyThread(){
    }
    MyThread(String title){
        this.title = title;
    }
    @Override
    public void run(){
        for (int i = 0; i&amp;lt;10;i++){
            System.out.println(this.title +  &quot;is starting&quot;);
            System.out.println(Thread.currentThread().getName());
        }
    }
}



 public static void main(String[] args) {
        new Thread(new MyThread(&quot;A&quot;),&quot;线程1&quot;).start();
        new Thread(new MyThread(&quot;C&quot;),&quot;线程2&quot;).start();
        new Thread(new MyThread(&quot;B&quot;)).start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231528710-2042728418.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个结果中有几个关注点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多线程的执行是无序的，不可控的&lt;/li&gt;
&lt;li&gt;调用的是&lt;code&gt;start()&lt;/code&gt;方法，但执行的是&lt;code&gt;run()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们来看一下源码，分析一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void start() {
      
        if (threadStatus != 0)  // 判断线程状态
        
        // 每一个线程的类的对象只允许启动一次，重复启动就会抛出这个异常，由run()抛出
            throw new IllegalThreadStateException();
            
        group.add(this);

        boolean started = false;
        try {
        // 调用此方法
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            
            }
        }
    }

    private native void start0();
   
   // 注释部分被我删掉了，太长了 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现&lt;code&gt;start()&lt;/code&gt;方法调用的是&lt;code&gt;start0()&lt;/code&gt;，而&lt;code&gt;start0()&lt;/code&gt;并没有实现，还被&lt;code&gt;native&lt;/code&gt;修饰，那么&lt;code&gt;native&lt;/code&gt;是啥呢？&lt;/p&gt;
&lt;p&gt;在Java程序执行的过程中考虑到对于不同层次的开发者需求，支持了本地的操作系统函数调用。这项技术被称为&lt;code&gt;JNI(Java Native Interface)&lt;/code&gt;，但在Java开发过程中并不推荐这样使用。利用这项技术，可以利用操作系统提供的的底层函数，操作一些特殊的处理。&lt;/p&gt;
&lt;p&gt;不同的系统在进行资源调度的时候由自己的一套算法，要想调用&lt;code&gt;start()&lt;/code&gt;方法启动线程，就要实现&lt;code&gt;start0()&lt;/code&gt;，这时候&lt;code&gt;JVM&lt;/code&gt;就会根据不同的操作系统来具体实现&lt;code&gt;start0()&lt;/code&gt;，总结就是一切的一切都是跨平台带来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231720654-436370468.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也规定了，&lt;strong&gt;启动多线程只有一种方案，调用&lt;code&gt;Thread&lt;/code&gt;类中的&lt;code&gt;start()&lt;/code&gt;方法&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Thread 构造函数可以接收一个实例对象和线程的名字参数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;Thread.currentThread().getName()&lt;/code&gt; 就代表了获取当前线程的名字。&lt;/p&gt;
&lt;p&gt;在返回值中还出现了&quot;Thread-3&quot;,这是由于Thread会自动给没有命名的线程分配一个不会重复的名字。&lt;/p&gt;
&lt;p&gt;这种方式启动多线程固然没错，但存在单继承的隐患。下面就给出另一种模式。&lt;/p&gt;
&lt;h4 id=&quot;runnable&quot;&gt;2. Runnable&lt;/h4&gt;
&lt;p&gt;首先分别来看一下&lt;code&gt;Thread&lt;/code&gt;类的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public
class Thread implements Runnable {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来&lt;code&gt;Thread&lt;/code&gt;是继承了&lt;code&gt;Runnable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再看一下&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Runnable {
    /**
     * When an object implementing interface &amp;lt;code&amp;gt;Runnable&amp;lt;/code&amp;gt; is used
     * to create a thread, starting the thread causes the object's
     * &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method to be called in that separately executing
     * thread.
     * &amp;lt;p&amp;gt;
     * The general contract of the method &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次惊讶，原来这个run方法也是从这里继承的。&lt;/p&gt;
&lt;p&gt;那就清楚了，来试一下吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 只需要实现 Runnable，重写run()即可，其他丝毫未变
public class MyThread implements Runnable {
    private String title;
    public MyThread(){
    }
    MyThread(String title){
        this.title = title;
    }
    @Override
    public void run(){
        for (int i = 0; i&amp;lt;10;i++){
            System.out.println(this.title +  &quot;is starting&quot;);
            System.out.println(Thread.currentThread().getName());
        }
    }
}




public class ThreadDemo {
    public static void main(String[] args) {
        new Thread(new MyThread(&quot;A线程&quot;),&quot;线程1&quot;).start();
        new Thread(new MyThread(&quot;C线程&quot;),&quot;线程2&quot;).start();
        new Thread(new MyThread(&quot;B线程&quot;)).start();
       // lambda 语法实现
//        new Thread(() -&amp;gt; {
//           System.out.println(&quot;启动新的线程&quot;);
//       }).start();


    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231755243-1938264502.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完全一致。&lt;/p&gt;
&lt;p&gt;在以后的多线程设计实现，优先使用&lt;code&gt;Runnable&lt;/code&gt;接口实现。&lt;/p&gt;
&lt;p&gt;还没完，我们依靠&lt;code&gt;Runnable&lt;/code&gt;接口实现的时候，会发现有一个缺陷，就是没有返回值，那有没有带返回值的实现方式呢？有！继续看&lt;/p&gt;
&lt;h4 id=&quot;callable&quot;&gt;3. Callable&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;Java1.5&lt;/code&gt;之后为了解决&lt;code&gt;run()&lt;/code&gt;方法没有返回值的问题，引入了新的线程实现&lt;code&gt;java.util.concurrent.Callable&lt;/code&gt;接口.&lt;/p&gt;
&lt;p&gt;我们看一下Oracle的api文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231820047-697698607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Callable定义的时候利用了一个泛型，代表了返回数据的类型，避免了向下转型带来的安全隐患&lt;/p&gt;
&lt;blockquote readability=&quot;2.5757575757576&quot;&gt;
&lt;p&gt;了解向下转型可以看我的另一篇文章：&lt;a href=&quot;https://www.cnblogs.com/gyyyblog/p/11806601.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/gyyyblog/p/11806601.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是问题又来了，我们上面已经说过了，要想启动多线程，必须使用&lt;code&gt;Thread&lt;/code&gt;类提供的&lt;br/&gt;&lt;code&gt;start()&lt;/code&gt; 方法调用&lt;code&gt;Runnable&lt;/code&gt;接口的 &lt;code&gt;run()&lt;/code&gt; 方法，可是现在 &lt;code&gt;Callable&lt;/code&gt;中并没有&lt;code&gt;run()&lt;/code&gt; 方法，那怎么办呢？&lt;/p&gt;
&lt;p&gt;再来找到一个&lt;code&gt;FutureTask&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt;
extends Object
implements RunnableFuture&amp;lt;V&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231844295-1320683799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的构造方法可以接收一个&lt;code&gt;Callable&lt;/code&gt;类型参数&lt;/p&gt;
&lt;p&gt;它又继承了&lt;code&gt;RunnableFuture&amp;lt;V&amp;gt;&lt;/code&gt;,那就继续往上找&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface RunnableFuture&amp;lt;V&amp;gt;
extends Runnable, Future&amp;lt;V&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现了，它出现了，&lt;code&gt;Runnable&lt;/code&gt;我们知道了，是没有返回值的，现在看看&lt;code&gt;Future&amp;lt;V&amp;gt;&lt;/code&gt;是个啥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231901500-1500837281.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它有一个&lt;code&gt;get()&lt;/code&gt;方法可以得到一个泛型返回值。&lt;/p&gt;
&lt;p&gt;OK，现在我们就可以梳理一下找到的这些东西怎么个关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108231913502-1565904771.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;具体实现&quot;&gt;具体实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class CallableThread implements Callable&amp;lt;String&amp;gt; {  // 继承实现Callable&amp;lt;V&amp;gt;
    // 覆写call()方法
    @Override
    public String call() throws Exception{
        for (int i = 0;i&amp;lt;10;i++){
            System.out.println(&quot;*********线程执行、i=&quot;+ i);
        }
        return &quot;线程执行完毕&quot;;
    }
}



// 调用
        FutureTask&amp;lt;String&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(new CallableThread());
        new Thread(task).start();
        System.out.println(&quot;【线程返回数据】&quot; + task.get());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1814231/201911/1814231-20191108232000171-1711377467.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了得到一个返回值可真不容易，核心思想还是实例化一个&lt;code&gt;Thread&lt;/code&gt;对象，可通过其构造方法接收一个&lt;code&gt;Rannable&lt;/code&gt;类型参数，调用&lt;code&gt;start()&lt;/code&gt;启动线程.&lt;/p&gt;
&lt;p&gt;总结：基本来说就这三种创建多线程模式，根据场景使用。&lt;/p&gt;
&lt;p&gt;**纯属个人理解，希望指正错误，共同交流。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 15:20:00 +0000</pubDate>
<dc:creator>Gyyyang</dc:creator>
<og:description>进程和线程 在学习线程之前，首先要理解什么是进程。打开你的任务管理器，导航栏第一个清清楚楚的写着 进程 ，点进去会发现是许许多多的你在运行的程序，这就是一个进程。 like this: 现代操作系统都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gyyyblog/p/11823842.html</dc:identifier>
</item>
<item>
<title>Python进阶函数 - YJ同心</title>
<link>http://www.cnblogs.com/yjtxin/p/11817092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjtxin/p/11817092.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.函数的动态参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前我们说过了传参, 如果我们需要给一个函数传参, 而参数又是不确定的. 或者我给一个函数传很多参数, 我的形参就要写很多, 很麻烦, 怎么办呢. 我们可以考虑使用动态参数.&lt;/p&gt;
&lt;p&gt;动态参数分成两种:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. *args 动态接收位置参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;动态接收参数的时候要注意：动态参数必须在位置参数后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; xue(*language,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; 　　&lt;span&gt;print&lt;/span&gt;('我要学:',language,&lt;span&gt;a&lt;/span&gt;,&lt;span&gt;b&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; xue(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,JAVA,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这个程序不遵循顺序的话就会报错，如上面代码，因为前面传进去的所有位置参数都给*language接收了，a和b永远也接收不了参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191108183522472-1683713610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以必须改写成如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; xue(*&lt;span&gt;language,a,b):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我要学：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,language,a,b)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; xue(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,b=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)　　#必须用关键字指定参数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191108184654908-1297035405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 这个时候a和b就有值了, 但是这样写呢位置参数就不能用了. 所以. 我们要先写位置参数,然后再用动态参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; xue(a,b,*&lt;span&gt;language):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我要学：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,a,b,language)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; xue(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;前两个参数用位置参数来接收，后面的参数用动态参数接收&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪默认值参数呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个时候我们发现所有的默认值都生了. 这个时候如果不给出关键字传参. 那么你的默认值是永远都生效的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;要记住的顺序: 位置参数, 动态参数*, 默认值参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. **kwargs 动态接收关键字参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在python中可以动态的位置参数, 但是*这种情况只能接收位置参数⽆无法接收关键字参数.&lt;/p&gt;
&lt;p&gt;在python中使⽤用**来接收动态关键字参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; xue(**&lt;span&gt;kwargs):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; xue(a=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,b=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191108192044655-602862952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个时候接收到的都是dict(字典)&lt;/p&gt;
&lt;p&gt;顺序问题，在函数调用的时候，如果先给出关键字参数，则整个函数都会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; xue(a,b,c,d):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a,b,c,d)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关键字参数必须在位置参数前面，否则参数会混乱至报错&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; xue(1,2,c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,666)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;所以关键字参数必须在位置参数后面. 由于实参是这个顺序. 所以形参接收的时候也是这&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;个顺序. 也就是说位置参数必须在关键字参数前⾯面. 动态接收关键字参数也要在后面&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;最终顺序(*):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;位置参数 &amp;gt; *args &amp;gt; 默认值参数 &amp;gt; **kwargs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数的注释:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; XUE(JAVA,PHP):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    这个函数是用来总结学的编程语言，
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    :param JAVA: 参数Java是Java语言
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    :param PHP: 参数PHP是PHP语言
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    :return: 返回的是什么东西
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(JAVA,PHP)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;坚持&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.命名空间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在python解释器开始执行之后, 就会在内存中开辟一个空间, 每当遇到一个变量的时候, 就把变量名和值之间的关系记录下来, 但是当遇到函数定义的时候, 解释器只是把函数名读入内存, 表示这个函数存在了, 至于函数内部的变量和逻辑, 解释器是不关心的. 也就是说一开始的时候函数只是加载进来, 仅此而已, 只有当函数被调用和访问的时候, 解释器才会根据函数内部声明的变量来进行开辟变量的内部空间. 随着函数执行行完毕, 这些函数内部变量占用的空间也会随着函数执行完毕而被清空&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; xue():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YJ&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;xue()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;a已经不存在了已经&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 1. 内置名称空间:存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间&lt;/p&gt;
&lt;p&gt;2. 全局名称空间:我们直接在py⽂文件中, 函数外声明的变量都属于全局命名空间&lt;/p&gt;
&lt;p&gt;3. 局部名称空间:在函数中声明的变量量会放在局部命名空间&lt;/p&gt;
&lt;p&gt;作用域:&lt;/p&gt;
&lt;p&gt;1. 全局作用域: 内置+全局      查看全局作用域globals()&lt;/p&gt;
&lt;p&gt;2. 局部作用域: 局部(函数被调用)    查看局部作用域locals（）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三，函数名的运用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数名是一个变量, 但它是一个特殊的变量, 与括号配合可以执行函数的变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.函数名的内存地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191109045338838-1504544407.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2. 函数名可以赋值给其他变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191109045616157-1643059525.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3. 函数名可以当做容器类的元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191109050047845-1870041061.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4. 函数名可以当做函数的参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191109050515537-929358625.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 5. 函数名可以作为函数的返回值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191109051143709-671251516.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.函数嵌套&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;函数可以互相的嵌套&lt;/p&gt;
&lt;p&gt;1.只要遇见了()就是函数的调用，如果没有()就不是函数的调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191108222611394-1687770919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.函数的执行顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1638478/201911/1638478-20191108222502724-2068436510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五， global和nonlocal关键&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;global：在局部访问全局中的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; a = 10 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全局变量本身就是不安全的, 不能随意修改, 闭包&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt; a  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 可以把全局中的内容引入到函数内部 , 2. 在全局创建一个变量&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; a = 20&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     a += 10 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; a = a+10&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;func()
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; a = 10&lt;br/&gt;#结果为，20，20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nonlocal：在局部寻找外层函数中离他最近的那个变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; a = 10
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; outer():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     a = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; inner(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在inner中改变a的值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         nonlocal a &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 寻找外层函数中离他最近的那个变量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         a = 20
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    inner()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;outer()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 08 Nov 2019 14:49:00 +0000</pubDate>
<dc:creator>YJ同心</dc:creator>
<og:description>一.函数的动态参数 之前我们说过了传参, 如果我们需要给一个函数传参, 而参数又是不确定的. 或者我给一个函数传很多参数, 我的形参就要写很多, 很麻烦, 怎么办呢. 我们可以考虑使用动态参数. 动态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yjtxin/p/11817092.html</dc:identifier>
</item>
<item>
<title>Java对象的&quot;后事处理&quot;——垃圾回收（二） - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/11809376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/11809376.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;finalize&lt;/strong&gt;()能做的所有工作，使用&lt;strong&gt;try-finally&lt;/strong&gt;或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。&lt;/p&gt;
&lt;p&gt;——《深入理解JVM》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;strong&gt;finalize()&lt;/strong&gt;方法确实可以实现一次对象的自救，但是其&lt;strong&gt;不确定性&lt;/strong&gt;和&lt;strong&gt;昂贵的运行代价&lt;/strong&gt;都表明这个方法的使用需要十分的慎重。那么finalize()在什么时期起作用又是如何实现对象的自救的呢？首先我们要理解虚拟机在扫描到死亡对象的时候并不是直接回收的，而是进行一次&lt;strong&gt;标记并且筛选&lt;/strong&gt;，筛选的条件就是其对象的&lt;strong&gt;finalize&lt;/strong&gt;方法是否有必要执行。如果当前对象&lt;strong&gt;没有重写finalize方法&lt;/strong&gt;或者&lt;strong&gt;已经调用过一次finalize方法&lt;/strong&gt;，那么则视为没有必要执行，此时便失去自救的机会，放入&quot;即将回收&quot;集合中。&lt;/p&gt;
&lt;p&gt;　　否则的话，则将对象放入一个叫&lt;strong&gt;F-Queue&lt;/strong&gt;的队列中，稍后虚拟机将一个个的执行队列中对象的&lt;strong&gt;finalize&lt;/strong&gt;方法（就是在此处对象可以在&lt;strong&gt;finalize&lt;/strong&gt;方法中将自身关联到引用链，从而暂时逃脱被回收的命运），需要注意的是虚拟机保证执行但不保证执行完&lt;strong&gt;finalize&lt;/strong&gt;方法，原因是如果&lt;strong&gt;finalize&lt;/strong&gt;方法执行时间过长或者陷入死循环，则可能让系统奔溃。全部执行之后，虚拟机将对队列的对象重新标记一次，如果还不在引用链中则GG，否则将其移出&quot;即将回收&quot;集合。下面例子参考《深入理解JVM》实现自救并且验证只能自救一次的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestForGc {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 定义一个根节点的静态变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; TestForGc INSTANCE;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 重写finalize方法，让其被标记为有必要执行并且加入F-Q
     *
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Throwable
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; finalize() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.finalize();
        System.err.println(&lt;/span&gt;&quot;finalize method in TestForGc Class invoked!&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将自身关联到根节点中，实现自救&lt;/span&gt;
        INSTANCE = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        INSTANCE &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestForGc();

        INSTANCE &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        System.gc();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 睡眠1S，保证F-Q中的方法执行完毕&lt;/span&gt;
        TimeUnit.SECONDS.sleep(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.nonNull(INSTANCE)) {
            System.out.println(&lt;/span&gt;&quot;i successfully save myself by finalize method!&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;i am dead :(&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 下面验证finalize方法只能调用一次
         * 几乎完全一样的代码，却是不同的结局
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        INSTANCE &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        System.gc();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 睡眠1S&lt;/span&gt;
        TimeUnit.SECONDS.sleep(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.nonNull(INSTANCE)) {
            System.out.println(&lt;/span&gt;&quot;i successfully save myself by finalize method again!&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;couldn't invoke finalize again, i am dead :(&quot;&lt;span&gt;);
        }
    }
}&lt;br/&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191106225944375-1646209609.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;208&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果说回收算法是接口，那么垃圾回收器就是这些接口的实现类，共有7种回收器，接下来一一罗列。&lt;/p&gt;
&lt;h2&gt;2.1 Serial垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;Serial&lt;/strong&gt;是一种单线程垃圾回收器，在工作的时候的时候会暂停所有的用户线程，也就是&quot;&lt;strong&gt;stop-the-world&lt;/strong&gt;&quot;，虽然单线程代表了用户线程的停顿，但是也意味着其不用进行线程的交互从而有更高的收集 效率。&lt;strong&gt;Serial&lt;/strong&gt;采用&lt;strong&gt;复制算法&lt;/strong&gt;，是&lt;strong&gt;Client&lt;/strong&gt;端新生代的默认垃圾回收器。其工作图类似于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108211418328-1507152895.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 ParNew垃圾回收器。&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;ParNew&lt;/strong&gt;是&lt;strong&gt;Serial&lt;/strong&gt;回收器的多线程版本，是&lt;strong&gt;Server&lt;/strong&gt;端新生代的默认回收器，除了并行多线程之外，其他包括实现都是一模一样，当然也是采用复制算法。还有一点重要的是，新生代的收集器除了&lt;strong&gt;Serial&lt;/strong&gt;之外，只有&lt;strong&gt;ParNew&lt;/strong&gt;能跟年老代的&lt;strong&gt;CMS&lt;/strong&gt;合作，其在低CPU的情况下效率比Serial低，但是在多个CPU的情况下要好的多。其工作图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108211647689-1855691112.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 Parallel Scavenge垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　跟&lt;strong&gt;ParNew&lt;/strong&gt;类似，作用于新生代，并行多线程并且也是采用复制算法。但是其关注的点却不同，其着重的是一种叫做&quot;&lt;strong&gt;吞吐量&lt;/strong&gt;&quot;的东西。所谓的&lt;strong&gt;&quot;吞吐量&quot;=运行用户代码的时间 / (运行用户代码的时间 + GC时间)&lt;/strong&gt;，也就是说其更加注重&lt;strong&gt;用户代码运行时间&lt;/strong&gt;而&lt;strong&gt;不是减少GC停顿时间&lt;/strong&gt;。相对于其他收集器来说，可以更加&lt;strong&gt;高效的利用CPU&lt;/strong&gt;，更加适合作为在后台运算而&lt;strong&gt;不大需要交互&lt;/strong&gt;的任务。&lt;strong&gt;Parallel&lt;/strong&gt;收集器提供了两个比较重要的参数。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-XX:MaxGCPauseMillis：&lt;/strong&gt;&lt;/span&gt;表示收集器将尽可能的在这个参数设定的毫秒数内完成回收工作。但这并不代表其设置的越低越好，缩减回收时间是通过减少吞吐量换来的，如果设置得太低可能导致频繁的GC。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-XX:GCTimeRatio：&lt;/strong&gt;&lt;/span&gt;表示代码运行时间和垃圾回收时间的比率，比如说设置为19，那么则垃圾回收时间占比为 1 / (1+19) = 5%，默认是99。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.4 Serial Old垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;Serial&lt;/strong&gt;的年老代版本，同&lt;strong&gt;Serial&lt;/strong&gt;基本相似，不同的是采用的是&lt;strong&gt;标记-整理&lt;/strong&gt;算法实现，作为&lt;strong&gt;Client&lt;/strong&gt;端默认的年老代收集器。如果在Server端的话，那么其主要作用有二：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;　1、跟新生代的Parallel Scavenge收集器配合。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　2、做一个有价值的&quot;备胎&quot;：当CMS垃圾回收器因为预留空间问题放不下对象而发生Concurrent Mode Fail时，作为其备选方案执行垃圾回收。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108213532541-761966016.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.5 Parallel Old垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;的年老代版本，&lt;strong&gt;多线程并行&lt;/strong&gt;，同样注重吞吐量，使用&lt;strong&gt;标记-整理算法&lt;/strong&gt;。这个收集器可以跟新生代的Parallel Svavenge一起搭配使用，在注重吞吐量和CPU资源敏感的场合中是一对很好的组合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108214247488-798293662.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.6 CMS垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　来了，它来了！CMS垃圾回收器被当做是具有划时代意义的、真正实现并发的垃圾回收器，总而言之=》&lt;/p&gt;
&lt;p&gt;　　,--^----------,--------,-----,-------^--,&lt;/p&gt;
&lt;p&gt;　　| ||||||||| `--------' | O&lt;/p&gt;
&lt;p&gt;　　`+---------------------------^----------|&lt;/p&gt;
&lt;p&gt;　　`\_,-------, _______________________强__|&lt;/p&gt;
&lt;p&gt;　　/ XXXXXX /`| /&lt;/p&gt;
&lt;p&gt;　　/ XXXXXX / `\ /&lt;/p&gt;
&lt;p&gt;　　/ XXXXXX /\______(&lt;/p&gt;
&lt;p&gt;　　/ XXXXXX /&lt;/p&gt;
&lt;p&gt;　　/ XXXXXX /&lt;/p&gt;
&lt;p&gt;　　(________(&lt;/p&gt;
&lt;p&gt;　　 `------'&lt;/p&gt;
&lt;p&gt;　　CMS是一款并发的垃圾回收器，但并&lt;strong&gt;不代表全程都不需要停顿&lt;/strong&gt;，只是&lt;strong&gt;大部分时间是跟用户线程一起执行&lt;/strong&gt;的。其整个GC过程中总共有4个阶段。&lt;/p&gt;
&lt;blockquote readability=&quot;15.447368421053&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、初始标记：&lt;/strong&gt;简单的标记所有的根节点，需要暂停所有的用户线程，即&quot;&lt;strong&gt;stop-the-world&lt;/strong&gt;&quot;，耗时较短。关于GCRooots的过程可以看下另一篇文章——&lt;a href=&quot;https://www.cnblogs.com/zhangweicheng/p/11795887.html&quot;&gt;垃圾回收（一）&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、并发标记：&lt;/strong&gt;跟用户线程一起工作，寻找堆中的死亡对象，整个过程耗时最长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;3、重新标记：&lt;/strong&gt;再次扫描，主要对象是并发标记过程中又新增的对象，也就是验漏。多线程，需要STW，时间相对并发标记来说短。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;4、并发清除：&lt;/strong&gt;GC线程跟用户线程一起执行，清除标记的死亡对象，&quot;&lt;strong&gt;浮动垃圾&lt;/strong&gt;&quot;在此阶段产生。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108220201760-467358207.png&quot; alt=&quot;&quot; width=&quot;816&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然而，优秀如CMS也会有不足之处，总共四个阶段的标记及清除算法的实现必定为其带来一些使用的麻烦。&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;1、占用一定CPU资源：&lt;/strong&gt;其有两个阶段需要并发跟用户线程一起执行，也就是说要跟用户线程抢占CPU的时间片，会占用一定的CPU资源，如果CPU资源不太优质的情况下，可能会造成不小的影响。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、空间利用率不能达到最大：&lt;/strong&gt;由于并发清除时用户线程也在运行，那么在GC结束前必定会产生一些额外的垃圾，那么就必须给这些垃圾预留一定的空间，否则会导致内存不足从而报&quot;&lt;strong&gt;Concurrent Mode Failure&lt;/strong&gt;&quot;，此时虚拟机便启用后备方案——&lt;strong&gt;使用Serial Old来进行垃圾回收&lt;/strong&gt;，进而浪费更多的时间。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、内存碎片导致提前FullGC：&lt;/strong&gt;CMS采用的是标记-清除算法，也就是说会产生&lt;strong&gt;内存碎片&lt;/strong&gt;，那么可能出现大对象放不下的情况，进而不得不提前进行一次FullGC。为了解决这个问题，虚拟机提供了两个参数&lt;em&gt;&lt;span&gt;&lt;strong&gt;-XX:+UseCMSCompactAtFullCollection&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;和&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-XX:CMSFullGCsBeforeCompaction&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;，分别表示&lt;strong&gt;CMS顶不住要进行FullGC的时候进行内存的整理&lt;/strong&gt;（整理的过程中无法并发，停顿时间不得不变长） 和&lt;strong&gt;进行多少次不压缩的FullGC之后来一次整理的GC&lt;/strong&gt;（默认0次，表示每次都进行内存整理）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.7 G1垃圾回收器&lt;/h2&gt;
&lt;p&gt;　　G1是一个新秀垃圾回收器，被赋予了很大的使命——取代CMS。G1作为新时代的垃圾回收器，相对于其他垃圾回收器来说有许多优势。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、并行和并发：&lt;/strong&gt;G1可以利用现在的硬件优势，缩短GC时stop-the-world的停顿时间，并且GC的时候同时也能让用户线程执行。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、分代收集：&lt;/strong&gt;跟其他垃圾回收器不同，G1没有物理上的年老代和新生代，其&lt;strong&gt;将内存分成了多个独立的Region&lt;/strong&gt;，每个Region都可能表示属于新生代还是年老代，所以不需要一堆Region凑放在一起然后将这块区域称作新生代，它们之间并不需要连续，所以只有概念上的分代，也是这种分代方式使得G1可以独立管理这个堆空间，不需要跟其他回收器合作。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;3、空间整合：&lt;/strong&gt;G1的算法从Region层面看属于复制算法（从一个Region复制到另一个），但是从整体看又是标记-整理法。然而不管是哪种，都表示G1不会产生内存碎片，不会因为空间不连续放不下大对象而出现FullGC的情况。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt;G1回收器将内存空间分成若干个&lt;strong&gt;Region&lt;/strong&gt;，并且这些&lt;strong&gt;Region&lt;/strong&gt;之前相互独立。但是我们都知道这并不能真正的独立，因为一个&lt;strong&gt;Region&lt;/strong&gt;中的对象不一定只会被当前&lt;strong&gt;Region&lt;/strong&gt;的其他对象引用，而&lt;strong&gt;可能被堆中的其他对象引用&lt;/strong&gt;，那G1是如何实现避免全堆扫描的呢？这个问题在分代的其他回收器中也有，但是在这里突显得更加明显而已。再G1中，对象本身都会有一个&lt;strong&gt;Remembered&lt;/strong&gt; &lt;strong&gt;Set&lt;/strong&gt;，这个&lt;strong&gt;Set&lt;/strong&gt;存放着当前对象被&lt;strong&gt;其他区域&lt;/strong&gt;对象引用的信息，这样子，在扫描引用的时候加上这个&lt;strong&gt;Set&lt;/strong&gt;就可以避免全堆扫描了。&lt;/p&gt;
&lt;p&gt;　　具体实现大致为：虚拟机在发现程序正在进行对&lt;strong&gt;Reference&lt;/strong&gt;类型的&lt;strong&gt;写操作&lt;/strong&gt;时，会&lt;strong&gt;暂时中断写操作&lt;/strong&gt;，然后检查&lt;strong&gt;Reference&lt;/strong&gt;引用的对象是否处于&lt;strong&gt;不同的区域&lt;/strong&gt;（&lt;strong&gt;如果是分代，则只对年老代的对象进行检查，检查是否引用的对象在新生代&lt;/strong&gt;），如果是的话则将引用信息记录在&lt;strong&gt;被引用的Remembered Set&lt;/strong&gt;中，这样在&lt;strong&gt;GC&lt;/strong&gt;的时候加上&lt;strong&gt;Remembered&lt;/strong&gt; &lt;strong&gt;Set&lt;/strong&gt;的扫描就可以避免全堆扫描了。&lt;/p&gt;
&lt;p&gt;　　跟CMS类型，G1也有四个阶段（不算Remembered Set的扫描），虽然相似但是还是有些区别的。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、初始标记：&lt;/strong&gt;标记可达的根节点，STW，单线程，时间短。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、并发标记：&lt;/strong&gt;跟用户线程同时执行，并发执行时对象可能会产生引用变化，其会将这些变化记录在Remembered Set Logs中，待下个阶段整合。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;3、最终标记：&lt;/strong&gt;验漏，将并发标记阶段的引用变化记录Remembered Set Logs整合到Remembered Set中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;4、筛选回收：&lt;/strong&gt;对各个Region中的回收价值进行排序，然后执行回收计划。暂停用户线程，并行执行。&lt;/em&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108220941017-1359484212.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本文首先介绍了“对象自救”的方法——&lt;strong&gt;finalize&lt;/strong&gt;，并且用一个小例子演示了对象如何实现自救。接着介绍了7种不同的垃圾回收器，新生代中有单线程的&lt;strong&gt;Serial&lt;/strong&gt;可以作为&lt;strong&gt;Client&lt;/strong&gt;端新生代的默认回收器，有多线程版本的Serial——&lt;strong&gt;ParNew&lt;/strong&gt;，还有着重点不同（吞吐量）的&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;；年老代方面有单线程的&lt;strong&gt;Serial Old&lt;/strong&gt;、跨时代意义的并发回收器——&lt;strong&gt;CMS&lt;/strong&gt;，虽然优秀还是其使用的算法和实现导致了它的三个缺点、还有吞吐量年老代版本——&lt;strong&gt;Parallel Old&lt;/strong&gt;收集器，最后还简单介绍了&lt;strong&gt;G1&lt;/strong&gt;收集器的几个过程还有独立的&lt;strong&gt;Region&lt;/strong&gt;间是如何实现避免堆扫描的。&lt;/p&gt;
&lt;p&gt;　　整体下来整篇行文还有些粗糙，日后会慢慢的圆润，如果有关于这方面好的文章可以在下面评论区分享学习一下，下方为各个垃圾回收器的搭配图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1742516/201911/1742516-20191108222122993-562505571.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;453&quot;/&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;It helps me a lot if you could share your opinion with us.&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 08 Nov 2019 14:41:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>1 先谈Finalize() finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。 ——《深入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/11809376.html</dc:identifier>
</item>
<item>
<title>Spring 动态代理 之 but was actually of type 'com.sun.proxy.$Proxy14 Exception - 逸游Java</title>
<link>http://www.cnblogs.com/dengchengchao/p/11823687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengchengchao/p/11823687.html</guid>
<description>&lt;p&gt;今天在写&lt;code&gt;Spring&lt;/code&gt;的引介代理的时候，报了一个错：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'inter1' is expected to be of type 'com.dengchengchao.springtest.intertest.Inter1Impl' but was actually of type 'com.sun.proxy.$Proxy14'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概的意思是类型转换错误。&lt;/p&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ApplicationContext  ctx = new AnnotationConfigApplicationContext(Conf.class);
Inter1 inter1 = ctx.getBean(&quot;inter1&quot;, Inter1Impl.class);

inter1.say1();

Inter2 inter2=(Inter2) inter1;
inter2.say2();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后来&lt;code&gt;google&lt;/code&gt;了一下发现把代理方式改成&lt;code&gt;CGLIB&lt;/code&gt;就行。&lt;/p&gt;
&lt;p&gt;我们都知道&lt;code&gt;JDK&lt;/code&gt;只能代理接口，对于非接口的类的代理，应该使用&lt;code&gt;CGLIB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;CGLIB&lt;/code&gt;是通过继承代理类实现，而&lt;code&gt;JDK&lt;/code&gt;是通过实现接口实现。&lt;/p&gt;
&lt;p&gt;但是我这里&lt;code&gt;Inter1&lt;/code&gt;分明就是一个接口。后来仔细检查了代码，发现其实使用&lt;code&gt;Java&lt;/code&gt;代理也行，只要改如下一行代码即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Inter1 inter1 = ctx.getBean(&quot;inter1&quot;, Inter1.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，需要转换成类型应该是&lt;code&gt;Inter1.class&lt;/code&gt;而不能是具体的类&lt;code&gt;Inter1Impl&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;为什么&lt;code&gt;Java&lt;/code&gt;代理只支持&lt;strong&gt;接口代理&lt;/strong&gt;，这里我们来深扒一下：&lt;/p&gt;
&lt;p&gt;首先定义一个接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface People {
    void eat();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义一个实现类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student implements People{

    @Override
    public void eat() {
        System.out.println(&quot;用手吃&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着定义一个代理类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StudentInvokeHandler implements InvocationHandler {

    private Object target;

    public StudentInvokeHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable    {

        System.out.println(&quot;饭前洗手&quot;);
        Object retVal = method.invoke(target, args);
        System.out.println(&quot;饭后吃水果&quot;);
        return retVal;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，通过代理来调用&lt;code&gt;Student&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public static void main(String[] args) {
    //初始化Student
    Student student = new Student();
    //初始化Student代理类
    StudentInvokeHandler studentInvokeHandler = new StudentInvokeHandler(student);
    //通过代理获取代理独享
    People studentProxy = (People) Proxy.newProxyInstance(StudentInvokeHandler.class.getClassLoader(), new Class[]{People.class}, studentInvokeHandler);
    //通过代理对象调用eat方法
    studentProxy.eat();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;可以看见，&lt;code&gt;Java&lt;/code&gt;的代理非常简单，但是底层是如何实现的呢？&lt;/p&gt;
&lt;p&gt;参照&lt;a href=&quot;https://blog.csdn.net/mhmyqn/article/details/48474815&quot;&gt;细说JDK动态代理的实现原理&lt;/a&gt;,我们在&lt;code&gt;main&lt;/code&gt;中设置一下&lt;code&gt;JVM&lt;/code&gt;属性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    //将生成的代理类文件保存
    System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);
    Student student = new Student();
    StudentInvokeHandler studentInvokeHandler = new StudentInvokeHandler(student);
    People studentProxy = (People) Proxy.newProxyInstance(StudentInvokeHandler.class.getClassLoader(), new Class[]{People.class}, studentInvokeHandler);
    studentProxy.eat();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，可以在项目根目录中找到&lt;code&gt;com/sun/proxy/$Proxy0.class&lt;/code&gt;文件，这个文件便是代理&lt;code&gt;Student&lt;/code&gt;生成的对象的&lt;code&gt;.class&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class $Proxy0 extends Proxy implements People {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void eat() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m3 = Class.forName(&quot;com.dengchengchao.springtest.proxy.People&quot;).getMethod(&quot;eat&quot;);
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上文件我们可以发现：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;生成的代理类继承了&lt;code&gt;Proxy&lt;/code&gt;，实现了&lt;code&gt;People&lt;/code&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也就是为什么&lt;code&gt;JDK&lt;/code&gt;代理只能代理接口，不能代理具体的类，因为&lt;code&gt;Java&lt;/code&gt;不能多继承，因此只能实现接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;由于实现的是接口，因此对于生成的代理对象&lt;code&gt;proxy&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;proxy instanceof People  //true
proxy instanceof Student //false&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这便是开始我们所遇到的问题的根源所在，&lt;code&gt;proxy&lt;/code&gt;仅仅是实现了&lt;code&gt;People&lt;/code&gt;接口，却不是继承自&lt;code&gt;Student&lt;/code&gt;类，因此无法将&lt;code&gt;proxy&lt;/code&gt;对象转换为&lt;code&gt;Student&lt;/code&gt;类型，所以才报的错。&lt;/p&gt;
&lt;p&gt;明白了这个问题，以后使用底层为&lt;code&gt;JDK&lt;/code&gt;代理的类，就不会再出错了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果觉得写得不错，欢迎扫描下面二维码关注微信公众号：逸游Java ,每天不定时发布一些有关Java进阶的文章，感谢关注&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363061/201911/1363061-20191108153402308-1399272640.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 14:31:00 +0000</pubDate>
<dc:creator>逸游Java</dc:creator>
<og:description>今天在写 的引介代理的时候，报了一个错： 大概的意思是类型转换错误。 源代码如下： 后来 了一下发现把代理方式改成 就行。 我们都知道 只能代理接口，对于非接口的类的代理，应该使用 。 因为 是通过继</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dengchengchao/p/11823687.html</dc:identifier>
</item>
<item>
<title>基于SkyWalking的分布式跟踪系统 - 异常告警 - 张坚</title>
<link>http://www.cnblogs.com/jianzh5/p/11823686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianzh5/p/11823686.html</guid>
<description>&lt;p&gt;通过前面2篇文章我们搭建了SW的基础环境，监控了微服务，能了解所有服务的运行情况。但是当出现服务响应慢，接口耗时严重时我们需要立即定位到问题，这就需要我们今天的主角--监控告警，同时此篇也是SW系列的最后一篇。&lt;/p&gt;
&lt;h2 id=&quot;ui参数&quot;&gt;UI参数&lt;/h2&gt;
&lt;p&gt;首先我们认识一下SW DashBoard上的几个关键参数，如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/990993/201911/990993-20191108223015429-1105798765.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;告警配置&quot;&gt;告警配置&lt;/h2&gt;
&lt;h3 id=&quot;告警流程&quot;&gt;告警流程&lt;/h3&gt;
&lt;p&gt;skywalking发送告警的基本原理是每隔一段时间轮询skywalking-collector收集到的链路追踪的数据，再根据所配置的告警规则（如服务响应时间、服务响应时间百分比）等，如果达到阈值则发送响应的告警信息。发送告警信息是以线程池异步的方式调用webhook接口完成，（具体的webhook接口可以使用者自行定义），从而开发者可以在指定的webhook接口中自行编写各种告警方式，钉钉告警、邮件告警等等。&lt;/p&gt;
&lt;h3 id=&quot;规则配置&quot;&gt;规则配置&lt;/h3&gt;
&lt;p&gt;告警的核心由一组规则驱动，这些规则定义在 &lt;code&gt;config/alarm-settings.yml&lt;/code&gt;，打开之后如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/990993/201911/990993-20191108223017952-84001366.png&quot; alt=&quot;1213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;告警规则的定义分为两部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;告警规则。它们定义了应该如何触发度量警报，应该考虑什么条件。&lt;/li&gt;
&lt;li&gt;[网络钩子](#Webhook}。当警告触发时，哪些服务终端需要被告知。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;告警规则主要有以下几点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Rule name。&lt;/strong&gt; 在告警信息中显示的唯一名称。必须以_rule结尾。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metrics name。&lt;/strong&gt; 也是oal脚本中的度量名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Include names。&lt;/strong&gt; 其下的实体名称都在此规则中。比如服务名，终端名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Threshold。&lt;/strong&gt; 阈值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OP。&lt;/strong&gt; 操作符, 支持 &amp;gt;, &amp;lt;, =。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Period.。&lt;/strong&gt; 多久检查一次当前的指标数据是否符合告警规则这是一个时间窗口，与后端部署环境时间相匹配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Count。&lt;/strong&gt; 在一个Period窗口中，如果values超过Threshold值（按op），达到Count值，需要发送警报。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Silence period。&lt;/strong&gt; 在时间N中触发报警后，在TN -&amp;gt; TN + period这个阶段不告警。 默认情况下，它和Period一样，这意味着相同的告警（在同一个Metrics name拥有相同的Id）在同一个Period内只会触发一次&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;webhook&quot;&gt;Webhook&lt;/h3&gt;
&lt;p&gt;SkyWalking 的告警 Webhook 要求对等方是一个 Web 容器. 告警的消息会通过 HTTP 请求进行发送, 请求方法为 POST, Content-Type 为 application/json, JSON 格式基于 List&amp;lt;org.apache.skywalking.oap.server.core.alarm.AlarmMessage, 包含以下信息.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;scopeId. 所有可用的 Scope 请查阅 &lt;code&gt;org.apache.skywalking.oap.server.core.source.DefaultScopeDefine&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;name. 目标 Scope 的实体名称.&lt;/li&gt;
&lt;li&gt;id0. Scope 实体的 ID.&lt;/li&gt;
&lt;li&gt;id1. 未使用.alarmMessage. 报警消息内容.&lt;/li&gt;
&lt;li&gt;startTime. 告警时间, 位于当前时间与 UTC 1920/1/1 之间.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[{
    &quot;scopeId&quot;: 1, 
        &quot;name&quot;: &quot;serviceA&quot;, 
    &quot;id0&quot;: 12,  
    &quot;id1&quot;: 0,  
    &quot;alarmMessage&quot;: &quot;alarmMessage xxxx&quot;,
    &quot;startTime&quot;: 1560524171000
}, {
    &quot;scopeId&quot;: 1,
        &quot;name&quot;: &quot;serviceB&quot;,
    &quot;id0&quot;: 23,
    &quot;id1&quot;: 0,
    &quot;alarmMessage&quot;: &quot;alarmMessage yyy&quot;,
    &quot;startTime&quot;: 1560524171000
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码实战&quot;&gt;代码实战&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;编写实体类用于接收sw告警消息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class SwAlarmVO {
    private int scopeId;
    private String name;
    private int id0;
    private int id1;
    private String alarmMessage;
    private long startTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写webhook接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;sw&quot;)
@Log4j2
public class AlarmController {
    @PostMapping(&quot;/alarm&quot;)
    public void alarm(@RequestBody List&amp;lt;SwAlarmVO&amp;gt; alarmList){
        log.info(&quot;skywalking alarm message:{}&quot;,alarmList);
        //todo doalarm
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改告警配置，开放webhook接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了模拟请求调用慢，我们在代码中使用&lt;code&gt;Thread.sleep(1000)&lt;/code&gt;增加接口耗时，然后等webhoook接口告警响应&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/990993/201911/990993-20191108223018327-430895773.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详细信息如下：&lt;br/&gt;&lt;code&gt;[SwAlarmVO(scopeId = 2, name = dubbo - consumer - pid: 13812 @ jianzhang11, id0 = 28, id1 = 0, alarmMessage = Response time of service instance dubbo - consumer - pid: 13812 @ jianzhang11 is more than 1000ms in 2 minutes of last 10 minutes, startTime = 1573122018755), SwAlarmVO(scopeId = 2, name = dubbo - provider2 - pid: 14108 @ jianzhang11, id0 = 25, id1 = 0, alarmMessage = Response time of service instance dubbo - provider2 - pid: 14108 @ jianzhang11 is more than 1000ms in 2 minutes of last 10 minutes, startTime = 1573122018755)]&lt;/code&gt;&lt;br/&gt;此时webhook能正常接收到sw的告警信息，后续的消息通知直接定制开发即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NjE0ODM2NA==&amp;amp;mid=2247483808&amp;amp;idx=1&amp;amp;sn=52d58ac4fb77e8b391bae6c3c8ccd688&amp;amp;chksm=cf37e243f8406b55fcfc7e0121174c94757e5725e565fd8db8cce4bcd68a43e4f4e67f61ec17&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1106gHW99XJlnLmAIMQSeKBL&amp;amp;sharer_sharetime=1573033776566&amp;amp;sharer_shareid=f4a0969410a6220c2924a1da2e3895da&amp;amp;key=20f7b87cb3d4d9a8c75744113fbbb35be19ccc1020001dd2a7abe92ba720f5ff72d10f00db85537c7dd166ae9e533310fc50c67033b942aee700340e65cb5477c03af4fb60506e05d065279030c0b779&amp;amp;ascene=1&amp;amp;uin=MTQ4ODgxOTEyOA%3D%3D&amp;amp;devicetype=Windows+10&amp;amp;version=62070152&amp;amp;lang=zh_CN&amp;amp;pass_ticket=wWkx5YQZDlmsvDcIxJhOPGfpMzhWgPVxUKAmU41A5y%2FKR8EKWAbTfxs1gsjZjBJI&quot;&gt;基于SkyWalking的分布式跟踪系统 - 环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NjE0ODM2NA==&amp;amp;mid=2247483846&amp;amp;idx=1&amp;amp;sn=f4cb5917db2b0a0bb350958bfdbd96a8&amp;amp;chksm=cf37e225f8406b33778ee9a2c490e22512ba9f0d2734f6775e4abd3b7ea649e014dc5505516e&amp;amp;scene=0&amp;amp;xtrack=1&amp;amp;key=09b6cb852691fba2749bbedc91b6ba8c5f9198234a6a5da4c07b75d6397ad195afd3ca14a5323dacbab83e9ab178f93f4dc178e92d7061d26dd57b62e5d8391a7e12a1bf985e941b8a32fbd0dfa6d575&amp;amp;ascene=1&amp;amp;uin=MTQ2MDEzMTM4MA%3D%3D&amp;amp;devicetype=Windows+10&amp;amp;version=62070158&amp;amp;lang=zh_CN&amp;amp;pass_ticket=VXdj%2BpQGMZrdj9MXmgtcIscRIauCGm1eqkmVFa%2BMFPS5yclhioVxPTb2QbuOURM7&quot;&gt;基于SkyWalking的分布式跟踪系统 - 微服务监控&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请关注个人公众号:JAVA日知录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jianzh5/1558279/t_qrcode_for_gh_1305f8d4a118_258.bmp&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 14:30:00 +0000</pubDate>
<dc:creator>张坚</dc:creator>
<og:description>通过前面2篇文章我们搭建了SW的基础环境，监控了微服务，能了解所有服务的运行情况。但是当出现服务响应慢，接口耗时严重时我们需要立即定位到问题，这就需要我们今天的主角 监控告警，同时此篇也是SW系列的最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jianzh5/p/11823686.html</dc:identifier>
</item>
<item>
<title>树状数组 复习与整理 - mzWyt</title>
<link>http://www.cnblogs.com/miserweyte/p/11823558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miserweyte/p/11823558.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/miserweyte/1543630/o_right.png&quot; alt=&quot;本文作者MiserWeyte&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rt。用&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;整理了公式。&lt;/p&gt;
&lt;p&gt;之前那篇很混乱而且咕咕咕到现在的随笔：&lt;a href=&quot;https://www.cnblogs.com/miserweyte/p/11477191.html&quot;&gt;st表、树状数组与线段树 笔记与思路整理&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一构成方式&quot;&gt;一、构成方式&lt;/h2&gt;
&lt;p&gt;树状数组是一种树状的结构（废话），但是只需要 $ O(n)$ 的空间复杂度。区间查询和单一修改时间复杂度都为 &lt;span class=&quot;math inline&quot;&gt;\(O(log\ n)\)&lt;/span&gt; ，利用差分区间修改也可以达到 &lt;span class=&quot;math inline&quot;&gt;\(O(log\ n)\)&lt;/span&gt; ，但此时不能区间查询。通过维护两个数组可以达到 &lt;span class=&quot;math inline&quot;&gt;\(O(log\ n)\)&lt;/span&gt; 的区间修改与查询。&lt;/p&gt;
&lt;p&gt;树状数组是基于一棵二叉树，为便于思想上向数组转化，这里稍微变形：（Excel绘图23333）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724537/201911/1724537-20191107115349230-1256332588.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要在一棵树上存储一个数组并且便于求和，我们可以想到让每个父节点存储其两个子节点的和。&lt;del&gt;（就决定是你啦！线段树！）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;为了达到 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt; 的空间复杂度，删去一些节点&lt;del&gt;（放弃线段树）&lt;/del&gt;后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724537/201911/1724537-20191107140338897-803817758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标有序号的节点为树状数组，序号从左向右增大。&lt;/p&gt;
&lt;h2 id=&quot;二运算规律&quot;&gt;二、运算规律&lt;/h2&gt;
&lt;p&gt;观察上一节的图可得，每个树状数组的节点都储存了&lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt;个原数组节点的数据（&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;为节点深度）。也就是说，在上面的图中：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;t[1] = a[1];
t[2] = a[1] + a[2];
t[3] = a[3];
t[4] = a[1] + a[2] + a[3] + a[4];
t[5] = a[5];
t[6] = a[5] + a[6];
t[7] = a[7];
t[8] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以说，这棵树的&lt;del&gt;（不是我自己推出来的）&lt;/del&gt;规律是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[t[i] = a[i - 2^k + 1] + a[i - 2^k + 2] + ... + a[i]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;的二进制中从最低位到高位连续零的长度&lt;/p&gt;
&lt;p&gt;将&lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt;称为&lt;span class=&quot;math inline&quot;&gt;\(lowbit(i)\)&lt;/span&gt;，则代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void add(int pos, int val){  //将节点pos增加val
    for(int i=pos; i&amp;lt;=n; i+=lowbit(i)){
        t[i] += val;
    }
}
int ask(int pos){  //求节点pos前缀和
    int ans = 0;
    for(int i=pos; i&amp;gt;0; i-=lowbit(i)){
        ans += t[i];
    }
    return ans;
}
int query_sum(int l, int r){  //利用前缀和求[l, r]总和
    return ask(r) - ask(l);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了，怎么求这个 &lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt; 呢？&lt;/p&gt;
&lt;p&gt;有一个巧妙的&lt;del&gt;（我自己也没推出来的）&lt;/del&gt;算法是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[lowbit(x) = x \&amp;amp; (-x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;抄一段证明如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 &lt;span class=&quot;math inline&quot;&gt;\(x\&amp;amp;(-x)\)&lt;/span&gt;有&lt;br/&gt;● 当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;时，即 &lt;span class=&quot;math inline&quot;&gt;\(0 \&amp;amp; 0\)&lt;/span&gt;，结果为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;；//因此实际运算的时候如果真的出现了&lt;span class=&quot;math inline&quot;&gt;\(lowbit(0)\)&lt;/span&gt;会卡死，要从&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;开始存储&lt;br/&gt;●当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为奇数时，最后一个比特位为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，取反加&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;没有进位，故&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(-x\)&lt;/span&gt;除最后一位外前面的位正好相反，按位与结果为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。结果为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。&lt;br/&gt;●当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为偶数，且为&lt;span class=&quot;math inline&quot;&gt;\(2^m\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的二进制表示中只有一位是&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;（从右往左的第&lt;span class=&quot;math inline&quot;&gt;\(m+1\)&lt;/span&gt;位），其右边有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;位&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，故&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;取反加&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;后，从右到左第有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，第&lt;span class=&quot;math inline&quot;&gt;\(m+1\)&lt;/span&gt;位及其左边全是&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。这样，&lt;span class=&quot;math inline&quot;&gt;\(x\&amp;amp; (-x)\)&lt;/span&gt; 得到的就是&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;。&lt;br/&gt;●当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为偶数，却不为&lt;span class=&quot;math inline&quot;&gt;\(2^m\)&lt;/span&gt;的形式时，可以写作&lt;span class=&quot;math inline&quot;&gt;\(x= y \times (2^k)\)&lt;/span&gt; 。其中，&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;的最低位为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。实际上就是把&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;用一个奇数左移&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;位来表示。这时，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的二进制表示最右边有&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，从右往左第&lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt;位为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。当对x取反时，最右边的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;位&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;变成&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，第&lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt;位变为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;；再加&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，最右边的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;位就又变成了&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，第&lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt;位因为进位的关系变成了&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;。左边的位因为没有进位，正好和&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;原来对应的位上的值相反。二者按位与，得到：第&lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt;位上为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，左边右边都为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。结果为&lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt;。&lt;br/&gt;总结一下：&lt;span class=&quot;math inline&quot;&gt;\(x\&amp;amp;(-x)\)&lt;/span&gt;，当&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;时结果为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为奇数时，结果为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为偶数时，结果为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;中&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;的最大次方的因子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三具体操作&quot;&gt;三、具体操作&lt;/h2&gt;
&lt;h3 id=&quot;区间查询单点修改&quot;&gt;1.区间查询单点修改&lt;/h3&gt;
&lt;p&gt;如上文所说，使用循环维护一条树上路径即可。&lt;/p&gt;
&lt;p&gt;模板题： &lt;a href=&quot;https://www.luogu.org/problem/P3374&quot;&gt;洛谷 P3374&lt;/a&gt;&lt;/p&gt;
&lt;details readability=&quot;23&quot;&gt;查看源码
&lt;pre&gt;
&lt;code&gt;#include &quot;bits/stdc++.h&quot;
    using namespace std;
    int a[500010], t[500010];
    int n, m;
    int lowbit(int x){
        return x &amp;amp; (-x);
    }
    void add(int pos, int val){
        for(int i=pos; i&amp;lt;=n; i+=lowbit(i)){
            t[i] += val;
        }
    }
    int query_node(int pos){
        int ans = 0;
        for(int i=pos; i&amp;gt;0; i-=lowbit(i)){
            ans += t[i];
        }
        return ans;
    }
    int query_range(int l, int r){
        return query_node(r) - query_node(l-1);
    }
    int main(){
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        int opt, pos, l, r, num;
        for(int i=1; i&amp;lt;=n; i++){
            scanf(&quot;%d&quot;, &amp;amp;a[i]);
            add_node(i, a[i]);
        }
        while(m--){
            scanf(&quot;%d&quot;, &amp;amp;opt);
            if(opt == 1){
                scanf(&quot;%d%d&quot;, &amp;amp;pos, &amp;amp;num); 
                add_node(pos, num);
            }
            if(opt == 2){
                scanf(&quot;%d%d&quot;, &amp;amp;l, &amp;amp;r);
                printf(&quot;%d\n&quot;, query_range(l, r));
            }
        }
        return 0;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;h3 id=&quot;单点查询区间修改&quot;&gt;2.单点查询区间修改&lt;/h3&gt;
&lt;p&gt;利用差分的思想，设数组&lt;span class=&quot;math inline&quot;&gt;\(b[i]=a[i]-a[i-1]\)&lt;/span&gt;，用树状数组&lt;span class=&quot;math inline&quot;&gt;\(t[~]\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(b[~]\)&lt;/span&gt;。(这里默认&lt;span class=&quot;math inline&quot;&gt;\(a[0]=b[0]=0\)&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;来一组样例：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a[~]=\{1,~5,~4,~2,~3,~1,~2,~5\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(b[\ ] = \{ 1,\ 4,\ -1,\ -2,\ 1,\ -2,\ 1,\ 3\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;处理区间&lt;span class=&quot;math inline&quot;&gt;\([1,\ 5]\)&lt;/span&gt;，将其中所有元素+1：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a[~]=\{1,~{\color{red}{6,~5,~3,~4,~2,}}~2,~5\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(b[\ ] = \{ 1,\ {\color{red}5,}\ -1,\ -2,\ 1,\ -2,\ {\color{red}0,}\ 3 \}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到，只有 &lt;span class=&quot;math inline&quot;&gt;\(b[1]\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(b[6]\)&lt;/span&gt; 发生了变化。（即更改区间&lt;span class=&quot;math inline&quot;&gt;\([l, r]\)&lt;/span&gt;时的&lt;strong&gt;节点&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;与节点&lt;span class=&quot;math inline&quot;&gt;\(r+1\)&lt;/span&gt;&lt;/strong&gt;）因此，以 &lt;span class=&quot;math inline&quot;&gt;\(b[\ ]\)&lt;/span&gt; 为原数组的 &lt;span class=&quot;math inline&quot;&gt;\(t[\ ]\)&lt;/span&gt; 只需要执行两次 &lt;span class=&quot;math inline&quot;&gt;\(add()\)&lt;/span&gt; 即可。但是，在查询 &lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt; 的时候就需要查询 &lt;span class=&quot;math inline&quot;&gt;\(b[1...i]\)&lt;/span&gt; 之和，在 &lt;span class=&quot;math inline&quot;&gt;\(log\ n\)&lt;/span&gt; 时间里只能查询单个节点的值。&lt;/p&gt;
&lt;p&gt;模板题：&lt;a href=&quot;https://www.luogu.org/problem/P3368&quot;&gt;洛谷 P3368&lt;/a&gt;&lt;/p&gt;
&lt;details readability=&quot;26&quot;&gt;查看源码
&lt;pre&gt;
&lt;code&gt;#include &quot;bits/stdc++.h&quot;
using namespace std;
int a[500010], t[500010];
int n, m;
int lowbit(int x){
    return x &amp;amp; (-x);
}
void add_node(int pos, int val){
    for(int i=pos; i&amp;lt;=n; i+=lowbit(i)){
        t[i] += val;
    }
}
void add_range(int l, int r, int val){
    add_node(l, val);
    add_node(r+1, -val);
}
int query_node(int pos){
    int ans = 0;
    for(int i=pos; i&amp;gt;0; i-=lowbit(i)){
        ans += t[i];
    }
    return ans;
}
int main(){
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    int opt, pos, l, r, num;
    for(int i=1; i&amp;lt;=n; i++){
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
        add_node(i, a[i] - a[i-1]);
    }
    while(m--){
        scanf(&quot;%d&quot;, &amp;amp;opt);
        if(opt == 1){
            scanf(&quot;%d%d%d&quot;, &amp;amp;l, &amp;amp;r, &amp;amp;num);
            add_range(l, r, num);
        }
        if(opt == 2){
            scanf(&quot;%d&quot;, &amp;amp;pos);
            printf(&quot;%d\n&quot;, query_node(pos));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;h3 id=&quot;区间查询区间修改&quot;&gt;3.区间查询区间修改&lt;/h3&gt;
&lt;p&gt;关于区间查询与区间修改的操作，考虑维护两个树状数组来优化差分：&lt;/p&gt;
&lt;p&gt;（本段参考了&lt;a href=&quot;https://www.cnblogs.com/xenny/&quot;&gt;xenny的博客&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^{n}a[i] =\sum_{i=1}^n \sum_{j=1}^it[j]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*}&amp;amp; a[1] + a[2] + ... + a[n]\\ = ~&amp;amp;(t[1]) + (t[1] + t[2]) + ... + (t[1] + t[2] + ... + t[n]) \\ = ~&amp;amp;n * t[1] + (n-1) * t[2] + ... + t[n]\\ =~&amp;amp; n * (t[1] + t[2] + ... + t[n]) - (0 * t[1] + 1 * t[2] + ... + (n - 1) * t[n])\end{align*} \]&lt;/span&gt;&lt;br/&gt;所以上式可以变为&lt;span class=&quot;math inline&quot;&gt;\(∑^n_{i = 1}a[i] = n∑^n_{i = 1}t[i] - ∑^n_{i = 1}( t[i] * (i - 1) )\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此，实现了区间查询与区间修改之后可以实现线段树的某些功能。但这种实现方式与线段树还有所差异，详情见下一节“优势与局限”。&lt;/p&gt;
&lt;p&gt;模板题：&lt;a href=&quot;https://www.luogu.org/problem/P3372&quot;&gt;洛谷 P3372&lt;/a&gt; （线段树模板1）&lt;/p&gt;
&lt;details readability=&quot;29&quot;&gt;查看源码
&lt;pre&gt;
&lt;code&gt;#include &quot;bits/stdc++.h&quot;
using namespace std;
typedef long long ll;
ll a[500010], t1[500010], t2[500010];
int n, m;
int lowbit(int x){
    return x &amp;amp; (-x);
}
void add_node(int pos, ll val){
    for(int i=pos; i&amp;lt;=n; i+=lowbit(i)){
        t1[i] += val;
        t2[i] += val * (pos-1);
    }
}
void add_range(int l, int r, int val){
    add_node(l, val);
    add_node(r+1, -val);
}
ll quary_node(int pos){
    ll ans = 0;
    for(int i=pos; i&amp;gt;0; i-=lowbit(i)){
        ans += pos * t1[i] - t2[i];
    }
    return ans;
}
ll quary_range(int l, int r){
    return quary_node(r) - quary_node(l-1);
}
int main(){
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    int opt, pos, l, r;
    ll num;
    for(int i=1; i&amp;lt;=n; i++){
        scanf(&quot;%d&quot;, &amp;amp;a[i]);
        add_node(i, a[i] - a[i-1]);
    }
    while(m--){
        scanf(&quot;%d&quot;, &amp;amp;opt);
        if(opt == 1){
            scanf(&quot;%d%d%lld&quot;, &amp;amp;l, &amp;amp;r, &amp;amp;num);
            add_range(l, r, num);
        }
        if(opt == 2){
            scanf(&quot;%d %d&quot;, &amp;amp;l, &amp;amp;r);
            printf(&quot;%lld\n&quot;, quary_range(l, r));
        }
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;h2 id=&quot;四优势与局限&quot;&gt;四、优势与局限&lt;/h2&gt;
&lt;p&gt;很显然，在相同的实现下（区间查询、区间修改），树状数组的码量要小于线段树等，运行时的常数与占用空间也较小。&lt;/p&gt;
&lt;p&gt;但实际上，树状数组只能维护前缀操作和（前缀和，前缀积，前缀最大最小），而线段树可以维护区间操作和。&lt;/p&gt;
&lt;p&gt;使用树状数组来“维护区间操作和”的实现，本质上是取右端点的前缀和，然后对左端点左边的前缀和的逆元做一次操作。因此，如果不存在逆元的操作（乘法（P.s.:模不为质数）、区间最值等）就无法用树状数组完成。&lt;/p&gt;
&lt;p&gt;此段参考资料：&lt;a href=&quot;https://www.zhihu.com/question/54746883&quot;&gt;关于线段树(Segment tree)和树状数组(BIT)的区别？-知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Nov 2019 14:02:00 +0000</pubDate>
<dc:creator>mzWyt</dc:creator>
<og:description>rt。用$\LaTeX$整理了公式。 之前那篇很混乱而且咕咕咕到现在的随笔： 'st表、树状数组与线段树 笔记与思路整理' 一、构成方式 树状数组是一种树状的结构（废话），但是只需要 $ O(n)$</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miserweyte/p/11823558.html</dc:identifier>
</item>
</channel>
</rss>