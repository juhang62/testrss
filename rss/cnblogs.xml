<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core Web API中使用Swagger - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/11130209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/11130209.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;本节导航&quot;&gt;本节导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Swagger介绍&lt;/li&gt;
&lt;li&gt;在ASP.NET CORE 中的使用swagger&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;  在软件开发中,管理和测试API是一件重要而富有挑战性的工作。在我之前的文章&lt;a href=&quot;http://www.zhikestreet.com/Home/Detail/6/&quot;&gt;《研发团队,请管好你的API文档》&lt;/a&gt;也专门阐述了通过文档管理工具,来保证API文档和代码的一致性,这样更加有助于团队的协作。&lt;/p&gt;
&lt;p&gt;  以往我们总是通过第三方平台工具来管理我们的API文档,如&lt;a href=&quot;https://www.eolinker.com/#/&quot;&gt;eolinker&lt;/a&gt;。在测试方面,我们也会依赖fiddler,PostMan这样的工具。&lt;/p&gt;
&lt;p&gt;  Swagger兼具了API文档管理和测试的功能,而且保证了代码和文档的一致性。它提供了无需任何实现逻辑的RESTfulAPI的UI表示。它允许用户在没有任何代码访问的情况下了解服务的功能，并减少创建服务文档的时间。&lt;/p&gt;
&lt;h3 id=&quot;swagger介绍&quot;&gt;1 Swagger介绍&lt;/h3&gt;
&lt;p&gt;  Swagger兼具了API文档管理和测试的功能,而且保证了代码和文档的一致性。它提供了无需任何实现逻辑的RESTfulAPI的UI表示。它允许用户在没有任何代码访问的情况下了解服务的功能，并减少创建服务文档的时间。&lt;/p&gt;
&lt;p&gt;  swagger使用swagger工具基于我们编写的服务代码生成的swagger.json文件来生成文档管理界面。此文件描述服务的功能，即服务支持多少方法，并提供有关方法参数的信息。使用这个文件，SwaggerUI生成客户机代码。下面是swagger.json文件的一个示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;swagger&quot;: &quot;2.0&quot;,
    &quot;info&quot;: {
        &quot;version&quot;: &quot;1.0&quot;,
        &quot;title&quot;: &quot;My Demo API&quot;
    },
    &quot;paths&quot;: {
        &quot;/api/Values&quot;: {
            &quot;get&quot;: {
                &quot;tags&quot;: [&quot;Values&quot;],
                &quot;summary&quot;: &quot;Get values&quot;,
                &quot;operationId&quot;: &quot;Get&quot;,
                &quot;consumes&quot;: [],
                &quot;produces&quot;: [&quot;text/plain&quot;, &quot;application/json&quot;, &quot;text/json&quot;],
                &quot;parameters&quot;: [],
                &quot;responses&quot;: {
                    &quot;200&quot;: {
                        &quot;description&quot;: &quot;Success&quot;,
                        &quot;schema&quot;: {
                            &quot;uniqueItems&quot;: false,
                            &quot;type&quot;: &quot;array&quot;,
                            &quot;items&quot;: {
                                &quot;type&quot;: &quot;string&quot;
                            }
                        }
                    }
                }
            },
            &quot;post&quot;: {
                &quot;tags&quot;: [&quot;Values&quot;],
                &quot;operationId&quot;: &quot;Post&quot;,
                &quot;consumes&quot;: [&quot;application/json-patch+json&quot;, &quot;application/json&quot;, &quot;text/json&quot;, &quot;application/*+json&quot;],
                &quot;produces&quot;: [],
                &quot;parameters&quot;: [{
                    &quot;name&quot;: &quot;value&quot;,
                    &quot;in&quot;: &quot;body&quot;,
                    &quot;required&quot;: false,
                    &quot;schema&quot;: {
                        &quot;type&quot;: &quot;string&quot;
                    }
                }],
                &quot;responses&quot;: {
                    &quot;200&quot;: {
                        &quot;description&quot;: &quot;Success&quot;
                    }
                }
            }
        }
    },
    &quot;definitions&quot;: {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在APS.NET Core Web API 中，我们可以用&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot;&gt;Swashbuckle.AspNetCore&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/RicoSuter/NSwag&quot;&gt;NSwag&lt;/a&gt;这两个包来实现Swagger,而且二者都是github上开源的。此外，nswag还提供了生成typescript客户端代码的方法以及用于API的服务代码。&lt;/p&gt;
&lt;h3 id=&quot;tpl&quot;&gt;1.2 TPL&lt;/h3&gt;
&lt;p&gt;  任务并行库（&lt;strong&gt;TPL&lt;/strong&gt;）是System.Threading和System.Threading.Tasks命名空间中的一组公共类型和API。&lt;/p&gt;
&lt;p&gt;  TPL动态地扩展并发度，以最有效地使用所有可用的处理器。通过使用TPL，您可以最大限度地提高代码的性能，同时专注于您的代码的业务实现。&lt;/p&gt;
&lt;p&gt;  从.NET Framework 4开始，TPL是编写多线程和并行代码的首选方式。&lt;/p&gt;
&lt;h3 id=&quot;在asp.net-core-中的使用swagger&quot;&gt;2 在ASP.NET CORE 中的使用swagger&lt;/h3&gt;
&lt;p&gt;  这里以Swashbuckle.AspNetCore来实现。&lt;/p&gt;
&lt;p&gt;  以下是在ASP.net Core Web API中配置Swagger的步骤:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 安装Swashbuckle.AspNetCore&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt; Install-Package Swashbuckle.AspNetCore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. 配置swagger中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  要将swagger middle添加到请求管道，需要在startup类的configureService方法中添加swaggergen方法。在这里，我们可以定义一个或多个swagger XML文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Startup.cs&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddSwaggerGen(c =&amp;gt;
            {
                c.SwaggerDoc(&quot;v1.0&quot;, new Info { Title = &quot;My Demo API&quot;, Version = &quot;1.0&quot; });
                c.IncludeXmlComments(System.IO.Path.Combine(System.AppContext.BaseDirectory, &quot;ZhiKeCore.API.xml&quot;));
            });
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如果要启用这个中间件，我们还需要在startup类的configure方法中调用useswagger方法。在这里，我们还需要配置swagerendpoint来生成UI。useswagegrui将添加一个静态文件中间件来加载swager.json文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseMvc();

            app.UseSwagger();
            app.UseSwaggerUI(c =&amp;gt;
            {
                c.SwaggerEndpoint(&quot;/swagger/v1.0/swagger.json&quot;, &quot;My Demo API (V 1.0)&quot;);
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  以上是配置swagger的基本步骤,如果我们想使用Visual Studio在开发环境中启动Swagger，还需要做一点设置。选择&lt;strong&gt;项目-属性-Debug&lt;/strong&gt;,修改启动浏览器(Launch Browser)的值为swagger。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%90%AF%E5%8A%A8Swagger.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  当我们启动程序以后,可以看到如下界面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/swaggerUI.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  正如我们在这里看到的，它对每个HTTP动词使用不同的颜色代码。当我们单击任何操作方法时，它将询问参数详细信息，当我们单击“非常”按钮时，它将向Web API发送请求。&lt;/p&gt;
&lt;p&gt;  在测试我们的WebAPI时，Swagger只需要最少的配置即可。&lt;/p&gt;
&lt;p&gt;  那么，如果我们想要在UI上显示代码注释应该怎么办呢？&lt;/p&gt;
&lt;p&gt;  在.NET Core中，我们可以通过在项目属性窗口的“构建”选项卡下设置“XML文档文件”属性来获取XML注释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/XML%20comments.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  默认情况下，Swagger UI不显示此文档。我们需要传递包含exmlcomments的路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
       // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddSwaggerGen(c =&amp;gt;
            {
                c.SwaggerDoc(&quot;v1.0&quot;, new Info { Title = &quot;My Demo API&quot;, Version = &quot;1.0&quot; });
                c.IncludeXmlComments(System.IO.Path.Combine(System.AppContext.BaseDirectory, &quot;ZhiKeCore.API.xml&quot;));
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/comments.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注&lt;/strong&gt;&lt;br/&gt;  请关注微信公众号&lt;strong&gt;智客坊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/2019zhikefang.jpg&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 00:40:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<og:description>本节导航 Swagger介绍 在ASP.NET CORE 中的使用swagger   在软件开发中,管理和测试API是一件重要而富有挑战性的工作。在我之前的文章 '《研发团队,请管</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lucky_hu/p/11130209.html</dc:identifier>
</item>
<item>
<title>寻找图的强连通分量：tarjan算法简单理解 - Asterism</title>
<link>http://www.cnblogs.com/Asterism12/p/11129773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Asterism12/p/11129773.html</guid>
<description>&lt;p&gt;1、简介&lt;br/&gt;tarjan是一种使用深度优先遍历（DFS）来寻找有向图强连通分量的一种算法。&lt;/p&gt;
&lt;p&gt;2、知识准备&lt;br/&gt;栈、有向图、强连通分量、DFS。&lt;/p&gt;
&lt;p&gt;3、快速理解tarjan算法的运行机制&lt;br/&gt;提到DFS，能想到的是通过栈来储存沿途的点，可以找到所有的环。环本身就是联通的，所以环对于强连通分量来说环已经很接近最终答案了。要把找环变成找强连通管分量还要考虑：&lt;br/&gt;a.在环外是不是有其他环在这个强连通分量内（极大性）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891008/201907/891008-20190703232228663-1112002072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（会被认为是2个环）&lt;/p&gt;
&lt;p&gt;b.一些不能构成环的点无法被考虑到，而他们本身就是强连通分量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891008/201907/891008-20190703232321624-407276973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2不被认为是一个强连通分量）&lt;/p&gt;

&lt;p&gt;所以Tarjan算法除了栈还引入了2个数组，分别是：&lt;br/&gt;DFN[N]//节点的时间戳，用来标记节点访问的先后顺序（以及是否被访问过）&lt;br/&gt;Low[N]//当前“环”里最先被访问到的节点，相当于当前这个强连通分量里的根&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Tarjan的流程是：&lt;br/&gt;DFS，每遇到一个未被访问过的节点就初始化DFN[i]=Low[i]=index++；&lt;br/&gt;如果找到了环，就在遍历中用Low数组向上传递根的时间戳，直到找到一个点他的时间戳和根的时间戳一致，即DFN[i]=Low[i]，这就说明这个点就是根。此时，栈内的所有在根后面的点（包括根）就组成一个强连通分量。&lt;/p&gt;
&lt;p&gt;4、伪代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
index=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
tarjan(u)
{
    DFN[u]&lt;/span&gt;=low[u]=index++&lt;span&gt;;
    u入栈;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(遍历每条边(u,v))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(v未被访问)
        {
            tarjan(v);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DFS&lt;/span&gt;
            low[u]=min(low(u),DFN(v));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将下方的时间戳向上传递&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(v在栈内)
        {
            low[u]&lt;/span&gt;=min(low[u],DFN(v));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到环，比较当前保存的根的时间戳和v的时间戳，取较早的那个作为根&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(DFN(u)==&lt;span&gt;low[u])
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回到了根节点，此时栈内从u往后的节点都是该强连通分量的节点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到了强连通分量，逐个退栈，输出&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;5、进一步说明&lt;br/&gt;a.对于问题a，为什么能找到强连通分量内其他的环？&lt;br/&gt;DFS的问题在于，找到了环立即处理而不考虑其他环；Tarjan算法把输出交给根节点处理，在到根节点之前，算法已经遍历的根节点下的所有节点，自然也把所有环放入了栈。&lt;br/&gt;b.对于问题b，为什么考虑到了不能构成环的那些节点？&lt;br/&gt;对于这些节点，DFN(u)==low[u]，相当于他们本身就是强连通分量的根节点。&lt;/p&gt;
&lt;p&gt;6、延伸阅读&lt;br/&gt;如果您仍然有疑问，可以参考https://blog.csdn.net/qq_34374664/article/details/77488976&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 00:37:00 +0000</pubDate>
<dc:creator>Asterism</dc:creator>
<og:description>1、简介tarjan是一种使用深度优先遍历（DFS）来寻找有向图强连通分量的一种算法。 2、知识准备栈、有向图、强连通分量、DFS。 3、快速理解tarjan算法的运行机制提到DFS，能想到的是通过栈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Asterism12/p/11129773.html</dc:identifier>
</item>
<item>
<title>Spring Boot2从入门到实战：统一异常处理 - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11130199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11130199.html</guid>
<description>&lt;p&gt;都说管理的精髓就是“制度管人，流程管事”。而所谓流程，就是对一些日常工作环节、方式方法、次序等进行标准化、规范化。且不论精不精髓，在技术团队中，对一些通用场景，统一规范是必要的，只有步调一致，才能高效向前。如前后端交互协议，如本文探讨的异常处理。&lt;/p&gt;

&lt;h3 id=&quot;1-Spring-Mvc中的异常处理&quot;&gt;1. Spring Mvc中的异常处理&lt;/h3&gt;
&lt;p&gt;在spring mvc中，跟异常处理的相关类大致如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/springmvcexresolver.png&quot; alt=&quot;springmvn异常处理类&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图中，spring mvc中处理异常的类（包括在请求映射时与请求处理过程中抛出的异常），都是 HandlerExceptionResolver 接口的实现，并且都实现了 Ordered 接口。与拦截器链类似，如果容器中存在多个实现了 HandlerExceptionResolver 接口的异常处理类，则它们的 resolveException 方法会被依次调用，顺序由order决定，值越小的先执行，只要其中一个调用返回不是null，则后续的异常处理将不再执行。&lt;/p&gt;
&lt;p&gt;各实现类简单介绍如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DefaultHandlerExceptionResolver&lt;/strong&gt;： 这个是默认实现，处理Spring定义的各种标准异常，将其转换为对应的Http Status Code，具体处理的异常参考 doResolveException 方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ResponseStatusExceptionResolver&lt;/strong&gt;：用来支持@ResponseStatus注解使用的实现，如果自定义的异常通过@ResponseStatus注解进行了修饰，并且容器中存在ResponseStatusExceptionResolver的bean，则自定义异常抛出时会被该bean进行处理，返回注解定义的Http Status Code及内容给客户端&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExceptionHandlerExceptionResolver&lt;/strong&gt;：用来支持@ExceptionHandler注解使用的实现，使用该注解修饰的方法来处理对应的异常。不过该注解的作用范围只在controller类，如果需要全局处理，则需要配合@ControllerAdvice注解使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SimpleMappingExceptionResolver&lt;/strong&gt;：将异常映射为视图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HandlerExceptionResolverComposite&lt;/strong&gt;：就是各类实现的组合，依次执行，只要其中一个处理返回不为null，则不再处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为本文主要是对spring boot如何对异常统一处理进行探讨，所以以上只对各实现做了基本介绍，更加详细的内容可查阅相关文档或后续再补上。&lt;/p&gt;
&lt;h3 id=&quot;2-Spring-Boot中如何统一异常处理&quot;&gt;2. Spring Boot中如何统一异常处理&lt;/h3&gt;
&lt;p&gt;通过第一部分介绍，可以使用@ExceptionHandler + @ControllerAdvice 组合的方式来实现异常的全局统一处理。对于REST服务来说，spring mvc提供了一个抽象类 ResponseEntityExceptionHandler， 该类类似于上面介绍的 DefaultHandlerExceptionResolver，对一些标准的异常进行了处理，但不是返回 ModelAndView对象， 而是返回 ResponseEntity对象。故我们可以基于该类来实现REST服务异常的统一处理&lt;br/&gt;定义异常处理类 BaseWebApplicationExceptionHandler 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseWebApplicationExceptionHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ResponseEntityExceptionHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseWebApplicationExceptionHandler(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.includeStackTrace =&lt;span&gt; includeStackTrace;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());

    @ExceptionHandler(BizException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;Object&amp;gt;&lt;span&gt; handleBizException(BizException ex) {
        logger.warn(&lt;/span&gt;&quot;catch biz exception: &quot; +&lt;span&gt; ex.toString(), ex.getCause());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.asResponseEntity(HttpStatus.valueOf(ex.getHttpStatus()), ex.getErrorCode(), ex.getErrorMessage(), ex);
    }

    @ExceptionHandler({IllegalArgumentException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, IllegalStateException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;Object&amp;gt;&lt;span&gt; handleIllegalArgumentException(Exception ex) {
        logger.warn(&lt;/span&gt;&quot;catch illegal exception.&quot;&lt;span&gt;, ex);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.asResponseEntity(HttpStatus.BAD_REQUEST, HttpStatus.BAD_REQUEST.name().toLowerCase(), ex.getMessage(), ex);
    }

    @ExceptionHandler(Exception.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;Object&amp;gt;&lt;span&gt; handleException(Exception ex) {
        logger.error(&lt;/span&gt;&quot;catch exception.&quot;&lt;span&gt;, ex);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.asResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR, HttpStatus.INTERNAL_SERVER_ERROR.name().toLowerCase(), ExceptionConstants.INNER_SERVER_ERROR_MSG, ex);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ResponseEntity&amp;lt;Object&amp;gt;&lt;span&gt; handleExceptionInternal(
            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
        }
        logger.warn(&lt;/span&gt;&quot;catch uncustom exception.&quot;&lt;span&gt;, ex);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.asResponseEntity(status, status.name().toLowerCase(), ex.getMessage(), ex);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ResponseEntity&amp;lt;Object&amp;gt;&lt;span&gt; asResponseEntity(HttpStatus status, String errorCode, String errorMessage, Exception ex) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; data = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
        data.put(BizException.ERROR_CODE, errorCode);
        data.put(BizException.ERROR_MESSAGE, errorMessage);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否包含异常的stack trace&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(includeStackTrace){
            addStackTrace(data, ex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;&amp;gt;&lt;span&gt;(data, status);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addStackTrace(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; errorAttributes, Throwable error) {
        StringWriter stackTrace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter();
        error.printStackTrace(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintWriter(stackTrace));
        stackTrace.flush();
        errorAttributes.put(BizException.ERROR_TRACE, stackTrace.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里有几点： &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义了一个includeStackTrace变量，来控制是否输出异常栈信息&lt;/li&gt;
&lt;li&gt;自定义了一个异常类BizException，表示可预知的业务异常，并对它提供了处理方法，见handleBizException方法&lt;/li&gt;
&lt;li&gt;对其它未预知异常，用Exception类型进行最后处理，见handleException方法&lt;/li&gt;
&lt;li&gt;重写了超类的handleExceptionInternal方法，统一响应内容的字段与格式&lt;/li&gt;
&lt;li&gt;针对REST服务，使用的是@RestControllerAdvice注解，而不是@ControllerAdvice&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;BaseWebApplicationExceptionHandler是通过增强的方式对controller抛出的异常做了统一处理，那如果请求都没有到达controller怎么办，比如在过滤器那边就抛异常了，Spring Boot其实对错误的处理做了一些自动化配置，参考ErrorMvcAutoConfiguration类，具体这里不详述，只提出方案——自定义ErrorAttributes实现，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseErrorAttributes &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultErrorAttributes {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getErrorAttributes(WebRequest webRequest, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; errorAttributes = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
        addStatus(errorAttributes, webRequest);
        addErrorDetails(errorAttributes, webRequest, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.includeStackTrace);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; errorAttributes;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上只列出了主要部分，具体实现可参考源码。这里同样定义了includeStackTrace来控制是否包含异常栈信息。 &lt;/p&gt;
&lt;p&gt;最后，将以上两个实现通过配置文件注入容器，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({Servlet.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, DispatcherServlet.&lt;span&gt;class&lt;/span&gt;, WebMvcConfigurer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@ConditionalOnMissingBean(ResponseEntityExceptionHandler.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@AutoConfigureBefore(ErrorMvcAutoConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionHandlerAutoConfiguration {
    @Profile({&lt;/span&gt;&quot;test&quot;, &quot;formal&quot;, &quot;prod&quot;&lt;span&gt;})
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseEntityExceptionHandler defaultGlobalExceptionHandler() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试、正式环境，不输出异常的stack trace&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseWebApplicationExceptionHandler(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    @Profile({&lt;/span&gt;&quot;default&quot;,&quot;local&quot;,&quot;dev&quot;&lt;span&gt;})
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseEntityExceptionHandler devGlobalExceptionHandler() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地、开发环境，输出异常的stack trace&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseWebApplicationExceptionHandler(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    @Profile({&lt;/span&gt;&quot;test&quot;, &quot;formal&quot;, &quot;prod&quot;&lt;span&gt;})
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ErrorAttributes basicErrorAttributes() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试、正式环境，不输出异常的stack trace&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseErrorAttributes(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    @Profile({&lt;/span&gt;&quot;default&quot;,&quot;local&quot;,&quot;dev&quot;&lt;span&gt;})
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ErrorAttributes devBasicErrorAttributes() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地、开发环境，输出异常的stack trace&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseErrorAttributes(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面的@Profile主要是控制针对不同环境，输出不同的响应内容。以上配置的意思是在profile为default、local、dev时，响应内容中包含异常栈信息；profile为test、formal、prod时，响应内容不包含异常栈信息。这么做的好处是，开发阶段，当前端联调时，如果出错，可直接从响应内容中看到异常栈，方便服务端开发人员快速定位问题，而测试、生产环境， 就不要返回异常栈信息了。&lt;/span&gt; &lt;/p&gt;
&lt;h3 id=&quot;3-基于Spring-Boot的异常处理规范&quot;&gt;3. 基于Spring Boot的异常处理规范&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;异常的表示形式&lt;br/&gt;异常一般可通过自定义异常类，或定义异常的信息，比如code，message之类，然后通过一个统一的异常类进行封装。如果每一种异常都定义一个异常类，则会造成异常类过多，所以实践开发中我一般倾向于后者。&lt;br/&gt;可以定义一个接口，该接口主要是方便后面的异常处理工具类实现&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BaseErrors {
    String getCode();

    String getMsg();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;然后定义一个枚举，实现该接口，在该枚举中定义异常信息，如&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; ErrorCodeEnum &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BaseErrors {
    qrcode_existed(&lt;/span&gt;&quot;该公众号下已存在同名二维码&quot;&lt;span&gt;),
    authorizer_notexist(&lt;/span&gt;&quot;公众号不存在&quot;&lt;span&gt;),
   
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String msg;
  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ErrorCodeEnum(String msg) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; msg;
    }
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name();
    }
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMsg() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;封装异常处理 &lt;br/&gt;分场景定义了ClientSideException，ServerSideException，UnauthorizedException，ForbiddenException异常，分别表示客户端异常（400），服务端异常（500），未授权异常（401），禁止访问异常（403），如ClientSideException定义&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientSideException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BizException {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;E &lt;span&gt;extends&lt;/span&gt; Enum&amp;lt;E&amp;gt; &amp;amp; BaseErrors&amp;gt;&lt;span&gt; ClientSideException(E exceptionCode, Throwable cause) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(HttpStatus.BAD_REQUEST, exceptionCode, cause);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;E &lt;span&gt;extends&lt;/span&gt; Enum&amp;lt;E&amp;gt; &amp;amp; BaseErrors&amp;gt;&lt;span&gt; ClientSideException(E exceptionCode) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(HttpStatus.BAD_REQUEST, exceptionCode, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且提供一个异常工具类ExceptionUtil，方便不同场景使用，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;rethrowClientSideException：抛出ClientSideException，将以status code 400返回客户端。由客户端引起的异常调用该方法，如参数校验失败。&lt;/li&gt;
&lt;li&gt;rethrowUnauthorizedException： 抛出UnauthorizedException，将以status code 401返回客户端。访问未授权时调用，如token校验失败等。&lt;/li&gt;
&lt;li&gt;rethrowForbiddenException： 抛出ForbidenException，将以status code 403返回客户端。访问被禁止时调用，如用户被禁用等。&lt;/li&gt;
&lt;li&gt;rethrowServerSideException： 抛出ServerSideException，将以status code 500返回客户端。服务端引起的异常调用该方法，如调用第三方服务异常，数据库访问出错等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际使用时，分两种情况，&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;不通过try/catch主动抛出异常，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(appId)) {
    LOG.warn(&lt;/span&gt;&quot;the authorizer for site[{}] is not existed.&quot;&lt;span&gt;, templateMsgRequestDto.getSiteId());
    ExceptionUtil.rethrowClientSideException(ErrorCodeEnum.authorizer_notexist);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;通过try/catch异常重新抛出（注意：可预知的异常，需要给客户端返回某种提示信息的，必须通过该方式重新抛出。否则将返回统一的code 500,提示“抱歉，服务出错了，请稍后重试”的提示信息）如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    String result &lt;/span&gt;=&lt;span&gt; wxOpenService.getWxOpenComponentService().getWxMpServiceByAppid(appId).getTemplateMsgService().sendTemplateMsg(templateMessage);
    LOG.info(&lt;/span&gt;&quot;result: {}&quot;&lt;span&gt;, result);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (WxErrorException wxException) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里不需要打日志，会统一在异常处理里记录日志&lt;/span&gt;
&lt;span&gt;    ExceptionUtil.rethrowServerSideException(ExceptionCodeEnum.templatemsg_fail, wxException);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体实现参考源码： &lt;a href=&quot;https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/ronwxy/base-spring-boot/tree/master/spring-boot-autoconfigure/src/main/java/cn/jboost/springboot/autoconfig/error&lt;/a&gt;&lt;br/&gt;另附demo源码：&lt;a href=&quot;https://github.com/ronwxy/springboot-demos/tree/master/springboot-error&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/ronwxy/springboot-demos/tree/master/springboot-error&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h3&gt;
&lt;p&gt;本文写完感觉信息量有点多，对于不具备一定基础的人来说理解可能有点难度。如果有任何疑问，欢迎交流。后续有需要的话也可以针对某个环节再进行细化补充。本文所提的规范不一定是最好的实践，但规范或流程的管理，都是遵循先僵化，后优化，再固化的步骤，先解决有没有的问题，再解决好不好的问题。&lt;/p&gt;&lt;p&gt;我的个人博客地址：&lt;a href=&quot;http://blog.jboost.cn/&quot;&gt;http://blog.jboost.cn&lt;/a&gt;&lt;br/&gt;我的github地址：&lt;a href=&quot;https://github.com/ronwxy&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/ronwxy&lt;/a&gt;&lt;br/&gt;我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注）&lt;br/&gt;——————————————————————————————————————————————————&lt;br/&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;br/&gt;欢迎关注我的微信公众号，及时获取最新分享&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 00:37:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>都说管理的精髓就是“制度管人，流程管事”。而所谓流程，就是对一些日常工作环节、方式方法、次序等进行标准化、规范化。且不论精不精髓，在技术团队中，对一些通用场景，统一规范是必要的，只有步调一致，才能高效</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11130199.html</dc:identifier>
</item>
<item>
<title>常见的集合容器应当避免的坑 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11130043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11130043.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7680acc67477.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前不久帮同事一起 &lt;code&gt;review&lt;/code&gt; 一个 &lt;code&gt;job&lt;/code&gt; 执行缓慢的问题时发现不少朋友在撸码实现功能时还是有需要细节不够注意，于是便有了这篇文章。&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; temp = new ArrayList() ;

//获取一批数据
List&amp;lt;String&amp;gt; all = getData();
for(String str : all) {
    temp.add(str);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先大家看看这段代码有什么问题嘛？&lt;/p&gt;
&lt;p&gt;其实在大部分情况下这都是没啥问题，无非就是循环的往 &lt;code&gt;ArrayList&lt;/code&gt; 中写入数据而已。&lt;/p&gt;
&lt;p&gt;但在特殊情况下，比如这里的 &lt;code&gt;getData()&lt;/code&gt; 返回数据非常巨大时后续 &lt;code&gt;temp.add(str)&lt;/code&gt; 就会有问题了。&lt;/p&gt;
&lt;p&gt;比如我们在 &lt;code&gt;review&lt;/code&gt; 代码时发现这里返回的数据有时会高达 2000W，这时 &lt;code&gt;ArrayList&lt;/code&gt; 写入的问题就凸显出来了。&lt;/p&gt;
&lt;h2 id=&quot;填坑指南&quot;&gt;填坑指南&lt;/h2&gt;
&lt;p&gt;大家都知道 ArrayList 是由数组实现，而数据的长度有限；需要在合适的时机对数组扩容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里以插入到尾部为例 add(E e)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc77047aa18412.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ArrayList&amp;lt;String&amp;gt; temp = new ArrayList&amp;lt;&amp;gt;(2) ;
temp.add(&quot;1&quot;);
temp.add(&quot;2&quot;);
temp.add(&quot;3&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们初始化一个长度为 2 的 &lt;code&gt;ArrayList&lt;/code&gt; ，并往里边写入三条数据时 &lt;code&gt;ArrayList&lt;/code&gt; 就得扩容了，也就是将之前的数据复制一份到新的数组长度为 3 的数组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc774fbe780989.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;之所以是 3 ，是因为新的长度=原有长度 * 1.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过源码我们可以得知 &lt;code&gt;ArrayList&lt;/code&gt; 的默认长度为 10.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc78ce03788576.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc791275268933.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但其实并不是在初始化的时候就创建了 &lt;code&gt;DEFAULT_CAPACITY = 10&lt;/code&gt; 的数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7a45b6264440.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而是在往里边 &lt;code&gt;add&lt;/code&gt; 第一个数据的时候会扩容到 10.&lt;/p&gt;
&lt;p&gt;既然知道了默认的长度为 10 ，那说明后续一旦写入到第九个元素的时候就会扩容为 &lt;code&gt;10*1.5 =15&lt;/code&gt;。&lt;br/&gt;这一步为数组复制，也就是要重新开辟一块新的内存空间存放这 15 个数组。&lt;/p&gt;
&lt;p&gt;一旦我们频繁且数量巨大的进行写入时就会导致许多的数组复制，这个效率是极低的。&lt;/p&gt;
&lt;p&gt;但如果我们提前预知了可能会写入多少条数据时就可以提前避免这个问题。&lt;/p&gt;
&lt;p&gt;比如我们往里边写入 1000W 条数据，在初始化的时候就给定数组长度与用默认 10 的长度之间性能是差距巨大的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我用 JMH 基准测试验证如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
public class CollectionsTest {

    private static final int TEN_MILLION = 10000000;

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void arrayList() {

        List&amp;lt;String&amp;gt; array = new ArrayList&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; TEN_MILLION; i++) {
            array.add(&quot;123&quot;);
        }

    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void arrayListSize() {
        List&amp;lt;String&amp;gt; array = new ArrayList&amp;lt;&amp;gt;(TEN_MILLION);

        for (int i = 0; i &amp;lt; TEN_MILLION; i++) {
            array.add(&quot;123&quot;);
        }

    }


    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(CollectionsTest.class.getSimpleName())
                .forks(1)
                .build();


        new Runner(opt).run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7a910a851524.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据结果可以看出预设长度的效率会比用默认的效率高上很多（这里的 &lt;code&gt;Score&lt;/code&gt; 指执行完函数所消耗的时间）。&lt;/p&gt;
&lt;p&gt;所以这里强烈建议大家：在有大量数据写入 &lt;code&gt;ArrayList&lt;/code&gt; 时，一定要初始化指定长度。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;再一个是一定要慎用 &lt;code&gt;add(int index, E element)&lt;/code&gt; 向指定位置写入数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7adefae63526.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过源码我们可以看出，每一次写入都会将 index 后的数据往后移动一遍，其实本质也是要复制数组；&lt;/p&gt;
&lt;p&gt;但区别于往常规的往数组尾部写入数据，它每次都会进行数组复制，效率极低。&lt;/p&gt;

&lt;p&gt;提到 &lt;code&gt;ArrayList&lt;/code&gt; 就不得不聊下 &lt;code&gt;LinkedList&lt;/code&gt; 这个孪生兄弟；虽说都是 &lt;code&gt;List&lt;/code&gt; 的容器，但本质实现却完全不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7b0c7d526575.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 是由链表组成，每个节点又有头尾两个节点分别引用了前后两个节点；因此它也是一个双向链表。&lt;/p&gt;
&lt;p&gt;所以理论上来说它的写入非常高效，将不会有 ArrayList 中效率极低的数组复制，每次只需要移动指针即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里偷懒就不画图了，大家自行脑补下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;坊间一直流传：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;LinkedList 的写入效率高于 ArrayList，所以在写大于读的时候非常适用于 LinkedList 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void linkedList() {
        List&amp;lt;String&amp;gt; array = new LinkedList&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; TEN_MILLION; i++) {
            array.add(&quot;123&quot;);
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc7b3353a90285.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里测试看下结论是否符合；同样的也是对 &lt;code&gt;LinkedList&lt;/code&gt; 写入 &lt;code&gt;1000W&lt;/code&gt; 次数据，通过结果来看初始化数组长度的 &lt;code&gt;ArrayList&lt;/code&gt; 效率明显是要高于 &lt;code&gt;LinkedList&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;但这里的前提是要提前预设 &lt;code&gt;ArrayList&lt;/code&gt; 的数组长度，避免数组扩容，这样 &lt;code&gt;ArrayList&lt;/code&gt; 的写入效率是非常高的，而 &lt;code&gt;LinkedList&lt;/code&gt; 的虽然不需要复制内存，但却需要创建对象，变换指针等操作。&lt;/p&gt;
&lt;p&gt;而查询就不用多说了，&lt;code&gt;ArrayList&lt;/code&gt; 可以支持下标随机访问，效率非常高。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 由于底层不是数组，不支持通过下标访问，而是需要根据查询 index 所在的位置来判断是从头还是从尾进行遍历。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/04/5d1cdc9f5b7d645892.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但不管是哪种都得需要移动指针来一个个遍历，特别是 &lt;code&gt;index&lt;/code&gt; 靠近中间位置时将会非常慢。&lt;/p&gt;

&lt;p&gt;高性能应用都是从小细节一点点堆砌起来的，就如这里提到的 &lt;code&gt;ArrayList&lt;/code&gt; 的坑一样，日常使用没啥大问题，一旦数据量起来所有的小问题都会成为大问题。&lt;/p&gt;
&lt;p&gt;所以再总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;再使用 ArrayList 时如果能提前预测到数据量大小，比较大时一定要指定其长度。&lt;/li&gt;
&lt;li&gt;尽可能避免使用 &lt;code&gt;add(index,e)&lt;/code&gt; api，会导致复制数组，降低效率。&lt;/li&gt;
&lt;li&gt;再额外提一点，我们常用的另一个 &lt;code&gt;Map&lt;/code&gt; 容器 &lt;code&gt;HashMap&lt;/code&gt; 也是推荐要初始化长度从而避免扩容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文所有测试代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/basic/CollectionsTest.java&quot; class=&quot;uri&quot;&gt;https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/basic/CollectionsTest.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jul 2019 00:27:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前不久帮同事一起 review 一个 job 执行缓慢的问题时发现不少朋友在撸码实现功能时还是有需要细节不够注意，于是便有了这篇文章。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11130043.html</dc:identifier>
</item>
<item>
<title>kubernetes实战篇之helm安装 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11130137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11130137.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11100649.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Helm是kubernetes的应用包管理工具,是CNCF孵化器下的一个项目,主要用来管理 Charts。类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM.它提供了一种简单的方法来发现,分享和使用为kubernetes准备的软件包.它消除了繁杂的配置和部署,从而极大提高开发者的生效效率.&lt;/p&gt;
&lt;p&gt;怎样来理解它呢,假设我们的项目非常复杂,同时需要部署api网关,注册中心,配置中心,web服务,数据库中间件,消息队列中间件和缓存中间件...这将会产生大量的配置文件,如果以上操行的顺序不对或者某些参数不对,就可能造成整个系统部署失败.如果你经过一段时间的实践熟悉了整个部署流程,但是把工作交给其它同事时他仍然可能需要大量的时间来了解部署方案,如果你要把自己的方案在互联网上分享,开发者往往想要一键部署,对于繁杂的配置可能会望而却步.实践中部署一个wordpress仅一个web项目和一个mysql服务器的部署就着实把不少开发者折腾的不轻,更不用说像上面复杂的配置了...&lt;/p&gt;
&lt;p&gt;而helm正是要解决这样的问题,它把一系列复杂的有状态和无状态服务的部署封装起来(实际上就是对yaml文件的组织),然后你可以暴露出一些自定义参数信息供用户选择,这样部署就会变得简单很多.下面我们对helm的一些常用术语进行介绍并展示如何安装helm&lt;/p&gt;
&lt;h2 id=&quot;helm相关术语&quot;&gt;helm相关术语&lt;/h2&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Helm&lt;/strong&gt; 是一个命令行下的客户端工具。主要用于 Kubernetes 应用程序 Chart 的创建、打包、发布以及创建和管理本地和远程的 Chart 仓库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Tiller&lt;/strong&gt; 是 Helm 的服务端，部署在 Kubernetes 集群中。Tiller 用于接收 Helm 的请求，并根据 Chart 生成 Kubernetes 的部署文件（ Helm 称为 Release ），然后提交给 Kubernetes 创建应用。Tiller 还提供了 Release 的升级、删除、回滚等一系列功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Chart&lt;/strong&gt; Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Repoistory&lt;/strong&gt; Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Release&lt;/strong&gt; 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：需要注意的是：Helm 中提到的 Release 和我们通常概念中的版本有所不同，这里的 Release 可以理解为 Helm 使用 Chart 包部署的一个应用实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;chart-install-过程&quot;&gt;Chart Install 过程&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Helm 将指定的 Chart 结构和 Values 信息通过 gRPC 传递给 Tiller。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 根据 Chart 和 Values 生成一个 Release。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 将 Release 发送给 Kubernetes 用于生成 Release。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;chart-update-过程&quot;&gt;Chart Update 过程&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Helm 将需要更新的 Release 的名称、Chart 结构和 Values 信息传递给 Tiller。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 生成 Release 并更新指定名称的 Release 的 History。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 将 Release 发送给 Kubernetes 用于更新 Release。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;chart-rollback-过程&quot;&gt;Chart Rollback 过程&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Helm 将要回滚的 Release 的名称传递给 Tiller。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 根据 Release 的名称查找 History。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 从 History 中获取上一个 Release。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tiller 将上一个 Release 发送给 Kubernetes 用于替换当前 Release。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;chart-处理依赖说明&quot;&gt;Chart 处理依赖说明&lt;/h2&gt;
&lt;p&gt;Tiller 在处理 Chart 时，直接将 Chart 以及其依赖的所有 Charts 合并为一个 Release，同时传递给 Kubernetes。因此 Tiller 并不负责管理依赖之间的启动顺序。Chart 中的应用需要能够自行处理依赖关系。&lt;/p&gt;
&lt;h2 id=&quot;安装过程&quot;&gt;安装过程&lt;/h2&gt;
&lt;p&gt;1) 先在 K8S 集群上每个节点安装 socat 软件，不然会报如下错误：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;E0522 22:22:15.492436   24409 portforward.go:331] an error occurred forwarding 38398 -&amp;gt; 44134: error forwarding port 44134 to pod dc6da4ab99ad9c497c0cef1776b9dd18e0a612d507e2746ed63d36ef40f30174, uid : unable to do port forwarding: socat not found.
Error: cannot connect to Tiller&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# YUM 安装（每个节点都要安装）
yum install -y socat &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;要验证socat是否已经安装,在命令容器输入&lt;code&gt;sockat&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2) 下载helm release&lt;/p&gt;
&lt;p&gt;每一个版本HELM提供多种操作系统的二进制版本。可以手动下载和安装这些版本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/helm/helm/releases/&quot;&gt;下载页面&lt;/a&gt;https://github.com/helm/helm/releases/&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意下载的时候选择下载的是&lt;code&gt;Installation and Upgrading&lt;/code&gt;下面的包,而不是下面assets里面的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;注意以上github下载链接地址其实指向的是&lt;code&gt;storage.googleapis.com&lt;/code&gt;这个地址目前在国内还是能访问的,但是时好时坏,通过wget下载很多能会失败,建议在windows上点击链接下载,如果未能下载成功然后再进行重试,多重试几次就能下载成功了,当然有上网软件更好啦!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3) 解压并拷贝&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;tar -xzvf helm-v2.12.0-linux-amd64.tar.gz
cd linux-amd64 &amp;amp;&amp;amp; mv helm /usr/bin/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;压缩中包含两个可执行文件helm,tiller。其中tiller为server，若采用容器化部署到kubernetes中，则可以不用管tiller，只需将helm复制到/usr/bin目录即可。&lt;/p&gt;
&lt;p&gt;4) 安装服务端（Tiller）&lt;/p&gt;
&lt;p&gt;```bash&lt;/p&gt;

&lt;p&gt;helm init --service-account tiller --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts&lt;/p&gt;

&lt;p&gt;helm init --service-account tiller --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 --tiller-tls-cert /etc/kubernetes/ssl/tiller001.pem --tiller-tls-key /etc/kubernetes/ssl/tiller001-key.pem --tls-ca-cert /etc/kubernetes/ssl/ca.pem --tiller-namespace kube-system --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
若遇到错误 failed to list: configmaps is forbidden: User “system:serviceaccount:kube-system:default” cannot list configmaps in the namespace “kube-system”&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以下命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create serviceaccount --namespace kube-system tiller
kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller

kubectl patch deploy --namespace kube-system tiller-deploy -p '{&quot;spec&quot;:{&quot;template&quot;:{&quot;spec&quot;:{&quot;serviceAccount&quot;:&quot;tiller&quot;}}}}'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里在init的时候需要指定镜像源是因为init的时候衬tiller服务端,服务端是以deployment的方式安装的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也可以尝试以下一键安装命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &amp;gt; get_helm.sh
$ chmod 700 get_helm.sh
$ ./get_helm.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;13.393063583815&quot;&gt;
&lt;p&gt;注意以下内容参照了&lt;a href=&quot;https://www.hi-linux.com/posts/21466.html#%E9%83%A8%E7%BD%B2-helm&quot;&gt;这一篇文章&lt;/a&gt;,实际在安装时没有及时记录下来,所以我的账户已经是正常的了,不知道是新版本的已经默认创建的sa还是我自己手动创建然后忘记了.这里也贴出来,初学的朋友不要害怕,即便是默认已经创建了,再执行以下命令也不会导致错误发生的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给 Tiller 授权&lt;br/&gt;因为 Helm 的服务端 Tiller 是一个部署在 Kubernetes 中 Kube-System Namespace 下 的 Deployment，它会去连接 Kube-Api 在 Kubernetes 里创建和删除应用。&lt;/p&gt;
&lt;p&gt;而从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。目前的 Tiller 部署时默认没有定义授权的 ServiceAccount，这会导致访问 API Server 时被拒绝。所以我们需要明确为 Tiller 部署添加授权。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可能看了以上描述的朋友依然一头雾水,不知所云,实际上是因为helm本身可以创建和删除pod,因此它需要有操作权限.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;创建 Kubernetes 的服务帐号和绑定角色&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl get deployment --all-namespaces
NAMESPACE     NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kube-system   tiller-deploy          1         1         1            1           1h
$ kubectl create serviceaccount --namespace kube-system tiller
$ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;为 Tiller 设置帐号&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;使用 kubectl patch 更新 API 对象
$ kubectl patch deploy --namespace kube-system tiller-deploy -p '{&quot;spec&quot;:{&quot;template&quot;:{&quot;spec&quot;:{&quot;serviceAccount&quot;:&quot;tiller&quot;}}}}'
deployment.extensions &quot;tiller-deploy&quot; patched&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看是否授权成功&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ kubectl get deploy --namespace kube-system   tiller-deploy  --output yaml|grep  serviceAccount
serviceAccount: tiller
serviceAccountName: tiller&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;验证 Tiller 是否安装成功&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl -n kube-system get pods|grep tiller
tiller-deploy-6df646875f-ttbn7         1/1     Running   5          15d
[centos@k8s-master ~]$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;helm客户端和服务端的版本必须是一致的才能正常工作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;helm命令智能补全&quot;&gt;helm命令智能补全&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;source &amp;lt;(helm completion bash)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于zsh命令,则使用如下命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;source &amp;lt;(helm completion zsh)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;卸载helm&quot;&gt;卸载helm&lt;/h2&gt;
&lt;p&gt;使用中你会发现,helm并不像想像的那样能正常完美工作,时尔会出现一些小问题,可以使用以下命令来卸载&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;helm reset&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看-helm-版本信息&quot;&gt;查看 helm 版本信息&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master tekton]$ helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 03 Jul 2019 23:57:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Helm是kubernetes的应用包管理工具,是CNCF孵化器下的一个项目,主要用来管理 Charts。类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM.它提供了一种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11130137.html</dc:identifier>
</item>
<item>
<title>跟我学SpringCloud | 第四篇：熔断器Hystrix - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11123850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11123850.html</guid>
<description>&lt;h2 id=&quot;熔断器&quot;&gt;1. 熔断器&lt;/h2&gt;
&lt;h4 id=&quot;服务雪崩&quot;&gt;服务雪崩&lt;/h4&gt;
&lt;p&gt;在正常的微服务架构体系下，一个业务很少有只需要调用一个服务就可以返回数据的情况，这种比较常见的是出现在demo中，一般都是存在调用链的，比如A-&amp;gt;B-&amp;gt;C-&amp;gt;D，如果D在某一个瞬间出现问题，比如网络波动，io偏高，导致卡顿，随着时间的流逝，后续的流量继续请求，会造成D的压力上升，有可能引起宕机。&lt;/p&gt;
&lt;p&gt;你以为这就是结束么，图样图森破，这才是噩梦的开始，在同一个调用链上的ABC三个服务都会随着D的宕机而引发宕机，这还不是结束，一个服务不可能只有一个接口，当它开始卡顿宕机时，会影响到其他调用链的正常调用，最终导致所有的服务瘫痪。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/chapter4/xuebeng.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;熔断器-1&quot;&gt;熔断器&lt;/h4&gt;
&lt;p&gt;相信大家都知道家用电闸，原来老式的电闸是使用保险丝的（现在很多都是空气开关了），当家里用电量过大的时候，保险丝经常烧断，这么做是保护家里的用电器，防止过载。&lt;/p&gt;
&lt;p&gt;熔断器的作用和这个很像，它可以实现快速失败，如果在一段时间内服务调用失败或者异常，会强制要求当前调用失败，不在走远程调用，走服务降级操作（返回固定数据或者其他一些降级操作）。从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以自动诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。&lt;/p&gt;
&lt;p&gt;熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。 Hystrix会有一个熔断时间窗口，具体转换逻辑如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://springcloud-oss.oss-cn-shanghai.aliyuncs.com/chapter4/rongduanqi.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熔断器就是保护服务高可用的最后一道防线。&lt;/p&gt;
&lt;h2 id=&quot;hystrix&quot;&gt;2. Hystrix&lt;/h2&gt;
&lt;h4 id=&quot;断路器机制&quot;&gt;1. 断路器机制&lt;/h4&gt;
&lt;p&gt;断路器很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open)。这时所有请求会直接失败而不会发送到后端服务。断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN)。这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN)。Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。&lt;/p&gt;
&lt;h4 id=&quot;fallback&quot;&gt;2. Fallback&lt;/h4&gt;
&lt;p&gt;Fallback相当于是降级操作。对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值。fallback方法的返回值一般是设置的默认值或者来自缓存。&lt;/p&gt;
&lt;h4 id=&quot;资源隔离&quot;&gt;3. 资源隔离&lt;/h4&gt;
&lt;p&gt;在Hystrix中, 主要通过线程池来实现资源隔离。通常在使用的时候我们会根据调用的远程服务划分出多个线程池。例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池。这样做的主要优点是运行环境被隔离开了。这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响。但是带来的代价就是维护多个线程池会对系统带来额外的性能开销。如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源。&lt;/p&gt;
&lt;h2 id=&quot;feign-hystrix&quot;&gt;3. Feign Hystrix&lt;/h2&gt;
&lt;p&gt;上一篇我们使用了producer和consumers，熔断器是只作用在服务调用端，因此上一篇使用到的consumers我们可以直接拿来使用。因为，Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。&lt;/p&gt;
&lt;h4 id=&quot;配置文件application.yml新增&quot;&gt;1. 配置文件application.yml新增&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8081
spring:
  application:
    name: spring-cloud-consumers
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
feign:
  hystrix:
    enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中新增了feign.hystrix.enabled = true&lt;/p&gt;
&lt;h4 id=&quot;创建fallback类继承与helloremote实现回调的方法&quot;&gt;2. 创建fallback类，继承与HelloRemote实现回调的方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.consumers.fallback;

import com.springcloud.consumers.remote.HelloRemote;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * Created with IntelliJ IDEA.
 *
 * @User: weishiyao
 * @Date: 2019/7/2
 * @Time: 23:14
 * @email: inwsy@hotmail.com
 * Description:
 */
@Component
public class HelloRemoteFallBack implements HelloRemote {
    @Override
    public String hello(@RequestParam(value = &quot;name&quot;) String name) {
        return &quot;hello &quot; + name + &quot;, i am fallback massage&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加fallback属性&quot;&gt;3. 添加fallback属性&lt;/h3&gt;
&lt;p&gt;在HelloRemote类添加指定fallback类，在服务熔断的时候返回fallback类中的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.springcloud.consumers.remote;

import com.springcloud.consumers.fallback.HelloRemoteFallBack;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * @Author: shiyao.wei
 * @Date: 2019/7/2 11:14
 * @Version: 1.0
 * @Desc:
 */
@FeignClient(name= &quot;SPRING-CLOUD-PRODUCER&quot;, fallback = HelloRemoteFallBack.class)
public interface HelloRemote {
    @RequestMapping(value = &quot;/hello&quot;)
    String hello(@RequestParam(value = &quot;name&quot;) String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有改动结束。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;4. 测试&lt;/h2&gt;
&lt;p&gt;现在我们测试看下结果，老规矩，顺次启动注册中心Eureka、provider、consumer&lt;/p&gt;
&lt;p&gt;访问上一节我们访问过的链接：http://localhost:8081/hello/spring&lt;/p&gt;
&lt;p&gt;现在可以看到页面正常显示：hello spring，producer is ready&lt;/p&gt;
&lt;p&gt;现在我们手动把provider停掉，再访问一下链接看一下：&lt;/p&gt;
&lt;p&gt;现在页面已经显示我们熔断后的信息了：hello spring, i am fallback massage&lt;/p&gt;
&lt;p&gt;现在说明我们的测试已经成功了。&lt;/p&gt;
&lt;p&gt;好了，现在可以将代码打包扔到Github上去了：）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter4&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://skaka.me/blog/2016/09/04/springcloud5/&quot;&gt;微服务框架Spring Cloud介绍 Part5: 在微服务系统中使用Hystrix, Hystrix Dashboard与Turbine&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jul 2019 23:16:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>跟我学SpringCloud | 第四篇：熔断器Hystrix 1. 熔断器 服务雪崩 在正常的微服务架构体系下，一个业务很少有只需要调用一个服务就可以返回数据的情况，这种比较常见的是出现在demo中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11123850.html</dc:identifier>
</item>
<item>
<title>python算法与数据结构-队列(44) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/11130026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/11130026.html</guid>
<description>&lt;h3&gt;一、队列的介绍&lt;/h3&gt;
&lt;p&gt;　　队列的定义：队列是一种特殊的线性表，只允许在表的头部（front处）进行删除操作，在表的尾部（rear处）进行插入操作的线性数据结构，这种结构就叫做队列。进行插入操作的一端称为队尾，进行删除操作的一端称为队尾。&lt;/p&gt;
&lt;p&gt;　　队列的类型：链式队列，即用链表实现的队列。静态队列：即用数组实现的队列。&lt;/p&gt;
&lt;p&gt;　　队列的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在队尾插入元素，在队首删除元素。&lt;/li&gt;
&lt;li&gt;FIFO（先进先出），就向排队取票一样。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190703221534059-2100057457.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二、队列的python代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Queue(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===创建队列===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.element &lt;/span&gt;=&lt;span&gt; []
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; inQueue(self,num):
        self.element.append(num)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d进入队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%num,end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_empty(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(self.element)==&lt;span&gt;0:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; outQueue(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.is_empty()==&lt;span&gt;True:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要删除的队列为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            num &lt;/span&gt;=&lt;span&gt; self.element[0]
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d要出队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%num,end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            self.element.pop(0)
            
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; length(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.element)
    
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; travel(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.is_empty()==&lt;span&gt;True:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要遍历的队列为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,self.length()):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%self.element[i],end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    q &lt;/span&gt;=&lt;span&gt; Queue()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===验证空队列===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    q.travel()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===往队列中添加数据===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    q.inQueue(&lt;/span&gt;1&lt;span&gt;)
    q.travel()
    q.inQueue(&lt;/span&gt;2&lt;span&gt;)
    q.inQueue(&lt;/span&gt;3&lt;span&gt;)
    q.inQueue(&lt;/span&gt;4&lt;span&gt;)
    q.inQueue(&lt;/span&gt;5&lt;span&gt;)
    q.travel()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===验证出队列===&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    q.outQueue()
    q.travel()
    q.outQueue()
    q.travel()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
===创建队列===
===验证空队列===&lt;span&gt;
你要遍历的队列为空
&lt;/span&gt;===往队列中添加数据===&lt;span&gt;
1进入队列 你要遍历的队列元素有： &lt;/span&gt;1&lt;span&gt;  

2进入队列 3进入队列 4进入队列 5进入队列 你要遍历的队列元素有： &lt;/span&gt;1  2  3  4  5  

===验证出队列===&lt;span&gt;
1要出队列 你要遍历的队列元素有： &lt;/span&gt;2  3  4  5&lt;span&gt;  

2要出队列 你要遍历的队列元素有： &lt;/span&gt;3  4  5  
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、队列的C语言代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  main.m
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  队列
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Created by 侯垒 on 2019/7/3.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Copyright © 2019 可爱的侯老师. All rights reserved.&lt;/span&gt;
&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; SIZE 20&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Q
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; array[SIZE];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; front;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rear;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length;
}Queue;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; createQueue(Queue *&lt;span&gt;q)
{
    q&lt;/span&gt;-&amp;gt;front = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    q&lt;/span&gt;-&amp;gt;rear = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    q&lt;/span&gt;-&amp;gt;length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建队列成功\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; inQueue(Queue *q,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q-&amp;gt;length &amp;gt;=&lt;span&gt; SIZE)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该队列已经满了\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        q&lt;/span&gt;-&amp;gt;rear = q-&amp;gt;rear+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        q&lt;/span&gt;-&amp;gt;array[q-&amp;gt;rear] =&lt;span&gt; num;
        q&lt;/span&gt;-&amp;gt;length++&lt;span&gt;;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d进入队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; outQueue(Queue *&lt;span&gt;q)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q-&amp;gt;length &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个空队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = q-&amp;gt;array[q-&amp;gt;&lt;span&gt;front];
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d出队列 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
        q&lt;/span&gt;-&amp;gt;front = q-&amp;gt;front+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        q&lt;/span&gt;-&amp;gt;length--&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; travel(Queue *&lt;span&gt;q)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q-&amp;gt;length &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个空队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你遍历的队列里面的数据有：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=q-&amp;gt;front; i&amp;lt;q-&amp;gt;rear+&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; %d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,q-&amp;gt;&lt;span&gt;array[i]);
        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[]) {
    
    Queue q;
    createQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    travel(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    inQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    travel(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    outQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    travel(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    outQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    travel(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    outQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    travel(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;创建队列成功
这是一个空队列
1进入队列
2进入队列
3进入队列
4进入队列
5进入队列
6进入队列
你遍历的队列里面的数据有： &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;&lt;span&gt; 
1出队列 你遍历的队列里面的数据有： &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;&lt;span&gt; 
2出队列 你遍历的队列里面的数据有： &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;&lt;span&gt; 
3出队列 你遍历的队列里面的数据有： &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、双端队列&lt;/h3&gt;
&lt;p&gt;双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。&lt;/p&gt;
&lt;p&gt;双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190704001637473-537260915.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;双端队列的常用操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Deque() 创建一个空的双端队列&lt;/li&gt;
&lt;li&gt;add_front(item) 从队头加入一个item元素&lt;/li&gt;
&lt;li&gt;add_rear(item) 从队尾加入一个item元素&lt;/li&gt;
&lt;li&gt;remove_front() 从队头删除一个item元素&lt;/li&gt;
&lt;li&gt;remove_rear() 从队尾删除一个item元素&lt;/li&gt;
&lt;li&gt;is_empty() 判断双端队列是否为空&lt;/li&gt;
&lt;li&gt;size() 返回队列的大小&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;五、双端队列的python代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Deque(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;双端队列&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.items &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化双端队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_empty(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断队列是否为空&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.items ==&lt;span&gt; []

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_front(self, item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;在队头添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d在队首进入队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;item)
        self.items.insert(0,item)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_rear(self, item):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;在队尾添加元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d在队尾进入队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;item)
        self.items.append(item)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove_front(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;从队头删除元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        item &lt;/span&gt;=&lt;span&gt; self.items[0]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从队首出队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;item)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.items.pop(0)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; remove_rear(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;从队尾删除元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从队尾出队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%self.items[len(self.items)-1&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.items.pop()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; size(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回队列大小&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.items)
    
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; travel(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(self.items)==&lt;span&gt;0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要遍历的队列是空队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,len(self.items)):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%self.items[i],end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    deque &lt;/span&gt;=&lt;span&gt; Deque()
    deque.add_front(&lt;/span&gt;1&lt;span&gt;)
    deque.add_front(&lt;/span&gt;2&lt;span&gt;)
    deque.add_rear(&lt;/span&gt;3&lt;span&gt;)
    deque.add_rear(&lt;/span&gt;4&lt;span&gt;)
    deque.travel()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列长度为：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;deque.size())
    deque.remove_front()
    deque.travel()
    deque.remove_front()
    deque.travel()
    deque.remove_rear()
    deque.travel()
    deque.remove_rear()
    deque.travel()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;初始化双端队列
1在队首进入队列
2在队首进入队列
3在队尾进入队列
4在队尾进入队列
你要遍历的队列元素有： &lt;/span&gt;2  1  3  4&lt;span&gt;  

队列长度为：&lt;/span&gt;4&lt;span&gt;

2从队首出队列
你要遍历的队列元素有： &lt;/span&gt;1  3  4&lt;span&gt;  

1从队首出队列
你要遍历的队列元素有： &lt;/span&gt;3  4&lt;span&gt;  

4从队尾出队列
你要遍历的队列元素有： &lt;/span&gt;3&lt;span&gt;  

3从队尾出队列
你要遍历的队列是空队列&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、双端队列的C语言代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  main.m
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  双端队列
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Created by 侯垒 on 2019/7/4.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Copyright © 2019 可爱的侯老师. All rights reserved.&lt;/span&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建队列的节点结构体&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; N
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; N *&lt;span&gt;next;
}Node;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建节点&lt;/span&gt;
Node * createNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    
    Node &lt;/span&gt;*node = (Node *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(Node));
    node&lt;/span&gt;-&amp;gt;num =&lt;span&gt; num;
    node&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建双端队列&lt;/span&gt;
Node *&lt;span&gt; createDeQue()
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Node &lt;/span&gt;*head =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否为空&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; is_empty(Node *&lt;span&gt;head)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (head ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求双向队列的长度&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; length(Node *&lt;span&gt;head)
{
    Node &lt;/span&gt;*current =&lt;span&gt; head;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is_empty(head))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current-&amp;gt;next!=&lt;span&gt;NULL)
    {
        count&lt;/span&gt;++&lt;span&gt;;
        current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头部插入&lt;/span&gt;
Node *add_front(Node *head, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    Node &lt;/span&gt;*node =&lt;span&gt; createNode(num);
    Node &lt;/span&gt;*current =&lt;span&gt; head;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_empty(head)==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        head &lt;/span&gt;=&lt;span&gt; node;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        node&lt;/span&gt;-&amp;gt;next =&lt;span&gt; head;
        head &lt;/span&gt;=&lt;span&gt; node;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从队列头部进入队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾部插入&lt;/span&gt;
Node *add_rear(Node *head,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    Node &lt;/span&gt;*node =&lt;span&gt; createNode(num);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_empty(head)==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        head &lt;/span&gt;=&lt;span&gt; add_front(head, num);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Node &lt;/span&gt;*current =&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current-&amp;gt;next !=&lt;span&gt; NULL)
        {
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        current&lt;/span&gt;-&amp;gt;next =&lt;span&gt; node;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从尾部进入队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头部删除&lt;/span&gt;
Node *remove_front(Node *&lt;span&gt;head)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_empty(head) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个空队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = head-&amp;gt;&lt;span&gt;num;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;head-&amp;gt;next = head-&amp;gt;next-&amp;gt;next;&lt;/span&gt;
        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从队列头部出队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,num);
        head &lt;/span&gt;= head-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾部删除&lt;/span&gt;
Node *remove_rear(Node *&lt;span&gt;head)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_empty(head) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是一个空队列&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (length(head) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
         head &lt;/span&gt;=&lt;span&gt; remove_front(head);
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Node &lt;/span&gt;*current =&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;length(head)-&lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
        {
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d从队列尾部出队列\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,current-&amp;gt;next-&amp;gt;&lt;span&gt;num);
        current&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; travel(Node *&lt;span&gt;head)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_empty(head) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你遍历的队列为空\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Node &lt;/span&gt;*current =&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;%d &quot;,current-&amp;gt;num);&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;length(head); i++&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,current-&amp;gt;&lt;span&gt;num);
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[])
{
    Node &lt;/span&gt;*head =&lt;span&gt; createDeQue();
    head &lt;/span&gt;= add_front(head, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    travel(head);
    head &lt;/span&gt;= add_front(head, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    travel(head);
    head &lt;/span&gt;= add_rear(head, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    travel(head);
    head &lt;/span&gt;= add_rear(head, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    travel(head);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  len =&lt;span&gt; length(head);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现在队列的长度为%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,len);
    
    head &lt;/span&gt;=&lt;span&gt; remove_front(head);
    travel(head);
    head &lt;/span&gt;=&lt;span&gt; remove_front(head);
    travel(head);
    len &lt;/span&gt;=&lt;span&gt; length(head);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现在队列的长度为%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,len);
    head &lt;/span&gt;=&lt;span&gt; remove_rear(head);
    travel(head);
    head &lt;/span&gt;=&lt;span&gt; remove_rear(head);
    travel(head);
   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;初始化队列
1从队列头部进入队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 
2从队列头部进入队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt; 
3从尾部进入队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; 
4从尾部进入队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt; 
现在队列的长度为4
2从队列头部出队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt; 
1从队列头部出队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt; 
现在队列的长度为2
4从队列尾部出队列
你要遍历的队列元素有：&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 
3从队列头部出队列
你遍历的队列为空&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 03 Jul 2019 17:15:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、队列的介绍 队列的定义：队列是一种特殊的线性表，只允许在表的头部（front处）进行删除操作，在表的尾部（rear处）进行插入操作的线性数据结构，这种结构就叫做队列。进行插入操作的一端称为队尾，进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/11130026.html</dc:identifier>
</item>
<item>
<title>线程的基本解析 - wudidamowang666</title>
<link>http://www.cnblogs.com/wudidamowang666/p/11130012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wudidamowang666/p/11130012.html</guid>
<description>&lt;p&gt;&lt;span&gt;线程对象是可以产生线程的对象。比如在&lt;a class=&quot;replace_word&quot; title=&quot;Java EE知识库&quot; href=&quot;http://lib.csdn.net/base/17&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt;平台中Thread对象，Runnable对象。线程，是指正在执行的一个指点令序列。在java平台上是指从一个线程对象的start()开始，运行run方法体中的那一段相对独立的过程。相比于多进程，多线程的优势有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （1）进程之间不能共享数据，线程可以；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （2）系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （3）Java语言内置了多线程功能支持，简化了java多线程编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、创建线程和启动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （1）继承Thread类创建线程类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过继承Thread类创建线程类的具体步骤和具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   • 定义一个继承Thread类的子类，并重写该类的run()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   • 创建Thread子类的实例，即创建了线程对象；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   • 调用该线程对象的start()方法启动线程。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeThead extends Thraad   { 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()   { 
     &lt;/span&gt;&lt;span&gt;//所要重写的方法&lt;/span&gt;
&lt;span&gt;    }  
 } 
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
 SomeThread oneThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SomeThread();   
  步骤3：启动线程：   
 oneThread.start(); 
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201907/1113047-20190704002157323-125357206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2）实现Runnable接口创建线程类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过实现Runnable接口创建线程类的具体步骤和具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   • 定义Runnable接口的实现类，并重写该接口的run()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   • 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeRunnable implements Runnable   { 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()   { 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所要重写的方法 &lt;/span&gt;
&lt;span&gt;  }  
} 
Runnable oneRunnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SomeRunnable();   
Thread oneThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(oneRunnable);   
oneThread.start();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上的两种方法均可实现创建线程类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，本魔王一开始乍一看的时候感觉大体上好像并没有什么区别，但事实显然并没有这么简单，试问一下，当使用Thread时候如有需求要求继承其他类的时候，是可以用extend继承父类的域，那万一要继承的不只是一个父类呢，Thread毕竟只是一个类，不是接口，诶！！对了，这时候用Runnable就会方便很多，下面为大家总结的是Runnable与Thread的相关性。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;****Runnable和Thread的区别和联系?****&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1) Thread是一个类,Runnable是一个接口;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) Thread类实现了Runnable接口,重写了run方法.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3) Runnable是一个接口,定义一个类实现接口的同时还可以继承其他的类 ; Runnable 支持多继承的写法;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) Runable可以简单的实现数据的共享 ;Thread不太好实现;其实都可以实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5) Runnable适合多个相同的程序代码的线程去处理同一个资源,避免Java中的单继承的限制，增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。线程池只能放入实现Runnable 类线程，不能直接放入继承Thread的类.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在面试的时候，很多面试官都喜欢问一些关于线程状态的问题，可能不多问的特别细，但起码道理我们得说的出来，下图是线程的生命周期，就挑几个常见的给大家解释的，其实有一些是我自己归纳的，也有一些是网上dd下来的，懂的是什么道理，自己整理一套白话最好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201907/1113047-20190704003226876-493851216.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;新线程：&lt;/strong&gt;&lt;/span&gt;
&lt;ul readability=&quot;0.99128540305011&quot;&gt;&lt;li readability=&quot;4.9564270152505&quot;&gt;
&lt;p&gt;&lt;span&gt; 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable），它仅仅作为一个对象实例存在， JVM没有为其分配CPU时间片和其他线程运行资源;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：&lt;/span&gt;不能对已经启动的线程再次调用start()方法，否则会出现&lt;a class=&quot;replace_word&quot; title=&quot;Java EE知识库&quot; href=&quot;http://lib.csdn.net/base/17&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt;.lang.IllegalThreadStateException异常。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201907/1113047-20190704003255790-1176184961.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;就绪状态：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在处于创建状态的线程中调用&lt;/span&gt;start&lt;span&gt;方法将线程的状态转换为就绪状态（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的）。等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;提示&lt;/span&gt;：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。（sleep()方法在下面会解释）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201907/1113047-20190704003555502-167434987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;运行状态&lt;/span&gt;:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;处于运行状态的线程是最复杂的，有阻塞状态，就绪状态和死亡状态&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。（&lt;span&gt;**&lt;/span&gt;当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;等待&lt;/span&gt;/&lt;span&gt;阻塞：&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;阻塞状态在这里我不便多说，因为我自己都还没看透（喷血），我只能理解的是当一个线程占用CPU运行时被其他线程或者语句剥夺或者说暂停了其了使用权，从而进入阻塞状态。&lt;/li&gt;
&lt;li&gt;在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Java提供了一些便捷的方法用于线程状态的控制，就举几个常用的例子，多了我也不会。具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、线程睡眠——sleep&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   （1）&lt;/strong&gt;sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。如下面的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; day7_3HomeWork;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Thread_text {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Thread_input ti = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread_input();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ti.start();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Thread_input &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     String[] str = {&quot;我&quot;,&quot;我爱&quot;,&quot;我爱福&quot;,&quot;我爱福建&quot;,&quot;我爱福建工&quot;,&quot;我爱福建工程&quot;,&quot;我爱福建工程学&quot;,&quot;我爱福建工程学院&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;str.length;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            System.out.println(str[i]);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }    
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于只是暂停当前的进程运行，线程处于阻塞状态，在2000mills的睡眠时间结束的时候才能重新变回就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。下图是sleep的方法，需要传入的是一个long mills的参数，这是毫秒的单位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113047/201907/1113047-20190704005733699-530735942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。&lt;/p&gt;

</description>
<pubDate>Wed, 03 Jul 2019 17:01:00 +0000</pubDate>
<dc:creator>wudidamowang666</dc:creator>
<og:description>线程对象是可以产生线程的对象。比如在Java平台中Thread对象，Runnable对象。线程，是指正在执行的一个指点令序列。在java平台上是指从一个线程对象的start()开始，运行run方法体中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wudidamowang666/p/11130012.html</dc:identifier>
</item>
<item>
<title>Netty源码分析--Channel注册&amp;绑定端口（下）（七） - Diligent_Watermelon</title>
<link>http://www.cnblogs.com/huxipeng/p/11075097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huxipeng/p/11075097.html</guid>
<description>&lt;p&gt;      接下来，我们看到的就是两个非常重要的方法&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190627225056735-968240556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      就是 processSelectedKeys() 和  runAllTasks() 方法了。&lt;/p&gt;
&lt;p&gt;      selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。属于I/O任务。&lt;/p&gt;
&lt;p&gt;      添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。属于非I/O任务。&lt;/p&gt;
&lt;p&gt;      两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。&lt;/p&gt;
&lt;p&gt;      我们看一下 processSelectedKeys() 方法， 因为 selectedKeys != null 所以进入  processSelectedKeysOptimized() 方法。&lt;/p&gt;
&lt;p&gt;      由于没有这里只是启动服务端，没有客户端接入进来，所以我们先跳过processSelectedKeys()，一会我们结合客户端接入来讲这里。&lt;/p&gt;
&lt;p&gt;      直接看 runAllTasks() 方法。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628001328537-836302792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        Runnable task = pollTask(); 这个就是从 taskQueue 中拿出一个task。&lt;/p&gt;
&lt;p&gt;        然后循环执行这个任务， safeExecute(task)。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628001605564-958426211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这个方法也是很简单，就是直接执行Runnable接口中的run()方法（这里并不是启动一个线程，而是仅仅的执行一个普通的run方法）。&lt;/p&gt;
&lt;p&gt;       大家想一下这里的这个task应该是什么呢?&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628001934350-1913459892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        大家还记得这段代码吗？ 就是这个 register0() 方法。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628002509509-1877054852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         我们先进入到 doRegister() 方法&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628002656819-1614418580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         继续传入当前的eventloop中的selector， opt = 0,  第三个参数 this 就是当前的 NioServerSocketChannel。 进入register 方法&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190628003126199-898108684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           大家看我圈出来的这一句，熟悉吗？我当时将NIO的时候是不是讲到了。&lt;/p&gt;
&lt;p&gt;           这里就是把当前的channel注册到这个多路复用器上。并且把 NioServerSocketChannel 传进去当做附件 attach， 注册的 interestOps = 0 &lt;/p&gt;
&lt;p&gt;          好了，当执行完task，由于是一个死循环，那么会继续执行刚刚的整个过程。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629161625960-1073671310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           好了，总结一下： 也就是说有一个线程一直在这里不断循环的等待新的 selectionKey中ready的事件，如accept、connect、read、write等。 如果有待处理的task,将会去优先处理的task.&lt;/p&gt;
&lt;p&gt;           一会我们会启动一个客户端看一下是怎么交互的。&lt;/p&gt;
&lt;p&gt;           整个注册完成之后，接下来就是 绑定端口 ，将服务对外开放出去。&lt;/p&gt;
&lt;p&gt;           我们看下AbstractBootstrap中的  doBind() 方法。&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629162229948-1147012799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;              由于整个注册过程是异步的，所以这里 regFuture.isDone() 是否已经完成，如果完成直接执行doBind0(),如果没有完成，那么就监听异步响应方法，等待成功之后，再执行doBind0()方法。&lt;/p&gt;
&lt;p&gt;             我们进入doBind0()方法&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165150919-1441209598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           我们看其实就是向eventLoop中的任务队列中添加一个task。&lt;/p&gt;
&lt;p&gt;           这里我们debug来看一下&lt;/p&gt;
&lt;p&gt;          另外在 AbstractBootstrap中打一个断点，在这里等待注册事件先完成。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165405183-1790710031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         好的，我们启动服务端。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165548912-242654418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        断点进来了， 我们再在  NioEventLoop 中打一个断点，因为这里是处理task的地方&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165310756-1164558048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           我们发现有一个主线程，一个子线程，如下图&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165741794-1623540623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         切换到子线程，我们看下 task 的执行过程。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629165829450-1556420667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       因为switch中的hasTask() 是true，那么我们就直接看&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629170032627-802483049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629170115202-915910514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     从任务队列中取出一个task，我们看到就是刚刚我们的那个任务。然后通过safeExecute(task)执行run方法&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629170237674-119048688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      继续F5。我们看进入到了runnable中的run方法。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629170255152-705069323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     接下来就是一段链式调用，链式访问pipleline中的handler         TailContext -&amp;gt; ServerBootstrapAcceptor -&amp;gt; LoggingHandler -&amp;gt; HeadContext&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629175850412-1813209935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     TailContext 和 ServerBootstrapAcceptor 中没有bind方法，直接进入LoggingHandler的bind方法，打一个日志&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629180248101-1425643144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   继续f5进入到 HeadContext中的bind方法&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629180439608-2081889667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629180549139-431949720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   先判断是否激活，如果没有，则稍后链式调用handlers中的 channelActive()方法。&lt;/p&gt;
&lt;p&gt;   进入doBind方法&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1143158/201906/1143158-20190629180826828-1870938861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   ok,到这里绑定端口成功。&lt;/p&gt;
&lt;p&gt;  目前为止，Server服务端启动完成，接下来我们看一下，一个客户端是怎么接入进来并且进行读写操作的。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jul 2019 16:07:00 +0000</pubDate>
<dc:creator>Diligent_Watermelon</dc:creator>
<og:description>接下来，我们看到的就是两个非常重要的方法 就是 processSelectedKeys() 和 runAllTasks() 方法了。 selectionKey中ready的事件，如accep</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huxipeng/p/11075097.html</dc:identifier>
</item>
<item>
<title>表格树控件QtTreePropertyBrowser编译成动态库(设计师插件) - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11129274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11129274.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11129274.html&quot;&gt;表格树控件QtTreePropertyBrowser编译成动态库(设计师插件)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一回顾&quot;&gt;一、回顾&lt;/h2&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11117259.html&quot;&gt;超级实用的表格树控件--QtTreePropertyBrowser&lt;/a&gt;讲了怎么去编译QtTreePropertyBrowser库，并且可以简单使用。由于我下载的库是基于Qt4的版本，所以编译起来也费劲巴拉的，改了好久的源码才编译通过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇文章我们核心讲解的是怎么把这个库编译成动态库，让别的模块去动态调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里引入Qt官方维护的模块QtSolutions，里边就包含了QtTreePropertyBrowser这个项目，最关键是Qt5可以直接编译通过。&lt;/p&gt;
&lt;p&gt;QtSolutions里边不仅仅有QtTreePropertyBrowser这个项目，而且包含了多个有用模块，文章最后会简单做以介绍。&lt;/p&gt;
&lt;p&gt;下面我们主要还是围绕QtTreePropertyBrowser这个库来进行讲解。。&lt;/p&gt;
&lt;h2 id=&quot;二动态库编译&quot;&gt;二、动态库编译&lt;/h2&gt;
&lt;p&gt;编译成动态库的方式有2种，一种是命令行，另一种是vs工具，其实本质上都是一样的，都是使用了msvc编译器。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想要使用其他编译器编译，本篇文章可以作为参考，可能有些地方不太实用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;编译这种长期维护的项目，我们首先就是去看代码中的文档说明，一般都会有编译步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_Install_doc.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;这个库也不例外，看上图中红色款圈出来的部分，就是我们编译的步骤，简单吧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;configure.bat，如果需要生成动态库则需要添加&lt;code&gt;-library&lt;/code&gt;参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;命令行编译动态库和测试程序&quot;&gt;1、命令行编译动态库和测试程序&lt;/h3&gt;
&lt;p&gt;命令行cd到源码根目录，执行以下步骤即可&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;confiture.bat -library&lt;/li&gt;
&lt;li&gt;qmake&lt;/li&gt;
&lt;li&gt;nmake&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没有什么悬念，代码应该可以正常编译通过，这里就不做过多解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点看下怎么使用vs工具进行编译&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;vs工具编译动态库和测试程序&quot;&gt;2、vs工具编译动态库和测试程序&lt;/h3&gt;
&lt;p&gt;首先在网上随便搜索下pro转sln工程的文章，总结一下就是下面两句话&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qmake xxx.pro
qmake -tp vc -r&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于我们的qtpropertybrowser代码可能就像下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qmake qtpropertybrowser.pro
qmake -tp vc -r&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果不使用这种方式，也可以使用vs-addin插件直接打开pro文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;执行完上述两句话之后，会发现我们的根目录下多了一个qtpropertybrowser.sln工程文件。每一个项目文件夹下也多了一个simple.vcxproj项目文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来就是用vs打开qtpropertybrowser.sln工程文件，然后进行编译了。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_project_file.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;通过命令行生成的QtSolutions_PropertyBrowser-head.vcxproj这个工程文件有一些小问题，需要修改下工程配置，否则编译会失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打开工程属性 -&amp;gt; C/C++ -&amp;gt; 预处理器 -&amp;gt; 预处理器定义项。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改QT_QTPROPERTYBROWSER_IMPORT宏为QT_QTPROPERTYBROWSER_EXPORT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后编译，动态库的编译结果如下图，其他测试程序这里没有放出来。&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_property_browser_dll.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;h3 id=&quot;安装文档&quot;&gt;3、安装文档&lt;/h3&gt;
&lt;p&gt;根据INSTALL.txt说明文件，尝试如下两种操作均失败&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加qch文件，发现没有这个文件&lt;/li&gt;
&lt;li&gt;使用添加命令&lt;code&gt;assustant -addContentFile xxx.dcf&lt;/code&gt;添加，报错。&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_install_help.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;后来无意中看到了一片文章&lt;a href=&quot;https://www.bbsmax.com/A/QV5ZjZXZ5y/&quot;&gt;创建文档和自定义的qt assistant&lt;/a&gt;，讲怎么生成Qt帮助文档的，&lt;strong&gt;发现其中有根据qhp文件生成qch文件的方式，尝试了下，居然可以&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;操作步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;qhelpgenerator xxx.qhp -o xxx.qch&lt;/li&gt;
&lt;li&gt;assistant -register xxx.qch&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于我们的qtpropertybrowser代码，可能会像下面这样。首先进入doc\html目录下，然后执行如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;qhelpgenerator qtpropertybrowser.qhp -o qtpropertybrowser.qch&lt;/li&gt;
&lt;li&gt;assistant -register qtpropertybrowser.qch&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_add_qch.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;第二步也可以通过工具来添加，如上图所示。编辑菜单 -&amp;gt; 首选项，选中文档页签，添加自己的qch文件即可。&lt;/p&gt;
&lt;h3 id=&quot;测试文档&quot;&gt;4、测试文档&lt;/h3&gt;
&lt;p&gt;搜索页签下输入&quot;QtPro&quot;，搜索到结果QtProperty，如下图所示，表示我们的文档集成成功。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_doc_result.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;h2 id=&quot;三设计师插件编译&quot;&gt;三、设计师插件编译&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;动态库都有了，设计师插件还会远吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自己写一个Qt插件，把需要导入到desinger中的控件都注册进来即可。&lt;/p&gt;
&lt;p&gt;大致流程如下&lt;/p&gt;
&lt;h3 id=&quot;重写qdesignercustomwidgetinterface&quot;&gt;1、重写QDesignerCustomWidgetInterface&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;WidgetInterface类继承自QDesignerCustomWidgetInterface，WidgetInterface类包含了一些默认行为，这里就不贴出来了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;class TreeBrowserInterface : public WidgetInterface
{
    Q_OBJECT
    Q_INTERFACES( QDesignerCustomWidgetInterface )

public:
    TreeBrowserInterface(QObject * parent);
    virtual QWidget * createWidget( QWidget * parent ) override;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加到插件列表&quot;&gt;2、添加到插件列表&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;WidgetCollectionInterface::WidgetCollectionInterface( QObject * parent /*= nullptr */ )
    : QObject(parent)
{
    d_plugins.append(new QPB::TreeBrowserInterface(this));
    d_plugins.append(new QPB::ButtonBrowserInterface(this));
    d_plugins.append(new QPB::GroupBoxBrowserInterface(this));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拷贝生成的dll&quot;&gt;3、拷贝生成的dll&lt;/h3&gt;
&lt;p&gt;生成的设计师动态库拷贝到Qt安装目录下，具体目录为和bin同级plugins目录下的designer文件夹中&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_desinger_dll.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;h3 id=&quot;重启qt-designer&quot;&gt;4、重启Qt Designer&lt;/h3&gt;
&lt;p&gt;重新启动设计师后，Widget Box列表中多了3个控件。&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_designer_plugin.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;一切准备就绪，剩下的就是自己玩儿了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于怎么写设计师插件，不是本文的重点，想学习的同学直接去百度即可&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四多说一句&quot;&gt;四、多说一句&lt;/h2&gt;
&lt;p&gt;qt-solutions是一个Qt官方维护的开源库，其中有8个项目，QtTreePropertyBrowser就是我们今天讲到的其中一个。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1494185/o_qt_solutions.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;这个8个模块如下列表：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;qtbrowserplugin 浏览器插件&lt;/li&gt;
&lt;li&gt;qtlockedfile 锁定文件&lt;/li&gt;
&lt;li&gt;qtpropertybrowser 属性编辑器&lt;/li&gt;
&lt;li&gt;qtscriptclassic 脚本支持&lt;/li&gt;
&lt;li&gt;qtservice 提供服务属性&lt;/li&gt;
&lt;li&gt;qtsingleapplication 单例运行&lt;/li&gt;
&lt;li&gt;qtsoap SOAP协议&lt;/li&gt;
&lt;li&gt;qtwinmigrate 混合运行，qt写界面dll，集成到Win32工程中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;表格树控件QtTreePropertyBrowser的运行效果，可以到&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11117259.html&quot;&gt;超级实用的表格树控件--QtTreePropertyBrowser&lt;/a&gt;这篇文章中查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有人说，Qt.Soluations这个库的代码时基于Qt4写的，而且最后的测试时间也是Qt4.4，最好使用Qt新版本的qtpropertybrowser代码，这里我自己也进行了测试，&lt;strong&gt;直接把Qt5的代码覆盖当前版本的代码，编译也是能通过的，唯一比较坑的一点就是不能作为动态库使用了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我就屁颠屁颠的，把所有需要导出的类都添加了导出宏，手都给我加酸了。&lt;/p&gt;
&lt;p&gt;随着后续对这个控件的使用，具体细节上的区别等以后再过来完善。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写到最后，使用Beyond Compare工具进行了两份代码的对比，其实本质上差别不大。 目前发现的唯一一个区别较大的就是QtTreePropertyBrowser这个类中使用的树控件问题了，Qt4时使用的是QTreeView，而到了Qt5使用的是QTreeWidget。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;五相关文章&quot;&gt;五、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11117259.html&quot;&gt;超级实用的表格树控件--QtTreePropertyBrowser&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bbsmax.com/A/QV5ZjZXZ5y/&quot;&gt;创建文档和自定义的qt assistant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yizhou2010/article/details/52994134/&quot;&gt;QtPropertyBrowser控件在Qt5.5上的安装配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上内容，基本就是本篇文章的所有内容啦！表格树控件可以使用起来了。希望可以帮到大家。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一起期待后续封装完善的控件。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;照着文章一步一步进行，所有库应该都可以编译通过，如果实在搞不定需要工程代码的可以留邮箱&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Wed, 03 Jul 2019 15:53:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 原文链接： '表格树控件QtTreePropertyBrowser编译成动态库(设计师插件)' 一、回顾 上一篇文章 '超级实用的表格树控件 QtTreePropertyBrowser'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11129274.html</dc:identifier>
</item>
</channel>
</rss>