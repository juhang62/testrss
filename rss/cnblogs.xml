<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>pytest之收集用例规则与运行指定用例 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-3.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;上篇文章相信大家已经了解了pytest在cmd下结合各种命令行参数如何运行测试用例，并输出我们想要看到的信息。那么今天会讲解一下pytest是如何收集我们写好的用例？我们又有哪些方式来运行单个用例或者批量运行用例呢？下面将为大家一一解答！&lt;/p&gt;
&lt;h3&gt;pytest收集用例原理分析&lt;/h3&gt;
&lt;p&gt;首先我们按照如下目录结构新建我们的项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[pyttest搜索测试用例的规则]
    &lt;/span&gt;|&lt;span&gt;[测试用例目录1]
    &lt;/span&gt;|    |&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
    &lt;/span&gt;|    |&lt;span&gt;test_测试模块1.py
    &lt;/span&gt;|    |&lt;span&gt;test_测试模块2.py
    &lt;/span&gt;|&lt;span&gt;[测试用例目录2]
    &lt;/span&gt;|    |&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
    &lt;/span&gt;|    |&lt;span&gt;test_测试用例1.py
    &lt;/span&gt;|    |&lt;span&gt;测试用例.py
    &lt;/span&gt;|&lt;span&gt;test_测试模块.py
    &lt;/span&gt;|测试用例2.py    
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;代码实例&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# test_测试模块1.py&lt;br/&gt;def&lt;/span&gt;&lt;span&gt; test_testFunc1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n我是一个测试用例! in test_testFunc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我不是一个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; test_测试模块2.py&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass1(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_class_func1(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n 我是一个类里面的测试用例 in test_class_func1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; class_func1(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是类里面的一个普通函数！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; test_测试用例1.py&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass2(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_class_func2(self):

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n 我是一个类里面的测试用例 in test_class_func2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,)
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; class_func2(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是类里面的一个普通函数！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_testFunc2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n我是一个测试用例 in test_testFunc2!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我不是一个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试用例.py&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_testFunc3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n我是一个测试用例! in 测试用例.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我不是一个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; test_测试模块3.py&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_testFunc4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n我是一个测试用例! in test_testFunc4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func4():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我不是一个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass3(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_class_func3(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n 我是一个类里面的测试用例 in test_class_func3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; class_func3(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是类里面的一个普通函数！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试用例2.py&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_testFunc5():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n我是一个测试用例! in test_testFunc5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func5():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我不是一个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; 1 == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们使用cmd命令来执行一下这个项目，看一下究竟会有多少条用例是有效的用例？打开cmd 切换到项目的根目录执行命令 &lt;span&gt;pytest -v&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
D:\pytest搜索测试用例规则&amp;gt;pytest -&lt;span&gt;v
&lt;/span&gt;============================= test session starts =============================&lt;span&gt;
platform win32 &lt;/span&gt;-- Python 3.6.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1 --&lt;span&gt; c:\python36\python.exe
cachedir: .pytest_cache
metadata: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows-10-10.0.17134-SP0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pytest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pluggy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.20.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allure-adaptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.7.10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JAVA_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Java\\jdk1.8.0_181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
rootdir: D:\pytest搜索测试用例规则, inifile:
plugins: metadata&lt;/span&gt;-1.8.0, html-1.20.0, allure-adaptor-1.7.10&lt;span&gt;
collected &lt;/span&gt;6&lt;span&gt; items

&lt;span&gt;test_测试模块3.py::test_testFunc4 PASSED                                 [ &lt;/span&gt;&lt;/span&gt;&lt;span&gt;16%]
test_测试模块3.py::TestClass3::test_class_func3 PASSED                   [ 33%]
测试用例目录1/test_测试模块1.py::test_testFunc1 PASSED                   [ 50%]
测试用例目录1/test_测试模块2.py::TestClass1::test_class_func1 PASSED     [ 66%]
测试用例目录2/test_测试用例1.py::TestClass2::test_class_func2 PASSED     [ 83%]
测试用例目录2/test_测试用例1.py::test_testFunc2 PASSED                   [100%]

&lt;/span&gt;========================== 6 passed &lt;span&gt;in&lt;/span&gt; 0.59 seconds ===========================
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果可以看到一共有6条用例passed，且详细的列出了是哪6条，那么按照我们上面编写的用例其实并不止6条，那么为什么会只运行了6条呢？综合以上的代码结构和我们的执行结果对比，我们应该能发现这样的规律&lt;/p&gt;
&lt;p&gt;pytets会从我们当前运行的目录开始查找所有目录，查找以test_开头的文件且文件中所有以test_开头的函数和以Test开头的类和类里面以test_开头的函数为测试用例。这就是为什么上面之运行了6条测试用例！&lt;/p&gt;
&lt;h3&gt;pytest运行指定测试用例&lt;/h3&gt;
&lt;p&gt;我们仍然使用上面的项目作为演示(cdm切换到项目的根目录)&lt;/p&gt;
&lt;h4&gt;1.运行指定目录下的所有用例&lt;/h4&gt;
&lt;p&gt;我们指定运行测试用例目录1里面的所有用例（&lt;span&gt;pytest -v 测试用例目录1&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
D:\pytest搜索测试用例规则&amp;gt;pytest -&lt;span&gt;v 测试用例目录1
&lt;/span&gt;============================= test session starts =============================&lt;span&gt;
platform win32 &lt;/span&gt;-- Python 3.6.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1 --&lt;span&gt; c:\python36\python.exe
cachedir: .pytest_cache
metadata: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows-10-10.0.17134-SP0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pytest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pluggy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.20.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allure-adaptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.7.10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JAVA_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Java\\jdk1.8.0_181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
rootdir: D:\pytest搜索测试用例规则, inifile:
plugins: metadata&lt;/span&gt;-1.8.0, html-1.20.0, allure-adaptor-1.7.10&lt;span&gt;
collected &lt;/span&gt;2&lt;span&gt; items

测试用例目录1&lt;/span&gt;/test_测试模块1.py::test_testFunc1 PASSED                   [ 50%&lt;span&gt;]
测试用例目录1&lt;/span&gt;/test_测试模块2.py::TestClass1::test_class_func1 PASSED     [100%&lt;span&gt;]

&lt;/span&gt;========================== 2 passed &lt;span&gt;in&lt;/span&gt; 0.05 seconds ===========================&lt;br/&gt;# 这样就会只搜索和指定指定目录下面所有的用
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.运行指定文件中的所有用例&lt;/h4&gt;
&lt;p&gt;我们指定运行test_测试模块1.py（&lt;span&gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块1.py&lt;/span&gt;&lt;/span&gt; ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
D:\pytest搜索测试用例规则&amp;gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块1.py
&lt;/span&gt;============================= test session starts =============================&lt;span&gt;
platform win32 &lt;/span&gt;-- Python 3.6.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1 --&lt;span&gt; c:\python36\python.exe
cachedir: .pytest_cache
metadata: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows-10-10.0.17134-SP0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pytest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pluggy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.20.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allure-adaptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.7.10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JAVA_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Java\\jdk1.8.0_181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
rootdir: D:\pytest搜索测试用例规则, inifile:
plugins: metadata&lt;/span&gt;-1.8.0, html-1.20.0, allure-adaptor-1.7.10&lt;span&gt;
collected &lt;/span&gt;1&lt;span&gt; item

测试用例目录1&lt;/span&gt;/test_测试模块1.py::test_testFunc1 PASSED                   [100%&lt;span&gt;]

&lt;/span&gt;========================== 1 passed &lt;span&gt;in&lt;/span&gt; 0.09 seconds ===========================&lt;br/&gt;# 运行指定文件下的所有用例
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.运行指定文件中的测试类&lt;/h4&gt;
&lt;p&gt;我们指定运行test_测试模块2.py中的测试类Testclass1(&lt;span&gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块2.py::TestClass1&lt;/span&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
D:\pytest搜索测试用例规则&amp;gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块2.py::TestClass1
&lt;/span&gt;============================= test session starts =============================&lt;span&gt;
platform win32 &lt;/span&gt;-- Python 3.6.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1 --&lt;span&gt; c:\python36\python.exe
cachedir: .pytest_cache
metadata: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows-10-10.0.17134-SP0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pytest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pluggy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.20.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allure-adaptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.7.10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JAVA_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Java\\jdk1.8.0_181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
rootdir: D:\pytest搜索测试用例规则, inifile:
plugins: metadata&lt;/span&gt;-1.8.0, html-1.20.0, allure-adaptor-1.7.10&lt;span&gt;
collected &lt;/span&gt;1&lt;span&gt; item

测试用例目录1&lt;/span&gt;/test_测试模块2.py::TestClass1::test_class_func1 PASSED     [100%&lt;span&gt;]

&lt;/span&gt;========================== 1 passed &lt;span&gt;in&lt;/span&gt; 0.05 seconds ===========================&lt;br/&gt;# 运行指定的测试类中的所有测试用
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.运行指定的测试用例函数&lt;/h4&gt;
&lt;p&gt;我们指定运行test_testFunc1(&lt;span&gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块1.py::test_testFunc1&lt;/span&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
D:\pytest搜索测试用例规则&amp;gt;pytest -v 测试用例目录1/&lt;span&gt;test_测试模块1.py::test_testFunc1
&lt;/span&gt;============================= test session starts =============================&lt;span&gt;
platform win32 &lt;/span&gt;-- Python 3.6.4, pytest-3.8.0, py-1.6.0, pluggy-0.7.1 --&lt;span&gt; c:\python36\python.exe
cachedir: .pytest_cache
metadata: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.6.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Platform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows-10-10.0.17134-SP0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pytest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pluggy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.7.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.20.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;allure-adaptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.7.10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JAVA_HOME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Program Files\\Java\\jdk1.8.0_181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
rootdir: D:\pytest搜索测试用例规则, inifile:
plugins: metadata&lt;/span&gt;-1.8.0, html-1.20.0, allure-adaptor-1.7.10&lt;span&gt;
collected &lt;/span&gt;1&lt;span&gt; item

测试用例目录1&lt;/span&gt;/test_测试模块1.py::test_testFunc1 PASSED                   [100%&lt;span&gt;]

&lt;/span&gt;========================== 1 passed &lt;span&gt;in&lt;/span&gt; 0.03 seconds ===========================
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;收集用例规则：搜索所有以test_开头的测试文件，以Test开头的测试类，以test_开头的测试函数&lt;/p&gt;
&lt;p&gt;执行用例规则：从-v 参数输出的执行信息我们就应该能发现，运行指定的目录下用例 使用命令 pytest 目录/目录 即可；运行指定文件使用 pytest 目录/文件 即可；运行指定类或者函数 使用命令 pytest 目录/文件::类名::函数名 或者 pytest 目录/文件::函数名&lt;/p&gt;
&lt;p&gt;搜索用例规则也是我们命名用例文件，测试类，测试函数的规则；执行指定测试用例记住规则即可&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 08:00:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 上篇文章相信大家已经了解了pytest在cmd下结合各种命令行参数如何运行测试用例，并输出我们想要看到的信息。那么今天会讲解一下pytest是如何收集我们写好的用例？我们又有哪些方式来运行单个用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-3.html</dc:identifier>
</item>
<item>
<title>PHP Iterator迭代对象属性 - itbsl</title>
<link>http://www.cnblogs.com/itbsl/p/10690133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itbsl/p/10690133.html</guid>
<description>&lt;p&gt;foreach用法和之前的数组遍历是一样的，只不过这里遍历的key是属性名，value是属性值。在类外部遍历时，只能遍历到public属性的，因为其它的都是受保护的，类外部不可见。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class HardDiskDrive {

    public $brand;
    public $color;
    public $cpu;
    public $workState;

    protected $memory;
    protected $hardDisk;

    private $price;

    public function __construct($brand, $color, $cpu, $workState, $memory, $hardDisk, $price) {

        $this-&amp;gt;brand = $brand;
        $this-&amp;gt;color = $color;
        $this-&amp;gt;cpu   = $cpu;
        $this-&amp;gt;workState = $workState;
        $this-&amp;gt;memory = $memory;
        $this-&amp;gt;hardDisk = $hardDisk;
        $this-&amp;gt;price = $price;
    }

}

$hardDiskDrive = new HardDiskDrive('希捷', 'silver', 'tencent', 'well', '1T', 'hard', '$456');

foreach ($hardDiskDrive as $property =&amp;gt; $value) {

    var_dump($property, $value);
    echo '&amp;lt;br&amp;gt;';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;string(5) &quot;brand&quot; string(6) &quot;希捷&quot; 
string(5) &quot;color&quot; string(6) &quot;silver&quot; 
string(3) &quot;cpu&quot; string(7) &quot;tencent&quot; 
string(9) &quot;workState&quot; string(4) &quot;well&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出结果我们也可以看得出来常规遍历是无法访问受保护的属性的。&lt;br/&gt;如果我们想遍历出对象的所有属性，就需要控制foreach的行为，就需要给类对象，提供更多的功能，需要继承自Iterator的接口:&lt;br/&gt;该接口，实现了foreach需要的每个操作。foreach的执行流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720430/201904/720430-20190411154246366-1474278308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看图例中，foreach中有几个关键步骤：5个。&lt;/p&gt;
&lt;p&gt;而Iterator迭代器中所要求的实现的5个方法，就是用来帮助foreach,实现在遍历对象时的5个关键步骤：&lt;/p&gt;
&lt;p&gt;当foreach去遍历对象时, 如果发现对象实现了Ierator接口, 则执行以上5个步骤时, 不是foreach的默认行为, 而是调用对象的对应方法即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720430/201904/720430-20190411154253007-1474559548.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class Team implements Iterator {

    //private $name = 'itbsl';
    //private $age  = 25;
    //private $hobby = 'fishing';

    private $info = ['itbsl', 25, 'fishing'];

    public function rewind()
    {
        reset($this-&amp;gt;info); //重置数组指针
    }

    public function valid()
    {
        //如果为null,表示没有元素，返回false
        //如果不为null,返回true

        return !is_null(key($this-&amp;gt;info));
    }

    public function current()
    {
        return current($this-&amp;gt;info);
    }

    public function key()
    {
        return key($this-&amp;gt;info);
    }

    public function next()
    {
        return next($this-&amp;gt;info);
    }

}

$team = new Team();

foreach ($team as $property =&amp;gt; $value) {

    var_dump($property, $value);
    echo '&amp;lt;br&amp;gt;';
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 11 Apr 2019 07:43:00 +0000</pubDate>
<dc:creator>itbsl</dc:creator>
<og:description>foreach用法和之前的数组遍历是一样的，只不过这里遍历的key是属性名，value是属性值。在类外部遍历时，只能遍历到public属性的，因为其它的都是受保护的，类外部不可见。 输出结果为: 通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itbsl/p/10690133.html</dc:identifier>
</item>
<item>
<title>Spring系列__02.ioc模块简介 - 本墨</title>
<link>http://www.cnblogs.com/JackHou/p/10690074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JackHou/p/10690074.html</guid>
<description>&lt;p&gt;Spring的两大核心功能就是IOC和AOP，这篇文章主要介绍IOC。&lt;br/&gt;简单来说，在面向对象思想下，A类中有一个B类的属性， 那么我们在创建A类时往往需要同时创建一个B类的对象，以便A类对其进行调用。但是，这样的后果便是，A类和B类的耦合度过高。所谓的IOC(控制反转)，或者其实现的方式DI(依赖注入)。 实质就是Spring容器负责来创建A类、B类的实例，并在用户使用的时候将引用提供给用户。这样的好处就是用户不需要考虑创建实例，同时在一定程度上进行了解耦。&lt;/p&gt;

&lt;h2 id=&quot;配置形式&quot;&gt;1.配置形式：&lt;/h2&gt;
&lt;p&gt;有三种配置形式，但是通常说两种：xml文件和注解，(有些书籍上说第三种是主动装配)。本文中主要介绍xml形式进行bean的配置。&lt;/p&gt;
&lt;h2 id=&quot;配置方式&quot;&gt;2.配置方式：&lt;/h2&gt;
&lt;p&gt;bean的配置方式有三种：通过反射的方式进行配置；通过工厂方法(静态工厂、实例工厂)；通过Spring提供的FactoryBean进行配置。&lt;/p&gt;
&lt;h2 id=&quot;依赖注入的方式属性注入构造器注入&quot;&gt;3.依赖注入的方式：属性注入、构造器注入&lt;/h2&gt;
&lt;p&gt;属性注入就是调用setter方法进行属性注入， 构造器注入方式是调用重载的带参构造器。&lt;br/&gt;说到这里，可以来一些代码了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        bean的配置方式1：通过全类名方式(反射)
        id：IOC容器中唯一存在，若不指定会默认使用全类名
    --&amp;gt;
    &amp;lt;bean id=&quot;car&quot; class=&quot;com.spring.demo.bean.Car&quot;&amp;gt;
 &amp;lt;!--
        依赖注入方式1：属性注入，属性注入是通过setter方法注入bean的属性值或者依赖的对象。
        也是实际应用中最常用的方式。
        name指定属性值，value或者value节点指定属性值，ref指定依赖的对象
    --&amp;gt;
        &amp;lt;property name=&quot;company&quot; value=&quot;大众&quot;/&amp;gt;
        &amp;lt;property name=&quot;brand&quot; value=&quot;宝来&quot;/&amp;gt;
        &amp;lt;property name=&quot;price&quot; value=&quot;200000.00&quot;/&amp;gt;
        &amp;lt;property name=&quot;maxSpeed&quot; value=&quot;200&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--
       依赖注入方式2：构造器注入
       通过构造方法注入属性，能够保证bean在实例化后就能使用
       没有name属性，默认按照构造器的变量顺序加载，也可以通过index或者type进行限制
   --&amp;gt;
    &amp;lt;!--
       若一个 bean 有多个构造器, 如何通过构造器来为 bean 的属性赋值
       可以根据 index 和 value 进行更加精确的定位. (了解)
       也可以通过name来具体制定属性名进行绑定
       若字面值中包含特殊字符, 则可以使用 DCDATA 来进行赋值. (了解)
       使用构造器方式注入属性值时，可以使用type或index来区别重载构造器
   --&amp;gt;
    &amp;lt;bean id=&quot;car1&quot; class=&quot;com.spring.demo.bean.Car&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;宝马&quot; type=&quot;java.lang.String&quot;/&amp;gt;
        &amp;lt;constructor-arg value=&quot;mini&quot; type=&quot;java.lang.String&quot;/&amp;gt;
        &amp;lt;constructor-arg value=&quot;200000.00&quot; type=&quot;double&quot;/&amp;gt;
        &amp;lt;constructor-arg value=&quot;240&quot; type=&quot;int&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--
        依赖注入方式3：工厂方法注入
        因为这种方法比较少使用，这里只是写一下注释，没有demo
     --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ioc容器beanfactory和applicationcontext简介&quot;&gt;4.IOC容器BeanFactory和ApplicationContext简介&lt;/h2&gt;
&lt;p&gt;.BeanFactory是Spirng框架的基础设施，面向Spring本身；ApplicationContext是BeanFactory的子接口，面向Spring框架的应用者，其提供了更多的功能。&lt;br/&gt;ApplicationContext具有两个只要的实现类：ClasspathXmlApplicationContext和FileSystemXmlApplicationContext；前者通过在类路径下加载配置文件来完成bean的装配，后者从文件系统下加载配置文件。项目结构如下所示：&lt;br/&gt;&lt;img src=&quot;https://github.com/houyuanbin/Blog/blob/master/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%9B%BE/1.png&quot; title=&quot;标题文字&quot; alt=&quot;插图1&quot;/&gt;&lt;br/&gt;在这里，则可以进行测试了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
    public void teStetter() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-ioc.xml&quot;);
        Car car = (Car) context.getBean(&quot;car&quot;);
        System.out.println(car);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字面值&quot;&gt;5.字面值&lt;/h2&gt;
&lt;p&gt;字面值可以用value标签或者value属性进行注入。基本类型及其包装类、String等都是采用字面值的方式进行注入。当具有特殊字符的时候，需要特殊处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        value简介：
            基本类型及其包装类、String都可以通过value标签或者value属性注入，
            当字面值包含特殊字符的时候，可用&amp;lt;![CDATA[]]&amp;gt;包含
     --&amp;gt;
    &amp;lt;bean id=&quot;car2&quot; class=&quot;com.spring.demo.bean.Car&quot;&amp;gt;
        &amp;lt;property name=&quot;company&quot; value=&quot;大众&quot;/&amp;gt;
        &amp;lt;property name=&quot;brand&quot;&amp;gt;
            &amp;lt;value&amp;gt;&amp;lt;![CDATA[&amp;lt;DZ宝来&amp;gt;]]&amp;gt;&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;maxSpeed&quot; value=&quot;200&quot;/&amp;gt;
        &amp;lt;property name=&quot;price&quot; value=&quot;200000.00&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring中某一属性不进行显式声明时，其会采用默认值，当然你可以显式的注入null：适应null标签&lt;br/&gt;同时，spring支持级联属性的注入。&lt;/p&gt;
&lt;h2 id=&quot;引用其他bean&quot;&gt;6.引用其他bean&lt;/h2&gt;
&lt;p&gt;当需要引用其他的bean时(A类引用B类)，可以通过ref标签或者ref属性进行注入。其用法和value类似。泣别：value注入的是字面值，ref注入的是一个引用。当然，内部bean的注入也是这种方式。&lt;br/&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        引入其他bean：
            例如person有car属性，需要引入,这是就不是使用value属性了，
            而是使用ref指定需要引入的bean
            也可以声明一个内部bean，此时内部bean就无需再指定id了，道理和内部类相似
    --&amp;gt;
    &amp;lt;bean id=&quot;person&quot; class=&quot;com.spring.demo.bean.Person&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;丽丽&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt;
        &amp;lt;property name=&quot;car&quot; ref=&quot;car&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- innerBean --&amp;gt;
    &amp;lt;bean id=&quot;person1&quot; class=&quot;com.spring.demo.bean.Person&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;丽丽&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt;
        &amp;lt;property name=&quot;car&quot;&amp;gt;
            &amp;lt;bean class=&quot;com.spring.demo.bean.Car&quot;&amp;gt;
                &amp;lt;property name=&quot;brand&quot; value=&quot;BMW&quot;/&amp;gt;
                &amp;lt;property name=&quot;company&quot; value=&quot;BMW&quot;/&amp;gt;
                &amp;lt;property name=&quot;maxSpeed&quot; value=&quot;233&quot;/&amp;gt;
                &amp;lt;property name=&quot;price&quot; value=&quot;233333.33&quot;/&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/houyuanbin/Blog/blob/master/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%9B%BE/2.png&quot; title=&quot;标题文字&quot; alt=&quot;插图2&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合属性&quot;&gt;7.集合属性&lt;/h2&gt;
&lt;p&gt;在Spring中可以通过xml标签配置集合属性：&lt;/p&gt;
&lt;h3 id=&quot;list和数组&quot;&gt;1.list和数组&lt;/h3&gt;
&lt;p&gt;配置java.util.LIst和数组类型时，可以通过标签来配置，list中的属性可以使用value标签或者ref标签。&lt;br/&gt;可以使用utility scheme来单独定义集合，这样的好处就是方便其他bean进行引用。&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;2.set&lt;/h3&gt;
&lt;p&gt;set的情况和list相似，使用set标签，用法和list标签一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        集合属性:
            list标签：数组和list数据使用这个标签，
            set标签：set数据使用，使用方法同list标签
    --&amp;gt;
    &amp;lt;bean id=&quot;stu&quot; class=&quot;com.spring.demo.bean.Student&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;苏大强&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;60&quot;/&amp;gt;
        &amp;lt;property name=&quot;cars&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;ref bean=&quot;car&quot;/&amp;gt;
                &amp;lt;ref bean=&quot;car1&quot;/&amp;gt;
                &amp;lt;ref bean=&quot;car2&quot;/&amp;gt;
                &amp;lt;ref bean=&quot;car3&quot;/&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--
        也可以单独定义list，然后直接绑定
    --&amp;gt;
    &amp;lt;util:list id=&quot;carList&quot;&amp;gt;
        &amp;lt;ref bean=&quot;car&quot;/&amp;gt;
        &amp;lt;ref bean=&quot;car1&quot;/&amp;gt;
        &amp;lt;ref bean=&quot;car2&quot;/&amp;gt;
        &amp;lt;ref bean=&quot;car3&quot;/&amp;gt;
    &amp;lt;/util:list&amp;gt;

    &amp;lt;bean id=&quot;stu1&quot; class=&quot;com.spring.demo.bean.Student&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;苏大强&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;60&quot;/&amp;gt;
        &amp;lt;property name=&quot;cars&quot; ref=&quot;carList&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map和properties&quot;&gt;3.map和properties&lt;/h3&gt;
&lt;p&gt;java.util.Map可以通过map标签进行指定，map标签中有多个entity子标签，每个entity定义一对键值对。&lt;br/&gt;在entity中可以通过key属性或者key标签来指定键，同理可以使用value、ref、bean、null属性或者标签指定值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        map:
            map的使用可list相似，使用entry标签来保存每一对键值对，
            同时可以使用key属性或者key标签来存储key，
            value值或value属性绑定普通的字面值，ref绑定其他bean作为值
    --&amp;gt;
    &amp;lt;bean id=&quot;teacher&quot; class=&quot;com.spring.demo.bean.Teacher&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;张莉&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;24&quot;/&amp;gt;
        &amp;lt;property name=&quot;carMap&quot;&amp;gt;
            &amp;lt;map&amp;gt;
                &amp;lt;entry key=&quot;car&quot; value-ref=&quot;car&quot;/&amp;gt;
                &amp;lt;entry key=&quot;car1&quot; value-ref=&quot;car1&quot;/&amp;gt;
                &amp;lt;entry key=&quot;car2&quot; value-ref=&quot;car2&quot;/&amp;gt;
                &amp;lt;entry key=&quot;car3&quot; value-ref=&quot;car3&quot;/&amp;gt;
            &amp;lt;/map&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;props标签用来定义java.util.Properties，该标签有子标签prop，具体使用方法与map一样。&lt;/p&gt;
&lt;h2 id=&quot;p命名空间&quot;&gt;8.p命名空间&lt;/h2&gt;
&lt;p&gt;Spring2.5之后支持p命名空间，可以简化xml配置，属性与原来的配置一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        spring2.5之后，可以使用p命名空间来简化属性配置,需要在配置文件中引入p命名空间
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    --&amp;gt;
    &amp;lt;bean id=&quot;car4&quot; class=&quot;com.spring.demo.bean.Car&quot; p:brand=&quot;宝马&quot; p:company=&quot;宝马&quot;
          p:price=&quot;2000000.00&quot; p:maxSpeed=&quot;200&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;autowire&quot;&gt;8.autowire&lt;/h2&gt;
&lt;p&gt;Spring的IOC容器可以通过自动装配来配置bean，使用方式就是使用autowire属性，有两种模式：byName和byType。byName会在Spring容器中根据名字取寻找匹配的bean，没有的话就无法完成装配；&lt;br/&gt;byType会在Spring容器中按照类型来查找并进行bean的配置，但是当找到多个符合条件的类型的bean时会报异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 自动装配: 只声明 bean, 而把 bean 之间的关系交给 IOC 容器来完成 --&amp;gt;
    &amp;lt;!--
        byType: 根据类型进行自动装配. 但要求 IOC 容器中只有一个类型对应的 bean, 若有多个则无法完成自动装配.
        byName: 若属性名和某一个 bean 的 id 名一致, 即可完成自动装配. 若没有 id 一致的, 则无法完成自动装配
    --&amp;gt;
    &amp;lt;!-- 在使用 XML 配置时, 自动转配用的不多. 但在基于 注解 的配置时, 自动装配使用的较多.  --&amp;gt;
    &amp;lt;bean id=&quot;car&quot; class=&quot;com.spring.demo.bean.Car&quot;&amp;gt;
        &amp;lt;property name=&quot;company&quot; value=&quot;大众&quot;/&amp;gt;
        &amp;lt;property name=&quot;brand&quot; value=&quot;宝来&quot;/&amp;gt;
        &amp;lt;property name=&quot;price&quot; value=&quot;200000.00&quot;/&amp;gt;
        &amp;lt;property name=&quot;maxSpeed&quot; value=&quot;200&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;person&quot; class=&quot;com.spring.demo.bean.Person&quot; autowire=&quot;byName&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;James&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt;
        &amp;lt;property name=&quot;car&quot; ref=&quot;carSub&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

   &amp;lt;!-- &amp;lt;bean id=&quot;person1&quot; class=&quot;com.spring.demo.bean.Person&quot; autowire=&quot;byType&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;James&quot;/&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;23&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;

    &amp;lt;!--
        自动装配的缺点：
            1.autowire默认会为bean装配全部属性，所以当你只想装配部分属性时显得不够灵活；
            2.byName和byType两种模式只能选择一个，不能兼有。
            
    --&amp;gt;

 @Test
    public void testByName() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-autowire.xml&quot;);
        Person person = (Person) context.getBean(&quot;person&quot;);
        System.out.println(person);
    }

    @Test
    public void testByType() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-autowire.xml&quot;);
        Person person = (Person) context.getBean(&quot;person1&quot;);
        System.out.println(person);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean的继承与依赖&quot;&gt;9.bean的继承与依赖&lt;/h2&gt;
&lt;p&gt;作为一个Java程序员，肯定会接触到继承。Spring中也提供了bean的继承，思想和面向对象的继承的思想相似。区别在于Spring中的bean的继承是指bean的配置可以被继承(复用)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        bean的继承：
            你可以定义一个bean并有其他bean继承，这样做的好处是能减少配置
            父bean的配置会由子bean继承，当然部分属性除外(autowire，abstract)
            子bean可以重新赋值一些属性，进行bean重新定义
            父bean可以定义为abstract，定义为abstract的bean只能被继承，不能被注册（实例化）
            父bean可以不定义class属性，由子类自己定义
            子bean需要通过parent属性指定你继承的父bean
    --&amp;gt;
    &amp;lt;bean id=&quot;carSup&quot; class=&quot;com.spring.demo.bean.Car&quot; p:company=&quot;宝马&quot; p:brand=&quot;mini&quot;
          p:maxSpeed=&quot;270&quot; p:price=&quot;300000.00&quot; abstract=&quot;true&quot;/&amp;gt;

    &amp;lt;bean id=&quot;carSub&quot; parent=&quot;carSup&quot;/&amp;gt;

 @Test
    public void testInherit() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-autowire.xml&quot;);
        Car car = (Car) context.getBean(&quot;carSub&quot;);
        System.out.println(car);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本文的开头，我们引入了A类和B类，当你想创建A类时，而A类又必须有B类的变量时，便可以使用依赖来解决这件事：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        bean的依赖：
            你可以声明当前bean依赖于哪些bean，这样当前bean初始化之前会去初始化依赖的bean，
            如果没有注册导致无法初始化便会报错
            依赖多个bean的时候，可以使用逗号或者空格分开
    --&amp;gt;
    &amp;lt;bean id=&quot;person1&quot; parent=&quot;person&quot; depends-on=&quot;carSub&quot;/&amp;gt;

 @Test
    public void testDepends() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-autowire.xml&quot;);
        Person person1 = (Person) context.getBean(&quot;person1&quot;);
        System.out.println(person1);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean的作用域&quot;&gt;9.bean的作用域&lt;/h2&gt;
&lt;p&gt;Spring中的bean的作用域有以下几种：&lt;br/&gt;singleton， property， request，session&lt;br/&gt;默认情况下，spring中每个bean只有一个实例，但是可以显示指定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--
        bean的生命周期：
            singleton：默认选项，IOC容器默认为每个bean只实例化一个实例，该实例在调用具体的bean之前完成。
            property：原型。该方式下IOC容器会在每次调用bean的时候实例化一个新的实例，并且只有在调用时进行bean的初始化
           request和session同JavaWeb中一样，在此不多加介绍
    --&amp;gt;

    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.spring.demo.bean.Dog&quot; p:name=&quot;haki&quot; scope=&quot;prototype&quot;/&amp;gt;

package com.spring.demo.bean;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@AllArgsConstructor
@ToString
public class Dog {
    private String name;
    public Dog() {
        super();
        System.out.println(&quot;dog's constructor&quot;);
    }
}

@Test
    public void testScope() {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-autowire.xml&quot;);
        Dog dog = (Dog) context.getBean(&quot;dog&quot;);
        Dog dog1 = (Dog) context.getBean(&quot;dog&quot;);
        System.out.println(dog == dog1);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的demo中，除了可以查看bean的创建个数，还应该查看bean的创建时机。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 07:36:00 +0000</pubDate>
<dc:creator>本墨</dc:creator>
<og:description>Spring的两大核心功能就是IOC和AOP，这篇文章主要介绍IOC。 简单来说，在面向对象思想下，A类中有一个B类的属性， 那么我们在创建A类时往往需要同时创建一个B类的对象，以便A类对其进行调用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JackHou/p/10690074.html</dc:identifier>
</item>
<item>
<title>面试编程题：使用数组实现一个简单的阻塞队列 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/10689976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/10689976.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这道题是我亲身经历的一道大厂面试题，非常值得分享！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题可以分为两个步骤进行编码解答，第一步是基于数组实现一个队列，第二步是实现线程阻塞。&lt;/p&gt;
&lt;p&gt;如果是基于数组实现栈的数据结构，那么我们只需要一个指针进行来回移动即可。&lt;/p&gt;
&lt;p&gt;想象一下，脑海中有一个竖立起来的栈，指针上移代表元素进栈，指针下移，代表元素出栈，整个过程只需要一个指针进行上下移动即可。&lt;/p&gt;
&lt;p&gt;由此可以写出下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;
import java.util.EmptyStackException;

public class ArrayStack&amp;lt;T&amp;gt; {
    private Object[] elements = new Object[16]; //数组大小默认16
    private int count; //1.-1后指向栈内末尾的元素 2.统计栈内元素的数量

    public void push(T e){
        //数组扩容
        if (count == elements.length){
            elements = Arrays.copyOf(elements,2*count+1);
        }
        elements[count++] = e;
    }

    public T pop(){
        if (count == 0){
            throw new EmptyStackException();
        }
        T o = (T) elements[--count];
        elements[count] = null; //防止内存泄漏
        return o;
    }

    public static void main(String[] args) {
        ArrayStack&amp;lt;Integer&amp;gt; arrayStack = new ArrayStack&amp;lt;&amp;gt;();
        arrayStack.push(1);
        arrayStack.push(2);
        System.out.println(arrayStack.pop()); //2
        System.out.println(arrayStack.pop()); //1
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，基于数组实现队列却需要两个指针进行来回移动。&lt;/p&gt;
&lt;p&gt;想象一下，脑海中有一个横放的空队列，在向队列进行ADD操作时，ADD指针从首端右移，直到移到末端填满队列；在向一个满队列进行GET操作时，GET指针从首端右移，直到移到末端取出所有元素。&lt;/p&gt;
&lt;p&gt;这些步骤都是需要前提条件的，满队列无法进行ADD操作，同理，空队列无法进行GET操作，在ADD和GET操作之前还需要对此进行检查。&lt;/p&gt;
&lt;p&gt;其次，ADD和GET指针会一直循环移动下去，它们移动到末端并不代表任何意义（即ADD指针移动到末端不代表队列已满，GET指针移动到末端不代表队列已空），所以，我们需要一个变量用做计数器，专门负责统计队列元素数量，检查队列是否已满或已空。&lt;/p&gt;
&lt;p&gt;至于阻塞/唤醒部分的逻辑就比较简单了，只需要使GET线程访问空队列时进行阻塞，ADD线程访问满队列时进行阻塞即可，并在GET方法、ADD方法操作结束时唤醒一下对方线程，如果对方正在阻塞状态就可以被唤醒继续向下运行。&lt;/p&gt;
&lt;p&gt;由此可以写出下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ArrayBlockingQueue&amp;lt;T&amp;gt; {
    private Lock lock = new ReentrantLock();
    private Object[] item;
    //两个指针负责ADD与GET操作
    //count负责统计元素数量
    private int addIndex, getIndex, count;
    //等待、通知
    private Condition addCondition = lock.newCondition();
    private Condition getCondition = lock.newCondition();

    public ArrayBlockingQueue(int size) {
        item = new Object[size];
    }

    public void add(T t) {
        lock.lock();
        try {
            System.out.println(&quot;正在ADD对象：&quot; + t);
            while (count == item.length) {
                try {
                    System.out.println(&quot;队列已满，阻塞ADD线程&quot;);
                    addCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列未满，添加对象并使计数器+1
            item[addIndex++] = t;
            count++;
            //ADD指针指向末端，重置
            if (addIndex == item.length) {
                addIndex = 0;
            }
            System.out.println(&quot;唤醒GET线程&quot;);
            getCondition.signal();
        } finally {
            lock.unlock();
        }
    }

    public T get() {
        lock.lock();
        try {
            while (count == 0) {
                try {
                    System.out.println(&quot;队列空了，阻塞GET线程&quot;);
                    getCondition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列不空，获取对象并使计数器-1
            T t = (T) item[getIndex++];
            System.out.println(&quot;正在GET对象：&quot; + t);
            count--;
            //GET指针到达末端、重置
            if (getIndex == item.length) {
                getIndex = 0;
            }
            System.out.println(&quot;唤醒ADD线程&quot;);
            addCondition.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        final ArrayBlockingQueue&amp;lt;Integer&amp;gt; queue = new ArrayBlockingQueue&amp;lt;&amp;gt;(3);
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 3; i++) {
                    queue.add(i);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 3; i++) {
                    queue.get();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

    }
}
//  打印输出：
//        正在ADD对象：0
//        唤醒GET线程
//        正在GET对象：0
//        唤醒ADD线程
//        队列空了，阻塞GET线程
//        正在ADD对象：1
//        唤醒GET线程
//        正在GET对象：1
//        唤醒ADD线程
//        队列空了，阻塞GET线程
//        正在ADD对象：2
//        唤醒GET线程
//        正在GET对象：2
//        唤醒ADD线程&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 11 Apr 2019 07:26:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>这道题是我亲身经历的一道大厂面试题，非常值得分享！ 这道题可以分为两个步骤进行编码解答，第一步是基于数组实现一个队列，第二步是实现线程阻塞。 如果是基于数组实现栈的数据结构，那么我们只需要一个指针进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/10689976.html</dc:identifier>
</item>
<item>
<title>C# -Asp.Net.SignalR.Core之Hub - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/10641531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/10641531.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;程序员的进步是需要环境的，良好的团队环境，良好的开发环境，会让人进步的更加快速。&lt;/p&gt;
&lt;p&gt;所以，我认为，如果一个程序员，在2019年还在用Visual Studio 2005开发，那么，他，大概率，不会想了解Linq是个什么东西，因为他根本用不到。&lt;/p&gt;
&lt;p&gt;就如同我，一直在纯Windows环境下开发，所以就对Core并不是很感兴趣。&lt;/p&gt;
&lt;p&gt;因此，如果一直用Visual Studio 2013以下版本开发的话，估计他对SignalR也就没什么兴趣。&lt;/p&gt;
&lt;p&gt;因为我们都有个坏习惯，用不到的就不喜欢去学习。&lt;/p&gt;
&lt;p&gt;引用SignalR&lt;/p&gt;
&lt;p&gt;闲话少叙，现在我们开始学习SignalR。&lt;/p&gt;
&lt;p&gt;首先，创建一个MVC项目，然后，我们打开Nuget搜索SignalR，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201904/243596-20190410143455349-978214207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功引用后，我们查看引用，会发现程序引用了很多dll，比如Owin等等；这是因为SingalR的依赖项比较多，所以，我们也引用了比较多的DLL。&lt;/p&gt;
&lt;p&gt;接着，我们会发现一个问题，我们添加引用是SignalR，但实际引用进来的却是SignalR.Core，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201904/243596-20190410143837551-765785995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SignalR.Core和SignalR有什么区别呢？&lt;/p&gt;
&lt;p&gt;我们上网查询一下，发现，他们的差异大致上就是下面这句话。&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0fb49-131&quot;&gt;【ASP.NET Core SignalR 不支持自动重新连接。 &lt;span data-ttu-id=&quot;0fb49-132&quot;&gt;如果客户端已断开连接，则用户必须显式启动新连接才能重新连接。 &lt;span data-ttu-id=&quot;0fb49-133&quot;&gt;在 ASP.NET SignalR 中，如果连接断开，SignalR 会尝试重新连接到服务器。】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;差异参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/signalr/version-differences?view=aspnetcore-2.2&quot;&gt;ASP.NET SignalR 和 ASP.NET Core SignalR 之间的差异&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Startup&lt;/p&gt;
&lt;p&gt;SignalR引入完成了，现在我们需要配置和使用它了。&lt;/p&gt;
&lt;p&gt;如何配置呢？很简单。添加Startup文件，修改代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        app.MapSignalR(); 
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Startup文件包含的功能很多，这里暂时不去详解了，我们暂时只要知道，Startup文件会在网站启动时跟着一起运行就可以了。&lt;/p&gt;
&lt;p&gt;因为网站运行时会调用Startup的Configuration方法，所以，我们在这里打开SignalR的映射——app.MapSignalR()，即网站初始化，我们就开启了SignalR的映射。&lt;/p&gt;
&lt;p&gt;Hub&lt;/p&gt;
&lt;p&gt;SignalR简单的来说，是用于一个网页即时通讯的工具，既然是即时通讯，那么肯定就是双工——双向的。&lt;/p&gt;
&lt;p&gt;现在我们先来看下，【网页——&amp;gt;服务器】这个方向的通讯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网页向服务器发送信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们在服务器建立一个Hub，用来接收网页的消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
//这里命名尽量用小写，因为前台只认小写
[HubName(&quot;kibahub&quot;)]
public class kibahub : Hub
{  
    // 这里函数命名虽然是大写，但前台Js调用要用小写字母开头
    public void Send(string message)
    {
        var id = Context.ConnectionId;   
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码很简单，我们建立了一个类，并集成Hub，然后编写了一个Send方法，供页面调用。&lt;/p&gt;
&lt;p&gt;还可以看到，我们在类上面加了一个特性，用来显示的声明这个Hub在网页端的名称。&lt;/p&gt;
&lt;p&gt;接下来，我们编写网页代码，在网页中，使用JavaScript来调用这个Hub的Send方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;~/Scripts/jquery-3.3.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;@*优先signalR引用*@
    &amp;lt;script src=&quot;~/Scripts/jquery.signalR-2.4.0.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;~/Signalr/hubs&quot;&amp;gt;&amp;lt;/script&amp;gt;@*这个是临时生成的文件，里面保存的是我们在服务器定义的hub生成的JavaScript代码*@
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
            &amp;lt;script type='text/javascript'&amp;gt; 
                //引用自动生成的代理，kibahub是HubName注解属性 
                var kibaHub = $.connection.kibahub;
                console.log(&quot;kibaHub get&quot;);
                //开始连接
                $.connection.hub.start().done(function () {
                    console.log(&quot;hub start done&quot;);
                    //客户端发送信息到服务器
                    kibaHub.server.send('kiba');
                    console.log(&quot;Send done&quot;);
                }); 
            &amp;lt;/script&amp;gt; 
   
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码中可以看到，我们首先引用了三个js文件。&lt;/p&gt;
&lt;p&gt;第一个没啥可说的，就是jq的文件。&lt;/p&gt;
&lt;p&gt;第二jquery.signalR-2.4.0.js文件，是我们在引用SignalR时，一起引入进来的，在Scripts文件夹下，我们也直接引入即可。&lt;/p&gt;
&lt;p&gt;第三Signalr/hubs个文件大家应该很奇怪，我们项目里根本没有这个文件夹，也没有这个文件，而且这个hubs文件居然还没有后缀名。&lt;/p&gt;
&lt;p&gt;事实上这个文件夹和文件的确是不存在的，因为，它们是在我们运行网站时，才会生成的临时文件。目前先不去管他是什么，我们只要知道，需要这个引用就可以了。&lt;/p&gt;
&lt;p&gt;接下来，我们看下JavaScript代码。&lt;/p&gt;
&lt;p&gt;在js代码里，我们通过$.connection.kibahub这样一句话就获取到了服务器的kibahub类的实例了，然后，我们只要调用它的Send方法就可以了。&lt;/p&gt;
&lt;p&gt;但是在调用之前，我们需要先连接一下服务器。所以就有了这么一句话 $.connection.hub.start()。&lt;/p&gt;
&lt;p&gt;到此，网页向服务器发送数据已经编写完成了，下面我们运行网站，在浏览器中按下F12进入调试模式，然后选择Console（控制台）来查看我们的输出内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201904/243596-20190411141736779-992745724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我们的SignalR成功的向服务器发出了信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器向网页发送信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网页请求已经发送成功了，现在我们开始编写服务器向网页发送信息。&lt;/p&gt;
&lt;p&gt;首先，我们在kibahub类的Send方法里稍作修改，代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
public void Send(string message)
{
    var id = Context.ConnectionId; 
    IHubContext context = GlobalHost.ConnectionManager.GetHubContext&amp;lt;kibahub&amp;gt;();
    context.Clients.Client(id).getmessage(&quot;518&quot;); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，我们在Send方法中获取了当前连接的唯一标识ConnectionId，然后我们利用这个ConnectionId找到他对应的Client客户端。&lt;/p&gt;
&lt;p&gt;在通过Client客户端调用网页中JavaScript定义的函数getmessage，并向他发送信息518。&lt;/p&gt;
&lt;p&gt;这样服务端的代码就编写完成了。&lt;/p&gt;
&lt;p&gt;但我们会发现，我们好像并没有在网页端用JavaScript定义过函数getmessage呀。&lt;/p&gt;
&lt;p&gt;别着急，我们现在就去网页定义这个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
 &amp;lt;script type='text/javascript'&amp;gt; 
     var kibaHub = $.connection.kibahub; 
     $.connection.hub.start().done(function () {
         console.log(&quot;hub start done&quot;); 
         kibaHub.server.send('kiba');
         console.log(&quot;Send done&quot;);
     });
     kibaHub.client.getmessage = function (message) {
         console.log(&quot;getmessage:&quot; + message);
     };
 &amp;lt;/script&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示。我们可以看到getmessage 已经定义好了，现在我们在运行下网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201904/243596-20190411142924118-602143151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，服务成功的向客户端发出了信息。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;到此Asp.Net.SignalR.Core就介绍完了。&lt;/p&gt;
&lt;p&gt;框架代码已经传到Github上了，欢迎大家下载。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/kiba518/KibaSignalR&quot; target=&quot;_blank&quot;&gt;https://github.com/kiba518/KibaSignalR&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;注：此文章为原创，欢迎转载，请在文章页面明显位置给出此文链接！&lt;br/&gt;若您觉得这篇文章还不错，请点击下方的&lt;span&gt;【&lt;strong&gt;推荐】&lt;/strong&gt;&lt;/span&gt;，非常感谢！&lt;/p&gt;

</description>
<pubDate>Thu, 11 Apr 2019 07:23:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<og:description>前言 程序员的进步是需要环境的，良好的团队环境，良好的开发环境，会让人进步的更加快速。 所以，我认为，如果一个程序员，在2019年还在用Visual Studio 2005开发，那么，他，大概率，不会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/10641531.html</dc:identifier>
</item>
<item>
<title>几道和「黑洞照片」那种海量数据有关的算法问题 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10689490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10689490.html</guid>
<description>&lt;p&gt;昨晚被一则新闻刷屏：北京时间 4 月 10 日今晚 9 点，人类首张黑洞照片正式发布。&lt;/p&gt;
&lt;p&gt;看到这张图片，小吴心里是极为震撼的：爱因斯坦太太太太太牛逼了！！！&lt;/p&gt;
&lt;p&gt;同时，看新闻的时候小吴还注意到里面有个细节，给黑洞”拍照“的事件视界望远镜从 2017 年就开始为黑洞拍照了，但直到 2019 年才公布。&lt;/p&gt;
&lt;p&gt;心里不禁纳闷：为什么给黑洞拍照需要这么长时间？&lt;/p&gt;
&lt;p&gt;于是去更加详细的搜索资料，果然发现了端倪，其中一个点就是 &lt;strong&gt;望远镜观测到的数据量非常庞大&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;2017 年时 8 个望远镜的数据量达到了 10PB（=10240TB），2018 年又增加了格陵兰岛望远镜，数据量继续增加。庞大的数据量为处理让数据处理的难度不断加大。&lt;/p&gt;
&lt;p&gt;平时面试的时候老是说海量数据，海量数据，这次的数据真的是海量数据了。&lt;/p&gt;
&lt;p&gt;这次的数据流之大，导致每个射电望远镜产生的数据，都只能用硬盘来储存。&lt;/p&gt;
&lt;p&gt;那么现在问题来了，假设你作为给黑洞拍照的研发人员，给你一台内存有限的计算机，你如何找出这些数据的中位数或者判断某个数字是否存在里面。&lt;/p&gt;
&lt;h2 id=&quot;h1&quot;&gt;1. 海量数据查找中位数&lt;/h2&gt;
&lt;h3 id=&quot;h&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;现在有 10 亿个 int 型的数字（ java 中 int 型占 4B），以及一台可用内存为 1GB 的机器，如何找出这 10 亿个数字的中位数？&lt;/p&gt;
&lt;p&gt;所谓中位数就是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;题目中有 10 亿个数字，每个数字在内存中占 4B，那么这 10 亿个数字完全加载到内存中需要：10 * 10^8 * 4，大概需要 4GB 的存储空间。根据题目的限制，显然不能把所有的数字都装入内存中。&lt;/p&gt;
&lt;p&gt;这里，可以采用基于 &lt;strong&gt;二进制位比较&lt;/strong&gt; 和 快速排序算法中的 &lt;strong&gt;分割思想&lt;/strong&gt; 来寻找中位数，实际上这也是 &lt;strong&gt;桶排序&lt;/strong&gt; 的一种应用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;桶排序&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/11/16a0b0d79153eaab?w=955&amp;amp;h=539&amp;amp;f=gif&amp;amp;s=1026397&quot; alt=&quot;桶排序&quot;/&gt;桶排序&lt;/p&gt;
&lt;p&gt;假设将这 10 亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制： 1GB )，将每个数字用二进制表示，比较二进制的最高位(第 32 位)，如果数字的最高位为 0，则将这个数字写入 file_0 文件中；如果最高位为 1，则将该数字写入 file_1 文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：最高位为符号位，也就是说 file_1 中的数都是负数，而 file_0 中的数都是正数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过这样的操作，这 10 亿个数字分成了两个文件，假设 file_0 文件中有 6 亿个数字，而 file_1 文件中有 4 亿个数字。&lt;/p&gt;
&lt;p&gt;这样划分后，思考一下：所求的&lt;strong&gt;中位数&lt;/strong&gt;在哪个文件中？&lt;/p&gt;
&lt;p&gt;10 亿个数字的中位数是10 亿个数排序之后的第 5 亿个数，现在 file_0 有 6 亿个正数，file_1 有 4 亿个负数，file_0 中的数都比 file_1 中的数要大，排序之后的第 5 亿个数一定是正数，那么排序之后的第 5 亿个数一定位于file_0中。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;strong&gt;中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 1 亿个数字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，我们只需要处理 file_0 文件了（不需要再考虑 file_1 文件）。&lt;/p&gt;
&lt;p&gt;而对于 file_0 文件，可以同样的采取上面的措施处理：将 file_0 文件依次读一部分到内存(不超内存限制：1GB )，将每个数字用二进制表示，比较二进制的 &lt;strong&gt;次高位（第 31 位），如果数字的次高位为 0，写入 file_0_0 文件中；如果次高位为 1 ，写入 file_0_1 文件中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现假设 file_0_0 文件中有 3 亿个数字，file_0_1中也有 3 亿个数字，则中位数就是：file_0_0 文件中的数字从小到大排序之后的第 1 亿个数字。&lt;/p&gt;
&lt;p&gt;抛弃 file_0_1 文件，继续对 file_0_0 文件 根据次次高位(第 30 位) 划分，假设此次划分的两个文件为：file_0_0_0中有 0.5 亿个数字，file_0_0_1 中有 2.5 亿个数字，那么中位数就是 file_0_0_1 文件中的所有数字排序之后的第 0.5 亿个数。&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;2. 海量数据中判断数字是否存在&lt;/h2&gt;
&lt;h3 id=&quot;h-2&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;现在有 10 亿个 int 型的数字（ java 中 int 型占 4B），以及一台可用内存为 1GB 的机器，给出一个整数，问如果快速地判断这个整数是否在这 10 亿数字中？&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;题目分析&lt;/h3&gt;
&lt;p&gt;这里可以使用 &lt;strong&gt;布隆过滤器&lt;/strong&gt; 进行处理。&lt;/p&gt;
&lt;p&gt;布隆过滤器（英语：Bloom Filter）是 1970 年由 &lt;strong&gt;Burton Bloom&lt;/strong&gt; 提出的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;它实际上是一个很长的二进制矢量和一系列随机映射函数。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它&lt;strong&gt;可以用来判断一个元素是否在一个集合中&lt;/strong&gt;。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。&lt;/p&gt;
&lt;p&gt;对于布隆过滤器而言，它的本质是一个&lt;strong&gt;位数组&lt;/strong&gt;：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。&lt;/p&gt;
&lt;p&gt;一开始，布隆过滤器的位数组所有位都初始化为 0。比如，数组长度为 m ，那么将长度为 m 个位数组的所有的位都初始化为 0。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;td&gt;m-2&lt;/td&gt;
&lt;td&gt;m-1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在数组中的每一位都是二进制位。&lt;/p&gt;
&lt;p&gt;布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。&lt;/li&gt;
&lt;li&gt;根据得到的哈希值，在位数组中把对应下标的值置为 1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;图 1&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/11/16a0b0d7918644c6?w=952&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=34180&quot; alt=&quot;图 1&quot;/&gt;图 1&lt;/p&gt;
&lt;p&gt;举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 &lt;code&gt;arr&lt;/code&gt;。现在要把 &lt;code&gt;2333&lt;/code&gt; 插入布隆过滤器中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对值进行三次哈希计算，得到三个值 n1, n2, n3。&lt;/li&gt;
&lt;li&gt;把位数组中三个元素 arr[n1], arr[n2], arr[3] 都置为 1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当要判断一个值是否在布隆过滤器中，对元素进行三次哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;布隆&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/11/16a0b0d79289f71e?w=953&amp;amp;h=531&amp;amp;f=gif&amp;amp;s=318967&quot; alt=&quot;布隆&quot;/&gt;布隆&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cxyxiaowu.com/articles/2019/04/04/1554346263604.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;小吴在前不久专门分析讲解过此题，更加详细的讲解请点击这里查看~&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hapjin/p/5769087.html&quot;&gt;海量数据查找中位数&lt;/a&gt;：https://www.cnblogs.com/hapjin/p/5769087.html&lt;/p&gt;
&lt;p&gt;个人网站：https://www.cxyxiaowu.com&lt;/p&gt;
&lt;p&gt;公众号：五分钟学算法&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 06:30:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>昨晚被一则新闻刷屏：北京时间 4 月 10 日今晚 9 点，人类首张黑洞照片正式发布。 看到这张图片，小吴心里是极为震撼的：爱因斯坦太太太太太牛逼了！！！ 同时，看新闻的时候小吴还注意到里面有个细节，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10689490.html</dc:identifier>
</item>
<item>
<title>Servlet底层原理、Servlet实现方式、Servlet生命周期 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10688617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10688617.html</guid>
<description>&lt;h2 id=&quot;2servlet定义&quot;&gt;Servlet简介&lt;/h2&gt;
&lt;h3 id=&quot;2servlet定义&quot;&gt;Servlet定义&lt;/h3&gt;
&lt;p&gt;Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。&lt;/p&gt;
&lt;h3 id=&quot;5servlet的特点&quot;&gt;Servlet的特点&lt;/h3&gt;
&lt;p&gt;（1）Servlet对像，由Servlet容器（Tomcat）创建。&lt;/p&gt;
&lt;p&gt;（2）Servlet是一个接口：位于javax.servlet包中。&lt;/p&gt;
&lt;p&gt;（3）service方法用于接收用户的请求并返回响应。&lt;/p&gt;
&lt;p&gt;（4）用户访问时多次被执行（可以统计网站的访问量）。&lt;/p&gt;
&lt;h2 id=&quot;二servlet底层原理&quot;&gt;Servlet底层原理&lt;/h2&gt;
&lt;h3 id=&quot;1javaxservlet-interface-servlet&quot;&gt;Servlet&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; javax.servlet;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Servlet {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; init(ServletConfig var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException;

    ServletConfig getServletConfig();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; service(ServletRequest var1, ServletResponse var2) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException;

    String getServletInfo();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看出Servlet实际上是一个接口，其中包含init、getServletConfig、service、getServletInfo、destroy几个接口方法。&lt;/p&gt;
&lt;h4 id=&quot;1servlet的实现方式一实现servlet接口&quot;&gt;实现Servlet接口&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.chenhao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.Servlet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletResponse;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FirstServlet &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Servlet {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;init方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(ServletConfig paramServletConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;getServletConfig方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletConfig getServletConfig() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;service方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(ServletRequest paramServletRequest,
            ServletResponse paramServletResponse) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException,
            IOException {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;getServletInfo方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getServletInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;destroy方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要实现servlet接口里面所有的方法，这对于我们开发来说是很繁琐的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Servlet 生命周期的方法: 以下方法都是由 Serlvet 容器负责调用.&lt;br/&gt;1). 构造器: 只被调用一次. 只有第一次请求 Servlet 时, 创建 Servlet 的实例. 调用构造器. &lt;strong&gt;这说明 Serlvet 的单实例的!&lt;/strong&gt;&lt;br/&gt;2). init 方法: 只被调用一次. 在创建好实例后立即被调用. 用于初始化当前 Servlet.&lt;br/&gt;3). service: 被多次调用. 每次请求都会调用 service 方法. 实际用于响应请求的.&lt;br/&gt;4). destroy: 只被调用一次. 在当前 Servlet 所在的 WEB 应用被卸载前调用. 用于释放当前 Servlet 所占用的资源.&lt;/p&gt;
&lt;p&gt;下面两个方法是开发者调用&lt;br/&gt;1). getServletConfig: 返回一个ServletConfig对象，其中包含这个servlet初始化和启动参数.&lt;br/&gt;2). getServletinfo: 返回有关servlet的信息，如作者、版本和版权.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;在 web.xml 文件中配置和映射这个 Servlet&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置和映射 Servlet --&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;!-- Servlet 注册的名字 --&amp;gt;
    &amp;lt;servlet-name&amp;gt;helloServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- Servlet 的全类名 --&amp;gt;
    &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.atguigu.javaweb.HelloServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
&amp;lt;/servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;!-- 需要和某一个 servlet 节点的 serlvet-name 子节点的文本节点一致 --&amp;gt;
    &amp;lt;servlet-name&amp;gt;helloServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- 映射具体的访问路径: / 代表当前 WEB 应用的根目录. --&amp;gt;
    &amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190411111053747-132608403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;load-on-startup 参数&lt;/h4&gt;
&lt;p&gt;1). 配置在 servlet 节点中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;!-- Servlet 注册的名字 --&amp;gt;
    &amp;lt;servlet-name&amp;gt;secondServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- Servlet 的全类名 --&amp;gt;
    &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.atguigu.javaweb.SecondServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;!-- 可以指定 Servlet 被创建的时机 --&amp;gt;
    &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2). load-on-startup: 可以指定 Serlvet 被创建的时机. 若为负数, 则在第一次请求时被创建.若为 0 或正数, 则在当前 WEB 应用被Serlvet 容器加载时创建实例, 且数组越小越早被创建.&lt;/p&gt;
&lt;h4&gt;关于 serlvet-mapping&lt;/h4&gt;
&lt;p&gt;1). 同一个Servlet可以被映射到多个URL上，即多个 &amp;lt;servlet-mapping&amp;gt; 元素的&amp;lt;servlet-name&amp;gt;子元素的设置值可以是同一个&lt;br/&gt;Servlet的注册名。&lt;/p&gt;
&lt;p&gt;2). 在Servlet映射到的URL中也可以使用 * 通配符，但是只能有两种固定的格式：&lt;br/&gt;一种格式是“*.扩展名”，另一种格式是以正斜杠（/）开头并以“/*”结尾。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;secondServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;

OR

&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;secondServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: 以下的既带 / 又带扩展名的不合法. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;secondServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.action&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Servlet生命周期&lt;/h4&gt;
&lt;p&gt;实例化：在第一次访问或启动tomcat时，tomcat会调用此无参构造方法实例化servlet。&lt;/p&gt;
&lt;p&gt;初始化：tomcat在实例化此servlet后，会立即调用init方法初始化servlet。&lt;/p&gt;
&lt;p&gt;就绪：容器收到请求后调用servlet的service方法来处理请求。&lt;/p&gt;
&lt;p&gt;销毁：容器依据自身算法删除servlet对象，删除前会调用destory方法&lt;/p&gt;
&lt;p&gt;其中实例化，初始化，销毁只会执行一次，service方法执行多次，默认情况下servlet是在第一次接受到用户请求的情况下才会实例化，可以在web.xml中的&amp;lt;servlet&amp;gt;&amp;lt;servlet&amp;gt;标签内添加一个&amp;lt;load-on-startup&amp;gt;1&amp;lt;load-on-startup&amp;gt;配置，此时在启动tomcat时会创建servlet实例。&lt;/p&gt;
&lt;h4&gt;ServletConfig&lt;/h4&gt;
&lt;p&gt;封装了 Serlvet 的配置信息, 并且可以获取 ServletContext 对象&lt;/p&gt;
&lt;p&gt;1). 配置 Serlvet 的初始化参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;helloServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.atguigu.javaweb.HelloServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    
    &amp;lt;!-- 配置 Serlvet 的初始化参数。 且节点必须在 load-on-startup 节点的前面 --&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;!-- 参数名 --&amp;gt;
        &amp;lt;param-name&amp;gt;user&amp;lt;/param-name&amp;gt;
        &amp;lt;!-- 参数值 --&amp;gt;
        &amp;lt;param-value&amp;gt;root&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;password&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;1230&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    
    &amp;lt;load-on-startup&amp;gt;-1&amp;lt;/load-on-startup&amp;gt;
    
&amp;lt;/servlet&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2). 获取初始化参数: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;getInitParameter(String name): 获取指定参数名的初始化参数
getInitParameterNames(): 获取参数名组成的 Enumeration 对象. 

String user &lt;/span&gt;= servletConfig.getInitParameter(&quot;user&quot;&lt;span&gt;);
System.out.println(&lt;/span&gt;&quot;user： &quot; +&lt;span&gt; user);

Enumeration&lt;/span&gt;&amp;lt;String&amp;gt; names =&lt;span&gt; servletConfig.getInitParameterNames();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(names.hasMoreElements()){
    String name &lt;/span&gt;=&lt;span&gt; names.nextElement();
    String value &lt;/span&gt;=&lt;span&gt; servletConfig.getInitParameter(name);
    System.out.println(&lt;/span&gt;&quot;^^&quot; + name + &quot;: &quot; +&lt;span&gt; value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;ServletContext&lt;/h4&gt;
&lt;p&gt;1). 可以由 SerlvetConfig 获取:&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;ServletContext servletContext = servletConfig.getServletContext();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2). 该对象代表当前 WEB 应用: 可以认为 SerlvetContext 是当前 WEB 应用的一个大管家. 可以从中获取到当前 WEB 应用的各个方面的信息.&lt;/p&gt;
&lt;p&gt;①. 获取当前 WEB 应用的初始化参数&lt;/p&gt;
&lt;p&gt;设置初始化参数: 可以为所有的 Servlet 所获取, 而 Servlet 的初始化参数只用那个 Serlvet 可以获取.&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&amp;lt;!-- 配置当前 WEB 应用的初始化参数 --&amp;gt;&lt;br/&gt;&amp;lt;context-param&amp;gt;&lt;br/&gt;　　&amp;lt;param-name&amp;gt;driver&amp;lt;/param-name&amp;gt;&lt;br/&gt;　　&amp;lt;param-value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/param-value&amp;gt;&lt;br/&gt;&amp;lt;/context-param&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot; readability=&quot;4.5&quot;&gt;
&lt;code readability=&quot;3&quot;&gt;ServletContext servletContext = servletConfig.getServletContext();&lt;br/&gt;String driver = servletContext.getInitParameter(&quot;driver&quot;);&lt;br/&gt;System.out.println(&quot;driver:&quot; + driver);&lt;p&gt;Enumeration&amp;lt;String&amp;gt; names2 = servletContext.getInitParameterNames();&lt;br/&gt;while(names2.hasMoreElements()){&lt;br/&gt;　　String name = names2.nextElement();&lt;br/&gt;　　System.out.println(&quot;--&amp;gt;&quot; + name); &lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;②. 获取当前 WEB 应用的某一个文件在服务器上的绝对路径, 而不是部署前的路径&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;String realPath = servletContext.getRealPath(&quot;/note.txt&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;③. 获取当前 WEB 应用的名称: &lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;String contextPath = servletContext.getContextPath();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;④. 获取当前 WEB 应用的某一个文件对应的输入流. &lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;InputStream is2 = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/jdbc.properties&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;如何在 Serlvet 中获取请求信息&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1). Servlet 的 service() 方法用于应答请求: 因为每次请求都会调用 service() 方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code&gt;public void service(ServletRequest request, ServletResponse response)throws ServletException, IOException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServletRequest: 封装了请求信息. 可以从中获取到任何的请求信息.&lt;br/&gt;ServletResponse: 封装了响应信息, 如果想给用户什么响应, 具体可以使用该接口的方法实现.&lt;/p&gt;
&lt;p&gt;这两个接口的实现类都是服务器给予实现的, 并在服务器调用 service 方法时传入.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2). ServletRequest: 封装了请求信息. 可以从中获取到任何的请求信息.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①. 获取请求参数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; String getParameter(String name): 根据请求参数的名字, 返回参数值. 

若请求参数有多个值(例如 checkbox), 该方法只能获取到第一个提交的值.

&lt;/span&gt;&amp;gt;&lt;span&gt; String[] getParameterValues(String name): 根据请求参数的名字, 返回请求参数对应的字符串数组.

&lt;/span&gt;&amp;gt;&lt;span&gt; Enumeration getParameterNames(): 返回参数名对应的 Enumeration 对象, 
类似于 ServletConfig(或 ServletContext) 的 getInitParameterNames() 方法.

&lt;/span&gt;&amp;gt; Map getParameterMap(): 返回请求参数的键值对: key: 参数名, value: 参数值, String 数组类型.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②. 获取请求的 URI:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HttpServletRequest httpServletRequest =&lt;span&gt; (HttpServletRequest) request;
    
String requestURI &lt;/span&gt;=&lt;span&gt; httpServletRequest.getRequestURI();
System.out.println(requestURI); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  /day_29/loginServlet&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③. 获取请求方式: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String method =&lt;span&gt; httpServletRequest.getMethod();
System.out.println(method); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④. 若是一个 GET 请求, 获取请求参数对应的那个字符串, 即 ? 后的那个字符串. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String queryString =&lt;span&gt; httpServletRequest.getQueryString();
System.out.println(queryString); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user=atguigu&amp;amp;password=123456&amp;amp;interesting=game&amp;amp;interesting=party&amp;amp;interesting=shopping&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤. 获取请求的 Serlvet 的映射路径 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String servletPath =&lt;span&gt; httpServletRequest.getServletPath();
System.out.println(servletPath);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  /loginServlet&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3). HttpServletRequest: 是 SerlvetRequest 的子接口. 针对于 HTTP 请求所定义. 里边包含了大量获取 HTTP 请求相关的方法. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4). ServletResponse: 封装了响应信息, 如果想给用户什么响应, 具体可以使用该接口的方法实现. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　①. *getWriter(): 返回 PrintWriter 对象. 调用该对象的 print() 方法, 将把 print() 中的参数直接打印到客户的浏览器上. &lt;/p&gt;
&lt;p&gt;　　②. 设置响应的内容类型: response.setContentType(&quot;application/msword&quot;);&lt;/p&gt;
&lt;p&gt;　　③. void sendRedirect(String location): 请求的重定向. (此方法为 HttpServletResponse 中定义.)&lt;/p&gt;

&lt;h3&gt;GenericServlet&lt;/h3&gt;
&lt;p&gt;1). 是一个 Serlvet. 是 Servlet 接口和 ServletConfig 接口的实现类. 但是一个抽象类. 其中的 service 方法为抽象方法&lt;/p&gt;
&lt;p&gt;2). 如果新建的 Servlet 程序直接继承 GenericSerlvet 会使开发更简洁.&lt;/p&gt;
&lt;p&gt;3). 具体实现:&lt;/p&gt;
&lt;p&gt;　　①. 在 GenericServlet 中声明了一个 SerlvetConfig 类型的成员变量, 在 init(ServletConfig) 方法中对其进行了初始化&lt;br/&gt;　　②. 利用 servletConfig 成员变量的方法实现了 ServletConfig 接口的方法&lt;br/&gt;　　③. 还定义了一个 init() 方法, 在 init(SerlvetConfig) 方法中对其进行调用, 子类可以直接覆盖 init() 在其中实现对 Servlet 的初始化.&lt;br/&gt;　　④. 不建议直接覆盖 init(ServletConfig), 因为如果忘记编写 super.init(config); 而还是用了 SerlvetConfig 接口的方法,则会出现空指针异常.&lt;br/&gt;　　⑤. 新建的 init(){} 并非 Serlvet 的生命周期方法. 而 init(ServletConfig) 是生命周期相关的方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericServlet &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Servlet, ServletConfig {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 以下方法为 Servlet 接口的方法 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {}

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletConfig getServletConfig() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletConfig;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getServletInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServletConfig servletConfig;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(ServletConfig arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.servletConfig =&lt;span&gt; arg0;
        init();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException{}

     &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;【注意】唯独service方法没有被实现，还是一个抽象方法，这个service方法必须我们自己去重写&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(ServletRequest arg0, ServletResponse arg1)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 以下方法为 ServletConfig 接口的方法 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getInitParameter(String arg0) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletConfig.getInitParameter(arg0);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Enumeration getInitParameterNames() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletConfig.getInitParameterNames();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletContext getServletContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletConfig.getServletContext();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getServletName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletConfig.getServletName();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;【注意】&lt;/strong&gt;唯独service方法没有被实现，还是一个抽象方法，这个service方法必须我们自己去重写。
&lt;/pre&gt;
&lt;h3&gt;HttpServlet&lt;/h3&gt;
&lt;p&gt;　　1). 是一个 Servlet, 继承自 GenericServlet. 针对于 HTTP 协议所定制.&lt;/p&gt;
&lt;p&gt;　　2). 在 service() 方法中直接把 ServletReuqest 和 ServletResponse 转为 HttpServletRequest 和 HttpServletResponse.并调用了重载的 service(HttpServletRequest, HttpServletResponse)&lt;/p&gt;
&lt;p&gt;　　    在 service(HttpServletRequest, HttpServletResponse) 获取了请求方式: request.getMethod(). 根据请求方式有创建了doXxx() 方法(xxx 为具体的请求方式, 比如 doGet, doPost)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(ServletRequest req, ServletResponse res)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    HttpServletRequest  request;
    HttpServletResponse response;
    
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        request &lt;/span&gt;=&lt;span&gt; (HttpServletRequest) req;
        response &lt;/span&gt;=&lt;span&gt; (HttpServletResponse) res;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassCastException e) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;non-HTTP request or response&quot;&lt;span&gt;);
    }
    service(request, response);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(HttpServletRequest request, HttpServletResponse response)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 获取请求方式.&lt;/span&gt;
    String method =&lt;span&gt; request.getMethod();
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 根据请求方式再调用对应的处理方法&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(&quot;GET&quot;&lt;span&gt;.equalsIgnoreCase(method)){
        doGet(request, response);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;POST&quot;&lt;span&gt;.equalsIgnoreCase(method)){
        doPost(request, response);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPost(HttpServletRequest request, HttpServletResponse response) 
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;    
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doGet(HttpServletRequest request, HttpServletResponse response) 
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3). 实际开发中, 直接继承 HttpServlet, 并根据请求方式复写 doXxx() 方法即可.&lt;/p&gt;
&lt;p&gt;4). 好处: 直接由针对性的覆盖 doXxx() 方法; 直接使用 HttpServletRequest 和 HttpServletResponse, 不再需要强转.&lt;/p&gt;
&lt;h4&gt;推荐博客&lt;/h4&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chen-haozi/p/10227797.html&quot; target=&quot;_blank&quot;&gt;程序员写代码之外，如何再赚一份工资？&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&quot;title-article&quot;&gt;Servlet的生命周期&lt;/h2&gt;
&lt;h3 id=&quot;一servlet生命周期图&quot;&gt;Servlet生命周期图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190411123348548-937154503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二servlet生命周期简述&quot;&gt;Servlet生命周期简述&lt;/h3&gt;
&lt;p&gt;（1）加载和实例化&lt;/p&gt;
&lt;p&gt;　　当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接读取该实例响应请求；如果不存在，就创建一个Servlet实例。&lt;/p&gt;
&lt;p&gt;（2） 初始化&lt;/p&gt;
&lt;p&gt;　　实例化后，Servlet容器将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）。&lt;/p&gt;
&lt;p&gt;（3）服务&lt;/p&gt;
&lt;p&gt;　　初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法,比如 doGet, doPost。&lt;/p&gt;
&lt;p&gt;（4）销毁&lt;/p&gt;
&lt;p&gt;　　当Servlet容器关闭时，Servlet实例也随时销毁。其间，Servlet容器会调用Servlet 的destroy()方法去判断该Servlet是否应当被释放（或回收资源）。&lt;/p&gt;

&lt;p&gt;其中实例化，初始化，销毁只会执行一次，service方法执行多次，默认情况下servlet是在第一次接受到用户请求的情况下才会实例化，可以在web.xml中的&amp;lt;servlet&amp;gt;&amp;lt;servlet&amp;gt;标签内添加一个&amp;lt;load-on-startup&amp;gt;1&amp;lt;load-on-startup&amp;gt;配置，此时在启动tomcat时会创建servlet实例。&lt;/p&gt;

</description>
<pubDate>Thu, 11 Apr 2019 06:09:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>Servlet简介 Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。 Servlet的特点 （1）Servlet对像，由Servlet容器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10688617.html</dc:identifier>
</item>
<item>
<title>配置两个Hadoop集群Kerberos认证跨域互信 - XIAO的博客</title>
<link>http://www.cnblogs.com/xiaodf/p/10689092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaodf/p/10689092.html</guid>
<description>&lt;p&gt;两个Hadoop集群开启Kerberos验证后，集群间不能够相互访问，需要实现Kerberos之间的互信，使用Hadoop集群A的客户端访问Hadoop集群B的服务（实质上是使用Kerberos Realm A上的Ticket实现访问Realm B的服务）。&lt;br/&gt;先决条件：&lt;br/&gt;1）两个集群(IDC.COM和HADOOP.COM)均开启Kerberos认证&lt;br/&gt;2）Kerberos的REALM分别设置为IDC.COM和HADOOP.COM&lt;br/&gt;步骤如下：&lt;/p&gt;

&lt;p&gt;实现DIDC.COM和HADOOP.COM之间的跨域互信，例如使用IDC.COM的客户端访问HADOOP.COM中的服务，两个REALM需要共同拥有名为krbtgt/HADOOP.COM@IDC.COM的principal，两个Keys需要保证密码，version number和加密方式一致。默认情况下互信是单向的， HADOOP.COM的客户端访问IDC.COM的服务，两个REALM需要有krbtgt/IDC.COM@HADOOP.COM的principal。&lt;br/&gt;向两个集群中添加krbtgt principal&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;  #IDC CLUSTER
  kadmin.local: addprinc –e “aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal ” krbtgt/HADOOP.COM@IDC.COM
  kadmin.local: addprinc –e “aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal ”  krbtgt/IDC.COM@HADOOP.COM

  #HADOOP CLUSTER
   kadmin.local: addprinc –e “aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal ” krbtgt/HADOOP.COM@IDC.COM
   kadmin.local: addprinc –e “aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal ”  krbtgt/IDC.COM@HADOOP.COM&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要验证两个entries具有匹配的kvno和加密type，查看命令使用getprinc&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kadmin.local:  getprinc  krbtgt/IDC.COM@HADOOP.COM
Principal: krbtgt/IDC.COM@HADOOP.COM
Expiration date: [never]
Last password change: Wed Jul 05 14:18:11 CST 2017
Password expiration date: [none]
Maximum ticket life: 1 day 00:00:00
Maximum renewable life: 30 days 00:00:00
Last modified: Wed Jul 05 14:18:11 CST 2017 (admin/admin@IDC.COM)
Last successful authentication: [never]
Last failed authentication: [never]
Failed password attempts: 0
Number of keys: 7
Key: vno 1, aes128-cts-hmac-sha1-96
Key: vno 1, des3-cbc-sha1
Key: vno 1, arcfour-hmac
Key: vno 1, camellia256-cts-cmac
Key: vno 1, camellia128-cts-cmac
Key: vno 1, des-hmac-sha1
Key: vno 1, des-cbc-md5
MKey: vno 1
Attributes:
Policy: [none]
kadmin.local:  getprinc  addprinc krbtgt/HADOOP.COM@IDC.COM
usage: get_principal [-terse] principal
kadmin.local:  getprinc  krbtgt/HADOOP.COM@IDC.COM
Principal: krbtgt/HADOOP.COM@IDC.COM
Expiration date: [never]
Last password change: Wed Jul 05 14:17:47 CST 2017
Password expiration date: [none]
Maximum ticket life: 1 day 00:00:00
Maximum renewable life: 30 days 00:00:00
Last modified: Wed Jul 05 14:17:47 CST 2017 (admin/admin@IDC.COM)
Last successful authentication: [never]
Last failed authentication: [never]
Failed password attempts: 0
Number of keys: 7
Key: vno 1, aes128-cts-hmac-sha1-96
Key: vno 1, des3-cbc-sha1
Key: vno 1, arcfour-hmac
Key: vno 1, camellia256-cts-cmac
Key: vno 1, camellia128-cts-cmac
Key: vno 1, des-hmac-sha1
Key: vno 1, des-cbc-md5
MKey: vno 1
Attributes:
Policy: [none]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3445497-cbf92e8585097150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot;/&gt;&lt;br/&gt;设置hadoop.security.auth_to_local参数，该参数用于将principal转变为user，一个需要注意的问题是SASL RPC客户端需要远程Server的Kerberos principal在本身的配置中匹配该principal。相同的pricipal name需要分配给源和目标cluster的服务，例如Source Cluster中的NameNode的kerbeors principal name为nn/h&lt;strong&gt;&lt;em&gt;@IDC.COM，在Destination cluster中NameNode的pricipal设置为nn/h&lt;/em&gt;&lt;/strong&gt;@HADOOP.COM（不能设置为nn2/h***@HADOOP.COM），例如：&lt;br/&gt;在IDC Cluster和 HADOOP Cluster的core-site中增加：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;hadoop.security.auth_to_local&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;
RULE:[1:$1@$0](^.*@HADOOP\.COM$)s/^(.*)@HADOOP\.COM$/$1/g
RULE:[2:$1@$0](^.*@HADOOP\.COM$)s/^(.*)@HADOOP\.COM$/$1/g
RULE:[1:$1@$0](^.*@IDC\.COM$)s/^(.*)@IDC\.COM$/$1/g
RULE:[2:$1@$0](^.*@IDC\.COM$)s/^(.*)@IDC\.COM$/$1/g 
DEFAULT             
&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用hadoop org.apache.hadoop.security.HadoopKerberosName 来实现验证，例如:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@node1a141 ~]#  hadoop org.apache.hadoop.security.HadoopKerberosName hdfs/nodea1a141@IDC.COM

Name: hdfs/nodea1a141@IDC.COM to hdfs &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置capaths&quot;&gt;3.1 配置capaths&lt;/h2&gt;
&lt;p&gt;第一种方式是配置shared hierarchy of names，这个是默认及比较简单的方式，第二种方式是在krb5.conf文件中改变capaths，复杂但是比较灵活，这里采用第二种方式。&lt;br/&gt;在两个集群的节点的/etc/krb5.conf文件配置domain和realm的映射关系，例如：在IDC cluster中配置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[capaths]
       IDC.COM = {
              HADOOP.COM = .
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HADOOP Cluster中配置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; [capaths]
       HADOOP.COM = {
              IDC.COM = .
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置成'.'是表示没有intermediate realms&lt;/p&gt;
&lt;h2 id=&quot;配置realms&quot;&gt;3.2 配置realms&lt;/h2&gt;
&lt;p&gt;为了是IDC 可以访问HADOOP的KDC，需要将HADOOP的KDC Server配置到IDC cluster中，如下，反之相同：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; [realms]
  IDC.COM = {
    kdc = {host}.IDC.COM:88
    admin_server = {host}.IDC.COM:749
    default_domain = IDC.COM
  }
  HADOOP.COM = {
    kdc = {host}.HADOOP.COM:88
    admin_server = {host}.HADOOP.COM:749
    default_domain = HADOOP.COM
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置domain_realm&quot;&gt;3.3 配置domain_realm&lt;/h2&gt;
&lt;p&gt;在domain_realm中，一般配置成'.IDC.COM'和'IDC.COM'的格式，'.'前缀保证kerberos将所有的IDC.COM的主机均映射到IDC.COM realm。但是如果集群中的主机名不是以IDC.COM为后缀的格式，那么需要在domain_realm中配置主机与realm的映射关系，例IDC.nn.local映射为IDC.COM，需要增加IDC.nn.local = IDC.COM。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[domain_realm]
.hadoop.com=HADOOP.COM
 hadoop.com=HADOOP.COM
 .IDC.com=IDC.COM
 IDC.com=IDC.COM
 node1a141 = IDC.COM
 node1a143 = IDC.COM
 node1a210 = HADOOP.COM
 node1a202 = HADOOP.COM
 node1a203 = HADOOP.COM &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启kerberos服务&lt;/p&gt;
&lt;h2 id=&quot;配置hdfs-site.xml&quot;&gt;3.4 配置hdfs-site.xml&lt;/h2&gt;
&lt;p&gt;在hdfs-site.xml，设置允许的realms&lt;br/&gt;在hdfs-site.xml中设置dfs.namenode.kerberos.principal.pattern为&quot;*&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3445497-362cb77b00aac5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot;/&gt;&lt;br/&gt;这个是客户端的匹配规则用于控制允许的认证realms，如果该参数不配置，会有下面的异常：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;java.io.IOException: Failed on local exception: java.io.IOException:
java.lang.IllegalArgumentException:
       Server has invalid Kerberosprincipal:nn/ HADOOP.COM@ IDC.COM;
       Host Details : local host is: &quot;host1.IDC.COM/10.181.22.130&quot;;
                        destination host is: &quot;host2.HADOOP.COM&quot;:8020;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1)使用hdfs命令测试IDC 和HADOOP 集群间的数据访问&lt;br/&gt;例如在IDC Cluster中kinit admin@IDC.COM，然后运行hdfs命令，查看本机群和对方集群得hdfs目录：&lt;br/&gt;如果未开启跨域互信，访问对方hdfs目录时会报认证错误&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@node1a141 ~]# kdestroy

在本机群客户端登陆admin用户,通过kerberos认证
[root@node1a141 ~]# kinit admin
Password for admin@IDC.COM:

访问本集群hdfs 
[root@node1a141 ~]# hdfs dfs -ls /
Found 3 items
drwxrwxrwx+  - hdfs supergroup          0 2017-06-13 15:13 /tmp
drwxrwxr-x+  - hdfs supergroup          0 2017-06-22 15:55 /user
drwxrwxr-x+  - hdfs supergroup          0 2017-06-14 14:11 /wa

访问对方集群hdfs
[root@node1a141 ~]# hdfs dfs -ls hdfs://node1a202:8020/
Found 9 items
drwxr-xr-x   - root  supergroup          0 2017-05-27 18:55 hdfs://node1a202:8020/cdtest
drwx------   - hbase hbase               0 2017-05-22 18:51 hdfs://node1a202:8020/hbase
drwx------   - hbase hbase               0 2017-07-05 19:16 hdfs://node1a202:8020/hbase1
drwxr-xr-x   - hbase hbase               0 2017-05-11 10:46 hdfs://node1a202:8020/hbase2
drwxr-xr-x   - root  supergroup          0 2016-12-01 17:30 hdfs://node1a202:8020/home
drwxr-xr-x   - mdss  supergroup          0 2016-12-13 18:30 hdfs://node1a202:8020/idfs
drwxr-xr-x   - hdfs  supergroup          0 2017-05-22 18:51 hdfs://node1a202:8020/system
drwxrwxrwt   - hdfs  supergroup          0 2017-05-31 17:37 hdfs://node1a202:8020/tmp
drwxrwxr-x+  - hdfs  supergroup          0 2017-05-04 15:48 hdfs://node1a202:8020/user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HADOOP.COM中进行相同的操作&lt;br/&gt;2）运行distcp程序将IDC的数据复制到HADOOP集群，命令如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@node1a141 ~]# hadoop distcp hdfs://node1a141:8020/tmp/test.sh  hdfs://node1a202:8020/tmp/&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;两集群的/etc/krb5.conf完整文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@node1a141 IDC]# cat /etc/krb5.conf
[logging]
 default = FILE:/var/log/krb5libs.log
 kdc = FILE:/var/log/krb5kdc.log
 admin_server = FILE:/var/log/kadmind.log

[libdefaults]
 default_realm = IDC.COM
 dns_lookup_realm = false
 dns_lookup_kdc = false
 ticket_lifetime = 7d
 renew_lifetime = 30
 forwardable = true
 renewable=true
 #default_ccache_name = KEYRING:persistent:%{uid}

[realms]
 HADOOP.COM = {
   kdc = node1a198
   admin_server = node1a198
   default_realm = HADOOP.COM
   supported_enctypes = aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal des-cbc-crc:normal
 }
 IDC.COM = {
   kdc = node1a141
   admin_server = node1a141
   default_realm = IDC.COM
   supported_enctypes = aes128-cts:normal des3-hmac-sha1:normal arcfour-hmac:normal camellia256-cts:normal camellia128-cts:normal des-hmac-sha1:normal des-cbc-md5:normal des-cbc-crc:normal
 }

[domain_realm]
 .hadoop.com=HADOOP.COM
 hadoop.com=HADOOP.COM
 .IDC.com=IDC.COM
 IDC.com=IDC.COM
 node1a141 = IDC.COM
 node1a143 = IDC.COM
 node1a210 = HADOOP.COM
 node1a202 = HADOOP.COM
 node1a203 = HADOOP.COM

[capaths]
IDC.COM = {
 HADOOP.COM = .
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 11 Apr 2019 05:33:00 +0000</pubDate>
<dc:creator>XIAO的博客</dc:creator>
<og:description>两个Hadoop集群开启Kerberos验证后，集群间不能够相互访问，需要实现Kerberos之间的互信，使用Hadoop集群A的客户端访问Hadoop集群B的服务（实质上是使用Kerberos Re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaodf/p/10689092.html</dc:identifier>
</item>
<item>
<title>面试官: 说说看, 什么是 Hook (钩子) 线程以及应用场景? - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10689065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10689065.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490782451488&quot; title=&quot;Hook 钩子线程&quot; alt=&quot;Hook 钩子线程&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3478260869565&quot;&gt;
&lt;p&gt;文章首发自个人微信号: 小哈学Java&lt;/p&gt;
&lt;p&gt;个人网站地址: &lt;a href=&quot;https://www.exception.site/java-concurrency/java-concurrency-hook-thread&quot; class=&quot;uri&quot;&gt;https://www.exception.site/java-concurrency/java-concurrency-hook-thread&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;一、Hook 线程介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;二、Hook 线程的应用场景&amp;amp;注意事项&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三、Hook 线程防应用重启实战&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;四、GitHub 源码地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;五、总结&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一hook-线程介绍&quot;&gt;一、Hook 线程介绍&lt;/h2&gt;
&lt;p&gt;通常情况下，我们可以向应用程序注入一个或多个 Hook (钩子) 线程，这样，在&lt;strong&gt;程序即将退出的时候，也就是 JVM 程序即将退出的时候，Hook 线程就会被启动执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先看一段示例代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490091542366&quot; title=&quot;示例代码&quot; alt=&quot;示例代码&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;①&lt;/strong&gt;：为应用程序注入一个钩子（Hook）线程，线程中，打印了相关日志，包括正在运行以及退出的日志；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;②&lt;/strong&gt;：再次注入一个同样逻辑的钩子（Hook）线程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt;：主线程执行结束，打印日志；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行这段代码，来验证一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490140234446&quot; title=&quot;Hook 线程执行结果&quot; alt=&quot;Hook 线程执行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从打印日志看到，当主线程执行结束，也就是 JVM 进程即将退出的时候，注入的两个 Hook 线程都被启动并打印相关日志。&lt;/p&gt;
&lt;h2 id=&quot;二hook-线程的应用场景注意事项&quot;&gt;二、Hook 线程的应用场景&amp;amp;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;2.1 应用场景&lt;/h3&gt;
&lt;p&gt;上面我们已经知道了， Hook 线程能够在 JVM 程序退出的时候被启动且执行，那么，我们能够通过这种特性，做点什么呢？&lt;/p&gt;
&lt;p&gt;罗列一些常见应用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;防止程序重复执行&lt;/strong&gt;，具体实现可以在程序启动时，校验是否已经生成 lock 文件，如果已经生成，则退出程序，如果未生成，则生成 lock 文件，程序正常执行，最后再注入 Hook 线程，这样在 JVM 退出的时候，线程中再将 lock 文件删除掉；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490317738185&quot; title=&quot;流程图&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS: 这种防止程序重复执行的策略，也被应用于 Mysql 服务器，zookeeper, kafka 等系统中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Hook 线程中也可以执行一些&lt;strong&gt;资源释放&lt;/strong&gt;的操作，比如关闭数据库连接，Socket 连接等。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;注意事项&quot;&gt;2.2 注意事项&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Hook 线程只有在正确接收到退出信号时，才能被正确执行，如果你是通过 &lt;code&gt;kill -9&lt;/code&gt;这种方式，强制杀死的进程，那么抱歉，进程是不会去执行 Hook 线程的，为什么呢？你想啊，它自己都被强制干掉了，哪里还管的上别人呢？&lt;/li&gt;
&lt;li&gt;请不要在 Hook 线程中执行一些耗时的操作，这样会导致程序长时间不能退出。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三hook-线程防应用重启实战&quot;&gt;三、Hook 线程防应用重启实战&lt;/h2&gt;
&lt;p&gt;针对上面防应用重启的场景，利用 Hook 线程，我们来实战一下，贴上代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.File;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

/**
 * @author 犬小哈（微信号: 小哈学Java）
 * @date 2019/4/10
 * @time 下午9:56
 * @discription
 **/
public class PreventDuplicated {

    /** .lock 文件存放路径 */
    private static final String LOCK_FILE_PATH = &quot;./&quot;;
    
    /** .lock 文件名称 */
    private static final String LOCK_FILE_NAME = &quot;.lock&quot;;

    public static void main(String[] args) {

        // 校验 .lock 文件是否已经存在
        checkLockFile();

        // 注入 Hook 线程
        addShutdownHook();

        // 模拟程序一直运行
        for (;;) {
            try {
                TimeUnit.SECONDS.sleep(1);
                System.out.println(&quot;The program is running ...&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * 注入 Hook 线程
     */
    private static void addShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
            // 接受到了退出信号
            System.out.println(&quot;The program received kill signal.&quot;);
            // 删除 .lock 文件
            deleteLockFile();
        }));
    }

    /**
     * 校验 .lock 文件是否已经存在
     */
    private static void checkLockFile() {
        if (isLockFileExisted()) {
            // .lock 文件已存在, 抛出异常, 退出程序
            throw new RuntimeException(&quot;The program already running.&quot;);
        }

        // 不存在，则创建 .lock 文件
        createLockFile();
    }

    /**
     * 创建 .lock 文件
     */
    private static void createLockFile() {
        File file = new File(LOCK_FILE_PATH + LOCK_FILE_NAME);
        try {
            file.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * .lock 文件 是否存在
     * @return
     */
    private static boolean isLockFileExisted() {
        File file = new File(LOCK_FILE_PATH + LOCK_FILE_NAME);
        return file.exists();
    }

    /**
     * 删除 .lock 文件
     */
    private static void deleteLockFile() {
        File file = new File(LOCK_FILE_PATH + LOCK_FILE_NAME);
        file.delete();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，控制台输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490629598066&quot; title=&quot;控制台输出&quot; alt=&quot;控制台输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序一直运行中，再来看下 &lt;code&gt;.lock&lt;/code&gt; 文件是否生成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490618803385&quot; title=&quot;lock 文件&quot; alt=&quot;lock 文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件生成成功，接下来，我们再次运行程序，看看是否能够重复启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490643471195&quot; title=&quot;重复启动程序，抛出异常&quot; alt=&quot;重复启动程序，抛出异常&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，无法重复运行程序，且抛出了 &lt;code&gt;The program already running.&lt;/code&gt; 的运行时异常。接下来，通过 &lt;code&gt;kill pid&lt;/code&gt; 或者 &lt;code&gt;kill -l pid&lt;/code&gt; 命令来结束进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490687717447&quot; title=&quot;Hook 线程被启动了&quot; alt=&quot;Hook 线程被启动了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序在即将退出的时候，启动了 Hook 线程，在看下 &lt;code&gt;.lock&lt;/code&gt; 文件是否已被删除：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155490701454199&quot; title=&quot;.lock 文件被删除了&quot; alt=&quot;.lock 文件被删除了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，Hook 线程代码实战部分结束了。&lt;/p&gt;
&lt;h2 id=&quot;四github-源码地址&quot;&gt;四、GitHub 源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/weiwosuoai/java-concurrent-tutorial&quot; class=&quot;uri&quot;&gt;https://github.com/weiwosuoai/java-concurrent-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;本文中，我们学习了什么是 Hook (钩子) 线程，相关应用场景以及注意事项。祝你学习愉快 ！&lt;/p&gt;
&lt;h2 id=&quot;六ref&quot;&gt;六、Ref&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;《Java 高并发编程详解》&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;欢迎关注微信公众号-小哈学java&quot;&gt;欢迎关注微信公众号: 小哈学Java&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/154874842150997&quot; title=&quot;小哈学Java&quot; alt=&quot;小哈学Java&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 05:27:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>文章首发自个人微信号: 小哈学Java 个人网站地址: 'https://www.exception.site/java concurrency/java concurrency hook threa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10689065.html</dc:identifier>
</item>
<item>
<title>在ZYNQ-7000平台上利用PS点亮PL上的LED灯 - liuyayong</title>
<link>http://www.cnblogs.com/ahead-liuyayong/p/10689021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ahead-liuyayong/p/10689021.html</guid>
<description>&lt;h2&gt;1、实验方案&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145553749-1422430245.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1    实验方案系统框图&lt;/p&gt;
&lt;h2&gt;2、具体步骤&lt;/h2&gt;
&lt;h3&gt;2.1、vivado工程建立&lt;/h3&gt;
&lt;p&gt;①打开vivado集成开发环境，点击“Create Project”，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145733258-139814459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;②点击“Next”，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145745775-1752222708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;③在“Project name”中输入工程名；在“Project location”中选择保存路径；勾选“Create project subdirectory”，最后点击“Next”,如下图所示，注意均不要出现中文。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145828565-673164874.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;④选择“RTL Project”，点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145840583-585065775.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑤点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145850044-337068565.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑥点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145858814-844188914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑦输入芯片型号，然后点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145908186-1292021439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑧点击“Finish”，完成vivado的工程创建，如下图所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145923324-318056424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;h3&gt;2.2、创建一个Block设计&lt;/h3&gt;
&lt;p&gt;⑨IP INTEGRATOR→Create Block Design，在弹出的对话框中输入设计名，最后点击“OK”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145938951-1348638487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑩点击“+”，在搜索框中输入“zynq”找到“ZYNQ7 Processing System”，双击就可以将ZYNQ处理器添加到设计中了，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145948101-866737546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑪双击ZYNQ→DDR Configuration→DDR Controller Configuration→DDR3，在Memory Part下拉菜单中根据自己板子上的DDR来选择相应的DDR3，本实验所用到型号：MT41K256M16 RE-15E，最后点击“OK”,如下图所示。&lt;/p&gt;
&lt;p&gt;注意这里的DDR3并不是和板子上的DDR3严格对应，而是参数最接近的型号，有时候实验不通的话，问题往往出现在这里，可以多试几个。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410145957124-1056231770.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑫点击“Run Block Automation”如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150005682-1364859578.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑬在弹出的选项中保持默认，点击“OK”，即可完成对ZYNQ7 Processing System的配置。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150016706-413985197.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑭按照添加ZYNQ7 Processing System的方法，继续添加AXI GPIO，然后双击AXI GPIO，打开AXI GPIO配置对话框，由于只有输出4个led灯，故而按照下图对其进行设置，最后点击“OK”确认。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150029247-210218449.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑮点击“Run Block Automation”即可完成对AXI GPIO的设置，如下图所示&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150037483-1747721654.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑯点击“Run Connection Automation”。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150045047-996481518.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑰在弹出的对话框中按照下图所示配置，然后“OK”确认。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150052744-1079194806.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑱最后生成如下的框图。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150100818-1559150241.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑲在框图中点击gpio引脚，在左边的“External Interface Properties”给gpio起名leds，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150112827-944871209.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;⑳source→design_1→create HDL wrapper…，如下图所示。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150128828-36736470.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;21在弹出的对话框中，保持默认，点击“OK”确认，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150140341-962705219.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;22至此，可生成HDL文件，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150154948-440537807.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;2.3、.XDC文件约束PL管脚&lt;/h3&gt;
&lt;p&gt;23在source目录下，点击“+”，在弹出的对话框中选定“Add or create constraints”最后点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150205759-2101717454.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;24点击“Create File”，在弹出的对话框中给约束文件命名，点击“OK”确认，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150216154-1769175423.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;25点击“Finish”，完成约束文件的创建。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150226541-2066728759.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;26打开新建的约束文件，进行如下的管脚分配。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150237576-799477305.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;27产生bit文件。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150246817-296452442.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;2.4、SDK程序编写&lt;/h3&gt;
&lt;p&gt;28File→Export→Export hardware…，在弹出的对话框中勾选“include bitstream”，点击“OK”确认，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150256842-1875676011.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;29File→Lauch SDK，在弹出的对话框中，保存默认，点击“OK”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150307233-128772098.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;30至此，打开SDK开发环境，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150318169-1207033240.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;31file→new→Application Project，来新建一个“Application Project”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150331926-1373105448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;32 给Application Project命名，最后点击“Next”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150341358-460083061.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;33选择“Empty Application”，然后点击“Finish”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150349952-272797417.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;34axi_led_bsp→system.mss→import examples，在弹出的对话框中选择“xgpio_example”，最后点击“OK”确认，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150405478-1627362361.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;35这样新建一个“xgpio_example”，如下图所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150417922-1877461577.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;2.5、下载调试&lt;/h3&gt;
&lt;p&gt;36design_1_wrapper_hw_platform0→Program FPGA，在弹出的对话框中选择默认，点击“program”，如下图所示；第一次下载可能会失败，第二次下载就成功了，这样就完成了bit文件的下载。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150429090-533502116.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;37axi_led_bsp_xgpio_example_1→Run As→1 Launch on Hardware（System Debugger），&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150439372-1494839469.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;2.5、实验总结&lt;/p&gt;
&lt;p&gt;38下面是实验测试结果的视频，可以看到4个led在闪烁。（由于视频上传不了，只有个图片）&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416616/201904/1416616-20190410150806794-1227859436.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;







&lt;h3&gt;2.6、备注及疑问&lt;/h3&gt;
&lt;p&gt;40注意这里的DDR3并不是和板子上的DDR3严格对应，而是参数最接近的型号，有时候实验不通的话，问题往往出现在这里，可以多试几个。&lt;/p&gt;
&lt;p&gt;41第一次下载可能会失败，第二次下载就成功了，这样就完成了bit文件的下载。&lt;/p&gt;


&lt;h3&gt;2.7、参考资料&lt;/h3&gt;
&lt;p&gt;1. cource_s1_ALINX_ZYNQ(AX7010_AX7020)开发平台基础教程V1.09&lt;/p&gt;
&lt;p&gt;2. https://blog.csdn.net/q416524389/article/details/83865266&lt;/p&gt;
&lt;p&gt;3. https://blog.csdn.net/weixin_39813867/article/details/83512913&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 05:18:00 +0000</pubDate>
<dc:creator>liuyayong</dc:creator>
<og:description>在ZYNQ-7000平台上利用PS点亮PL上的LED灯 1、实验方案 图1 实验方案系统框图 2、具体步骤 2.1、vivado工程建立 ①打开vivado集成开发环境，点击“Create Proje</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ahead-liuyayong/p/10689021.html</dc:identifier>
</item>
</channel>
</rss>