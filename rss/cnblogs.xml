<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>异步路由、单播泛洪产生的安全侦听风险 - 白桦林_HK</title>
<link>http://www.cnblogs.com/baihualin/p/10486975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baihualin/p/10486975.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;存在于经典网络架构中的一个信息窃取风险&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景：&lt;/span&gt;&lt;/strong&gt;核心交换机和其他&lt;/span&gt;IDC&lt;span&gt;用三层互联，和接入交换机运行二层网络。核心交换机运行&lt;/span&gt;&lt;span&gt;VRRP&lt;/span&gt;&lt;span&gt;做本&lt;/span&gt;&lt;span&gt;IDC&lt;/span&gt;&lt;span&gt;内网网关（左边为主，右边为备）。现有其他&lt;/span&gt;&lt;span&gt;IDC&lt;/span&gt;&lt;span&gt;需访问本&lt;/span&gt;&lt;span&gt;IDC&lt;/span&gt;&lt;span&gt;内&lt;/span&gt;&lt;span&gt;10.1.1.1&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;拓扑：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597916/201903/1597916-20190306235021915-781688218.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;流量走向：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;入向流量：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、&lt;span&gt;目的为&lt;/span&gt;10.1.1.1&lt;span&gt;的流量到达右边核心交换机&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;span&gt;右边核心交换机查看本机&lt;/span&gt;MAC&lt;span&gt;地址表匹配目标&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;，结果发现查不到，于是在同&lt;/span&gt;&lt;span&gt;vlan&lt;/span&gt;&lt;span&gt;内泛洪此流量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;span&gt;同&lt;/span&gt;vlan&lt;span&gt;内&lt;/span&gt;&lt;span&gt;10.1.1.1&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;10.1.1.2&lt;/span&gt;&lt;span&gt;都收到此流量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;出向流量：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、10.1.1.1&lt;span&gt;查路由表，发现内网网关为核心交换机，此时左边核心交换机为&lt;/span&gt;&lt;span&gt;VRRP&lt;/span&gt;&lt;span&gt;主，故&lt;/span&gt;&lt;span&gt;ARP&lt;/span&gt;&lt;span&gt;解析将左边交换机&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;解析为网关地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、流量交给左边交换机，左边交换机根据三层路由表将数据直接传出去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;产生问题：&lt;/strong&gt;&lt;/span&gt;右边核心通过泛洪将数据包发给了&lt;/span&gt;vlan&lt;span&gt;内所有的服务器，那么只要拿到这个&lt;/span&gt;&lt;span&gt;vlan&lt;/span&gt;&lt;span&gt;内任意一台服务器的权限就可以嗅探到到达此&lt;/span&gt;&lt;span&gt;vlan&lt;/span&gt;&lt;span&gt;的所有包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题原因：&lt;/span&gt;&lt;/strong&gt;由于回包不经过右边交换机，所以右边交换机永远学不到&lt;/span&gt;10.1.1.1&lt;span&gt;的&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;。学不到&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;就要在同&lt;/span&gt;&lt;span&gt;vlan&lt;/span&gt;&lt;span&gt;内泛洪。（单播泛洪）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、核心交换机做堆叠&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在交换机无关端口开启阻塞端口泛洪。（SW(config-if)#switchport block unicast）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、采用全三层组网结构&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Mar 2019 15:50:00 +0000</pubDate>
<dc:creator>白桦林_HK</dc:creator>
<og:description>存在于经典网络架构中的一个信息窃取风险 背景：核心交换机和其他IDC用三层互联，和接入交换机运行二层网络。核心交换机运行VRRP做本IDC内网网关（左边为主，右边为备）。现有其他IDC需访问本IDC内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baihualin/p/10486975.html</dc:identifier>
</item>
<item>
<title>python深拷贝与浅拷贝 - 漫漫芜</title>
<link>http://www.cnblogs.com/sheshouxin/p/10486898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheshouxin/p/10486898.html</guid>
<description>&lt;h3&gt;可变对象与不可变对象&lt;/h3&gt;
&lt;p&gt;要理解深拷贝和浅拷贝，首先要理解可变对象和不可变对象。&lt;/p&gt;
&lt;p&gt;不可变对象：该对象所指向的内存中的值不能被改变，修改对象的值时，由于其指向的值不能被改变，因此实际上是在内存中重新开辟一个地址用来存储新的值，然后将对象指向这个新值。本质上是两个对象，赋值前后对象id发生了变化。python中的不可变对象包括：bool、int、str、float、tuple、frozenset、None。&lt;/p&gt;
&lt;p&gt;可变对象：该对象所指向的内存中的值可以被改变。变量（引用）的值发生改变时，实际上是其指向的值直接发生改变，没有开辟新的内存地址。python中的可变对象包括：list、dict、set。&lt;/p&gt;
&lt;p&gt; python中的赋值语句不会创建对象的拷贝，仅仅只是将变量名称绑定到一个对象上。对于不可变对象，这种操作不会产生差别，但是处理可变对象或可变对象的集合时，你可能希望创建这些对象的“真实拷贝”，在修改创建的拷贝时不改变原始的对象。&lt;/p&gt;
&lt;p&gt;浅拷贝：通常指构造一个新的集合对象，然后用原始对象中的找到的子对象的引用来填充它。浅层的复制只有一层深度，复制过程中不会递归，所以不会创建子对象本身的副本。&lt;/p&gt;
&lt;p&gt;深拷贝：深拷贝使复制过程递归，即首先构造一个新的集合对象，然后递归地用在原始对象中找到的子对象的副本来填充它。通过深拷贝复制对象，是原始对象及其所有子对象的完全独立的克隆。&lt;/p&gt;
&lt;h3&gt;赋值与引用&lt;/h3&gt;
&lt;p&gt;python的赋值语句不会复制对象，而是创建一个对象的引用（可以理解为标签）。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306224445196-1251509489.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图示例中，创建了两个变量（实际两个变量表示的是同一个列表），但两个变量id相同，指向的是同一个内存地址。&lt;/p&gt;
&lt;h3&gt;创建浅拷贝&lt;/h3&gt;
&lt;p&gt;仍以python列表为例，通常我们会用list()函数来复制一个列表，这个复制过程，就是一个浅拷贝。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306225309164-1725297228.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，通过浅拷贝方式，确实是复制了一个列表。复制前后两个变量的id不同，两个变量指向两个不同的内存地址，且修改其中一个列表中的值，对另一个列表不会产生影响。&lt;/p&gt;
&lt;p&gt;而之所以称这种复制方式为浅拷贝，是因为这种拷贝只对一层对象有效，当列表中有子对象时，对子对象的修改将同时影响原始对象和拷贝对象。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306230706903-1730798565.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，修改第一层次的成员值，不会影响拷贝对象；修改子对象的成员值（第二层次），会同时影响原始对象和拷贝对象。这是因为浅拷贝没有递归复制原始对象的值，只复制了第一层，因此拷贝对象中复制了子对象的引用，并没有复制子对象的值。&lt;/p&gt;
&lt;h3&gt;创建深拷贝&lt;/h3&gt;
&lt;p&gt;python标准库中的copy模块提供了创建python对象的浅拷贝和深拷贝的接口。使用deepcopy()函数，可以创建一个对象的深拷贝。代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201903/1606258-20190306231808987-1545590857.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，通过深拷贝复制的对象递归克隆了原始对象，两者是完全独立的。无论怎样修改其中一个对象，都不会对另一个对象产生影响。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不可变对象没有深拷贝和浅拷贝之分，可以理解为都是深拷贝&lt;/li&gt;
&lt;li&gt;创建对象的浅拷贝不会克隆子对象，不能完全对立与原始对象&lt;/li&gt;
&lt;li&gt;深拷贝会递归克隆原始对象，两者完全独立，互不影响，创建深拷贝的速度较慢&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 06 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>漫漫芜</dc:creator>
<og:description>可变对象与不可变对象 要理解深拷贝和浅拷贝，首先要理解可变对象和不可变对象。 不可变对象：该对象所指向的内存中的值不能被改变，修改对象的值时，由于其指向的值不能被改变，因此实际上是在内存中重新开辟一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheshouxin/p/10486898.html</dc:identifier>
</item>
<item>
<title>区域生长算法 全局分类 C++ &amp; matlab - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10486891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10486891.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;strong&gt;// 注：本内容为作者原创，禁止在其他网站复述内容以及用于商业盈利，如需引用，请标明出处：&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lv-anchoret/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lv_anchoret/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天我们来介绍用C++算法如何来实现图像处理中的区域生长算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/8366231?fr=aladdin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;区域生长的简介&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们解决的是对一整张图像所有内容进行区域生长分类，当然，如果是对图像中的某一类型进行区域生长可能更容易一些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;个人理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区域生长算法需要确定一个阈值，这个值代表同一类图像信息灰度值的差值，比如，我要一个人脸图（假设眼睛是蓝色的），头发是黑色的但是不同光线反射原因或者位置不同，图像中显示的灰度颜色值有5、10、3等，虽然灰度值不一样，但是他们代表的都是黑色，都是头发，区域生长，就是把这些相似灰度值的一类事物统一标注显示，这也就达到了分类识别的目的，关于阈值，比如上述的头发，我们需要将所有是头发的像素点都标注出来，那么我们的阈值就应该设置为10，如果设置为3，可能灰度值为3和5的点会统一识别，但是10就被排除在外了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;算法核心&lt;/strong&gt;&lt;/span&gt;就是一个bfs，设立一个种子点，向四周扩张，如果相邻的点的灰度值相对于种子点在阈值范围之内，那么，我们把它识别并包含统一进来，扩张完毕之后，所有相似的一类图像将被统一标注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于标注我们还需要说一下，一开始，想起了四色定理，即用四种颜色就可以吧整个地图分类标注且相邻类别颜色不同，后来想了想还不如把同一类型区域中的所有点都设置为种子点灰度像素值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后想起来我们光线追踪一直用的ppm彩色文件格式，索性将灰度值转成rgb彩色图看着更爽&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;区域生长算法流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 找种子点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 扩张原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 终止条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的数据是一张灰度图 ： 见 &lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/gallery/image/234346.html&quot; target=&quot;_blank&quot;&gt;纹理相册夹中的第二张图&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们处理输出的是一张彩色图像，图像格式是我们光线追踪的文件格式 .ppm，用我们光线追踪的图片解析器（ppmviewer）就能打开（没有的也没关系，搜索一下，下载不超过十几秒，超轻量级ppm解读器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道，C/C++ 中读取图像麻烦，特别是这种.jpg复杂格式数据，所以，我们用matlab先把图像读出来，输出到一个TXT中，存储为二维矩阵形式，然后用C++代码读取TXT文件内容，存储到一个二维数据序列中。（都有代码在后面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们侧重实现算法本身，所以关于图像的读取和写入我们不做过多描述&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 算法自命名：首次左上区域生长算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 时间复杂度：O(图像大小*种子数量*log（种子数量）)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、区域生长的三大要素确立：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）生长合并规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户自定义阈值，根据种子点和当前点的差值，如果在阈值之内，那么合并，将当前点的灰度值设为种子灰度值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）种子选取：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将图像左上角第一个点作为第一个种子，在扩张的过程中第一个不符合生长合并规则的位置，作为下一次生长的种子，即首次选定，后期自适应确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）算法结束：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;种子为空&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该算法的优点：  针对大型全局生长而衍生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                该算法种子不会将同一个位置作为种子多次重复生长（时间空间复杂度优化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                某个种子在开始生长时，如果已经被包含于另一个种子的生长区域中，那么该种子将不会进行生长（时间复杂度优化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该算法的缺点：  首次选定法不能用合适的灰度代表整个区域，只能是坐标小的点的灰度值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                生长出来的区域可能不是很完美，因为该区域是由该区域坐标最小的点生长而成的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、灰度值转rgb算法设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为要将单一的灰度值映射到r、g、b,使其代表的颜色具有独特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个可以自己设计，我的设计如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306222109183-626269582.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、构架设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;含有一个类 —— regional&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_img：用于存储图像灰度矩阵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;reset：用于记录某个位置的灰度是否被重置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_delt：阈值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成员函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readfile：读图像灰度矩阵文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bfs：进行区域生长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;out：输出处理后的图像灰度矩阵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readout：读取处理后的图像灰度矩阵文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gograph：将灰度图像转为rgb图像，由于ppmview显示空间有限，所以将此图划分为6块（将原图像分为3行2列的6块），分别输出6个图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224634170-1309990522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、数据结构设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：（C++描述）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用bfs算法进行的话，必然需要队列，但是种子们不能用队列去存，某个种子进行生长的时候可以用队列记录每一个生长状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此法采用8领域进行生长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用队列存储当前种子生长过程中的状态点，进行bfs扩展，确定该种子生长所形成的区域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用set容器存储各个种子，保证了种子点唯一性，即优点2，同时，set容器还会根据位置自动排序，所以导致了缺点2，其次，set容器的存取操作的时间复杂度均为O(n log n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bfs状态采用只包含x、y坐标的一个结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;采用C++描述的首次左上区域生长算法针对2012*1881的灰度卫星图像矩阵数据处理时间为：78.9s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224721782-1753825804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阈值为20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224752907-1915076876.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　　　　　　　　　　图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先蓝色圈所代表的部分，如果是水域的深浅，那么这一块还是被划分的很清楚的，大致分了5部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看下阈值为25的图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224819104-1793592639.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　　　　　　　　图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如我们所预期的那样，图1中蓝色圈的水深划分等级更少了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，我们看图1的红色圈代表的水体，内部中间划分出来的区域更小了，或者说水体的边缘区域扩张了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再如，黑色圈代表的水域，中间的黑色圈有一块东西，它的区域更小了，不利于捕捉细微的水内状况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图1的黑色内的小黑圈部分看不太清楚，那么可以看一下下面这个，都是一样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XnView打开效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224847301-710046667.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果把黄色部分看做是竖着的地质锤，那么图2显然少了锤头~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有水边一片房子聚集地，也被基本划分为一种色调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224916182-350311709.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而针对下图以及图4以及原图上方一片森林山脉，将各种处理方法进行叠加，效果可能会更好，方案如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有很多星星点点的噪声，可以选择先去噪声，但是，效果也不是很好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要将其纳入到统一的大片区域中，还是选择先做一个平滑处理，将其尖锐的边缘过渡更加平滑些，再进行区域生长，加以阈值调整，星点可能会减少，可能还存在一些，但是不会那么显眼，和周围环境的色差不会那么大了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190306224947794-2075480652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　图5&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;matlab 代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;matlab：
&lt;br/&gt;function writetxt
 
I &lt;/span&gt;= imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;poyanghu.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
fid &lt;/span&gt;= fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
[x,y] &lt;/span&gt;=&lt;span&gt; size(I);
fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d %d\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,x,y);
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:x
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:y
        fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,I(i,j));
    end
    fprintf(fid,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
end
 
fclose(fid);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;C++:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//regional.h&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region
{
    constexpr &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dir[&lt;span&gt;8&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
    {
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
        { &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
    };

    constexpr size_t H &lt;/span&gt;= &lt;span&gt;2012&lt;/span&gt;&lt;span&gt;;
    constexpr size_t L &lt;/span&gt;= &lt;span&gt;1881&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; regional
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pos
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; _x, _y;
            pos(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) :_x(a), _y(b) {  }
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&amp;lt;(&lt;span&gt;const&lt;/span&gt; pos&amp;amp; p)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_x ==&lt;span&gt; p._x)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _y &amp;lt;&lt;span&gt; p._y;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _x &amp;lt;&lt;span&gt; p._x;
            }
        };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        regional(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; size_t delt);

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; readfile();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bfs();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; readout();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; gograph()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; _img[&lt;span&gt;2012&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1881&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; reset[H + &lt;span&gt;1&lt;/span&gt;][L + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        size_t _delt;

    };

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;regional.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fstream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;queue&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region;

regional::regional(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; size_t delt)
    :_delt(delt)
{
    memset(reset, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; reset);
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::readfile()
{
    ifstream infile;
    infile.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;infile.is_open())
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, y;
    infile &lt;/span&gt;&amp;gt;&amp;gt; x &amp;gt;&amp;gt;&lt;span&gt; y;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= x; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= y; ++&lt;span&gt;j)
            infile &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; _img[i][j];
    infile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::bfs()
{
    queue&lt;/span&gt;&amp;lt;pos&amp;gt;&lt;span&gt;  Qcurrent;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&amp;lt;pos&amp;gt;&lt;span&gt; Qnew;
    Qnew.insert(pos(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (Qnew.size())
    {
        Qcurrent.push(&lt;/span&gt;*&lt;span&gt;Qnew.begin());
        Qnew.erase(Qnew.begin());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reset[Qcurrent.front()._x][Qcurrent.front()._y])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该种子点已经访问过&lt;/span&gt;
&lt;span&gt;        {
            Qcurrent.pop();
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (Qcurrent.size())
        {
            pos seed &lt;/span&gt;=&lt;span&gt; Qcurrent.front();
            reset[seed._x][seed._y] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            Qcurrent.pop();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; trans = &lt;span&gt;0&lt;/span&gt;; trans &amp;lt; &lt;span&gt;8&lt;/span&gt;; ++&lt;span&gt;trans)
            {
                pos p(seed._x &lt;/span&gt;+ dir[trans][&lt;span&gt;0&lt;/span&gt;], seed._y + dir[trans][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p._x &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p._x &amp;lt;= H &amp;amp;&amp;amp; p._y &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p._y &amp;lt;= L &amp;amp;&amp;amp; !&lt;span&gt;reset[p._x][p._y])
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (abs(_img[p._x][p._y] - _img[seed._x][seed._y]) &amp;lt;&lt;span&gt; _delt)
                    {
                        _img[p._x][p._y] &lt;/span&gt;=&lt;span&gt; _img[seed._x][seed._y];
                        reset[p._x][p._y] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        Qcurrent.push(p);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        Qnew.insert(p);
            }

        }
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; regional::&lt;span&gt;out&lt;/span&gt;&lt;span&gt;()
{
    ofstream outfile;
    outfile.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outall.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;outfile.is_open())
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= H; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
            outfile &lt;/span&gt;&amp;lt;&amp;lt; _img[i][j] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        outfile &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; endl;
    }
    
    outfile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; regional::readout()
{
    ifstream infile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outall.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;infile.is_open())
    {
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= H; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
            infile &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; _img[i][j];

    infile.close();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; regional::gograph()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
    ofstream file;

    auto left &lt;/span&gt;= [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (cnt - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;700&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;700&lt;/span&gt; * cnt; ++&lt;span&gt;i)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= &lt;span&gt;1000&lt;/span&gt;; ++&lt;span&gt;j)
                file &lt;/span&gt;&amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.2&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.5&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.7&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*_img[i][j]) &amp;lt;&amp;lt;&lt;span&gt; endl;
    };

    auto right &lt;/span&gt;= [&amp;amp;](&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (cnt - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;700&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;700&lt;/span&gt; * cnt; ++&lt;span&gt;i)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = L - &lt;span&gt;1000&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= L; ++&lt;span&gt;j)
                file &lt;/span&gt;&amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.2&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.5&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*&lt;span&gt;_img[i][j])
                &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;0.7&lt;/span&gt; + &lt;span&gt;float&lt;/span&gt;(_img[i][j] % &lt;span&gt;10&lt;/span&gt;) / &lt;span&gt;10&lt;/span&gt;)*_img[i][j]) &amp;lt;&amp;lt;&lt;span&gt; endl;
    };

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip1'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip2'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip3'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip4'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    file.close();


    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip5'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    left(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    file.close();

    file.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slip6'.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1000&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;700&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    right(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    file.close();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;main.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;regional.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; region;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fstream&amp;gt;
&lt;span&gt;#define&lt;/span&gt; stds std::

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{

    regional reg(&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;);
    reg.readfile();
    reg.bfs();
    reg.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;reg.readout();&lt;/span&gt;
&lt;span&gt;    reg.gograph();
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;complished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 15:26:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>// 注：本内容为作者原创，禁止在其他网站复述内容以及用于商业盈利，如需引用，请标明出处：https://www.cnblogs.com/lv-anchoret/ 今天我们来介绍用C++算法如何来实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10486891.html</dc:identifier>
</item>
<item>
<title>SpringMvc @InitBinder - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</guid>
<description>&lt;p&gt;&lt;span&gt;这篇博客记录@InitBinder怎么起作用、起什么作用？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  首先,该注解被解析的时机，是该匹配Controller的请求执行映射的方法之前; 同时 @InitBinder标注的方法执行是多次的，一次请求来就执行一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当某个Controller上的第一次请求由SpringMvc前端控制器匹配到该Controller&lt;span&gt;之后，根据Controller的 class 类型 查找 所有方法上标注了@InitBinder的方法，并且存入RequestMappingHandlerAdapter的 &lt;span&gt;initBinderCache，下次一请求执行对应业务方法之前时,可以走initBinderCache缓存,而不用再去解析@InitBinder; 所以 initBinder是controller级别的，一个controller实例中的所有@initBinder 只对该controller有效；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;功能一.注册Controller级别的 MVC属性编辑器 (属性编辑器功能就是将Web请求中的属性转成我们需要的类型) &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  @InitBinder唯一的一个属性value,作用是限制对哪些 @RequestMapping 方法起作用,具体筛选条件就是通过@RequestMapping方法入参来筛选，默认不写就代表对所有@RequestMapping的方法起作用;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  @InitBinder标注的方法, 方法入参和 @RequestMapping方法入参可选范围一样(这里指的是比如&lt;strong&gt;HttpServletRequest&lt;/strong&gt;、&lt;strong&gt;ModelMap&lt;/strong&gt;这些)， 通常一个入参 &lt;strong&gt;WebDataBinder&lt;/strong&gt; 就够我们使用了； @InitBinder标注的方法返回值, 必须为null，这里我理解的是&lt;span&gt;运行期&lt;/span&gt;的返回值;如果运行时返回值不为null,抛出异常 &lt;a href=&quot;mailto:“@InitBinder&quot;&gt;&lt;span&gt;“@InitBinder&lt;/span&gt;&lt;/a&gt; &lt;span&gt;methods should return void&lt;/span&gt;:”，编译时IDEA会提示@InitBinder应该返回null,但是不影响编译通过;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
@InitBinder
    public  void initBinder(WebDataBinder binder, HttpServletRequest request){
        System.out.println(request.getParameter(&quot;date&quot;));
        binder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(&quot;MM-dd-yyyy&quot;),false));
    }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  上面是一个@InitBinder的简单用法, 其中binder.registerCustomEditor(Date.class,new CustomDateEditor(new SimpleDateFormat(&quot;MM-dd-yyyy&quot;),false)); 这样一句话,作用就是将 自定义的MVC属性编辑器PropertyEditor 注册到当前binder的typeConverter的customEditors集合中,每一次请求和后端交互，&lt;span&gt;每一个Controller方法入参都会创建一个Binder对象&lt;/span&gt;,binder对象相当于来完成请求和后端之间参数类型转换的职能类;  注意，每次请求都会创建新的binder对象，就是说上次请求的customEditors不可复用 , 每次执行都会添加到当前方法入参交互的binder的customEditors中，而且每次执行真正请求方法之前，会把 匹配上的@InitBinder标注的方法执行一遍才开始处理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当请求中参数和方法入参开始进行转换的时候，都会先使用自定义注册的PropertyEditor，会首先根据需要的类型去binder的typeConverter的typeConverterDelegate的propertyEditorRegistry的cutomEditors集合中查找，有点绕，先记录下，typeConverterDelegate的propertyEditorRegistry就是typeConverter对象本身, 所以就是去typeConverter对象的cutomEditors寻找自定义注册的属性编辑器,又回到了原点。 比如去customEditors中根据key为Date.class查找editor,  分为两种情况，一种是找到了合适的属性编辑器,调用其setValue、setAsText方法, 之后使用getValue就得到转换后的值，  得到了转换后的值，可能不是我们想要的类型，这时候就会使用 conversionService 重新来过，放弃之前的转换；  是我们想要的类型就直接返回转换后的值; &lt;/span&gt; &lt;span&gt;第二种情况是没找到合适的属性编辑器， 直接调用 ConversionService 进行转换工作;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面方式是@InitBinder作为Controller级别的 SpringMvc属性编辑器,  下面记录一下全局级别（所有@Controller）的属性编辑器;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Xml中 注册全局属性编辑器到 ConfigurableWebBindingInitializer上，再将其注册到 RequestMappingHandlerAdapter里；记录原因，绑定binder的属性编辑器时候，会将当前的 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Initializer中的属性编辑器也给注册到binder中，这样就能实现全局的属性编辑器&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&amp;lt;!--&amp;lt;mvc:annotation-driven/&amp;gt;--&amp;gt;
    &amp;lt;!--取消注解驱动的话Spring4.3就要手动注册RequestMappingHandlerMapping、RequestMappingHandlerAdapter--&amp;gt;

&amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&amp;gt;

&amp;lt;/bean&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&amp;gt;
    &amp;lt;property name=&quot;webBindingInitializer&quot; ref=&quot;initializer1&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;initializer1&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&amp;gt;
    &amp;lt;property name=&quot;propertyEditorRegistrars&quot;&amp;gt;
       &amp;lt;list&amp;gt;
            &amp;lt;bean class=&quot;demo2.MyPropertyEditor&quot;/&amp;gt;
       &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;
&lt;p&gt;MyPropertyEditor.java&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class MyPropertyEditor implements PropertyEditorRegistrar {

    @Override
    public void registerCustomEditors(PropertyEditorRegistry registry) {
        registry.registerCustomEditor(Date.class,new MyDateEditor());
    }

    public static class MyDateEditor extends PropertyEditorSupport {
        @Override
        public void setValue(Object value) {
            super.setValue(value);
        }

        @Override
        public void setAsText(String text) throws IllegalArgumentException {
            Date d=null;
            try {
                System.out.println(&quot;我调用自己的全局MVC属性编辑器&quot;);
                d=new SimpleDateFormat(&quot;MM-dd-yyyy&quot;).parse(text);
                setValue(d);
            } catch (ParseException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;上面两段代码就可以注册 自定义的属性编辑器到 所有@Controller中，&lt;span&gt;相当于之前每个 Controller都使用了 @InitBinder&lt;/span&gt;;  但是这样写不太友好，SpringMvc&amp;lt;mvc:annotation-driven/&amp;gt;替我们注册的很多东西可能就没法使用了，意义不大，所以简单改造了一下： 在之前记录的Spring加载初始化容器的流程基础上改造了下;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231218421-445902142.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;393&quot; border=&quot;0&quot; data-action=&quot;zoom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spring  XML文件仍然使用注解驱动:&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&amp;lt;mvc:annotation-driven/&amp;gt;
&amp;lt;bean id=&quot;globalBeanDefinitionRegistry&quot; class=&quot;demo2.GlobalBeanDefinitionRegistry&quot;&amp;gt;
    &amp;lt;property name=&quot;editorRegistrars&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;bean class=&quot;demo2.MyPropertyEditor&quot;/&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;

&lt;p&gt;自定义的 GlobalBeanDefinitionRegistry代码如下:  简单说下原理，在Spring原有注解驱动的基础上，改变了webBindingInitializer，使它可以自由地配置方式添加属性编辑器；优点就是，不破坏SpringMvc注解驱动带给我们的好处，可以自定义添加属性全局的编辑器；缺点就是 代码中判断逻辑的 处理器映射器适配器 RequestMappingHandlerAdapter是硬编码的,Spring4可能还好用,Spring3突然又不支持了,同样也是有解决方案的&lt;/p&gt;
&lt;p&gt;用法其实就是在Spring初始化容器中对象之前移花接木地替换我们的 webBindingInitalizer.&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class GlobalBeanDefinitionRegistry  implements BeanDefinitionRegistryPostProcessor {
        private PropertyEditorRegistrar[]  editorRegistrars;
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        if(registry.containsBeanDefinition(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;)){
            BeanDefinition beanDefinition = registry.getBeanDefinition(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;);
            PropertyValue pv = beanDefinition.getPropertyValues().getPropertyValue(&quot;webBindingInitializer&quot;);
            BeanDefinition intializer= (BeanDefinition) pv.getValue();
            intializer.getPropertyValues().addPropertyValue(&quot;propertyEditorRegistrars&quot;,editorRegistrars);
        }
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

    }
    public void setEditorRegistrars(PropertyEditorRegistrar[] editorRegistrars) {
        this.editorRegistrars = editorRegistrars;
    }
&lt;/pre&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
}
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;因为@InitBinder方法 作为Controller级别的属性编辑器 和全局的自定义Mvc属性编辑器没有太大差别，所以下面讲一些别的用法：&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;功能二. WebDatabinder的setFieldDefaultPrefix(String fieldDefaultPrefix)&lt;/h2&gt;
&lt;h3&gt;作用：将SpringMvc请求参数带有fieldDefaultPrefix的参数,去掉该前缀再绑定到对应请求入参上&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;想来想去，也没搞明白这个方法的意义，以及实际用途，想到一种实际中可能出现的情况，觉得是个有几率出现的事情，正好可以用该方法可以解决；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题：假设 后台 用两个对象来接受请求参数(SpringMvc可以做到)，Pojo、Pojo2对象，他们两个属性如下：发现两个对象都有个name属性，问题来了，前台我们不能传两个 name属性吧，那样接收肯定会出错（我这里没尝试过），原有对象不修改的基础上可行方案如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
@Setter
@Getter
@ToString  // 代码整洁所以使用lombok,可以自行百度
public class Pojo {
    private String name;
    private String haircolor;
}

@Setter
@ToString
public class Pojo2 {
    private String name;
    private int age;
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在两个对象上各使用@ModelAttribute，来给对象分别起别名， @Initbinder这里value属性指定 别名，然后给不同的参数加上了前缀 person. 、cat.  ;注意这里的两个 &lt;span&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;/span&gt; 号 &lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 @RequestMapping(&quot;/test3&quot;)
    @ResponseBody
    public String test3(@ModelAttribute(&quot;person&quot;) Pojo person, @ModelAttribute(&quot;cat&quot;) Pojo2 cat){
        return &quot;test Response Ok!&quot;+person+&quot;,&quot;+cat;
    }

    @InitBinder(&quot;person&quot;)
    public void initPerson(WebDataBinder binder){
          binder.setFieldDefaultPrefix(&quot;person.&quot;);
    }

    @InitBinder(&quot;cat&quot;)
    public void initCat(WebDataBinder binder){
        binder.setFieldDefaultPrefix(&quot;cat.&quot;);
    }
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样请求URL：………… &lt;a title=&quot;http://localhost:8090/initBinder/test3?person.name=lvbinbin&amp;amp;cat.name=xiaobinggan&amp;amp;haircolor=black&amp;amp;age=20&quot;&gt;test3?person.name=lvbinbin&amp;amp;cat.name=xiaobinggan&amp;amp;haircolor=black&amp;amp;age=20&lt;/a&gt; 这里前台改动的地方就是 person.name和 cat.name，而其他独有属性不需要前缀也可以对应赋给pojo、pojo2;  补充说明&lt;span&gt;,@ModelAttribute注解不可以省略，通过这个取的别名来决定哪个@InitBinder对其生效&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看效果图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231219125-1016056830.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;56&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单记录下，因为这个 defaultPrefix 所在代码确实不好找:&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
protected void doBind(MutablePropertyValues mpvs) {
                checkFieldDefaults(mpvs);    //这里就是 defaultPrefix生效的地方
                checkFieldMarkers(mpvs);
                super.doBind(mpvs);
        }
//效果就是请求中包含defaultPrefix的,将其前缀去掉保存
protected void checkFieldDefaults(MutablePropertyValues mpvs) {
        if (getFieldDefaultPrefix() != null) {
                String fieldDefaultPrefix = getFieldDefaultPrefix();
                PropertyValue[] pvArray = mpvs.getPropertyValues();
                for (PropertyValue pv : pvArray) {
                        if (pv.getName().startsWith(fieldDefaultPrefix)) {
                                String field = pv.getName().substring(fieldDefaultPrefix.length());
                                if (getPropertyAccessor().isWritableProperty(field) &amp;amp;&amp;amp; !mpvs.contains(field)) {
                                        mpvs.add(field, pv.getValue());
                                }
                                mpvs.removePropertyValue(pv);
                        }
                }
        }
}
&lt;/pre&gt;

&lt;h2&gt;功能三.WebDataBinder的setDisallowedFields(String ….disallowedFields);&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;作用：SpringMvc接收请求参数时候，有些参数禁止的，不想接收，我也没遇到过啥情况禁止接收参数，这时候可以设置setDisallowedFields不接受参数&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 @RequestMapping(&quot;/test4&quot;)
    @ResponseBody
    public String test4(@ModelAttribute(&quot;pojo2&quot;) Pojo2 pojo){
        return &quot;test Response Ok!&quot;+pojo;
    }

    @InitBinder(&quot;pojo2&quot;)
    public void disallowFlied(WebDataBinder binder){
        binder.setDisallowedFields(&quot;age&quot;);
    }
&lt;/pre&gt;

&lt;p&gt;简单贴下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190301231219596-1431675802.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;269&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;正好发现了日志输出证明这一点：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190306231353088-1080966280.png&quot; alt=&quot;image&quot; width=&quot;902&quot; height=&quot;23&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那就顺便把代码贴一下，万一要用呢；  另外补充一下，disallowedFields支持 * 通配符；&lt;/p&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
protected void checkAllowedFields(MutablePropertyValues mpvs) {
                PropertyValue[] pvs = mpvs.getPropertyValues();
                for (PropertyValue pv : pvs) {
                        String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
                        if (!isAllowed(field)) {
                                mpvs.removePropertyValue(pv);
                                getBindingResult().recordSuppressedField(field);
                                if (logger.isDebugEnabled()) {
                                        logger.debug(&quot;Field [&quot; + field + &quot;] has been removed from PropertyValues &quot; +
                                                        &quot;and will not be bound, because it has not been found in the list of allowed fields&quot;);
                                }
                        }
                }
        }
protected boolean isAllowed(String field) {
        String[] allowed = getAllowedFields();
        String[] disallowed = getDisallowedFields();
        return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &amp;amp;&amp;amp;
                        (ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field)));
}
&lt;/pre&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&lt;/pre&gt;

&lt;p&gt;@Initbinder的用法简而言之,就是Controller级别的属性编辑器,将请求中的String类型转为我们需要的参数,但是从效率、内存分析，感觉一直在创建新的属性编辑器集合，如果属性编辑器太多是不是会占用大量内存呢，那请求达到一定多的数量，这个对象是不是太多了呢？&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>这篇博客记录@InitBinder怎么起作用、起什么作用？ 首先,该注解被解析的时机，是该匹配Controller的请求执行映射的方法之前; 同时 @InitBinder标注的方法执行是多次的，一次请</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10459303.html</dc:identifier>
</item>
<item>
<title>SpingBoot二——引入MySql数据库 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10486117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10486117.html</guid>
<description>&lt;p&gt;　　◆&lt;strong&gt;版权声明：本文出自胖喵~的博客，转载必须注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　转载请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: SpingBoot二——引入MySql数据库&quot; href=&quot;https://www.cnblogs.com/by-dream/p/10486117.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/by-dream/p/10486117.html&lt;/a&gt; &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 阿里云部署SpingBoot服务过程记录&quot; href=&quot;https://www.cnblogs.com/by-dream/p/9957624.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;搭起一个简单的服务后，接下来我们加入数据库，通过服务去读取DB中的数据进行显示。顺便将模块划分再清晰一些。&lt;/p&gt;
&lt;p&gt;不说太多了，直接说代码吧。&lt;/p&gt;
&lt;p&gt;1、pom.xml的dependencies中入依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mybatis 数据库 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mysql 驱动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里我们引入mybatis，所有和数据库之间的操作都借助它来完成。&lt;/p&gt;
&lt;p&gt;2、resource中加入数据库配置和mapper的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据库配置&lt;/span&gt;
spring.datasource.url=jdbc:mysql://**.**.**.**:3306/rap?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=&lt;span&gt;true
spring.datasource.username&lt;/span&gt;=&lt;span&gt;root
spring.datasource.password&lt;/span&gt;=123456&lt;span&gt;
spring.datasource.driver&lt;/span&gt;-&lt;span&gt;class&lt;/span&gt;-name=&lt;span&gt;com.mysql.jdbc.Driver

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mybatis 配置.xml文件路径&lt;/span&gt;
mybatis.mapper-locations=classpath:mapper/*.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一列需要配置你的ip地址和端口，3306后面的第一个斜线后跟数据库名（也就是这里的rap）&lt;/p&gt;
&lt;p&gt;这里需要提前登录到服务上进行了建表：&lt;/p&gt;
&lt;p&gt;mysql -u root -p 后输入密码进入，创建数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
create DATABASE rap;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后建表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create table user (
    id bigint unsigned  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null auto_increment comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;主键&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    gmt_create datetime  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    gmt_modified datetime  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;修改时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    nick varchar(&lt;/span&gt;1024)  &lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    age bigint unsigned  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; null comment &lt;span&gt;'&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    primary key (id)
) default charset&lt;/span&gt;=utf8 comment=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这是一张用户表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入一条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
insert into user (nick, age) values (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bryan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建表完成后。我们还需要开启数据库远程链接。首先运行：&lt;/p&gt;
&lt;p&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456'  ;&lt;br/&gt;这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址&lt;br/&gt;接着运行  flush privileges;  这一步不可获取，否则不会成功。此时我们在本地远程登录到服务器上看下是否可行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306222207087-1601933625.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、在resource中加入创建mapper：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306223545259-463969073.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;**-mapper.xml 里面的内容有点像写sql一样，这里我们先实现一个findById的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.bryan.demo.dal.dao.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.bryan.demo.dal.entity.UserDO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;nick&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;nick&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;columns&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        id, nick, age
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Long&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;columns&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM user
        WHERE id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、对应的我们需要建一个mapper的类和其对应的数据类do类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306224040643-913121087.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Mapper;

@Mapper
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserMapper {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDO findById(Long id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 主键
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long id;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String nick;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getNick() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nick;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNick(String nick) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nick =&lt;span&gt; nick;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UserMapper类的作用就是提供数据库操作的方法，UserDO类的作用就是将数据库中的数据转化为Java数据类型；&lt;/p&gt;
&lt;p&gt;5、接下来Service层的实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306224602984-309275861.png&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
    UserDO findById(Long id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bryan.demo.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.dao.UserMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.dal.entity.UserDO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bryan.demo.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserMapper userMapper;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDO findById(Long id) {

        UserDO userDO &lt;/span&gt;= userMapper.findById(1L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userDO;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、最终Controller层直接调用service的接口返回：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MachineInfoController {

    @Autowired
    UserService userService;

    @RequestMapping(&lt;/span&gt;&quot;/&quot;&lt;span&gt;)
    String homePage() {
        UserDO userDO &lt;/span&gt;= userService.findById(1L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;name：&quot;+userDO.getNick() + &quot; age：&quot;+&lt;span&gt;userDO.getAge();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们在浏览器情况，查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306225604044-288276326.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 好，看下整体的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306225828343-504690002.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整理了一下关系链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190306230215123-1438554797.png&quot; alt=&quot;&quot; width=&quot;142&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于本节只说数据库，所以整体的服务端的架构还没有特别的完善，下一节我会针对整体服务端架构进行分层，然后详细说明。&lt;/p&gt;
&lt;p&gt;代码我传到git上：&lt;/p&gt;



</description>
<pubDate>Wed, 06 Mar 2019 15:07:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>◆版权声明：本文出自胖喵~的博客，转载必须注明出处。 转载请注明出处：https://www.cnblogs.com/by-dream/p/10486117.html 搭起一个简单的服务后，接下来我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10486117.html</dc:identifier>
</item>
<item>
<title>headfirst设计模式（8）—适配器模式与外观模式 - 纷飞丶</title>
<link>http://www.cnblogs.com/skyseavae/p/10486438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyseavae/p/10486438.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这一章主要讲2个模式，一个是，适配器模式（负责将一个类的接口适配成用户所期待的），另外一个是外观模式（为子系统提供一个共同的对外接口），看完的第一反应是，为什么要把它们两放在同一章，难道它们有什么不可告人的秘密？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;难道是因为他们俩都很简单吗？不会不会，毕竟是大名鼎鼎的headfirst，怎么可能这么草率，这我是万万不相信的！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;细想了一下，我和工作的点点滴滴，我发现，一般到项目的后期，好像都比较容易用上这两个东西...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当然，项目的后期并不是说一个项目自己从头发开到尾的项目，而是在它生命周期的后半段，比如适配器，用来适配老的接口，比如外观模式，用来隐藏各个子系统，各个模块的协作细节。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不过外观模式却不一定都是在后期才发力的：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，前期如果系统比较复杂，在系统规划的时候，就会有意识的对系统分层，为上层模块提供一些高级的api。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，在系统的中期呢，开发过程中，发现子系统越来越复杂，也可以提供类似的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，在系统后期，模块越来越多，功能越来越复杂，还有历史原因，外观模式就更加有用了，毕竟，有一个简单易用的API，比手动调用各个系统的逻辑那简直是不要太舒服！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为什么后期不重构？而是要做这些修修补补的工作呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;举个例子，房子上有棵树，你觉得这棵树很碍事，就把树给干掉了，因为你以为，是房子上面长的，结果呢？特么是树把房子吊着的！类似的坑实在是太多了，所以，重构需谨慎，且构且珍惜。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当然不是说重构不好，而是要综合考量各方面的因素，而且，重构也用得上这些啊，毕竟，重构不是重写...（诶，重写好像也要用）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;适配器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;先说说它是干嘛的，用通俗一点的话来讲就是，VGA转DVI，2线插头转3线插头...废话不多说，上个图就知道了&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785526/201903/785526-20190306214720322-1506564450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;什么？大家很想看个例子？那么我就来一个例子吧，就举一个小火鸡变成小鸭子的故事吧&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;先看看鸭子接口（对应Target）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 鸭子接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Duck {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 鸭叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; quack();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下火鸡的接口和实现类(对应Adaptee)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 火鸡接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Turkey {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 火鸡叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; gobble();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly();
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 野火鸡
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WildTurkey &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Turkey {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; gobble() {
        System.out.println(&lt;/span&gt;&quot;咯咯&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
        System.out.println(&lt;/span&gt;&quot;我在飞，虽然我飞的很近&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先可以看出，它们的之间有一些共同之处，都有叫声，都可以飞行，这个也是适配的前提，有共同点！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果没有共同点，是不是去隔壁的其他设计模式看看？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;OK，接下来开始适配操作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;火鸡适配器(Adapter)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 火鸡适配器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TurkeyAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Duck {
    Turkey turkey;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持有一个火鸡对象&lt;/span&gt;
 
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TurkeyAdapter(Turkey turkey) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.turkey =&lt;span&gt; turkey;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 鸭叫
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; quack() {
        turkey.gobble();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 飞行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配的时候，这里模拟飞行5次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i= 0; i &amp;lt; 5; i++&lt;span&gt;) {
            turkey.fly();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;适配器的逻辑也很简单&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先，实现Duck接口，要让Client能够调用，那么首先得长得和别人一样啊&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其次，持有一个真正的处理对象，然后再根据Duck接口来进行适配，比如这里，quack接口，就直接调用Turkey#gobble()，而fly()可能是因为某种神秘力量，需要火鸡飞行的距离和鸭子一样远，所以需要手动去适配，在这里添加了适配的代码&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后，适配器的作用就是把一个类转换成另外一个类，转换的时候可能需要一些逻辑上的处理，让它能符合用户的期待&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;测试下是不是成功的伪装了呢&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DuckClient {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一只火鸡&lt;/span&gt;
        WildTurkey turkey = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WildTurkey();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;伪装成一只鸭子&lt;/span&gt;
        Duck duck = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TurkeyAdapter(turkey);

        System.out.println(&lt;/span&gt;&quot;鸣叫:&quot;&lt;span&gt;);
        duck.quack();

        System.out.println(&lt;/span&gt;&quot;------------------&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;飞行：&quot;&lt;span&gt;);
        duck.fly();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/785526/201903/785526-20190306214907747-1899798999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;适配器模式模式确实很简单，但是确实也很实用，优点很明显，&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;可以将目标类和适配者解耦，不需要改动原来的结构（新增了Adapter来封装了适配的逻辑），但是建议不要在系统设计阶段就盲目的使用它，增加系统的复杂度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;外观模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;这个就更简单了，例子我可以举一堆，比如说，酒店前台的小姐姐，餐厅前台的小姐姐，医院的小姐姐...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;核心思想：为子系统们提供一套通用的对外接口（高级API）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;为什么会有这样的需求呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;各个子系统在设计过程中，或者在实际使用的过程中会发现，有一些通用的步骤，对于更加高的调用层来说，它们其实不需要知道底层是通过哪些步骤来实现的，更多的是，以一个统一的接口来调用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;比如，在想在家里搞一个家庭影院，需要以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，灯光不能太亮，亮度需要调低到10&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，需要打开投影机，并且要调整到宽屏模式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，音响需要调整成环绕立体音，音量设置成5&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4，打开DVD开始播放&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;灯光：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c773ad03-f4be-4d52-9d79-6acf09e05f3c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c773ad03-f4be-4d52-9d79-6acf09e05f3c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c773ad03-f4be-4d52-9d79-6acf09e05f3c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 影院灯光
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TheaterLights {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TheaterLights(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dim(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
        System.out.println(description &lt;/span&gt;+ &quot; 亮度调节到：&quot; + level  + &quot;%&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;投影仪：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('362ed6b9-c46b-4ab1-bacb-cdd8212b14c9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('362ed6b9-c46b-4ab1-bacb-cdd8212b14c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_362ed6b9-c46b-4ab1-bacb-cdd8212b14c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 投影仪屏幕
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Screen {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Screen(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; up() {
        System.out.println(description &lt;/span&gt;+ &quot; 上升&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; down() {
        System.out.println(description &lt;/span&gt;+ &quot; 下降&quot;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 投影仪
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Projector {
    String description;
    DvdPlayer dvdPlayer;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Projector(String description, DvdPlayer dvdPlayer) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dvdPlayer =&lt;span&gt; dvdPlayer;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; wideScreenMode() {
        System.out.println(description &lt;/span&gt;+ &quot; 调整到宽屏模式&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; tvMode() {
        System.out.println(description &lt;/span&gt;+ &quot; 调整到tv模式&quot;&lt;span&gt;);
    }
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;音响：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f03d0b26-97c4-4632-a21f-e49a9a1a2d1d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f03d0b26-97c4-4632-a21f-e49a9a1a2d1d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f03d0b26-97c4-4632-a21f-e49a9a1a2d1d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 音响
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Amplifier {
    String description;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Amplifier(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 打开&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立体声&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStereoSound() {
        System.out.println(description &lt;/span&gt;+ &quot; 立体声模式&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;环绕声&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSurroundSound() {
        System.out.println(description &lt;/span&gt;+ &quot; 环绕声模式&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVolume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
        System.out.println(description &lt;/span&gt;+ &quot; 调整音量到： &quot; +&lt;span&gt; level);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;DVD播放器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6baa29c2-7b1d-4b09-9e07-3483eefd5ed1')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6baa29c2-7b1d-4b09-9e07-3483eefd5ed1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6baa29c2-7b1d-4b09-9e07-3483eefd5ed1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * DVD播放器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DvdPlayer {
    String description;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentTrack;
    Amplifier amplifier;
    String movie;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DvdPlayer(String description, Amplifier amplifier) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.amplifier =&lt;span&gt; amplifier;
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(description &lt;/span&gt;+ &quot; 播放&quot;&lt;span&gt;);
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(description &lt;/span&gt;+ &quot; 关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String movie) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.movie =&lt;span&gt; movie;
        currentTrack &lt;/span&gt;= 0&lt;span&gt;;
        System.out.println(description &lt;/span&gt;+ &quot; 播放 \&quot;&quot; + movie + &quot;\&quot;&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;不重要的代码就折叠了，免得难得看，不使用外观模式，需要调用一堆代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 不使用外观模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Amplifier amp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Amplifier(&quot;Top-O-Line 扬声器&quot;&lt;span&gt;);
        DvdPlayer dvd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DvdPlayer(&quot;Top-O-Line DVD播放器&quot;&lt;span&gt;, amp);
        Projector projector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Projector(&quot;Top-O-Line 投影仪&quot;&lt;span&gt;, dvd);
        TheaterLights lights &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TheaterLights(&quot;客厅灯&quot;&lt;span&gt;);
        Screen screen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Screen(&quot;投影仪银幕&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;准备看电影...&quot;&lt;span&gt;);
        lights.dim(&lt;/span&gt;10&lt;span&gt;);
        screen.down();
        projector.on();
        projector.wideScreenMode();
        amp.on();
        amp.setSurroundSound();
        amp.setVolume(&lt;/span&gt;5&lt;span&gt;);
        dvd.on();
        dvd.play(&lt;/span&gt;&quot;夺宝奇兵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用外观模式，一行解决：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用外观模式后的测试类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FacadeClient {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HomeTheaterFacade HOME_THEATER;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        Amplifier amp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Amplifier(&quot;Top-O-Line 扬声器&quot;&lt;span&gt;);
        DvdPlayer dvd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DvdPlayer(&quot;Top-O-Line DVD播放器&quot;&lt;span&gt;, amp);
        Projector projector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Projector(&quot;Top-O-Line 投影仪&quot;&lt;span&gt;, dvd);
        TheaterLights lights &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TheaterLights(&quot;客厅灯&quot;&lt;span&gt;);
        Screen screen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Screen(&quot;投影仪银幕&quot;&lt;span&gt;);

        HOME_THEATER &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HomeTheaterFacade(amp, dvd, projector, screen, lights);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看电影&lt;/span&gt;
        HOME_THEATER.watchMovie(&quot;夺宝奇兵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我擦？咋还是这么多行？&lt;/p&gt;
&lt;p&gt;static块里面的代码是初始化代码，一般使用spring，都是依赖注入的东西，其实调用就一行：&lt;/p&gt;
&lt;pre&gt;
HOME_THEATER.watchMovie(&quot;夺宝奇兵&quot;&lt;span&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一键解决就是爽啊，如果说对比的话，相当于，去网上买了个床，小哥送来的是一堆零件让你组装，和小哥送来就是一张组装好了的床啊！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是能够一键解决的，更多的是一些通用的操作，比如说，例子中，灯光不能太亮，你想把它调到5，不想用默认的10,，那么可能就只能自己写一遍外观模式封装的逻辑了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么这里就有个问题了，能不能重载方法，让它支持可以自定义灯光亮度这个参数呢？对于这个我只能说，要看业务需求了，如果100个人里面只有1个人用，那么对于系统产生的复杂度可能比 产生的价值高，反过来，可能就需要去实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是，如果这种需求越来越多，系统变得越来越复杂，那外观模式还是一个简单可爱的小姐姐吗？如果不实现，就无法达到隐藏子系统复杂度的痛点，如果实现，就会产生新的API调用的复杂度，我终于知道为啥我特么还在学习设计模式了...&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;说了这么多，说说它的优缺点吧&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;1，对客户屏蔽了子系统组件使用起来门槛更低。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;2，实现了子系统与客户之间的松耦合关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;3，虽然提供了访问子系统的统一入口，但是并不影响用户直接使用子系统类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;1，通过外观类访问子系统时，减少了可变性和灵活性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;2，在新的子系统加入，或者子系统接口变更时，可能需要修改外观类或客户端的源代码，违背了“开闭原则”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 14:04:00 +0000</pubDate>
<dc:creator>纷飞丶</dc:creator>
<og:description>前言 这一章主要讲2个模式，一个是，适配器模式（负责将一个类的接口适配成用户所期待的），另外一个是外观模式（为子系统提供一个共同的对外接口），看完的第一反应是，为什么要把它们两放在同一章，难道它们有什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyseavae/p/10486438.html</dc:identifier>
</item>
<item>
<title>小记-我的前端开发工作经历 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/10485949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/10485949.html</guid>
<description>&lt;p&gt;大家好，我叫海瑞菌，从事web前端开发工作4年，期间在外包公司，签约咪咕数媒旗下开发咪咕项目，以咪咕阅读为主。一个手机阅读软件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;咪咕阅读APP界面，app采取webview开发模式（前端H5页面+app功能壳（B+C））。部分页面及功能采用原生开发，内容展示采用前端页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306202343163-1810373598.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前2年项目使用的是freemarker+css+es5+zepto(jquery)的开发模式开发的。freemarker是一种jsp模板引擎，使用碎片化开发思维，用于输出服务器响应数据转化成html，本地写好的freemarker代码复制到UES编辑系统中运行，拖入碎片进行搭建页面。页面渲染采用css+es5+zepto开发模式。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;编写碎片代码，采用freemarker模板引擎+html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306203536183-236178705.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;管理线上页面、碎片、样式、脚本、风格，采用编辑管理系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306203916389-410954441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发样式脚本采用本地开发完传入编辑系统，并预览&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306204822641-186375009.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本地调试线上页面采用fiddler代理调试工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306204956322-317084172.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直至开发调试完成，测试通过，运营通知上线。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;后2年项目采用react(es5版)+sass+webpack+gulp进行重构和新需求开发，多页开发模式，页面首屏数据是放在全局变量pageData中的json，一个页面中有多个组件，组件初始化时从props中获取到当前组件的首屏数据。前端渲染数据为视图。更新的地方使用ajax请求后台微服务接口拿到json，使用setState方式更新视图。经常使用的react生命周期：getInitialState（组件初始化）、componentWillMount（组件渲染前）、componentDidMount（组件第一次渲染后）、componentWillReceiveProps（组件接收到新属性时）、render（渲染），其他较少使用。&lt;/p&gt;
&lt;p&gt;页面间跳转使用a链接或使用客户端打开新webview，之所以多页面是为了老架构向新架构过度，不影响原先页面。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目react本地开发环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tomcat+gulp本地服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306210631702-87767368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;react（es5）开发模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sass预处理样式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306211636356-1532323949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cmrsdk为jsBridge对象。可调取app原生方法，进行app交互&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306212558047-1128539005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用假数据在本地开发调试组件。本地服务器编译查看本地效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190306212641112-497815268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;组件通过svn上传至测试或线上服务器，由服务器编译后，通过编辑系统管理线上页面。以及测试线上页面。完成发布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用fiddler抓包工具进行页面代理，调试线上页面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;个人感觉公司技术使用上比较低端，业务却比较繁重。没太多时间学习，主要还是遇上了瓶颈，没有了成长空间，想跳出去却很难，已掌握的技术低端，高端技术的项目经验又不足。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 13:34:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<og:description>大家好，我叫海瑞菌，从事web前端开发工作4年，期间在外包公司，签约咪咕数媒旗下开发咪咕项目，以咪咕阅读为主。一个手机阅读软件。 咪咕阅读APP界面，app采取webview开发模式（前端H5页面+a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/10485949.html</dc:identifier>
</item>
<item>
<title>利用winrar代码执行漏洞拿下windows - yuleitest</title>
<link>http://www.cnblogs.com/yuleitest/p/10486218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuleitest/p/10486218.html</guid>
<description>
&lt;p&gt;最近winrar爆出安全漏洞，大部分其他厂家的压缩软件也受影响，毕竟我自己用的也是winrar，如果遇到大面积邮件钓鱼攻击，对企业影响会十分严重。&lt;/p&gt;

&lt;p&gt;1.下载安装python3，并下载CVE-2018-20250 exp&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WyAtu/CVE-2018-20250&quot;&gt;https://github.com/WyAtu/CVE-2018-20250&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.使用msfvnom或者免杀工具制作一个后门文件放在该目录，修改代码中的文件名shell.exe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213256085-131323170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213256815-1816614312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 执行exp, 生成test.rar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213257462-291621607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 发送给目标，为使攻击成为可能，可在目录放入大量图片，诱使解压（例如这样）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213258162-564624857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目标解压后自动在启动项创建启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213258950-871087784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.设置msf监听，目标下一次启动计算机时hi.exe自动运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213259498-1310187475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;机器上线，拿到shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/741432/201903/741432-20190306213300534-395962048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Mar 2019 13:28:00 +0000</pubDate>
<dc:creator>yuleitest</dc:creator>
<og:description>最近winrar爆出安全漏洞，大部分其他厂家的压缩软件也受影响，毕竟我自己用的也是winrar，如果遇到大面积邮件钓鱼攻击，对企业影响会十分严重。 1.下载安装python3，并下载CVE-2018-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuleitest/p/10486218.html</dc:identifier>
</item>
<item>
<title>HashMap数据结构的C++实现 - zmlgo</title>
<link>http://www.cnblogs.com/share-ideas/p/10486107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/share-ideas/p/10486107.html</guid>
<description>&lt;p&gt;Hash表在计算机的应用编程中是一种很常用的数据结构，很多算法的实现都离不开它。虽然C++11标准模板库中的有hashmap类型的实现，但在工程实践中，若项目本身使用的是较低版本的C++，或是出于性能的考虑，可能需要开发出一套独立的hashmap数据类型，从而能更加方便高效的维护相关业务。出于这种目的，有必要自己梳理一下其实现代码，并分享给大家。&lt;/p&gt;
&lt;p&gt;至于hash表实现的原理主要就两种：1、链表法，2、开放地址法。在此以链表法来实现hashmap的数据结构，相关示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建HashMap的数据结构类型&lt;/span&gt;
template&amp;lt;typename KEY, typename VALUE, unsigned &lt;span&gt;int&lt;/span&gt; NUM&amp;gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashMapper
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; item
    {
        item(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;key, &lt;span&gt;const&lt;/span&gt; VALUE&amp;amp;&lt;span&gt; value):first(key),second(value),next(NULL){}
        item(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key):first(key),next(NULL){}
        item():next(NULL){}
        
        KEY first;
        VALUE second;
        item&lt;/span&gt;*&lt;span&gt; next;
    };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        HashMapper();
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;HashMapper();
        item&lt;/span&gt;* Select(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key);
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; item* Select(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;key) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Insert(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;key, &lt;span&gt;const&lt;/span&gt; VALUE&amp;amp;&lt;span&gt; value);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Remove(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key);
        VALUE&lt;/span&gt;&amp;amp; &lt;span&gt;operator&lt;/span&gt;[](&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key);
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Key2Hash(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;key, unsigned &lt;span&gt;int&lt;/span&gt; &amp;amp;hashvalue) &lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        item&lt;/span&gt;*&lt;span&gt; hash_bucket[NUM];
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到指定key的map节点&lt;/span&gt;
Select(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key)
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    Key2Hash(key, value);
    item&lt;/span&gt;* pCur =&lt;span&gt; hash_bucket[value];
    
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(pCur !=&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == pCur-&amp;gt;&lt;span&gt;first)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pCur;
        }
        
        pCur &lt;/span&gt;= pCur-&amp;gt;&lt;span&gt;next;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向hashmap中插入键值对&lt;/span&gt;
Insert(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;key, &lt;span&gt;const&lt;/span&gt; VALUE&amp;amp;&lt;span&gt; value)
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashvalue;
    Key2Hash(key, hashvalue);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash位置没有内容&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (hash_bucket[hashvalue] ==&lt;span&gt; NULL)
    {
        hash_bucket[hashvalue] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; item(key, value);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    
    item&lt;/span&gt;* pCur =&lt;span&gt; hash_bucket[hashvalue];
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == pCur-&amp;gt;&lt;span&gt;first)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pCur-&amp;gt;next ==&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            pCur &lt;/span&gt;= pCur-&amp;gt;&lt;span&gt;next;
        }
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    pCur&lt;/span&gt;-&amp;gt;next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; item(key, value);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定key值的节点&lt;/span&gt;
Remove(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp;&lt;span&gt;key)
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashvalue;
    Key2Hash(key, hashvalue);

    item&lt;/span&gt;* pCur =&lt;span&gt; hash_bucket[hashvalue];
    item&lt;/span&gt;* pLast =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(pCur !=&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == pCur-&amp;gt;&lt;span&gt;first)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pLast ==&lt;span&gt; NULL)
            {
                hash_bucket[hashvalue] &lt;/span&gt;= pCur-&amp;gt;&lt;span&gt;next;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                pLast&lt;/span&gt;-&amp;gt;next = pCur-&amp;gt;&lt;span&gt;next;
            }
            &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; pCur;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        pLast &lt;/span&gt;=&lt;span&gt; pCur;
        pCur &lt;/span&gt;= pCur-&amp;gt;&lt;span&gt;next;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由字符串转化为hash值，如若要求保证唯一性，则可利用MD5来转化成u long long类型&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Key2Hash(&lt;span&gt;const&lt;/span&gt; KEY &amp;amp; index, unsigned &lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt; hashvalue)
{
    hashvalue &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; index.strlen();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; ++&lt;span&gt;i)
    {
        hashvalue &lt;/span&gt;= ((unsigned &lt;span&gt;char&lt;/span&gt;)index[i] + hashvalue) %&lt;span&gt; hashsize;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上示例主要实现思路是，每个KEY值经hash变换后生成对应的hashvalue，由hashvalue可在数组所构成的所有“桶”中找对指定的桶，再遍历桶中所有的KEY值，直到找到为止。&lt;/p&gt;

</description>
<pubDate>Wed, 06 Mar 2019 13:13:00 +0000</pubDate>
<dc:creator>zmlgo</dc:creator>
<og:description>hashmap的c++实现过程讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/share-ideas/p/10486107.html</dc:identifier>
</item>
<item>
<title>Account的简单架构 - KING_GUOKUN</title>
<link>http://www.cnblogs.com/guokun/p/10486063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guokun/p/10486063.html</guid>
<description>&lt;p&gt;　　前几天，有园友私下问我，博客中的AccountDemo后端架构为什么是那样的，是不是分层太多太冗余，故这里简单介绍下。先看解决方案工程截图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201903/481360-20190306193451347-2076838559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　每个工程的含义，见https://www.cnblogs.com/guokun/p/7082987.html。运行时，请求处理流程，这里再贴出来：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201903/481360-20190306200417064-1136849417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里，园友主要不解的是，为什么会有两个接口层，Account.Repository.Contract和Account.Service.Contract，是不是太多了。最近几年，在后端架构中，出现了一种称之为六边形架构的架构模式，这货之前曾被叫做洋葱架构、端口适配器架构，反正大家知道都是它就是了。六边形架构的核心，就是应用程序业务逻辑处于架构的核心，而上层的视图、控制器、数据访问等，都属于基础设施，是用来辅助实现业务逻辑的，他们都依赖于核心业务逻辑。这些基础设施是易变或者说很可能被频繁替换的，例如应用层今天可能是MVC，明天可能是WebAPI，数据访问今天可能是EF，明天可能是Dapper，甚至CSRedis，MongoDB。。。&lt;/p&gt;
&lt;p&gt;　　六边形架构最终要实现的效果就是，解耦应用核心业务逻辑与基础设施，其整体架构与依赖如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201903/481360-20190306205129916-1192222327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　蓝色箭头方向代表依赖方向，而非运行时数据流向或请求处理流向，请特别注意。ApplicationCore处于整个架构的中心，周边都是依赖于它的，这也是这一层名称ApplicationCore的由来，其核心特征是：1、用用层及基础设施层都依赖核心业务层；2、业务逻辑保持不变，应用层或基础设施层，比如切库、切ORM、切应用层框架，随便搞；3、有别于传统三层架构，数据层提供什么，业务层就有什么或用什么，六边形架构是业务层需要什么，就定义什么契约，数据层就实现什么或提供什么。&lt;/p&gt;
&lt;p&gt;　　介绍完了六边形架构，接下来回答，为什么有两个接口层。本质上，Account.Repository.Contract和Account.Service.Contract两层契约均归属于核心业务层，Account.Service.Contract用于对应用层承诺，提供什么服务，Account.Repository.Contract和Account.Service.Contract则规定基础设施层必须给自己提供什么操作。如果你愿意，那么这两个接口层完全可以融入Account.Service工程中，这都是没问题的，本来他们就属于业务逻辑的范畴，但我还是把它单独分出来，否则便是应用层、基础设施层直接硬依赖Account.Service，一者太重，二者不符合将面向接口编程。&lt;/p&gt;
&lt;p&gt;　　最后，说下，为什么Account.Repository.EF仓储工程中，一个实体类，对应了一个仓储对象。严格来讲，这么做是不合适的，设想一下，假如数据库表很多，那这里岂不膨胀得厉害。要弄明白这个问题，首先得知道仓储的由来。这玩意儿来自领域驱动架构，一般来讲，一个仓储是一一对应一个聚合根，这个聚合根是业务上功能聚合的一系列领域对象的，例如一个学生，对应一个宿舍，同时这个学生是个高富帅，他他妈的比较花心，身边有N个白富美女朋友。如果系统要维护这么样一个对应关系或信息，这里学生就是一个聚合根。具体表现在代码中，直观看就类似一个复杂对象，这个复杂对象的最外边就是学生，里边嵌套啥宿舍啊，女朋友集合啊，什么的。正常情况下，应该是学生这个聚合根才对应一个仓储类的，什么宿舍，女朋友都不应该有仓储类（假设没有其他需求导致他们需要上升为聚合根）。解释完了聚合根，这里回到刚才那问题，为什么搞成了一个数据库实体一个仓储类。主要在于，示例中抽象出了这么一个仓储基类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/481360/201903/481360-20190306210504817-597164534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这玩意儿是泛型的，因为后续仓储实现类想要用到其中的一些公用方法，实现这个基类时候，需要约定实体，所以为了偷懒，我就每个数据库表或者领域实体一个仓储类了，仅此而已。&lt;/p&gt;
&lt;p&gt;好了，园友提到的几个问题差不多就这样。&lt;/p&gt;

</description>
<pubDate>Wed, 06 Mar 2019 13:08:00 +0000</pubDate>
<dc:creator>KING_GUOKUN</dc:creator>
<og:description>前几天，有园友私下问我，博客中的AccountDemo后端架构为什么是那样的，是不是分层太多太冗余，故这里简单介绍下。先看解决方案工程截图： 每个工程的含义，见https://www.cnblogs.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guokun/p/10486063.html</dc:identifier>
</item>
</channel>
</rss>