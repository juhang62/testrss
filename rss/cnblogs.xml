<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux防火墙之iptables入门 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12237976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12237976.html</guid>
<description>&lt;p&gt;一、防火墙的概念&lt;/p&gt;
&lt;p&gt;　　什么是防火墙？防火墙是一台或一组设备，用以在网络间实施访问控制策略；事实上一个防火墙能够包含OSI模型中的很多层，并且可能会涉及进行数据包过滤的设备，它可以实施数据包检查和过滤，在更高的层次中对某应用程序实现某一策略，或做更多类似的事情。防火墙的功能主要是隔离功能，工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查，并在匹配某规则定义的行为进行处理的一组功能组件，基本上的实现都是默认情况下关闭所有的访问，只开放允许访问的策略；防火墙分主机防火墙、网络防火墙、硬件防火墙、软件防火墙、网络层防火墙、应用层防火墙等；主机防火墙指定的是针对服务当前主机做的访问策略的防火墙；网络防火墙指服务范围为防火墙一侧的局域网；硬件防火墙指在专用硬件级别实现部分功能的防火墙，另一部分功能基于软件实现；软件防火墙指运行于通用硬件平台之上的防火墙应用软件；网络层防火墙指OSI模型下四层的防火墙，主要针对OSI模型下四层的网络报文的访问策略控制；应用层防火墙/代理服务器指OSI模型中的应用层的防火墙，它主要在应用层进行操作，针对应用层的程序数据报文进行访问策略控制；&lt;/p&gt;
&lt;p&gt;二、网络型防火墙和应用层防火墙的优缺点&lt;/p&gt;
&lt;p&gt;　　网络层防火墙主要是包过滤，网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目标地址，所用端口和协议状态等因素，或他们的组合来取定是否允许该数据包通过；优点对用户来说透明，处理速度快且易于维护；缺点无法检查应用层数据，如病毒等；&lt;/p&gt;
&lt;p&gt;　　应用层防火墙我们又称代理服务型防火墙，它将所有跨越防火墙的网络通信链路分为两段；内外网用户的访问都是通过代理服务器上的“链路”来实现，这种防火墙优点是在应用层对数据进行检查，比较安全，确定是增加防火墙的负载。&lt;/p&gt;
&lt;p&gt;　　现实生产环境中所使用的防火墙一般都是二者结合体，即现检查网络数据，通过之后在送到应用层去检查。&lt;/p&gt;
&lt;p&gt;三、iptables简介&lt;/p&gt;
&lt;p&gt;　　先来说说内核组件netfilter，它是Linux2.4以后的内核版本引入的一个子系统，它作为一个通用的、抽象的框架，提供一整套的hook(勾子)函数的管理机制，使得诸如数据包过滤、网络地址转换和基于协议类型的连接追踪成为了可能；它在内核中选取了五个位置放置了五个hook(勾子)函数分别是INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING，而这五个勾子函数向用户开放，用户可以通过一个命令工具（iptables）向其写入规则；从上面的介绍不难理解，iptables只是管理netfilter上规则的一个用户空间的工具，真正实现防火墙的功能是netfilter，我们知道内核空间的功能，用户是没有办法直接使用，必须通过用户空间的软件去调用才可以使用。这也不难说明了iptables它是一个工具，而不是一个服务。&lt;/p&gt;
&lt;p&gt;四、iptables的组成以及数据包的传输过程&lt;/p&gt;
&lt;p&gt;　　iptables由五个表和五个链以及一些规则组成，五个表分别是filter、nat、mangle、raw、security，这五张表每张表都有不同的作用，filter表，主要是过滤报文策略的定义，根据预定义的规则过滤符合条件的数据包才允许或拒绝通行。nat表是地址转换规则表，它上面主要定义一些地址转换规则。mangle表是修改数据标记位规则表，raw是关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度，security用于强制访问控制（MAC）网络规则，有Linux安全模块（如selinux）实现；他们的优先级由高到低的顺序为security---&amp;gt;raw----&amp;gt;mangle----&amp;gt;nat----&amp;gt;filter&lt;/p&gt;
&lt;p&gt;　　五个内置的链（chain）就是我们上面说的五个勾子函数INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING，netfilter表和链对应关系如下图&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200205203847119-627930828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图没有画出securiyt表所工作的链，它和filter表一样，都工作在INPUT、FORWARD、OUTPUT链上。上图主要是说明了五个表的工作位置，了解了表和链的对应关系，我们在来看看数据包过滤匹配流程&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200205204848930-1216510733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　如上图所示，从网络A访问网络B，首先数据要先到达我们防火墙的网卡上，内核根据数据包目的IP判断是否需要转送出去，在路由之前数据报文要通过raw、mangel、nat这三个表中的规则，如果通过了这三张表中的规则后，数据才能决定到底是发往本机还是通过本机转发出去，如果是发往本机的，则数据会经过PREROUTING链，来到INPUT链，在进入用户空间访问用户空间的应用进程时，数据首先要通过，INPUT链上的所有规则，才可以访问本机用户空间的进程，用户空间进程接受到远端用户请求的数据报文后，响应报文会来到OUTPUT链上，这个链主要检查由本机发出的数据包，只有数据包满足出站规则后，它才能通过OUTPUT，当数据报文通过OUTPUT链后，数据报文会经过路由，来到POSTROUTING链，然后POSTROUTING链上的规则会对出站报文进行匹配，满足匹配策略POSTROUTING链放行或拒绝；如果数据包不是发往本机，则数据报文会经过PREROUTING链来到FORWARD链上，在FORWARD链上也有规则，数据符合FORWARD链上定义的规则，则通过或不通过（这个要看链上的处理动作怎么定义的，我们这里假设是匹配通过，不匹配这不通过来说明数据报文过滤匹配流程），如果数据通过了FORWARD链上的所有规则，这时数据会再次经过路由来到POSTROUTING链，同理它需要通过POSTROUTING上的所有规则后才能把到达下一个网络，从而实现数据包的转发；&lt;/p&gt;
&lt;p&gt;　　通过上图，不难发现数据报文的流向有三种，第一种是到本机来到，第二种是从本机出去的，第三种是经由本机转发的；流入本机的报文首先要通过PREROUTING链然后通过后来到INPUT链，通过后最后到达用户空间进程；流出本机的数据报文走向是用户空间进程----&amp;gt;OUTPUT----&amp;gt;POSTROUTING；经本机转发出去的报文走向：PREROUTING --&amp;gt; FORWARD --&amp;gt; POSTROUTING&lt;/p&gt;
&lt;p&gt;　　了解了数据报文的走向后，我们在来说说路由功能和发生的时间点，报文进入本机后，内核通过数据报的目标ip来判断此数据包是发往本机还是转发，如果是发往本机，则数据报文会送到INPUT链，如果不是发往本机的数据报文会送到FORWARD链，这时报文进入本机前端路由；在报文离开本机之前，内核会根据目标地址IP来判断数据报文由那个接口送往下一跳（下一个网络）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200205212332395-1244067200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去；如果数据包就是进入本机的，数据包就会到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出；如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出；&lt;/p&gt;
&lt;p&gt;五、ipatbles规则&lt;/p&gt;
&lt;p&gt;　　规则（rule）是由匹配条件和匹配动作组成，根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作作出处理。匹配条件有基本匹配条件和扩展匹配条件，基本匹配条件就是内建匹配条件，原生就有的，扩展匹配条件是由扩展模块定义，需要安装特定的模块才可以实现特定的扩展匹配；处理动作分基本处理动作，就是内建，原生支持的动作，扩展处理动作，由扩展模块定义，还有就是用户自定义处理（就是把匹配到达报文叫由自定义链来处理，这也是自定义链被主链调用的方式），iptables的链分内置链，和自定义链，内置的链就是对应五个勾子函数；自定义链式用于内置链的扩展和补充，可实现更灵活的规则管理机制，它只有被内置链调用才能生效；&lt;/p&gt;
&lt;p&gt;　　iptables规则添加需要考量以下几点&lt;/p&gt;
&lt;p&gt;　　1、要实现那种功能，判断规则该添加到那张表上的那个位置（iptables匹配规则的顺序是从上至下依次匹配，匹配到了就安装匹配到的处理动作做出处理，没有匹配到就按默认动作处理，所以添加规则需要考虑添加到那个位置）&lt;/p&gt;
&lt;p&gt;　　2、报文流经的路径必须清楚，需要判断把规则添加到哪个链上&lt;/p&gt;
&lt;p&gt;　　3、报文的流向，判断源和目标&lt;/p&gt;
&lt;p&gt;　　4、匹配规则，根据业务需求，怎么去匹配规则&lt;/p&gt;
&lt;p&gt;六、iptables命令使用和选项说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -h
iptables v1.4.21

Usage: iptables -[ACD] chain rule-specification [options]
       iptables -I chain [rulenum] rule-specification [options]
       iptables -R chain rulenum rule-specification [options]
       iptables -D chain rulenum [options]
       iptables -[LS] [chain [rulenum]] [options]
       iptables -[FZ] [chain] [options]
       iptables -[NX] chain
       iptables -E old-chain-name new-chain-name
       iptables -P chain target [options]
       iptables -h (print this help information)

Commands:
Either long or short options are allowed.
  --append  -A chain            Append to chain
  --check   -C chain            Check for the existence of a rule
  --delete  -D chain            Delete matching rule from chain
  --delete  -D chain rulenum
                                Delete rule rulenum (1 = first) from chain
  --insert  -I chain [rulenum]
                                Insert in chain as rulenum (default 1=first)
  --replace -R chain rulenum
                                Replace rule rulenum (1 = first) in chain
  --list    -L [chain [rulenum]]
                                List the rules in a chain or all chains
  --list-rules -S [chain [rulenum]]
                                Print the rules in a chain or all chains
  --flush   -F [chain]          Delete all rules in  chain or all chains
  --zero    -Z [chain [rulenum]]
                                Zero counters in chain or all chains
  --new     -N chain            Create a new user-defined chain
  --delete-chain
            -X [chain]          Delete a user-defined chain
  --policy  -P chain target
                                Change policy on chain to target
  --rename-chain
            -E old-chain new-chain
                                Change chain name, (moving any references)
Options:
    --ipv4      -4              Nothing (line is ignored by ip6tables-restore)
    --ipv6      -6              Error (line is ignored by iptables-restore)
[!] --protocol  -p proto        protocol: by number or name, eg. `tcp'
[!] --source    -s address[/mask][...]
                                source specification
[!] --destination -d address[/mask][...]
                                destination specification
[!] --in-interface -i input name[+]
                                network interface name ([+] for wildcard)
 --jump -j target
                                target for rule (may load target extension)
  --goto      -g chain
                              jump to chain with no return
  --match       -m match
                                extended match (may load extension)
  --numeric     -n              numeric output of addresses and ports
[!] --out-interface -o output name[+]
                                network interface name ([+] for wildcard)
  --table       -t table        table to manipulate (default: `filter')
  --verbose     -v              verbose mode
  --wait        -w [seconds]    maximum wait to acquire xtables lock before give up
  --wait-interval -W [usecs]    wait time to try to acquire xtables lock
                                default is 1 second
  --line-numbers                print line numbers when listing
  --exact       -x              expand numbers (display exact values)
[!] --fragment  -f              match second or further fragments only
  --modprobe=&amp;lt;command&amp;gt;          try to insert modules using this command
  --set-counters PKTS BYTES     set the counter during insert/append
[!] --version   -V              print package version.
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：除了以上用-h来了解iptables的简要用法和说明外，我们还可以通过man  8 iptables来了解每个选项的详细说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200205221752147-1101453000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   　　-t选项表示指定表名，默认是filter表，-A表示追加规则到最后，-s表示指定源ip地址 -j 表示处理的动作；iptables命令大概可以分二段段，第一段是指明规则位置，第二段是规则本身，规则又需要指明匹配条件和处理动作；上图命令表示在INPUT链上的filter表上追加一条规则到最后，规则内容为源地址为192.168.0.1的报文将丢弃；注意-A后面需要跟链名，链名必须得大写。&lt;/p&gt;
&lt;p&gt;　　总结命令使用格式：iptables [-t tablesname] COMMAND chain [-m matchname [per-match-options]] -j targetname [per-target-options]&lt;/p&gt;
&lt;p&gt;　　tablesname: raw,mangle,nat,[filter]默认不指定就是filter;&lt;/p&gt;
&lt;p&gt;　　COMMAND子命令，指明对规则的增删查改&lt;/p&gt;
&lt;p&gt;　　　　1、链管理&lt;/p&gt;
&lt;p&gt;　　　　-N：new，自定义一条新的规则链&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 7 packets, 488 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 5 packets, 524 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -N my_chain
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 22 packets, 1556 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 15 packets, 1396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-X：delete,删除自定义的空的规则链（删除一条自定义链的前提是，自定义连未被主链引用，也就是引用计数为0，其次是自定义链必须是空连，就是没有任何规则的链）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -A my_chain -s 192.168.0.0/24 -j ACCEPT
[root@test ~]# iptables -A INPUT -s 192.168.0.0/24 -j my_chain
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   24  1688 my_chain   all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 16 packets, 1488 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
   24  1688 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test ~]# iptables -X my_chain
iptables: Too many links.
[root@test ~]# iptables -F INPUT
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 25 packets, 1780 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 16 packets, 1552 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
   94  6516 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test ~]# iptables -X my_chain
iptables: Directory not empty.
[root@test ~]# iptables -F my_chain
[root@test ~]# iptables -X my_chain
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 22 packets, 1556 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 15 packets, 1396 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-P：policy，设置默认策略；对filter表中的链而言，其默认策略有：ACCEPT接受，允许。DROP：丢弃&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 29890 packets, 10M bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 31689 packets, 26M bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -P FORWARD ACCEPT
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 5 packets, 356 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 416 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -nvL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-E：重命名自定义连；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  104  7344 you_chain  all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 37 packets, 4120 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain you_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
  104  7344 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test ~]# iptables -E you_chain my_chain
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  178 12540 my_chain   all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 17 packets, 1580 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
  178 12540 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：重命名自定义链，引用计数不为零是可以被重命名的&lt;/p&gt;
&lt;p&gt;　　2、规则管理&lt;/p&gt;
&lt;p&gt;　　　　-A：append ，追加规则到指定表达最后&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 2208  340K my_chain   all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 1382 packets, 253K bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
 2208  340K ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test ~]# iptables -A my_chain -d 192.168.0.99 -j ACCEPT
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 2360  351K my_chain   all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 10 packets, 1048 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
 2360  351K ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            192.168.0.99        
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-I：insert, 插入，要指明位置，省略时表示第一条；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 195 packets, 13312 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 121 packets, 12112 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -A my_chain -d 192.168.0.99 -p tcp --dport 41319 -j ACCEPT 
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 20 packets, 1372 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 13 packets, 1212 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# iptables -I my_chain -d 192.168.0.99 -p tcp --dport 80 -j ACCEPT           
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 124 packets, 10836 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 114 packets, 10648 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:80
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# iptables -I  my_chain 2 -d 192.168.0.99 -p tcp --dport 8080 -j ACCEPT 
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 9 packets, 620 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 6 packets, 1176 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:80
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:8080
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-D：delete，删除；删除规则需啊哟指明规则序号，或者明规则本身&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 18 packets, 1136 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 17 packets, 3072 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:80
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:8080
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# iptables -D my_chain 1
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 6 packets, 396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 416 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:8080
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# iptables -D my_chain -d 192.168.0.99 -p tcp --dport 8080 -j ACCEPT
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 6 packets, 396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 528 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-R：replace，替换指定链上的指定规则；需指明替换第几条规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 6 packets, 396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 528 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
[root@test ~]# iptables -R my_chain 1 -d 192.168.0.100 -p tcp --dport 22 -j DROP
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 6 packets, 396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 528 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 DROP       tcp  --  *      *       0.0.0.0/0            192.168.0.100        tcp dpt:22
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-F：flush，清空指定的规则链；若为指定链 ，则表示清空filter表所在的所有链&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 38 packets, 2560 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 29 packets, 3648 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 DROP       tcp  --  *      *       0.0.0.0/0            192.168.0.100        tcp dpt:22
[root@test ~]# iptables -F
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 16 packets, 1108 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 11 packets, 1028 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -A INPUT -d 192.168.0.99 -p tcp --dport 41319 -j ACCEPT
[root@test ~]# iptables -A my_chain -d 192.168.0.99 -p tcp --dport 80 -j DROP
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  139  9668 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 13 packets, 1212 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 DROP       tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:80
[root@test ~]# iptables -F my_chain
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  200 13824 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 13 packets, 1212 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-Z：zero，置零指定链上的计数器，若为指定则表示，清空filter表所在的所有链上的规则计数器；iptables的每条规则都有两个计数器：(1) 匹配到的报文的个数；(2) 匹配到的所有报文的大小之和；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL 
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  783 59868 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   50  4212 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 27 packets, 3364 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    8   672 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -Z OUTPUT 
[root@test ~]# iptables -nvL      
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  822 62468 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   60  5052 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 416 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -Z
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   31  2124 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
    0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 19 packets, 1764 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、查看指定链上的规则&lt;/p&gt;
&lt;p&gt;　　　　-L：list, 列出指定链上的所有规则；-n：numberic，以数字格式显示地址和端口；-v：verbose，详细信息，支持-vv -vvv来指定详细程度&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;62&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  anywhere             test                 tcp dpt:41319
ACCEPT     icmp --  anywhere             test                 icmp echo-request

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     icmp --  test                 anywhere             icmp echo-reply

Chain my_chain (0 references)
target     prot opt source               destination         
[root@test ~]# iptables -Ln
iptables: No chain/target/match by that name.
[root@test ~]# iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     tcp  --  0.0.0.0/0            192.168.0.99         tcp dpt:41319
ACCEPT     icmp --  0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     icmp --  192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
target     prot opt source               destination         
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 4 packets, 284 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  205 14232 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   73  6132 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 160 packets, 18172 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   73  6132 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -nL -vv 
Chain INPUT (policy ACCEPT 4 packets, 284 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  244 16780 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   93  7812 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 185 packets, 21408 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   93  7812 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
libiptc vlibxtables.so.10. 1544 bytes.
Table `filter'
Hooks: pre/in/fwd/out/post = ffffffff/0/220/2b8/ffffffff
Underflows: pre/in/fwd/out/post = ffffffff/188/220/378/ffffffff
Entry 0 (0):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 192.168.0.99/255.255.255.255
Interface: `'/................to `'/................
Protocol: 6
Flags: 00
Invflags: 00
Counters: 244 packets, 16780 bytes
Cache: 00000000
Match name: `tcp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 1 (200):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 192.168.0.99/255.255.255.255
Interface: `'/................to `'/................
Protocol: 1
Flags: 00
Invflags: 00
Counters: 93 packets, 7812 bytes
Cache: 00000000
Match name: `icmp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 2 (392):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 4 packets, 284 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_ACCEPT

Entry 3 (544):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_DROP

Entry 4 (696):
SRC IP: 192.168.0.99/255.255.255.255
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 1
Flags: 00
Invflags: 00
Counters: 93 packets, 7812 bytes
Cache: 00000000
Match name: `icmp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 5 (888):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 185 packets, 21408 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_ACCEPT

Entry 6 (1040):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `ERROR' [64]
error=`my_chain'

Entry 7 (1216):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `' [40]
verdict=RETURN

Entry 8 (1368):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `ERROR' [64]
error=`ERROR'

[root@test ~]# iptables -nL -vvv
Chain INPUT (policy ACCEPT 4 packets, 284 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  288 18748 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   97  8148 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 264 packets, 32648 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   97  8148 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
libiptc vlibxtables.so.10. 1544 bytes.
Table `filter'
Hooks: pre/in/fwd/out/post = ffffffff/0/220/2b8/ffffffff
Underflows: pre/in/fwd/out/post = ffffffff/188/220/378/ffffffff
Entry 0 (0):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 192.168.0.99/255.255.255.255
Interface: `'/................to `'/................
Protocol: 6
Flags: 00
Invflags: 00
Counters: 288 packets, 18748 bytes
Cache: 00000000
Match name: `tcp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 1 (200):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 192.168.0.99/255.255.255.255
Interface: `'/................to `'/................
Protocol: 1
Flags: 00
Invflags: 00
Counters: 97 packets, 8148 bytes
Cache: 00000000
Match name: `icmp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 2 (392):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 4 packets, 284 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_ACCEPT

Entry 3 (544):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_DROP

Entry 4 (696):
SRC IP: 192.168.0.99/255.255.255.255
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 1
Flags: 00
Invflags: 00
Counters: 97 packets, 8148 bytes
Cache: 00000000
Match name: `icmp'
Target name: `' [40]
verdict=NF_ACCEPT

Entry 5 (888):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 264 packets, 32648 bytes
Cache: 00000000
Target name: `' [40]
verdict=NF_ACCEPT

Entry 6 (1040):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `ERROR' [64]
error=`my_chain'

Entry 7 (1216):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `' [40]
verdict=RETURN

Entry 8 (1368):
SRC IP: 0.0.0.0/0.0.0.0
DST IP: 0.0.0.0/0.0.0.0
Interface: `'/................to `'/................
Protocol: 0
Flags: 00
Invflags: 00
Counters: 0 packets, 0 bytes
Cache: 00000000
Target name: `ERROR' [64]
error=`ERROR'

[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用查看子命令-L如果有其他修饰子命令的选项和-L合并时，需要把 其他修饰该命令的选项需要放在-L 前面，否则会把其选项识别成链名&lt;/p&gt;
&lt;p&gt;　　　　-x：exactly，显示计数器结果的精确值,而非单位转换后的易读值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200205233812777-1800995995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　--line-numbers：显示规则的序号；可缩写为--line-num&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 7 packets, 502 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 7196  322K ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
  459 38556 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 13994 packets, 13M bytes)
 pkts bytes target     prot opt in     out     source               destination         
  459 38556 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -nvL --line-numbers
Chain INPUT (policy ACCEPT 7 packets, 502 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     7227  324K ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
2      459 38556 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 14018 packets, 13M bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1      459 38556 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
num   pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -nvL --line-num
Chain INPUT (policy ACCEPT 7 packets, 502 bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1     7240  325K ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
2      459 38556 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 14031 packets, 13M bytes)
num   pkts bytes target     prot opt in     out     source               destination         
1      459 38556 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
num   pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　-S selected,以iptables-save 命令格式显示链上规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N my_chain
-A INPUT -d 192.168.0.99/32 -p tcp -m tcp --dport 41319 -j ACCEPT
-A INPUT -d 192.168.0.99/32 -p icmp -m icmp --icmp-type 8 -j ACCEPT
-A OUTPUT -s 192.168.0.99/32 -p icmp -m icmp --icmp-type 0 -j ACCEPT
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果有需要，可以将其输出重定向到一个文件中去，但是导出的内容不能用于规则导入到文件，也就是说导出的文件不能用来重载iptables规则表&lt;/p&gt;
&lt;p&gt;　　4、规则的导出和导入&lt;/p&gt;
&lt;p&gt;　　iptables规则导出到指定文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables-save &amp;gt; iptables.txt 
[root@test ~]# cat iptables.txt 
# Generated by iptables-save v1.4.21 on Thu Feb  6 00:01:22 2020
*security
:INPUT ACCEPT [122:11155]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [100:10857]
COMMIT
# Completed on Thu Feb  6 00:01:22 2020
# Generated by iptables-save v1.4.21 on Thu Feb  6 00:01:22 2020
*mangle
:PREROUTING ACCEPT [122:11155]
:INPUT ACCEPT [122:11155]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [100:10857]
:POSTROUTING ACCEPT [100:10857]
COMMIT
# Completed on Thu Feb  6 00:01:22 2020
# Generated by iptables-save v1.4.21 on Thu Feb  6 00:01:22 2020
*raw
:PREROUTING ACCEPT [122:11155]
:OUTPUT ACCEPT [100:10857]
COMMIT
# Completed on Thu Feb  6 00:01:22 2020
# Generated by iptables-save v1.4.21 on Thu Feb  6 00:01:22 2020
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [5:280]
:POSTROUTING ACCEPT [5:280]
COMMIT
# Completed on Thu Feb  6 00:01:22 2020
# Generated by iptables-save v1.4.21 on Thu Feb  6 00:01:22 2020
*filter
:INPUT ACCEPT [40:5587]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [100:10857]
:my_chain - [0:0]
-A INPUT -d 192.168.0.99/32 -p tcp -m tcp --dport 41319 -j ACCEPT
-A INPUT -d 192.168.0.99/32 -p icmp -m icmp --icmp-type 8 -j ACCEPT
-A OUTPUT -s 192.168.0.99/32 -p icmp -m icmp --icmp-type 0 -j ACCEPT
COMMIT
# Completed on Thu Feb  6 00:01:22 2020
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：保存规则使用iptables-save命令，它默认是把链上的所有规则打印到标准输出，如果需要保存到指定文件需要用到输出重定向到指定文件即可&lt;/p&gt;
&lt;p&gt;　　iptables规则的导入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
54895 2298K ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
   75  6300 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 117K packets, 130M bytes)
 pkts bytes target     prot opt in     out     source               destination         
   75  6300 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -F
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 27 packets, 1976 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 20 packets, 1816 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables-restore &amp;lt; iptables.txt 
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   24  1636 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
    7   588 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 15 packets, 1396 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    7   588 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：导入规则的文件内容必须是iptables-save 导出的文件，不能用iptables -S 导出的文件还原。&lt;/p&gt;
&lt;p&gt;　　　　-n, --noflush：不清除原有规则导入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -F
[root@test ~]# iptables -A INPUT -d 192.168.0.99 -p tcp --dport 3306 -j ACCEPT
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 48 packets, 3468 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:3306

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 34 packets, 3028 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables-restore -n iptables.txt 
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:3306
   24  1636 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:41319
    4   336 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.0.99         icmptype 8

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 15 packets, 1396 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    4   336 ACCEPT     icmp --  *      *       192.168.0.99         0.0.0.0/0            icmptype 0

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：-n选项是不清空原有非自定义链上的规则，对于自定义链不管是否引用都会被清空&lt;/p&gt;
&lt;p&gt;　　　　-t, --test：仅分析生成规则集，但不提交&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -F
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 24 packets, 1708 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 17 packets, 1548 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables-restore -t iptables.txt 
[root@test ~]# iptables -nvL
Chain INPUT (policy ACCEPT 98 packets, 7096 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 72 packets, 7188 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain my_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上导出和导入规则适用centos6 和centos7 &lt;/p&gt;
&lt;p&gt;　　centos6除上面的方式可以导入和导出规则，它还可以用service iptables save 或者/etc/init.d/iptables save 使用脚本来保存iptables规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#cat /etc/redhat-release 
CentOS release 6.7 (Final)
[root@test-node1 ~]#iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   25  1728 you_chain  all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 16 packets, 2272 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain you_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
   25  1728 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test-node1 ~]#service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]
[root@test-node1 ~]#cat /etc/sysconfig/iptables
# Generated by iptables-save v1.4.7 on Thu Feb  6 00:49:32 2020
*filter
:INPUT ACCEPT [22:1656]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [82:8776]
:you_chain - [0:0]
-A INPUT -s 192.168.0.0/24 -j you_chain 
-A you_chain -s 192.168.0.0/24 -j ACCEPT 
COMMIT
# Completed on Thu Feb  6 00:49:32 2020
[root@test-node1 ~]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在centos6上使用脚本的方式去导出iptables规则，它默认覆盖保存在/etc/sysconfig/iptables文件&lt;/p&gt;
&lt;p&gt;　　centos6导入规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#iptables -F
[root@test-node1 ~]#iptables -nvL
Chain INPUT (policy ACCEPT 22 packets, 1556 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 14 packets, 1304 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain you_chain (0 references)
 pkts bytes target     prot opt in     out     source               destination         
[root@test-node1 ~]#service iptables restart
iptables: Setting chains to policy ACCEPT: filter          [  OK  ]
iptables: Flushing firewall rules:                         [  OK  ]
iptables: Unloading modules:                               [  OK  ]
iptables: Applying firewall rules:                         [  OK  ]
[root@test-node1 ~]#iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
   19  1332 you_chain  all  --  *      *       192.168.0.0/24       0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 13 packets, 1228 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain you_chain (1 references)
 pkts bytes target     prot opt in     out     source               destination         
   19  1332 ACCEPT     all  --  *      *       192.168.0.0/24       0.0.0.0/0           
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：导入规则centos6 用restart 来导入，不是restore。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Feb 2020 17:03:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、防火墙的概念 什么是防火墙？防火墙是一台或一组设备，用以在网络间实施访问控制策略；事实上一个防火墙能够包含OSI模型中的很多层，并且可能会涉及进行数据包过滤的设备，它可以实施数据包检查和过滤，在更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12237976.html</dc:identifier>
</item>
<item>
<title>数据结构与算法概念 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12267404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12267404.html</guid>
<description>&lt;p&gt;数据结构指一组相互之间存在一种或多种特定关系的数据元素的集合,&lt;br/&gt;当我们需要在计算机中存储这些数据时,还涉及到数据的,组织方式,在计算机中的存储方式,以及定义在该数据上的一组操作;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一组数据相互之间有某种关系&lt;/li&gt;
&lt;li&gt;组织方式&lt;/li&gt;
&lt;li&gt;存储方式&lt;/li&gt;
&lt;li&gt;以及可对其进行的一组操作&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;理解&quot;&gt;理解:&lt;/h6&gt;
&lt;p&gt;我们学习的最终目的是要在计算机中存储&lt;strong&gt;一组数据&lt;/strong&gt;,但是不得不先考虑数据的&lt;strong&gt;组织方式&lt;/strong&gt;,在计算机中的&lt;strong&gt;存储方式&lt;/strong&gt;,以及可以对这些数据进行的&lt;strong&gt;一组操作&lt;/strong&gt;,当然了既然是一组数据必然表明了这写数据之间是存在想换的关联关系的;关系可能还会有多种;&lt;/p&gt;
&lt;h6 id=&quot;例如&quot;&gt;例如:&lt;/h6&gt;
&lt;p&gt;一组数据:12345&lt;/p&gt;
&lt;p&gt;组织方式:从小到大&lt;/p&gt;
&lt;p&gt;存储方式:可使用线性存储结构&lt;/p&gt;
&lt;p&gt;操作:要取出最大的一个&lt;/p&gt;
&lt;h6 id=&quot;数据结构研究方向&quot;&gt;数据结构研究方向&lt;/h6&gt;
&lt;p&gt;问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;机外处理&lt;/li&gt;
&lt;li&gt;处理要求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建模:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逻辑结构&lt;/li&gt;
&lt;li&gt;基本运算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储结构&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本术语&quot;&gt;基本术语&lt;/h2&gt;
&lt;h3 id=&quot;数据data&quot;&gt;数据(Data):&lt;/h3&gt;
&lt;p&gt;​ 所有能被计算机处理的符号的集合&lt;/p&gt;
&lt;h3 id=&quot;数据元素dataelement&quot;&gt;数据元素(DataElement):&lt;/h3&gt;
&lt;p&gt;​ 是数据集合中的一个 个体,即数据的基本单位&lt;/p&gt;
&lt;h3 id=&quot;数据项dataitem&quot;&gt;数据项(DataItem):&lt;/h3&gt;
&lt;p&gt;​ 数据元素常常可分为若干个数据项,数据项是数据具有意义的最小单位&lt;/p&gt;
&lt;h6 id=&quot;组织数据的三个层次&quot;&gt;组织数据的三个层次:&lt;/h6&gt;
&lt;p&gt;数据(表)-&amp;gt;数据元素(行)-&amp;gt;数据项(字段)&lt;/p&gt;
&lt;p&gt;实际问题中的数据成为原始数据&lt;/p&gt;
&lt;h3 id=&quot;逻辑结构logicalstructure&quot;&gt;逻辑结构(LogicalStructure)&lt;/h3&gt;
&lt;p&gt;​ 数据元素之间的结构关系,如从小到大/一对一/一对多&lt;/p&gt;
&lt;h3 id=&quot;物理结构physicalstructure&quot;&gt;物理结构(PhysicalStructure)&lt;/h3&gt;
&lt;p&gt;​ 也会叫做存储结构,指数据在计算机内的表示,逻辑结构在计算机中的具体实现&lt;/p&gt;
&lt;h2 id=&quot;逻辑结构&quot;&gt;逻辑结构&lt;/h2&gt;
&lt;h3 id=&quot;常见的逻辑结构如下&quot;&gt;常见的逻辑结构如下:&lt;/h3&gt;
&lt;h4 id=&quot;集合&quot;&gt;集合:&lt;/h4&gt;
&lt;p&gt;数据元素属于同一个集合,表示为R{}; 数据之间不存在特定关系&lt;/p&gt;
&lt;p&gt;组织结构松散,任意两节点之间都没有邻接关系&lt;/p&gt;
&lt;h4 id=&quot;线性&quot;&gt;线性:&lt;/h4&gt;
&lt;p&gt;除了起始节点d1和终端阶段dn外,每个节点都有一个前驱和一个后继,表示为R={d1,d2...dn},数据之间存在前后顺序关系&lt;/p&gt;
&lt;p&gt;各节点按逻辑关系排列,形成一条'链'&lt;/p&gt;
&lt;h4 id=&quot;树状&quot;&gt;树状:&lt;/h4&gt;
&lt;p&gt;每个元素最多有一个前驱,可以有多个后继,表示为(D,{R}),就像一个树干长了多个树枝&lt;/p&gt;
&lt;p&gt;具备分支,层次特性,上层节点可以和下层多个节点相邻接,但是下层节点只能和一个上层节点邻接&lt;/p&gt;
&lt;h4 id=&quot;图状&quot;&gt;图状:&lt;/h4&gt;
&lt;p&gt;任何两个元素之间都可以相邻接,表示为(D,{R})&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意:&lt;/h3&gt;
&lt;p&gt;逻辑结构&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;与元素本身的形式,内容,无关&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;元素的相对位置,无关&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;与包含的节点个数,无关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;存储结构&quot;&gt;存储结构&lt;/h2&gt;
&lt;p&gt;存储结构由 &lt;code&gt;存储节点(每个存储节点存放一个数据元素)&lt;/code&gt; 和 &lt;code&gt;节点之间的逻辑关系&lt;/code&gt;共同组成&lt;/p&gt;
&lt;p&gt;反过来说,一个完整的存储结构必须可以存储&lt;code&gt;数据元素&lt;/code&gt;,以及&lt;code&gt;元素之间的逻辑关系&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;存储结构分类-缺图&quot;&gt;存储结构分类 (缺图)&lt;/h3&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;h4 id=&quot;顺序存储&quot;&gt;顺序存储&lt;/h4&gt;
&lt;p&gt;使用索引(相对起始位置)来表示数据的逻辑结构,数据被存储在一组连续的存储单元中&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需预先分配长度,&lt;/li&gt;
&lt;li&gt;插入和删除慢,需要移动其他元素&lt;/li&gt;
&lt;li&gt;存取数据快捷,属于随机存储结构(可通过索引直接访问任意位置数据)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;h4 id=&quot;链式存储&quot;&gt;链式存储&lt;/h4&gt;
&lt;p&gt;借助元素地址指针表示数据的逻辑结构,每个元素都会包含指向下一个元素的指针&lt;/p&gt;
&lt;p&gt;这种结构需要在节点上附加一个指针项,指出后继节点的位置,即每个节点存储单元包含两个部分:&lt;code&gt;[数据项,指针项]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态分配内容,不需要预先分配内存&lt;/li&gt;
&lt;li&gt;插入删除快捷,不需要移动其他元素&lt;/li&gt;
&lt;li&gt;非随机存取结构(获取数据必须遍历前面的所有节点)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;h4 id=&quot;索引存储map是否属于索引结构-很疑惑&quot;&gt;索引存储(Map是否属于索引结构 很疑惑?)&lt;/h4&gt;
&lt;p&gt;借助索引表来指示数据元素的存储位置&lt;/p&gt;
&lt;p&gt;索引表中包含了所有数据元素的地址,查询索引表能够快速的定位到需要的数据&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;索引是一份独立于实际存放数据,的数据结构(就像书的目录都在正文前面)&lt;/li&gt;
&lt;li&gt;索引需要占用额外的存储空间&lt;/li&gt;
&lt;li&gt;当实际数据发生改变时需要重建索引&lt;/li&gt;
&lt;li&gt;查询数据快&lt;/li&gt;
&lt;li&gt;插入修改,删除慢&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h4 id=&quot;散列存储哈希表&quot;&gt;散列存储(哈希表)&lt;/h4&gt;
&lt;p&gt;通过散列函数计算得出元素的位置&lt;/p&gt;
&lt;p&gt;特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在散列函数不变时,相同数据会得出相同的位置&lt;/li&gt;
&lt;li&gt;存入顺序和取出顺序通常不一致&lt;/li&gt;
&lt;li&gt;无法完成随机存取(指定获取某个元素)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;顺序和链式是最基本的也是最常用的存储结构,需要重点掌握,包括各自的优缺点,使用场景等&lt;/p&gt;
&lt;p&gt;链式存储结构可实现树结构(逻辑结构)&lt;/p&gt;
&lt;h2 id=&quot;运算&quot;&gt;运算&lt;/h2&gt;
&lt;p&gt;运算指的是某种逻辑结构上可以进行的操作;&lt;/p&gt;
&lt;h3 id=&quot;运算分为两类&quot;&gt;运算分为两类:&lt;/h3&gt;
&lt;h3 id=&quot;常见运算&quot;&gt;常见运算:&lt;/h3&gt;
&lt;p&gt;建立,查找,读取,插入,删除&lt;/p&gt;
&lt;p&gt;加工型:建立,插入,删除&lt;/p&gt;
&lt;p&gt;引用型:读取,查找&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;
&lt;p&gt;算法字面意思,计算方法;&lt;/p&gt;
&lt;p&gt;算法规定了求解给定类型问题所需的所有&lt;code&gt;处理步骤&lt;/code&gt;以及&lt;code&gt;执行顺序&lt;/code&gt;,使得问题能在有限时间内机械的求解,一个算法就是对特定问题求解步骤的一种描述,再具体一点,算法是一段有穷的指令序列;算法必须能使用某种语言描述;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算1到5的和 ,这个需求,如何来实现,第一步做什么,第二步做什么,整个计算步骤和执行顺序统称为算法,如果最终能够在有限的步骤下求出正确的和,那这就是一个合格的算法;&lt;/p&gt;
&lt;h3 id=&quot;算法的特点&quot;&gt;算法的特点:&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有穷性&lt;/p&gt;
&lt;p&gt;算法必须在执行有穷步后结束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确定性&lt;/p&gt;
&lt;p&gt;算法的每一个步骤都必须是明确定义的,&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可行性&lt;/p&gt;
&lt;p&gt;算法中的每一步都是可以通过已实现的操作来完成的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;p&gt;一个算法具备0或多个输入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;一个算法有一个或多个输出,它们与输入有着特定的关系&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;算法与程序的区别,算法只是一种描述,可以使用任何语言,但是通常不能直接被计算机运行,而程序则是算法的具体实现,使用某种计算机语言;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法设计应满足的要求&quot;&gt;算法设计应满足的要求&lt;/h3&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;正确性:对于合法的输入产生符合要求的输出&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;易读性:算法应该尽可能易读,便于交流,这也是保证正确性的前提(注释可提高易读性)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;健壮性:当输入非法数据时,算法可作出适当反应而不至于崩溃(例如输出错误原因);&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;时空性:指的是算法的时间复杂度和空间复杂度,算法分析主要也是分析算法的时间复杂度和空间复杂的,其目的是提高算法的效率;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;算法分析&quot;&gt;算法分析&lt;/h3&gt;
&lt;p&gt;解决同一问题的算法可能有多种,我们希望从中选出最优的算法,效率高的,占用空间小的,为此我们就需要对算法进行评估和分析;&lt;/p&gt;
&lt;p&gt;通常评估算法根据两个度量&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;时间复杂度:算法运行完成所需的总步数(标准操作),通常是问题规模的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;空间复杂度:算法执行时所占用的存储空间,通常是问题规模的函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;确定算法的计算量&quot;&gt;确定算法的计算量&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;合理选择一种或几种操作作为'标准操作',无特殊说明&lt;strong&gt;默认以赋值操作作为标准操作&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;确定算法&lt;strong&gt;共执行多少次标准操作&lt;/strong&gt;,并将&lt;strong&gt;此次&lt;/strong&gt;数规定为算法的&lt;strong&gt;计算量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以算法在所有时输入下的计&lt;strong&gt;算量最大值&lt;/strong&gt;作为算法的&lt;strong&gt;最坏情况时间复杂度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以算法在所有时输入下的计&lt;strong&gt;算量最小值&lt;/strong&gt;作为算法的&lt;strong&gt;最好情况时间复杂度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以算法在所有时输入下的&lt;strong&gt;计算量平均值&lt;/strong&gt;作为算法的&lt;strong&gt;平均情况时间复杂度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最坏/平均情况时间复杂度都可作为时间复杂度,通常以最坏情况衡量;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意:时间复杂度通常以量级来衡量,也就是说不需要精确的计算到底执行了几步,而是得出其计算量的数量级即可,并忽略常数,因为当数量级足够大时,常数对于计算量的影响可以忽略不计;&lt;/p&gt;
&lt;p&gt;如: (n-1)(n-2) 数量级为 n^2&lt;/p&gt;
&lt;p&gt;时间复杂度使用大O表示,如O(1)&lt;/p&gt;
&lt;h4 id=&quot;案例&quot;&gt;案例:&lt;/h4&gt;
&lt;h5 id=&quot;section&quot;&gt;1.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void aFunction(){
    int c = 10 + 20;
    int d = c * c;
        printf(d);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上列算法若以赋值运算作为标准操作,则该算法的计算量为2,其时间复杂度记为O(1),为什么是O(1)呢,是因为2是一个常数,常数对于函数的增长影响并不大,所以计算量为常数时表示为O(1),按照这种方式,即使计算量为2000,同样记为O(1),称为&lt;strong&gt;常数&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;section-1&quot;&gt;2.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
  for(int i = 0;i &amp;lt; n;i++){ // n
    int c = 2 * i;// 1
    int d = 3 * i;// 2
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时函数的循环次数由未知数n来决定,循环体内计算量为2,当n是一个自然数时,函数的计算量等于(n)(2),此时时间复杂度为O(n),无论用常数&lt;code&gt;2&lt;/code&gt;对n进行加减乘除对于n的指数都没有影响,当n足够大时,内部的2次计算量可以忽略,所以记为O(n),称为&lt;strong&gt;线性阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更粗陋的度量方法是函数体包含一层循环时记为O(n)&lt;/p&gt;
&lt;h5 id=&quot;section-2&quot;&gt;3.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
  for(int i = 0;i &amp;lt; n;i++){
      for(int j = 0;j &amp;lt; i;j++){
      }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外层循环次数为n,内层循环次数随着n的增长而增长且最大值为n-1次,那么整个函数的计算量为(n)(n-1),常数可以忽略,所以时间复杂度记为O(n^2) ,称为&lt;strong&gt;平方阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;粗陋的方法是有两层嵌套循环,且循环次数都随着n的增长而增长,所以是O(n^2),以此类推,但是要注意下面这种情况&lt;/p&gt;
&lt;h5 id=&quot;section-3&quot;&gt;4.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
  for(int i = 0;i &amp;lt; n;i++){
      for(int j = 0;j &amp;lt; 3;j++){
      }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时内层循环的循环次数是固定(常数)所以不会影响计算量的数量级,时间复杂度记为O(n)&lt;/p&gt;
&lt;h5 id=&quot;section-4&quot;&gt;5.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
  for(int i = 3;i &amp;lt; n;){
      i *= 3;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时函循环次数会随着3循环体中的常数3的的变化而变化,我们可以用对数来表示,&lt;/p&gt;
&lt;p&gt;假设循环次数为s,循环条件可表示为 s = 3^s &amp;lt; n;(即i本身为3,其次幂会不断的增长,但结果要小于n)&lt;/p&gt;
&lt;p&gt;当然这里有个条件是i的初值必须和每次乘等的值相同,形成次幂的增长;&lt;/p&gt;
&lt;p&gt;用对数表示为s = log3n,时间复杂度记为O(log3n),常数可以忽略,所以最后是O(logn)称之为&lt;strong&gt;对数阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数阶的数量级小于线性阶,因为若n的值相同,对数阶计算量必然小于线性阶&lt;/p&gt;
&lt;h5 id=&quot;section-5&quot;&gt;6.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
 for(int i = 0;i &amp;lt; n;i++){
     for(int j = 0;j &amp;lt; n;j++){
         for(int k = 0;k &amp;lt; n;k++){
       }
     }   
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述算法时间复杂度为O(n^3),3为常数,对应着循环的嵌套层数;也可以用O(n^C)表示,称为&lt;strong&gt;多项式阶&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;section-6&quot;&gt;7.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n){
  int num = 2;
  for(int i = 0;i &amp;lt; n;){ //O(n)
        num *= 2;
  }
  for (int j = 0;j&amp;lt;num;j++){ //O(n)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述函数输入的参数n将作为循环次数的指数,假设循环次数为s, s = 2^n,那么时间复杂度为O(2^n),&lt;/p&gt;
&lt;p&gt;称之为&lt;strong&gt;指数阶&lt;/strong&gt;,可记为O(C^n)&lt;/p&gt;
&lt;h5 id=&quot;section-7&quot;&gt;8.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n)
{
    for(int i=0;i&amp;lt;n;i++){
          for(int j=0;j&amp;lt;n;j++){
          }
    }   
  
      for(int i=0;i&amp;lt;n;i++){
      }             
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于顺序运行的算法,总时间复杂度等于算法中最大时间复杂度,即O(n^2)&lt;/p&gt;
&lt;h5 id=&quot;section-8&quot;&gt;9.&lt;/h5&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void bFunction(int n)
{
  if(n % 2 ==0){
    for(int i=0;i&amp;lt;n;i++){
          for(int j=0;j&amp;lt;n;j++){
          }
    }   
  }else{
      for(int i=0;i&amp;lt;n;i++){
      }             
  } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于具备分支结构的算法,总时间复杂度等于算法中时间复杂度最大路径的复杂度,即O(n^2)&lt;/p&gt;
&lt;h4 id=&quot;时间复杂度大小顺序&quot;&gt;时间复杂度大小顺序&lt;/h4&gt;
&lt;p&gt;常数 &amp;lt; 对数阶 &amp;lt; 线性阶 &amp;lt; 平方阶 &amp;lt; 多项式阶 &amp;lt; 指数阶&lt;/p&gt;
&lt;p&gt;O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(n^2) &amp;lt; O(n^C) &amp;lt; O(C^n)&lt;/p&gt;
&lt;p&gt;个人观点,若有错误敬请指出,谢谢!&lt;/p&gt;
</description>
<pubDate>Wed, 05 Feb 2020 16:07:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>数据结构小白入门 数据结构指一组相互之间存在一种或多种特定关系的数据元素的集合, 当我们需要在计算机中存储这些数据时,还涉及到数据的,组织方式,在计算机中的存储方式,以及定义在该数据上的一组操作; 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12267404.html</dc:identifier>
</item>
<item>
<title>图像增强之空间域滤波 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12267325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12267325.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、为什么进行图像增强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图像增强是指增强图像中某些特征，同时削弱或去除某些不需要的信息，即为了某种应用而去改善图像的质量，消除噪声，显现那些被模糊了的细节或简单的突出一副图像中感兴趣的特征。所以图像增强并不是增强图像的原始信息，而是只针对某一特征以提高某种信息的辨别能力，图像增强需要根据需求采用特定的方法，当增强一些信息时另外一些信息必定被损失，不存在一种通用的方法，必须根据需求决定保留哪些信息丢弃哪些信息。&lt;/p&gt;
&lt;p&gt;图像增强技术基本上可以分为两类：空间域增强、频域增强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、空间域滤波理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1定义&lt;/p&gt;
&lt;p&gt;空间域滤波就是在图像平面上对像素进行操作。&lt;/p&gt;
&lt;p&gt;空间域滤波大体分为两类：平滑、锐化。&lt;/p&gt;
&lt;p&gt;平滑滤波：模糊处理，用于减小噪声，实际上是低通滤波，典型的滤波器是高斯滤波。&lt;/p&gt;
&lt;p&gt;锐化滤波：提取边缘突出边缘及细节、弥补平滑滤波造成的边缘模糊。实际上是高通滤波。&lt;/p&gt;
&lt;p&gt;空间域处理可由下式表示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;g(x,y)=T[f(x,y)]&lt;/p&gt;
&lt;p&gt;式中，f(x,y)是输入图像，g(x,y)是处理后的图像，T是在点(x,y)的邻域上定义的关于f的一种算子，算子可应用于单幅图像或图像集合。&lt;/p&gt;
&lt;p&gt;2.2空间域滤波和邻域处理&lt;/p&gt;
&lt;p&gt;1）空间滤波器由一个邻域（通常是一个较小的矩形）和对该邻域所包围图像像素执行的预定义操作组成。对预定义的点（x，y）为中心的领域内的像素进行计算。&lt;/p&gt;
&lt;p&gt;2）滤波产生一个新像素，新像素的坐标等于邻域中心的坐标（x，y），像素的值是滤波操作的结果。即用计算后的新像素值作为点（x，y）的值。&lt;/p&gt;
&lt;p&gt;3）循环步骤1和2，滤波器的中心遍历图像中的每个像素后，就生成了滤波后的图像。&lt;/p&gt;
&lt;p&gt;4）如果在图像像素上执行的是线性操作，则该滤波器称为线性空间滤波器，否则，称为非线性空间滤波器。&lt;/p&gt;
&lt;p&gt;一般来说，使用大小为 m×n的滤波器对大小为 M×N的图像进行线性空间滤波，可由下式表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205233231063-1491516224.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;59&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、平滑滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平滑滤波可以减少和抑制图像中的噪声，平滑后图像变得模糊，噪声降低。模糊处理常用于预处理任务中，如在目标提取之前去除图像中的一些琐碎细节，以及桥接直线或曲线的缝隙。&lt;/p&gt;
&lt;p&gt;1）工作原理&lt;/p&gt;
&lt;p&gt;一般来说，图像具有局部连续的性质，即相邻的像素的值相近，而噪声使得噪点处产生像素跳跃，所以通过平滑噪点可以减少噪声，去除图像中的不相关细节。&lt;/p&gt;
&lt;p&gt;2）均值滤波和加权滤波&lt;/p&gt;
&lt;p&gt;平滑滤波的输出是包含在滤波器模板邻域内的像素的简单平均值，也就是均值滤波器。&lt;/p&gt;
&lt;p&gt;均值滤波器是低通滤波器，常见的操作有均值滤波和加权滤波。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205234059874-1348277891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;W是滤波模板，模板的大小取决于需要滤除的物体的大小，使用时需要更具图像特点选择模板尺寸。&lt;/p&gt;
&lt;p&gt;为什么使用加权，平滑滤波对领域内的像素一视同仁，但是一般认为距离模板中心的像素应对滤波结果有较大的贡献，所以将模板中心的系数取得比模板周边的系数大，随着距离中心距离增大，权重迅速减小。高斯滤波就是一种加权滤波，只不过模板中的系数由高斯分布来确定的。&lt;/p&gt;
&lt;p&gt;3）实现&lt;/p&gt;
&lt;p&gt;Matlab滤波可以用fspecial产生滤波模板。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;f=fspecial('average', 3)产生系数为：&lt;/p&gt;
&lt;p&gt;f =&lt;/p&gt;
&lt;p&gt;    0.1111    0.1111    0.1111&lt;/p&gt;
&lt;p&gt;    0.1111    0.1111    0.1111&lt;/p&gt;
&lt;p&gt;    0.1111    0.1111    0.1111&lt;/p&gt;
&lt;p&gt;例1：均值滤波&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
imgPath = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\opencv_pic\src_pic\pic4.bmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
img &lt;/span&gt;=&lt;span&gt; imread(imgPath);
img &lt;/span&gt;= imnoise(img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salt &amp;amp; pepper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;0.02&lt;/span&gt;&lt;span&gt;);
 
f&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;average&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
img1&lt;/span&gt;=&lt;span&gt;imfilter(img, f);
f&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;average&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
img2&lt;/span&gt;=&lt;span&gt;imfilter(img, f2);
 
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),imshow(img), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;原始图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),imshow(img1),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;均值滤波1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),imshow(img2),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;均值滤波2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见下图，当滤波系数为3*3时，可以滤波大部分噪声，当滤波系数为10时，滤除了全部噪声但是图像变得模糊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205233321542-440083290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例2：高斯噪声滤波&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
imgPath = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\opencv_pic\src_pic\pic4.bmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
img &lt;/span&gt;=&lt;span&gt; imread(imgPath);
img &lt;/span&gt;= imnoise(img, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gaussian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;);
 
f&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;average&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
img1&lt;/span&gt;=&lt;span&gt;imfilter(img, f);
f2&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gaussian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;);
img2&lt;/span&gt;=&lt;span&gt;imfilter(img, f2);
 
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),imshow(img), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;原始图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),imshow(img1),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;均值滤波&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),imshow(img2),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;两个滤波模板分别为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;f =&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0400    0.0400    0.0400    0.0400    0.0400&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0400    0.0400    0.0400    0.0400    0.0400&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0400    0.0400    0.0400    0.0400    0.0400&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0400    0.0400    0.0400    0.0400    0.0400&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0400    0.0400    0.0400    0.0400    0.0400&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;f2 =&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0005    0.0050    0.0109    0.0050    0.0005&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0050    0.0522    0.1141    0.0522    0.0050&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0109    0.1141    0.2491    0.1141    0.0109&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0050    0.0522    0.1141    0.0522    0.0050&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    0.0005    0.0050    0.0109    0.0050    0.0005&lt;/p&gt;
&lt;p&gt;滤波效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205233355876-1459120003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 放大后观察细节，均值滤波在渐变处出现严重的模糊现象，高斯滤波由于使用了带权重的滤波系数，情况好很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205233411056-76267593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;、自适应平滑滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）原理&lt;/p&gt;
&lt;p&gt;利用平均模板平滑在消除噪声的同时也使得图像变得模糊，高斯平滑在一定程度上缓解了这些现象，但由于平滑滤波的原理可知这种模糊是不可避免的。所以可以进行选择性的平滑，即只对噪声局部区域进行平滑，对无噪声的局部区域不进行平滑，将模糊的影响降到最低。&lt;/p&gt;
&lt;p&gt;2）实现&lt;/p&gt;
&lt;p&gt;自适应的关键是对噪声区域的识别，哪些区域是需要平滑的，哪些区域不需要。一般地，噪声的存在使噪声点产生灰度跳跃，从而使噪声点局部区域灰度跨度较大。&lt;/p&gt;
&lt;p&gt;所以，方法1：可以设定阈值T，当局部最大灰度和最小灰度只差大于阈值，则进行平滑；否则不平滑。方法2：当局部区域灰度方差大于阈值T则进行平滑；否则不平滑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、中值滤波&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）原理&lt;/p&gt;
&lt;p&gt;中值滤波是一种统计排序滤波器，图像上点（x，y），中值滤波以该点为中心，领域内所有像素的统计排序中值作为此点的响应，中值滤波是非线性滤波。&lt;/p&gt;
&lt;p&gt;相比与均值滤波和高斯滤波，中值滤波可以有效的降低随机噪声，直接忽略掉噪声点，把噪声引起的模糊降到最低。典型的应用就是中值滤波消除椒盐噪声。&lt;/p&gt;
&lt;p&gt;2）中值滤波效果对比&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
imgPath = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\opencv_pic\src_pic\pic4.bmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
img &lt;/span&gt;=&lt;span&gt; imread(imgPath);
img0 &lt;/span&gt;=&lt;span&gt; rgb2gray(img);
img &lt;/span&gt;= imnoise(img0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salt &amp;amp; pepper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
f&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;average&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
img1&lt;/span&gt;=&lt;span&gt;imfilter(img, f);
f2&lt;/span&gt;=fspecial(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gaussian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;);
img2&lt;/span&gt;=&lt;span&gt;imfilter(img, f2);
img3&lt;/span&gt;=medfilt2(img, [&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
 
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),imshow(img0), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;原始图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;),imshow(img), title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;噪声图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),imshow(img1),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;均值滤波&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;),imshow(img2),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
subplot(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;),imshow(img3),title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中值滤波&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;从下图可见，线性平滑滤波在滤除噪声的同时不可避免的引起了模糊，而中值滤波在有效滤除随机噪声的同时，还有效抑制了模糊效应。对于椒盐噪声图像，中值滤波的效果要好于线性平滑滤波。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205233453047-1474154821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放大后观察细节，中值滤波较好的还原了原图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200205234320924-814956971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、图像增强之空间域滤波 -- Part1. 原理篇&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hhaowang/article/details/87978218&quot;&gt;https://blog.csdn.net/hhaowang/article/details/87978218&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、Image Filtering and Enhancement&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/images/image-enhancement-and-restoration.html?s_tid=CRUX_lftnav&quot;&gt;https://ww2.mathworks.cn/help/images/image-enhancement-and-restoration.html?s_tid=CRUX_lftnav&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;3.4623655913978&quot;&gt;
&lt;p&gt;尊重原创技术文章，转载请注明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12267325.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12267325.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Wed, 05 Feb 2020 15:41:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>图像增强之空间域滤波</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12267325.html</dc:identifier>
</item>
<item>
<title>冬日曙光——回溯CNN的诞生 - KenSporger</title>
<link>http://www.cnblogs.com/kensporger/p/12267319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kensporger/p/12267319.html</guid>
<description>&lt;p&gt;　　卷积神经网络(CNN)作为深度学习的重要一支，在当前计算机视觉领域应用相当广泛。本文回顾了深度学习的发展历程，讲述CNN基本的理论概念和第一代卷积神经网络LeNet-5的建立。文章言有不当之处，还望批评指出，共同进步！&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205114222497-1395214732.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2015年，AlphaGo战败樊麾二段，&quot;深度学习&quot;的命运就此改变，这个曾被抛弃忘却的领域成为了数年至今无数人追求的研究方向。然而，它璀璨夺目的前世却充满了暗淡与不幸。&lt;/p&gt;
&lt;p&gt;　　“深度学习”的概念正式提出是在2006年，狭义上可以看作是人工神经网络。最早的相关研究是19世纪40~60年代的控制论，已经提出了前馈层次网络摸型，也就是感知器，不过只是一种简单的线性模型。该模型功能类似于拟合$f(x,\omega )=x_0\omega_0+x_1\omega_1+...+x_n\omega_n$这样的函数，但在许多像异或问题的情形下显得无能为力。&lt;/p&gt;
&lt;p&gt;　　直到80年代，Hinton等人提出了反向传播(BP)算法，使得模型具备了非线性映射的能力，解决了历史遗留下来的异或问题。但当时很多神经网络的研究者都是物理学家或者是心理学家，神经网络普遍不能被工程师和计算机科学家所接受。并且，因为受限于当时的数据规模，模型训练很容易出现“过拟合”，加上机器计算能力的不足和神经网络算法的“神秘性”，那些本就寥寥无几的研究者也逐渐对它失去了兴趣，纷纷转行钻研支持向量机(SVM)的机器学习算法。虽然如此，当时却仍有一些“固执”的探索者凭着坚定的信念在神经网络领域默默耕耘，其中就包括后来建立LeNet网络的Yann LeCun。&lt;/p&gt;
&lt;p&gt;　　1998年，Yann LeCun等人在IEEE上发表了《Gradient-based learning applied to document recognization》一文，文中提出了基于梯度学习的卷积神经网络算法，并成功运用于手写数字识别中，取得了低于1%的错误率，超过了当时所有的模型，由此神经网络的研究开始回热。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205114306012-1969361937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一个卷积神经网络并非是LeNet，而是1987年由Alexander Waibel等人提出的时间延迟网络(Time Delay Neural Network, TDNN)。TDNN是一个应用于语音识别问题的一维卷积神经网络，而二维网络则是由Yann LeCun提出的，并且论文中首次使用了“卷积”一词，所以以“第一人”称呼Yann LeCun不为过。&lt;/p&gt;
&lt;p&gt;　　据吴恩达对LeCun的采访了解，LeCun从小就对科技兴致盎然，尤其是对“人类的智慧”、“有智慧的机器”等话题非常痴迷，最喜欢看有“现代科幻电影技术里程碑”美誉之称的《2001太空漫游》——看来幼时的兴趣着实能影响一个人的一生啊！后来在大学期间，LeCun通过一本辩论语言是否天生的哲学书间接了解到了“感知器”的概念。抱着满脑的好奇，他去了好几个大学的图书馆，想要找到有关的资料进一步学习，才发现在50年代之后就很少有人谈及到感知器了。&lt;/p&gt;
&lt;p&gt;　　当LeCun拿到工程学位以后，LeCun去学习了与神经网络并不相关的芯片设计，但同时对研究神经网络仍念念不忘——在当时，还没有出现所谓的反向传播算法，如何训练多层网络依旧是困扰研究者的一大难题，LeCun因此特别想从事这方面的研究。幸运的是，老天从来不会辜负有理想并为之努力的人，LeCun在后来渐渐接触到了一些神经网络方面的研究者，这些人都多多少少对他产生过影响。例如，当时有群法国实验室的人正在研究自动机网络，给他看了一些前沿的论文，其中就有Hinton和Terrence写的关于玻尔兹曼机的文章，LeCun看后非常震惊，原来世界上有这样一群人已经找到了神经网络正确的研究方向。&lt;/p&gt;
&lt;p&gt;　　后来在读博期间，LeCun有幸遇到了当年论文的作者之一Terrence，通过交流，他从Terrence那了解到了反向传播，这个概念当时还处于研究阶段，没有论文的发表。Terrence从法国回到美国后，就跟好友Hinton谈及了LeCun，几个月后Hinton的演讲会上，LeCun便认识了这位对他影响深远的导师。&lt;/p&gt;
&lt;p&gt;　　LeCun最早开始研究卷积网络是在多伦多大学跟着Hinton做博士后的阶段。那时候没有像现在这样丰富完善的数据库，自然也没有现在被人“嚼烂”了的MNIST数据集，LeCun就用鼠标在个人电脑上一个一个地画出字符用作训练样本，就这样做出了早期的卷积神经网络，并且那时已经有超越传统网络的迹象了。再后来，不得不提的就是贝尔实验室了，可以说它是LeCun成功的重要平台。在实验室，LeCun拥有了自己专用的Sun4电脑(在多伦多大学一台Sun4电脑是整个学院共享的)，当时实验室的主管Larry说，在贝尔实验室没有谁是能靠省钱省出名的。在刚加入实验室的三个月内，LeCun便用实验室原本建立的数据集USPS训练出了第一代LeNet，得到了实验室内最好的效果。虽然现在回过头看LeNet的架构已经相当普通了，甚至一些教程里都只是一笔带过，网上也有各种版本的复现，但对于当时环境来讲，没有Python、Matlab，没有Pytorch、TensorFlow等现成框架，网络的构建需要自己写模拟器和解释器，是相当复杂的。&lt;/p&gt;
&lt;p&gt;　　再后来，被人所铭记的就是LeCun在98年的LeNet论文，论文中提及了LeNet5和自动机，标志着真正的CNN诞生了。现今任何的卷积网络你都可以看到LeNet的影子，Yann LeCun也同Geoffrey Hinton 和 Yoshua Bengio一起获得了2018年的图灵奖，并称为“深度学习三巨头”。&lt;/p&gt;
&lt;p&gt;　　成功背后——在被问及深度学习的冬天时，LeCun说道，我一直坚信这些方法总有一天会回到大家的视野中，大家会学会如何用它们，解决一些实际问题。我一直有这个信念。&lt;/p&gt;


&lt;p&gt;　　我个人刚接触深度学习并没有太长时间，同许多人一样，也是看着吴恩达老师的视频“长大”的。庆幸的是，我们学校有自组织的深度学习小组，所以在一定程度上讲，我并非是完全的自学，这一点我认为还是很重要的——众人的智慧总是比个人来得强大。同样，LeNet5也并非纯粹的个人成果，其中也汲取了时代的经验。此外，我认为，有些人学深度学习都是没有“根”的(有点狂妄了)，这里所讲的“根”便是历史的概念。高中时候学历史总感觉兴味索然，认为历史无用，理科才是有“料”的；但反观物理学，了解物理的发展史是基本的素养。深度学习也是一样，当视频中讲到拟合、误差函数、梯度下降等概念的时候，总以为学到了一些很先进的概念，其实回顾历史，这些东西早在上世纪中期就差不多有了。&lt;/p&gt;
&lt;p&gt;　　这一节主要讲的是在LeNet5提出前当时已有一些重要成果，也只是蜻蜓点水一般地描述，不会过度深入地解释，一来是自己的底子薄弱，二来也并非是文章的主旨。&lt;/p&gt;

&lt;h2&gt;Loss and Gradient&lt;/h2&gt;
&lt;p&gt;　　神经网络的训练实质上就是网络权重的更新调整。现在的网络基本都采用计算损失函数结合梯度下降来更新参数，有趣的是，最早具备这种特征的算法在70年前差不多就存在了，该算法被称为Delta学习规则，其修正公式是$\omega_{ij}(t+1)=\omega_{ij}(t)+\alpha(d_i-y_i)x_j(t) $。其中，$\alpha$为学习速率，$d_i$和$y_i$为神经元i的期望输出和实际输出，$x_j(t)$为神经元j的状态(神经元i输入)，可以发现，这跟我们现在的权重更新是很相似了，只是Delta学习规则是针对单层网络而言的，对于多层网络的权重更新，当时的人还是一头雾水。&lt;/p&gt;
&lt;p&gt;　　不过从那时起到现在，人们对于如何从数据中学习的基本思想是一致的——无论什么样的网络，我们都希望，实际的输出和期望的结果间的差别最小(损失函数的内涵所在)，而影响损失函数的便是网络的权重，所以可借助损失函数的梯度，来衡量参数对损失函数值的影响力大小，进而更新权重(梯度更新的内涵)。&lt;/p&gt;

&lt;h2&gt;Training error and Test error&lt;/h2&gt;
&lt;p&gt;　　在LeNet5论文中，作者曾谈到一个经验公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205133724285-998050171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　$E_{test}$和$E_{train}$分别表示测试集和训练集的误差；$k$和$\alpha$都是常数，$h$是网络复杂度水平，$P$表示数据集的大小。这个简单公式实际上可以当做是整个深度学习研究的潜在定律：首先，对深度学习有过了解的人都知道随着网络复杂度的增加，对训练集的拟合效果会越来越好，也就是训练集误差会下降，公式也验证了这个常识。那么这种情况下的测试集误差呢，一开始可能也是下降的，但下降的速度一般都比训练集慢，这就牵扯到网络的泛化能力了，假如复杂度再增加，如果数据集大小不变的话，很可能就会有过拟合问题冒出来。再来看数据集大小的影响，随着$P$的增大，测试集误差会无限接近训练集的误差，这往往是研究者们期望看到的结果。&lt;/p&gt;
&lt;p&gt;　　在实际训练时，我们既想要训练集误差的下降，又想要测试集误差尽可能接近训练集误差，这就对硬件的性能和数据获取提出了巨大的挑战。即使在今日，我们也没办法将这两项都做到极致，力所能及的只是做到两者的平衡罢了，这也是当时研究者所能看到的状况。&lt;/p&gt;

&lt;h2&gt;SGD&lt;/h2&gt;
&lt;p&gt;　　神经网络发展过程出现了很多的梯度下降法，其中有很多好的算法可以加快下降、更容易找到全局最小值，比如现在普遍使用的Adam。但在90年代用的比较多的还是随机梯度下降SGD，SGD从60年代开始便有在研究了，只是到了80年代中期才被应用到网络上。总的来说，SGD每次采用个别样本来更新权重，这使得计算量减少了很多，收敛得也更快，不容易困在局部最小值里出不来，当然前提是训练集得足够大，稀释噪声带来的影响。&lt;/p&gt;

&lt;h2&gt;Back-Propagation&lt;/h2&gt;
&lt;p&gt;　　LeNet的出现或者CNN的发展都要感谢反向传播算法的提出。在反向传播算法提出以前，梯度下降都只能应用于线性网络中，因为人们无法很方便地求解多层网络间对参数的导数。反向传播实质上是链式法则的应用，相信一些像我一样的深度学习的初学者对反向传播的过程也不是很熟悉——现在的框架像TensorFlow具备了自动求导的功能，根本不需要手动一层层地向前求导了。之前知乎上看到胡渊鸣大神一篇文章讲述了自己曾被链式求导法则折磨了很久，于是最后将其开发的模拟器命名为ChainQueen来纪念那段经历，可知链式求导可不是说说那么简单的呀！&lt;/p&gt;
&lt;p&gt;　　其实还有很多的技术可以一一说来的，但是精力和能力有限，这里不再叙述了。有兴趣的可以看看LeNet5论文，包含了很多当时的研究状况。&lt;/p&gt;



&lt;p&gt; 　　我们经常讨论一些很有意思的为什么，比如：“为什么自然选择人成为高等生物”、“为什么民主和法治是制度发展的趋势”、“为什么华为能成为行业的领先者”等等，这些问题似乎都遵循了物竞天择的道理。在卷积网络出现前，普遍使用的都是全连接的形式，卷积凭借什么特性能够独树一帜呢？本节将讲述卷积网络的基本概念和优越之处。&lt;/p&gt;

&lt;h2&gt;全连接的败因&lt;/h2&gt;
&lt;p&gt;　　针对2D图像识别的全连接网络，首要的问题便在于参数过多。试想一下，一张32*32像素大小的手写字符图片作为第一层输入，假使第二层神经元数量只有100个，那么需要训练的数量就已经达到32*32*100=102400个了，何况一般的网络层数都要在3层以上。对于全连接网络，网络的连接数等于要训练的参数个数(不考虑偏置的话)，一方面网络复杂性的提高是必须的，但是参数增加的同时所需要的训练数据也必须增加，否则就容易过拟合，因此全连接层带来的参数增长和过拟合问题在当时是著名的难题。&lt;/p&gt;
&lt;p&gt;　　其次就是网络不具备特征不变性。最简单的例子就是，如果你拿一批字符都在中间的数据去训练的话，即使测试时准确率有多高，如果用一批字符都偏左边的数据去测试，那么得到的结果将大跌眼镜。其中原因就在于全连接层是顺序输入的，非常依赖于特征的位置信息，因此导致了它对平移、形变、扭曲等几何变换非常敏感。&lt;/p&gt;
&lt;p&gt;　　进一步地说，因为全连接层是每个像素单独对应一个权重，而图像特征大多都是相邻像素的组合，这种做法显然忽视了图片像素的拓扑结构，就像是“管中窥豹”一般。再打个有趣的比方，我让你去识别一个数字，但规定了你一次只能看图片里的一个像素，这显然是故意为难你啊！&lt;/p&gt;

&lt;h2&gt;局部感受野&lt;/h2&gt;
&lt;p&gt;　　要了解卷积网络，就必须先了解什么是感受野。这个概念最早是在1959年的对猫的初级视皮层的一项研究中提出的，卷积网络便是受到了它的启发。&lt;/p&gt;
&lt;p&gt;　　我们可以通俗地将感受野理解为眼睛所能看到的区域，比如说，眼睛可以看到整个图片的内容，那感受野就是一张图片那么大；如果也让这只眼睛来次“管中窥豹”，那感受野就可能减少为几个像素的大小了。例子的后者就可以认为是局部感受野，因为只能看见图片的一部分。现在，我们将网络的每一个神经元都看作一双双眼睛，那么情景就如下图一样，每双眼睛观察的地方都不一样，但视野大小相同，最终整个图片都会被窥看一尽。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205164158719-1864653797.jpg&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;312&quot;/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205164841801-867363755.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看的过程并非是漫无目地赏景，而是对视野内的像素作加权运算，感受野每个位置都有权重值，这些权重值就是网络的训练参数。加权所得的值作为这只“眼睛”的值，然后感受野会平移一定像素距离，这个距离称为步长。移动后的感受野再次加权运算，结果作为另一只“眼睛”的值。这样，前一层的图就会映射成新的图，这个图叫做特征图。&lt;/p&gt;
&lt;p&gt;　　这就是局部感受野，相比于全连接，它同时考虑某个局部区域，这样更容易提取到想要的特征。&lt;/p&gt;

&lt;h2&gt;共享权重&lt;/h2&gt;
&lt;p&gt;　　为什么叫做“特征图”呢？如果有接触过图像处理的话，会知道卷积在图像平滑、边缘等方面应用很多。一种权重的感受野(以下简称“一种感受野”)可能会“感受”到边缘特征，另一种感受野可能会“感受”到拐角特征。对于一张特征图来说，因为都是由同一种感受野观察到的，因此很可能就是一张某种特征的集合，只是这些特征分布在前一层图的不同位置。&lt;/p&gt;
&lt;p&gt;　　我们将之前的模型推广一下，如下图所示，前一层图具有3个通道。在卷积的过程中，感受野不再是二维，而变成了三维形式，包含的权重参数也就有3*3*3=27个。感受野每平移一次，27个像素值线性加权，结果作为这只“眼睛”的值，卷积完毕后得到一个新特征图。在实际应用中，通常对前一层图卷积多次，每次使用不同的感受野，以获得多种特征。比如卷积4次，那么总共就用了4种三维感受野，得到4种特征。&lt;/p&gt;
&lt;p&gt;　　　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205202254055-1351252528.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　共享权重就体现在每次卷积只使用一种感受野。之所以将感受野变成三维模式，可以这么理解：在多层卷积网络中，某层网络有n通道的特征图，也就有n种特征；对该层卷积就是对这n个特征进行组合，获取更高维特征的过程，因而三维感受野的线性加权相当于特征的组合，权重不同，组合方式也不同。&lt;/p&gt;
&lt;p&gt;　　再来算一下所产生的参数量，假设卷积4次，步长为1，感受野大小为3*3，前一层图大小为32*32，有3个通道。将感受野扩展为三维形式，一个感受野有3*3*3+3=30个参数(加上每个感受野有个偏置参数)，于是总参数量为30*4=120个。经过卷积后生成的特征图大小为30*30(感受野不能超过图的边界，因此少了两行两列)，共4个通道，那就有4*30*30个“眼睛”，每个眼睛在卷积时都有27+1根连接线，所以总连接数为4*30*30*28=100800。可以看到，在保持网络复杂性的同时，有效降低了需要训练的参数，这就是共享权重带来的好处。&lt;/p&gt;

&lt;h2&gt;下采样&lt;/h2&gt;
&lt;p&gt;　　向后层网络传递时，特征图的大小总是不断缩减，而通道不断增加的。这样做使得特征越来越多，越来越重要，而位置信息越来越少。事实上，物体的识别何尝不是这样的呢？例如，我们判断一个动物是不是猫，根本就不用在意它体型多大，是肥的还是瘦的；不用在意它坐在桌上，还是躺在床上。而是去看它的胡须、耳朵、鼻子等等的细节特征。再比如判断一个数字是不是7，我们会看它的三个端点的相对关系，至于它多少大、写得多少歪那只不过是审美上的事罢了。卷积网络更是这样，在最后几层的特征图里，你根本看不出是个啥玩意儿，因为太高维了！&lt;/p&gt;
&lt;p&gt;　　卷积网络的这个特性在一定程度上要归功于下采样操作，它类似于卷积，不过不含权重，一般对每个通道都在感受野内选择最大值或者均值作为结果，因此下采样后特征图的大小会减小，但通道数仍不变。这种操作类似于将一张图片进行缩小，在缩小时主动丢失了一些像素信息，但是整体上看内容基本上没有发生变化。&lt;/p&gt;
&lt;p&gt;　　很多教程上说，下采样有三种功效：一定程度的特征不变性、防止过拟合和减少参数量。最后一个功能是显而易见的，过拟合在参数减少情况下也相对难以出现，但是关于特征不变性我还不能很好理解(大佬如果知道，可以教教我)，只能这样解释：下采样建立了一种激励机制，越有帮助的特征其值便越大，这通过网络的反馈和权重的调整应该是可以做到的，既而特征所处的位置就不再敏感，形变的输入也会因为这种机制凸显出所要的特征。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205212605733-1993875592.png&quot; alt=&quot;&quot; width=&quot;1059&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　LeNet-5是为手写字符的识别专门而生的，LeCun后来也建立了MNIST数据库供人们使用，现在初学者一般都会拿这个数据集下刀。跑这个数据集的话，我还是很想建议用全连接层和LeNet-5跑一下的——用过笨办法，你才知道智慧是怎么来的。&lt;/p&gt;
&lt;p&gt;　　LeNet-5当时用的图片大小是32*32的，这个跟现在的不一样，现在直接就是28*28了。其实32*32也是LeCun他们自己从28*28扩出来的，而现在的边缘处理由框架直接可以实现了。LeNet采用的是最原始的卷积下采样交替，全连接输出的结构。&lt;/p&gt;
&lt;p&gt;　　输入的图像像素值都经过了严格的归一化处理，最后255对应了-0.1，0对应了1.175，归一化的过程作者并未提及，只是说这样处理后数据的均值近似0，方差近似为1，这与现在的概念差不了多少。&lt;/p&gt;
&lt;p&gt;　　C1层、S2层很普通就不啰嗦了。C3层采用了很怪异的局部连接，就是每次卷积并非都对全部通道进行，而是有选择的进行，具体配置请看下图，至于这样有选择的进行特征组合是否有意义呢？很不好说，至少现在的网络都不这么做了。不过，这里有个很有趣的点——假如让LeCun在中间再加一层卷积，他还会不会这么干？表示很好奇。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1547375/202002/1547375-20200205215625933-1233515670.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　S4也略过。因为输入大小的巧合，所以C5层已经是被展平了，但是在结构上仍表示一层卷积，因此作者没有把它标成F5。图中的高斯连接涉及到了当时的RBF算法，类似于现在的softmax，这里也不深入探究了。&lt;/p&gt;
&lt;p&gt;　　另外，除了输出层以外的层都采用了tanh型激活函数，在当时，sigma函数的缺点就已经被发现了。还有一个不同点就是，LeNet的下采样层也是有训练参数的，当时他采用的还是平均值采样，再乘以一个权重值。&lt;/p&gt;



&lt;p&gt;　　最近正在学习卷积神经网络，打算好好琢磨一下这几年出现的经典网络。深度学习是一个很“玄学”的研究，有很多地方都值得去思考深究。之前看到有人问一个只专于图像处理算法研究的博主，为什么不去搞深度学习，博主评论道，如果你不去原理上研究深度学习，那这就是个调参的东西，没什么意思。&lt;/p&gt;
&lt;p&gt;　　我前两天纠结要不要好好看一下LeNet论文，要不要写这样一篇回顾性的文章，毕竟LeNet对于现在来讲已经不怎么用了。就像前文提到的，你是倾向于紧追潮流，还是愿意先回头瞥一眼历史，这个话题在飞速发展的今天显得挺有意思。后来整理过程中，我觉得历史还是很重要的，历史能帮助我搞清楚自己研究这个的目的，是为了有一技之长，还是为了什么？&lt;/p&gt;
&lt;p&gt;　　这里分享LeCun的一段话：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AI 这个领域和我刚刚进入的时候已经完全不一样了。我觉得这个领域现在有一点很棒，就是想要在一定程度上参与进来是很简单的一件事。我们现在有很多简单好用的工具，TensorFlow、PyTorch 等等一大堆，自己家里随便一个什么电脑就能运行得起来，然后训练一个卷积网络或者循环神经网络做任何想做的事情。除了这些工具，也还有很多线上的教学资源可以学习，没有什么门槛，高中生都能玩得转，我觉得这棒极了。而且现在的学生里对机器学习、AI 感兴趣的也越来越多，年轻人也能喜欢真的很好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的建议是，如果你想要进入这个领域的话，做出一些帮助，比如在开源项目里贡献一些代码，或者实现某个网上找不到代码的标准算法，这样别人就有得用了。你可以就找一篇你觉得重要的论文，把算法实现出来，然后做成开源的代码包，或者贡献到别的开源代码包里。如果你写的东西有趣、有用，就会有别人注意到你，你非常想去的公司可能会发 offer 给你，你很想读博的地方也可能给你回信，之类的。我觉得这是一种很好的开头方式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　最后，还是得感谢大家的阅读！&lt;/p&gt;



</description>
<pubDate>Wed, 05 Feb 2020 15:39:00 +0000</pubDate>
<dc:creator>KenSporger</dc:creator>
<og:description>前言 卷积神经网络(CNN)作为深度学习的重要一支，在当前计算机视觉领域应用相当广泛。本文回顾了深度学习的发展历程，讲述CNN基本的理论概念和第一代卷积神经网络LeNet-5的建立。文章言有不当之处，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kensporger/p/12267319.html</dc:identifier>
</item>
<item>
<title>机器学习-计算机视觉和卷积网络CNN - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12267298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12267298.html</guid>
<description>&lt;p&gt;对于计算机视觉的应用现在是非常广泛的，但是它背后的原理其实非常简单，就是将每一个像素的值pixel输入到一个DNN中，然后让这个神经网络去学习这个模型，最后去应用这个模型就可以了。听起来是不是很简单，其实如果大家深入研究的话，这里面还是有很多内容去学习的，例如：咱们的图片大小可能不一样，同一张图片不同的旋转角度可到的结果可能不一样，如何给咱们的本地图片来label（实际中并不是所有的数据都想mnist那样，谷歌都给咱们label好了，拿来用就行），等等这些问题咱们在实际中肯定都是要用到的。这一节首先会先介绍一下如何直接将图片的塞进网络训练；第二部分会介绍一下卷积网络的结构原理和应用（用谷歌自己提供的mnist数据集）；第三部分我会介绍一下如何用卷及网络CNN来训练咱们自己的图片数据。其中的核心重点是咱们的第二部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;传统DNN之图片识别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;传统的DNN肯定大家都是知道的，就是通过构建Sequential layers, 然后将咱们的图片的pixel值作为数据传递给这个DNN的input layer， 只有这个input layer后面的dense layers是根据用户自己的需求进行创建架构的。那么通过什么流程来训练呢？首先第一步咱们得加载数据，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mnist =&lt;span&gt; tf.keras.datasets.fashion_mnist
(training_images, training_labels), (test_images, test_labels) &lt;/span&gt;=&lt;span&gt; mnist.load_data()
training_images&lt;/span&gt;=training_images/255.0&lt;span&gt;
test_images&lt;/span&gt;=test_images/255.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的数据是咱们TensorFlow自带的，它都帮助咱们这里好了，也帮助咱们把图片的labels都设定好了，帮助咱们省了很多的功夫，但是很遗憾，这些数据只能在学习的时候用，在实际的工业环境中，咱们是不可能这么幸运的，嘿嘿。那么咱们这里就先用这个demo 数据来学习吧。接下来第二步，咱们来构建咱们的DNN，咱们接着往下看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
model =&lt;span&gt; tf.keras.models.Sequential([
  tf.keras.layers.Flatten(),
  tf.keras.layers.Dense(&lt;/span&gt;512, activation=&lt;span&gt;tf.nn.relu),
  tf.keras.layers.Dense(&lt;/span&gt;10, activation=&lt;span&gt;tf.nn.softmax)
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里跟咱们前面说的普通DNN稍微有点不同，那就是咱们在dense layers之前加了一个tf.keras.layers.Flatten()函数，因为咱们的图片不像咱们之前dataframe数据那样每一行数据都是将features排列好的，每一张图片都是一个二维（或者三维）的pixel值，这些pixel就是咱们这个model的features，所以咱们必须得将这个图片的像素全部转化成一列数据，而咱们的Flatten()函数就是做这个工作的。在这个classification的场景中，咱们一共有的classes是10个，所以咱们最后的output layer的units的数量是10个，这个数量必须要匹配，否则会有error。第三部就是configure这个模型，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
model.compile(optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sparse_categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然啦，在这里咱们可以加一个callbacks，当咱们的loss小于0.4的时候，咱们就停止咱们模型的训练&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; myCallback(tf.keras.callbacks.Callback):
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; on_epoch_end(self, epoch, logs=&lt;span&gt;{}):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(logs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;lt;0.4&lt;span&gt;):
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(logs)  
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nReached 0.4 loss so cancelling training!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      self.model.stop_training &lt;/span&gt;=&lt;span&gt; True

callbacks &lt;/span&gt;= myCallback()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后当然就是咱们的训练的过程啦，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
model.fit(training_images, training_labels, epochs=5, callbacks=[callbacks])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于后面的predict和evaluate的过程，更前面章节讲的都是一模一样的，这里就不在展示啦。上面展示的是一个用传统的DNN来训练label好了的图片来创建一个神经网络，可惜的是在实际中我们几乎不会用这种方式来做图片的classification，因为在实际中每一个图片的大小都是不一样的，所以每一个input layer都是不一样，很显然这不符合咱们的实际情况；另外实际中图片不可能都是给你label好了，并且放在dataset里面，这些都需要咱们额外去做的工作，那么咱们这里就要来看看咱们如何来解决这些问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;计算机视觉之图片数据准备&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;咱们都知道在实际中，咱们没有准备好的mnist dataset，所有的图片都需要咱们自己去label，那么如何给不同的本地图片分配不同的labels, 并且最后怎么组织这是图片和label数据来训练呢？这里咱们就要用到一个TensorFlow里面专门用于处理图片的一个库了，那就是ImageDataGenerator，它会给咱们的图片根据文件夹的名称来label，并且将这些图片和labels组织起来变成一个类似于dataset的数据集，我们称之于generator，咱们在这里就将它看成一个类似于dataset的数据集就行了，并且可以直接传递给model.fit()来训练，就跟dataset一样。那咱们就来看一下这个具体的流程吧，咱们这里就以一个本地的压缩文件为例来展示一下，如何将一个本地的图片来label并且生成一个generator。&lt;/p&gt;
&lt;p&gt;第一步：解压文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; zipfile
local_zip &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\tangx\\OneDrive\\Desktop\\DATA\\cats_and_dogs_filtered.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
zip_ref &lt;/span&gt;= zipfile.ZipFile(local_zip,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
zip_ref.extractall(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\tangx\\OneDrive\\Desktop\\DATA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;where we extract our zip file to&lt;/span&gt;
zip_ref.close
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面将一个压缩的文件夹cats_and_dogs_filtered.zip解压到C:\\Users\\tangx\\OneDrive\\Desktop\\DATA这个文件夹中，并且解压后的文件名就是cats_and_dogs_filtered。&lt;/p&gt;
&lt;p&gt;第二步：define all subdirectories&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre readability=&quot;13&quot;&gt;
base_dir = &quot;C:\\Users\\tangx\\OneDrive\\Desktop\\DATA\\cats_and_dogs_filtered&quot;&lt;p&gt;train_dir = os.path.join(base_dir, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;train&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
val_dir &lt;/span&gt;= os.path.join(base_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;validation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

train_cats_dir &lt;/span&gt;= os.path.join(train_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cats&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
train_dogs_dir &lt;/span&gt;= os.path.join(train_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

val_cats_dir &lt;/span&gt;= os.path.join(val_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cats&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
val_dogs_dir &lt;/span&gt;= os.path.join(val_dir,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dogs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一步咱们定义了咱们所有图片的子文件夹，这些子文件夹中装着的正是咱们的图片。&lt;/p&gt;
&lt;p&gt;第三步：生成ImageDataGenerator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; tensorflow.keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;rescale&lt;/span&gt;
train_imagegen = ImageDataGenerator(rescale=1/255.0&lt;span&gt;)
val_imagegen &lt;/span&gt;= ImageDataGenerator(rescale=1/255.0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;flow image data&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
train_dir: which directory our image data are embeded in
batch_size:the number of images our image generator yields each time
target_size: our oringial images are various shape, so here we set all the image to a fixed size, wich is (150,150)
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;the labels will be based on the directories's name, wwhich is sorted alphanumeric; for example: cats:0; dogs:1&lt;/span&gt;
train_imagegen = train_imagegen.flow_from_directory(train_dir,batch_size=20,class_mode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,target_size=(150,150&lt;span&gt;))
val_imagegen &lt;/span&gt;= val_imagegen.flow_from_directory(val_dir,batch_size=20,class_mode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;binary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,target_size=(150,150))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里首先咱们实例化一个ImageDatagenerator并且对咱们后面要导入的照片进行一个rescale, 然后通过这个generator调用它的对象方法flow_from_directory()来给咱们的图片label并且生成咱们的最终的数据对generator。这里有几个参数需要了解一下，一个batch_size是指到时候在训练数据的时候每一个gradient选择多少个数据来计算， class_mode是指你的classification是什么类型，这里有这几种可能是 “binary”,“sparse”, &quot;categorical&quot;, &quot;input&quot;和None这几种情况，根据咱们的实际情况来选择。还有一个很重要的参数，那就是target_size, 这个参数能把咱们的图片全部转化成相同的大小，这给咱们后面创建神经网络的时候带来了极大的方便，在创建神经网络的时候咱们可以固定咱们input layer中node的数量了。还有一个很小的细节容易忽视，那就是imagegenerator给咱们图片label的时候是根据装咱们图片的文件夹的名称的字母顺序来得，例如cats，label是0；dogs， label是1。至此，咱们已经完成了所有的图片的准备工作的了，包括图片的label，图片的大小统一等工作。下面咱们就要来说说咱们在计算机视觉中应用的最广泛的一种网络结构了，那就是卷积网络CNN。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;卷积网络CNN&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于Convolutional Neuro Network (CNN), 咱们第一步得了解他的结构是什么样的，然后才能理解它的一些概念，例如：filter, pooling等概念。那么下面我自己花了一张简易的CNN的网络结构图，如果大家理解了下面的这个网络结构，那么大家肯定也就立即了CNN的一下概念，咱们直接看下面的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1287224/202002/1287224-20200205225854298-683231150.jpg&quot; alt=&quot;&quot; width=&quot;817&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的图片展示的就是一个含有一个convolution layer, 一个pooling layer的一个卷积网络。首先咱们的原始图片是一张28*28像素的图片，之后咱们让TensorFlow随机生成9个filter,每一个filter都是一个3*3结构的filter，这里就是咱们整个CNN的核心了。然后让每一个filter都去cover一下咱们的原始图片都会生成一个26*26的图片，所以咱们一共生成了9个26*26的图片；注意实际上这里每一个filter都是根据不同的角度来提取咱们原始图片的特征，这就是这些filter的本质。之后所有的这些经过过滤后的26*26size 的图片再经过一个Maxpooling（2*2）层来压缩咱们的26*26的图片，结果就是生成了9个13*13的图片。为了将这个数据加载在咱们后面的DNN中进行计算，很显然咱们还是得将这9个13*13的图片经过flatten操作后才能将它作为咱们的input layer。后面的步骤就跟咱们传统的DNN是一模一样的了。那么这里的核心就是filter的过程，它是用来提取不同角度的图片的特征的。如果上面的CNN的结构理解了，那么我们就接着上面的imagegenerator的例子，看看如何用TensorFlow来应用CNN吧。首先搭建CNN结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
model =&lt;span&gt; tf.keras.Sequential([
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Note the input shape is the desired size of the image 150x150 with 3 bytes color&lt;/span&gt;
    tf.keras.layers.Conv2D(32, (3,3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, input_shape=(150, 150, 3&lt;span&gt;)),
    tf.keras.layers.MaxPooling2D(&lt;/span&gt;2,2&lt;span&gt;),
    tf.keras.layers.Conv2D(&lt;/span&gt;16, (3,3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    tf.keras.layers.MaxPooling2D(&lt;/span&gt;2,2&lt;span&gt;), 
    tf.keras.layers.Conv2D(&lt;/span&gt;64, (3,3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
    tf.keras.layers.MaxPooling2D(&lt;/span&gt;2,2&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Flatten the results to feed into a DNN&lt;/span&gt;
&lt;span&gt;    tf.keras.layers.Flatten(), &lt;/span&gt;
    tf.keras.layers.Dense(1024, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
    tf.keras.layers.Dense(&lt;/span&gt;128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Only 1 output neuron. It will contain a value from 0-1 where 0 for 1 class ('cats') and 1 for the other ('dogs')&lt;/span&gt;
    tf.keras.layers.Dense(1, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
])
model.compile(
    optimizer &lt;/span&gt;= tf.optimizers.Adam(0.0001&lt;span&gt;),
    loss &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    metrics &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先咱们看出这个网络结构中，咱们构建了3个convolutional layers, 第一个卷积层的filter数量四32，第二个卷积层的filter数量是16，第三个卷积层数量是64。并且在第一个卷积层咱们声明了咱们每一个图片的size和dimension，例如咱们的图片是彩色的图片，长宽都是150，然后彩色图片有3个channel，所以咱们的input_shape=(150, 150, 3)。接下来就是咱们的training的过程了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
model.fit(train_imagegen, epochs=15, validation_data=val_imagegen, shuffle=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的fit函数咱们可以看出来，咱们就是直接传递的generator当做数据传递给它当做咱们的数据源了。至于后面的predict，evaluate等方式，跟前面章节讲的DNN的过程完全一样，这里我就不在赘述了。好了这就是CNN在计算机视觉中的应用。&lt;/p&gt;

</description>
<pubDate>Wed, 05 Feb 2020 15:30:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>概述 对于计算机视觉的应用现在是非常广泛的，但是它背后的原理其实非常简单，就是将每一个像素的值pixel输入到一个DNN中，然后让这个神经网络去学习这个模型，最后去应用这个模型就可以了。听起来是不是很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12267298.html</dc:identifier>
</item>
<item>
<title>线程池技术之：ThreadPoolExecutor 源码解析 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/12267274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/12267274.html</guid>
<description>&lt;p&gt;　　java中的所说的线程池，一般都是围绕着 ThreadPoolExecutor 来展开的。其他的实现基本都是基于它，或者模仿它的。所以只要理解 ThreadPoolExecutor, 就相当于完全理解了线程池的精髓。&lt;/p&gt;
&lt;p&gt;　　其实要理解一个东西，一般地，我们最好是要抱着自己的疑问或者理解去的。否则，往往收获甚微。&lt;/p&gt;

&lt;p&gt;　　理解 ThreadPoolExecutor, 我们可以先理解一个线程池的意义: 本质上是提供预先定义好的n个线程，供调用方直接运行任务的一个工具。&lt;/p&gt;

&lt;h3&gt;线程池解决的问题:&lt;/h3&gt;
&lt;p&gt;　　1. 提高任务执行的响应速度，降低资源消耗。任务执行时，直接立即使用线程池提供的线程运行，避免了临时创建线程的CPU/内存开销，达到快速响应的效果。&lt;/p&gt;
&lt;p&gt;　　2. 提高线程的可管理性。线程总数可预知，避免用户主动创建无限多线程导致死机风险，还可以进行线程统一的分配、调优和监控。&lt;/p&gt;
&lt;p&gt;　　3. 避免对资源的过度使用。在超出预期的请求任务情况，响应策略可控。&lt;/p&gt;

&lt;h3&gt;线程池提供的核心接口:&lt;/h3&gt;
&lt;p&gt;　　要想使用线程池，自然是要理解其接口的。一般我们使用 ExecotorService 进行线程池的调用。然而，我们并不针对初学者。&lt;/p&gt;
&lt;p&gt;　　整体的接口如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/830731/202002/830731-20200205230446936-476157631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　我们就挑几个常用接口探讨下：&lt;/p&gt;
&lt;p&gt;　　　　submit(Runnable task): 提交一个无需返回结果的任务。&lt;br/&gt;　　　　submit(Callable&amp;lt;T&amp;gt; task): 提交一个有返回结果的任务。&lt;br/&gt;　　　　invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long, TimeUnit): 同时执行n个任务并返回结果列表。&lt;br/&gt;　　　　shutdown(): 关闭线程程池。&lt;br/&gt;　　　　awaitTermination(long timeout, TimeUnit unit): 等待关闭结果，最长不超过timeout时间。&lt;/p&gt;

&lt;p&gt;以上是ThreadPoolExector 提供的特性，针对以上特性。&lt;/p&gt;
&lt;h3&gt;我们应该要有自己的几个实现思路或疑问:&lt;/h3&gt;
&lt;p&gt;　　1. 线程池如何接受任务？&lt;/p&gt;
&lt;p&gt;　　2. 线程如何运行任务？&lt;/p&gt;
&lt;p&gt;　　3. 线程池如何关闭？&lt;/p&gt;

&lt;p&gt;接下来，就让我们带着疑问去看实现吧。&lt;/p&gt;
&lt;h3&gt;ThreadPoolExecutor 核心实现原理&lt;/h3&gt;
&lt;h4&gt;1. 线程池的处理流程&lt;/h4&gt;
&lt;p&gt;　　我们首先重点要看的是，如何执行提交的任务。我可以通过下图来看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/830731/202002/830731-20200205230837459-830906457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　总结描述下就是:&lt;/p&gt;
&lt;p&gt;　　　　1. 判断核心线程池是否已满，如果不是，则创建线程执行任务&lt;br/&gt;　　　　2. 如果核心线程池满了，判断队列是否满了，如果队列没满，将任务放在队列中&lt;br/&gt;　　　　3. 如果队列满了，则判断线程池是否已满，如果没满，创建线程执行任务&lt;br/&gt;　　　　4. 如果线程池也满了，则按照拒绝策略对任务进行处理&lt;/p&gt;

&lt;p&gt;　　另外，我们来看一下 ThreadPoolExecutor 的构造方法，因为这里会体现出每个属性的含义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; allowCoreThreadTimeOut} is set
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; unit the time unit for the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; keepAliveTime} argument
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Runnable}
     *        tasks submitted by the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; execute} method.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; threadFactory the factory to use when the executor
     *        creates a new thread
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException if one of the following holds:&amp;lt;br&amp;gt;
     *         {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; corePoolSize &amp;lt; 0}&amp;lt;br&amp;gt;
     *         {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; keepAliveTime &amp;lt; 0}&amp;lt;br&amp;gt;
     *         {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; maximumPoolSize &amp;lt;= 0}&amp;lt;br&amp;gt;
     *         {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; maximumPoolSize &amp;lt; corePoolSize}
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; workQueue}
     *         or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; threadFactory} or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; handler} is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
            keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从构造方法可以看出 ThreadPoolExecutor 的主要参数 7 个，在其注释上也有说明功能，咱们翻译下每个参数的功能:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    corePoolSize: 线程池核心线程数（平时保留的线程数）,使用时机: 在初始时刻，每次请求进来都会创建一个线程直到达到该size
    maximumPoolSize: 线程池最大线程数,使用时机: 当workQueue都放不下时，启动新线程，直到最大线程数，此时到达线程池的极限
    keepAliveTime&lt;/span&gt;/&lt;span&gt;unit: 超出corePoolSize数量的线程的保留时间,unit为时间单位
    workQueue: 阻塞队列，当核心线程数达到或者超出后，会先尝试将任务放入该队列由各线程自行消费;  
        ArrayBlockingQueue: 构造函数一定要传大小
        LinkedBlockingQueue: 构造函数不传大小会默认为65536（Integer.MAX_VALUE ），当大量请求任务时，容易造成 内存耗尽。
        SynchronousQueue: 同步队列，一个没有存储空间的阻塞队列 ，将任务同步交付给工作线程。
        PriorityBlockingQueue: 优先队列
    threadFactory：线程工厂,用于线程需要创建时，调用其newThread()生产新线程使用
    handler: 饱和策略，当队列已放不下任务，且创建的线程已达到 maximum 后，则不能再处理任务，直接将任务交给饱和策略
        AbortPolicy: 直接抛弃（默认）
        CallerRunsPolicy: 用调用者的线程执行任务
        DiscardOldestPolicy: 抛弃队列中最久的任务
        DiscardPolicy: 抛弃当前任务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2. submit 流程详解&lt;/h4&gt;
&lt;p&gt;　　当调用 submit 方法，就是向线程池中提交一个任务，处理流程如步骤1所示。但是我们需要更深入理解。&lt;/p&gt;
&lt;p&gt;　　submit 方法是定义在 AbstractExecutorService 中，最终调用 ThreadPoolExecutor 的 execute 方法，即是模板方法模式的应用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable, T)&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; RejectedExecutionException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException       {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt;&lt;span&gt; submit(Runnable task, T result) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装任务和返回结果为 RunnableFuture, 统一交由具体的子类执行&lt;/span&gt;
        RunnableFuture&amp;lt;T&amp;gt; ftask =&lt;span&gt; newTaskFor(task, result);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; execute 将会调用 ThreadPoolExecutor 的实现，是我们讨论的重要核心&lt;/span&gt;
&lt;span&gt;        execute(ftask);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ftask;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FutureTask 是个重要的线程池组件，它承载了具体的任务执行流&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; RunnableFuture} for the given runnable and default
     * value.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; runnable the runnable task being wrapped
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value the default value for the returned future
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; the type of the given value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; RunnableFuture} which, when run, will run the
     * underlying runnable and which, as a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Future}, will yield
     * the given value as its result and provide for cancellation of
     * the underlying task
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt;&lt;span&gt; newTaskFor(Runnable runnable, T value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;T&amp;gt;&lt;span&gt;(runnable, value);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor 的任务提交过程
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor#execute&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler}.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; command the task to execute
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; RejectedExecutionException at discretion of
     *         {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; command} is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctl 是一个重要的控制全局状态的数据结构，定义为一个线程安全的 AtomicInteger
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctl = new AtomicInteger(ctlOf(RUNNING, 0));&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当还没有达到核心线程池的数量时，直接添加1个新线程，然后让其执行任务即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.1. 添加新线程，且执行command任务
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加成功，即不需要后续操作了，添加失败，则说明外部环境变化了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            c &lt;/span&gt;=&lt;span&gt; ctl.get();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当核心线程达到后，则尝试添加到阻塞队列中，具体添加方法由阻塞队列实现
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; isRunning =&amp;gt; c &amp;lt; SHUTDOWN;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2. 添加队列成功后，还要再次检测线程池的运行状态，决定启动线程或者状态过期
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2.1. 当线程池已关闭，则将刚刚添加的任务移除，走reject策略&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
                reject(command);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2.2. 当一个worker都没有时，则添加worker&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
                addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当队列满后，则直接再创建新的线程运行，如果不能再创建线程了，则 reject&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.3. 拒绝策略处理&lt;/span&gt;
&lt;span&gt;            reject(command);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上面这一小段代码，我们就已经完整地看到了。通过一个 ctl 变量进行全局状态控制，从而保证了线程安全性。整个框架并没有使用锁，但是却是线程安全的。&lt;/p&gt;
&lt;p&gt;　　整段代码刚好完整描述了线程池的执行流程:&lt;/p&gt;
&lt;p&gt;　　　　1. 判断核心线程池是否已满，如果不是，则创建线程执行任务;&lt;br/&gt;　　　　2. 如果核心线程池满了，判断队列是否满了，如果队列没满，将任务放在队列中;&lt;br/&gt;　　　　3. 如果队列满了，则判断线程池是否已满，如果没满，创建线程执行任务;&lt;br/&gt;　　　　4. 如果线程池也满了，则按照拒绝策略对任务进行处理;&lt;/p&gt;

&lt;p&gt;2.1. 添加新的worker&lt;/p&gt;
&lt;p&gt;　　一个worker，即是一个工作线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Checks if a new worker can be added with respect to current
     * pool state and the given bound (either core or maximum). If so,
     * the worker count is adjusted accordingly, and, if possible, a
     * new worker is created and started, running firstTask as its
     * first task. This method returns false if the pool is stopped or
     * eligible to shut down. It also returns false if the thread
     * factory fails to create a thread when asked.  If the thread
     * creation fails, either due to the thread factory returning
     * null, or due to an exception (typically OutOfMemoryError in
     * Thread.start()), we roll back cleanly.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; firstTask the task the new thread should run first (or
     * null if none). Workers are created with an initial first task
     * (in method execute()) to bypass queuing when there are fewer
     * than corePoolSize threads (in which case we always start one),
     * or when the queue is full (in which case we must bypass queue).
     * Initially idle threads are usually created via
     * prestartCoreThread or to replace other dying workers.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; core if true use corePoolSize as bound, else
     * maximumPoolSize. (A boolean indicator is used here rather than a
     * value to ensure reads of fresh values after checking other pool
     * state).
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true if successful
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为确保线程安全，进行CAS反复重试&lt;/span&gt;
&lt;span&gt;        retry:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取runState , c 的高位存储
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; c &amp;amp; ~CAPACITY;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经shutdown, firstTask 为空的添加并不会成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                   firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                   !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果超出最大允许创建的线程数，则直接失败&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                    wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS 更新worker+1数，成功则说明占位成功退出retry，后续的添加操作将是安全的，失败则说明已有其他线程变更该值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
                c &lt;/span&gt;= ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runState 变更，则退出到 retry 重新循环 &lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下为添加 worker 过程&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        Worker w &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 Worker 封闭 firstTask 任务，后续运行将由 Worker 接管&lt;/span&gt;
            w = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加 worker 的过程，需要保证线程安全&lt;/span&gt;
&lt;span&gt;                mainLock.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SHUTDOWN 情况下还是会创建 Worker, 但是后续检测将会失败&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                        (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 既然是新添加的线程，就不应该是 alive 状态&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; workers 只是一个工作线程的容器，使用 HashSet 承载
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();&lt;/span&gt;
&lt;span&gt;                        workers.add(w);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 维护一个全局达到过的最大线程数计数器&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                            largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                        workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mainLock.unlock();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; worker 添加成功后，进行将worker启起来，里面应该是有一个 死循环，一直在获取任务
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不然怎么运行添加到队列里的任务呢？&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                    t.start();
                    workerStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果任务启动失败，则必须进行清理，返回失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
                addWorkerFailed(w);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大概添加 worker 的框架明白了，重点对象是 Worker, 我们稍后再讲
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现在先来看看，添加失败的情况，如何进行&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Rolls back the worker thread creation.
     * - removes worker from workers, if present
     * - decrements worker count
     * - rechecks for termination, in case the existence of this
     *   worker was holding up termination
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addWorkerFailed(Worker w) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (w != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                workers.remove(w);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctl 中的 workerCount - 1 , CAS 实现&lt;/span&gt;
&lt;span&gt;            decrementWorkerCount();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试处理空闲线程&lt;/span&gt;
&lt;span&gt;            tryTerminate();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Decrements the workerCount field of ctl. This is called only on
     * abrupt termination of a thread (see processWorkerExit). Other
     * decrements are performed within getTask.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; decrementWorkerCount() {
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; {} &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt; compareAndDecrementWorkerCount(ctl.get()));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止可能启动的 worker&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Transitions to TERMINATED state if either (SHUTDOWN and pool
     * and queue empty) or (STOP and pool empty).  If otherwise
     * eligible to terminate but workerCount is nonzero, interrupts an
     * idle worker to ensure that shutdown signals propagate. This
     * method must be called following any action that might make
     * termination possible -- reducing worker count or removing tasks
     * from the queue during shutdown. The method is non-private to
     * allow access from ScheduledThreadPoolExecutor.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; tryTerminate() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池正在运行、正在清理、已关闭但队列还未处理完，都不会进行 terminate 操作&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (isRunning(c) ||
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; c &amp;gt;= TIDYING&lt;/span&gt;
                runStateAtLeast(c, TIDYING) ||&lt;span&gt;
                (runStateOf(c) &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) != 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eligible to terminate
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止线程的两个方式之一，只中断一个 worker&lt;/span&gt;
&lt;span&gt;                interruptIdleWorkers(ONLY_ONE);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下为整个线程池的后置操作&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
            mainLock.lock();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置正在清理标识&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (ctl.compareAndSet(c, ctlOf(TIDYING, 0&lt;span&gt;))) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池已终止的钩子方法，默认实现为空&lt;/span&gt;
&lt;span&gt;                        terminated();
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        ctl.set(ctlOf(TERMINATED, &lt;/span&gt;0&lt;span&gt;));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处 termination 为唤醒等待关闭的线程&lt;/span&gt;
&lt;span&gt;                        termination.signalAll();
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                mainLock.unlock();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry on failed CAS&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Interrupts threads that might be waiting for tasks (as
     * indicated by not being locked) so they can check for
     * termination or configuration changes. Ignores
     * SecurityExceptions (in which case some threads may remain
     * uninterrupted).
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; onlyOne If true, interrupt at most one worker. This is
     * called only from tryTerminate when termination is otherwise
     * enabled but there are still other workers.  In this case, at
     * most one waiting worker is interrupted to propagate shutdown
     * signals in case all threads are currently waiting.
     * Interrupting any arbitrary thread ensures that newly arriving
     * workers since shutdown began will also eventually exit.
     * To guarantee eventual termination, it suffices to always
     * interrupt only one idle worker, but shutdown() interrupts all
     * idle workers so that redundant workers exit promptly, not
     * waiting for a straggler task to finish.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; interruptIdleWorkers(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyOne) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代所有 worker&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers) {
                Thread t &lt;/span&gt;=&lt;span&gt; w.thread;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到 worker 的锁之后，再进行 interrupt&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp;&lt;span&gt; w.tryLock()) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        t.interrupt();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        w.unlock();
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只中断一个 worker, 立即返回, 不保证 interrupt 成功&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (onlyOne)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.2. 当添加队列成功后，发现线程池状态变更，需要进行移除队列操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Removes this task from the executor's internal queue if it is
     * present, thus causing it not to be run if it has not already
     * started.
     *
     * &amp;lt;p&amp;gt;This method may be useful as one part of a cancellation
     * scheme.  It may fail to remove tasks that have been converted
     * into other forms before being placed on the internal queue. For
     * example, a task entered using {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; submit} might be
     * converted into a form that maintains {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Future} status.
     * However, in such cases, method {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #purge} may be used to
     * remove those Futures that have been cancelled.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; task the task to remove
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if the task was removed
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Runnable task) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此移除不一定能成功&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; removed =&lt;span&gt; workQueue.remove(task);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上面已经看过，它会尝试停止一个 worker 线程&lt;/span&gt;
        tryTerminate(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; In case SHUTDOWN and now empty&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; removed;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3. 添加失败进行执行拒绝策略&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Invokes the rejected execution handler for the given command.
     * Package-protected for use by ScheduledThreadPoolExecutor.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reject(Runnable command) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝策略是在构造方法时传入的，默认为 RejectedExecutionHandler
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即用户只需实现 rejectedExecution 方法，即可以自定义拒绝策略了&lt;/span&gt;
        handler.rejectedExecution(command, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4. Worker 的工作机制&lt;/h4&gt;
&lt;p&gt;　　从上面的实现中，我们可以看到，主要是对 Worker 的添加和 workQueue 的添加，所以具体的工作是由谁完成呢？自然就是 Worker 了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Worker 的构造方法，主要是接受一个 task, 可以为 null, 如果非null, 将在不久的将来被执行
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; private final class Worker extends AbstractQueuedSynchronizer implements Runnable&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Creates with given first task and thread from ThreadFactory.
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; firstTask the first task (null if none)
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Worker(Runnable firstTask) {
            setState(&lt;/span&gt;-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; inhibit interrupts until runWorker&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.firstTask =&lt;span&gt; firstTask;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 Worker 自身当作一个 任务，绑定到 worker.thread 中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thread 启动时，worker 就启动了&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Worker 的主要工作实现，通过一个循环扫描实现        &lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Delegates main run loop to outer runWorker  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 ThreadPoolExecutor 外部实现的 runWorker 方法&lt;/span&gt;
            runWorker(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Main worker run loop.  Repeatedly gets tasks from queue and
     * executes them, while coping with a number of issues:
     *
     * 1. We may start out with an initial task, in which case we
     * don't need to get the first one. Otherwise, as long as pool is
     * running, we get tasks from getTask. If it returns null then the
     * worker exits due to changed pool state or configuration
     * parameters.  Other exits result from exception throws in
     * external code, in which case completedAbruptly holds, which
     * usually leads processWorkerExit to replace this thread.
     *
     * 2. Before running any task, the lock is acquired to prevent
     * other pool interrupts while the task is executing, and then we
     * ensure that unless pool is stopping, this thread does not have
     * its interrupt set.
     *
     * 3. Each task run is preceded by a call to beforeExecute, which
     * might throw an exception, in which case we cause thread to die
     * (breaking loop with completedAbruptly true) without processing
     * the task.
     *
     * 4. Assuming beforeExecute completes normally, we run the task,
     * gathering any of its thrown exceptions to send to afterExecute.
     * We separately handle RuntimeException, Error (both of which the
     * specs guarantee that we trap) and arbitrary Throwables.
     * Because we cannot rethrow Throwables within Runnable.run, we
     * wrap them within Errors on the way out (to the thread's
     * UncaughtExceptionHandler).  Any thrown exception also
     * conservatively causes thread to die.
     *
     * 5. After task.run completes, we call afterExecute, which may
     * also throw an exception, which will also cause thread to
     * die. According to JLS Sec 14.20, this exception is the one that
     * will be in effect even if task.run throws.
     *
     * The net effect of the exception mechanics is that afterExecute
     * and the thread's UncaughtExceptionHandler have as accurate
     * information as we can provide about any problems encountered by
     * user code.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; w the worker
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runWorker(Worker w) {
        Thread wt &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        Runnable task &lt;/span&gt;=&lt;span&gt; w.firstTask;
        w.firstTask &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        w.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allow interrupts&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不停地从 workQueue 中获取任务，然后执行，就是这么个逻辑
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getTask() 会阻塞式获取，所以 Worker 往往不会立即退出 &lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行过程中是不允许并发的，即同时只能一个 task 在运行，此时也不允许进行 interrupt&lt;/span&gt;
&lt;span&gt;                w.lock();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If pool is stopping, ensure thread is interrupted;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if not, ensure thread is not interrupted.  This
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; requires a recheck in second case to deal with
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shutdownNow race while clearing interrupt
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测是否已被线程池是否停止 或者当前 worker 被中断
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STOP = 1 &amp;lt;&amp;lt; COUNT_BITS;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((runStateAtLeast(ctl.get(), STOP) ||&lt;span&gt;
                     (Thread.interrupted() &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                      runStateAtLeast(ctl.get(), STOP))) &lt;/span&gt;&amp;amp;&amp;amp;
                    !&lt;span&gt;wt.isInterrupted())
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中断信息传递&lt;/span&gt;
&lt;span&gt;                    wt.interrupt();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务开始前 切点，默认为空执行&lt;/span&gt;
&lt;span&gt;                    beforeExecute(wt, task);
                    Throwable thrown &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用任务的run方法， 具体的返回结果，会被 FutureTask 封装到 某个变量中
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以参考以前的文章 （FutureTask是怎样获取到异步执行结果的？ &lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/yougewe/p/11666284.html&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;
&lt;span&gt;                        task.run();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Error x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(x);
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务开始后 切点，默认为空执行&lt;/span&gt;
&lt;span&gt;                        afterExecute(task, thrown);
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    task &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    w.completedTasks&lt;/span&gt;++&lt;span&gt;;
                    w.unlock();
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正常退出，有必要的话，可能重新将 Worker 添加进来&lt;/span&gt;
            completedAbruptly = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理退出后下一步操作，可能重新添加 Worker&lt;/span&gt;
&lt;span&gt;            processWorkerExit(w, completedAbruptly);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Performs cleanup and bookkeeping for a dying worker. Called
     * only from worker threads. Unless completedAbruptly is set,
     * assumes that workerCount has already been adjusted to account
     * for exit.  This method removes thread from worker set, and
     * possibly terminates the pool or replaces the worker if either
     * it exited due to user task exception or if fewer than
     * corePoolSize workers are running or queue is non-empty but
     * there are no workers.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; w the worker
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; completedAbruptly if the worker died due to user exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processWorkerExit(Worker w, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; completedAbruptly) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (completedAbruptly) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If abrupt, then workerCount wasn't adjusted&lt;/span&gt;
&lt;span&gt;            decrementWorkerCount();

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            completedTaskCount &lt;/span&gt;+=&lt;span&gt; w.completedTasks;
            workers.remove(w);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }

        tryTerminate();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (runStateLessThan(c, STOP)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 Worker 正常退出的情况下，检查是否超时导致，维持最小线程数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;completedAbruptly) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; min = allowCoreThreadTimeOut ? 0&lt;span&gt; : corePoolSize;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (min == 0 &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty())
                    min &lt;/span&gt;= 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果满足最小线程要求，则直接返回&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;gt;=&lt;span&gt; min)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replacement not needed&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则再添加一个Worker到线程池中备用
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非正常退出，会直接再添加一个Worker&lt;/span&gt;
            addWorker(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Performs blocking or timed wait for a task, depending on
     * current configuration settings, or returns null if this worker
     * must exit because of any of:
     * 1. There are more than maximumPoolSize workers (due to
     *    a call to setMaximumPoolSize).
     * 2. The pool is stopped.
     * 3. The pool is shutdown and the queue is empty.
     * 4. This worker timed out waiting for a task, and timed-out
     *    workers are subject to termination (that is,
     *    {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; allowCoreThreadTimeOut || workerCount &amp;gt; corePoolSize})
     *    both before and after the timed wait, and if the queue is
     *    non-empty, this worker is not the last thread in the pool.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; task, or null if the worker must exit, in which case
     *         workerCount is decremented
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getTask() {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; timedOut = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did the last poll() time out?&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果进行了 shutdown, 且队列为空, 则需要将 worker 退出&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP ||&lt;span&gt; workQueue.isEmpty())) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do {} while (! compareAndDecrementWorkerCount(ctl.get()));&lt;/span&gt;
&lt;span&gt;                decrementWorkerCount();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Are workers subject to culling?&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt;&lt;span&gt; corePoolSize;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程数据大于最大允许线程，需要删除多余的 Worker&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp;&lt;span&gt; timedOut))
                &lt;/span&gt;&amp;amp;&amp;amp; (wc &amp;gt; 1 ||&lt;span&gt; workQueue.isEmpty())) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndDecrementWorkerCount(c))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果开户了超时删除功能，则使用 poll, 否则使用 take() 进行阻塞获取&lt;/span&gt;
                Runnable r = timed ?&lt;span&gt;
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到任务，则可以进行执行了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有超时设置，则会在下一循环时退出&lt;/span&gt;
                timedOut = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忽略中断异常
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这种情况下，Worker如何响应外部的中断请求呢？？？ 思考&lt;/span&gt;
            &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException retry) {
                timedOut &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以，Worker的作用就体现出来了,一个循环取任务执行任务过程：&lt;/p&gt;
&lt;p&gt;　　　　1. 有一个主循环一直进行任务的获取;&lt;br/&gt;　　　　2. 针对有超时的设置，会使用poll进行获取任务，如果超时，则 Worker 将会退出循环结束线程;&lt;br/&gt;　　　　3. 无超时的设置，则会使用 take 进行阻塞式获取，直到有值;&lt;br/&gt;　　　　4. 获取任务执行前置+业务+后置任务;&lt;br/&gt;　　　　5. 当获取到null的任务之后，当前Worker将会结束；&lt;br/&gt;　　　　6. 当前Worker结束后，将会判断是否有必要维护最低Worker数，从而决定是否再添加Worker进来。&lt;/p&gt;
&lt;p&gt;　　还是借用一个网上同学比较通用的一个图来表述下 Worker/ThreadPoolExecutor 的工作流程吧（已经很完美，不需要再造这轮子了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/830731/202002/830731-20200205231805428-282140642.png&quot; alt=&quot;&quot; width=&quot;713&quot; height=&quot;642&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;5. shutdown 操作实现&lt;/h4&gt;
&lt;p&gt;　　ThreadPoolExecutor 是通过 ctl 这个变量进行全局状态维护的，shutdown 在线程池中也是表现为一个状态，所以应该是比较简单的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * &amp;lt;p&amp;gt;This method does not wait for previously submitted tasks to
     * complete execution.  Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #awaitTermination awaitTermination}
     * to do that.
     *
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为保证线程安全，使用 mainLock&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SecurityManager 检查&lt;/span&gt;
&lt;span&gt;            checkShutdownAccess();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置状态为 SHUTDOWN&lt;/span&gt;
&lt;span&gt;            advanceRunState(SHUTDOWN);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中断空闲的 Worker, 即相当于依次关闭每个空闲线程&lt;/span&gt;
&lt;span&gt;            interruptIdleWorkers();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭钩子，默认实现为空操作，为方便子类实现自定义清理功能&lt;/span&gt;
            onShutdown(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hook for ScheduledThreadPoolExecutor&lt;/span&gt;
        } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再&lt;/span&gt;
&lt;span&gt;        tryTerminate();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Transitions runState to given target, or leaves it alone if
     * already at least the given target.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetState the desired state, either SHUTDOWN or STOP
     *        (but not TIDYING or TERMINATED -- use tryTerminate for that)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; advanceRunState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; targetState) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自身CAS更新成功或者被其他线程更新成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (runStateAtLeast(c, targetState) ||&lt;span&gt;
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭空闲线程（非 running 状态）&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Common form of interruptIdleWorkers, to avoid having to
     * remember what the boolean argument means.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIdleWorkers() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上文已介绍， 此处 ONLY_ONE 为 false, 即是最大可能地中断所有 Worker&lt;/span&gt;
        interruptIdleWorkers(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    
    与 shutdown 对应的，有一个 shutdownNow, 其语义是 立即停止所有任务。
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution. These tasks are drained (removed)
     * from the task queue upon return from this method.
     *
     * &amp;lt;p&amp;gt;This method does not wait for actively executing tasks to
     * terminate.  Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #awaitTermination awaitTermination} to
     * do that.
     *
     * &amp;lt;p&amp;gt;There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  This implementation
     * cancels tasks via {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Thread#interrupt}, so any task that
     * fails to respond to interrupts may never terminate.
     *
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Runnable&amp;gt;&lt;span&gt; shutdownNow() {
        List&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; tasks;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            checkShutdownAccess();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与 shutdown 的差别，设置的状态不一样&lt;/span&gt;
&lt;span&gt;            advanceRunState(STOP);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强行中断线程&lt;/span&gt;
&lt;span&gt;            interruptWorkers();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将未完成的任务返回&lt;/span&gt;
            tasks =&lt;span&gt; drainQueue();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
        tryTerminate();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tasks;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Interrupts all threads, even if active. Ignores SecurityExceptions
     * (in which case some threads may remain uninterrupted).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptWorkers() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 worker 的提供的中断方法&lt;/span&gt;
&lt;span&gt;                w.interruptIfStarted();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.Worker#interruptIfStarted&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIfStarted() {
            Thread t;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;t.isInterrupted()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用任务的 interrupt&lt;/span&gt;
&lt;span&gt;                    t.interrupt();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;6. invokeAll 的实现方式&lt;/h4&gt;
&lt;p&gt;　　invokeAll, 望文生义，即是调用所有给定的任务。想来应该是一个个地添加任务到线程池队列吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; invokeAll 的方法直接在抽象方便中就实现了，它的语义是同时执行n个任务，并同步等待结果返回
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.util.concurrent.AbstractExecutorService#invokeAll(java.util.Collection&amp;lt;? extends java.util.concurrent.Callable&amp;lt;T&amp;gt;&amp;gt;)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; tasks)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tasks == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        ArrayList&lt;/span&gt;&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;(tasks.size());
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Callable&amp;lt;T&amp;gt;&lt;span&gt; t : tasks) {
                RunnableFuture&lt;/span&gt;&amp;lt;T&amp;gt; f =&lt;span&gt; newTaskFor(t);
                futures.add(f);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次调用各子类的实现，添加任务&lt;/span&gt;
&lt;span&gt;                execute(f);
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, size = futures.size(); i &amp;lt; size; i++&lt;span&gt;) {
                Future&lt;/span&gt;&amp;lt;T&amp;gt; f =&lt;span&gt; futures.get(i);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;f.isDone()) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次等待执行结果&lt;/span&gt;
&lt;span&gt;                        f.get();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancellationException ignore) {
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException ignore) {
                    }
                }
            }
            done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; futures;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;done)
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, size = futures.size(); i &amp;lt; size; i++&lt;span&gt;)
                    futures.get(i).cancel(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现很简单，都是些外围调用。&lt;/p&gt;

&lt;h4&gt;7. ThreadPoolExecutor 的状态值的设计&lt;/h4&gt;
&lt;p&gt;　　通过上面的过程，可以看到，整个ThreadPoolExecutor 非状态的依赖是非常强的。所以一个好的状态值的设计就显得很重要了，runState 代表线程池或者 Worker 的运行状态。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; runState is stored in the high-order bits
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整个状态使值使用 ctl 的高三位值进行控制， COUNT_BITS=29
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1110 0000 0000 0000&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0000 0000 0000 0000&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0010 0000 0000 0000&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0100 0000 0000 0000&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0110 0000 0000 0000&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整个状态值的大小顺序主: RUNNING &amp;lt; SHUTDOWN &amp;lt; STOP &amp;lt; TIDYING &amp;lt; TERMINATED
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而低 29位，则用来保存 worker 的数量，当worker增加时，只要将整个 ctl 增加即可。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0001 1111 1111 1111, 即是最大的 worker 数量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整个 ctl 描述为一个 AtomicInteger, 功能如下:&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The main pool control state, ctl, is an atomic integer packing
     * two conceptual fields
     *   workerCount, indicating the effective number of threads
     *   runState,    indicating whether running, shutting down etc
     *
     * In order to pack them into one int, we limit workerCount to
     * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2
     * billion) otherwise representable. If this is ever an issue in
     * the future, the variable can be changed to be an AtomicLong,
     * and the shift/mask constants below adjusted. But until the need
     * arises, this code is a bit faster and simpler using an int.
     *
     * The workerCount is the number of workers that have been
     * permitted to start and not permitted to stop.  The value may be
     * transiently different from the actual number of live threads,
     * for example when a ThreadFactory fails to create a thread when
     * asked, and when exiting threads are still performing
     * bookkeeping before terminating. The user-visible pool size is
     * reported as the current size of the workers set.
     *
     * The runState provides the main lifecycle control, taking on values:
     *
     *   RUNNING:  Accept new tasks and process queued tasks
     *   SHUTDOWN: Don't accept new tasks, but process queued tasks
     *   STOP:     Don't accept new tasks, don't process queued tasks,
     *             and interrupt in-progress tasks
     *   TIDYING:  All tasks have terminated, workerCount is zero,
     *             the thread transitioning to state TIDYING
     *             will run the terminated() hook method
     *   TERMINATED: terminated() has completed
     *
     * The numerical order among these values matters, to allow
     * ordered comparisons. The runState monotonically increases over
     * time, but need not hit each state. The transitions are:
     *
     * RUNNING -&amp;gt; SHUTDOWN
     *    On invocation of shutdown(), perhaps implicitly in finalize()
     * (RUNNING or SHUTDOWN) -&amp;gt; STOP
     *    On invocation of shutdownNow()
     * SHUTDOWN -&amp;gt; TIDYING
     *    When both queue and pool are empty
     * STOP -&amp;gt; TIDYING
     *    When pool is empty
     * TIDYING -&amp;gt; TERMINATED
     *    When the terminated() hook method has completed
     *
     * Threads waiting in awaitTermination() will return when the
     * state reaches TERMINATED.
     *
     * Detecting the transition from SHUTDOWN to TIDYING is less
     * straightforward than you'd like because the queue may become
     * empty after non-empty and vice versa during SHUTDOWN state, but
     * we can only terminate if, after seeing that it is empty, we see
     * that workerCount is 0 (which sometimes entails a recheck -- see
     * below).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0));
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;8. awaitTermination 等待关闭完成&lt;/h4&gt;
&lt;p&gt;　　从上面的 shutdown, 可以看到，只是写了 SHUTDOWN 标识后，尝试尽可能地中断停止Worker线程，但并不保证中断成功。要想保证停止完成，需要有另外的机制来保证。从 awaitTermination 的语义来说，它是能保证任务停止完成的，那么它是如何保证的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.awaitTermination()&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; awaitTermination(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nanos =&lt;span&gt; unit.toNanos(timeout);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只是循环 ctl 状态, 只要 状态为 TERMINATED 状态，则说明已经关闭成功
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处 termination 的状态触发是在 tryTerminate 中触发的&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (runStateAtLeast(ctl.get(), TERMINATED))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                nanos &lt;/span&gt;=&lt;span&gt; termination.awaitNanos(nanos);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看起来, awaitTermination 并没有什么特殊操作，而是一直在等待。所以 TERMINATED 是 Worker 自行发生的动作。&lt;/p&gt;
&lt;p&gt;　　那是在哪里做的操作呢？其实是在获取任务的时候，会检测当前状态是否是 SHUTDOWN, 如果是SHUTDOWN且 队列为空，则会触发获取任务的返回null.从而结束当前 Worker. &lt;/p&gt;
&lt;p&gt;　　Worker 在结束前会调用 processWorkerExit() 方法，里面会再次调用 tryTerminate(), 当所有 Worker 都运行到这个点后， awaitTermination() 就会收到通知了。（注意: processWorkerExit() 会在每次运行后进行 addWorker() 尝试，但是在 SHUTDOWN 状态的添加操作总是失败的，所以不用考虑）&lt;/p&gt;

&lt;p&gt;　　到此，你是否可以解答前面的几个问题了呢？&lt;/p&gt;


</description>
<pubDate>Wed, 05 Feb 2020 15:25:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>java中的所说的线程池，一般都是围绕着 ThreadPoolExecutor 来展开的。其他的实现基本都是基于它，或者模仿它的。所以只要理解 ThreadPoolExecutor, 就相当于完全理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/12267274.html</dc:identifier>
</item>
<item>
<title>五彩斑斓的黑 - Licsber</title>
<link>http://www.cnblogs.com/licsber/p/colorful-black.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/licsber/p/colorful-black.html</guid>
<description>&lt;h2 id=&quot;项目背景&quot;&gt;项目背景&lt;/h2&gt;
&lt;p&gt;由于众所周知的原因（&lt;code&gt;武汉2020&lt;/code&gt;），只能在家整东西玩，想起了以前和同学聊天提到的&lt;code&gt;五彩斑斓的黑&lt;/code&gt;，遂来了灵感，造出来这么一个轮子。&lt;/p&gt;
&lt;h2 id=&quot;项目效果图&quot;&gt;项目效果图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231311731-1891686149.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目简介&quot;&gt;项目简介&lt;/h2&gt;
&lt;p&gt;五彩斑斓的黑，可以把黑白的论文变成五彩斑斓，这样看论文的时候就不无聊了（误&lt;/p&gt;
&lt;p&gt;实现了pdf转化为&lt;code&gt;五颜六色&lt;/code&gt;的pdf，其实对于其他类型图片的处理也是一样的&lt;/p&gt;
&lt;h2 id=&quot;项目开源地址&quot;&gt;项目开源地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Licsber/Colorful-Black&quot;&gt;我的github&lt;/a&gt;，求路过的朋友点个star吧，提PR那是更好的！&lt;/p&gt;
&lt;h2 id=&quot;项目依赖&quot;&gt;项目依赖&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;必备：opencv 图像处理的基础库&lt;/li&gt;
&lt;li&gt;必备：wand 是imagemagick的前端&lt;/li&gt;
&lt;li&gt;必备：imagemagick 基础库&lt;/li&gt;
&lt;li&gt;选配：flask 用于搭建一个服务器在线批量转换&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;算法介绍&quot;&gt;算法介绍&lt;/h2&gt;
&lt;h3 id=&quot;读取pdf&quot;&gt;读取pdf&lt;/h3&gt;
&lt;p&gt;借助wand可以实现pdf转换为jpg图片形式，这样方便使用opencv处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parse_pdf(filepath, resolution=300):
    pdf = wi(filename=filepath, resolution=resolution)
    pdf = pdf.convert(&quot;jpeg&quot;)
    return pdf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换完毕的pdf批量保存为文件，因为没有找到wand与opencv的联通格式，所以采用文件作保存处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def save_pdf_as_img(pdf, filename):
    page_count = 1
    for img in pdf.sequence:
        page = wi(image=img)
        page.save(filename=filename + str(page_count) + '.jpg')
        page_count += 1
    return page_count&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成彩色图像&quot;&gt;生成彩色图像&lt;/h3&gt;
&lt;p&gt;这里偷了个懒，利用等差数列乘以一个等比数列，采用opencv的热力图applyColorMap()方法变为彩色，再横竖相加获取随机但仍有一定规律的彩虹图像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@memoize
def get_color_img(width, height):
    w = np.logspace(0, 255, height, base=1.01, dtype=np.uint8)
    w = np.reshape(w, (-1, 1))
    h = np.linspace(0, 255, width, dtype=np.uint8)
    h = np.reshape(h, (1, -1))
    shu = w * h
    shu = np.reshape(shu, (height, -1))
    shu = cv2.cvtColor(shu, cv2.COLOR_GRAY2BGR)
    shu = cv2.applyColorMap(shu, cv2.COLORMAP_HSV)

    w = np.linspace(0, 255, height, dtype=np.uint8)
    w = np.reshape(w, (-1, 1))
    h = np.logspace(0, 255, width, base=1.01, dtype=np.uint8)
    h = np.reshape(h, (1, -1))
    heng = w * h
    heng = np.reshape(heng, (height, -1))
    heng = cv2.cvtColor(heng, cv2.COLOR_GRAY2BGR)
    heng = cv2.applyColorMap(heng, cv2.COLORMAP_HSV)

    img = heng + shu

    img = cv2.medianBlur(img, 101)
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231452791-1512719541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231546800-1100642836.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231709897-2035612081.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，使用权重比较大的中值滤波很好的平滑了图像。&lt;/p&gt;
&lt;p&gt;因为替换模版的不变性，所以我们利用python的装饰器在内存中保存这个图像，具体可能我会写一篇关于python高级特性：装饰器的文章，不过还是有可能咕咕咕了，这里就把装饰器理解为一个参数是函数的函数就好了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def memoize(func):
    cache = dict()

    def memoized_func(*args):
        if args in cache:
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result

    return memoized_func&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;图像的混合&quot;&gt;图像的混合&lt;/h3&gt;
&lt;p&gt;利用&lt;code&gt;蒙版（mask）&lt;/code&gt;技术，可以完美的实现黑色文字的替换，或者可以自行更改这个要替换的颜色，或者颜色范围，以实现更花里胡哨的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def mix_img(file_dir, filename, count):
    path = os.path.join(file_dir, filename)
    for i in range(1, count):
        img = cv2.imread(path + str(i) + '.jpg')
        color = get_color_img(img.shape[1], img.shape[0])
        mask = (img == (0, 0, 0))[:, :, 0]
        img[mask] = color[mask]
        mix = img
        cv2.imwrite(path + str(i) + '.jpg', mix)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pdf的生成&quot;&gt;pdf的生成&lt;/h3&gt;
&lt;p&gt;混合完的图像还是利用wand复原为pdf文件，生成的pdf可能会比较大，因为变成了纯图像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def save_img_as_pdf(file_dir, filename, count, output_dir, output_filename):
    path = os.path.join(file_dir, filename)
    output_path = os.path.join(output_dir, output_filename)
    with wi() as w:
        for i in range(1, count):
            with wi(filename=path + str(i) + '.jpg') as page:
                w.sequence.append(page)
        w.save(filename=output_path)
    return output_path&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231754432-607854337.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络端接受上传&quot;&gt;网络端接受上传&lt;/h3&gt;
&lt;p&gt;首先让我们5秒写个网页来接受用户pdf文件的输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;五彩斑斓的黑 - Licsber&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&amp;gt;
    &amp;lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body class=&quot;container&quot;&amp;gt;
&amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h3 id=&quot;header&quot;&amp;gt;{{message}}&amp;lt;/h3&amp;gt;
    &amp;lt;h2&amp;gt;欢迎试用一键五彩斑斓的黑，支持上传pdf。&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;创意By Licsber、Mikewang000000。&amp;lt;/h2&amp;gt;
    &amp;lt;form id=&quot;form1&quot; method=&quot;post&quot; action=&quot;/api/upload&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;input id=&quot;File1&quot; type=&quot;file&quot; name=&quot;myfile&quot; class=&quot;btn btn-default btn-lg&quot;&amp;gt;
            &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-info btn-lg&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    var heading = $(&quot;#header&quot;)[0];
    setInterval(function () {
        if (heading.style.display == &quot;block&quot;) {
            heading.style.display = &quot;none&quot;;
        } else if (heading.style.display == &quot;none&quot;) {
            heading.style.display = &quot;block&quot;;
        }
    }, 1000);
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007765/202002/1007765-20200205231818228-1698955601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闪烁部分是后来写的，主要网页表单部分真的只写了五秒。&lt;/p&gt;
&lt;p&gt;serve一下主页：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@app.route('/')
def upload_test():
    message = ''
    return render_template(UPLOAD_HTML, message=message)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后写一个flask的函数来接收文件并保存，这个函数，嘿嘿，发现了什么东西没，不管符不符合都先保存再说，方便日志记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@app.route('/api/upload', methods=['POST'], strict_slashes=False)
def api_upload():
    f = request.files['myfile']
    if f:
        old_name = f.filename
        ext = old_name.rsplit('.', 1)[1]
        unix_time = int(time.time())
        new_filename = old_name + str(unix_time) + '.' + ext
        print(new_filename)
        path = os.path.join(file_dir, new_filename)
        f.save(path)
    else:
        message = '你没上传文件哦'
        return render_template(UPLOAD_HTML, message=message)
    if f and allowed_file(f.filename):
        pdf = entity.Pdf(file_dir, new_filename, OUTPUT_PATH)
        return downloader(pdf.get_output_filename())
    else:
        message = '文件类型不支持哦 重新上传试试呢'
        return render_template(UPLOAD_HTML, message=message)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载文件就简单了，flask自带这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@app.route(&quot;/download/&amp;lt;path:filename&amp;gt;&quot;)
def downloader(filename):
    dir_path = os.path.join(app.root_path, 'output')
    return send_from_directory(dir_path, filename, as_attachment=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;足够的抽象&quot;&gt;足够的抽象&lt;/h3&gt;
&lt;p&gt;Java程序员表示，看见什么都想给它抽象成一个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Pdf:
    def __init__(self, file_dir, filename, output_path):
        self.file_dir = file_dir
        self.filename = filename
        self.pdf = pdf.parse_pdf(filepath=os.path.join(file_dir, filename))
        self.page_count = 0
        self.output_path = output_path

    def extract(self, tmp_dir='tmp/'):
        return pdf.save_pdf_as_img(pdf=self.pdf, filename=tmp_dir + self.filename)

    def convert(self):
        if self.page_count == 0:
            return
        color.mix_img(file_dir='tmp/', filename=self.filename, count=self.page_count)
        return

    def save(self):
        return pdf.save_img_as_pdf(file_dir='tmp/', filename=self.filename,
                                   count=self.page_count, output_dir=self.output_path, output_filename=self.filename)

    def get_output_filename(self):
        self.page_count = self.extract()
        self.convert()
        self.save()
        return self.filename&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来想随机填充的，发现随机生成的图像虽然随机，但是不好看。&lt;/p&gt;
&lt;h2 id=&quot;todos&quot;&gt;TODOS&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;异步返回处理结果（因为算法有点慢&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;OSS&lt;/code&gt;减轻网络io负担&lt;/li&gt;
&lt;li&gt;更多文件图片格式支持&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;还有什么好玩的想法可以私聊我呀（&lt;br/&gt;大家试着可以一起实现一下&lt;/p&gt;
</description>
<pubDate>Wed, 05 Feb 2020 15:21:00 +0000</pubDate>
<dc:creator>Licsber</dc:creator>
<og:description>一个业余的小项目，实现转换pdf为五彩斑斓的pdf，图片同理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/licsber/p/colorful-black.html</dc:identifier>
</item>
<item>
<title>用 C# 写一个 Redis 数据同步小工具 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/12267246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/12267246.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;为了实现 redis 的数据迁移而写的一个小工具，将一个实例中的 redis 数据同步到另外一个实例中。(原本打算找一个已有的工具去做，找了一个 nodejs 的小工具，结果折腾了好久都没装上。。。于是就自己写了这个小工具）&lt;/p&gt;
&lt;p&gt;之所以自己写一个工具而不是利用 redis 备份机制来实现，主要是因为我们用的是 redis 云服务，不能像自己的服务器一样 SSH 上去一顿操作，要把云服务的 redis 数据同步到自己服务器上的 redis 实例。&lt;/p&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;基本使用&lt;/h2&gt;
&lt;h3 id=&quot;配置解读&quot;&gt;配置解读&lt;/h3&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;AppSettings&quot;: {
    &quot;SyncDatabases&quot;: &quot;0,1&quot;,
    &quot;BatchSize&quot;: 50
  },
  &quot;ConnectionStrings&quot;: {
    &quot;Source&quot;: &quot;redis1:6379,asyncTimeout=30000,syncTimeout=30000&quot;,
    &quot;Dest&quot;: &quot;redis2:6379,password=123433,asyncTimeout=30000,syncTimeout=30000&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AppSettings:SyncDatabases&lt;/code&gt;是要同步的 redis 数据库，多个数据库用英文的逗号分隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AppSettings:BatchSize&lt;/code&gt; 是每次从源 redis 服务器读取 N 个 key（分页读取，每页 N 个）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConnectionStrings:Source&lt;/code&gt; 代表了源 redis 服务器连接字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConnectionStrings:Dest&lt;/code&gt; 代表了目标 redis 服务器连接字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;redis 连接字符串详细参数可以参考文档：&lt;a href=&quot;https://weihanli.github.io/StackExchange.Redis-docs-zh-cn/Configuration.html&quot; class=&quot;uri&quot;&gt;https://weihanli.github.io/StackExchange.Redis-docs-zh-cn/Configuration.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;执行迁移&quot;&gt;执行迁移&lt;/h3&gt;
&lt;p&gt;修改 redis 配置之后（根据自己要同步数据量的大小设置超时时间），在项目根目录下运行 &lt;code&gt;dotnet run&lt;/code&gt; 即可，&lt;/p&gt;
&lt;h3 id=&quot;sample-run&quot;&gt;Sample Run&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/202002/489462-20200205231748562-5947111.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;支持同步/迁移的数据类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;ZSet(SortedSet)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现源码：&lt;a href=&quot;https://github.com/WeihanLi/SamplesInPractice/tree/master/RedisCopy&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/SamplesInPractice/tree/master/RedisCopy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 05 Feb 2020 15:19:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>用 C# 写一个 Redis 数据同步小工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/12267246.html</dc:identifier>
</item>
<item>
<title>OpenResty学习指南（一） - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/12267231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/12267231.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/202002/1204119-20200205231358427-693150161.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的博客： &lt;a href=&quot;https://www.luozhiyun.com/archives/217&quot; class=&quot;uri&quot;&gt;https://www.luozhiyun.com/archives/217&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想要学好 OpenResty，你必须理解下面 8 个重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步非阻塞的编程模式；&lt;/li&gt;
&lt;li&gt;不同阶段的作用；&lt;/li&gt;
&lt;li&gt;LuaJIT 和 Lua 的不同之处；&lt;/li&gt;
&lt;li&gt;OpenResty API 和周边库；&lt;/li&gt;
&lt;li&gt;协程和 cosocket；&lt;/li&gt;
&lt;li&gt;单元测试框架和性能测试工具；&lt;/li&gt;
&lt;li&gt;火焰图和周边工具链；&lt;/li&gt;
&lt;li&gt;性能优化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你不应该使用任何 Lua 世界的库来解决上述问题，而是应该使用 cosocket 的 lua-resty-* 库。Lua 世界的库很可能会带来阻塞，让原本高性能的服务，直接下降几个数量级。&lt;/p&gt;
&lt;h2 id=&quot;openresty阶段&quot;&gt;OpenResty阶段&lt;/h2&gt;
&lt;p&gt;和nginx一样，都有阶段的概念，并且每个阶段都有自己不同的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;set_by_lua，用于设置变量；&lt;/li&gt;
&lt;li&gt;rewrite_by_lua，用于转发、重定向等；&lt;/li&gt;
&lt;li&gt;access_by_lua，用于准入、权限等；&lt;/li&gt;
&lt;li&gt;content_by_lua，用于生成返回内容；&lt;/li&gt;
&lt;li&gt;header_filter_by_lua，用于应答头过滤处理；&lt;/li&gt;
&lt;li&gt;body_filter_by_lua，用于应答体过滤处理；&lt;/li&gt;
&lt;li&gt;log_by_lua，用于日志记录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OpenResty 的 API 是有阶段使用限制的。每一个 API 都有一个与之对应的使用阶段列表，如果你超范围使用就会报错。&lt;/p&gt;
&lt;p&gt;具体的API可以查阅文档：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨阶段的变量&quot;&gt;跨阶段的变量&lt;/h3&gt;
&lt;p&gt;有些情况下，我们需要的是跨越阶段的、可以读写的变量。&lt;/p&gt;
&lt;p&gt;OpenResty 提供了 ngx.ctx，来解决这类问题。它是一个 Lua table，可以用来存储基于请求的 Lua 数据，且生存周期与当前请求相同。我们来看下官方文档中的这个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;location /test {
      rewrite_by_lua_block {
          ngx.ctx.foo = 76
      }
      access_by_lua_block {
          ngx.ctx.foo = ngx.ctx.foo + 3
      }
      content_by_lua_block {
          ngx.say(ngx.ctx.foo)
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终输出79&lt;/p&gt;
&lt;h2 id=&quot;包管理&quot;&gt;包管理&lt;/h2&gt;
&lt;h3 id=&quot;opm&quot;&gt;OPM&lt;/h3&gt;
&lt;p&gt;OPM（OpenResty Package Manager）是 OpenResty 自带的包管理器&lt;br/&gt;&lt;code&gt;opm search lua-resty-http&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;luarocks&quot;&gt;LUAROCKS&lt;/h3&gt;
&lt;p&gt;不同于 OPM 里只包含 OpenResty 相关的包，LuaRocks 里面还包含 Lua 世界的库。&lt;br/&gt;&lt;code&gt;luarocks search lua-resty-http&lt;/code&gt;&lt;br/&gt;我们还可以去网站上看包的详细信息：&lt;a href=&quot;https://luarocks.org/modules/pintsized/lua-resty-http%EF%BC%8C%E8%BF%99%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E4%BA%86%E4%BD%9C%E8%80%85%E3%80%81License%E3%80%81GitHub&quot; class=&quot;uri&quot;&gt;https://luarocks.org/modules/pintsized/lua-resty-http，这里面包含了作者、License、GitHub&lt;/a&gt; 地址、下载次数、功能简介、历史版本、依赖等。&lt;/p&gt;
&lt;h3 id=&quot;awesome-resty&quot;&gt;AWESOME-RESTY&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bungle/awesome-resty&quot;&gt;awesome-resty&lt;/a&gt; 这个项目，就维护了几乎所有 OpenResty 可用的包，并且都分门别类地整理好了。&lt;/p&gt;
&lt;h2 id=&quot;nginx&quot;&gt;nginx&lt;/h2&gt;
&lt;h3 id=&quot;nginx命令行&quot;&gt;nginx命令行&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;格式：nginx -s reload&lt;/li&gt;
&lt;li&gt;帮助： -？ -h&lt;/li&gt;
&lt;li&gt;使用指定的配置文件： -c&lt;/li&gt;
&lt;li&gt;指定配置指令：-g&lt;/li&gt;
&lt;li&gt;指定运行目录：-p&lt;/li&gt;
&lt;li&gt;发送信号：-s （stop / quit / reload / reopen）&lt;/li&gt;
&lt;li&gt;测试配置文件是否有语法错误：-t -T&lt;/li&gt;
&lt;li&gt;打印nginx的版本信息、编译信息等：-v -V&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;nginx信号&quot;&gt;nginx信号&lt;/h3&gt;
&lt;p&gt;因为nginx是多进程的程序：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/202002/1204119-20200205231452343-2138929288.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以信号分为Master进程信号和worker进程信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master进程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监控worker进程： CHILD ，如果worker进程出现了故障而挂掉了，那么master可以通过这个信号将worker进程迅速拉起&lt;/li&gt;
&lt;li&gt;管理worker进程：
&lt;ul&gt;&lt;li&gt;TERM，INT：表示立刻停止nginx进程&lt;/li&gt;
&lt;li&gt;QUIT：表示优雅停止nginx进程&lt;/li&gt;
&lt;li&gt;HUP：重载配置文件&lt;/li&gt;
&lt;li&gt;USR1：表示重新打开日志文件&lt;/li&gt;
&lt;li&gt;USR2、WINCH：专门针对热部署使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;worker进程：与master进程命令一一对应&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TERM，INT：表示立刻停止nginx进程&lt;/li&gt;
&lt;li&gt;QUIT：表示优雅停止nginx进程&lt;/li&gt;
&lt;li&gt;USR1：表示重新打开日志文件&lt;/li&gt;
&lt;li&gt;WINCH：专门针对热部署使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Nginx命令行，相当于直接向master进程发送命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;reload：HUP&lt;/li&gt;
&lt;li&gt;reopen：USR1&lt;/li&gt;
&lt;li&gt;stop：TERM&lt;/li&gt;
&lt;li&gt;quit：QUIT&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;openresty入门&quot;&gt;openresty入门&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建工作目录&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mkdir geektime
cd luoluo
mkdir logs/ conf/&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在conf里面添加nginx.conf文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;events {
    worker_connections 1024;
}
http {
    server {
        listen 8080;
        location / {
            content_by_lua '
                ngx.say(&quot;hello, world&quot;)
            ';
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动openresty服务&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openresty -p `pwd` -c conf/nginx.conf
指定运行目录：-p
使用指定的配置文件： -c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;openresty后面跟随的命令和nginx是一样的&lt;/p&gt;
&lt;h2 id=&quot;独立出lua代码&quot;&gt;独立出Lua代码&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们先在luo的工作目录下，创建一个名为lua的目录&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;$ mkdir lua
$ cat lua/hello.lua
ngx.say(&quot;hello, world&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改 nginx.conf 的配置&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;pid logs/nginx.pid;
events {
    worker_connections 1024;
}
http {
    server {
        listen 8080;
        location / {
            content_by_lua_file lua/hello.lua;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里把 content_by_lua_block 改为 content_by_lua_file&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重启OpenResty&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;$ sudo kill -HUP `cat logs/nginx.pid`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里使用了发送信号的方式 -HUP表示重载配置文件&lt;/p&gt;
&lt;h2 id=&quot;nyi&quot;&gt;NYI&lt;/h2&gt;
&lt;p&gt;NYI，全称为 Not Yet Implemented。LuaJIT 中 JIT 编译器的实现还不完善，有一些原语它还无法编译，因为这些原语实现起来比较困难，再加上 LuaJIT 的作者目前处于半退休状态。这些原语包括常见的 pairs() 函数、unpack() 函数、基于 Lua CFunction 实现的 Lua C 模块等。这样一来，当 JIT 编译器在当前代码路径上遇到它不支持的操作时，便会退回到解释器模式。这些不能编译的函数称为NYI。&lt;/p&gt;
&lt;p&gt;NYI函数都在：&lt;a href=&quot;http://wiki.luajit.org/NYI&quot; class=&quot;uri&quot;&gt;http://wiki.luajit.org/NYI&lt;/a&gt;&lt;br/&gt;在开发中，可以先去找OpenResty的API：&lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot; class=&quot;uri&quot;&gt;https://github.com/openresty/lua-nginx-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例如，NYI 列表中 string 库的几个函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/202002/1204119-20200205231415465-754319536.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，string.byte 对应的能否被编译的状态是 yes，表明可以被 JIT。&lt;/p&gt;
&lt;p&gt;string.char 对应的编译状态是 2.1，表明从 LuaJIT 2.1 开始支持。我们知道，OpenResty 中的 LuaJIT 是基于 LuaJIT 2.1 的，所以你也可以放心使用。&lt;/p&gt;
&lt;p&gt;string.dump 对应的编译状态是 never，即不会被 JIT，会退回到解释器模式。&lt;/p&gt;
&lt;p&gt;string.find 对应的编译状态是 2.1 partial，意思是从 LuaJIT 2.1 开始部分支持，后面的备注中写的是 只支持搜索固定的字符串，不支持模式匹配。&lt;/p&gt;
&lt;h3 id=&quot;如何检测函数&quot;&gt;如何检测函数&lt;/h3&gt;
&lt;p&gt;LuaJIT 自带的 jit.dump 和 jit.v 模块。它们都可以打印出 JIT 编译器工作的过程。前者会输出非常详细的信息，可以用来调试 LuaJIT 本身；后者的输出比较简单，每行对应一个 trace，通常用来检测是否可以被 JIT。&lt;/p&gt;
&lt;p&gt;使用resty：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$resty -j v -e &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，resty 的 -j 就是和 LuaJIT 相关的选项；后面的值为 dump 和 v，就对应着开启 jit.dump 和 jit.v 模式。&lt;/p&gt;
&lt;p&gt;如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$resty -j v -e 'local t = {}
 for i=1,100 do
     t[i] = i
 end
 
 for i=1, 1000 do
     for j=1,1000 do
         for k,v in pairs(t) do
             --
         end
     end
 end'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的pairs是NYI的语句，不能被JIT，所以结果里面就会显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; [TRACE   1 (command line -e):2 loop]
 [TRACE --- (command line -e):7 -- NYI: bytecode 72 at (command line -e):8]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;shdict-get-api&quot;&gt;shdict get API&lt;/h2&gt;
&lt;p&gt;shared dict（共享字典）是基于 NGINX 共享内存区的 Lua 字典对象，它可以跨多个 worker 来存取数据，一般用来存放限流、限速、缓存等数据。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;http {
      lua_shared_dict dogs 10m;
      server {
          location /demo {
              content_by_lua_block {
                  local dogs = ngx.shared.dogs
         dogs:set(&quot;Jim&quot;, 8)
         local v = dogs:get(&quot;Jim&quot;)
                  ngx.say(v)
              }
          }
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说明一下，在 Lua 代码中使用 shared dict 之前，我们需要在 nginx.conf 中用 lua_shared_dict 指令增加一块内存空间，它的名字是 dogs，大小为 10M。&lt;/p&gt;
&lt;p&gt;也可以使用resty CLI：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ resty --shdict 'dogs 10m' -e 'local dogs = ngx.shared.dogs
 dogs:set(&quot;Jim&quot;, 8)
 local v = dogs:get(&quot;Jim&quot;)
 ngx.say(v)'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;共享内存使用阶段&quot;&gt;共享内存使用阶段&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;context: set_by_lua*, 
rewrite_by_lua*, 
access_by_lua*, 
content_by_lua*, 
header_filter_by_lua*, 
body_filter_by_lua*, 
log_by_lua*, 
ngx.timer.*, 
balancer_by_lua*, 
ssl_certificate_by_lua*, 
ssl_session_fetch_by_lua*, 
ssl_session_store_by_lua*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出， init 和 init_worker 两个阶段不在其中，也就是说，共享内存的 get API 不能在这两个阶段使用。&lt;/p&gt;
&lt;h3 id=&quot;get函数返回多个值&quot;&gt;get函数返回多个值&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;value, flags = ngx.shared.DICT:get(key)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常情况下：&lt;br/&gt;第一个参数value 返回的是字典中 key 对应的值；但当 key 不存在或者过期时，value 的值为 nil。&lt;br/&gt;第二个参数 flags 就稍微复杂一些了，如果 set 接口设置了 flags，就返回，否则不返回。&lt;/p&gt;
&lt;p&gt;一旦 API 调用出错，value 返回 nil，flags 返回具体的错误信息。&lt;/p&gt;
&lt;h2 id=&quot;cosocket&quot;&gt;cosocket&lt;/h2&gt;
&lt;p&gt;cosocket 是把协程和网络套接字的英文拼在一起形成的，即 cosocket = coroutine + socket。&lt;/p&gt;
&lt;p&gt;遇到网络 I/O 时，它会交出控制权（yield），把网络事件注册到 Nginx 监听列表中，并把权限交给 Nginx；当有 Nginx 事件达到触发条件时，便唤醒对应的协程继续处理（resume），最终实现了非阻塞网络 I/O。&lt;/p&gt;
&lt;h3 id=&quot;api&quot;&gt;API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建对象：ngx.socket.tcp。&lt;/li&gt;
&lt;li&gt;设置超时：tcpsock:settimeout 和 tcpsock:settimeouts。&lt;/li&gt;
&lt;li&gt;建立连接：tcpsock:connect。&lt;/li&gt;
&lt;li&gt;发送数据：tcpsock:send。&lt;/li&gt;
&lt;li&gt;接受数据：tcpsock:receive、tcpsock:receiveany 和 tcpsock:receiveuntil。&lt;/li&gt;
&lt;li&gt;连接池：tcpsock:setkeepalive。&lt;/li&gt;
&lt;li&gt;关闭连接：tcpsock:close。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上下文：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rewrite_by_lua*, 
access_by_lua*, 
content_by_lua*,
ngx.timer.*, 
ssl_certificate_by_lua*, 
ssl_session_fetch_by_lua*_&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cosocket API 在 set_by_lua&lt;em&gt;， log_by_lua&lt;/em&gt;， header_filter_by_lua* 和 body_filter_by_lua* 中是无法使用的。init_by_lua* 和 init_worker_by_lua* 中暂时也不能用。&lt;/p&gt;
&lt;p&gt;与这些API相应的Nginx指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lua_socket_connect_timeout：连接超时，默认 60 秒。&lt;/li&gt;
&lt;li&gt;lua_socket_send_timeout：发送超时，默认 60 秒。&lt;/li&gt;
&lt;li&gt;lua_socket_send_lowat：发送阈值（low water），默认为 0。&lt;/li&gt;
&lt;li&gt;lua_socket_read_timeout： 读取超时，默认 60 秒。&lt;/li&gt;
&lt;li&gt;lua_socket_buffer_size：读取数据的缓存区大小，默认 4k/8k。&lt;/li&gt;
&lt;li&gt;lua_socket_pool_size：连接池大小，默认 30。&lt;/li&gt;
&lt;li&gt;lua_socket_keepalive_timeout：连接池 cosocket 对象的空闲时间，默认 60 秒。&lt;/li&gt;
&lt;li&gt;lua_socket_log_errors：cosocket 发生错误时，是否记录日志，默认为 on。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;例子&quot;&gt;例子&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ resty -e 'local sock = ngx.socket.tcp()
        sock:settimeout(1000)  -- one second timeout
        local ok, err = sock:connect(&quot;www.baidu.com&quot;, 80)
        if not ok then
            ngx.say(&quot;failed to connect: &quot;, err)
            return
        end
 
        local req_data = &quot;GET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\n&quot;
        local bytes, err = sock:send(req_data)
        if err then
            ngx.say(&quot;failed to send: &quot;, err)
            return
        end
 
        local data, err, partial = sock:receive()
        if err then
            ngx.say(&quot;failed to receive: &quot;, err)
            return
        end
 
        sock:close()
        ngx.say(&quot;response is: &quot;, data)'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先，通过 ngx.socket.tcp() ，创建 TCP 的 cosocket 对象，名字是 sock。&lt;/li&gt;
&lt;li&gt;然后，使用 settimeout() ，把超时时间设置为 1 秒。注意这里的超时没有区分 connect、receive，是统一的设置。&lt;/li&gt;
&lt;li&gt;接着，使用 connect() 去连接指定网站的 80 端口，如果失败就直接退出。&lt;/li&gt;
&lt;li&gt;连接成功的话，就使用 send() 来发送构造好的数据，如果发送失败就退出。&lt;/li&gt;
&lt;li&gt;发送数据成功的话，就使用 receive() 来接收网站返回的数据。这里 receive() 的默认参数值是 &lt;em&gt;l，也就是只返回第一行的数据；如果参数设置为了&lt;/em&gt;a，就是持续接收数据，直到连接关闭；&lt;/li&gt;
&lt;li&gt;最后，调用 close() ，主动关闭 socket 连接。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;超时时间&quot;&gt;超时时间&lt;/h4&gt;
&lt;p&gt;在上面settimeout() ，作用是把连接、发送和读取超时时间统一设置为一个值。如果要想分开设置，就需要使用 settimeouts() 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sock:settimeouts(1000, 2000, 3000) &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接收数据&quot;&gt;接收数据&lt;/h4&gt;
&lt;p&gt;receive 接收指定大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;local data, err, partial = sock:receiveany(10240)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码就表示，最多只接收 10K 的数据。&lt;/p&gt;
&lt;p&gt;关于 receive，还有另一个很常见的用户需求，那就是一直获取数据，直到遇到指定字符串才停止。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ocal reader = sock:receiveuntil(&quot;\r\n&quot;)
 
 while true do
     local data, err, partial = reader(4)
     if not data then
         if err then
             ngx.say(&quot;failed to read the data stream: &quot;, err)
             break
         end
 
         ngx.say(&quot;read done&quot;)
         break
     end
     ngx.say(&quot;read chunk: [&quot;, data, &quot;]&quot;)
 end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中的 receiveuntil 会返回 \r\n 之前的数据，并通过迭代器每次读取其中的 4 个字节。&lt;/p&gt;
&lt;h4 id=&quot;连接池&quot;&gt;连接池&lt;/h4&gt;
&lt;p&gt;没有连接池的话，每次请求进来都要新建一个连接，就会导致 cosocket 对象被频繁地创建和销毁，造成不必要的性能损耗。&lt;/p&gt;
&lt;p&gt;在你使用完一个 cosocket 后，可以调用 setkeepalive() 放到连接池中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;local ok, err = sock:setkeepalive(2 * 1000, 100)
if not ok then
    ngx.say(&quot;failed to set reusable: &quot;, err)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码设置了连接的空闲时间为 2 秒，连接池的大小为 100。在调用 connect() 函数时，就会优先从连接池中获取 cosocket 对象。&lt;/p&gt;
&lt;p&gt;需注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不能把发生错误的连接放入连接池&lt;/li&gt;
&lt;li&gt;第二，要搞清楚连接的数量。连接池是 worker 级别的，每个 worker 都有自己的连接池。所以，如果你有 10 个 worker，连接池大小设置为 30，那么对于后端的服务来讲，就等于有 300 个连接。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;定时任务&quot;&gt;定时任务&lt;/h2&gt;
&lt;p&gt;OpenResty 的定时任务可以分为下面两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ngx.timer.at，用来执行一次性的定时任务；&lt;/li&gt;
&lt;li&gt;ngx.time.every，用来执行固定周期的定时任务。但是在启动了一个 timer 之后，你就再也没有机会来取消这个定时任务了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;init_worker_by_lua_block {
        local function handler()
            local sock = ngx.socket.tcp()
            local ok, err = sock:connect(“www.baidu.com&quot;, 80)
        end
        local ok, err = ngx.timer.at(0, handler)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动了一个延时为 0 的定时任务。它启动了回调函数 handler，并在这个函数中，用 cosocket 去访问一个网站&lt;/p&gt;
</description>
<pubDate>Wed, 05 Feb 2020 15:16:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>我的博客： https://www.luozhiyun.com/archives/217 想要学好 OpenResty，你必须理解下面 8 个重点： 同步非阻塞的编程模式； 不同阶段的作用； LuaJ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/12267231.html</dc:identifier>
</item>
<item>
<title>浅谈synchronized - coderyhy</title>
<link>http://www.cnblogs.com/yhycoder/p/12267191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yhycoder/p/12267191.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;看多线程的相关书籍的时候，会经常阅读到一个使用前景，就是银行的取钱存钱操作。&lt;br/&gt;假设我们使用两个线程来模拟取钱操作，模拟两个人使用同一个账户并发取钱的问题，我们都知道存款不可能为负的，&lt;br/&gt;但是往往并发操作的时候，可能就会导致系统出错导致出现负的数字（假设一开始都是200元余额，两边同时操作取出150，系统可能就会出错）。&lt;br/&gt;出现类似这种问题就是缺少同步安全性，为了解决这个问题，Java就增进了同步监视器来解决这个，也就是本文讲的synchronized的作用。&lt;/p&gt;
&lt;h2 id=&quot;是什么&quot;&gt;是什么&lt;/h2&gt;
&lt;p&gt;synchronized是Java中的&lt;strong&gt;关键字&lt;/strong&gt;。同步的意思，用在解决&lt;strong&gt;线程安全&lt;/strong&gt;问题上。有添加在&lt;strong&gt;方法&lt;/strong&gt;上，和直接修饰&lt;strong&gt;代码块&lt;/strong&gt;。有种保护的作用，使用修饰之后，家门上了锁，别人进不来。用synchronized修饰的方法&lt;strong&gt;只允许一个线程&lt;/strong&gt;执行，其他线程无法进入该方法。（原子性操作），银行使用该操作之后，就会变成一个排队操作一样，像前言的例子，就会变成一个人等另一个操作取出150之后才可以取钱，这样就不会出现负的余额。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本上所有的并发模式 在解决线程冲突的时候，都是采用序列化访问共享资源的方案。就是在给定的时间间隔内只允许一个任务访问共享资源。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;所以synchronized保护的是线程遭受破坏，必须按照允许的权限进行资源访问。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记得synchronized关键字可以修饰方法，可以修饰代码块，但&lt;strong&gt;不能&lt;/strong&gt;修饰构造函数、属性等。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//long与double的操作不是原子的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/04/yAwzan6S2RWk3BC.png&quot; width=&quot;850px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;格式&quot;&gt;格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/03/yvfkjoFdD91P2gn.png&quot; width=&quot;850px&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步代码块&quot;&gt;同步代码块&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//synchronized代码块
//obj对象即表示线程开始执行同步代码块之前，必须先获得对同步监视器的锁定
//步骤：加锁--修改--释放锁
synchronized (obj) {
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。具体的格式参见上面。&lt;/p&gt;
&lt;h3 id=&quot;同步方法&quot;&gt;同步方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//synchronized方法,可以分为静态方法和普通方法
synchronized void method(){
    ...
}
//等价于
public void method()
{
   synchronized(this) {
      // todo
   }
}
//无论哪种形式都可以看做是“｛”处获取锁，“｝”释放锁&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与同步代码块对应，Java 的多线程安全支持还提供了同步方法，同步方法就是使用synchronized关键字来修饰某个方法(放在权限词的&lt;strong&gt;后面&lt;/strong&gt;即可)，则该方法称为同步方法。对于同步方法而言，&lt;strong&gt;无须显式&lt;/strong&gt;指定同步监视器，同步方法的同步监视器是this，也就是&lt;strong&gt;该对象&lt;/strong&gt;本身。在&lt;strong&gt;格式&lt;/strong&gt;上可以看到一些用法，但是具体来讲，synchronized用在方法体上还分为用在普通方法和静态方法两种，区别在作用锁对象的不同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;修饰普通方法作用的是调用这个方法的对象，修饰静态方法作用是调用这个类的所有对象。
synchronized static方法可以在类的范围内防止对static数据的并发访问，&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用同步方法可以很方便得实现线程安全的类，这样类的对象可以被多个线程同时安全得访问。&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;synchronized不能被继承。&lt;/li&gt;
&lt;li&gt;collection中的线程不安全的集合可以变成使用Collections工具类的,具体用法语句可以参考API文档，写的还算比较详细。&lt;img src=&quot;https://i.loli.net/2020/02/05/A8VafvYhTC1x7Rg.png&quot; width=&quot;850px&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;关于什么使用同步，也就是上锁，引用书上的话&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果你在写一个变量，它可能接下来将被另一个线程读取，或者正在读取上一个已经被另一个线程写过的变量，那么你必须使用同步，并且，读取线程都必须用相同的监视器锁同步&lt;/p&gt;
&lt;p&gt;​ ——Brain Goetz《Java Concurrency in Pactice》的作者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;个人学习记录，有错误欢迎指点，谢谢！加油！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 05 Feb 2020 15:06:00 +0000</pubDate>
<dc:creator>coderyhy</dc:creator>
<og:description>浅谈synchronized [toc] 前言 看多线程的相关书籍的时候，会经常阅读到一个使用前景，就是银行的取钱存钱操作。 假设我们使用两个线程来模拟取钱操作，模拟两个人使用同一个账户并发取钱的问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yhycoder/p/12267191.html</dc:identifier>
</item>
</channel>
</rss>