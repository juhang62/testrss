<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解读 Android TTS  语音合成播报 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/10796420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/10796420.html</guid>
<description>&lt;p&gt;随着从事 Android 开发年限增加，负责的工作项目也从应用层开发逐步过渡到 Android Framework 层开发。虽然一开始就知道 Android 知识体系的庞大，但是当你逐渐从 Application 层向 Framework 层走的时候，你才发现之前懂得认知真是太少。之前更多打交道的 Activity 和 Fragment ，对于 Service 和 Broadcast 涉及的很少，更多注重的是界面的布局、动画、网络请求等，虽然走应用开发的话，后期会关注架构、性能优化、Hybrid等，但是逐渐接触 Framework 层相关模块时候，发现里面的知识点各种错综复杂，就好比讲讲今天分享的主题是 &lt;strong&gt;Android TTS&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;话不多说，先来张图，分享大纲如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201904/331079-20190430154402793-778626540.png&quot; alt=&quot;大纲&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前受一篇文章启发，说的是如何讲解好一个技术点知识，可以分为两部分去介绍：外部应用维度和内部设计维度，基本从这两个角度出发，可以把一个技术点讲的透彻。同样，我把这种方式应用到写作中去。&lt;/p&gt;
&lt;h2 id=&quot;外部应用维度&quot;&gt;外部应用维度&lt;/h2&gt;
&lt;h3 id=&quot;什么是-tts&quot;&gt;什么是 TTS&lt;/h3&gt;
&lt;p&gt;在 Android 中，TTS全称叫做 Text to Speech，从字面就能理解它解决的问题是什么，把文本转为语音服务，意思就是你输入一段文本信息，然后Android 系统可以把这段文字播报出来。这种应用场景目前比较多是在各种语音助手APP上，很多手机系统集成商内部都有内置文本转语音服务，可以读当前页面上的文本信息。同样，在一些阅读类APP上我们也能看到相关服务，打开微信读书，里面就直接可以把当前页面直接用语音方式播放出来，特别适合哪种不方便拿着手机屏幕阅读的场景。&lt;/p&gt;
&lt;h3 id=&quot;tts-技术规范&quot;&gt;TTS 技术规范&lt;/h3&gt;
&lt;p&gt;这里主要用到的是TextToSpeech类来完成，使用TextToSpeech的步骤如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;创建TextToSpeech对象，创建时传入OnInitListener监听器监听示范创建成功。&lt;br/&gt;设置TextToSpeech所使用语言国家选项，通过返回值判断TTS是否支持该语言、国家选项。&lt;br/&gt;调用speak()或synthesizeToFile方法。&lt;br/&gt;关闭TTS，回收资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;XML文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;ScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&amp;gt;

        &amp;lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:orientation=&quot;vertical&quot;&amp;gt;

            &amp;lt;EditText
                android:id=&quot;@+id/edit_text1&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;杭州自秦朝设县治以来已有2200多年的历史，曾是吴越国和南宋的都城。因风景秀丽，素有“人间天堂”的美誉。杭州得益于京杭运河和通商口岸的便利，以及自身发达的丝绸和粮食产业，历史上曾是重要的商业集散中心。&quot; /&amp;gt;

            &amp;lt;Button
                android:id=&quot;@+id/btn_tts1&quot;
                android:layout_width=&quot;150dp&quot;
                android:layout_height=&quot;60dp&quot;
                android:layout_marginTop=&quot;10dp&quot;
                android:text=&quot;TTS1&quot; /&amp;gt;

            &amp;lt;EditText
                android:id=&quot;@+id/edit_text2&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;伊利公开举报原创始人郑俊怀:多名高官充当保护伞  北京青年报  2018-10-24 12:01:46  　　10月24日上午，伊利公司在企业官方网站发出举报信，公开举报郑俊怀等人，声称郑俊怀索要巨额犯罪所得不成，动用最高检某原副检察长等人施压，长期造谣迫害伊利，多位省部级、厅局级领导均充当郑俊怀保护伞，人为抹掉2.4亿犯罪事实，运作假减刑，14年来无人敢处理。&quot; /&amp;gt;

            &amp;lt;Button
                android:id=&quot;@+id/btn_tts2&quot;
                android:layout_width=&quot;150dp&quot;
                android:layout_height=&quot;60dp&quot;
                android:layout_marginTop=&quot;10dp&quot;
                android:text=&quot;TTS2&quot; /&amp;gt;

            &amp;lt;Button
                android:id=&quot;@+id/btn_cycle&quot;
                android:layout_width=&quot;150dp&quot;
                android:layout_height=&quot;60dp&quot;
                android:layout_marginTop=&quot;10dp&quot;
                android:text=&quot;Cycle TTS&quot; /&amp;gt;

            &amp;lt;Button
                android:id=&quot;@+id/btn_second&quot;
                android:layout_width=&quot;150dp&quot;
                android:layout_height=&quot;60dp&quot;
                android:layout_marginTop=&quot;10dp&quot;
                android:text=&quot;Second TTS&quot; /&amp;gt;

        &amp;lt;/LinearLayout&amp;gt;

    &amp;lt;/ScrollView&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Activity文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TtsMainActivity extends AppCompatActivity implements View.OnClickListener,TextToSpeech.OnInitListener {
    private static final String TAG = TtsMainActivity.class.getSimpleName();
    private static final int THREADNUM = 100; // 测试用的线程数目

    private EditText mTestEt1;
    private EditText mTestEt2;
    private TextToSpeech mTTS;  // TTS对象
    private XKAudioPolicyManager mXKAudioPolicyManager;
    private HashMap mParams = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTestEt1 = (EditText) findViewById(R.id.edit_text1);
        mTestEt2 = (EditText) findViewById(R.id.edit_text2);

        findViewById(R.id.btn_tts1).setOnClickListener(this);
        findViewById(R.id.btn_tts2).setOnClickListener(this);
        findViewById(R.id.btn_cycle).setOnClickListener(this);
        findViewById(R.id.btn_second).setOnClickListener(this);
        init();
    }

    private void init(){
        mTTS = new TextToSpeech(this.getApplicationContext(),this);
        mXKAudioPolicyManager = XKAudioPolicyManager.getInstance(this.getApplication());
        mParams = new HashMap();
        mParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, &quot;3&quot;); //设置播放类型（音频流类型）
    }

    @Override
    public void onInit(int status) {
        if (status == TextToSpeech.SUCCESS) {
            int result = mTTS.setLanguage(Locale.ENGLISH);
            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                Toast.makeText(this, &quot;数据丢失或不支持&quot;, Toast.LENGTH_SHORT).show();
            }
        }
    }

    @Override
    public void onClick(View v) {
        int id = v.getId();
        switch (id){
            case R.id.btn_tts1:
                TtsPlay1();
                break;
            case R.id.btn_tts2:
                TtsPlay2();
                break;
            case R.id.btn_second:
                TtsSecond();
                break;
            case R.id.btn_cycle:
                TtsCycle();
                break;
            default:
                break;
        }
    }

    private void TtsPlay1(){
        if (mTTS != null &amp;amp;&amp;amp; !mTTS.isSpeaking() &amp;amp;&amp;amp; mXKAudioPolicyManager.requestAudioSource()) {
            //mTTS.setOnUtteranceProgressListener(new ttsPlayOne());
            String text1 = mTestEt1.getText().toString();
            Log.d(TAG, &quot;TtsPlay1-----------播放文本内容：&quot; + text1);
            //朗读，注意这里三个参数的added in API level 4   四个参数的added in API level 21
            mTTS.speak(text1, TextToSpeech.QUEUE_FLUSH, mParams);
        }
    }

    private void TtsPlay2(){
        if (mTTS != null &amp;amp;&amp;amp; !mTTS.isSpeaking() &amp;amp;&amp;amp; mXKAudioPolicyManager.requestAudioSource()) {
            //mTTS.setOnUtteranceProgressListener(new ttsPlaySecond());
            String text2 = mTestEt2.getText().toString();
            Log.d(TAG, &quot;TtsPlay2-----------播放文本内容：&quot; + text2);
            // 设置音调，值越大声音越尖（女生），值越小则变成男声,1.0是常规
            mTTS.setPitch(0.8f);
            //设定语速 ，默认1.0正常语速
            mTTS.setSpeechRate(1f);
            //朗读，注意这里三个参数的added in API level 4   四个参数的added in API level 21
            mTTS.speak(text2, TextToSpeech.QUEUE_FLUSH, mParams);
        }
    }

    private void TtsSecond(){
        Intent intent = new Intent(TtsMainActivity.this,TtsSecondAcitivity.class);
        startActivity(intent);
    }

    private void TtsCycle(){
        long millis1 = System.currentTimeMillis();

        for (int i = 0; i &amp;lt; THREADNUM; i++) {
            Thread tempThread = new Thread(new MyRunnable(i, THREADNUM));
            tempThread.setName(&quot;线程&quot; + i);
            tempThread.start();
        }

        long millis2 = System.currentTimeMillis();
        Log.d(TAG, &quot;循环测试发音耗费时间：&quot; + (millis2 - millis1));
    }

    @Override
    protected void onStart() {
        super.onStart();
    }

    @Override
    protected void onStop() {
        super.onStop();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        shutDown();
    }

    private void shutDown(){
        if(mTTS != null){
            mTTS.stop();
            mTTS.shutdown();
        }
        if(mXKAudioPolicyManager != null){
            mXKAudioPolicyManager.releaseAudioSource();
        }
    }

    /**
     * 自定义线程可执行处理
     * */
    class MyRunnable implements Runnable {
        private int i; // 第几个线程
        private int threadNum; // 总共创建了几个线程

        public MyRunnable(int i, int threadNum) {
            this.i = i;
            this.threadNum = threadNum;
        }

        @Override
        public void run() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    Log.d(TAG, &quot;在主线程中执行index：&quot; + i + &quot;,线程总数:&quot; + threadNum);
                    if(i % 2 == 0){
                        Log.d(TAG, &quot;TtsPlay1 index：&quot; + i);
                        TtsPlay1();
                    }
                    else{
                        Log.d(TAG, &quot;TtsPlay2 index：&quot; + i);
                        TtsPlay2();
                    }
                    try {
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });

        }

    }


    public class ttsPlayOne extends UtteranceProgressListener{

        @Override
        public void onStart(String utteranceId) {
            Log.d(TAG, &quot;ttsPlayOne-----------onStart&quot;);
        }

        @Override
        public void onDone(String utteranceId) {
            Log.d(TAG, &quot;ttsPlayOne-----------onDone&quot;);
        }

        @Override
        public void onError(String utteranceId) {
            Log.d(TAG, &quot;ttsPlayOne-----------onError&quot;);
        }
    }

    public class ttsPlaySecond extends  UtteranceProgressListener{

        @Override
        public void onStart(String utteranceId) {
            Log.d(TAG, &quot;ttsPlaySecond-----------onStart&quot;);
        }

        @Override
        public void onDone(String utteranceId) {
            Log.d(TAG, &quot;ttsPlaySecond-----------onDone&quot;);
        }

        @Override
        public void onError(String utteranceId) {
            Log.d(TAG, &quot;ttsPlaySecond-----------onError&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;加上权限&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;### TTS 最佳实践&lt;/p&gt;
&lt;p&gt;由于目前我在公司负责开发的产品是属于语音助手类型，自然这类 TTS 发声的问题和坑日常见的比较多。常见的有如下几种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统自带的 TTS 功能是不支持中文的，想要支持中文的话，需要借助第三方引擎，比如常见的科大讯飞、百度等。&lt;/li&gt;
&lt;li&gt;如果换成支持中文引擎的话，一旦输入的文本中有夹杂着英文，那么有时候第三方TTS引擎有时候就很不友好，有时候会把英文单词每个字母读出来，英文甚至是发音不了，这里就需要注意下引擎的测试。&lt;/li&gt;
&lt;li&gt;在设置 TTS 参数的时候，需要注意语速、音高、音调的上限值，有时候参数可能是0-100的范围，有时候有些参数是在0-10的范围，特别需要根据不同引擎参数的值类型去设定。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;### 使用趋势&lt;/p&gt;
&lt;p&gt;随着物联网的到来，IoT设备增多，那么对于类似语音助手相关应用也会增多，因为语音是一个很好的入口，现在逐步从显示到去显示的过程，很多智能设备有些是不需要屏幕的，只需要能识别语音和播放声音。因此，随着这类应用的增长，对于TTS 相关的API接口调用频率肯定也是加大，相信谷歌在这方面也会逐步在完善。&lt;/p&gt;
&lt;h2 id=&quot;内部设计维度&quot;&gt;内部设计维度&lt;/h2&gt;
&lt;p&gt;从外部使用角度入手，基本是熟悉API接口和具体项目中应用碰到的问题，然后不断总结出来比较优化的实践方式。了解完外部角度切入，那么我们需要里面内部设计是怎么一回事，毕竟作为一个开发者，知道具体实现原理是一个基本功。&lt;/p&gt;
&lt;h3 id=&quot;解决目标&quot;&gt;解决目标&lt;/h3&gt;
&lt;p&gt;Android TTS 目标就是解决文本转化为语音播报的过程。那它到底是怎么实现的呢，我们从TextToSpeech类的构造函数开始分析。&lt;/p&gt;
&lt;p&gt;这里我们用Android 6.0版本源码分析为主，主要涉及的相关类和接口文件，在源码中的位置如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;framework\base\core\java\android\speech\tts\TextToSpeech.java&lt;br/&gt;framework\base/core\java/android\speech\tts\TextToSpeechService.java&lt;br/&gt;external\svox\pico\src\com\svox\pico\PicoService.java&lt;br/&gt;external\svox\pico\compat\src\com\android\tts\compat\CompatTtsService.java&lt;br/&gt;external\svox\pico\compat\src\com\android\tts\compat\SynthProxy.java&lt;br/&gt;external\svox\pico\compat\jni\com_android_tts_compat_SynthProxy.cpp&lt;br/&gt;external\svox\pico\tts\com_svox_picottsengine.cpp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;初始化角度&lt;/strong&gt;：先看TextToSpeech类，在使用时，一般TextToSpeech类要进行初始化，它的构造函数有三个，最后真正调用的构造函数代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; /**
     * Used by the framework to instantiate TextToSpeech objects with a supplied
     * package name, instead of using {@link android.content.Context#getPackageName()}
     *
     * @hide
     */
    public TextToSpeech(Context context, OnInitListener listener, String engine,
            String packageName, boolean useFallback) {
        mContext = context;
        mInitListener = listener;
        mRequestedEngine = engine;
        mUseFallback = useFallback;

        mEarcons = new HashMap&amp;lt;String, Uri&amp;gt;();
        mUtterances = new HashMap&amp;lt;CharSequence, Uri&amp;gt;();
        mUtteranceProgressListener = null;

        mEnginesHelper = new TtsEngines(mContext);
        initTts();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从构造函数可以看到，调用到initTts操作，我们看下initTts方法里是什么东东，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private int initTts() {
        // Step 1: Try connecting to the engine that was requested.
        if (mRequestedEngine != null) {
            if (mEnginesHelper.isEngineInstalled(mRequestedEngine)) {
                if (connectToEngine(mRequestedEngine)) {
                    mCurrentEngine = mRequestedEngine;
                    return SUCCESS;
                } else if (!mUseFallback) {
                    mCurrentEngine = null;
                    dispatchOnInit(ERROR);
                    return ERROR;
                }
            } else if (!mUseFallback) {
                Log.i(TAG, &quot;Requested engine not installed: &quot; + mRequestedEngine);
                mCurrentEngine = null;
                dispatchOnInit(ERROR);
                return ERROR;
            }
        }

        // Step 2: Try connecting to the user's default engine.
        final String defaultEngine = getDefaultEngine();
        if (defaultEngine != null &amp;amp;&amp;amp; !defaultEngine.equals(mRequestedEngine)) {
            if (connectToEngine(defaultEngine)) {
                mCurrentEngine = defaultEngine;
                return SUCCESS;
            }
        }

        // Step 3: Try connecting to the highest ranked engine in the
        // system.
        final String highestRanked = mEnginesHelper.getHighestRankedEngineName();
        if (highestRanked != null &amp;amp;&amp;amp; !highestRanked.equals(mRequestedEngine) &amp;amp;&amp;amp;
                !highestRanked.equals(defaultEngine)) {
            if (connectToEngine(highestRanked)) {
                mCurrentEngine = highestRanked;
                return SUCCESS;
            }
        }

        // NOTE: The API currently does not allow the caller to query whether
        // they are actually connected to any engine. This might fail for various
        // reasons like if the user disables all her TTS engines.

        mCurrentEngine = null;
        dispatchOnInit(ERROR);
        return ERROR;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里比较有意思了，第一步先去连接用户请求的TTS引擎服务（这里可以让我们自定义TTS引擎，可以替换系统默认的引擎），如果没找到连接用户的TTS引擎，那么就去连接默认引擎，最后是连接高性能引擎，从代码可以看出高性能引擎优先级最高，默认引擎其次，connectToEngine方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private boolean connectToEngine(String engine) {
        Connection connection = new Connection();
        Intent intent = new Intent(Engine.INTENT_ACTION_TTS_SERVICE);
        intent.setPackage(engine);
        boolean bound = mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        if (!bound) {
            Log.e(TAG, &quot;Failed to bind to &quot; + engine);
            return false;
        } else {
            Log.i(TAG, &quot;Sucessfully bound to &quot; + engine);
            mConnectingServiceConnection = connection;
            return true;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的Engine.INTENT_ACTION_TTS_SERVICE的值为&quot;android.intent.action.TTS_SERVICE&quot;;其连接到的服务为action，为&quot;android.intent.action.TTS_SERVICE&quot;的服务，在external\svox\pico目录中的AndroidManifest.xml文件可以发现：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;service android:name=&quot;.PicoService&quot;
           android:label=&quot;@string/app_name&quot;&amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.TTS_SERVICE&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
            &amp;lt;meta-data android:name=&quot;android.speech.tts&quot; android:resource=&quot;@xml/tts_engine&quot; /&amp;gt;
  &amp;lt;/service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统自带的默认连接的服务叫做PicoService，其具体代码如下：其继承于CompatTtsService。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PicoService extends CompatTtsService {

    private static final String TAG = &quot;PicoService&quot;;
    
    @Override
    protected String getSoFilename() {
        return &quot;libttspico.so&quot;;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看看CompatTtsService这个类，这个类为抽象类，它的父类为TextToSpeechService,其有一个成员SynthProxy类，该类负责调用TTS的C++层代码。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201904/331079-20190430154434948-33360871.png&quot; alt=&quot;CompatTtsService代码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看CompatTtsService的onCreate()方法，该方法中主要对SynthProxy进行了初始化：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
    public void onCreate() {
        if (DBG) Log.d(TAG, &quot;onCreate()&quot;);

        String soFilename = getSoFilename();

        if (mNativeSynth != null) {
            mNativeSynth.stopSync();
            mNativeSynth.shutdown();
            mNativeSynth = null;
        }

        // Load the engineConfig from the plugin if it has any special configuration
        // to be loaded. By convention, if an engine wants the TTS framework to pass
        // in any configuration, it must put it into its content provider which has the URI:
        // content://&amp;lt;packageName&amp;gt;.providers.SettingsProvider
        // That content provider must provide a Cursor which returns the String that
        // is to be passed back to the native .so file for the plugin when getString(0) is
        // called on it.
        // Note that the TTS framework does not care what this String data is: it is something
        // that comes from the engine plugin and is consumed only by the engine plugin itself.
        String engineConfig = &quot;&quot;;
        Cursor c = getContentResolver().query(Uri.parse(&quot;content://&quot; + getPackageName()
                + &quot;.providers.SettingsProvider&quot;), null, null, null, null);
        if (c != null){
            c.moveToFirst();
            engineConfig = c.getString(0);
            c.close();
        }
        mNativeSynth = new SynthProxy(soFilename, engineConfig);

        // mNativeSynth is used by TextToSpeechService#onCreate so it must be set prior
        // to that call.
        // getContentResolver() is also moved prior to super.onCreate(), and it works
        // because the super method don't sets a field or value that affects getContentResolver();
        // (including the content resolver itself).
        super.onCreate();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;紧接着看看SynthProxy的构造函数都干了什么，我也不知道干了什么，但是里面有个静态代码块，其加载了ttscompat动态库，所以它肯定只是一个代理，实际功能由C++本地方法实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
     * Constructor; pass the location of the native TTS .so to use.
     */
    public SynthProxy(String nativeSoLib, String engineConfig) {
        boolean applyFilter = shouldApplyAudioFilter(nativeSoLib);
        Log.v(TAG, &quot;About to load &quot;+ nativeSoLib + &quot;, applyFilter=&quot; + applyFilter);
        mJniData = native_setup(nativeSoLib, engineConfig);
        if (mJniData == 0) {
            throw new RuntimeException(&quot;Failed to load &quot; + nativeSoLib);
        }
        native_setLowShelf(applyFilter, PICO_FILTER_GAIN, PICO_FILTER_LOWSHELF_ATTENUATION,
                PICO_FILTER_TRANSITION_FREQ, PICO_FILTER_SHELF_SLOPE);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，在构造函数中，调用了native_setup方法来初始化引擎，其实现在C++层(com_android_tts_compat_SynthProxy.cpp)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201904/331079-20190430154531015-798715478.png&quot; alt=&quot;nativeSetup代码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到ngine-&amp;gt;funcs-&amp;gt;init(engine, __ttsSynthDoneCB, engConfigString);这句代码比较关键，这个init方法上面在com_svox_picottsengine.cpp中，如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/* Google Engine API function implementations */

/** init
 *  Allocates Pico memory block and initializes the Pico system.
 *  synthDoneCBPtr - Pointer to callback function which will receive generated samples
 *  config - the engine configuration parameters, here only contains the non-system path
 *      for the lingware location
 *  return tts_result
*/
tts_result TtsEngine::init( synthDoneCB_t synthDoneCBPtr, const char *config )
{
    if (synthDoneCBPtr == NULL) {
        ALOGE(&quot;Callback pointer is NULL&quot;);
        return TTS_FAILURE;
    }

    picoMemArea = malloc( PICO_MEM_SIZE );
    if (!picoMemArea) {
        ALOGE(&quot;Failed to allocate memory for Pico system&quot;);
        return TTS_FAILURE;
    }

    pico_Status ret = pico_initialize( picoMemArea, PICO_MEM_SIZE, &amp;amp;picoSystem );
    if (PICO_OK != ret) {
        ALOGE(&quot;Failed to initialize Pico system&quot;);
        free( picoMemArea );
        picoMemArea = NULL;
        return TTS_FAILURE;
    }

    picoSynthDoneCBPtr = synthDoneCBPtr;

    picoCurrentLangIndex = -1;

    // was the initialization given an alternative path for the lingware location?
    if ((config != NULL) &amp;amp;&amp;amp; (strlen(config) &amp;gt; 0)) {
        pico_alt_lingware_path = (char*)malloc(strlen(config));
        strcpy((char*)pico_alt_lingware_path, config);
        ALOGV(&quot;Alternative lingware path %s&quot;, pico_alt_lingware_path);
    } else {
        pico_alt_lingware_path = (char*)malloc(strlen(PICO_LINGWARE_PATH) + 1);
        strcpy((char*)pico_alt_lingware_path, PICO_LINGWARE_PATH);
        ALOGV(&quot;Using predefined lingware path %s&quot;, pico_alt_lingware_path);
    }

    return TTS_SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，TTS引擎的初始化就完成了。&lt;/p&gt;
&lt;p&gt;再看下&lt;strong&gt;TTS调用的角度&lt;/strong&gt;，一般TTS调用的类是TextToSpeech中的speak()方法，我们来看看其执行流程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public int speak(final CharSequence text,
                     final int queueMode,
                     final Bundle params,
                     final String utteranceId) {
        return runAction(new Action&amp;lt;Integer&amp;gt;() {
            @Override
            public Integer run(ITextToSpeechService service) throws RemoteException {
                Uri utteranceUri = mUtterances.get(text);
                if (utteranceUri != null) {
                    return service.playAudio(getCallerIdentity(), utteranceUri, queueMode,
                            getParams(params), utteranceId);
                } else {
                    return service.speak(getCallerIdentity(), text, queueMode, getParams(params),
                            utteranceId);
                }
            }
        }, ERROR, &quot;speak&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是看runAction()方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private &amp;lt;R&amp;gt; R runAction(Action&amp;lt;R&amp;gt; action, R errorResult, String method,
            boolean reconnect, boolean onlyEstablishedConnection) {
        synchronized (mStartLock) {
            if (mServiceConnection == null) {
                Log.w(TAG, method + &quot; failed: not bound to TTS engine&quot;);
                return errorResult;
            }
            return mServiceConnection.runAction(action, errorResult, method, reconnect,
                    onlyEstablishedConnection);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要看下mServiceConnection类的runAction方法，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;R&amp;gt; R runAction(Action&amp;lt;R&amp;gt; action, R errorResult, String method,
                boolean reconnect, boolean onlyEstablishedConnection) {
            synchronized (mStartLock) {
                try {
                    if (mService == null) {
                        Log.w(TAG, method + &quot; failed: not connected to TTS engine&quot;);
                        return errorResult;
                    }
                    if (onlyEstablishedConnection &amp;amp;&amp;amp; !isEstablished()) {
                        Log.w(TAG, method + &quot; failed: TTS engine connection not fully set up&quot;);
                        return errorResult;
                    }
                    return action.run(mService);
                } catch (RemoteException ex) {
                    Log.e(TAG, method + &quot; failed&quot;, ex);
                    if (reconnect) {
                        disconnect();
                        initTts();
                    }
                    return errorResult;
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现最后会回调action.run(mService)方法。接着执行service.playAudio()，这里的service为PicoService，其继承于抽象类CompatTtsService，而CompatTtsService继承于抽象类TextToSpeechService。&lt;/p&gt;
&lt;p&gt;所以会执行TextToSpeechService中的playAudio()，该方法位于TextToSpeechService中mBinder中。该方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
        public int playAudio(IBinder caller, Uri audioUri, int queueMode, Bundle params,
                String utteranceId) {
            if (!checkNonNull(caller, audioUri, params)) {
                return TextToSpeech.ERROR;
            }

            SpeechItem item = new AudioSpeechItemV1(caller,
                    Binder.getCallingUid(), Binder.getCallingPid(), params, utteranceId, audioUri);
            return mSynthHandler.enqueueSpeechItem(queueMode, item);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着执行mSynthHandler.enqueueSpeechItem(queueMode, item),其代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
         * Adds a speech item to the queue.
         *
         * Called on a service binder thread.
         */
        public int enqueueSpeechItem(int queueMode, final SpeechItem speechItem) {
            UtteranceProgressDispatcher utterenceProgress = null;
            if (speechItem instanceof UtteranceProgressDispatcher) {
                utterenceProgress = (UtteranceProgressDispatcher) speechItem;
            }

            if (!speechItem.isValid()) {
                if (utterenceProgress != null) {
                    utterenceProgress.dispatchOnError(
                            TextToSpeech.ERROR_INVALID_REQUEST);
                }
                return TextToSpeech.ERROR;
            }

            if (queueMode == TextToSpeech.QUEUE_FLUSH) {
                stopForApp(speechItem.getCallerIdentity());
            } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
                stopAll();
            }
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    if (isFlushed(speechItem)) {
                        speechItem.stop();
                    } else {
                        setCurrentSpeechItem(speechItem);
                        speechItem.play();
                        setCurrentSpeechItem(null);
                    }
                }
            };
            Message msg = Message.obtain(this, runnable);

            // The obj is used to remove all callbacks from the given app in
            // stopForApp(String).
            //
            // Note that this string is interned, so the == comparison works.
            msg.obj = speechItem.getCallerIdentity();

            if (sendMessage(msg)) {
                return TextToSpeech.SUCCESS;
            } else {
                Log.w(TAG, &quot;SynthThread has quit&quot;);
                if (utterenceProgress != null) {
                    utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
                }
                return TextToSpeech.ERROR;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是看 speechItem.play()方法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
         * Plays the speech item. Blocks until playback is finished.
         * Must not be called more than once.
         *
         * Only called on the synthesis thread.
         */
        public void play() {
            synchronized (this) {
                if (mStarted) {
                    throw new IllegalStateException(&quot;play() called twice&quot;);
                }
                mStarted = true;
            }
            playImpl();
        }

        protected abstract void playImpl();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到主要播放实现方法为playImpl()，那么在TextToSpeechService中的playAudio()中代码可以知道这里的speechitem为SynthesisSpeechItemV1。&lt;/p&gt;
&lt;p&gt;因此在play中执行的playimpl()方法为SynthesisSpeechItemV1类中的playimpl()方法，其代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
        protected void playImpl() {
            AbstractSynthesisCallback synthesisCallback;
            mEventLogger.onRequestProcessingStart();
            synchronized (this) {
                // stop() might have been called before we enter this
                // synchronized block.
                if (isStopped()) {
                    return;
                }
                mSynthesisCallback = createSynthesisCallback();
                synthesisCallback = mSynthesisCallback;
            }

            TextToSpeechService.this.onSynthesizeText(mSynthesisRequest, synthesisCallback);

            // Fix for case where client called .start() &amp;amp; .error(), but did not called .done()
            if (synthesisCallback.hasStarted() &amp;amp;&amp;amp; !synthesisCallback.hasFinished()) {
                synthesisCallback.done();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在playImpl方法中会执行onSynthesizeText方法，这是个抽象方法，记住其传递了一个synthesisCallback，后面会讲到。哪该方法具体实现是在哪里呢，没错，就是在TextToSpeechService的子类CompatTtsService中。来看看它怎么实现的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
    protected void onSynthesizeText(SynthesisRequest request, SynthesisCallback callback) {
        if (mNativeSynth == null) {
            callback.error();
            return;
        }

        // Set language
        String lang = request.getLanguage();
        String country = request.getCountry();
        String variant = request.getVariant();
        if (mNativeSynth.setLanguage(lang, country, variant) != TextToSpeech.SUCCESS) {
            Log.e(TAG, &quot;setLanguage(&quot; + lang + &quot;,&quot; + country + &quot;,&quot; + variant + &quot;) failed&quot;);
            callback.error();
            return;
        }

        // Set speech rate
        int speechRate = request.getSpeechRate();
        if (mNativeSynth.setSpeechRate(speechRate) != TextToSpeech.SUCCESS) {
            Log.e(TAG, &quot;setSpeechRate(&quot; + speechRate + &quot;) failed&quot;);
            callback.error();
            return;
        }

        // Set speech
        int pitch = request.getPitch();
        if (mNativeSynth.setPitch(pitch) != TextToSpeech.SUCCESS) {
            Log.e(TAG, &quot;setPitch(&quot; + pitch + &quot;) failed&quot;);
            callback.error();
            return;
        }

        // Synthesize
        if (mNativeSynth.speak(request, callback) != TextToSpeech.SUCCESS) {
            callback.error();
            return;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终又回到系统提供的pico引擎中，在com_android_tts_compat_SynthProxy.cpp这个文件中，可以看到使用speak方法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static jint
com_android_tts_compat_SynthProxy_speak(JNIEnv *env, jobject thiz, jlong jniData,
        jstring textJavaString, jobject request)
{
    SynthProxyJniStorage* pSynthData = getSynthData(jniData);
    if (pSynthData == NULL) {
        return ANDROID_TTS_FAILURE;
    }

    initializeFilter();

    Mutex::Autolock l(engineMutex);

    android_tts_engine_t *engine = pSynthData-&amp;gt;mEngine;
    if (!engine) {
        return ANDROID_TTS_FAILURE;
    }

    SynthRequestData *pRequestData = new SynthRequestData;
    pRequestData-&amp;gt;jniStorage = pSynthData;
    pRequestData-&amp;gt;env = env;
    pRequestData-&amp;gt;request = env-&amp;gt;NewGlobalRef(request);
    pRequestData-&amp;gt;startCalled = false;

    const char *textNativeString = env-&amp;gt;GetStringUTFChars(textJavaString, 0);
    memset(pSynthData-&amp;gt;mBuffer, 0, pSynthData-&amp;gt;mBufferSize);

    int result = engine-&amp;gt;funcs-&amp;gt;synthesizeText(engine, textNativeString,
            pSynthData-&amp;gt;mBuffer, pSynthData-&amp;gt;mBufferSize, static_cast&amp;lt;void *&amp;gt;(pRequestData));
    env-&amp;gt;ReleaseStringUTFChars(textJavaString, textNativeString);

    return (jint) result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，TTS的调用就结束了。&lt;/p&gt;
&lt;h3 id=&quot;tts-优劣势&quot;&gt;TTS 优劣势&lt;/h3&gt;
&lt;p&gt;从实现原理我们可以看到Android系统原生自带了一个TTS引擎。那么在此，我们就也可以去自定义TTS引擎，只有继承ITextToSpeechService接口即可，实现里面的方法。这就为后续自定义TTS引擎埋下伏笔了，因为系统默认的TTS引擎是不支持中文，那么市场上比较好的TTS相关产品，一般是集成讯飞或者Nuance等第三方供应商。&lt;/p&gt;
&lt;p&gt;因此，我们也可以看到TTS优劣势：&lt;/p&gt;
&lt;p&gt;优势：接口定义完善，有着完整的API接口方法，同时支持扩展，可根据自身开发业务需求重新打造TTS引擎，并且与原生接口做兼容，可适配。&lt;/p&gt;
&lt;p&gt;劣势：原生系统TTS引擎支持的多国语言有限，目前不支持多实例和多通道。&lt;/p&gt;
&lt;h3 id=&quot;演进趋势&quot;&gt;演进趋势&lt;/h3&gt;
&lt;p&gt;从目前来看，随着语音成为更多Iot设备的入口，那么在语音TTS合成播报方面技术会越来越成熟，特别是对于Android 系统原生相关的接口也会越来越强大。因此，对于TTS后续的发展，应该是冉冉上升。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;总的来说，对于一个知识点，前期通过使用文档介绍，到具体实践，然后在实践中优化进行总结，选择一个最佳的实践方案。当然不能满足“知其然而不知其所以然”，所以得去看背后的实现原理是什么。这个知识点优劣势是什么，在哪些场景比较适用，哪些场景不适用，接下来会演进趋势怎么样。通过这么一整套流程，那么对于一个知识点来说，可以算是了然于胸了。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 07:46:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<og:description>随着从事 Android 开发年限增加，负责的工作项目也从应用层开发逐步过渡到 Android Framework 层开发。虽然一开始就知道 Android 知识体系的庞大，但是当你逐渐从 Appli</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/10796420.html</dc:identifier>
</item>
<item>
<title>【小程序】使用模板消息发送消息给多个用户 - HsuHung</title>
<link>http://www.cnblogs.com/hsuhung/p/10792290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hsuhung/p/10792290.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用模板消息发送消息给多个用户&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、需求背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发，通过微信聊天列表中的服务通知可快捷进入查看消息，点击查看详情还能跳转到下发消息的小程序的指定页面。&lt;/p&gt;
&lt;p&gt;　　微信小程序允许下发模板消息的条件分为两类：支付或者提交表单。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下条数独立，相互不影响）”。&lt;/p&gt;

&lt;p&gt;　　然而，用户1次触发7天内推送1条通知是明显不够用的。比如，签到功能利用模板消息的推送来提醒用户每天签到，只能在用户前一天签到的情况下，获取一次推送模板消息的机会，然后用于第二天向该用户发送签到提醒。但是很多情况下，用户在某一天忘记签到，系统便失去了提醒用户的权限，导致和用户断开了联系；再比如，系统想主动告知用户即将做某活动，然而由于微信小程序被动触发通知的限制，系统将无法主动推送消息。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、如何突破模板消息的推送限制？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;　&lt;/span&gt;为了突破模板消息的推送限制，实现7天内任性推送，只需收集到足够的推送码，即每次提交表单时获取到的formId。一个formId代表着开发者有向当前用户推送模板消息的一次权限。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;三、实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.收集推送码。获取多个表单id并保存，便于一次性发送给服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　// 收集推送码&lt;br/&gt;　　Page({&lt;br/&gt;　　　　formSubmit: funcition(e) {//form表单按钮点击调用该方法&lt;br/&gt;　　　　　　let formId = e.detail.formId; //获取表单formId&lt;br/&gt;　　　　　　this.collectFormIds(formId); //保存推送码&lt;br/&gt;　　　　　　let type = e.detail.target.dataset.type; // 根据type执行点击事件&lt;br/&gt;　　　　},&lt;/p&gt;
&lt;p&gt;　　　　collectFormIds: function(formId) { //保存推送码&lt;br/&gt;　　　　　　let formIds = app.globalData.globalFormIds; // 获取全局推送码数组&lt;br/&gt;　　　　　　if (!formIds)&lt;br/&gt;　　　　　　　　formIds = [];&lt;br/&gt;　　　　　　let data = {&lt;br/&gt;　　　　　　　　formId: formId,&lt;br/&gt;　　　　　　　　expire: new Data().getTime() + 60480000 // 7天后的过期时间戳&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　formIds.push(data);&lt;br/&gt;　　　　　　app.globalData.globalFormIds = formIds;&lt;br/&gt;　　　　　　},&lt;br/&gt;　　　　})&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.上传推送码。即将推送码发送给服务器然后保存起来(需要上传的数据：formId和openId&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　// 上报推送码&lt;br/&gt;　　　　Page({&lt;br/&gt;　　　　　　onLoad: funcition(e) {&lt;br/&gt;　　　　　　this.uploadFormIds(); //上传推送码&lt;br/&gt;　　　　},&lt;/p&gt;
&lt;p&gt;　　　　collectFormIds: function(formId) {&lt;br/&gt;　　　　　　var formIds = app.globalData.globalFormIds; // 获取全局推送码&lt;br/&gt;　　　　　　if (formIds.length) {&lt;br/&gt;　　　　　　　　formIds = JSON.stringify(formIds); // 转换成JSON字符串&lt;br/&gt;　　　　　　　　app.globalData.gloabalFomIds = ''; // 清空当前全局推送码&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　wx.request({ // 发送到服务器&lt;br/&gt;　　　　　　　　url: 'http://xxx',&lt;br/&gt;　　　　　　　　method: 'POST',&lt;br/&gt;　　　　　　　　data: {&lt;br/&gt;　　　　　　　　　　openId: 'openId',//openId为小程序的用户唯一标识，需自行获取&lt;br/&gt;　　　　　　　　　　formIds: formIds//表单id&lt;br/&gt;　　　　　　　　},&lt;br/&gt;　　　　　　　　success: function(res) {&lt;br/&gt;　　　　　　　　　　}&lt;br/&gt;　　　　　　　　});&lt;br/&gt;　　　　　　},&lt;br/&gt;　　　　})&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.服务端-存储推送码（&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;高频IO，采用Redis来存储推送码。将推送码保存到数据库实现持久化存储，由于formId有七天有效期，所以需要定时清理无效推送码）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　/**&lt;br/&gt;　　　　* 收集用户推送码&lt;br/&gt;　　　　*&lt;br/&gt;　　　　* @param openId   用户的openid&lt;br/&gt;　　　　* @param formIds  用户的formId&lt;br/&gt;　　　　*/&lt;br/&gt;　　　　public void collect(String openId, List&amp;lt;FormTemplateVO&amp;gt; formTemplates) {&lt;br/&gt;　　　　　　redisTemplate.opsForList().rightPushAll(openId, formIds);&lt;br/&gt;　　　　}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.发送模板消息相关接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　相关接口详细信息请查看官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api-backend/&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/api-backend/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　需要使用的接口：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　&lt;strong&gt;1&amp;gt;&lt;/strong&gt;模板消息发送api：POST https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESS_TOKEN&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;　　要想使用该接口发送模板消息，还需要获取 &lt;/code&gt;&lt;code&gt;ACCESS_TOKEN 即接口调用凭证&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549943/201904/1549943-20190430150726332-403255556.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;569&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;&lt;strong&gt;2&amp;gt;&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;接口调用凭证&lt;/code&gt;&lt;code&gt;api：&lt;/code&gt;&lt;code&gt;GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=APPID&amp;amp;secret=APPSECRET&lt;br/&gt;获取接口调用凭证需要appid和secret&lt;br/&gt;appid：小程序唯一标识&lt;br/&gt;&lt;/code&gt;&lt;code&gt;secret：小程序唯一凭证密钥&lt;br/&gt;appid和secret获取方式请查看：&lt;a href=&quot;https://jingyan.baidu.com/article/8cdccae9221703315513cd6e.html&quot;&gt;https://jingyan.baidu.com/article/8cdccae9221703315513cd6e.html&lt;/a&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549943/201904/1549943-20190430151058849-1590849932.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;696&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;pre readability=&quot;4.3811881188119&quot;&gt;
&lt;code readability=&quot;3.5049504950495&quot;&gt;&lt;strong&gt;5.推送模板消息。发送消息给用户&lt;/strong&gt;&lt;p&gt;templateId消息模板id：自行登录&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;https://mp.weixin.qq.com/&lt;/a&gt;获取&lt;/p&gt;&lt;p&gt;以下两个方法只是部分代码，调用sendTemplateMessage方法即可发送消息&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　/**&lt;br/&gt;　　* 发送模板消息&lt;br/&gt;　　*&lt;br/&gt;　　* @param accessToken 接口调用凭证&lt;br/&gt;　　* @param touser 接收者（用户）的 openid&lt;br/&gt;　　* @param templateId 所需下发的模板消息的id&lt;br/&gt;　　* @param page 点击模板卡片后的跳转页面，仅限本小程序内的页面。支持带参数,（示例index?foo=bar）。该字段不填则模板无跳转&lt;br/&gt;　　* @param formId 表单提交场景下，为 submit 事件带上的 formId；支付场景下，为本次支付的 prepay_id&lt;br/&gt;　　* @param data 模板内容，不填则下发空模板。具体格式请参考示例。&lt;br/&gt;　　* @param emphasisKeyword 模板需要放大的关键词，不填则默认无放大&lt;br/&gt;　　*/&lt;br/&gt;　　public WxResSendTemplateMessage sendTemplateMessage(String accessToken, String touser, String templateId, String page, String formId, Map&amp;lt;String, Object&amp;gt; data, String 　　　　　　emphasisKeyword) {&lt;/p&gt;&lt;p&gt;　　　　/**&lt;br/&gt;　　　　* data示例:&lt;br/&gt;　　　　*&lt;br/&gt;　　　　* &quot;data&quot;: {&lt;br/&gt;　　　　* &quot;keyword1&quot;: { &quot;value&quot;: title, &quot;color&quot;: &quot;#173177&quot; },&lt;br/&gt;　　　　* &quot;keyword2&quot;: { &quot;value&quot;: gettime() }&lt;br/&gt;　　　　* }&lt;br/&gt;　　　　* emphasisKeyword示例:&lt;br/&gt;　　　　* &quot;emphasis_keyword&quot;: &quot;keyword1.DATA&quot;&lt;br/&gt;　　　　*&lt;br/&gt;　　　　*/&lt;/p&gt;&lt;p&gt;　　　　/** 结果 */&lt;br/&gt;　　　　String result = &quot;&quot;;&lt;br/&gt;　　　　/** 获取输出流 */&lt;br/&gt;　　　　OutputStreamWriter os = null;&lt;br/&gt;　　　　/** 获取输入流 */&lt;br/&gt;　　　　BufferedReader in = null;&lt;/p&gt;&lt;p&gt;　　　　/** 请求地址 */&lt;br/&gt;　　　　String urlPath = &quot;https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=&quot; + accessToken;&lt;/p&gt;
&lt;p&gt;　　　　/** 需要传递的数据 */&lt;br/&gt;　　　　Map&amp;lt;String, Object&amp;gt; messageData = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;　　　　messageData.put(&quot;touser&quot;, touser);//接收者（用户）的 openid&lt;br/&gt;　　　　messageData.put(&quot;template_id&quot;, templateId);//所需下发的模板消息的id&lt;br/&gt;　　　　messageData.put(&quot;page&quot;, page);//点击模板卡片后的跳转页面，仅限本小程序内的页面。支持带参数,（示例index?foo=bar）。该字段不填则模板无跳转&lt;br/&gt;　　　　messageData.put(&quot;form_id&quot;, formId);//表单提交场景下，为 submit 事件带上的 formId；支付场景下，为本次支付的 prepay_id&lt;br/&gt;　　　　messageData.put(&quot;data&quot;, data);//模板内容，不填则下发空模板。具体格式请参考示例。&lt;br/&gt;　　　　messageData.put(&quot;emphasis_keyword&quot;, emphasisKeyword);//模板需要放大的关键词，不填则默认无放大&lt;/p&gt;&lt;p&gt;　　　　try {&lt;br/&gt;　　　　　　/** 获得url对象 */&lt;br/&gt;　　　　　　URL url = new URL(urlPath);&lt;/p&gt;&lt;p&gt;　　　　　　/** 打开连接 */&lt;br/&gt;　　　　　　HttpURLConnection conn = (HttpURLConnection) url.openConnection();&lt;/p&gt;&lt;p&gt;　　　　　　/** 设置通用的请求属性 */&lt;br/&gt;　　　　　　conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);&lt;br/&gt;　　　　　　conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);&lt;br/&gt;　　　　　　conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);&lt;br/&gt;　　　　　　conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);&lt;/p&gt;&lt;p&gt;　　　　　　/** 设置请求方式 */&lt;br/&gt;　　　　　　conn.setRequestMethod(Http.HttpMethod.POST.name());&lt;/p&gt;&lt;p&gt;　　　　　　/** 设置允许读写出数据,默认可以读不可写 */&lt;br/&gt;　　　　　　conn.setDoOutput(true);&lt;br/&gt;　　　　　　conn.setDoInput(true);&lt;/p&gt;&lt;p&gt;　　　　　　/** 获取输出流 */&lt;br/&gt;　　　　　　os = new OutputStreamWriter(conn.getOutputStream(), &quot;UTF-8&quot;);&lt;/p&gt;&lt;p&gt;　　　　　　/** 发送请求参数 */&lt;br/&gt;　　　　　　os.write(JsonMapper.toJsonString(messageData));&lt;/p&gt;&lt;p&gt;　　　　　　/** 输出缓存流 */&lt;br/&gt;　　　　　　os.flush();&lt;/p&gt;&lt;p&gt;　　　　　　/** 获取输入流 */&lt;br/&gt;　　　　　　in = new BufferedReader(new InputStreamReader(conn.getInputStream()));&lt;/p&gt;&lt;p&gt;　　　　　　/** 接收行数据 */&lt;br/&gt;　　　　　　String line;&lt;/p&gt;&lt;p&gt;　　　　　　/** 读取数据 */&lt;br/&gt;　　　　　　while((line = in.readLine()) != null) {&lt;br/&gt;　　　　　　　　result += line;&lt;br/&gt;　　　　　　}&lt;/p&gt;&lt;p&gt;　　　　} catch(Exception e) {&lt;br/&gt;　　　　　　e.printStackTrace();&lt;br/&gt;　　　　} finally {/** 释放输入输出流并关闭 */&lt;br/&gt;　　　　try {&lt;br/&gt;　　　　　　if(os != null) {&lt;br/&gt;　　　　　　　　os.close();&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　if(in != null) {&lt;br/&gt;　　　　　　　　in.close();&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　} catch (Exception e) {&lt;br/&gt;　　　　　　　e.printStackTrace();&lt;br/&gt;　　　　　}&lt;br/&gt;　　　　}&lt;/p&gt;&lt;p&gt;　　　　logger.error(&quot;&amp;gt;&amp;gt;&amp;gt;模板消息发送&amp;gt;&amp;gt;&amp;gt;result={}&amp;gt;&amp;gt;&amp;gt;&quot;, result);&lt;/p&gt;&lt;p&gt;　　　　return (WxResSendTemplateMessage) JsonMapper.fromJsonString(result, WxResSendTemplateMessage.class);&lt;br/&gt;　　}&lt;/p&gt;

&lt;p&gt;　　　　/**&lt;br/&gt;　　　　* 获取小程序全局唯一后台接口调用凭据（access_token）&lt;br/&gt;　　　　*&lt;br/&gt;　　　　* @param appId 小程序唯一凭证&lt;br/&gt;　　　　* @param secret 小程序唯一凭证密钥&lt;br/&gt;　　　　* @return&lt;br/&gt;　　　　* @throws BusinessException&lt;br/&gt;　　　　*/&lt;br/&gt;　　　　public WxResAccessToken getAccessToken(String appId, String secret) throws BusinessException {&lt;/p&gt;&lt;p&gt;　　　　　　String requestUrl = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=&quot; + appId + &quot;&amp;amp;secret=&quot; + secret;&lt;/p&gt;&lt;p&gt;　　　　　　String res = HttpUtils.get(requestUrl, HttpContentType.CONTENT_TYPE_FORM_DATA, null, null);&lt;/p&gt;&lt;p&gt;　　　　　　if (StringUtils.isBlank(res)) {&lt;br/&gt;　　　　　　　　throw BusinessException.create(&quot;获取信息失败！&quot;);&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　try {&lt;br/&gt;　　　　　　　　res = new String(res.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);&lt;br/&gt;　　　　　　} catch (UnsupportedEncodingException e) {&lt;br/&gt;　　　　　　　　e.printStackTrace();&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　Map&amp;lt;String, Object&amp;gt; map = JsonUtils.unPackMap(res, String.class, Object.class);&lt;/p&gt;
&lt;p&gt;　　　　　　if (map == null) {&lt;br/&gt;　　　　　　　　throw BusinessException.create(&quot;获取信息失败！&quot;);&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　if (map.containsKey(&quot;errcode&quot;)) {&lt;br/&gt;　　　　　　　　throw BusinessException.create(String.valueOf(map.get(&quot;errmsg&quot;)));&lt;br/&gt;　　　　　　}&lt;/p&gt;&lt;p&gt;　　　　　　WxResAccessToken out = new WxResAccessToken();&lt;br/&gt;　　　　　　/** 获取到的凭证 */&lt;br/&gt;　　　　　　out.setAccessToken(String.valueOf(map.get(&quot;access_token&quot;)));&lt;br/&gt;　　　　　　/** 凭证有效时间，单位：秒。目前是7200秒之内的值 */&lt;br/&gt;　　　　　　if(map.get(&quot;expires_in&quot;) != null) {&lt;br/&gt;　　　　　　　　out.setExpiresIn(BaseUtils.getLong(String.valueOf(map.get(&quot;expires_in&quot;))));&lt;br/&gt;　　　　　　}else {&lt;br/&gt;　　　　　　　　out.setExpiresIn(0L);&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　/** 错误码 */&lt;br/&gt;　　　　　　if(map.get(&quot;errcode&quot;) != null) {&lt;br/&gt;　　　　　　　　out.setErrcode(BaseUtils.getLong(String.valueOf(map.get(&quot;errcode&quot;))));&lt;br/&gt;　　　　　　}else {&lt;br/&gt;　　　　　　　　out.setErrcode(0L);&lt;br/&gt;　　　　　　}&lt;br/&gt;　　　　　　/** 错误信息 */&lt;br/&gt;　　　　　　out.setErrmsg(String.valueOf(map.get(&quot;errmsg&quot;)));&lt;/p&gt;&lt;p&gt;　　　　　　return out;&lt;br/&gt;　　　　}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;openid、secret 、appid必须成套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板消息内容的json字符串需严格按官方给出的格式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/e9641aabb051&quot;&gt;https://www.jianshu.com/p/e9641aabb051&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/rolan1993/article/details/79398362&quot;&gt;https://blog.csdn.net/rolan1993/article/details/79398362&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/xcrow/article/details/37731719&quot;&gt;https://blog.csdn.net/xcrow/article/details/37731719&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 07:43:00 +0000</pubDate>
<dc:creator>HsuHung</dc:creator>
<og:description>使用模板消息发送消息给多个用户 一、需求背景 基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发，通过微信聊天列表中的服务通知可快捷进入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hsuhung/p/10792290.html</dc:identifier>
</item>
<item>
<title>详解Go语言中的屏蔽现象 - u#vitamin</title>
<link>http://www.cnblogs.com/u-vitamin/p/10793554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/u-vitamin/p/10793554.html</guid>
<description>&lt;p&gt;在刚开始学习Go语言的过程中，难免会遇到一些问题，尤其是从其他语言转向Go开发的人员，面对语法及其内部实现的差异，在使用Go开发时也避免不了会踩“坑”。本文主要针对Go设计中的屏蔽现象进行详细的说明，我主要从变量屏蔽和方法屏蔽的角度去分析Go中的屏蔽现象。&lt;/p&gt;
&lt;h2 id=&quot;程序实体的作用域&quot;&gt;程序实体的作用域&lt;/h2&gt;
&lt;p&gt;在开始分析变量的屏蔽之前，我们先来理解一下Go语言中的作用域，Go语言的作用域决定了一个程序实体可以被访问的范围。在Go语言的组织架构中，程序实体被层层嵌套的代码块包裹，正是这些代码块决定了程序实体的访问权限，Go 语言中程序实体的访问权限主要体现三种形式：包级别私有，模块级别私有(internal)以及公开的访问权限。包级别私有和模块级别私有对应的是代码包代码块，而公开的访问权限则是对应全域代码块。然而更细粒度的权限控制代码块还体现在函数，循环体内等。在Go语言层面其实就是依据代码块对程序实体作用域进行的定义。&lt;/p&gt;
&lt;h2 id=&quot;变量的屏蔽现象&quot;&gt;变量的屏蔽现象&lt;/h2&gt;
&lt;p&gt;根据对作用域的理解，程序实体的访问权限由代码块控制，变量也属于程序实体, 嵌套的代码块导致变量出现被屏蔽的现象。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

var name = struct{}{}

func main() {
    name := &quot;vitamin &quot;
    {
        name := 0
        fmt.Println(name)
    }
    fmt.Println(name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/BsXg1gHoQgM&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;main包中的name变量被main函数中的同名变量“屏蔽”，而main函数中的name变量又被子代码块内部的声明的同名变量所“屏蔽”，而且这里的同名变量类型可以不同。为什么会出现这种“屏蔽”现象？其实这也暗示了Go语言变量的查找过程，当然这个过程并不限制于变量，而是适用于所有程序实体。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;程序实体总是优先查找当前所在的代码块，如果当前代码块内查找不到该程序实体的定义则会根据嵌套关系直接向嵌套该代码块的内部查找，循环往复，直到在当前代码块所属的包内查找，如果包内仍然找不到该变量的定义，程序就会出现编译错误。&lt;br/&gt;但是在这里有一个特殊情况：通过&lt;code&gt;import .&lt;/code&gt; 的方式静态导入的代码包，会将导入的代码包内公开的程序实体当作是当前源码文件的程序实体。这样在当前源码文件内查找不到程序实体的定义后，会在该代码包中查找，若仍然查到不到，才会去该源码文件所在的代码包中去查找。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;方法的屏蔽现象&quot;&gt;方法的屏蔽现象&lt;/h2&gt;
&lt;p&gt;在Go语言中方法是定义在某个自定义数据类型(不能是接口类型)上的特殊函数，那在方法的定义上会不会出现和变量一样的“屏蔽”现象呢，让我们以结构体为例看几个例子&lt;/p&gt;
&lt;h3 id=&quot;在结构体内定义同名的字段和方法&quot;&gt;在结构体内定义同名的字段和方法&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct{
    FightWay string 
}

func(c Superhero) FightWay()string{
    return c.FightWay
}

func main() {
    s:=Superhero{}
    fmt.Println(s.FightWay)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/MJNB6HaaK4s&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后我们会看到这样的编译错误: &quot;type Superhero has both field and method named FightWay&quot;，这也直接的说明了在结构体内部是不允许出现这种定义方式的，所以也根本不存在“屏蔽”的现象。&lt;/p&gt;
&lt;h3 id=&quot;在结构体内定义同名但不同签名的方法&quot;&gt;在结构体内定义同名但不同签名的方法&lt;/h3&gt;
&lt;p&gt;在某些编程语言中，这种定义方式可能叫做“重载”，是实现面向对象中多态的一种表现形式，那么在Go语言中又会是怎么样呢？&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct{
    FightWay string 
}

func(c Superhero) FightWay()string{
    return c.FightWay
}

func(c *Superhero) FightWay(way string){
     c.FightWay = way
}

func main() {
    s:=Superhero{}
    fmt.Println(s.FightWay())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/0goktPavSdf&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后编译出现错误: &quot;type Superhero has both field and method named FightWay&quot;，看来这种定义方式在Go语言中也是不允许的，所以也不存在“屏蔽”的现象。&lt;/p&gt;
&lt;h3 id=&quot;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名的属性&quot;&gt;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名的属性&lt;/h3&gt;
&lt;p&gt;在Go语言中并不存在继承的概念，而是以一种更加灵活地方式：组合类型(内嵌类型)，来实现对多个结构体之间的组合，并将内嵌类型的属性和方法嫁接到了组合类型，避免了继承这种关系导致结构体之间的强依赖和繁琐的多重继承问题。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
    FightWay string
}

type Ironman struct {
    FightWay string
    Superhero
}

func main() {
    i:=Ironman{ FightWay: &quot;Steel Armor&quot;, Superhero:Superhero{ &quot;The Avengers&quot; }}
    fmt.Println(i.FightWay)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/frP0nc9hqX7&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;由输出结果可以看到组合的结构体(Ironman)内的 FightWay 属性“屏蔽”了被内嵌类型(Superhero)的同名属性&lt;/p&gt;
&lt;h3 id=&quot;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名的属性和方法&quot;&gt;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名的属性和方法&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
    FightWay string
}

type Ironman struct {
    Superhero
}

func(i Ironman )FightWay()string{
    return i.Superhero.FightWay
}

func main() {
    i:=Ironman{ Superhero:Superhero{ &quot;The Avengers&quot; }}
    fmt.Println(i.FightWay)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/cNdAw383421&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行程序后我们发现编译报错: “Println arg i.FightWay is a func value, not called”，这也间接的说明了组合类型(Ironman)中定义的方法 FightWay()string “屏蔽”了内嵌类型(Superhero)中的同名属性,，反过来我们尝试一下&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
}

func(s Superhero)FightWay()string{
    return &quot;The Avengers&quot;
}


type Ironman struct {
    FightWay string 
    Superhero
}


func main() {
    i:=Ironman{ FightWay:&quot;Steel Armor&quot; }
    fmt.Println(i.FightWay())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/U9rfq_E7cqF&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后我们同样会看到编译错误: &quot;cannot call non-function i.FightWay (type string)&quot;，这也从反面论证了在组合类型和内嵌类型中声明同名的属性和方法之间的互相“屏蔽“现象。&lt;/p&gt;
&lt;h3 id=&quot;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名但不同签名的方法&quot;&gt;在含内嵌类型的结构体和被内嵌类型结构体之中定义同名但不同签名的方法&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
type Superhero struct { }

func(s Superhero)FightWay()string{
    return &quot;The Avengers&quot;
}

type Ironman struct {
    Name string 
    Superhero
}

func(i *Ironman) FightWay(name string){
    i.Name=name
}

func main() {
    i:=Ironman{ Name:&quot;Iron Man&quot; }
    i.FightWay()
    fmt.Println(i.Name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/UW4y_-gc_HA&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后我们发现编译器报错: &quot;not enough arguments in call to i.FightWay&quot;，在组合类型和被内嵌类型之间定义的同名不同签名的方法同样存在“屏蔽”现象。&lt;/p&gt;
&lt;p&gt;上面我们演示的都是看上去不是在同一层面的结构，那么对于多个内嵌类型处于同一层面，这时会不会发生变量或者是方法的屏蔽现象呢&lt;/p&gt;
&lt;h3 id=&quot;在同一层面的内嵌类型的结构体内定义同名的属性&quot;&gt;在同一层面的内嵌类型的结构体内定义同名的属性&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
    Name string
}

type Skill struct{
    Name string 
}

type Ironman struct {
    Superhero 
    Skill
}

func main() {
    i:=Ironman{ Superhero:Superhero{&quot;Iron Man&quot;},Skill:Skill{ Name:&quot;Steel Armor&quot; } }
    fmt.Println(i.Name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/emFIG2HJo91&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;当我们运行代码后，会发现编译器输出这样一句话：“ambiguous selector i.Name”，这是由于组合类型就是把内嵌类型内的变量嫁接到组合类型，此时在组合类型内存在两个一样的属性，当属性被调用的时候，编译器也不知道该调用哪一个，跟内嵌类型在组合类型内出现的顺序没有关系。当然编译不通过也就不会涉及“屏蔽”现象了。&lt;/p&gt;
&lt;h3 id=&quot;在同一层面的内嵌类型的结构体内定义同名的变量和方法&quot;&gt;在同一层面的内嵌类型的结构体内定义同名的变量和方法&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
    Name string
}

type Skill struct{}
func(s Skill) Name()string{
    return &quot;Hero`s Skill&quot;
}

type Ironman struct {
    Superhero 
    Skill
}

func main() {
    i:=Ironman{ Superhero:Superhero{&quot;Iron Man&quot;} }
    fmt.Println(i.Name)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/ATZPefUoUeW&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;当我们运行代码之后，也是会出现编译错误：“ambiguous selector i.Name” 。接下来我们在看看方法会不会也出现类似的编译错误&lt;/p&gt;
&lt;h3 id=&quot;在同一层面的内嵌类型的结构体内定义同名但不同签名的方法&quot;&gt;在同一层面的内嵌类型的结构体内定义同名但不同签名的方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;type Superhero struct { }

func(s Superhero) Name()string{
    return &quot;Super Hero &quot;
}

type Skill struct{}
func(s Skill) Name()(string,error){
    return &quot;Hero`s Skill&quot;,nil
}

type Ironman struct {
    Superhero 
    Skill
}

func main() {
    i:=Ironman{ }
    fmt.Println(i.Name())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/tQe5393UYhV&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后，诶！还是编译错误：“ambiguous selector i.Name”。&lt;/p&gt;
&lt;p&gt;其实，无论组合类型中内嵌了多少个其他类型又或者是这些内嵌类型又内嵌了其他内嵌类型，出于最深层次的属性或者是方法被上层同名属性或方法“屏蔽”的概率就越高；当处于同一层面的多个内嵌类型之间含有同性的属性或者是方法时，从错误信息也可得知，编译器不知如何选择被调用的属性或者方法，从而引发编译错误，当然这也很容易理解。&lt;/p&gt;
&lt;p&gt;好了，上面我们针对嵌入的类型都是非指针类型，如果在结构内嵌入的是指针类型又会是怎么样的呢？&lt;/p&gt;
&lt;h3 id=&quot;在结构体内嵌入某个类型的指针类型&quot;&gt;在结构体内嵌入某个类型的指针类型&lt;/h3&gt;
&lt;p&gt;当我们在组合类型内嵌入某个自定义类型的指针类型时，仍然像上述那样出现各种“屏蔽”和编译不通过的现象。但是他们之间的区分在于值类型方法和指针类型的方法对应实现接口的是不相同的(不含实现0个的情况)。&lt;/p&gt;
&lt;h3 id=&quot;如何访问被屏蔽的信息&quot;&gt;如何访问被屏蔽的信息&lt;/h3&gt;
&lt;p&gt;对于访问被“屏蔽”的属性或者是方法，我们可以通过使用组合类型实例+“.”+内嵌类型的类型名称+“.”+被“屏蔽”的属性或方法的链式编程的形式访问到&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Superhero struct {
    FightWay string
}

type Ironman struct {
    FightWay string
    Superhero
}

func main() {
    i:=Ironman{ FightWay: &quot;Steel Armor&quot;, Superhero:Superhero{ &quot;The Avengers&quot; }}
    fmt.Println(i.Superhero.FightWay)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/B520S5falMi&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;运行代码后，我们会看到结果：“The Avengers”,而这个值正是被组合类型同名属性“屏蔽”掉属性的值。&lt;/p&gt;
&lt;h3 id=&quot;屏蔽可以带来哪些好处&quot;&gt;屏蔽可以带来哪些好处&lt;/h3&gt;
&lt;p&gt;虽然Go语言设计形式允许存在“屏蔽”现象，在“屏蔽”的同时也给我们带来了一些好处，下面我们来谈谈：&lt;/p&gt;
&lt;p&gt;组合类型的方法可以对内嵌类型的同名方法进行包装，扩展，这也是在面向对象开发过程中常用的一种手法。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
type Task struct{}

func(t Task) Do(){
    fmt.Println(&quot;击败灭霸，救回队友&quot;)
}

type Ironman struct {
    Task
}

func(r Ironman) Do(){
    fmt.Println(&quot;提供成熟的技术方案&quot;)
    r.Task.Do()
    fmt.Println(&quot;在战斗中负责打响指，自我牺牲&quot;)
}

func main() {
    i:=Ironman{ }
    i.Do()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/cpDUotThGw4&quot; title=&quot;Go Playground&quot;&gt;点击运行&lt;/a&gt;&lt;br/&gt;在这场终局之战中，整个联盟的任务就是击败灭霸，救回队友，而钢铁侠的任务除了基本任务外，还负责成熟的技术支持和在战斗中自我牺牲。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文只是对一些常见的“屏蔽”现象进行简单的说明和演示，让在初学Go语言的过程中对这种现象有一个初步的了解，碰见该现象时知道是怎么回事，从而采取措施避过这种现象或者是从现象中获益。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文所编写的例子均为做演示使用，可能存在逻辑不通或拼写错误的情况，还望见谅。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 07:39:00 +0000</pubDate>
<dc:creator>u#vitamin</dc:creator>
<og:description>在刚开始学习Go语言的过程中，难免会遇到一些问题，尤其是从其他语言转向Go开发的人员，面对语法及其内部实现的差异，在使用Go开发时也避免不了会踩“坑”。本文主要针对Go设计中的屏蔽现象进行详细的说明，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/u-vitamin/p/10793554.html</dc:identifier>
</item>
<item>
<title>优雅的go语言--入门篇 - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/10796241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/10796241.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.静态类型，编译型的开源语言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.脚本华的语法，支持多种编程范式（函数式&amp;amp;面向对象）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.原生，给力的并发编程的支持&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.脚本化的语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.静态类型+编译型，程序运行速度有保障&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.原生支持并发编程（降低开发，维护成本。程序可以更好的执行）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.语法糖并没有python和ruby那么多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.目前的程序运行速度还不及c。但已经赶超c++和Java&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.第三方函数库暂时不能像绝对主流的编程语言那样多&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.GOROOT:安装目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.GOPATH:工作区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.GOBIN:编译文件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.工作区是放置go源码文件的目录&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.一般情况下，go源码文件都需要存放在工作区&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3.对于命令源码文件，并不是必须的&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;4.工作区的目录：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　0.平台相关目录&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.两个隐含的go语言环境变量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　GOOS：操作系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　GOARCH：计算架构&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.以$GOOS_&lt;/span&gt; &lt;span class=&quot;Apple-tab-span&quot;&gt;$GOARCH 为命名方式，如darwin_amd64&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.src：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.用于存放源码文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.以代码包为组织形式&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.pkg：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.用于存放归档文件（名称以.a为后缀的文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.所有归档文件都会被存放在pkg目录下的平台相关目录中，同样以代码包为组织形式&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.bin:&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.用于存放当前工作区中的go程序的可执行文件&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.失效：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　1.当环境变量GOBIN已有效设置时，该目录会变的无意义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　2.当GOPATH的值中包含多个工作区的路径时，必须设置GOBIN,否则无法成功安装go程序的可执行文件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.go源码文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.名称以.go为后缀，内容以go语言代码组织的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.多个go源码文件是需要用代码包组织起来的&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.源码文件分类&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.命令源码文件，库源码文件：go语言程序&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.测试源码文件：辅助源码文件&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.命令源码文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.声明自己属于main代码包，包含无参数声明和结果声明的main函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.被安装后，相应的可执行文件会被存放到GOBIN指向的目录或 当前工作区目录的bin目录下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3.go程序的入口，但不建议把程序都写在一个文件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　4.同一个代码包中强烈不建议直接包含多个命令源码文件&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　4.库源码文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.不具备命令源码文件的特征的源码文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.被安装后，相应的归档文件会被存放到当 前工作区目录/pkg/平台相关目录 下&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　5.测试&lt;/span&gt;源码&lt;span class=&quot;Apple-tab-span&quot;&gt;文件&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.与库源码文件类似&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.不具备命令源码文件的特征的源码文件&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3.名称以_test.go为后缀&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　4.有测试函数：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　1.至少有一个函数名称以Test或Benchmark为前缀&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　2.该函数接受一个类型为*testing.T或*testing.B的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　3.示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
func TestFind(t *testing.T){ } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;功能测试函数&lt;/span&gt;
&lt;span&gt;
func BenchmarkFind(b &lt;/span&gt;*testing.B){ } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准测试函数或性能测试函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.代码包的作用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.编译和归档的最基本单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.代码划分，集结和依赖的有效组织形式，也是权限控制的辅助手段&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.代码包的规则&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.一个代码包实际上就是一个由导入路径代表的目录&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.导入路径即 （工作区目录/src 或 工作区目录/pkg/平台相关目录） 之下的某段子目录&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.代码包的声明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.每个源码文件必须声明其所属的代码包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.同一个代码包中的所有源码文件声明的代码包应该是相同的&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　4.代码包声明与代码包导入路径的区别&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.代码包声明语句中的包名称应该是该代码包的导入路径的最右子路径&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　5.代码包导入&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.代码包导入语句中使用的包名称应该与其导入的路径一致&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　6.代码包导入方法&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.普通导入方法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　import “strings”===&amp;gt; strings.HasPrefix(“abc”,”a”)   &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.带别名的导入&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　import str “strings”===&amp;gt;str.HasPrefix(“abc”,”a”)   //可以直接使用别名&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3.本地化的导入&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　import . “strings”===&amp;gt;HasPrefix(“abc”,”a”)   //无需前缀，本地！！！&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　4.仅仅初始化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　　　import _ “strings”  //仅执行代码包中的初始化函数&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;7.代码包初始化&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.代码包初始化函数即：无参数声明和结果声明的init函数&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.init函数可以被声明在任何文件中，且可以有多个，同一代码包下多个init函数执行顺序是不确定的&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.init函数执行时机&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.单一代码包内：对所有全局函数进行求值===&amp;gt;执行所有init函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.不同代码包之间：执行被导入代码包中的init===&amp;gt;执行导入它的那个代码包的init函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3. &lt;span class=&quot;Apple-tab-span&quot;&gt;4.每一个init函数只会被执行一次，init在main函数之前执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1.go run&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.用于运行命令源码文件&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.只能接受一个命令源码文件以及若干个库源码文件作为文件参数，程序只能有一个入口&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.其内部操作步骤是：先编译源码文件再运行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　源码文件 —&amp;gt; 编译 —&amp;gt; 临时文件 —&amp;gt;运行 —&amp;gt;1. &lt;span class=&quot;Apple-tab-span&quot;&gt;可执行文件 2.归档文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　4.常用标记&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.-a ：强制编译相关代码，不论它们的编译结果是否已是最新的，一般加上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.-n ：打印编译过程中所需的命令，但不真正执行它们&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3.-p n ：并行编译，n代表并行数量。n的值最好设置为当前cpu的逻辑cpu(所有cpu的核的总数量)的个数。加快编译速度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　4.-v : 列出被编译的代码包的名称（不包含go语言自带的标准库的代码包）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　5.-work ：显示编译时创建的临时工作目录的路径，并且不删除此临时工作目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　6.-x ：打印编译过程中所需运行的命令，并执行它们&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2.go build&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.用于编译源码文件或代码包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.编译非命令源码文件不会产生任何结果文件，只会检查源码文件的有效性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.编译命令源码文件会在该命令的执行目录中生成一个可执行文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　4.执行该命令且不追加任何参数时，它会试图把当前目录作为代码包并编译&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　5.执行该命令且以代码包的导入路径作为参数时，该代码包及其依赖会被编译&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　6.执行该命令且以若干源码文件作为参数时，只有这些文件会被编&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3.go install&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.用于编译并安装代码包或源码文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.安装代码包会在当前工作区的 pkg/平台相关目录 下生成归档文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.安装命令源码文件会在当前工作区的bin目录或$GOBIN目录下生成可执行文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　4.执行该命令且不追加任何参数时，它会试图把当前目录作为代码包并安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　5.执行该命令且以代码包的导入路径作为参数时，该代码包及其依赖会被安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　6.执行该命令且以命令源码文件及相关库源码文件作为参数时，只有这些文件会被编译并安装&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;4.go get&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　1.用于从远程仓库上下载并安装代码包 如：GitHub，gitLlab,Gogs&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　2.受支持的代码版本控制系统：git，hg，svn，bazaar&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　3.指定的代码包会被带走到￥GOPATH中包含的第一个工作区的src目录中 &lt;span class=&quot;Apple-tab-span&quot;&gt;4.常用标记&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　1.-d ：直至下载工作，而不执行安装动作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　2.-fix ：在下载代码包之后先执行修正动作，而后再紧张编译和安装。主要为了消除版本不兼容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;　　　　3.-u ：利用网络来更新已有的代码包及其依赖包&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<og:description>1.特点 1.静态类型，编译型的开源语言 2.脚本华的语法，支持多种编程范式（函数式&amp;面向对象） 3.原生，给力的并发编程的支持 2.优势 1.脚本化的语法 2.静态类型+编译型，程序运行速度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/10796241.html</dc:identifier>
</item>
<item>
<title>Java实现远程服务生产与消费(RPC)的4种方法-RMI,WebService,HttpClient,RestTemplate - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10796319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10796319.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文将通过具体的远程服务发布与消费案例展示4种RPC远程调用方法.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;Java自身提供了&lt;code&gt;java.rmi&lt;/code&gt;包, 方便开发者进行远程服务的部署与消费, 下面将通过具体案例进行讲解.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程服务提供者实现.&quot;&gt;远程服务提供者实现.&lt;/h2&gt;
&lt;h3 id=&quot;创建rmi-provider项目maven&quot;&gt;创建rmi-provider项目(Maven)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建&lt;code&gt;UserService&lt;/code&gt;接口.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//将要发布的服务的接口
public interface UserService extends Remote {
    public String helloRmi(String name) throws RemoteException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建&lt;code&gt;UserServiceImpl&lt;/code&gt;实现类&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;注意, &lt;code&gt;UserServiceImpl&lt;/code&gt;除了实现&lt;code&gt;UserService&lt;/code&gt;接口外, 还要继承&lt;code&gt;UnicastRemoteObject&lt;/code&gt;类, 你可以理解为它是一个发布出去供他人调用的类, 当&lt;code&gt;UserServiceImpl&lt;/code&gt;实现了这个类后, &lt;code&gt;UserServiceImpl&lt;/code&gt;就能被发布出去供别人调用.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//将要发布的服务的实现类
public class UserServiceImpl extends UnicastRemoteObject implements UserService {
    public UserServiceImpl() throws RemoteException {
        super();
    }

    public String helloRmi(String name) throws RemoteException {
        return &quot;hello &quot; + name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;发布远程服务&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    try {
        //完成远程服务的发布
        LocateRegistry.createRegistry(8888);//将远程服务发布在本地的8888端口
        String name = &quot;rmi://localhost:8888/rmi&quot;;//发布的远程服务被访问的url
        UserService userService = new UserServiceImpl();//创建一个提供具体服务的远程对象
        Naming.bind(name, userService);//给远程服务绑定一个url
        System.out.println(&quot;--- 已发布rmi远程服务 ---&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;远程服务消费者实现&quot;&gt;远程服务消费者实现&lt;/h2&gt;
&lt;h3 id=&quot;创建rmi-consumer项目&quot;&gt;创建rmi-consumer项目&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;rmi-provider&lt;/code&gt;项目种的&lt;code&gt;UserService&lt;/code&gt;接口与&lt;code&gt;UserServiceImpl&lt;/code&gt;实现类复制到本&lt;code&gt;rmi-consumer&lt;/code&gt;项目中.(这一步可以进行优化解耦, 我们可以多创建一个&lt;code&gt;rmi-resource&lt;/code&gt;项目, 让&lt;code&gt;rmi-provider&lt;/code&gt;和&lt;code&gt;rmi-consumer&lt;/code&gt;共同依赖&lt;code&gt;rmi-resource&lt;/code&gt;项目, 然后把资源文件比如远程服务所用到的&lt;code&gt;UserService&lt;/code&gt;等放入&lt;code&gt;rmi-resource&lt;/code&gt;项目中)&lt;/li&gt;
&lt;li&gt;远程服务消费者对远程服务发起调用.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    try {
        //发布远程服务的访问url
        String name = &quot;rmi://localhost:8888/rmi&quot;;
        //通过发布远程服务的url, 获取远程服务的代理对象
        UserService userService = (UserService) Naming.lookup(name);
        System.out.println(&quot;获得的远程服务的代理对象:&quot; + userService.getClass().getName());
        String result = userService.helloRmi(&quot;rmi&quot;);//拿到远程方法调用的结果
        System.out.println(&quot;result: &quot; + result);

    }catch (Exception e) {
        e.printStackTrace();
    }
}

//最后输出
获得的远程服务的代理对象:com.sun.proxy.$Proxy0
result: hello rmi&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过最后的输出我们看到获得的远程服务对象是动态代理产生的.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;WebService协议是RPC的一种具体实现, 服务提供方和消费方通过&lt;code&gt;http + xml&lt;/code&gt;进行通信.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程服务提供者实现.-1&quot;&gt;远程服务提供者实现.&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;首先创建远程服务接口&lt;code&gt;UserService&lt;/code&gt;及其实现类&lt;code&gt;UserServiceImpl&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;注意, 使用&lt;code&gt;WebService&lt;/code&gt;时需要对远程服务加上注解&lt;code&gt;@WebService&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@WebService
public interface UserService {
    public String sayHello(String name);
}

@WebService
public class UserServiceImpl implements UserService {
    @Override
    public String sayHello(String name) {
        return &quot;hello &quot; + name + &quot;~&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;发布远程服务, 过程和&lt;code&gt;rmi&lt;/code&gt;差不多, 需要提供远程服务的访问地址和具体的远程服务实现类, 使用&lt;code&gt;Endpoint&lt;/code&gt;类的&lt;code&gt;publish()&lt;/code&gt;方法进行发布, 这都是JDK封装好的.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WsProviderApp {
    public static void main(String[] args) {
        //发布的WebService的被访问地址
        String address = &quot;http://localhost:9999/ws&quot;;
        //创建远程服务对象
        UserService userService = new UserServiceImpl();
        //发布服务
        Endpoint.publish(address, userService);
        System.out.println(&quot;远程服务已经发布...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看远程服务文档wdsl&quot;&gt;查看远程服务文档wdsl&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;和&lt;code&gt;rmi&lt;/code&gt;不同的是, WebService发布后, 调用者可以通过查看它的文档对远程服务发起调用.&lt;/li&gt;
&lt;li&gt;查看的方法是在浏览器中输入远程服务的访问地址加上&lt;code&gt;?wdsl&lt;/code&gt;, 比如本案例中是&lt;code&gt;http://localhost:9999/ws?wsdl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意, 在客户端调用远程方法时需要用工具对wdsl文档进行解析, 并获得调用远程方法的工具类. 具体操作见下一段.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程服务消费者实现.&quot;&gt;远程服务消费者实现.&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;首先根据文档获得调用远程服务的工具类, JDK已经为我们封装好了获取的工具, 它在&lt;code&gt;bin&lt;/code&gt;目录下, 名字是&lt;code&gt;wsimport&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开命令行, 在命令行中输入解析命令&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;wsimport -keep -d C:\githubRepositories\shopping\ws-consumer\src\main\java -p com.shenghao.client http://localhost:9999/ws?wsdl

解释:
1. wsimport 是命令的名字
2. -keep 用于保留生成的类, 如果没有该指令会只生成class文件
3. -d 后面接项目中存放这些工具类的包, 填绝对路径
4. -p 填wdsl文档的地址&lt;/code&gt;
&lt;/pre&gt;
&lt;img width=&quot;80%&quot; src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_rpc1.png&quot;/&gt;&lt;img width=&quot;30%&quot; src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_rpc2.png&quot;/&gt;
&lt;ol&gt;&lt;li&gt;可以看到命令执行完后, 指定的包中出现一堆相关的类, 最直接调用到的类是&lt;code&gt;UserServiceImplService&lt;/code&gt;. 下面演示对远程方法进行调用.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    //创建服务类对象
    UserServiceImplService service = new UserServiceImplService();
    //获得远程服务的代理对象
    UserServiceImpl userService = service.getUserServiceImplPort();
    System.out.println(userService.getClass().getName());
    //对远程服务对象的方法进行调用
    String result = userService.sayHello(&quot;炭烧生蚝&quot;);
    System.out.println(result);
}

//结果输出
com.sun.proxy.$Proxy32
hello 炭烧生蚝~&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;这里我们换一个案例进行演示. 假设现在有一套用户系统和一套订单系统, 要实现用户系统访问订单系统以获得某个用户的订单信息.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程服务提供者实现&quot;&gt;远程服务提供者实现&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;提供远程服务的过程和响应web请求很相似, 只不过响应的不是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签, 而是&lt;code&gt;json&lt;/code&gt;字符串. 微信小程序前后端通信也是这个原理.&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;创建名为&lt;code&gt;order-sys&lt;/code&gt;的Maven项目, 指定打包为&lt;code&gt;war&lt;/code&gt;包.&lt;/li&gt;
&lt;/ol&gt;&lt;details readability=&quot;5&quot;&gt;点击这里查看pom.xml文件, 常规操作
&lt;p&gt;&lt;code&gt; 4.3.18.RELEASE 1.2 2.5 2.0 2.9.0    jstl jstl ${jstl.version} javax.servlet servlet-api ${servlet-api.version} provided javax.servlet jsp-api ${jsp-api.version} provided  org.springframework spring-webmvc ${spring.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} order  org.apache.tomcat.maven tomcat7-maven-plugin 2.2 /order 7070 &lt;/code&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;ol&gt;&lt;li&gt;创建订单类&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Order {
    private String id;
    private Double total;
    private String date;

    //get / set ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;对外提供服务, 发布时打包发布到&lt;code&gt;Tomcat&lt;/code&gt;上&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
public class OrderController {
    /**
     * 接收http请求, 响应订单集合, 异步响应
     * 将list集合序列化为json串响应
     * @param uid
     * @return
     */
    @RequestMapping(&quot;/loadOrderList2&quot;)
    @ResponseBody
    public List&amp;lt;Order&amp;gt; loadOrderList2(String uid){
        System.out.println(&quot;uid: &quot; + uid);

        //模拟订单数据
        Order o1 = new Order();
        o1.setId(&quot;111&quot;);
        o1.setTotal(333.33);
        o1.setDate(&quot;2019-4-29&quot;);

        Order o2 = new Order();
        o2.setId(&quot;222&quot;);
        o2.setTotal(444.44);
        o2.setDate(&quot;2019-5-29&quot;);

        Order o3 = new Order();
        o3.setId(&quot;333&quot;);
        o3.setTotal(555.55);
        o3.setDate(&quot;2019-6-29&quot;);

        List&amp;lt;Order&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(o1);
        list.add(o2);
        list.add(o3);

        return list;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;远程服务消费者实现-1&quot;&gt;远程服务消费者实现&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在服务消费端使用&lt;code&gt;HttpClient&lt;/code&gt;发送请求, 可以理解为模拟浏览器发送post/get请求. &lt;code&gt;HttpClient&lt;/code&gt;为我们封装了拼接一个请求的细节, 使得发送一个请求变得容易.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws IOException {
    //发送远程的http请求的地址
    String url = &quot;http://localhost:7070/order/loadOrderList2&quot;;
    //创建HttpClient对象
    CloseableHttpClient client = HttpClients.createDefault();
    //创建HttpPost对象, 发送post请求
    HttpPost method = new HttpPost(url);
    //封装发送到服务提供者的参数
    NameValuePair id = new BasicNameValuePair(&quot;uid&quot;, &quot;10001&quot;);
    List&amp;lt;NameValuePair&amp;gt; params = new ArrayList&amp;lt;&amp;gt;();
    params.add(id);
    //封装请求体数据
    method.setEntity(new UrlEncodedFormEntity(params, &quot;UTF-8&quot;));
    //发送具体的http请求
    HttpResponse response = client.execute(method);

    //获得服务提供者响应的具体数据
    HttpEntity entity = response.getEntity();
    //获得http的响应体
    InputStream is = entity.getContent();

    int len = 0;
    char[] buf = new char[1024];
    //使用字符流读
    InputStreamReader reader = new InputStreamReader(is);
    StringBuffer sb = new StringBuffer();
    while((len = reader.read(buf)) != -1){
        sb.append(String.valueOf(buf, 0, len));
    }
    System.out.println(sb);

    //将响应回来的json字符串解析为Order集合
    List&amp;lt;Order&amp;gt; list = JSON.parseArray(sb.toString(), Order.class);
    for(Order o : list){
        System.out.println(o.getId() + &quot;\t&quot; + o.getTotal() + &quot;\t&quot; + o.getDate());
    }
}&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;通过一个红包系统和订单系统进行演示, 红包系统访问订单系统, 获得某个用户的订单信息, 派发红包.&lt;/li&gt;
&lt;li&gt;订单系统继续沿用&lt;code&gt;HttpClient&lt;/code&gt;中的订单系统, 通过访问&lt;code&gt;loadOrderList2&lt;/code&gt;方法能返回一个订单集合Json字符串.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程服务消费者实现.-1&quot;&gt;远程服务消费者实现.&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
public class RedController {
    //注入由spring提供的RestTemplate对象
    @Autowired
    private RestTemplate restTemplate;
    /**
     * 发送远程的http请求, 消费http服务
     * 获得订单对象的集合
     */
    @RequestMapping(&quot;/loadOrderList3&quot;)
    @ResponseBody
    public List&amp;lt;ResponseEntity&amp;lt;Order[]&amp;gt;&amp;gt; loadOrderList3(String uid){
        //发送远程http请求的url
        String url = &quot;http://localhost:7070/order/loadOrderList2&quot;;
        //发送到远程服务的参数
        MultiValueMap&amp;lt;String, Object&amp;gt; params = new LinkedMultiValueMap&amp;lt;&amp;gt;();
        params.add(&quot;uid&quot;, uid);

        //通过RestTemplate对象发送post请求
        ResponseEntity&amp;lt;Order[]&amp;gt; entitys = restTemplate.postForEntity(url, params, Order[].class);

        //查看响应的状态码
        System.out.println(entitys.getStatusCodeValue());

        //查看响应头
        HttpHeaders headMap = entitys.getHeaders();
        for(Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; m : headMap.entrySet()){
            System.out.println(m.getKey() + &quot;: &quot; + m.getValue());
        }

        return Arrays.asList(entitys);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 30 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 本文将通过具体的远程服务发布与消费案例展示4种RPC远程调用方法. 一. 通过rmi实现远程服务的生产与消费 Java自身提供了 包, 方便开发者进行远程服务的部署与消费, 下面将通过具体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10796319.html</dc:identifier>
</item>
<item>
<title>看板与Scrum：哪个更适合你的团队？ - Worktile</title>
<link>http://www.cnblogs.com/worktile/p/10795663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/worktile/p/10795663.html</guid>
<description>&lt;p&gt;敏捷是理想型指标和原则，看板和Scrum是帮助团队坚持敏捷原则并完成工作的基本框架。本文详细介绍了在Scrum和看板之间做出选择时要考虑的关键因素，以及如果我们无法做出决定时该怎么办。&lt;/p&gt;
&lt;p&gt;Scrum和看板实践之间的区别很容易总结出，但这只是表面上的。虽然这两种框架实践起来不同，但原则基本相同，他们都将帮助团队以更高的效率构建更好的产品和服务。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;敏捷&lt;/h3&gt;
&lt;p&gt;敏捷是一种结构化的迭代方法，多用于项目管理和产品开发。它根据产品开发的波动性特征，为组织团队提供了一种能够在不偏离项目常规轨道的情况下随时作出响应、更改的方法。今天，敏捷很难成为某个组织的独有竞争优势，因为还没有被彻底掌握并做到最佳。这意味着把它做好比以往任何时候都更重要。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/ada10765-4859-4a80-9f33-a15da7d573a5&quot; alt=&quot;敏捷开发流程.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;
&lt;p&gt;&lt;br/&gt;（敏捷开发流程）&lt;/p&gt;

&lt;h3 id=&quot;-&quot;&gt;看板&lt;/h3&gt;
&lt;p&gt;看板可以让你手头的工作变得可视化，并限制正在进行的大量工作，最大化提升效率(或优化流程)。团队通过使用看板并不断改进他们的工作流程，能够有效减少从项目(或需求)开始到结束所花费的时间。&lt;/p&gt;
&lt;h3 id=&quot;-scrum-&quot;&gt;Scrum&lt;/h3&gt;
&lt;p&gt;Scrum团队通常以Sprints的固定时间间隔为准来交付最终产品，他们的做法是创建循环任务，以便快速收集和集成客户反馈。Scrum团队采用特定的角色，创建特殊的工具，并定期举行会议来保持项目的进展。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/feabe0ef-8d86-4168-a68d-204802bb438f&quot; alt=&quot;看板和敏捷 图表.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;h2 id=&quot;-scrum-&quot;&gt;Scrum：结构化的敏捷方法&lt;/h2&gt;
&lt;p&gt;使用Scrum的团队，需要承诺在每个Sprint结束时交付一些有价值的工作增量。Scrum专注于小的增量工作，帮助团队不断进行学习，以预测和了解到接下来要做什么。&lt;/p&gt;
&lt;h4 id=&quot;-scrum-&quot;&gt;Scrum工作节奏&lt;/h4&gt;
&lt;p&gt;Scrum发展很快，每2-4个星期就有一个明确的开始和结束日期。短时间框架迫使复杂的任务被分解成更小的需求，并帮助团队快速学习。但关键的问题是：您的团队能够如此快速地交付可用代码吗?Sprint 的进行中还包括 Sprint 计划、Sprint 评审和回顾会议，并穿插着每日Scrum 站立会议。这些Scrum仪式都是轻量级的，在循环任务的基础上运行。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;交付方式&lt;/h4&gt;
&lt;p&gt;每次Sprint结束时发布版本一直是Scrum的最佳实践，团队为每个Sprint设置一个目标，在Sprint评审会议上决定是否要发布。&lt;/p&gt;
&lt;h4 id=&quot;-scrum-&quot;&gt;Scrum角色&lt;/h4&gt;
&lt;p&gt;Scrum有三个明确定义的角色：产品负责人为客户提供支持，管理产品 Backlog，并帮助开发团队确定所做工作的优先级；Scrum Master 帮助团队坚持 Scrum 原则；开发团队完成项目工作，交付增量。&lt;/p&gt;
&lt;p&gt;那谁来管理 Scrum 团队？答案是：没有设定这个角色。Scrum 团队属于自治型，尽管职责不同，但每个人都是平等的，所有人都坚定于一个共同的目标：为客户提供有价值的产品。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;关键指标&lt;/h4&gt;
&lt;p&gt;Scrum团队的核心指标是速度，即在一个Sprint周期中完成的需求数量，它为下一阶段Sprint及团队要承担的工作作出了预测性指导。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/8c35b839-0f82-4426-955d-9ec71613ce47&quot; alt=&quot;7.0迭代.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;h4 id=&quot;-&quot;&gt;多变性&lt;/h4&gt;
&lt;p&gt;Scrum团队有时会得到客户反馈，并了解到他们所做的可能不符合客户的预期价值。在这种情况下，Sprint的范围应该以“客户期望的价值”为中心来改变。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;看板：持续改进，流程灵活&lt;/h2&gt;
&lt;p&gt;看板有助于可视化我们手头的工作，限制正在进行的工作(WIP)，制定完整工作流程。看板对于项目任务复杂、优先级划分明晰的团队非常有用，Scrum需要对整体工作内容进行高度控制，而看板则灵活度更高。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/0616ac0e-5bef-47cf-ad99-73676b53a3fd&quot; alt=&quot;7.0看板.jpg&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;h4 id=&quot;-&quot;&gt;看板工作节奏&lt;/h4&gt;
&lt;p&gt;看板基于一个连续的工作流结构，它能够让团队保持敏捷，随时准备适应不断变化的任务优先级。工作项(通常由卡片表示)排布在看板上，它们从工作流程的一个阶段流向下一个阶段，基本工作流阶段包括：To Do（未开始）- In Progress（进行中）- In Review（审查中）-Done（已完成）。想了解更多“工作流”内容也可以查看：&lt;a href=&quot;https://worktile.com/blog/pm/workflow&quot; rel=&quot;nofollow&quot;&gt;制定工作流来获得团队更高效率&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;看板最大的优势是为团队定制出工作的标准流程。例如我们文章创作项目，流程包括“初稿-稿件审核中-稿件审核通过（待排期）-稿件已发布”，审核人可以很全面的把控内容的创作质量。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/b2652b65-e086-43fe-aedd-7ff22144dfe2&quot; alt=&quot;WX20190423-171235@2x.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;h4 id=&quot;-&quot;&gt;交付方式&lt;/h4&gt;
&lt;p&gt;理论上，看板并没有规定交付任务的固定时间。如果任务完成得更早(或更晚)，团队就可以根据需要发布产品，而不必等待Sprint Review这样的发布里程碑。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;看板的角色&lt;/h4&gt;
&lt;p&gt;整个团队都可以共享看板，也为所有需要交付的任务负责。虽然有些团队聘请了敏捷教练，但与Scrum不同的是，没有一个“看板大师”能让所有事情都顺利运行。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;关键指标&lt;/h4&gt;
&lt;p&gt;交付时间和周期时间是看板团队的重要指标，即处理任务从开始到完成所需的平均时间。循环任务的完成时间的长短，体现了一个看板团队的效率高低。&lt;/p&gt;
&lt;p&gt;看板中，处理工作瓶颈的方法是WIP限制，它可以控住工作流任何一个阶段中的卡片数量（即任务量）。当您达到WIP限制时，类似于Worktile的看板工具就会为该列（流程阶段）设置任务上限，团队就会更多的专注于这一阶段的工作。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;多变性&lt;/h4&gt;
&lt;p&gt;看板十分灵活，工作项可以随时更改。新的工作项被添加到待办事项列表中，现有的卡片可以根据优先级的规划情况被暂定或删除。此外，如果团队工作量发生变化，可以重新校准WIP限制，并相应地调整工作项。&lt;/p&gt;
&lt;h2 id=&quot;-vs-scrum-&quot;&gt;看板vs scrum：哪个更适合团队？&lt;/h2&gt;
&lt;p&gt;俗话说：“尽信书，则不如无书”，Scrum和看板正是“书上的敏捷”。因此为团队做出的决定不需要如此黑白分明，我们还需要联系现实情况去决定；还有一种情况是，目前有很多团队正在使用scrum和看板的混合模型。&lt;/p&gt;
&lt;p&gt;不管你为团队最终选择了什么，务必坚持使用一段时间。可以在日常会议中从待办事项列表中找出一些要做的工作，然后问问你的团队认为哪些做得好，哪些做得不好；通过尝试scrum和看板，并不断提出问题和复盘工作，那你的团队已经走在通往敏捷的路上了。&lt;/p&gt;

&lt;p&gt;文章来源：&lt;a href=&quot;https://worktile.com/blog/scrum?utm_source=oschina&amp;amp;utm_medium=meiyang&quot; target=&quot;_blank&quot;&gt;Worktile敏捷博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎访问交流更多关于技术及协作的问题。&lt;/p&gt;
&lt;p&gt;文章转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 06:09:00 +0000</pubDate>
<dc:creator>Worktile</dc:creator>
<og:description>敏捷是理想型指标和原则，看板和Scrum是帮助团队坚持敏捷原则并完成工作的基本框架。本文详细介绍了在Scrum和看板之间做出选择时要考虑的关键因素，以及如果我们无法做出决定时该怎么办。 Scrum和看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/worktile/p/10795663.html</dc:identifier>
</item>
<item>
<title>Lua脚本语言快速入门手册 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/10795622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/10795622.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;学了两天Lua语言，感叹其短小精悍，上手极快，语法还很舒服，不错！整理下学习过程中经常用到的基础知识，共勉！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lua语言是在1993年由巴西一个大学研究小组发明，其设计目标是作为嵌入式程序移植到其他应用程序，它是由C语言实现的，虽然简单小巧但是功能强大，所以许多应用都选用它作为脚本语言，尤其是在游戏领域，例如大名鼎鼎的暴雪公司将Lua语言引入到“魔兽世界”这款游戏中，Rovio公司将Lua语言作为“愤怒的小鸟”这款火爆游戏的关卡升级引擎，Web服务器Nginx将Lua语言作为扩展，增强自身功能。Redis将Lua作为脚本语言可帮助开发者定制自己的Redis命令，在这之前，必须修改源码。在介绍如何在Redis中使用Lua脚本之前，有必要对Lua语言的使用做一个基本的介绍。&lt;/p&gt;
&lt;h2 id=&quot;linux-系统上安装&quot;&gt;Linux 系统上安装&lt;/h2&gt;
&lt;p&gt;Linux &amp;amp; Mac上安装 Lua 安装非常简单，只需要下载源码包并在终端解压编译即可，本文使用了5.3.0版本进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz
tar zxf lua-5.3.0.tar.gz
cd lua-5.3.0
make linux test
make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mac-os-x-系统上安装&quot;&gt;Mac OS X 系统上安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz
tar zxf lua-5.3.0.tar.gz
cd lua-5.3.0
make macosx test
make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们创建一个 HelloWorld.lua 文件，代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(&quot;Hello World!&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以下命令:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ lua HelloWorld.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello World!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据类型及其逻辑处理&quot;&gt;1.数据类型及其逻辑处理&lt;/h2&gt;
&lt;p&gt;Lua语言提供了如下几种数据类型：booleans（布尔）、numbers（数值）、strings（字符串）、tables（表格），和许多高级语言相比，相对简单。下面将结合例子对Lua的基本数据类型和逻辑处理进行说明。&lt;/p&gt;
&lt;h3 id=&quot;字符串&quot;&gt;1.字符串&lt;/h3&gt;
&lt;p&gt;下面定义一个字符串类型的数据：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local strings val = &quot;world&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，local代表val是一个局部变量，如果没有local代表是全局变量。&lt;br/&gt;print函数可以打印出变量的值，例如下面代码将打印world，其中&quot;--&quot;是Lua语言的注释。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- 结果是&quot;world&quot;
print(hello)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组&quot;&gt;2.数组&lt;/h3&gt;
&lt;p&gt;在Lua中，如果要使用类似数组的功能，可以用tables类型，下面代码使用定义了一个tables类型的变量myArray，但和大多数编程语言不同的是，Lua的数组下标从1开始计算：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local tables myArray = {&quot;redis&quot;, &quot;jedis&quot;, true, 88.0}
--true
print(myArray[3])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想遍历这个数组，可以使用for和while，这些关键字和许多编程语言是一致的。&lt;/p&gt;
&lt;h4 id=&quot;for&quot;&gt;for&lt;/h4&gt;
&lt;p&gt;下面代码会计算1到100的和，关键字for以end作为结束符：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local int sum = 0
for i = 1, 100
do
    sum = sum + i
end
-- 输出结果为5050
print(sum)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要遍历myArray，首先需要知道tables的长度，只需要在变量前加一个#号即可：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;for i = 1, #myArray
do
print(myArray[i])
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，Lua还提供了内置函数ipairs，使用for index，value ipairs（tables）可以遍历出所有的索引下标和值：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;for index,value in ipairs(myArray)
do
print(index)
print(value)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;while&quot;&gt;while&lt;/h4&gt;
&lt;p&gt;下面代码同样会计算1到100的和，只不过使用的是while循环，while循环同样以end作为结束符。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local int sum = 0
local int i = 0
while i &amp;lt;= 100
do
    sum = sum + i
    i = i + 1
end
--输出结果为5050
print(sum)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;if-else&quot;&gt;if else&lt;/h4&gt;
&lt;p&gt;要确定数组中是否包含了jedis，有则打印true，注意if以end结尾，if后紧跟then：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local tables myArray = { &quot;redis&quot;, &quot;jedis&quot;, true, 88.0 }
for i = 1, #myArray
do
    if myArray[i] == &quot;jedis&quot;
    then
        print(&quot;true&quot;)
        break
    else
        --do nothing
    end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;哈希&quot;&gt;3.哈希&lt;/h3&gt;
&lt;p&gt;如果要使用类似哈希的功能，同样可以使用tables类型，例如下面代码定义了一个tables，每个元素包含了key和value，其中strings1..string2是将两个字符串进行连接：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;local tables user_1 = {age = 28, name = &quot;tome&quot;}
--user_1 age is 28
print(&quot;user_1 age is &quot; .. user_1[&quot;age&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要遍历user_1，可以使用Lua的内置函数pairs：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;for key,value in pairs(user_1)
do print(key .. value)
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数定义&quot;&gt;2.函数定义&lt;/h2&gt;
&lt;p&gt;在Lua中，函数以function开头，以end结尾，funcName是函数名，中间部分是函数体：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function funcName()
...
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;contact函数将两个字符串拼接：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function contact(str1, str2)
return str1 .. str2
end
--&quot;hello world&quot;
print(contact(&quot;hello &quot;, &quot;world&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;我的其它文章&quot;&gt;我的其它文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/lua/lua-tutorial.html&quot;&gt;Lua 教程：菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yueshutong/p/10792425.html&quot;&gt;OpenResty入门之使用Lua开发Nginx插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yueshutong/p/10785905.html&quot;&gt;Redis进阶之使用Lua脚本自定义Redis命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yueshutong/p/10786163.html&quot;&gt;SpringBoot通过RedisTemplate执行Lua脚本&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 06:02:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>学了两天Lua语言，感叹其短小精悍，上手极快，语法还很舒服，不错！整理下学习过程中经常用到的基础知识，共勉！ Lua用法简述 Lua语言是在1993年由巴西一个大学研究小组发明，其设计目标是作为嵌入式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/10795622.html</dc:identifier>
</item>
<item>
<title>python接口自动化（二十七）--html 测试报告——上（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10783105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10783105.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　上一篇我们批量执行完用例后，生成的测试报告是文本形式的，不够直观，而且报告一般都是发给leader的，所以最好是直观一目了然，为了更好的展示测试报告，最好是生成 HTML 格式的。unittest 里面是不能生成 html 格式报告的，需&lt;/p&gt;
&lt;p&gt;要导入一个第三方的模块：HTMLTestRunner。&lt;/p&gt;
&lt;h2&gt;导入 HTMLTestRunner&lt;/h2&gt;
&lt;p&gt;1.、这 个 模 块 下 载 不 能 通 过 pip 安装了，只能下载后手动导入，下载地址：&lt;a href=&quot;http://tungwaiyip.info/software/HTMLTestRunner.html&quot; target=&quot;_blank&quot;&gt;http://tungwaiyip.info/software/HTMLTestRunner.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190429152046444-1406129484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、Download 下 HTMLTestRunner.py 文件就是我们需要下载的包。&lt;span&gt;注意点击后会进入其源码，可以通过另存为将其下载下来或者直接Ctrl+A加Ctrl+C，Ctrl+V,推荐另存为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、下载后手动拖到 python 安装文件的 Lib 目录下&lt;/p&gt;
&lt;h2&gt;demo 解析&lt;/h2&gt;
&lt;p&gt;1、下载 Download 下的第二个文件 test_HTMLTestRunner.py,这个就是官方给的一个测试demo 了，从这个文件可以找到该模块的用法。&lt;/p&gt;
&lt;p&gt;2、找到下图这段，就是官方给的一个 demo 了，test_main()里上半部分就是加载测试 case,我们不需要搞这么复杂。&lt;/p&gt;
&lt;p&gt;3、最核心的代码是下面的红色区域，这个就是本篇的重点啦。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190429152917024-1676365984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;生成 html 报告&lt;/h2&gt;
&lt;p&gt;1、我们只需把上面红色区域代码 copy 到上一篇的基础上稍做修改就可以了，这里主要有三个参数:　&lt;/p&gt;
&lt;p&gt;　　--stream:测试报告写入文件的存储区域&lt;/p&gt;
&lt;p&gt;　　--title:测试报告的主题&lt;/p&gt;
&lt;p&gt;　　--description：测试报告的描述&lt;/p&gt;
&lt;p&gt;2、report_path 是存放测试报告的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430090152883-1583104116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;测试报告详情&lt;/h2&gt;
&lt;p&gt;1、找到测试报告文件，用浏览器打开，点开 View 里的 Detail 可以查看详情描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430100128178-955501387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、为了生成带中文描述的测试用例，可以在 case 中添加注释，如在 test_01 的脚本添加如下注释：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430100609877-46899857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、重新运行后查看测试报告&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430100523313-1526469244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;29&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用discover批量执行测试用例
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import os
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.编写测试用例和断言
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def all_case():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    # 待执行用例的目录
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     #case_dir = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     case_dir = os.path.join(os.getcwd(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     testcase =&lt;span&gt; unittest.TestSuite()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     discover =&lt;span&gt; unittest.defaultTestLoader.discover(case_dir,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                                                    pattern=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                                                    top_level_dir=&lt;span&gt;None)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    # #discover方法筛选出用例，循环添加到测试套件中
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     # &lt;span&gt;for&lt;/span&gt; test_suit &lt;span&gt;in&lt;/span&gt;&lt;span&gt; discover:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     #     &lt;span&gt;for&lt;/span&gt; test_case &lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_suit:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    #         #添加用力到testcase
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    #         testcase.addTests(test_case)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    # print(testcase)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    print(testcase)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; testcase
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    # 返回实例
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     runner =&lt;span&gt; unittest.TextTestRunner()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    #导入第三方模块HTMLTestRunner
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    import HTMLTestRunner
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    #保存生成报告的路径
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     report_path =  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\result.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     fp = open(report_path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     runner = HTMLTestRunner.HTMLTestRunner(stream=&lt;span&gt;fp,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                                            title=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自动化测试用例&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                                            description=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用例执行情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                           )
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    # run 所有用例
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    runner.run(all_case())
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     fp.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;1、fp.close()  #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError&lt;/p&gt;
&lt;p&gt;2、问题： 执行测试用例的过程中，不会打印任何东西，导致上个厕所或第二天回来时，根本不知道执行到哪了，或者执行多少测试用例了。&lt;/p&gt;
&lt;p&gt;解决思路： 每次执行一个测试用例时，就打印该测试用例的名称。&lt;/p&gt;
&lt;p&gt;解决方案： 调用HTMLTestRunner时，定义 verbosity 为大于1的整数，比如说 2：&lt;/p&gt;
&lt;p&gt;runner=HTMLTestRunner.HTMLTestRunner(fp,title=&quot;xxxx&quot;,description=&quot;xxx&quot;,verbosity=2)&lt;/p&gt;
&lt;p&gt;在控制台console 就可以看到每执行一条用例，就会有如下输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190430110722822-1596324694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、HTMLTestRunner 脚本源码分析与解释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OutputRedirector(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;# 将输出进行重定向
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Template_mixin(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;# 定义生成HTML结果文件所需要的模板。
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;# 如果我们想改变HTML的格式等待，可以在这里进行改动
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; _TestResult(TestResult)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# 定义继承自 unittest.TestResult 的 类。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;# 这里重写了 unittest.TestResult 的多个方法，比如 startTest(self, test) 等等
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HTMLTestRunner(Template_mixin)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 这里可以说是使用 HTMLTestRunner.py 的入口。定义了多个我们可以看到的方法，比如 run(self, test)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestProgram(unittest.TestProgram)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;# 这里继承自 unittest.TestProgram 类，重写了 runTests 方法。
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; # 用于命令行执行测试
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、缺点：使用HTMLTestRunner的执行测试用例的过程中，如果中间中断执行，则已经执行完的用例结果也不会打印到html文件&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 05:34:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 上一篇我们批量执行完用例后，生成的测试报告是文本形式的，不够直观，而且报告一般都是发给leader的，所以最好是直观一目了然，为了更好的展示测试报告，最好是生成 HTML 格式的。unittes</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10783105.html</dc:identifier>
</item>
<item>
<title>深入理解Object提供的阻塞和唤醒API - throwable</title>
<link>http://www.cnblogs.com/throwable/p/10795445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/10795445.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;前段时间花了大量时间去研读JUC中同步器&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;的源码实现，再结合很久之前看过的一篇关于&lt;code&gt;Object&lt;/code&gt;提供的等待和唤醒机制的JVM实现，发现两者有不少的关联，于是决定重新研读一下&lt;code&gt;Object&lt;/code&gt;中提供的阻塞和唤醒方法。本文阅读JDK类库源码使用的JDK版本是JDK11，因为本文内容可能不适合于其他版本。&lt;/p&gt;
&lt;h2 id=&quot;object提供的阻塞和唤醒api&quot;&gt;Object提供的阻塞和唤醒API&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;作为所有非基本类型的基类，也就是说所有&lt;code&gt;java.lang.Object&lt;/code&gt;的子类都具备阻塞和唤醒的功能。下面详细分析&lt;code&gt;Object&lt;/code&gt;提供的阻塞和唤醒API。&lt;/p&gt;
&lt;h3 id=&quot;阻塞等待-wait&quot;&gt;阻塞等待-wait&lt;/h3&gt;
&lt;p&gt;等待-&lt;code&gt;wait()&lt;/code&gt;方法提供了阻塞的功能，分超时和永久阻塞的版本，实际上，底层只提供了一个JNI方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这个是底层提供的JNI方法，带超时的阻塞等待，响应中断，其他两个只是变体
public final native void wait(long timeoutMillis) throws InterruptedException;

// 变体方法1，永久阻塞，响应中断
public final void wait() throws InterruptedException {
    wait(0L);
}

// 变体方法2，带超时的阻塞，超时时间分两段：毫秒和纳秒，实际上纳秒大于0直接毫秒加1(这么暴力...)，响应中断
public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
    if (timeoutMillis &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;);
    }
    if (nanos &amp;lt; 0 || nanos &amp;gt; 999999) {
        throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
    }
    if (nanos &amp;gt; 0) {
        timeoutMillis++;
    }
    wait(timeoutMillis);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是只有一个&lt;code&gt;wait(long timeoutMillis)&lt;/code&gt;方法是JNI接口，其他两个方法相当于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;等价于&lt;code&gt;wait(0L)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait(long timeoutMillis, int nanos)&lt;/code&gt;在参数合法的情况下等价于&lt;code&gt;wait(timeoutMillis + 1L)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于&lt;code&gt;wait(long timeoutMillis, int nanos)&lt;/code&gt;是参数最完整的方法，它的API注释特别长，这里直接翻译和摘取它注释中的核心要素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前线程阻塞等待直到被唤醒，唤醒的情况一般有三种：notify(All)被调用、线程被中断或者在指定了超时阻塞的情况下超过了指定的阻塞时间。&lt;/li&gt;
&lt;li&gt;当前线程必须获取此对象的监视器锁(&lt;strong&gt;monitor lock&lt;/strong&gt;)，也就是&lt;strong&gt;调用阻塞等待方法之前一个线程必须成为此对象的监视器锁的拥有者&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;调用了&lt;code&gt;wait()&lt;/code&gt;方法之后，当前线程会把自身放到当前对象的等待集合(wait-set)，然后释放所有在此对象上的同步声明(then to relinquish any nd all synchronization claims on this object)，谨记只有当前对象上的同步声明会被释放，当前线程在其他对象上的同步锁只有在调用其&lt;code&gt;wait()&lt;/code&gt;方法之后才会释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Warning&lt;/strong&gt;：线程被唤醒之后(&lt;code&gt;notify()&lt;/code&gt;或者中断)就会从等待集合(wait-set)中移除并且重新允许被线程调度器调度。通常情况下，这个被唤醒的线程会与其他线程竞争对象上的同步权(锁)，一旦线程重新&lt;strong&gt;控制了对象(regained control of the object)&lt;/strong&gt;，它对对象的所有同步声明都恢复到以前的状态，即恢复到调用&lt;code&gt;wait()&lt;/code&gt;方法时(笔者认为，其实准确来说，是调用&lt;code&gt;wait()&lt;/code&gt;方法前)的状态。&lt;/li&gt;
&lt;li&gt;如果任意线程在它调用了&lt;code&gt;wait()&lt;/code&gt;之前，或者调用过&lt;code&gt;wait()&lt;/code&gt;方法之后处于阻塞等待状态，一旦线程调用了&lt;code&gt;Thread#interrupt()&lt;/code&gt;，线程就会中断并且抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常，线程的中断状态会被清除。&lt;code&gt;InterruptedException&lt;/code&gt;异常会延迟到在第4点提到&quot;它对对象的所有同步声明都恢复到以前的状态&quot;的时候抛出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;值得注意的还有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个线程必须成为此对象的监视器锁的拥有者才能正常调用&lt;code&gt;wait()&lt;/code&gt;系列方法，也就是&lt;code&gt;wait()&lt;/code&gt;系列方法必须在同步代码块(&lt;code&gt;synchronized&lt;/code&gt;代码块)中调用，否则会抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常&lt;/strong&gt;，这一点是初学者或者不了解&lt;code&gt;wait()&lt;/code&gt;的机制的开发者经常会犯的问题。&lt;/p&gt;
&lt;p&gt;上面的五点描述可以写个简单的同步代码块伪代码时序总结一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
final Object lock = new Object();

synchronized(lock){
    1、线程进入同步代码块，意味着获取对象监视器锁成功
    while(!condition){
        lock.wait();   2.线程调用wait()进行阻塞等待
        break;
    }
    3.线程从wait()的阻塞等待中被唤醒，恢复到第1步之后的同步状态
    4.继续执行后面的代码，直到离开同步代码块
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;唤醒-notify&quot;&gt;唤醒-notify&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;notify()&lt;/code&gt;方法的方法签名如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@HotSpotIntrinsicCandidate
public final native void notify();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面按照惯例翻译一下其API注释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;唤醒一个阻塞等待在此对象监视器上的线程，(如果存在多个阻塞线程)至于选择哪一个线程进行唤醒是任意的，取决于具体的现实，一个线程通过调用&lt;code&gt;wait()&lt;/code&gt;方法才能阻塞在对象监视器上。&lt;/li&gt;
&lt;li&gt;被唤醒的线程并不会马上继续执行，直到当前线程(也就是当前调用了&lt;code&gt;notify()&lt;/code&gt;方法的线程)释放对象上的锁。被唤醒的线程会与其他线程竞争在对象上进行同步(换言之只有获得对象的同步控制权才能继续执行)，在成为下一个锁定此对象的线程时，被唤醒的线程没有可靠的特权或劣势。&lt;/li&gt;
&lt;li&gt;此方法只有在一个线程获取了此对象监视器的所有权(the owner)的时候才能调用，具体就是：同步方法中、同步代码块中或者静态同步方法中。否则，会抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;唤醒所有-notifyall&quot;&gt;唤醒所有-notifyAll&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;notifyAll()&lt;/code&gt;方法的方法签名如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@HotSpotIntrinsicCandidate
public final native void notifyAll();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.唤醒所有阻塞等待在此对象监视器上的线程，一个线程通过调用&lt;code&gt;wait()&lt;/code&gt;方法才能阻塞在对象监视器上。&lt;/p&gt;
&lt;p&gt;其他注释的描述和&lt;code&gt;notify()&lt;/code&gt;方法类似。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;我们经常看到的资料中提到&lt;code&gt;synchronized&lt;/code&gt;关键字的用法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;普通同步方法，同步或者说锁定的是当前实例对象。&lt;/li&gt;
&lt;li&gt;静态同步方法，同步或者说锁定的是当前实例对象的&lt;code&gt;Class&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;同步代码块，同步或者说锁定的是括号里面的实例对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于同步代码块而言，&lt;code&gt;synchronized&lt;/code&gt;关键字抽象到字节码层面就是同步代码块中的字节码执行在&lt;code&gt;monitorenter&lt;/code&gt;和&lt;code&gt;monitorexit&lt;/code&gt;指令之间：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(xxxx){

    ...coding block
}

↓↓↓↓↓↓↓↓↓↓

monitorenter;
...coding block - bytecode
monitorexit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor(实际上是&lt;code&gt;ObjectMonitor&lt;/code&gt;)与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。&lt;/p&gt;
&lt;p&gt;对于同步(静态)方法而言，&lt;code&gt;synchronized&lt;/code&gt;方法则会被翻译成普通的方法调用和返回指令，如：&lt;code&gt;invokevirtual&lt;/code&gt;等等，在JVM字节码层面并没有任何特别的指令来实现被&lt;code&gt;synchronized&lt;/code&gt;修饰的方法，而是在&lt;code&gt;Class&lt;/code&gt;文件的方法表中将该方法的&lt;code&gt;access_flags&lt;/code&gt;字段中的&lt;code&gt;synchronized&lt;/code&gt;标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的&lt;code&gt;Class&lt;/code&gt;在JVM的内部对象表示&lt;code&gt;Klass&lt;/code&gt;做为锁对象。&lt;/p&gt;
&lt;p&gt;其实从开发者角度简单理解，&lt;strong&gt;这两种方式只是在获取锁的时机有所不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面重复阐述&lt;strong&gt;几个第一眼看起来不合理却是事实的问题&lt;/strong&gt;(其实前文已经提及过)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在线程进入&lt;code&gt;synchronized&lt;/code&gt;方法或者代码块，相当于获取监视器锁成功，如果此时成功调用&lt;code&gt;wait()&lt;/code&gt;系列方法，那么它会立即释放监视器锁，并且添加到等待集合(Wait Set)中进行阻塞等待。&lt;/li&gt;
&lt;li&gt;由于已经有线程释放了监视器锁，那么在另一个线程进入&lt;code&gt;synchronized&lt;/code&gt;方法或者代码块之后，它可以调用&lt;code&gt;notify(All)&lt;/code&gt;方法唤醒等待集合中正在阻塞的线程，但是这个唤醒操作并不是调用&lt;code&gt;notify(All)&lt;/code&gt;方法后立即生效，而是在该线程退出&lt;code&gt;synchronized&lt;/code&gt;方法或者代码块之后才生效。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;wait()&lt;/code&gt;方法阻塞过程中被唤醒的线程会竞争监视器目标对象的控制权，一旦重新控制了对象，那么线程的同步状态就会恢复到步入&lt;code&gt;synchronized&lt;/code&gt;方法或者代码块时候的状态(也就是成功获取到对象监视器锁时候的状态)，这个时候线程才能够继续执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了验证这三点，可以写个简单的Demo：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Lock {

    @Getter
    private final Object lock = new Object();
}

public class WaitMain {

    private static final DateTimeFormatter F = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);

    public static void main(String[] args) throws Exception {
        final Lock lock = new Lock();
        new Thread(new  WaitRunnable(lock), &quot;WaitThread-1&quot;).start();
        new Thread(new  WaitRunnable(lock), &quot;WaitThread-2&quot;).start();
        Thread.sleep(50);
        new Thread(new  NotifyRunnable(lock), &quot;NotifyThread&quot;).start();
        Thread.sleep(Integer.MAX_VALUE);
    }

    @RequiredArgsConstructor
    private static class WaitRunnable implements Runnable {

        private final Lock lock;

        @Override
        public void run() {
            synchronized (lock) {
                System.out.println(String.format(&quot;[%s]-线程[%s]获取锁成功,准备执行wait方法&quot;, F.format(LocalDateTime.now()),
                        Thread.currentThread().getName()));
                while (true) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        //ignore
                    }
                    System.out.println(String.format(&quot;[%s]-线程[%s]从wait中唤醒,准备exit&quot;, F.format(LocalDateTime.now()),
                            Thread.currentThread().getName()));
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        //ignore
                    }
                    break;
                }
            }
        }
    }

    @RequiredArgsConstructor
    private static class NotifyRunnable implements Runnable {

        private final Lock lock;

        @Override
        public void run() {
            synchronized (lock) {
                System.out.println(String.format(&quot;[%s]-线程[%s]获取锁成功,准备执行notifyAll方法&quot;, F.format(LocalDateTime.now()),
                        Thread.currentThread().getName()));
                lock.notifyAll();
                System.out.println(String.format(&quot;[%s]-线程[%s]先休眠3000ms&quot;, F.format(LocalDateTime.now()),
                        Thread.currentThread().getName()));
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    //ignore
                }
                System.out.println(String.format(&quot;[%s]-线程[%s]准备exit&quot;, F.format(LocalDateTime.now()),
                        Thread.currentThread().getName()));
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某个时刻的执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[2019-04-27 23:28:17.617]-线程[WaitThread-1]获取锁成功,准备执行wait方法
[2019-04-27 23:28:17.631]-线程[WaitThread-2]获取锁成功,准备执行wait方法
[2019-04-27 23:28:17.657]-线程[NotifyThread]获取锁成功,准备执行notifyAll方法 &amp;lt;-------- 这一步执行完说明WaitThread已经释放了锁
[2019-04-27 23:28:17.657]-线程[NotifyThread]先休眠3000ms
[2019-04-27 23:28:20.658]-线程[NotifyThread]准备exit &amp;lt;------- 这一步后NotifyThread离开同步代码块
[2019-04-27 23:28:20.658]-线程[WaitThread-1]从wait中唤醒,准备exit &amp;lt;------- 这一步WaitThread-1解除阻塞
[2019-04-27 23:28:21.160]-线程[WaitThread-2]从wait中唤醒,准备exit &amp;lt;------- 这一步WaitThread-2解除阻塞，注意发生时间在WaitThread-1解除阻塞500ms之后，符合我们前面提到的第3点&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果结合&lt;code&gt;wait()&lt;/code&gt;和&lt;code&gt;notify()&lt;/code&gt;可以简单总结出一个同步代码块的伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final Object lock = new Object();

// 等待
synchronized(lock){
    1、线程进入同步代码块，意味着获取对象监视器锁成功
    while(!condition){
        lock.wait();   2.线程调用wait()进行阻塞等待
        break;
    }
    3.线程从wait()的阻塞等待中被唤醒，尝试恢复第1步之后的同步状态，并不会马上生效，直到notify被调用并且调用notify方法的线程已经释放锁，同时当前线程需要竞争成功
    4.继续执行后面的代码，直到离开同步代码块
}

// 唤醒
synchronized(lock){
    1、线程进入同步代码块，意味着获取对象监视器锁成功
    lock.notify();  2.唤醒其中一个在对象监视器上等待的线程
    3.准备推出同步代码块释放锁，只有释放锁之后第2步才会生效
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;图解object提供的阻塞和唤醒机制&quot;&gt;图解Object提供的阻塞和唤醒机制&lt;/h2&gt;
&lt;p&gt;结合前面分析过的知识点以及参考资料中的文章，重新画一个图理解一下对象监视器以及相应阻塞和唤醒API的工作示意过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-u-c-o-w-n-1.png&quot; alt=&quot;j-u-c-o-w-n-1.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Entry Set(实际上是&lt;code&gt;ObjectMonitor&lt;/code&gt;中的_EntryList属性)：存放等待锁并且处于阻塞状态的线程。&lt;/li&gt;
&lt;li&gt;Wait Set(实际上是&lt;code&gt;ObjectMonitor&lt;/code&gt;中的_WaitSet属性)：存放处于等待阻塞状态的线程。&lt;/li&gt;
&lt;li&gt;The Owner(实际上是&lt;code&gt;ObjectMonitor&lt;/code&gt;中的_owner属性)：指向获得对象监视器的线程，在同一个时刻只能有一个线程被The Owner持有，通俗来看，它就是监视器的控制权。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用例子&quot;&gt;使用例子&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;Object&lt;/code&gt;提供的阻塞和唤醒机制举几个简单的使用例子。&lt;/p&gt;
&lt;h3 id=&quot;维修厕所的例子&quot;&gt;维修厕所的例子&lt;/h3&gt;
&lt;p&gt;假设有以下场景：厕所的只有一个卡位，厕所维修工修厕所的时候，任何人不能上厕所。当厕所维修工修完厕所的时候，上厕所的人需要&quot;得到厕所的控制权&quot;才能上厕所。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 厕所类
public class Toilet {
    // 厕所的锁
    private final Object lock = new Object();
    private boolean available;

    public Object getLock() {
        return lock;
    }

    public void setAvailable(boolean available) {
        this.available = available;
    }

    public boolean getAvailable() {
        return available;
    }
}

// 厕所维修工
@RequiredArgsConstructor
public class ToiletRepairer implements Runnable {

    private static final DateTimeFormatter F = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
    private final Toilet toilet;

    @Override
    public void run() {
        synchronized (toilet.getLock()) {
            System.out.println(String.format(&quot;[%s]-厕所维修员得到了厕所的锁,维修厕所要用5000ms...&quot;, LocalDateTime.now().format(F)));
            try {
                Thread.sleep(5000);
            } catch (Exception e) {
                // ignore
            }
            toilet.setAvailable(true);
            toilet.getLock().notifyAll();
            System.out.println(String.format(&quot;[%s]-厕所维修员维修完毕...&quot;, LocalDateTime.now().format(F)));
        }
    }
}

//上厕所的任务
@RequiredArgsConstructor
public class ToiletTask implements Runnable {

    private static final DateTimeFormatter F = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
    private final Toilet toilet;
    private final String name;
    private final Random random;

    @Override
    public void run() {
        synchronized (toilet.getLock()) {
            System.out.println(String.format(&quot;[%s]-%s得到了厕所的锁...&quot;, LocalDateTime.now().format(F), name));
            while (!toilet.getAvailable()) {
                try {
                    toilet.getLock().wait();
                } catch (InterruptedException e) {
                    //ignore
                }
                int time = random.nextInt(3) + 1;
                try {
                    // 模拟上厕所用时
                    TimeUnit.SECONDS.sleep(time);
                } catch (InterruptedException e) {
                    //ignore
                }
                System.out.println(String.format(&quot;[%s]-%s上厕所用了%s秒...&quot;, LocalDateTime.now().format(F), name, time));
            }
        }
    }
}

// 场景入口
public class Main {

    public static void main(String[] args) throws Exception {
        Toilet toilet = new Toilet();
        Random random = new Random();
        Thread toiletRepairer = new Thread(new ToiletRepairer(toilet), &quot;ToiletRepairer&quot;);
        Thread thread1 = new Thread(new ToiletTask(toilet, &quot;张三&quot;, random), &quot;thread-1&quot;);
        Thread thread2 = new Thread(new ToiletTask(toilet, &quot;李四&quot;, random), &quot;thread-2&quot;);
        Thread thread3 = new Thread(new ToiletTask(toilet, &quot;王五&quot;, random), &quot;thread-3&quot;);
        thread1.start();
        thread2.start();
        thread3.start();
        Thread.sleep(50);
        toiletRepairer.start();
        Thread.sleep(Integer.MAX_VALUE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某次执行的结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[2019-04-29 01:07:25.914]-张三得到了厕所的锁...
[2019-04-29 01:07:25.931]-李四得到了厕所的锁...
[2019-04-29 01:07:25.931]-王五得到了厕所的锁...
[2019-04-29 01:07:25.951]-厕所维修员得到了厕所的锁,维修厕所要用5000ms...
[2019-04-29 01:07:30.951]-厕所维修员维修完毕...
[2019-04-29 01:07:32.952]-张三上厕所用了2秒...
[2019-04-29 01:07:35.952]-王五上厕所用了3秒...
[2019-04-29 01:07:37.953]-李四上厕所用了2秒...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;阻塞队列实现&quot;&gt;阻塞队列实现&lt;/h3&gt;
&lt;p&gt;实现一个简单固定容量的阻塞队列，接口如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BlockingQueue&amp;lt;T&amp;gt; {

    void put(T value) throws InterruptedException;

    T take() throws InterruptedException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;put(T value)&lt;/code&gt;会阻塞直到队列中有可用的容量，而&lt;code&gt;take()&lt;/code&gt;方法会阻塞直到有元素投放到队列中。实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultBlockingQueue&amp;lt;T&amp;gt; implements BlockingQueue&amp;lt;T&amp;gt; {

    private Object[] elements;
    private final Object notEmpty = new Object();
    private final Object notFull = new Object();
    private int count;
    private int takeIndex;
    private int putIndex;

    public DefaultBlockingQueue(int capacity) {
        this.elements = new Object[capacity];
    }

    @Override
    public void put(T value) throws InterruptedException {
        synchronized (notFull) {
            while (count == elements.length) {
                notFull.wait();
            }
        }
        final Object[] items = this.elements;
        items[putIndex] = value;
        if (++putIndex == items.length) {
            putIndex = 0;
        }
        count++;
        synchronized (notEmpty) {
            notEmpty.notify();
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public T take() throws InterruptedException {
        synchronized (notEmpty) {
            while (count == 0) {
                notEmpty.wait();
            }
        }
        final Object[] items = this.elements;
        T value = (T) items[takeIndex];
        items[takeIndex] = null;
        if (++takeIndex == items.length) {
            takeIndex = 0;
        }
        count--;
        synchronized (notFull) {
            notFull.notify();
        }
        return value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景入口类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) throws Exception {
        BlockingQueue&amp;lt;String&amp;gt; queue = new DefaultBlockingQueue&amp;lt;&amp;gt;(5);
        Runnable r = () -&amp;gt; {
            while (true) {
                try {
                    String take = queue.take();
                    System.out.println(String.format(&quot;线程%s消费消息-%s&quot;, Thread.currentThread().getName(), take));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(r, &quot;thread-1&quot;).start();
        new Thread(r, &quot;thread-2&quot;).start();

        IntStream.range(0, 10).forEach(i -&amp;gt; {
            try {
                queue.put(String.valueOf(i));
            } catch (InterruptedException e) {
                //ignore
            }
        });

        Thread.sleep(Integer.MAX_VALUE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某次执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;线程thread-1消费消息-0
线程thread-2消费消息-1
线程thread-1消费消息-2
线程thread-2消费消息-3
线程thread-1消费消息-4
线程thread-2消费消息-5
线程thread-1消费消息-6
线程thread-2消费消息-7
线程thread-1消费消息-8
线程thread-2消费消息-9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个例子就是简单的单生产者-多消费者的模型。&lt;/p&gt;
&lt;h3 id=&quot;线程池实现&quot;&gt;线程池实现&lt;/h3&gt;
&lt;p&gt;这里实现一个极度简陋的固定容量的线程池，功能是：初始化固定数量的活跃线程，阻塞直到有可用的线程用于提交任务。它只有一个接口方法，接口定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ThreadPool {

    void execute(Runnable runnable);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultThreadPool implements ThreadPool {

    private final int capacity;
    private List&amp;lt;Worker&amp;gt; initWorkers;
    private Deque&amp;lt;Worker&amp;gt; availableWorkers;
    private Deque&amp;lt;Worker&amp;gt; busyWorkers;
    private final Object nextLock = new Object();

    public DefaultThreadPool(int capacity) {
        this.capacity = capacity;
        init(capacity);
    }

    private void init(int capacity) {
        initWorkers = new ArrayList&amp;lt;&amp;gt;(capacity);
        availableWorkers = new LinkedList&amp;lt;&amp;gt;();
        busyWorkers = new LinkedList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; capacity; i++) {
            Worker worker = new Worker();
            worker.setName(&quot;Worker-&quot; + (i + 1));
            worker.setDaemon(true);
            initWorkers.add(worker);
        }
        for (Worker w : initWorkers) {
            w.start();
            availableWorkers.add(w);
        }
    }

    @Override
    public void execute(Runnable runnable) {
        if (null == runnable) {
            return;
        }
        synchronized (nextLock) {
            while (availableWorkers.size() &amp;lt; 1) {
                try {
                    nextLock.wait(500);
                } catch (InterruptedException e) {
                    //ignore
                }
            }
            Worker worker = availableWorkers.removeFirst();
            busyWorkers.add(worker);
            worker.run(runnable);
            nextLock.notifyAll();
        }
    }

    private void makeAvailable(Worker worker) {
        synchronized (nextLock) {
            availableWorkers.add(worker);
            busyWorkers.remove(worker);
            nextLock.notifyAll();
        }
    }

    private class Worker extends Thread {

        private final Object lock = new Object();
        private Runnable runnable;
        private AtomicBoolean run = new AtomicBoolean(true);

        private void run(Runnable runnable) {
            synchronized (lock) {
                if (null != this.runnable) {
                    throw new IllegalStateException(&quot;Already running a Runnable!&quot;);
                }
                this.runnable = runnable;
                lock.notifyAll();
            }
        }

        @Override
        public void run() {
            boolean ran = false;
            while (run.get()) {
                try {
                    synchronized (lock) {
                        while (runnable == null &amp;amp;&amp;amp; run.get()) {
                            lock.wait(500);
                        }

                        if (runnable != null) {
                            ran = true;
                            runnable.run();
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    synchronized (lock) {
                        runnable = null;
                    }
                    if (ran) {
                        ran = false;
                        makeAvailable(this);
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景类入口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {

    private static final DateTimeFormatter F = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);

    public static void main(String[] args) throws Exception{
        ThreadPool threadPool = new DefaultThreadPool(2);
        threadPool.execute(() -&amp;gt; {
            try {
                System.out.println(String.format(&quot;[%s]-任务一开始执行持续3秒...&quot;, LocalDateTime.now().format(F)));
                Thread.sleep(3000);
                System.out.println(String.format(&quot;[%s]-任务一执行结束...&quot;, LocalDateTime.now().format(F)));
            }catch (Exception e){
                //ignore
            }
        });
        threadPool.execute(() -&amp;gt; {
            try {
                System.out.println(String.format(&quot;[%s]-任务二开始执行持续4秒...&quot;, LocalDateTime.now().format(F)));
                Thread.sleep(4000);
                System.out.println(String.format(&quot;[%s]-任务二执行结束...&quot;, LocalDateTime.now().format(F)));
            }catch (Exception e){
                //ignore
            }
        });
        threadPool.execute(() -&amp;gt; {
            try {
                System.out.println(String.format(&quot;[%s]-任务三开始执行持续5秒...&quot;, LocalDateTime.now().format(F)));
                Thread.sleep(5000);
                System.out.println(String.format(&quot;[%s]-任务三执行结束...&quot;, LocalDateTime.now().format(F)));
            }catch (Exception e){
                //ignore
            }
        });
        Thread.sleep(Integer.MAX_VALUE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某次执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[2019-04-29 02:07:25.465]-任务二开始执行持续4秒...
[2019-04-29 02:07:25.465]-任务一开始执行持续3秒...
[2019-04-29 02:07:28.486]-任务一执行结束...
[2019-04-29 02:07:28.486]-任务三开始执行持续5秒...
[2019-04-29 02:07:29.486]-任务二执行结束...
[2019-04-29 02:07:33.487]-任务三执行结束...&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;鉴于笔者C语言学得不好，这里就无法深入分析JVM源码的实现，只能结合一些现有的资料和自己的理解重新梳理一下&lt;code&gt;Object&lt;/code&gt;提供的阻塞和唤醒机制这些知识点。结合之前看过JUC同步器的源码，一时醒悟过来，JUC同步器只是在数据结构和算法层面使用Java语言对原来JVM中C语言的阻塞和唤醒机制即&lt;code&gt;Object&lt;/code&gt;提供的那几个JNI方法进行了一次实现而已。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;Object&lt;/code&gt;提供的阻塞等待唤醒机制是JVM实现的(如果特别熟悉C语言可以通过JVM源码研究其实现，对于大部分开发者来说是黑箱)，除非是特别熟练或者是JDK版本太低尚未引入JUC包，一般情况下不应该优先选择&lt;code&gt;Object&lt;/code&gt;，而应该考虑专门为并发设计的JUC包中的类库。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;原文链接&quot;&gt;原文链接&lt;/h2&gt;
&lt;p&gt;Github Page：http://www.throwable.club/2019/04/30/java-object-wait-notify/&lt;br/&gt;Coding Page：http://throwable.coding.me/2019/04/30/java-object-wait-notify/&lt;/p&gt;
&lt;p&gt;(本文完 c-7-d e-a-20190430)&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 05:13:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>深入理解Object提供的阻塞和唤醒API 前提 前段时间花了大量时间去研读JUC中同步器 的源码实现，再结合很久之前看过的一篇关于 提供的等待和唤醒机制的JVM实现，发现两者有不少的关联，于是决定重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/10795445.html</dc:identifier>
</item>
<item>
<title>NLP入门（八）使用CRF++实现命名实体识别(NER) - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10795413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10795413.html</guid>
<description>&lt;h3 id=&quot;crf与ner简介&quot;&gt;CRF与NER简介&lt;/h3&gt;
&lt;p&gt;  CRF，英文全称为conditional random field, 中文名为条件随机场，是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫（Markov）随机场。&lt;br/&gt;  较为简单的条件随机场是定义在线性链上的条件随机场，称为线性链条件随机场（linear chain conditional random field）. 线性链条件随机场可以用于序列标注等问题，而本文需要解决的命名实体识别(NER)任务正好可通过序列标注方法解决。这时，在条件概率模型P(Y|X)中，Y是输出变量，表示标记序列（或状态序列），X是输入变量，表示需要标注的观测序列。学习时，利用训练数据 集通过极大似然估计或正则化的极大似然估计得到条件概率模型p(Y|X)；预测时，对于给定的输入序列x，求出条件概率p(y|x)最大的输出序列y0.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-d61d2a1e34289c86.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;X和Y有相同的图结构的线性链条件随机场&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  命名实体识别（Named Entity Recognition，简称NER）是信息提取、问答系统、句法分析、机器翻译等应用领域的重要基础工具，在自然语言处理技术走向实用化的过程中占有重要地位。一般来说，命名实体识别的任务就是识别出待处理文本中三大类（实体类、时间类和数字类）、七小类（人名、机构名、地名、时间、日期、货币和百分比）命名实体。常见的实现NER的算法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-22bfe366f840e587.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;实现NER的算法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  本文不准备详细介绍条件随机场的原理与实现算法，关于具体的原理与实现算法，可以参考《统计学习算法》一书。我们将借助已实现条件随机场的工具——CRF++来实现命名实体识别。关于用深度学习算法来实现命名实体识别， 可以参考文章：&lt;a href=&quot;https://www.jianshu.com/p/ee750877ab6f&quot;&gt;NLP入门（五）用深度学习实现命名实体识别（NER）&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;crf&quot;&gt;CRF++&lt;/h3&gt;
&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;p&gt;  CRF++是著名的条件随机场的开源工具，也是目前综合性能最佳的CRF工具，采用C++语言编写而成。其最重要的功能我认为是采用了特征模板。这样就可以自动生成一系列的特征函数，而不用我们自己生成特征函数，我们要做的就是寻找特征，比如词性等。关于CRF++的特性，可以参考网址：&lt;a href=&quot;http://taku910.github.io/crfpp/&quot; class=&quot;uri&quot;&gt;http://taku910.github.io/crfpp/&lt;/a&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;  CRF++的安装可分为Windows环境和Linux环境下的安装。关于Linux环境下的安装，可以参考文章：&lt;a href=&quot;https://blog.51cto.com/wutengfei/2095715&quot;&gt;CRFPP/CRF++编译安装与部署&lt;/a&gt; 。 在Windows中CRF++不需要安装，下载解压CRF++0.58文件即可以使用，下载网址为：&lt;a href=&quot;https://blog.csdn.net/lilong117194/article/details/81160265&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/lilong117194/article/details/81160265&lt;/a&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;h5 id=&quot;语料&quot;&gt;1. 语料&lt;/h5&gt;
&lt;p&gt;  以我们本次使用的命名实体识别的语料为例，作为CRF++训练的语料（前20行，每一句话以空格隔开。）如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;played VBD O
on IN O
Monday NNP O
( ( O
home NN O
team NN O
in IN O
CAPS NNP O
) ) O
: : O

American NNP B-MISC
League NNP I-MISC

Cleveland NNP B-ORG
2 CD O
DETROIT NNP B-ORG
1 CD O

BALTIMORE VB B-ORG&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意字与标签之间的分隔符为制表符\t，否则会导致feature_index.cpp(86) [max_size == size] inconsistent column size错误。&lt;/p&gt;
&lt;h5 id=&quot;模板&quot;&gt;2. 模板&lt;/h5&gt;
&lt;p&gt;  模板是使用CRF++的关键，它能帮助我们自动生成一系列的特征函数，而不用我们自己生成特征函数，而特征函数正是CRF算法的核心概念之一。一个简单的模板文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Unigram
U00:%x[-2,0]
U01:%x[0,1]
U02:%x[0,0]
U03:%x[1,0]
U04:%x[2,0]
U05:%x[-2,0]/%x[-1,0]/%x[0,0]
U06:%x[-1,0]/%x[0,0]/%x[1,0]
U07:%x[0,0]/%x[1,0]/%x[2,0]
U08:%x[-1,0]/%x[0,0]
U09:%x[0,0]/%x[1,0]
 
# Bigram
B&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在这里，我们需要好好理解下模板文件的规则。T**:%x[#,#]中的T表示模板类型，两个&quot;#&quot;分别表示相对的行偏移与列偏移。一共有两种模板：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种模板是Unigram template:第一个字符是U，用于描述unigram feature的模板。每一行%x[#,#]生成一个CRF中的点(state)函数: f(s, o), 其中s为t时刻的的标签(output)，o为t时刻的上下文。假设&lt;code&gt;home NN O&lt;/code&gt;所在行为&lt;code&gt;CURRENT TOKEN&lt;/code&gt;，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;played VBD O
on IN O
Monday NNP O
( ( O
home NN O &amp;lt;&amp;lt; CURRENT TOKEN
team NN O
in IN O
CAPS NNP O
) ) O
: : O&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么%x[#,#]的对应规则如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;%x[0,0]&lt;/td&gt;
&lt;td&gt;home&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;%x[0,1]&lt;/td&gt;
&lt;td&gt;NN&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;%x[-1,0]&lt;/td&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;%x[-2,1]&lt;/td&gt;
&lt;td&gt;NNP&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;%x[0,0]/%x[0,1]&lt;/td&gt;
&lt;td&gt;home/NN&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ABC%x[0,1]123&lt;/td&gt;
&lt;td&gt;ABCNN123&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以“U01:%x[0,1]”为例，它在该语料中生成的示例函数如下:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;func1 = if (output = O and feature=&quot;U01:NN&quot;) return 1 else return 0&lt;br/&gt;func2 = if (output = O and feature=&quot;U01:N&quot;) return 1 else return 0&lt;br/&gt;func3 = if (output = O and feature=&quot;U01:NNP&quot;) return 1 else return 0&lt;br/&gt;....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;第二种模板是Bigram template:第一个字符是B，每一行%x[#,#]生成一个CRFs中的边(Edge)函数:f(s', s, o), 其中s'为t–1时刻的标签。也就是说,Bigram类型与Unigram大致相同,只是还要考虑到t–1时刻的标签。如果只写一个B的话,默认生成f(s', s)，这意味着前一个output token和current token将组合成bigram features。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;训练&quot;&gt;3. 训练&lt;/h5&gt;
&lt;p&gt;  CRF++的训练命令一般格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crf_learn  -f 3 -c 4.0 template train.data model -t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，template为模板文件，train.data为训练语料，-t表示可以得到一个model文件和一个model.txt文件，其他可选参数说明如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;-f, –freq=INT使用属性的出现次数不少于INT(默认为1)

-m, –maxiter=INT设置INT为LBFGS的最大迭代次数 (默认10k)

-c, –cost=FLOAT    设置FLOAT为代价参数，过大会过度拟合 (默认1.0)

-e, –eta=FLOAT设置终止标准FLOAT(默认0.0001)

-C, –convert将文本模式转为二进制模式

-t, –textmodel为调试建立文本模型文件

-a, –algorithm=(CRF|MIRA)    选择训练算法，默认为CRF-L2

-p, –thread=INT线程数(默认1)，利用多个CPU减少训练时间

-H, –shrinking-size=INT    设置INT为最适宜的跌代变量次数 (默认20)

-v, –version显示版本号并退出

-h, –help显示帮助并退出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在训练过程中，会输出一些信息，其意义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iter：迭代次数。当迭代次数达到maxiter时，迭代终止

terr：标记错误率

serr：句子错误率

obj：当前对象的值。当这个值收敛到一个确定值的时候，训练完成

diff：与上一个对象值之间的相对差。当此值低于eta时，训练完成&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;预测&quot;&gt;4. 预测&lt;/h5&gt;
&lt;p&gt;  在训练完模型后，我们可以使用训练好的模型对新数据进行预测，预测命令格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crf_test -m model NER_predict.data &amp;gt; predict.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-m model&lt;/code&gt;表示使用我们刚刚训练好的model模型，预测的数据文件为NER_predict.data, &lt;code&gt;&amp;gt; predict.txt&lt;/code&gt;表示将预测后的数据写入到predict.txt中。&lt;/p&gt;
&lt;h3 id=&quot;ner实现实例&quot;&gt;NER实现实例&lt;/h3&gt;
&lt;p&gt;  接下来，我们将利用CRF++来实现英文命名实体识别功能。&lt;br/&gt;  本项目实现NER的语料库如下(文件名为train.txt，一共42000行，这里只展示前15行，可以在文章最后的Github地址下载该语料库)：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;played on Monday ( home team in CAPS ) :&lt;br/&gt;VBD IN NNP ( NN NN IN NNP ) :&lt;br/&gt;O O O O O O O O O O&lt;br/&gt;American League&lt;br/&gt;NNP NNP&lt;br/&gt;B-MISC I-MISC&lt;br/&gt;Cleveland 2 DETROIT 1&lt;br/&gt;NNP CD NNP CD&lt;br/&gt;B-ORG O B-ORG O&lt;br/&gt;BALTIMORE 12 Oakland 11 ( 10 innings )&lt;br/&gt;VB CD NNP CD ( CD NN )&lt;br/&gt;B-ORG O B-ORG O O O O O&lt;br/&gt;TORONTO 5 Minnesota 3&lt;br/&gt;TO CD NNP CD&lt;br/&gt;B-ORG O B-ORG O&lt;br/&gt;......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单介绍下该语料库的结构：该语料库一共42000行，每三行为一组，其中，第一行为英语句子，第二行为句子中每个单词的词性，第三行为NER系统的标注，共分4个标注类别：PER（人名），LOC（位置），ORG（组织）以及MISC，其中B表示开始，I表示中间，O表示单字词，不计入NER，sO表示特殊单字词。&lt;br/&gt;  首先我们将该语料分为训练集和测试集，比例为9:1，实现的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

# NER预料train.txt所在的路径
dir = &quot;/Users/Shared/CRF_4_NER/CRF_TEST&quot;

with open(&quot;%s/train.txt&quot; % dir, &quot;r&quot;) as f:
    sents = [line.strip() for line in f.readlines()]

# 训练集与测试集的比例为9:1
RATIO = 0.9
train_num = int((len(sents)//3)*RATIO)

# 将文件分为训练集与测试集
with open(&quot;%s/NER_train.data&quot; % dir, &quot;w&quot;) as g:
    for i in range(train_num):
        words = sents[3*i].split('\t')
        postags = sents[3*i+1].split('\t')
        tags = sents[3*i+2].split('\t')
        for word, postag, tag in zip(words, postags, tags):
            g.write(word+' '+postag+' '+tag+'\n')
        g.write('\n')

with open(&quot;%s/NER_test.data&quot; % dir, &quot;w&quot;) as h:
    for i in range(train_num+1, len(sents)//3):
        words = sents[3*i].split('\t')
        postags = sents[3*i+1].split('\t')
        tags = sents[3*i+2].split('\t')
        for word, postag, tag in zip(words, postags, tags):
            h.write(word+' '+postag+' '+tag+'\n')
        h.write('\n')

print('OK!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行此程序，得到NER_train.data, 此为训练集数据，NER_test.data，此为测试集数据。NER_train.data的前20行数据如下（以\t分隔开来）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;played VBD O
on IN O
Monday NNP O
( ( O
home NN O
team NN O
in IN O
CAPS NNP O
) ) O
: : O

American NNP B-MISC
League NNP I-MISC

Cleveland NNP B-ORG
2 CD O
DETROIT NNP B-ORG
1 CD O

BALTIMORE VB B-ORG&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们使用的模板文件template内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Unigram
U00:%x[-2,0]
U01:%x[-1,0]
U02:%x[0,0]
U03:%x[1,0]
U04:%x[2,0]
U05:%x[-1,0]/%x[0,0]
U06:%x[0,0]/%x[1,0]

U10:%x[-2,1]
U11:%x[-1,1]
U12:%x[0,1]
U13:%x[1,1]
U14:%x[2,1]
U15:%x[-2,1]/%x[-1,1]
U16:%x[-1,1]/%x[0,1]
U17:%x[0,1]/%x[1,1]
U18:%x[1,1]/%x[2,1]

U20:%x[-2,1]/%x[-1,1]/%x[0,1]
U21:%x[-1,1]/%x[0,1]/%x[1,1]
U22:%x[0,1]/%x[1,1]/%x[2,1]

# Bigram
B&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  接着训练该数据，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crf_learn -c 3.0 template NER_train.data model -t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行时的输出信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-48f8b8cfc3643802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CRF++输出信息&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在笔者的电脑上一共迭代了193次，运行时间为490.32秒，标记错误率为0.00004，句子错误率为0.00056。&lt;/p&gt;
&lt;p&gt;  接着，我们需要在测试集上对该模型的预测表现做评估。预测命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crf_test -m model NER_test.data &amp;gt; result.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Python脚本统计预测的准确率，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

dir = &quot;/Users/Shared/CRF_4_NER/CRF_TEST&quot;

with open(&quot;%s/result.txt&quot; % dir, &quot;r&quot;) as f:
    sents = [line.strip() for line in f.readlines() if line.strip()]

total = len(sents)
print(total)

count = 0
for sent in sents:
    words = sent.split()
    # print(words)
    if words[-1] == words[-2]:
        count += 1

print(&quot;Accuracy: %.4f&quot; %(count/total))
# 0.9706&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;21487
Accuracy: 0.9706&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，在测试集上的准确率高达0.9706，效果相当好。&lt;/p&gt;
&lt;p&gt;  最后，我们对新数据进行命名实体识别，看看模型在新数据上的识别效果。实现的Python代码如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import os
import nltk

dir = &quot;/Users/Shared/CRF_4_NER/CRF_TEST&quot;

sentence = &quot;Venezuelan opposition leader and self-proclaimed interim president Juan Guaidó said Thursday he will return to his country by Monday, and that a dialogue with President Nicolas Maduro won't be possible without discussing elections.&quot;
#sentence = &quot;Real Madrid's season on the brink after 3-0 Barcelona defeat&quot;
# sentence = &quot;British artist David Hockney is known as a voracious smoker, but the habit got him into a scrape in Amsterdam on Wednesday.&quot;
# sentence = &quot;India is waiting for the release of an pilot who has been in Pakistani custody since he was shot down over Kashmir on Wednesday, a goodwill gesture which could defuse the gravest crisis in the disputed border region in years.&quot;
# sentence = &quot;Instead, President Donald Trump's second meeting with North Korean despot Kim Jong Un ended in a most uncharacteristic fashion for a showman commander in chief: fizzle.&quot;
# sentence = &quot;And in a press conference at the Civic Leadership Academy in Queens, de Blasio said the program is already working.&quot;
#sentence = &quot;The United States is a founding member of the United Nations, World Bank, International Monetary Fund.&quot;

default_wt = nltk.word_tokenize # 分词
words = default_wt(sentence)
print(words)
postags = nltk.pos_tag(words)
print(postags)

with open(&quot;%s/NER_predict.data&quot; % dir, 'w', encoding='utf-8') as f:
    for item in postags:
        f.write(item[0]+' '+item[1]+' O\n')

print(&quot;write successfully!&quot;)

os.chdir(dir)
os.system(&quot;crf_test -m model NER_predict.data &amp;gt; predict.txt&quot;)
print(&quot;get predict file!&quot;)

# 读取预测文件redict.txt
with open(&quot;%s/predict.txt&quot; % dir, 'r', encoding='utf-8') as f:
    sents = [line.strip() for line in f.readlines() if line.strip()]

word = []
predict = []

for sent in sents:
    words = sent.split()
    word.append(words[0])
    predict.append(words[-1])

# print(word)
# print(predict)

# 去掉NER标注为O的元素
ner_reg_list = []
for word, tag in zip(word, predict):
    if tag != 'O':
        ner_reg_list.append((word, tag))

# 输出模型的NER识别结果
print(&quot;NER识别结果：&quot;)
if ner_reg_list:
    for i, item in enumerate(ner_reg_list):
        if item[1].startswith('B'):
            end = i+1
            while end &amp;lt;= len(ner_reg_list)-1 and ner_reg_list[end][1].startswith('I'):
                end += 1

            ner_type = item[1].split('-')[1]
            ner_type_dict = {'PER': 'PERSON: ',
                             'LOC': 'LOCATION: ',
                             'ORG': 'ORGANIZATION: ',
                             'MISC': 'MISC: '
                            }
            print(ner_type_dict[ner_type], ' '.join([item[0] for item in ner_reg_list[i:end]]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;识别的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MISC:  Venezuelan
PERSON:  Juan Guaidó
PERSON:  Nicolas Maduro&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;识别有个地方不准确， Venezuelan应该是LOC，而不是MISC. 我们再接着测试其它的新数据：&lt;/p&gt;
&lt;p&gt;输入语句1：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Real Madrid's season on the brink after 3-0 Barcelona defeat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果1：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ORGANIZATION: Real Madrid&lt;br/&gt;LOCATION: Barcelona&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入语句2：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;British artist David Hockney is known as a voracious smoker, but the habit got him into a scrape in Amsterdam on Wednesday.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果2：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;MISC: British&lt;br/&gt;PERSON: David Hockney&lt;br/&gt;LOCATION: Amsterdam&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入语句3：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;India is waiting for the release of an pilot who has been in Pakistani custody since he was shot down over Kashmir on Wednesday, a goodwill gesture which could defuse the gravest crisis in the disputed border region in years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果3：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;LOCATION: India&lt;br/&gt;LOCATION: Pakistani&lt;br/&gt;LOCATION: Kashmir&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入语句4：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Instead, President Donald Trump's second meeting with North Korean despot Kim Jong Un ended in a most uncharacteristic fashion for a showman commander in chief: fizzle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果4：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PERSON: Donald Trump&lt;br/&gt;PERSON: Kim Jong Un&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入语句5：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;And in a press conference at the Civic Leadership Academy in Queens, de Blasio said the program is already working.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果5：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ORGANIZATION: Civic Leadership Academy&lt;br/&gt;LOCATION: Queens&lt;br/&gt;PERSON: de Blasio&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入语句6：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The United States is a founding member of the United Nations, World Bank, International Monetary Fund.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;识别效果6：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;LOCATION: United States&lt;br/&gt;ORGANIZATION: United Nations&lt;br/&gt;PERSON: World Bank&lt;br/&gt;ORGANIZATION: International Monetary Fund&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  在这些例子中，有让我们惊喜之处：识别出了人物Donald Trump, Kim Jong Un. 但也有些不足指出，如将World Bank识别为人物，而不是组织机构。总的来说，识别效果还是让人满意的。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  最近由于工作繁忙，无暇顾及博客。但转念一想，技术输出也是比较重要的，需要长期坚持下去～&lt;br/&gt;  本项目的Github地址为：&lt;a href=&quot;https://github.com/percent4/CRF_4_NER&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/CRF_4_NER&lt;/a&gt; 。&lt;br/&gt;  五一将至，祝大家假期愉快～&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 04:59:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>使用CRF++实现命名实体识别(NER)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10795413.html</dc:identifier>
</item>
</channel>
</rss>