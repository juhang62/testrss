<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>带你剖析WebGis的世界奥秘----点和线的世界 - 烟花散尽13141</title>
<link>http://www.cnblogs.com/zhangxinhua/p/11489673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinhua/p/11489673.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;昨天写了好久的博文我没保存，今天在来想继续写居然没了，气死人啊这种情况你们见到过没，所以今天重新写，我还是切换到了HTML格式的书写上大笑。废话不多说了，我们现在就进入主题，上周我仔细研究了WebGis基于openlayers的显示问题，同事也略微的实现了地图上的点击事件当然啦，这周我们将细分为点和线的点击事件，如果读者有兴趣也可以自己研究区域的点击事件，说白了就是我们初中时候学的那个三维立体的思想，或者读者也可以私下找我交流。&lt;br/&gt;逻辑思想&lt;/p&gt;
&lt;p&gt;（点）在处理这些点击事件中我突然想到一个很常见的思路，就是我通过点击来获取屏幕的坐标，然后在将屏幕的坐标转换成对应地图上的经纬度，拿到经纬度之后去和数据库里面一条一条匹配，最后从数据查到这个点了我就将这个点的信息给输出，如果我没有查到这个点就说明我没有点击到这个点上。但是值得注意的一点就是我们地图在屏幕上是很小的，是存在点击误差的，什么叫点击误差就是我们点击地图上的点我们肉眼上觉得是点击了点，但是实际上我们点击的那个点的坐标和地图上的那个点的坐标是存在一定的误差的，所以我为了实现肉眼上的点击点的事件，我在查找数据库的时候给定了一个我们肉眼默认的误差范围的，也就是说我在数据中并不是真正去查这个点，而是查询数据库中的点到我这个店的距离的，只要这个距离小于我指定的误差值，我就默认为这两个点是同一个点，这也就是我实现点的思路；那么问题来了如果我在地图上点击的时候出现了两个点都和我这个点的距离在我的误差范围之内呢，答案是肯定会的，那么有的读者会问，这个该怎么办呢。不用担心我有解决方法。在取到不止两个的情况下我们去距离最小的那一个，离的最近的我们默认选择这个点的&lt;br/&gt;（线）处理完点自然就是线了，在处理线的时候我一开始的思路就是拿角度去比对，如果是统一角度的就说明我们点击的点在这条线上面，如果不是统一角度就不在这条线上，这个方法后来我实行了，当然这个也是存在误差的，我指定好了误差之后就可行的，但是在性能上不好，没有在距离的方法有效，因为如果我们用角度的话，角度会根据大小的不同误差级别，也就是说角度本身就有误差，在加上我们的肉眼的误差这样就相当于放大了误差，所以最后在项目里我放弃了角度的方法，后来我换了一种思路，我可以求点到直线的距离啊，这样我就成功的将角度的问题转换成了上面的距离的问题了，而且高中我们都会用点到直线的距离公式，而且俩个点确定直线的方程我们也都会使用最后整理了一下就是下面的代码来实现球点到直线的距离，拿到了距离了就回归了我们上面的点的处理中了，我们只要指定误差范围就可以了。&lt;br/&gt;（总结）理论呢就是这么多，估计有的同学已经开始着急了，怎么还没有代码啊，个人觉得！授人以渔不如授人以渔。所以我在上面才唠叨半天，只要你们理解我的思路，下面的代码只需要有初中的水平就可以看得懂了。&lt;br/&gt;/&lt;em&gt;续上&lt;/em&gt;/&lt;br/&gt;代码实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、在map地图上我们注册点击事件，唯一不同的是我们在这里自行区分点线&lt;/span&gt;&lt;br/&gt;map.events.register(&quot;click&quot;, map, function(e) {&lt;br/&gt;//编写点击事件&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、获取屏幕坐标从而转向地理坐标&lt;br/&gt;var lonlat = map.getLonLatFromPixel(e.xy);&lt;br/&gt;3、通过地理坐标去和已有的数据进行匹配查询，这里说的已有数据是说数据库中已经存在的点和线的数据，我现在js模拟一下数据库的写法（data就是数据里的数据）&lt;br/&gt;if(data.length&amp;gt;1){&lt;br/&gt;var min=getDis(data[0].x, data[0].y, data[1].x, data[1].y, lonlat.lon, lonlat.lat);&lt;br/&gt;var index=0;&lt;br/&gt;for(var i=0;i&amp;lt;data.length;i++){&lt;br/&gt;if(i&amp;lt;data.length-1){&lt;br/&gt;var fx = data[i].x;&lt;br/&gt;var fy = data[i].y;&lt;br/&gt;var tx = data[i+1].x;&lt;br/&gt;var ty = data[i+1].y;&lt;br/&gt;}&lt;br/&gt;var dis = getDis(fx, fy, tx, ty, lonlat.lon, lonlat.lat);&lt;br/&gt;if(dis&amp;lt;min){&lt;br/&gt;min=dis;&lt;br/&gt;index=i;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;var wc = judgediswc(map.getZoom());&lt;br/&gt;if(wc&amp;gt;=min){&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //在误差范围内，可以认为是同一线
    var lineName = data[index].site_name+&quot;&amp;gt;&quot;+data[index+1].site_name;
    //alert(lineName);
    $(&quot;#qds&quot;).val(lineName);
    }else{
      searRailLine(lonlat.lon, lonlat.lat);
    }
}else{
    searRailLine(lonlat.lon, lonlat.lat);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、这里提到的getDis 和 judgediswc 还有searRailLine这几个方法都是自己去写的，他们的作用是分别计算点到直线的距离、点到直线距离和误差的比较、去真实数据库查找线的方法。下面进行这三个方法的讲解&lt;br/&gt;4-1、获得点到直线的距离，这个就是我们初高中经常用到的点到直线距离公式，自己稍加推到就可以看得懂了，这个没有什么技术含量，只有别把坐标位置放错了，就可以了，这个返回的dis就是我们需要的距离。这个算法我在数据里也封装好了，待会最后我会帖进来的。&lt;br/&gt;function getDis(fx,fy,tx,ty,lon,lat){&lt;br/&gt;var dis = 637800.138 * (&lt;br/&gt;Math.abs(&lt;br/&gt;(&lt;br/&gt;(ty - fy) * lon&lt;br/&gt;) + (&lt;br/&gt;(fx -&lt;br/&gt;tx) &lt;em&gt;&lt;br/&gt;lat&lt;br/&gt;) + tx&lt;/em&gt; fy - ty * fx&lt;br/&gt;)&lt;br/&gt;) / (&lt;br/&gt;Math.pow(&lt;br/&gt;(ty&lt;br/&gt;- fy) * (ty - fy) + (fx -&lt;br/&gt;tx) * (fx -&lt;br/&gt;tx),&lt;br/&gt;0.5&lt;br/&gt;)&lt;br/&gt;);&lt;br/&gt;return dis;&lt;br/&gt;}&lt;br/&gt;4-2、误差的大小（由于地图的缩放级别不同，我们的误差也不同，这个在前面的理论中我已经解释过了，这个就不多说了）这个就返回我们肉眼能够接受的误差最大值&lt;br/&gt;function judgediswc(level){&lt;br/&gt;var dis=0;&lt;br/&gt;var angle=0;&lt;br/&gt;if(level==15){&lt;br/&gt;dis=12;&lt;br/&gt;angle=42;&lt;br/&gt;}else if(level==14){&lt;br/&gt;dis=16;&lt;br/&gt;angle=94;&lt;br/&gt;}else if(level==13){&lt;br/&gt;dis=52;&lt;br/&gt;angle=149;&lt;br/&gt;}else if(level==12){&lt;br/&gt;dis=69;&lt;br/&gt;angle=403;&lt;br/&gt;}else if(level==11){&lt;br/&gt;dis=178;&lt;br/&gt;angle=479;&lt;br/&gt;}else if(level==10){&lt;br/&gt;dis=294;&lt;br/&gt;angle=1093;&lt;br/&gt;}else if(level==9){&lt;br/&gt;dis=682;&lt;br/&gt;angle=1449;&lt;br/&gt;}else if(level==8){&lt;br/&gt;dis=1488;&lt;br/&gt;angle=4143;&lt;br/&gt;}else if(level==7){&lt;br/&gt;dis=3521;&lt;br/&gt;angle=4617;&lt;br/&gt;}else if(level==6){&lt;br/&gt;dis=6636;&lt;br/&gt;angle=5265;&lt;br/&gt;}else if(level==5){&lt;br/&gt;dis=7051;&lt;br/&gt;angle=30217;&lt;br/&gt;}else if(level==4){&lt;br/&gt;dis=25763;&lt;br/&gt;angle=68126;&lt;br/&gt;}else if(level==3){&lt;br/&gt;dis=60342;&lt;br/&gt;angle=120000;&lt;br/&gt;}else if(level==2){&lt;br/&gt;dis=88189;&lt;br/&gt;angle=220000;&lt;br/&gt;}else if(level==1){&lt;br/&gt;dis=110189;&lt;br/&gt;angle=1000000;&lt;br/&gt;}&lt;br/&gt;return angle;&lt;br/&gt;}&lt;br/&gt;4-3、下面的方法我们就是真正去数据库查找的，上面的方法没有实际用处，只是为了掩饰给读者的快捷方法（注意我ajax的传参 很重要）&lt;br/&gt;function searRailLine(lon,lat){&lt;br/&gt;var sus = function(json, status) {&lt;br/&gt;//alert();&lt;br/&gt;var lineName = json.map[0].station_name+&quot;站&quot;+&quot;&amp;gt;&quot;+json.map[0].next_name+&quot;站&quot;;&lt;br/&gt;$(&quot;#qds&quot;).val(lineName);&lt;br/&gt;siteJson = json.map;&lt;br/&gt;};&lt;br/&gt;AjaxUtil.ajaxCon(path + &quot;/echartMap/selectLineNameStr.json&quot;, {lon:lon,lat:lat,angle:judgediswc(map.getZoom())},&lt;br/&gt;sus);&lt;br/&gt;}&lt;br/&gt;5、具体的三层架构实现我就不写了，相信能看到这里的孩子们三层架构一定都了解。我直接贴sql语句（x，y，z分别是经度、纬度、地图的显示级别）方法中返回的是点到直线的最小距离（有可能有很多个直线都是符合的我们取最小的那个）&lt;/p&gt;
&lt;p&gt;6、有的读者会问了，说好的点和线呢，你的点呢，别着急啊，我先把难的讲完简单，点呢我就把sql语句贴出来，返回了距离的值，在后台你想怎么办就怎么办，那就看你自己了。对吧&lt;/p&gt;
&lt;p&gt;效果贴图&lt;/p&gt;
&lt;p&gt;1、途中高亮显示的是模拟的js中的数据，点击高亮部分就会在脚本中查询我模拟的数据&lt;/p&gt;
&lt;p&gt;2、点击高亮线路（北京--》北京南--》丰台）跳出相应的线路信息&lt;/p&gt;
&lt;p&gt;3、点击非高亮地区会去查询数据库中的数据，就是真正的数据，如果点击在线上了也会弹出线的详细信息&lt;/p&gt;
&lt;p&gt;4、如果我们点击在点上面就会 是点的相应信息，就不贴出来了，在高亮的线上我留个bug就是在线的延长线上也是认为在线上的，实际上不应该认为是线上，这点由于时间紧急我当时就没有写，读者有兴趣自己补充，提示一下判断点的位置是否在线的两端的中间就可以了，这个功能在点击非高亮线的sql语句我实现了的，可以参考一下。&lt;br/&gt;总结&lt;/p&gt;
&lt;p&gt;研究了openlayers也有两周了，这两周学到的东西很多。学东西一定要从底层学，才可以学到真正的东西。openlayers的几个基本功能我都已经实现了（地图显示+点线点击事件+定位点+定位线+居中显示墨点+手型显示），其他一些实时定位并随地理位置变动而变动的这个功能没有去实现，因为就两周时间，也就这样了，之间走了很多的弯路，所以发出博文希望对学习WebGis的新同学有点帮助&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxinhua/p/11489673.html#addMe&quot;&gt;加入战队&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;微信公众号&quot;&gt;微信公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1002125/201909/1002125-20190909084810032-325260480.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:48:00 +0000</pubDate>
<dc:creator>烟花散尽13141</dc:creator>
<og:description>前言 昨天写了好久的博文我没保存，今天在来想继续写居然没了，气死人啊这种情况你们见到过没，所以今天重新写，我还是切换到了HTML格式的书写上大笑。废话不多说了，我们现在就进入主题，上周我仔细研究了We</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangxinhua/p/11489673.html</dc:identifier>
</item>
<item>
<title>调度系统Airflow的第一个DAG - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/airflow-first-dag.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/airflow-first-dag.html</guid>
<description>&lt;p&gt;考虑了很久,要不要记录airflow相关的东西, 应该怎么记录. 官方文档已经有比较详细的介绍了,还有各种博客,我需要有一份自己的笔记吗?&lt;/p&gt;
&lt;p&gt;答案就从本文开始了.&lt;/p&gt;
&lt;p&gt;本文将从一个陌生视角开始认知airflow,顺带勾勒出应该如何一步步搭建我们的数据调度系统.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在是9102年9月上旬, Airflow最近的一个版本是1.10.5.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ps. 查资料发现自己好多文章被爬走,换了作者.所以,接下里的内容会随机添加一些防伪标识,忽略即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么数据调度系统?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中台这个概念最近比较火, 其中就有一个叫做数据中台, 文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53843604&quot;&gt;数据中台到底是什么&lt;/a&gt;给出了一个概念.&lt;br/&gt;我粗糙的理解, 大概就是: 收集各个零散的数据,标准化,然后服务化, 提供统一数据服务. 而要做到数据整理和处理,必然涉及数据调度,也就需要一个调度系统.[本文出自Ryan Miao]&lt;br/&gt;数据调度系统可以将不同的异构数据互相同步,可以按照规划去执行数据处理和任务调度. Airflow就是这样的一个任务调度平台.&lt;/p&gt;
&lt;p&gt;前面&lt;a href=&quot;https://www.cnblogs.com/woshimrf/p/airflow-install-with-docker.html&quot;&gt;Airflow1.10.4介绍与安装&lt;/a&gt;已经&lt;br/&gt;安装好了我们的airflow, 可以直接使用了. 这是第一个DAG任务链.&lt;/p&gt;
&lt;h2 id=&quot;创建一个任务hello-world&quot;&gt;创建一个任务Hello World&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;目标: 每天早上8点执行一个任务--打印&lt;code&gt;Hello World&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux上,我们可以在crontab插入一条记录:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190906205445350-1965038546.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Springboot, 我们可以使用&lt;code&gt;@Scheduled(cron=&quot;0 0 8 * * ?&quot;)&lt;/code&gt;来定时执行一个method.&lt;/p&gt;
&lt;p&gt;使用quartz, 我们可以创建一个&lt;code&gt;CronTrigger&lt;/code&gt;, 然后去执行对应的JobDetail.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; CronTrigger trigger = (CronTrigger)TriggerBuilder.newTrigger()
            .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
            .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0 0 8 * * ?&quot;))
            .build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Airflow, 也差不多类似.&lt;/p&gt;
&lt;p&gt;在docker-airflow中,我们将dag挂载成磁盘,现在只需要在dag目录下编写dag即可.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; volumes:
            - ./dags:/usr/local/airflow/dags&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个&lt;code&gt;hello.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;&quot;
Airflow的第一个DAG
&quot;&quot;&quot;
from airflow import DAG
from airflow.operators.bash_operator import BashOperator
from datetime import datetime


default_args = {
    &quot;owner&quot;: &quot;ryan.miao&quot;,
    &quot;start_date&quot;: datetime(2019, 9, 1)
}

dag = DAG(&quot;Hello-World&quot;, 
        description=&quot;第一个DAG&quot;,
        default_args=default_args, 
        schedule_interval='0 8 * * *')

t1 = BashOperator(task_id=&quot;hello&quot;, bash_command=&quot;echo 'Hello World, today is {{ ds }}'&quot;, dag=dag)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个Python脚本, 主要定义了两个变量.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示一个有向无环图,一个任务链, 其id全局唯一. DAG是airflow的核心概念, 任务装载到dag中, 封装成任务依赖链条. DAG决定这些任务的执行规则,比如执行时间.这里设置为从9月1号开始,每天8点执行.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TASK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;task表示具体的一个任务,其id在dag内唯一. task有不同的种类,通过各种Operator插件来区分任务类型. 这里是一个BashOperator, 来自airflow自带的插件, airflow自带了很多拆箱即用的插件.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ds&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;airflow内置的时间变量模板, 在渲染operator的时候,会注入一个当前执行日期的字符串. 后面会专门讲解这个执行日期.&lt;/p&gt;
&lt;p&gt;[本文出自Ryan Miao]&lt;/p&gt;
&lt;h2 id=&quot;部署dag&quot;&gt;部署dag&lt;/h2&gt;
&lt;p&gt;将上述&lt;code&gt;hello.py&lt;/code&gt;上传到dag目录, airflow会自动检测文件变化, 然后解析py文件,导入dag定义到数据库.&lt;/p&gt;
&lt;p&gt;访问airflow地址,刷新即可看到我们的dag.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190907110005863-1594073417.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启dag, 进入dag定义, 可以看到已经执行了昨天的任务.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190907110136357-1821237270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击任务实例, 点击view log可以查看日志&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190907110439356-393652837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的任务在这台机器上执行,并打印了hello, 注意, 这个打印的日期.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190907113528361-749329226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就是一个基本的airflow任务单元了, 这个任务每天8点会执行.&lt;/p&gt;
&lt;h2 id=&quot;理解调度系统的概念&quot;&gt;理解调度系统的概念&lt;/h2&gt;
&lt;h3 id=&quot;任务定义&quot;&gt;任务定义&lt;/h3&gt;
&lt;p&gt;定义一个任务的具体内容,比如这里就是打印&lt;code&gt;Hello World,today is {{ ds }}&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;任务实例&quot;&gt;任务实例&lt;/h3&gt;
&lt;p&gt;任务设定了运行时间,每次运行时会生成一个实例,即 dag-task-executiondate 标记一个任务实例.任务实例和任务当前代表的执行时间绑定. 本demo中,每天会生成一个任务实例.&lt;/p&gt;
&lt;h3 id=&quot;执行日期&quot;&gt;执行日期&lt;/h3&gt;
&lt;p&gt;今天是2019-09-07, 但我们日志里打印的任务执行日期是2019-09-06.&lt;/p&gt;
&lt;p&gt;执行日期是任务实例运行所代表的任务时间, 我们通常叫做execute-date或bizdate, 类似hive表的的分区.&lt;/p&gt;
&lt;p&gt;为什么今天执行的任务,任务的时间变量是昨天呢?&lt;/p&gt;
&lt;p&gt;因为任务实例是一个时间段的任务, 比如计算每天的访问量, 我们只有6号这一天过去了才能计算6号这一天的的总量. 那这个任务最早要7号0点之后才能计算, 计算6号0点到7号0点之间的访问量.所以,这个任务时间就代表任务要处理的数据时间, 就是6号. 任务真正执行时间不固定的, 可以7号, 也可以8号, 只要任务执行计算的数据区间是6号就可以了.&lt;/p&gt;
&lt;p&gt;因此, 调度系统中的ds(execution date)通常是过去的一个周期, 即本周期执行上周期的任务.&lt;/p&gt;
&lt;h3 id=&quot;任务依赖&quot;&gt;任务依赖&lt;/h3&gt;
&lt;p&gt;最典型的任务模型etl(Extract &amp;amp; Transformation &amp;amp; Loading，即数据抽取，转换，加载)最少也要分成3步. 对于每天要统计访问量这个目标来说, 我必须要抽取访问日志, 找到访问量的字段, 计算累加. 这3个任务之间有先后顺序,必须前一个执行完毕之后,后一个才可以执行. 这叫任务依赖. 不同的任务之间的依赖.在airflow里, 通过在关联任务实现依赖.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/686418/201909/686418-20190907130007037-941486630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有同一个任务的时间依赖. 比如,计算新增用户量, 我必须知道前天的数据和昨天的数据, 才能计算出增量. 那么, 这个任务就必须依赖于昨天的任务状态. 在airflow里,通过设置&lt;code&gt;depends_on_past&lt;/code&gt;来决定.&lt;/p&gt;
&lt;h3 id=&quot;任务补录backfill&quot;&gt;任务补录backfill&lt;/h3&gt;
&lt;p&gt;airflow里有个功能叫backfill, 可以执行过去时间的任务. 我们把这个操作叫做补录或者补数,为了计算以前没计算的数据.&lt;/p&gt;
&lt;p&gt;我们的任务是按时间执行的, 今天创建了一个任务, 计算每天的用户量, 那么明天会跑出今天的数据. 这时候,我想知道过去1个月每天的用户增量怎么办?&lt;/p&gt;
&lt;p&gt;自己写code, 只要查询日期范围的数据,然后分别计算就好. 但调度任务是固定的, 根据日期去执行的. 我们只能创建不同日期的任务实例去执行这些任务. backfill就是实现这种功能的.&lt;/p&gt;
&lt;h3 id=&quot;任务重跑&quot;&gt;任务重跑&lt;/h3&gt;
&lt;p&gt;让跑过的任务再跑一次.&lt;/p&gt;
&lt;p&gt;有时候, 我们的任务需要重跑. 比如, etl任务, 今天突然发现昨天抽取的数据任务有问题,少抽取一个app的数据, 那后面的计算用户量就不准确, 我们就需要重新抽取,重新计算.&lt;/p&gt;
&lt;p&gt;在airflow里, 通过点击任务实例的clear按钮, 删除这个任务实例, 然后调度系统会再次创建并执行这个实例.&lt;/p&gt;
&lt;p&gt;关于调度系统这个实现逻辑, 我们后面有机会来查看源码了解.&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;本文没太实质性的任务具体介绍, 而是引出Hello World, 先跑起来,我们接下来继续完善我们的dag.&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:48:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<og:description>Airflow的第一个DAG ================= 考虑了很久,要不要记录airflow相关的东西, 应该怎么记录. 官方文档已经有比较详细的介绍了,还有各种博客,我需要有一份自己的笔记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/woshimrf/p/airflow-first-dag.html</dc:identifier>
</item>
<item>
<title>从SpringBoot构建十万博文聊聊Tomcat集群监控 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/11487757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/11487757.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182856926-18172438.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在十万博文终极架构中，我们使用了Tomcat集群，但这并不能保证系统不会出问题，为了保证系统的稳定运行，我们还需要对 Tomcat 进行有效的运维监控手段，不至于问题出现或者许久一段时间才知道。凌晨一点这个锅可谁都不想背，为此基于目前的情况搭建了以下这么一套监控预警系统。&lt;/p&gt;
&lt;h2 id=&quot;架构图&quot;&gt;架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182903961-667594888.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关软件&quot;&gt;相关软件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Nginx：代理访问 Grafana&lt;/li&gt;
&lt;li&gt;Grafana： 可视化面板(Dashboard)，有着非常漂亮的图表和布局展示&lt;/li&gt;
&lt;li&gt;Influxdb：开源的时间序列数据库，适用于记录度量，事件及执行分析&lt;/li&gt;
&lt;li&gt;Telegraf：收集系统和服务的统计数据&lt;/li&gt;
&lt;li&gt;Docker：开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;监控架构&quot;&gt;监控架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182911492-146550060.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GTI监控预警系统，架构流程说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：数据采集，Telegraf 采集 Tomcat 相关参数数据&lt;/li&gt;
&lt;li&gt;第二步：数据存储，Influxdb 存储 Telegraf 采集的数据&lt;/li&gt;
&lt;li&gt;第三步：数据可视化，Grafana 配置 Tomcat 监控面板&lt;/li&gt;
&lt;li&gt;第四步：预警通知，配置钉钉、邮件等预警&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装配置&quot;&gt;安装配置&lt;/h2&gt;
&lt;p&gt;这里只对Grafana、Telegraf、Influxdb、Tomcat 做相应的安装说明，Nginx 以及 Docker 请自行查阅资料。&lt;/p&gt;
&lt;h3 id=&quot;grafana&quot;&gt;Grafana&lt;/h3&gt;
&lt;p&gt;Grafana只是一个接入数据源的可视化面板，这里为了方便，我们选择Docker安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir grafana
ID=$(id -u)
docker run -d --user $ID --name=grafana  --volume &quot;$PWD/grafana:/var/lib/grafana&quot; -p 3000:3000 grafana/grafana
# 如果生产环境配置，最好提前配置好域名
docker run -d --user $ID --name=grafana --volume &quot;$PWD/data:/var/lib/grafana&quot; -p 3000:3000 -e &quot;GF_SERVER_ROOT_URL=http://monitor.52itstyle.vip&quot; grafana/grafana
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功以后，执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现grafana运行容器说明安装成功。&lt;/p&gt;
&lt;p&gt;查看容器相关参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker inspect docker.io/grafana/grafana&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it grafana /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Grafana的默认配置文件grafana.ini位于容器中的/etc/grafana，这个文件是映射不出来的。不过可以先创建并运行一个容器，拷贝出来重新创建运行容器。&lt;/p&gt;
&lt;p&gt;参数说明(这里截取了部分重点参数)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;##################### Grafana 几个重要的参数(参考一下) #####################
[paths]
# 存放临时文件、session以及sqlite3数据库的目录
;data = /var/lib/grafana

# 存放日志的地方
;logs = /var/log/grafana

# 存放相关插件的地方
;plugins = /var/lib/grafana/plugins

#################################### Server ####################################
[server]
# 默认协议 支持(http, https, socket)
;protocol = http

# 默认端口
;http_port = 3000

# 这里配置访问地址，如果使用了反向代理请配置域名，发送告警通知的时候作为访问地址
root_url = http://grafana.52itstyle.vip

#################################### Database ####################################
[database]

# 默认使用的数据库sqlite3，位于/var/lib/grafana目录下面
;path = grafana.db

#################################### Session ####################################
[session]
# session 存储方式，默认是file即可  Either &quot;memory&quot;, &quot;file&quot;, &quot;redis&quot;, &quot;mysql&quot;, &quot;postgres&quot;, default is &quot;file&quot;
;provider = file

#################################### SMTP / Emailing ##########################
[smtp]
# 邮件服务器配置，自行修改配置
enabled = true
host = smtp.mxhichina.com:465
user = admin@52itstyle.vip
# If the password contains # or ; you have to wrap it with trippel quotes. Ex &quot;&quot;&quot;#password;&quot;&quot;&quot;
password = 123456
;cert_file =
;key_file =
;skip_verify = false
from_address = admin@52itstyle.vip
# 这里不要设置中文，否则会发送失败
from_name = Grafana&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;influxdb&quot;&gt;Influxdb&lt;/h3&gt;
&lt;p&gt;创建并运行容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d -p 8083:8083 -p 8086:8086 -e ADMIN_USER=&quot;root&quot; -e INFLUXDB_INIT_PWD=&quot;root&quot; -e PRE_CREATE_DB=&quot;telegraf&quot; --name influxdb tutum/influxdb:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个参数含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-d：容器在后台运行

--name：容器名称

-e：指定环境变量，容器中可以使用该环境变量 

-p：将容器内端口映射到宿主机端口，格式为 宿主机端口:容器内端口；8083是influxdb的web管理工具端口，8086是influxdb的HTTP API端口&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行成功以后，执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现influxdb运行容器说明安装成功。&lt;/p&gt;
&lt;p&gt;访问地址：http://ip:8083/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182924869-1576579191.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;telegraf&quot;&gt;Telegraf&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker pull telegraf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把telegraf相关配置拷贝到宿机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker cp telegraf:/etc/telegraf/telegraf.conf ./telegraf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采集Tomcat数据：&lt;/p&gt;
&lt;p&gt;如果想监控多个Tomcat，这里配置多个[[inputs.tomcat]]即可，但是一定要配置不同的tags标识。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[inputs.tomcat]]
url = &quot;http://192.168.1.190:8080/manager/status/all?XML=true&quot;
# Tomcat访问账号密码 必须配置
username = &quot;tomcat&quot;
password = &quot;tomcat&quot;
timeout = &quot;5s&quot;
# 标识Tomcat名称、根据实际项目部署情况而定
[inputs.tomcat.tags]
host = &quot;blog&quot;

[[inputs.tomcat]]
url = &quot;http://192.168.1.190:8081/manager/status/all?XML=true&quot;
# Tomcat访问账号密码 必须配置
username = &quot;tomcat&quot;
password = &quot;tomcat&quot;
timeout = &quot;5s&quot;
# 标识Tomcat名称、根据实际项目部署情况而定
[inputs.tomcat.tags]
host = &quot;bbs&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采集数据到influxdb：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[outputs.influxdb]]
      # urls = [&quot;udp://localhost:8089&quot;] # UDP endpoint example
      urls = [&quot;http://localhost:8086&quot;] # required，这个url改成自己host
      ## The target database for metrics (telegraf will create it if not exists).
      database = &quot;telegraf&quot; # 这个会在influx库创建一个库&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把配置文件复制到容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker cp telegraf.conf telegraf:/etc/telegraf/telegraf.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启telegraf服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;tomcat&quot;&gt;Tomcat&lt;/h3&gt;
&lt;p&gt;由于telegraf收集Tomcat相关数据需要配置访问权限，这里我们选择Tomcat7做配置说明。&lt;/p&gt;
&lt;p&gt;修改位于conf下的tomcat-users.xml文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;tomcat-users&amp;gt;
&amp;lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status&quot;/&amp;gt;
&amp;lt;/tomcat-users&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启Tomcat容器，访问以下地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://ip:8080/manager/status/all?XML=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182935659-89031491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现以上界面，说明配置成功。&lt;/p&gt;
&lt;h2 id=&quot;监控配置&quot;&gt;监控配置&lt;/h2&gt;
&lt;p&gt;依次启动Tomcat、Influxdb、Telegraf、Grafana完成后，我们进入Grafana后台管理进行相关配置。&lt;/p&gt;
&lt;h4 id=&quot;配置influxdb数据源&quot;&gt;配置Influxdb数据源：&lt;/h4&gt;
&lt;p&gt;选择 datasources/Add datasource&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908182956126-1863135355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入正确的HTTP地址以及数据库账号密码，点击保存，如果出现绿色提示框，说明配置成功。&lt;/p&gt;
&lt;h4 id=&quot;配置tomcat仪表盘&quot;&gt;配置Tomcat仪表盘：&lt;/h4&gt;
&lt;p&gt;选择 dashboard/import&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183004099-101406816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有三种方式导入面板：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择输入官方面板ID或者URL&lt;/li&gt;
&lt;li&gt;直接复制黏贴JSON格式代码&lt;/li&gt;
&lt;li&gt;导入第三方面板JSON格式文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们导入事先自己定制保存的Tomcat监控面板，最后点击导入保存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183011309-826275203.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不出意外，将会是下图的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183017733-92235920.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;告警配置&quot;&gt;告警配置&lt;/h2&gt;
&lt;p&gt;前期做了这么多，我们的最终目的是为了提前预警通知，在系统即将发生灾难之前作出相应的准备调整。这里我们以Tomcat的线程数量阈值作为预警通知。&lt;/p&gt;
&lt;h4 id=&quot;点击线程面板-选择编辑&quot;&gt;点击线程面板-选择编辑：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183027014-1542407874.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置相关参数&quot;&gt;配置相关参数：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183034043-1745592278.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、Alert名称，可以自定义。&lt;br/&gt;2、执行的频率，这里我选择每60s检测一次。&lt;br/&gt;3、判断标准，默认是avg，这里是下拉框，自己按需求选择。&lt;br/&gt;4、query（A,5m,now），字母A代表选择的metrics中设置的sql，也可以选择其它在metrics中设置的，但这里是单选。5m代表从现在起往之前的五分钟，即5m之前的那个点为时间的起始点，now为时间的结束点，此外这里可以自己手动输入时间。&lt;br/&gt;5、设置的预警临界点，这里手动输入，和6是同样功能，6可以手动移动，两种操作是等同的。&lt;/p&gt;
&lt;h4 id=&quot;配置预警信息以及通知方式&quot;&gt;配置预警信息以及通知方式：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183041458-1694252657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们选择的是邮件预警通知，但是要提前进行配置，详见一开始grafana.ini中 SMTP / Emailing 相关参数配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183057306-812067907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183103470-80962566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击发送测试，提示成功会发送一份告警Demo到指定邮箱：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190908183112472-1250807947.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;讲道理，这一套东西还是挺强大的。特别是对于中小公司来说，各种成熟的开源组间一整合完美搭建出一套监控系统，时间成本、人力成本、技术成本可以降到最低。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;大家安装过程中，版本可能不尽相同，相关页面展示会不一致，但是不会影响最终功能呈现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.grafana.org/&quot; class=&quot;uri&quot; title=&quot;http://docs.grafana.org/&quot;&gt;http://docs.grafana.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.influxdata.com/influxdb/&quot; class=&quot;uri&quot; title=&quot;https://docs.influxdata.com/influxdb/&quot;&gt;https://docs.influxdata.com/influxdb/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.influxdata.com/telegraf/&quot; class=&quot;uri&quot; title=&quot;https://docs.influxdata.com/telegraf/&quot;&gt;https://docs.influxdata.com/telegraf/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.52itstyle.vip/archives/2014/&quot; class=&quot;uri&quot; title=&quot;https://blog.52itstyle.vip/archives/2014/&quot;&gt;https://blog.52itstyle.vip/archives/2014/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.52itstyle.vip/archives/2029/&quot; class=&quot;uri&quot; title=&quot;https://blog.52itstyle.vip/archives/2029/&quot;&gt;https://blog.52itstyle.vip/archives/2029/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/influxdata/telegraf/pull/3277&quot; class=&quot;uri&quot; title=&quot;https://github.com/influxdata/telegraf/pull/3277&quot;&gt;https://github.com/influxdata/telegraf/pull/3277&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:38:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<og:description>前言 在十万博文终极架构中，我们使用了Tomcat集群，但这并不能保证系统不会出问题，为了保证系统的稳定运行，我们还需要对 Tomcat 进行有效的运维监控手段，不至于问题出现或者许久一段时间才知道。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smallSevens/p/11487757.html</dc:identifier>
</item>
<item>
<title>跟我学SpringCloud | 第十七篇：服务网关Zuul基于Apollo动态路由 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11489632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11489632.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章我们介绍了Gateway基于Nacos动态网关路由的解决方案&lt;a href=&quot;https://www.geekdigging.com/2019/09/02/gateway-ji-yu-nacos-dong-tai-wang-guan-lu-you/&quot;&gt;《Spring Cloud Alibaba | Gateway基于Nacos动态网关路由》&lt;/a&gt;，同为Spring Cloud服务网关组件的Spring Cloud Zuul在生产环境中使用更为广泛，那么它有没有方便的动态路由解决方案呢？答案当然是肯定的，Zuul作为一个老牌的开源服务网关组件，动态路由对它来讲是一个十分必要的功能，毕竟我们不能随便重启服务网关，服务网关是一个微服务系统的大门，今天我们介绍的Zuul动态路由的解决方案来自于携程开源的配置中心Apollo。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190909082910235-1842931793.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;apollo概述&quot;&gt;Apollo概述&lt;/h2&gt;
&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。&lt;/p&gt;
&lt;p&gt;Apollo支持4个维度管理Key-Value格式的配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;application (应用)&lt;/li&gt;
&lt;li&gt;environment (环境)&lt;/li&gt;
&lt;li&gt;cluster (集群)&lt;/li&gt;
&lt;li&gt;namespace (命名空间)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;apollo相比于spring-cloud-config优势&quot;&gt;Apollo相比于Spring Cloud Config优势&lt;/h2&gt;
&lt;p&gt;前面的文章我们也介绍了Spring Cloud Config&lt;a href=&quot;https://www.geekdigging.com/2019/08/31/di-qi-pian-spring-cloud-config-pei-zhi-zhong-xin-gao-ke-yong/&quot;&gt;《跟我学SpringCloud | 第七篇：Spring Cloud Config 配置中心高可用和refresh》&lt;/a&gt;，但是它和我们今天要使用的相比，又有什么劣势呢？&lt;/p&gt;
&lt;p&gt;Spring Cloud Config的精妙之处在于它的配置存储于Git，这就天然的把配置的修改、权限、版本等问题隔离在外。通过这个设计使得Spring Cloud Config整体很简单，不过也带来了一些不便之处。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;配置界面&lt;/td&gt;
&lt;td&gt;一个界面管理不同环境、不同集群配置&lt;/td&gt;
&lt;td&gt;无，需要通过git操作&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;配置生效时间&lt;/td&gt;
&lt;td&gt;实时&lt;/td&gt;
&lt;td&gt;重启生效，或手动refresh生效&lt;/td&gt;
&lt;td&gt;Spring Cloud Config需要通过Git webhook，加上额外的消息队列才能支持实时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;版本管理&lt;/td&gt;
&lt;td&gt;界面上直接提供发布历史和回滚按钮&lt;/td&gt;
&lt;td&gt;无，需要通过git操作&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;灰度发布&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;授权、审核、审计&lt;/td&gt;
&lt;td&gt;界面上直接支持，而且支持修改、发布权限分离&lt;/td&gt;
&lt;td&gt;需要通过git仓库设置，且不支持修改、发布权限分离&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;实例配置监控&lt;/td&gt;
&lt;td&gt;可以方便的看到当前哪些客户端在使用哪些配置&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;配置获取性能&lt;/td&gt;
&lt;td&gt;快，通过数据库访问，还有缓存支持&lt;/td&gt;
&lt;td&gt;较慢，需要从git clone repository，然后从文件系统读取&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;客户端支持&lt;/td&gt;
&lt;td&gt;原生支持所有Java和.Net应用，提供API支持其它语言应用，同时也支持Spring annotation获取配置&lt;/td&gt;
&lt;td&gt;支持Spring应用，提供annotation获取配置&lt;/td&gt;
&lt;td&gt;Apollo的适用范围更广一些&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;工程实战&quot;&gt;工程实战&lt;/h2&gt;
&lt;p&gt;这里需要准备一个Apollo配置中心，具体如何构建Apollo配置中心我这里不多做介绍，大家可以参考Apollo的官方文档：https://github.com/ctripcorp/apollo/wiki&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;工程依赖pom.xml如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码清单：chapter16/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.ctrip.framework.apollo&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;apollo-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${apollo-client.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;app.properties如下：&lt;/p&gt;
&lt;p&gt;代码清单：chapter16/src/main/resources/META-INF/app.properties&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.id=123456789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置的&lt;code&gt;app.id&lt;/code&gt;是在Apollo中创建项目时配置的。&lt;/p&gt;
&lt;p&gt;application.yml如下：&lt;/p&gt;
&lt;p&gt;代码清单：chapter16/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apollo:
  bootstrap:
    enabled: true
    namespaces: zuul-config-apollo
  Meta: http://localhost:8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Apollo上新建一个命名空间&lt;code&gt;zuul-config-apollo&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其余的配置都配置在Apollo中，具体如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190909082910502-473405252.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动主类Chapter16Application.java如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码清单：chapter16/src/main/java/com/springcloud/chapter16/Chapter16Application.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableEurekaClient
@EnableZuulProxy
@EnableApolloConfig
public class Chapter16Application {

    public static void main(String[] args) {
        SpringApplication.run(Chapter16Application.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;@EnableZuulProxy&lt;/code&gt;表示开启Zuul网关代理，&lt;code&gt;@EnableApolloConfig&lt;/code&gt;表示开启Apollo配置。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;路由刷新&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码路径：chapter16/src/main/java/com/springcloud/chapter16/config/ZuulProxyRefresher.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class ZuulProxyRefresher implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    @Autowired
    private RouteLocator routeLocator;

    @ApolloConfigChangeListener(value = &quot;zuul-config-apollo&quot;)
    public void onChange(ConfigChangeEvent changeEvent) {
        boolean zuulProxyChanged = false;
        for (String changedKey : changeEvent.changedKeys()) {
            if (changedKey.startsWith(&quot;zuul.&quot;)) {
                zuulProxyChanged = true;
                break;
            }
        }
        if (zuulProxyChanged) {
            refreshZuulProxy(changeEvent);
        }
    }

    private void refreshZuulProxy(ConfigChangeEvent changeEvent) {
        this.applicationContext.publishEvent(new EnvironmentChangeEvent(changeEvent.changedKeys()));
        this.applicationContext.publishEvent(new RoutesRefreshedEvent(routeLocator));
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@ApolloConfigChangeListener(value = &quot;zuul-config-apollo&quot;)&lt;/code&gt;中value的默认参数是&lt;code&gt;application&lt;/code&gt;，因为这里我们自定义了namespace，所以需要指定，我们使用&lt;code&gt;@ApolloConfigChangeListener&lt;/code&gt;监听Apollo的配置下发，有配置更新时会调用&lt;code&gt;refreshZuulProxy()&lt;/code&gt;刷新路由信息。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们启动Client-Apollo工程和Zuul-Apollo工程，打开浏览器访问：http://localhost:9091/client/hello ，页面可以正常显示，我们在Apollo中修改路由信息，具体如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190909082910946-1560774798.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完后点击发布，待发布成功后，我们刷新浏览器，之前的路由访问已经报错404，我们使用修改过后的路由http://localhost:9091/client_new/hello ，页面可以正常显示&lt;code&gt;Hello, i am dev from apollo update.&lt;/code&gt;，测试成功，我们通过Apollo实现了Zuul的路由信息动态刷新。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter16&quot;&gt;Github-示例代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/SpringCloudLearning/tree/master/chapter16&quot;&gt;Gitee-示例代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:29:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>SpringCloud系列教程 | 第十七篇：服务网关Zuul基于Apollo动态路由 Springboot: 2.1.7.RELEASE SpringCloud: Greenwich.SR2 [TO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11489632.html</dc:identifier>
</item>
<item>
<title>三个小白是如何在三个月内搭一个基于kaldi的嵌入式在线语音识别系统的 - davidtym</title>
<link>http://www.cnblogs.com/talkaudiodev/p/11240033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkaudiodev/p/11240033.html</guid>
<description>&lt;p&gt;前面的博客里说过最近几个月我从传统语音（语音通信）切到了智能语音（语音识别）。刚开始是学语音识别领域的基础知识，学了后把自己学到的写了PPT给组内同学做了presentation（&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/10635656.html&quot;&gt;语音识别传统方法(GMM+HMM+NGRAM)概述&lt;/a&gt;）。一段时间后老板就布置了具体任务：在我们公司自己的ARM芯片上基于kaldi搭建一个在线语音识别系统，三个人花三个月左右的时间完成。由于我们都是语音识别领域的小白，要求可以低些，就用传统的GMM-HMM来实现。说实话接到这个任务我们心里是有点没底的，不知道能不能按时完成，毕竟我们对语音识别不熟，对kaldi不熟。既然任务下达了，硬着头皮也要上，并尽最大努力完成。我本能的先在网上用百度/google搜了搜，看有没有一些经验可供参考，好让我们少走弯路。遗憾的是没搜到有价值的东西。没办法，我们只能根据自己以前的经验摸索着前进。最终我们按计划花了不到三个月的时间完成了嵌入式平台上在线语音识别系统的搭建。虽然只是demo，但是为后面真正做商用的产品打下了良好的基础，累积了不少的经验。今天我就把我们怎么做的分享出来，给也想做类似产品的朋友做个参考。&lt;/p&gt;

&lt;p&gt;既然作为一个项目来做，就要有计划，分几个阶段完成这个项目。我在学习语音识别基础知识时对kaldi有一个简单的了解（在做语音识别前就已知kaldi的大名，没办法这几年人工智能（AI）太热了。智能语音作为人工智能的主要落地点之一，好多都是基于kaldi来实现的。我是做语音的，自然会关注这个热门领域的动态）。根据对kaldi的简单了解，我把项目分成了三个阶段，第一阶段是学习kaldi，对kaldi有一个更深的认识，同时搞清楚基于kaldi做方案后面有哪些事情要做，计划花一个月左右的时间完成。第二阶段是设计软件架构、写代码、训练模型等，也是花一个月左右的时间完成。第三阶段是调试，提升识别率，还是花一个月左右的时间完成。计划的时间会根据实际情况做微调。&lt;/p&gt;

&lt;p&gt;1，第一阶段&lt;/p&gt;
&lt;p&gt;第一阶段就是学习kaldi。由于我们是三个人做这个项目，我就把学习任务分成三块：数据准备和MFCC、GMM-HMM模型训练、解码网络创建和解码。在其他两位同学挑好模块后剩下的解码网络创建和解码就有我来学习了。学习过程就是看网上文章、看博客和看kaldi代码、脚本的过程。学完后大家搞清楚了后面有哪些事情要做，同时做了PPT给组内同学讲，让大家共同提高。解码相关的见我前面的文章（&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/11064283.html&quot;&gt;基于WFST的语音识别解码器&lt;/a&gt; ）。Kaldi中解码有两种类型：offline（多用于模型调试等）和online（多用于在线识别等），其中online也有两种方式，一种是通过PortAudio从MIC采集语音数据做在线语音识别，另一种是通过读音频WAV文件的方式做在线语音识别。我们要做的是在线语音识别，这两个就是很好的参考，尤其是通过PortAudio从MIC采集方式的，很有必要弄明白运行机制。于是我根据网上的博客基于thchs30搭建了PC上的在线识别来调试，基本上搞清楚了代码的运行机制。Kaldi中设定采样率为16kHZ，每帧25ms（其中帧移10ms），每27帧为一组集中做MFCC特征提取和解码，这样处理一组的语音时长是285ms（25+（27-1）*10=285），共4560（16*285=4560）个采样点。每次处理完一组后就从buffer中再取出一组做MFCC和解码，解码后看有没有识别的字出来，有的话就打印出来。&lt;/p&gt;

&lt;p&gt;2，第二阶段 &lt;/p&gt;
&lt;p&gt;第一阶段主要是学习，第二阶段就要真正干活了。我们在Linux上开发，先制定系统搭建完成后的目标：设备用数据线连在PC上，能在线实时识别英文数字0—9（选识别这些是因为网上有现成的英国人说的音频源，我们可以省去录音频源的工作，好节约时间），即人对着设备说出英文数字0—9后PC屏幕上能实时打印出来，识别率接近GMM-HMM模型下的较好值。大家的任务还是沿袭第一阶段的。学习数据准备和MFCC的同学先数据准备相关的工作，如标注等，好给模型训练的同学用，然后移植kaldi中MFCC相关的代码。学习模型训练的同学先开始模型训练的准备工作，等要准备的数据好了后就开始训练。我负责整个软件架构的设计，同时还要把kaldi中的绝大部分（除了MFCC）移植进我们系统中。通过对kaldi的学习，使我对怎么设计这个在线语音识别的软件架构有了更深的认识。语音识别分两个阶段，即训练阶段和识别阶段。训练阶段就是得到模型给识别阶段用。它相对独立，我们就基于kaldi来训练模型，最终得到final.mdl等文件给识别阶段的软件用（在初始化时读取这些文件得到解码网络）。识别阶段的软件主要分两部分，声音采集和识别（包括特征提取和解码）。这样系统就有两个thread，一个是声音采集thread（audio capture thread），它基于ALSA来做，负责声音的采集和前处理（如噪声抑制），另一个是识别thread（kaldi process thread），负责MFCC和解码。两个thread通过ring buffer交互数据，同时要注意数据的保护。这样系统的软件架构框图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201908/1181527-20190821182713493-1638076315.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家对软件架构讨论觉得没什么问题后我就开始写代码搭建软件框架了。在 Linux中创建thread等都是一些套路活。Audio capture thread里先做初始化，包括ALSA的配置以及前处理模块的初始化等。然后就每隔一定时间通过ALSA_LIB的API完成一次音频数据的采集工作，读完数据后就做前处理，处理好后把音频数据放进ring buffer中，同时激活kaldi process thread，让kaldi process thread开始干活。Kaldi thread也是先做一些初始化的工作，然后睡下去等待激活。激活后先从ring buffer里取语音数据，然后做MFCC和decoder。完成后又睡下去等待下次再被激活。搭建软件框架时kaldi相关的代码还没被移植进去，kaldi process thread里仅仅把从ring  buffer里拿到的语音数据写进PCM文件，然后用CoolEdit听，声音正常就说明软件框架基本成型了。刚开始时audio capture thread里也没加前处理模块，调试时把从ALSA里获取的数据写进PCM文件听后发现有噪声，就加了噪声抑制（ANS）模块。这个模块用的是webRTC里的。webRTC里的三大前处理模块（AEC/ANS/AGC）几年前我就用过，这次拿过来简单处理一下就用好了，去噪效果也挺好的。ANS一个loop是10ms，而前面说过kaldi里在线识别解码一次处理一组27帧是285ms，我就取两者的最小公倍数570ms作为audio capture thread的loop时间。从ALSA取到语音数据后分57（570/10 = 57）次做噪声抑制，再把抑制后的语音数据写进ring buffer。Kaldi thread激活后还是每次取出285ms语音数据做处理，只不过要取两次（570/285 = 2）。&lt;/p&gt;

&lt;p&gt;软件架构搭好后就开始移植kaldi代码了。Kaldi代码量大，不可能也没必要全部移植到我们系统里，只需要移植我们需要的就可以了。怎样才能移植我们需要的代码呢？考虑后我用了如下的方法：先把在线解码相关的代码移植进去，然后开始不停的编译，报什么错提示缺什么就加什么，直到编译通过。这种方法保证了把需要的文件都移植进系统了，但有可能某些文件中的函数没用到，即到文件级还没到函数级。由于时间紧，这个问题就暂时不管了。移植过程更多的是一个体力活，需要小心细致。在移植过程中遇到问题就去网上搜，最后都圆满解决了。Kaldi主要用到了三个开源库：openfst、BLAS、LAPACK。BLAS和LAPACK我用的常规方法，即到官网上下载编译后生成库，然后把库和头文件放到系统的”/usr/lib”和“/use/include”下，让其他代码用。kaldi支持的有BALS库有 ATLAS / CLAPACK / openBLAS / MKL等。在X86的Ubuntu PC上跑kaldi时就用的Intel的MKL，在ARM上就不能用了，需要用其他的几种之一。我评估下来用了openBLAS，主要因为三点：1）它是BSD的；2）它支持多种架构(ARM/X86/MIPS/….)，是开源库里性能最好的（各种架构里都嵌了很多的汇编代码），被多家著名公司使用，如IBM/ARM/nvidia/huawei等；3）它有多个编译选项可供选择，比如单线程/多线程选择、设定线程数等。BLAS的早期代码都是用fortran写的，后来用C对其进行了封装，所以系统还要加上对fortran的支持。对openFST，我发现用到的代码并不多，也就没用常规的方法，而是直接把用到的代码移植进系统。我移植好编译没问题后另一个同学把剩下的MFCC以及和ALSA接口（用ALSA接口替代kaldi里的PortAudio接口）相关的也移植进去了。这样移植工作就算结束了。对比了下移植进系统的kaldi代码和kaldi里SRC下的代码，应该是只用了其中一小部分。下图显示了移植进系统的kaldi文件（没列出相关的头文件）。同时负责模型训练的同学也有了一个初步的模型生成的文件，把这些文件放进系统里就可以跑起来了，人说话后PC屏幕上就有词打印出来，不过不正确。这也正常呀，因为还没调试呢！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201908/1181527-20190816091613078-1368302591.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3，第三阶段&lt;/p&gt;
&lt;p&gt;第三阶段就是调试。第二阶段结束后说话就有词出来，但都是错的，需要排查定位问题。在线语音识别系统从大的角度可以分两块：模型和代码实现。首先我们需要定位是模型的问题还是代码实现的问题，先从模型排查。在第一阶段时利用thchs30大致搞清楚了在线解码的机制，是用模型tri1调的，当时识别率很差。现在要关注识别率了，把模型换成了tri2b，识别率有所提高。这说明kaldi里的在线解码的代码是没有问题的，识别率差问题出在模型。况且全球这么多人在用kaldi，如果在线解码有问题应该早就fix了。所以我们决定把我们生成的模型文件放进thchs30里来验证模型是否有问题。为了排除从MIC输入的音频数据有噪声等的干扰，先用读文件的方式验证。把我们的模型文件放进去后发现基本识别不正确，这说明模型是有问题的。负责模型的同学去调查，发现用于训练的音源都是8K采样的，但是在线解码用的都是16K采样的，这是我们自己挖的坑，用重采样程序把8K的全部转成16K的，这个坑也就填好了，但是识别率依旧不好。又发现训练集全是英国人的发音，而测试集是我们中国人的发音，有一定口音的，最好用我们中国人自己的发音作为训练集。于是我们自己又录了用于训练的音源，为了加大训练的数据，又请好多其他人录了音源。训练后得到了新的模型，再放到thchs30里面验证，识别率有六七成了，这说明模型的大方向对了，为了提高识别率，模型还需要继续调试。&lt;/p&gt;

&lt;p&gt;接下来就要看代码部分是否有问题了。把新生产的模型放进我们自己的系统，并且用从音频文件都数据的方式（我们的系统既可以从MIC采集数据也可以从音频文件读数据，从音频文件读数据是为了debug）来替代从MIC采集到的数据（这样做是为了排除噪声等因素的干扰）来看代码是否有问题。运行下来发现识别率依旧很差，这说明我们的代码也是有问题的。在第二阶段我已经调试过部分代码，确保了在kaldi process thread里从PCM ring buffer里拿到的音频数据是没有问题的。还有两方面需要调试，一是送进MFCC的PCM数据要是OK的，二是我们的在线解码机制要跟kaldi里的在线解码机制完全一样。一很快就调试好了。二是先再深入研究吃透kaldi里的在线解码机制，改正我们与它不一样的地方，经过两三天调试后识别率跟thchs30里的差不多了，这说明我们的代码经过调试后也有一个好的base了，后面就要开始调性能了。&lt;/p&gt;

&lt;p&gt;前面是通过从音频文件中读取数据来做在线识别的，数据相对干净些。现在要从MIC读取音频数据做真正在线识别了，试下来后识别率明显偏低，这说明我们的前处理还没完全做好（前面调试时只加了ANS模块）。我把前处理后的音频数据dump出来用CoolEdit听，的确有时候音质不好，于是我又把webRTC中的AGC模块加上去，再次dump出前处理后的音频数据听，多次听后都感觉音质正常。再来运行加了AGC后的从MIC采集音频数据的在线识别，识别率果然有了明显的提升。前处理能做的都做了，要想再提高识别率，就要靠模型发力了。做模型的同学一边请更多的人录音源来训练，一边尝试各种模型，最终用的是tri4b，有了一个相对不错的识别率。由于我们用的是GMM-HMM，如今主流的语音识别中已不再使用，老板就觉得没有必要再调了，后面肯定会用主流的模型的，但是整个嵌入式上的在线语音识别软件代码尤其软件架构和音频采集还是有用的，后面就要基于这些代码做真正的产品。&lt;/p&gt;

&lt;p&gt;对语音识别领域的资深人士来说，这个嵌入式在线语音识别系统还很稚嫩。但通过搭这个系统，让我们对语音识别领域有了多一点的感性认识，也有了一个良好的开端，给老板以信心，并且可以继续做下去。这次工程上的事情偏多，后面希望更深入的做下去，累积更多的语音识别领域的经验。搭这个系统没有任何可供参考的资料，纯粹是根据我们以往的经验摸索着搭出来的。做的产品可能不一样，但很多解决问题的思路都是一样的。如果有朋友也搭过嵌入式上的在线语音识别系统，欢迎探讨，搭出一个更好的在线语音识别系统。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:21:00 +0000</pubDate>
<dc:creator>davidtym</dc:creator>
<og:description>前面的博客里说过最近几个月我从传统语音（语音通信）切到了智能语音（语音识别）。刚开始是学语音识别领域的基础知识，学了后把自己学到的写了PPT给组内同学做了presentation（语音识别传统方法(G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/talkaudiodev/p/11240033.html</dc:identifier>
</item>
<item>
<title>高可用的K8S集群部署方案 - KAnts</title>
<link>http://www.cnblogs.com/ants/p/11489598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/11489598.html</guid>
<description>&lt;ol&gt;&lt;li&gt;LVS&lt;/li&gt;
&lt;li&gt;HAProxy&lt;/li&gt;
&lt;li&gt;Harbor&lt;/li&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;Kubernetes (Master Worker)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/7ecacd23ly1g6nalv8ub6j20z80trq3p.jpg&quot;/&gt;&lt;br/&gt;以上是最小生产可用的整体拓补图（相关节点根据需要进行增加，但不能减少）&lt;/p&gt;
&lt;p&gt;按功能组划分&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SLB
&lt;ul&gt;&lt;li&gt;LVS&lt;/li&gt;
&lt;li&gt;HAProxy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;K8S Node (Master / Worker)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LVS 、HAProxy 被规划为基础层，主要提供了一个高可用的7层负载均衡器。&lt;br/&gt;由LVS keepalived 提供一个高可用的VIP（虚拟IP）。&lt;br/&gt;这个VIP DR模式转发到后端的HAProxy服务器。&lt;br/&gt;HAProxy反代了K8S Master服务器，提供了K8S Master API的高可用和负载均衡能力。&lt;/p&gt;
&lt;h2 id=&quot;可以使用nginx代替haproxy吗&quot;&gt;可以使用Nginx代替HAProxy吗？&lt;/h2&gt;
&lt;p&gt;是可以的，这边使用HAproxy是因为k8s文档中出现了HAproxy，且后续可能会有4层反代的要求，从而使用了HAProxy。&lt;/p&gt;
&lt;h2 id=&quot;可以直接从lvs转发到master吗&quot;&gt;可以直接从LVS转发到Master吗？&lt;/h2&gt;
&lt;p&gt;理论上可行，我没有试验。&lt;br/&gt;如果不缺两台机器推荐还是架设一层具有7层代理能力的服务。&lt;br/&gt;k8s apiserver、harbor、etcd都是以HTTP的方式提供的api，如果有7层代理能力的服务后续会更容易维护和扩展。&lt;/p&gt;
&lt;h2 id=&quot;推荐配置&quot;&gt;推荐配置&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Keepalive&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HAProxy&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4GB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;etcd是一个采用了raft算法的分布式键值存储系统。&lt;br/&gt;这不是k8s专属的是一个独立的分布式系统，具体的介绍大家可以参考官网，这边不多做介绍。&lt;br/&gt;我们采用了 static pod的方式部署了etcd集群。&lt;/p&gt;
&lt;h2 id=&quot;失败容忍度&quot;&gt;失败容忍度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最小可用节点数：(n/2)+1&lt;/strong&gt;，下面是一个参考表格，其中加粗的是推荐的节点数量：&lt;br/&gt;| 总数 | 最少存活 | 失败容忍 |&lt;br/&gt;| :--: | :--: | :--: |&lt;br/&gt;| 1 | 1 | 0 |&lt;br/&gt;| 2 | 2 | 0 |&lt;br/&gt;| 3 | 2 | &lt;strong&gt;1&lt;/strong&gt; |&lt;br/&gt;| 4 | 3 | 1 |&lt;br/&gt;| 5 | 3 | &lt;strong&gt;2&lt;/strong&gt; |&lt;br/&gt;| 6 | 4 | 2 |&lt;br/&gt;| 7 | 4 | &lt;strong&gt;3&lt;/strong&gt; |&lt;br/&gt;| 8 | 5 | 3 |&lt;br/&gt;| 9 | 5 | &lt;strong&gt;4&lt;/strong&gt; |&lt;/p&gt;
&lt;h2 id=&quot;推荐配置-1&quot;&gt;推荐配置&lt;/h2&gt;
&lt;p&gt;括号内是官方推荐的配置&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;etcd&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4 (8~16)&lt;/td&gt;
&lt;td&gt;8GB (16GB~64GB)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;1.6411483253589&quot;&gt;
&lt;p&gt;&lt;strong&gt;官网:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://etcd.io/&quot; class=&quot;uri&quot;&gt;https://etcd.io/&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;官方硬件建议:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://etcd.io/docs/v3.3.12/op-guide/hardware/&quot; class=&quot;uri&quot;&gt;https://etcd.io/docs/v3.3.12/op-guide/hardware/&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;Static Pod部署文档:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;kubernetes集群主要有两种类型的节点：Master和Worker。&lt;br/&gt;Master则是集群领导。&lt;br/&gt;Worker是工作者节点。&lt;br/&gt;可以看出这边主要的工作在Master节点，Worker节点根据具体需求随意增减就好了。&lt;br/&gt;Master节点的高可用拓补官方给出了两种方案。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Stacked etcd topology（堆叠etcd）&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;External etcd topology（外部etcd）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;可以看出最主要的区别在于etcd的部署方式。&lt;/strong&gt;&lt;br/&gt;第一种方案是所有k8s Master节点都运行一个etcd在本机组成一个etcd集群。&lt;br/&gt;第二种方案则是使用外部的etcd集群（额外搭建etcd集群）。&lt;br/&gt;我们采用的是第二种，外部etcd，拓补图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/7ecacd23ly1g6nck4sziij21yw1cugsm.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果采用堆叠的etcd拓补图则是：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/7ecacd23ly1g6ncnb681tj21ye1a8458.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这边大家可以根据具体的情况选择，推荐使用第二种，外部的etcd。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.68421052631579&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考来源:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;master节点的组件&quot;&gt;Master节点的组件&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;apiserver&lt;/li&gt;
&lt;li&gt;controller-manager&lt;/li&gt;
&lt;li&gt;scheduler&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个master节点主要含有上面3个组件 ( 像cloud-controller-manager这边就不多做说明了，正常不会用到 )&lt;br/&gt;&lt;strong&gt;apiserver&lt;/strong&gt;: 一个api服务器，所有外部与k8s集群的交互都需要经过它。（可水平扩展）&lt;br/&gt;&lt;strong&gt;controller-manager&lt;/strong&gt;: 执行控制器逻辑（循环通过apiserver监控集群状态做出相应的处理）（一个master集群中只会有一个节点处于激活状态）&lt;br/&gt;&lt;strong&gt;scheduler&lt;/strong&gt;: 将pod调度到具体的节点上（一个master集群中只会有一个节点处于激活状态）&lt;/p&gt;
&lt;p&gt;可以看到除了apiserver外都只允许一个 实例处于激活状态（类HBase）运行于其它节点上的实例属于待命状态，只有当激活状态的实例不可用时才会尝试将自己设为激活状态。&lt;br/&gt;这边牵扯到了领导选举（zookeeper、consul等分布式集群系统也是需要领导选举）&lt;/p&gt;
&lt;h3 id=&quot;master高可用需要几个节点失败容忍度是多少&quot;&gt;Master高可用需要几个节点？失败容忍度是多少？&lt;/h3&gt;
&lt;p&gt;k8s依赖etcd所以不存在数据一致性的问题（把数据一致性压到了etcd上），所以k8s master不需要采取投票的机制来进行选举，而只需节点健康就可以成为leader。&lt;br/&gt;所以这边master并不要求奇数，偶数也是可以的。&lt;br/&gt;那么master高可用至少需要2个节点，失败容忍度是(n/0)+1，也就是只要有一个是健康的k8s master集群就属于可用状态。（&lt;strong&gt;这边需要注意的是master依赖etcd，如果etcd不可用那么master也将不可用&lt;/strong&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;1.0909090909091&quot;&gt;
&lt;p&gt;&lt;strong&gt;Master组件说明:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/components/&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/concepts/overview/components/&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;部署文档:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;硬件配置&quot;&gt;硬件配置&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Master&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8GB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;至此生产可用的k8s集群已“搭建完成”。为什么打引号？因为还没有进行测试和验证，下面给出我列出的验证清单&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/7ecacd23ly1g6ptptfpcij22160pujze.jpg&quot;/&gt;&lt;br/&gt;还有涉及的BGP相关的验证不在此次文章内容中，后续会为大家说明。&lt;/p&gt;

&lt;p&gt;还有一点需要注意的是物理机的可用性，如果这些虚拟机全部在一台物理机上那么还是存在“单点问题”。&lt;strong&gt;这边建议至少3台物理机以上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要3台物理机以上？&lt;/strong&gt;&lt;br/&gt;主要是考虑到了etcd的问题，如果只有两台物理机部署了5个etcd节点，那么部署了3个etcd的那台物理机故障了，则不满足etcd失败容忍度而导致etcd集群宕机，从而导致k8s集群宕机。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:20:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<og:description>涉及到的内容 1. LVS 2. HAProxy 3. Harbor 4. etcd 5. Kubernetes (Master Worker) 整体拓补图 以上是最小生产可用的整体拓补图（相关节点根</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ants/p/11489598.html</dc:identifier>
</item>
<item>
<title>给 Flutter 界面切换来点特效 - 安卓小煜</title>
<link>http://www.cnblogs.com/nesger/p/11489579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/11489579.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文微信公众号「AndroidTraveler」首发。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;我们知道页面之间如果直接切换，会比较生硬，还会让用户觉得很突兀，用户体验不是很好。&lt;/p&gt;
&lt;p&gt;因此一般情况下，页面之间的切换为了达到平滑过渡，都会添加动画。&lt;/p&gt;
&lt;p&gt;另外，有时候我们不喜欢系统的默认动画，希望能够自定义动画。&lt;/p&gt;
&lt;p&gt;基于此，本篇主要讲述如何给 Flutter 的页面切换增加自定义动画。&lt;/p&gt;
&lt;h3 id=&quot;默认效果&quot;&gt;默认效果&lt;/h3&gt;
&lt;p&gt;首先我们看看默认效果是怎样的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/5/16d00b86b773d013?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=91463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来似乎还不错。代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;import 'package:flutter/material.dart';

void main() =&amp;gt; runApp(MaterialApp(
      home: MyApp(),
    ));

class MyApp extends StatelessWidget {
  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return _getCenterWidget(RaisedButton(
        child: Text('Go to next page-&amp;gt;'),
        onPressed: () {
          Navigator.of(context).push(_createRoute());
        }));
  }
}

Route _createRoute() {
  return MaterialPageRoute(builder: (BuildContext context) =&amp;gt; Page2());
}

class Page2 extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return _getCenterWidget(Text('Page2'));
  }
}

Widget _getCenterWidget(Widget child) {
  return Scaffold(
    appBar: AppBar(),
    body: Center(
      child: child,
    ),
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到创建了两个页面 MyApp 和 Page2。&lt;/p&gt;
&lt;p&gt;第一个页面 MyApp 有一个按钮，第二个页面 Page2 有一个文本。&lt;/p&gt;
&lt;p&gt;关键的切换就在 _createRoute() 这个路由创建方法里面。&lt;/p&gt;
&lt;p&gt;我们点进去 MaterialPageRoute 源码，可以看到&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;  @override
  Widget buildTransitions(BuildContext context, Animation&amp;lt;double&amp;gt; animation, Animation&amp;lt;double&amp;gt; secondaryAnimation, Widget child) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions&amp;lt;T&amp;gt;(this, context, animation, secondaryAnimation, child);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上一开始的注释，可以知道这个就是默认的界面切换过渡效果。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by [MaterialPageRoute.buildTransitions].&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外这里可以看到默认的动画时长为 300ms，而且我们不能自定义。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;  @override
  Duration get transitionDuration =&amp;gt; const Duration(milliseconds: 300);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们就说说如何自定义我们的界面切换过渡效果，并且自定义动画时长。&lt;/p&gt;
&lt;h3 id=&quot;自定义动画&quot;&gt;自定义动画&lt;/h3&gt;

&lt;p&gt;由上面的分析我们知道最关键的地方在创建路由方法 _createRoute() 中。&lt;/p&gt;
&lt;p&gt;因此我们首先修改一下，不使用默认的 &lt;strong&gt;MaterialPageRoute&lt;/strong&gt;，我们使用 &lt;strong&gt;PageRouteBuilder&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        return child;
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们通过 &lt;strong&gt;pageBuilder&lt;/strong&gt; 指定路由页面，通过 &lt;strong&gt;transitionsBuilder&lt;/strong&gt; 指定页面过渡效果。&lt;/p&gt;
&lt;p&gt;另外说明一下，这里的参数大家不用死记硬背，我们点进去源码一看就知道了，如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;/// Signature for the function that builds a route's primary contents.
/// Used in [PageRouteBuilder] and [showGeneralDialog].
///
/// See [ModalRoute.buildPage] for complete definition of the parameters.
typedef RoutePageBuilder = Widget Function(BuildContext context, Animation&amp;lt;double&amp;gt; animation, Animation&amp;lt;double&amp;gt; secondaryAnimation);

/// Signature for the function that builds a route's transitions.
/// Used in [PageRouteBuilder] and [showGeneralDialog].
///
/// See [ModalRoute.buildTransitions] for complete definition of the parameters.
typedef RouteTransitionsBuilder = Widget Function(BuildContext context, Animation&amp;lt;double&amp;gt; animation, Animation&amp;lt;double&amp;gt; secondaryAnimation, Widget child);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们运行代码，由于直接返回 &lt;strong&gt;child&lt;/strong&gt;，所以应该是没有动画效果的。我们运行之后，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/5/16d017e77365532d?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=56567&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加-tween-和-slidetransition&quot;&gt;2. 添加 Tween 和 SlideTransition&lt;/h4&gt;
&lt;p&gt;默认的过渡效果是从右边往左过来，我们这里自定义的演示效果就从下面往上过渡好了。&lt;/p&gt;
&lt;p&gt;需要了解一下的是 &lt;strong&gt;Tween&lt;/strong&gt; 是一个介于开始和结束值的线性插值器。&lt;/p&gt;
&lt;p&gt;另外我们跟进上面的 &lt;strong&gt;transitionsBuilder&lt;/strong&gt; 可以知道他的第一个 &lt;strong&gt;animation&lt;/strong&gt; 参数取值为 0.0 到 1.0。&lt;/p&gt;
&lt;p&gt;我们这边是从下往上，所以 y 轴的偏移就是由 1.0 到 0.0，表示竖直方向距离顶部一整个页面到不存在偏移（已经在顶部）。&lt;/p&gt;
&lt;p&gt;因此关于 &lt;strong&gt;Tween&lt;/strong&gt; 和 &lt;strong&gt;animation&lt;/strong&gt; 我们可以得到：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;var begin = Offset(0.0, 1.0);
var end = Offset(0.0, 0.0);
var tween = Tween(begin: begin, end: end);
var offsetAnimation = animation.drive(tween);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们是要实现滑动，因此将这个确定好的偏移动画通过 &lt;strong&gt;SlideTransition&lt;/strong&gt; 处理并返回，可以得到修改后的路由代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
    transitionDuration: Duration(seconds: 5),
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        var begin = Offset(0.0, 1.0);
        var end = Offset(0.0, 0.0);
        var tween = Tween(begin: begin, end: end);
        var offsetAnimation = animation.drive(tween);

        return SlideTransition(
          position: offsetAnimation,
          child: child,
        );
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d045c7e27cd7a2?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=57322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到上面效果，可能有小伙伴会有疑问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题一：你打开页面是从下到上我可以理解，但是返回为什么是反过来的从上到下呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们跟进去 &lt;strong&gt;transitionsBuilder&lt;/strong&gt; 的源码，可以看到&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  final RouteTransitionsBuilder transitionsBuilder;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们跟进去（通过点击）注释里面的 &lt;strong&gt;buildTransitions&lt;/strong&gt;，可以看到 &lt;strong&gt;animation&lt;/strong&gt; 的说明如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,
  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]
  ///    pops the topmost route this animation runs from 1.0 to 0.0.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到入栈和出栈的动画效果是相反的，而这个也符合我们的认知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二：现在的效果是从下到上，如果我要实现从上到下，是不是将 begin 和 end 的 Offset 交换一下就可以？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实如果你理解我上面说的这句话&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们这边是从下往上，所以 y 轴的偏移就是由 1.0 到 0.0，表示竖直方向距离顶部一整个页面到不存在偏移（已经在顶部）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你就会知道，改成从 0.0 到 1.0 会是什么情况。&lt;/p&gt;
&lt;p&gt;我们改一下，通过实际演示效果来说明。&lt;/p&gt;
&lt;p&gt;修改后的代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        var begin = Offset(0.0, 0.0);
        var end = Offset(0.0, 1.0);
        var tween = Tween(begin: begin, end: end);
        var offsetAnimation = animation.drive(tween);

        return SlideTransition(
          position: offsetAnimation,
          child: child,
        );
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅是 begin 和 end 的 Offset 做了交换。&lt;/p&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d046fc4609c102?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=38056&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然能够看出一点端倪，但是我们前面讲过，默认动画时长是 300 ms，所以比较快，这样不好分析。&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;strong&gt;PageRouteBuilder&lt;/strong&gt; 的 &lt;strong&gt;transitionDuration&lt;/strong&gt; 属性来设置动画的时长。&lt;/p&gt;
&lt;p&gt;我们设置 3s 来看下效果，代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
      transitionDuration: Duration(seconds: 3),
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        var begin = Offset(0.0, 0.0);
        var end = Offset(0.0, 1.0);
        var tween = Tween(begin: begin, end: end);
        var offsetAnimation = animation.drive(tween);

        return SlideTransition(
          position: offsetAnimation,
          child: child,
        );
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d04c1a85a86b51?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=85724&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到了吧，确实是反过来了，从一开始距离顶部为 0.0，到距离顶部 1.0（100%）。&lt;/p&gt;
&lt;p&gt;那么如果我想实现从上到下进入怎么办呢？&lt;/p&gt;
&lt;p&gt;我们给一张图，相信看完你就懂了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d04c854ce490d6?w=1572&amp;amp;h=2034&amp;amp;f=png&amp;amp;s=167517&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这张图我们知道，如果我们从下往上，y 应该从 1.0 变到 0.0。如果要从上往下，y 应该从 -1.0 变到 0.0。&lt;/p&gt;
&lt;p&gt;所以我们修改代码，如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
      transitionDuration: Duration(seconds: 3),
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        var begin = Offset(0.0, -1.0);
        var end = Offset(0.0, 0.0);
        var tween = Tween(begin: begin, end: end);
        var offsetAnimation = animation.drive(tween);

        return SlideTransition(
          position: offsetAnimation,
          child: child,
        );
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d04cbab8364a18?w=450&amp;amp;h=936&amp;amp;f=gif&amp;amp;s=83888&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过-curvetween-来点加速度&quot;&gt;3. 通过 CurveTween 来点加速度&lt;/h4&gt;
&lt;p&gt;当我们将动画时长设置为 3s 之后，我们可以明显的看到我们的动画速度似乎是匀速的。&lt;/p&gt;
&lt;p&gt;那么如果我想修改下动画的速度，比如进来快，结束慢，可不可以呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的。&lt;/p&gt;
&lt;p&gt;我们通过 CurveTween 可以来实现这个需求。&lt;/p&gt;
&lt;p&gt;使用的重点在于 curve 的选择，所以我们要选择哪种 curve 呢？&lt;/p&gt;
&lt;p&gt;其实 Flutter 我比较喜欢的一个点就是代码注释详细，并且还有 demo 演示。&lt;/p&gt;
&lt;p&gt;我们进入 Curves 源码，以 Curves.ease 为例：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;  /// A cubic animation curve that speeds up quickly and ends slowly.
  ///
  /// {@animation 464 192 https://flutter.github.io/assets-for-api-docs/assets/animation/curve_ease.mp4}
  static const Cubic ease = Cubic(0.25, 0.1, 0.25, 1.0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释说了启动快，结束慢，而且还有一个 mp4 链接，点击可以看到如下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d04d278c500b97?w=462&amp;amp;h=177&amp;amp;f=gif&amp;amp;s=120549&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出它的变化趋势，通过斜率可以看出前期快，后期慢，而且右边还有四种动画的效果预览。&lt;/p&gt;
&lt;p&gt;我们设置 CurveTween 代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;var curveTween = CurveTween(curve: Curves.ease);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到很简单，选择一种你想要的变化趋势即可。&lt;/p&gt;
&lt;h4 id=&quot;组合-tween-和-curvetween&quot;&gt;4. 组合 Tween 和 CurveTween&lt;/h4&gt;
&lt;p&gt;这个也比较简单，通过 Tween 自带的 chain 方法即可，如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: Curves.ease));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一般 Offset(0.0, 0.0) 可以直接写为 Offset.zero。&lt;/p&gt;
&lt;p&gt;修改后代码为：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Route _createRoute() {
  return PageRouteBuilder(
      transitionDuration: Duration(seconds: 3),
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder:(context, animation, secondaryAnimation, child) {
        var begin = Offset(0.0, 1.0);
        var end = Offset.zero;
        var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: Curves.ease));

        return SlideTransition(
          position: animation.drive(tween),
          child: child,
        );
      }
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d052f86ab4e5e3?w=450&amp;amp;h=939&amp;amp;f=gif&amp;amp;s=163705&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;完整例子&quot;&gt;5. 完整例子&lt;/h4&gt;
&lt;p&gt;有了上面的基础，我们就可以将四个方向的动画效果都加上，当然我们这边就不延时了。另外为了演示方便，就直接打开后 delay 1s 返回。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;import 'package:flutter/material.dart';

void main() =&amp;gt; runApp(MaterialApp(
      home: MyApp(),
    ));

class MyApp extends StatelessWidget {
  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return _getCenterWidget(Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: &amp;lt;Widget&amp;gt;[
        _getBtn(context, 'right in',
            Tween(begin: Offset(1.0, 0.0), end: Offset.zero)),
        _getBtn(context, 'left in',
            Tween(begin: Offset(-1.0, 0.0), end: Offset.zero)),
        _getBtn(context, 'bottom in',
            Tween(begin: Offset(0.0, 1.0), end: Offset.zero)),
        _getBtn(context, 'top in',
            Tween(begin: Offset(0.0, -1.0), end: Offset.zero)),
      ],
    ));
  }
}

Widget _getBtn(BuildContext context, String textContent, Tween&amp;lt;Offset&amp;gt; tween) {
  return RaisedButton(
      child: Text(textContent),
      onPressed: () {
        Navigator.of(context).push(_createRoute(tween));
      });
}

Route _createRoute(Tween&amp;lt;Offset&amp;gt; tween) {
  return PageRouteBuilder(
      pageBuilder: (context, animation, secondaryAnimation) =&amp;gt; Page2(),
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return SlideTransition(
          position:
              animation.drive(tween.chain(CurveTween(curve: Curves.ease))),
          child: child,
        );
      });
}

class Page2 extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    Future.delayed(Duration(seconds: 1), () {
      Navigator.of(context).pop();
    });
    return _getCenterWidget(Text('Page2'));
  }
}

Widget _getCenterWidget(Widget child) {
  return Scaffold(
    appBar: AppBar(),
    body: Center(
      child: child,
    ),
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d053cdc57d316b?w=450&amp;amp;h=939&amp;amp;f=gif&amp;amp;s=178845&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;到了这里，基本就把 Flutter 界面之间的过渡说清楚了。&lt;/p&gt;
&lt;p&gt;其他的比如旋转、缩放、透明度甚至组合动画，相信有了上面的基础，你也可以自行进行 DIY。&lt;/p&gt;
&lt;p&gt;这里附上缩放的效果如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/6/16d05aaf5d69c1a1?w=450&amp;amp;h=939&amp;amp;f=gif&amp;amp;s=86640&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体代码见 GitHub：&lt;br/&gt;&lt;a href=&quot;https://github.com/nesger/flutter_page_transition&quot;&gt;flutter_page_transition&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://flutter.dev/docs/cookbook/animation/page-route-animation&quot;&gt;Animate a page route transition&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://api.flutter.dev/flutter/animation/Tween-class.html&quot;&gt;Tween class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多阅读：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/mp/homepage?__biz=MzI3OTAyNzAwNg==&amp;amp;hid=1&amp;amp;sn=b4b216d105a1496cd72ec6729bb22279&amp;amp;scene=18#wechat_redirect&quot;&gt;Flutter 即学即用系列博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/mp/homepage?__biz=MzI3OTAyNzAwNg==&amp;amp;hid=5&amp;amp;sn=7e4598d8b00537fe2846f2e85d746b9a&amp;amp;scene=18#wechat_redirect&quot;&gt;Flutter &amp;amp; Dart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/5/16bc08e14696aba3?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=231181&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:11:00 +0000</pubDate>
<dc:creator>安卓小煜</dc:creator>
<og:description>本文微信公众号「AndroidTraveler」首发。 背景 我们知道页面之间如果直接切换，会比较生硬，还会让用户觉得很突兀，用户体验不是很好。 因此一般情况下，页面之间的切换为了达到平滑过渡，都会添</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nesger/p/11489579.html</dc:identifier>
</item>
<item>
<title>分析一次double强转float的翻车原因 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/11489577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/11489577.html</guid>
<description>&lt;p&gt;人逢喜事精神爽,总算熬到下班撩~~&lt;br/&gt;正准备和同事打个招呼回家,被同事拖住问了.&lt;br/&gt;🙋‍♂️: 你们组做的那块代码,把double类型数据成float有问题啊💨.&lt;br/&gt;💁‍♀️: 嗯?不对是正常啊,float精度是没有double高,但float能保存到小数点后好多位,对我们来说完全够用了!&lt;br/&gt;🙋‍♂️: 不是啊,这不是小数点多少位的问题,而是现在整型数据,转出来也有问题啊,你看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/DoubleToFloat.png&quot; alt=&quot;翻车&quot;/&gt;&lt;/p&gt;
&lt;p&gt;💁‍♀️: XX00😱.... 这什么鬼?&lt;/p&gt;
&lt;p&gt;看到这个结果,差点闪到我的老腰🤦,咋不按套路出牌呢?&lt;br/&gt;然后,下班路上,感觉我好像被我挚爱的.Net欺骗了💔,double强转float用了这么多年,咋说不对就不对了?.Net不靠谱啊!&lt;/p&gt;

&lt;p&gt;当然,我内心还是相信.Net是清白的,所以刨根究底,网上找的资料大多是说这种强转会照成小数点后的精度的问题,可是造成整数位的问题精度问题却少有人提及.&lt;br/&gt;为了理解这个问题,我们要从一些大学计算机基础的相关知识讲起😂.&lt;/p&gt;
&lt;h2 id=&quot;float和double有什么不同&quot;&gt;float和double有什么不同?&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;float四个字节,double八个字节.&lt;/li&gt;
&lt;li&gt;float范围从10^-38到10^38 和 -10^38到-10^-38, double的范围从10^-308到10^308 和 -10^-308到-10^-308&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然了,这都是废话🤷, 重点是下面这条.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;float是&lt;code&gt;单精度浮点数&lt;/code&gt;,double是&lt;code&gt;双精度浮点数&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;单精度与双精度什么区别&quot;&gt;单精度与双精度什么区别&lt;/h2&gt;
&lt;p&gt;根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/official.png&quot; alt=&quot;float&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。&lt;/p&gt;
&lt;p&gt;十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。&lt;/p&gt;
&lt;p&gt;对于32位的&lt;code&gt;单精度&lt;/code&gt;浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/float.jpg&quot; alt=&quot;float&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于64位的&lt;code&gt;双精度&lt;/code&gt;浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/double.jpg&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过上面关于浮点数的介绍,相信你可能还是一头雾水,就像下面这幅漫画展示的那样🐎.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/horse.png&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;浮点数转成内存存储&quot;&gt;浮点数转成内存存储&lt;/h2&gt;
&lt;p&gt;为了避免产生上面那种画马的跳跃,我们一小步一小步,看看浮点数据具体怎么在内存中存储的.双精度与单精度类似,这里我以单精度为例.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先将这个实数的绝对值化为二进制格式。&lt;/li&gt;
&lt;li&gt;将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。&lt;/li&gt;
&lt;li&gt;从小数点右边第一位开始数出二十三位数字放入第22到第0位。&lt;/li&gt;
&lt;li&gt;如果实数是正的，则在第31位放入“0”，否则放入“1”。&lt;/li&gt;
&lt;li&gt;⭐如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。&lt;/li&gt;
&lt;li&gt;如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们先用上述步骤尝试把9.0转化成二进制存储形式.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/float9.0.png&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过这个地址校验计算结果的正确性. &lt;a href=&quot;https://www.h-schmidt.net/FloatConverter/IEEE754.html&quot; class=&quot;uri&quot;&gt;https://www.h-schmidt.net/FloatConverter/IEEE754.html&lt;/a&gt;&lt;br/&gt;可以看到,与我们的计算结果完全一致.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/float9.0Result.png&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在我们用上面的步骤,把照成翻车的83459338转成内存存储形式看看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/floatTest.png&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过在线工具转换后证实我们的转换完全正确.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/floatTestResult.png&quot; alt=&quot;double&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再把数据转回来.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/pic/DoubleToFloat/official.png&quot; alt=&quot;float&quot;/&gt;&lt;/p&gt;
&lt;p&gt;S是第31位,为0, E =&lt;code&gt;0011001&lt;/code&gt;(25)+1=26, 重点在M,它是1.(&lt;code&gt;有效数字位&lt;/code&gt;)即 &lt;code&gt;1.00111110010111110100001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.00111110010111110100001&lt;/code&gt;乘上2的26次方,为&lt;code&gt;100111110010111110100001000&lt;/code&gt;,将其转换为十进制,为 &lt;code&gt;83459336&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;没错,就是&lt;code&gt;83459336&lt;/code&gt;,而不是&lt;code&gt;83459338&lt;/code&gt;🌋&lt;br/&gt;83459338=&amp;gt; &lt;code&gt;100111110010111110100001010&lt;/code&gt;&lt;br/&gt;83459336=&amp;gt; &lt;code&gt;100111110010111110100001000&lt;/code&gt;&lt;br/&gt;可以看到,两个数字转成成二进制后,倒数第二位产生了差异,而产生这种的差异的原因就是单精度浮点数小数位23位不足以存储所有二进制数(26位).&lt;br/&gt;🚑这场事故告诉我们,强转虽好,容易翻车.&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:09:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>背景 人逢喜事精神爽,总算熬到下班撩~~ 正准备和同事打个招呼回家,被同事拖住问了. 🙋‍♂️: 你们组做的那块代码,把double类型数据成float有问题啊💨. 💁‍♀️: 嗯?不对是正常啊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoderAyu/p/11489577.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core结合Nacos来完成配置管理和服务发现 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/11489052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/11489052.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今年4月份的时候，和平台组的同事一起调研了一下Nacos，也就在那个时候写了.net core版本的非官方版的&lt;a href=&quot;https://github.com/catcherwong/nacos-sdk-csharp&quot;&gt;SDK&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然公司内部由于某些原因最后没有真正的用起来，但很多人还是挺看好的。在和镇汐大大沟通后，决定写一篇博客简单介绍一下。&lt;/p&gt;
&lt;p&gt;下面这个图，就是本文的重点了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908224330144-915666479.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nacos的简介&quot;&gt;Nacos的简介&lt;/h2&gt;
&lt;p&gt;Nacos是一个易于构建云原生应用的动态服务发现、配置管理和服务管理平台，它提供了一组简单易用的特性集，帮助我们快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;/p&gt;
&lt;p&gt;它有下面的关键特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务发现和服务健康监测&lt;/li&gt;
&lt;li&gt;动态配置服务&lt;/li&gt;
&lt;li&gt;动态 DNS 服务&lt;/li&gt;
&lt;li&gt;服务及其元数据管理&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特性还是挺多的，也有挺多值的挖掘的地方。有关Nacos的更多信息可以访问下面的地址：&lt;/p&gt;
&lt;p&gt;下面就开始正题了，第一步肯定是先把Nacos跑起来。&lt;/p&gt;
&lt;h2 id=&quot;启动nacos&quot;&gt;启动Nacos&lt;/h2&gt;
&lt;p&gt;由于是演示，所以直接用docker启动了&lt;code&gt;Standalone Mysql&lt;/code&gt;模式的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone --depth 1 https://github.com/nacos-group/nacos-docker.git
cd nacos-docker
docker-compose -f example/standalone-mysql.yaml up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行docker-compose后，会先拉取几个镜像回来，然后就看到下面的输出，基本就是正常启动了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908224946299-1324916241.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器访问 &lt;code&gt;http://localhost:8848/nacos&lt;/code&gt; 就可以看到Nacos控制台的登录界面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908224955441-1831367.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始的用户名和密码都是 &lt;strong&gt;nacos&lt;/strong&gt;，登录进来之后大概是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225006002-261555734.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到运行起来的Nacos，版本是1.1.3，还有清晰可见的几个大菜单，这些都是可以很方便我们去进行管理的。&lt;/p&gt;
&lt;p&gt;那我们就先来看一下Nacos的配置管理吧。&lt;/p&gt;
&lt;h2 id=&quot;配置管理&quot;&gt;配置管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225018119-1237551115.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的特性大图中，已经很明确的告诉了我们配置管理的几个重要功能。&lt;/p&gt;
&lt;p&gt;在配置中有几个比较重要的概念需要先了解一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tenant 租户信息，对应 Nacos 的命名空间字段。&lt;/li&gt;
&lt;li&gt;dataId 配置ID。&lt;/li&gt;
&lt;li&gt;group 配置分组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先添加下面这个nuget包，然后看一下这个配置要怎么玩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet add package nacos-sdk-csharp-unofficial&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有必不可少的就是在&lt;code&gt;Startup&lt;/code&gt;里面进行配置。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // configuration
    services.AddNacos(configure =&amp;gt;
    {
        // default timeout
        configure.DefaultTimeOut = 8;
        // nacos's endpoint
        configure.ServerAddresses = new System.Collections.Generic.List&amp;lt;string&amp;gt; { &quot;localhost:8848&quot; };
        // namespace
        configure.Namespace = &quot;&quot;;
        // listen interval
        configure.ListenInterval = 1000;
    });
    
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也算是比较常见的配置了，就不多说了，还可以通过配置文件来加载配置。&lt;/p&gt;
&lt;p&gt;这些配置里面，其实最主要的就是Nacos的地址。&lt;/p&gt;
&lt;p&gt;先来看看最简单的获取配置信息。&lt;/p&gt;
&lt;p&gt;SDK中提供了一个名为&lt;code&gt;INacosConfigClient&lt;/code&gt;的Client接口，这个接口里面的所有内容都是操作配置相关的。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ConfigController : ControllerBase
{
    private readonly INacosConfigClient _configClient;

    public ConfigController(INacosConfigClient configClient)
    {
        _configClient = configClient;
    }

    // GET api/config?key=demo1
    [HttpGet(&quot;&quot;)]
    public async Task&amp;lt;string&amp;gt; Get([FromQuery]string key)
    {
        var res = await _configClient.GetConfigAsync(new GetConfigRequest
        {
            DataId = key,
            Group = &quot;DEFAULT_GROUP&quot;,
            //Tenant = &quot;tenant&quot;
        }) ;

        return string.IsNullOrWhiteSpace(res) ? &quot;Not Found&quot; : res;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面获取配置的这个获取配置的方法，大意就是 读取默认命名空间(public)下面的&lt;code&gt;DEFAULT_GROUP&lt;/code&gt;这个配置分组下面的，名为key的配置Id的值。&lt;/p&gt;
&lt;p&gt;如果我们输入的key，在Nacos上面没有，那个这个方法就会返回 &lt;code&gt;Not Found&lt;/code&gt;给调用方，如果有，那就会返回具体的配置值。&lt;/p&gt;
&lt;p&gt;由于我们是刚运行起行，什么都没有操作，所以肯定是没有任何配置信息的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225037046-1930222843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们就先添加一个，看看效果如何。&lt;/p&gt;
&lt;p&gt;同样在上面的控制器中加入下面的发布配置的方法，同样也是通过&lt;code&gt;INacosConfigClient&lt;/code&gt;来添加配置。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// GET api/config/add?key=demo1&amp;amp;value=123
[HttpGet(&quot;add&quot;)]
public async Task&amp;lt;string&amp;gt; Add([FromQuery]string key, [FromQuery]string value)
{
    var res = await _configClient.PublishConfigAsync(new PublishConfigRequest
    {
        DataId = key,
        Group = &quot;DEFAULT_GROUP&quot;,
        //Tenant = &quot;tenant&quot;
        Content = value
    });

    return res.ToString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225050205-457218085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们已经添加成功了。&lt;/p&gt;
&lt;p&gt;\回去控制台，也可以看到刚才加的配置已经出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225100488-783354970.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再一次访问获取配置信息的接口，就已经可以拿到对应的配置内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225110117-1543897535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面通过控制台去修改一下配置的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225120532-560147143.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点发布按钮的时候，会有一个比较页面，让我们对比前后修改了那些内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225128416-1709401361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们通过&lt;code&gt;INacosConfigClient&lt;/code&gt;去访问的话，发现是获取不到我们刚才更新的内容的。&lt;/p&gt;
&lt;p&gt;这个是因为，从Nacos读取配置成功后，会写入配置信息到本地缓存中，后面访问的话会优先去读缓存的内容。&lt;/p&gt;
&lt;p&gt;那么要怎么做到有人修改了配置内容后，它能实时生效呢？其实很简单，只需要添加一下对配置的监听就可以了。&lt;/p&gt;
&lt;p&gt;这个得益于Nacos允许我们监听配置，以便实时感知配置变更。如果配置变更，则用获取配置接口获取配置的最新值，动态刷新本地缓存。&lt;/p&gt;
&lt;p&gt;下面是一个简单的示例，这里用的是&lt;code&gt;BackgroundService&lt;/code&gt;来处理的。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class ListenConfigurationBgTask : BackgroundService
{
    private readonly ILogger _logger;

    private readonly INacosConfigClient _configClient;

    public ListenConfigurationBgTask(ILoggerFactory loggerFactory, INacosConfigClient configClient)
    {
        _logger = loggerFactory.CreateLogger&amp;lt;ListenConfigurationBgTask&amp;gt;();

        _configClient = configClient;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Add listener
        await _configClient.AddListenerAsync(new AddListenerRequest
        {
            DataId = &quot;demo1&quot;,
            //Group = &quot;DEFAULT_GROUP&quot;,
            //Tenant = &quot;tenant&quot;,
            Callbacks = new List&amp;lt;Action&amp;lt;string&amp;gt;&amp;gt;
            {
                x =&amp;gt;
                {
                    _logger.LogInformation($&quot; We found something changed!!! {DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)}  [{x}]&quot;);
                },
            }
        });
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        // Remove listener
        await _configClient.RemoveListenerAsync(new RemoveListenerRequest
        {
            DataId = &quot;demo1&quot;,
            Callbacks = new List&amp;lt;Action&amp;gt;
            {
                () =&amp;gt;
                {                        
                     _logger.LogInformation($&quot; Removed listerner  &quot;);
                },
            }
        });

        await base.StopAsync(cancellationToken);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里其实没有什么内容，就是在程序启动的时候添加一下监听，然后在程序退出的时候，同样也退出监听。&lt;/p&gt;
&lt;p&gt;不要忘记在Startup中加下面的代码，这样配置的监听才会生效！&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;services.AddHostedService&amp;lt;ListenConfigurationBgTask&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们添加监听之后，修改了配置文件的内容，它就可以动态的更新加载了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225156799-1495811929.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，控制台里面也有监听的记录，可以在&lt;strong&gt;监听查询&lt;/strong&gt;里面找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225204185-91669767.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是具体的程序日志输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225215768-675302413.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置的每一次修改，都会有历史记录，可以从历史版本里面找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225225804-613928728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了能看历史的记录，还可以回滚到指定的版本，这是个很有用的功能。&lt;/p&gt;
&lt;p&gt;在数据库中，配置信息的保存是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225236167-62787868.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个删除配置的方法，这里就不介绍了，都是差不多的用法，不过正常情况下是不应该删除配置的，除非是多余的。&lt;/p&gt;
&lt;p&gt;关于Nacos配置管理的介绍就先到这里了，有兴趣的朋友可以继续去深究。&lt;/p&gt;
&lt;p&gt;下面我们就来看看Nacos的服务发现。&lt;/p&gt;
&lt;h2 id=&quot;服务发现&quot;&gt;服务发现&lt;/h2&gt;
&lt;p&gt;关于服务注册和发现，听的比较多的大概就是，consul, eureka, etcd , k8s 等等。&lt;/p&gt;
&lt;p&gt;思路其实都差不多，在服务启动的时候，把当前服务的相关信息注册上去，然后要调用某个服务的时候，就获取这个服务下面的列表，然后选一个可用的进行访问。最后就是当服务停止的时候，我们要注销当前的服务。&lt;/p&gt;
&lt;p&gt;目前这个SDK提供了两种形式，一种是原始的API，一种是对原始API进行了封装，可以直接注册和发现相应的下游服务。&lt;/p&gt;
&lt;p&gt;原始的API在一个名为&lt;code&gt;INacosNamingClient&lt;/code&gt;的Client接口中提供，这个接口里面的所有内容都是服务发现相关的。&lt;/p&gt;
&lt;p&gt;不过在这里只介绍封装过后的使用方法，当然也可以自己根据原始的API进行封装处理。&lt;/p&gt;
&lt;p&gt;首先要添加下面这个nuget包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet add package nacos-sdk-csharp-unofficial.AspNetCore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先起来一个服务。&lt;/p&gt;
&lt;p&gt;先在配置文件&lt;code&gt;appsettings.json&lt;/code&gt;中添加下面的内容&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;nacos&quot;: {
    &quot;ServerAddresses&quot;: [ &quot;localhost:8848&quot; ],
    &quot;DefaultTimeOut&quot;: 15,
    &quot;Namespace&quot;: &quot;&quot;,
    &quot;ListenInterval&quot;: 1000,
    &quot;ServiceName&quot;: &quot;BaseService&quot;,
    &quot;Weight&quot;: 10
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个配置主要表达了，这个实例的服务名是 &lt;code&gt;BaseService&lt;/code&gt;， 权重是&lt;code&gt;10&lt;/code&gt;， Nacos的地址是 &lt;code&gt;localhost:8848&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后在Startup中把当前实例注册到Nacos。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;namespace BaseService
{
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Nacos.AspNetCore;

    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            // important step
            services.AddNacosAspNetCore(Configuration);
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }

        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();
            
            // important step
            app.UseNacosAspNetCore();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只需要简单的配置这两个地方就可以完成服务的注册功能了！！&lt;/p&gt;
&lt;p&gt;下面就启动这个程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225251576-1143129529.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在启动程序的时候，当前实例就会向Nacos发送心跳，心跳的里面包含了IP和端口等信息。&lt;/p&gt;
&lt;p&gt;回到控制台，我们可以看到这个服务现在已经有一个实例了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225300248-76758575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再启动一个同服务名的实例，这里只对接口返回的内容做了一下调整，其他都是一样的！&lt;/p&gt;
&lt;p&gt;这个时候点进服务的详情里面，可以看到更加具体的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225307858-1680683024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务现在是已经注册上来了，下面我们就再来一个服务去调用上面这个注册好的服务。&lt;/p&gt;
&lt;p&gt;Startup中的内容都是差不多的，不同的是，如果确定服务不被内部其它应用调用的话，可以不注册到Nacos上面。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class Startup
{
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public IConfiguration Configuration { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddHttpClient();
        services.AddNacosAspNetCore(Configuration);
        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMvc();

        //app.UseNacosAspNetCore();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是发现服务了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INacosServerManager&lt;/code&gt;里面提供了一个只根据服务名来获取健康的实例的地址信息。不足的地方就是忽略了命名空间和集群这些参数，会考虑在后面的版本中加上吧。&lt;/p&gt;
&lt;p&gt;这里获取到的地址信息是随机取出来的，最简单的轮训算法。。获取到一次所有的实例地址信息后会缓存10秒钟，这10秒钟里面就会直接从缓存中的地址信息取一个。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    private readonly INacosServerManager _serverManager;
    private readonly IHttpClientFactory _clientFactory;

    public ValuesController(INacosServerManager serverManager, IHttpClientFactory clientFactory)
    {
        _serverManager = serverManager;
        _clientFactory = clientFactory;
    }

    // GET api/values
    [HttpGet]
    public async Task&amp;lt;string&amp;gt; GetAsync()
    {
        var result = await GetResultAsync();

        if (string.IsNullOrWhiteSpace(result))
        {
            result = &quot;ERROR!!!&quot;;
        }

        return result;
    }

    private async Task&amp;lt;string&amp;gt; GetResultAsync()
    {
        var baseUrl = await _serverManager.GetServerAsync(&quot;BaseService&quot;);

        if (string.IsNullOrWhiteSpace(baseUrl))
        {
            return &quot;&quot;;
        }

        var url = $&quot;{baseUrl}/api/values&quot;;

        var client = _clientFactory.CreateClient();

        var result = await client.GetAsync(url);

        return await result.Content.ReadAsStringAsync();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果就来看动图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201909/558945-20190908225342386-794127973.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在两个实例的健康状态都是true的时候，会随机调用一个实例。&lt;/p&gt;
&lt;p&gt;当把其中一个实例停掉的时候，这个实例的健康状态就会被标识为false，这个时候就不会调用到这个false的实例。&lt;/p&gt;
&lt;p&gt;当把这个实例重新运行之后，又恢复到随机调用的情况。&lt;/p&gt;
&lt;p&gt;Nacos的服务发现除了上面介绍的，还有系统开关，数据指标，集群信息等功能，有待去深入挖掘。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;Nacos使用起来不算复杂，算是比较容易上手的，用的公司也挺多的了。&lt;/p&gt;
&lt;p&gt;还有个把 steeltoe 和Nacos结合起来的项目 &lt;a href=&quot;https://github.com/magicsgxie/skynet-cloud&quot;&gt;skynet-cloud&lt;/a&gt; 也可以看看。&lt;/p&gt;
&lt;p&gt;文中的示例代码可以戳这里 &lt;a href=&quot;https://github.com/catcherwong-archive/2019/tree/master/09/NacosDemo&quot;&gt;NacosDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SDK的地址 &lt;a href=&quot;https://github.com/catcherwong/nacos-sdk-csharp&quot;&gt;nacos-sdk-csharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望感兴趣的大佬给个星星，也十分希望有大佬来一起维护这个项目，和提些建议。&lt;/p&gt;
&lt;p&gt;因为是第一次写SDK类的东西，参考了其他平台提供.NET的SDK，然后结合Nacos的Open API写的，有可能会有不少遗漏和bug，还请各位大佬多多包涵。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:03:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>ASP.NET Core结合Nacos来完成配置管理和服务发现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/catcher1994/p/11489052.html</dc:identifier>
</item>
<item>
<title>【github】论怎么去写一个高大上的ReadMe - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11485101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11485101.html</guid>
<description>&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;51pdi-0-0&quot;&gt;&lt;span data-offset-key=&quot;51pdi-0-0&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;1oe54-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1oe54-0-0&quot;&gt;以前我时常觉得，自己写的ReadMe很单调乏味，但后来仔细研究一下后，发现有很多方式可以让ReadMe在简洁的基础上变得好看些，所以在这里和大家分享，如果大家有更好的想法，也非常欢迎在评论区留言哦&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;35vng-0-0&quot;&gt;&lt;span data-offset-key=&quot;35vng-0-0&quot;&gt;美化方案&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;a40e5-0-0&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;a40e5-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a40e5-0-0&quot;&gt;加彩色徽章：介绍npm版本，证书类型，发布版本等&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;10f7f-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;10f7f-0-0&quot;&gt;给代码添加颜色，不要使用纯文本啦！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;dlm3q-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dlm3q-0-0&quot;&gt;给自己的代码库设计一个专属的logo&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;rlq1-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;rlq1-0-0&quot;&gt;有想到再加其他的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ah05m-0-0&quot;&gt;&lt;span data-offset-key=&quot;ah05m-0-0&quot;&gt;最终结果&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-e13cd686552a8fc28178648123ef08ac_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1884&quot; data-rawheight=&quot;1592&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-e13cd686552a8fc28178648123ef08ac_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-187ff003a2663dd511d69d6e0561d145_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fc07p-0-0&quot;&gt;&lt;span data-offset-key=&quot;fc07p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Github地址&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;https://github.com/penghuwan/water.js&lt;span class=&quot;LinkCard-meta&quot;&gt;​github.com&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;8kcdq-0-0&quot;&gt;&lt;span data-offset-key=&quot;8kcdq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Act1. 加彩色徽章&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;2vi3h-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2vi3h-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;大家可能会感到奇怪，下面这些彩色徽章哪里来的呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-0bee4c6437eff7a1fddd4f0ecc665b2b_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1050&quot; data-rawheight=&quot;170&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;epba3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;epba3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;打开网站，往下翻，可以看到几个输入框，如下所示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/v2-27a60ba5dceb22e2860bbf6040659216_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;942&quot; data-rawheight=&quot;256&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-27a60ba5dceb22e2860bbf6040659216_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-7723fce1d5af5157e720706b19978867_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;3a29c-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3a29c-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;比如我们想要生成license MIT这样的徽章，就分别在label和message上填写,同时选择颜色，最后点击&lt;span data-offset-key=&quot;3a29c-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Make Badge&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-965128ef61db23d1d8125106c8cfac30_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;784&quot; data-rawheight=&quot;180&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-965128ef61db23d1d8125106c8cfac30_b.jpg&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-d546719293c0d7c544a695ac1705d906_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;38l1k-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;38l1k-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;点击&lt;span data-offset-key=&quot;38l1k-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Make Badge后会跳转到一个打开的图标文件，这个地址就是图片的引用地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/v2-fb2abff81dff668d4b0d62274bc448c5_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1058&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-fb2abff81dff668d4b0d62274bc448c5_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-ac54097e2c238839139677a5e31b22c7_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;7me78-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7me78-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;然后我们只要把这个地址复制到ReadMe上写成图片就好了，比如&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bhikf-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
![](https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;img.shields.io/badge/license-MIT-blue)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;dvppo-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dvppo-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;看到的结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/v2-ab371e2ffb769507776f5e52f8fcd4e9_b.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;132&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;402&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-ab371e2ffb769507776f5e52f8fcd4e9_b.jpg&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-551064154f7251176546a088271f0804_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9c1ks-0-0&quot;&gt;&lt;span data-offset-key=&quot;9c1ks-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Act2. 加代码颜色&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;5huca-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5huca-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们知道，我们可以用下面的Markdown标记添加代码块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4ir7r-0-0&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
``` 代码 ```
&lt;/pre&gt;&lt;/div&gt;
&lt;span data-offset-key=&quot;4ir7r-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;baru5-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;baru5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;但如果仅仅这样，&lt;span data-offset-key=&quot;baru5-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;代码是没有颜色的&lt;span data-offset-key=&quot;baru5-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，就像这样&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/v2-68ac3c9d9a349f92bda4c444406e0e41_b.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;184&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;666&quot; data-rawheight=&quot;288&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-68ac3c9d9a349f92bda4c444406e0e41_b.jpg&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-1bac2338f50747dbb6e3913a7a548f78_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;4s8fe-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4s8fe-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;如果我想加上颜色，我可以这么做： 给```后面加上语言名简写，比如：js&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4s3dv-0-0&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
```js &lt;br/&gt;代码 &lt;br/&gt;```
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;f3q0p-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f3q0p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;然后代码就被赋予颜色&lt;span data-offset-key=&quot;f3q0p-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;了呀（灵魂）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-73e086bd9a842f75131fbd50fb69a340_b.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;154&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;774&quot; data-rawheight=&quot;288&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-73e086bd9a842f75131fbd50fb69a340_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-415c2309ebbed9ba94a2f4d1ab89a4cf_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;6m1a0-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6m1a0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;同理，python的代码颜色可以这样设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7oac3-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
```python &lt;br/&gt;#!/usr/bin/python3 &lt;br/&gt;print(&quot;Hello, World!&quot;); &lt;br/&gt;```
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;8so0b-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8so0b-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;其他语言也是一样的，大家自己替换上去就好了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1d1gd-0-0&quot;&gt;&lt;span data-offset-key=&quot;1d1gd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Act3. 给自己的代码库设计一个logo&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;44a6n-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;44a6n-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;设计logo的网站很多，一查就有，随便你用哪个，但是我用过的设计最好，体验最好的还是下面这个Canva&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;ddl2q-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ddl2q-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;可以给自己设计图标，名称和介绍&lt;span data-offset-key=&quot;ddl2q-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，这下面是我的使用过程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-b3a3bffaf0f0f0d98e0b0f373426b3c8_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1842&quot; data-rawheight=&quot;1300&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-b3a3bffaf0f0f0d98e0b0f373426b3c8_b.jpg&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-5e57511a83b7b83f5575535514b6a72e_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1fv2c&quot; data-offset-key=&quot;8mtlo-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;8mtlo-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;效果如下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/v2-e5b97631142824942b05a13a79742de6_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1530&quot; data-rawheight=&quot;596&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-e5b97631142824942b05a13a79742de6_b.jpg&quot; data-watermark-src=&quot;https://pic3.zhimg.com/v2-56100b79d62c9aa08a2dc147737edd42_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;ci5u0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;哦，对了，我前端时间开始和爸妈学做菜了，那就写个做菜的技术总结吧&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ci5u0-0-0&quot;&gt;&lt;span data-offset-key=&quot;ci5u0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;做菜的技术总结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;一般常见青菜的做法: 先加油滚热，蒜头拍碎，浸油爆香。然后再放青菜翻炒。酱油在出锅前几分钟再加入。翻炒均匀后出锅。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;油麦菜香麦菜等“软菜”是不需要加水的。但是一些“硬菜”比如青椒之类还是要加点水，不然容易焦糊&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;炒鱼的时候，一般煎过比较香，但是我们一般不舍得加没过鱼肉的宽油，所以可以用另一种方法: 加部分油，同时适时转动锅的角度，均匀得煎炸。最后把鱼煎香后放微波炉里烤好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大白菜的处理是非常典型的，因为大白菜的茎和叶质地差别比较大，茎熟的慢，叶子熟的很快，所以建议手动剥开两份，先炒白菜茎，再炒白菜叶&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;木耳炒肉的时候，判断出锅时机是水煮浅，木耳发出噼里啪啦的声音&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;肉卷切片越薄越好，而且刀工要利索，炒肉丸的时候如果不处理肉丸会不够入味，需要每个丸子都用菜刀划几刀，成井字形&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;秋葵好像不能切段的时候好像不能切太碎，否则籽会都掉出来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;鱼和鸭子要加生姜炒，压腥味，可以考虑加点料酒，鸭子最好高压蒸熟，单单炒的话炒不透的，咬起来很硬。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当处理西红柿炒鸡蛋时候，肯定是先把鸡蛋炒好成型，然后加西红柿的，不然的话西红柿和鸡蛋同时放会 。。。。emmmm&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;常见的一种蘸酱调料的制作方式： 蒜瓣捣碎成蒜蓉，混入金谷饭，醋和香菜，用来沾者油炸豆腐吃，感觉还可以呀&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span data-offset-key=&quot;ci5u0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文完&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Sep 2019 00:02:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>以前我时常觉得，自己写的ReadMe很单调乏味，但后来仔细研究一下后，发现有很多方式可以让ReadMe在简洁的基础上变得好看些，所以在这里和大家分享，如果大家有更好的想法，也非常欢迎在评论区留言哦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11485101.html</dc:identifier>
</item>
</channel>
</rss>