<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《HelloGitHub》第 47 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12380411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12380411.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213457513-542391419.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;c-项目&quot;&gt;C++ 项目&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/AnthonyCalandra/modern-cpp-features&quot;&gt;modern-cpp-features&lt;/a&gt;：该项目介绍了现代 C++（C++11 以及之后的版本）语言和库的新特性。它能够帮助大家更快地入手新时代的 C++&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Light-City/CPlusPlusThings&quot;&gt;CPlusPlusThings&lt;/a&gt;：这是一个适合 C++ 初学者从入门到进阶的教程。解决了面试者想要深入 C++ 及如何入坑 C++ 的问题。除此之外，该仓库拓展了更加深入的语法分析、多线程并发等的知识，是一个比较全面的 C++ 从入门学习到进阶提升的项目&lt;/p&gt;
&lt;h3 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h3&gt;
&lt;p&gt;3、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/geektutu/7days-golang&quot;&gt;7days-golang&lt;/a&gt;：用 Go 在 7 天时间内实现 Web 框架、分布式缓存等应用的实战教程&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/cli/cli&quot;&gt;cli&lt;/a&gt;：GitHub 官方基于 Go 语言开发的命令行 GitHub 工具。用它可以在终端中执行 GitHub 的常用的管理 Issue、切分支、Clone 等操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213519906-677068787.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h3&gt;
&lt;p&gt;5、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/AlmasB/FXGLGames&quot;&gt;FXGLGames&lt;/a&gt;：此项目包含 FXGL 框架构建的游戏示例。该游戏框架无需安装或设置开箱即用，游戏可以轻松打包到单个可执行文件.jar。示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BasicGameApp extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(800);
        settings.setHeight(600);
        settings.setTitle(&quot;Basic Game App&quot;);
    }

    public static void main(String[] args) {
        launch(args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213534995-783776816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/quarkusio/quarkus-quickstarts&quot;&gt;quarkus-quickstarts&lt;/a&gt;：Quarkus 开源的 Java 多种框架 demo 项目集合。这些示例项目可以快速启动、结构清晰，初学者可用作 Java 的实战项目，老手可以当作项目脚手架。启动示例：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn quarkus:dev
mvn clean package -Pnative
./target/amqp-quickstart-1.0-SNAPSHOT-runner&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h3&gt;
&lt;p&gt;7、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/star7th/showdoc&quot;&gt;showdoc&lt;/a&gt;：一款基于 JavaScript 实现的开源在线文档工具。支持：多端编辑查看、权限管理、文档导出、Markdown 语法等，功能虽不多但已足够用了。推荐自建自用、小团队内部使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213551262-1811504702.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/vortesnail/qier-progress&quot;&gt;qier-progress&lt;/a&gt;：这是一个用于缓解用户焦虑，给予用户请求回馈的顶部进度条。该项目使用 ts 重构了万星 star 的 nprogress 项目，打包体积更小、且支持了多彩模式、自定义高度和颜色等，最重要的是有良好的类型注解。该项目结构简单、代码量也比较少，非常利于学习 ts 相关用法和作为实战项目。示例代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const qprogress = new QProgress()
qprogress.start()
qprogress.finish()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213605432-845382928.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/zerosoul/image-compress-without-backend&quot;&gt;image-compress-without-backend&lt;/a&gt;：一个纯前端在线图片压缩小工具。即无需上传照片到服务器，一切都在浏览器端完成，快速而高效。非常适用于图片压缩后质量要求不是很高的场景，比如：移动端图片展示等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213618482-1984594561.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/zerosoul/breathe-relaxer&quot;&gt;breathe-relaxer&lt;/a&gt;：一个在线放松网站的项目。带上耳机，&lt;a href=&quot;https://works.yangerxiao.com/breathe-relaxer/&quot;&gt;点开网站&lt;/a&gt;然后深呼吸&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213632138-222702981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/youngjuning/wx-promise-pro&quot;&gt;wx-promise-pro&lt;/a&gt;：支持 finnaly、typescript 的微信小程序异步解决方案。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方便集成：一处引用，处处使用&lt;/li&gt;
&lt;li&gt;把微信小程序所有异步 API promise 化并挂在到 wx.pro 对象下&lt;/li&gt;
&lt;li&gt;支持 ES2018 finally 特性&lt;/li&gt;
&lt;li&gt;支持 TypeScript 开发&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { promisifyAll, promisify } from 'wx-promise-pro'
// promisify all wx‘s api
promisifyAll()
// promisify single api
promisify(wx.getSystemInfo)().then(console.log)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h3&gt;
&lt;p&gt;12、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Automattic/simplenote-macos&quot;&gt;simplenote-macos&lt;/a&gt;：一款 macOS 上免费开源的记事本应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213649777-182331635.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;php-项目&quot;&gt;PHP 项目&lt;/h3&gt;
&lt;p&gt;13、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/jupeter/clean-code-php&quot;&gt;clean-code-php&lt;/a&gt;：PHP 代码的整洁之道，整理了一系列整洁代码实操。小到变量细道 SOLID 都有涉猎，&lt;a href=&quot;https://github.com/php-cpm/clean-code-php&quot;&gt;中文译版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/CismonX/ext-collections&quot;&gt;ext-collections&lt;/a&gt;：一个 C 语言实现的 PHP 扩展库。提供了类似 Java stream API 和 kotlin.collections 的一系列库函数，方便开发者优雅、快速地操作 PHP 数组。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了丰富的 PHP 数组操作函数，有助于提高开发效率和代码的可读性&lt;/li&gt;
&lt;li&gt;使用 C 语言实现，比同类 PHP 实现性能更高&lt;/li&gt;
&lt;li&gt;初学者可以通过阅读此项目代码帮助自己入门 PHP 扩展开发&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$employees = [
    ['name' =&amp;gt; 'Alice', 'sex' =&amp;gt; 'female', 'age' =&amp;gt; 35],
    ['name' =&amp;gt; 'Bob', 'sex' =&amp;gt; 'male', 'age' =&amp;gt; 29],
    ['name' =&amp;gt; 'David', 'sex' =&amp;gt; 'male', 'age' =&amp;gt; 40],
    ['name' =&amp;gt; 'Benjamin', 'sex' =&amp;gt; 'male', 'age' =&amp;gt; 32]
];
// Trying to get an array of names of male employees,
// sorted by the descending order of their age.
$names = Collection::init($employees)
    -&amp;gt;filter(function ($value) {
        return $value['sex'] == 'male';
    })
    -&amp;gt;sortedByDescending(function ($value) {
        return $value['age'];
    })
    -&amp;gt;map(function ($value) {
        return $value['name'];
    })
    -&amp;gt;toArray();
// You got $names == ['David', 'Benjamin', 'Bob'].&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h3&gt;
&lt;p&gt;15、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/chubin/wttr.in&quot;&gt;wttr.in&lt;/a&gt;：一个 Python 实现的命令行查看天气工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213707052-1223933667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/ActivityWatch/activitywatch&quot;&gt;activitywatch&lt;/a&gt;：一个记录你的时间都花在那的 Python 项目。支持 Web 可视化，效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213719311-1825106121.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/jindaxiang/akshare&quot;&gt;akshare&lt;/a&gt;：一款基于 Python 的开源金融数据接口库。提供了股票、期货、期权、基金、数字货币等金融产品的基本数据、实时和历史行情数据、衍生数据，包含数据采集、数据清洗、到数据落地的一套开源工具。满足了金融数据科学家、数据科学爱好者在金融数据获取方面的需求。示例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import akshare as ak
bond_df = ak.bond_spot_deal()
print(bond_df)

   债券简称 成交净价(元) 最新收益率(%)  涨跌(BP) 加权收益率(%) 交易量(亿)
0          19国开15   98.97   3.5750    1.00   3.5826   None
1        19附息国债03   99.82   2.7714    0.14   2.7772   None
2        19附息国债11   99.87   2.8000    0.25   2.7963   None
3        19附息国债04  100.82   2.9832   -1.54   2.9747   None
4        15附息国债05  102.95   3.0359   -1.41   3.0359   None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;18、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/NaNShaner/repoll&quot;&gt;repoll&lt;/a&gt;：基于 Django 开发的 redis 集群管理、监控工具。功能包括：标准化申请流程、管理配置、监控接口等，减轻了运维人员的痛苦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213733417-1499035454.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;swift-项目&quot;&gt;Swift 项目&lt;/h3&gt;
&lt;p&gt;19、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/Caldis/Mos&quot;&gt;Mos&lt;/a&gt;：一个用于在 macOS 上平滑鼠标滚动效果或单独设置滚动方向的小工具。让你的滚轮爽如触控板般丝滑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213747424-1584645738.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它&quot;&gt;其它&lt;/h3&gt;
&lt;p&gt;20、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/bregman-arie/devops-exercises&quot;&gt;devops-exercises&lt;/a&gt;：这个仓库包含了 DevOps（开发运维）常见、流行服务相关的面试问题和回答，推荐给从事运维的同学&lt;/p&gt;
&lt;p&gt;21、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/rust-lang/book&quot;&gt;book&lt;/a&gt;：《Rust 编程语言》这是官方出品的关于 Rust 的入门书籍&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/zhaoolee/OnlineToolsBook&quot;&gt;OnlineToolsBook&lt;/a&gt;：该项目收集了一些有趣、实用的在线工具网站，点开即用&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/nikitavoloboev/my-mac-os&quot;&gt;my-mac-os&lt;/a&gt;：该项目罗列了作者自用、收集的 macOS 上实用、炫酷的软件。我从中找到好几个炫酷、实用提高工作的工具，你也赶快来挑挑吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213804864-423777254.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/dbohdan/structured-text-tools&quot;&gt;structured-text-tools&lt;/a&gt;：用于处理结构化文本数据（日志、JSON、YAML 等）的命令行工具列表&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/apache/incubator-apisix&quot;&gt;incubator-apisix&lt;/a&gt;：一个云原生、高性能、可扩展的微服务 API 网关。它是基于 Nginx 和 etcd 来实现，和传统 API 网关相比，APISIX 具备动态路由和插件热加载，适合微服务体系下的 API 管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213817454-1410258665.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/florinpop17/app-ideas&quot;&gt;app-ideas&lt;/a&gt;：该收集了各类应用的想法，并按照易学程度把应用进行划分。你可以通过这个项目提高编程技术、学习新技术&lt;/p&gt;
&lt;h3 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h3&gt;
&lt;p&gt;27、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/ipython-books/cookbook-2nd&quot;&gt;cookbook-2nd&lt;/a&gt;：《IPython Cookbook 第二版》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200228213832341-1909910311.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;机器学习&lt;/h3&gt;
&lt;p&gt;28、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/google-research/google-research&quot;&gt;google-research&lt;/a&gt;：非官方整理的 Google AI Research 集合项目&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://hellogithub.com/periodical/statistics/click/?target=https://github.com/yatengLG/Retinanet-Pytorch&quot;&gt;Retinanet-Pytorch&lt;/a&gt;：一个以 Pytorch 深度学习库实现的 retinanet 目标检测模型。项目拥有清晰的结构、完善的注释以及详细的使用说明。适用于有些许深度学习基础的初学者进行学习或在实际的目标检测项目中使用&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你发现了 GitHub 上有趣的项目，欢迎在 HelloGitHub 项目提 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;issues&lt;/a&gt; 告诉我们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202001/759200-20200129180553287-52110265.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关注 HelloGitHub 公众号获取第一手的更新&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 00:32:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>兴趣是最好的老师， HelloGitHub 就是帮你找到兴趣！ 简介 分享 GitHub 上有趣、入门级的开源项目。 这是一个面向 编程新手 、 热爱编程 、 对开源社区感兴趣 人群的月刊，月刊的内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12380411.html</dc:identifier>
</item>
<item>
<title>第3篇-如何编写一个面试时能拿的出手的开源项目？ - 归去来兮辞</title>
<link>http://www.cnblogs.com/extjs4/p/12381467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/extjs4/p/12381467.html</guid>
<description>&lt;p&gt;&lt;span&gt;前2篇的链接如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/extjs4/p/12342287.html&quot; target=&quot;_blank&quot;&gt;第1篇-如何编写一个面试时能拿的出手的开源项目？&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/extjs4/p/12370328.html&quot; target=&quot;_blank&quot;&gt;第2篇-如何编写一个面试时能拿的出手的开源项目？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1篇介博文中详细介绍过编写一个规范开源项目所要遵循的规范，并且初步实现了博主自己的开源项目&lt;a href=&quot;https://gitee.com/mazhimazh/JavacASTViewer&quot; target=&quot;_blank&quot;&gt;Javac AST View插件&lt;/a&gt;，不过只搭建了项目开发的基本框架，树状结构的数据模型也是硬编码的；第2篇从Eclipse编辑器中读取Java源代码并转换为Javac的抽象语法树，然后又将Javac的抽象语法树转换为了Eclipse树形插件所识别的数据模型，在视图中动态展现出来。本篇将为这个树形插件视图完善功能。主要就是添加读入、刷新、展开与折叠的功能按钮，同时双击树中的某个结点，选中Eclipse中对应的源代码信息。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、添加读入、刷新、展开与折叠功能按钮&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;代码比较简单，只需要定义相应的Action，然后添加到工具栏管理器IToolBarManager中即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义的相应Action如下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;private void makeActions() {
        
        
        fFocusAction = new Action() {
                @Override
                public void run() {
                        performSetFocus();
                }
        };
        fFocusAction.setText(&quot;&amp;amp;Show AST of active editor&quot;);
        fFocusAction.setToolTipText(&quot;Show AST of active editor&quot;); 
        fFocusAction.setActionDefinitionId(IWorkbenchCommandConstants.FILE_REFRESH);
        ASTViewImages.setImageDescriptors(fFocusAction, ASTViewImages.SETFOCUS);
        
        fRefreshAction = new Action() {
                @Override
                public void run() {
                        try {
                                refreshAST();
                        } catch (CoreException e) {
                                e.printStackTrace();
                        }
                }
        };
        fRefreshAction.setText(&quot;&amp;amp;Refresh AST&quot;); 
        fRefreshAction.setToolTipText(&quot;Refresh AST&quot;); 
        fRefreshAction.setEnabled(false);
        ASTViewImages.setImageDescriptors(fRefreshAction, ASTViewImages.REFRESH);
        
        fCollapseAction = new Action() {
                @Override
                public void run() {
                        performCollapse();
                }
        };
        fCollapseAction.setText(&quot;C&amp;amp;ollapse&quot;); 
        fCollapseAction.setToolTipText(&quot;Collapse Selected Node&quot;); 
        fCollapseAction.setEnabled(true);
        ASTViewImages.setImageDescriptors(fCollapseAction, ASTViewImages.COLLAPSE);

        fExpandAction = new Action() {
                @Override
                public void run() {
                        performExpand();
                }
        };
        fExpandAction.setText(&quot;E&amp;amp;xpand&quot;); 
        fExpandAction.setToolTipText(&quot;Expand Selected Node&quot;); 
        fExpandAction.setEnabled(true);
        ASTViewImages.setImageDescriptors(fExpandAction, ASTViewImages.EXPAND);
        
        fDoubleClickAction = new Action() {
                @Override
                public void run() {
                        performDoubleClick();
                }
        };

}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;单击4个按钮后执行的对应动作由3个函数定义，如下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;private void refreshAST() throws CoreException {
        internalSetInput(uri);
}

protected void performCollapse() {
        IStructuredSelection selection= (IStructuredSelection) fViewer.getSelection();
        if (selection.isEmpty()) {
                fViewer.collapseAll();
        } else {
                fViewer.getTree().setRedraw(false);
                for (Object s : selection.toArray()) {
                        fViewer.collapseToLevel(s, AbstractTreeViewer.ALL_LEVELS);
                }
                fViewer.getTree().setRedraw(true);
        }
}

protected void performExpand() {
        IStructuredSelection selection= (IStructuredSelection) fViewer.getSelection();
        if (selection.isEmpty()) {
                fViewer.expandToLevel(3);
        } else {
                fViewer.getTree().setRedraw(false);
                for (Object s : selection.toArray()) {
                        fViewer.expandToLevel(s, AbstractTreeViewer.ALL_LEVELS);
                }
                fViewer.getTree().setRedraw(true);
        }
}

protected void performSetFocus() {
        IEditorPart part= EditorUtility.getActiveEditor();
        if (part instanceof ITextEditor) {
                try {
                        setInput((ITextEditor) part);
                } catch (CoreException e) {
                        showAndLogError(&quot;Could not set Javac AST view input &quot;, e); //$NON-NLS-1$
                }
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;performSetFocus()函数执行读入动作、refreshAST()函数执行刷新动作、performCollapse()函数执行语法树合上动作，而performExpand()函数执行语法树展开动作。可以展开特定语法树节点，只要选中这个语法树节点，然后点击展开按钮即可。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向工具栏管理器中添加定义好的Action，如下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;private void contributeToActionBars() {
        IActionBars bars = getViewSite().getActionBars();
        bars.getToolBarManager().add(fFocusAction);
        bars.getToolBarManager().add(fRefreshAction);
        bars.getToolBarManager().add(fCollapseAction);
        bars.getToolBarManager().add(fExpandAction);
        bars.setGlobalActionHandler(ActionFactory.REFRESH.getId(), fFocusAction);
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在createPartControl()函数中调用相关方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;makeActions();
contributeToActionBars();
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/222237/202002/222237-20200228122452524-258083640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、选中源代码功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要选中Eclipse插件中某个范围的源代码，需要调用相关函数，同时传递2个重要的参数，一个就是字符的开始位置pos，另外就是长度length。这两个参数我们可以直接从Javac的相关API中获取，修改createAST()函数，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public static EndPosTable ept = null;

private JCCompilationUnit createAST(URI is) {
        Context context = new Context();
        JavacFileManager.preRegister(context);
        JavaFileManager fileManager = context.get(JavaFileManager.class);
        JavaCompiler comp = JavaCompiler.instance(context);
        JavacFileManager dfm = (JavacFileManager) fileManager;

        JavaFileObject jfo = dfm.getFileForInput(is.getPath());
        comp.genEndPos = true;
        JCCompilationUnit tree = comp.parse(jfo);
        ept = tree.endPositions;        
　　　　　comp.parseFiles(otherFiles);

        return tree;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要打开JavaCompiler的genEndPos开关，这样Javac在分析Java源代码字符流的过程中，就会保存对应的语法树节点到字符结束位置的对应关系，这个关系就保存在EndPostTable中，所以我们用全局变量ept保存即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在JavacASTNode中新定义2个属性，用来保存对应语法树节点在字符流中的开始与结束位置，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;private int startpos,endpos;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后修改JavacASTNode的构造函数，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public JavacASTNode(int startpos,int endpos) {
        children = new ArrayList&amp;lt;JavacASTNode&amp;gt;();
        this.startpos = startpos;
        this.endpos = endpos;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在访问者方法中为这2个属性赋值，例如在visitCompilationUnit()和visitClass()方法中赋值，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;@Override
public JavacASTNode visitCompilationUnit(CompilationUnitTree node, Void p) {
        JCCompilationUnit t = (JCCompilationUnit) node;
        JavacASTNode currnode = new JavacASTNode(t.getStartPosition(),t.getEndPosition(JavacASTViewer.ept));
        currnode.setProperty(&quot;root&quot;);
        currnode.setType(t.getClass().getSimpleName());
        
        traverse(currnode,&quot;packageAnnotations&quot;,t.packageAnnotations);
        traverse(currnode,&quot;pid&quot;,t.pid);
        traverse(currnode,&quot;defs&quot;,t.defs);

        return currnode;
}

@Override
public JavacASTNode visitClass(ClassTree node, Void p) {
        JCClassDecl t = (JCClassDecl) node;
        JavacASTNode currnode = new JavacASTNode(t.getStartPosition(),t.getEndPosition(JavacASTViewer.ept));

        traverse(currnode,&quot;extending&quot;,t.extending);
        traverse(currnode,&quot;implementing&quot;,t.implementing);
        traverse(currnode,&quot;defs&quot;,t.defs);
        
        return currnode;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过调用节点类的getStartPosition()获取开始位置，调用getEndPosition()获取结束位置，不过调用这个方法需要传递之前保存的EndPosTable信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义监听器监听双击事件，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;package astview.listener;

import org.eclipse.jface.text.DocumentEvent;
import org.eclipse.jface.text.IDocumentListener;
import org.eclipse.jface.viewers.DoubleClickEvent;
import org.eclipse.jface.viewers.IDoubleClickListener;

import astview.JavacASTViewer;

public class ListenerMix implements IDocumentListener,IDoubleClickListener {

        private JavacASTViewer fView;

        public ListenerMix(JavacASTViewer view) {
                fView= view;
        }

        public void dispose() {
                fView= null;
        }

        // ...

        @Override
        public void doubleClick(DoubleClickEvent event) {
                fView.handleDoubleClick();
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用这个监听器，在createPartControl()中为fViewer添加监听器，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;fViewer.addDoubleClickListener(fSuperListener);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样在双击语法树某个节点时，监听器会调用fView.hanbndleDoubleClick()方法对动作做相应的处理，函数的实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;protected void performDoubleClick() {
        if (fEditor == null) {
                return;
        }

        ISelection selection = fViewer.getSelection();
        Object obj = ((IStructuredSelection) selection).getFirstElement();
        if(obj!=null &amp;amp;&amp;amp; obj instanceof JavacASTNode) {
                JavacASTNode node = (JavacASTNode)obj;
                EditorUtility.selectInEditor(fEditor, node.getStartpos(),node.getEndpos()-node.getStartpos());
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用EditorUtility工具类中的selectInEditor()方法，这个方法的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public static void selectInEditor(ITextEditor editor, int offset, int length) {
        IEditorPart active = getActiveEditor();
        if (active != editor) {
                editor.getSite().getPage().activate(editor);
        }
        editor.selectAndReveal(offset, length);
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用IEditorPart的selectAndReveal()方法，同时传递开始位置和选中的长度就完成了这个功能。　　&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3、发布插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;发布Eclipse插件非常简单，网上相关的资料也非常多，这里就不做过多介绍。作者将打包好的插件放到了&lt;a href=&quot;https://gitee.com/mazhimazh/JavacASTViewer&quot; target=&quot;_blank&quot;&gt;JavacASTViewer&lt;/a&gt;项目的zip目录下，大家可以下载下来以Install的方式安装。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4、编写README.md&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;编写文档介绍项目以及使用方法，具体内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;# JavacTreeViewer
## 1、项目简介
以插件的形式直观的查看基于OpenJDK的编译器Javac的抽象语法树。
## 2、项目描述
可以在Eclipse中以插件的方式安装、查看Javac的抽象语法树结构。类似于Eclipse AST View插件。Eclipse AST View插件显示的是ECJ编译器的抽象语法树，而JavacASTViewer显示的是基于OpenJDK的编译器Javac的抽象语法树结构。
## 3、用法
可直接下载项目源代码，自己导出Eclipse插件包，或者下载本项目中zip目录下作者打包好的插件包，以Install的方式安装。
目前只测试了Eclipse IDE for RCP and RAP Developers 4.14.0版本。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样一个插件就开发完了，不过后续还需要增加更多的测试用例，以及完善更多的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 29 Feb 2020 00:17:00 +0000</pubDate>
<dc:creator>归去来兮辞</dc:creator>
<og:description>前2篇的链接如下： 第1篇-如何编写一个面试时能拿的出手的开源项目？ 第2篇-如何编写一个面试时能拿的出手的开源项目？ 第1篇介博文中详细介绍过编写一个规范开源项目所要遵循的规范，并且初步实现了博主自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/extjs4/p/12381467.html</dc:identifier>
</item>
<item>
<title>Jprofile解析dump文件使用详解 - 路人111122233</title>
<link>http://www.cnblogs.com/JavaEdge/p/12381428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/12381428.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.ej-technologies.com/products/jprofiler/overview.html&quot;&gt;官网&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060516583-1577760199.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;下载对应的系统版本即可&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060526532-812764375.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;性能查看工具JProfiler，可用于查看java执行效率，查看线程状态，查看内存占用与内存对象，还可以分析dump日志.&lt;/p&gt;

&lt;p&gt;在Thread界面则可以实时查看线程运行状态，黄色的是wait 红色是block 绿色的是runnable蓝色是网络和I/O请求状态&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060612826-1558841004.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择ThreadDumps,可以录制瞬时线程的调用堆栈信息，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060620531-524949797.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;dump-生成&quot;&gt;3.1 dump 生成&lt;/h2&gt;
&lt;h3 id=&quot;jprofiler-在线&quot;&gt;JProfiler 在线&lt;/h3&gt;
&lt;p&gt;当JProfiler连接到JVM之后选择Heap Walker，选择Take snapshot图标，然后等待即可&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060626153-1931176050.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060628692-2070280893.png&quot;/&gt;&lt;br/&gt;如果内存很大，jprofiler万一参数设置的不正确打不开就需要要重新生成，内存小的时候无所谓&lt;/p&gt;
&lt;h3 id=&quot;使用jprofiler生成文件&quot;&gt;使用JProfiler生成文件&lt;/h3&gt;
&lt;p&gt;当JProfiler连接到JVM之后选择菜单上的Profiling-&amp;gt;save HPROF snapshot 弹出下拉框保存即可，这时候生成的文件就可以一直保存在文件上&lt;/p&gt;
&lt;h3 id=&quot;jmap&quot;&gt;jmap&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;jmap -dump:format=b,file=文件名 pid

windows下不用[]，路径要加引号

jmap -dump:format=b,file=&quot;D:\a.dump&quot; 8632&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令中文件名就是要保存的dump文件路径， pid就是当前jvm进程的id&lt;/p&gt;
&lt;h3 id=&quot;jvm启动参数&quot;&gt;JVM启动参数&lt;/h3&gt;
&lt;p&gt;在发生outofmemory的时候自动生成dump文件:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\heapdump&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Pah后面是一个存在的可访问的路径，将改参数放入jvm启动参数可以在发生内存outofmemory的时候自动生成dump文件，但是正式环境使用的时候不要加这个参数，不然在内存快满的时候总是会生成dump而导致jvm卡半天，需要调试的时候才需要加这个参数&lt;/p&gt;
&lt;p&gt;注意：通过WAS生成的PHD文件dump不能分析出出问题的模板，因为PHD文件不包含对象的值内容，无法根据PHD文件找到出问题的模板，所以PHD文件没有太大的参考价值&lt;/p&gt;
&lt;h2 id=&quot;dump文件分析&quot;&gt;3.2 dump文件分析&lt;/h2&gt;
&lt;p&gt;dump文件生成后，将dump压缩传输到本地，不管当前dump的后缀名是什么，直接改成*.hprof，就可以直接用jprofiler打开了&lt;/p&gt;
&lt;p&gt;打开的过程时间可能会很长，主要是要对dump进行预处理，计算什么的，注意 这个过程不能点skip，否则就不太好定位大文件&lt;/p&gt;

&lt;p&gt;也可以使用工具栏中的“转到开始”按钮访问第一个数据集&lt;/p&gt;
&lt;h2 id=&quot;内存视图-memory-views&quot;&gt;4.1 内存视图 Memory Views&lt;/h2&gt;
&lt;p&gt;JProfiler的内存视图部分可以提供动态的内存使用状况更新视图和显示关于内存分配状况信息的视图。所有的视图都有几个聚集层并且能够显示现有存在的对象和作为垃圾回收的对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有对象 All Objects&lt;br/&gt;显示类或在状况统计和尺码信息堆上所有对象的包。你可以标记当前值并显示差异值。&lt;/li&gt;
&lt;li&gt;记录对象 Record Objects&lt;br/&gt;显示类或所有已记录对象的包。你可以标记出当前值并且显示差异值。&lt;/li&gt;
&lt;li&gt;分配访问树 Allocation Call Tree&lt;br/&gt;显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。&lt;/li&gt;
&lt;li&gt;分配热点 Allocation Hot Spots&lt;br/&gt;显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。&lt;/li&gt;
&lt;li&gt;类追踪器 Class Tracker&lt;br/&gt;类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;堆遍历-heap-walker&quot;&gt;4.2 堆遍历 Heap Walker&lt;/h2&gt;
&lt;h3 id=&quot;使用背景&quot;&gt;使用背景&lt;/h3&gt;
&lt;p&gt;在视图中找到增长快速的对象类型，在memory视图中找到Concurrenthashmap---点右键----选择“Show Selectiion In Heap Walker”，切换到HeapWarker 视图；切换前会弹出选项页面，注意一定要选择“Select recorded objects”，这样Heap Walker会在刚刚的那段记录中进行分析；否则，会分析tomcat的所有内存对象，这样既耗时又不准确；&lt;/p&gt;
&lt;p&gt;在JProfiler的堆遍历器(Heap Walker)中，你可以对堆的状况进行快照并且可以通过选择步骤下寻找感兴趣的对象。堆遍历器有五个视图：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类 Classes&lt;br/&gt;显示所有类和它们的实例，可以右击具体的类&quot;Used Selected Instance&quot;实现进一步跟踪。&lt;/li&gt;
&lt;li&gt;分配 Allocations&lt;br/&gt;为所有记录对象显示分配树和分配热点。&lt;/li&gt;
&lt;li&gt;索引 References&lt;br/&gt;为单个对象和“显示到垃圾回收根目录的路径”提供索引图的显示功能。还能提供合并输入视图和输出视图的功能。&lt;/li&gt;
&lt;li&gt;时间 Time&lt;br/&gt;显示一个对已记录对象的解决时间的柱状图。&lt;/li&gt;
&lt;li&gt;检查 Inspections&lt;br/&gt;显示了一个数量的操作，将分析当前对象集在某种条件下的子集，实质是一个筛选的过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在heapwalker中找到泄漏的对象&quot;&gt;在HeapWalker中，找到泄漏的对象&lt;/h3&gt;
&lt;p&gt;HeapWarker 会分析内存中的所有对象，包括对象的引用、创建、大小和数量.&lt;br/&gt;通过切换到References页签，可以看到这个类的具体对象实例。 为了在这些内存对象中，找到泄漏的对象（应该被回收），可以在该对象上点击右键，选择“Use Selected Instances”缩小对象范围&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060646290-1444943842.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过引用分析该对象&quot;&gt;通过引用分析该对象&lt;/h3&gt;
&lt;p&gt;References 可以看到该对象的的引用关系，选项显示引用的类型&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060647895-1467882105.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;incoming&lt;br/&gt;显示这个对象被谁引用&lt;/li&gt;
&lt;li&gt;outcoming&lt;br/&gt;显示这个对象引用的其他对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择“Show In Graph”将引用关系使用图形方式展现；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选中该对象，点击&lt;code&gt;Show Paths To GC Root&lt;/code&gt;，会找到引用的根节点&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200229060651901-435851158.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;通过创建分析该对象&quot;&gt;通过创建分析该对象&lt;/h3&gt;
&lt;p&gt;如果还不能定位内存泄露的地方，我们可以尝试使用Allocations页签，该页签显示对象是如何创建出来的；&lt;br/&gt;我们可以从创建方法开始检查，检查所有用到该对象的地方，直到找到泄漏位置；&lt;/p&gt;
&lt;h2 id=&quot;图表-graph&quot;&gt;图表 Graph&lt;/h2&gt;
&lt;p&gt;你需要在references视图和biggest视图手动添加对象到图表，它可以显示对象的传入和传出引用，能方便的找到垃圾收集器根源。&lt;/p&gt;
&lt;p&gt;tips：在工具栏点击&quot;Go To Start&quot;可以使堆内存重新计数，也就是回到初始状态。&lt;/p&gt;

&lt;h2 id=&quot;cpu-视图-cpu-views&quot;&gt;CPU 视图 CPU Views&lt;/h2&gt;
&lt;p&gt;　　JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。CPU视图部分包括：&lt;/p&gt;

&lt;p&gt;访问树 Call Tree&lt;br/&gt;显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC,JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。&lt;br/&gt;热点 Hot Spots&lt;br/&gt;显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS和JNDI服务请求以及按照URL请求来进行计算。&lt;br/&gt;访问图 Call Graph&lt;br/&gt;显示一个从已选方法、类、包或J2EE组件开始的访问队列的图。&lt;br/&gt;方法统计 Method Statistis&lt;br/&gt;显示一段时间内记录的方法的调用时间细节。&lt;/p&gt;
&lt;h2 id=&quot;线程视图-thread-views&quot;&gt;线程视图 Thread Views&lt;/h2&gt;
&lt;p&gt;　　JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析，JProfiler提供以下视图:&lt;/p&gt;

&lt;p&gt;线程历史 Thread History&lt;br/&gt;显示一个与线程活动和线程状态在一起的活动时间表。&lt;br/&gt;线程监控 Thread Monitor&lt;br/&gt;显示一个列表，包括所有的活动线程以及它们目前的活动状况。&lt;br/&gt;线程转储 Thread Dumps&lt;br/&gt;显示所有线程的堆栈跟踪。&lt;/p&gt;
&lt;h2 id=&quot;监控器视图-monitor-views&quot;&gt;监控器视图 Monitor Views&lt;/h2&gt;
&lt;p&gt;　　JProfiler提供了不同的监控器视图，如下所示:&lt;/p&gt;

&lt;p&gt;当前锁定图表 Current Locking Graph&lt;br/&gt;显示JVM中的当前锁定情况。&lt;br/&gt;当前监视器 Current Monitors&lt;br/&gt;显示当前正在等待或阻塞中的线程操作。&lt;br/&gt;锁定历史图表 Locking History Graph&lt;br/&gt;显示记录在JVM中的锁定历史。&lt;br/&gt;监控器历史 Monitor History&lt;br/&gt;显示等待或者阻塞的历史。&lt;br/&gt;监控器使用统计 Monitor Usage Statistics&lt;br/&gt;计算统计监控器监控的数据。&lt;/p&gt;
&lt;h2 id=&quot;vm遥感勘测技术视图-vm-telemetry-views&quot;&gt;VM遥感勘测技术视图 VM Telemetry Views&lt;/h2&gt;
&lt;p&gt;　　观察JVM的内部状态，JProfiler提供了不同的遥感勘测视图，如下所示:&lt;/p&gt;

&lt;p&gt;内存 Memory&lt;br/&gt;显示堆栈的使用状况和堆栈尺寸大小活动时间表。&lt;br/&gt;记录的对象 Recorded Objects&lt;br/&gt;显示一张关于活动对象与数组的图表的活动时间表。&lt;br/&gt;记录的生产量 Recorded Throughput&lt;br/&gt;显示一段时间累计的JVM生产和释放的活动时间表。&lt;br/&gt;垃圾回收活动 GC Activity&lt;br/&gt;显示一张关于垃圾回收活动的活动时间表。&lt;br/&gt;类 Classes&lt;br/&gt;显示一个与已装载类的图表的活动时间表。&lt;br/&gt;线程 Threads&lt;br/&gt;显示一个与动态线程图表的活动时间表。&lt;br/&gt;CPU负载 CPU Load&lt;br/&gt;显示一段时间中CPU的负载图表。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/onmyway20xx/p/3963735.html&quot;&gt;使用JProfiler进行内存分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 22:07:00 +0000</pubDate>
<dc:creator>路人111122233</dc:creator>
<og:description>1 Jprofile简介 &amp;quot;官网&amp;quot; 下载对应的系统版本即可 性能查看工具JProfiler，可用于查看java执行效率，查看线程状态，查看内存占用与内存对象，还可以分析dump日志</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/12381428.html</dc:identifier>
</item>
<item>
<title>Spring-cloud微服务实战【十】：消息总线Bus - 悟空不败</title>
<link>http://www.cnblogs.com/wukongbubai/p/12381394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wukongbubai/p/12381394.html</guid>
<description>&lt;p&gt;  回忆一下,在上一篇文章中,我们使用了分布式配置中心config来管理所有微服务的配置文件,那这样有没有什么问题?有,那就是无法配置文件无法自动更新,当我的git服务器上的配置文件更新后,不能同步更新到config-server,需要config-server重启才能生效,这在生产环境下,肯定是不可以的,我们需要当git服务器的文件更新后,自动同步到config-server,并且config-server不需要重启就能获取到最新的配置,因此我们需要借助spring cloud bus消息总线来实现该功能.其实spring cloud bus 本质上是利用MQ(消息中间件,常用的是RabbitMQ或者kafka)实现消息的推送功能.&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-bus的使用&quot;&gt;spring cloud bus的使用&lt;/h2&gt;
&lt;p&gt;  上面我们说到spring cloud bus需要借助MQ,本文中我们借助RabbitMQ来实现该功能.首先需要我们在本机安装好RabbitMQ(安装过程就不再说了,大家发挥各自的聪明才智吧~),然后启动RabbitMQ:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMzRhMjBjYzI4ZGQ3OGFiOWNlMDE1ODI5MTY4OTMucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  以上打印信息说明已经启动好了,让我们登录网页版的控制台看一下,rabbitMQ控制台默认端口号15672:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyY2YzNmRhYjgzOGFjNWM4MzlhMDE1ODI5MTY5MDYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  出现该页面说明rabbitMQ已经成功启动了,大家可以用默认的账号密码guest/guest登录进去看一下:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMjBmMGJiNDU4ZDEzMmNkMGYzMDE1ODI5MTY5MTUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后我们将[dhp-micro-service-config-server]复制一份为[dhp-micro-service-config-bus-server]:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMjhhNzY1MTZjMTMwYWY5Zjg3MDE1ODI5MTY5MjQucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后新增maven依赖:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYzU4NjViOGFkODRjZjM4ZTEwMDE1ODI5MTY5MzYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  配置文件我们改造一下,使用yml文件,并且新增rabbitMQ相关配置,并且由于需要暴露refresh的地址,因此方便起见直接使用星号表示暴露全部地址:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNDhkYzBkYzcxM2RkNGUxNjBmMDE1ODI5MTY5NTgucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后启动试一下:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMjY3NDhmOGM5YjlmOTU1NmU4MDE1ODI5MTY5NjgucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMDZiOTVjZjVkM2Y5YzdkMWRlMDE1ODI5MTY5NzUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  说明已经成功了,然后现在将[dhp-micro-eureka-server-config]复制一份为[dhp-micro-eureka-server-config-bus]:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNGU0OTZlMjViMGI3Mjg2NWU3MDE1ODI5MTY5ODYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后新增maven依赖:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNGU4MmY1MzZlMjdlOTkzNGU4MDE1ODI5MTY5OTMucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后修改git服务器上的配置文件,新增rabbitMQ的相关配置,以及新增一些用于测试自动刷新的内容:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMjk5MTNlNmZlOTRlYjY2MmEzMDE1ODI5MTcwMDIucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  修改[dhp-micro-eureka-server-config-bus]代码,新增user.config的相关配置:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyZDViOGEzYjc2NGZkMTg5NDg0MDE1ODI5MTcwMTQucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后启动[dhp-micro-eureka-server-config-bus]:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNmVhYWM5MDU5MThiMjBhMDFiMDE1ODI5MTcwMjIucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyM2FhOWNjMmQ5YmJjN2I4Mzg3MDE1ODI5MTcwMzUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  接下来我们测试一下自动刷新,首先修改git服务器上的用户相关信息:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYmZkNjYwZjZjNGVmNDk1OTg1MDE1ODI5MTcwNDUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  然后再访问一下用户信息的地址:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyODAzMGFkOTgzYjExM2ZiYjdkMDE1ODI5MTcwNTYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  嗯?什么情况?没有成功?是配置出现问题了吗?还是其他什么问题?其实不是的,我们说现在eureka-server作为config-server的一个消费者,通过rabbitMQ进行监听,现在config-server并没有发出消息通知,消费者自然不能接收到更新信号了,因此我们需要在在config-server手动发一个信号:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNzEyMTgzNTBkOTJmZTVmZWZlMDE1ODI5MTcwNjYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  在1.X的版本时,可以直接使用GET请求访问,2.X版本只能使用POST请求,因此我们借助Postman来发送post请求:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYzc0YmZlMmY2MGRkMmQ1NzNjMDE1ODI5MTcwNzUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  此时再看一下userConfig信息:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyY2ZmNzFkMmU5OTVmMThjYWVkMDE1ODI5MTcwODQucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  这样自动刷新就成功了.但是生产环境不可能每次都需要我们手动发起请求,因此我们可以借助git的webhook的方式,自动帮助我们刷新:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyMTBmMGM0Yjk0NjI1ZjlhM2I4MDE1ODI5MTcwOTYucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  这里的Payload URL填写我们的刷新地址即可,比如:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyZDBlZGRlNDFkMzRlYTgyMWZmMDE1ODI5MTcxMDQucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  但是要注意这个地址必须是公网地址,否则公网访问不了不生效!&lt;/p&gt;
&lt;p&gt;  自此,我们的整个微服务spring cloud就结束了,喜欢的童鞋们请赶紧收藏吧!&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://github.com/dongheping/dhp-micro-service-chapter9&quot;&gt;本文的GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 28 Feb 2020 19:25:00 +0000</pubDate>
<dc:creator>悟空不败</dc:creator>
<og:description>回忆一下,在上一篇文章中,我们使用了分布式配置中心config来管理所有微服务的配置文件,那这样有没有什么问题?有,那就是无法配置文件无法自动更新,当我的git服务器上的配置文件更新后,不能同步更新到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wukongbubai/p/12381394.html</dc:identifier>
</item>
<item>
<title>使用C#开发pdf阅读器初探（基于WPF，没有使用开源库） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/pdf-reader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/pdf-reader.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt; pdf是最流行的版式格式文件标准，已成为国际标准。pdf相关的开源软件非常多，也基本能满足日常需要了。相关商业软件更是林林总总，几乎应有尽有！似乎没必要自己再独立自主开发！但，本人基于以下考虑，决定自主研发一款pdf阅读器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）通过编写pdf阅读器，可以迅速的熟悉pdf文件的处理。pdf格式包含的内容非常多，仅仅通过查资料，很难掌握其内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）任何技术，只有自主可控，才能到达气定神闲！使用开源软件是简单，万一遇到问题，就是个坑！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）解决pdf与ofd互转问题。ofd是国家标准，相关的处理软件非常少。为了解决两种格式文件互转，必须了解pdf。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）本人此前开发了一款ofd阅读器，积累了一些经验。为开发pdf阅读器增添了信心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;特别说明&lt;/strong&gt;&lt;/span&gt; 本人花了几周写了这款阅读器，验证了pdf不同类型的数据处理，还远远到不了商用的要求。不积跬步无以至千里！本人会慢慢完善这款软件，敬请期待。本人的参考资料有两本英文书籍和pdf英文标准文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;程序界面： &lt;a href=&quot;https://files.cnblogs.com/files/yuanchenhui/pdf%E9%98%85%E8%AF%BB%E5%99%A8%E5%92%8C%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6(QQ%E4%BA%A4%E6%B5%81%E7%BE%A4877371250).zip&quot; target=&quot;_blank&quot;&gt;点击下载程序&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200228235849475-2000775351.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;pdf相关参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200226204447268-443838125.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200226204540359-1100914526.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200226204202465-892102858.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;pdf文件结构简介 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;pdf总的内容结构如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200228222905488-1998635046.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1）header: 有关pdf版本信息。最新版为 %PDF−1. 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2）Body：存储具体数据，pdf就是由很多object组成的。每个object由dictionary和stream组成。dictionary存储就是key、value字符对。dictionary是可以嵌套的，就是value有可能也是一个dictionary。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3）Cross-Reference Table：交叉索引表。可以快速定位到具体object。便于随机读取object。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4）Trailer：给出交叉索引表的位置。读取pdf文件都是从最后开始读的，所以Trailer一定是在文件最后。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; pdf处理总体结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200228230402283-252284265.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; object内容读取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　交叉索引表能快速定位到某个object的位置，读取object内容不难，关键是分析dictionary。dictionary是可以嵌套，就是dictionary的内容还有dictionary。快速解析出所有的dictionary是处理的关键。典型的dictionary结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&amp;lt;
/Annots &lt;span&gt;68&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; R
&lt;/span&gt;/BleedBox [&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;504&lt;/span&gt; &lt;span&gt;661.5&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;/Contents [&lt;span&gt;51&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; R]
&lt;/span&gt;/CropBox [&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;504&lt;/span&gt; &lt;span&gt;661.5&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;/MediaBox [&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;504&lt;/span&gt; &lt;span&gt;661.5&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;/Parent &lt;span&gt;4334&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; R

&lt;/span&gt;/&lt;span&gt;Resources
&lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;嵌套dictionary&lt;/span&gt;
/ColorSpace &amp;lt;&amp;lt;/CS1 &lt;span&gt;62&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R&amp;gt;&amp;gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2次嵌套dictionary&lt;/span&gt;
/Font &amp;lt;&amp;lt;/F1 &lt;span&gt;7&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R/F2 &lt;span&gt;11&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R/F3 &lt;span&gt;13&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R/F4 &lt;span&gt;53&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R&amp;gt;&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2次嵌套dictionary&lt;/span&gt;
/ProcSet [/PDF/Text/ImageB/ImageC] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组&lt;/span&gt;
/XObject &amp;lt;&amp;lt;/I1 &lt;span&gt;54&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R/I2 &lt;span&gt;56&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R/I3 &lt;span&gt;60&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; R&amp;gt;&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2次嵌套dictionary&lt;/span&gt;
&amp;gt;&amp;gt;

/Type /&lt;span&gt;Page
&lt;/span&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;页面内容分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　页面内容由系列操作数和操作符组成。所有的操作数和操作符在同一个文本中，所以要快速的将操作数和操作符组成可以执行的操作对。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0 0 515.95 728.6 re
W* n
0 w
2 M
2 J
2 j
0 0 0 RG
BT
0 0 0 rg
/FT8 180 Tf
/GS13 gs
0.05 0 0 -0.05 187.68 676.49 Tm
&amp;lt;35BE&amp;gt;Tj 180 0 TD&amp;lt;1D5F&amp;gt;Tj 180 0 TD&amp;lt;4205&amp;gt;Tj 180 0 TD&amp;lt;4EC8&amp;gt;Tj
ET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　字符都是存在（）或&amp;lt;&amp;gt;中，除去字符和数字，就是操作符。如上文W*、n都是操作符；&amp;lt;35BE&amp;gt;为16进制字符对应的key，具体代表哪个字，需要到查字符表。这里的35BE并不是unicode字符对应的值，还需要再查表。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beginbfchar
&amp;lt;0019&amp;gt; &amp;lt;0036&amp;gt;
&amp;lt;35BE&amp;gt; &amp;lt;0037&amp;gt;
&amp;lt;001B&amp;gt; &amp;lt;0038&amp;gt;
&amp;lt;001C&amp;gt; &amp;lt;0039&amp;gt;
endbfchar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&amp;lt;35BE&amp;gt;对应的是&amp;lt;0037&amp;gt;。该表存在字体资源文件object中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 页面显示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　坐标系变换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　理清不同坐标系之间的关系是处理的关键。坐标系分为：Device Space（设备坐标空间）、User Space（设备坐标空间）、text space（文本坐标空间）等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　绘画上下文设置 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当前绘画的状态（画笔、画刷等）是保存在栈中，会有入栈出栈操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　特出画刷处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pdf有一种画刷，比如渐变色，这个很难找到现成的画刷使用。我使用的是ImageBrush，就是使用图片作为画刷。在内存中创建可擦写的图片，可以精确控制每个像素的值。根据pdf标准提供的算法，计算每个像素的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pdf的显示大体分为三种：曲线、文本、图片。其中曲线的显示是比较麻烦的，关键是将pdf标准的描述与wpf曲线操作对应起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;pdf阅读器开发说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果完全参数标准文件开发，是比较枯燥，感觉慢慢长路看不到尽头。我采用是单个功能各个击破的方法，能很快见到开发成果。我使用的参考书是《PDF Explained》，100多页，只是对pdf做大体介绍，但是各个功能点都有所提及。我就参照该书提供的示例文件，逐步验证每个文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每种显示都有多种处理方法，每个软件生成pdf的风格是不同的。对特定的软件生成的pdf做几次验证后，基本可以保证该软件生成的pdf都可以正常显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　wps是可以直接将doc文件转换为pdf的。我特地对wps生成的pdf做了测试，经过几次调试，现在基本可以正常处理wps生成的pdf文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200228235514724-1244569766.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;　后记&lt;/span&gt;&lt;/strong&gt; 对于开发pdf阅读器这类软件，以前都是不敢想象的。像这种复杂的软件，必须遵循一定的设计模式、正确建立域模型。所以开发这类软件，并不是在于你对pdf标准的理解是否深刻，关键还是编程的功底。继承、封装、多态、SOLID设计准则这些并不难理解，但是要达到应用自如还需要反复锤炼。把握好每个细节，正确运用设计准则，一步一个脚印，最终会将不可能变成可能！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 16:23:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 pdf是最流行的版式格式文件标准，已成为国际标准。pdf相关的开源软件非常多，也基本能满足日常需要了。相关商业软件更是林林总总，几乎应有尽有！似乎没必要自己再独立自主开发！但，本人基于以下考虑，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanchenhui/p/pdf-reader.html</dc:identifier>
</item>
<item>
<title>代码演示C#各版本新功能 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20200228-csharp-history-code-demo.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20200228-csharp-history-code-demo.html</guid>
<description>&lt;p&gt;C#各版本新功能其实都能在官网搜到，但很少有人整理在一起，并通过非常简短的代码将每个新特性演示出来。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;476.8265949068&quot;&gt;

&lt;p&gt;&lt;code&gt;C#&lt;/code&gt;各版本新功能其实都能在官网搜到，但很少有人整理在一起，并通过&lt;strong&gt;非常简短&lt;/strong&gt;的代码将每个新特性演示出来。&lt;/p&gt;
&lt;h2 id=&quot;c-2.0版---2005&quot;&gt;C# 2.0版 - 2005&lt;/h2&gt;
&lt;h3 id=&quot;泛型&quot;&gt;泛型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;中的泛型不支持值类型，且会运行时类型擦除，这一点&lt;code&gt;.NET&lt;/code&gt;更优秀。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// Declare the generic class.
public class GenericList&amp;lt;T&amp;gt;
{
    public void Add(T input) { }
}
class TestGenericList
{
    private class ExampleClass { }
    static void Main()
    {
        // Declare a list of type int.
        GenericList&amp;lt;int&amp;gt; list1 = new GenericList&amp;lt;int&amp;gt;();
        list1.Add(1);

        // Declare a list of type string.
        GenericList&amp;lt;string&amp;gt; list2 = new GenericList&amp;lt;string&amp;gt;();
        list2.Add(&quot;&quot;);

        // Declare a list of type ExampleClass.
        GenericList&amp;lt;ExampleClass&amp;gt; list3 = new GenericList&amp;lt;ExampleClass&amp;gt;();
        list3.Add(new ExampleClass());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分部类型&quot;&gt;分部类型&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;拆分一个类、一个结构、一个接口或一个方法的定义到两个或更多的文件中是可能的。 每个源文件包含类型或方法定义的一部分，编译应用程序时将把所有部分组合起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public partial class Employee
{
    public void DoWork()
    {
    }
}

public partial class Employee
{
    public void GoToLunch()
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匿名方法&quot;&gt;匿名方法&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Func&amp;lt;int, int, int&amp;gt; sum = delegate (int a, int b) { return a + b; };
Console.WriteLine(sum(3, 4));  // output: 7&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可以为null的值类型&quot;&gt;可以为null的值类型&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;double? pi = 3.14;
char? letter = 'a';

int m2 = 10;
int? m = m2;

bool? flag = null;

// An array of a nullable type:
int?[] arr = new int?[10];&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;迭代器&quot;&gt;迭代器&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main()
{
    foreach (int number in SomeNumbers())
    {
        Console.Write(number.ToString() + &quot; &quot;);
    }
    // Output: 3 5 8
    Console.ReadKey();
}

public static System.Collections.IEnumerable SomeNumbers()
{
    yield return 3;
    yield return 5;
    yield return 8;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协变和逆变&quot;&gt;协变和逆变&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 C# 中，协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。 协变保留分配兼容性，逆变则与之相反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// Assignment compatibility.   
string str = &quot;test&quot;;  
// An object of a more derived type is assigned to an object of a less derived type.   
object obj = str;  
  
// Covariance.   
IEnumerable&amp;lt;string&amp;gt; strings = new List&amp;lt;string&amp;gt;();  
// An object that is instantiated with a more derived type argument   
// is assigned to an object instantiated with a less derived type argument.   
// Assignment compatibility is preserved.   
IEnumerable&amp;lt;object&amp;gt; objects = strings;  
  
// Contravariance.             
// Assume that the following method is in the class:   
// static void SetObject(object o) { }   
Action&amp;lt;object&amp;gt; actObject = SetObject;  
// An object that is instantiated with a less derived type argument   
// is assigned to an object instantiated with a more derived type argument.   
// Assignment compatibility is reversed.   
Action&amp;lt;string&amp;gt; actString = actObject;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c-3.0版---2007&quot;&gt;C# 3.0版 - 2007&lt;/h2&gt;
&lt;h3 id=&quot;自动实现的属性&quot;&gt;自动实现的属性&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// This class is mutable. Its data can be modified from
// outside the class.
class Customer
{
    // Auto-implemented properties for trivial get and set
    public double TotalPurchases { get; set; }
    public string Name { get; set; }
    public int CustomerID { get; set; }

    // Constructor
    public Customer(double purchases, string name, int ID)
    {
        TotalPurchases = purchases;
        Name = name;
        CustomerID = ID;
    }

    // Methods
    public string GetContactInfo() { return &quot;ContactInfo&quot;; }
    public string GetTransactionHistory() { return &quot;History&quot;; }

    // .. Additional methods, events, etc.
}

class Program
{
    static void Main()
    {
        // Intialize a new object.
        Customer cust1 = new Customer(4987.63, &quot;Northwind&quot;, 90108);

        // Modify a property.
        cust1.TotalPurchases += 499.99;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匿名类型&quot;&gt;匿名类型&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var v = new { Amount = 108, Message = &quot;Hello&quot; };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and n .  
Console.WriteLine(v.Amount + v.Message);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询表达式linq&quot;&gt;查询表达式（LINQ）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LINQ&lt;/code&gt;允许你可以像写&lt;code&gt;SQL&lt;/code&gt;一样写&lt;code&gt;C#&lt;/code&gt;代码，像这样：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;from p in persons
where p.Age &amp;gt; 18 &amp;amp;&amp;amp; p.IsBeatiful
select new
{
    p.WeChatId, 
    p.PhoneNumber
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LINQ&lt;/code&gt;的意义在于让&lt;code&gt;C#&lt;/code&gt;做出了重大调整，本章中说到的&lt;code&gt;lambda&lt;/code&gt;表达式、扩展方法、表达式树、匿名类型、自动属性等，都是&lt;code&gt;LINQ&lt;/code&gt;的必要组成部分。&lt;/p&gt;
&lt;p&gt;由于用扩展方法的形式也能得到一致的结果，而且还能让代码风格更加一致，所以我平时用&lt;code&gt;LINQ&lt;/code&gt;语法较少：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// 与上文代码相同，但改成了扩展方法风格：
persons
    .Where(x =&amp;gt; x.Age &amp;gt; 18 &amp;amp;&amp;amp; x.IsBeatiful)
    .Select(x =&amp;gt; new 
    {
        x.WeChatId, 
        x.PhoneNumber, 
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lambda表达式&quot;&gt;Lambda表达式&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Func&amp;lt;int, int&amp;gt; square = x =&amp;gt; x * x;
Console.WriteLine(square(5));
// Output:
// 25&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表达式树&quot;&gt;表达式树&lt;/h3&gt;
&lt;p&gt;这个是&lt;code&gt;LINQ&lt;/code&gt;的基础之一，它的作用是将代码像数据一样，保存在内存中；然后稍后对这些“代码数据”进行重新解释/执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Entity Framework&lt;/code&gt;就是一个经典场景，它先将表达式树保存起来，然后执行时，将其翻译为&lt;code&gt;SQL&lt;/code&gt;发给数据库执行。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：表达式树并不能表示所有的代码，&lt;code&gt;C# 3.0&lt;/code&gt;之后的语法，包含&lt;code&gt;??&lt;/code&gt;、&lt;code&gt;?.&lt;/code&gt;、&lt;code&gt;async await&lt;/code&gt;、可选参数等，都无法放到表达式树中。据说官方准备更新它，但迟迟没有进展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;扩展方法&quot;&gt;扩展方法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static void Main()
{
    Console.WriteLine (&quot;Perth&quot;.IsCapitalized());    
    // Equivalent to:
    Console.WriteLine (StringHelper.IsCapitalized (&quot;Perth&quot;));   
    
    // Interfaces can be extended, too:
    Console.WriteLine (&quot;Seattle&quot;.First());   // S
}

public static class StringHelper
{
    public static bool IsCapitalized (this string s)
    {
        if (string.IsNullOrEmpty(s)) return false;
        return char.IsUpper (s[0]);
    }
    
    public static T First&amp;lt;T&amp;gt; (this IEnumerable&amp;lt;T&amp;gt; sequence)
    {
        foreach (T element in sequence)
            return element;
        
        throw new InvalidOperationException (&quot;No elements!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;var&quot;&gt;var&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var i = 10; // Implicitly typed.
int i = 10; // Explicitly typed.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分部方法&quot;&gt;分部方法&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;namespace PM
{
    partial class A
    {
        partial void OnSomethingHappened(string s);
    }

    // This part can be in a separate file.
    partial class A
    {
        // Comment out this method and the program
        // will still compile.
        partial void OnSomethingHappened(String s)
        {
            Console.WriteLine(&quot;Something happened: {0}&quot;, s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象和集合初始值设定项&quot;&gt;对象和集合初始值设定项&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class Cat
{
    // Auto-implemented properties.
    public int Age { get; set; }
    public string Name { get; set; }

    public Cat()
    {
    }

    public Cat(string name)
    {
        this.Name = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c-4.0版---2010&quot;&gt;C# 4.0版 - 2010&lt;/h2&gt;
&lt;h3 id=&quot;dynamic&quot;&gt;dynamic&lt;/h3&gt;
&lt;p&gt;这个是特性使得&lt;code&gt;CLR&lt;/code&gt;不得不进行一次修改。有了这个，&lt;code&gt;C#&lt;/code&gt;也能像&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;php&lt;/code&gt;、&lt;code&gt;python&lt;/code&gt;等弱类型语言一样写代码了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;dynamic a = 3;
a = 3.14;
a = &quot;Hello World&quot;;
a = new[] { 1, 2, 3, 4, 5 };
a = new Func&amp;lt;int&amp;gt;(() =&amp;gt; 3);
a = new StringBuilder();
Console.WriteLine(a.GetType().Name); // StringBuilder&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;dynamic&lt;/code&gt;可以表示任何东西，包含数组、委托等等。滥用&lt;code&gt;dynamic&lt;/code&gt;容易让程序变得很难维护。&lt;/p&gt;
&lt;h3 id=&quot;命名参数可选参数&quot;&gt;命名参数/可选参数&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;PrintOrderDetails(productName: &quot;Red Mug&quot;, sellerName: &quot;Gift Shop&quot;, orderNum: 31);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ExampleMethod(int required, string optionalstr = &quot;default string&quot;,
    int optionalint = 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;泛型中的协变和逆变&quot;&gt;泛型中的协变和逆变&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;IEnumerable&amp;lt;Derived&amp;gt; d = new List&amp;lt;Derived&amp;gt;();
IEnumerable&amp;lt;Base&amp;gt; b = d;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Action&amp;lt;Base&amp;gt; b = (target) =&amp;gt; { Console.WriteLine(target.GetType().Name); };
Action&amp;lt;Derived&amp;gt; d = b;
d(new Derived());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类型等效内置互操作类型&quot;&gt;类型等效、内置互操作类型&lt;/h3&gt;
&lt;p&gt;这个主要是为了和&lt;code&gt;COM&lt;/code&gt;进行交互。之前需要引用一些&lt;code&gt;COM&lt;/code&gt;类型相关的程序集，现在可以直接引用&lt;code&gt;COM&lt;/code&gt;。&lt;br/&gt;具体可以参见：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/framework/interop/type-equivalence-and-embedded-interop-types&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/framework/interop/type-equivalence-and-embedded-interop-types&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;c-5.0版---2012&quot;&gt;C# 5.0版 - 2012&lt;/h2&gt;
&lt;h3 id=&quot;asyncawait&quot;&gt;async/await&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;private DamageResult CalculateDamageDone()
{
    // Code omitted:
    //
    // Does an expensive calculation and returns
    // the result of that calculation.
}

calculateButton.Clicked += async (o, e) =&amp;gt;
{
    // This line will yield control to the UI while CalculateDamageDone()
    // performs its work.  The UI thread is free to perform other work.
    var damageResult = await Task.Run(() =&amp;gt; CalculateDamageDone());
    DisplayDamage(damageResult);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;的本质是状态机，像&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;一样。以前游戏引擎&lt;code&gt;Unity&lt;/code&gt;只支持&lt;code&gt;C# 3.0&lt;/code&gt;，因此当时它用状态机发&lt;code&gt;Http&lt;/code&gt;请求是用的&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;有两个好处，一是可以避免&lt;code&gt;UI&lt;/code&gt;线程卡顿，二是提高系统吞吐率，最终提高性能。&lt;/p&gt;
&lt;h3 id=&quot;调用方信息&quot;&gt;调用方信息&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void DoProcessing()
{
    TraceMessage(&quot;Something happened.&quot;);
}

public void TraceMessage(string message,
        [CallerMemberName] string memberName = &quot;&quot;,
        [CallerFilePath] string sourceFilePath = &quot;&quot;,
        [CallerLineNumber] int sourceLineNumber = 0)
{
    System.Diagnostics.Trace.WriteLine(&quot;message: &quot; + message);
    System.Diagnostics.Trace.WriteLine(&quot;member name: &quot; + memberName);
    System.Diagnostics.Trace.WriteLine(&quot;source file path: &quot; + sourceFilePath);
    System.Diagnostics.Trace.WriteLine(&quot;source line number: &quot; + sourceLineNumber);
}

// Sample Output:
//  message: Something happened.
//  member name: DoProcessing
//  source file path: c:\Visual Studio Projects\CallerInfoCS\CallerInfoCS\Form1.cs
//  source line number: 31&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个是编译期生成的，因此比&lt;code&gt;StackTrace&lt;/code&gt;更能保证性能。&lt;/p&gt;
&lt;h2 id=&quot;c-6.0版---2015&quot;&gt;C# 6.0版 - 2015&lt;/h2&gt;
&lt;h3 id=&quot;静态导入&quot;&gt;静态导入&lt;/h3&gt;
&lt;p&gt;终于可以不用写静态类名了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;using static System.Math;
using static System.Console;

WriteLine(Sin(3.14)); // 0.00159265291648683&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常筛选器&quot;&gt;异常筛选器&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;try-catch&lt;/code&gt;时，可以按指定的条件进行&lt;code&gt;catch&lt;/code&gt;，其它条件不&lt;code&gt;catch&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static async Task&amp;lt;string&amp;gt; MakeRequest()
{
    WebRequestHandler webRequestHandler = new WebRequestHandler();
    webRequestHandler.AllowAutoRedirect = false;
    using (HttpClient client = new HttpClient(webRequestHandler))
    {
        var stringTask = client.GetStringAsync(&quot;https://docs.microsoft.com/en-us/dotnet/about/&quot;);
        try
        {
            var responseText = await stringTask;
            return responseText;
        }
        catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(&quot;301&quot;))
        {
            return &quot;Site Moved&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自动初始化表达式&quot;&gt;自动初始化表达式&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public ICollection&amp;lt;double&amp;gt; Grades { get; } = new List&amp;lt;double&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;expression-bodied-函数成员&quot;&gt;Expression-bodied 函数成员&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public override string ToString() =&amp;gt; $&quot;{LastName}, {FirstName}&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;null传播器&quot;&gt;Null传播器&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var first = person?.FirstName;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串内插&quot;&gt;字符串内插&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public string GetGradePointPercentage() =&amp;gt;
    $&quot;Name: {LastName}, {FirstName}. G.P.A: {Grades.Average():F2}&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nameof表达式&quot;&gt;&lt;code&gt;nameof&lt;/code&gt;表达式&lt;/h3&gt;
&lt;p&gt;有时字符串值和某个变量名称一致，尤其是在做参数验证时。这里&lt;code&gt;nameof&lt;/code&gt;就能在编译期，自动从变量名生成一个字符串。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;if (IsNullOrWhiteSpace(lastName))
    throw new ArgumentException(message: &quot;Cannot be blank&quot;, paramName: nameof(lastName));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;索引初始值设定项&quot;&gt;索引初始值设定项&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使集合初始化更容易的另一个功能是对 Add 方法使用扩展方法 。 添加此功能的目的是进行 Visual Basic 的奇偶校验。 如果自定义集合类的方法具有通过语义方式添加新项的名称，则此功能非常有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;c-7.0版本---2017&quot;&gt;C# 7.0版本 - 2017&lt;/h2&gt;
&lt;h3 id=&quot;out变量&quot;&gt;out变量&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;if (int.TryParse(input, out int result))
    Console.WriteLine(result);
else
    Console.WriteLine(&quot;Could not parse input&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;元组和析构函数&quot;&gt;元组和析构函数&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;(string Alpha, string Beta) namedLetters = (&quot;a&quot;, &quot;b&quot;);
Console.WriteLine($&quot;{namedLetters.Alpha}, {namedLetters.Beta}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;析构函数应该类似C++中的析构函数，在实例回收时执行？&lt;/p&gt;
&lt;h3 id=&quot;模式匹配&quot;&gt;模式匹配&lt;/h3&gt;
&lt;p&gt;现在可以在匹配一个类型时，自动转换为这个类型的变量，如果转换失败，这个变量就赋值为默认值（&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;0&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;极简版：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;if (input is int count)
    sum += count;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;switch/case版：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static int SumPositiveNumbers(IEnumerable&amp;lt;object&amp;gt; sequence)
{
    int sum = 0;
    foreach (var i in sequence)
    {
        switch (i)
        {
            case 0:
                break;
            case IEnumerable&amp;lt;int&amp;gt; childSequence:
            {
                foreach(var item in childSequence)
                    sum += (item &amp;gt; 0) ? item : 0;
                break;
            }
            case int n when n &amp;gt; 0:
                sum += n;
                break;
            case null:
                throw new NullReferenceException(&quot;Null found in sequence&quot;);
            default:
                throw new InvalidOperationException(&quot;Unrecognized type&quot;);
        }
    }
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;本地函数&quot;&gt;本地函数&lt;/h3&gt;
&lt;p&gt;这个主要是方便，&lt;code&gt;javascript&lt;/code&gt;就能这样写。&lt;/p&gt;
&lt;p&gt;比&lt;code&gt;lambda&lt;/code&gt;的好处在于，这个可以定义在后面，而&lt;code&gt;lambda&lt;/code&gt;必须定义在前面。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static IEnumerable&amp;lt;char&amp;gt; AlphabetSubset3(char start, char end)
{
    if (start &amp;lt; 'a' || start &amp;gt; 'z')
        throw new ArgumentOutOfRangeException(paramName: nameof(start), message: &quot;start must be a letter&quot;);
    if (end &amp;lt; 'a' || end &amp;gt; 'z')
        throw new ArgumentOutOfRangeException(paramName: nameof(end), message: &quot;end must be a letter&quot;);

    if (end &amp;lt;= start)
        throw new ArgumentException($&quot;{nameof(end)} must be greater than {nameof(start)}&quot;);

    return alphabetSubsetImplementation();

    IEnumerable&amp;lt;char&amp;gt; alphabetSubsetImplementation()
    {
        for (var c = start; c &amp;lt; end; c++)
            yield return c;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更多的expression-bodied成员&quot;&gt;更多的expression-bodied成员&lt;/h3&gt;
&lt;p&gt;该功能可以让一些函数写成表达式的形式，非常的方便。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// Expression-bodied constructor
public ExpressionMembersExample(string label) =&amp;gt; this.Label = label;

// Expression-bodied finalizer
~ExpressionMembersExample() =&amp;gt; Console.Error.WriteLine(&quot;Finalized!&quot;);

private string label;

// Expression-bodied get / set accessors.
public string Label
{
    get =&amp;gt; label;
    set =&amp;gt; this.label = value ?? &quot;Default label&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ref-局部变量和返回结果&quot;&gt;Ref 局部变量和返回结果&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此功能允许使用并返回对变量的引用的算法，这些变量在其他位置定义。 一个示例是使用大型矩阵并查找具有某些特征的单个位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个功能主要是为了提高值类型的性能，让它真正发挥其作用。&lt;code&gt;C++&lt;/code&gt;就有类似的功能。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static ref int Find(int[,] matrix, Func&amp;lt;int, bool&amp;gt; predicate)
{
    for (int i = 0; i &amp;lt; matrix.GetLength(0); i++)
        for (int j = 0; j &amp;lt; matrix.GetLength(1); j++)
            if (predicate(matrix[i, j]))
                return ref matrix[i, j];
    throw new InvalidOperationException(&quot;Not found&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;ref var item = ref MatrixSearch.Find(matrix, (val) =&amp;gt; val == 42);
Console.WriteLine(item);
item = 24;
Console.WriteLine(matrix[4, 2]);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;弃元&quot;&gt;弃元&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;通常，在进行元组解构或使用&lt;code&gt;out&lt;/code&gt;参数调用方法时，必须定义一个其值无关紧要且你不打算使用的变量。 为处理此情况，&lt;code&gt;C#&lt;/code&gt;增添了对弃元的支持 。 弃元是一个名为&lt;code&gt;_&lt;/code&gt;的只写变量，可向单个变量赋予要放弃的所有值。 弃元类似于未赋值的变量；不可在代码中使用弃元（赋值语句除外）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;

public class Example
{
    public static void Main()
    {
        var (_, _, _, pop1, _, pop2) = QueryCityDataForYears(&quot;New York City&quot;, 1960, 2010);

        Console.WriteLine($&quot;Population change, 1960 to 2010: {pop2 - pop1:N0}&quot;);
    }
   
    private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
    {
        int population1 = 0, population2 = 0;
        double area = 0;
      
        if (name == &quot;New York City&quot;)
        {
            area = 468.48; 
            if (year1 == 1960)
            {
                population1 = 7781984;
            }
            if (year2 == 2010)
            {
                population2 = 8175133;
            }
            return (name, area, year1, population1, year2, population2);
        }

        return (&quot;&quot;, 0, 0, 0, 0, 0);
    }
}
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二进制文本和数字分隔符&quot;&gt;二进制文本和数字分隔符&lt;/h3&gt;
&lt;p&gt;这个用于使数字和二进制更可读。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// 二进制文本：
public const int Sixteen =   0b0001_0000;
public const int ThirtyTwo = 0b0010_0000;
public const int SixtyFour = 0b0100_0000;
public const int OneHundredTwentyEight = 0b1000_0000;

// 数字分隔符：
public const long BillionsAndBillions = 100_000_000_000;
public const double AvogadroConstant = 6.022_140_857_747_474e23;
public const decimal GoldenRatio = 1.618_033_988_749_894_848_204_586_834_365_638_117_720_309_179M;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;throw表达式&quot;&gt;throw表达式&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;throw&lt;/code&gt;之前必须是一个语句，因此有时不得不写更多的代码来完成所需功能。但&lt;code&gt;7.0&lt;/code&gt;提供了&lt;code&gt;throw&lt;/code&gt;表达式来使代码更简洁，阅读更轻松。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;void Main()
{
    // You can now throw expressions in expressions clauses.
    // This is useful in conditional expressions:
    
    string result = new Random().Next(2) == 0 ? &quot;Good&quot; : throw new Exception (&quot;Bad&quot;);
    result.Dump();
    
    Foo().Dump();
}

public string Foo() =&amp;gt; throw new NotImplementedException();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c-8.0-版---2019&quot;&gt;C# 8.0 版 - 2019&lt;/h2&gt;
&lt;h3 id=&quot;readonly-成员&quot;&gt;Readonly 成员&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public readonly override string ToString() =&amp;gt;
    $&quot;({X}, {Y}) is {Distance} from the origin&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;默认接口方法&quot;&gt;默认接口方法&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;接口中也能定义方法了，这个新功能经常受到争论。但想想，有时是先定义接口，而实现接口需要实现很多相关、但又繁琐的功能，如&lt;code&gt;ASP.NET Core&lt;/code&gt;中的&lt;code&gt;ILogger&lt;/code&gt;，谁用谁知道，特别多需要实现的方法，但又都差不多。因此所以这个功能其实很有必要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;void Main()
{
    ILogger foo = new Logger();
    foo.Log (new Exception (&quot;test&quot;));   
}

class Logger : ILogger
{   
    public void Log (string message) =&amp;gt; Console.WriteLine (message);
}

interface ILogger
{
    void Log (string message);  
    
    // Adding a new member to an interface need not break implementors:
    public void Log (Exception ex) =&amp;gt; Log (ExceptionHeader + ex.Message);
    
    // The static modifier (and other modifiers) are now allowed:
    static string ExceptionHeader = &quot;Exception: &quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模式匹配增强&quot;&gt;模式匹配增强&lt;/h3&gt;
&lt;p&gt;这个是为简化代码、函数式编程而生的，我个人非常喜欢。&lt;/p&gt;
&lt;h4 id=&quot;属性模式&quot;&gt;属性模式&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static decimal ComputeSalesTax(Address location, decimal salePrice) =&amp;gt;
    location switch
    {
        { State: &quot;WA&quot; } =&amp;gt; salePrice * 0.06M,
        { State: &quot;MN&quot; } =&amp;gt; salePrice * 0.75M,
        { State: &quot;MI&quot; } =&amp;gt; salePrice * 0.05M,
        // other cases removed for brevity...
        _ =&amp;gt; 0M
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tuple模式&quot;&gt;Tuple模式&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static string RockPaperScissors(string first, string second)
    =&amp;gt; (first, second) switch
    {
        (&quot;rock&quot;, &quot;paper&quot;) =&amp;gt; &quot;rock is covered by paper. Paper wins.&quot;,
        (&quot;rock&quot;, &quot;scissors&quot;) =&amp;gt; &quot;rock breaks scissors. Rock wins.&quot;,
        (&quot;paper&quot;, &quot;rock&quot;) =&amp;gt; &quot;paper covers rock. Paper wins.&quot;,
        (&quot;paper&quot;, &quot;scissors&quot;) =&amp;gt; &quot;paper is cut by scissors. Scissors wins.&quot;,
        (&quot;scissors&quot;, &quot;rock&quot;) =&amp;gt; &quot;scissors is broken by rock. Rock wins.&quot;,
        (&quot;scissors&quot;, &quot;paper&quot;) =&amp;gt; &quot;scissors cuts paper. Scissors wins.&quot;,
        (_, _) =&amp;gt; &quot;tie&quot;
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;位置模式&quot;&gt;位置模式&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static Quadrant GetQuadrant(Point point) =&amp;gt; point switch
{
    (0, 0) =&amp;gt; Quadrant.Origin,
    var (x, y) when x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 =&amp;gt; Quadrant.One,
    var (x, y) when x &amp;lt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 =&amp;gt; Quadrant.Two,
    var (x, y) when x &amp;lt; 0 &amp;amp;&amp;amp; y &amp;lt; 0 =&amp;gt; Quadrant.Three,
    var (x, y) when x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; 0 =&amp;gt; Quadrant.Four,
    var (_, _) =&amp;gt; Quadrant.OnBorder,
    _ =&amp;gt; Quadrant.Unknown
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;switch表达式&quot;&gt;switch表达式&lt;/h3&gt;
&lt;p&gt;这个功能能使代码从大量的&lt;code&gt;if/else&lt;/code&gt;或&lt;code&gt;switch/case&lt;/code&gt;变成“一行代码”，符合函数式编程的思想，非常好用！&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static RGBColor FromRainbow(Rainbow colorBand) =&amp;gt;
    colorBand switch
    {
        Rainbow.Red    =&amp;gt; new RGBColor(0xFF, 0x00, 0x00),
        Rainbow.Orange =&amp;gt; new RGBColor(0xFF, 0x7F, 0x00),
        Rainbow.Yellow =&amp;gt; new RGBColor(0xFF, 0xFF, 0x00),
        Rainbow.Green  =&amp;gt; new RGBColor(0x00, 0xFF, 0x00),
        Rainbow.Blue   =&amp;gt; new RGBColor(0x00, 0x00, 0xFF),
        Rainbow.Indigo =&amp;gt; new RGBColor(0x4B, 0x00, 0x82),
        Rainbow.Violet =&amp;gt; new RGBColor(0x94, 0x00, 0xD3),
        _              =&amp;gt; throw new ArgumentException(message: &quot;invalid enum value&quot;, paramName: nameof(colorBand)),
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;using声明&quot;&gt;using声明&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static int WriteLinesToFile(IEnumerable&amp;lt;string&amp;gt; lines)
{
    using var file = new System.IO.StreamWriter(&quot;WriteLines2.txt&quot;);
    // Notice how we declare skippedLines after the using statement.
    int skippedLines = 0;
    foreach (string line in lines)
    {
        if (!line.Contains(&quot;Second&quot;))
        {
            file.WriteLine(line);
        }
        else
        {
            skippedLines++;
        }
    }
    // Notice how skippedLines is in scope here.
    return skippedLines;
    // file is disposed here
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;静态本地函数&quot;&gt;静态本地函数&lt;/h3&gt;
&lt;p&gt;相比非静态本地函数，静态本地函数没有闭包，因此生成的代码更少，性能也更容易控制。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;int M()
{
    int y = 5;
    int x = 7;
    return Add(x, y);

    static int Add(int left, int right) =&amp;gt; left + right;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异步流&quot;&gt;异步流&lt;/h3&gt;
&lt;p&gt;这个功能和&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;对应，一个经典的表格如下：&lt;br/&gt;| | 单值 | 多值 |&lt;br/&gt;| ---- | ------- | -------------- |&lt;br/&gt;| 同步 | T | IEnumerable |&lt;br/&gt;| 异步 | Task | ?&lt;/p&gt;
&lt;p&gt;其中，这个问号&lt;code&gt;?&lt;/code&gt;终于有了答案，它就叫异步流——&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public static async System.Collections.Generic.IAsyncEnumerable&amp;lt;int&amp;gt; GenerateSequence()
{
    for (int i = 0; i &amp;lt; 20; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不像&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;，&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;系统还没有内置扩展方法，因此可能没有&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;方便，&lt;strong&gt;但是&lt;/strong&gt;可以通过安装&lt;code&gt;NuGet&lt;/code&gt;包&lt;code&gt;f&lt;/code&gt;来实现和&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;一样（或者更爽）的效果。&lt;/p&gt;
&lt;h3 id=&quot;索引和范围&quot;&gt;索引和范围&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;和&lt;code&gt;Python&lt;/code&gt;中的切片器一样，只是&lt;code&gt;-&lt;/code&gt;用&lt;code&gt;^&lt;/code&gt;代替了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var words = new string[]
{
                // index from start    index from end
    &quot;The&quot;,      // 0                   ^9
    &quot;quick&quot;,    // 1                   ^8
    &quot;brown&quot;,    // 2                   ^7
    &quot;fox&quot;,      // 3                   ^6
    &quot;jumped&quot;,   // 4                   ^5
    &quot;over&quot;,     // 5                   ^4
    &quot;the&quot;,      // 6                   ^3
    &quot;lazy&quot;,     // 7                   ^2
    &quot;dog&quot;       // 8                   ^1
};              // 9 (or words.Length) ^0

var quickBrownFox = words[1..4];
var lazyDog = words[^2..^0];
var allWords = words[..]; // contains &quot;The&quot; through &quot;dog&quot;.
var firstPhrase = words[..4]; // contains &quot;The&quot; through &quot;fox&quot;
var lastPhrase = words[6..]; // contains &quot;the&quot;, &quot;lazy&quot; and &quot;dog&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;null合并赋值&quot;&gt;Null合并赋值&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;List&amp;lt;int&amp;gt; numbers = null;
int? i = null;

numbers ??= new List&amp;lt;int&amp;gt;();
numbers.Add(i ??= 17);
numbers.Add(i ??= 20);

Console.WriteLine(string.Join(&quot; &quot;, numbers));  // output: 17 17
Console.WriteLine(i);  // output: 17&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;非托管构造类型&quot;&gt;非托管构造类型&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;与任何非托管类型一样，可以创建指向此类型的变量的指针，或针对此类型的实例在堆栈上分配内存块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Span&amp;lt;Coords&amp;lt;int&amp;gt;&amp;gt; coordinates = stackalloc[]
{
    new Coords&amp;lt;int&amp;gt; { X = 0, Y = 0 },
    new Coords&amp;lt;int&amp;gt; { X = 0, Y = 3 },
    new Coords&amp;lt;int&amp;gt; { X = 4, Y = 0 }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套表达式中的-stackalloc&quot;&gt;嵌套表达式中的 stackalloc&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Span&amp;lt;int&amp;gt; numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 };
var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6 ,8 });
Console.WriteLine(ind);  // output: 1&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这么多功能，你印象最深刻的是哪个呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6.2426035502959&quot;&gt;
&lt;p&gt;参考资料：C#发展历史 - C#指南 | Microsoft Docs &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文内容和代码由&lt;strong&gt;肖鹏&lt;/strong&gt;整理，有修改；转载已获得肖鹏本人授权。&lt;strong&gt;肖鹏&lt;/strong&gt;是我公司从&lt;code&gt;Java&lt;/code&gt;转&lt;code&gt;.NET&lt;/code&gt;的同事。原文链接为：&lt;a href=&quot;https://akiyax.github.io/new-features-in-csharp/&quot; class=&quot;uri&quot;&gt;https://akiyax.github.io/new-features-in-csharp/&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 28 Feb 2020 15:54:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>C#各版本新功能其实都能在官网搜到，但很少有人整理在一起，并通过非常简短的代码将每个新特性演示出来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20200228-csharp-history-code-demo.html</dc:identifier>
</item>
<item>
<title>Golang实现高性能凑单工具：给定计算所有组合 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12145928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12145928.html</guid>
<description>&lt;p&gt;公司有一个比较坑爹的报销方案，需要根据一堆零碎的发票中，凑出一个目标金额，要求误差在1块钱以内。&lt;br/&gt;例如：你有一堆发票[100, 101, 103, 105, 106, 132, 129, 292, 182, 188, 224.3, 40.5, 35.9, 32.5, 39, 12, 17.5, 28, 35, 34, 26.32, 28, 35, 39, 25, 1, 24, 35, 45, 47, 32.11, 45, 32, 38.88, 44, 36.5, 35.8, 45, 26.5, 33, 25, 364, 27.3, 39.2, 180, 279, 282, 281, 285, 275, 277, 278, 200, 201, 1959.12, 929.53, 1037.03, 1033.9]，让你从这堆票中凑出5000块来，然后最多不能超过1块钱。你瞧瞧这是人干的事么！&lt;/p&gt;
&lt;p&gt;缺点：每次人肉去对比，浪费大量的时间。&lt;br/&gt;操作过程大概是这样的：新建一个excel表格，将所有的金额录入，然后自己勾选发票，直到目标金额出现，如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200229000412776-2101645252.png&quot;/&gt;&lt;br/&gt;人品大爆发的时候一下就凑出来，运气不好的时候凑着凑着一两个小时就过去了！&lt;br/&gt;因此，我们急需一个程序自己去干这个事。&lt;/p&gt;

&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最差方案：全组和&lt;br/&gt;使用全组合，搜索所有组合方案，遍历满足的结果输出，时间复杂度为O(n!)，原先调用了python的排列组合函数实现，结果卡得不行，有时候能把程序跑挂了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;中等方案：回溯暴力破解&lt;br/&gt;利用回溯输出，存在重复递归，时间复杂度为O(2^n)，一般来说已经满足正常需求，但是如果n很大，还是影响性能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最优方案：动态规划&lt;br/&gt;时间复杂度为O(n*w)，为最快方案，提升气质指数，5颗星！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终用动态规划思想实现，空间换时间，200个碎票匹配1万的金额秒出结果，大概使用800M内存，&lt;/p&gt;
&lt;p&gt;代码已经贴到github：&lt;a href=&quot;https://github.com/chenqionghe/amount-calculator&quot;&gt;chenqionghe/amount-calculator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;github.com/shopspring/decimal&quot;
    &quot;strconv&quot;
    &quot;time&quot;
)

type InvoiceCounter struct {
    maxValue int   //期望值（单元为分）
    items    []int //发票金额（单元为分）
    overflow int   //允许的误差值（单元为分）
}

//items:所有发票 maxValue:目标金额 overflow:允许误差金额
func NewInvoiceCounter(items []float64, maxValue float64, overflow float64) *InvoiceCounter {
    obj := &amp;amp;InvoiceCounter{}
    obj.maxValue = obj.dollarToCent(maxValue)
    obj.overflow = obj.dollarToCent(overflow)
    centItems := make([]int, len(items))
    for i, v := range items {
        centItems[i] = obj.dollarToCent(v)
    }
    obj.items = centItems
    return obj
}

//元转分
func (this *InvoiceCounter) dollarToCent(value float64) int {
    value, _ = strconv.ParseFloat(fmt.Sprintf(&quot;%.2f&quot;, value), 64)
    decimalValue := decimal.NewFromFloat(value)
    decimalValue = decimalValue.Mul(decimal.NewFromInt(100))
    res, _ := decimalValue.Float64()
    return int(res)
}
//分转元
func (this *InvoiceCounter) centToDollar(v int) float64 {
    value := float64(v)
    value, _ = strconv.ParseFloat(fmt.Sprintf(&quot;%.2f&quot;, value/100), 64)
    return value
}

//执行计算，返回所有方案
func (this *InvoiceCounter) Run() [][]float64 {
    items := this.items
    n := len(this.items)
    max := this.maxValue + this.overflow
    states := this.createStates(len(this.items), max+1)
    states[0][0] = true
    if items[0] &amp;lt;= max {
        states[0][items[0]] = true
    }
    for i := 1; i &amp;lt; n; i++ {
        //不选
        for j := 0; j &amp;lt;= max; j++ {
            if states[i-1][j] {
                states[i][j] = states[i-1][j]
            }
        }
        //选中
        for j := 0; j &amp;lt;= max-items[i]; j++ {
            if states[i-1][j] {
                states[i][j+items[i]] = true
            }
        }
    }
    //获取最终所有满足的方案
    res := make([][]float64, 0)
    for j := this.maxValue; j &amp;lt;= max; j++ {
        for i := 0; i &amp;lt; n; i++ {
            if states[i][j] {
                //判断必须最后一个选中才算，要不区间有重合 比如前5个元素已经满足目标金额了，state[5][w]=true，然后state[6][w]也是true，存在重复的方案
                if j-items[i] &amp;gt;= 0 &amp;amp;&amp;amp; states[i-1][j-items[i]] == true {
                    res = append(res, this.getSelected(states, items, i, j))
                }
            }
        }
    }
    return res
}

//获取所有选中的元素（倒推）
func (this *InvoiceCounter) getSelected(states [][]bool, items []int, n, max int) []float64 {
    var selected = make([]int, 0)
    for i := n; i &amp;gt;= 1; i-- {
        //元素被选中
        if max-items[i] &amp;gt;= 0 &amp;amp;&amp;amp; states[i-1][max-items[i]] == true {
            selected = append([]int{items[i]}, selected...)
            max = max - items[i]
        } else {
            //没选，max重量不变，直接进入下一次
        }
    }
    if max != 0 {
        selected = append([]int{items[0]}, selected...)
    }
    dollarItems := make([]float64, len(selected))
    for i, v := range selected {
        dollarItems[i] = this.centToDollar(v)
    }
    return dollarItems
}

//初始化所有状态
func (this *InvoiceCounter) createStates(n, max int) [][]bool {
    states := make([][]bool, n)
    for i, _ := range states {
        states[i] = make([]bool, max)
    }
    return states
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;直接调用代码适合用来开发自己的软件&quot;&gt;1.直接调用代码（适合用来开发自己的软件）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;github.com/chenqionghe/amount-calculator&quot;
    &quot;time&quot;
)

func main() {
    //所有碎票
    items := []float64{100, 101, 103, 105, 106, 132, 129, 292, 182, 188, 224.3, 40.5, 35.9, 32.5, 39, 12, 17.5, 28, 35, 34, 26.32, 28, 35, 39, 25, 1, 24, 35, 45, 47, 32.11, 45, 32, 38.88, 44, 36.5, 35.8, 45, 26.5, 33, 25, 364, 27.3, 39.2, 180, 279, 282, 281, 285, 275, 277, 278, 200, 201, 1959.12, 929.53, 1037.03, 1033.9}
    //目标金额
    target := float64(5000)
    //允许超出
    overflow := float64(1)
    obj := amountcalculator.New(items, target, overflow)

    startTime := time.Now()

    //获取所有的组合
    res := obj.GetCombinations()
    for _, v := range res {
        fmt.Println(v)
    }
    fmt.Printf(&quot;total:%d used time：%s\n&quot;, len(res), time.Now().Sub(startTime))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[100 101 103 105 106 132 129 292 182 188 224.3 40.5 12 17.5 35 34 26.32 28 35 39 25 1 24 35 45 47 45 32 38.88 44 36.5 45 26.5 33 25 364 27.3 39.2 180 279 282 281 285 275 277 278]
[100 101 103 105 132 129 292 182 188 35.9 39 12 17.5 28 35 34 26.32 28 35 39 25 1 24 35 45 47 32.11 45 32 38.88 44 36.5 35.79 45 26.5 33 25 364 27.3 39.2 180 279 282 281 285 275 277 278 200]
...
[35.9 25 24 38.88 36.5 35.79 45 26.5 33 25 27.3 39.2 180 279 282 281 285 275 277 278 200 201 1037.03 1033.9]
total:577 used time：97.048224ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;耗时97毫秒，共计算出577种方案，性能高到令人忍不住想鼓掌！&lt;/p&gt;
&lt;p&gt;这种方式适合在自己开发的程序中使用，比如要出一个web界面，给前端提供数据&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/662544/202002/662544-20200229001401565-915381306.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;命令行模式适合不会编程的人使用&quot;&gt;2.命令行模式（适合不会编程的人使用）&lt;/h2&gt;
&lt;p&gt;这种方式适合不会go语言，或者不会编程的人使用，只需编译出对应平台的版本就行。&lt;br/&gt;一次编译多次分发，相当于copy了个绿色版软件到电脑上直接使用&lt;/p&gt;
&lt;p&gt;编译过程如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建一个go文件：main.go&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;github.com/chenqionghe/amount-calculator&quot;
)

func main() {
    amountcalculator.RunCliMode()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;go build -o amount-calculator&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行该工具&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; ./amount-calculator -max=156 -overflow=1 -items=12,135,11,12,15,16,18,32,64,76,50
156 [11 15 16 18 32 64]
156 [16 64 76]
156 [12 18 76 50]
157 [12 15 16 18 32 64]
157 [15 16 18 32 76]
157 [15 16 76 50]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，命令行直接输出了所有匹配的组合，还给出了每个组合的金额，对于使用者来说，不会编程语言也完全没有关系，只需要自己执行一下即可，相当方便。&lt;/p&gt;
&lt;p&gt;另外，命令行模式省了一个编译的过程，效率更高，推荐！&lt;/p&gt;

&lt;p&gt;技术解放生产力，这种重复且费时的劳动完全应该由程序去做，可惜的是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一般的产品提不出这样的需求&lt;/li&gt;
&lt;li&gt;产品即使能提这样的需求，开发也不一定能实现出来&lt;/li&gt;
&lt;li&gt;开发即使能实现出来，程序也不一定能跑得动，因为很可能太耗内存或太耗CPU，还没等结果运行出来程序就挂了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;哈哈，稍微有点吹牛逼了，不管怎么样，就一句话：yeah buddy! light weight baby! 让我听到你们的尖叫声！&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 15:53:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>[toc] 一、需求 公司有一个比较坑爹的报销方案，需要根据一堆零碎的发票中，凑出一个目标金额，要求误差在1块钱以内。 例如：你有一堆发票[100, 101, 103, 105, 106, 132,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/12145928.html</dc:identifier>
</item>
<item>
<title>视频在线率统计——基于驱动总线设备的领域驱动设计方法落地 - JerryMouseLi</title>
<link>http://www.cnblogs.com/JerryMouseLi/p/12381098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JerryMouseLi/p/12381098.html</guid>
<description>&lt;p&gt;本司智能信息箱产品是管控摄像头电源，监控摄像头视频在线率的一个有效运维工具。因为统计视频在线率是业主十分关心的问题，所以如何有效地统计视频在线率是工程师需要努力解决的问题。&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ping&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;onvif&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ffmpeg&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;ping，onvif,ffmpeg三种协议应用场合不同，各有优劣。onvif会多出用户名，密码字段，方法上会多StartStreaming，StopStreaming，及识别视频的编码分辨率等信息，从而从媒体信息地址URI获取视频流；ffmpeg则更进一步，可以直接调用方法分析视频质量等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里需要声明本文侧重点有两方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向领域编程，不面向数据库，下文会做详解；&lt;/li&gt;
&lt;li&gt;第2点的三种协议都可以借鉴linux的设备，总线，驱动与摄像头之间的交互协议设计思想，只是创建子领域对象时onvif会多用户名，密码字段，方法上会多StartStreaming，StopStreaming。ffmpeg则可以直接将需要的方法包装到子领域进行调用。因此本文侧重讲解设备，总线，驱动来开发与硬件设备交互的思想。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606616/202002/1606616-20200228233525080-1620885788.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;值对象drivercontext&quot;&gt;4.1 值对象driverContext&lt;/h2&gt;
&lt;p&gt;driverContext是用来配置ping驱动软件（new System.Net.Ping()）接口正常工作的上下文配置。这里主要是interval，timeout，minSuccess三个字段，其中timeout是驱动内配置，interval，minSuccess为驱动外配置，下文6.1中会有详细举例，按下不表。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3个字段含义详见注释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class PingDriverContext
    {
        ///可以增加name字段，表示驱动名称。

        /// &amp;lt;summary&amp;gt;
        /// ping间隔
        /// &amp;lt;/summary&amp;gt;
        public int interval { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// ping超时时间
        /// &amp;lt;/summary&amp;gt;
        public int timeout { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// ping成功最小次数
        /// &amp;lt;/summary&amp;gt;
        public int minSuccess { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;子领域camerapingdm&quot;&gt;4.2 子领域CameraPingDM&lt;/h2&gt;
&lt;p&gt;Camera表示摄像头，ping表示检查摄像头网络状态的驱动，DM表示Domain Model即领域模型。&lt;/p&gt;
&lt;h3 id=&quot;枚举类型摄像头网络状态camerastate&quot;&gt;4.2.1 枚举类型摄像头网络状态CameraState&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    public enum CameraState
    {
        Online = 0,
        Offline = 1,
        Unknown = 2
    }   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性&quot;&gt;4.2.2 属性&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        private PingDriverContext _driverContext;

        private Timer _timer;

        private readonly object _lock = new object();
        private readonly ReadOnlyMemory&amp;lt;byte&amp;gt; _buffer;

        public int CurrentSuccess { get; private set; }
        /// &amp;lt;summary&amp;gt;
        /// IP地址
        /// &amp;lt;/summary&amp;gt;
        public string Ip { get; set; }
     
        ///// &amp;lt;summary&amp;gt;
        ///// 状态
        ///// &amp;lt;/summary&amp;gt;
        private CameraState cameraState;

        public CameraState CameraState
        {
            get { return cameraState; }
            set { cameraState = value; }
        }
        /// &amp;lt;summary&amp;gt;
        /// 摄像头状态更新时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime UpdateTime { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;_driverContext&lt;br/&gt;值对象，每个摄像头的timeout，interval，minSuccess都可以配置不同，这里在总线类文件里写死成&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        interval = 3,//每个摄像头间隔3秒ping一次
        timeout = 200,//单次ping等待返回结果200ms超时
        minSuccess = 0,//一次ping成功即可认为online&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;_lock&lt;br/&gt;多线程并发互斥锁&lt;/li&gt;
&lt;li&gt;_buffer&lt;br/&gt;ping发送的数据包。&lt;/li&gt;
&lt;li&gt;CurrentSuccess&lt;br/&gt;当前ping成功次数，根据minSuccess进行适当的计数清零。&lt;/li&gt;
&lt;li&gt;cameraState&lt;br/&gt;网络状态，详见4.2.1&lt;/li&gt;
&lt;li&gt;UpdateTime&lt;br/&gt;摄像头状态更新时间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;子领域的划分&quot;&gt;4.2.3 子领域的划分&lt;/h3&gt;
&lt;h4 id=&quot;析构体&quot;&gt;4.2.3.1析构体&lt;/h4&gt;
&lt;p&gt;在析构体中，主要传入创建子领域对象所必须的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        #region Constructors
        /// &amp;lt;summary&amp;gt;
        /// 根据IP，以及driverContext创建摄像头领域模型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;driverContext&quot;&amp;gt;聚合CameraPingBus中的驱动上下文driverContext&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;iP&quot;&amp;gt;数据库中的摄像头的IP地址&amp;lt;/param&amp;gt;
        public CameraPingDM(PingDriverContext driverContext, string iP)
        {
            string data = &quot;ping-pong&quot;;
            _buffer = Encoding.ASCII.GetBytes(data);
            Ip = iP;
            _driverContext = driverContext;

            LoggerHelper.Debug($&quot;Ping camera IPList every {_driverContext.interval}s&quot;);
        }
        //Dapper数据模型需要
        public CameraPingDM(){ }
        #endregion&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建子领域对象&quot;&gt;4.2.3.2 创建子领域对象&lt;/h4&gt;
&lt;p&gt;这里就是传入所需要的参数直接new子领域对象。一般是直接调用，所以它是静态方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;=&amp;gt;这里是lambda表达式的语法糖，表示返回一个创建好的CameraPingDM子领域对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#region Creations
public static CameraPingDM Create(PingDriverContext driverContext, string iP) =&amp;gt; new CameraPingDM(driverContext, iP);
#endregion &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;子领域对象内的修改属性行为&quot;&gt;4.2.3.3 子领域对象内的修改属性行为&lt;/h4&gt;
&lt;p&gt;主要表现为修改属性值等。这里CameraStateUpdate方法更新摄像头网络状态，同时保存更新时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        #region Behaviors
        /// &amp;lt;summary&amp;gt;
        /// 更新摄像头网络状态，同时保存更新时间
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;_cameraState&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public void CameraStateUpdate(CameraState _cameraState)
        {
            cameraState = _cameraState;
            UpdateTime  = DateTime.Now;
        }
        #endregion&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;摄像头的网络驱动ping驱动相关的行为&quot;&gt;4.2.3.4 摄像头的网络驱动——ping驱动相关的行为&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;        #region Behaviors with Ping
        /// &amp;lt;summary&amp;gt;
        /// 表示为ping单个摄像头，检查其网络状态。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; Start()
        {
            if (_driverContext.interval &amp;gt;= 0)
            {
                var interval = Convert.ToInt32(TimeSpan.FromSeconds(_driverContext.interval).TotalMilliseconds);

                _timer = new Timer(state =&amp;gt;
                {
                    lock (_lock)
                    {
                        DoPing();
                    }
                }, null, interval, interval);
            }

            return true;
        }
        /// &amp;lt;summary&amp;gt;
        /// 根据ping对应IP返回的结果来对当前ping成功次数计数，满足要求为online,否则为offline。
        /// &amp;lt;/summary&amp;gt;
        private void DoPing()
        {
            var pingSender = new Ping();
            var options = new PingOptions
            {
                //不分包
                DontFragment = true
            };

            try
            {
                PingReply reply = pingSender.Send(IPAddress.Parse(Ip), _driverContext.timeout, _buffer.ToArray(), options);

                LoggerHelper.Debug($&quot;Ping reply for {Ip} is {reply.Status}&quot;);

                if (reply?.Status == IPStatus.Success)
                {
                    Increment();
                }
                else
                {
                    Decrement();
                }
            }
            catch (Exception)
            {
                LoggerHelper.Debug($&quot;Ping reply for {Ip} failed&quot;);
                Decrement();
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 当前ping成功次数CurrentSuccess减1，CurrentSuccess为非负数
        /// &amp;lt;/summary&amp;gt;
        private void Decrement()
        {
            if (CurrentSuccess &amp;lt;= 0)
            {
                CurrentSuccess = 0;
                CameraStateUpdate(CameraState.Offline);
            }
            else
            {
                CurrentSuccess--;
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 当前ping成功次数CurrentSuccess+1，如果大于等于设置的最小ping成功次数，则更新摄像头的网络状态
        /// &amp;lt;/summary&amp;gt;
        private void Increment()
        {
            if (CurrentSuccess &amp;gt;= _driverContext.minSuccess)
            {
                CameraStateUpdate(CameraState.Online);
            }
            else
            {
                CurrentSuccess++;
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 定时ping定时器关闭
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; Stop()
        {
            _timer?.Dispose();
            return true;
        }
        #endregion&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有方法的作用详见注释，不明白的可以在评论区评论，我会耐心解答，有更好建议的恳请提出。&lt;br/&gt;这里上层聚合CameraPingBus主要调用的就是Start()表示开始ping对应ip的摄像头，根据ping结果刷新摄像头网络状态更新时间；Stop()方法停止ping。这里Timer定时器会在4.3.5中详细介绍，按下不表。&lt;/p&gt;
&lt;h2 id=&quot;聚合camerapingbus&quot;&gt;4.3 聚合CameraPingBus&lt;/h2&gt;
&lt;p&gt;也可称之为CameraPingBus领域，也就是需要我们去解决与摄像头协议交互查看摄像头是否在线的问题域。领域是从需要解决的问题域命名，聚合是从功能角度命名，该类是聚合了许多子领域CameraPingDM，它是去ping 摄像头Camera的行为，返回的是online/offline网络状态值，通过子领域聚合而解决了一整个问题域。&lt;/p&gt;
&lt;h3 id=&quot;属性-1&quot;&gt;4.3.1 属性&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        private Timer _dbTimer;
        ICamera_Services _camera_Services;
        public IList&amp;lt;CameraPingDM&amp;gt; CameraPingDMList = new List&amp;lt;CameraPingDM&amp;gt;();

        ///可以增加name字段，表示驱动名称。
        
        ///写一个IP地址 对应状态变化的方法，将有变化的ADD进差异集合。 如果差异集合不为空，再保存进数据库。

        ///通过winform修改pingDriverContext  3个参数

        //默认参数5/100/0
        static PingDriverContext pingDriverContext = new PingDriverContext()
        {
            interval = 3,
            timeout = 200,
            minSuccess = 0,
        };&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        public CameraPingBus(ICamera_Services camera_Services)
        {
            _camera_Services = camera_Services;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;与camerapingdm所有子领域相关的行为&quot;&gt;4.3.3 与CameraPingDM所有子领域相关的行为&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        #region Behaviors with all the CameraPingDMList
        /// &amp;lt;summary&amp;gt;
        /// 从数据库的数据模型获取所有摄像头的IP地址加载到CameraPingDM对象集合，由Dapper完成数据模
        /// 型的IP到CameraPingDM领域模型IP赋值的转换工作,启动所有CameraPingDM对象集合的ping方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; CreateAndStartAllCameraPing()
        {
            var CameraIpList = await GetCameraIpList();
             try
             {
                foreach (var item in CameraIpList)
                {
                    var cameraPingDM = CameraPingDM.Create(pingDriverContext, item.Ip);
                    await cameraPingDM.Start();
                    CameraPingDMList.Add(cameraPingDM);
                }
           }
           catch  { return false; }
            return true;
        }
        /// &amp;lt;summary&amp;gt;
        /// 停止所有CameraPingDM对象集合的ping方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; StopPing()
        {
            try
            {
                foreach (var item in CameraPingDMList)
                {
                    await item.Stop();
                }
            }
            catch { return false; }
            return true;
        }
        /// &amp;lt;summary&amp;gt;
        /// 异步获取CameraPingDM对象集合元素数量
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;int&amp;gt; CameraIpCount()
        {
            var CameraIpList =  await _camera_Services.GetAllCameraIPAsync();
            return CameraIpList.Count(); 
        }
        #endregion&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所用方法的作用我都做了详细的注释，详见注释。有问题可在评论区提出，我会耐心解答。&lt;/p&gt;
&lt;h3 id=&quot;领域模型字段在数据库中的读写行为&quot;&gt;4.3.4 领域模型字段在数据库中的读写行为&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        #region Behaviors with DataBase
        /// &amp;lt;summary&amp;gt;
        /// 从数据库中加载所有摄像头IP地址到CameraPingDM的IP字段
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;IEnumerable&amp;lt;CameraPingDM&amp;gt;&amp;gt; GetCameraIpList()
        {
            return await _camera_Services.GetAllCameraIPAsync();
        }

        /// &amp;lt;summary&amp;gt;
        /// 将所有Cameara的在线状态根据IP地址匹配定时5秒更新到数据库
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; Save2DbTimerStart()
        {
            _dbTimer = new Timer(state =&amp;gt;
            {
                   _camera_Services.UpdateList(CameraPingDMList);

            }, null, 4000, 4000);
           
            return true;
        }
        /// &amp;lt;summary&amp;gt;
        /// 关闭数据库定时保存定时器
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;bool&amp;gt; Save2DbTimerStop()
        {
            _dbTimer?.Dispose();
            return true;
        }

        #endregion&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所用方法的作用我都做了详细的注释，详见注释。有问题可在评论区提出，我会耐心解答。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里需要注意的是由Dapper完成数据模型的IP到CameraPingDM领域模型IP赋值的转换工作，保存也是由Dapper进行了从领域模型的IP,CameraState到数据模型的无缝对接，碍于篇幅过长，时间也很晚了，感兴趣的请在评论区留言。笔者将根据读者反馈情况看是否有必要另起一篇，写一下基于Dapper进行数据模型与领域模型之间的互相转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定时器timer介绍&quot;&gt;4.3.5 定时器timer介绍&lt;/h3&gt;
&lt;h4 id=&quot;定义一个定时器的引用类&quot;&gt;4.3.5.1 定义一个定时器的引用类&lt;/h4&gt;
&lt;p&gt;用来指向下面的定时器实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Threading;
private Timer _dbTimer;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定时器使用&quot;&gt;4.3.5.2 定时器使用&lt;/h4&gt;
&lt;p&gt;定时器的引用类型指向new Timer()实例，目的是为了去写定时器的关闭方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            _dbTimer = new Timer(state =&amp;gt;
            {
                   _camera_Services.UpdateList(CameraPingDMList);

            }, null, 4000, 4000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定时器有4个参数，F12可得如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //   callback:
        //     A System.Threading.TimerCallback delegate representing a method to be executed.
        //
        //   state:
        //     An object containing information to be used by the callback method, or null.
        //
        //   dueTime:
        //     The amount of time to delay before callback is invoked, in milliseconds. Specify
        //     System.Threading.Timeout.Infinite to prevent the timer from starting. Specify
        //     zero (0) to start the timer immediately.
        //
        //   period:
        //     The time interval between invocations of callback, in milliseconds. Specify System.Threading.Timeout.Infinite
        //     to disable periodic signaling.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;_dbTimer?.Dispose();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;与java的调度器scheduledexecutorservice相比&quot;&gt;4.3.5.4 与Java的调度器ScheduledExecutorService相比&lt;/h4&gt;
&lt;p&gt;熟悉Java的道友有没有发现，C#里的Timer与Java的ScheduledExecutorService很相似，也不知道是谁抄谁，或者是异曲同工之妙吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.ScheduledExecutorService;

private final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(DeviceSetting.MAX_GROUP_ID);

executorService.scheduleWithFixedDelay(() -&amp;gt; {
            try {
                BaseMsg baseMsg = deque.take();
                Thread.sleep(AWAKE_TO_PROCESS_INTERVAL);
                Channel channel = touchChannel(channelId);
                if (channel == null || !channel.isActive()) {
                    logger.warn(&quot;「Channel」&quot; + &quot; Channel「&quot; + channelId + &quot;」无效，无法下发该帧&quot;);
                    removeChannelCompleted(channel);
                    deque.clear();
                    return;
                }

        }, channelId, CommSetting.FRAME_SEND_INTERVAL, TimeUnit.MILLISECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;timers调用库的问题&quot;&gt;4.3.5.5 Timers调用库的问题&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：这里必须要调用System.Threading库里的定时器可以多线程并发执行回调方法，否则的话，将没有此功能，System.Timers定时器使用较为复杂，且无法多线程并发,需要自己写多线程并发的方法，System.Timers定时器只能提供定时功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606616/202002/1606616-20200228233605247-1954772081.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;camerapingbus总线依赖注入&quot;&gt;5.1 CameraPingBus总线依赖注入&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;            //Domain 
            services.AddScoped(typeof(CameraPingBus));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;窗体程序析构法调用&quot;&gt;5.2 窗体程序析构法调用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;        public PingSetting(CameraPingBus cameraPingBus)
        {
            _cameraPingBus = cameraPingBus;
            InitializeComponent();
            LoggerHelper.Debug(&quot;视频在线率配置工具启动&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;camerapingbus使用实例&quot;&gt;5.3 CameraPingBus使用实例&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 按下启动按钮执行操作
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;
        private async void button1_Click(object sender, EventArgs e)
        {
            //IP地址从数据库数据模型赋值到领域模型的IP字段，并且每隔3秒开始ping摄像头，保存其网络状态
            await _cameraPingBus.CreateAndStartAllCameraPing();
            //每隔4s将摄像头网络状态更新到IP地址相等的数据库数据模型中去
            await _cameraPingBus.Save2DbTimerStart();
        }
        /// &amp;lt;summary&amp;gt;
        /// 按下停止按钮执行操作
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;
        private async void button2_Click(object sender, EventArgs e)
        {   
            //停止摄像头定时ping行为
            await _cameraPingBus.StopPing();
            //停止保存摄像头网络状态到数据库
            await _cameraPingBus.Save2DbTimerStop();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各调用方法含义详见注释。&lt;/p&gt;
&lt;h2 id=&quot;基于net-core3.1的winform工具效果图&quot;&gt;5.4 基于net Core3.1的winform工具效果图&lt;/h2&gt;
&lt;p&gt;工具图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606616/202002/1606616-20200228233624663-1365502839.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;驱动&quot;&gt;6.1.驱动&lt;/h2&gt;
&lt;p&gt;驱动即软件接口，ping是驱动，modbus协议库也是驱动，驱动配置（driverContext）分为驱动内配置与驱动外配置。值对象驱动上下文driverContext就是包含了驱动内配置与驱动外配置。&lt;/p&gt;
&lt;h3 id=&quot;驱动内配置举例&quot;&gt;6.1.1驱动内配置举例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var pingSender = new Ping();
 PingReply reply = pingSender.Send(IPAddress.Parse(Ip), _driverContext.timeout, _buffer.ToArray(), options);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;_driverContext.timeout即为ping驱动内配置。&lt;/p&gt;
&lt;h3 id=&quot;驱动外配置举例&quot;&gt;6.1.2驱动外配置举例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;            if (CurrentSuccess &amp;gt;= _driverContext.minSuccess)
            {
                CameraStateUpdate(CameraState.Online);
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;_driverContext.minSuccess即为驱动外配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            if (_driverContext.interval &amp;gt;= 0)
            {
                var interval = Convert.ToInt32(TimeSpan.FromSeconds(_driverContext.interval).TotalMilliseconds);

                _timer = new Timer(state =&amp;gt;
                {
                    lock (_lock)
                    {
                        DoPing();
                    }
                }, null, interval, interval);
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;_driverContext.interval也为驱动外配置。&lt;/p&gt;
&lt;h2 id=&quot;设备&quot;&gt;6.2 设备&lt;/h2&gt;
&lt;p&gt;摄像头即设备，这里驱动跟设备是1对1的关系，驱动是设备的一个被动行为，SC平台通过加载驱动的所需配置（driverContext）来获取对应设备的数据（信号或者说状态）。&lt;/p&gt;
&lt;h2 id=&quot;总线&quot;&gt;6.3 总线&lt;/h2&gt;
&lt;p&gt;总线就像高速公路，他需要有名称，是否关闭，起点，终点，限速（接口参数）。所以这里的IP地址就好比是终点地址，故这里的摄像头IP是属于总线的概念范畴。&lt;br/&gt;具体驱动协议的上一层，一根总线可以对应多个驱动，也可以对应多个设备。&lt;/p&gt;
&lt;h2 id=&quot;类比&quot;&gt;6.4 类比&lt;/h2&gt;
&lt;p&gt;设备上的信号值（网络状态值）相当于是要寄的快递，驱动相当于是运快递的车，保持车间距，按时到达终点，而总线相当于是车开着的高速路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606616/202002/1606616-20200228233643410-1018437791.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析日志记录内容1时刻值&quot;&gt;7.1分析日志记录内容1时刻值&lt;/h2&gt;
&lt;p&gt;得到结果ping行为为并发&lt;/p&gt;
&lt;h2 id=&quot;分析日志记录内容2线程号t&quot;&gt;7.2分析日志记录内容2线程号T&lt;/h2&gt;
&lt;p&gt;得到结果为多线程ping&lt;/p&gt;
&lt;h2 id=&quot;分析日志记录内容3消息&quot;&gt;7.3分析日志记录内容3消息&lt;/h2&gt;
&lt;p&gt;ping成功与超时与实际在线离线IP地址结果相符。&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;摄像头也是一个聚合，摄像头的告警（离线，停电告警），历史告警，摄像头的型号，摄像头的厂商，区域，设备箱，运维公司，运维人员，摄像头驱动，摄像头总线都是摄像头的子领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;driver与driverContext&lt;br/&gt;driver就是Ping驱动。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var pingSender = new Ping();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;驱动上下文driverContext的字段（配置信息）会加载到驱动pingSender上去,去获取所需要的值，即为软件接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PingReply reply = pingSender.Send(IPAddress.Parse(Ip), _timeout, _buffer.ToArray(), options);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;自己对于领域驱动设计的理解并不深刻，但是凭着对设备域，以及协议，总线，驱动的甚微了解，以及看了不少开源项目，不断地学习同行的数据库，硬生生地拼凑成了此文，可能有些概念上或者实现上会有不合适的地方，请路过的高手们不吝赐教。当然如果你有不明白的地方也请提出，我也会耐心解答。&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。欢迎转载、使用、重新发布，但务必保留文章署名JerryMouseLi（包含链接：&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/JerryMouseLi/&lt;/a&gt;），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我联系。&lt;br/&gt;————————————————&lt;br/&gt;版权声明：本文为博客园博主「JerryMouseLi」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/p/12381098.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/JerryMouseLi/p/12381098.html&lt;/a&gt;</description>
<pubDate>Fri, 28 Feb 2020 15:41:00 +0000</pubDate>
<dc:creator>JerryMouseLi</dc:creator>
<og:description>视频在线率统计——基于驱动总线设备的领域驱动设计方法落地 [toc] 1.应用背景 本司智能信息箱产品是管控摄像头电源，监控摄像头视频在线率的一个有效运维工具。因为统计视频在线率是业主十分关心的问题，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JerryMouseLi/p/12381098.html</dc:identifier>
</item>
<item>
<title>Spring源码分析-BeanFactoryPostProcessors 应用之 PropertyPlaceholderConfigurer - yalunwang</title>
<link>http://www.cnblogs.com/yalunwang/p/12380985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yalunwang/p/12380985.html</guid>
<description>&lt;h2 id=&quot;beanfactorypostprocessors&quot;&gt;BeanFactoryPostProcessors&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;BeanFactoryPostProcessors完整定义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Allows for custom modification of an application context's bean definitions,
 * adapting the bean property values of the context's underlying bean factory.
 * @see BeanPostProcessor
 * @see PropertyResourceConfigurer
 */
public interface BeanFactoryPostProcessor {

    /**
     * Modify the application context's internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     * @param beanFactory the bean factory used by the application context
     * @throws org.springframework.beans.BeansException in case of errors
     */
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道spring最大优点就是其可扩展性,BeanFactoryPostProcessor接口就是spring中提供给我们用于扩展的一个地方。我们看该接口上的javadoc其实非常的详细,这也是我们看spring源码的一个技巧，就是看一个类是干嘛的一定要先通读其注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;结合接口上的注释大致描述下BeanFactoryPostProcessor：
允许用户通过修改applicationContext 中的bean定义(就是xml中定义的bean的信息即:BeanDefinition是和xml有一对一的配置，比如是否是单利，以及propert 属性的赋值等)
来调整applicationContext中bean工厂中bean属性值。

也就是说执行到BeanFactoryPostProcessor时全部的BeanDefinition定义已经加载好了但是bean实例还没有被创建,我们可以修补或者覆盖bean属性值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下ApplicationContext中BeanFactoryPostProcessor的调用位置来印证是否如此&lt;/p&gt;
&lt;p&gt;下面是ApplicationContext核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.
            prepareRefresh();

            
            //获取beanFactory实例
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        
            prepareBeanFactory(beanFactory);

            try {
             
                postProcessBeanFactory(beanFactory);

                //这里正是我们的BeanFactoryPostProcessor执行的位置
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                //创建非懒加载的所有单例  这里是真正创建bean实例的地方
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset 'active' flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            prepareBeanFactory(beanFactory);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两步我们已经拿到了beanFactory实例,也就是每一个bean对应的BeanDefinition已经加载好了。下面才是执行invokeBeanFactoryPostProcessors(beanFactory)，也就印证了我们上面的结论。&lt;br/&gt;&lt;strong&gt;下面我们通过一个BeanFactoryPostProcessor的典型应用PropertyPlaceholderConfigurer来详细讲解BeanFactoryPostProcessor执行原理&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;propertyplaceholderconfigurer&quot;&gt;PropertyPlaceholderConfigurer&lt;/h2&gt;
&lt;h3 id=&quot;简单使用的例子&quot;&gt;简单使用的例子&lt;/h3&gt;
&lt;p&gt;PropertyPlaceholderConfigurer相信大家都使用过,我们在配置bean的属性可以使用占位符来赋值，然后通过调整properties文件中对应的属性值来修改。看一个使用PropertyPlaceholderConfigurer简单的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Student {
    
        private String name;
    
        private Integer age;
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public Integer getAge() {
            return age;
        }
    
        public void setAge(Integer age) {
            this.age = age;
        }
    }

    &amp;lt;bean class=&quot;com.yalunwang.Student&quot; id=&quot;student&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;${student.name}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;age&quot; value=&quot;${student.age}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;
        &amp;lt;property name=&quot;location&quot; value=&quot;classpath:bean.properties&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bean.properties配置文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    student.name=anan
    student.age=2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void test_ioc_app(){
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;);

        Student student =(Student) ac.getBean(&quot;student&quot;);

        System.out.println(&quot;name: &quot;+student.getName());
        System.out.println(&quot;age: &quot;+student.getAge());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果一切正常:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name: anan
age: 2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;先看一下PropertyPlaceholderConfigurer的类继承图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/681140/202002/681140-20200228194615681-1128965001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到PropertyPlaceholderConfigurer实现了BeanFactoryPostProcessor和 PriorityOrdered。&lt;/p&gt;
&lt;p&gt;我们接着对上面的 invokeBeanFactoryPostProcessors(beanFactory)继续进行分析:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
     * respecting explicit order if given.
     * 实例化并调用所有已注册的BeanFactoryPostProcessor Bean，
     * 如果继承了Order接口按顺序执行
     * &amp;lt;p&amp;gt;Must be called before singleton instantiation.
     */
    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
        // Invoke BeanDefinitionRegistryPostProcessors first, if any.
        Set&amp;lt;String&amp;gt; processedBeans = new HashSet&amp;lt;String&amp;gt;();
        //如果是beanFactory实现了BeanDefinitionRegistry
        if (beanFactory instanceof BeanDefinitionRegistry) {
            BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
            List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = new LinkedList&amp;lt;BeanFactoryPostProcessor&amp;gt;();
            List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryPostProcessors =
                    new LinkedList&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;();
            //遍历硬编码设置的beanFactory后置处理器          
            for (BeanFactoryPostProcessor postProcessor : getBeanFactoryPostProcessors()) {
                //如果是BeanDefinitionRegistryPostProcessor类型先执行postProcessBeanDefinitionRegistry方法再将其添加到registryPostProcessors集合中进行后续postProcessBeanFactory方法的执行
                if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                    BeanDefinitionRegistryPostProcessor registryPostProcessor =
                            (BeanDefinitionRegistryPostProcessor) postProcessor;
                    registryPostProcessor.postProcessBeanDefinitionRegistry(registry);
                    registryPostProcessors.add(registryPostProcessor);
                }
                else {
                    //同理将正常的beanFactory后置处理器添加到regularPostProcessors集合中进行后续postProcessBeanFactory方法的执行
                    regularPostProcessors.add(postProcessor);
                }
            }
            //找出配置的BeanDefinitionRegistryPostProcessor后置处理器 
            Map&amp;lt;String, BeanDefinitionRegistryPostProcessor&amp;gt; beanMap =
                    beanFactory.getBeansOfType(BeanDefinitionRegistryPostProcessor.class, true, false);
            List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryPostProcessorBeans =
                    new ArrayList&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;(beanMap.values());
            OrderComparator.sort(registryPostProcessorBeans);
            //执行BeanDefinitionRegistryPostProcessor后置处理器的postProcessBeanDefinitionRegistry方法
            for (BeanDefinitionRegistryPostProcessor postProcessor : registryPostProcessorBeans) {
                postProcessor.postProcessBeanDefinitionRegistry(registry);
            }
            //执行上面添加的beanFactory后置处理器的集合里的方法
            invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
            invokeBeanFactoryPostProcessors(registryPostProcessorBeans, beanFactory);
            invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
            //处理后的添加到集合里 防止后面重复执行
            processedBeans.addAll(beanMap.keySet());
        }
        else {
            // Invoke factory processors registered with the context instance.
            invokeBeanFactoryPostProcessors(getBeanFactoryPostProcessors(), beanFactory);
        }

    
        //获取配置的BeanFactoryPostProcessor
        //以下按实现了 PriorityOrdered  Ordered 没有继承 三种进行优先级排序执行 
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
        
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = new ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();
        List&amp;lt;String&amp;gt; orderedPostProcessorNames = new ArrayList&amp;lt;String&amp;gt;();
        List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = new ArrayList&amp;lt;String&amp;gt;();
        for (String ppName : postProcessorNames) {
            //这个就是上面记录的如果已经处理了配置的BeanFactoryPostProcessors就跳过
            if (processedBeans.contains(ppName)) {
                // skip - already processed in first phase above
            }
            else if (isTypeMatch(ppName, PriorityOrdered.class)) {
                priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
            }
            else if (isTypeMatch(ppName, Ordered.class)) {
                orderedPostProcessorNames.add(ppName);
            }
            else {
                nonOrderedPostProcessorNames.add(ppName);
            }
        }

        // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
        OrderComparator.sort(priorityOrderedPostProcessors);
        //上面我们说了PropertyPlaceholderConfigurer 实现了BeanFactoryPostProcessor和 PriorityOrdered,所以会在这一步执行调用
        invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

        // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = new ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();
        for (String postProcessorName : orderedPostProcessorNames) {
            orderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        OrderComparator.sort(orderedPostProcessors);
        invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

        // Finally, invoke all other BeanFactoryPostProcessors.
        List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = new ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();
        for (String postProcessorName : nonOrderedPostProcessorNames) {
            nonOrderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class));
        }
        invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面主要的执行逻辑我都添加了中文注释方便大家理解。&lt;br/&gt;总结一下改方法主要做的事情:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先判断如果beanFactory是BeanDefinitionRegistry类型的话就添加对BeanDefinitionRegistryPostProcessor类型的调用,BeanDefinitionRegistryPostProcessor接口是BeanFactoryPostProcessor的子接口,BeanDefinitionRegistryPostProcessor的作用是方便我们可以手动注册bean交给spring来管理,可以通过扩展其唯一的方法(void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;) 来注册bean到spring里，这个不是本次分析的重点后面再举例讲解。&lt;/li&gt;
&lt;li&gt;先对硬编码配置的BeanFactoryPostProcessor进行处理 如果是BeanDefinitionRegistryPostProcessor类型会进行postProcessBeanDefinitionRegistry调用和postProcessBeanFactory调用,如果不是则只进行postProcessBeanFactory调用。&lt;/li&gt;
&lt;li&gt;再对配置的BeanDefinitionRegistryPostProcessor进行处理(postProcessBeanDefinitionRegistry调用和postProcessBeanFactory调用)&lt;/li&gt;
&lt;li&gt;最后对配置BeanFactoryPostProcessor的进行处理会按 PriorityOrdered/Ordered/没有继承任何排序接口 三种进行优先级排序执行postProcessBeanFactory调用。&lt;strong&gt;其中我们的PropertyPlaceholderConfigurer 实现了BeanFactoryPostProcessor和 PriorityOrdered,所以会在这一步执行调用&lt;br/&gt;invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;** 我们继续进行分析：**&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);&lt;/p&gt;
&lt;p&gt;会执行PropertyPlaceholderConfigurer父类PropertyResourceConfigurer中的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * {@linkplain #mergeProperties Merge}, {@linkplain #convertProperties convert} and
     * {@linkplain #processProperties process} properties against the given bean factory.
     * @throws BeanInitializationException if any properties cannot be loaded
     */
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        try {
            Properties mergedProps = mergeProperties();

            // Convert the merged properties, if necessary.
            convertProperties(mergedProps);

            // Let the subclass process the properties.
            processProperties(beanFactory, mergedProps);
        }
        catch (IOException ex) {
            throw new BeanInitializationException(&quot;Could not load properties&quot;, ex);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mergeProperties()方法会先将 配置的properties加载到mergedProps里&lt;br/&gt;后面调用** processProperties(beanFactory, mergedProps)**;进行处理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;processProperties(beanFactory, mergedProps)分析&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)
            throws BeansException {

        StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(props);

        this.doProcessProperties(beanFactoryToProcess, valueResolver);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只有两行代码,第一行是创建StringValueResolver实例(用于替换占位符的真正方法)&lt;br/&gt;我们跨过千山万水终于要到马上要进行占位符替换了，继续分析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
            StringValueResolver valueResolver) {
       
        
        //将创建的valueResolver设置到BeanDefinitionVisitor里 用于最终替换逻辑 (替换占位符为对应properties里配置的值)
        BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);
        //拿出ioc容器里注册的beans
        String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();
        for (String curName : beanNames) {
            
            //排除掉当前beanName也就是 PropertyPlaceholderConfigurer Bean 且beanFactoryToProcess必须是当前容器
            if (!(curName.equals(this.beanName) &amp;amp;&amp;amp; beanFactoryToProcess.equals(this.beanFactory))) {
                //获取一个bean对应的bean定义
                BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);
                try {
                    //进行bean定义元数据的替换操作
                    visitor.visitBeanDefinition(bd);
                }
                catch (Exception ex) {
                    throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage());
                }
            }
        }

        // New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
        beanFactoryToProcess.resolveAliases(valueResolver);

        // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
        beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我已经使用中文注释写的很清楚了接着进行分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;visitor.visitBeanDefinition(bd);&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public void visitBeanDefinition(BeanDefinition beanDefinition) {
        visitParentName(beanDefinition);
        visitBeanClassName(beanDefinition);
        visitFactoryBeanName(beanDefinition);
        visitFactoryMethodName(beanDefinition);
        visitScope(beanDefinition);
        visitPropertyValues(beanDefinition.getPropertyValues());
        ConstructorArgumentValues cas = beanDefinition.getConstructorArgumentValues();
        visitIndexedArgumentValues(cas.getIndexedArgumentValues());
        visitGenericArgumentValues(cas.getGenericArgumentValues());
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以对应 bean的parentName beanClassName property等进行替换操作我们这里只关注属性的替换操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;visitPropertyValues(beanDefinition.getPropertyValues());&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;protected void visitPropertyValues(MutablePropertyValues pvs) {
        PropertyValue[] pvArray = pvs.getPropertyValues();
        for (PropertyValue pv : pvArray) {
            Object newVal = resolveValue(pv.getValue());
            if (!ObjectUtils.nullSafeEquals(newVal, pv.getValue())) {
                pvs.add(pv.getName(), newVal);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Object newVal = resolveValue(pv.getValue());&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@SuppressWarnings(&quot;rawtypes&quot;)
    protected Object resolveValue(Object value) {
        if (value instanceof BeanDefinition) {
            visitBeanDefinition((BeanDefinition) value);
        }
        else if (value instanceof BeanDefinitionHolder) {
            visitBeanDefinition(((BeanDefinitionHolder) value).getBeanDefinition());
        }
        else if (value instanceof RuntimeBeanReference) {
            RuntimeBeanReference ref = (RuntimeBeanReference) value;
            String newBeanName = resolveStringValue(ref.getBeanName());
            if (!newBeanName.equals(ref.getBeanName())) {
                return new RuntimeBeanReference(newBeanName);
            }
        }
        else if (value instanceof RuntimeBeanNameReference) {
            RuntimeBeanNameReference ref = (RuntimeBeanNameReference) value;
            String newBeanName = resolveStringValue(ref.getBeanName());
            if (!newBeanName.equals(ref.getBeanName())) {
                return new RuntimeBeanNameReference(newBeanName);
            }
        }
        else if (value instanceof Object[]) {
            visitArray((Object[]) value);
        }
        else if (value instanceof List) {
            visitList((List) value);
        }
        else if (value instanceof Set) {
            visitSet((Set) value);
        }
        else if (value instanceof Map) {
            visitMap((Map) value);
        }
        else if (value instanceof TypedStringValue) {
            TypedStringValue typedStringValue = (TypedStringValue) value;
            String stringValue = typedStringValue.getValue();
            if (stringValue != null) {
                String visitedString = resolveStringValue(stringValue);
                typedStringValue.setValue(visitedString);
            }
        }
        else if (value instanceof String) {
            return resolveStringValue((String) value);
        }
        return value;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有很多类型,是因为spring支持很多类型的配置比如property的值我们可以配置为ref=xxxbean那么value就是RuntimeBeanReference类型,&lt;br/&gt;如果配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;             &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;343&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;45&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么value就是List类型等等。这里我们例子中配置的类型是TypedStringValue，那么执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    else if (value instanceof TypedStringValue) {
            TypedStringValue typedStringValue = (TypedStringValue) value;
            //这里拿到的值是原始的带有占位符的比如例子里就是${student.name}、${student.age}这种
            String stringValue = typedStringValue.getValue();
            if (stringValue != null) {
                //这一步就是去进行替换
                String visitedString = resolveStringValue(stringValue);
                typedStringValue.setValue(visitedString);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;String visitedString = resolveStringValue(stringValue);&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
     * Resolve the given String value, for example parsing placeholders.
     * @param strVal the original String value
     * @return the resolved String value
     */
    protected String resolveStringValue(String strVal) {
        if (this.valueResolver == null) {
            throw new IllegalStateException(&quot;No StringValueResolver specified - pass a resolver &quot; +
                    &quot;object into the constructor or override the 'resolveStringValue' method&quot;);
        }
        //调用我们之前传进来的valueResolver也就是上面 (BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver); 这里传进来的) 进行替换操作
        String resolvedValue = this.valueResolver.resolveStringValue(strVal);
        // Return original String if not modified.
        return (strVal.equals(resolvedValue) ? strVal : resolvedValue);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;valueResolver其实就是PlaceholderResolvingStringValueResolver实例,它又委托PropertyPlaceholderHelper进行操作&lt;/p&gt;
&lt;p&gt;也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * Replaces all placeholders of format {@code ${name}} with the value returned
     * from the supplied {@link PlaceholderResolver}.
     * @param value the value containing the placeholders to be replaced.
     * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement.
     * @return the supplied value with placeholders replaced inline.
     */
    public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
        Assert.notNull(value, &quot;Argument 'value' must not be null.&quot;);
        return parseStringValue(value, placeholderResolver, new HashSet&amp;lt;String&amp;gt;());
    }

    protected String parseStringValue(
            String strVal, PlaceholderResolver placeholderResolver, Set&amp;lt;String&amp;gt; visitedPlaceholders) {

        StringBuilder buf = new StringBuilder(strVal);

        int startIndex = strVal.indexOf(this.placeholderPrefix);
        while (startIndex != -1) {
            int endIndex = findPlaceholderEndIndex(buf, startIndex);
            if (endIndex != -1) {
                //将ex. ${student.name} 转成 student.name
                String placeholder = buf.substring(startIndex + this.placeholderPrefix.length(), endIndex);
                String originalPlaceholder = placeholder;
                if (!visitedPlaceholders.add(originalPlaceholder)) {
                    throw new IllegalArgumentException(
                            &quot;Circular placeholder reference '&quot; + originalPlaceholder + &quot;' in property definitions&quot;);
                }
                // 递归调用直到没有占位符
                placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);
                // 获取properties配置文件对应的值  就是获取student.name 对应在 properties里的值
                String propVal = placeholderResolver.resolvePlaceholder(placeholder);
                if (propVal == null &amp;amp;&amp;amp; this.valueSeparator != null) {
                    int separatorIndex = placeholder.indexOf(this.valueSeparator);
                    if (separatorIndex != -1) {
                        String actualPlaceholder = placeholder.substring(0, separatorIndex);
                        String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());
                        propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);
                        if (propVal == null) {
                            propVal = defaultValue;
                        }
                    }
                }
                if (propVal != null) {
                    //再次递归调用 确保最后的值没有占位符
                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);
                    //将原先的StringBuff的原始值替换为拿到的值
                    buf.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Resolved placeholder '&quot; + placeholder + &quot;'&quot;);
                    }
                    //这里因为已经替换成真正的值 拿不到占位符(${)所以值就是-1 会跳出循环返回
                    startIndex = buf.indexOf(this.placeholderPrefix, startIndex + propVal.length());
                }
                else if (this.ignoreUnresolvablePlaceholders) {
                    // Proceed with unprocessed value.
                    startIndex = buf.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());
                }
                else {
                    throw new IllegalArgumentException(&quot;Could not resolve placeholder '&quot; +
                            placeholder + &quot;'&quot; + &quot; in string value \&quot;&quot; + strVal + &quot;\&quot;&quot;);
                }
                visitedPlaceholders.remove(originalPlaceholder);
            }
            else {
                startIndex = -1;
            }
        }

        return buf.toString();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法是真正替换的操作所在,改方法已经添加中文注释应该很好理解了，总结就是做了一下两件事:&lt;br/&gt;1.首先会将ex. ${student.name} 转成 student.name&lt;br/&gt;2.将student.name通过 tring propVal = placeholderResolver.resolvePlaceholder(placeholder);获取真正的值然后返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected String resolvePlaceholder(String placeholder, Properties props, int systemPropertiesMode) {
        String propVal = null;
        if (systemPropertiesMode == SYSTEM_PROPERTIES_MODE_OVERRIDE) {
            propVal = resolveSystemProperty(placeholder);
        }
        if (propVal == null) {
            propVal = resolvePlaceholder(placeholder, props);
        }
        if (propVal == null &amp;amp;&amp;amp; systemPropertiesMode == SYSTEM_PROPERTIES_MODE_FALLBACK) {
            propVal = resolveSystemProperty(placeholder);
        }
        return propVal;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法就比较简单了就是根据不同的模式做处理,systemPropertiesMode默认是SYSTEM_PROPERTIES_MODE_FALLBACK&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果systemPropertiesMode = SYSTEM_PROPERTIES_MODE_OVERRIDE 是指 系统配置文件优先级大于我们的配置文件。&lt;/li&gt;
&lt;li&gt;拿不到或者配置不等于SYSTEM_PROPERTIES_MODE_OVERRIDE 就去我们配置文件里进行获取&lt;/li&gt;
&lt;li&gt;如果还获取不到且如果systemPropertiesMode=SYSTEM_PROPERTIES_MODE_FALLBACK就再尝试去系统文件里查找。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;经过以上各个步骤最终BeanDefinition里的parentName beanClassName property中的占位符都会被我们propertis配置文件中对应的值所替换掉，这就为后续实例化bean后做bean实例属性填充时做好了准备。&lt;br/&gt;我们再进行 Student student =(Student) ac.getBean(&quot;student&quot;); 时就可以正常打印对应的值了。&lt;/p&gt;
&lt;h2 id=&quot;看源码的一点分享tip&quot;&gt;看源码的一点分享tip&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;看源码可能会比较枯燥,坚持很重要,如果看一遍是懵的那就是歇一歇再继续多看几遍这样慢慢就会找到感觉&lt;/li&gt;
&lt;li&gt;看的过程中一定要写例子进行调试,然后再继续反复看慢慢就会明白其中的含义&lt;/li&gt;
&lt;li&gt;看源码可以看某一个核心类的继承图,以及javadoc。还可以尝试画出核心的时序图，这些都能对我们看懂源码起到事半功倍的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此本篇源码分析就结束了,后续继续spring源码分析的文章。加油！！！&lt;/p&gt;
</description>
<pubDate>Fri, 28 Feb 2020 15:12:00 +0000</pubDate>
<dc:creator>yalunwang</dc:creator>
<og:description>BeanFactoryPostProcessors 介绍 BeanFactoryPostProcessors完整定义: 我们知道spring最大优点就是其可扩展性,BeanFactoryPostPro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yalunwang/p/12380985.html</dc:identifier>
</item>
<item>
<title>Docker实战之MySQL主从复制 - 当我遇上你csy</title>
<link>http://www.cnblogs.com/idea360/p/12380991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idea360/p/12380991.html</guid>
<description>&lt;p&gt;曾几何时，看着高大上的架构和各位前辈高超的炫技，有没有怦然心动，也想一窥究竟？每当面试的时候，拿着单应用的架构，吹着分库分表的牛X，有没有心里慌的一批？&lt;/p&gt;
&lt;p&gt;其实很多时候，我们所缺少的只是对高大上的技术的演练。没有相关的业务需求，没有集群环境，然后便只是Google几篇博文，看下原理，便算是了解了。然而真的明白了吗？众多的复制粘贴中，那篇文章才对我们有用，哪些又是以讹传讹？&lt;/p&gt;
&lt;p&gt;所幸容器技术的快速发展，让各种技术的模拟成为现实。接下来Docker相关的一系列文章，将以实战为主，帮助大家快速搭建测试和演练环境。&lt;/p&gt;

&lt;p&gt;由于是测试为了演练用，这里用docker-compose进行配置文件的编排，实际的集群环境中并不是这么部署的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编排docker-compose-mysql-cluster.yml,安装master和slave节点&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: '3'
services:
  mysql-master:
    image: mysql:5.7
    container_name: mysql-master
    environment:
      - MYSQL_ROOT_PASSWORD=root
    ports:
      - &quot;3307:3306&quot;
    volumes:
      - &quot;./mysql/master/my.cnf:/etc/my.cnf&quot;
      - &quot;./mysql/master/data:/var/lib/mysql&quot;
    links:
      - mysql-slave

  mysql-slave:
    image: mysql:5.7
    container_name: mysql-slave
    environment:
      - MYSQL_ROOT_PASSWORD=root
    ports:
      - &quot;3308:3306&quot;
    volumes:
      - &quot;./mysql/slave/my.cnf:/etc/my.cnf&quot;
      - &quot;./mysql/slave/data:/var/lib/mysql&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置master配置文件my.cnf&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[mysqld]
# [必须]启用二进制日志
log-bin=mysql-bin 
# [必须]服务器唯一ID，默认是1，一般取IP最后一段  
server-id=1
## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）
binlog-ignore-db=mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置slave配置文件my.cnf&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[mysqld]
# [必须]服务器唯一ID，默认是1，一般取IP最后一段  
server-id=2&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动docker-compose，创建docker镜像文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;docker&quot;&gt;
&lt;code&gt;docker-compose -f docker-compose-mysql-cluster.yml up -d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt;查看进程，可以看到2个实例已启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
1f4ad96b4d5e        mysql:5.7           &quot;docker-entrypoint.s…&quot;   48 seconds ago      Up 46 seconds       33060/tcp, 0.0.0.0:3307-&amp;gt;3306/tcp   mysql-master
8e2214aacc43        mysql:5.7           &quot;docker-entrypoint.s…&quot;   49 seconds ago      Up 47 seconds       33060/tcp, 0.0.0.0:3308-&amp;gt;3306/tcp   mysql-slave&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;配置master&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230816022-1499933919.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置slave&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230819366-1231847837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候就可以运行一些 SQL 语句来验证同步服务是否正常了。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;master创建db&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230820312-445546806.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看slave是否同步创建&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230821358-1485832828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由结果可知，已完成MySQL主从复制环境的搭建。&lt;/p&gt;

&lt;p&gt;MySQL主从复制是其自己的功能，实现读写分离就得依靠其他组件了，比如&lt;code&gt;sharding-jdbc&lt;/code&gt;。但是&lt;code&gt;sharding-jdbc&lt;/code&gt;只是实现读写分离，本身的权限控制还是需要MySQL这边来配置的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置master账户及权限&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建帐号并授予读写权限&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE USER 'master'@'%' IDENTIFIED BY 'Password123';
GRANT select,insert,update,delete ON *.* TO 'master'@'%';
flush privileges;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230823465-1948269610.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置slave账户及权限&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建帐号并授予只读权限&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;use mysql;
CREATE USER 'slave'@'%' IDENTIFIED BY 'Password123';
GRANT select ON *.* TO 'slave'@'%';
FLUSH PRIVILEGES;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230826163-1368264431.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这篇文章以搭建环境为主，后续会继续完善故障转移、分库分表、数据平滑迁移等相关演练。菜鸟博客，不尽完善，希望大家不吝赐教。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;公众号 【当我遇上你】&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683301/202002/1683301-20200228230827619-485126595.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 28 Feb 2020 15:08:00 +0000</pubDate>
<dc:creator>当我遇上你csy</dc:creator>
<og:description>前言 曾几何时，看着高大上的架构和各位前辈高超的炫技，有没有怦然心动，也想一窥究竟？每当面试的时候，拿着单应用的架构，吹着分库分表的牛X，有没有心里慌的一批？ 其实很多时候，我们所缺少的只是对高大上的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/idea360/p/12380991.html</dc:identifier>
</item>
</channel>
</rss>