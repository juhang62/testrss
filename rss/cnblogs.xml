<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>意识科学初步：David Chalmers的简单问题与困难问题 - 毛利小九郎</title>
<link>http://www.cnblogs.com/morikokyuro/p/10335713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morikokyuro/p/10335713.html</guid>
<description>&lt;p&gt;这是第一篇关于意识科学的内容。主要谈一下阅读大卫查莫斯的几篇论文的一些观点和思考。&lt;/p&gt;
&lt;p&gt;论文作者简介（摘自wiki）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;David John Chalmers&lt;/strong&gt; (&lt;span class=&quot;nowrap&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517558/201901/1517558-20190130225829182-171317834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人主页：http://consc.net/&lt;/p&gt;

&lt;p&gt;意识作为一个和人类生存息息相关的问题古已有之，但是一直只是哲学讨论的对象。而近代以来，随着神经科学和脑科学，包括心理学和认知科学等领域的发展，人们开始逐渐将意识的机理的研究纳入到科学的范畴之中来。但是，Chalmers认为，现在的认知科学与神经科学所研究的问题，和我们真正关心的&lt;strong&gt;意识问题&lt;/strong&gt;其实并没有太大的联系。Chalmers在这些文章中的的主要任务是，先为意识科学的研究者们划清研究的界限，即哪些问题是意识科学本身应该重点关注的，而哪些研究对于最根本的意识问题没有太大助益。下面简单介绍一下Chalmers的一些基本论点。&lt;/p&gt;
&lt;p&gt;他的第一个论点就是区分&lt;strong&gt;困难问题&lt;/strong&gt;和&lt;strong&gt;简单问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;简单问题（the easy problem）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如，我们的人类主体是如何判别感官刺激并且对此做出反应？我们的大脑是如何整合信息，并且控制行为的？主体是如何通过语言表达它的内在状态的？&lt;/p&gt;
&lt;p&gt;这些问题在chalmers看来，属于简单问题。这里的简单是相对的，只是为了和真正困难的意识问题区分开。这些问题的共同点在于，它们关心的是mechanism of cognitive system，也就是认知系统的机制，或者简单来说，就是机械性的那些原理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;困难问题（the hard problem）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而困难问题则不一样。困难问题说的是：为什么我们的大脑的反应的这些物理的过程，也就是前面说的那些种过程，总会产生或者说伴随着一个意识主体的&lt;strong&gt;意识体验（conscious experience，subjective experience，在后面一般直接就写成experience了）。&lt;/strong&gt;这是我们最关心的意识问题中的重点，而 chalmers认为现在的人做的工作还没有真正触及这个问题。&lt;/p&gt;
&lt;p&gt;也就是说，我们更关注&lt;strong&gt;体验&lt;/strong&gt;这种主观的意识现象，而不是认知机制等等。chalmers认为，简单问题通过神经生物学，脑科学，心理学等等这些学科的发展总能够得到解决，也就是研究方式是正确的，最终结果只是时间问题。而困难问题则不一样，人们还没有进入这个领域，因此也没有一个统一的理论框架，或者研究范式。chalmers的目的就是为困难问题设定一个可能的理论框架。&lt;/p&gt;
&lt;p&gt;为了说明困难问题，我们可以举几个栗子：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;玛丽黑白屋问题（isolated neuroscientist in a black-and-white room）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个问题是由澳大利亚的哲学家 &lt;strong&gt;Frank Jackson&lt;/strong&gt; 提出来的，实际上是一个思想实验。imagine 在23世纪又一个神经科学家Mary， 玛丽是世界上一流的脑科学专家，她非常了解大脑对于颜色视觉的处理机制。但是，玛丽一生都生活在一个黑白屋里，在这里她从来没有看到过任何除了黑白以外的颜色。那么我们可以说，玛丽知道很多关于颜色视觉的知识，比方说，我们的视觉系统如何接收刺激，如何传递信息，整合信息，大脑如何处理，如何做出反应，以及不同颜色在频谱中各自占据哪些范围等等。但是我们说，玛丽的知识中仍然有一个重要的缺陷，也就是，她不知道什么是&lt;strong&gt;红色的体验&lt;/strong&gt;（experience of red）。她可以说，红色是多少纳米的波长范围，红色被视觉系统中的视锥细胞的哪些物理过程所捕获，然后通过哪些神经传到大脑进行处理，最终让我们判断它是红色，等等。但是她没有对于红色的体验。打个比方，这一点就像我们现在的正常人对于红外光的感受，我们知道它是怎么一回事，但是我们仍然无法体验到红外光，或者另一个例子，我们可以讨论高维空间为何物，里面的距离如何计算，里面的几何体有什么性质，物理现象遵从什么规律，等等。但是我们无法想象出高维空间，就像这个没见过红色的神经科学家没法体验到红色一样。&lt;/p&gt;
&lt;p&gt;这个思想实验其实就是将困难问题和简单问题剥离开，玛丽缺少的那部分知识，就是我们需要在困难问题中解决的。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1517558/201901/1517558-20190130225927282-685388642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释鸿沟（explanatory gap）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个概念由Joseph Levine提出。 指的是物理过程和意识之间的巨大差异。简言之，chalmers认为，现有的物理的理论无法解释的一个重要的意识问题是：为什么物理过程必须要伴随着意识？ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题是很重要的，因为我们知道，如果一个人，按照生物物理学的或者生物化学的机械形式，是可以完全完成从【接受刺激-进行处理-做出反应】这个过程的，这样看起来意识似乎是可有可无的。因为一个automaton，机器人，或者称为自动机，就可以完成很多人所能完成的内容。那么为何这样的过程还有给主体投射一个体验或者说印象呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物理的方式其实更多的是机械论的方式，是将过程解释成具体的process，但是意识是不能被这样解释出来的，这就是物理理论对于意识的解释鸿沟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，如果意识科学要是可能的话，那么必有又一种新的理论来解决。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Dancing Qualia in a Synthetic Brain&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;systems with the same organization will embody the same information。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这个是一个假设，这个假设可以通过一个思想实验来证明，也就是所谓的dancing qualia。 qualia指的是感受质。这个思想实验如图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1517558/201901/1517558-20190130230002065-493726593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对上面的解释简单介绍一下。作者是如何证明相同的结构的系统会有相同的意识体验呢？这里作者采用反证法（归谬法），先假设如果不成立，也就是说，相同结构的不同系统具有不同的意识体验。那么，我们设想一个硅基系统，里面的芯片都是按照大脑中神经元的组织结构和功能做成的，那么，我们将大脑中的某个区域的神经元换成硅基系统中的一些同等结构的芯片，也就是说，比如我们用芯片替代了我们的视觉皮层（visual cortex），那么我们仍然能够视觉，但是，按照假设，我们的原先的体验和改变后的意识体验应当是不同的，比如对于红色，本来我们的体验是红色，现在变成了紫色的体验。那么，如果我们有一个开关，这个开关可以控制我们用芯片的大脑还是原本的大脑，那么，由于我们的意识体验不同，那么我们的qualia就会dancing between两种不同的意识体验。然而，又因为我们的脑组织结构没有改变，那么我们的判断是不变的，也就是说，即使两种颜色在眼前dancing，我们仍然会认为无事发生，没有任何改变。这个是不合理的。这也就说明我们的假设不合理，通过反证法得到结论。&lt;/p&gt;
&lt;p&gt;可能这个说明还是不够具体，我们进一步来说明。假设我很喜欢红色，那么当开关在两种意识体验（红色和紫色）之间来回交替的时候，我仍然会对别人说，这个就是我喜欢的颜色，并且是没有变化的。但是我们假设了意识体验是不同的，但是我们却对它产生了同样的领悟和理解，以及处理方式，那么这种现象就不合理。或者说，抛开归谬法，我们想象，如果这个东西对我们来说意味着完全一样的东西，那么他们对我们来说，没有理由不认为它门对我们有着相同的意识体验。这个思想实验的关键在于，把【相同还是不同】这个比较难解的问题转化成了【变化还是不变】这样一个更加直观和易于判别的问题，并从中得出结论。&lt;/p&gt;

&lt;p&gt;这是我们介绍的两个思想实验。以及一些概念。最重要的是困难问题的理解。在之后我们再整理chalmers的其他文章，他在有些文章里对现有的意识研究的模型和路线提出了一些质疑，并表示他们都是在解决简单问题。并且给出了如果要解决困难问题的话，需要遵循的一些原则。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;Chalmers D J . The puzzle of conscious experience.[J]. Scientific American, 1995, 273(6):80.&lt;/p&gt;


</description>
<pubDate>Wed, 30 Jan 2019 15:19:00 +0000</pubDate>
<dc:creator>毛利小九郎</dc:creator>
<og:description>意识作为一个和人类生存息息相关的问题古已有之，但是一直只是哲学讨论的对象。而近代以来，随着神经科学和脑科学，包括心理学和认知科学等领域的发展，人们开始逐渐将意识的机理的研究纳入到科学的范畴之中来。但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morikokyuro/p/10335713.html</dc:identifier>
</item>
<item>
<title>使用Kazoo操作ZooKeeper服务治理 - Harvard_Fly</title>
<link>http://www.cnblogs.com/FG123/p/10261682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FG123/p/10261682.html</guid>
<description>&lt;p&gt;&lt;span&gt;单机服务的可靠性及可扩展性有限，某台服务宕机可能会影响整个系统的正常使用；分布式服务能够有效地解决这一问题，但同时分布式服务也会带来一些新的问题，如：服务发现(新增或者删除了服务如何确保能让客户端知道)，容灾(某些服务出现故障如何让客户端只访问正常的服务)；ZooKeeper的提出主要是为了解决分布式服务的治理问题，它在分布式环境中协调和管理服务。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zookeeper协调管理服务的过程如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201901/739231-20190123095338887-1408365925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;服务端：每台服务器都要向注册中心Zookeeper进行注册登记，并且保持与Zookeeper的连接，如果服务器与Zookeeper断开了连接，Zookeeper将删除该服务器的地址。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;客户端：需要服务的时候先向Zookeeper订阅服务器的地址信息，Zookeeper返回给客户端已注册的服务器信息列表，客户端从服务器信息列表中选择服务器进行服务调用，如果Zookeeper记录的服务器信息发生了变更，服务器会通知客户端变更事件，客户端可以获取最新的服务器信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ZooKeeper文件系统的数据结构是个树状结构，它的每个节点(znode)由一个名称标识，并用路径/分割：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201901/739231-20190129202950561-1373842958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; ZooKeeper的节点类型有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1. 持久节点(ZooKeeper默认的节点类型，创建该节点的客户端断开连接后，持久节点仍然存在)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2. 顺序节点(将10位的序列号附加到原始名称来设置节点的路径，如：/server0000000001)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3. 临时节点(当客户端与ZooKeeper断开连接时，临时节点会自动删除)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;RPC服务注册到ZooKeeper&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务端：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KazooClient
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; divide_rpc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ServerStub
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; divide_rpc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; InvalidOperation
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadServer(object):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, port, handlers):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.sock =&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.host =&lt;span&gt; host
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.port =&lt;span&gt; port
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        self.sock.bind((host, port))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         self.handlers =&lt;span&gt; handlers
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; serve(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        开始服务
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         self.sock.listen(128&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        self.register_zk()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始监听&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             conn, addr =&lt;span&gt; self.sock.accept()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建立链接%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; str(addr))
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             t = threading.Thread(target=self.handle, args=&lt;span&gt;(conn,))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            t.start()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self, client):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         stub =&lt;span&gt; ServerStub(client, self.handlers)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                stub.process()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; EOFError:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端关闭连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        client.close()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; register_zk(self):
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        注册到zookeeper
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         self.zk = KazooClient(hosts=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1:2181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        self.zk.start()
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         self.zk.ensure_path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/rpc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建根节点&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         value = json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: self.host, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: self.port})
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建服务子节点&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;         self.zk.create(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/rpc/server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, value.encode(), ephemeral=True, sequence=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Handlers:
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; divide(num1, num2=1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        除法
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        :param num1:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        :param num2:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        :return:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; num2 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; InvalidOperation()
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         val = num1 /&lt;span&gt; num2
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; val
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(sys.argv) &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usage:python server.py [host] [port]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         exit(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     host = sys.argv[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     port = sys.argv[2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     server =&lt;span&gt; ThreadServer(host, int(port), Handlers)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     server.serve()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务端通过kazoo连接zookeeper，依次创建根节点和服务的子节点，当启动多线程服务器的时候，会根据ip和端口创建不同的节点，依次启动两个server(8001、8002)，查看zookeeper的节点信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KazooClient
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; zk = KazooClient(hosts=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1:2181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; zk.start() 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; children = zk.get_children(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/rpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(children)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server0000000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;server0000000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;客户端：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; divide_rpc &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ClientStub, InvalidOperation
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; kazoo.client &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KazooClient
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DistributedChannel(object):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self._zk = KazooClient(hosts=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1:2181&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        self._zk.start()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        self._get_servers()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; _get_servers(self, event=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        从zookeeper获取服务器地址信息列表
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         servers = self._zk.get_children(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/rpc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, watch=&lt;span&gt;self._get_servers)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(servers)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         self._servers =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; server &lt;span&gt;in&lt;/span&gt;&lt;span&gt; servers:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             data = self._zk.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/rpc/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; server)[0]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 addr =&lt;span&gt; json.loads(data.decode())
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                self._servers.append(addr)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _get_server(self):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        随机选出一个可用的服务器
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; random.choice(self._servers)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_connection(self):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        提供一个可用的tcp连接
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             server =&lt;span&gt; self._get_server()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(server)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 sock =&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 sock.connect((server[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], server[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionRefusedError:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sock
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; channel =&lt;span&gt; DistributedChannel()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(50&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         stub =&lt;span&gt; ClientStub(channel)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         val =&lt;span&gt; stub.divide(i)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; InvalidOperation as e:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.message)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(val)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     time.sleep(1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;客户端连接zookeeper，通过get_children来获取服务器信息，并watch监听服务器的变化情况，启动客户端会发现它会调用8001端口的server和8002端口的server：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201901/739231-20190130225706063-2097430521.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时服务端新增加一个结点，8003，客户端变化情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201901/739231-20190130230024050-57962967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出zookeeper总共有三个节点了，前面调用的server都是8001和8002,当8003加入后，zookeeper会发现并调用它&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时服务端断开一个server，8001，客户端变化情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201901/739231-20190130230408534-789067832.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;断开server前客户端会调用8001、8002、8003这三个服务，当断开server 8001以后，zookeeper只会调用8002和8003这两个server了&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 15:09:00 +0000</pubDate>
<dc:creator>Harvard_Fly</dc:creator>
<og:description>单机服务的可靠性及可扩展性有限，某台服务宕机可能会影响整个系统的正常使用；分布式服务能够有效地解决这一问题，但同时分布式服务也会带来一些新的问题，如：服务发现(新增或者删除了服务如何确保能让客户端知道</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FG123/p/10261682.html</dc:identifier>
</item>
<item>
<title>Windows-删除Windows Server backup卷影副本 - Wenzhongxiang</title>
<link>http://www.cnblogs.com/wenzhongxiang/p/10340173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenzhongxiang/p/10340173.html</guid>
<description>&lt;p&gt;现有环境中有一台Windows Server做过定期备份计划，时间太久未做清理操作，收到磁盘报警邮件后需要及时释放该空间，具体操作步骤如下：&lt;/p&gt;
&lt;p&gt;当前备份计划信息如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230555041-252858939.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;444&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230555723-1911764410.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清理步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.以管理身份运行CMD或者Powershell:&lt;/p&gt;
&lt;p&gt;2.在命令行模式下输入：diskshadow 进入diskshadow 模式&lt;/p&gt;
&lt;p&gt;DiskShadow.exe是一种公开卷影复制服务（VSS）提供的功能的工具。默认情况下，DiskShadow使用类似于DiskRAID或DiskPart的交互式命令解释器。DiskShadow还包括可编写脚本的模式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230556182-17497502.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;94&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230556622-259685255.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关diskshadow命令行的具体帮助信息如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230557232-1223395034.png&quot;&gt;&lt;img width=&quot;638&quot; height=&quot;728&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230557861-1341726369.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.列出当前所有备份卷信息：List shadows all&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230558282-872304562.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;385&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230558801-1837961395.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230559163-1844590794.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;193&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230559605-1390063228.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.删除目标路径下旧的备份，或删除指定ID卷影副本：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
delete shadows oldest \\?\Volume{df31d105-2303-11e6-b55e-6c92bf0e506c}\
delete shadows ID {10860cfa-be0d-4b80-a1c4-b12b4ecec5c1}
&lt;/pre&gt;
&lt;p&gt;DELETE SHADOWS { ALL | VOLUME &amp;lt;volume&amp;gt; | OLDEST &amp;lt;volume&amp;gt; | SET &amp;lt;setID&amp;gt; | ID &amp;lt;shadowID&amp;gt; | EXPOSED &amp;lt;drive letter, mountPoint or share&amp;gt; }&lt;/p&gt;
&lt;p&gt;删除持久和非持久的卷影副本&lt;/p&gt;
&lt;p&gt;ALL 所有卷影副本。&lt;/p&gt;
&lt;p&gt;VOLUME &amp;lt;volume&amp;gt; 删除给定卷的所有卷影副本。&lt;/p&gt;
&lt;p&gt;OLDEST &amp;lt;volume&amp;gt;   删除给定卷的最旧卷影副本。&lt;/p&gt;
&lt;p&gt;SET &amp;lt;setID&amp;gt; 删除由 setId 参数指定的卷影副本集中的卷影副本。&lt;/p&gt;
&lt;p&gt;ID &amp;lt;shadowID&amp;gt; 删除由 shadowId 参数指定的卷影副本。&lt;/p&gt;
&lt;p&gt;EXPOSED &amp;lt;exposeName&amp;gt; 删除在指定的驱动器号、装入点或共享暴露的卷影副&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;DELETE SHADOWS ALL&lt;/p&gt;
&lt;p&gt;DELETE SHADOWS EXPOSED p:&lt;/p&gt;
&lt;p&gt;DELETE SHADOWS EXPOSED ShareName&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230600168-468827723.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;149&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230600645-1402947255.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;删除所有卷影副本：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
delete shadows all
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230601356-2105830343.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;127&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230601992-1795731203.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.再次查询当前所有备份卷信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230602561-52319406.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;133&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230603285-1816576840.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.或者我们可以只保留最近3个副本：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
wbadmin delete systemstatebackup -keepVersions:3
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230603912-1534677852.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;170&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230604611-993947230.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230605282-1176059043.png&quot;&gt;&lt;img width=&quot;640&quot; height=&quot;53&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1328979/201901/1328979-20190130230606061-1122670169.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 15:06:00 +0000</pubDate>
<dc:creator>Wenzhongxiang</dc:creator>
<og:description>现有环境中有一台Windows Server做过定期备份计划，时间太久未做清理操作，收到磁盘报警邮件后需要及时释放该空间，具体操作步骤如下：当前备份计划信息如下：清理步骤如下：1.以管理身份运行CMD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenzhongxiang/p/10340173.html</dc:identifier>
</item>
<item>
<title>程序员如何科学地记日志 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10339952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10339952.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;69&quot;&gt;
&lt;p&gt;无论是哪种程序员，日常开发中都离不开记日志。但是通过最近的review会，发现很多程序员在记日志的时候，还是会有些问题。那么如何科学地记录日志呢？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;为什么要记日志&lt;/h2&gt;
&lt;p&gt;在寻求方法前，我们先看看我们记日志的目标。&lt;br/&gt;日志是程序运行时的x光，能够追踪到程序运行的状态，通过日志，程序员能够加速调试速度，还原异常情况出现的场景。&lt;br/&gt;也有通过日志记录处理数据，方便后面统计和审计。&lt;br/&gt;还有通过日志进行备份，当数据有问题时，通过日志恢复数据。&lt;br/&gt;总之，我们记日志，是为了给人看，来了解程序运行的状态。今天我们只讲日常调试和发现异常的场景。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;日志记录什么内容&lt;/h2&gt;
&lt;p&gt;既然日志是给人看的，就要让人能读懂，给出足够的信息。要带有上下文，4w都要清晰。把日志记录时刻的时间when、地点where（发生的函数，代码行）、什么数据或请求导致（who）。通过这些我们推出why，和how。知道为什么会记录成这样，有什么影响。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;日志的级别&lt;/h2&gt;
&lt;p&gt;在程序中，日志也是分级别的，不同的级别表示日志的不同场景和用途。&lt;br/&gt;通常有如下级别：&lt;br/&gt;TRACE：打印最详尽，在开发过程中使用此级别。类似于单步调试，在发不到运营环境后应该屏蔽掉这个级别。&lt;br/&gt;DEBUG：指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。&lt;br/&gt;INFO：消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。&lt;br/&gt;WARN： 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。&lt;br/&gt;ERROR： 发生了错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，需要记录后处理。&lt;br/&gt;FATAL： 指出每个严重的错误事件将会导致应用程序的退出。严重错误，直接停止程序。&lt;br/&gt;每一条日志都是以上级别中的一种，程序中通过配置默认打印的级别，控制哪些语句打印，哪些不打印。&lt;br/&gt;一般开发阶段使用DEBUG级别，线上运营阶段使用INFO或WARN级别。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;注意事项&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;控制好日志的量&lt;/h3&gt;
&lt;p&gt;记录日志是旁路逻辑，和给用户使用的逻辑是互不影响的。但是日志会消耗程序性能，抢占给用户的计算机资源。所以在记录日志时，要控制好日志的量，不要因为记录日志而导致性能下降。&lt;br/&gt;有些同学会觉得，我的业务现在量也不大，多记些日志也没什么。勿以善小而不为。要养成好的习惯，如果没有这种意识，是没有机会做大业务量的程序的。即使有，也会出问题。&lt;br/&gt;即使量少，用户少，但是不保证程序运行的次数少。如果有个循环频繁调用，触发记录日志，也会导致出问题的。我就见过日志记录太多，把cpu给占满，机器连ssh都连不上。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;日志中出现太多的特殊字符&lt;/h3&gt;
&lt;p&gt;看到有的同学在日志里，会写些特殊的字符串，例如「XXXXXXXXXX」。原因是为了好搜索。如果是为了解决号搜索的问题，使用有规则的格式，和有意义的名字是不是更好，把代码行号打进去是不是更容易搜索？而且大家还知道是什么意思。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;注意日志级别&lt;/h3&gt;
&lt;p&gt;一种是把DEBUG级别设置到生产环境。还有一种是在代码中没有日志级别的概念，都用一种级别，DEBUG或者ERROR。要么所有的日志在生产环境都打不出来，要么一下子全打出来了。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;注意日志安全&lt;/h3&gt;
&lt;p&gt;既然日志记录了这么多信息，要注意日志中的内容，不能什么都打。和用户隐私相关的要避免打印到日志中去。因为这些信息如果不影响查找bug，记录后容易泄露用户隐私。例如：用户的聊天记录、用户的密钥、用户的电话号码邮箱等。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;日志可读性&lt;/h3&gt;
&lt;p&gt;尽量用英文，尽量少用中文，防止机器或网页有字符问题，造成不必要的查找麻烦。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;几种有效的日志形式&lt;/h2&gt;
&lt;p&gt;以下这几种记录日志的形式都各有所长，值得大家学习。但是切记，都有好用的日志库，千万别自己实现，里面的水很深。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;内存日志&lt;/h3&gt;
&lt;p&gt;既然日志打印很耗费性能，一般是磁盘IO是瓶颈。但是在程序遇到问题时，还想把从程序开始，到出问题这段时间的日志都记录下来，怎么办呢？就用内存日志。&lt;br/&gt;申请一个共享内存变量，在程序的各个运行节点，都把要记录的日志信息存储在这个变量中。当程序出错，或者要crash后。用工具把这段内存dump下来，相当于一些栈信息打印出来。如果程序运行正常，当新的请求再开始执行时，重新清空变量，再继续记录。&lt;br/&gt;既记录了很多信息，有没有造成IO的花销，在寻找C++后台程序core的原因时是非常有用的一种方式。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;远程日志&lt;/h3&gt;
&lt;p&gt;既然打本机日志耗费IO性能，导致cpu使用率飙升。那么通过网络包，把信息发送给远端，尽量减轻本地记录日志负担。这也是一种好方法。远端有专门处理日志的程序，负责给日志入库，进行分析和索引。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;染色日志&lt;/h3&gt;
&lt;p&gt;当有用户反馈遇到问题时，但发现只是个例，其他用户并没有此问题时。可以给反馈问题的用户「染色」。日志程序在写日志时，只对染色的用户进行记录，其他的不记。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;流水日志&lt;/h3&gt;
&lt;p&gt;一般用于写接口，把每次写的原始参数给记下来。通过这些流水日志，能够恢复出记录的数据，用于备份或对账最终数据，或者提供给其他系统重写数据。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;日志是给人看的，要注意可读性。&lt;br/&gt;写日志时要注意不要影响程序性能，按需而记。&lt;br/&gt;日志在软件维护期间使用的最多，不要日志用时方恨少。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 30 Jan 2019 13:55:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>无论是哪种程序员，日常开发中都离不开记日志。但是通过最近的review会，发现很多程序员在记日志的时候，还是会有些问题。那么如何科学地记录日志呢？ 为什么要记日志 在寻求方法前，我们先看看我们记日志的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/10339952.html</dc:identifier>
</item>
<item>
<title>记录下diagwait的问题 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10339816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10339816.html</guid>
<description>&lt;p&gt;对于Oracle集群，有关diagwait的解释可以很容易在网上搜到：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;该问题只会出现在ORACLE 11.2 以前版本中，在 11G R2版本中，diagwait的值默认配置为13。&lt;br/&gt;而针对11.2以前的版本，需要手工将diagwait修改为13，以推迟重启的时间便于将缓存中的日志信息有足够的时间写入到磁盘文件中，以及减少因为与OS交互允许时间太短而造成的重启可能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;diagwait算是一个小知识点，但具有普遍性。因为现实中很多客户生产数据库版本低于11.2，同时diagwait没有正确设置（默认配置不合理），轻则导致一些节点驱逐的案例缺少相关日志无法准确分析原因，重则由于oporcd默认的1.5s（1000ms+500ms）过短过于敏感，比如瞬时压力过大都很容易导致节点主机重启，这显然不是我们所期望的。&lt;/p&gt;
&lt;p&gt;diagwait设置方法（使用root用户）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crsctl set css diagwait 13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;diagwait查询方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crsctl get css diagwait 
ps -ef|grep oproc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要重启集群才能生效修改。&lt;/p&gt;
&lt;p&gt;下面在测试环境验证下这个过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@rac1-server ~]$ ps -ef|grep oproc
oracle   12527  6205  0 11:44 pts/4    00:00:00 grep oproc
root     21426 20189  0 Jan24 ?        00:00:00 /bin/sh /etc/init.d/init.cssd oprocd
root     21799 21426  0 Jan24 ?        00:00:15 /s01/oracle/product/10.2.0/crs_1/bin/oprocd.bin run -t 1000 -m 500 -f
[oracle@rac1-server ~]$ crsctl get css diagwait
Configuration parameter diagwait is not defined.

[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl set css diagwait 13
Configuration parameter diagwait is now set to 13.
[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl get css diagwait 
13[oracle@rac1-server ~]$ ps -ef|grep oproc
oracle   15375 14082  0 12:56 pts/4    00:00:00 grep oproc
root     21426 20189  0 Jan24 ?        00:00:00 /bin/sh /etc/init.d/init.cssd oprocd
root     21799 21426  0 Jan24 ?        00:00:15 /s01/oracle/product/10.2.0/crs_1/bin/oprocd.bin run -t 1000 -m 500 -f
此时可以看到oprocd的设置并未修改。

--需要重启crs（所有节点都需要重启）：
[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl stop crs
[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl start crs

--再次查看oprocd进程，看到-m后面的值已经成为由默认的500改为10000，单位是ms：
[oracle@rac1-server ~]$ ps -ef|grep oprocd
root     17520 16659  0 12:58 ?        00:00:00 /bin/sh /etc/init.d/init.cssd oprocd
root     17916 17520  0 12:58 ?        00:00:00 /s01/oracle/product/10.2.0/crs_1/bin/oprocd.bin run -t 1000 -m 10000 -hsi 5:10:50:75:90 -f
oracle   18504 16764  0 12:59 pts/4    00:00:00 grep oprocd&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 30 Jan 2019 13:10:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>对于Oracle集群，有关diagwait的解释可以很容易在网上搜到： 该问题只会出现在ORACLE 11.2 以前版本中，在 11G R2版本中，diagwait的值默认配置为13。 而针对11.2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10339816.html</dc:identifier>
</item>
<item>
<title>ES6学习笔记（一）-变量的解构赋值 - JoeJoan</title>
<link>http://www.cnblogs.com/Joe-and-Joan/p/10339820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-and-Joan/p/10339820.html</guid>
<description>&lt;h2 id=&quot;用途&quot; class=&quot;用途&quot;&gt;变量的解构赋值种类&lt;/h2&gt;
&lt;p&gt;解构（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。&lt;/p&gt;
&lt;p&gt;只有当一个数组成员严格等于（===）&lt;code&gt;undefined&lt;/code&gt;，包括空“ ” ，默认值才会生效，null不全等于undefined，默认值不会生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一种：数组的解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210426675-1636179145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组的元素是按次序排列的，变量的取值由它的位置决定；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二种：对象的解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210245902-876843799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三种：字符串的解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210521803-1817832098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210528040-344843081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串被转换成了一个类似数组的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四种：数值和布尔值的解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210641572-1629013470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第五种：函数参数的解构赋值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201901/1486391-20190130210743947-698477769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数&lt;code&gt;add&lt;/code&gt;的参数表面上是一个数组，但在传入参数时，数组参数就被解构成变量&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意点：只要有可能，就不要在模式中放置圆括号（）,否则可能导致解构的歧义。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;用途&quot; class=&quot;用途&quot;&gt;变量的解构赋值用途&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量的解构赋值用途很多&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）交换变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let x = 1&lt;span&gt;;
let y &lt;/span&gt;= 2&lt;span&gt;;

[x, y] &lt;/span&gt;= [y, x];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码交换变量&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的值，这样的写法不仅简洁，而且易读，语义非常清晰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）从函数返回多个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个数组&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [1, 2, 3&lt;span&gt;];
}
let [a, b, c] &lt;/span&gt;=&lt;span&gt; example();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个对象&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    foo: &lt;/span&gt;1&lt;span&gt;,
    bar: &lt;/span&gt;2&lt;span&gt;
  };
}
let { foo, bar } &lt;/span&gt;= example();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（3）函数参数的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值可以方便地将一组参数与变量名对应起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数是一组有次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f([x, y, z]) { ... }
f([&lt;/span&gt;1, 2, 3&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数是一组无次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f({x, y, z}) { ... }
f({z: &lt;/span&gt;3, y: 2, x: 1});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（4）提取 JSON 数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值对提取 JSON 对象中的数据，尤其有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
let jsonData =&lt;span&gt; {
  id: &lt;/span&gt;42&lt;span&gt;,
  status: &lt;/span&gt;&quot;OK&quot;&lt;span&gt;,
  data: [&lt;/span&gt;867, 5309&lt;span&gt;]
};

let { id, status, data: number } &lt;/span&gt;=&lt;span&gt; jsonData;

console.log(id, status, number);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 42, &quot;OK&quot;, [867, 5309]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码可以快速提取 JSON 数据的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）函数参数的默认值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
jQuery.ajax = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url, {
  async &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  beforeSend &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {},
  cache &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  complete &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {},
  crossDomain &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  global &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... more config&lt;/span&gt;
} =&lt;span&gt; {}) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... do stuff&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定参数的默认值，就避免了在函数体内部再写&lt;code&gt;var foo = config.foo || 'default foo';&lt;/code&gt;这样的语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）遍历 Map 结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何部署了 Iterator 接口的对象，都可以用&lt;code&gt;for...of&lt;/code&gt;循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'first', 'hello'&lt;span&gt;);
map.set(&lt;/span&gt;'second', 'world'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key, value] of map) {
  console.log(key &lt;/span&gt;+ &quot; is &quot; +&lt;span&gt; value);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; first is hello&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; second is world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只想获取键名，或者只想获取键值，可以写成下面这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取键名&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key] of map) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取键值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [,value] of map) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（7）输入模块的指定方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。

const { SourceMapConsumer, SourceNode } &lt;/span&gt;= require(&quot;source-map&quot;);
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 30 Jan 2019 13:09:00 +0000</pubDate>
<dc:creator>JoeJoan</dc:creator>
<og:description>变量的解构赋值种类 解构（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。 只有当一个数组成员严格等于（ ）undefined，包括空“ ” ，默认值才会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joe-and-Joan/p/10339820.html</dc:identifier>
</item>
<item>
<title>应对复杂软件的思考 - whthomas</title>
<link>http://www.cnblogs.com/whthomas/p/10339817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whthomas/p/10339817.html</guid>
<description>&lt;p&gt;由于自己身处SAAS行业，在经历了几轮复杂需求的蹂躏之后，我一直试图寻找一种解法，可以尽量cover住复杂多变的需求。在过去的一年中，通过反复阅读和实践，似乎让我对此有了一些清晰的思路，所以我想写一点东西总结一下自己的这一年里的思考。&lt;/p&gt;
&lt;p&gt;在我们的项目初期，项目的规模可能比较小，代码量很少，我们的代码或许还能整理的比较干净，就像这几组交换机的网线一样，比较有条理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210322413-1999097446.png&quot; alt=&quot;整齐的网线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是随着功能复杂之后，项目也随之变得庞大，整个代码就可能会和这个机房一样，非常的混乱。在经历几次这种状况之后，于是我便在想，究竟是什么问题导致了这种混乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210353770-1591014552.png&quot; alt=&quot;凌乱的机房&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先来看一段代码（&lt;code&gt;Kotlin Code&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;
fun executeRequest(request: Request) : String {
    // 校验身份
    val isValidate = validateRequest(request)
    if( isValidate ) {
        return &quot;Request is not valid&quot;
    }
    // 处理业务
   dealBiz(request)
    try {
        // 存储数据
        saveToDB(request)
    } catch (exception:Exception) {
        return &quot;Occur error when save results to DB&quot;
    }
    // 发送消息
    val isSendSuccess = sendMessage(request)
    if (isSendSuccess == false) {
         return &quot;message send unsuccessfully.&quot;
    }
    return &quot;success&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是我们比较常见的一些代码结构，其实看起来问题也不算很大，但是随着业务复杂，&lt;strong&gt;业务逻辑&lt;/strong&gt;的控制和&lt;strong&gt;控制逻辑&lt;/strong&gt;耦合的很厉害，阅读这种&quot;&lt;strong&gt;面条代码&lt;/strong&gt;&quot;的成本越来越高。每一位新进入项目的伙伴犹如进入了一个“代码迷宫”。来来回回去寻找自己需要的那一段代码，实际上这个时候已经形成了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只有上帝和我能看得懂的“上帝代码”了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这显然是我们不愿见到的代码，在&lt;a href=&quot;https://time.geekbang.org/column/48&quot;&gt;左耳听风专栏&lt;/a&gt;里有一篇《编程的本质》里讲到：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有效地分离 Logic、Control 和 Data 是写出好程序的关键所在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那什么又是&lt;code&gt;Logic&lt;/code&gt;,&lt;code&gt;Control&lt;/code&gt;,&lt;code&gt;Data&lt;/code&gt; 呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Logic : 就是一般的业务代码，类似上面代码中的&lt;code&gt;dealBiz()&lt;/code&gt;,&lt;code&gt;sendMessage()&lt;/code&gt;等等&lt;/li&gt;
&lt;li&gt;Control : 对业务逻辑的流程控制，比如遍历数据、查找数据、多线程、并发、异步等等&lt;/li&gt;
&lt;li&gt;Data ：函数和程序之间传递的这部分信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有效地将这几种代码分离，代码可读性将会大大提升。通过这种拆分，我们也降低除了&lt;strong&gt;自己之外的维护者&lt;/strong&gt;阅读代码&lt;strong&gt;翻译业务&lt;/strong&gt;内容的成本。通过分离，我们可以将代码写成这样：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun executeRequest(request: Request) : String {
    return Result
            .of(request)
            .flatMap { validateRequest(request) }
            .flatMap { dealBiz(request) }
            .flatMap { saveToDB(request) }
            .flatMap { sendMessage(request) }
            .fold(
                success = { return &quot;success&quot; },
                failure = { return it.message }
            )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这里说了如何写细节的代码，那么代码架构又如何去做才可能保证可以应对这么多的变化？&lt;/p&gt;
&lt;p&gt;一般的项目中我们把一个软件系统进行分层，这是我们目前做工程项目的一个共识，我们最初学习的分层架构就是经典的三层架构了。它自顶向下分成三层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户界面层（User Interface Layer）&lt;/li&gt;
&lt;li&gt;业务逻辑层（Business Logic Layer）&lt;/li&gt;
&lt;li&gt;数据访问层（Data Access Layer）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到&lt;strong&gt;数据访问层&lt;/strong&gt;这块，其实很多系统已经变成了&lt;strong&gt;面向数据编程&lt;/strong&gt;，最终做成了“数据库管理系统”。按照传统的三层模型，用户界面的开发依赖Service层，而Service层又依赖着DAO，DAO对应着数据库。大家相互依赖，业务逻辑一旦修改，就意味着要从DAO层开始修改，数据库也跟着被修改，而往往随着我们开发的深入，业务的模型会被不断调整，这样数据库可能就要频繁的变动。代码也开始变得复杂... ...&lt;/p&gt;
&lt;p&gt;而在领域驱动设计中提出了另外一种&lt;strong&gt;四层架构&lt;/strong&gt;，在此之前，我想先分享《实现领域驱动设计》一书讲的六边形模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210435213-1790154051.png&quot; alt=&quot;六边形架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在设计系统的时候，往往过于关注数据库，Http接口等基础设施的设计，而忽略了我们需要关注的业务。在复杂系统中，最容易变化的也是业务形态，产品经常会要求改来改去，因为业务本身就在不断地演进，如果我们一开始就基于数据库作所有的设计，那么势必一旦遇上业务的修改，库表肯定也需要对应先进行变化。假如我们融入六边形架构，将数据库和暴露的&lt;code&gt;Controller&lt;/code&gt;都视为是基础设施，先去关注业务的模型和代码，&lt;code&gt;Class&lt;/code&gt;的修改比要数据库改起来要简单的多。另外一方面，也大大提高了程序的可测试性：在没有准备一堆基础设施(数据库，接口，异步通知等等)情况下，可以先测试逻辑的完整性。&lt;/p&gt;
&lt;p&gt;另外，有时候随着业务增长有的基础设施是会需要进行替换的，采用六边形架构之后，这种更换的成本就会降低。另外如果出现需要使用Web Service的客户，我们也不必纠结于之前的HTTP接口，直接开出一套新的协议代码供客户使用，而不会纠结领域部分代码有逻辑上的缺失。&lt;/p&gt;
&lt;p&gt;采用六边形架构之后，我们的领域模型也会更加独立，更精简，在适应新的需求时修改也会更容易。在《架构整洁之道》之中提到的“整洁架构”也与“六边形架构”大同小异。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210514304-1859240163.png&quot; alt=&quot;Bob大叔的Clean Architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这两种架构也是&lt;strong&gt;依赖倒置原则&lt;/strong&gt;很好的实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节&lt;/li&gt;
&lt;li&gt;细节应该依赖抽象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时再回顾原来定义的四层架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户展示层&lt;/li&gt;
&lt;li&gt;应用服务层&lt;/li&gt;
&lt;li&gt;领域层&lt;/li&gt;
&lt;li&gt;基础设施层&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;他们的依赖关系如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210535562-100711042.png&quot; alt=&quot;四层架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们可以将业务核心代码放入&lt;code&gt;领域层&lt;/code&gt;之中，要应对的各个场景代码放入应用服务层中。将协议转换、中间件和数据库的适配都放入基础设施层里。在应用层与&lt;code&gt;Controller&lt;/code&gt;之间的那些&lt;code&gt;VO&lt;/code&gt;作为用户展示层，以做出整洁架构。&lt;/p&gt;
&lt;p&gt;当我们开始学习Java的时候，都知道Java是一门面向对象的语言，我们本可以将现实世界翻译到代码的世界之中，但实际上我们往往在项目中只会将对象定义成&lt;strong&gt;贫血模型&lt;/strong&gt;，最终写成面向过程的代码。如何做才能让这个复杂的世界反应到代码里呢？&lt;/p&gt;
&lt;p&gt;让我们再从需求说起，对于一个复杂的软件，任何一个项目的参与者（包括初创的成员），都很难靠自己就看清整个项目的全貌，我们犹如图中的盲人，大家可能最后对项目的理解都是不一致的。此时每一位参与者都犹如“盲人摸象”中的“盲人”，对需求(大象)只有片面的理解，于是乎，有的人觉得大象是水管的形状，有的人觉得大象是扇子一样的形状，有的人说大象长得跟柱子一样... ...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210607896-285144989.png&quot; alt=&quot;盲人摸象&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过讨论，我们会对自我的认知进行一些修正，最终大致得出一个需求的全貌。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210623755-2013718568.png&quot; alt=&quot;讨论的价值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如我们要去识别一些系统边界，在DDD的战略设计中非常强调划分&lt;strong&gt;界限上下文&lt;/strong&gt;。比如我作为一个个体，在不同的场景中，我的身份、角色都不大相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210736123-373402660.png&quot; alt=&quot;对自我身份的识别&quot;/&gt;&lt;/p&gt;
&lt;p&gt;犹如在上图中，在“地铁”、“家庭”和“公司”中，我的身份是不一样的，但是我依旧是我，找出业务的场景，也就意味着我找到了系统的边界。通过分析场景识别边界来找出系统的核心领域和支撑领域，以此来最终确定系统的数量，降低系统的耦合。&lt;/p&gt;
&lt;p&gt;我们还可以用&lt;a href=&quot;https://www.infoq.cn/articles/xh-four-color-modeling&quot;&gt;四色建模方法&lt;/a&gt;来识别出我们系统中发生的整个流程，发现究竟是谁通过什么方式触发了什么事情，最终又影响了哪些对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210714588-612839442.jpg&quot; alt=&quot;四色建模(图片来自infoq.cn)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终通过我们找出的事件，整理出一个能够让我们进行沟通的模型。在我们的模型被构建得相对完善之时，其实代码也差不多已经被构建出来了，因为这个时候再去回想&lt;strong&gt;面向对象&lt;/strong&gt;的设计，我们发现模型即代码，代码即模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201901/475531-20190130210650333-153286060.png&quot; alt=&quot;四色建模的要点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直以来我都希望通过一些好的“工程实践”来提高团队的效率以及我们的代码质量，我想这也是思考这些架构的意义吧。我想用《架构整洁之道》中的一句话来做本文的总结：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;软件架构的最终目标是，用&lt;strong&gt;最小&lt;/strong&gt;的人力成本来满足&lt;strong&gt;构建和维护&lt;/strong&gt;系统的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如《人月神话》里说的一样，软件工程里没有“银弹”，即使做了整洁架构也无法避免需求的变化和延期，只是希望当我们身处需求的困境中时，仍能给自己以更多的选择。&lt;/p&gt;
&lt;h6 id=&quot;参考资料活动&quot;&gt;参考资料&amp;amp;活动 ：&lt;/h6&gt;
</description>
<pubDate>Wed, 30 Jan 2019 13:08:00 +0000</pubDate>
<dc:creator>whthomas</dc:creator>
<og:description>由于自己身处SAAS行业，在经历了几轮复杂需求的蹂躏之后，我一直试图寻找一种解法，可以尽量cover住复杂多变的需求。在过去的一年中，通过反复阅读和实践，似乎让我对此有了一些清晰的思路，所以我想写一点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whthomas/p/10339817.html</dc:identifier>
</item>
<item>
<title>Egg中使用egg-mongoose和常用的Mongoose 方法 - wxw婉</title>
<link>http://www.cnblogs.com/wxw1314/p/10339775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxw1314/p/10339775.html</guid>
<description>&lt;h2 class=&quot;heading&quot;&gt;Mongoose&lt;/h2&gt;
&lt;p&gt;Mongoose就是一套操作MongoDB数据库的接口，而Egg中有对应的插件egg-mongoose。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot;&gt;安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;$ npm install egg-mongoose --save
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;heading&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;改变Egg项目中的配置文件{workplace}/config/plugin.js中来启用 egg-mongoose 插件:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;exports.mongoose = {
  &lt;span class=&quot;hljs-built_in&quot;&gt;enable: &lt;span class=&quot;hljs-literal&quot;&gt;true,
  package: &lt;span class=&quot;hljs-string&quot;&gt;'egg-mongoose',
};
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;heading&quot;&gt;Egg连接mongoose&lt;/h2&gt;
&lt;p&gt;在Egg项目中的配置文件{workplace}/config/default.js配置项config添加属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;config.mongoose = {
    url: process.env.EGG_MONGODB_URL || &lt;span class=&quot;hljs-string&quot;&gt;'mongodb://127.0.0.1/website',
    options: {
      server: {
        poolSize: 40,
      },
    },
  };
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;heading&quot;&gt;定义数据表&lt;/h2&gt;
&lt;p&gt;在{workplace}/app/model/article.js定义数据表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;'use strict';
module.exports = app =&amp;gt; {
  const mongoose = app.mongoose;
  const Schema = mongoose.Schema;
  const PostSchema = new Schema({
    wid: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    release: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Boolean,
    },
    sort: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Number,
    },
    img: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    abstract: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    text: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    isSetTop: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Number,
    },
    title: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    keywords: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    describe: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    updateTime: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Date,
    },
    num: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Number,
    },
    uid: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    editors: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: String,
    },
    &lt;span class=&quot;hljs-built_in&quot;&gt;disable: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Boolean,
    },
    columnId: {
      &lt;span class=&quot;hljs-built_in&quot;&gt;type: Schema.Types.ObjectId,
    },
  });
  &lt;span class=&quot;hljs-built_in&quot;&gt;return mongoose.model(&lt;span class=&quot;hljs-string&quot;&gt;'Article', PostSchema);
};

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：其中type表示字段类型，Mongoose 有以下几种类型Number（数字），String（字符串），Boolean（布尔值），ObjectId（对象ID），Array（数组），Object（对象），Date（日期）。。。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot;&gt;常用的Mongoose 方法&lt;/h2&gt;
&lt;h3 class=&quot;heading&quot;&gt;一，增加数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.create(post,callback);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：其中post为json数据结构，callback为操作后的回调函数&lt;/p&gt;
&lt;h3 class=&quot;heading&quot;&gt;二，查询数据&lt;/h3&gt;
&lt;h4 class=&quot;heading&quot;&gt;1，获取所有数据，返回是一个数组&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;heading&quot;&gt;2，获取一个数据，返回是一个对象&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.findOne()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;heading&quot;&gt;3，条件查询&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find(conditions,callback);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;condition有以下几种类型&lt;/p&gt;
&lt;h4 class=&quot;heading&quot;&gt;1），根据具体数据进行查询&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({_id：5c4a819fb87ba4002a47bc4f,title:&lt;span class=&quot;hljs-string&quot;&gt;&quot;123&quot;},callback);
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回_id为5c4a819fb87ba4002a47bc4f，title为123的结果&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;2），条件查询&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$lt&quot;    小于
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$lte&quot;    小于等于
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$gt&quot;     大于
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$gte&quot;    大于等于
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$ne&quot;     不等于
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({“sort”:{ &lt;span class=&quot;hljs-variable&quot;&gt;$get:18 , &lt;span class=&quot;hljs-variable&quot;&gt;$lte:30 });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中sort 大于等于18并小于等于30的结果&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;3），或查询 OR&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$in&quot; 一个键对应多个值
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$nin&quot; 同上取反, 一个键不对应指定值
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$or&quot; 多个条件匹配, 可以嵌套 &lt;span class=&quot;hljs-variable&quot;&gt;$in 使用
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$not&quot;    同上取反, 查询与特定模式不匹配的文档
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;:{ &lt;span class=&quot;hljs-variable&quot;&gt;$in:[20,21,22.&lt;span class=&quot;hljs-string&quot;&gt;&quot;haha&quot;]} );
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中title等于20或21或21或&quot;haha&quot;的结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$or&quot; :  [ {&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;:18} , {&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;wxw&quot;} ] });
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中age等于18或 name等于&quot;wxw&quot;的结果&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;4），类型查询（&lt;code&gt;&quot;$exists&quot;&lt;/code&gt;条件判定）&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({name: {&lt;span class=&quot;hljs-variable&quot;&gt;$exists: &lt;span class=&quot;hljs-literal&quot;&gt;true}},&lt;span class=&quot;hljs-keyword&quot;&gt;function(error,docs){
  //返回Article表中所有存在name属性的结果
});
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({telephone: {&lt;span class=&quot;hljs-variable&quot;&gt;$exists: &lt;span class=&quot;hljs-literal&quot;&gt;false}},&lt;span class=&quot;hljs-keyword&quot;&gt;function(error,docs){
  //返回Article表中所有不存在telephone属性的结果
});
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;heading&quot;&gt;5），匹配正则表达式查询&lt;/h4&gt;
&lt;p&gt;MongoDb 是使用 Prel兼容的正则表达式库来匹配正则表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find( {&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot; : /joe/i } );
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为 joe 的结果, 并忽略大小写&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;6），查询数组&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array&quot;:10} );
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array[5]&quot;:10}  );
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array&quot;:[5,10]});
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中查询匹配array数组中既有5又有10的结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array&quot;:{&lt;span class=&quot;hljs-variable&quot;&gt;$size : 3} });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中查询匹配array数组长度为3 的的结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array&quot;:{&lt;span class=&quot;hljs-variable&quot;&gt;$slice : 10} });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中查询匹配array数组的前10个元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({&lt;span class=&quot;hljs-string&quot;&gt;&quot;array&quot;:{&lt;span class=&quot;hljs-variable&quot;&gt;$slice :  [5,10]} });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中查询匹配array数组的第5个到第10个元素&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;7)，where&lt;/h4&gt;
&lt;p&gt;用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find( {&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$where&quot; :  &lt;span class=&quot;hljs-string&quot;&gt;&quot;this.x + this.y === 10&quot; } );
this.ctx.model.Article.find( {&lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$where&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot; function(){ return this.x + this.y ===10; } &quot; } )
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中this为数据表中的数据，上述返回Article表中属性x+属性y=10的所有数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot;&gt;三，删除数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.remove(conditions,callback);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：conditions为查询条件，与查询数据介绍的一样，eg：{ _id：5c4a819fb87ba4002a47bc4f }，找到_id为5c4a819fb87ba4002a47bc4f的数据，callback为操作成功后的回调函数&lt;/p&gt;
&lt;h3 class=&quot;heading&quot;&gt;四，更新数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update(conditions, update, callback)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;参数1:查询条件, 参数2:更新对象,可以使用MondoDB的更新修改器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;备注：conditions与查询数据中介绍的一样&lt;/p&gt;
&lt;h4 class=&quot;heading&quot;&gt;1，update为更新对象&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;let post = {
    wid: &lt;span class=&quot;hljs-string&quot;&gt;'5c492c57acbe363fd4824446',
    column: [ &lt;span class=&quot;hljs-string&quot;&gt;'新闻' ],
    titleHead: &lt;span class=&quot;hljs-string&quot;&gt;'',
    img: &lt;span class=&quot;hljs-string&quot;&gt;'',
    isAbstract: &lt;span class=&quot;hljs-string&quot;&gt;'false',
}
this.ctx.model.Article.update({ _id: &lt;span class=&quot;hljs-string&quot;&gt;'5c4a819fb87ba4002a47bc4f ' }, post)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询Article表中特定_id，并对post中所包含的属性进行更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;2，update使用MondoDB的更新修改器，有以下几种使用场景&lt;/h4&gt;
&lt;h4 class=&quot;heading&quot;&gt;1），&lt;code&gt;&quot;$inc&quot;&lt;/code&gt;增减修改器,只对数字有效&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;:22}, {&lt;span class=&quot;hljs-variable&quot;&gt;$inc:{&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;:1} }  );
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;找到age=22的文档,修改文档的age值自增1&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;2），&lt;code&gt;'$set'&lt;/code&gt; 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({ _id：5c4a819fb87ba4002a47bc4f }, { &lt;span class=&quot;hljs-variable&quot;&gt;$set: { isDelete: &lt;span class=&quot;hljs-literal&quot;&gt;true } });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对5c4a819fb87ba4002a47bc4f 表进行软删除，找到特定_id数据，增加或者修改isDelete属性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;3），&lt;code&gt;&quot;$unset&quot;&lt;/code&gt;同上取反,删除一个键&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({age:22}, {&lt;span class=&quot;hljs-variable&quot;&gt;$unset:{age:18} } );
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;执行后age键不存在&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;4），&lt;code&gt;'$push'&lt;/code&gt;给一个键push一个数组成员,键不存在会创建,对数组有效&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({name:&lt;span class=&quot;hljs-string&quot;&gt;'wxw'}, {&lt;span class=&quot;hljs-variable&quot;&gt;$push:{array:10} } );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为wxw的数据，增加一个array键,类型为数组,有一个成员 10&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;5），&lt;code&gt;'$addToSet'&lt;/code&gt;向数组中添加一个元素,如果存在就不添加&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({name:&lt;span class=&quot;hljs-string&quot;&gt;'wxw'},{&lt;span class=&quot;hljs-variable&quot;&gt;$addToSet:{array:10} } );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为wxw的数据，array中有10所以不会添加&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;6），&lt;code&gt;'$each'&lt;/code&gt;遍历数组和 $push 修改器配合可以插入多个值&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({name:&lt;span class=&quot;hljs-string&quot;&gt;'wxw'}, {&lt;span class=&quot;hljs-variable&quot;&gt;$push:{array:{&lt;span class=&quot;hljs-variable&quot;&gt;$each: [1,2,3,4,5]}} } );
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为wxw的数据，执行后array : [10,1,2,3,4,5]&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;7），&lt;code&gt;'$pop'&lt;/code&gt; 向数组中尾部删除一个元素&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({name:&lt;span class=&quot;hljs-string&quot;&gt;'wxw'}, {&lt;span class=&quot;hljs-variable&quot;&gt;$pop:{array:1} } );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为wxw的数据，其中array : [10,1,2,3,4,5]，执行后 array : [10,1,2,3,4]&lt;/li&gt;
&lt;li&gt;tip:将1改成-1可以删除数组首部元素&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot;&gt;8），&lt;code&gt;'$pull'&lt;/code&gt; 向数组中删除指定元素&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.update({name:&lt;span class=&quot;hljs-string&quot;&gt;'wxw'}, {&lt;span class=&quot;hljs-variable&quot;&gt;$pull:{array:10} });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回Article表中name为wxw的数据，匹配到array中的10后将其删除。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot;&gt;五，排序（sort）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.sort({ isSetTop: -1, sort: 1, editTime: -1 });
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对Article表中的数据进行排序，先按“isSetTop”降序，再按“sort”升序，最后按“editTime”降序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;备注：键对应数据中的键名，值代表排序方向，1 升序, -1降序。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot;&gt;六，限制返回结果的数量（limit）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.limit(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对Article表中的数据进行返回，返回为前面3条数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot;&gt;七，跳过前3个文档,返回其余的（skip）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.skip(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对Article表中的数据进行返回，跳过前面3条数据，返回其余数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;附：综合使用最后三个方法进行分页查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;this.ctx.model.Article.find({ _id：5c4a819fb87ba4002a47bc4f }).skip(pageSize * (pageNum - 1)).limit(parseInt(pageSize)).sort({ isSetTop: -1, sort: 1, editTime: -1 });
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中pageSize和pageNum为动态传递数据，返回Article表中特定_id在每页数据为pageSize条件下的第pageNum页中的数据，并按照“isSetTop”降序，再按“sort”升序，最后按“editTime”降序进行排序。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 30 Jan 2019 12:57:00 +0000</pubDate>
<dc:creator>wxw婉</dc:creator>
<og:description>Mongoose Mongoose就是一套操作MongoDB数据库的接口，而Egg中有对应的插件egg-mongoose。 安装 配置 改变Egg项目中的配置文件{workplace}/config/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxw1314/p/10339775.html</dc:identifier>
</item>
<item>
<title>[翻译]各个类型的IO -  阻塞, 非阻塞,多路复用和异步 - fairjm</title>
<link>http://www.cnblogs.com/fairjm/p/translate-the-various-kinds-of-io-blocking-non.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fairjm/p/translate-the-various-kinds-of-io-blocking-non.html</guid>
<description>&lt;p&gt;同事推荐,感觉写的不错就试着翻译了下.&lt;br/&gt;原文链接: &lt;a href=&quot;https://www.rubberducking.com/2018/05/the-various-kinds-of-io-blocking-non.html&quot; class=&quot;uri&quot;&gt;https://www.rubberducking.com/2018/05/the-various-kinds-of-io-blocking-non.html&lt;/a&gt;&lt;br/&gt;作者: &lt;a href=&quot;https://www.blogger.com/profile/15503004383957399868&quot;&gt;Rubber Ducking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我发现对于软件程序员来说很难分清楚各种类型的IO.对于阻塞,非阻塞,多路复用和异步IO有很多的混淆点.&lt;br/&gt;所以我想尝试解释清楚各种IO类型意味着什么&lt;/p&gt;

&lt;p&gt;在现代操作系统中,IO(输入/输出)是一种和外围设备交换数据的方式.包括读写磁盘或SSD,通过网络发送和接受数据,在显示器上显示,接入键盘和鼠标输入,等等.&lt;/p&gt;
&lt;p&gt;现代操作系统和外围设备的交流取决于外围设备的特定类型以及他们的固件版本和硬件能力.&lt;br/&gt;通常来说,你可以认为外围设备是很高级的,他们可以同时处理多个并发的读写数据请求.也就是说,串行交流的日子一去不返了.&lt;br/&gt;在这些场景中,外围设备和CPU间的交流在硬件层面都是异步的.&lt;/p&gt;
&lt;p&gt;这个异步机制被称为硬件中断.&lt;br/&gt;想想一个简单的场景,CPU请求外围设备去读取一些数据,接着CPU会进入一个无限循环,每一次都会检查外围设备的数据是否可用,直到获得了数据为止.&lt;br/&gt;这种方法被称为拉取(&lt;code&gt;polling&lt;/code&gt;),因为CPU需要保持检查外围设备.&lt;br/&gt;在现代硬件中,取而代之发生的是CPU请求外围硬件执行操作,然后就忘了这件事,继续处理其他的CPU指令.只要外围设备做完了,他会通过电路中断来通知CPU.&lt;br/&gt;这发生在硬件中,CPU因此不需要停下来或者检查这个外围设备,可以继续执行其他的工作,直到周边设备说已经做完了.&lt;/p&gt;

&lt;p&gt;现在我们了解了硬件中发生的事,我们可以移动到软件这一侧了.&lt;br/&gt;在这一层IO通过多种方式被暴露:阻塞,非阻塞,多路复用和异步.让我们一个个来仔细解释.&lt;/p&gt;
&lt;h2 id=&quot;阻塞&quot;&gt;阻塞&lt;/h2&gt;
&lt;p&gt;还记得用户程序如何在一个进程内运行，代码是在线程的上下文中执行的吗？&lt;br/&gt;你总是会遇到需要编写一个需要从文件中读取数据的程序的情况.&lt;br/&gt;使用阻塞IO,你所做的是从你的线程中请求操作系统,将线程置于休眠(sleep),当数据可用于被消费时操作系统会唤醒线程.&lt;/p&gt;
&lt;p&gt;也就是说,阻塞IO之所以被称为阻塞是因为使用他的线程会被阻塞直到IO完成.&lt;/p&gt;
&lt;h2 id=&quot;非阻塞&quot;&gt;非阻塞&lt;/h2&gt;
&lt;p&gt;阻塞IO的问题是当你的线程在休眠时,他除了等IO完成不能干其他事.&lt;br/&gt;有时候,你的程序可能没有其他事可做了.&lt;br/&gt;但如果还有其他事需要做的话,能在等待IO的时候并发做可是极好的.&lt;/p&gt;
&lt;p&gt;其中一种实现方式被称为非阻塞IO.&lt;br/&gt;他的思想是当你读取一个文件时,OS只是简单返回给你文件的内容或者一个等待状态告诉你IO还未完成,而不是将线程休眠.&lt;br/&gt;他不会阻塞你的线程,但之后检查IO是否完成的工作还是交给了你.&lt;br/&gt;这意味着当处于等待状态时,你可以去做一些工作,当你再次需要IO时,可以再读取一次,那时候IO可能已经完成了,文件的内容会返回,如果还是处于等待状态的话,你可以选择继续做其他事.&lt;/p&gt;
&lt;h2 id=&quot;多路复用&quot;&gt;多路复用&lt;/h2&gt;
&lt;p&gt;非阻塞IO的问题是如果你在等待IO的过程中要做的其他事情就是另外的IO的话,事情会变得很奇怪.&lt;/p&gt;
&lt;p&gt;在一个好的场景下,你请求OS去读取文件A的内容,然后去做一些重计算的工作,做完之后再去检查文件A是否完成读取,如果完成了,你再做一些关于这个文件内容的操作,不然就继续做其他的工作,循环往复.&lt;br/&gt;但在一个坏的场景中,你没有重计算的工作要去做,而是需要去读取另一个文件B.&lt;br/&gt;那除了等待他们还有什么事要做呢?&lt;br/&gt;没有了,你的程序就进入了一个死循环,判断文件A是否被读取完毕,接着再去判断文件B,一遍又一遍.&lt;br/&gt;要么你使用简单的状态轮询,这会导致过多消耗CPU,或者你手动加入一些随意的休眠时间,不过这也意味着你将延迟知道IO完成,这会降低程序的吞吐.&lt;/p&gt;
&lt;p&gt;为了避免这个问题,你可以使用多路复用IO来代替.&lt;br/&gt;他所做的是你再次阻塞在IO上,但这次不仅仅是一个一个的IO操作,你可以将所有需要的IO操作塞入队列,阻塞在所有的操作上. 当其中有一个IO完成之后OS会唤醒你.&lt;br/&gt;一些多路复用的实现提供了更多的控制,你可以设置在特定一些IO操作完成之后再被唤醒,例如A和C文件或B和D文件完成的时候.&lt;/p&gt;
&lt;p&gt;所有你可以调用非阻塞读取文件A,然后非阻塞读取文件B,最后告诉操作系统将我的线程置于休眠,当A和B的IO都完成的时候或其中一个完成的时候再唤醒他.&lt;/p&gt;
&lt;h2 id=&quot;异步&quot;&gt;异步&lt;/h2&gt;
&lt;p&gt;多路复用IO的问题是在IO完毕前你还是处于休眠状态.&lt;br/&gt;又一次,这对一些程序来说可行,那些除了等待IO操作完成外没有其他操作要去执行的程序.&lt;br/&gt;但有时候,你确实需要去做其他事情.&lt;br/&gt;可能你正在计算PI的数字,同时也在汇总一些文件的值.&lt;br/&gt;你想要进行的操作是将所有的读操作入队列,当等待他们读取完成前,你可以继续计算PI.当一个文件读取完成后,你可以汇总他的值,然后继续进行PI的计算直到另一个文件完成读取.&lt;/p&gt;
&lt;p&gt;为了让这可行,你需要一种方式当IO完成时中断PI的计算,并且你需要IO来执行这个操作当他完成时.&lt;/p&gt;
&lt;p&gt;这通过事件回调完成.执行读操作的调用会需要一个回调,并且调用立即返回.当IO完成时,操作系统会挂起你的线程,并执行你的回调.当回调完成时,他会恢复你的线程.&lt;/p&gt;

&lt;p&gt;你可能已经注意到我所描述的所有线程都是关于单个线程的,也就是你的主线程.&lt;br/&gt;真相是,IO的执行不依赖于线程,这我在最开始就已经解释过了,外围设备都是在他们自己的电路里异步执行IO.&lt;br/&gt;所以阻塞,非阻塞,多路复用和异步IO都是可能在单线程模型中被执行的.&lt;br/&gt;这也是为什么并发IO可以不借助于多线程支持来工作.&lt;/p&gt;
&lt;p&gt;现在,对于处理IO操作完成的结果,或者请求IO操作很明显是可以多线程的,如果你需要的话.这允许你在并发IO之上执行并发计算.所以没有什么东西阻止多线程和这些IO机制结合.&lt;/p&gt;
&lt;p&gt;事实上,这里也有第五种受欢迎的基于多线程的IO.&lt;br/&gt;他经常被混淆为非阻塞IO或异步IO,因为他对外暴露出的是类似他们的接口.&lt;br/&gt;真相是,他是假装的非阻塞或异步IO.他的工作方式很简单,他使用阻塞IO,但是每个阻塞操作都是在他自己的线程中(注:多线程环境,非主线程中).&lt;br/&gt;现在取决于他的实现机制,他要么接收一个回调,或者使用一种拉取模型,比如返回一个Future对象.&lt;/p&gt;

&lt;p&gt;我希望这篇文章可以帮助你澄清对多种IO的理解.还有很重要的一点需要注意,他们不是被所有的操作系统和所有的外围设备支持的.相似的,不是所有的编程语言都暴露了操作系统支持的所有IO类型的API.&lt;/p&gt;
&lt;p&gt;这边请,所有类型的IO都解释了.&lt;/p&gt;
&lt;p&gt;希望能对你有所帮助.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/50205346/172272&quot;&gt;non-blocking IO vs async IO and implementation in Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.omega-prime.co.uk/2015/09/03/asynchronous-and-non-blocking-io/&quot;&gt;Asynchronous and non-blocking IO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linux-mag.com/id/331/&quot;&gt;Multiplexed I/O&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;Reactor pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proactor_pattern&quot;&gt;Proactor pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.stephencleary.com/2013/11/there-is-no-thread.html&quot;&gt;There is no thread&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://davmac.org/davpage/linux/async-io.html&quot;&gt;Asynchronous I/O and event notification on linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/87892/what-is-the-status-of-posix-asynchronous-i-o-aio&quot;&gt;What is the status of POSIX asynchronous I/O (AIO)?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lse.sourceforge.net/io/aio.html&quot;&gt;Kernel Asynchronous I/O (AIO) Support for Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85).aspx&quot;&gt;I/O Completion Ports&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我不是一个系统层面的程序员,我也不是一个操作系统提供的所有种类IO方面的专家.这篇文章是我尽可能总结我所知的内容,更偏向于中间层面的知识.所以如果你发现有任何问题的话请指正我.&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 12:38:00 +0000</pubDate>
<dc:creator>fairjm</dc:creator>
<og:description>同事推荐,感觉写的不错就试着翻译了下. 原文链接: 'https://www.rubberducking.com/2018/05/the various kinds of io blocking no</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fairjm/p/translate-the-various-kinds-of-io-blocking-non.html</dc:identifier>
</item>
<item>
<title>数据清洗(二)：岗位职责与要求的分离 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10339702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10339702.html</guid>
<description>&lt;p&gt;    在现有的所有互联网招聘网站上，岗位信息里的所有条目都是在同一级标签下。因此，岗位信息作为一个整体，就需要额外的操作把要求与职责分离开。鉴于岗位信息里数据格式的不统一，因此博主放弃了使用正则表达式的方法，而是选择了&lt;strong&gt;模糊匹配+结构化匹配&lt;/strong&gt;，将字符串比较的问题转化成了概率问题。&lt;/p&gt;


&lt;p&gt;    在之前写的&lt;a href=&quot;https://www.cnblogs.com/magicxyx/category/1392840.html&quot;&gt;爬虫&lt;/a&gt;里，岗位信息一栏使用Xpath的String()方法抓取，作为一个大的字符串，所有信息都位于一个单元格中。现在计划在爬虫运行时，得到岗位信息后就将其分离，再写入硬盘中。所以，爬取数据时的格式会极大的影响分离的方法，字符串适合使用正则表达式，但是在格式混乱的岗位信息中，这显然不是完美的解法，如'岗位职责'，与之类似的还有'工作内容'，'职位描述'等等，这些词的各种排列组合会极大的增加正则表达式的长度。&lt;/p&gt;
&lt;p&gt;    所以我决定将每一行信息都转化为数组的一个元素，再通过上下文信息与其自身的词汇信息判断其归属。在我爬取的51job移动端中，岗位信息的条目都在标签&amp;lt;article&amp;gt;下，因此使用&lt;strong&gt;//text()&lt;/strong&gt;方法，将&amp;lt;article&amp;gt;标签下每一行的信息都转化为一个数组元素。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;info = selector.xpath(&lt;span&gt;'//*[@id=&quot;pageContent&quot;]/div[3]/div[2]/article//text()'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202840978-596913594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图表&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;数据在源码中的位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;    上图所示的数据格式是最完美的，只需要正则表达式就能匹配成功。每一条数据都含有信息，'岗位职责'与'岗位要求'预示下文的数据与这个主题相关，其余信息则属于某一个主题。所以对这类结构化非常明显的信息，只需要匹配出'职责'与'要求'即可完成数据的分离。&lt;/p&gt;
&lt;p&gt;    另一种情况如下所示，职位描述里包含了一眼就能看出来的岗位职责与要求，但是职责头信息缺失，通过上下文无法得出该信息的归属。因此，对于这类上下文无关的信息，就需要单独进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202844437-1826010183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图表&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;缺少主题的&lt;/span&gt;&lt;span&gt;jd&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    通过上述分析，就得出了这样一个处理流程：如果现在处理的信息属于头部信息(职责、要求等)，则进入结构化处理流程，否则单独处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202845893-1550866361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图表&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;流程图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;    由于对相同意思的不同表述，以及输入过程中可能会出现的错误，因此使用模糊匹配来近似地查找与字符串匹配的字串。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    字符串模糊匹配（ fuzzy string matching）是一种近似地（而不是精确地）查找与模式匹配的字符串的技术。换句话说，字符串模糊匹配是一种搜索，即使用户拼错单词或只输入部分单词进行搜索，也能够找到匹配项。因此，它也被称为字符串近似匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    先导入第三方库fuzzywuzzy：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;from fuzzywuzzy import fuzz  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;fuzz有五个常用的函数，先做一个简单的测试来看看区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202846258-1633844640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    函数功能就像它们的名称一样，通俗易懂。再换一个长一点儿的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202846536-925939268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    所以我选择partial_token_sort_ratio()的值作为判断的依据。&lt;/p&gt;
&lt;p&gt;通过分析ratio函数的源码，可以发现ratio()函数的求值公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202846896-1812840549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;M是匹配的元素个数，T是字符串长度。所以针对partial的函数，我们可以用2/(len(thisStr))*100来判断字符串是否满足模糊匹配。&lt;/p&gt;
&lt;p&gt;另外有一个小问题，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202847338-248197448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    后来发现，str2 = 'word1word2word3'时，word1出现在str1中，则匹配失败。所以在str2前加入一个字，取'工作'后一字，则解决问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202847660-704433043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    正如正则表达式需要自己定义匹配的字符一样，模糊匹配也需要自己定义一个类似的字符集。我们总共需要四个字符集，分别是岗位要求与职责头的字符集，以及具体要求的字符集。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;str_responsibility = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;作职责描述介绍内容&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;str_requirement = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;能力要求需求资格条件标准&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;str_line_res = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;负责基于构建根据制定规范需求&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;str_line_req = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;经验熟悉熟练掌握精通优先学历专业以上基础知识学习交流年龄编程了解&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    函数parse()作为信息处理的入口，接收一个含有岗位信息的数组，返回一个数组，数组元素分别是岗位职责与要求。&lt;/p&gt;
&lt;p&gt;    由于爬取的信息含有大量制表符与空字符，所以需要排除无效的信息，并用一个新的数组'ls_jd'存储岗位信息。&lt;/p&gt;
&lt;ol readability=&quot;69&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;def parse(ls):  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; len(ls) == 0:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; [&lt;span&gt;'null'&lt;span&gt;,&lt;span&gt;'null'&lt;span&gt;]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    ls_jd = []  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    result_res = []  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    result_req = []  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    str_responsibility = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;作职责描述介绍内容&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    str_requirement = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;能力要求需求资格条件标准&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; i in range(len(ls)):  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        str_line = str(ls[i]).strip()  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; len(str_line.strip()) &amp;lt; 2:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;            ls_jd.append(str_line)  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再声明一个变量Index，用来记录现在读取到数组元素的下标。&lt;/p&gt;
&lt;p&gt;使用一个循环，从第一个元素开始，依次读取数组元素，并求得其与'岗位职责'字串、'岗位要求'字串的相似度，再分别进行匹配。&lt;/p&gt;
&lt;p&gt;另外，由于需要对循环元素进行操作，所以不能使用for循环，因此此处使用了while()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;index = 0  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt; int(index) &amp;lt; len(ls_jd):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    str_line = ls_jd[index]  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; len(str_line) &amp;lt; 10:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        fuzz_res = fuzz.partial_token_sort_ratio(str_line, str_responsibility)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        fuzz_req = fuzz.partial_token_sort_ratio(str_line, str_requirement)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;        parse_line(str_line,result_res,result_req)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        index += 1  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;continue&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; fuzz_res &amp;gt; fuzz_req &lt;span&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;span&gt; fuzz_res &amp;gt;= (2/len(str_responsibility)*100):  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;        index = parse_res(index,ls_jd,str_requirement,result_res)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;elif&lt;/strong&gt;&lt;span&gt; fuzz_req &amp;gt; fuzz_res &lt;span&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;span&gt; fuzz_req &amp;gt;= (2/len(str_requirement)*100):  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;        index = parse_req(index,ls_jd,str_responsibility,result_req)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;'warn: '&lt;span&gt;+ str_line)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    index += 1  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于结构的信息提取会修改当前读取数组的下标，所以需要将当前函数内读取到的下标返回。参数里传列表，实际上传的是地址，所以结果不需要额外操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; parse_res(index,ls,str_break,result_res):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# print('&lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位职责&lt;/span&gt;&lt;span&gt;()Start')&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt; index &amp;lt; len(ls)-1:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        index += 1  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        fuzz_break = fuzz.partial_token_sort_ratio(ls[index], str_break)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; fuzz_break &amp;lt; 49:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            result_res.append(ls[index])  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; index-1  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; index  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; parse_req(index,ls,str_break,result_req):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;# print('&lt;/span&gt;&lt;/span&gt;&lt;span&gt;岗位要求&lt;/span&gt;&lt;span&gt;()Start')&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt; index &amp;lt; len(ls)-1:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        index += 1  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        fuzz_break = fuzz.partial_token_sort_ratio(ls[index], str_break)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; fuzz_break &amp;lt; 49:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            result_req.append(ls[index])  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; index-1  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; index  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; parse_line(line,result_res,result_req):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    str_res = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;负责基于构建根据制定规范需求&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    str_req = &lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;经验熟悉熟练掌握精通优先学历专业以上基础知识学习交流年龄编程了解&lt;/span&gt;&lt;span&gt;'&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    fuzz_res = fuzz.partial_token_sort_ratio(line, str_res)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    fuzz_req = fuzz.partial_token_sort_ratio(line, str_req)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; fuzz_res-1 &amp;gt;= (2/len(str_res)*100):  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        result_res.append(line)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;elif&lt;/strong&gt;&lt;span&gt; fuzz_req-1 &amp;gt;= (2/len(str_req)*100):  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        result_req.append(line)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201901/1219242-20190130202848318-1996556783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    可以看出还是有一些小问题的。&lt;/p&gt;

&lt;p&gt;    基于概率匹配的信息分解受制于自定义匹配数据的完整性，尽管目前给出的几个关键词囊括了大部分的情况，不过仍然有相当多的漏网之鱼。&lt;/p&gt;
&lt;p&gt;    另外，fuzz库的模糊匹配并不能完美适配此次字符匹配，除了第三大点后给出的问题外，对长句中不同词语应该有不同的权重，以避免长居中词太多导致匹配失败。&lt;/p&gt;
&lt;p&gt;    不过最可喜的应该是，这次有了相对统一的数据，回头可以用这些数据去Spark上跑个模型，亲自操刀一下机器学习了，哈哈哈。&lt;/p&gt;

</description>
<pubDate>Wed, 30 Jan 2019 12:29:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>在现有的所有互联网招聘网站上，岗位信息里的所有条目都是在同一级标签下。因此，岗位信息作为一个整体，就需要额外的操作把要求与职责分离开。鉴于岗位信息里数据格式的不统一，因此博主放弃了使用正则表达式的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10339702.html</dc:identifier>
</item>
</channel>
</rss>