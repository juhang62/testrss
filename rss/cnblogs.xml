<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据可视化-svg入门基础（二） - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10897321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10897321.html</guid>
<description>&lt;p&gt;接上一篇：&lt;span&gt;&lt;a href=&quot;https://www.mwcxs.top/page/607.html&quot; target=&quot;_blank&quot;&gt;数据可视化-svg入门基础（一）&lt;/a&gt;，基础一主要是介绍了svg概念，元素样式设置等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;svg是（scalable vector graphic）伸缩矢量图像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）图形元素&lt;/p&gt;
&lt;p&gt;（2）文字元素&lt;/p&gt;
&lt;p&gt;（3）特殊元素&lt;/p&gt;
&lt;p&gt;（4）滤镜元素&lt;/p&gt;
&lt;p&gt;（5）渐变元素&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、图形元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、矩形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;矩形使用&amp;lt;rect&amp;gt;&amp;lt;/rect&amp;gt;标签来进行绘制。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25c8naDpir8Ms5L6nlrC39cU99.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;ry=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;（1）x：左上角x的坐标，距离左边的距离，相当于margin-left；&lt;/p&gt;
&lt;p&gt;（2）y：左上角y的坐标，距离顶部的距离，相当于margin-top；&lt;/p&gt;
&lt;p&gt;（3）width：矩形的宽度；&lt;/p&gt;
&lt;p&gt;（4）height：矩形的高度；&lt;/p&gt;
&lt;p&gt;（5）rx：圆角矩形，x轴方向的半径；&lt;/p&gt;
&lt;p&gt;（6）ry：圆角矩形，y轴方向的半径&lt;/p&gt;
&lt;p&gt;（7）fill：填充颜色&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、圆形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;圆形使用&amp;lt;circle&amp;gt;&amp;lt;/circle&amp;gt;标签来进行绘制。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25-FITb75rgq5nmIFUCdYVrL6Q.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;circle &lt;span class=&quot;hljs-attr&quot;&gt;cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;r=&lt;span class=&quot;hljs-string&quot;&gt;&quot;40&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;circle&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;（1）cx：圆形的x坐标；&lt;/p&gt;
&lt;p&gt;（2）cy：圆心的y做标；&lt;/p&gt;
&lt;p&gt;（3）r：半径&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、椭圆形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;椭圆形使用标签&amp;lt;ellipse&amp;gt;&amp;lt;/ellipse&amp;gt;标签进行绘制，与圆形的绘制方法类似。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/251TUxWTpnEsgFSneTPDWWk577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ellipse &lt;span class=&quot;hljs-attr&quot;&gt;cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;40&quot; &lt;span class=&quot;hljs-attr&quot;&gt;ry=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ellipse&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;cx：圆心的x坐标；&lt;/p&gt;
&lt;p&gt;cy：圆心的y坐标；&lt;/p&gt;
&lt;p&gt;rx：水平方向上的半径；&lt;/p&gt;
&lt;p&gt;ry：垂直方向上的半径&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、线段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线段使用&amp;lt;line&amp;gt;&amp;lt;/line&amp;gt;标签进行绘制。&lt;/p&gt;
&lt;p&gt;实例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;line &lt;span class=&quot;hljs-attr&quot;&gt;x1=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y1=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;x2=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y2=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;line&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x1：起点的x坐标；&lt;/p&gt;
&lt;p&gt;y1：起点的y坐标；&lt;/p&gt;
&lt;p&gt;x2：终点的x坐标；&lt;/p&gt;
&lt;p&gt;y2：终点的y坐标&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、折线和多边形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;折线和多边形的绘制方法类似，都是&lt;strong&gt;用points属性设置各个点的坐标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;折线使用标签&amp;lt;polyline&amp;gt;&amp;lt;/polyline&amp;gt;进行绘制，而多边形使用标签&amp;lt;polygon&amp;gt;&amp;lt;/polygon&amp;gt;进行绘制，且多边形会将起点和终点连接起来，折线不会。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25BNqvOW1MP-3H_7S3S2avqUS_.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;ponits：设置各个点的坐标，各组坐标之间使用空格分隔，x坐标和y坐标之间使用逗号分开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路径使用标签&amp;lt;path&amp;gt;&amp;lt;/path&amp;gt;进行绘制，使用d属性控制路径的类型和绘制。路径的功能最多，前面的所有图形都可以使用路径进行绘制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d属性值&lt;/strong&gt;的书写有两种，使用逗号分隔坐标，如：d=&quot;M10, 10&quot;，也可以使用空格的形式，如：d=&quot;M 10 10&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：大写字母：表示坐标系中使用绝对坐标，小写字母：使用相对坐标（相对当前画笔所在的点）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1移动类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;M：moveto，将画笔移动到指定坐标，如：d=&quot;M10,10&quot;，表示将画笔移动到坐标(10,10)的位置。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25BK3EhVKiWd4YzJJGU9Quj_zR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M 10 10 L 180 180&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
   &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.2绘制直线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;L：lineto，绘制直线到指定坐标，如：d=&quot;M 10 10 L 80 80&quot;，表示绘制一条起点坐标为(10,10)，终点坐标为(80,80)的直线。&lt;/p&gt;
&lt;p&gt;H：horizontal  lineto，绘制水平直线到指定坐标，如：d=&quot;M 10 10 H 100&quot;，表示是绘制一条起点坐标为(10,10)，终点坐标为(100,10)的直线，注意：H只需要设置一个值，如果设置了多个值，则最后取最后一个值。&lt;/p&gt;
&lt;p&gt;V：vertical，绘制垂直直线到指定坐标，如：d=&quot;M 10 10 V 100&quot;，表示绘制一条起点坐标(10,10)，终点坐标为(10,100)的直线，注意：V只需要设置一个值，如果是多个值，则取最后一个值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.3绘制曲线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C：curveto，绘制三次方贝塞尔曲线到终点坐标，中间经过两个控制点控制曲线的弧度，所以需要制定三个坐标来实现绘制曲线，如：d=&quot;M10,10 C40,5 40,140 100,100&quot;&lt;/p&gt;
&lt;p&gt;S：shorthand/smooth curveto，绘制平滑三次方贝塞尔曲线到终点坐标，与上一条三次方贝塞尔曲线相连，第一个控制点为上一条曲线第二个控制点的对称点，所以还需制定一个控制点坐标和终点坐标。如：d=&quot;M10,10 C40,5 40,140 100,100 S140,180 160,160&quot;，如果不与贝塞尔曲线相连，即：&lt;code&gt;d=&quot;M10,10 S140,180 160,160&quot;&lt;/code&gt;，则绘制的图线接近于二次贝塞尔曲线&lt;/p&gt;
&lt;p&gt;Q：quadratic Bezier curveto，绘制二次贝塞尔曲线到终点坐标，中间经过一个控制点控制曲线的弧度，如：&lt;code&gt;d=&quot;M10,10 Q40,140 100,100&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;T：shorthand/smooth quadratic Bezier curveto，绘制平湖二次贝塞尔曲线到终点坐标，与上一条二次贝塞尔曲线相连，控制点为上一条曲线控制点的对称点，所以还需指定一个终点坐标，如：&lt;code&gt;d=&quot;M10,10 Q40,140 100,100 T160,160&quot;&lt;/code&gt;，如果不与贝塞尔曲线相连，即：&lt;code&gt;d=&quot;M10,10 T160,160&quot;&lt;/code&gt;，则绘制的图线是一条直线。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/255OVGtyxAMErS5_K9x58h8MeR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.4绘制弧线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：el liptical arc，绘制椭圆曲线到指定坐标，需设置的参数有：&lt;/p&gt;
&lt;p&gt;（1）rx，ry：x轴方向半径，y轴方向半径；&lt;/p&gt;
&lt;p&gt;（2）x-axis-rotation：x轴与水平顺时针方向夹角；&lt;/p&gt;
&lt;p&gt;（3）large-arc-flag：角度弧线大小(1：大，0：小)；&lt;/p&gt;
&lt;p&gt;（4）sweep-flag：绘制方向(1：顺时针，0：逆时针)；&lt;/p&gt;
&lt;p&gt;（5）x y：终点坐标&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/2531Bh_qezmbbyvfpl7naL_1yd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;500&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;500&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M50,50 A60 30 0 1,0 150,50 Z&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4px&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：起点坐标(50,50)，终点坐标(150,50)，角度为0，角度弧线大小large-arc-flag为1，选择大弧度，根据分析，即选择红色的弧线，又绘制方向sweep-flag为0，为逆时针，即从起点沿着逆时针方向绘制到终点，所以是红色虎先位于下方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25Zgms5XiFsD46jdWS8OtvqyG7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：当 (起点与终点之间的直线距离／2) &amp;gt; (椭圆的水平半径) 时，角度为0的情况下，此时椭圆会等比放大，到相等为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.5闭合类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Z：closepath，绘制直线将终点与起点连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次提醒：大写字母：表示坐标系中使用绝对坐标，小写字母：使用相对坐标（相对当前画笔所在的点）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、文字元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在svg中使用&amp;lt;text&amp;gt;&amp;lt;/text&amp;gt;标签绘制文字。&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x：文字的x坐标；&lt;/p&gt;
&lt;p&gt;y：文字的y坐标；&lt;/p&gt;
&lt;p&gt;dx：相对于当前位置x方向的距离；&lt;/p&gt;
&lt;p&gt;dy：相对于当前位置的y方向的距离；&lt;/p&gt;
&lt;p&gt;textLength：文字的显示长度；&lt;/p&gt;
&lt;p&gt;rotate：旋转角度，也可以使用transform=&quot;rotate(30)&quot;&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25sFxc5Pc9GhxEFUPR2pvVLbW9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;text &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;dx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;dy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;textLength=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rotate=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&amp;gt;示例文字&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;text&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2、文本路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要实现文字沿着路径进行排列，可使用&amp;lt;textPath&amp;gt;&amp;lt;/textPath&amp;gt;标签来实现。需要提前定义好路径path，并指定id，textPath使用xlink:href定义文字要匹配的路径。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gt-dM_wTfbAYOTzxIlZ5BSIf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;600&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;600&quot;&amp;gt;
        &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;textPath1&quot; &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M100,100 C140,50 140,240 200,200 S240,280 360,360&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4px&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
        &amp;lt;text x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; dx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-10&quot; dy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-10&quot; rotate=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&amp;gt;
          &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;textPath &lt;span class=&quot;hljs-attr&quot;&gt;xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#textPath1&quot; &lt;span class=&quot;hljs-attr&quot;&gt;textLength=&lt;span class=&quot;hljs-string&quot;&gt;&quot;300&quot;&amp;gt;
            很扭曲的测试示例文字
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;textPath&amp;gt;
        &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/text&amp;gt;
      &amp;lt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、特殊元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、克隆元素use&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt;标签用来克隆其他元素，克隆后的元素不能修改样式。 示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25dzTXQNGnSga8L1S3BKst5GOS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;rect1&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;
  &amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &amp;lt;use x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#rect1&quot;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;use&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x：相对被克隆元素x轴偏移量；&lt;/p&gt;
&lt;p&gt;y：相对被克隆元素y轴偏移量；&lt;/p&gt;
&lt;p&gt;xlink:href：指向被克隆元素的ID&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、模板元素symbol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;symbol&lt;/code&gt;标签用定义模版，需要结合&lt;code&gt;use&lt;/code&gt;标签使用，模版在未被使用之前，不会展示在页面上。模版内部可包含多个元素&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;symbol &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;template1&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;
          &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot;
          &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;
    &amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;symbol&amp;gt;
  &amp;lt;use x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#template1&quot;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;use&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3、组元素g&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group&lt;/code&gt;的简写，用来创建分组，&lt;strong&gt;组内所有的元素都会继承&lt;code&gt;g&lt;/code&gt;的属性，可以嵌套使用&lt;/strong&gt;，也可以和&lt;code&gt;use&lt;/code&gt;标签结合使用。另外可使用transform属性定义控制整个组的位置。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;g &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;g&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt;标签内部的两个矩形，都会继承&lt;code&gt;g&lt;/code&gt;标签的样式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、clipPath裁剪元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lipPath&lt;/code&gt;元素主要用来剪裁元素，&lt;code&gt;clipPath&lt;/code&gt;元素定义范围外的内容将不会被展示。另外要注意写在&lt;code&gt;&amp;lt;clipPath&amp;gt;&amp;lt;/clipPath&amp;gt;&lt;/code&gt;标签内部的元素不会被显示，clipPath标签需要放在defs标签内。其他元素在引用clipPath元素时，需要使用&lt;code&gt;clip-path=&quot;url(#ID)&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;defs&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;clipPath &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;clip&quot;&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;clipPath&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;defs&amp;gt;
    &amp;lt;circle cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; r=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; clip-path=&lt;span class=&quot;hljs-string&quot;&gt;&quot;url(#clip)&quot; stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;none&quot; fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot; /&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25rps4ldeJhPPawOFN3z3BmSMZ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/257E0NtUaDFefMyJRg5jgWSIpH.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 May 2019 15:33:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>接上一篇：数据可视化-svg入门基础（一），基础一主要是介绍了svg概念，元素样式设置等。 svg是（scalable vector graphic）伸缩矢量图像。 一、目录 （1）图形元素 （2）文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10897321.html</dc:identifier>
</item>
<item>
<title>使用Try.NET创建可交互.NET文档 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10894497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10894497.html</guid>
<description>&lt;blockquote readability=&quot;2.5357142857143&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/creating-interactive-net-documentation/&quot;&gt;Create Interactive .NET Documentation with Try .NET&lt;/a&gt;&lt;br/&gt;原文作者：Maria&lt;br/&gt;译文地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10894497.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10894497.html&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们编写开发人员使用的文档时，我们需要捕捉他们的兴趣，并引导他们尽快走上成功的道路。开发人员生态系统一直在为社区提供可交互的文档，用户可以一个地方阅读文档，运行代码并进行编辑。&lt;/p&gt;
&lt;p&gt;在过去的2年里，.NET语言团队一直在不断发展Try .NET, 以支持在线和离线的交互式文档。&lt;/p&gt;

&lt;p&gt;Try .NET是一个基于.NET Core的交互式文档生成器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230645016-1266379729.png&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2017年9月，Try .NET第一次在&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/&quot;&gt;docs.microsoft.com&lt;/a&gt;中使用，开发人员可以使用Azure Container实例运行代码。然而在过去的5个月内，我们改用Blazor和Web Assembly作为代码执行客户端。&lt;/p&gt;
&lt;p&gt;你可以自己访问如下&lt;a href=&quot;https://docs.microsoft.com/dotnet/csharp/tutorials/intro-to-csharp/hello-world?tutorial-step=5&quot;&gt;链接&lt;/a&gt;, 并打开开发者工具。在控制台标签页中，你可以看到如下信息&lt;code&gt;WASM:Initialized&lt;/code&gt;, 切换到网络标签页，你将看到所有在客户端执行的DLL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230736840-1047370574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台标签页： &lt;code&gt;*WASM Initialized*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230744627-197226262.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络标签页： DLLs&lt;/p&gt;

&lt;p&gt;对我们而言，离线版和在线版一样的重要。针对离线体验，对我们而言，创建一种可以融入内容作者工作流程的体验是非常重要的。&lt;/p&gt;
&lt;p&gt;在我们的调查结果中，我们注意到内容开发人员(content developers)在创建开发人员文档时，经常使用2种说明方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个用户可以下载并运行的实例。&lt;/li&gt;
&lt;li&gt;一些Markdown文件，其中包含一系列说明，以及从代码库复制黏贴的的代码片段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Try .NET提供了全局工具dotnet try, 以方便.NET开发人员创建可交互的Markdown文件。&lt;/p&gt;
&lt;p&gt;为了使你的Markdown文件具有交互性，你需要安装.NET Core的SDK, 全局工具dotnet try, 以及Visual Studio / VS Code。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230754830-708974414.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;扩展markdown&quot;&gt;扩展Markdown&lt;/h2&gt;
&lt;p&gt;在Markown文件中，你会使用隔离代码块来突出显示代码段。在代码块的前后，你会使用```来包裹它们。你可以添加可选的语言标识符，启用针对代码段的语法突出显示。&lt;/p&gt;
&lt;p&gt;例：C#的代码块&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;​``` cs 
var name =&quot;Rain&quot;;
Console.WriteLine($&quot;Hello {name.ToUpper()}!&quot;);
​```&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Try .NET, 我们可以扩展隔离代码块，给它添加一些额外的参数。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;​``` cs --region methods --source-file .\myapp\Program.cs --project .\myapp\myapp.csproj 
var name =&quot;Rain&quot;;
Console.WriteLine($&quot;Hello {name.ToUpper()}!&quot;);
​```&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用了3个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;--region&lt;/code&gt;参数 - 指定一个C#的分块(region)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--source-file&lt;/code&gt;参数 - 指定程序文件的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--project&lt;/code&gt;参数 - 指定项目文件和引用的系统程序集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，以上示例中，我们做的事情是，当你运行Try .NET的解析你的Markdown文件的时候，程序会去尝试引用&lt;code&gt;Program.cs&lt;/code&gt;文件中名为&lt;code&gt;methods&lt;/code&gt;的分块代码。&lt;/p&gt;
&lt;h2 id=&quot;使用regions&quot;&gt;使用&lt;code&gt;#regions&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在Markdown中，我们扩展了代码块，提供了&lt;code&gt;--region&lt;/code&gt;参数，用它可以指定C#代码中的分块(region)。&lt;br/&gt;所以，你的&lt;code&gt;Program.cs&lt;/code&gt;文件看起来可能是这样的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
 
namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            #region methods
            var name =&quot;Rain&quot;
            Console.WriteLine($&quot;Hello{name.ToUpper()}!&quot;);  
            #endregion
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dotnet-try-verify&quot;&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;是一个文档编译器。使用这个命令，你可以确保每个代码块都能正常工作，并且和项目代码保持一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;命令的目的是为了验证你的文档按照你期望的样子工作。&lt;/p&gt;
&lt;p&gt;通过使用&lt;code&gt;dotnet try verify&lt;/code&gt;命令，你可以检测Markdown文件并编译错误。例如，如果我将之前代码中移除一个分号，并且将&lt;code&gt;methods&lt;/code&gt;代码分块改名为&lt;code&gt;method&lt;/code&gt;。现在如果运行编译器，会出现以下错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230807292-2140650136.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dotnet try&lt;/code&gt;现在已经可以使用了。这是一个&lt;code&gt;dotnet try&lt;/code&gt;全局工具的早期预览版，你可以从我们的&lt;a href=&quot;https://github.com/dotnet/try&quot;&gt;仓储&lt;/a&gt;克隆代码。&lt;/p&gt;
&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;克隆代码仓储&lt;/li&gt;
&lt;li&gt;签出Samples分支&lt;/li&gt;
&lt;li&gt;安装.NET Core 2.1或3.0预览版&lt;/li&gt;
&lt;li&gt;打开控制台窗口&lt;/li&gt;
&lt;li&gt;安装Try .NET全局工具&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet tool install --global dotnet-try --version 1.0.19264.11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新&lt;code&gt;dotnet try&lt;/code&gt;也很简单，只需要运行如下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet tool update -g dotnet-try&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定位到当前仓储的&lt;code&gt;Samples&lt;/code&gt;目录，输入&lt;code&gt;dotnet try&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230821702-604534020.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器会自动打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230834097-1152273812.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在Try.NET已经在Github上开源了！由于我们仍处于早期开发阶段，所以目前我们无法接受任何功能的Pull Request, 但我们打算在未来这么做。请随时在我们的Issue列表中提交Bug报告。 如果你有任何功能建议，请在我们的Issue列表中使用社区建议的标签提交。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 15:14:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文地址： 'Create Interactive .NET Documentation with Try .NET' 原文作者：Maria 译文地址： 译者：Lamond Lu 背景 当我们编写开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10894497.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第20期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10896597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10896597.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;2019年理事会活动&quot; &quot;&quot;实用的F 挑战&quot;意见截止日期接近，不要忘记提交博客文章或者其它作品&quot; &quot;接口中的默认实现&quot; &quot;.NET Core 3.0里的性能增强&quot; &quot;使用Try .NET创建交互性.NET文档&quot; &quot;新的Azure搜索文档包含F 示例&quot; &quot;eiriktsarpalis/dotn</description>
<pubDate>Mon, 20 May 2019 15:14:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '2019年理事会活动' ''实用的F 挑战'意见截止日期接近，不要忘记提交博客文章或者其它作品' '接口中的默认实现' '.NET Core 3.0里的性能增强' '使用Try .NET创建交</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10896597.html</dc:identifier>
</item>
<item>
<title>打通电商多模式支持的“任督二脉” - 程序猿攻城狮</title>
<link>http://www.cnblogs.com/syjkfind/p/10897012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/syjkfind/p/10897012.html</guid>
<description>&lt;p&gt;你听说过任督二脉吗？像这样~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520220527179-450856610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咳咳~今天不讲武功，讲电商平台设计的功夫~&lt;/p&gt;

&lt;p&gt;当今的电商可不仅仅是B2C商城，接下来还会有O2O，往后可能还会有商超、奥莱、二手交易。。。且称之为业务模式~而每个业务模式下还会有预售、竞拍、拼团等不同组合的子模式。&lt;/p&gt;
&lt;p&gt;可是我商城的商品列表页不想展示O2O的商品啊，商品列表的数据希望按一定规则相互隔离。其他模块，有的出于操作习惯的考虑不隔离，有的出于用户行为的考虑需要隔离。&lt;/p&gt;
&lt;p&gt;各模块数据隔离需求如下&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;列表页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;商详页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;商品组&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;优惠券&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;活动&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;订单&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;原商城&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;O2O&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;各模块流程差异&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;新建商品&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;列表页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;购物车&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;订单&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;原商城&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;店铺创建，门店设置库存&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;基于item建es文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;跨门店&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;状态流转走快递&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;O2O&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;门店创建（沿用原模型但弱化店铺的概念）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;基于item建es文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;单个门店&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;状态流转走配送&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;于是我们就会面临不同的改造的场景。&lt;/p&gt;
&lt;h2&gt;场景1，新建商品就是新建商品啊！！！&lt;/h2&gt;
&lt;p&gt;例如商品的新建保存，是基础服务，已经具备通用存储模型。为了支持新模式我还得改服务接口、发布二方包？咱可不可以这样？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商品服务&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Integer bizMode =&lt;span&gt; BizModeContext.getBizMode();
itemDO.setBizMode(bizMode);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
itemDAO.save(itemDO);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;场景2，下单就是下单啊！！！&lt;/h2&gt;
&lt;p&gt;例如创建订单，虽然商品维度、订单类型、优惠方式有很多，但我修改一下B2C下单的字段计算，还要引发O2O模式的回归测试？咱可不可以这样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520221344079-1849689801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;甚至这样~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类路由&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@BizModeService( bizMode=BizMode.B2C, srvClz=OrderTradeService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MallOrderTradeServiceImpl &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractOrderTradeService { }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用时&lt;/span&gt;
Integer bizMode =&lt;span&gt; BizModeContext.getBizMode();
OrderTradeService srv &lt;/span&gt;= BizModeRouter.routeBean(bizMode, OrderTradeService.&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;眼尖的小哥哥可能已经发现，要是能再搭配个热加载的bean容器，都可以做成插件了！emmm...那是远景~&lt;/p&gt;


&lt;p&gt;首先要舌尖抵住上颚，再来三个深呼吸~然后拿起一本《Thinking In Java》或《Core Java》假装在修炼。。。等等。。。什么是任督二脉？&lt;/p&gt;
&lt;p&gt;Java老司机都知道，我们通常会把ApplicationContext比作Spring的任督二脉，它贯穿始终，管理着bean的生命周期和传递。&lt;/p&gt;
&lt;p&gt;所以电商平台的任督二脉就是BizModeContext啦！它的经脉图大概长这样~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/syjkfind/p/10897012.html&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520221709549-1638679454.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们通过下面一二三四，入口处打标、dubbo服务间传递、RocketMQ传递、本机线程池内传递，一步一步打通整个标的透传。&lt;/p&gt;
&lt;h2&gt;步骤1-打标&lt;/h2&gt;
&lt;p&gt;aop按包路径切面+注解覆盖，满足你不同的定制需求~于是，在用户点击页面操作的那一刻，每个接口都被打上了“模式标”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注解打标&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerConfig {
        @Aspect
        @Component
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CxcAdvice &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BizModeControllerAspect {
                 @Override
                 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getBizMode() {
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 300&lt;span&gt;;
                 }
                 @Override
                 @Pointcut(&lt;/span&gt;&quot;execution(* com.mall.web.controller..*(..))&quot;&lt;span&gt;)
                 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointcut() {
                 }
        }
}
 
@Slf4j
@RestController
@MarkBizMode(bizMode &lt;/span&gt;= 200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminOldController2 {
        @RequestMapping(&lt;/span&gt;&quot;/admin_anno_byclass&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String annoByClass() {
                 log.info(&lt;/span&gt;&quot;annoByClass got bizmode: &quot; +&lt;span&gt; BizModeContext.getBizMode());
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;this is &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().toString();
        }
        @RequestMapping(&lt;/span&gt;&quot;/admin_anno_bymethod&quot;&lt;span&gt;)
        @MarkBizMode(bizMode &lt;/span&gt;= 100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String annoByMethod() {
                 log.info(&lt;/span&gt;&quot;annoByMethod got bizmode: &quot; +&lt;span&gt; BizModeContext.getBizMode());
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;this is &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().toString();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;步骤2-dubbo服务传递&lt;/h2&gt;
&lt;p&gt;借助dubbo自带的Filter和RpcContext可以轻松实现。那是因为dubbo的设计中已经充分考虑了。&lt;/p&gt;
&lt;h3&gt;Filter的使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Activate(group =&lt;span&gt; Constants.CONSUMER)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BizModeDubboConsumerFilter &lt;span&gt;implements&lt;/span&gt; Filter { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;filter配置扫描发现： /src/main/resources/META-INF/dubbo/com.alibaba.dubbo.rpc.Filter&lt;/p&gt;
&lt;p&gt;filter的装配原理： List&amp;lt;Filter&amp;gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);&lt;/p&gt;
&lt;p&gt;dubbo的SPI扩展机制就不具体展开啦~&lt;/p&gt;
&lt;h3&gt;RpcContext的生命周期&lt;/h3&gt;
&lt;p&gt;RpcContext -&amp;gt; RpcInvocation ---服务调用--- RpcInvocation -&amp;gt; RpcContext&lt;/p&gt;
&lt;p&gt;业务扩展的调用：RpcContext.getContext().setAttachment(&quot;bizMode&quot;, (bizMode.toString()));&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RpcContext.java&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个线程隔离的上下文实例&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InternalThreadLocal&amp;lt;RpcContext&amp;gt; LOCAL = &lt;span&gt;new&lt;/span&gt; InternalThreadLocal&amp;lt;RpcContext&amp;gt;&lt;span&gt;() {
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; RpcContext initialValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcContext();
        }
    };
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RpcContext getContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LOCAL.get();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dubbo对attachment的传递：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本机（当前线程）的保存：RpcContext&lt;/li&gt;
&lt;li&gt;远程调用的保存和传递：RpcInvocation&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;将RpcContext存入RpcInvocation：AbstractInvoker&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractInvoker&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Invoker&amp;lt;T&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result invoke(Invocation inv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RpcException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; context =&lt;span&gt; RpcContext.getContext().getAttachments();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          invocation.addAttachmentsIfAbsent(context);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)){
          invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
        }
        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return ...&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; Result doInvoke(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;序列化与反序列化：DubboCodec （此处不展开）&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;从RpcInvocation取出，存入提供方的RpcContext：ContextFilter&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@Activate(group = Constants.PROVIDER, order = -10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ContextFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result invoke(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RpcException {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; attachments =&lt;span&gt; invocation.getAttachments();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
&lt;span&gt;                RpcContext.getContext().getAttachments().putAll(attachments);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            RpcResult result &lt;/span&gt;=&lt;span&gt; (RpcResult) invoker.invoke(invocation);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pass attachments to result&lt;/span&gt;
&lt;span&gt;            result.addAttachments(RpcContext.getServerContext().getAttachments());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            RpcContext.removeContext();
            RpcContext.getServerContext().clearAttachments();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;步骤3-RocketMQ传递&lt;/h2&gt;
&lt;p&gt;RocketMQ设计时也预留了扩展打标的能力，只需要把模式标存入属性字段，就能跟随MQ把标传递到消费方。&lt;/p&gt;
&lt;h3&gt;消息体数据结构&lt;/h3&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.rocketmq.common.message.Message&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;private String topic;&lt;br/&gt;private int flag;&lt;br/&gt;private Map&amp;lt;String, String&amp;gt; properties;&lt;br/&gt;private byte[] body;&lt;/p&gt;

&lt;p&gt;//填入属性，仅包可见&lt;br/&gt;void putProperty(final String name, final String value);&lt;/p&gt;
&lt;p&gt;//填入自定义属性，与其他属性共享map，但对key过滤保留字&lt;br/&gt;public void putUserProperty(final String name, final String value);&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.rocketmq.common.message.MessageExt&lt;/p&gt;
&lt;p&gt;是Message的子类&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt; private int queueId;&lt;/p&gt;
&lt;p&gt;private int storeSize;&lt;/p&gt;
&lt;p&gt;private long queueOffset;&lt;br/&gt;private int sysFlag;&lt;br/&gt;private long bornTimestamp;&lt;br/&gt;private SocketAddress bornHost;&lt;/p&gt;
&lt;p&gt;private long storeTimestamp;&lt;br/&gt;private SocketAddress storeHost;&lt;br/&gt;private String msgId;&lt;br/&gt;private long commitLogOffset;&lt;br/&gt;private int bodyCRC;&lt;br/&gt;private int reconsumeTimes;&lt;/p&gt;
&lt;p&gt;private long preparedTransactionOffset;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;因此，可以在消息体的 Map&amp;lt;String, String&amp;gt; properties 属性上附加打标信息。&lt;/p&gt;

&lt;h3&gt;发消息的扩展钩子&lt;/h3&gt;
&lt;p&gt;org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.registerSendMessageHook(SendMessageHook)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222335898-565093332.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;收消息的扩展钩子&lt;/h3&gt;
&lt;p&gt;org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.registerConsumeMessageHook(ConsumeMessageHook)&lt;/p&gt;
&lt;p&gt;但由于收消息是一批一批收的，收到的是消息列表 List&amp;lt;MessageExt&amp;gt;，默认配置下只有一个元素，但允许配置多个，因此不能在这个钩子上做扩展。&lt;/p&gt;
&lt;p&gt;因此，对starter做改造，在单个消息消费的位置增加了类似的hook扩展点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConsumerHook&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ConsumeOneMessageAdvice {
    String hookName();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; consumeMessageBefore(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageExt msg);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; consumeMessageAfter(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageExt msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;步骤4-线程池子线程传递&lt;/h2&gt;
&lt;p&gt;BizModeContext的原理是用ThreadLocal存储线程范围的上下文，可是实际场景中，总会有些异步和并发的问题，需要使用到线程池。那么问题来了。&lt;/p&gt;
&lt;h3&gt;父线程context如何传递给子线程&lt;/h3&gt;
&lt;p&gt;jdk自带InheritableThreadLocal类解决了父子线程传递的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thread.init()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Thread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(ThreadGroup g, Runnable target, String name,
                      &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize, AccessControlContext acc,
                      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; inheritThreadLocals) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        Thread parent =&lt;span&gt; currentThread();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;span&gt;
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
&lt;span&gt;    }
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程创建时会把父线程的ThreadLocalMap复制到子线程中&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadLocalMap(ThreadLocalMap parentMap) {
            Entry[] parentTable &lt;/span&gt;=&lt;span&gt; parentMap.table;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; parentTable.length;
            setThreshold(len);
            table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[len];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; len; j++&lt;span&gt;) {
                Entry e &lt;/span&gt;=&lt;span&gt; parentTable[j];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                    ThreadLocal&lt;/span&gt;&amp;lt;Object&amp;gt; key = (ThreadLocal&amp;lt;Object&amp;gt;&lt;span&gt;) e.get();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        Object value &lt;/span&gt;=&lt;span&gt; key.childValue(e.value);
                        Entry c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(key, value);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = key.threadLocalHashCode &amp;amp; (len - 1&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (table[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            h &lt;/span&gt;=&lt;span&gt; nextIndex(h, len);
                        table[h] &lt;/span&gt;=&lt;span&gt; c;
                        size&lt;/span&gt;++&lt;span&gt;;
                    }
                }
            }
        }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;线程池中子线程复用时怎样维护context&lt;/h3&gt;
&lt;p&gt;但如果使用了线程池，子线程运行完并不会销毁，被另一个父线程复用时不会重新初始化。&lt;/p&gt;
&lt;p&gt;这时候我们需要借助一个开源框架 TransmittableThreadLocal  &lt;a href=&quot;https://github.com/alibaba/transmittable-thread-local&quot;&gt;https://github.com/alibaba/transmittable-thread-local&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222601054-1765333315.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;563&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来自官网）&lt;/p&gt;
&lt;p&gt;在获取子线程时重新读取父线程的上下文，子线程run()执行结束时清理子线程的上下文。&lt;/p&gt;

&lt;p&gt;打通模式标的透传后，能怎么使用呢？大家可以尽情发挥下想象力~何时何地只需要 BizModeContext.getBizMode()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志MDC打标：可以统一给日志记录加入模式标。&lt;/li&gt;
&lt;li&gt;sql自动追加查询条件：通过mybatis插件扩展或甚至是数据源代理，可以给sql自动追加隔离标条件（虽然具体业务中并不那么好用）。&lt;/li&gt;
&lt;li&gt;全链路监控或压测：是的，如果打标的不是bizMode，而是traceId或影子标，就可以通过这个“任督二脉”透传整个系统！&lt;/li&gt;
&lt;li&gt;新模式插件化接入：各业务板块逐渐模块化后，可以通过给扩展点开发实现类的形式接入新模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;远景-多模式插件化部署&lt;/h2&gt;
&lt;p&gt;我们期望，未来新的业务模式接入，就像安装插件一样无痛无感知。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222710563-846874075.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新模式接入，只需要增加部署新的bizmodeX节点，其他业务不需要回归测试。&lt;/p&gt;
&lt;p&gt;某个业务，例如bizmode100，部署重启时，其他业务不受影响。&lt;/p&gt;
&lt;p&gt;这还需要一步一步来，目前我们先实现了“任督二脉”的打通，后面的故事，敬请期待哦~&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 14:30:00 +0000</pubDate>
<dc:creator>程序猿攻城狮</dc:creator>
<og:description>你听说过任督二脉吗？像这样~ 咳咳~今天不讲武功，讲电商平台设计的功夫~ 背景 当今的电商可不仅仅是B2C商城，接下来还会有O2O，往后可能还会有商超、奥莱、二手交易。。。且称之为业务模式~而每个业务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/syjkfind/p/10897012.html</dc:identifier>
</item>
<item>
<title>学习RadonDB源码（二） - wingsless</title>
<link>http://www.cnblogs.com/wingsless/p/10896517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wingsless/p/10896517.html</guid>
<description>&lt;h2 id=&quot;为我新的一天没有放弃而喝彩&quot;&gt;1. 为我新的一天没有放弃而喝彩&lt;/h2&gt;
&lt;p&gt;学习是一件很容易放弃的事情，因为就算是不学，我也能在现在的岗位上发光发热。可是人不就是一个热爱折腾的种群吗？&lt;/p&gt;
&lt;p&gt;今天没有放弃不代表明天没有放弃，也许放弃的可能性大于坚持的可能性，不管怎样，坚持一天算一天。&lt;/p&gt;
&lt;p&gt;RadonDB面对着TiDB，OceanBase等等数据库的竞争，都是分布式数据库，为什么要首先学习RadonDB呢？毕竟这是一款真的基于MySQL而不是兼容MySQL的产品，通过学习RadonDB，也许有一天我能在其源码上做出点什么贡献也未可知，我起码对MySQL的熟悉程度更高。&lt;/p&gt;
&lt;h2 id=&quot;继续昨天的话题&quot;&gt;2. 继续昨天的话题&lt;/h2&gt;
&lt;p&gt;昨天我写到了程序的主入口，注意其最重要的一句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Proxy.
    proxy := proxy.NewProxy(log, flagConf, build.Tag, conf)
    proxy.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切都是从这里开始的，为什么这么说呢？&lt;/p&gt;
&lt;p&gt;这一启动，就好像启动了一个mysqld一样，可以正常的接收mysql客户端的连接请求。&lt;/p&gt;
&lt;p&gt;根据昨天讲述的，proxy的启动实际上是执行了Accept方法，而Accept则是以服务形式启动起来，并且监听了几个端口的。&lt;/p&gt;
&lt;p&gt;那我们再来看看Accept方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Accept runs an accept loop until the listener is closed.
func (l *Listener) Accept() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for {
        conn, err := l.listener.Accept()
        if err != nil {
            // Close() was probably called.
            return
        }
        ID := l.connectionID
        l.connectionID++
        go l.handle(conn, ID, l.serverVersion)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码逻辑上看，只要没有执行Close，就会一直循环监听下去，监听的就是一个一个的网络连接请求。&lt;/p&gt;
&lt;p&gt;我猜测这里的连接就好像是我们在MySQL中执行“show processlist”的时候，显示的信息，每来一个连接，就会给它分配一个ID，并启动一个监听器的handler goroutine，可以理解为启动了一个线程，这个线程专门负责该连接。&lt;/p&gt;
&lt;p&gt;到这里我们就可以肯定，RadonDB也是一个单进程多线程的架构，和MySQL并无二致。&lt;/p&gt;
&lt;p&gt;现在就可以分析分析handler方法到底做了什么。这个方法很长很长，我实在是不能一行一行的粘贴过来，只是捡一些有代表性的讲讲。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// handle is called in a go routine for each client connection.
func (l *Listener) handle(conn net.Conn, ID uint32, serverVersion string) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先映入眼帘的一定是注释，良好的代码一定拥有良好的注释。注释告诉我们，这个handler方法是处理每个客户端连接的。&lt;/p&gt;
&lt;p&gt;客户端连接嘛，每个DBA都知道，连接上来就是为了执行SQL的命令的，有一般的DDL，DML还有些指令性命令。&lt;/p&gt;
&lt;p&gt;那么我推断代码里一定有一个switch分支用于对每种命令进行处理：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;for {
        if data, err = session.packets.Next(); err != nil {
            return
        }

        // Update the session last query time for session idle.
        session.updateLastQueryTime(time.Now())
        switch data[0] {
        // COM_QUIT
        case sqldb.COM_QUIT:
            return
            // COM_INIT_DB
        case sqldb.COM_INIT_DB:
            db := l.parserComInitDB(data)
            if err = l.handler.ComInitDB(session, db); err != nil {
                if werr := session.writeErrFromError(err); werr != nil {
                    return
                }
            } else {
                session.SetSchema(db)
                if err = session.packets.WriteOK(0, 0, session.greeting.Status(), 0); err != nil {
                    return
                }
            }
            // COM_PING
        case sqldb.COM_PING:
            if err = session.packets.WriteOK(0, 0, session.greeting.Status(), 0); err != nil {
                return
            }
            // COM_QUERY
        case sqldb.COM_QUERY:
            query := l.parserComQuery(data)
            if err = l.handler.ComQuery(session, query, nil, func(qr *sqltypes.Result) error {
                return session.writeTextRows(qr)
            }); err != nil {
                log.Error(&quot;server.handle.query.from.session[%v].error:%+v.query[%s]&quot;, ID, err, query)
                if werr := session.writeErrFromError(err); werr != nil {
                    return
                }
            }
//省略其他&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还真的是有，逻辑也不复杂，其实刚才的代码里没有展现出session的概念，先讲讲session在回过头来讲刚才的代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;session := newSession(log, ID, l.serverVersion, conn)
//省略一些session的检查等操作

l.handler.SessionInc(session)
defer l.handler.SessionDec(session)

// Reset packet sequence ID.
session.packets.ResetSeq()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心思想就是新建了一个session，之后，才有了刚才的操作，要从session中拿出用户操作来，放在一个叫做data的切片中，然后判断切片中具体的操作类型。&lt;/p&gt;
&lt;p&gt;到这里应该很多人都会知道，RadonDB到底做了一个什么样的入口了，其实就是做了一个自己的MySQL服务，监听特定的端口，接收用户的操作。&lt;/p&gt;
&lt;p&gt;这里所有的代码都可以参考以下这个github项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xelabs/go-mysqlstack&quot;&gt;go-mysqlstack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者也是RadonDB的作者之一。这个go-mysqlstack的目的也很简单，就是实现一个mysqld：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-47734bfccb6a1cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简介&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方给的示例，就是启动了一个服务端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-32d9f659e2dd904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于交付的客户来说，其实就是在用MySQL，只不过端口有变，服务的启动方式和配置方式不太一样，但是写代码还是用jdbc-driver，对于开发者来说没有任何变化。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;3. 小结&lt;/h2&gt;
&lt;p&gt;Go语言真有意思，利用已经成熟的项目来学习Go语言，我觉得比一点一点看书来的快一些。&lt;/p&gt;
&lt;p&gt;当然了，学会了写之后就要思考，思考这门语言，真的做到Thinking in Go。&lt;/p&gt;
&lt;p&gt;真是学而不思则罔。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 13:16:00 +0000</pubDate>
<dc:creator>wingsless</dc:creator>
<og:description>1. 为我新的一天没有放弃而喝彩 学习是一件很容易放弃的事情，因为就算是不学，我也能在现在的岗位上发光发热。可是人不就是一个热爱折腾的种群吗？ 今天没有放弃不代表明天没有放弃，也许放弃的可能性大于坚持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wingsless/p/10896517.html</dc:identifier>
</item>
<item>
<title>深入探究Java中equals()和==的区别是什么 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</guid>
<description>
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&quot;==&quot;相等判断符用于比较基本数据类型和引用类型数据. 当比较基本数据类型的时候比较的是数值, 当比较引用类型数据时比较的是引用(指针).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;判断基本类型是否相等.&quot;&gt;&quot;==&quot;判断基本类型是否相等.&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先基本数据类型指的是Java中的八大数据类型: byte, short, int, long, float, double, char, boolean&lt;/li&gt;
&lt;li&gt;这八大基本数据类型有个共同的特点是它们在内存中是有具体值的, 比如说一个int类型的数据&quot;2&quot;, 它在8位数据总线的机器上(假设的)保存形式为&lt;code&gt;0000 0010&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;当使用&quot;==&quot;比较两个基本数据类型的时候, 就是比较它们各自在内存中的值.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;判断引用类型数据是否相等&quot;&gt;&quot;==&quot;判断引用类型数据是否相等&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;引用数据类型在字面上也是很好理解的, 就是一个引用, 它会指向一个具体的对象.&lt;/li&gt;
&lt;li&gt;比如说&lt;code&gt;Student stu = new Student();&lt;/code&gt;, 这里的&lt;code&gt;stu&lt;/code&gt;就是一个引用, 它指向的是当前&lt;code&gt;new&lt;/code&gt;出来的&lt;code&gt;Student&lt;/code&gt;对象. 当我们想要操作这个&lt;code&gt;Student&lt;/code&gt;对象时, 只需要操作引用即可, 比如说&lt;code&gt;int age = stu.getAge();&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;所以用&quot;==&quot;判断两个引用数据类型是否相等的时候, &lt;strong&gt;实际上是在判断两个引用是否指向同一个对象&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;看下面的示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    String s1 = &quot;hello&quot;;    //s1指向常量池中的&quot;hello&quot;字符串
    String s2 = &quot;hello&quot;;    //s2也指向常量池中的&quot;hello&quot;字符串
    System.out.println(s1 == s2);   //true

    String s3 = new String(&quot;hello&quot;);   //s3指向的是堆内存中的字符串对象 
    System.out.println(s1 == s3);   //false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的例子可以看到, 由于引用&quot;s1&quot;和&quot;s2&quot;指向的都是常量池中的&quot;hello&quot;字符串, 所以返回true.&lt;/li&gt;
&lt;li&gt;而&quot;s3&quot;指向的是新创建字符串对象, 因为只要动用了&lt;code&gt;new&lt;/code&gt;关键字, 就会在堆内存创建一个新的对象,&lt;/li&gt;
&lt;li&gt;也就是说s1和s3指向的是不同的字符串对象, 所以返回false.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;equals()和&lt;code&gt;==&lt;/code&gt;有着本质的区别, &lt;code&gt;==&lt;/code&gt;可以看作是对操作系统比较数据手段的封装, 而equals()则是每个对象自带的比较方法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;equals()和&lt;code&gt;==&lt;/code&gt;的本质区别更通俗的说法是, &lt;code&gt;==&lt;/code&gt;的比较规则是定死的, 如上面所述; 而equals()的比较规则是不固定的, 可以由用户自己定义.&lt;/li&gt;
&lt;li&gt;看下面的例子:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    String s1 = &quot;hello&quot;;
    String s3 = new String(&quot;hello&quot;);    
    System.out.println(s1.equals(s3));  //true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在用&lt;code&gt;==&lt;/code&gt;比较的时候, 上面s1和s3比较出的结果为false. 而当用equals比较的时候, 得出的结果为true.&lt;/li&gt;
&lt;li&gt;想知道原因我们还得看源码, 下面是String类的equals()源码.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean equals(Object anObject) {
    if (this == anObject) { //先比较两个字符串的引用是否相等(是否指向同一个对象), 是直接返回true
        return true;
    }
    if (anObject instanceof String) {   //两个引用不等还会继续比较
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;  //字符串类是用字符数组实现的, 先要拿到两个字符串的字符数组
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {  //然后对两个数组逐个字符地进行比较
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的源码可以看到, 当调用String类型的equals()方法时, 首先会判断两个字符串的引用是否相等, 也就是说两个字符串引用是否指向同一个对象, 是则返回true.&lt;/li&gt;
&lt;li&gt;如果不是指向同一个对象, 则把两个字符串中的字符挨个进行比较. 由于s1和s3字符串都是&quot;hello&quot;, 是可以匹配成功的, 所以最终返回true.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;通过上面的讲解相信你已经知道&lt;code&gt;==&lt;/code&gt;和equals()的区别, 一个的比较规则是定死的, 一个是可以由编程人员自己定义的.&lt;/li&gt;
&lt;li&gt;可是为什么会有equals()方法, 而且还可以被自由定制呢?&lt;/li&gt;
&lt;li&gt;这个问题要落到Java语言的核心--面向对象思想了. Java不同于面向过程的C语言, Java是一款面向对象的高级语言. 如果只是面向过程, 直接操作内存上存储的数据的话, 用&lt;code&gt;==&lt;/code&gt;所定义的规则来判断两个数据是否相等已经足够了.&lt;/li&gt;
&lt;li&gt;而Java中处处是对象, 我们经常要面对的问题是这两个对象是否相等, 而不是这两串二进制数是否相等, 仅有&quot;==&quot;是完全不够用的.&lt;/li&gt;
&lt;li&gt;考虑到编程人员会使用Java创建各种满足它们业务需求的对象, &lt;strong&gt;系统无法提前知道两个对象在什么条件下算相等, Java干脆把判断对象是否相等的权力交给编程人员&lt;/strong&gt;.&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;具体的措施是: 所有的类都必须继承Object类, 而Object类中写有equals()方法. 编程人员可以通过重写equals()方法实现自己的比较策略, 也可以不重写, 使用Object类的equals()比较策略.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Object类中的equals()方法源码
public boolean equals(Object obj) {
    return (this == obj);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从Object类的equals()源码可以看到, 如果编程人员没有显示地重写equals()方法, 则该类对象默认通过引用数据类型进行比较, 也就是说比较两个引用是否指向同一个对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;补充: 关于基本数据类型包装类的比较&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;由于Java中万物皆对象, 就连基本数据类型也有其对应的包装对象, 那么它们对应的比较策略是什么呢?&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    int a = 3;
    Integer b = new Integer(3);
    System.out.println(b.equals(a));    //true, 自动装箱
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的代码可以看到尽管两个引用不同, 但是输出的结果仍为true, 证明Integer包装类重写了equals()方法.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Integer类中的equals方法
public boolean equals(Object obj) {
    if (obj instanceof Integer) {
        return value == ((Integer)obj).intValue();
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从源码看到, 基本类型包装类在重写的equals方法中, 比较的还是基本数据类型的值.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;最后欢迎关注我的&lt;strong&gt;免费&lt;/strong&gt;知识星球, 我会在星球中持续更新系统的Java后端面试题分析, 将会囊括Java基础知识到主流框架原理. 还会分享关于编程的趣味漫画.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e6%98%9f%e7%90%832.png&quot;/&gt;</description>
<pubDate>Mon, 20 May 2019 13:15:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[toc] 相等判断符'=='介绍   '=='相等判断符用于比较基本数据类型和引用类型数据. 当比较基本数据类型的时候比较的是数值, 当比较引用类型数据时比较的是引用(指针).  </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</dc:identifier>
</item>
<item>
<title>Maven虐我千百遍，我待Maven如初恋 - 二叉树的博客</title>
<link>http://www.cnblogs.com/luao/p/10896403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10896403.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在如今的互联网项目开发当中，特别是Java领域，可以说Maven随处可见。Maven的&lt;strong&gt;仓库管理、依赖管理、继承和聚合&lt;/strong&gt;等特性为项目的构建提供了一整套完善的解决方案，可以说如果你搞不懂Maven，那么一个多模块的项目足以让你头疼，依赖冲突就会让你不知所措，甚至搞不清楚项目是如何运行起来的，专题的目的就是：彻底搞定Maven！&lt;/p&gt;
&lt;h2&gt;Thinking in Maven&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;回想一下，当你新到一家公司，安装完JDK后就会安装配置Maven（MAVEN_HOME、path），很大可能性你需要修改settings.xml文件，比如你会修改本地仓库地址路径，比如你很可能会copy一段配置到你的settings.xml中（很可能就是私服的一些配置）。接下来，你会到IDEA或者Eclipse中进行Maven插件配置，然后你就可以在工程中的pom.xml里面开始添加&amp;lt;dependency&amp;gt;标签来管理jar包，在Maven规范的目录结构下进行编写代码，最后你会通过插件的方式来进行测试、打包（jar or war）、部署、运行。&lt;/p&gt;
&lt;br/&gt;上面描述了我们对Maven的一些使用方式，下面我们进行一些思考：&lt;/div&gt;
&lt;div readability=&quot;6.4509547274407&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520202223505-191266934.jpg&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;447&quot;/&gt;&lt;p&gt;Maven仓库配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: ${user.home}/.m2/repository
  &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt;
  --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;你要jar包，不可能每次都要联网去下载吧，多费劲，所以本地仓库就是相当于加了一层jar包缓存，先到这里来查。如果这里查不到，那么就去私服上找，如果私服也找不到，那么去中央仓库去找，找到jar后，会把jar的信息同步到私服和本地仓库中。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;私服&lt;/strong&gt;，就是公司内部局域网的一台服务器而已，你想一下，当你的工程Project-A依赖别人的Project-B的接口，怎么做呢？没有Maven的时候，当然是copy Project-B jar到你的本地lib中引入，那么Maven的方式，很显然需要其他人把Project-B deploy到私服仓库中供你使用。&lt;strong&gt;因为私服中存储了本公司的内部专用的jar！不仅如此，私服还充当了中央仓库的镜像，说白了就是一个代理！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中央仓库&lt;/strong&gt;：该仓库存储了互联网上的jar，由Maven团队来维护，地址是：http://repo1.maven.org/maven2/。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h2&gt;Q2：关于&amp;lt;dependency&amp;gt;的使用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;坐标配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;6.4399962321025&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.12.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520204135849-1041769128.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;11.995469522241&quot;&gt;
&lt;div readability=&quot;19.11231884058&quot;&gt;
&lt;p&gt;其实这个标签揭示了jar的查找坐标：&lt;strong&gt;groupId、artifactId、version&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般而言，我们可以到私服上输入artifactId进行搜索，或者到&lt;a href=&quot;https://link.jianshu.com?t=http://search.maven.org/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://search.maven.org/&lt;/a&gt;、&lt;a href=&quot;https://link.jianshu.com?t=http://mvnrepository.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://mvnrepository.com/&lt;/a&gt;上进行查找确定坐标。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;version分为开发版本（&lt;em&gt;Snapshot&lt;/em&gt;）和发布版本（&lt;em&gt;Release&lt;/em&gt;），那么为什么要分呢？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际开发中，我们经常遇到这样的场景，比如A服务依赖于B服务，A和B同时开发，B在开发中发现了BUG，修改后，将版本由1.0升级为2.0，那么A必须也跟着在POM.XML中进行版本升级。过了几天后，B又发现了问题，进行修改后升级版本发布，然后通知A进行升级...可以说这是开发过程中的版本不稳定导致了这样的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven，已经替我们想好了解决方案，就是使用Snapshot版本，在开发过程中B发布的版本标志为Snapshot版本，A进行依赖的时候选择Snapshot版本，那么每次B发布的时候，会在私服仓库中，形成带有时间戳的Snapshot版本，而A构建的时候会自动下载B最新时间戳的Snapshot版本！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Q3：既然Maven进行了依赖管理，为什么还会出现依赖冲突？处理依赖冲突的手段是？&lt;/h2&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520135522336-1609101566.png&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;198&quot;/&gt;&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;首先来说，&lt;strong&gt;对于Maven而言，同一个groupId同一个artifactId下，只能使用一个version！&lt;/strong&gt;根据上图的依赖顺序，将使用1.2版本的jar。&lt;/p&gt;
&lt;p&gt;现在，我们可以思考下了，比如工程中需要引入A、B，而A依赖1.0版本的C，B依赖2.0版本的C，那么问题来了，C使用的版本将由引入A、B的顺序而定？这显然不靠谱！如果A的依赖写在B的依赖后面，将意味着最后引入的是1.0版本的C，很可能在运行阶段出现类（&lt;strong&gt;ClassNotFoundException&lt;/strong&gt;）、方法（&lt;strong&gt;NoSuchMethodError&lt;/strong&gt;）找不到的错误（因为B使用的是高版本的C）！&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;这里其实涉及到了2个概念：依赖传递（transitive）、Maven的最近依赖策略。&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖传递：如果A依赖B，B依赖C，那么引入A，意味着B和C都会被引入。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maven的最近依赖策略：如果一个项目依赖相同的groupId、artifactId的多个版本，那么在依赖树（mvn dependency:tree）中离项目最近的那个版本将会被使用。（从这里可以看出Maven是不是有点小问题呢？能不能选择高版本的进行依赖么？据了解，Gradle就是version+策略）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;现在，我们可以想想如何处理依赖冲突呢？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法1：要使用哪个版本，我们是清楚的，那么能不能不管如何依赖传递，都可以进行版本锁定呢？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用&amp;lt;dependencyManagement&amp;gt;  [这种主要用于子模块的版本一致性中]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法2：在依赖传递中，能不能去掉我们不想依赖的？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用&amp;lt;exclusions&amp;gt; [在实际中我们可以在IDEA中直接利用插件帮助我们生成]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法3：既然是最近依赖策略，那么我们就直接使用显式依赖指定版本，那不就是最靠近项目的么？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用&amp;lt;dependency&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h2&gt;&lt;strong&gt;Q4：引入依赖的最佳实践，提前发现问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在工程中，我们避免不了需要加一些依赖，也许加了依赖后运行时才发现存在依赖冲突在去解决，似乎有点晚！那么能不能提前发现问题呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们新加入一个依赖的话，那么先通过mvn dependency:tree命令形成依赖树，看看我们新加入的依赖，是否存在传递依赖，传递依赖中是否和依赖树中的版本存在冲突，如果存在多个版本冲突，利用上文的方式进行解决！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Q5：Maven规范化目录结构&lt;/h2&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520135602101-1305787265.png&quot; alt=&quot;&quot;/&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意2点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一：src/main下内容最终会打包到Jar/War中，而src/test下是测试内容，并不会打包进去。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二：src/main/resources中的资源文件会COPY至目标目录，这是Maven的默认生命周期中的一个规定动作。（想一想，hibernate/mybatis的映射XML需要放入resources下，而不能在放在其他地方了）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;br/&gt;&lt;h2&gt;Q6：Maven的生命周期&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520205730100-1563668191.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;283&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12.5&quot;&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;我们只需要注意一点：&lt;strong&gt;执行后面的命令时，前面的命令自动得到执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实际上，我们最常用的就是这么几个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;clean：有问题，多清理！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;package：打成Jar or War包，会自动进行clean+compile&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;install：将本地工程Jar上传到本地仓库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deploy：上传到私服&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h2&gt;Q7：关于scope依赖范围&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;既然，Maven的生命周期存在编译、测试、运行这些过程，那么显然有些依赖只用于测试，比如&lt;strong&gt;junit&lt;/strong&gt;；有些依赖编译用不到，只有运行的时候才能用到，比如&lt;strong&gt;mysql的驱动包&lt;/strong&gt;在编译期就用不到（&lt;strong&gt;编译期用的是JDBC接口&lt;/strong&gt;），而是在运行时用到的；还有些依赖，编译期要用到，而运行期不需要提供，因为有些容器已经提供了，比如&lt;strong&gt;servlet-api&lt;/strong&gt;在tomcat中已经提供了，我们只需要的是编译期提供而已。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;compile：默认的scope，运行期有效，需要打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;provided：编译期有效，运行期不需要提供，不会打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;runtime：编译不需要，在运行期有效，需要导入包中。（接口与实现分离）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;test：测试需要，不会打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;system：非本地仓库引入、存在系统的某个路径下的jar。（一般不使用）&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 20 May 2019 13:01:00 +0000</pubDate>
<dc:creator>二叉树的博客</dc:creator>
<og:description>前言 在如今的互联网项目开发当中，特别是Java领域，可以说Maven随处可见。Maven的仓库管理、依赖管理、继承和聚合等特性为项目的构建提供了一整套完善的解决方案，可以说如果你搞不懂Maven，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10896403.html</dc:identifier>
</item>
<item>
<title>在实战中使用nginx-rtmp遇到的TCP连接问题分析 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/10896015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/10896015.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;前段时间公司做了一次体育赛事的现场直播，网络由某通信公司负责搭建，主要测试5G CPE上行网络的带宽和稳定性，为了做到万无一失，他们同时搭建了一条用作备份的400M光纤线路。通过配置交换机来做到主备切换，要达到以下的效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无线链路down掉，交换机自动检测到丢包，丢包到指定数量（可以在交换机中配置），自动切换到备用链路。&lt;/li&gt;
&lt;li&gt;无线链接恢复，备用链路切换回无线链路。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考 &lt;a href=&quot;https://blog.51cto.com/zxteach/1919615&quot;&gt;静态路由与SLA技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们采用nginx-rtmp搭建了2层CDN。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_5:05:23.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;推流端推送RTMP流会向nginx-rtmp发送请求建立TCP链接，推流过程中，把交换机上的无线链路网线拔掉。自动切换到光纤线路，推流端重连后依然不能够成功建立链接，推流软件卡死。&lt;/p&gt;
&lt;p&gt;server端的TCP链接一直存在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@iz2zehy7gff0ksipgb4ch3z /u/l/nginx# netstat -natp | grep &quot;1936&quot;
tcp        0      0 0.0.0.0:1936            0.0.0.0:*               LISTEN      9467/nginx: master  
tcp        0      0 192.168.199.6:1936      223.71.3.82:46012       ESTABLISHED 11177/nginx: worker &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx 报错了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019/05/20 15:44:58 [error] 6947#0: *286 live: already publishing, client: 223.71.3.82, server: 0.0.0.0:1936&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时&lt;/p&gt;
&lt;p&gt;就是因为无线链接断开时，TCP链接不能够被正常关闭，publisher会一直存在导致的。&lt;/p&gt;
&lt;p&gt;复习一下四次挥手：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_5:11:45.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道TCP连接有一个特性：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TCP 连接一旦建立，只要通信双方之间的中间结点（包括网关和交换机、路由器等网络设备）工作正常，那么在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。TCP 连接的这种特性，使得一个长期不交换任何信息的空闲连接可以长期保持数小时、数天甚至数月。中间路由器可以崩溃、重启，网线可以被挂断再连通，只要两端的主机没有被重启，TCP 连接就可以被一直保持下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，网线虽然断掉了，但是server端没有收到client的任何消息，server端不会主动发起挥手，因此连接会一直维持很长一段时间（我的测试机器上大概数小时）。链接断开后server端一直在发送PSH+ACK:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_7:10:2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何才能实现快速重连&quot;&gt;如何才能实现快速重连&lt;/h2&gt;
&lt;h3 id=&quot;为源站加load-balance&quot;&gt;为源站加load balance&lt;/h3&gt;
&lt;p&gt;加一个备源和一个调度服务，调度策略采取轮询，两次连续的TCP连接请求会被定向到不同的源站上面。这个方法治标不治本，切一次可以，如果无线链路恢复，再切回来的时候，可能TCP链接还没有关闭。&lt;br/&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_6:02:14.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加drop_idle_publisher&quot;&gt;添加drop_idle_publisher&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Syntax: drop_idle_publisher timeout&lt;br/&gt;Context: rtmp, server, application&lt;/p&gt;
&lt;p&gt;Drop publisher connection which has been idle (no audio/video data) within specified time. Default is off. Note this only works when connection is in publish mode (after sending publish command).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;drop_idle_publisher 10s;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;nginx-rtmp会在指定的时间内丢弃空闲的publisher：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@iz2zehy7gff0ksipgb4ch3z /u/l/n/logs# netstat -natp | grep &quot;1936&quot;
tcp        0      0 0.0.0.0:1936            0.0.0.0:*               LISTEN      11421/nginx: master 
tcp        0      0 192.168.199.6:1936      61.148.243.150:9338     ESTABLISHED 12923/nginx: worker 
tcp        0      1 192.168.199.6:1936      223.71.3.82:47240       FIN_WAIT1   -      &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见这次是server端在2s后探测到这个TCP连接处于空闲状态，主动发起了挥手消息，此时publisher就被释放掉了，再次推流会重新建立新的TCP，重新生成此publisher。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_6:47:59.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是链路断掉后，TCP链接完全断开前server端向client发送的数据包，可以看到一直在发送FIN+最后一个数据包的ACK，时间间隔大概为 0.2秒-&amp;gt;0.4秒-&amp;gt;0.8秒-&amp;gt;1.6秒-&amp;gt;3.2秒-&amp;gt;6.4秒-&amp;gt;12.8秒-&amp;gt;25.6秒&lt;/p&gt;
&lt;p&gt;这种方法是可行的。&lt;/p&gt;
&lt;h3 id=&quot;so_keepalive&quot;&gt;so_keepalive&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;listen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;syntax: listen (addr[:port]|port|unix:path) [bind] [ipv6only=on|off] [so_keepalive=on|off|keepidle:keepintvl:keepcnt|proxy_protocol]&lt;/p&gt;
&lt;p&gt;context: server&lt;/p&gt;
&lt;p&gt;Adds listening socket to NGINX for accepting RTMP connections&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于TCP探活机制的几个参数的说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keepcnt 关闭一个非活跃连接之前进行探测的最大次数t&lt;/li&gt;
&lt;li&gt;keepidle 对一个连接进行有效性探测之前运行的最大非活跃时间间隔&lt;/li&gt;
&lt;li&gt;keepintvl 两个探测的时间间隔&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置如下参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;listen 1936 so_keepalive=5s:2:2; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http:/qiniu.harlanc.vip/5.20.2019_7:21:19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，最后一个ACK没有回复后隔了5秒开始TCP keep-alive 探活，总共两次，间隔2秒，最后发送RST+ACK断开了TCP连接 。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/arut/nginx-rtmp-module/wiki/Directives&quot;&gt;nginx-rtmp-module wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/aix/library/0808_zhengyong_tcp/index.html&quot;&gt;TCP 连接断连问题剖析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 11:31:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>在实战中使用nginx rtmp遇到的TCP连接问题分析 背景 前段时间公司做了一次体育赛事的现场直播，网络由某通信公司负责搭建，主要测试5G CPE上行网络的带宽和稳定性，为了做到万无一失，他们同时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/10896015.html</dc:identifier>
</item>
<item>
<title>Java 设计模式 - 不会敲代码的老王</title>
<link>http://www.cnblogs.com/rolandlee/p/10895899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rolandlee/p/10895899.html</guid>
<description>&lt;h4 id=&quot;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结&quot;&gt;设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;设计模式分为 &lt;strong&gt;23 种&lt;/strong&gt;经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式&lt;/li&gt;
&lt;li&gt;列举几种设计原则，这几种设计原则将贯通全文：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;面向接口编程，而不是面向实现。这个尤为重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建型模式&quot;&gt;创建型模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建型模式的作用就是创建对象，new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简单工厂模式&quot;&gt;简单工厂模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;和名字一样简单，非常简单，直接上代码吧：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class FoodFactory {

    public static Food makeFood(String name) {
        if (name.equals(&quot;noodle&quot;)) {
            Food noodle = new LanZhouNoodle();
            noodle.addSpicy(&quot;more&quot;);
            return noodle;
        } else if (name.equals(&quot;chicken&quot;)) {
            Food chicken = new HuangMenChicken();
            chicken.addCondiment(&quot;potato&quot;);
            return chicken;
        } else {
            return null;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。&lt;/li&gt;
&lt;li&gt;简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们强调职责单一原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface FoodFactory {
    Food makeFood(String name);
}
public class ChineseFoodFactory implements FoodFactory {

    @Override
    public Food makeFood(String name) {
        if (name.equals(&quot;A&quot;)) {
            return new ChineseFoodA();
        } else if (name.equals(&quot;B&quot;)) {
            return new ChineseFoodB();
        } else {
            return null;
        }
    }
}
public class AmericanFoodFactory implements FoodFactory {

    @Override
    public Food makeFood(String name) {
        if (name.equals(&quot;A&quot;)) {
            return new AmericanFoodA();
        } else if (name.equals(&quot;B&quot;)) {
            return new AmericanFoodB();
        } else {
            return null;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class APP {
    public static void main(String[] args) {
        // 先选择一个具体的工厂
        FoodFactory factory = new ChineseFoodFactory();
        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象
        Food food = factory.makeFood(&quot;A&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;虽然都是调用 makeFood(&quot;A&quot;) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;核心在于，我们需要在第一步选好我们需要的工厂。&lt;/strong&gt;比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;虽然简单，不过我也把所有的构件都画到一张图上，这样看着比较清晰：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520143952.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当涉及到产品族的时候，就需要引入抽象工厂模式了。&lt;/li&gt;
&lt;li&gt;一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。&lt;/li&gt;
&lt;li&gt;因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144103.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个时候的客户端调用是这样的：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 得到 Intel 的 CPU
CPUFactory cpuFactory = new IntelCPUFactory();
CPU cpu = intelCPUFactory.makeCPU();

// 得到 AMD 的主板
MainBoardFactory mainBoardFactory = new AmdMainBoardFactory();
MainBoard mainBoard = mainBoardFactory.make();

// 组装 CPU 和主板
Computer computer = new Computer(cpu, mainBoard);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;单独看 CPU 工厂和主板工厂，它们分别是前面我们说的&lt;strong&gt;工厂模式&lt;/strong&gt;。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;但是，这种方式有一个问题，那就是如果** Intel 家产的 CPU 和 AMD 产的主板不能兼容使用**，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;-下面就是我们要说的&lt;strong&gt;产品族&lt;/strong&gt;的概念，它代表了组成某个产品的一系列附件的集合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144237.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520144258.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    // 第一步就要选定一个“大厂”
    ComputerFactory cf = new AmdFactory();
    // 从这个大厂造 CPU
    CPU cpu = cf.makeCPU();
    // 从这个大厂造主板
    MainBoard board = cf.makeMainBoard();
      // 从这个大厂造硬盘
      HardDisk hardDisk = cf.makeHardDisk();

    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起
    Computer result = new Computer(cpu, board, hardDisk);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了对&lt;strong&gt;修改关闭，对扩展开放&lt;/strong&gt;这个设计原则。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {
    // 首先，将 new Singleton() 堵死
    private Singleton() {};
    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建
    private static Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，
    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了
    public static Date getDate(String mode) {return new Date();}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;饱汉模式最容易出错：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Singleton {
    // 首先，也是先堵死 new Singleton() 这条路
    private Singleton() {}
    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的
    private static volatile Singleton instance = null;

    public static Singleton getInstance() {
        if (instance == null) {
            // 加锁
            synchronized (Singleton.class) {
                // 这一次判断也是必须的，不然会有并发问题
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;双重检查，指的是两次检查 instance 是否为 null。&lt;br/&gt;volatile 在这里是需要的，希望能引起读者的关注。&lt;br/&gt;很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;嵌套类最经典，以后大家就用它吧：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Singleton3 {

    private Singleton3() {}
    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性
    private static class Holder {
        private static Singleton3 instance = new Singleton3();
    }
    public static Singleton3 getInstance() {
        return Holder.instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，很多人都会把这个&lt;strong&gt;嵌套类&lt;/strong&gt;说成是&lt;strong&gt;静态内部类&lt;/strong&gt;，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;最后，一定有人跳出来说用枚举实现单例，是的没错，枚举类很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。不说了，读者自己看着办吧，不建议使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Food food = new FoodBuilder().a().b().c().build();
Food food = Food.builder().a().b().c().build();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;来一个中规中矩的建造者模式：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class User {
    // 下面是“一堆”的属性
    private String name;
    private String password;
    private String nickName;
    private int age;

    // 构造方法私有化，不然客户端就会直接调用构造方法了
    private User(String name, String password, String nickName, int age) {
        this.name = name;
        this.password = password;
        this.nickName = nickName;
        this.age = age;
    }
    // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，
    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好
    public static UserBuilder builder() {
        return new UserBuilder();
    }

    public static class UserBuilder {
        // 下面是和 User 一模一样的一堆属性
        private String  name;
        private String password;
        private String nickName;
        private int age;

        private UserBuilder() {
        }

        // 链式调用设置各个属性值，返回 this，即 UserBuilder
        public UserBuilder name(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder password(String password) {
            this.password = password;
            return this;
        }

        public UserBuilder nickName(String nickName) {
            this.nickName = nickName;
            return this;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。
        // 当然，可以在 “复制” 之前做点检验
        public User build() {
            if (name == null || password == null) {
                throw new RuntimeException(&quot;用户名和密码必填&quot;);
            }
            if (age &amp;lt;= 0 || age &amp;gt;= 150) {
                throw new RuntimeException(&quot;年龄不合法&quot;);
            }
            // 还可以做赋予”默认值“的功能
              if (nickName == null) {
                nickName = name;
            }
            return new User(name, password, nickName, age);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性复制给实际产生的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;看看客户端的调用：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class APP {
    public static void main(String[] args) {
        User d = User.builder()
                .name(&quot;foo&quot;)
                .password(&quot;pAss12345&quot;)
                .age(25)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;说实话，建造者模式的链式写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 &lt;strong&gt;Builder 的构造方法&lt;/strong&gt;中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;@Builder
class User {
    private String  name;
    private String password;
    private String nickName;
    private int age;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么样，省下来的时间是不是又可以干点别的了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 *&lt;strong&gt;return this&lt;/strong&gt; 就可以了，然后就可以像下面这样调用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;User user = new User().setName(&quot;&quot;).setPassword(&quot;&quot;).setAge(20);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原型模式&quot;&gt;原型模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这是我要说的创建型模式的最后一个设计模式了。&lt;/li&gt;
&lt;li&gt;原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。&lt;/li&gt;
&lt;li&gt;Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先实现 Cloneable 接口，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;protected native Object clone() throws CloneNotSupportedException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建型模式总结&quot;&gt;创建型模式总结&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代理模式&quot;&gt;代理模式&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;既然说是&lt;strong&gt;代理&lt;/strong&gt;，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;理解代理这个词，这个模式其实就简单了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;
public interface FoodService {
    Food makeChicken();
    Food makeNoodle();
}

public class FoodServiceImpl implements FoodService {
    public Food makeChicken() {
          Food f = new Chicken()
        f.setChicken(&quot;1kg&quot;);
          f.setSpicy(&quot;1g&quot;);
          f.setSalt(&quot;3g&quot;);
        return f;
    }
    public Food makeNoodle() {
        Food f = new Noodle();
        f.setNoodle(&quot;500g&quot;);
        f.setSalt(&quot;5g&quot;);
        return f;
    }
}

// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService
public class FoodServiceProxy implements FoodService {

    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入
    private FoodService foodService = new FoodServiceImpl();

    public Food makeChicken() {
        System.out.println(&quot;我们马上要开始制作鸡肉了&quot;);

        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，
        // 代理只是在核心代码前后做些“无足轻重”的事情
        Food food = foodService.makeChicken();

        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;); // 增强
          food.addCondiment(&quot;pepper&quot;);

        return food;
    }
    public Food makeNoodle() {
        System.out.println(&quot;准备制作拉面~&quot;);
        Food food = foodService.makeNoodle();
        System.out.println(&quot;制作完成啦&quot;)
        return food;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端调用，注意，我们要用代理来实例化接口：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 这里用代理类来实例化
FoodService foodService = new FoodServiceProxy();
foodService.makeChicken();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520150626.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;说到动态代理，又可以展开说 …… Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。&lt;/li&gt;
&lt;li&gt;适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配&lt;/li&gt;
&lt;li&gt;适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;默认适配器模式&quot;&gt;默认适配器模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先，我们先看看最简单的适配器模式&lt;strong&gt;默认适配器模式(Default Adapter)&lt;/strong&gt;是怎么样的。&lt;/li&gt;
&lt;li&gt;我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface FileAlterationListener {
    void onStart(final FileAlterationObserver observer);
    void onDirectoryCreate(final File directory);
    void onDirectoryChange(final File directory);
    void onDirectoryDelete(final File directory);
    void onFileCreate(final File file);
    void onFileChange(final File file);
    void onFileDelete(final File file);
    void onStop(final FileAlterationObserver observer);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的&lt;strong&gt;文件创建&lt;/strong&gt;和&lt;strong&gt;文件删除&lt;/strong&gt;事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;所以，我们需要下面的一个&lt;strong&gt;适配器&lt;/strong&gt;，它用于实现上面的接口，但是所有的方法都是空方法，这样，我们就可以转而定义自己的类来继承下面这个类即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class FileAlterationListenerAdaptor implements FileAlterationListener {

    public void onStart(final FileAlterationObserver observer) {
    }

    public void onDirectoryCreate(final File directory) {
    }

    public void onDirectoryChange(final File directory) {
    }

    public void onDirectoryDelete(final File directory) {
    }

    public void onFileCreate(final File file) {
    }

    public void onFileChange(final File file) {
    }

    public void onFileDelete(final File file) {
    }

    public void onStop(final FileAlterationObserver observer) {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class FileMonitor extends FileAlterationListenerAdaptor {
    public void onFileCreate(final File file) {
        // 文件创建
        doSomething();
    }

    public void onFileDelete(final File file) {
        // 文件删除
        doSomething();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍“正统的”适配器模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对象适配器模式&quot;&gt;对象适配器模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface Duck {
    public void quack(); // 鸭的呱呱叫
      public void fly(); // 飞
}

public interface Cock {
    public void gobble(); // 鸡的咕咕叫
      public void fly(); // 飞
}

public class WildCock implements Cock {
    public void gobble() {
        System.out.println(&quot;咕咕叫&quot;);
    }
      public void fly() {
        System.out.println(&quot;鸡也会飞哦&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用
public class CockAdapter implements Duck {

    Cock cock;
    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用
      public CockAdapter(Cock cock) {
        this.cock = cock;
    }

    // 实现鸭的呱呱叫方法
      @Override
      public void quack() {
        // 内部其实是一只鸡的咕咕叫
        cock.gobble();
    }

      @Override
      public void fly() {
        cock.fly();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端调用很简单了：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    // 有一只野鸡
      Cock wildCock = new WildCock();
      // 成功将野鸡适配成鸭
      Duck duck = new CockAdapter(wildCock);
      ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们用一个图来简单说明下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151032.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类适配器模式&quot;&gt;类适配器模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;废话少说，直接上图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151119.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 &lt;strong&gt;Target t = new SomeAdapter();&lt;/strong&gt; 就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;适配器模式总结&quot;&gt;适配器模式总结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151335.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;桥梁模式&quot;&gt;桥梁模式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public interface DrawAPI {
   public void draw(int radius, int x, int y);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后是一系列实现类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class RedPen implements DrawAPI {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}
public class GreenPen implements DrawAPI {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}
public class BluePen implements DrawAPI {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义一个抽象类，此类的实现类都需要使用 DrawAPI：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class Shape {
   protected DrawAPI drawAPI;

   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义抽象类的子类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 圆形
public class Circle extends Shape {
   private int radius;

   public Circle(int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.radius = radius;
   }

   public void draw() {
      drawAPI.draw(radius, 0, 0);
   }
}
// 长方形
public class Rectangle extends Shape {
    private int x;
      private int y;

      public Rectangle(int x, int y, DrawAPI drawAPI) {
        super(drawAPI);
          this.x = x;
          this.y = y;
    }
      public void draw() {
      drawAPI.draw(0, x, y);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后，我们来看客户端演示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    Shape greenCircle = new Circle(10, new GreenPen());
      Shape redRectangle = new Rectangle(4, 8, new RedPen());

      greenCircle.draw();
      redRectangle.draw();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151512.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;装饰模式&quot;&gt;装饰模式&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151615.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们来说说装饰模式的出发点，从图中可以看到，接口 &lt;code&gt;Component&lt;/code&gt;其实已经有了 &lt;code&gt;ConcreteComponentA&lt;/code&gt; 和 &lt;code&gt;ConcreteComponentB&lt;/code&gt; 两个实现类了，但是，如果我们要&lt;strong&gt;增强&lt;/strong&gt;这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来&lt;strong&gt;装饰&lt;/strong&gt;实现类，以达到增强的目的。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的方式，但是那样的话代码就复杂了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 ConcreteDecorator&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起装饰作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中&lt;strong&gt;加了层皮来装饰而已。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea......但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？万一有个变态要四份柠檬，所以这种做法是给自己找加班的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不说废话了，上代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，定义饮料抽象基类：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class Beverage {
      // 返回描述
      public abstract String getDescription();
      // 返回价格
      public abstract double cost();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后是三个基础饮料实现类，红茶、绿茶和咖啡：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class BlackTea extends Beverage {
      public String getDescription() {
        return &quot;红茶&quot;;
    }
      public double cost() {
        return 10;
    }
}
public class GreenTea extends Beverage {
    public String getDescription() {
        return &quot;绿茶&quot;;
    }
      public double cost() {
        return 11;
    }
}
...// 咖啡省略&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义调料，也就是装饰者的基类，此类必须继承自 Beverage：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 调料
public abstract class Condiment extends Beverage {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承 Condiment 类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Lemon extends Condiment {
    private Beverage bevarage;
      // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，
      // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶
      public Lemon(Beverage bevarage) {
        this.bevarage = bevarage;
    }
      public String getDescription() {
        // 装饰
        return bevarage.getDescription() + &quot;, 加柠檬&quot;;
    }
      public double cost() {
          // 装饰
        return beverage.cost() + 2; // 加柠檬需要 2 元
    }
}
public class Mango extends Condiment {
    private Beverage bevarage;
      public Mango(Beverage bevarage) {
        this.bevarage = bevarage;
    }
      public String getDescription() {
        return bevarage.getDescription() + &quot;, 加芒果&quot;;
    }
      public double cost() {
        return beverage.cost() + 3; // 加芒果需要 3 元
    }
}
...// 给每一种调料都加一个类&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;看客户端调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
      // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡
    Beverage beverage = new GreenTea();
      // 开始装饰
      beverage = new Lemon(beverage); // 先加一份柠檬
      beverage = new Mongo(beverage); // 再加一份芒果

      System.out.println(beverage.getDescription() + &quot; 价格：￥&quot; + beverage.cost());
      //&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果我们需要芒果珍珠双份柠檬红茶：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520151958.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到这里，大家应该已经清楚装饰模式了吧。&lt;/li&gt;
&lt;li&gt;下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152042.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;FilterInputStream 承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(&quot;&quot;)));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们应该像下面这样使用：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;DataInputStream is = new DataInputStream(
                              new BufferedInputStream(
                                  new FileInputStream(&quot;&quot;)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;门面模式&quot;&gt;门面模式&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，我们定义一个接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface Shape {
   void draw();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义几个实现类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Circle::draw()&quot;);
   }
}

public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Rectangle::draw()&quot;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端调用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    // 画一个圆形
      Shape circle = new Circle();
      circle.draw();

      // 画一个长方形
      Shape rectangle = new Rectangle();
      rectangle.draw();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下面，我们看看怎么用门面模式来让客户端调用更加友好一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们先定义一个门面：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;

   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }

  /**
   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定
   */

   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;看看现在客户端怎么调用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
  ShapeMaker shapeMaker = new ShapeMaker();

  // 客户端调用现在更加清晰了
  shapeMaker.drawCircle();
  shapeMaker.drawRectangle();
  shapeMaker.drawSquare();        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;组合模式&quot;&gt;组合模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。&lt;/li&gt;
&lt;li&gt;直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List&amp;lt;Employee&amp;gt; subordinates; // 下属

   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList&amp;lt;Employee&amp;gt;();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List&amp;lt;Employee&amp;gt; getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return (&quot;Employee :[ Name : &quot; + name + &quot;, dept : &quot; + dept + &quot;, salary :&quot; + salary+&quot; ]&quot;);
   }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;享元模式&quot;&gt;享元模式&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这种简单的代码我就不演示了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结构型模式总结&quot;&gt;结构型模式总结&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;策略模式&quot;&gt;策略模式&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，先定义一个策略接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface Strategy {
   public void draw(int radius, int x, int y);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后我们定义具体的几个策略：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class RedPen implements Strategy {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}
public class GreenPen implements Strategy {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}
public class BluePen implements Strategy {
   @Override
   public void draw(int radius, int x, int y) {
      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用策略的类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;
   }

   public int executeDraw(int radius, int x, int y){
      return strategy.draw(radius, x, y);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端演示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    Context context = new Context(new BluePen()); // 使用绿色笔来画
      context.executeDraw(10, 0, 0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;放到一张图上，让大家看得清晰些：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152640.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images-roland.oss-cn-shenzhen.aliyuncs.com//blog/20190520152702.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Subject {

   private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;Observer&amp;gt;();
   private int state;

   public int getState() {
      return state;
   }

   public void setState(int state) {
      this.state = state;
      // 数据已变更，通知观察者们
      notifyAllObservers();
   }

   public void attach(Observer observer){
      observers.add(observer);        
   }

   // 通知观察者们
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }     
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义观察者接口：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们来定义具体的几个观察者类：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class BinaryObserver extends Observer {

      // 在构造方法中进行订阅主题
    public BinaryObserver(Subject subject) {
        this.subject = subject;
        // 通常在构造方法中将 this 发布出去的操作一定要小心
        this.subject.attach(this);
    }

      // 该方法由主题类在数据变更的时候进行调用
    @Override
    public void update() {
        String result = Integer.toBinaryString(subject.getState());
        System.out.println(&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot; + result);
    }
}

public class HexaObserver extends Observer {

    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
          String result = Integer.toHexString(subject.getState()).toUpperCase();
        System.out.println(&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot; + result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端使用也非常简单：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    // 先定义一个主题
      Subject subject1 = new Subject();
      // 定义观察者
      new BinaryObserver(subject1);
      new HexaObserver(subject1);

      // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用
      subject.setState(11);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;订阅的数据发生变化，新的数据处理为二进制值为：1011
订阅的数据发生变化，新的数据处理为十六进制值为：B
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;首先，我们要定义流程上节点的基类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class RuleHandler {

      // 后继节点
    protected RuleHandler successor;

    public abstract void apply(Context context);

    public void setSuccessor(RuleHandler successor) {
        this.successor = successor;
    }
    public RuleHandler getSuccessor() {
        return successor;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class NewUserRuleHandler extends RuleHandler {

    public void apply(Context context) {
        if (context.isNewUser()) {
              // 如果有后继节点的话，传递下去
            if (this.getSuccessor() != null) {
                this.getSuccessor().apply(context);
            }
        } else {
            throw new RuntimeException(&quot;该活动仅限新用户参与&quot;);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;校验用户所在地区是否可以参与：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class LocationRuleHandler extends RuleHandler {
    public void apply(Context context) {
        boolean allowed = activityService.isSupportedLocation(context.getLocation);
          if (allowed) {
            if (this.getSuccessor() != null) {
                this.getSuccessor().apply(context);
            }
        } else  {
            throw new RuntimeException(&quot;非常抱歉，您所在的地区无法参与本次活动&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;校验奖品是否已领完：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class LimitRuleHandler extends RuleHandler {
    public void apply(Context context) {
          int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品
        if (remainedTimes &amp;gt; 0) {
            if (this.getSuccessor() != null) {
                this.getSuccessor().apply(userInfo);
            }
        } else {
            throw new RuntimeException(&quot;您来得太晚了，奖品被领完了&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    RuleHandler newUserHandler = new NewUserRuleHandler();
      RuleHandler locationHandler = new LocationRuleHandler();
      RuleHandler limitHandler = new LimitRuleHandler();

      // 假设本次活动仅校验地区和奖品数量，不校验新老用户
      locationHandler.setSuccessor(limitHandler);
      locationHandler.apply(context);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;模板方法模式&quot;&gt;模板方法模式&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在含有继承结构的代码中，模板方法模式是非常常用的，这也是在开源代码中大量被使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通常会有一个抽象类：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class AbstractTemplate {
    // 这就是模板方法
      public void templateMethod(){
        init();
        apply(); // 这个是重点
        end(); // 可以作为钩子方法
    }
    protected void init() {
        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);
    }
      // 留给子类实现
    protected abstract void apply();
    protected void end() {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。&lt;/li&gt;
&lt;li&gt;我们写一个实现类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ConcreteTemplate extends AbstractTemplate {
    public void apply() {
        System.out.println(&quot;子类实现抽象方法 apply&quot;);
    }
      public void end() {
        System.out.println(&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;客户端调用演示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    AbstractTemplate t = new ConcreteTemplate();
      // 调用模板方法
      t.templateMethod();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;状态模式&quot;&gt;状态模式&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义状态接口：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface State {
   public void doAction(Context context);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义减库存的状态：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class DeductState implements State {

   public void doAction(Context context) {
      System.out.println(&quot;商品卖出，准备减库存&quot;);
      context.setState(this);

      //... 执行减库存的具体操作
   }

   public String toString(){
      return &quot;Deduct State&quot;;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义补库存状态：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class RevertState implements State {
    public void doAction(Context context) {
        System.out.println(&quot;给此商品补库存&quot;);
          context.setState(this);

          //... 执行加库存的具体操作
    }
      public String toString() {
        return &quot;Revert State&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Context {
    private State state;
      private String name;
      public Context(String name) {
        this.name = name;
    }

      public void setState(State state) {
        this.state = state;
    }
      public void getState() {
        return this.state;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们来看下客户端调用，大家就一清二楚了：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    // 我们需要操作的是 iPhone X
    Context context = new Context(&quot;iPhone X&quot;);

    // 看看怎么进行补库存操作
      State revertState = new RevertState();
      revertState.doAction(context);

    // 同样的，减库存操作也非常简单
      State deductState = new DeductState();
      deductState.doAction(context);

      // 如果需要我们可以获取当前的状态
    // context.getState().toString();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。&lt;/li&gt;
&lt;li&gt;不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;行为型模式总结&quot;&gt;行为型模式总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 20 May 2019 10:58:00 +0000</pubDate>
<dc:creator>不会敲代码的老王</dc:creator>
<og:description>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结 设计模式分为 23 种 经典的模式，根据用途我们又可以分为三大类。分别是创建型模式、结构型模式和行为型模式 列举几种设计原则，这几种设计原则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rolandlee/p/10895899.html</dc:identifier>
</item>
<item>
<title>深入学习线程池原理 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10783012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10783012.html</guid>
<description>&lt;p&gt; 　　&lt;span&gt;在前面的文章：&amp;lt;&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/10783008.html&quot; target=&quot;_blank&quot;&gt;线程池原理初探&lt;/a&gt;&amp;gt;&amp;gt;中我们学习了线程池的基本用法和优点，并且从源码层面学习了线程池的内部数据结构以及运行状态表征方法，这是最基础但是又很重要的一环，有了这一步铺垫我们便可以开始进一步的源码学习之旅了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文会从如下几个方面展开：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#a&quot;&gt;工作线程--Worker&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#b&quot;&gt;如何提交任务&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#c&quot;&gt;如何添加Worker&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#d&quot;&gt;worker是如何开始工作的&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#e&quot;&gt;线程池如何结束Worker的工作&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#f&quot;&gt;终止线程池原理&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#g&quot;&gt;总结&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1. 工作线程--Worker&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;上文说到，线程池中的工作线程是保存在一个hashSet中，这样说其实并不是很准确，因为线程池中执行任务的基本单元是一个定义在ThreadPoolExecutor中的内部类Worker，继承自AQS，并实现了Runnable接口，其本身就是一个任务，内部封装了驱动其运行的线程，而这个worker才是保存在hashSet中的。我们来看一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt; AbstractQueuedSynchronizer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable
    {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 这才是真的线程，worker只是一个runnable，需要线程来驱动，而这个线程则是封装在worker中，worker在其自己的run()方法中再去执行队列中的任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Thread thread;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 第一个要执行的任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Runnable firstTask;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 已完成的任务数量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; completedTasks;
&lt;br/&gt;　　　　 // 构造函数
        Worker(Runnable firstTask) {
            setState(&lt;/span&gt;-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止在runWorker之前被中断&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.firstTask =&lt;span&gt; firstTask;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 委托给ThreadPoolExecutor中的runWorker方法  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            runWorker(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState() != 0&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;)) {
                setExclusiveOwnerThread(Thread.currentThread());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
            setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            setState(&lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lock()        { acquire(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock()  { &lt;span&gt;return&lt;/span&gt; tryAcquire(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unlock()      { release(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isLocked() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; isHeldExclusively(); }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIfStarted() {
            Thread t;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;t.isInterrupted()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    t.interrupt();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在Worker中封装了一个Thread，这个才是真正的线程池帮我们管理的线程。Worker只是一个runnable，需要线程来驱动，而这个线程又是封装在Worker内部，Worker在其自己的run()方法中再去执行队列中的任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在Worker中封装的Thread会在Worker的初始化方法中进行赋值，通过线程池内部的ThreadFactory获取一个Thread实例，也就是说所有线程池中的线程都是通过ThreadFactory这一工厂产生的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Worker继承自AQS，实现了一个简单的不可重入互斥锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了防止在线程实际开始执行任务之前被中断，在Worker的初始化方法中直接将锁状态变量state置为-1，在runWorker方法中会将其清除为0；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;这里其实只要重点关注Worker自身是一个任务，它将线程封装起来了，由该线程来驱动Worker的run()方法，然后Worker在其自己的run()方法中不断地从任务队列中获取任务并执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于Worker，我们先了解这么多就够了，一些更深入的细节还需要结合ThreadPoolExecutor自身的逻辑来理解才更容易弄清楚。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2. 如何提交任务&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;其实ThreadPoolExecutor的execut()方法是一个很好的看源码的入口，因为这也许是我们使用的最多的方法，并且线程池的主要逻辑也在这个方法中。该方法对于用户来说就是向线程池提交任务，至于提交任务之后的逻辑，是否要新建线程、是否将任务加入阻塞队列中、是否要拒绝任务等等，这些对用户都是透明的，这也是我们接下来要重点探索的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查工作线程的数量，低于corePoolsize则添加Worker&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        c &lt;/span&gt;=&lt;span&gt; ctl.get();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; isRunning()用来检查线程池是否处于运行状态&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次进行防御性检查&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
            reject(command);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
            addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到这里已经意味着已经饱和或者被shutdown了，尝试添加一个非核心worker，如果失败就就直接执行拒绝&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        reject(command);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;141&quot;&gt;&lt;span&gt;　　如上，配合注释更容易理解，总结一下，一共分成3步：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;142&quot;&gt;&lt;li&gt;&lt;span&gt;检查工作线程的数量，低于corePoolsize则添加Worker；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;判断线程池是否处于运行状态，如果在，判断任务队列是否允许插入，插入成功再次验证线程池是否处于运行状态，如果不在运行状态则移除插入的任务，然后抛出拒绝策略，否则检查存活线程的数量，如果没有线程了，就添加一个Worker；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果执行到这一步意味着线程池已经饱和或者被shutdown了，尝试添加一个非核心worker，如果失败就就直接执行拒绝；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 如何添加Worker&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;接下来我们再来看一下如何添加Worker，这部分逻辑是在addWorker()方法中，这部分主要负责创建新的线程并执行任务：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
    retry:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);
　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程池的状态值大于或等SHUTDOWN，则不处理提交的任务，直接返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            !(rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
               firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
               !&lt;span&gt;workQueue.isEmpty()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前线程数量太多则直接退出&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做自旋，如果当前线程数量更新成功则跳出retry执行后面addworker逻辑&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新读取ctl，如果线程池状态改变，则从retry重新执行&lt;/span&gt;
            c = ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    Worker w &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池主锁&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
            mainLock.lock();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加线程到workers中（线程池中）&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                    (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                    workers.add(w);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                        largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                    workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
&lt;span&gt;                mainLock.unlock();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动新建的线程，此时添加的worker会被驱动执行其run()方法&lt;/span&gt;
&lt;span&gt;                t.start();
                workerStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
            addWorkerFailed(w);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;223&quot;&gt;&lt;span&gt;　　主要分为如下5步：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;224&quot;&gt;&lt;li&gt;&lt;span&gt;判断是否需要添加worker：&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果线程池的状态值大于SHUTDOWN，则不需添加worker，直接返回false；　　　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程池的状态值等于SHUTDOWN，此时如果传入的firstTask不为空，则不需要添加worker，则直接返回false；　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程池的状态值等于SHUTDOWN，且传入的firstTask为空，则检查workQueue是否为空，是则不需要添加worker，直接返回false；　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;否则代表判断通过，继续执行后面逻辑；　　&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;做自旋，更新创建线程数量；&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果此时线程数量太多(超过ctl能保存的数量或者超过指定的线程池最大线程数量)，则直接返回false；　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;利用cas更新线程数量(ctl加1)，成功则跳出自旋继续后面的操作；　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果更新失败则检查线程运行状态，如果发生改变则重新开始addWorker，否则继续自旋更新ctl；　　&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取线程池主锁，通过ReentrantLock锁保证线程安全，因为workers这个hashSet对于用户来说相当于共享变量，所以这里要加锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;添加新线程到workers中（一个HashSet），释放锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果添加成功则启动新建的线程；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程启动失败，代表添加也失败了，则执行回退补偿逻辑，在addWorkerFailed()方法中；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. Worker是如何工作的&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在addWorker中添加了新的worker之后会启动其封装的线程，该worker也会随之被线程驱动执行(因为worker继承自Runnable)。&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10783012.html#a&quot;&gt;前面&lt;/a&gt;讲Worker的时候我们知道其run()方法中只调用了一个方法，就是定义在ThreadPoolExecutor中的runWorker()，这里才是执行worker的主要工作逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runWorker(Worker w) {
    Thread wt &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
    Runnable task &lt;/span&gt;=&lt;span&gt; w.firstTask;
    w.firstTask &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　 // 因为Worker自身就是一把简单的不可重入互斥锁(听起来好像也不简单。。)，这里调用unlock()是为了将state的状态从-1改为0
    w.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allow interrupts&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是第一次执行任务，或者从队列中能够获取到任务，则执行&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            w.lock();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If pool is stopping, ensure thread is interrupted;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if not, ensure thread is not interrupted.  This
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; requires a recheck in second case to deal with
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shutdownNow race while clearing interrupt
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据线程池的状态来判断是否需要将当前线程interrupt&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((runStateAtLeast(ctl.get(), STOP) ||&lt;span&gt;
                 (Thread.interrupted() &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                  runStateAtLeast(ctl.get(), STOP))) &lt;/span&gt;&amp;amp;&amp;amp;
                !&lt;span&gt;wt.isInterrupted())
                wt.interrupt();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行任务开始前钩子函数&lt;/span&gt;
&lt;span&gt;                beforeExecute(wt, task);
                Throwable thrown &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 真正开始执行任务&lt;/span&gt;
&lt;span&gt;                    task.run();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException x) {
                    thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Error x) {
                    thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
                    thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(x);
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行任务后钩子函数&lt;/span&gt;
&lt;span&gt;                    afterExecute(task, thrown);
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                task &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; task置空，以便while循环中获取新任务&lt;/span&gt;
                w.completedTasks++&lt;span&gt;;
                w.unlock();
            }
        }
        completedAbruptly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        processWorkerExit(w, completedAbruptly);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;这是一个被final修饰的方法，不能被重写。总结一下其逻辑(比较复杂)：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;291&quot;&gt;&lt;li&gt;&lt;span&gt;根据线程池的状态来判断是否需要将当前线程interrupt，如果线程池为stop且当前线程未被interrupt，则interrupt当前线程；反之如果线程池为running或shutdown，则需要确保当前线程未被interrupt(源码里是通过Thread.interrupted()来保证的，因为其可以将中断状态清零)，并且再次检查线程池状态是否为stop，如果是则逻辑同上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果是第一次执行任务，或者从队列中能够获取到任务，则继续循环执行；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行任务开始前的钩子函数；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用task的run方法，真正开始执行任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行任务后钩子函数；　　　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将task置空，释放锁，完成任务+1；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行退出worker逻辑，需要将worker从workers中移除；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;好了， 看了不少源码，我们稍微停一下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用户调用线程池的execute()方法之后，线程池根据情况有三种操作：addWorker、将任务放到阻塞队列中、拒绝；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;后面两种操作很简单，addWorker操作会步骤多一些，主要包括：做一些必要的判断、创建新的Worker并将其加入到workers中、将worker跑起来；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;worker跑起来之后会不断地从阻塞队列中取任务并执行；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;上面的runWorker()方法中我们也看到了，worker跑起来之后取就进入了一个while循环中，不断地取任务并执行，好像没有看到哪里可以退出，那线程池又是如何让worker停下来的呢？我们接着往下看。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5. 线程池如何结束Worker的工作&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;在上面那节的代码中我们可以看到Worker启动之后，一直在一个while()循环中工作，如果退出了这个循环，run()方法也就邻近结束了。所以只要能够让运行中的worker退出自己的while()循环就能结束worker了，那我们就要来看一下while循环中的条件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    。。。  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　有两个条件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;task不为空，当work执行了一个任务之后，这个就会被置空，所以第一个条间很多情况下都是false；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从getTask()获取任务，如果返回为空，那么循环条件为false，循环退出；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这就是线程池关闭线程的开关入口，我们来看一下这个getTast()方法吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getTask() {
      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; timedOut = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did the last poll() time out?&lt;/span&gt;

      &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只在必要的时候才检查任务队列是否为空&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP ||&lt;span&gt; workQueue.isEmpty())) {
              decrementWorkerCount();
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
          }

          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);

          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Are workers subject to culling?&lt;/span&gt;
          &lt;span&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt;&lt;span&gt; corePoolSize;

          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp;&lt;span&gt; timedOut))
              &lt;/span&gt;&amp;amp;&amp;amp; (wc &amp;gt; 1 ||&lt;span&gt; workQueue.isEmpty())) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndDecrementWorkerCount(c))
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
          }

          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
              Runnable r &lt;/span&gt;= timed ?&lt;span&gt;
                  workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                  workQueue.take();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
              timedOut &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException retry) {
              timedOut &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          }
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;接着就要从任务队列取任务了：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果允许超时则调用poll取任务，这个方法会使当前线程阻塞一段指定时间；　　&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;否则调用take()取任务，这个方法会使当前线程一直阻塞，直到获取到任务或者被当前线程被中断；　　&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果取出任务则返回，没有的话则将timedOut置为true，标记为已超时(代表核心线程等待时间过长，需要删除)，重新进入到步骤1，继续循环执行；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这里的逻辑比较多，因为有涉及到是否允许核心线程超时，所以需要细细品味。当调用getTask()为拿到任务，就意味着当前线程该做的工作已经完成了，不用再循环取任务执行了，剩下就是执行processWorkerExit()结束工作了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6. 终止线程池原理&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;现在提交任务、执行任务、以及停止任务的入口，这些逻辑我们都看完了，我们来看一下如何停止线程池。主要有两个方法：shutdown、shutdownNow，从名字我们可以看出区别：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;shutdown()执行之后线程池会停止接收任务，但是还是会把任务池中的任务执行完再结束；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;shutdownNow()执行之后线程池不仅会停止接收任务，而且会把任务池中未执行的任务都清空，直接结束；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　我们来看一下具体实现细节：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.1 shutdown&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            checkShutdownAccess();&lt;br/&gt;　　　　　　  // 修改线程池运行状态为SHUTDOWN
            advanceRunState(SHUTDOWN);&lt;br/&gt;　　　　　　  // 中断空闲线程
            interruptIdleWorkers();&lt;br/&gt;　　　　　　　// 预留的钩子函数
            onShutdown(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hook for ScheduledThreadPoolExecutor&lt;/span&gt;
        } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }&lt;br/&gt;　　　　  // 
        tryTerminate();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;逻辑比较清晰：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先，获取线程池的主锁，只有1个线程可以操作；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;权限判断；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;利用CAS机制不断尝试修改线程池状态为SHUTDOWN，直到成功为止；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;中断空闲线程；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;释放锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行tryTerminate()；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;先来看一下如何利用CAS修改线程池状态，如下代码是advanceRunState()的实现，可以看到在循环中不断调用原子类ctl的compareAndSet()方法来设置值，这就是利用CAS机制：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; advanceRunState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; targetState) {&lt;br/&gt;　　　　  // 进入循环
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();&lt;br/&gt;　　　　　　　// 如果状态修改成功则退出循环
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (runStateAtLeast(c, targetState) ||&lt;span&gt;
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;接下来看一下如何中断空闲线程，也很简单，就是对所有worker进行遍历，判断其是否被中断，如果没有则尝试设置其中断标志。这里只是说了一下基本流程，有些细节没有提到，需要代码中体会：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIdleWorkers() {
        interruptIdleWorkers(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; interruptIdleWorkers(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyOne) {&lt;br/&gt;　　　　  // 获取线程池的锁，并上锁
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　// 遍历workers
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers) {
                Thread t &lt;/span&gt;=&lt;span&gt; w.thread;&lt;br/&gt;　　　　　　　　　　// 判断worker封装的Thread实例是否被中断，如果没有则尝试获取worker自己的锁
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp;&lt;span&gt; w.tryLock()) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　　　 // 设置中断状态
                        t.interrupt();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        w.unlock();
                    }
                }&lt;br/&gt;　　　　　　　　　　// 根据传入的参数，只中断一个worker
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (onlyOne)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　&lt;span&gt;　最后我们再来看一下tryTerminate()的逻辑，配合代码看效果会更好，这里简单说一下，首先会有几轮判断，是否需要执行terminate()，接着会利用CAS机制尝试修改线程池状态为TIDYING，成功则执行terminate()，失败则循环执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; tryTerminate() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get(); &lt;br/&gt;　　　　　　　/**&lt;br/&gt;　　　　　　　　* 满足如下两个条件则直接返回&lt;br/&gt;　　　　　　　　*   1. 线程池当前状态为RUNNING、TIDYING、TERMINATED&lt;br/&gt;　　　　　　　　*   2. 线程池当前状态为SHUTDOWN且任务队列不为空，那还要继续将队列中的任务执行完才能结束&lt;br/&gt;　　　　　　　　**/
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRunning(c) ||&lt;span&gt;
                runStateAtLeast(c, TIDYING) &lt;/span&gt;||&lt;span&gt;
                (runStateOf(c) &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty()))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　// 到这里代表线程池的状态为SHUTDOWN或STOP，如果还有存活线程，则尝试中断一个并返回
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) != 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eligible to terminate&lt;/span&gt;
&lt;span&gt;                interruptIdleWorkers(ONLY_ONE);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
            mainLock.lock();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　// 尝试将线程池状态修改为TIDYING，修改成功则执行terminated()，如果没有则继续循环执行
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctl.compareAndSet(c, ctlOf(TIDYING, 0&lt;span&gt;))) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        terminated();
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　　　 // 执行完terminated()之后需要确保将线程池状态修改为TERMINATED 
                        ctl.set(ctlOf(TERMINATED, &lt;/span&gt;0&lt;span&gt;));
                        termination.signalAll();
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                mainLock.unlock();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry on failed CAS&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;其实shutdown()最终还是通过设置工作线程的中断状态来实现结束中断线程的，关于这种方式我们前面也是专门写过一篇文章的：&amp;lt;&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/10783003.html&quot; target=&quot;_blank&quot;&gt;线程间通信&lt;/a&gt;&amp;gt;&amp;gt;。具体是如何结束的，在线程执行的过程中会不断的调用getTask()从任务队列获取任务，在getTask()中会对中断状态进行监控，一旦发现之后会根据具体逻辑执行对应操作，具体参考getTask()的代码。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.2 shutdownNow&lt;/h3&gt;
&lt;p&gt; 　　&lt;span&gt;看完shutdown()的我们再来看一下shutdownNow()的逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Runnable&amp;gt;&lt;span&gt; shutdownNow() {
        List&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; tasks;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            checkShutdownAccess();
            advanceRunState(STOP);
            interruptWorkers();
            tasks &lt;/span&gt;=&lt;span&gt; drainQueue();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
        tryTerminate();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tasks;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;基本流程和shutdown()类似，advanceRunState()和tryTerminate()是一样的，我们就不再赘述了，重点来看一下interruptWorkers()的逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptWorkers() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers)
                w.interruptIfStarted();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这样看很简单，就是遍历所有worker，调用其interruptIfStarted()方法，这个方法实现在Worker中，我们来看一下这个方法，也比较清晰，就是判断一下再决定是否设置线程中断标志位，可见，其和shutdown停止线程的方式是一样的，区别主要在于设置线程状态的不同以及将任务队列中的任务丢弃，即drainQueue()方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIfStarted() {
        Thread t;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;t.isInterrupted()) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                t.interrupt();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Runnable&amp;gt;&lt;span&gt; drainQueue() {
        BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt; q =&lt;span&gt; workQueue;
        ArrayList&lt;/span&gt;&amp;lt;Runnable&amp;gt; taskList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Runnable&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将阻塞队列中的任务全部移除并添加到taskList中&lt;/span&gt;
&lt;span&gt;        q.drainTo(taskList);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再检查一次队列是否有任务&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;q.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Runnable r : q.toArray(&lt;span&gt;new&lt;/span&gt; Runnable[0&lt;span&gt;])) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (q.remove(r))
                    taskList.add(r);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;7. 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;线程池中通过阻塞队列来保存接收用户提交的任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程池的基本工作单元为Worker，为实现在ThreadPoolExecutor中的内部类，继承了Runnable，它封装了驱动自己运行的线程，工作时worker会不断从任务队列中获取任务并执行；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程池内部通过一个HashSet来保存worker，这才是真的“池”；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用户通过调用线程池的execute()将任务提交给线程池，之后由线程池来统一分配线程执行任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用户可以调用shutdown()或shutdownNow()来停止线程池；&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;调用shutdown()之后线程池不再接收新的任务，但是会将任务队列中的任务执行完再逐一将线程销毁并停止线程池；　　&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用shutdownNow()之后线程池不仅不再接收新的任务，而且会将任务队列中&lt;/span&gt;未执行的任务清空丢弃，并且将待正在运行的线程执行完毕就销毁线程，然后停止线程池；　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;其实呢，在啃线程池源码的过程中，还是要费一些心思的，尤其是要弄明白如何添加任务、如何添加Worker、Worker如果工作以及如何停止Worker的工作这一整套流程，中间确实逻辑比较复杂，但是呢在探索的过程中会不断有新的发现，越啃越细，越啃越清晰。我其实也不是一两天就看明白了，最早只是大概看了一遍，然后做了一些笔记，隔了几个月之后再来看，又有新的收获，所以就有了这篇文章。看到这里说明你也看懂了，恭喜你在学习的路上又有精进了   ^_^&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 10:56:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>深入源码研究ThreadPoolExecutot线程池的原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10783012.html</dc:identifier>
</item>
</channel>
</rss>