<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用EventNext实现基于事件驱动的业务处理 - smark</title>
<link>http://www.cnblogs.com/smark/p/10920628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10920628.html</guid>
<description>&lt;p&gt;&lt;span&gt;事件驱动模型相信对大家来说并不陌生，因为这是一套非常高效的逻辑处理模型，通过事件来驱动接下来需要完成的工作，而不像传统同步模型等待任务完成后再继续！虽然事件驱动有着这样的好处，但在传统设计上基于消息回调的处理方式在业务处理中相对比较麻烦整体设计成本也比较高，所以落地也不容易。&lt;code&gt;EventNext&lt;/code&gt;是一个事件驱动的应用框架，它的事件驱动支持接口调用，在一系列的业务接口调用过程中通过事件驱动调用来完成；简单来说组件驱动的接口行为是由上一接口行为完成而触发执行，接下来介绍详细介绍一下&lt;code&gt;EventNext&lt;/code&gt;和使用。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;nextqueue&quot;&gt;NextQueue&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;EventNext&lt;/code&gt;组件有一个核心的事件驱动队列&lt;code&gt;NextQueue&lt;/code&gt;,&lt;code&gt;NextQueue&lt;/code&gt;和传统的线程队列有着很大的区别；传统队列都是线程不停的执行消息，下一个消息都是线程等待上一个消息完成后再继续。但&lt;code&gt;NextQueue&lt;/code&gt;的设计则不是，它的所有消息都基于上一个消息完成来驱动(不管上一个消息的逻辑是同步还是异步)。实际情况是&lt;code&gt;NextQueue&lt;/code&gt;触发任务的消息是启用线程工作外，后面的消息都是基于上一个消息回调执行；&lt;code&gt;NextQueue&lt;/code&gt;上的消息执行线程是不确定性也不需要等待，虽然队列里的消息执行线程不是唯一的，但执行顺序是一致的这也是&lt;code&gt;NextQueue&lt;/code&gt;所带来的好处，在有序的情况下确保线程的利用率更高。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;组件使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在使用组前需要引用组件,Nuget安装如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package EventNext
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过组件制定的业务必须以接口的方式来描述，而业务的调用也是通过接口的方式进行；虽然组件支持以消息回调的方式便不建议这样做，毕竟面向业务接口有着更好的易用性和可维护性。为了确保业务接口方式 的行为满足事件驱动队列的要求 ，所有业务行为方法必须以Task作为返回值；非Task返回值的行为方法都不能被组件注册和调用。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;接口定义和实现&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;接口的定义有一定的规则，除了方法返回值是&lt;code&gt;Task&lt;/code&gt;外，也不支持同一名称的函数进行重载，如果有需要可以使用特定的&lt;code&gt;Attribute&lt;/code&gt;来标记对应的名称（out类型参数不被支持）。以下是一个简单的接口定义:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Income(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Payout(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; Amount();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;业务实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Service(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IUserService))]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService :  IUserService
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mAmount;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; Amount()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Income(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             mAmount +=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Payout(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             mAmount -=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要通过&lt;code&gt;ServiceAttribute&lt;/code&gt;来描这个类提供那些事件驱动的接口行为。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;组件通过一个&lt;code&gt;EventCenter&lt;/code&gt;的对象来进行逻辑调用，创建该对象并注册相应业务功能的程序集即可：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EventCenter eventCenter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventCenter();
eventCenter.Register(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(Program).Assembly);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;定义&lt;code&gt;EventCenter&lt;/code&gt;加载逻辑后就可以创建代理接口调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; service=EventCenter.Create&amp;lt;IUserService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; server.Payout(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; server.Income(&lt;span&gt;10&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;事件驱动队列分配&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;组件针对不同情况的需要，可以给接口实例或方法定义不同的事件队列配置，主要为以下几种情况&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;默认&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;由组件内部队列组进行负载情况进行配置，这种分配方式会导致同一接口的方法有可能分配在不同的队列上；在默认分配下接口实例的方法会存在多线程中同时的运行，因此这种模式的应用并不是线程安全。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;actor&quot;&gt;Actor&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Actor&lt;/code&gt;相信大家也很熟悉，一种高性能一致性的调度模型；组件支持这种模型的接口实例创建，只需要在创建接口代理的时候指定&lt;code&gt;Actor&lt;/code&gt;名称即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
henry = EventCenter.Create&amp;lt;IUserService&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;henry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当指定&lt;code&gt;Actor&lt;/code&gt;名称后，这个接口的所有方法调用都会一致性到对应实例的队列中，即所有功能方法线程调用的唯一性；在接口调用返回的时候也会再次切入到其他事件驱动队列，确保&lt;code&gt;Actor&lt;/code&gt;内部的工作队列不受响后的应逻辑影响；当使用这种方式时整个Actor实例都是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;threadpool&quot;&gt;ThreadPool&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这种配置只适用于接口方法，描述方法无论什么情况都从线程池中执行相关代码，此行为的方法非线程安全&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[ThreadInvoke(ThreadType.ThreadPool)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; ThreadInvoke()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             mCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mCount.ToTask();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;singlequeue&quot;&gt;SingleQueue&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这种配置只适用于接口方法,用于描述方法不管那个实例都一致性到一个队列中，此行为的方法内线程安全，不保证对应实例是线程安全.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        [ThreadInvoke(ThreadType.SingleQueue)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; GetID([ThreadUniqueID]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!mValues.TryGetValue(name, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 value = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 value++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             mValues[name] =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.ToTask();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这配置下还可以再细分，如上面的&lt;code&gt;[ThreadUniqueID]&lt;/code&gt;对不同参数做一致性对列，这个时候name的不同值会一致性到不同的事件队列中。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;actor-&quot;&gt;Actor性能对比&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;组件默认集成了&lt;code&gt;Actor&lt;/code&gt;模型，可以通过它实现高并发无锁业务集成，&lt;code&gt;EventNext&lt;/code&gt;最大的特点是以接口的方式集成应用，相对于&lt;code&gt;akka.net&lt;/code&gt;基于消息接收的模式来说有着明显的应用优势。在性能上&lt;code&gt;EventNext&lt;/code&gt;基于接口的ask机制也比&lt;code&gt;akka.net&lt;/code&gt;基于消息receive的ask机制要高，以下是一个简单的对比测试&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;akak-net&quot;&gt;akak.net&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserActor : ReceiveActor
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserActor()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Receive&amp;lt;Income&amp;gt;(Income =&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 mAmount +=&lt;span&gt; Income.Memory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Sender.Tell(mAmount);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Receive&amp;lt;Payout&amp;gt;(Outlay =&amp;gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 mAmount -=&lt;span&gt; Outlay.Memory;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Sender.Tell(mAmount);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             Receive&amp;lt;Get&amp;gt;(Outlay =&amp;gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Sender.Tell(mAmount);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; mAmount;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;invoke&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     Income income = &lt;span&gt;new&lt;/span&gt; Income { Memory =&lt;span&gt; i };
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; nbActor.Ask&amp;lt;&lt;span&gt;decimal&lt;/span&gt;&amp;gt;&lt;span&gt;(income);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     Payout payout = &lt;span&gt;new&lt;/span&gt; Payout { Memory =&lt;span&gt; i };
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; nbActor.Ask&amp;lt;&lt;span&gt;decimal&lt;/span&gt;&amp;gt;(payout);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;event-next&quot;&gt;Event Next&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Service(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IUserService))]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService : IUserService
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mAmount;   
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; Amount()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Income(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             mAmount +=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Payout(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             mAmount -=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(mAmount);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;invoke&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; nb.Income(i);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; nb.Payout(i);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细测试代码&lt;a href=&quot;https://github.com/IKende/EventNext/tree/master/samples/EventNext_AkkaNet&quot;&gt;https://github.com/IKende/EventNext/tree/master/samples/EventNext_AkkaNet&lt;/a&gt; 在默认配置下不同并发下的测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254151/201905/254151-20190524224921791-1329186732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;event-sourcing&quot;&gt;Event Sourcing&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于事件驱动提倡的业务处理都是异步，这样就带来一个业务事务性的问题，如何确保不同接口方法业务处理一致性就比较关键了。由于不同的逻辑在不同线程中异步进行，所以相对比较好解决的就是在业务处理时引入&lt;code&gt;Event Sourcing&lt;/code&gt;.以下就简单介绍一下组件这方面的应用，就不详细介绍了。毕竟 Event Sourcing设计和业务还有着一些关系&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;long&lt;/span&gt;&amp;gt; Income(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; EventCenter.WriteEvent(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { History = user.Amount, Change = amount, Value = user.Amount +&lt;span&gt; amount });
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             user.Amount +=&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user.Amount;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;long&lt;/span&gt;&amp;gt; Pay(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; amount)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; EventCenter.WriteEvent(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { History = user.Amount, Change = -amount, Value = user.Amount -&lt;span&gt; amount });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             user.Amount -=&lt;span&gt; amount;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user.Amount;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;组件提供事件信息的读写接口&lt;code&gt;IEventLogHandler&lt;/code&gt;可以通过实现这个接口扩展自己的事件源处理。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;使用注意事项&lt;/h2&gt;
&lt;h3 id=&quot;-async-await&quot;&gt;适应async/await&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;其实整个事件队列都是使用&lt;code&gt;async/await&lt;/code&gt;,通过它大大简化了消息和回调函数间不同数据状态整合的难度。&lt;code&gt;.Net&lt;/code&gt;也现有所异步API都支持&lt;code&gt;async/wait&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;异步化设计你的逻辑&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在实现接口逻辑的情况尽可能使和异步逻辑方法，在逻辑实施过程中禁用&lt;code&gt;Task.Wait&lt;/code&gt;或一些线程相关&lt;code&gt;Wait&lt;/code&gt;的方法，特别不带超时的&lt;code&gt;Wait&lt;/code&gt;因为这种操作极容易导致事件驱动队列逻辑被挂起，导致队列无法正常工作；更糟糕的情况可能引起事件队列假死的情况。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;-api&quot;&gt;传统异步API&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于各种原因，可能还存在旧的异步API不支持&lt;code&gt;async/wait&lt;/code&gt;，出现这情况可以通过&lt;code&gt;TaskCompletionSource&lt;/code&gt;来扩展已经有的异步方法支持&lt;code&gt;async/wait&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IKende/EventNext&quot;&gt;https://github.com/IKende/EventNext&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 14:50:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>事件驱动模型相信对大家来说并不陌生，因为这是一套非常高效的逻辑处理模型，通过事件来驱动接下来需要完成的工作，而不像传统同步模型等待任务完成后再继续！虽然事件驱动有着这样的好处，但在传统设计上基于消息回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smark/p/10920628.html</dc:identifier>
</item>
<item>
<title># 【nodejs原理&amp;源码赏析（3）】欣赏手术级的原型链加工艺术 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10920388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10920388.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214501615-1328407608.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/nodejs/marvel-prototype&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;好的代码都差不多，烂的代码却各有各的烂法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-概述&quot;&gt;一. 概述&lt;/h2&gt;
&lt;p&gt;原型链是&lt;strong&gt;javascript&lt;/strong&gt;非常重要的基础知识。最近在阅读&lt;code&gt;node.js&lt;/code&gt;，发现许多代码乍一看会觉得很费解，但细细品味之后会觉得非常优雅，对于代码细节的把控和性能的考量让人觉得赞叹。不得不说看大师级的作品真的是一种享受。本篇中我将以&lt;code&gt;cluster&lt;/code&gt;模块中子进程管理对象&lt;code&gt;Worker类&lt;/code&gt;的实现为例，带你一起看看堪称艺术的代码是如何像手术一样操作原型链，同时理解本节的知识点对于下一篇&lt;code&gt;cluster&lt;/code&gt;模块的学习压力。&lt;/p&gt;
&lt;h2 id=&quot;二.-原型链基础知识&quot;&gt;二. 原型链基础知识&lt;/h2&gt;
&lt;p&gt;javascript中存在两种原型概念——内置&lt;code&gt;[[prototype]]&lt;/code&gt;属性指向的对象和&lt;code&gt;prototype&lt;/code&gt;原型对象，&lt;code&gt;prototype&lt;/code&gt;原型对象上挂载着实例上的公共方法和属性，&lt;code&gt;[[prototype]]&lt;/code&gt;属性可以通过&lt;code&gt;__proto__&lt;/code&gt;属性来访问（虽然暴露了这个属性但不推荐使用，平时更多使用&lt;code&gt;Object.getPrototypeOf( )&lt;/code&gt;方法来获取，也可以通过&lt;code&gt;Object.setPrototypeOf( )&lt;/code&gt;来修改，本文中为了书写方便继续用&lt;code&gt;__proto__&lt;/code&gt;），所一个实例的&lt;code&gt;[[prototype]]&lt;/code&gt;属性指向的并不一定是自己构造方法对应的&lt;code&gt;prototype&lt;/code&gt;原型对象。&lt;/p&gt;
&lt;p&gt;javascript中通过&lt;code&gt;new&lt;/code&gt;运算符来生成对象，生成的对象的&lt;code&gt;[[prototype]]&lt;/code&gt;属性会以一种串联的方式指向多个构造函数的原型对象，以便可以获取可被共享使用的方法，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214512783-590290505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们需要实现功能继承时，最简单的做法就是在子类的构造函数里生成一个父类的实例，然后令实例的&lt;code&gt;__proto__&lt;/code&gt;属性指向这个实例，但这样做会使得父类上一些本应被添加在实例上的属性和方法被添加到了原型链上，而不是真正的子类实例上，而继承的目的主要是为了获取父类的提供的公共的原型方法，所以&lt;code&gt;ES6&lt;/code&gt;的&lt;code&gt;extends&lt;/code&gt;语法糖实现的继承效果就是下面这个样子的，后文中我们会看到&lt;code&gt;Worker&lt;/code&gt;的原型链也是按照这样的方式来修剪的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214536445-1173808122.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三.-worker类的原型链加工&quot;&gt;三. Worker类的原型链加工&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt;的源代码在官方仓库的&lt;code&gt;lib/internal/worker.js&lt;/code&gt;，代码只有50行，用IDE折叠起来先浏览一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214547279-575718719.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们分析一下它的运作机制，首先声明了&lt;code&gt;Worker&lt;/code&gt;这个类，此时它对应的原型链如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214557231-584346501.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了&lt;code&gt;Worker&lt;/code&gt;拥有消息收发的能力，需要让它从&lt;code&gt;EventEmitter&lt;/code&gt;类来继承发布订阅能力，所以这里将&lt;code&gt;EventEmitter.prototype&lt;/code&gt;对象添加到&lt;code&gt;Worker&lt;/code&gt;的原型链中：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Object.setPrototypeOf(Worker.prototype, EventEmitter.prototype);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时的原型链就变成了下面的样子，也就是和&lt;code&gt;ES6&lt;/code&gt;中&lt;code&gt;extends&lt;/code&gt;关键字的实现的继承是一致的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214607996-1170470853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来的这句就有些费解，看起来好像没起到什么作用，你可以自己思考一下，最后我们再揭晓答案：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Object.setPrototypeOf(Worker,EventEmitter);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一图胜千言，直接看原型链结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214617979-1403356091.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的加工使得&lt;code&gt;Worker&lt;/code&gt;构造方法的&lt;code&gt;__proto__&lt;/code&gt;从&lt;code&gt;Worker.prototype&lt;/code&gt;改变到了&lt;code&gt;EventEmitter&lt;/code&gt;构造方法，这使得原型链直接变成一个三叉形，看起来非常奇怪，而且看起来&lt;code&gt;Worker&lt;/code&gt;和它的原型对象&lt;code&gt;Worker.prototype&lt;/code&gt;之间断开了联系，如果此时让你生成一个&lt;code&gt;worker&lt;/code&gt;实例，你能清楚地说出它的原型链是什么样子吗？&lt;/p&gt;
&lt;p&gt;我们先继续往后看，后面的代码在&lt;code&gt;Worker.prototype&lt;/code&gt;上添加了一些原型方法，使得原型链再一次变形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214627505-334231464.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，原型链就调整结束了，下一节我们开始看&lt;code&gt;Worker&lt;/code&gt;如何生成实例。&lt;/p&gt;
&lt;h2 id=&quot;四.-实例的生成&quot;&gt;四. 实例的生成&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;worker&lt;/code&gt;的实例化是在&lt;code&gt;lib/internal/cluster/master.js&lt;/code&gt;中，也就是主线程中生成子线程时调用的，调用的语句是：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; const worker = new Worker({
    id: id,
    process: workerProcess
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说它是通过&lt;code&gt;new&lt;/code&gt;操作符来生成实例的。&lt;code&gt;Worker&lt;/code&gt;构造方法中的核心语句如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Worker(options){
    if(!(this instanceof Worker)){
        return new Worker(options)
    }
    EventEmitter.call(this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先对于&lt;code&gt;this&lt;/code&gt;的判断是用来限制&lt;code&gt;Worker&lt;/code&gt;只能作为构造函数使用，因为此时&lt;code&gt;this&lt;/code&gt;会指向实例，如果&lt;code&gt;this&lt;/code&gt;并不是&lt;code&gt;Worker&lt;/code&gt;的实例，就说明Worker是作为方法调用的，此时会自动用&lt;code&gt;new&lt;/code&gt;操作符来生成实例，如果你它的机制还不清楚，可以先阅读以下Mozilla开发者文档（&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;【MDN中对于new算法的描述】&lt;/a&gt;），基本算法是这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;1.生成一个新的空对象；
2.将空对象的.__proto__指向构造函数的原型对象;
3.将这个空对象绑定为this指向然后传入构造函数来运行;
4.如果构造函数有返回值，则将返回值作为实例返回，如果没有则将之前生成的空对象作为实例返回。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上面的描述，当函数被执行到&lt;code&gt;Worker&lt;/code&gt;构造方法的函数体中时，原型链是下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214641823-168383185.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来执行的是:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;EventEmitter.call(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是将实例作为&lt;code&gt;this&lt;/code&gt;透传到&lt;code&gt;EventEmitter&lt;/code&gt;构造方法中去执行，在官方文档中可以找到它实际上执行的是&lt;code&gt;EventEmitter.init&lt;/code&gt;方法，语句只有几行，但非常有意思：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;EventEmitter.init = function(){
    if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果实例上没有&lt;code&gt;_events&lt;/code&gt;属性，或者它的&lt;code&gt;_events&lt;/code&gt;属性存在于自己的原型链上，那么就使用&lt;code&gt;Object.create(null)&lt;/code&gt;生成一个空对象，就直接在实例上添加&lt;code&gt;_events&lt;/code&gt;属性和&lt;code&gt;_eventsCount&lt;/code&gt;属性并赋值。空对象字面量和&lt;code&gt;Object.create(null)&lt;/code&gt;生成的对象原型链是不一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214656181-1366538108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后者生成的对象原型链更短，对象的本质是一种散列结构，你新生成的对象很可能只是用来存储一些键值对的映射关系而并不是为了当做对象实例在使用，后一种结构在查找某个属性时需要遍历的属性就更少，效率也会高一些。&lt;/p&gt;
&lt;p&gt;至此实例就生成完毕了，它最终的原型链是下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214704605-1240201297.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;Worker&lt;/code&gt;虽然继承了&lt;code&gt;EventEmitter&lt;/code&gt;的消息收发能力，但是却并没有生成完整的&lt;code&gt;EventEmitter&lt;/code&gt;实例，而只是将必须拥有的实例属性添加在了子类的实例对象上，在实现能力的同时也保持原型链结构的最小化，避免冗余，这一波干净利落的原型链加工真的太秀了，不得不说&lt;code&gt;node.js&lt;/code&gt;的细节处理真的堪称艺术。&lt;/p&gt;
&lt;h2 id=&quot;五.-最后一个问题&quot;&gt;五. 最后一个问题&lt;/h2&gt;
&lt;p&gt;前面我们还遗留了一个问题，还记得吗？&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Object.setPrototypeOf(Worker,EventEmitter)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以很清楚地看到实例的原型链和上面这条语句实现的功能没什么关系。事实上它的作用是&lt;strong&gt;为了让子类继承父类的静态方法&lt;/strong&gt;，一张图就能解决的问题，我就不再多bibi了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190524214716536-339125577.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的目的就是为了尽可能完整地实现面向对象的特性，使得你可以直接通过&lt;code&gt;Worker&lt;/code&gt;构造函数来访问到&lt;code&gt;EventEmitter&lt;/code&gt;上的静态属性和方法，你可以在本文提供的demo中看到。&lt;/p&gt;
&lt;h2 id=&quot;六.-一些心得&quot;&gt;六. 一些心得&lt;/h2&gt;
&lt;p&gt;阅读经典源码是一个非常缓慢且吃力的事情，尤其是没人带没人交流时，但是如果开始了，就请一定保持耐心。比如上面的代码仅仅是&lt;code&gt;cluster&lt;/code&gt;模块中很小的一部分，只有短短50行，如果基础薄弱可能要花很久才能消化其中的东西，但是它能够教给你的原型链知识和对开发细节的把控能力，是你读5000行垃圾代码也无法学习到的。&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 13:49:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashnowords/p/10920388.html</dc:identifier>
</item>
<item>
<title>自动检测ARouter路由地址分组使用冲突问题 - HappyCorn</title>
<link>http://www.cnblogs.com/lwbqqyumidi/p/10920264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwbqqyumidi/p/10920264.html</guid>
<description>&lt;div readability=&quot;87.004524886878&quot;&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;项目中使用ARouter进行路由，由于不同上层业务模块都能都会使用到同一目标的路由地址，因此，将所有业务模块路由地址以一种类似静态常量的方式设置在Base模块中。这样，在实际目前上加上对应此地址的注解，就可以将其对应加入到路由中。使用方通过ARouter对应的地址方式去路由，即可访问到对应的目标。&lt;/p&gt;
&lt;p&gt;以Activity路由为例，通过注解，编译后在对应模块路径下生成的文件名为Arouter$$Group$$GroupName1.java文件。其中GroupName1为分组名。 具体路径为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;/build/generated/&lt;span class=&quot;hljs-built_in&quot;&gt;source/kapt/变体/com/alibaba/android/arouter/routes/
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原则上，不同模块应该注解到不同的路由地址分组。否则不同的模块下编译后会生成相同的Arouter$$Group$$GroupName1.java文件，在项目构建安装后，会发生不可预期的路由地址失败问题（如其中一个Arouter$$Group$$GroupName1.java文件中的路由生效，另一个直接路由失败）。&lt;/p&gt;
&lt;p&gt;网上查了下，发现同样问题，其他人也有遇到，具体问题描述GitHub上ARouter项目中issues等： &lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Falibaba%2FARouter%2Fissues%2F296&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github.com/alibaba/ARo…&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Falibaba%2FARouter%2Fissues%2F348&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github.com/alibaba/ARo…&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Falibaba%2FARouter%2Fissues%2F624&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github.com/alibaba/ARo…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近期，项目中在进行模块化改进时，由于部分注解了路由地址的目标文件被同事从一个模块移动到另一个模块，导入出现同样问题发。原因在于，如果直接通过Android Studio中的三角形绿色图标直接run android app时，对于不同模块下生成的同名java文件在编译及打包组装过程中是不会提示如下信息的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;* What went wrong:
Execution failed &lt;span class=&quot;hljs-keyword&quot;&gt;for task &lt;span class=&quot;hljs-string&quot;&gt;':app:transformClassesWithJarMergingForDevDebug'.
&amp;gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/alibaba/android/arouter/routes/ARouter$&lt;span class=&quot;hljs-variable&quot;&gt;$Group$&lt;span class=&quot;hljs-variable&quot;&gt;$trans_second.class
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果直接通过./gradlew命令方式构建，是可以直接出现如上错误提示的。大多数情况下，项目开发中直接通过run构建，使得此问题直接被隐藏。&lt;/p&gt;
&lt;br/&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;分析与解决&lt;/h3&gt;
&lt;p&gt;对比两者实际上构建流程上的差异，发现通过./gradlew命令方式构建，在执行task&lt;code&gt;app:transformClassesWithJarMergingForDevDebug&lt;/code&gt;时会抛出duplicate entry class错误，但Android Studio直接run则没有执行。&lt;/p&gt;
&lt;p&gt;为了兼容Android Studio直接run形式，在开发人员开发阶段早些发现此类问题，可以自己实现一个task，加入到构建过程中的适当阶段，以自动检测在不同模块下ARouter生成的文件重复问题。&lt;/p&gt;
&lt;p&gt;具体思路：&lt;br/&gt;分别并统计项目中各个模块中ARouter生成的java文件，并计次数（次要区分构建类型，一个构建类型算唯一的一次即可，否则对于多个变体情况下会重复计算），对于同一构建类型，对于同样的文件名，生成的文件次数多余1，显然应该直接构建失败，并给出具体提示。&lt;/p&gt;
&lt;p&gt;实现：&lt;br/&gt;1，首先自定义task，实现次数检测和统计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;task checkARouterDuplicatedJavaFiles {
    &lt;span class=&quot;hljs-keyword&quot;&gt;doLast {
        def fileMap = [:]
        def buildTypeList = []
        def hasPathBuildTypeList = []

        project.extensions.findByName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;android&quot;).applicationVariants.all { variant -&amp;gt;
            def buildTypeName = variant.buildType.name
            &lt;span class=&quot;hljs-keyword&quot;&gt;if(!buildTypeList.contains(buildTypeName)) {
                buildTypeList.add(buildTypeName)
            }
        }

        project.rootProject.subprojects { subProject -&amp;gt;
            def subProjectBuildDir

            try {
                subProjectBuildDir = subProject.buildDir

                &lt;span class=&quot;hljs-keyword&quot;&gt;if (subProjectBuildDir == null) &lt;span class=&quot;hljs-built_in&quot;&gt;return

                subProjectBuildDir.eachFileRecurse(FileType.DIRECTORIES) { dir -&amp;gt;
                    &lt;span class=&quot;hljs-keyword&quot;&gt;if (dir.path.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/generated/source/kapt/&quot;) &amp;amp;&amp;amp; dir.path.endsWith(&lt;span class=&quot;hljs-string&quot;&gt;&quot;com/alibaba/android/arouter/routes&quot;)) {
                        def filePrefix = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;
                        &lt;span class=&quot;hljs-keyword&quot;&gt;for (buildType &lt;span class=&quot;hljs-keyword&quot;&gt;in buildTypeList) {
                            &lt;span class=&quot;hljs-keyword&quot;&gt;if(dir.path.toLowerCase().contains(buildType + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;)
                                    &amp;amp;&amp;amp; !hasPathBuildTypeList.contains(subProject.getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/generated/source/kapt/&quot; + buildType + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;)){

                                filePrefix = buildType + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;
                                dir.eachFile(FileType.FILES) { file -&amp;gt;
                                    &lt;span class=&quot;hljs-keyword&quot;&gt;if (fileMap[filePrefix + file.name] == null) {
                                        fileMap[filePrefix + file.name] = 0
                                    }
                                    fileMap[filePrefix + file.name]++
                                }

                                hasPathBuildTypeList.add(subProject.getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/generated/source/kapt/&quot; + filePrefix)
                                &lt;span class=&quot;hljs-built_in&quot;&gt;return
                            }
                        }
                    }
                }
            } catch (Exception e) {
                // ignore
                println e.toString()
            }
        }

        fileMap.each { key, value -&amp;gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (value &amp;gt; 1) {
                throw new GradleException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ARouter: &quot; + key + &lt;span class=&quot;hljs-string&quot;&gt;&quot; fileCount: &quot; + value + &lt;span class=&quot;hljs-string&quot;&gt;&quot; ,路由地址设置有误！&quot;)
            }
        }
    }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中的hasPathBuildTypeList逻辑是因为app module中的变体与library module中的变体设置不一样，以处理对应的兼容逻辑。&lt;/p&gt;
&lt;p&gt;2，将此task加入到构建流程的适当阶段。通过对比实际的构建过程中执行的task列表，最终决定将名称含有“package”的task依赖自定义的&lt;code&gt;checkARouterDuplicatedJavaFiles&lt;/code&gt;task，并将自定义的task依赖名称含有“transformClassesWithCom.alibaba.arouter”的task。 具体实现为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;project.tasks.whenTaskAdded { Task task -&amp;gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (task.name.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;package&quot;)) {
        task.dependsOn(checkARouterDuplicatedJavaFiles)
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (task.name.contains(&lt;span class=&quot;hljs-string&quot;&gt;&quot;transformClassesWithCom.alibaba.arouter&quot;)) {
        checkARouterDuplicatedJavaFiles.dependsOn(task)
    }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终可以确保自定义的&lt;code&gt;checkARouterDuplicatedJavaFiles&lt;/code&gt;task可以在构建过程中完成对应的检测。 如果通过./gradlew命令构建，依然可以达到以系统task&lt;code&gt;app:transformClassesWithJarMergingForDevDebug&lt;/code&gt;为先。&lt;/p&gt;
&lt;p&gt;通过Android Studio run，如果重现此类情形，最终效果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;org.gradle.api.tasks.TaskExecutionException: Execution failed &lt;span class=&quot;hljs-keyword&quot;&gt;for task &lt;span class=&quot;hljs-string&quot;&gt;':app:checkARouterDuplicatedJavaFiles'.
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:100)
        ...
        at java.lang.Thread.run(Thread.java:745)
Caused by: org.gradle.api.GradleException: ARouter: release/ARouter$&lt;span class=&quot;hljs-variable&quot;&gt;$Group$&lt;span class=&quot;hljs-variable&quot;&gt;$trans_second.java fileCount: 2 ,路由地址设置有误！
        at build_4p6esrqwzg61igroldd1aht2w&lt;span class=&quot;hljs-variable&quot;&gt;$_run_closure5&lt;span class=&quot;hljs-variable&quot;&gt;$_closure42.doCall(/Users/corn/AndroidStudioProjects/MyCorn/&lt;/span&gt;app&lt;span class=&quot;hljs-variable&quot;&gt;/build.gradle:395)
        ...

&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建失败，并给出提示。&lt;/p&gt;
&lt;br/&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;ARouter官方建议在不同的模块下本就不应该使用同样的分组，分组名可以使用模块名或其他名称，分组名与模块本质上是一种映射关系。但无论如何设置，考虑到其他模块需要使用到此路由地址，当这种映射关系与模块化结合时，这一可能存在冲突的矛盾直接在分组名的定义上，通过技术手段是无法直接隔离开的。因此，考虑通过自定义task并加入到构建过程中的适当阶段，以完成潜在的可能的人为失误，是一种有效方案。&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;</description>
<pubDate>Fri, 24 May 2019 13:22:00 +0000</pubDate>
<dc:creator>HappyCorn</dc:creator>
<og:description>背景 项目中使用ARouter进行路由，由于不同上层业务模块都能都会使用到同一目标的路由地址，因此，将所有业务模块路由地址以一种类似静态常量的方式设置在Base模块中。这样，在实际目前上加上对应此地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwbqqyumidi/p/10920264.html</dc:identifier>
</item>
<item>
<title>Django2.2使用mysql数据库pymysql版本不匹配问题的解决过程与总结 - 漫漫芜</title>
<link>http://www.cnblogs.com/sheshouxin/p/10920255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheshouxin/p/10920255.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前置条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;django版本：2.2.1&lt;/p&gt;
&lt;p&gt;python版本：3.6.6&lt;/p&gt;
&lt;p&gt;mysql版本：mysql-community8.0.15&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在搭建django项目，配置mysql数据库时遇到无法迁移数据库的问题，错误信息如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201905/1606258-20190524192913581-1861554568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由错误信息，可大致看出是一个叫mysqlclient的包版本不匹配导致的问题。&lt;/p&gt;
&lt;p&gt;搜索引擎检索相关错误，得知：python访问mysql需要安装对应的驱动包，即将mysql的API接口转换成python格式供数据库应用软件开发者直接调用的第三方库。django2.2默认使用“mysqlclient”这个库去连接mysql，而网上很多教程中使用的是“pymysql”。这两个库有什么区别呢？继续搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pymysql、mysqlclient与mysqldb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pypi中关于pymsql的说明：最新版本0.9.3，用纯python语言开发的mysql驱动库，大部分API与mysqlclient和MySQLdb兼容，python2只支持2.7版本，python3版本支持3.4及以上版本，mysql版本要求5.5版本及以上。&lt;/p&gt;
&lt;p&gt;pypi中关于mysqlclient的说明：最新版本1.4.2，是MySQLdb1的分支，支持python3。&lt;/p&gt;
&lt;p&gt;pypi中关于mysqldb的说明：包名称为MySQL-python，mysql数据库的接口库，支持mysql数据库3.23-5.5版本，支持python2.4-2.7版本，线程安全。&lt;/p&gt;
&lt;p&gt;此时，错误信息中的两个版本号就可以解释了，因为我按网上教程，在django配置文件settings.py中使用了pymsql来连接mysql数据库，这是报错的原因。为什么错误信息中提示我的myclient版本是0.9.3？猜想（没有验证）是因为“pymysql.install_as_MySQLdb()”这行代码，因为django而默认使用mysqldb（或myclient，一个东西，可看成python2和python3的对应版本），而pymysql是一个很方便的支持python3的mysql数据库驱动库，所以把它以mysqldb的名字安装，此时django把pymsql的版本号当成myclient的版本号输出。&lt;/p&gt;
&lt;p&gt;到这里，问题解决的思路就比较明确了，两种方式：一种是修改django的源码，让版本号通过校验；另一种是安装合适的myclient版本。&lt;/p&gt;
&lt;p&gt;在选择解决方案之前，心中有个疑惑还没有解决：pymysql和myclient都提供mysql数据库的python版API，用哪个好？继续搜索引擎大法。&lt;/p&gt;
&lt;p&gt;一通对比搜索后，找到下面三篇看上去比较严谨可信的文章：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u011510825/article/details/86632598&lt;/p&gt;
&lt;p&gt;https://my.oschina.net/sukai/blog/1930092&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/sigmarising/article/details/83473039&lt;/p&gt;
&lt;p&gt;总结起来就是：mysqldb（mysqlclient）C语言开发，速度相比pymysql优势明显；pymysql由于纯python开发，与python无缝对接，使用、安装方便，反而用的人更多；mysqlclient对mysql8的默认用户加密方式 &lt;code&gt;caching_sha2_password不支持（未验证）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;经过一翻对比，决定使用mysqlclient，一是考虑其性能更好，二是不想随意修改django源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysqlclient安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;果不其然，mysqlclient的安装并不顺利，使用pip指令安装直接报错，错误信息如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1606258/201905/1606258-20190524205336992-1467049780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续搜索，查到是因为mysql-devel没安装，顺便检索到mysql-devel的作用：header files, debug symbols. Required when building source packages that requires them，里面包含了C语言的一些头文件，想要编译安装mysql的其它客户端程序时，需要用到这个库。&lt;/p&gt;
&lt;p&gt;centos系统下输入rpm查找指令：rpm -qa|grep mysql查看mysql安装信息，发现确实没有安装mysql-devel，于是下载与已安装的mysql服务相同版本号（不同版本可能又会引出其它问题）的mysql-devel库的rpm包，安装成功后再次使用pip命令安装myclient库，成功。&lt;/p&gt;
&lt;p&gt;修改django全局配置文件settings.py，取消导入pymysql库，注释代码pymysql.install_as_MySQLdb()，再次迁移数据库，成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上是在学习django过程中遇到的一个小问题，从一个小问题一层层深入、分析问题的原因，从问题中引出新的问题，层层递进，可以由一点串成一条线甚至到一张网（如果时间允许的话）。问题本身意义不大，但自觉在解决这个问题的过程中层层递进，由点到线的学习思想很有总结意义，特记录于此，也可供更多人学习、参考。&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 13:19:00 +0000</pubDate>
<dc:creator>漫漫芜</dc:creator>
<og:description>django连接mysql数据库时，pymysql版本不匹配问题的解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheshouxin/p/10920255.html</dc:identifier>
</item>
<item>
<title>图像分类丨Inception家族进化史「GoogleNet、Inception、Xception」 - vincent1997</title>
<link>http://www.cnblogs.com/vincent1997/p/10920036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vincent1997/p/10920036.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Google提出的Inception系列是分类任务中的代表性工作，不同于VGG简单地堆叠卷积层，Inception重视网络的拓扑结构。本文关注Inception系列方法的演变，并加入了Xception作为对比。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;PS1：这里有一篇blog，作者Bharath Raj简洁明了地介绍这系列的工作：&lt;a href=&quot;https://towardsdatascience.com/a-simple-guide-to-the-versions-of-the-inception-network-7fc52b863202%EF%BC%8C%E5%BC%BA%E7%83%88%E5%BB%BA%E8%AE%AE%E9%98%85%E8%AF%BB&quot; class=&quot;uri&quot;&gt;https://towardsdatascience.com/a-simple-guide-to-the-versions-of-the-inception-network-7fc52b863202，强烈建议阅读&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS2：我看了比较多的blog，都没有介绍清楚V2和V3的区别。主要是因为V2的提出涉及到两篇paper，并且V2和V3是在一篇论文中提到的。实际上，它们两者的区别并不大。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;inceptionv1&quot;&gt;InceptionV1&lt;/h2&gt;
&lt;p&gt;Going Deeper with Convolutions&lt;/p&gt;
&lt;h3 id=&quot;核心思想&quot;&gt;核心思想&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;由于图像的突出部分可能有极大的尺寸变化，这为卷积操作选择正确的内核大小创造了困难，比如更全局的信息应该使用大的内核，而更局部的信息应该使用小内核。不妨在同一级运行多种尺寸的滤波核，让网络本质变得更&quot;宽&quot;而不是”更深“。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202550402-1029893671.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提出Inception模块（左），具有三种不同的滤波器（1x1,3x3,5x5）和max pooling。为降低计算量，GooLeNet借鉴Network-in-Network的思想，用1x1卷积降维减小参数量（右）。可在保持计算成本的同时增加网络的深度和宽度。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202549905-750605951.png&quot; alt=&quot;1558666788758&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络架构&quot;&gt;网络架构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GoogLeNet具有9个Inception模块，22层深（27层包括pooling），并在最后一个Inception模块使用全局池化。&lt;/li&gt;
&lt;li&gt;由于网络深度，将存在梯度消失&lt;em&gt;vanishing gradient&lt;/em&gt;的问题。&lt;/li&gt;
&lt;li&gt;为了防止网络中间部分消失，作者提出了两个辅助分类器&lt;em&gt;auxiliary classifiers&lt;/em&gt;（紫色），总损失是实际损失和辅助损失的加权求和。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# The total loss used by the inception net during training.
total_loss = real_loss + 0.3 * aux_loss_1 + 0.3 * aux_loss_2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202549517-675993077.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202549072-1055863136.png&quot; alt=&quot;1558666809958&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验结果&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202548582-1427543952.png&quot; alt=&quot;1558666832773&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;inceptionv2&quot;&gt;InceptionV2&lt;/h2&gt;
&lt;p&gt;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&lt;/p&gt;
&lt;p&gt;Rethinking the Inception Architecture for Computer Vision&lt;/p&gt;
&lt;h3 id=&quot;核心思想-1&quot;&gt;核心思想&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;使用Batch Normalization&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;将输出归一化为N(0,1正态分布，一方面可以采用较大的学习速率，加快收敛；另一方面BN具有正则效应。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202547963-1096823230.png&quot; alt=&quot;1558680941376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202547391-935672466.png&quot; alt=&quot;1558680956115&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;卷积分解Factorizing Convolutions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;当卷积没有彻底改变输入维度时，神经网络表现更好。过度减小尺寸会导致信息丢失，称为&quot;representational bottleneck&quot;，巧妙地使用分解(factorization)方法，可提高卷积的计算效率。&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;分解为更小的卷积&lt;/strong&gt;：&lt;span class=&quot;math inline&quot;&gt;\(5\times5\)&lt;/span&gt;卷积可分解为两个&lt;span class=&quot;math inline&quot;&gt;\(3\times3\)&lt;/span&gt;卷积以提升计算效率，计算效率为原来的&lt;span class=&quot;math inline&quot;&gt;\(\frac{3\times3+3\times3}{5\times5}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分解为非对称卷积&lt;/strong&gt;：&lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt;卷积可分解为&lt;span class=&quot;math inline&quot;&gt;\(1\times n\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(n \times 1\)&lt;/span&gt;的卷积。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202546923-409128095.png&quot; alt=&quot;1558684519671&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Inception的演化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;a为InceptionV1；用两个3x3卷积替换5x5得到b；再将3x3卷积分解为3x1、1x3得c；在高层特征中，卷积组被拓展为d已产生更多不一样的特征。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202546393-358613488.png&quot; alt=&quot;1558684267707&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下采样模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;InceptionV3不再使用max pooling下采样，这样导致信息损失较大。于是作者想用conv升维，然后再pooling，但会带来较大的计算量，所以作者设计了一个并行双分支的结构&lt;em&gt;Grid Size Reduction&lt;/em&gt;来取代max pooling。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202545852-940125910.png&quot; alt=&quot;1558698302811&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202545522-1731025908.png&quot; alt=&quot;1558698431338&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络结构&quot;&gt;网络结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202545036-933230594.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;figure5、figure6、figure7分别表示上图的b、c、d&lt;/em&gt;，每种block之间加入Grid Size Reduction。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202544377-734143064.png&quot; alt=&quot;1558698621846&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验结果-1&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Inceptionv2达到23.4%，而Inceptionv3是指在Inceptionv2上同时使用RMSProp、Label Smoothing和分解7x7卷积、辅助分类器使用BN。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202543763-1202237382.png&quot; alt=&quot;1558686108083&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;inceptionv3&quot;&gt;InceptionV3&lt;/h2&gt;
&lt;p&gt;Rethinking the Inception Architecture for Computer Vision&lt;/p&gt;
&lt;h3 id=&quot;核心思想-2&quot;&gt;核心思想&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;作者指出，辅助分类器在训练即将结束时准确度接近饱和时才会有大的贡献。因此可以作正则化regularizes。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;V3在V2上作了如下改进，见V2实验结果：
&lt;ol&gt;&lt;li&gt;RMSProp Optimizer&lt;/li&gt;
&lt;li&gt;分解7x7的卷积&lt;/li&gt;
&lt;li&gt;辅助分类器采用BatchNorm&lt;/li&gt;
&lt;li&gt;Label Smoothing，防止过拟合。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实验结果-2&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202543107-716459719.png&quot; alt=&quot;1558681467663&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;inceptionv4&quot;&gt;InceptionV4&lt;/h2&gt;
&lt;p&gt;Inception-ResNet and the Impact of Residual Connections on Learning&lt;/p&gt;
&lt;p&gt;这篇文章结合ResNet和Inception提出了三种新的网络结构&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Inception-ResNet-v1：混合版Inception，和InceptionV3有相同计算成本。&lt;/li&gt;
&lt;li&gt;Inception-ResNet-v2：计算成本更高，显著提高performance。&lt;/li&gt;
&lt;li&gt;InceptionV4：纯Inception变体，无residual连接，媲美Inception-ResNetV2&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;核心思想-3&quot;&gt;核心思想&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;InceptionV4是对原来的版本进行了梳理，因为原始模型是采用分区方式训练，而迁移到TensorFlow框架后可以对Inception模块进行一定的规范和简化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网络架构-1&quot;&gt;网络架构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Stem：Inception-ResNetV1采用了top，Inceptionv4和Inception-ResNetV2采用了bottom。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202542367-426659627.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Inception modules A,B,C&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202541622-637796509.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reduction Blocks A,B&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202540882-1474240887.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202540364-1645638479.png&quot; alt=&quot;1558687320681&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;inception-resnet&quot;&gt;Inception-ResNet&lt;/h2&gt;
&lt;h3 id=&quot;核心思想-4&quot;&gt;核心思想&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;受ResNet启发，提出一种混合版的Inception。Inception-ResNet有v1、v2版本。&lt;/strong&gt;
&lt;ol&gt;&lt;li&gt;Inception-ResNetV1计算量与InceptionV3相似，Inception-ResNetV2计算量与InceptionV4相似。&lt;/li&gt;
&lt;li&gt;它们有不同的steam。&lt;/li&gt;
&lt;li&gt;它们的A、B、C模块相同，区别在于超参数设置。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202539791-1124201828.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当卷积核数量超过1000时，更深的单元会导致网络死亡。因此为了增加稳定性，作者对残差激活值进行0.1-0.3的缩放。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络架构-2&quot;&gt;网络架构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Steam：见InceptionV4&lt;/li&gt;
&lt;li&gt;Inception-ResNet Module A,B,C&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202539366-1519285794.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Residual Blocks A,B&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202538806-2018434932.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202538196-122808744.png&quot; alt=&quot;1558688704111&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验结果-3&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202537366-1256486700.png&quot; alt=&quot;1558688933305&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;xception&quot;&gt;Xception&lt;/h2&gt;
&lt;h3 id=&quot;核心思想-5&quot;&gt;核心思想&lt;/h3&gt;
&lt;p&gt;Xception: Deep Learning with Depthwise Separable Convolutions&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;借鉴depth wise separable conv改进InceptionV3。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;Inception基于假设：卷积时将通道和空间卷积分离会更好。其1x1的卷积作用于通道，3x3的卷积同时作用于通道和空间，没有做到完全分离。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Xception(Extream Inception)则让3x3卷积只作用于一个通道的特征图，从而实现了完全分离。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;InceptionV3到Xception的演化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202536700-2017038605.png&quot; alt=&quot;1558690123450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202535964-2112614161.png&quot; alt=&quot;1558690140937&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202535346-1634287979.png&quot; alt=&quot;1558690150713&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202534803-407861535.png&quot; alt=&quot;1558690159562&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Xception与depthwise separable conv的不同之处：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;em&gt;depthwise separable conv先对通道进行卷积再1x1卷积，而Xception先1x1卷积，再对通道卷积。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;depthwise separable conv两个卷积间不带激活函数，Xception会经过ReLU。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;网络架构-3&quot;&gt;网络架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202534205-104204888.png&quot; alt=&quot;1558690223181&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验结果-4&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202533551-250557822.png&quot; alt=&quot;1558690259737&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/201905/1519578-20190524202533049-1961564603.png&quot; alt=&quot;1558690273755&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;[1]Szegedy C, Liu W, Jia Y, et al. Going deeper with convolutions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 1-9.&lt;/p&gt;
&lt;p&gt;[2]Ioffe S, Szegedy C. Batch normalization: Accelerating deep network training by reducing internal covariate shift[J]. arXiv preprint arXiv:1502.03167, 2015.&lt;/p&gt;
&lt;p&gt;[3]Szegedy C, Vanhoucke V, Ioffe S, et al. Rethinking the inception architecture for computer vision[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 2818-2826.&lt;/p&gt;
&lt;p&gt;[4]Szegedy C, Ioffe S, Vanhoucke V, et al. Inception-v4, inception-resnet and the impact of residual connections on learning[C]//Thirty-First AAAI Conference on Artificial Intelligence. 2017.&lt;/p&gt;
&lt;p&gt;[5]Chollet F. Xception: Deep learning with depthwise separable convolutions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1251-1258.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://towardsdatascience.com/a-simple-guide-to-the-versions-of-the-inception-network-7fc52b863202&quot;&gt;A Simple Guide to the Versions of the Inception Network&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50754671&quot;&gt;&lt;em&gt;Inception&lt;/em&gt;模型进化史：从GoogLeNet到&lt;em&gt;Inception&lt;/em&gt;-ResNet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38567468&quot;&gt;关于&lt;em&gt;Xception&lt;/em&gt;，你需要知道这些&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 12:22:00 +0000</pubDate>
<dc:creator>vincent1997</dc:creator>
<og:description>﻿ 引言 Google提出的Inception系列是分类任务中的代表性工作，不同于VGG简单地堆叠卷积层，Inception重视网络的拓扑结构。本文关注Inception系列方法的演变，并加入了Xce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vincent1997/p/10920036.html</dc:identifier>
</item>
<item>
<title>python网络-多任务实现之协程 - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/10915263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/10915263.html</guid>
<description>&lt;h3&gt;一、协程&lt;/h3&gt;
&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;
&lt;p&gt;协程不是进程，也不是线程，它就是一个函数，一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。所以说，协程与进程、线程相比，不是一个维度的概念。&lt;/p&gt;
&lt;p&gt;一个进程可以包含多个线程，一个线程也可以包含多个协程，也就是说，一个线程内可以有多个那样的特殊函数在运行。但是有一点，必须明确，一个线程内的多个协程的运行是串行的。如果有多核CPU的话，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内的多个协程却绝对串行的，无论有多少个CPU（核）。这个比较好理解，毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但是这些函数都是串行运行的。当一个协程运行时，其他协程必须挂起。&lt;/p&gt;
&lt;p&gt;通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定&lt;/p&gt;
&lt;h3&gt;二、yield实现协程&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; A():
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----A---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         time.sleep(0.3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; B(c):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----B---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        next(c)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         time.sleep(0.3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     a =&lt;span&gt; A()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     B(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
----B---
----A---
----B---
----A---
----B---
----A---
----B---
----A---
----B---
----A---&lt;br/&gt;省略。。。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;p&gt;第17行：调用函数B，并把a传递进去。执行打印B的代码，代码执行到next(c)时，会调用函数A，执行打印A的代码，当代码实行带第6行遇到yield的实行，该协程进入等待状态，回到原来next(c)处继续执行，&lt;strong&gt;从而实现多协程的切换，通过yield关键字。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;三、greenlet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、greenlet实现多任务协程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单，在使用前先要确保greenlet模块安装&lt;/p&gt;
&lt;p&gt;使用如下命令安装greenlet模块:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo pip install greenlet
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding = utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    gr2.switch()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    gr1.switch()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

gr1 &lt;/span&gt;=&lt;span&gt; greenlet(test1)
gr2 &lt;/span&gt;=&lt;span&gt; greenlet(test2)
gr1.switch()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;当创建一个greenlet时，首先初始化一个空的栈， switch到这个栈的时候，会运行在greenlet构造时传入的函数（首先在test1中打印 1）， 如果在这个函数（test1）中switch到其他协程（到了test2 打印3），那么该协程会被挂起，等到切换回来（在test1切换回来 打印2）。当这个协程对应函数执行完毕，那么这个协程就变成dead状态。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;注意 上面没有打印test2的最后一行输出 4，因为在test2中切换到gr1之后挂起，但是没有地方再切换回来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、greenlet的模块与类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们首先看一下greenlet这个module里面的属性&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; dir(greenlet)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GREENLET_USE_GC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GREENLET_USE_TRACING&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GreenletExit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_C_API&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__version__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;getcurrent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gettrace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;greenlet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;settrace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，比较重要的是getcurrent()， 类greenlet、异常类GreenletExit。&lt;/p&gt;
&lt;p&gt;getcurrent()返回当前的greenlet实例；&lt;/p&gt;
&lt;p&gt;GreenletExit：是一个特殊的异常，当触发了这个异常的时候，即使不处理，也不会抛到其parent（后面会提到协程中对返回值或者异常的处理）&lt;/p&gt;
&lt;p&gt;然后我们再来看看greenlet.greenlet这个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;dir(greenlet.greenlet)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GreenletExit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__bool__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dir__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__format__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ge__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getattribute__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getstate__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__gt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__hash__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init_subclass__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__le__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__lt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ne__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce_ex__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__sizeof__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__subclasshook__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_stack_saved&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;getcurrent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gettrace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gr_frame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;settrace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较重要的几个属性：&lt;/p&gt;
&lt;p&gt;　　run：当greenlet启动的时候会调用到这个callable，如果我们需要继承greenlet.greenlet时，需要重写该方法&lt;/p&gt;
&lt;p&gt;　　switch：前面已经介绍过了，在greenlet之间切换&lt;/p&gt;
&lt;p&gt;　　parent：可读写属性，后面介绍&lt;/p&gt;
&lt;p&gt;　　dead：如果greenlet执行结束，那么该属性为true&lt;/p&gt;
&lt;p&gt;　　throw：切换到指定greenlet后立即跑出异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章后面提到的greenlet大多都是指greenlet.greenlet这个class，请注意区别&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;对于greenlet，最常用的写法是 x = gr.switch(y)。 这句话的意思是切换到gr，传入参数y。当从其他协程（&lt;em&gt;不一定是这个gr&lt;/em&gt;）切换回来的时候，将值付给x。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1(x, y):
    z &lt;/span&gt;= gr2.switch(x +&lt;span&gt; y)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; z)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2(a):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; a)
    gr1.switch(&lt;/span&gt;10&lt;span&gt;)


gr1 &lt;/span&gt;=&lt;span&gt; greenlet.greenlet(test1)
gr2 &lt;/span&gt;=&lt;span&gt; greenlet.greenlet(test2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(gr1.switch(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;test2:HelloWorld
test1:&lt;/span&gt;10&lt;span&gt;
None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子，第10行从main greenlet切换到了gr1，test1第3行切换到了gs2，然后gr1挂起，第7行从gr2切回gr1时，将值（10）返回值给了 z。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、greenlet生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　文章开始的地方提到第一个例子中的gr2其实并没有正常结束，我们可以借用greenlet.dead这个属性来查看&lt;/p&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     gr2.switch(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1: finished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2(x):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2:first %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    gr1.switch()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2:back&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; gr1 =&lt;span&gt; greenlet.greenlet(test1)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; gr2 =&lt;span&gt; greenlet.greenlet(test2)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;gr1.switch()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gr1 is dead? : %s, gr2 is dead? :%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (gr1.dead, gr2.dead))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;gr2.switch()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gr1 is dead? : %s, gr2 is dead? :%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (gr1.dead, gr2.dead))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
test2:first 1&lt;span&gt;
test1: finished
gr1 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; dead? : True, gr2 &lt;span&gt;is&lt;/span&gt;&lt;span&gt; dead? :False
test2:back
gr1 &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; dead? : True, gr2 &lt;span&gt;is&lt;/span&gt; dead? :True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有当协&lt;strong&gt;程对应的函数执行完毕，协程才会die&lt;/strong&gt;，所以第一次Check的时候gr2并没有die，因为第12行切换出去了就没切回来。在main中再switch到gr2的时候， 执行后面的逻辑，gr2 die&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、greenlet注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用greenlet需要注意一下三点：&lt;/p&gt;
&lt;p&gt;　　第一：greenlet创生之后，一定要结束，不能switch出去就不回来了，否则容易造成内存泄露&lt;/p&gt;
&lt;p&gt;　　第二：python中每个线程都有自己的main greenlet及其对应的sub-greenlet ，不能线程之间的greenlet是不能相互切换的&lt;/p&gt;
&lt;p&gt;　　第三：不能存在循环引用，这个是官方文档明确说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet, GreenletExit
 &lt;/span&gt;2 huge =&lt;span&gt; []
 &lt;/span&gt;3 &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show_leak():
 &lt;/span&gt;4     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
 &lt;/span&gt;5&lt;span&gt;         gr2.switch()
 &lt;/span&gt;6 
 7     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
 &lt;/span&gt;8         huge.extend([x* x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;)])
 &lt;/span&gt;9&lt;span&gt;         gr1.switch()
&lt;/span&gt;10         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;finish switch del huge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
11         &lt;span&gt;del&lt;/span&gt;&lt;span&gt; huge[:]
&lt;/span&gt;12     
13     gr1 =&lt;span&gt; greenlet(test1)
&lt;/span&gt;14     gr2 =&lt;span&gt; greenlet(test2)
&lt;/span&gt;15&lt;span&gt;     gr1.switch()
&lt;/span&gt;16     gr1 = gr2 =&lt;span&gt; None
&lt;/span&gt;17     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length of huge is zero ? %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; len(huge)
&lt;/span&gt;18 
19 &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;20     show_leak() 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在test2函数中 第11行，我们将huge清空，然后再第16行将gr1、gr2的引用计数降到了0。但运行结果告诉我们，第11行并没有执行，所以如果一个协程没有正常结束是很危险的，往往不符合程序员的预期。greenlet提供了解决这个问题的办法，官网文档提到：如果一个greenlet实例的引用计数变成0，那么会在上次挂起的地方抛出GreenletExit异常，这就使得我们可以通过try ... finally 处理资源泄露的情况。如下面的代码： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet, GreenletExit
 &lt;/span&gt;2 huge =&lt;span&gt; []
 &lt;/span&gt;3 &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show_leak():
 &lt;/span&gt;4     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
 &lt;/span&gt;5&lt;span&gt;         gr2.switch()
 &lt;/span&gt;6 
 7     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
 &lt;/span&gt;8         huge.extend([x* x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;)])
 &lt;/span&gt;9         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;10&lt;span&gt;             gr1.switch()
&lt;/span&gt;11         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;12             &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;finish switch del huge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
13             &lt;span&gt;del&lt;/span&gt;&lt;span&gt; huge[:]
&lt;/span&gt;14     
15     gr1 =&lt;span&gt; greenlet(test1)
&lt;/span&gt;16     gr2 =&lt;span&gt; greenlet(test2)
&lt;/span&gt;17&lt;span&gt;     gr1.switch()
&lt;/span&gt;18     gr1 = gr2 =&lt;span&gt; None
&lt;/span&gt;19     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length of huge is zero ? %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; len(huge)
&lt;/span&gt;20 
21 &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;22     show_leak()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码的switch流程：main greenlet --&amp;gt; gr1 --&amp;gt; gr2 --&amp;gt; gr1 --&amp;gt; main greenlet, 很明显gr2没有正常结束（在第10行刮起了）。第18行之后gr1,gr2的引用计数都变成0，那么会在第10行抛出GreenletExit异常，因此finally语句有机会执行。同时，在文章开始介绍Greenlet module的时候也提到了，GreenletExit这个异常并不会抛出到parent，所以main greenlet也不会出异常。&lt;/p&gt;
&lt;h3&gt;四、gevent&lt;/h3&gt;
&lt;p&gt;greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块&lt;code&gt;gevent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。&lt;/p&gt;
&lt;p&gt;由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(gevent.getcurrent(),i))


g1 &lt;/span&gt;=&lt;span&gt; gevent.spawn(f)
g2 &lt;/span&gt;=&lt;span&gt; gevent.spawn(f)
g3 &lt;/span&gt;=&lt;span&gt; gevent.spawn(f)
g1.join()
g2.join()
g3.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Greenlet at 0x1ba533f9598: f(5)&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x1ba533f9598: f(5)&amp;gt;:1
&amp;lt;Greenlet at 0x1ba533f9598: f(5)&amp;gt;:2
&amp;lt;Greenlet at 0x1ba533f9598: f(5)&amp;gt;:3
&amp;lt;Greenlet at 0x1ba533f9598: f(5)&amp;gt;:4
&amp;lt;Greenlet at 0x1ba533f97b8: f(5)&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x1ba533f97b8: f(5)&amp;gt;:1
&amp;lt;Greenlet at 0x1ba533f97b8: f(5)&amp;gt;:2
&amp;lt;Greenlet at 0x1ba533f97b8: f(5)&amp;gt;:3
&amp;lt;Greenlet at 0x1ba533f97b8: f(5)&amp;gt;:4
&amp;lt;Greenlet at 0x1ba533f99d8: f(5)&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x1ba533f99d8: f(5)&amp;gt;:1
&amp;lt;Greenlet at 0x1ba533f99d8: f(5)&amp;gt;:2
&amp;lt;Greenlet at 0x1ba533f99d8: f(5)&amp;gt;:3
&amp;lt;Greenlet at 0x1ba533f99d8: f(5)&amp;gt;:4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，3个greenlet是依次运行而不是交替运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gevent的切换执行&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(gevent.getcurrent(),i))
        gevent.sleep(0)


g1&lt;/span&gt;=&lt;span&gt;gevent.spawn(f)
g2&lt;/span&gt;=&lt;span&gt;gevent.spawn(f)
g3&lt;/span&gt;=&lt;span&gt;gevent.spawn(f)
g1.join()
g2.join()
g3.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Greenlet at 0x20a5e719598: f&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x20a5e7197b8: f&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x20a5e7199d8: f&amp;gt;&lt;span&gt;:0
&lt;/span&gt;&amp;lt;Greenlet at 0x20a5e719598: f&amp;gt;:1
&amp;lt;Greenlet at 0x20a5e7197b8: f&amp;gt;:1
&amp;lt;Greenlet at 0x20a5e7199d8: f&amp;gt;:1
&amp;lt;Greenlet at 0x20a5e719598: f&amp;gt;:2
&amp;lt;Greenlet at 0x20a5e7197b8: f&amp;gt;:2
&amp;lt;Greenlet at 0x20a5e7199d8: f&amp;gt;:2
&amp;lt;Greenlet at 0x20a5e719598: f&amp;gt;:3
&amp;lt;Greenlet at 0x20a5e7197b8: f&amp;gt;:3
&amp;lt;Greenlet at 0x20a5e7199d8: f&amp;gt;:3
&amp;lt;Greenlet at 0x20a5e719598: f&amp;gt;:4
&amp;lt;Greenlet at 0x20a5e7197b8: f&amp;gt;:4
&amp;lt;Greenlet at 0x20a5e7199d8: f&amp;gt;:4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3个greenlet交替运行&lt;/p&gt;
&lt;p&gt;gevent.spawn 启动协程，参数为函数名称，参数名称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、gevent并发下载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;monkey可以使一些阻塞的模块变得不阻塞，机制：遇到IO操作则自动切换，手动切换可以用gevent.sleep(0)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;有I/O时需要这一句,如果没有这句话就会有阻塞状态，加上就没有阻塞&lt;/span&gt;
&lt;span&gt;monkey.patch_all()


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myDownLoad(url):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;url)
    resp &lt;/span&gt;=&lt;span&gt; urllib.request.urlopen(url)
    data &lt;/span&gt;=&lt;span&gt; resp.read()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d bytes received from %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(len(data),url))


gevent.joinall((
    gevent.spawn(myDownLoad,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    gevent.spawn(myDownLoad,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://apple.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    gevent.spawn(myDownLoad,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/Se7eN-HOU/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
GET:http://www.baidu.com/&lt;span&gt;
GET:https:&lt;/span&gt;//&lt;span&gt;apple.com
GET:https:&lt;/span&gt;//www.cnblogs.com/Se7eN-HOU/
153390 bytes received &lt;span&gt;from&lt;/span&gt; http://www.baidu.com/
18880 bytes received &lt;span&gt;from&lt;/span&gt; https://www.cnblogs.com/Se7eN-HOU/
58865 bytes received &lt;span&gt;from&lt;/span&gt; https://apple.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上能够看到是先发送的获取baidu的相关信息，然后依次是apple,cnblogs但是收到数据的先后顺序不一定与发送顺序相同，这也就体现出了异步，即不确定什么时候会收到数据，顺序不一定.&lt;/p&gt;
&lt;p&gt;上面如果没有下面这句代码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;有I/O时需要这一句,如果没有这句话就会有阻塞状态，加上就没有阻塞&lt;/span&gt;
monkey.patch_all()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
GET:http://www.baidu.com/
153378 bytes received &lt;span&gt;from&lt;/span&gt; http://www.baidu.com/&lt;span&gt;
GET:https:&lt;/span&gt;//&lt;span&gt;apple.com
&lt;/span&gt;58865 bytes received &lt;span&gt;from&lt;/span&gt; https://&lt;span&gt;apple.com
GET:https:&lt;/span&gt;//www.cnblogs.com/Se7eN-HOU/
18880 bytes received &lt;span&gt;from&lt;/span&gt; https://www.cnblogs.com/Se7eN-HOU/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每请求一个网站就会等着请求完毕了在执行第二个，在请求的过程中，网速慢等待的状态就是在阻塞。&lt;/p&gt;
&lt;h3&gt;五、asyncio&lt;/h3&gt;
&lt;p&gt;我们都知道，现在的服务器开发对于IO调度的优先级控制权已经不再依靠系统，都希望采用协程的方式实现高效的并发任务，如js、lua等在异步协程方面都做的很强大。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;replace_word&quot; title=&quot;Python知识库&quot; href=&quot;http://lib.csdn.net/base/python&quot; target=&quot;_blank&quot;&gt;Python&lt;/a&gt;在3.4版本也加入了协程的概念，并在3.5确定了基本完善的语法和实现方式。同时3.6也对其进行了如解除了await和yield在同一个函数体限制等相关的优化。&lt;/p&gt;
&lt;p&gt;event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。&lt;br/&gt;coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。&lt;br/&gt;task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。&lt;br/&gt;future： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别&lt;br/&gt;async/await 关键字：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、创建协程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先定义一个协程，在def前加入async声明，就可以定义一个协程函数。&lt;/p&gt;
&lt;p&gt;一个协程函数不能直接调用运行，只能把协程加入到事件循环loop中。asyncio.get_event_loop方法可以创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---协程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---主线程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    loop.run_until_complete(fun())

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
---主线程中---
---协程中---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、任务对象task&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象。所谓task对象是Future类的子类。保存了协程运行后的状态，用于未来获取协程的结果。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---协程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---主线程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建task&lt;/span&gt;
    task =&lt;span&gt; loop.create_task(fun())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(task)
    loop.run_until_complete(task)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(task)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
---主线程中---
&amp;lt;Task pending coro=&amp;lt;fun() running at C:/Users/Se7eN_HOU/PycharmProjects/PythonLesson/test.py:4&amp;gt;&amp;gt;
---协程中---
&amp;lt;Task finished coro=&amp;lt;fun() done, defined at C:/Users/Se7eN_HOU/PycharmProjects/PythonLesson/test.py:4&amp;gt; result=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建task后，task在加入事件循环之前是pending状态，因为fun()中没有耗时的阻塞操作，task很快就执行完毕了。后面打印的finished状态。&lt;br/&gt;asyncio.ensure_future 和 loop.create_task都可以创建一个task，run_until_complete的参数是一个futrue对象。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;三、绑定回调&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;协程&lt;/span&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---协程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;协程的回调函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(future):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;future.result是协程的返回值&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;callBack:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;future.result())


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---主线程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建loop回路&lt;/span&gt;
    loop =&lt;span&gt; asyncio.get_event_loop()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建task&lt;/span&gt;
    task =&lt;span&gt; loop.create_task(fun())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用回调函数&lt;/span&gt;
&lt;span&gt;    task.add_done_callback(callback)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(task)
    loop.run_until_complete(task)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(task)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
---主线程中---
&amp;lt;Task pending coro=&amp;lt;fun() running at C:/Users/Se7eN_HOU/PycharmProjects/PythonLesson/test.py:4&amp;gt; cb=[callback() at C:/Users/Se7eN_HOU/PycharmProjects/PythonLesson/test.py:9]&amp;gt;
---协程中---&lt;span&gt;
callBack:Se7eN_HOU
&lt;/span&gt;&amp;lt;Task finished coro=&amp;lt;fun() done, defined at C:/Users/Se7eN_HOU/PycharmProjects/PythonLesson/test.py:4&amp;gt; result=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用ensure_future获取返回值&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;协程&lt;/span&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---协程中---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;协程的回调函数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;def callback(future):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;future.result是协程的返回值&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(&quot;callBack:%s&quot;%future.result())&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建loop回路&lt;/span&gt;
    loop =&lt;span&gt; asyncio.get_event_loop()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建task&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;task = loop.create_task(fun())&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用回调函数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;task.add_done_callback(callback)&lt;/span&gt;
    task =&lt;span&gt; asyncio.ensure_future(fun())
    loop.run_until_complete(task)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fun函数的返回值是：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;format(task.result()))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
---协程中---&lt;span&gt;
fun函数的返回值是：Se7eN_HOU&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四、await阻塞，执行并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。&lt;br/&gt;耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---1---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    await asyncio.sleep(&lt;/span&gt;5&lt;span&gt;)    
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---2---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---3---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    await asyncio.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---4---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test3():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---5---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    await asyncio.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---6---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;begin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    t1 &lt;/span&gt;=&lt;span&gt; test1()
    t2 &lt;/span&gt;=&lt;span&gt; test2()
    t3 &lt;/span&gt;=&lt;span&gt; test3()
    tasks1 &lt;/span&gt;=&lt;span&gt; [t1,t2,t3]


    loop.run_until_complete(asyncio.wait(tasks1))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    loop.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;begin
&lt;/span&gt;---3---
---1---
---5---
---4---
---6---
---2---&lt;span&gt;
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 24 May 2019 11:33:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、协程 协程，又称微线程，纤程。英文名Coroutine。 协程不是进程，也不是线程，它就是一个函数，一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。所以说，协程与进程、线程相比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/10915263.html</dc:identifier>
</item>
<item>
<title>带你学Node系列之express-CRUD - pubdreamcc</title>
<link>http://www.cnblogs.com/dreamcc/p/10919726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreamcc/p/10919726.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;hello，小伙伴们，我是你们的&lt;code&gt;pubdreamcc&lt;/code&gt;，本篇博文出至于我的GitHub仓库&lt;code&gt;node学习教程资料&lt;/code&gt;，欢迎小伙伴们点赞和&lt;code&gt;star&lt;/code&gt;，你们的点赞是我持续更新的动力。&lt;/p&gt;
&lt;blockquote readability=&quot;2.8378378378378&quot;&gt;
&lt;p&gt;GitHub仓库地址：&lt;a href=&quot;https://github.com/pubdreamcc/Node.js&quot;&gt;node学习教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.7272727272727&quot;&gt;
&lt;p&gt;本篇文章对应的源码：&lt;a href=&quot;https://github.com/pubdreamcc/Student-Management-System&quot;&gt;Student-Management-System&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，废话不多说了，今天继续我们&lt;code&gt;express&lt;/code&gt;的学习~&lt;/p&gt;
&lt;h2 id=&quot;student-management-system&quot;&gt;Student-Management-System&lt;/h2&gt;
&lt;p&gt;今天我们实现一个案例，用express实现基本的C-R-U-D（增删改查）学生信息管理系统。学习这个案例一方面让我们熟悉业务开发的流程，一方面可以巩固之前学习的express知识。&lt;/p&gt;
&lt;h2 id=&quot;文件说明&quot;&gt;文件说明&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;app.js -- 入口模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;router.js -- 路由模块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;student.js -- 操作数据模块（封装操作数据的基本API）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Db.json -- 模拟数据库，保存数据的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;views文件夹 -- 页面视图文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;public文件夹 -- 静态资源文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动&quot;&gt;启动&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt; 克隆项目到本地&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt; 进入项目文件夹，下载相关依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;node app.js&lt;/code&gt; node启动项目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;主体设计&quot;&gt;主体设计&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建&lt;code&gt;public&lt;/code&gt;静态文件夹，&lt;code&gt;views&lt;/code&gt;页面视图文件夹。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;项目中前端页面使用了&lt;code&gt;bootstrap&lt;/code&gt;快速搭建，所有需要开放bootstrap样式文件和页面相关的脚本文件。在&lt;code&gt;views&lt;/code&gt;文件夹中存放主页面： &lt;code&gt;index.html&lt;/code&gt;，编辑学生信息页面：&lt;code&gt;edit.html&lt;/code&gt;，添加学生页面：&lt;code&gt;add.html&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建数据文件&lt;code&gt;Db.json&lt;/code&gt;，模拟数据库存放学生信息数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为我们没有涉及到数据库，所以暂时把学生数据存放在Db.json文件中，在数据文件中，我们需要一个数组：&lt;code&gt;students&lt;/code&gt;，用来存放每一个学生的信息。通常数据文件都是一个json格式文件，所以严格按照json格式要求来模拟数据。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;students&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;牛魔王&quot;,
      &quot;age&quot;: 18,
      &quot;hobbies&quot;: &quot;打人&quot;
    }
    ...
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建入口模块：app.js&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在入口模块中启动服务器，配置&lt;code&gt;art-template&lt;/code&gt;模板引擎，配置express中间件&lt;code&gt;body-parser&lt;/code&gt;解析&lt;code&gt;post&lt;/code&gt;请求提交的数据，最后把路由容器&lt;code&gt;router&lt;/code&gt;挂载到app服务器实例上。因为node中解析代码是从上至下，所以路由容器挂载必须在各项配置之后，否则会出错。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const express = require('express')
const router = require('./router')
const bodyParser = require('body-parser')
const app = express()
// 开发静态资源
app.use('/public/', express.static('./public'))
app.use('/node_modules/', express.static('./node_modules'))
// 配置模板引擎
app.engine('html', require('express-art-template'))
// 配置body-parser，得到post请求体数据
app.use(bodyParser.urlencoded({ extended: false }))
// 注意：配置模板引擎和body-parser，开放静态资源必须放在路由容器挂载之前
// 挂载路由容器
app.use(router)
// 绑定端口号，开启服务
app.listen(3000, () =&amp;gt; {
  console.log('running...')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;抽取路由模块&lt;code&gt;router.js&lt;/code&gt;，专门处理每个路由&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为项目中需要处理多个路由，所以我们分离出一个路由模块，用来处理路由信息。模块的分离使得node中每个模块各司其职，职能单一，同时也便于后期代码维护。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;router.js&lt;/code&gt;模块中每个路由都需要涉及到操作数据文件，所以我们在此之外需要封装一些数据操作的API。封装异步 API这里才是我们学习 Node 的精华部分：奥义之所在。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 路由模块
const express = require('express')
const Student = require('./student')
// 得到路由容器
const router = express.Router()
/*
  * 下面就是把每条路由都挂载到路由容器中
*/
// 请求'/'，显示全部学生信息
router.get('/', (req, res) =&amp;gt; {
  // 调用Student.find()API，获取所有学生信息
  。。。
})

// 请求/add'，显示添加学生信息的界面
router.get('/add', (req, res) =&amp;gt; {
  res.render('add.html')
})

// 表单post提交数据到'/add'，处理数据后重定向至'/'
router.post('/add', (req, res) =&amp;gt; {
  /*
    *获取表单提交的数据
    *添加到数据文件中
    *重定向至首页，显示新提交的学生信息
  */
  。。。
})
// 请求'/edit'，展示编辑学生信息界面
router.get('/edit', (req, res) =&amp;gt; {
  // 调用 Student.findById()API，通过id值获取学生信息渲染在页面上
  。。。
})

// 获取post请求提交的数据，更新学生信息，重定向到'/'
router.post('/edit', (req, res) =&amp;gt; {
  /**
   * 获取新修改的post请求提交的学生信息
   * 处理数据文件，修改学生信息
   * 重定向到'/'
   */
})
// 当请求'/delete'，根据id值删除相应的学生信息，重定向到'/'
router.get('/delete', (req, res) =&amp;gt; {
  // 调用 Student.deleteById()API，通过id值查找到对应学生，删除其信息
  。。。
})

module.exports = router&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;封装数据操作的API，提取数据操作文件模块&lt;code&gt;student.js&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;数据操作的模块，只负责操作数据（增加新数据，修改数据，删除数据等），不关心业务逻辑。&lt;/p&gt;
&lt;p&gt;注意：我们在操作数据文件的时候，永远只能是：先读取出来原有的字符串数据，转换成对象，处理完成之后，再把对象转换成JSON格式字符串，最后再保存到数据文件中。&lt;strong&gt;文件中永远存放的是字符串格式的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于是这种操作顺序，所以student.js中频繁使用到node核心模块&lt;code&gt;fs&lt;/code&gt;，反复调用&lt;code&gt;fs.readFile()&lt;/code&gt;读取文件内容，&lt;code&gt;fs.writeFile()&lt;/code&gt;修改文件中的数据。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 引入fs核心模块
const fs = require('fs')
// 保存学生信息
/**
 * 保存新添加的学生信息到数据文件中
 * 参数：
 * 1. 新加的学生信息对象
 * 2. callback回调函数，拿到异步操作的结果
 * callback中的参数：
 * 第一个参数err
 *   成功是null, 失败是错误对象
 *  第二个参数是结果
 *   成功是数组，失败是undefined
 */
exports.save = (student, callback) =&amp;gt; {
  fs.readFile('./Db.json', 'utf8', (err, data) =&amp;gt; {
    if (err) {
      return callback(err)
    }
    // 得到所有学生信息
    let students = JSON.parse(data).students
    // 为新加的学生添加一个唯一的id属性（原来最大id属性值基础上加1）
    if (students.length === 0) {
      // 如果原始数据文件中没有学生信息
      student.id = 1
    } else {
      student.id = parseInt(students[students.length-1].id) + 1
    }
    students.push(student)
    // 把新增加学生信息后的对象转换成字符串保存到数据文件中
    let dataStr = JSON.stringify({
      students: students
    })
    fs.writeFile('./Db.json', dataStr, err =&amp;gt; {
      if (err) {
        // 如果写入失败，则把错误对象传递给它
        return callback(err)
      }
      // 成功就没错，所以错误对象是 null
      callback(null)
    })
  })
}
。。。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于篇幅原因，这里只罗列了添加学生信息API的实现代码。这里还有一个非常重要的知识点：&lt;em&gt;怎样获取到一个函数内部异步操作的结果？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只能是通过回调函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或许有一些其他的内置模块，包括封装的API也可以拿到异步操作的结果，但是其底层都是利用了回调函数的思想。比如常见的Node内置&lt;code&gt;events&lt;/code&gt;事件模块等。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;视图文件编写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里只需强调一点，在编写视图文件的时候，需要把一些动态的数据用模板语法包裹起来，能够使得模板引擎正确的渲染模板文件即可。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动服务后看结果（略）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;后话&quot;&gt;后话&lt;/h2&gt;
&lt;p&gt;需要学习资料和案例源码的伙伴可以去GitHub上查看，如果您对这案例或者学习资料有更好的看法，欢迎issue，或者评论，谢谢。&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 10:48:00 +0000</pubDate>
<dc:creator>pubdreamcc</dc:creator>
<og:description>前言 hello，小伙伴们，我是你们的 ，本篇博文出至于我的GitHub仓库 ，欢迎小伙伴们点赞和 ，你们的点赞是我持续更新的动力。 GitHub仓库地址： 'node学习教程' 本篇文章对应的源码：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dreamcc/p/10919726.html</dc:identifier>
</item>
<item>
<title>Flutter学习（一）——搭建开发环境（Windows） - 麦豇豆</title>
<link>http://www.cnblogs.com/MaiJiangDou/p/10919711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaiJiangDou/p/10919711.html</guid>
<description>&lt;p&gt;&lt;span&gt;久闻 &lt;span&gt;Flutter&lt;/span&gt; 大名，今天终于有时间体验一下了 ٩(๑&amp;gt;◡&amp;lt;๑)۶&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;官网：&lt;a href=&quot;https://flutter.dev/&quot; target=&quot;_blank&quot;&gt;https://flutter.dev/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中文官网：&lt;a href=&quot;https://flutterchina.club/&quot; target=&quot;_blank&quot;&gt;https://flutterchina.club/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;、下载&lt;/span&gt;Flutter SDK&lt;/h3&gt;
&lt;h4&gt;1、下载&lt;/h4&gt;
&lt;p&gt;①官网下载：&lt;a href=&quot;https://flutter.dev/docs/development/tools/sdk/releases#windows&quot; target=&quot;_blank&quot;&gt;https://flutter.dev/docs/development/tools/sdk/releases#windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;②github下载：&lt;a href=&quot;https://github.com/flutter/flutter/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/flutter/flutter/releases&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt; 2、解压&lt;/h4&gt;
&lt;p&gt;将安装包zip解压到你想安装Flutter SDK的路径。&lt;/p&gt;
&lt;h4&gt;3、打开flutter命令行&lt;/h4&gt;
&lt;p&gt;在Flutter安装目录的&lt;code class=&quot;highlighter-rouge&quot;&gt;flutter&lt;/code&gt;文件下找到&lt;code class=&quot;highlighter-rouge&quot;&gt;flutter_console.bat&lt;/code&gt;，双击运行并启动flutter命令行，接下来，你就可以在Flutter命令行运行flutter命令了。&lt;/p&gt;
&lt;h3&gt;二、下载Android Studio&lt;/h3&gt;
&lt;p&gt;下载安装就行了，注意一下sdk的路径，需要配置环境变量。&lt;/p&gt;
&lt;h3&gt;三、配置编辑器&lt;/h3&gt;
&lt;p&gt;编辑器我习惯用VS Code，在扩展商店搜索 ‘flutter’，安装Flutter插件就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524175916586-654974122.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四、配置环境变量&lt;/h3&gt;
&lt;h4&gt; 1、镜像&lt;/h4&gt;
&lt;p&gt;由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export PUB_HOSTED_URL=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pub.flutter-io.cn&lt;/span&gt;
export FLUTTER_STORAGE_BASE_URL=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;storage.flutter-io.cn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524180655351-1785213068.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2、在Path中添加flutter\bin的全路径，如下图：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524181148840-310687350.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3、配置ANDROID_HOME，设置为SDK安装目录&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524181343145-789388336.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;五、连接设备&lt;/h3&gt;
&lt;h4&gt;1、真机&lt;/h4&gt;
&lt;p&gt;手机连接电脑，在开发者选项中，打开USB调试，授权计算机访问设备。&lt;/p&gt;
&lt;h4&gt;2、模拟器&lt;/h4&gt;
&lt;p&gt;这次没有使用模拟器，之前做RN用过，电脑会比较卡。&lt;/p&gt;
&lt;h3&gt; 六、创建新应用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;启动 VS Code&lt;/li&gt;
&lt;li&gt;调用 &lt;strong&gt;View&amp;gt;Command Palette…&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入 ‘flutter’, 然后选择 &lt;strong&gt;‘Flutter: New Project’&lt;/strong&gt; action&lt;/li&gt;
&lt;li&gt;输入 Project 名称 (如&lt;code class=&quot;highlighter-rouge&quot;&gt;myapp&lt;/code&gt;), 然后按回车键&lt;/li&gt;
&lt;li&gt;指定放置项目的位置，然后按蓝色的确定按钮&lt;/li&gt;
&lt;li&gt;等待项目创建继续，并显示main.dart文件&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;七、运行&lt;/h3&gt;
&lt;h4&gt;1、在flutter命令行中运行 &lt;strong&gt;flutter doctor&lt;/strong&gt; 命令，查看是否需要安装任何依赖项来完成安装。&lt;/h4&gt;
&lt;p&gt;该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524183648721-145166942.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2、确保在VS Code的右下角选择了目标设备&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524183317091-1260490252.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3、按 F5 键或调用&lt;strong&gt;Debug&amp;gt;Start Debugging&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　安装成功即会在手机上看到如下应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524171815137-34058710.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面是遇到的一些问题------------------------------&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;问题一：&lt;/h4&gt;
&lt;p&gt;安装Android studio时出现&lt;em&gt;&lt;strong&gt;unable to access android sdk add-on list&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;解决方法：&lt;/h4&gt;
&lt;p&gt;1、用记事本打开bin下面的idea.properties文件（xxx/android studio/bin/idea.properties）；&lt;/p&gt;
&lt;p&gt;2、在idea.properties最后一行加上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
disable.android.first.run=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、重启电脑&lt;/p&gt;

&lt;h4&gt;问题二：&lt;/h4&gt;
&lt;p&gt;安装Android studio后，用flutter doctor检测，发现Android licenses not accepted&lt;/p&gt;
&lt;h4&gt;解决方法：&lt;/h4&gt;
&lt;p&gt;运行如下命令，然后都选择y，接受，就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
flutter doctor --android-licenses
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;问题三：&lt;/h4&gt;
&lt;p&gt;在设备上运行程序失败，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1110154/201905/1110154-20190524165129742-539381570.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;解决方法：&lt;/h4&gt;
&lt;p&gt;配置ANDROID_HOME环境变量（这里上面有讲到，但是我第一次运行时没有配置，导致报错）&lt;/p&gt;

&lt;p&gt;&lt;span&gt; END。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 May 2019 10:43:00 +0000</pubDate>
<dc:creator>麦豇豆</dc:creator>
<og:description>久闻 Flutter 大名，今天终于有时间体验一下了 ٩(๑&gt;◡&lt;๑)۶ 官网：https://flutter.dev/ 中文官网：https://flutterchina.cl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MaiJiangDou/p/10919711.html</dc:identifier>
</item>
<item>
<title>Spring Security在标准登录表单中添加一个额外的字段 - 程序猿Knight</title>
<link>http://www.cnblogs.com/xjknight/p/10919653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjknight/p/10919653.html</guid>
<description>&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;在本文中，&lt;strong&gt;我们将通过向标准登录表单添加额外字段来实现Spring Security的自定义身份验证方案&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;将重点关注两种不同的方法，以展示框架的多功能性以及我们可以使用它的灵活方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;的第一种方法是一个简单的解决方案，专注于重用现有的核心Spring Security实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们的第二种&lt;strong&gt;方法是更加定制的解决方案，可能更适合高级&lt;/strong&gt;用例。&lt;/p&gt;
&lt;h3 id=&quot;maven设置&quot;&gt;2. Maven设置&lt;/h3&gt;
&lt;p&gt;我们将使用Spring Boot启动程序来引导我们的项目并引入所有必需的依赖项。&lt;br/&gt;我们将使用的设置需要父声明，Web启动器和安全启动器;我们还将包括thymeleaf ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.0.M7&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;
  
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.thymeleaf.extras&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;thymeleaf-extras-springsecurity4&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在Maven Central找到最新版本的Spring Boot安全启动器。&lt;/p&gt;
&lt;h4 id=&quot;简单的项目设置&quot;&gt;3.简单的项目设置&lt;/h4&gt;
&lt;p&gt;在我们的第一种方法中，我们将专注于重用Spring Security提供的实现。特别是，&lt;strong&gt;我们将重用DaoAuthenticationProvider和UsernamePasswordToken，因为它们是“开箱即用”的&lt;/strong&gt;。&lt;/p&gt;
&lt;h6 id=&quot;关键组件包括&quot;&gt;关键组件包括：&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SimpleAuthenticationFilter&lt;/strong&gt; - UsernamePasswordAuthenticationFilter的扩展&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SimpleUserDetailsService&lt;/strong&gt; - UserDetailsService的实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User&lt;/strong&gt; - Spring Security提供的User类的扩展，它声明了我们的额外域字段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SecurityConfig&lt;/strong&gt; - 我们的Spring Security配置，它将SimpleAuthenticationFilter插入到过滤器链中，声明安全规则并连接依赖项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;login.html&lt;/strong&gt; - 收集用户名，密码和域的登录页面&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;简单authentication-filter&quot;&gt;3.1. 简单Authentication Filter&lt;/h4&gt;
&lt;p&gt;在我们的SimpleAuthenticationFilter中，&lt;strong&gt;域和用户名字段是从请求中提取的。我们连接这些值并使用它们来创建UsernamePasswordAuthenticationToken的&lt;/strong&gt;实例。&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;将令牌传递给AuthenticationProvider进行身份验&lt;/strong&gt;证：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleAuthenticationFilter
  extends UsernamePasswordAuthenticationFilter {
 
    @Override
    public Authentication attemptAuthentication(
      HttpServletRequest request, 
      HttpServletResponse response) 
        throws AuthenticationException {
 
        // ...
 
        UsernamePasswordAuthenticationToken authRequest
          = getAuthRequest(request);
        setDetails(request, authRequest);
         
        return this.getAuthenticationManager()
          .authenticate(authRequest);
    }
 
    private UsernamePasswordAuthenticationToken getAuthRequest(
      HttpServletRequest request) {
  
        String username = obtainUsername(request);
        String password = obtainPassword(request);
        String domain = obtainDomain(request);
 
        // ...
 
        String usernameDomain = String.format(&quot;%s%s%s&quot;, username.trim(), 
          String.valueOf(Character.LINE_SEPARATOR), domain);
        return new UsernamePasswordAuthenticationToken(
          usernameDomain, password);
    }
 
    // other methods
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;简单的userdetails服务&quot;&gt;3.2.简单的UserDetails服务&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;UserDetailsService定义了一个名为loadUserByUsername的方法。我们的实现提取用户名和域名。然后将值传递给我们的UserRepository以获&lt;/strong&gt;取用户：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SimpleUserDetailsService implements UserDetailsService {
 
    // ...
 
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String[] usernameAndDomain = StringUtils.split(
          username, String.valueOf(Character.LINE_SEPARATOR));
        if (usernameAndDomain == null || usernameAndDomain.length != 2) {
            throw new UsernameNotFoundException(&quot;Username and domain must be provided&quot;);
        }
        User user = userRepository.findUser(usernameAndDomain[0], usernameAndDomain[1]);
        if (user == null) {
            throw new UsernameNotFoundException(
              String.format(&quot;Username not found for domain, username=%s, domain=%s&quot;, 
                usernameAndDomain[0], usernameAndDomain[1]));
        }
        return user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring-security配置&quot;&gt;3.3. Spring Security配置&lt;/h4&gt;
&lt;p&gt;我们的&lt;strong&gt;设置与标准的Spring Security配置不同，因为我们在默认情况下通过调用addFilterBefore将SimpleAuthenticationFilter插入到过滤&lt;/strong&gt;器链中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
 
    http
      .addFilterBefore(authenticationFilter(), 
        UsernamePasswordAuthenticationFilter.class)
      .authorizeRequests()
        .antMatchers(&quot;/css/**&quot;, &quot;/index&quot;).permitAll()
        .antMatchers(&quot;/user/**&quot;).authenticated()
      .and()
      .formLogin().loginPage(&quot;/login&quot;)
      .and()
      .logout()
      .logoutUrl(&quot;/logout&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用提供的DaoAuthenticationProvider，&lt;strong&gt;因为我们使用SimpleUserDetailsService配置它&lt;/strong&gt;。回想一下，&lt;strong&gt;我们的SimpleUserDetailsService知道如何解析我们的用户名和域字段，并返回在验证时&lt;/strong&gt;使用的相应用户。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public AuthenticationProvider authProvider() {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder());
    return provider;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们使用&lt;strong&gt;的是SimpleAuthenticationFilter，因此我们配置自己的AuthenticationFailureHandler以确保正确处理失&lt;/strong&gt;败的登录尝试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public SimpleAuthenticationFilter authenticationFilter() throws Exception {
    SimpleAuthenticationFilter filter = new SimpleAuthenticationFilter();
    filter.setAuthenticationManager(authenticationManagerBean());
    filter.setAuthenticationFailureHandler(failureHandler());
    return filter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;登录页面&quot;&gt;3.4.登录页面&lt;/h4&gt;
&lt;p&gt;我们使用的登录&lt;strong&gt;页面收集我们的SimpleAuthenticationFilter提取的额外&lt;/strong&gt;的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;form class=&quot;form-signin&quot; th:action=&quot;@{/login}&quot; method=&quot;post&quot;&amp;gt;
 &amp;lt;h2 class=&quot;form-signin-heading&quot;&amp;gt;Please sign in&amp;lt;/h2&amp;gt;
 &amp;lt;p&amp;gt;Example: user / domain / password&amp;lt;/p&amp;gt;
 &amp;lt;p th:if=&quot;${param.error}&quot; class=&quot;error&quot;&amp;gt;Invalid user, password, or domain&amp;lt;/p&amp;gt;
 &amp;lt;p&amp;gt;
   &amp;lt;label for=&quot;username&quot; class=&quot;sr-only&quot;&amp;gt;Username&amp;lt;/label&amp;gt;
   &amp;lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; class=&quot;form-control&quot;
     placeholder=&quot;Username&quot; required autofocus/&amp;gt;
 &amp;lt;/p&amp;gt;
 &amp;lt;p&amp;gt;
   &amp;lt;label for=&quot;domain&quot; class=&quot;sr-only&quot;&amp;gt;Domain&amp;lt;/label&amp;gt;
   &amp;lt;input type=&quot;text&quot; id=&quot;domain&quot; name=&quot;domain&quot; class=&quot;form-control&quot;
     placeholder=&quot;Domain&quot; required autofocus/&amp;gt;
 &amp;lt;/p&amp;gt;
 &amp;lt;p&amp;gt;
   &amp;lt;label for=&quot;password&quot; class=&quot;sr-only&quot;&amp;gt;Password&amp;lt;/label&amp;gt;
   &amp;lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot;
     placeholder=&quot;Password&quot; required autofocus/&amp;gt;
 &amp;lt;/p&amp;gt;
 &amp;lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot;&amp;gt;Sign in&amp;lt;/button&amp;gt;&amp;lt;br/&amp;gt;
 &amp;lt;p&amp;gt;&amp;lt;a href=&quot;/index&quot; th:href=&quot;@{/index}&quot;&amp;gt;Back to home page&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们运行应用&lt;strong&gt;程序并访问http：// localhost：8081上下文时，我们会看到一个访问安全页面的链接。单击该链接将显示登录页面&lt;/strong&gt;。正如所料，我们看到了额外的域名字段&lt;br/&gt;&lt;img src=&quot;https://www.baeldung.com/wp-content/uploads/2018/01/Spring_Security_Extra_Fields_Login_page-300x238.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;3.5.总结&lt;/h4&gt;
&lt;p&gt;在我们&lt;strong&gt;的第一个例子中，我们能够通过“伪造”用户名字段来重用DaoAuthenticationProvider和UsernamePasswordAuthenticationToken&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;我们能够使用最少量的配置和其他代码添加对额外登录字段的支持&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自定义项目设置&quot;&gt;4.自定义项目设置&lt;/h3&gt;
&lt;p&gt;我们的第二种方&lt;strong&gt;法与第一种方法非常相似，但可能更适合于非平凡&lt;/strong&gt;用例。&lt;/p&gt;
&lt;p&gt;我们的第二种方法的关键组成部分包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CustomAuthenticationFilter&lt;/strong&gt; - UsernamePasswordAuthenticationFilter的扩展&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CustomUserDetailsService&lt;/strong&gt; - 声明loadUserbyUsernameAndDomain方法的自定义接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CustomUserDetailsServiceImpl&lt;/strong&gt; - CustomUserDetailsService的实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CustomUserDetailsAuthenticationProvider&lt;/strong&gt; - AbstractUserDetailsAuthenticationProvider的扩展&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CustomAuthenticationToken&lt;/strong&gt; - UsernamePasswordAuthenticationToken的扩展&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User&lt;/strong&gt; - Spring Security提供的User类的扩展，它声明了我们的额外域字段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SecurityConfig&lt;/strong&gt; - 我们的Spring Security配置，它将CustomAuthenticationFilter插入到过滤器链中，声明安全规则并连接依赖项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;login.html&lt;/strong&gt; - 收集用户名，密码和域的登录页面&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自定义验证过滤器&quot;&gt;4.1.自定义验证过滤器&lt;/h4&gt;
&lt;p&gt;在我&lt;strong&gt;们的CustomAuthenticationFilter中，我们从请求中提取用户名，密码和域字段。这些值用于创建CustomAuthenticationToken的实例，该实例将传递给AuthenticationProvider进行&lt;/strong&gt;身份验证：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CustomAuthenticationFilter 
  extends UsernamePasswordAuthenticationFilter {
 
    public static final String SPRING_SECURITY_FORM_DOMAIN_KEY = &quot;domain&quot;;
 
    @Override
    public Authentication attemptAuthentication(
        HttpServletRequest request,
        HttpServletResponse response) 
          throws AuthenticationException {
 
        // ...
 
        CustomAuthenticationToken authRequest = getAuthRequest(request);
        setDetails(request, authRequest);
        return this.getAuthenticationManager().authenticate(authRequest);
    }
 
    private CustomAuthenticationToken getAuthRequest(HttpServletRequest request) {
        String username = obtainUsername(request);
        String password = obtainPassword(request);
        String domain = obtainDomain(request);
 
        // ...
 
        return new CustomAuthenticationToken(username, password, domain);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义userdetails服务&quot;&gt;4.2.自定义UserDetails服务&lt;/h4&gt;
&lt;p&gt;我们&lt;strong&gt;的CustomUserDetailsService合约定义了一个名为loadUserByUsernameAndDomain的方&lt;/strong&gt;法。&lt;/p&gt;
&lt;p&gt;我&lt;strong&gt;们创建的CustomUserDetailsServiceImpl类只是实现并委托我们的CustomUserRepository来获取用户&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public UserDetails loadUserByUsernameAndDomain(String username, String domain) 
    throws UsernameNotFoundException {
    if (StringUtils.isAnyBlank(username, domain)) {
        throw new UsernameNotFoundException(&quot;Username and domain must be provided&quot;);
    }
    User user = userRepository.findUser(username, domain);
    if (user == null) {
        throw new UsernameNotFoundException(
          String.format(&quot;Username not found for domain, username=%s, domain=%s&quot;, 
            username, domain));
    }
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义userdetailsauthenticationprovider&quot;&gt;4.3.自定义UserDetailsAuthenticationProvider&lt;/h4&gt;
&lt;p&gt;我们&lt;strong&gt;的CustomUserDetailsAuthenticationProvider将AbstractUserDetailsAuthenticationProvider和委托扩展到我们的CustomUserDetailService以检索用户。这个类最重要的特性是retrieveUser方法的&lt;/strong&gt;实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意，我们必须将身份验证令牌强制转换为CustomAuthenticationToken才能访问我们的自定义字段&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected UserDetails retrieveUser(String username, 
  UsernamePasswordAuthenticationToken authentication) 
    throws AuthenticationException {
  
    CustomAuthenticationToken auth = (CustomAuthenticationToken) authentication;
    UserDetails loadedUser;
 
    try {
        loadedUser = this.userDetailsService
          .loadUserByUsernameAndDomain(auth.getPrincipal()
            .toString(), auth.getDomain());
    } catch (UsernameNotFoundException notFound) {
  
        if (authentication.getCredentials() != null) {
            String presentedPassword = authentication.getCredentials()
              .toString();
            passwordEncoder.matches(presentedPassword, userNotFoundEncodedPassword);
        }
        throw notFound;
    } catch (Exception repositoryProblem) {
  
        throw new InternalAuthenticationServiceException(
          repositoryProblem.getMessage(), repositoryProblem);
    }
 
    // ...
 
    return loadedUser;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结-1&quot;&gt;4.4.总结&lt;/h4&gt;
&lt;p&gt;我们的第二种方法几乎与我&lt;strong&gt;们首先提出的简单方法相同。通过实现我们自己的AuthenticationProvider和CustomAuthenticationToken，我们避免了需要使用自定义解析逻辑来调整我们的用户名字&lt;/strong&gt;段。&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;5.结论&lt;/h3&gt;
&lt;p&gt;在本文中，我们在Spring Security中实现了一个使用额外登录字段的表单登录。我们以两种不同的方式做到了这一点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在我们简&lt;strong&gt;单的方法中，我们最小化了我们需要编写的代码量。通过使用自定义解析逻辑调整用户名，我们能够重用DaoAuthenticationProvider和UsernamePasswordAuthenticatio&lt;/strong&gt;n&lt;/li&gt;
&lt;li&gt;在我&lt;strong&gt;们更加个性化的方法中，我们通过扩展AbstractUserDetailsAuthenticationProvider并使用CustomAuthenticationToken提供我们自己的CustomUserDetailsService来提供自定义字段支&lt;/strong&gt;持。&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;与往常一样所有源代码都可以在github上找到&quot;&gt;与往常一样，所有源代码都&lt;a href=&quot;https://github.com/eugenp/tutorials/tree/master/spring-5-security&quot;&gt;可以在GitHub上找到&lt;/a&gt;。&lt;/h6&gt;
</description>
<pubDate>Fri, 24 May 2019 10:26:00 +0000</pubDate>
<dc:creator>程序猿Knight</dc:creator>
<og:description>概述 在本文中， 我们将通过向标准登录表单添加额外字段来实现Spring Security的自定义身份验证方案 。 我们 将重点关注两种不同的方法，以展示框架的多功能性以及我们可以使用它的灵活方式 。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xjknight/p/10919653.html</dc:identifier>
</item>
<item>
<title>机器学习（3）：机器的进化-迭代学习 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10919610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10919610.html</guid>
<description>&lt;p&gt;之前介绍的简单线性回归，就是一个回归模型，是一个可用于机器学习的模型。什么意思呢？就是模型的状态（参数集合）是可以进化的，只要合理训练它，模型就能取得更好的预测状态，所以说模型可用于机器学习。&lt;/p&gt;
&lt;p&gt;要应用机器学习，一开始就要考虑选择一个良好的模型（分类模型或回归模型），想清楚了，这步是很重要的，如果你选择了一个不对口的模型，你可能花了半辈子的样本挑选与训练，也得不到一个好的模型状态，最终预测不到好的结果。但这里讲的不是怎么选择模型，而是想说，&lt;strong&gt;模型是怎么进化的，也就是训练的过程是怎么样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;又是一些枯燥的内容，但是我也没有办法，难道枯燥就不去了解吗？或者你有更好的表达办法？&lt;/p&gt;
&lt;h4 id=&quot;一迭代训练的概念&quot;&gt;（一）迭代训练的概念&lt;/h4&gt;
&lt;p&gt;你可能已经想像到，训练会一直在调整模型的参数。是的，训练就是要强大，强大就是要固化出最好的参数集合，跟你全面锻炼身体一样，你体重多少？&lt;/p&gt;
&lt;p&gt;为了更具体地理解训练的运行原理，可以参考以下这张图（图片源于：&lt;a href=&quot;https://developers.google.com/machine-learning/crash-course/reducing-loss/an-iterative-approach&quot; class=&quot;uri&quot;&gt;https://developers.google.com/machine-learning/crash-course/reducing-loss/an-iterative-approach&lt;/a&gt;）：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0.jpg&quot; alt=&quot;迭代学习&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为训练接受的样本是带标签的，所以交给模型的是特征与标签的组合，&lt;strong&gt;但你要注意，模型处理的是“所有”样本，它对“所有”样本进行预测，得到一堆预测标签，然后再计算误差或损失，然后再调整参数。所以你不要理解为&lt;/strong&gt;一定是&lt;strong&gt;先处理一个样本就调参然后再来一个样本&lt;/strong&gt;。这里，我留了一个后路，为了计算损失，并不一定要所有样本参与，甚至可以一次迭代只用一个样本，这个在最后再说。&lt;/p&gt;
&lt;p&gt;比如，套用之前的简单线性回归模型，根据关系y=mx+b，每一个样本都得到预测标签。之后，根据预测标签与真实标签，进行损失计算，比如按均方误差计算出损失，如果损失已经很小了，或者若干次调整都不能让损失变小或变小的幅度很小，那你可以下结论了：这个就是最小损失，不用再训练了，模型的状态是最fit的了--这个叫训练&lt;strong&gt;收敛&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果损失比上一次还小（还小很多）而且还不是你以为最小的值，那说明什么？说明还有好处可捞啊，还要调整参数以取得更小的损失啊。那调整参数之后，是不是预测效果就更好了呢？不知道！这时要对所有样本再预测一遍、再计算一次损失，才知道。于是，迭代开始了。&lt;/p&gt;
&lt;p&gt;如此，反复迭代预测、算损失、调参的流程，至到天荒地老（即收敛，收敛了就放过它）。迭代的过程是自驱动的，这个是机器学习的特点。&lt;/p&gt;
&lt;p&gt;迭代的流程是比较重要的概念（能让你较全局地理解机器学习），你有必要在脑海中多想一下这个情景，为了配合你，小程把一元回归模型的图放在下面，你想像一下，图里面的那根线，调整一个角度后，对所有点算一次损失，如果不是最小损失，就再调整一个角度...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4-%E5%AF%B9%E6%89%80%E6%9C%89%E6%A0%B7%E6%9C%AC%E8%AE%A1%E7%AE%97%E6%8D%9F%E5%A4%B1.jpg&quot; alt=&quot;迭代-调整角度&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面多次说到调整参数，说得轻巧，怎么调整？随便加1或减1吗？&lt;/p&gt;
&lt;h4 id=&quot;二调整模型参数的办法&quot;&gt;（二）调整模型参数的办法&lt;/h4&gt;
&lt;p&gt;在迭代学习的过程中，机器会自驱动地调整模型的参数。调整模型的参数是机器学习的一个重要环节，那么，如何调整模型的参数呢？&lt;/p&gt;
&lt;p&gt;以简单的一元回归（是一块钱回到家的意思吗？）为例：y=wx+b，要调整的参数就是w跟b，怎么调？首先你要记得你的目的，你调参的目的，是为了得到最小损失，那w跟b是何值时，才是最小损失呢？&lt;/p&gt;
&lt;p&gt;先说一个不经过设计的自然的想法，假设先调整w（b先随便固定一个值），如果我能把所有的w值的损失都计算出来了，也就是对于w取{1，-1，2，2.5，...}各个值时，都算出所有点的整体损失，那不是有最小损失了吗？最小损失对应的那个w值就是最佳的参数啊。&lt;/p&gt;
&lt;p&gt;想法是没错的，但是，一般来说，越自然的想法，越不是一个好的算法。&lt;/p&gt;
&lt;p&gt;算法就是设计的东西。怎么调整出最佳参数，同样有更好的算法，而不是对所有w值全量计算（效率太低了！），其中一个常用算法叫&lt;strong&gt;梯度下降法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先要理解一个前提。据研究（不是我的研究），损失跟权重的关系，是一个碗状图（这就是损失函数），就是这个：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E6%8D%9F%E5%A4%B1%E6%98%AF%E7%A2%97%E7%8A%B6.jpg&quot; alt=&quot;碗状的损失&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有什么特点？一个特点是，有一个最低点，就是损失最小的点，这个就是我们的目标（对应的w值就是最佳参数），另一个特点是，沿着碗边走，只要方向对而且移动幅度足够小，就一定能到达最低点。&lt;/p&gt;
&lt;p&gt;要到达远方，现在就要出发。这里有两个关键点，一个是方向，一个是移动幅度。&lt;/p&gt;
&lt;p&gt;怎么确定方向呢？比如对于曲线，往左还是往右（即w是增加还是减小），对于曲面呢？&lt;/p&gt;
&lt;p&gt;这时，梯度下降法来帮你，它可以有效地去到最低点。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以下分隔线内的东西，横空而来，你若有兴趣则读一读，它告诉你，什么是梯度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是导数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导数是函数的导数，函数只有一个自变量时叫导数（否则叫偏导数）。直观点，函数都是曲线，所以导数就是曲线上某一点的导数（不说不可导的情况）。&lt;/p&gt;
&lt;p&gt;某一点的导数是什么意思呢，就是这一点的变化率，定义大概是这样的（数学符号不好写）：在某一点，在x的增量趋于0时，也就是x的变化很小很小很小时，y的增量与x的增量的比值，就是变化率。明显，以x的增量趋于0来描述了这一点的变化（让变化很小）。这个就是变化率的含义，简单来说，导数就是变化率，描述了变化的情况。&lt;/p&gt;
&lt;p&gt;换一个角度来说（只考虑变量值是实数的情况），先看看我的手绘图（你给多少分？）：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E6%9F%90%E7%82%B9%E7%9A%84%E5%8F%98%E5%8C%96.jpg&quot; alt=&quot;某一点的变化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图，表达的是p1下一步（“附近”）的变化率，为了好画线，找了一个很远的p2点。你可以想象，当p1的下一步变化很小很小时（dx趋于0时），p2就会无限接近p1，而这个过程，直线p1p2的变化是怎么样的？想象一下，是不是p1p2会越来越像p1处的切线？&lt;/p&gt;
&lt;p&gt;点p1的导数，从另一个角度来说，就是这个地方的切线斜率。可以想象，如果曲线上的所有点，都取它的切线，就可以逼近曲线。这种用导数来还原曲线（函数）的办法，就叫积分。求导跟积分是互逆过程。&lt;/p&gt;
&lt;p&gt;如果你还是不太明白，那知道一个概念就算了：变化、导数跟切线，是关联的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是偏导数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到的损失函数是一个曲线，因为只有一个特征变量。如果有多个特征，那损失函数就不再是曲线，而是曲面（某点的切线有无数条）。曲面（多个自变量）时，不再叫导数，而叫某某变量的偏导数，只是为了明确是谁的变化率。而问题也在这里，为了得到x的偏导数，就要固定其它自变量，而此时的偏导数就只是沿x方向的变化（不能同时考虑进其它方向），这样就没有任意方向了，没有任意方向是个问题吗？&lt;/p&gt;
&lt;p&gt;举个例子，假设你在山坡上，你要走到山谷的小湖中。如果每次移动你只能在x、y或z（平面与高度）中的一个方向移动（假设你总能移动哪怕是穿透），那你只能是“直上直下”、“直前直后”的，这个不是高效的走法。此时，为了形象，手绘图再次出场：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E5%81%8F%E5%AF%BC%E4%B8%8E%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0.jpg&quot; alt=&quot;如何最快到山谷&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的虚线（实际上有无线），可能让你更快地到达小湖洗脚，这个叫方向导数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是方向导数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决直前直后的偏导数的问题，引入另一个概念就是方向导数。方向导数就是任意方向的导数，可以想象，你所在的山坡的位置，有无数的方向导数，于是，哪一个方向导数（也就是变化率）是变化最大的？变化最大的方向在哪里？这个大小跟方向都是可以求出来的。&lt;/p&gt;
&lt;p&gt;为了标志方向导数的最大值跟方向，引入了一个名字，叫梯度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是梯度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;终于到我出场了，梯度是一个矢量（有大小跟方向），梯度的值就是最大的变化率（方向导数的最大值），梯度的方向就是最大变化率的方向（取得最大方向导数的方向）。&lt;/p&gt;
&lt;p&gt;所以，沿着梯度的反方向，就是下降最快的方向，就是最快到损失最低点的方向，而梯度下降算法就利用了这个特征。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;梯度是一个矢量，值是最大方向导数的值，方向是取得最大方向导数的方向。是不是很绕？是的，跟废话一样绕。简单来说，梯度的反方向代表着最佳的前进方向，指引你快速到达损失最低点。&lt;/p&gt;
&lt;p&gt;问题是，我不会计算梯度啊，怎么办？在应用的世界，这都不是问题，比如tensorflow会帮你计算梯度，你躺着就好。&lt;/p&gt;
&lt;p&gt;但稍微理解一下操作总是要的吧。梯度下降法，在整体操作上，还是较容易理解的。可以参考这个图（图片来源于：&lt;a href=&quot;https://developers.google.com/machine-learning/crash-course/reducing-loss/gradient-descent&quot; class=&quot;uri&quot;&gt;https://developers.google.com/machine-learning/crash-course/reducing-loss/gradient-descent&lt;/a&gt;）：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%BF%AD%E4%BB%A3%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%9A%84%E6%93%8D%E4%BD%9C.jpg&quot; alt=&quot;梯度下降法的操作&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面提过，走到最低点，一看方向，二看移动幅度。方向的问题用梯度解决了，那移动的幅度呢？这时引入一个概念，叫&lt;strong&gt;学习速率（learning_rate）&lt;/strong&gt;，也叫&lt;strong&gt;步长&lt;/strong&gt;。移动的幅度，就是当前点的梯度值乘以学习速率（比如是0.001），再加上原梯度值。&lt;/p&gt;
&lt;p&gt;如果学习速率很小，那总会走到损失的最低点，但训练时间有可能很长。如果学习速率很大，那有可能总是跳过最低点而无法收敛（注意，不是说一出现跳过最低点就一定不能收敛，它可以左右摆动最终到达最低点，因为移动幅度是变化的，跟陡峭的程度有关）。&lt;/p&gt;
&lt;p&gt;一般可以边训练边观察，寻找一个折中的学习速率值，这个跟样本的数量、特征复杂度等有关。对于学习速率的直观感受，你可以在这个页面操作一下：&lt;br/&gt;&lt;a href=&quot;https://developers.google.com/machine-learning/crash-course/fitter/graph&quot; class=&quot;uri&quot;&gt;https://developers.google.com/machine-learning/crash-course/fitter/graph&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上就介绍了怎么调整参数。&lt;/p&gt;
&lt;p&gt;最后，再重提一下损失曲线，上面说每一次迭代都要对所有样本预测并计算损失，而实际上，“所有”并不是终极方案，如果有更优的方案呢，如果不必所有的样本都计算一次呢（毕竟有时样本是海量的）？这时，一些优化方案就出来了，比如随机梯度下降（只使用一个样本）、小批量随机梯度下降（多一点样本），这些就不细说了，谁用谁研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下，本文介绍了模型训练的迭代学习的原理。迭代学习的过程，主要是模型的计算参数被调整，进而触发反复的标签预测（预测是为了算损失）、损失计算与模型参数调整，是一个自驱动的过程。在迭代的过程中，调整模型的参数是重要的一环，梯度下降算法可以有效地调整模型参数，以达到最小的损失，从而使训练收敛。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E5%AD%A6%E9%BE%84%E5%89%8D%E6%B5%8B%E8%AF%95%E9%A2%98%EF%BC%9A%E5%B7%B4%E5%A3%AB%E5%BE%80%E5%93%AA%E8%BE%B9%E5%BC%80.png&quot; alt=&quot;idear&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 May 2019 10:15:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>之前介绍的简单线性回归，就是一个回归模型，是一个可用于机器学习的模型。什么意思呢？就是模型的状态（参数集合）是可以进化的，只要合理训练它，模型就能取得更好的预测状态，所以说模型可用于机器学习。 要应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freeself/p/10919610.html</dc:identifier>
</item>
</channel>
</rss>