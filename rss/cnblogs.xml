<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Vue躬行记（4）——组件 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11377043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11377043.html</guid>
<description>&lt;p&gt;　　组件是可复用的Vue实例，拥有属于自己的数据、模板、脚本和样式，可避免繁重的重复性开发。由于组件都是独立的，因此其内部代码不会影响其它组件，但可以包含其它组件，并且相互之间还能通信。&lt;/p&gt;

&lt;p&gt;　　在使用组件之前，需要先将其注册，Vue提供了两种注册方式：全局注册和局部注册。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）全局注册&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过Vue.component()方法可注册全局的组件，它能接收两个参数，第一个是组件名称，第二个既可以是扩展过的构造器（即Vue.extend()的返回值），也可以是选项对象（会自动调用Vue.extend()），如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;btn-custom&quot;, Vue.extend({ }));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩展过的构造器&lt;/span&gt;
Vue.component(&quot;btn-custom&quot;, { });                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选项对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　组件的选项对象也会包含data、methods、计算属性和生命周期钩子等成员，但不包含挂载目标el选项，并且data选项也不再是一个对象而是一个函数，因为只有这样才能让每个实例维护各自的数据对象，互不影响。注意，只有在组件注册之后才能将其应用于其它Vue根实例的模板中，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        txt: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      };
    },
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button&amp;gt;{{txt}}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({　
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　渲染出的DOM结构如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　组件的命名方式除了上面的连字符分隔式之外，还有另一种大驼峰式（例如BtnCustom）。当把组件引用至字符串模板中时，两种命名方式都是有效的；而当把组件直接应用到DOM模板中时（如下所示），就不能用大驼峰命名，因为标签会被自动转换成小写（即&amp;lt;btncustom&amp;gt;），于是就找不到这个组件的定义，进而抛出错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BtnCustom&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;BtnCustom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）局部注册&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Vue的局部注册需要分两步，首先通过创建选项对象的方式来定义组件，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; BtnCustom =&lt;span&gt; {
  data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      txt: &lt;/span&gt;&quot;提交&quot;&lt;span&gt;
    };
  },
  template: &lt;/span&gt;&quot;&amp;lt;button&amp;gt;{{txt}}&amp;lt;/button&amp;gt;&quot;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在Vue根实例的components选项中注册要使用的组件（如下所示），其中属性名就是模板中要使用的自定义元素名，属性值就是组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&quot;#container&quot;&lt;span&gt;,
  components: {
    &lt;/span&gt;&quot;btn-custom&quot;&lt;span&gt;: BtnCustom
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，当构建一个组件时，其模板中必须包含一个根元素，之前的示例都只有一个元素。如果有多个元素，那么就得像下面这样用一个元素（&amp;lt;div&amp;gt;）包裹其它元素（&amp;lt;span&amp;gt;和&amp;lt;button&amp;gt;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; BtnCustom =&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;按钮&amp;lt;/span&amp;gt;
      &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;`
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　组件的props选项能接收从外部（可以是父组件）传递进来的数据，其值是一个由HTML特性组成的数组或对象，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;in-html&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    props: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inHtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button&amp;gt;{{inHtml}}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于HTML特性的名称大小写不敏感，因此浏览器会将所有大写字母自动转换成小写。这意味着如果在组件内为props选项添加驼峰式的特性（例如inHtml），那么在DOM模板中需要声明成等价的连字符分隔式的特性（例如in-html），否则在组件内将读取不到该特性。有一点要注意，在字符串模板中使用特性，两种命名方式都是有效的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）动态传值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　特性值的类型除了上文的字符串之外，还可以通过v-bind指令动态的将任意类型传递给组件的props选项，例如传入一个数字，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;:digit&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    props: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;digit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.digit;         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;number&quot;&lt;/span&gt;
&lt;span&gt;    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在created钩子中调用typeof运算符计算this.digit，得到的值为“number”，说明数字传递成功。&lt;/p&gt;
&lt;p&gt;　　如果要传递对象的所有属性，那么不必一个一个声明，只需要不定义v-bind的参数即可，如下所示，两个btn-custom组件是等价的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;v-bind&lt;/span&gt;&lt;span&gt;=&quot;obj&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 相当于 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;:id&lt;/span&gt;&lt;span&gt;=&quot;obj.id&quot;&lt;/span&gt;&lt;span&gt; :name&lt;/span&gt;&lt;span&gt;=&quot;obj.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    props: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button&amp;gt;{{id}}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      obj: { id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，在props选项中声明的是id或name，而不是obj。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数据流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在Vue中，组件之间的数据是自顶向下单向流动的（即单向数据流），父组件通过props将数据传递给子组件。一旦父组件的数据有所更新，那么子组件也会自动更新，如果在子组件中修改接收的props（例如下面的digit特性），那么Vue会抛出错误警告，避免改变父组件的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;btn-custom&quot;&lt;span&gt;, {
  props: [&lt;/span&gt;&quot;digit&quot;&lt;span&gt;],
  created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.digit = 2&lt;span&gt;;
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很多需要改变props的情况，其实都能以另一种更合理的方式解决，例如将其保存到组件的data属性中或定义成一个计算属性等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）校验特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　组件的props能以对象的形式指定值类型，其键是接收的特性名称，值是类型构造函数。这样既有助于阅读，也可以避免传递无效的值。在下面的示例中，指定了digit必须是数字，而number既可以是数字也可以是字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;btn-custom&quot;&lt;span&gt;, {
  props: {
    digit: Number,
    number: [Number, String]
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了Number和String之外，内置的构造函数还有Boolean、Array、Object、Date、Function和Symbol。不仅如此，还可以自定义构造函数，通过instanceof运算符来检查。在下面的示例中，验证man特性是否是通过new Person()创建的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;btn-custom&quot;&lt;span&gt;, {
  props: {
    man: People
  }
});
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; People(name) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了基础的类型检查之外，组件还允许自定义验证函数、添加必填标记和附带默认值，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;btn-custom&quot;&lt;span&gt;, {
  props: {
    digit: {        
      type: Number,
      required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填&lt;/span&gt;
&lt;span&gt;    },
    number: {        
      type: Number,
      &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: 100      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数字默认值&lt;/span&gt;
&lt;span&gt;    },
    people: {        
      type: Object,
      &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;function&lt;/span&gt;() {           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象默认值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; { name: &quot;strick&quot;&lt;span&gt; };
      }
    },
    name: {            
      validator: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证函数&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; value.length &amp;gt; 5&lt;span&gt;;
      }
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在使用这些校验规则时，有两点需要注意：&lt;/p&gt;
&lt;p&gt;　　（1）当默认值是对象或数组时，需要从函数中获取。&lt;/p&gt;
&lt;p&gt;　　（2）由于props会在组件实例创建之前进行验证，因此在default()和validator()函数中不能使用组件的属性，例如data、computed、methods等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）未在props中的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　组件可以声明任意多个特性，而那些没有在props中定义的特性不但会被保存到实例属性$attrs中，还会被添加到根元素上。注意，class和style两个特性未包含在$attrs属性中，并且它们会与原特性进行合并，而不是替换。以下面的btn-custom组件为例，根元素&amp;lt;button&amp;gt;会接收type和class两个特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    props: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;digit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$attrs);         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{type: &quot;submit&quot;}&lt;/span&gt;
&lt;span&gt;    },
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button type=&quot;button&quot; class=&quot;warning&quot;&amp;gt;{{digit}}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　渲染出的&amp;lt;button&amp;gt;元素如下所示，其中type的值被替换成了“submit”，而class的值变成了“warning size”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;warning size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不想让根元素继承特性，那么可以将组件的inheritAttrs选项设为false，但要注意，inheritAttrs不会影响class和style的传递。还是以btn-custom组件为例，props和template两个选项与之前相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;btn-custom &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn-custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    inheritAttrs: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　渲染出的&amp;lt;button&amp;gt;元素如下所示，其中type的值未被替换，而class的值仍然是“warning size”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;warning size&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　混入（mixin）是一种代码复用技术，一个混入对象可包含任意组件选项，并能将其与普通组件混合在一起。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）选项合并策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当组件和混入对象包含同名选项时，这些选项将会通过2种策略进行合并。&lt;/p&gt;
&lt;p&gt;　　（1）当数据对象或值为对象的选项（例如methods、components等）发生冲突时，同名的属性将以组件的为准。如下代码所示，虽然混入对象Mixin的数据对象也包含name属性，但是依然会被btn-custom组件中的name属性所覆盖，并且它的getName()也会被替换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Mixin =&lt;span&gt; {
  data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { name: &quot;strick&quot;&lt;span&gt; };
  },
  methods: {
    getName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&quot;mixin&quot;&lt;span&gt;);
    }
  }
};
Vue.component(&lt;/span&gt;&quot;btn-custom&quot;&lt;span&gt;, {
  mixins: [Mixin],
  data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { name: &quot;freedom&quot;&lt;span&gt; };
  },
  methods: {
    getName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&quot;component&quot;&lt;span&gt;);
    }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）当生命周期钩子发生冲突时，同名的钩子将合并成一个数组，混入对象的钩子在前，组件的钩子在后，如下所示，先输出“mixin”，再输出“component”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Mixin =&lt;span&gt; {
  created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;mixin&quot;&lt;span&gt;);
  }
};
Vue.component(&lt;/span&gt;&quot;btn-custom&quot;&lt;span&gt;, {
  mixins: [Mixin],
  created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;component&quot;&lt;span&gt;);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）全局混入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过Vue.mixin()方法可注册全局的混入对象，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Vue.mixin({
  created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;&quot;global&quot;&lt;span&gt;);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　全局混入会影响所有的Vue实例，包括自定义的组件或第三方组件，因此要谨慎使用。大部分情况下它只适合自定义的选项，在官方的代码风格指南中，为混入中的这些选项制订了专门的命名规范，即以“$_”和自定义的命名空间为前缀（例如$_namespace_），从而避免与其它实例中的选项相冲突，下面是一个简单的示例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Vue.mixin({
  $_namespace_getAge: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 28&lt;span&gt;;
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）自定义选项合并策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　除了预定义的合并策略之外，Vue还允许自定义合并策略，只需在Vue.config.optionMergeStrategies中添加一个包含合并逻辑的函数即可。&lt;/p&gt;
&lt;p&gt;　　下面是一个示例，首先在混入对象和组件中都声明了一个自定义的age选项；然后在Vue.config.optionMergeStrategies中添加一个同名的age()函数，并且需要在组件之前声明合并函数；最后在created钩子中调用实例属性$options，读取到的age值为28，符合age()函数中的合并规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Mixin =&lt;span&gt; {
  age: &lt;/span&gt;28&lt;span&gt;
};
Vue.config.optionMergeStrategies.age &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(toVal, fromVal) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fromVal &amp;gt; toVal ?&lt;span&gt; toVal : fromVal;
};
Vue.component(&lt;/span&gt;&quot;btn-custom&quot;&lt;span&gt;, {
  mixins: [Mixin],
  created: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$options.age;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;
&lt;span&gt;  },
  age: &lt;/span&gt;30&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Vue内置的&amp;lt;component&amp;gt;元素可渲染一个元组件为动态组件，通过它的is特性来决定使用哪个组件。下面用一个例子来演示&amp;lt;component&amp;gt;元素的用法，首先全局注册两个组件tab1和tab2；然后将它们合并成数组赋给vm实例的tabs属性，而另一个current属性记录了当前要渲染的组件，默认值为tab1；最后将该属性值传递给is特性，并在DOM模板中创建两个按钮，每个按钮都注册了点击事件，可更改要渲染的组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;tab in tabs&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;current = tab&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ tab }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component &lt;/span&gt;&lt;span&gt;:is&lt;/span&gt;&lt;span&gt;=&quot;current&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input type=&quot;text&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
  Vue.component(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input type=&quot;text&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  });
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    data: {
      current: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      tabs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
  });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）&amp;lt;keep-alive&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　虽然可以动态切换组件，但是组件的状态无法保持，例如在tab1组件的文本框中输入字符，来回切换后，这些字符就消失了。如果要缓存组件的状态，那么可以用Vue提供的另一个内置的&amp;lt;keep-alive&amp;gt;元素，如下所示，用它来包裹&amp;lt;component&amp;gt;元素，就不会销毁失活的组件，从而提升渲染性能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component &lt;/span&gt;&lt;span&gt;:is&lt;/span&gt;&lt;span&gt;=&quot;current&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，&amp;lt;keep-alive&amp;gt;元素自身不会渲染成一个DOM元素，并且其可与任意元素配合，但子元素只能渲染一个。由此可知，&amp;lt;keep-alive&amp;gt;元素内可包含条件指令（如下所示），但不能包含v-for指令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tab1 &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;current == 'tab1'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tab1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tab2 &lt;/span&gt;&lt;span&gt;v-else&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tab2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有两个与&amp;lt;keep-alive&amp;gt;元素相关的生命周期钩子：activated和deactivated。以之前的tab1组件为例，为其添加这两个钩子（如下代码所示），它被包裹在&amp;lt;keep-alive&amp;gt;元素中。当激活tab1组件时，会触发activated钩子；而当停用tab1组件时，会触发deactivated钩子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Vue.component(&quot;tab1&quot;&lt;span&gt;, {
  template: &lt;/span&gt;'&amp;lt;input type=&quot;text&quot;/&amp;gt;'&lt;span&gt;,
  activated: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;activated&quot;&lt;span&gt;);
  },
  deactivated: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;deactivated&quot;&lt;span&gt;);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 28 Oct 2019 00:27:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>组件是可复用的Vue实例，拥有属于自己的数据、模板、脚本和样式，可避免繁重的重复性开发。由于组件都是独立的，因此其内部代码不会影响其它组件，但可以包含其它组件，并且相互之间还能通信。 一、注册 在使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11377043.html</dc:identifier>
</item>
<item>
<title>java架构之路-（Redis专题）简单聊聊redis分布式锁 - 小菜技术</title>
<link>http://www.cnblogs.com/cxiaocai/p/11737372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxiaocai/p/11737372.html</guid>
<description>&lt;p&gt;　　这次我们来简单说说分布式锁，我记得过去我也过一篇JMM的内存一致性算法，就是说拿到锁的可以继续操作，没拿到的自旋等待。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思路与场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们在Zookeeper中提到过分布式锁，这里我们先用redis实现一个简单的分布式锁，这里是我们一个简单的售卖减库存的小实例，剩余库存假设存在数据库内。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@GetMapping(value = &quot;/getLock&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
        stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样简单的实现了一个售卖的过程，现在看来确实没什么问题的，但是如果是一个并发下的场景就可能会出现超卖的情况了，我们来改造一下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@GetMapping(value = &quot;/getLock&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
            stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　貌似这回就可以了，可以抗住高并发了，但是新的问题又来了，我们如果是分布式的场景下，synchronized关键字是不起作用的啊。也就是说还是会出现超卖的情况的啊，我们再来改造一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@GetMapping(value = &quot;/getLock&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
    String lockKey &lt;/span&gt;= &quot;lock&quot;&lt;span&gt;;

    Boolean bool &lt;/span&gt;= stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;xiaocai&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于我们的setnx命令&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;bool){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
        stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);
        stringRedisTemplate.delete(lockKey);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
        stringRedisTemplate.delete(lockKey);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次我们看来基本可以了，使用我们的setnx命令来做一次唯一的限制，万一报错了呢？解锁怎么办？再来改造一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@GetMapping(value = &quot;/getLock&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
    String lockKey &lt;/span&gt;= &quot;lock&quot;&lt;span&gt;;
    Boolean bool &lt;/span&gt;= stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;xiaocai&quot;, 10, TimeUnit.SECONDS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于我们的setnx命令&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bool) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
            stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bool) {
            stringRedisTemplate.delete(lockKey);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这次貌似真的可以了，可以加锁，最后在finally解锁，如果解锁还是不成功，我们还设置了我们的超时时间，貌似完美了，我们再来提出一个场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191026222151964-1074019708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   　　就是什么意思呢？我们的线程来争抢锁，拿到锁的线程开始执行，但是我们并不知道何时执行完成，我们只是设定了10秒自动释放掉锁，如果说我们的线程10秒还没有结束，其它线程会拿到锁资源，开始执行代码，但是过了一段时间（蓝色线程还未执行完成），这时我们的绿色线程执行完毕了，开始释放锁资源，他释放的其实已经不是他自己的锁了，他自己的锁超时了，自动释放了，实则绿色线程释放的蓝色的资源，这也就造成了释放其它的锁，其它的线程又会重复的拿到锁，重复执行该操作。明显有点乱了，这不合理，我们来改善一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@GetMapping(value = &quot;/getLock&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
    String lockKey &lt;/span&gt;= &quot;lock&quot;&lt;span&gt;;
    String lockValue &lt;/span&gt;=&lt;span&gt; UUID.randomUUID().toString();
    Boolean bool &lt;/span&gt;= stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, 10, TimeUnit.SECONDS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于我们的setnx命令&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bool) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
            stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lockValue.equals(stringRedisTemplate.opsForValue().get(lockKey))) {
            stringRedisTemplate.delete(lockKey);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次再来看一下流程，我们设置一个UUID，设置为锁的值，也就是说，每次上锁的UUID都是不一致的，我们的线程A的锁这次只能由我们的线程A来释放掉，不会造成释放其它锁的问题了，还是上次的图，我们回过头来看一下，10秒？真的合理吗？万一10秒还没有执行完成呢？有的人还会问，那设置100秒？万一执行到delete操作的时候，服务宕机了呢？是不是还要等待100秒才可以释放锁。别说那只是万一，我们的代码希望达到我们能力范围之内的最严谨。这次来说一下我们本节的其中一个重点，Lua脚本，后面会去说，我们来先用我们这次博文的Redisson吧&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redisson&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　刚才我们提到了我们锁的时间设置，多长才是合理的，100秒？可能宕机，造成等待100秒自动释放，1秒？线程可能执行不完，我们可不可以这样来做呢？我们设置一个30秒，或者说设置10秒，然后我们给予一个固定时间来检查我们的主线程是否执行完成，执行完成再释放我们的锁，思路有了，但是代码实现起来并不简单，别着急，我们已经有了现成的包供我们使用的，就是我们的Redisson，首先我们来引入我们的依赖，修改一下pom文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.redisson/redisson --&amp;gt;&lt;/span&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.11.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后通过@Bean的方式注入容器，三种方式我都写在上面了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Redisson redisson(){
    Config config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Config();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主从(单机)&lt;/span&gt;
    config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setDatabase(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;哨兵
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().setMasterName(&quot;mymaster&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().addSentinelAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.1.1:26379&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().addSentinelAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.1.2:26379&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().addSentinelAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.1..3:26379&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().setDatabase(0);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;集群
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useClusterServers()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.1:8001&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.2:8002&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.3:8003&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.4:8004&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.5:8005&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            .addNodeAddress(&quot;redis:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.6:8006&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    config.useSentinelServers().setPassword(&quot;xiaocai&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码设置&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (Redisson) Redisson.create(config);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们的是springboot也可以通过配置来实现的。&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
## 因为springboot-data-&lt;span&gt;redis 是用到了jedis，所已这里得配置
spring.redis.database&lt;/span&gt;=10&lt;span&gt;
spring.redis.pool.max&lt;/span&gt;-idle=8&lt;span&gt;
spring.redis.pool.min&lt;/span&gt;-idle=0&lt;span&gt;
spring.redis.pool.max&lt;/span&gt;-active=8&lt;span&gt;
spring.redis.pool.max&lt;/span&gt;-wait=-1&lt;span&gt;
## jedis 哨兵配置
spring.redis.sentinel.master&lt;/span&gt;=&lt;span&gt;mymaster
spring.redis.sentinel.nodes&lt;/span&gt;=192.168.1.241:26379,192.168.1.241:36379,192.168.1.241:46379&lt;span&gt;
spring.redis.password&lt;/span&gt;=&lt;span&gt;admin
## 关键地方 redisson
spring.redis.redisson.config&lt;/span&gt;=classpath:redisson.json
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;redisson.json&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## redisson.json 文件
{
  &lt;/span&gt;&quot;sentinelServersConfig&quot;&lt;span&gt;:{
    &lt;/span&gt;&quot;sentinelAddresses&quot;: [&quot;redis://192.168.1.241:26379&quot;,&quot;redis://192.168.1.241:36379&quot;,&quot;redis://192.168.1.241:46379&quot;&lt;span&gt;],
    &lt;/span&gt;&quot;masterName&quot;: &quot;mymaster&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;database&quot;: 0&lt;span&gt;,
    &lt;/span&gt;&quot;password&quot;:&quot;admin&quot;&lt;span&gt;
  }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就建立了我们的Redisson的连接了，我们来看一下如何使用吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.redisclient.cluster;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.redisson.Redisson;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.redisson.api.RLock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;


@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCluster {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringRedisTemplate stringRedisTemplate;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Redisson redisson;

    @GetMapping(value &lt;/span&gt;= &quot;/getLock&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getLock() {
        String lockKey &lt;/span&gt;= &quot;lock&quot;&lt;span&gt;;
        RLock redissonLock &lt;/span&gt;=&lt;span&gt; redisson.getLock(lockKey);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            redissonLock.lock();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(&quot;stock&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stock &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; realStock = stock - 1&lt;span&gt;;
                stringRedisTemplate.opsForValue().set(&lt;/span&gt;&quot;stock&quot;, realStock + &quot;&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;售卖成功,剩余&quot; + realStock + &quot;&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;剩余库存不足&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;fail&quot;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            redissonLock.unlock();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191026233134462-247555401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用也是超级简单的，Redisson还有重入锁功能等等，有兴趣的可以去Redisson查看，地址：&lt;a href=&quot;https://redisson.org/&quot;&gt;https://redisson.org/&lt;/a&gt; 国外的地址打开可能会慢一些。Redis的分布式锁使用就差不多说到这里了，我们来回到我们刚才说到的Lua脚本这里。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Lua脚本和管道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Lua脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　lua脚本就是一个事务控制的过程，我们可以在lua脚本中写一些列的命令，一次性的塞入到我们的redis客户端，保证了原子性，要么都成功，要么都失败。好处在于减少与reidis的多次连接，可以替代redis的事务操作以及保证我们的原子性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String luaString = &quot;&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Lua脚本&lt;/span&gt;
jedis.eval(luaString, Arrays.asList(&quot;keysList&quot;),Arrays.asList(&quot;valueList&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　脚本我就不写了（我也不熟悉），我来解释一下eval的三个参数，第一个是我们的写好的脚本，然后我们的脚本可能传参数的，也就是我们KEYS[1]或者是ARGV[4]，意思就是我们的KEYS[1]就是我们的ArrayList(&quot;keysList&quot;)中的第一项，ARGV[4]就是我们的ArrayList(&quot;valueList&quot;)的第四项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　管道和我们的和我们的Lua脚本差不多，不一样就是管道不会保证我们的事务，也就是说我们现在塞给管道10条命令 ，我们执行到第三条时报错了，后面的依然会执行，前面执行过的两条还是生效的。虽然可以减少我们的网络开销，也别一次塞太多命令进去，毕竟redis的是单线程的，不建议使用管道来操作redis，想深入了解的可以参照&lt;a href=&quot;https://www.runoob.com/redis/redis-pipelining.html&quot;&gt;https://www.runoob.com/redis/redis-pipelining.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　redis的分布式锁差不多就说这么多了，关键是实现思路，使用Redisson倒是很简单的，还有我们的Lua脚本和管道，Lua脚本可以保证事务，管道一次性可以执行多条命令，减少网络开销，但不建议使用，下次我们来说下，大厂用redis的一些使用注意事项和优化吧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191008130905751-289956431.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191008130911073-1068230076.jpg&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最进弄了一个公众号，小菜技术，欢迎大家的加入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191006211816137-1624049234.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 28 Oct 2019 00:21:00 +0000</pubDate>
<dc:creator>小菜技术</dc:creator>
<og:description>这次我们来简单说说分布式锁，我记得过去我也过一篇JMM的内存一致性算法，就是说拿到锁的可以继续操作，没拿到的自旋等待。 思路与场景 我们在Zookeeper中提到过分布式锁，这里我们先用redis实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxiaocai/p/11737372.html</dc:identifier>
</item>
<item>
<title>SpringBoot生命周期管理之停掉应用服务几种方法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11750227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11750227.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201910/1815316-20191028080931523-145091081.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在生产环境下管理Spring Boot应用的生命周期非常重要。Spring容器通过ApplicationContext处理应用服务的所有的beans的创建、初始化、销毁。&lt;br/&gt;本文着重于生命周期中的销毁阶段的处理，我将使用多种方式来实现关闭Spring Boot应用服务。如果你需要了解关于Spring Boot更多内容，请看我之前写过的文章和精品合辑！&lt;/p&gt;
&lt;h2 id=&quot;一通过actuator-shutdown-端点服务&quot;&gt;一、通过Actuator Shutdown 端点服务&lt;/h2&gt;
&lt;p&gt;Spring Boot Actuator是一个主要用于应用指标监控和健康检查的服务。可以通过Http访问对应的Endpoint来获取应用的健康及指标信息。另外，它还提供了一个远程通过http实现应用shutdown的端点。&lt;br/&gt;首先，我们要在Spring Boot中引入Actuator。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产环境通常出于安全考虑，不能将应用关闭的访问完全公开，我们还要引入spring-boot-starter-security。具体的安全配置，请参考学习Spring security，在此不多做叙述！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，出于安全考虑shutdown端点服务是处于关闭状态的，我们需要通过配置开启：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;management.endpoints.web.exposure.include=*
management.endpoint.shutdown.enabled=true
endpoints.shutdown.enabled=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们就可以通过发送一个Post请求，来停掉Spring Boot应用服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST localhost:port/actuator/shutdown&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法的缺陷在于：当你引入Actuator的shutdown服务的时候，其他的监控服务也自动被引入了。&lt;/p&gt;
&lt;h2 id=&quot;二-关闭application-context&quot;&gt;二、 关闭Application Context&lt;/h2&gt;
&lt;p&gt;我们也可以自己实现一个Controller开放访问端点，调用Application Context的close方法实现应用服务的关闭。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class ShutdownController implements ApplicationContextAware {
     
    private ApplicationContext context;
     
    @PostMapping(&quot;/shutdownContext&quot;)
    public void shutdownContext() {
        ((ConfigurableApplicationContext) context).close();
    }
 
    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        this.context = ctx;
         
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们添加了一个Controller继承自ApplicationContextAware接口，并且重写了setApplicationContext方法获取当前的应用上下文。然后在Post请求方法中调用close方法关闭当前应用。这种实现的方法更加轻量级，不会像Actuator一样引入更多的内容。我们同样可以通过发送Post请求，实现应用的关闭。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X POST localhost:port/shutdownContext&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同样，当你对外开放一个关闭服务的端点，你要考虑它的权限与安全性&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四退出-springapplication&quot;&gt;四、退出 &lt;em&gt;SpringApplication&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;还可以通过&lt;em&gt;SpringApplication&lt;/em&gt; 向JVM注册一个 &lt;em&gt;shutdown&lt;/em&gt; 钩子来确保应用服务正确的关闭。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConfigurableApplicationContext ctx = new SpringApplicationBuilder(Application.class)
  .web(WebApplicationType.NONE).run();
 
int exitCode = SpringApplication.exit(ctx, new ExitCodeGenerator() {
@Override
public int getExitCode() {
        // return the error code
        return 0;
    }
});
 
System.exit(exitCode);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的效果，使用Java 8 lambda可以这样实现，代码简单很多:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringApplication.exit(ctx, () -&amp;gt; 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五kill杀掉应用进程&quot;&gt;五、kill杀掉应用进程&lt;/h2&gt;
&lt;p&gt;我们还可以使用bat或者shell脚本来停止应用的进程。所以，我们首先在应用启动的时候，要把进程ID写到一个文件里面。如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SpringApplicationBuilder app = new SpringApplicationBuilder(Application.class)
  .web(WebApplicationType.NONE);
app.build().addListeners(new ApplicationPidFileWriter(&quot;./bin/shutdown.pid&quot;));
app.run();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个&lt;em&gt;shutdown.bat&lt;/em&gt;脚本，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill $(cat ./bin/shutdown.pid)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调用这个脚本就可以把应用服务进程杀死。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Mon, 28 Oct 2019 00:10:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>前言 在生产环境下管理Spring Boot应用的生命周期非常重要。Spring容器通过ApplicationContext处理应用服务的所有的beans的创建、初始化、销毁。 本文着重于生命周期中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11750227.html</dc:identifier>
</item>
<item>
<title>Spring 框架基础(04)：AOP切面编程概念，几种实现方式演示 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/11750221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/11750221.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/spring-mvc-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/spring-mvc-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;切面编程简介&quot;&gt;1、切面编程简介&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AOP全称：Aspect Oriented Programming，面向切面编程。通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。核心作用：可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的复用性和开发效率。AOP提供了取代继承和委托的一种新的方案，而且使用起来更加简洁清晰，是软件开发中的一个热点理念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;aop术语&quot;&gt;2、AOP术语&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201910/1691717-20191028080232167-224489002.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(1)、通知类型:Advice&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;前置通知[Before]：目标方法被调用之前;
返回通知[After-returning]：目标方法执行成功之后;
异常通知[After-throwing]：在目标方法抛出异常之后; 
后置通知[After]：目标方法完成之后;
环绕通知[Around]：在目标方法执行前后环绕通知;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)、连接点：JoinPoint&lt;/p&gt;
&lt;p&gt;程序执行的某一个特定位置，如类初始前后，方法的运行前后。&lt;/p&gt;
&lt;p&gt;(3)、切点:Pointcut&lt;/p&gt;
&lt;p&gt;连接点是指那些在指定策略下可能被拦截到的方法。&lt;/p&gt;
&lt;p&gt;(4)、切面：Aspect&lt;/p&gt;
&lt;p&gt;切面由切点和通知的结合。&lt;/p&gt;
&lt;p&gt;(5)、引入：Introduction&lt;/p&gt;
&lt;p&gt;特殊的增强,为类添加一些属性和方法。&lt;/p&gt;
&lt;p&gt;(6)、织入：Weaving&lt;/p&gt;
&lt;p&gt;将增强添加到目标类的具体连接点上的过程。编译期织入，这要求使用特殊编译器；类装载期织入，这要求使用特殊的类加载器；动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring采用的是动态代理织入，而AspectJ采用编译期织入和类装载期织入。&lt;/p&gt;
&lt;p&gt;(7)、代理：Proxy&lt;/p&gt;
&lt;p&gt;类被AOP织入后生成一个结果类，它是融合了原类和增强逻辑的代理类。&lt;/p&gt;

&lt;p&gt;案例基于如下类进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Book {
    private String bookName ;
    private String author ;
}
public interface BookService {
    void addBook (Book book) ;
}
public class BookServiceImpl implements BookService {
    @Override
    public void addBook(Book book) {
        System.out.println(book.getBookName());
        System.out.println(book.getAuthor());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jdk动态代理&quot;&gt;1、JDK动态代理&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class BookAopProxyFactory {
    public static BookService createService() {
        // 目标类
        final BookService bookService = new BookServiceImpl() ;
        // 切面类
        final BookAspect bookAspect = new BookAspect();
        /*
         * 代理类：将目标类（切入点）和 切面类（通知） 结合
         */
        BookService proxyBookService = (BookService) Proxy.newProxyInstance(
                BookAopProxyFactory.class.getClassLoader(),
                bookService.getClass().getInterfaces(),
                new InvocationHandler() {
                    public Object invoke(Object proxy, Method method,
                                         Object[] args) throws Throwable {
                        // 前执行
                        bookAspect.before();
                        // 执行目标类的方法
                        Object obj = method.invoke(bookService, args);
                        // 后执行
                        bookAspect.after();
                        return obj;
                    }
                });
        return proxyBookService ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cglib字节码增强&quot;&gt;2、CgLib字节码增强&lt;/h2&gt;
&lt;p&gt;采用字节码增强框架cglib，在运行时创建目标类的子类，从而对目标类进行增强。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BookAopCgLibFactory {
    public static BookService createService() {
        // 目标类
        final BookService bookService = new BookServiceImpl() ;
        // 切面类
        final BookAspect bookAspect = new BookAspect();
        // 核心代理类
        Enhancer enhancer = new Enhancer();
        // 确定父类
        enhancer.setSuperclass(bookService.getClass());
        // 设置回调函数
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object proxy, Method method,
                                    Object[] args,
                                    MethodProxy methodProxy) throws Throwable {
                bookAspect.before();
                Object obj = method.invoke(bookService, args);
                bookAspect.after();
                return obj;
            }
        });
        BookServiceImpl proxyService = (BookServiceImpl) enhancer.create();
        return proxyService ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring半自动代理&quot;&gt;3、Spring半自动代理&lt;/h2&gt;
&lt;p&gt;spring 创建代理对象，从spring容器中手动的获取代理对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 创建目标类 --&amp;gt;
&amp;lt;bean id=&quot;bookService&quot; class=&quot;com.spring.mvc.service.impl.BookServiceImpl&quot; /&amp;gt;
&amp;lt;!-- 创建切面类 --&amp;gt;
&amp;lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.mvc.config.BookAopSpringHalf&quot; /&amp;gt;
&amp;lt;!-- 创建代理类 --&amp;gt;
&amp;lt;bean id=&quot;proxyFactory&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;interfaces&quot; value=&quot;com.spring.mvc.service.BookService&quot; /&amp;gt;
    &amp;lt;property name=&quot;target&quot; ref=&quot;bookService&quot; /&amp;gt;
    &amp;lt;property name=&quot;interceptorNames&quot; value=&quot;myAspect&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class BookAopSpringHalf implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;Method Before ...&quot;);
        Object obj = methodInvocation.proceed();
        System.out.println(&quot;Method After ...&quot;);
        return obj;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring全自动代理&quot;&gt;4、Spring全自动代理&lt;/h2&gt;
&lt;p&gt;从spring容器获得目标类，如果配置Aop，spring将自动生成代理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 创建目标类 --&amp;gt;
&amp;lt;bean id=&quot;bookService&quot; class=&quot;com.spring.mvc.service.impl.BookServiceImpl&quot; /&amp;gt;
&amp;lt;!-- 创建切面类 --&amp;gt;
&amp;lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.mvc.config.BookAopSpringHalf&quot; /&amp;gt;
&amp;lt;!-- AOP编程配置 --&amp;gt;
&amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt;
    &amp;lt;aop:pointcut expression=&quot;execution(* com.spring.mvc.service.*.*(..))&quot;
                  id=&quot;myPointCut&quot;/&amp;gt;
    &amp;lt;aop:advisor advice-ref=&quot;myAspect&quot; pointcut-ref=&quot;myPointCut&quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;综合测试&quot;&gt;5、综合测试&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void test1 (){
    BookService bookService = BookAopProxyFactory.createService() ;
    Book book = new Book() ;
    book.setBookName(&quot;Spring实战&quot;);
    book.setAuthor(&quot;Craig Walls&quot;);
    bookService.addBook(book);
}
@Test
public void test2 (){
    BookService bookService = BookAopCgLibFactory.createService() ;
    Book book = new Book() ;
    book.setBookName(&quot;MySQL&quot;);
    book.setAuthor(&quot;Baron&quot;);
    bookService.addBook(book);
}
@Test
public void test3 (){
    String xmlPath = &quot;spring-aop-half.xml&quot;;
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(xmlPath);
    BookService bookService = (BookService) context.getBean(&quot;proxyFactory&quot;);
    Book book = new Book() ;
    book.setBookName(&quot;红楼梦&quot;);
    book.setAuthor(&quot;曹雪芹&quot;);
    bookService.addBook(book);
}
@Test
public void test4 (){
    String xmlPath = &quot;spring-aop-all.xml&quot;;
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(xmlPath);
    BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);
    Book book = new Book() ;
    book.setBookName(&quot;西游记&quot;);
    book.setAuthor(&quot;吴承恩&quot;);
    bookService.addBook(book);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;基础简介&quot;&gt;1、基础简介&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;AspectJ是一个基于Java语言的AOP框架，Spring2.0以后新增了对AspectJ切点表达式支持，通过JDK5注解技术，允许直接在类中定义切面，新版本Spring框架，推荐使用AspectJ方式来开发AOP编程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;xml配置方式&quot;&gt;2、XML配置方式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class BookAopAspectJ {
    public void myBefore(JoinPoint joinPoint){
        System.out.println(&quot;前置通知：&quot; + joinPoint.getSignature().getName());
    }
    public void myAfterReturning(JoinPoint joinPoint,Object ret){
        System.out.println(&quot;后置通知：&quot; + joinPoint.getSignature().getName() + &quot; , --&amp;gt;&quot; + ret);
    }
    public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println(&quot;环绕通知前&quot;);
        Object obj = joinPoint.proceed();
        System.out.println(&quot;环绕通知前后&quot;);
        return obj;
    }
    public void myAfterThrowing(JoinPoint joinPoint,Throwable e){
        System.out.println(&quot;抛出异常通知 ： &quot; + e.getMessage());
    }
    public void myAfter(JoinPoint joinPoint){
        System.out.println(&quot;最终通知&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 创建目标类 --&amp;gt;
&amp;lt;bean id=&quot;bookService&quot; class=&quot;com.spring.mvc.service.impl.BookServiceImpl&quot; /&amp;gt;
&amp;lt;!-- 创建切面类 --&amp;gt;
&amp;lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.mvc.config.BookAopAspectJ&quot; /&amp;gt;
&amp;lt;!-- 配置AOP编程 --&amp;gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect ref=&quot;myAspect&quot;&amp;gt;
        &amp;lt;aop:pointcut expression=&quot;execution(* com.spring.mvc.service.impl.BookServiceImpl.*(..))&quot; id=&quot;myPointCut&quot;/&amp;gt;
        &amp;lt;!-- 前置通知--&amp;gt;
        &amp;lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;myPointCut&quot;/&amp;gt;
        &amp;lt;!-- 后置通知 --&amp;gt;
        &amp;lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;myPointCut&quot; returning=&quot;ret&quot; /&amp;gt;
        &amp;lt;!-- 环绕通知 --&amp;gt;
        &amp;lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;myPointCut&quot;/&amp;gt;
        &amp;lt;!-- 抛出异常 --&amp;gt;
        &amp;lt;aop:after-throwing method=&quot;myAfterThrowing&quot; pointcut-ref=&quot;myPointCut&quot; throwing=&quot;e&quot;/&amp;gt;
        &amp;lt;!-- 最终通知 --&amp;gt;
        &amp;lt;aop:after method=&quot;myAfter&quot; pointcut-ref=&quot;myPointCut&quot;/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void test1 (){
    String xmlPath = &quot;spring-aop-aspectj-01.xml&quot;;
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(xmlPath);
    BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);
    Book book = new Book() ;
    book.setBookName(&quot;三国演义&quot;);
    book.setAuthor(&quot;罗贯中&quot;);
    bookService.addBook(book);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注解扫描方式&quot;&gt;3、注解扫描方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 开启类注解的扫描 --&amp;gt;
&amp;lt;context:component-scan base-package=&quot;com.spring.mvc.service.impl&quot; /&amp;gt;
&amp;lt;!-- 确定AOP注解生效 --&amp;gt;
&amp;lt;aop:aspectj-autoproxy /&amp;gt;
&amp;lt;!-- 声明切面 --&amp;gt;
&amp;lt;bean id=&quot;myAspect&quot; class=&quot;com.spring.mvc.config.AuthorAopAspectJ&quot; /&amp;gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect ref=&quot;myAspect&quot; /&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注解切面类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Component
@Aspect
public class AuthorAopAspectJ {
    @Pointcut(&quot;execution(* com.spring.mvc.service.impl.AuthorServiceImpl.*(..))&quot;)
    private void myPointCut(){
    }
    @Before(&quot;execution(* com.spring.mvc.service.impl.AuthorServiceImpl.*(..))&quot;)
    public void myBefore(JoinPoint joinPoint){
        System.out.println(&quot;前置通知：&quot; + joinPoint.getSignature().getName());
    }
    @AfterReturning(value=&quot;myPointCut()&quot; ,returning=&quot;ret&quot;)
    public void myAfterReturning(JoinPoint joinPoint,Object ret){
        System.out.println(&quot;后置通知：&quot; +
                joinPoint.getSignature().getName() + &quot; , --&amp;gt;&quot; + ret);
    }
    @Around(value = &quot;myPointCut()&quot;)
    public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println(&quot;环绕通知前&quot;);
        Object obj = joinPoint.proceed();
        System.out.println(&quot;环绕通知前后&quot;);
        return obj;
    }
    @AfterThrowing(
            value=&quot;execution(* com.spring.mvc.service.impl.AuthorServiceImpl.*(..))&quot;,
            throwing=&quot;e&quot;)
    public void myAfterThrowing(JoinPoint joinPoint,Throwable e){
        System.out.println(&quot;抛出异常通知 ： &quot; + e.getMessage());
    }
    @After(&quot;myPointCut()&quot;)
    public void myAfter(JoinPoint joinPoint){
        System.out.println(&quot;最终通知&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
public void test2 (){
    String xmlPath = &quot;spring-aop-aspectj-02.xml&quot;;
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(xmlPath);
    AuthorService authorService = (AuthorService) context.getBean(&quot;authorService&quot;);
    System.out.println(&quot;作者：&quot;+authorService.getAuthor());
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/spring-mvc-parent
GitEE·地址
https://gitee.com/cicadasmile/spring-mvc-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Oct 2019 00:05:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' 一、AOP基础简介 1、切面编程简介 AOP全称：Aspect Oriented Programming，面向切面编程。通过预编译方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/11750221.html</dc:identifier>
</item>
<item>
<title>掌握设计模式之策略模式 - 闻人的技术博客</title>
<link>http://www.cnblogs.com/one12138/p/11750208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/one12138/p/11750208.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近段时间，接到一个需求：开发一个聚合支付服务，对其他内部项目提供统一的接口来实现不同支付平台的支付能力发起，比如支付宝，微信，银联等。为了处理相似的支付操作而各平台具体实现不同的情况，要让各个平台接口能力能相互独立，并要方便扩展后续新增的支付平台，我引入了设计模式的策略模式来应对需求场景，借此深入学习总结下策略模式，于是也就有了本文，希望对学习策略模式的同学有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要策略模式&quot;&gt;为什么需要策略模式&lt;/h2&gt;
&lt;p&gt;日常工作开发中我们总会遇到如下熟悉的代码片段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(condition1){
 // do something1
} else if (condition2){
 // do something2
} else if (condition3){
 // do something3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在每个 if 条件下都有数十行甚至百行的业务处理，各自处理又是相互独立的并且目的一致，都汇聚在一个方法里。这样的写法不但让类变得臃肿冗长，并且不同逻辑都在一个类中修改，维护和扩展起来都很费劲。那么又有什么办法可以优化这大段的代码呢，在实现功能的同时，让代码更加灵活和易维护。&lt;/p&gt;
&lt;p&gt;要解决这个问题，本文的主角—&lt;strong&gt;策略模式&lt;/strong&gt; 就登场了，作为设计模式中比较简单的行为型模式，其实很多框架中都见到它的身影，稍后我们也会从各框架源码中识别策略模式的应用。使用策略模式可以帮助我们将每个处理逻辑封装成独立的类，客户端类需要进行哪种处理逻辑就使用对应的类，调用其封装了业务处理细节的方法即可。这样一来，客户端类减少了业务处理逻辑的大量代码，让自身更加精简。当业务逻辑有所改动时，只要在对应的类中修改，而不影响其他的类；并且如果出现了新的业务逻辑只要新增相似的类进行实现，供客户端类调用即可。&lt;/p&gt;
&lt;h2 id=&quot;什么是策略模式&quot;&gt;什么是策略模式&lt;/h2&gt;
&lt;p&gt;接下来我们就介绍下策略模式的定义和组成，以及它的基本形式。&lt;/p&gt;
&lt;p&gt;首先看下维基百科上策略模式的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;7.953795379538&quot;&gt;
&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_programming&quot;&gt;computer programming&lt;/a&gt;, the &lt;strong&gt;strategy pattern&lt;/strong&gt; (also known as the &lt;strong&gt;policy pattern&lt;/strong&gt;) is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Behavioral_design_pattern&quot;&gt;behavioral&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_pattern_(computer_science)&quot;&gt;software design pattern&lt;/a&gt; that enables selecting an &lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithm&quot;&gt;algorithm&lt;/a&gt; at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;策略模式也叫政策模式，允许程序在运行时选择一个算法执行，通常存在一类算法实现提供外部选择执行，这里的算法，也可以叫做策略，相当于上节内容提到的具体处理逻辑。&lt;/p&gt;
&lt;p&gt;再来看下 《&lt;strong&gt;设计模式：可复用面向对象软件的基础&lt;/strong&gt;》一书中对策略模式的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再次对其定义解读：定义一类算法，各自独立封装实现，并且相互之间是可替换的。除此之外，由客户端类决定具体使用哪个算法。&lt;/p&gt;
&lt;p&gt;上述两个定义都提到了&lt;strong&gt;算法&lt;/strong&gt;一词，它表示了完整的，不可再拆分的业务逻辑处理。通常用接口或者抽象类来表示一类算法的抽象，提供多种对该类算法的操作实现，以此组成一类独立且可替换的算法，也叫策略组。&lt;/p&gt;
&lt;p&gt;了解完定义后，我们再来看下策略模式通用类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201910/664672-20191028074544208-383909106.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图中涉及三类角色：Context，Strategy 和 ConcreteStrategy&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Strategy：抽象策略角色，代表某个算法的接口或者抽象类，定义了每个算法或者策略需要具有的方法和属性。&lt;/li&gt;
&lt;li&gt;Context：上下文角色，引用策略接口对象，屏蔽了外部模块对策略或方法的直接访问，只能通过Context 提供的方法访问。&lt;/li&gt;
&lt;li&gt;ConcreteStrategy：抽象策略的具体实现，该类含有具体的算法，并且通常不只一种实现，有多个类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三个角色的功能职责都十分明确，对应的源码实现也十分简单，现在我们就来快速看下每个角色对应的通用源码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 抽象的策略角色
public interface Strategy {
    void doSomething();
}

// 具体策略角色
public class ConcreteStrategy implements Strategy {
    @Override
    public void doSomething() {
        System.out.println(&quot;ConcreteStrategy doSomething !&quot;);
    }
}

// 上下文角色
public class Context {
    private final Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void doAnything() {
        this.strategy.doSomething();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了策略模式的基本代码结构，在客户端类中使用十分简单，想要哪个策略，就产生出它的具体策略对象放入上下文对象内，然后由上下文对象执行具体策略操作即可，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Client {
    public static void main(String[] args) {
        Strategy strategy = new ConcreteStrategy();
        Context context = new Context(strategy);
        context.doAnything(); // ConcreteStrategy doSomething !
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;识别策略模式&quot;&gt;识别策略模式&lt;/h2&gt;
&lt;p&gt;看清楚了策略模式的定义，角色组成以及通用的代码结构之后，我们就来看下策略模式在通用框架里的应用，来加深对策略模式的认识。&lt;/p&gt;
&lt;h3 id=&quot;jdk-与策略模式&quot;&gt;JDK 与策略模式&lt;/h3&gt;
&lt;p&gt;在常用的Java 集合框架中，比较器 &lt;strong&gt;java.util.Comparator&lt;/strong&gt; 的设计就采用了策略模式。Comparator 就是一个抽象的策略接口，只要一个类实现这个接口，自定 compare 方法，该类成为具体策略类，你可以在很多地址找到这个抽象策略接口的实现，官方在工具类 &lt;strong&gt;java.util.Comparators&lt;/strong&gt; 里也提供 NaturalOrderComparator，NullComparator 两种具体策略类。而使用 Comparator 到的 &lt;strong&gt;java.util.Collections&lt;/strong&gt; 类就是 Context 角色，将集合的比较功能封装成静态方法对外提供。&lt;/p&gt;
&lt;h3 id=&quot;spring-framework-与策略模式&quot;&gt;Spring Framework 与策略模式&lt;/h3&gt;
&lt;p&gt;Spring 框架最早以 IoC 和 DI 两大特性著称，不需要开发者自己创建对象，而是通过 Spring IoC 容器识别然后实例化所需对象。在 Spring 中将执行创建对象实例的这个操作封装为一种算法，用接口类 &lt;strong&gt;org.springframework.beans.factory.support.InstantiationStrategy&lt;/strong&gt; 进行声明，而具体策略类则有 &lt;strong&gt;org.springframework.beans.factory.support.SimpleInstantiationStrategy&lt;/strong&gt; 和 &lt;strong&gt;org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy&lt;/strong&gt; 两个，并且 CglibSubclassingInstantiationStrategy 是对 SimpleInstantiationStrategy 的继承扩展，也是 Spring 容器中真正使用到的策略类,具体应用的源码可参考 &lt;strong&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory&lt;/strong&gt; 类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    * Instantiate the given bean using its default constructor.
    * @param beanName the name of the bean
    * @param mbd the bean definition for the bean
    * @return a BeanWrapper for the new instance
    */
protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    //...
    beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用策略模式&quot;&gt;如何使用策略模式&lt;/h2&gt;
&lt;h3 id=&quot;实例应用&quot;&gt;实例应用&lt;/h3&gt;
&lt;p&gt;俗话说学以致用，接触了策略模式后我们应该想想怎么用在自己日常开发项目中呢，这里就简单通过一个实例来说明下策略模式的使用方式。假设现在有个需求：需要对一个目录或者文件实现两种不同格式的解压缩方式：zip压缩和gzip压缩，也后续可能新增其他的解压缩方式。&lt;/p&gt;
&lt;p&gt;我们首先将解压缩的算法抽象成抽象策略接口 CompressStrategy， 提供压缩方法 compress 和解压缩方法 uncompress，分别接受源文件路径和目的文件路径。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;策略类在命名通常上以 Strategy 为后缀，来指明自身采用策略模式进行设计，以此简化与其他人沟通成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface CompressStrategy {
    public boolean compress(String source, String to);
    public boolean uncompress(String source, String to);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再对抽象策略接口进行实现，分别提供zip 压缩算法和 gzip 压缩算法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZipStrategy implements CompressStrategy {

    @Override
    public boolean compress(String source, String to) {
        System.out.println(source + &quot; --&amp;gt; &quot; + to + &quot; ZIP压缩成功!&quot;);
        return true;
    }

    @Override
    public boolean uncompress(String source, String to) {
        System.out.println(source + &quot; --&amp;gt; &quot; + to + &quot; ZIP解压缩成功!&quot;);
        return true;
    }
}

public class GzipStrategy implements CompressStrategy {

    @Override
    public boolean compress(String source, String to) {
        System.out.println(source + &quot; --&amp;gt; &quot; + to + &quot; GZIP压缩成功!&quot;);
        return true;
    }

    @Override
    public boolean uncompress(String source, String to) {
        System.out.println(source + &quot; --&amp;gt; &quot; + to + &quot; GZIP解压缩成功!&quot;);
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码示例里的实现为了简化只是简单打印操作，具体实现可以参考 JDK API 进行操作。&lt;/p&gt;
&lt;p&gt;接下来看下 Context 角色的代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CompressContext {

    private CompressStrategy compressStrategy;

    public CompressContext(CompressStrategy compressStrategy) {
        this.compressStrategy = compressStrategy;
    }

    public boolean compress(String source, String to) {
        return compressStrategy.compress(source, to);
    }

    public boolean uncompress(String source, String to) {
        return compressStrategy.uncompress(source, to);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十分简单，只是传入一个具体算法，然后执行，到这里标准的策略模式就编写完毕了。客户端类只是根据需要指定的具体压缩策略对象传给 CompressContext 对象即可。如果要新增一个压缩算法，也只需对 CompressStrategy 接口提供新的实现即可传给 CompressContext 对象使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Client {
    public static void main(String[] args) {
        CompressContext context;
        System.out.println(&quot;========执行算法========&quot;);
        context = new CompressContext(new ZipStrategy());
        context.compress(&quot;c:\\file&quot;, &quot;d:\\file.zip&quot;);
        context.uncompress(&quot;c:\\file.zip&quot;, &quot;d:\\file&quot;);
        System.out.println(&quot;========切换算法========&quot;);
        context = new CompressContext(new GzipStrategy());
        context.compress(&quot;c:\\file&quot;, &quot;d:\\file.gzip&quot;);
        context.uncompress(&quot;c:\\file.gzip&quot;, &quot;d:\\file&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的策略模式的应用示例是不是很简单，类似应用也有很多，比如要对接第三方支付，不同的支付平台有不同的支付API，这个API操作都可以抽象成策略接口，客户端发起特定平台的支付接口时，我们只需调用具体的支付策略类执行，并且每个支付策略类相互独立，可替换。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;适用场景&lt;/h3&gt;
&lt;p&gt;本节最后简单总结下策略模式的适用场景：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果一个对象有很多的行为，它们的实现目的相同，而这些行为使用了多重的条件选择语句来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;当一个系统需要动态地切换算法，会选择一种算法去执行。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端类不需要知道具体算法的实现细节，只要调用并完成所需要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;lambda-与-策略模式&quot;&gt;Lambda 与 策略模式&lt;/h2&gt;
&lt;p&gt;JDK 8 之后，利用Lambda可以提供策略模式更加精简的实现，如果策略接口是一个函数接口，那么不需要声明新的类来实现不同策略，直接通过传递Lambda就可实现，并且更加简洁，具体使用方式参见下方代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Context 对象
 */
public class Validator {
    private final ValidationStrategy strategy;

    public Validator(ValidationStrategy v) {
        this.strategy = v;
    }

    public boolean validate(String s) {
        return strategy.execute(s);
    }

}

/**
 * 策略接口
 */
@FunctionalInterface
public interface ValidationStrategy {
    boolean execute(String s);
}

numericValidator = new Validator((String s) -&amp;gt; s.matches(&quot;[a-z]+&quot;));
b1 = numericValidator.validate(&quot;aaaa&quot;); // true
lowerCaseValidator = new Validator((String s) -&amp;gt; s.matches(&quot;\\d+&quot;));
b2 = lowerCaseValidator.validate(&quot;bbbb&quot;); // false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合 Lambda 的策略模式更适合用于处理简单算法操作的场景，如果算法实现复杂过于冗长复杂，还是建议拆分成单个类进行实现。&lt;/p&gt;
&lt;h2 id=&quot;策略模式的注意点&quot;&gt;策略模式的注意点&lt;/h2&gt;
&lt;p&gt;策略模式使用起来虽然简单，但它的灵活性在许多项目都能见到其身影，在使用时也有需要注意的地方，下面我们就来看下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;策略模式中每个算法都是完整，不可拆分的原子业务，并且多个算法必须是可以相互替换,，而用哪个算法由外部调用者决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当如果具体策略类超过4个，需要使用混合模式减少类膨胀和对外暴露的问题，通过其他模式修正：工厂方法模式，代理模式，享元模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;策略模式的优缺点&quot;&gt;策略模式的优缺点&lt;/h2&gt;
&lt;p&gt;一个设计模式的引入必存在它合理的地方和不足，最后我们再说说下策略模式的优缺点。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用策略模式，可以在不修改原有系统的基础上更换算法或行为，可以灵活地增加新的算法或行为，提供了系统的扩展性&lt;/li&gt;
&lt;li&gt;策略模式提供了对一类算法进行管理维护。&lt;/li&gt;
&lt;li&gt;使用策略模式可以避免使用多重条件判断，由外部模块决定所要执行的策略类。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;客户端必须知道所有的策略类，并自行决定使用哪一个策略类。&lt;/li&gt;
&lt;li&gt;会产生很多策略类，使得类的项目增多。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;到这里，本文对策略模式的学习就此结束，当然关于策略模式的内容远不止这些，配合其他模式还有用法，感兴趣了的同学可以参考文末提供的资料链接进一步深入学习。也欢迎扫码关注微信公众号：「闻人的技术博客」，定期分享Java技术干货，共同进步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664672/201910/664672-20191028074545418-1013333496.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Sun, 27 Oct 2019 23:46:00 +0000</pubDate>
<dc:creator>闻人的技术博客</dc:creator>
<og:description>前言 最近段时间，接到一个需求：开发一个聚合支付服务，对其他内部项目提供统一的接口来实现不同支付平台的支付能力发起，比如支付宝，微信，银联等。为了处理相似的支付操作而各平台具体实现不同的情况，要让各个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/one12138/p/11750208.html</dc:identifier>
</item>
<item>
<title>sql查询入门 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11509385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11509385.html</guid>
<description>&lt;p&gt;SQL语言是一门相对来说简单易学却又功能强大的语言，它能让你快速上手并很快就能写出比较复杂的查询语句。但是对于大多数开发者来说，使用SQL语句查询数据库的时候，如果没有一个抽象的过程和一个合理的步骤，很可能会在写一些特定的SQL查询语句来解决特定问题的时候被卡住。&lt;/p&gt;
&lt;p&gt;这里主要讲述下SQL查询的一些基本理论，以及写查询语句的抽象思路。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SQL查询的简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SQL语言起源于1970年E.J.Codd发表的关系数据库理论，所以可以说SQL是为关系数据库服务的。而对于SQL查询，是指从数据库中取得数据的子集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842514/201909/842514-20190911215407269-1120220080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子集指的就是从一个或多个表中提取特定的字段和字段对应的记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/842514/201909/842514-20190911215512127-1134625322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以说，SQL中无论多复杂的查询，都可以抽象成如上面的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;精确查询的前置条件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要正确取得所需要的数据子集，除了需要思路正确并将思路正确转变为对应SQL查询语句之外，还有很重要的一点是需要数据库有着良好的设计。这里的良好设计指的是数据库的设计符合业务逻辑。如果数据库设计得很烂，那数据查询起来就很困难，要达到精确查询也就变得困难起来。&lt;/p&gt;
&lt;p&gt;举个简单的例子，A表中有a字段，B表中也有a字段，在业务处理的过程中，A表中的a字段可能和B表中的a字段发生了分歧，这时候是要取A表中的a字段的值还是取B表中的a字段的值，也就成了一个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;两种方式，同一种结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQL中，取得相同的数据子集可以用不同的思路或不同的SQL语句，因为SQL源于关系数据库理论，而关系数据库理论又源于数学，思考如何构建查询语句时，都可以抽象为两种方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系代数法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关系代数法的思路是对数据库进行分步操作，最后取得想要的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;WHERE&lt;/span&gt; AGE &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关系代数的思路描述上面语句为：对USERS表进行投影（选择列）操作，然后对结果进行筛选，只取得年龄大于20的结果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系演算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相比较关系代数法而言，关系演算法更多关注的是取得数据所满足的条件。比如上面SQL用关系演算法可以被描述为：我想得到所有年龄大于20的员工的姓名，部门和年龄。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两种算法的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于简单的查询语句来说，上面两种方法都不需要，因为可能用脚就可以想出来了，只是问题在于很多情况下查询语句会非常复杂，这时候就用两种算法去区分描述的优势才会表现出来。&lt;/p&gt;
&lt;p&gt;对于关系演算法来说，更多关注的是所取出信息所满足的条件；而对于关系代数法来说，更多关注的是如何取出特定的信息。简单地说，关系演算法表示的是【what】，而关系代数法表达的是【how】。SQL语句中所体现的思路，有些时候是关系代数法，有些时候是关系演算法，还有些会是两种思路的混合。&lt;/p&gt;
&lt;p&gt;对于某些查询情况，关系代数法可能会更简单；而对于另外一些情况，关系演算法则会显得更直接；还有一些情况则是需要混合两种思路。所以这两种思维方式在写SQL查询时都是必须要掌握的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单表查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单表查询是所有查询中的中间状态，即使是多个表的复杂查询，在进行各种连接后最终都能够被抽象成单表查询。所以先从单表查询开始。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择列的子集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上面数据子集的说法，选择列是通过在SELECT语句后面添加所要选择的列名实现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; USERS;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选择行的子集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择行的子集，是在SQL语句的WHERE子句后面加上相应的限制条件。当WHERE子句后面的表达式为【真/true】时，也就是满足所谓的【条件】时，返回相应的行的子集。&lt;/p&gt;
&lt;p&gt;WHERE子句后面的运算符分为两类，分别是比较运算符和逻辑运算符。&lt;/p&gt;
&lt;p&gt;比较运算符是将两个相同类型的数据进行比较，进而返回布尔类型（boolean）的运算符。在SQL中，比较运算符一共有六种，分别是等于（=）、小于（&amp;lt;）、小于或等于（&amp;lt;=）、大于或等于（&amp;gt;=）以及不等于（&amp;lt;&amp;gt;）。其中，小于或等于和大于或等于可以看成是比较运算符和逻辑运算符的结合体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;WHERE&lt;/span&gt; AGE &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑运算符是将两个布尔类型进行连接，并返回一个新的布尔类型的运算符。在SQL中，逻辑运算符通常是将比较运算符返回的布尔类型相连接以最终确定WHERE子句后面满足条件的真假。逻辑运算符一共有三种，分别是与（AND）、或（OR）和非（NOT）。其中，非运算符可以看作是特殊的比较运算符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;WHERE&lt;/span&gt; AGE &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; AGE &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;60&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，这几种运算符是有优先级的，优先级由大到小排列，是比较运算符&amp;gt;于逻辑运算符（AND）&amp;gt;或逻辑运算符（OR）。当然，也可以通过括号运算符来改变优先级，括号运算符的优先级最高。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1+1≠2的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假定USERS表中存在一个SEX（性别）字段，我们一般可能会认为，这个世界不是男人就是女人，因此SEX字段就只能有male和female两种值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;WHERE&lt;/span&gt; SEX &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; SEX &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是当我们执行上面的SQL时发现获取的并不是USERS表中的所有记录。这是因为，在实际的场景中，有一些用户在录入表单的时候可能不会填写SEX字段，因此SEX字段还会有第三个值：NULL。因此我们需要加入SQL语句中提供的NULL判断条件来获取表中的所有记录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;WHERE&lt;/span&gt; SEX &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; SEX &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; SEX &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，实际场景中SEX（性别）一般会被设计为布尔类型，并提供默认值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面的那些方法都是关于取出数据，而下面是关于将取出的子集进行排序。SQL通过ORDER BY子句来进行排序，ORDER BY子句必须是SQL查询语句的最后一个子句，也就是说，在ORDER BY子句之后，不允许再添加任何的子句了。&lt;/p&gt;
&lt;p&gt;ORDER BY子句分为升序（ASC）和降序（DESC）。如果不指定升序或者降序，则默认为升序（由小到大），而ORDER BY是根据排序依据的数据类型来决定的排列的先后顺序的，分别有3种数据类型可以进行排序：字符、数字和时间日期。其中，字符按照字母表进行排序，数字根据数字大小排序，时间日期根据时间的先后进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; AGE &lt;span&gt;DESC&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的语句即按AGE（年龄）对USERS表中的记录进行降序排序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚合函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;聚合的意思就是按照一定的条件进行分组，SQL通过GROUP BY子句来进行分组，通过分组并配合聚合函数来达到聚合统计的目的。另外还提供有HAVING子句与GROUP BY子句联合使用，作用是分组后对数据的筛选/过滤，优先级低于WHERE子句。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; AREA, &lt;span&gt;AVG&lt;/span&gt;(AGE) &lt;span&gt;FROM&lt;/span&gt; USERS &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; AREA &lt;span&gt;HAVING&lt;/span&gt; &lt;span&gt;AVG&lt;/span&gt;(AGE) &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的语句即按AREA（地区）对USERS表中的记录求平均AGE（年龄），且平均年龄大于18岁，简单描述，就是求USERS表中平均年龄大于18岁的地区。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多表连接查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在关系数据库中，一个查询往往会涉及多个表，因为很少有数据库只有一个表，而如果大多数查询只涉及到一个表的话，那么那个表也往往低于第三范式，存在大量冗余和异常。因此，连接(JOIN)就是一种把多个表连接成一个表的重要手段。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;笛卡尔积&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;笛卡尔积在SQL中的实现方式即是交叉连接(CROSS JOIN)。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合。在实际应用中，笛卡尔积本身大多没有什么实际用处，只有在两个表连接时加上限制条件，才会有实际意义。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果分步骤理解的话，内连接可以看做是先对两个表进行了交叉连接后，再通过加上限制条件（SQL中通过关键字ON）剔除不符合条件的行的子集，得到的结果就是内连接了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; B &lt;span&gt;ON&lt;/span&gt; A.ID &lt;span&gt;=&lt;/span&gt; B.ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;外连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;外连接是以一个表作为主体，通过限制条件（关键字ON）来进行连接。&lt;/p&gt;
&lt;p&gt;左外连接（LEFT OUTER JOIN）是将左表作为主体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; B &lt;span&gt;ON&lt;/span&gt; A.ID &lt;span&gt;=&lt;/span&gt; B.ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右外连接（RIGHT OUTER JOIN）是将右表作为主体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A &lt;span&gt;RIGHT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; B &lt;span&gt;ON&lt;/span&gt; A.ID &lt;span&gt;=&lt;/span&gt; B.ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全外连接（FULL OUTER JOIN）是将左表和右表每行都至少输出一次，可以看作是左外连接和右外连接的结合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A &lt;span&gt;FULL&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; B &lt;span&gt;ON&lt;/span&gt; A.ID &lt;span&gt;=&lt;/span&gt; B.ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的语句可以看出，使用外连接编写SQL时可以省略OUTER关键字。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果说内连接是取两个表之间的交集，那么自连接也可以这么理解（如果有WHERE，没有WHERE的话则是取的两个表所有记录的完整笛卡尔积）。通常理解上是，自连接是一种特殊的内连接，不同在于内连接是使用ON关键字做限制条件，自连接则是通过WHETE子句来限制记录的获取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A, B &lt;span&gt;WHERE&lt;/span&gt; A.ID &lt;span&gt;=&lt;/span&gt; B.ID;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;交叉连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;交叉连接和没有WHERE条件限制的自连接获取的记录结果是一样的，它们都返回两个表所有记录的完整笛卡尔积。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; A &lt;span&gt;CROSS&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; B;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;多表连接查询的总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面说的连接都是两个表进行连接，而多个表连接实际上可以看成是对N个表进行N-1次双表连接；多个表连接查询之后也可以看作是一个整体，即看成对一个单表进行查询操作。这样分析的话，会让复杂的问题简单化，再困难的问题也能迎刃而解。&lt;/p&gt;

&lt;p&gt;&quot;假如人生是一场未知目的地的旅行，我们只是一味地狂奔，却忘记了旅行的意义。&quot;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Oct 2019 23:41:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>SQL语言是一门相对来说简单易学却又功能强大的语言，它能让你快速上手并很快就能写出比较复杂的查询语句。但是对于大多数开发者来说，使用SQL语句查询数据库的时候，如果没有一个抽象的过程和一个合理的步骤，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11509385.html</dc:identifier>
</item>
<item>
<title>AOP框架Dora.Interception 3.0 [5]: 基于策略的拦截器注册方式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-3-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-3-05.html</guid>
<description>&lt;p&gt;注册拦截器旨在解决如何将拦截器应用到目标方法的问题。在我看来，针对拦截器的注册应该是明确而精准的，也就是我们提供的注册方式应该让拦截器准确地应用到期望的目标方法上，不能多也不能少。如果注册的方式过于模糊，很容易将拦截器应用到非目标方法上。按照这个原则，一些AOP框架提供的针对类型命名空间、类型或者成员名称前（后）缀的拦截器映射策略其实都是不严谨的。Dora.Interception只提供两种严谨的拦截器注册方式，一种前面介绍的&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-04.html&quot;&gt;针对特性标注&lt;/a&gt;的方式，另一种就是本篇介绍的针对策略的方式。&lt;/p&gt;

&lt;p&gt;拦截策略表达的是：&lt;strong&gt;将一个提供拦截器的IInterceptorProvider对象应用到某个目标类型的某一个或者多个方法或者属性成员上&lt;/strong&gt;。如下所示的是在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-01.html&quot;&gt;编程体验&lt;/a&gt;》中定义的拦截策略，它表达的意图是：将CacheReturnValueAttribute应用到SystemClock类型的GetCurrentTime方法上，并且将Order属性设置为1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
            .UseInterceptableServiceProvider(configure: Configure)
                .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
                .Build()
                .Run();

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(InterceptionBuilder interceptionBuilder)
        {
            interceptionBuilder.AddPolicy(policyBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; policyBuilder
                .For&lt;/span&gt;&amp;lt;CacheReturnValueAttribute&amp;gt;(order: &lt;span&gt;1&lt;/span&gt;, cache =&amp;gt;&lt;span&gt; cache
                    .To&lt;/span&gt;&amp;lt;SystemClock&amp;gt;(target =&amp;gt;&lt;span&gt; target
                        .IncludeMethod(clock &lt;/span&gt;=&amp;gt; clock.GetCurrentTime(&lt;span&gt;default&lt;/span&gt;&lt;span&gt;)))));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的代码片段可以看出，拦截策略是通过调用InterceptionBuilder 的&lt;strong&gt;AddPolicy&lt;/strong&gt;扩展方法注册的。如下面的代码片段所示，该方法具有一个&lt;strong&gt;Action&amp;lt;IInterceptionPolicyBuilder&amp;gt;&lt;/strong&gt;类型的参数，具体的拦截策略最终是利用IInterceptionPolicyBuilder对象来定义的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptionBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InterceptionBuilder AddPolicy(&lt;span&gt;this&lt;/span&gt; InterceptionBuilder builder, Action&amp;lt;IInterceptionPolicyBuilder&amp;gt;&lt;span&gt; configure);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Dora.Interception最终利用InterceptionPolicy对象来表示拦截策略，如下面的代码片段所示，IInterceptionPolicyBuilder的Build方法最终会生成该对象。具体针对拦截策略的定义体现在针对&lt;strong&gt;For&amp;lt;TInterceptorProvider&amp;gt;&lt;/strong&gt;方法的调用上。拦截策略是以提供拦截器的IInterceptorProvider对象来基础，For&amp;lt;TInterceptorProvider&amp;gt;方法直接利用泛型参数来提供具体的IInterceptorProvider类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptionPolicyBuilder
{
    IServiceProvider ServiceProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    InterceptionPolicy Build();
    IInterceptionPolicyBuilder For&lt;/span&gt;&amp;lt;TInterceptorProvider&amp;gt;(&lt;span&gt;int&lt;/span&gt; order, Action&amp;lt;IInterceptorProviderPolicyBuilder&amp;gt; configureTargets, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] arguments) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TInterceptorProvider: IInterceptorProvider;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For&amp;lt;TInterceptorProvider&amp;gt;方法的Order属性表示提供拦截器在最终拦截器管道的位置，最终的arguments参数用来提供创建拦截器对象时所需的参数列表。如果构造函数的所有参数都可以利用依赖注入容器（对应于IInterceptionPolicyBuilder的ServiceProvider属性）来提供，这个参数是可以缺省的。For&amp;lt;TInterceptorProvider&amp;gt;方法的核心是作为第二个参数的Action&lt;strong&gt;&amp;lt;IInterceptorProviderPolicyBuilder&amp;gt;&lt;/strong&gt; 对象，它决定了指定的IInterceptorProvider应该应用到那个类型的哪些成员上。&lt;/p&gt;

&lt;p&gt;IInterceptorProviderPolicyBuilder的&lt;span&gt;To&lt;/span&gt;&lt;strong&gt;&amp;lt;TTarget&amp;gt;&lt;/strong&gt;方法会将当前指定的IInterceptorProvider应用到通过泛型参数表示的目标类型上，至于具体应用到哪些方法或者属性成员上，则由提供的Action&amp;lt;ITargetPolicyBuilder&amp;lt;TTarget&amp;gt;&amp;gt; &lt;span&gt;对象作进一步设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptorProviderPolicyBuilder
{    
    InterceptorProviderPolicy Build();
    IInterceptorProviderPolicyBuilder To&lt;/span&gt;&amp;lt;TTarget&amp;gt;(Action&amp;lt;ITargetPolicyBuilder&amp;lt;TTarget&amp;gt;&amp;gt;&lt;span&gt; configure);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ITargetPolicyBuilder&amp;lt;T&amp;gt;（泛型类型表示IInterceptorProvider应用的目标类型）旨在解决成员选择的问题。我们可以调用&lt;strong&gt;IncludeMethod&lt;/strong&gt;或者&lt;strong&gt;IncludeProperty&amp;lt;TValue&amp;gt;&lt;/strong&gt;显式指定目标方法或者属性。如果我们需要应用到所有可被拦截的方法和属性，可以调用IncludeAllMembers方法，如果需要排除少数几个方法或者属性成员，可以调用&lt;strong&gt;ExcludeMethod&lt;/strong&gt;或者&lt;strong&gt;ExcludeMethod&amp;lt;TValue&amp;gt;&lt;/strong&gt;方法。由于这些方法利用&lt;strong&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/strong&gt;而不是名称来选择目标成员，所以它不但能够避免方法名称写错的情况，还能解决方法重载的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ITargetPolicyBuilder&amp;lt;T&amp;gt;&lt;span&gt;
{
    TargetTypePolicy Build();
    ITargetPolicyBuilder&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; IncludeAllMembers();
    ITargetPolicyBuilder&lt;/span&gt;&amp;lt;T&amp;gt; IncludeMethod(Expression&amp;lt;Action&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; methodInvocation);
    ITargetPolicyBuilder&lt;/span&gt;&amp;lt;T&amp;gt; ExcludeMethod(Expression&amp;lt;Action&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; methodInvocation);
    ITargetPolicyBuilder&lt;/span&gt;&amp;lt;T&amp;gt; IncludeProperty&amp;lt;TValue&amp;gt;(Expression&amp;lt;Func&amp;lt;T, TValue&amp;gt;&amp;gt;&lt;span&gt; propertyAccessor, PropertyMethod propertyMethod);
    ITargetPolicyBuilder&lt;/span&gt;&amp;lt;T&amp;gt; ExcludeProperty&amp;lt;TValue&amp;gt;(Expression&amp;lt;Func&amp;lt;T, TValue&amp;gt;&amp;gt;&lt;span&gt; propertyAccessor, PropertyMethod propertyMethod);
}

[Flags]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; PropertyMethod
{
    Get &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    Set &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
    Both &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过上面Dora.Interception提供的API，基本上能够将任何请问的拦截器注册需求定义成相应的拦截策略。如下所示的拦截策略综合使用了上述所有的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    Host.CreateDefaultBuilder()
        .UseInterceptableServiceProvider(configure: Configure)
            .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .Build()
            .Run();

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(InterceptionBuilder buidler) =&amp;gt; buidler.AddPolicy(policy =&amp;gt;&lt;span&gt; policy
        .For&lt;/span&gt;&amp;lt;FooInterceptorAttribute&amp;gt;(&lt;span&gt;1&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
            .To&lt;/span&gt;&amp;lt;FoobarService&amp;gt;(target =&amp;gt;&lt;span&gt; target
                .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set))
            .To&lt;/span&gt;&amp;lt;FoobazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
                .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set)))

        .For&lt;/span&gt;&amp;lt;BarInterceptorAttribute&amp;gt;(&lt;span&gt;2&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
            .To&lt;/span&gt;&amp;lt;FoobarService&amp;gt;(target =&amp;gt;&lt;span&gt; target
                .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set))
            .To&lt;/span&gt;&amp;lt;BarbazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
                .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set)))

        .For&lt;/span&gt;&amp;lt;BazInterceptorAttribute&amp;gt;(&lt;span&gt;3&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
            .To&lt;/span&gt;&amp;lt;FoobazService&amp;gt;(target =&amp;gt;&lt;span&gt; target
                .IncludeAllMembers()
                .ExcludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.NonInterceptableInvokeAsync())
                .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.NonInterceptable, PropertyMethod.Both)
                .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Set)
                .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Get))
            .To&lt;/span&gt;&amp;lt;BarbazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
                .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
                .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set))));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;考虑到拦截策略可能需要动态调整，但是我们又不希望对应用进行重新编译和发布，所以我们可以考虑将拦截策略定义在配置文件中。但是配置文件在表达“目标成员选择”方面会很繁琐，因为如果好标识某个方法，不仅需要指定方法名称，还需要指定所有参数列表类型。我们最终将拦截策略定义成&lt;strong&gt;&lt;span&gt;C#脚本&lt;/span&gt;&lt;/strong&gt;来解决这个问题。如果已经将拦截策略定义在一个C#脚本文件中，我们可以调用InterceptionBuilder如下这个AddPolicy扩展方法重载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptionBuilderExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; InterceptionBuilder AddPolicy(&lt;span&gt;this&lt;/span&gt; InterceptionBuilder builder, &lt;span&gt;string&lt;/span&gt; fileName, Action&amp;lt;PolicyFileBuilder&amp;gt; configure = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了指定作为策略文件的路径之外，我们还可以提供一个&lt;strong&gt;Action&amp;lt;PolicyFileBuilder&amp;gt;&lt;/strong&gt;对象。如下面的代码片段所示，PolicyFileBuilder提供了三个方法，&lt;strong&gt;SetFileProvider&lt;/strong&gt;方法用来设置用来读取拦截策略文件的IFileProvider对象（默认为针对当前目录的PhysicalFileProvider），&lt;strong&gt;AddReferences&lt;/strong&gt;和&lt;strong&gt;AddImports&lt;/strong&gt;方法则用来添加程序集引用和导入命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PolicyFileBuilder
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFileProvider FileProvider {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Assembly[] References {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] Imports {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PolicyFileBuilder SetFileProvider(IFileProvider fileProvider);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PolicyFileBuilder AddReferences(&lt;span&gt;params&lt;/span&gt;&lt;span&gt; Assembly[] references);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PolicyFileBuilder AddImports(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] namespaces);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ReadAllText(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们在定义拦截策略脚本的时候，它可以获取一个用来构建拦截器策略的IInterceptionPolicyBuilder对象的全局变量，该全局变量被命名为&lt;span&gt;&lt;strong&gt;policyBuilder&lt;/strong&gt;。对于上面一节中定义的拦截策略，我们可以采用如下的方式将它脚本话，两者的内容几乎是完全一致的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;policyBuilder
    .For&lt;/span&gt;&amp;lt;FooInterceptorAttribute&amp;gt;(&lt;span&gt;1&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
        .To&lt;/span&gt;&amp;lt;FoobarService&amp;gt;(target =&amp;gt;&lt;span&gt; target
            .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set))
        .To&lt;/span&gt;&amp;lt;FoobazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
            .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set)))

    .For&lt;/span&gt;&amp;lt;BarInterceptorAttribute&amp;gt;(&lt;span&gt;2&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
        .To&lt;/span&gt;&amp;lt;FoobarService&amp;gt;(target =&amp;gt;&lt;span&gt; target
            .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set))
        .To&lt;/span&gt;&amp;lt;BarbazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
            .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Set)))

    .For&lt;/span&gt;&amp;lt;BazInterceptorAttribute&amp;gt;(&lt;span&gt;3&lt;/span&gt;, interceptor =&amp;gt;&lt;span&gt; interceptor
        .To&lt;/span&gt;&amp;lt;FoobazService&amp;gt;(target =&amp;gt;&lt;span&gt; target
            .IncludeAllMembers()
            .ExcludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.NonInterceptableInvokeAsync())
            .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.NonInterceptable, PropertyMethod.Both)
            .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Set)
            .ExcludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Set, PropertyMethod.Get))
        .To&lt;/span&gt;&amp;lt;BarbazService&amp;gt;(targetBuilder =&amp;gt;&lt;span&gt; targetBuilder
            .IncludeMethod(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.InterceptableInvokeAsync())
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Both, PropertyMethod.Both)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt;&lt;span&gt; foobar.Get, PropertyMethod.Get)
            .IncludeProperty(foobar &lt;/span&gt;=&amp;gt; foobar.Set, PropertyMethod.Set)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-01.html&quot;&gt;AOP框架Dora.Interception 3.0 [1]: 编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-2.html&quot;&gt;AOP框架Dora.Interception 3.0 [2]: 实现原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-03.html&quot;&gt;AOP框架Dora.Interception 3.0 [3]: 拦截器设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-04.html&quot;&gt;AOP框架Dora.Interception 3.0 [4]: 基于特性的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-05.html&quot;&gt;AOP框架Dora.Interception 3.0 [5]: 基于策略的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-06.html&quot;&gt;AOP框架Dora.Interception 3.0 [6]: 自定义拦截器注册方式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Oct 2019 23:33:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>注册拦截器旨在解决如何将拦截器应用到目标方法的问题。在我看来，针对拦截器的注册应该是明确而精准的，也就是我们提供的注册方式应该让拦截器准确地应用到期望的目标方法上，不能多也不能少。如果注册的方式过于模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/dora-interception-3-05.html</dc:identifier>
</item>
<item>
<title>深入理解 Java 中的 final 关键字 - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11750053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11750053.html</guid>
<description>&lt;p&gt;final 是Java 中重要关键字之一，可以应用于类、方法以及变量上。这篇文章中将讲解什么是 final 关键字？将变量、方法和类声明为 final 代表了什么？使用 final 的好处是什么？&lt;/p&gt;

&lt;p&gt;final 在 Java 中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作 final，你将不能改变这个引用了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。&lt;/p&gt;

&lt;p&gt;凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为 final 的都叫作 final 变量。final 变量经常和 static 关键字一起使用，作为常量。下面是 final 变量的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final String NAME = &quot;wupx&quot;;
NAME = new String(&quot;wupx&quot;); //invalid compilation error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;final 变量是只读的。&lt;/p&gt;

&lt;p&gt;final 也可以声明方法，Java 里用 final 修饰符去修饰一个方法的唯一正确用途就是表达：这个方法原本是一个虚方法，现在通过 final 来声明这个方法不允许在派生类中进一步被覆写（override）。&lt;/p&gt;
&lt;p&gt;Java 中非私有的成员方法默认都是虚方法，而虚方法就可以在派生类中被覆写。为了保证某个类上的某个虚方法不在派生类中被进一步覆写，就需要使用 final 修饰符来声明，让编译器（例如 javac）与 JVM 共同检查并保证这个限制总是成立。&lt;/p&gt;
&lt;p&gt;下面引用 R 大 在知乎上的回答来打破“用 final 修饰方法可以让对这个方法的调用变快”的流言：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;曾经有一种广为流传的说法是用final修饰方法可以让对这个方法的调用变快。这种说法在现代主流的优化JVM上都是不成立的（例如Oracle JDK / OpenJDK HotSpot VM、IBM J9 VM、Azul Systems Zing VM等）。这是因为：能用final修饰的虚方法，其派生类中必然不可能存在对其覆写的版本，于是可以判定这个虚方法只有一个可能的调用目标；而如果此时把这个final修饰符去掉，这些先进的JVM都可以通过“类层次分析”（Class Hierarchy Analysis，CHA）来发现这个方法在派生类中没有进一步覆写的版本，于是同样可以判定这个虚方法只有一个可能的调用目标。然后两者的优化程度会一模一样，无论是从“不需要通过虚分派而可以直接调用目标”（称为“去虚化”，devirtualization）还是从“便于内联”的角度看，这两种情况都是一样的。&lt;/p&gt;
&lt;p&gt;而如果某个类层次结构中原本某个虚方法就存在多个覆写版本的话，那么本来也不可能对这个虚方法加上final修饰，所以就算这种情况下去虚化变得困难，锅也不能让“因为没用final修饰”来背。&lt;/p&gt;
&lt;p&gt;使用final关键字在现代主流的优化JVM上不会提升性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是 final 方法的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class User{
    public final String getName(){
        return &quot;user：wupx&quot;;
    }
}

class Reader extends User{
    @Override
    public final String getName(){
        return &quot;reader wupx&quot;; //compilation error: overridden method is final
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用 final 来修饰的类叫作 final 类，final类通常功能是完整的，它们不能被继承，Java 中有许多类是 final 的，比如 String, Interger 以及其他包装类。下面是 final 类的实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final class User{

}

class Reader extends User{  //compilation error: cannot inherit from final class

}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;对于 final 变量，编译器和处理器都要遵守两个重排序规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数内，对一个 final 变量的写入，与随后把这个被构造对象的引用赋值给一个变量，这两个操作之间不可重排序&lt;/li&gt;
&lt;li&gt;首次读一个包含 final 变量的对象，与随后首次读这个 final 变量，这两个操作之间不可以重排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上这两个规则也正是针对 final 变量的写与读。写的重排序规则可以保证，在对象引用对任意线程可见之前，对象的 final 变量已经正确初始化了，而普通变量则不具有这个保障；读的重排序规则可以保证，在读一个对象的 final 变量之前，一定会先读这个对象的引用。如果读取到的引用不为空，根据上面的写规则，说明对象的 final 变量一定以及初始化完毕，从而可以读到正确的变量值。&lt;/p&gt;
&lt;p&gt;如果 final 变量的类型是引用型，那么构造函数内，对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。&lt;/p&gt;
&lt;p&gt;实际上这也是为了保证 final 变量在对其他线程可见之前，能够正确的初始化完成。&lt;/p&gt;

&lt;p&gt;下面为使用 final 关键字的一些好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;final 关键字提高了性能，JVM 和 Java 应用都会缓存 final 变量&lt;/li&gt;
&lt;li&gt;final 变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;final 关键字可以用于成员变量、本地变量、方法以及类&lt;/li&gt;
&lt;li&gt;final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就汇报编译错误&lt;/li&gt;
&lt;li&gt;不能够对 final 变量再次赋值&lt;/li&gt;
&lt;li&gt;本地变量必须在声明时赋值&lt;/li&gt;
&lt;li&gt;在匿名类中所有变量都必须是 final 变量&lt;/li&gt;
&lt;li&gt;final 方法不能被重写&lt;/li&gt;
&lt;li&gt;final 类不能被继承&lt;/li&gt;
&lt;li&gt;接口中声明的所有变量本身是 final 的&lt;/li&gt;
&lt;li&gt;final 和 abstract 这两个关键字是反相关的，final 类就不可能是 abstract 的&lt;/li&gt;
&lt;li&gt;没有在声明时初始化 final 变量的称为空白 final 变量(blank final variable)，它们必须在构造器中初始化，或者调用 this() 初始化，不这么做的话，编译器会报错final变量(变量名)需要进行初始化&lt;/li&gt;
&lt;li&gt;按照 Java 代码惯例，final 变量就是常量，而且通常常量名要大写&lt;/li&gt;
&lt;li&gt;对于集合对象声明为 final 指的是引用不能被更改&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;《Java编程思想》&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/66083114&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201910/1356806-20191028002647366-1298714269.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Oct 2019 16:27:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>final 是Java 中重要关键字之一，可以应用于类、方法以及变量上。这篇文章中将讲解什么是 final 关键字？将变量、方法和类声明为 final 代表了什么？使用 final 的好处是什么？ f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11750053.html</dc:identifier>
</item>
<item>
<title>算法 - 二分法查找 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/11749937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/11749937.html</guid>
<description>&lt;h2 id=&quot;什么是二分法查找&quot;&gt;什么是二分法查找&lt;/h2&gt;
&lt;p&gt;二分法查找主要是为了快速查找给定数组内，期待值在数组中的位置（下标）&lt;/p&gt;
&lt;p&gt;二分法查找通过对整个数组取中间值，判断期待值所在的范围并缩小范围，每次查找范围折半，直到范围的边界重合，得出期待值的位置，如果找不到返回null&lt;/p&gt;
&lt;p&gt;二分法有一个先决条件是：数组内元素必须是有序的&lt;/p&gt;
&lt;h2 id=&quot;简单图解&quot;&gt;简单图解&lt;/h2&gt;
&lt;p&gt;给定一个包含1，3，5，7，8，9这一个元素的有序数组，求得期待值7所在的位置，下边用绿块表示指针所在位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201910/1149398-20191027231709204-35452742.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是按照直接遍历的方式，绿块会从数组的第一个下标开始比较，直到7所在的下标得到结果，遍历需要4次，下边演示下二分法的图示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次&lt;/strong&gt;，取值范围为整个数组，取数组长度中间值(0+5)/2取整2作为下标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201910/1149398-20191027231751767-313419952.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;取中间值初始以数组的第一个下标与最后一个下标相加取中间值，如果不为整，舍去小数部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较期待值与下标为2的值大小，发现5&amp;lt;7，7这个值应在中间值的右侧&lt;/p&gt;
&lt;p&gt;缩小查找范围为中间值+1与最大下标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次&lt;/strong&gt;，范围缩小为原数组的一半，下标不变，取中间值(3+5)/2=4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201910/1149398-20191027232104005-1534668259.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下标4对应的值8，大于7，所以向左取范围最小下标3，最大下标4-1=3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次&lt;/strong&gt;，取中间值(3+3)/2=3，下标3上的值恰好与期待值相等，返回下标3&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;虽然看起来只少了一次，原因在数组的长度小，另外就是期待值设置的小，&lt;/p&gt;
&lt;p&gt;再举个长一点的例子，这里有1-100的数组，100个元素，期待值为100&lt;/p&gt;
&lt;p&gt;简单遍历次数最大为元素的个数n次，本例中100次&lt;/p&gt;
&lt;p&gt;使用二分查找只需要log&lt;sub&gt;2&lt;/sub&gt;n次，本例中17次！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二分法查找的java实现&quot;&gt;二分法查找的Java实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package binarysearch;

/**
 * 二分查找：求得期待值在有序数组中的位置
 * @author hellxz
 */
public class MyBinarySearch {

    /**
     * 二分查找算法实现
     * @param orderedArray 有序数组
     * @param expect 期待数值
     * @return 期待值在数组中的下标，如果期待数值不在数组中，返回null
     */
    public static Integer binarySearch(int[] orderedArray, int expect) {
        //low与high构成动态的数组下标范围
        //初始low下标为0，high为数组长度-1
        int low = 0;
        int high = orderedArray.length - 1;

        //当数组范围存在时，有两种情况：最小边界值小于最大边界值 或 两个边界值相等；
        //最小边界值不大于最大边界值是有意义的，表示范围的存在，如果范围不存在了，说明数组中无此元素
        while (low &amp;lt;= high) {
            //取两个边界下标的中间下标与中间值，作为下标时会自动取整
            int middle = (low + high) / 2;
            int middleVal = orderedArray[middle];
            //中间值与期待值相等，说明中间值的下标就是我们要找的期待数的下标
            if (middleVal == expect) {
                return middle;
            }
            //中间值小于期待值，我们需要将最小边界下标移到中间下标的下一位
            //此时，最大边界不变，最小边界变大，范围缩小原来一半
            if (middleVal &amp;lt; expect) {
                low = middle + 1;
            }
            //中间值大于期待值，说明最大边界应小于中间下标
            if (middleVal &amp;gt; expect) {
                high = middle - 1;
            }
        }

        //循环结束未返回下标说明数组中不存在期待元素，返回null
        return null;
    }

    public static void main(String[] args) {
        int[] arr = { 2, 4, 5, 6, 10, 18, 19,22, 25, 70};
        int expectVal = 25;
        System.out.printf(&quot;当前期待的值为%d，其所在的下标为%d&quot;, expectVal, binarySearch(arr, expectVal));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本人不是科班出身，很多知识都在学习中，算法与数据结构系列将不定时更新（学会哪个更哪个😄）&lt;/p&gt;
</description>
<pubDate>Sun, 27 Oct 2019 15:49:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>什么是二分法查找 二分法查找主要是为了快速查找给定数组内，期待值在数组中的位置（下标） 二分法查找通过对整个数组取中间值，判断期待值所在的范围并缩小范围，每次查找范围折半，直到范围的边界重合，得出期待</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/11749937.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第43期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11747934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11747934.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;F eXchange 2020——征文通知&quot; &quot;FSSF在忙什么？2019年第三季度版本&quot; &quot;Miguel强烈推荐使用TensorFlow.NET&quot; &quot;运行在ASP.NET Core 3上的SAFE BookStore&quot; &quot;新的Thoth.Json站点&quot; &quot;Rider 2019.3早期可访问</description>
<pubDate>Sun, 27 Oct 2019 15:00:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'F eXchange 2020——征文通知' 'FSSF在忙什么？2019年第三季度版本' 'Miguel强烈推荐使用TensorFlow.NET' '运行在ASP.NET Core 3上的S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11747934.html</dc:identifier>
</item>
</channel>
</rss>