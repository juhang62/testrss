<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>5 手写Java Stack 核心源码 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10099988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10099988.html</guid>
<description>&lt;p&gt;Stack是Java中常用的数据结构之一，Stack具有&quot;后进先出(LIFO)&quot;的性质。&lt;br/&gt;只能在一端进行插入或者删除，即压栈与出栈&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的实现比较简单，性质也简单。可以用一个数组来实现栈结构。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入栈的时候，只在数组尾部插入&lt;/li&gt;
&lt;li&gt;出栈的时候，只在数组尾部删除**&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们来看一下Stack的用法 ：如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void main(String[] args){

        //新建一个栈
        Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

        //分别向栈中添加不同的元素
        stack.push(&quot;tom&quot;);
        stack.push(&quot;jim&quot;);
        stack.push(&quot;wendy&quot;);
        stack.push(&quot;natasha&quot;);

        //分别弹栈
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;natasha
wendy
jim
tom&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出可以看到，最后入栈的，最先出栈&lt;/p&gt;
&lt;p&gt;下面我们底层用数组也来实现这样一个栈，在数组的尾部插入和删除。&lt;br/&gt;也就是入栈和出栈。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/594516/201812/594516-20181210233810623-1924032077.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class QStack&amp;lt;E&amp;gt; {
    //数组的默认大小为10
    private static final int DEFAULT_INIT_CAPACITY = 10;

    //底层的数组
    private Object[] elements;

    //栈中的个数
    private int size;

    public QStack() {
        this(DEFAULT_INIT_CAPACITY);
    }


    public QStack(int capacity) {
        //capacity条件检查 ，这里我们直接抛出异常
        if (capacity &amp;lt;= 0) {
            throw new IllegalArgumentException(&quot;capacity &amp;lt;= 0&quot;);
        }

        if (capacity &amp;gt; Integer.MAX_VALUE) {
            throw new IllegalArgumentException(&quot;capacity &amp;gt; Integer.MAX_VALUE&quot;);
        }

        //新建一个capacity大小的数组
        elements = new Object[capacity];

        //初始个数为0
        size = 0;
    }

    //栈是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    //返回栈中的元素个数
    public int size() {
        return size;
    }

    //将一个元素压入栈中
    public E push(E e) {
        //如果栈已满，进行扩容
        if (size &amp;gt;= elements.length) {
            grow();
        }

        //扩容完后将元素e压入栈中
        elements[size] = e;

        //别忘了size需要加 1
        size++;

        return e;
    }

    //出栈，就是将数组最后一个元素弹出
    public E pop() {
        //如果栈为空就返回null
        if (isEmpty()) {
            return null;
        }

        //拿到栈的大小
        int len = size();

        //把数组中最后一个元素保存起来
        E e = peek();
        //个数别忘了减1
        size--;

        //将最后一个元素置null
        elements[len - 1] = null;

        //返回e
        return e;
    }

    //返回最后一个元素
    public E peek() {
        int len = size();

        if (len == 0)
            throw new RuntimeException(&quot;stack is empty&quot;);

        return (E) elements[len - 1];
    }

    //扩容
    private void grow() {
        //将之前的数组保存
        int oldCapacity = elements.length;
        Object[] old = elements;

        //新的数组大小为原来数组大小的2倍
        int newCapacity = oldCapacity * 2;
        //再新建一个大小为原来数组2倍的新数组
        elements = new Object[newCapacity];

        //把以前的老的数组中的元素都移动新数组中
        for (int i = 0; i &amp;lt; oldCapacity; i++) {
            elements[i] = old[i];
        }

        //释放以前的内存空间
        old = null;
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上面可知：用数组实现栈结构，主要需要注意以下 2 点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在数组的尾部插入和删除，也就是压栈和弹栈&lt;/li&gt;
&lt;li&gt;由于是用数组实现栈结构，数组满的时候，需要扩容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们写一段测试代码来测试,如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public static void main(String[] args){
        //创建一个栈
        QStack&amp;lt;String&amp;gt; stack = new QStack&amp;lt;&amp;gt;();
        
        //分别向栈中压入4个不同的元素
        stack.push(&quot;tom&quot;);
        stack.push(&quot;jim&quot;);
        stack.push(&quot;wendy&quot;);
        stack.push(&quot;natasha&quot;);

        //分别弹栈
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;natasha
wendy
jim
tom&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 10 Dec 2018 15:37:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>Stack是Java中常用的数据结构之一，Stack具有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10099988.html</dc:identifier>
</item>
<item>
<title>tomcat源码 Connector - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10099897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10099897.html</guid>
<description>&lt;p&gt;Connector容器主要负责解析socket请求，在tomcat中的源码位于org.apache.catalina.connector和org.apache.coyote包路径下；通过上两节的分析，我们知道了Connector是Service的子容器，而Service又是Server的子容器。在server.xml文件中配置，然后在Catalina类中通过Digester完成实例化。在server.xml中默认配置了两种Connector的实现，分别用来处理Http请求和AJP请求。&lt;br/&gt;Connector的实现一共有以下三种：&lt;/p&gt;
&lt;p&gt;1、Http Connector：解析HTTP请求，又分为BIO Http Connector和NIO Http Connector，即阻塞IO Connector和非阻塞IO Connector。本文主要分析NIO Http Connector的实现过程。&lt;/p&gt;
&lt;p&gt;2、AJP：基于AJP协议，用于Tomcat与HTTP服务器通信定制的协议，能提供较高的通信速度和效率。如与Apache服务器集成时，采用这个协议。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;3、APR HTTP Connector：用C实现，通过JNI调用的。主要提升对静态资源（如HTML、图片、CSS、JS等）的访问性能。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;具体要使用哪种Connector可以在server.xml文件中通过protocol属性配置如下：&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Connector &lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;=&quot;8080&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;HTTP/1.1&quot;&lt;/span&gt;&lt;span&gt;
               connectionTimeout&lt;/span&gt;&lt;span&gt;=&quot;20000&quot;&lt;/span&gt;&lt;span&gt;
               redirectPort&lt;/span&gt;&lt;span&gt;=&quot;8443&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下Connector的构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connector(String protocol) {
    setProtocol(protocol);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate protocol handler&lt;/span&gt;
    ProtocolHandler p = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(protocolHandlerClassName);
        p &lt;/span&gt;=&lt;span&gt; (ProtocolHandler) clazz.getConstructor().newInstance();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        log.error(sm.getString(
                &lt;/span&gt;&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;&lt;span&gt;), e);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.protocolHandler =&lt;span&gt; p;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Globals.STRICT_SERVLET_COMPLIANCE) {
        uriCharset &lt;/span&gt;=&lt;span&gt; StandardCharsets.ISO_8859_1;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        uriCharset &lt;/span&gt;=&lt;span&gt; StandardCharsets.UTF_8;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProtocol(String protocol) {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; aprConnector = AprLifecycleListener.isAprAvailable() &amp;amp;&amp;amp;&lt;span&gt;
            AprLifecycleListener.getUseAprConnector();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;HTTP/1.1&quot;.equals(protocol) || protocol == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aprConnector) {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.http11.Http11AprProtocol&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;&lt;span&gt;);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;AJP/1.3&quot;&lt;span&gt;.equals(protocol)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aprConnector) {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.ajp.AjpNioProtocol&quot;&lt;span&gt;);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        setProtocolHandlerClassName(protocol);
    }
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过分析Connector构造器的源码可以知道，每一个Connector对应了一个protocolHandler，一个protocolHandler被设计用来监听服务器某个端口的网络请求，但并不负责处理请求(处理请求由Container组件完成)。下面就以Http11NioProtocol为例分析Http请求的解析过程。&lt;br/&gt;在Connector的startInterval方法中启动了protocolHandler,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Validate settings before starting&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (getPort() &amp;lt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LifecycleException(sm.getString(
                &lt;/span&gt;&quot;coyoteConnector.invalidPort&quot;&lt;span&gt;, Integer.valueOf(getPort())));
    }

    setState(LifecycleState.STARTING);

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        protocolHandler.start();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LifecycleException(
                sm.getString(&lt;/span&gt;&quot;coyoteConnector.protocolHandlerStartFailed&quot;&lt;span&gt;), e);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Http11NioProtocol创建一个org.apache.tomcat.util.net.NioEndpoint实例,然后将监听端口并解析请求的工作全被委托给NioEndpoint实现。tomcat在使用Http11NioProtocol解析HTTP请求时一共设计了三种线程，分别为Acceptor，Poller和Worker。&lt;/p&gt;

&lt;p&gt;Acceptor实现了Runnable接口，根据其命名就知道它是一个接收器，负责接收socket，其接收方法是serverSocket.accept()方式，获得SocketChannel对象，然后封装成tomcat自定义的org.apache.tomcat.util.net.NioChannel。虽然是Nio，但在接收socket时仍然使用传统的方法，使用阻塞方式实现。Acceptor以线程池的方式被创建和管理，在NioEndpoint的startInternal()方法中完成Acceptor的启动，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
        running &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        paused &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        processorCache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                socketProperties.getProcessorCache());
        eventCache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                        socketProperties.getEventCache());
        nioChannels &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                socketProperties.getBufferPool());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create worker collection&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( getExecutor() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
            createExecutor();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最大连接数,默认值为maxConnections = 10000，通过同步器AQS实现。&lt;/span&gt;
&lt;span&gt;        initializeConnectionLatch();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是2个，Math.min(2,Runtime.getRuntime().availableProcessors());和虚拟机处理器个数比较
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start poller threads&lt;/span&gt;
        pollers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller[getPollerThreadCount()];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;pollers.length; i++&lt;span&gt;) {
            pollers[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller();
            Thread pollerThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+&lt;span&gt;i);
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            pollerThread.start();
        }
&lt;/span&gt;
&lt;span&gt;        startAcceptorThreads();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续追踪startAcceptorThreads的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startAcceptorThreads() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动Acceptor线程，默认是1个&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getAcceptorThreadCount();
    acceptors &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Acceptor[count];

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
        acceptors[i] &lt;/span&gt;=&lt;span&gt; createAcceptor();
        String threadName &lt;/span&gt;= getName() + &quot;-Acceptor-&quot; +&lt;span&gt; i;
        acceptors[i].setThreadName(threadName);
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Acceptor线程的核心代码在它的run方法中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Acceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractEndpoint.Acceptor {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; errorDelay = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop until we receive a shutdown command&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (running) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop if endpoint is paused&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (paused &amp;amp;&amp;amp;&lt;span&gt; running) {
                state &lt;/span&gt;=&lt;span&gt; AcceptorState.PAUSED;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;50&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ignore&lt;/span&gt;
&lt;span&gt;                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            state &lt;/span&gt;=&lt;span&gt; AcceptorState.RUNNING;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if we have reached max connections, wait&lt;/span&gt;
&lt;span&gt;                countUpOrAwaitConnection();

                SocketChannel socket &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept the next incoming connection from the server
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收socket请求&lt;/span&gt;
                    socket =&lt;span&gt; serverSock.accept();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We didn't get a socket&lt;/span&gt;
&lt;span&gt;                    countDownConnection();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (running) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Introduce delay if necessary&lt;/span&gt;
                        errorDelay =&lt;span&gt; handleExceptionWithDelay(errorDelay);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-throw&lt;/span&gt;
                        &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ioe;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Successful accept, reset the error delay&lt;/span&gt;
                errorDelay = 0&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure the socket&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (running &amp;amp;&amp;amp; !&lt;span&gt;paused) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setSocketOptions() will hand the socket off to
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; an appropriate processor if successful&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;setSocketOptions(socket)) {
                        closeSocket(socket);
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    closeSocket(socket);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error(sm.getString(&lt;/span&gt;&quot;endpoint.accept.fail&quot;&lt;span&gt;), t);
            }
        }
        state &lt;/span&gt;=&lt;span&gt; AcceptorState.ENDED;
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeSocket(SocketChannel socket) {
        countDownConnection();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.socket().close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)  {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isDebugEnabled()) {
                log.debug(sm.getString(&lt;/span&gt;&quot;endpoint.err.close&quot;&lt;span&gt;), ioe);
            }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isDebugEnabled()) {
                log.debug(sm.getString(&lt;/span&gt;&quot;endpoint.err.close&quot;&lt;span&gt;), ioe);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Acceptor完成了socket请求的接收，然后交给NioEndpoint 进行配置，继续追踪Endpoint的setSocketOptions方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; setSocketOptions(SocketChannel socket) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process the connection&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;disable blocking, APR style, we are gonna be polling it
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为非阻塞&lt;/span&gt;
        socket.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        Socket sock &lt;/span&gt;=&lt;span&gt; socket.socket();
        socketProperties.setProperties(sock);

        NioChannel channel &lt;/span&gt;=&lt;span&gt; nioChannels.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            SocketBufferHandler bufhandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketBufferHandler(
                    socketProperties.getAppReadBufSize(),
                    socketProperties.getAppWriteBufSize(),
                    socketProperties.getDirectBuffer());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSSLEnabled()) {
                channel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SecureNioChannel(socket, bufhandler, selectorPool, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                channel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioChannel(socket, bufhandler);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            channel.setIOChannel(socket);
            channel.reset();
        }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮训pollers数组元素，调用Poller的register方法，完成channel的注册。&lt;/span&gt;
&lt;span&gt;        getPoller0().register(channel);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,t);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable tt) {
            ExceptionUtils.handleThrowable(tt);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Tell to close the socket&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析setSocketOptions的源码可以知道，该方法的主要功能是利用传入的SocketChannel参数生成SecureNioChannel或者NioChannel，然后注册到Poller线程的selector中，可以进一步了解Java nio的相关知识，对这一块内容有更深的理解。&lt;/p&gt;

&lt;p&gt; Poller同样实现了Runnable接口，是NioEndpoint类的内部类。在Endpoint的startInterval方法中创建、配置并启动了Poller线程，见代码清单4。Poller主要职责是不断轮询其selector，检查准备就绪的socket(有数据可读或可写)，实现io的多路复用。其构造其中初始化了selector。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Poller() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.selector =&lt;span&gt; Selector.open();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在分析Acceptor的时候，提到了Acceptor接受到一个socket请求后，调用NioEndpoint的setSocketOptions方法(代码清单6),该方法生成了NioChannel后调用Poller的register方法生成PoolorEvent后加入到Eventqueue，register方法的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; NioChannel socket) {
    socket.setPoller(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    NioSocketWrapper ka &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioSocketWrapper(socket, NioEndpoint.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    socket.setSocketWrapper(ka);
    ka.setPoller(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    ka.setReadTimeout(getSocketProperties().getSoTimeout());
    ka.setWriteTimeout(getSocketProperties().getSoTimeout());
    ka.setKeepAliveLeft(NioEndpoint.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMaxKeepAliveRequests());
    ka.setSecure(isSSLEnabled());
    ka.setReadTimeout(getConnectionTimeout());
    ka.setWriteTimeout(getConnectionTimeout());
    PollerEvent r &lt;/span&gt;=&lt;span&gt; eventCache.pop();
    ka.interestOps(SelectionKey.OP_READ);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this is what OP_REGISTER turns into.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成PoolorEvent并加入到Eventqueue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ( r==&lt;span&gt;null&lt;/span&gt;) r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PollerEvent(socket,ka,OP_REGISTER);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; r.reset(socket,ka,OP_REGISTER);
    addEvent(r);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Poller的核心代码也在其run方法中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop until destroy() is called
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用了destroy()方法后终止此循环&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasEvents = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;close) {
                hasEvents &lt;/span&gt;=&lt;span&gt; events();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wakeupCounter.getAndSet(-1) &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if we are here, means we have other stuff to do
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do a non blocking select
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非阻塞的 select&lt;/span&gt;
                    keyCount =&lt;span&gt; selector.selectNow();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞selector，直到有准备就绪的socket&lt;/span&gt;
                    keyCount =&lt;span&gt; selector.select(selectorTimeout);
                }
                wakeupCounter.set(&lt;/span&gt;0&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法遍历了eventqueue中的所有PollerEvent，然后依次调用PollerEvent的run，将socket注册到selector中。&lt;/span&gt;
&lt;span&gt;                events();
                timeout(&lt;/span&gt;0, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    selector.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
                    log.error(sm.getString(&lt;/span&gt;&quot;endpoint.nio.selectorCloseFail&quot;&lt;span&gt;), ioe);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
            ExceptionUtils.handleThrowable(x);
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,x);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;either we timed out or we woke up, process events first&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( keyCount == 0 ) hasEvents = (hasEvents |&lt;span&gt; events());

        Iterator&lt;/span&gt;&amp;lt;SelectionKey&amp;gt; iterator =&lt;span&gt;
            keyCount &lt;/span&gt;&amp;gt; 0 ? selector.selectedKeys().iterator() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Walk through the collection of ready keys and dispatch
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any active event.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历就绪的socket事件&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (iterator != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; iterator.hasNext()) {
            SelectionKey sk &lt;/span&gt;=&lt;span&gt; iterator.next();
            NioSocketWrapper attachment &lt;/span&gt;=&lt;span&gt; (NioSocketWrapper)sk.attachment();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attachment may be null if another thread has called
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cancelledKey()&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (attachment == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                iterator.remove();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                iterator.remove();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processKey方法对有数据读写的socket进行处理，在分析Worker线程时会分析该方法&lt;/span&gt;
&lt;span&gt;                processKey(sk, attachment);
            }
        }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;process timeouts&lt;/span&gt;
&lt;span&gt;        timeout(keyCount,hasEvents);
    }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;
&lt;span&gt;
    getStopLatch().countDown();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;run方法中调用了events方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; events() {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    PollerEvent pe &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, size = events.size(); i &amp;lt; size &amp;amp;&amp;amp; (pe = events.poll()) != &lt;span&gt;null&lt;/span&gt;; i++&lt;span&gt; ) {
        result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将pollerEvent中的每个socketChannel注册到selector中&lt;/span&gt;
&lt;span&gt;            pe.run();
            pe.reset();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (running &amp;amp;&amp;amp; !&lt;span&gt;paused) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将注册了的pollerEvent加到endPoint.eventCache&lt;/span&gt;
&lt;span&gt;                eventCache.push(pe);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( Throwable x ) {
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,x);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续跟进PollerEvent的run方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interestOps ==&lt;span&gt; OP_REGISTER) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将SocketChannel注册到selector中,注册时间为SelectionKey.OP_READ读事件&lt;/span&gt;
&lt;span&gt;            socket.getIOChannel().register(
                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception x) {
            log.error(sm.getString(&lt;/span&gt;&quot;endpoint.nio.registerFail&quot;&lt;span&gt;), x);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SelectionKey key =&lt;span&gt; socket.getIOChannel().keyFor(socket.getPoller().getSelector());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The key was cancelled (e.g. due to socket closure)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and removed from the selector while it was being
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; processed. Count down the connections at this point
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; since it won't have been counted down when the socket
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; closed.&lt;/span&gt;
&lt;span&gt;                socket.socketWrapper.getEndpoint().countDownConnection();
                ((NioSocketWrapper) socket.socketWrapper).closed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; NioSocketWrapper socketWrapper =&lt;span&gt; (NioSocketWrapper) key.attachment();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketWrapper != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we are registering the key to start with, reset the fairness counter.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; ops = key.interestOps() |&lt;span&gt; interestOps;
                    socketWrapper.interestOps(ops);
                    key.interestOps(ops);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    socket.getPoller().cancelledKey(key);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException ckx) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                socket.getPoller().cancelledKey(key);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ignore) {}
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Worker线程即SocketProcessor是用来处理Socket请求的。SocketProcessor也同样是Endpoint的内部类。在Poller的run方法中(代码清单8)监听到准备就绪的socket时会调用processKey方法进行处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processKey(SelectionKey sk, NioSocketWrapper attachment) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( close ) {
            cancelledKey(sk);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( sk.isValid() &amp;amp;&amp;amp; attachment != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有读写事件就绪时&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (sk.isReadable() ||&lt;span&gt; sk.isWritable() ) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( attachment.getSendfileData() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
                    processSendfile(sk,attachment, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    unreg(sk, attachment, sk.readyOps());
                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; closeSocket = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read goes before write
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket可读时，先处理读事件&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sk.isReadable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processSocket方法进一步处理&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!processSocket(attachment, SocketEvent.OPEN_READ, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                            closeSocket &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写事件&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!closeSocket &amp;amp;&amp;amp;&lt;span&gt; sk.isWritable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processSocket方法进一步处理&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!processSocket(attachment, SocketEvent.OPEN_WRITE, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                            closeSocket &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closeSocket) {
                        cancelledKey(sk);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;invalid key&lt;/span&gt;
&lt;span&gt;            cancelledKey(sk);
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( CancelledKeyException ckx ) {
        cancelledKey(sk);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,t);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续跟踪processSocket方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; processSocket(SocketWrapperBase&amp;lt;S&amp;gt;&lt;span&gt; socketWrapper,
        SocketEvent event, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatch) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketWrapper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试循环利用之前回收的SocketProcessor对象，如果没有可回收利用的则创建新的SocketProcessor对象&lt;/span&gt;
        SocketProcessorBase&amp;lt;S&amp;gt; sc =&lt;span&gt; processorCache.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            sc &lt;/span&gt;=&lt;span&gt; createSocketProcessor(socketWrapper, event);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环利用回收的SocketProcessor对象&lt;/span&gt;
&lt;span&gt;            sc.reset(socketWrapper, event);
        }
        Executor executor &lt;/span&gt;=&lt;span&gt; getExecutor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dispatch &amp;amp;&amp;amp; executor != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SocketProcessor实现了Runneble接口，可以直接传入execute方法进行处理&lt;/span&gt;
&lt;span&gt;            executor.execute(sc);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            sc.run();
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RejectedExecutionException ree) {
        getLog().warn(sm.getString(&lt;/span&gt;&quot;endpoint.executor.fail&quot;&lt;span&gt;, socketWrapper) , ree);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This means we got an OOM or similar creating a thread, or that
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the pool and its queue are full&lt;/span&gt;
        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;&lt;span&gt;), t);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NioEndpoint中createSocketProcessor创建一个SocketProcessor。&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; SocketProcessorBase&amp;lt;NioChannel&amp;gt;&lt;span&gt; createSocketProcessor(
        SocketWrapperBase&lt;/span&gt;&amp;lt;NioChannel&amp;gt;&lt;span&gt; socketWrapper, SocketEvent event) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketProcessor(socketWrapper, event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;Http11NioProtocol是基于Java Nio实现的，创建了Acceptor、Poller和Worker线程实现多路io的复用。三类线程之间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201812/738818-20181210233329983-329796945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Acceptor和Poller之间是生产者消费者模式的关系，Acceptor不断向EventQueue中添加PollerEvent，Pollor轮询检查EventQueue中就绪的PollerEvent，然后发送给Work线程进行处理。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>Connector容器主要负责解析socket请求，在tomcat中的源码位于org.apache.catalina.connector和org.apache.coyote包路径下；通过上两节的分析，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10099897.html</dc:identifier>
</item>
<item>
<title>Linux常见命令（二） - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/10066949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/10066949.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;三，文件系统命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文件系统组织结构&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）一切从根目录“&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;”开始（文件系统层次化标准：&lt;/span&gt;&lt;span&gt;FHS&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204211351327-106989961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;tree&lt;span&gt;安装：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;下载：&lt;/span&gt;yum install  tree&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;tree&lt;span&gt;命令行参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;参数&lt;/span&gt; 作用&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-a 显示所有文件和目录。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-A &lt;span&gt;使用&lt;/span&gt;ASNI&lt;span&gt;绘图字符显示树状图而非以&lt;/span&gt;&lt;span&gt;ASCII&lt;/span&gt;&lt;span&gt;字符组合。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-C 在文件和目录清单加上色彩，便于区分各种类型。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-d 显示目录名称而非内容。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-D 列出文件或目录的更改时间。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-f 在每个文件或目录之前，显示完整的相对路径名称。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-F &lt;span&gt;在执行文件，目录，&lt;/span&gt;Socket&lt;span&gt;，符号连接，管道名称名称，各自加上”&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;”号。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-i 不以阶梯状列出文件或目录名称。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-I 不显示符合范本样式的文件或目录名称。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-n 不在文件和目录清单加上色彩。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-N 直接列出文件和目录名称，包括控制字符。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-p 列出权限标示。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-P 只显示符合范本样式的文件或目录名称。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-q &lt;span&gt;用&lt;/span&gt;”&lt;span&gt;?&lt;/span&gt;&lt;span&gt;”号取代控制字符，列出文件和目录名称。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-s 列出文件或目录大小。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-t 用文件和目录的更改时间排序。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）拓扑：倒置的树形目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）目录作用：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;A./root:  root&lt;span&gt;账号所用文件数据&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;B./bin:   &lt;span&gt;储存常用命令的程序文件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;C./boot:  &lt;span&gt;系统启动文件储存目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;D./dev :   &lt;span&gt;硬件设备文件储存目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;E./etc:    &lt;span&gt;系统配置文件目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;F./home:   &lt;span&gt;普通账户的家目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;G./var:    &lt;span&gt;日志文件目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;H./media:  &lt;span&gt;光驱常用挂载目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;I./mnt:     &lt;span&gt;设备挂载常用目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.rm  &lt;span&gt;命名：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;作用：删除文件或命令&lt;/li&gt;
&lt;li&gt;&lt;span&gt;格式：&lt;/span&gt;rm  -&lt;span&gt;参数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;参数：
&lt;ol&gt;&lt;li&gt;-f   &lt;span&gt;：强制删除不确认&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;-r   &lt;span&gt;：删除目录&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;D.&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;rm  -rf  test  &lt;span&gt;（强制删除目录）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Rm  -f  tem.txt  (&lt;span&gt;删除文件&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.cp  &lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;A.&lt;span&gt;格式：&lt;/span&gt;&lt;span&gt;cp   -&lt;/span&gt;&lt;span&gt;参数  源文件   目标文件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;B.&lt;span&gt;作用：拷贝复制文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;C.&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1.-p  &lt;span&gt;保留原始文件&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.-d  &lt;span&gt;若对象为“连接文件”，则保留改文件的属性&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.-r  &lt;span&gt;拷贝复制目录时使用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4.-i  :&lt;span&gt;若文件已存在则提示是否覆盖&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;5.-a  :&lt;span&gt;相当于  &lt;/span&gt;&lt;span&gt;-pdr&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;D.&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;cp  t1   t2  (&lt;span&gt;在当前目录下拷贝&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;cp  /root/t1      /media (&lt;span&gt;拷贝到其他目录下&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;4.mv &lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;A.&lt;span&gt;作用：移动剪切文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;B.&lt;span&gt;格式：&lt;/span&gt;&lt;span&gt;mv   -&lt;/span&gt;&lt;span&gt;参数   源文件或目录   目标文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;C.&lt;span&gt;区别：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1.&lt;span&gt;重命名：若远类型及目标类型都是文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.&lt;span&gt;移动：源是文件或目录，目标是目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204211416259-1490683489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;例：&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;mkdir  m1&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Touch  k1.txt&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;mv  k1.txt   k2.txt(&lt;span&gt;重命名&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Mv  m1   /media  &lt;span&gt;（移动）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;5.dd &lt;span&gt;命令：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;查看文件，硬盘使用情况（属性）&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204211435418-973104240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;格式：&lt;/span&gt;dd  if=&lt;span&gt;输入数据的文件名   &lt;/span&gt;&lt;span&gt;of=&lt;/span&gt;&lt;span&gt;输出文件名   &lt;/span&gt;&lt;span&gt;count=&lt;/span&gt;&lt;span&gt;数据块个数   &lt;/span&gt;&lt;span&gt;bs=&lt;/span&gt;&lt;span&gt;每个块容量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;作用：按照指定大小制作文件&lt;/li&gt;
&lt;li&gt;例：&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204211455197-1416393776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;/dev/zero:&lt;span&gt;是一个特殊设备文件，代表一个永远输出&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的设备文件，使用它作为输入可以得到全为空的文件。因此可用来创建新的文件和覆盖的方式清除旧文件，该设备文件不占系统储存空间，却又提供无穷无尽的数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;制作光盘镜像文件（&lt;/span&gt;*.iOS&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;dd  if=/dev/cdrom   of=centos_x86_64.iso&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;数据源为光盘&lt;/span&gt;     &lt;span&gt;新文件名&lt;/span&gt;     &lt;span&gt;省略容量，以光盘为准&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;四．文件查看命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;file &lt;span&gt;命令：&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;显示文件类型&lt;/li&gt;
&lt;li&gt;&lt;span&gt;格式：&lt;/span&gt;file  &lt;span&gt;文件名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;例：&lt;/span&gt;file   t1.txt&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;File   tty&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常见文件类型：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Empty&lt;span&gt;：   空文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Directory&lt;span&gt;：  目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Block  special &lt;span&gt;： 块设备（高速设备）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Character  special&lt;span&gt;： 字符设备（低速设备）&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;cat &lt;span&gt;命令：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 10 Dec 2018 15:18:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>三，文件系统命令： （1）一切从根目录“/”开始（文件系统层次化标准：FHS） 下载：yum install tree tree命令行参数： 参数 作用 -a 显示所有文件和目录。 -A 使用ASNI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/10066949.html</dc:identifier>
</item>
<item>
<title>你真的了解回流和重绘吗 - 陈陈jg</title>
<link>http://www.cnblogs.com/chenjg/p/10099886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjg/p/10099886.html</guid>
<description>&lt;p&gt;回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合自己的体会，写了这篇文章，希望可以帮助到大家。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的渲染过程&quot;&gt;浏览器的渲染过程&lt;/h2&gt;
&lt;p&gt;本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn&quot;&gt;MDN&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/97293716a8b6dd2fcfc4ae5364e37f8f55affaa4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396462313465373733663963633f773d36323426683d32383926663d706e6726733d3431303537&quot; alt=&quot;webkit渲染过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面这个图上，我们可以看到，浏览器渲染过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析HTML，生成DOM树，解析CSS，生成CSSOM树&lt;/li&gt;
&lt;li&gt;将DOM树和CSSOM树结合，生成渲染树(Render Tree)&lt;/li&gt;
&lt;li&gt;Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）&lt;/li&gt;
&lt;li&gt;Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素&lt;/li&gt;
&lt;li&gt;Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。&lt;/p&gt;
&lt;h3 id=&quot;生成渲染树&quot;&gt;生成渲染树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231250620-1709964320.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了构建渲染树，浏览器主要完成了以下工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从DOM树的根节点开始遍历每个可见节点。&lt;/li&gt;
&lt;li&gt;对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。&lt;/li&gt;
&lt;li&gt;根据每个可见节点以及其对应的样式，组合生成渲染树。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一些不会渲染输出的节点，比如script、meta、link等。&lt;/li&gt;
&lt;li&gt;一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：渲染树只包含可见的节点&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;回流&quot;&gt;回流&lt;/h3&gt;
&lt;p&gt;前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。&lt;/p&gt;
&lt;p&gt;为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;title&amp;gt;Critial Path: Hello world!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div style=&quot;width: 50%&quot;&amp;gt;
      &amp;lt;div style=&quot;width: 50%&quot;&amp;gt;Hello world!&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231232605-889405024.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重绘&quot;&gt;重绘&lt;/h3&gt;
&lt;p&gt;最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。&lt;/p&gt;
&lt;p&gt;既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。&lt;/p&gt;
&lt;h2 id=&quot;何时发生回流重绘&quot;&gt;何时发生回流重绘&lt;/h2&gt;
&lt;p&gt;我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加或删除可见的DOM元素&lt;/li&gt;
&lt;li&gt;元素的位置发生变化&lt;/li&gt;
&lt;li&gt;元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）&lt;/li&gt;
&lt;li&gt;内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。&lt;/li&gt;
&lt;li&gt;页面一开始渲染的时候（这肯定避免不了）&lt;/li&gt;
&lt;li&gt;浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：回流一定会触发重绘，而重绘不一定会回流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的优化机制&quot;&gt;浏览器的优化机制&lt;/h2&gt;
&lt;p&gt;现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！&lt;strong&gt;当你获取布局信息的操作的时候，会强制队列刷新&lt;/strong&gt;，比如当你访问以下属性或者使用以下方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;offsetTop、offsetLeft、offsetWidth、offsetHeight&lt;/li&gt;
&lt;li&gt;scrollTop、scrollLeft、scrollWidth、scrollHeight&lt;/li&gt;
&lt;li&gt;clientTop、clientLeft、clientWidth、clientHeight&lt;/li&gt;
&lt;li&gt;getComputedStyle()&lt;/li&gt;
&lt;li&gt;getBoundingClientRect&lt;/li&gt;
&lt;li&gt;具体可以访问这个网站：&lt;a href=&quot;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&quot; class=&quot;uri&quot;&gt;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，&lt;strong&gt;最好避免使用上面列出的属性，他们都会刷新渲染队列。&lt;/strong&gt;如果要使用它们，最好将值缓存起来。&lt;/p&gt;
&lt;h2 id=&quot;减少回流和重绘&quot;&gt;减少回流和重绘&lt;/h2&gt;
&lt;p&gt;好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。&lt;/p&gt;
&lt;h3 id=&quot;最小化重绘和重排&quot;&gt;最小化重绘和重排&lt;/h3&gt;
&lt;p&gt;由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。&lt;/p&gt;
&lt;p&gt;因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用cssText&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改CSS的class&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.className += ' active';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;批量修改dom&quot;&gt;批量修改DOM&lt;/h3&gt;
&lt;p&gt;当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使元素脱离文档流&lt;/li&gt;
&lt;li&gt;对其进行多次修改&lt;/li&gt;
&lt;li&gt;将元素带回到文档中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。&lt;/p&gt;
&lt;p&gt;有三种方式可以让DOM脱离文档流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏元素，应用修改，重新显示&lt;/li&gt;
&lt;li&gt;使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。&lt;/li&gt;
&lt;li&gt;将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑我们要执行一段批量插入节点的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i &amp;lt; data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}

const ul = document.getElementById('list');
appendDataToElement(ul, data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。&lt;/p&gt;
&lt;p&gt;我们可以使用这三种方式进行优化:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏元素，应用修改，重新显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个会在展示和隐藏节点的时候，产生两次重绘&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i &amp;lt; data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const ul = document.getElementById('list');
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述那种情况，我写了一个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9DOM.html&quot;&gt;demo&lt;/a&gt;来测试修改前和修改后的性能。然而实验结果不是很理想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;避免触发同步布局事件&quot;&gt;避免触发同步布局事件&lt;/h3&gt;
&lt;p&gt;上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function initP() {
    for (let i = 0; i &amp;lt; paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const width = box.offsetWidth;
function initP() {
    for (let i = 0; i &amp;lt; paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，我也写了个&lt;a&gt;demo&lt;/a&gt;来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。&lt;/p&gt;
&lt;h3 id=&quot;对于复杂动画效果使用绝对定位让其脱离文档流&quot;&gt;对于复杂动画效果,使用绝对定位让其脱离文档流&lt;/h3&gt;
&lt;p&gt;对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231048609-619022494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。&lt;/p&gt;
&lt;h3 id=&quot;css3硬件加速gpu加速&quot;&gt;css3硬件加速（GPU加速）&lt;/h3&gt;
&lt;p&gt;比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。&lt;/p&gt;
&lt;h4 id=&quot;如何使用&quot;&gt;如何使用&lt;/h4&gt;
&lt;p&gt;常见的触发硬件加速的css属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;opacity&lt;/li&gt;
&lt;li&gt;filters&lt;/li&gt;
&lt;li&gt;Will-change&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;效果&quot;&gt;效果&lt;/h4&gt;
&lt;p&gt;我们可以先看个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html&quot;&gt;例子&lt;/a&gt;。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210230959987-1419348644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。&lt;/p&gt;
&lt;h4 id=&quot;重点&quot;&gt;重点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘&lt;/li&gt;
&lt;li&gt;对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;css3硬件加速的坑&quot;&gt;css3硬件加速的坑&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;本文地址在-&amp;gt;&lt;a href=&quot;https://github.com/chenjigeng/blog&quot;&gt;本人博客地址&lt;/a&gt;, 欢迎给个 start 或 follow&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 15:14:00 +0000</pubDate>
<dc:creator>陈陈jg</dc:creator>
<og:description>回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjg/p/10099886.html</dc:identifier>
</item>
<item>
<title>Python时间日期格式化之time与datetime模块总结 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10099766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10099766.html</guid>
<description>&lt;h3&gt;1 引言&lt;/h3&gt;
&lt;h3&gt;2 理论准备&lt;/h3&gt;
&lt;h3&gt;3 time模块&lt;/h3&gt;
&lt;h3&gt;4 timedate模块&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　4.1 date类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.2 time类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.3 datetime类&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　4.4 datedelta类&lt;/h4&gt;

&lt;p&gt;　　在实际开发过程中，我们经常会用到日期或者时间，那么在Python中我们怎么获取时间，以及如何将时间转换为我们需要的格式呢？在之前的开发中，也曾遇到time、datetime等模块下的不同函数，这些函数名又很是相似，几次下来头都昏了，今天来彻底总结梳理一下Python中日期时间获取与格式化。&lt;/p&gt;

&lt;p&gt;         首先必须做一点理论准备，不然待会都不知道为什么会有这些函数。介绍3个概念：&lt;/p&gt;
&lt;p&gt;UTC time Coordinated Universal Time，世界协调时，又称格林尼治天文时间、世界标准时间。与UTC time对应的是各个时区的local time，也就是本地时间，例如我们的北京时间。&lt;/p&gt;
&lt;p&gt;　　epoch time表示时间开始的起点；它是一个特定的时间，不同平台上这个时间点的值不太相同，对于Unix而言，epoch time为 1970-01-01 00:00:00 UTC。&lt;/p&gt;
&lt;p&gt;　　timestamp（时间戳） 也称为Unix时间 或 POSIX时间；它是一种时间表示方式，表示从格林尼治时间1970年1月1日0时0分0秒开始到现在所经过的毫秒数，其值为float类型。 但是有些编程语言的相关方法返回的是秒数，例如我们的天下第一编程语言-Python大法就是这样（请不要反驳我）。所谓的时间戳timestamp就是当前时间与格林尼治时间1970年1月1日0时0分0秒之间过了多少秒。&lt;/p&gt;
&lt;p&gt;　　相应的，日期时间就有三种表示方法：&lt;/p&gt;
&lt;p&gt;　　1）stamptime时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。stamptime表现为一个float类型数据。&lt;/p&gt;
&lt;p&gt;　　2）struct_time时间元组，共有九个元素组。stamptime时间戳和格式化时间字符串之间的转化必须通过struct_time才行，所以struct_time时间元组时3中时间表示的中心。&lt;/p&gt;
&lt;p&gt;　　3）format time 格式化时间，已格式化的结构字符串使时间更具可读性。包括自定义格式和固定格式。&lt;/p&gt;
&lt;p&gt;　　那么，下面要说的就是怎么获取这三个时间，并进行这三个时间之间的转化。先总结一下time模块。&lt;/p&gt;

&lt;p&gt;　　先放两个图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181210223546138-1495614145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　time模块中，几乎所有时间获取与格式转化的函数都在上图中了，只要理清了这幅图的关系，那么time模块就不再是问题。图中，蓝色方块表示那三种时间格式，箭头表示时间的转化。下面，重点来了：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1）获取当前时间的方法只有一个，那就是通过上图中的函数1——time.time()。&lt;/strong&gt;也就是说，要想获取当前时间，只能通过这个方法，而且获取的是时间戳格式的时间。想直接获取当前时间的时间元组格式或格式化字符串？没门，只能老老实实转化。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2）当传入默认参数时，指的是使用当前时间作为参数值。&lt;/strong&gt;图中带黄色底纹的都是设有默认值的参数（虽然默认值为None），函数2、3不传入该参数时，系统会自动获取当前时间的时间戳作为该参数值。而函数5则是系统会自动获取当前时间的时间元组作为该参数值，不是不能直接获取当前时间的时间元组吗？是的，但系统会先获取当前时间的时间戳，然后转化为时间元组。上图中只有向左的箭头所代表的函数才有默认值，就是因为向右才能由时间戳转化得到需要的时间格式。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3） localtime（函数2）和gmtime（函数3）都可以实现将时间戳转化为时间元组，但是，localtime转化的是本地时间，gmtime转为的是世界标准时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4）asctime（函数7）和ctime（函数8）只能转为为%a %b %d %H:%M:%S %Y格式的字符串时间。不传入参数时，用的也是当前时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　5）struct_time元组元素结构：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;下标/索引&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_year&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot;&gt;
&lt;p align=&quot;left&quot;&gt;年份，如 2018&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_mon&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;月份，取值范围为[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_mday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个月中的第几天，取值范围为[1-31]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_hour&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;小时， 取值范围为[0-23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_min&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;分钟，取值范围为[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_sec&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;秒，取值范围为[0, 61]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_wday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个星期中的第几天，取值范围为[0-6]，0表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_yday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的第几天，取值范围为[1, 366]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_isdst&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;是否为夏令时，可取值为：0 , 1 或 -1，默认值为-1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　struct_time属性值的获取方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　可以把它当做一种特殊的有序不可变序列通过 &lt;strong&gt;&lt;em&gt;下标&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;/&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;索引&lt;/em&gt;&lt;/strong&gt; 获取各个元素的值，如t[0]&lt;/li&gt;
&lt;li&gt;　　也可以通过对象名 “t&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;属性名&lt;/em&gt;&lt;/strong&gt;” 的方式来获取各个元素的值，如t.tm_year。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　6）format time结构化表示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;格式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%a&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地（locale）简化星期名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%A&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地完整星期名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%b&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地简化月份名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%B&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地完整月份名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%c&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应的日期和时间表示&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个月中的第几天（01 - 31）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%H&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一天中的第几个小时（24小时制，00 - 23）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%I&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;第几个小时（12小时制，01 - 12）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%j&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的第几天（001 - 366）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%m&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;月份（01 - 12）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%M&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;分钟数（00 - 59）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%p&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地am或者pm的相应符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%S&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;秒（01 - 61）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%U&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%w&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个星期中的第几天（0 - 6，0是星期天）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%W&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;和%U基本相同，不同的是%W以星期一为一个星期的开始。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%x&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应日期&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%y&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;去掉世纪的年份（00 - 99）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%Y&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;完整的年份&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%Z&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;时区的名字（如果不存在为空字符）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%%&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;‘%’字符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　在代码中实践一下上面的内容：&lt;/p&gt;
&lt;p&gt;　　1）time.time()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.time()

&lt;/span&gt;1544278402.1804464
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）time.localtime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.localtime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=22, tm_min=14, tm_sec=58, tm_wday=5, tm_yday=342, tm_isdst=&lt;span&gt;0)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; time.localtime(time.time()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入当前时间&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=22, tm_min=15, tm_sec=33, tm_wday=5, tm_yday=342, tm_isdst=&lt;span&gt;0)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; time.localtime(1544200000.1232) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入其他时间戳&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=0, tm_min=26, tm_sec=40, tm_wday=5, tm_yday=342, tm_isdst=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）time.gctime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.gmtime()

time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=14, tm_min=18, tm_sec=38, tm_wday=5, tm_yday=342, tm_isdst=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）time.mktime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.mktime(time.localtime())

&lt;/span&gt;1544279024.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5）strftime(format, p_tuple=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%y-%m-%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; , time.localtime())

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18-12-08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , time.localtime())&lt;p&gt;'2018-12-08'
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; time.strftime('%Y年%m月%d日 %M时%I分%S秒' , time.localtime())&lt;/p&gt;
&lt;p&gt;'2018年12月08日 34时10分04秒'&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　6）strptime(string, format)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.strptime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年12月08日 34时10分04秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y年%m月%d日 %M时%I分%S秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=10, tm_min=34, tm_sec=4, tm_wday=5, tm_yday=342, tm_isdst=-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7）asctime(p_tuple=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.asctime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数，默认是当前时间&lt;/span&gt;

&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:42:46 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.asctime(time.localtime(1544278402.1804464&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:13:22 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8）ctime(seconds=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.ctime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数&lt;/span&gt;

&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:45:58 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.ctime(1544278402.1804464&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:13:22 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　datetime模块是time模块的进一步封装，对用户更加友好，在时间各属性的获取上回更加方便一些，当然，在效率上会略微低一些。datetime模块的功能主要都几种在datetime、date、time、timedelta、tzinfo五个类中。这五个类功能如下表所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;类名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;date&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;提供日期（年、月、日）的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;time&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;提供时间（时、分、秒）的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;datetime&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;同时提供对日期和时间的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;timedelta&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;两个date、time、datetime实例之间的时间间隔（时间加减运算）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot;&gt;
&lt;p&gt;时区信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.1 date类&lt;/h2&gt;
&lt;p&gt;　　先来说说date类，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.date(year, month, day)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;year, month 和 day都是是必须参数，各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;参数名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;取值范围&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[MINYEAR, MAXYEAR]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;[1, 指定年份的月份中的天数]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　类方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;类方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象所能表示的最大日期：9999-12-31&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象所能表示的最小日志：00001-01-01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.resoluation&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象表示的日期的最小单位：天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.today()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个表示当前本地日期的date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.fromtimestamp(timestamp)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据跟定的时间戳，返回一个date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　对象方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对象方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;年&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;月&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;日&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.replace(year[, month[, day]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;生成并返回一个新的日期对象，原日期对象不变&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.timetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回日期对应的time.struct_time对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.toordinal()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回日期是是自 0001-01-01 开始的第多少天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.weekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回日期是星期几，[0, 6]，0表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isoweekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;返回日期是星期几，[1, 7], 1表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isocalendar()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;返回一个元组，格式为：(year, weekday, isoweekday)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isoformat()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回‘YYYY-MM-DD’格式的日期字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.strftime(format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回指定格式的日期字符串，与time模块的strftime(format, struct_time)功能相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.2 time类&lt;/h2&gt;
&lt;p&gt;　　定义格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.time(hour, [minute[, second, [microsecond[, tzinfo]]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　hour为必须参数，其他为可选参数。各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 1000000]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;tzinfo的子类对象，如timezone类的实例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　类方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;类方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;time类所能表示的最大时间：time(23, 59, 59, 999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;time类所能表示的最小时间：time(0, 0, 0, 0)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.resolution&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;时间的最小单位，即两个不同时间的最小差值：1微秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　对象方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;对象方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;时&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;分&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;微秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回传递给time构造方法的tzinfo对象，如果该参数未给出，则返回None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.replace(hour[, minute[, second[, microsecond[, tzinfo]]]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;生成并返回一个新的时间对象，原时间对象不变&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.isoformat()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个‘HH:MM:SS.%f’格式的时间字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.strftime()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回指定格式的时间字符串，与time模块的strftime(format, struct_time)功能相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.3 datetime类&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　datetime类的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　year, month 和 day是必须要传递的参数， tzinfo可以是None或tzinfo子类的实例。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[MINYEAR, MAXYEAR]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[1, 指定年份的月份中的天数]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 1000000]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tzinfo的子类对象，如timezone类的实例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　如果一个参数超出了这些范围，会引起ValueError异常。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　类方法和属性:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;类方法/&lt;/strong&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.today()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回一个表示当前本期日期时间的datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.now([tz])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回指定时区日期时间的datetime对象，如果不指定tz参数则结果同上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.utcnow()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回当前utc日期时间的datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.fromtimestamp(timestamp[, tz])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;根据指定的时间戳创建一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.utcfromtimestamp(timestamp)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;根据指定的时间戳创建一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.combine(date, time)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;把指定的date和time对象整合成一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.strptime(date_str, format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;将时间字符串转换为datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;对象方法和属性:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;对象方法/&lt;/strong&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.year, dt.month, dt.day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;年、月、日&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.hour, dt.minute, dt.second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;时、分、秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.microsecond, dt.tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;微秒、时区信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.date()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.time()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的time对象， tzinfo 为None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.timetz()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的time对象，tzinfo与datetime对象的tzinfo相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;12&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;生成并返回一个新的datetime对象，如果所有参数都没有指定，则返回一个与原datetime对象相同的对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.timetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回datetime对象对应的tuple（不包括tzinfo）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.utctimetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回datetime对象对应的utc时间的tuple（不包括tzinfo）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.toordinal()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.weekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.isocalendar()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date独享&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.isoformat([sep])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回一个‘%Y-%m-%d&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.ctime()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;等价于time模块的time.ctime(time.mktime(d.timetuple()))&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.strftime(format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回指定格式的时间字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　上面是date、time、datetime三个类的方法和属性，关于这三个类，使用方法上基本与time模块差不多，看方法名基本就一目了然，实在忘记，直接查表就好，本文不在过多介绍。&lt;/p&gt;
&lt;h2&gt;4.4 timedelta类&lt;/h2&gt;
&lt;p&gt;　　timedelta可以方便实现日期（date实例、time实例、datetime实例）之间的加减运算。&lt;/p&gt;
&lt;p&gt;　　datetime.timedelta类的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, hours=0, weeks=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　所有参数都是默认参数，因此都是可选参数。参数的值可以是整数或浮点数，也可以是正数或负数。内部值存储days、seconds 和 microseconds，其他所有参数都将被转换成这3个单位：
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1毫秒转换为1000微秒&lt;/li&gt;
&lt;li&gt;1分钟转换为60秒&lt;/li&gt;
&lt;li&gt;1小时转换为3600秒&lt;/li&gt;
&lt;li&gt;1周转换为7天&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　然后对这3个值进行标准化，使得它们的表示是唯一的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;microseconds : [0, 999999]&lt;/li&gt;
&lt;li&gt;seconds : [0, 86399]&lt;/li&gt;
&lt;li&gt;days : [-999999999, 999999999]&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　类属性:&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;类属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;timedelta(-999999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.resolution&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;timedelta(microseconds=1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　实例方法和属性:&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;实例方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.days&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;天 [-999999999, 999999999]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.seconds&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;秒 [0, 86399]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.microseconds&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;微秒 [0, 999999]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.total_seconds()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;时间差中包含的总秒数，等价于: td / timedelta(seconds=1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　对于Python中时间、日期模块的应用主要集中在time模块和datetime模块中，其中涉及到的方法和属性有些多容易混淆，可以以time模块为出发点，只要理清time模块中3种时间格式之间的关系，就容易记忆了。&lt;/p&gt;
&lt;p&gt;　　参考资料：&lt;/p&gt;
&lt;p&gt;　　https://blog.csdn.net/p9bl5bxp/article/details/54945920&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>在实际开发过程中，我们经常会用到日期或者时间，那么在Python中我们怎么获取时间，以及如何将时间装换位我们需要的格式呢？在之前的开发中，也曾遇到time、datetime等模块下的不同函数，这些函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10099766.html</dc:identifier>
</item>
<item>
<title>Python面向对象基础：编码细节和注意事项 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10099735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10099735.html</guid>
<description>&lt;p&gt;在前面，我用了3篇文章解释python的面向对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9965110.html&quot;&gt;面向对象：从代码复用开始&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10091181.html&quot;&gt;面向对象：设置对象属性&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10094021.html&quot;&gt;类和对象的名称空间&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇是第4篇，用一个完整的示例来解释面向对象的一些细节。&lt;/p&gt;
&lt;p&gt;例子的模型是父类Employe和子类Manager，从类的定义开始，一步步完善直到类变得完整。&lt;/p&gt;

&lt;h2 id=&quot;定义person类&quot;&gt;定义Person类&lt;/h2&gt;
&lt;p&gt;现在，假设Employe类有3个属性：名字name、职称job和月薪水pay。&lt;/p&gt;
&lt;p&gt;定义这个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为&lt;code&gt;__init__()&lt;/code&gt;的job参数提供了默认值：None，表示这个员工目前没有职称。对于没有职称的人，pay当然也应该是0。这样创建Employe对象的时候，可以只给参数name。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    longshuai = Employe(&quot;Ma Longshuai&quot;)
    xiaofang = Employe(&quot;Gao Xiaofang&quot;, job=&quot;accountant&quot;, pay=15000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的if判断表示这个py文件如果当作可执行程序而不是模块，则执行if内的语句，如果是以模块的方式导入这个文件，则if内的语句不执行。这种用法在测试模块代码的时候非常方便。&lt;/p&gt;
&lt;p&gt;运行该py文件，得到结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;__main__.Employe object at 0x01321690&amp;gt;
&amp;lt;__main__.Employe object at 0x01321610&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;添加方法&quot;&gt;添加方法&lt;/h2&gt;
&lt;p&gt;每个Employe对象的name属性由姓、名组成，中间空格分隔，现在想取出每个对象的名。对于普通的&lt;code&gt;姓 名&lt;/code&gt;字符串，可以使用字符串工具的split()函数来处理。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Ma Longshuai&quot;
&amp;gt;&amp;gt;&amp;gt; name.split()[-1]
'Longshuai'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是可以在longshuai和xiaofang这两个Employe对象上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai.name.split()[-1])
print(xiaofang.name.split()[-1])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Longshuai
Xiaofang&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之类似的，如果想要为员工按10%加薪水，可以在每个Employe对象上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xiaofang.pay *= 1.1
print(xiaofang.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是截取name的名部分，还是加薪水的操作，都是Employe共用的，每个员工都可以这样来操作。所以，更合理的方式是将它们定义为类的方法，以便后续的代码复用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

if __name__ == &quot;__main__&quot;:
    longshuai = Employe(&quot;Ma Longshuai&quot;)
    xiaofang = Employe(&quot;Gao Xiaofang&quot;, job=&quot;accountant&quot;, pay=15000)
    
    print(longshuai.lastName())
    print(xiaofang.lastName())
    xiaofang.giveRaise(0.10)
    print(xiaofang.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的giveRaise()方法中使用了int()进行类型转换，因为整数乘以一个小数，返回结果会是一个小数(例如&lt;code&gt;15000 * 0.1 = 1500.0&lt;/code&gt;)。这里我们不想要这个小数，所以使用int()转换成整数。&lt;/p&gt;

&lt;h2 id=&quot;定义子类并重写父类方法&quot;&gt;定义子类并重写父类方法&lt;/h2&gt;
&lt;p&gt;现在定义Employe的子类Manager。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Manager的薪水计算方式是在原有薪水上再加一个奖金白分别，所以要重写父类的giveRaise()方法。有两种方式可以重写：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完全否定父类方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在父类方法的基础上进行扩展&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽然有了父类的方法，拷贝修改很方便，但第一种重写方式仍然是不合理的。合理的方式是采用第二种。&lt;/p&gt;
&lt;p&gt;下面是第一种方式重写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def giveRaise(self, percent, bonus=0.10):
        self.pay = int(self.pay * (1 + percent + bonus))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种重写方式逻辑很简单，但是完全否定了父类的giveRaise()方法，完完全全地重新定义了自己的方法。这种方式不合理，因为如果修改了Employe中的giveRaise()计算方法，Manager中的giveRaise()方法也要修改。&lt;/p&gt;
&lt;p&gt;下面是第二种在父类方法基础上扩展，这是合理的重写方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def giveRaise(self, percent, bonus=0.10):
        Employe.giveRaise(self, percent + bonus)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种方式是在自己的giveRaise()方法中调用父类的giveRaise()方法。这样的的好处是在需要修改薪水计算方式时，要么只需修改Employe中的，要么只需修改Manager中的，不会同时修改多个。&lt;/p&gt;
&lt;p&gt;另外注意，上面是通过硬编码的类名Employe来调用父类方法的，python中没有其它方法，只能通过这种硬编码的方式。但好在并没有任何影响。因为调用时明确指定了第一个参数为self，而self代表的是对象自身，所以逻辑上仍然是对本对象的属性self.pay进行修改。&lt;/p&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    wugui = Manager(&quot;Wu Xiaogui&quot;, &quot;mgr&quot;, 15000)
    wugui.giveRaise(0.1, 0.1)
    print(wugui.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般在重写方法的时候，只要允许，就应该选择在父类基础上进行扩展重写。如果真的需要定义完全不同的方法，可以不要重写，而是在子类中定义新的方法。当然，如果真的有需求要重写，且又要否定父类方法，那也没办法，不过这种情况基本上都是因为在类的设计上不合理。&lt;/p&gt;

&lt;h2 id=&quot;定制子类构造方法&quot;&gt;定制子类构造方法&lt;/h2&gt;
&lt;p&gt;对于子类Manager，每次创建对象的时候其实没有必要去传递一个参数&quot;job=mgr&quot;的参数，因为这是这个子类自然具备的。于是，在构造Manager对象的时候，可以让它自动设置&quot;job=mgr&quot;。&lt;/p&gt;
&lt;p&gt;所以，在Manager类中重写&lt;code&gt;__init__()&lt;/code&gt;。既然涉及到了重写，就有两种方式：(1)完全否定父类方法，(2)在父类方法上扩展。无论何时，总应当选第二种。&lt;/p&gt;
&lt;p&gt;以下是Manager类的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def __init__(self, name, pay):
        Employe.__init__(self, name, &quot;mgr&quot;, pay)

    def giveRaise(self, percent, bonus=0.10):
        Employe.giveRaise(self, percent + bonus)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在构造Manager对象的时候，只需给name和pay就可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    wugui = Manager(&quot;Wu Xiaogui&quot;, 15000)
    wugui.giveRaise(0.1, 0.1)
    print(wugui.pay)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;子类必须重写方法&quot;&gt;子类必须重写方法&lt;/h2&gt;
&lt;p&gt;有些父类中的方法可能会要求子类必须重写。&lt;/p&gt;
&lt;p&gt;本文的这个示例不好解释这一点。下面简单用父类Animal、子类Horse、子类Sheep、子类Cow来说明，这个例子来源于我写的面向对象相关的第一篇文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9965110.html&quot;&gt;从代码复用开始&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在要为动物定义叫声speak()方法，方法的作用是输出&quot;谁发出了什么声音&quot;。看代码即可理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Animal:
    def __init__(self, name):
        self.name = name
    def speak(self):
        print(self.name + &quot; speak &quot; + self.sound())
    def sound(self):
        raise NotImplementedError(&quot;you must override this method&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，speak()方法调用了sound()方法，但Animal类中的sound()方法却明确抛出异常&quot;你必须自己实现这个方法&quot;。&lt;/p&gt;
&lt;p&gt;为什么呢？因为每种动物发出的叫声不同，而这里又是通过方法来返回叫声的，不是通过属性来表示叫声的，所以每个子类必须定义自己的叫声。如果子类不定义sound()，子类对象调用&lt;code&gt;self.sound()&lt;/code&gt;就会搜索到父类Animal的名称空间上，而父类的sound()会抛出错误。&lt;/p&gt;
&lt;p&gt;现在在子类中重写sound()，但是Cow不重写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Horse(Animal):
    def sound(self):
        return &quot;neigh&quot;

class Sheep(Animal):
    def sound(self):
        return &quot;baaaah&quot;

class Cow(Animal):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h = Horse(&quot;horseA&quot;)
h.speak()

s = Sheep(&quot;sheepA&quot;)
s.speak()

c = Cow(&quot;cowA&quot;)
c.speak()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果正如预期，h.speak()和s.speak()都正常输出，但c.speak()会抛出&quot;you must override this method&quot;的异常。&lt;/p&gt;
&lt;p&gt;再考虑一下，如果父类中不定义sound()会如何？同样会在c.speak()时抛出错误。虽然都会终止程序，但是这已经脱离了面向对象的代码复用原则：对于对象公有的属性，都应该抽取到类中，对于类所公有的属性，都应该抽取到父类中。sound()显然是每种动物都应该具备的属性，要么定义为子类变量，要么通过类方法来返回。&lt;/p&gt;
&lt;p&gt;之前也提到过，如果可以，尽量不要定义类变量，因为这破坏了面向对象的封装原则，打开了&quot;黑匣子&quot;。所以最合理的方法，还是每个子类重写父类的sound()，且父类中的sound()强制要求子类重写。&lt;/p&gt;

&lt;h2 id=&quot;运算符重载&quot;&gt;运算符重载&lt;/h2&gt;
&lt;p&gt;如果用print()去输出我们自定义的类的对象，比如Employe对象，得到的都是一个元数据信息，比如包括类型和地址。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai)
print(xiaofang)

## 结果：
&amp;lt;__main__.Employe object at 0x01321690&amp;gt;
&amp;lt;__main__.Employe object at 0x01321610&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以自定义print()如何输出对象，只需定义类的&lt;code&gt;__str__()&lt;/code&gt;方法即可。只要在类中自定义了这个方法，print()输出对象的时候，就会自动调用这个&lt;code&gt;__str__()&lt;/code&gt;取得返回值，并将返回值输出。&lt;/p&gt;
&lt;p&gt;例如，在输出每个Employe对象的时候，都输出它的name、job、pay，并以一种自定义的格式输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

    ## 重载__str__()方法
    def __str__(self):
        return &quot;[Employe: %s, %s, %s]&quot; % (self.name, self.job, self.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再print()输出对象，将得到这个对象的信息，而不是这个对象的元数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai)
print(xiaofang)

## 结果：
[Employe: Ma Longshuai, None, 0]
[Employe: Gao Xiaofang, accountant, 15000]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，print()总是会调用对象的&lt;code&gt;__str__()&lt;/code&gt;，如果类中没有定义&lt;code&gt;__str__()&lt;/code&gt;，就会查找父类中的&lt;code&gt;__str__()&lt;/code&gt;。这里Employe的父类是祖先类object，它正好有一个&lt;code&gt;__str__()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; object.__dict__[&quot;__str__&quot;]
&amp;lt;slot wrapper '__str__' of 'object' objects&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换句话说，当Employe中定义了&lt;code&gt;__str__()&lt;/code&gt;，就意味着重载了父类object的&lt;code&gt;__str__()&lt;/code&gt;方法。而这个方法正好是被print()调用的，于是将这种行为称之为&quot;&lt;strong&gt;运算符重载&lt;/strong&gt;&quot;。&lt;/p&gt;
&lt;p&gt;可能从print()上感受不到为什么是运算符，换一个例子就很好理解了。&lt;code&gt;__add__()&lt;/code&gt;是决定加号&lt;code&gt;+&lt;/code&gt;运算模式的，比如&lt;code&gt;3 + 2&lt;/code&gt;之所以是5，是因为int类中定义了&lt;code&gt;__add__()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a=3
&amp;gt;&amp;gt;&amp;gt; type(a)
&amp;lt;class 'int'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; int.__dict__[&quot;__add__&quot;]
&amp;lt;slot wrapper '__add__' of 'int' objects&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这使得每次做数值加法运算的时候，都会调用这个&lt;code&gt;__add__()&lt;/code&gt;来决定如何做加法：&lt;/p&gt;
&lt;p&gt;实际上在类中定义构造函数&lt;code&gt;__init__()&lt;/code&gt;也是运算符重载，它在每次创建对象的时候被调用。&lt;/p&gt;
&lt;p&gt;还有很多运算符可以重载，加减乘除、字符串串联、大小比较等等和运算符有关、无关的都可以被重载。在后面，会专门用一篇文章来介绍运算符重载。&lt;/p&gt;

&lt;h2 id=&quot;序列化&quot;&gt;序列化&lt;/h2&gt;
&lt;p&gt;对象也是一种数据结构，数据结构可以进行序列化。通过将对象序列化，可以实现对象的本地持久性存储，还可以通过网络套接字发送给网络对端，然后通过反序列化可以还原得到完全相同的原始数据。&lt;/p&gt;
&lt;p&gt;序列化非本文内容，此处仅是介绍一下该功能，后面我会写几篇专门介绍python序列化的文章。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 14:48:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>在前面，我用了3篇文章解释python的面向对象： 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10099735.html</dc:identifier>
</item>
<item>
<title>约定Service构建方式 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9940469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9940469.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　对于DevOps中，将开发好的软件交付给运维人员去部署与维护，过程中参杂着诸多不可控制的变量，如环境问题、版本问题等等，而Docker容器极大程度上解决了这些问题，同时对于服务的持续交付，也变得方便和简洁，本次讲讲我的整个生成流水线中服务部署方面的一些想法和执行方式，或许不是很中意的想法，并且还可能被认为存在漏洞和错误，但是，至少是这个环节是通了的。最完美的前提至少是运行完成，在设计过程中，考虑到了几种情况，主要是针对服务器中镜像生产者和服务承载者之间的关系，也有不同的实现方式。&lt;/strong&gt; &lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、无需交付&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　镜像生产和服务部署共用服务器集群，服务器之间通过Docker Swarm完成集群，同时Docker Swarm中的Manager与镜像生产者在同一台服务器上，管理整个服务集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181207181439196-1940166014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;仍然需要将生产完毕的镜像推送到镜像仓库中，因为在同一个集群中的其他Worker节点需要指定镜像下载，镜像生产结束后，推送到仓库，此时发起一个创建服务或是更新服务的命令，指定本服务器上的集群完成相应工作。在交付服务时，可以有两种方式进行交付，采用单个服务的创建脚本docker service create或是采用多个服务的批量创建脚本docker stack deploy指定.yaml文件，将.yaml文件中的服务进行批量创建或更新。&lt;/p&gt;
&lt;p&gt;　　对于多个服务的创建脚本，我没有去尝试，有兴趣的可以查看&lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker官网&lt;/a&gt;相关资料，对于单个服务的创建或更新脚本可以采用命令行方式或是使用UI工具去完成创建和更新，如使用Portainer工具，在Portainer中操作是很方便的。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、手动交付&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　当镜像生产者和服务部署分离时，通常也是这种情形，镜像生产者只作为镜像的生产，职责便是生产镜像，而作为部署服务器，职责便是承载服务，对外提供服务。这个过程中就存在着，服务由谁创建，什么时候更新，由谁更新的一些问题，对于这些问题，也在一步一步设计中解答，本次先使用手动交付的形式，使用命令行来完成服务创建和更新，当镜像生产完毕后，便是交付环节，手动交付是最为基本的交付方式了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过&lt;strong&gt;命令行方式&lt;/strong&gt;完成手动交付：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、在Jenkins中使用命令行完成交付，当镜像生产完毕，执行创建服务或是更新服务，这有点随着镜像的变更而变更，无需人为操作，但是也是有问题的，就单个来讲，镜像的变更往往是由开发人员将代码合并到主干中，才触动镜像更新，这也在一定程度上受限于合并到主干的时机，如果合并太过频繁，则镜像生产者需要连续生产，并且中间的镜像生产过程变得毫无意义了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、在Swarm Cluster内使用命令行创建服务完成交付，在Swarm集群中的Manager节点上单个操作，是可行的，如果集群数量少，且没有安装图形管理工具之类的，可以使用这种方式，只是如果Swarm Cluster数量过多，需要一个一个切换\登录，也是比较繁琐的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、在其他主机上操控Swarm Cluster使用命令行完成交付，这个过程同直接操作Swarm Cluster也是差不多的，只是可以使用额外的管理主机管理多个Swarm Cluster的Manager节点，这样一来，也较为方便，直接在一台非Swarm Cluster内的主机上即可完成所有Swarm Cluster的创建和更新过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181207184615403-982321039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图例：直接在Jenkins所在主机上操控Swarm Cluster完成交付&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;三、借助工具手动交付&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对于命令行来讲，多条复杂命令总是难记，有可以直接操作的工具往往是更受欢迎的，而对于Docker来讲，Portainer工具是极受欢迎的，快速安装，简单的操作界面，丰富的功能等，同样还有其他不错的图形化容器管理工具，如DockerUI、Shipyard等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、利用Portainer工具完成手动交付，在Portainer界面中，配置好仓库地址和用户名密码，便于私有镜像的拉取，至于仓库，可以是自己搭建的镜像仓库，也可以使用第三方提供的镜像仓库，如阿里云、腾讯云镜像仓库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181210220256477-36415498.png&quot; alt=&quot;&quot; width=&quot;1345&quot; height=&quot;493&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、利用其他Docker及Docker Swarm集群管理工具完成手动交付，至于使用其他的工具，我也没有使用过，但是工具只不过是将命令行进行了分装，因此，其他图形化管理工具也是应该存在这些功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181207190135240-317854269.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图例：利用Portainer工具操控Swarm Cluster完成交付&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;四、借助工具自动交付&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对于自动交付，这个功能，只是见到过其他人这么玩过，猜想了一下工作方式，至于实际尝试，并没有去做，因为思考了一些操作过程，感觉我对这个自动交付的环节并不太感冒，因为按照生产来讲，追求稳定才是重要的，如果存在测试人员，测试相应服务完毕后，推送测试好的镜像，这是运维人员将镜像交付到生产环境中，能够保证不出差错，虽然失去了效率，但是也在是心安理得。至此，我只能简单描述下借助工具完成自动交付过程，在Docker Swarm集群中的Manager节点或单独弄一台服务器作为镜像更新后的交付服务器，在服务器中加入Jenkins工具，指定镜像版本更新，则拉取最新镜像完成服务更新，镜像首次推送，则完成服务创建，对于使用批量创建/更新服务的脚本文件，没有使用的太深，但是那个是非常有价值的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181210221613571-319221598.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　至此，几种我用过的方式也讲完了，在其中对于docker stack deploy使用的较少，因为docker stack deploy使用场景是为了批量服务的创建和更新而存在的，如果对于单个服务我都使用这个命令，有点杀鸡用牛刀的感觉，而对于以后的k8s学习，使用批量服务创建更新脚本文件，将会是常态。目前&lt;span&gt;我现在采用的是“借助工具手动交付“这种方式，原因有几点，主要是，思考了下，服务交付的意义，主要是为了稳定，少出问题，必须在确保稳定后才能交付部署，经测试人员测试完毕后完成交付到生产环境，这应该是我们所希望能够见到的，无论开发人员每天或每周有多少个版本更新，经测试人员测试后的稳定版本，才能交付到生产环境中，而不是说开发人员一将分支代码合并到主干中，有新的镜像生成了，就直接将新的镜像推送到生产环境中，而做到所谓的持续交付的目的，实际的持续交付应该是保证测试完毕到生产部署这个环节具有连续性，稳定性，每一次交付都经得起推敲，具体其中发生了什么，稳定性如何等，虽然这种方式效率较低，但对于持续交付来讲，这个效率也算是可以接受的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 约定Service构建方式&quot; href=&quot;https://www.cnblogs.com/CKExp/p/9940469.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9940469.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201812/1133736-20181210222201898-1213546560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-12-10,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 10 Dec 2018 14:24:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>对于DevOps中，将开发好的软件交付给运维人员去部署与维护，过程中参杂着诸多不可控制的变量，如环境问题、版本问题等等，而Docker容器极大程度上解决了这些问题，同时对于服务的持续交付，也变得方便和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9940469.html</dc:identifier>
</item>
<item>
<title>排序之快速排序详解 - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/10099502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/10099502.html</guid>
<description>&lt;p&gt;快速排序(Quick Sort)：它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，分别对这丙部分继续进行快速排序，直至整个序列有序。&lt;/p&gt;
&lt;p&gt;任取一个元素 (如第一个) 为中心&lt;br/&gt;所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；&lt;br/&gt;对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个&lt;/p&gt;
&lt;p&gt;①每一趟的子表的形成是采用从两头向中间交替式逼近法；&lt;/p&gt;
&lt;p&gt;②由于每趟中对各子表的操作都相似，可采用递归算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181210220407552-1321818241.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置两个指针i，j,首先在序列里面选出一个枢纽temp出来，将j指向的数字和temp比较，如果比temp大，则减1，如果比temp小，应该把当前j指向的位置上面的数值和&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181210220433180-1324848599.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最好：划分后，左侧右侧子序列的长度相同,&lt;/p&gt;
&lt;p&gt;最坏：从小到大排好序，递归树成为单支树，每次划分只得到一个比上一次少一个对象的子序列，必须经过 n-1 趟才能把所有对象定位，而且第 i 趟需要经过 n-i 次关键码比较才能找到第 i 个对象的安放位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181210220449088-1166499391.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若出现各种可能排列的概率相同，则可取最好情况和最坏情况的平均情况&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;时间效率：O(nlog2n) —每趟确定的元素呈指数增加&lt;br/&gt;空间效率：O（log2n）—递归要用到栈空间&lt;br/&gt;稳 定 性： 不稳定 —可选任一元素为支点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何选枢纽&quot;&gt;1.如何选枢纽&lt;/h2&gt;
&lt;p&gt;由上述描述可以知道，快速排序是以枢纽的点进行来回交换，所以快速排序的排序趟数和初始的序列有关系。&lt;br/&gt;所以选择快速排序的枢纽点是非常重要的，因为关系到排序的效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取前或后法&lt;/strong&gt;：序列中的第一个或最后一个元素作为基准，如果输入序列（上文中的数组）是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机选取基准&lt;/strong&gt;：&lt;br/&gt;这是一种相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n2）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三数取中法：&lt;/strong&gt;在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数。&lt;/p&gt;
&lt;h2 id=&quot;如何证明时间复杂度&quot;&gt;2.如何证明时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、最优情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为 [log2n]+1（ [x] 表示不大于 x 的最大整数），即仅需递归 log2n 次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，就有了下面的不等式推断：&lt;br/&gt;这说明，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.最坏情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后再来看最糟糕情况下的快排，当待排序的序列为正序或逆序排列时，且每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为n(n-1)/2，最终其时间复杂度为O(n^2)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.平均时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接设对规模的数组排序需要的时间期望为, 期望其实就是平均复杂度换个说法.&lt;br/&gt;空表的时候不用排, 所以初值条件就是 T(0) = 0 .所谓快排就是随便取出一个数,一般是第一个数,然后小于等于他的放左边, 大于他的的排右边.比如左边 k 个那接下来还要排: T(n - k) + T (k - 1) 的时间.然后 k 多少那是不确定的, 遍历 1~ n , 出现概率都是相等的. 另外分割操作本身也要时间 P(n) , 操作花费是线性时间 P(n) = cn , 这也要加进去, 所以一共是:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181210220508514-1572106964.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class QuickSort {

    //任取一个元素 (如第一个) 为中心
    //所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；
    //对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个
    //一趟排序过程后我们返回枢纽的位置
    int partition(int A[], int left, int right) {
        //选择枢纽元素
        int p = A[left];
        while (left &amp;lt; right) {
            //如果尾指针位置的数比枢纽数要大，移动尾指针的位置，否则就把所指示的值给首指针的位置
            while (left &amp;lt; right &amp;amp;&amp;amp; A[right] &amp;gt;= p) {
                --right;
            }
            A[left] = A[right];
            //如果首指针位置的数比枢纽数要小，移动首指针的位置，否则就把所指示的值给尾指针的位置
            while (left &amp;lt; right &amp;amp;&amp;amp; A[left] &amp;lt;= p) {
                ++left;
            }
            A[right] = A[left];
        }
        //此时的首尾指针已经相等，把枢纽的值赋给首尾指针相等的位置即可
        A[left] = p;
        return left;
    }

    //快速排序的递归
    void Quick(int A[], int left, int right) {
        //定义一个枢纽的位置
        int pnode;
        if (left &amp;lt; right) {
            pnode = partition(A, left, right);
            Quick(A, left, pnode - 1);
            Quick(A, pnode + 1, right);
        }
    }

    public static void main(String[] args) {

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/c8b1384238f7&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/c8b1384238f7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chengxiao/p/6262208.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/chengxiao/p/6262208.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/oohaha_123/article/details/26558363&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/oohaha_123/article/details/26558363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/22393997/answer/406278523&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/22393997/answer/406278523&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/onepixel/articles/7674659.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/onepixel/articles/7674659.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注个人技术公众号：Coder辰砂&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181210220557184-399120104.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 14:07:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>一、算法介绍 快速排序(Quick Sort)：它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，分别对这丙部分继续进行快速排序，直至整个序列有序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/10099502.html</dc:identifier>
</item>
<item>
<title>【经典】5种IO模型 | IO多路复用 - 毒逆天</title>
<link>http://www.cnblogs.com/dunitian/p/10099343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dunitian/p/10099343.html</guid>
<description>&lt;p&gt;上篇回顾：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyOTA3NzUwMQ==&amp;amp;mid=2649748027&amp;amp;idx=1&amp;amp;sn=44e9c7ee92a76812b15cb02c161cceee&amp;amp;chksm=f0536aa9c724e3bf196a433a890062341cec023aab2e4e3b228768f6e785643c1dd34d9fff55&amp;amp;scene=21#wechat_redirect&quot;&gt;静态服务器+压测&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念篇&quot;&gt;3.2.概念篇&lt;/h2&gt;
&lt;h3 id=&quot;同步与异步&quot;&gt;1.同步与异步&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;同步是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;异步是指不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作。然后继续执行下面代码逻辑，只要自己完成了整个任务就算完成了（异步一般使用状态、通知和回调）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：&lt;strong&gt;项目里面一般是这样的&lt;/strong&gt;：（个人经验）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同步架构：一般都是和钱相关的需求，需要实时返回的业务&lt;/li&gt;
&lt;li&gt;异步架构：更多是对写要求比较高时的场景（同步变异步）
&lt;ul&gt;&lt;li&gt;读一般都是实时返回，代码一般都是&lt;code&gt;await xxx()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;想象个情景就清楚了：
&lt;ul&gt;&lt;li&gt;异步：现在用户写了篇文章，可以异步操作，就算没真正写到数据库也可以返回：发表成功（大不了失败提示一下）&lt;/li&gt;
&lt;li&gt;同步：用户获取订单信息，你如果异步就会这样了：提示下获取成功，然后一片空白...用户不卸载就怪了...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;阻塞与非阻塞&quot;&gt;2.阻塞与非阻塞&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;阻塞是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务（大部分代码都是这样的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;非阻塞是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（继续执行下面代码，或者重试机制走起）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：&lt;strong&gt;项目里面重试机制为啥一般都是3次？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次重试，两台PC挂了也是有可能的&lt;/li&gt;
&lt;li&gt;第二次重试，负载均衡分配的三台机器同时挂的可能性不是很大，这时候就有可能是网络有点拥堵了&lt;/li&gt;
&lt;li&gt;最后一次重试，再失败就没意义了，日记写起来，再重试网络负担就加大了，得不偿失了&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;五种io模型&quot;&gt;3.五种IO模型&lt;/h3&gt;
&lt;p&gt;对于一次IO访问，数据会先被拷贝到内核的缓冲区中，然后才会从内核的缓冲区拷贝到应用程序的地址空间。需要经历两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;准备数据&lt;/li&gt;
&lt;li&gt;将数据从内核缓冲区拷贝到进程地址空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于存在这两个阶段，Linux产生了下面五种IO模型（&lt;code&gt;以socket为例&lt;/code&gt;）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阻塞式IO：
&lt;ul&gt;&lt;li&gt;当用户进程调用了&lt;code&gt;recvfrom&lt;/code&gt;等阻塞方法时，内核进入IO的第1个阶段：准备数据（内核需要等待足够的数据再拷贝）这个过程需要等待，用户进程会被阻塞，等内核将数据准备好，然后拷贝到用户地址空间，内核返回结果，用户进程才从阻塞态进入就绪态&lt;/li&gt;
&lt;li&gt;Linux中默认情况下所有的socket都是阻塞的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非阻塞式IO：
&lt;ul&gt;&lt;li&gt;当用户进程发出read操作时，如果&lt;code&gt;kernel&lt;/code&gt;中的数据还没有准备好，那么它并不会&lt;code&gt;block&lt;/code&gt;用户进程，而是立刻返回一个&lt;code&gt;error&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;用户进程判断结果是一个&lt;code&gt;error&lt;/code&gt;时，它就知道数据还没有准备好，于是它可以再次发送read操作&lt;/li&gt;
&lt;li&gt;一旦&lt;code&gt;kernel&lt;/code&gt;中的数据准备好了，并且又再次收到了用户进程的&lt;code&gt;system call&lt;/code&gt;，那么它马上就将数据拷贝到了用户内存，然后返回&lt;/li&gt;
&lt;li&gt;非阻塞IO模式下用户进程需要不断地询问内核的数据准备好了没有&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO多路复用&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;通过一种机制，一个进程可以监视多个文件描述符（套接字描述符）一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作（这样就不需要每个用户进程不断的询问内核数据准备好了没）&lt;/li&gt;
&lt;li&gt;常用的IO多路复用方式有&lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;和&lt;code&gt;epoll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;信号驱动IO：
&lt;ul&gt;&lt;li&gt;内核文件描述符就绪后，通过信号通知用户进程，用户进程再通过系统调用读取数据。&lt;/li&gt;
&lt;li&gt;此方式属于同步IO（实际读取数据到用户进程缓存的工作仍然是由用户进程自己负责的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步IO&lt;/strong&gt;（&lt;code&gt;POSIX&lt;/code&gt;的&lt;code&gt;aio_&lt;/code&gt;系列函数）
&lt;ul&gt;&lt;li&gt;用户进程发起read操作之后，立刻就可以开始去做其它的事。内核收到一个异步&lt;code&gt;IO read&lt;/code&gt;之后，会立刻返回，不会阻塞用户进程。&lt;/li&gt;
&lt;li&gt;内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个&lt;code&gt;signal&lt;/code&gt;告诉它read操作完成了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;unix图示&quot;&gt;4.Unix图示&lt;/h3&gt;
&lt;p&gt;贴一下Unix编程里面的图：&lt;/p&gt;
&lt;center&gt;**非阻塞IO**&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181210212858009-948984805.png&quot; alt=&quot;2.非阻塞IO&quot;/&gt;&lt;/p&gt;
&lt;center&gt;**IO复用**&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181210212908314-1267377747.png&quot; alt=&quot;3.IO复用&quot;/&gt;&lt;/p&gt;
&lt;center&gt;**信号IO**&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181210212934040-13536334.png&quot; alt=&quot;4.信号IO&quot;/&gt;&lt;/p&gt;
&lt;center&gt;**异步AIO**&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181210212944334-1184572641.png&quot; alt=&quot;5.异步AIO&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;io多路复用&quot;&gt;3.3.IO多路复用&lt;/h2&gt;
&lt;p&gt;开始之前咱们通过非阻塞IO引入一下：（来个简单例子&lt;code&gt;socket.setblocking(False)&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import time
import socket

def select(socket_addr_list):
    for client_socket, client_addr in socket_addr_list:
        try:
            data = client_socket.recv(2048)
            if data:
                print(f&quot;[来自{client_addr}的消息：]\n&quot;)
                print(data.decode(&quot;utf-8&quot;))
                client_socket.send(
                    b&quot;HTTP/1.1 200 ok\r\nContent-Type: text/html;charset=utf-8\r\n\r\n&amp;lt;h1&amp;gt;Web Server Test&amp;lt;/h1&amp;gt;&quot;
                )
            else:
                # 没有消息是触发异常，空消息是断开连接
                client_socket.close()  # 关闭客户端连接
                socket_addr_list.remove((client_socket, client_addr))
                print(f&quot;[客户端{client_addr}已断开连接，当前连接数：{len(socket_addr_list)}]&quot;)
        except Exception:
            pass

def main():
    # 存放客户端集合
    socket_addr_list = list()

    with socket.socket() as tcp_server:
        # 防止端口绑定的设置
        tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tcp_server.bind(('', 8080))
        tcp_server.listen()
        tcp_server.setblocking(False)  # 服务端非阻塞
        while True:
            try:
                client_socket, client_addr = tcp_server.accept()
                client_socket.setblocking(False)  # 客户端非阻塞
                socket_addr_list.append((client_socket, client_addr))
            except Exception:
                pass
            else:
                print(f&quot;[来自{client_addr}的连接，当前连接数：{len(socket_addr_list)}]&quot;)
            # 防止客户端断开后出错
            if socket_addr_list:
                # 轮询查看客户端有没有消息
                select(socket_addr_list)  # 引用传参
                time.sleep(0.01)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201812/1127869-20181210110004422-72437374.gif&quot; alt=&quot;3.nowait.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以思考下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么Server也要设置为非阻塞？
&lt;ul&gt;&lt;li&gt;PS：一个线程里面只能有一个死循环，现在程序需要两个死循环，so ==&amp;gt; 放一起咯&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;断开连接怎么判断？
&lt;ul&gt;&lt;li&gt;PS：没有消息是触发异常，空消息是断开连接&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;client_socket为什么不用dict存放？
&lt;ul&gt;&lt;li&gt;PS：dict在循环的过程中，del会引发异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;select&quot;&gt;1.Select&lt;/h3&gt;
&lt;p&gt;select和上面的有点类似，就是轮询的过程交给了操作系统：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来个和上面等同的案例：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import select
import socket

def main():
    with socket.socket() as tcp_server:
        tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tcp_server.bind(('', 8080))
        tcp_server.listen()
        socket_info_dict = dict()
        socket_list = [tcp_server]  # 监测列表
        while True:
            # 劣势：select列表数量有限制
            read_list, write_list, error_list = select.select(
                socket_list, [], [])
            for item in read_list:
                # 服务端迎接新的连接
                if item == tcp_server:
                    client_socket, client_address = item.accept()
                    socket_list.append(client_socket)
                    socket_info_dict[client_socket] = client_address
                    print(f&quot;[{client_address}已连接，当前连接数：{len(socket_list)-1}]&quot;)
                # 客户端发来
                else:
                    data = item.recv(2048)
                    if data:
                        print(data.decode(&quot;utf-8&quot;))
                        item.send(
                            b&quot;HTTP/1.1 200 ok\r\nContent-Type: text/html;charset=utf-8\r\n\r\n&amp;lt;h1&amp;gt;Web Server Test&amp;lt;/h1&amp;gt;&quot;
                        )
                    else:
                        item.close()
                        socket_list.remove(item)
                        info = socket_info_dict[item]
                        print(f&quot;[{info}已断开，当前连接数：{len(socket_list)-1}]&quot;)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出和上面一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展说明：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;select 函数监视的文件描述符分3类，分别是&lt;code&gt;writefds&lt;/code&gt;、&lt;code&gt;readfds&lt;/code&gt;、和&lt;code&gt;exceptfds&lt;/code&gt;。调用后select函数会阻塞，直到有描述符就绪函数返回（&lt;strong&gt;有数据可读、可写、或者有except&lt;/strong&gt;）或者超时（timeout指定等待时间，如果立即返回设为null即可）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024（64位=&amp;gt;2048）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;然后Poll就出现了，就是把上限给去掉了，本质并没变，还是使用的&lt;code&gt;轮询&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;epoll&quot;&gt;2.EPoll&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;epoll在内核2.6中提出（Linux独有），使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，采用监听回调的机制，这样在用户空间和内核空间的copy只需一次，避免再次遍历就绪的文件描述符列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来看个案例吧：（输出和上面一样）&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import socket
import select

def main():
    with socket.socket() as tcp_server:
        tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tcp_server.bind(('', 8080))
        tcp_server.listen()

        # epoll是linux独有的
        epoll = select.epoll()
        # tcp_server注册到epoll中
        epoll.register(tcp_server.fileno(), select.EPOLLIN | select.EPOLLET)

        # key-value
        fd_socket_dict = dict()

        # 回调需要自己处理
        while True:
            # 返回可读写的socket fd 集合
            poll_list = epoll.poll()
            for fd, event in poll_list:
                # 服务器的socket
                if fd == tcp_server.fileno():
                    client_socket, client_addr = tcp_server.accept()
                    fd = client_socket.fileno()
                    fd_socket_dict[fd] = (client_socket, client_addr)
                    # 把客户端注册进epoll中
                    epoll.register(fd, select.EPOLLIN | select.EPOLLET)
                else:  # 客户端
                    client_socket, client_addr = fd_socket_dict[fd]
                    data = client_socket.recv(2048)
                    print(
                        f&quot;[来自{client_addr}的消息，当前连接数：{len(fd_socket_dict)}]\n&quot;)
                    if data:
                        print(data.decode(&quot;utf-8&quot;))
                        client_socket.send(
                            b&quot;HTTP/1.1 200 ok\r\nContent-Type: text/html;charset=utf-8\r\n\r\n&amp;lt;h1&amp;gt;Web Server Test&amp;lt;/h1&amp;gt;&quot;
                        )
                    else:
                        del fd_socket_dict[fd]
                        print(
                            f&quot;[{client_addr}已离线，当前连接数：{len(fd_socket_dict)}]\n&quot;
                        )
                        # 从epoll中注销
                        epoll.unregister(fd)
                        client_socket.close()

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展：&lt;strong&gt;epoll的两种工作模式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;LT（level trigger，水平触发）模式：当epoll_wait检测到描述符就绪，将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。LT模式是默认的工作模式。&lt;br/&gt;LT模式同时支持阻塞和非阻塞socket。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ET（edge trigger，边缘触发）模式：当epoll_wait检测到描述符就绪，将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;br/&gt;ET是高速工作方式，只支持非阻塞socket（ET模式减少了epoll事件被重复触发的次数，因此效率要比LT模式高）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Code提炼一下&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化对象：&lt;code&gt;epoll = select.epoll()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注册对象：&lt;code&gt;epoll.register(tcp_server.fileno(), select.EPOLLIN | select.EPOLLET)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注销对象：&lt;code&gt;epoll.unregister(fd)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：&lt;code&gt;epoll&lt;/code&gt;不一定比&lt;code&gt;Select&lt;/code&gt;性能高，一般都是分场景的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高并发下，连接活跃度不高时：epoll比Select性能高（eg：web请求，页面随时关闭）&lt;/li&gt;
&lt;li&gt;并发不高，连接活跃度比较高：Select更合适（eg：小游戏）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Select是win和linux通用的，而epoll只有linux有&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实IO多路复用还有一个&lt;code&gt;kqueue&lt;/code&gt;，和&lt;code&gt;epoll&lt;/code&gt;类似，下面的通用写法中有包含&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;通用写法selector&quot;&gt;3.通用写法（&lt;code&gt;Selector&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;一般来说：&lt;strong&gt;Linux下使用epoll，Win下使用select&lt;/strong&gt;（IO多路复用会这个通用的即可）&lt;/p&gt;
&lt;p&gt;先看看Python源代码：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 选择级别：epoll|kqueue|devpoll &amp;gt; poll &amp;gt; select
if 'KqueueSelector' in globals():
    DefaultSelector = KqueueSelector
elif 'EpollSelector' in globals():
    DefaultSelector = EpollSelector
elif 'DevpollSelector' in globals():
    DefaultSelector = DevpollSelector
elif 'PollSelector' in globals():
    DefaultSelector = PollSelector
else:
    DefaultSelector = SelectSelector&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实战案例&lt;/strong&gt;：(可读和可写可以不分开)&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import socket
import selectors

# Linux下使用epoll，Win下使用select
Selector = selectors.DefaultSelector()

class Task(object):
    def __init__(self):
        # 存放客户端fd和socket键值对
        self.fd_socket_dict = dict()

    def run(self):
        self.server = socket.socket()
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind(('', 8080))
        self.server.listen()
        # 把Server注册到epoll
        Selector.register(self.server.fileno(), selectors.EVENT_READ,
                          self.connected)

    def connected(self, key):
        &quot;&quot;&quot;客户端连接时处理&quot;&quot;&quot;
        client_socket, client_address = self.server.accept()
        fd = client_socket.fileno()
        self.fd_socket_dict[fd] = (client_socket, client_address)
        # 注册一个客户端读的事件（服务端去读消息）
        Selector.register(fd, selectors.EVENT_READ, self.call_back_reads)
        print(f&quot;{client_address}已连接，当前连接数：{len(self.fd_socket_dict)}&quot;)

    def call_back_reads(self, key):
        &quot;&quot;&quot;客户端可读时处理&quot;&quot;&quot;
        # 一个fd只能注册一次，监测可写的时候需要把可读给注销
        Selector.unregister(key.fd)
        client_socket, client_address = self.fd_socket_dict[key.fd]
        print(f&quot;[来自{client_address}的消息:]\n&quot;)
        data = client_socket.recv(2048)
        if data:
            print(data.decode(&quot;utf-8&quot;))
            # 注册一个客户端写的事件（服务端去发消息）
            Selector.register(key.fd, selectors.EVENT_WRITE,
                              self.call_back_writes)
        else:
            client_socket.close()
            del self.fd_socket_dict[key.fd]
            print(f&quot;{client_address}已断开，当前连接数：{len(self.fd_socket_dict)}&quot;)

    def call_back_writes(self, key):
        &quot;&quot;&quot;客户端可写时处理&quot;&quot;&quot;
        Selector.unregister(key.fd)
        client_socket, client_address = self.fd_socket_dict[key.fd]
        client_socket.send(b&quot;ok&quot;)
        Selector.register(key.fd, selectors.EVENT_READ, self.call_back_reads)

def main():
    t = Task()
    t.run()
    while True:
        ready = Selector.select()
        for key, obj in ready:
            # 需要自己回调
            call_back = key.data
            call_back(key)

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Code提炼一下&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化对象：&lt;code&gt;Selector = selectors.DefaultSelector()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注册对象：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Selector.register(server.fileno(), selectors.EVENT_READ, call_back)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Selector.register(server.fileno(), selectors.EVENT_WRITE, call_back)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注销对象：&lt;code&gt;Selector.unregister(key.fd)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意一下：&lt;strong&gt;一个fd只能注册一次，监测可写的时候需要把可读给注销（反之一样）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;业余拓展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select, iocp, epoll,kqueue及各种I/O复用机制
https://blog.csdn.net/shallwake/article/details/5265287

kqueue用法简介
http://www.cnblogs.com/luminocean/p/5631336.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下级预估：协程篇 or 网络深入篇&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 13:41:00 +0000</pubDate>
<dc:creator>毒逆天</dc:creator>
<og:description>上篇回顾：静态服务器+压测 3.2.概念篇 1.同步与异步 同步是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成。 异步是指不需要等待被依赖的任务完成，只是通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dunitian/p/10099343.html</dc:identifier>
</item>
<item>
<title>Linux驱动程序入门 三 - stormeLi</title>
<link>http://www.cnblogs.com/dl04301201/p/10098864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dl04301201/p/10098864.html</guid>
<description>&lt;p&gt;&lt;strong&gt;LED驱动程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：看懂 PCB 原理图和 芯片datasheet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：寻找对应 Pin 的寄存器地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 第三步：匹配有效的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面以 iTOP4412 ARM9开发板为例 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找出对应的 LED 引脚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210182042114-484055644.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;通过 &lt;strong&gt;KP_COL0 和 VDD50_EN 匹配芯片上对应的 Pin ：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210182432083-1819652196.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210182610242-181629670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;从上图可知 : &lt;/strong&gt;KP_COL0 对应在 chip 上的 Pin ：GPL2_0  ; &lt;strong&gt;VDD50_EN &lt;/strong&gt;&lt;strong&gt;&lt;strong&gt; 对应在 chip 上的 Pin ：GPK1_1 &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;然后通过 chip datasheet 去匹配对应的寄存器 : &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210183056676-805450835.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上图可知GPL2对应的个寄存器的功能。可知这些 datasheet &lt;strong&gt;都是英文的，建议志同道合的伙伴们记得去提升一下自己的英语文化水平。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;从匹配的信息来看，需要的是 GPL2_0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPL_CON 寄存器 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210183528556-635732459.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上图可知 GPL2CON 的 Base Address  ：0x1100_0000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址对应的偏移为：Base Address + 0x1000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重置值为 ： 0x0000_0000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; LED， 那么则须把 GPL2CON［０］设置成 ： 0x1 = Output ---&amp;gt;输出模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPL_DAT 寄存器 : &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210192219177-2127450106.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description 处要仔细读， 里面涉及了对应寄存器的用法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;GPK1_1 配信息的原理同上！！！！&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综述 : &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPL2_CON      地址为 : 0x11000100 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPL_DAT         地址为：0x11000104&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPK1_CON      地址为 : 0x11000060 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPK_DAT         地址为：0x11000064&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;驱动原理 ：就是操作 open read write ioctl close 等函数，所以在 Linux驱动程序入门 二 时说过，学驱动很简单！&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;10&quot; cellpadding=&quot;10&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;用户层&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;ioctl&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;file_operation&lt;/td&gt;
&lt;td&gt;  ||&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;驱动层&lt;/td&gt;
&lt;td&gt;led_open&lt;/td&gt;
&lt;td&gt;led_read&lt;/td&gt;
&lt;td&gt;led_write&lt;/td&gt;
&lt;td&gt;led_ioctl&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;





&lt;p&gt;用户层有一个 &lt;strong&gt;open&lt;/strong&gt; 函数，则驱动层有对应的&lt;strong&gt; led_open 函数，两者通过 file_operation结构关联起来！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;led 的驱动程序为 : &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;linux/module.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;linux/kernel.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;linux/fs.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;linux/init.h&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;linux/delay.h&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;asm/uaccess.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;asm/io.h&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;linux/device.h&amp;gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; major;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *gpl2con =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *gpl2dat =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *gpk1con =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *gpk1dat =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; led_open(&lt;span&gt;struct&lt;/span&gt; inode *inode, &lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;file)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;配置GPL2为输出,先清零，再配置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     *gpl2con &amp;amp;= ~&lt;span&gt;0x03&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     *gpl2con |= &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;配置GPK1为输出,先清零，再配置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     *gpk1con &amp;amp;= ~(&lt;span&gt;0x03&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     *gpk1con |=  (&lt;span&gt;0x01&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; led_write(&lt;span&gt;struct&lt;/span&gt; file *&lt;span&gt;filp, 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         /&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, size_t count, loff_t *&lt;span&gt;ppos)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;从用户拷贝到内核///copy_to_user()从内核拷贝到用户&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     copy_from_user(&amp;amp;&lt;span&gt;val, buf, count);   
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(val == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点灯&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         *gpl2dat |= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点灯&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         *gpk1dat |= &lt;span&gt;0x02&lt;/span&gt;&lt;span&gt;;        
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;灭灯&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         *gpl2dat &amp;amp;= ~&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点灯&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         *gpk1dat &amp;amp;= ~&lt;span&gt;0x02&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; file_operations led_fops =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;这是一个宏，推向编译环境时自动创建的__this_module&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     .owner =&lt;span&gt; THIS_MODULE,           
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     .open =&lt;span&gt; led_open,
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     .write =&lt;span&gt; led_write,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; led_drv_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册驱动程序，告诉内核这个函数来被谁调用&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     register_chrdev(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first_drv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;first_drv_fops); 
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     
&lt;span&gt;63&lt;/span&gt;     gpl2con = (&lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *)ioremap(&lt;span&gt;0x11000100&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     gpl2dat = gpl2con + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     
&lt;span&gt;66&lt;/span&gt;     gpk1con = (&lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; *)ioremap(&lt;span&gt;0x11000060&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     gpk1dat = gpk1con + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; led_drv_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     unregister_chrdev(major, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first_drv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    device_unregister(firstdrv_class_dev);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    class_destroy(firstdrv_class);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    iounmap(gpl2con);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    iounmap(gpk1con);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;module_init(led_drv_init);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;module_exit(led_drv_exit);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; MODULE_LICENSE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dual BSD/GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; MODULE_AUTHOR(&lt;span&gt;&quot;stormeli&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; MODULE_DESCRIPTION(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LEDdriver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对应的Makefile，即编译内核为 : &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#！/bin/&lt;span&gt;bash
obj&lt;/span&gt;-m +=&lt;span&gt; led_drv.o

KDIR :&lt;/span&gt;= /home/topeet/Android/Android4.&lt;span&gt;0&lt;/span&gt;/iTop4412_Kernel_3.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

PWD &lt;/span&gt;?=&lt;span&gt; $(shell pwd)

all:
    make &lt;/span&gt;-C $(KDIR) M=&lt;span&gt;$(PWD) modules

clean:
    rm &lt;/span&gt;-rf *&lt;span&gt;.o
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;用户层程序为 ：&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *firstdrvtest on
 *firstdrvtest off
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;argv)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; val = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    fd &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/dev/led&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_RDWR);
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fd &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;can't open!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc != &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage :\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s &amp;lt;on|off&amp;gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, argv[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(strcmp(argv[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        val &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        val &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    
    write(fd, &lt;/span&gt;&amp;amp;val, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;编译过程为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、编译驱动程序 : 使用 make 指令，得到 .ko 文件，即模块驱动文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210194348116-794821073.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、编译用户程序 : 使用 arm-none-linux-guneabi- gcc -o led_device led_device.c -static 指令编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210194909303-1760267890.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;得到可执行文件 led_device&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把编译得到的 可执行文件 led_device 和 led_drv.ko 文件拷贝进 &lt;/strong&gt;iTOP4412 板子里（可使用的方法有 U盘拷贝， nfs协议传输，tftp协议传输）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;板子上的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载内核模块的指令 ： insmod xxx.ko&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看内核模块的指令：lsmod&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卸载内核模块的指令：rmmod xxx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过 insmod xxx.ko 加载内核模块， 然后 lsmod 查询，是否加载成功， 再使用 cat /proc/device 查看分配的 主设备号 跟 次设备号「此关于设备文件的创建」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「驱动匹配得有 设备文件『由用户层可知创建 ／dev/led 文件&lt;/strong&gt;』跟驱动文件&lt;strong&gt;」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;创建设备文件的指令为 : mknod /dev/led c 主设备号 次设备号             c「代表是字符 character 设备驱动」&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;最后执行用户可执行文件 ./led_device &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210201341225-63662484.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210201355182-113447070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可知 led_drv 主设备号为 248， 次设备号为 0 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210201553929-1673907388.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210201930101-2105941896.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;板子 LED 点亮&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210202003445-657712151.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210202210880-1044161827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1547088/201812/1547088-20181210202223056-1788947021.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 12:25:00 +0000</pubDate>
<dc:creator>stormeLi</dc:creator>
<og:description>LED驱动程序 第一步：看懂 PCB 原理图和 芯片datasheet 第二步：寻找对应 Pin 的寄存器地址 第三步：匹配有效的信息 下面以 iTOP4412 ARM9开发板为例 ： 找出对应的 L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dl04301201/p/10098864.html</dc:identifier>
</item>
</channel>
</rss>