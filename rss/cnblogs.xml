<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html</guid>
<description>&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;服务注册&lt;/a&gt;》、《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;服务消费&lt;/a&gt;》和《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;生命周期&lt;/a&gt;》主要从实现原理的角度对.NET Core的依赖注入框架进行了介绍，接下来更进一步，看看该框架的总体设计和实现。在过去的多个版本更迭过程中，依赖注入框架的底层实现一直都在发生改变，加上底层的涉及的大都是内容接口和类型，所以我们不打算涉及太过细节的层面。&lt;/p&gt;

&lt;p&gt;对于依赖注入的底层设计和实现来说，ServiceProviderEngine和ServiceProviderEngineScope是两个最为核心的类型。顾名思义，ServiceProviderEngine表示提供服务实例的提供引擎，服务实例最终是通过该引擎提供的，在一个应用范围内只存在一个&lt;span&gt;全局唯一的ServiceProviderEngine&lt;/span&gt;对象。ServiceProviderEngineScope代表服务范围，它利用对提供服务实例的缓存实现对生命周期的控制。ServiceProviderEngine实现了接口IServiceProviderEngine，从如下的代码片段可以看出，一个ServiceProviderEngine对象同时也是一个IServiceProvider对象，还是一个IServiceScopeFactory对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServiceProviderEngine :  IServiceProvider, IDisposable, IAsyncDisposable
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ValidateService(ServiceDescriptor descriptor);
    IServiceScope RootScope { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderEngine : IServiceProviderEngine, IServiceScopeFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceScope RootScope { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceScope CreateScope();
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServiceProviderEngine的RootScope属性返回的IServiceScope对象是为&lt;span&gt;根容器提供的服务范围&lt;/span&gt;。作为一个IServiceScopeFactory对象，ServiceProviderEngine的CreateScope会创建一个新的服务范围，这两种服务范围都通过一个&lt;span&gt;ServiceProviderEngineScope&lt;/span&gt;对象来表示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderEngineScope : IServiceScope, IDisposable,  IServiceProvider, IAsyncDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ServiceProviderEngine Engine { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider ServiceProvider { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetService(Type serviceType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，一个ServiceProviderEngineScope对象不仅是一个&lt;span&gt;IServiceScope&lt;/span&gt;对象，还是一个&lt;span&gt;IServiceProvider&lt;/span&gt;对象。在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;生命周期&lt;/a&gt;》中，我们说表示服务范围的IServiceScope对象是对一个表示依赖注入容器的IServiceProvider对象的封装，实际上&lt;span&gt;两者合并为同一个ServiceProviderEngineScope对象&lt;/span&gt;，一个ServiceProviderEngineScope对象的ServiceProvider属性返回的就是它自己。换句话说，我们所谓的子容器和它所在的服务范围引用的都是同一个ServiceProviderEngineScope对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084227018-139335347.png&quot;&gt;&lt;img width=&quot;534&quot; height=&quot;218&quot; title=&quot;4-12&quot; alt=&quot;4-12&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084227305-44676849.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图进一步揭示了ServiceProviderEngine和ServiceProviderEngineScope之间的关系。对于一个通过调用ServiceProviderEngine对象的CreateScope创建的ServiceProviderEngineScope来说，由于它同时也是一个IServiceProvider对象，如果我们调用它的GetService&amp;lt;IServiceProvider&amp;gt;方法，该方法同样返回它自己。如果我们调用它的GetService&amp;lt;IServiceScopeFactory&amp;gt;方法，它返回创建它的ServiceProviderEngine对象，也就是该方法和Engine属性返回同一个对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084227487-1291609346.png&quot;&gt;&lt;img width=&quot;432&quot; height=&quot;137&quot; title=&quot;4-13&quot; alt=&quot;4-13&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084227718-1899001857.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;依赖注入框架提供的服务实例最终是通过ServiceProviderEngine对象提供的。从上面给出的代码片段可以看出，ServiceProviderEngine是一个抽象类，.NET Core依赖注入框架提供了如下四个具体的实现类型，默认使用的是DynamicServiceProviderEngine。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RuntimeServiceProviderEngine：采用反射的方式提供服务实例；&lt;/li&gt;
&lt;li&gt;ILEmitServiceProviderEngine：采用IL Emit的方式提供服务实例；&lt;/li&gt;
&lt;li&gt;ExpressionsServiceProviderEngine：采用表达式树的方式提供服务实例；&lt;/li&gt;
&lt;li&gt;DynamicServiceProviderEngine：根据请求并发数量动态决定最终的服务实例提供方案（反射和者IL Emit或者反射与表达式树，是否选择IL Emit取决于当前运行时是否支持Reflection Emit）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用IServiceCollection集合的扩展方法BuildServiceProvider创建的是一个ServiceProvider对象。作为根容器的ServiceProvider对象，和前面介绍的ServiceProviderEngine和ServiceProviderEngineScope对象，一起构建了整个依赖注入框架的设计蓝图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084227938-1171796424.png&quot;&gt;&lt;img width=&quot;495&quot; height=&quot;161&quot; title=&quot;4-14&quot; alt=&quot;4-14&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191115084228162-852480170.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在利用IServiceCollection集合创建ServiceProvider对象的时候，提供的服务注册将用来创建一个具体的ServiceProviderEngine对象。该ServiceProviderEngine对象的RootScope就是它创建的一个ServiceProviderEngineScope对象，子容器提供的Singleton服务实例由它维护。如果调用ServiceProvider对象的GetService&amp;lt;IServiceProvider&amp;gt;方法，返回的其实&lt;span&gt;不是它自己&lt;/span&gt;，而是作为RootScope的ServiceProviderEngineScope对象（调用ServiceProviderEngineScope对象的GetService&amp;lt;IServiceProvider&amp;gt;方法返回的&lt;span&gt;是它自己&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;ServiceProvider和ServiceProviderEngineScope都实现了IServiceProvider接口，如果我们调用了它们的GetService&amp;lt;IServiceScopeFactory&amp;gt;方法，返回的都是&lt;span&gt;同一个ServiceProviderEngine对象&lt;/span&gt;。这一个特性决定了调用它们的CreateScope扩展方法都会创建一个新的ServiceProviderEngineScope对象作为子容器。综上所述，我们针对依赖注入框架总结出如下的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ServiceProviderEngine的唯一性：整个服务提供体系只存在一个唯一的ServiceProviderEngine对象。&lt;/li&gt;
&lt;li&gt;ServiceProviderEngine与IServiceFactory的同一性：唯一存在的ServiceProviderEngine会作为创建服务范围的IServiceFactory工厂。&lt;/li&gt;
&lt;li&gt;ServiceProviderEngineScope和IServiceProvider的同一性：表示服务范围的ServiceProviderEngineScope同时也是作为服务提供者的依赖注入容器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了印证我们总结出来的特性，我们编写的测试代码。由于设计的ServiceProviderEngine和ServiceProviderEngineScope都是内部类型，我们只能采用反射的方式得到它们的属性或者字段成员。上面总结的这些特征体现在如下几组调试断言中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; (engineType, engineScopeType) =&lt;span&gt; ResolveTypes();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection().BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child1 =&lt;span&gt; root.CreateScope().ServiceProvider;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child2 =&lt;span&gt; root.CreateScope().ServiceProvider;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; engine =&lt;span&gt; GetEngine(root);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rootScope =&lt;span&gt; GetRootScope(engine, engineType);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ServiceProviderEngine的唯一性&lt;/span&gt;
&lt;span&gt;        Debug.Assert(ReferenceEquals(GetEngine(rootScope, engineScopeType), engine));
        Debug.Assert(ReferenceEquals(GetEngine(child1, engineScopeType), engine));
        Debug.Assert(ReferenceEquals(GetEngine(child2, engineScopeType), engine));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ServiceProviderEngine和IServiceScopeFactory的同一性&lt;/span&gt;
        Debug.Assert(ReferenceEquals(root.GetRequiredService&amp;lt;IServiceScopeFactory&amp;gt;&lt;span&gt;(), engine));
        Debug.Assert(ReferenceEquals(child1.GetRequiredService&lt;/span&gt;&amp;lt;IServiceScopeFactory&amp;gt;&lt;span&gt;(), engine));
        Debug.Assert(ReferenceEquals(child2.GetRequiredService&lt;/span&gt;&amp;lt;IServiceScopeFactory&amp;gt;&lt;span&gt;(), engine));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ServiceProviderEngineScope提供的IServiceProvider是它自己
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ServiceProvider提供的IServiceProvider是RootScope&lt;/span&gt;
        Debug.Assert(ReferenceEquals(root.GetRequiredService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;(), rootScope));
        Debug.Assert(ReferenceEquals(child1.GetRequiredService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;(), child1));
        Debug.Assert(ReferenceEquals(child2.GetRequiredService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;(), child2));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ServiceProviderEngineScope和IServiceProvider的同一性&lt;/span&gt;
&lt;span&gt;        Debug.Assert(ReferenceEquals((rootScope).ServiceProvider, rootScope));
        Debug.Assert(ReferenceEquals(((IServiceScope)child1).ServiceProvider, child1));
        Debug.Assert(ReferenceEquals(((IServiceScope)child2).ServiceProvider, child2));
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; (Type Engine, Type EngineScope) ResolveTypes()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assembly = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ServiceProvider).Assembly;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; engine = assembly.GetTypes().Single(it =&amp;gt; it.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IServiceProviderEngine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; engineScope = assembly.GetTypes().Single(it =&amp;gt; it.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceProviderEngineScope&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (engine, engineScope);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetEngine(ServiceProvider serviceProvider)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; field = &lt;span&gt;typeof&lt;/span&gt;(ServiceProvider).GetField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_engine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BindingFlags.Instance |&lt;span&gt; BindingFlags.NonPublic);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; field.GetValue(serviceProvider);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetEngine(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; enginScope, Type engineScopeType)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; property = engineScopeType.GetProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Engine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BindingFlags.Instance |&lt;span&gt; BindingFlags.Public);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; property.GetValue(enginScope);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; IServiceScope GetRootScope(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; engine, Type engineType)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; property = engineType.GetProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RootScope&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, BindingFlags.Instance |&lt;span&gt; BindingFlags.Public);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (IServiceScope)property.GetValue(engine);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;依赖注入模式&lt;/a&gt;》中，我们从“Service Locator”设计模式是反模式的角度说明了为什么不推荐在服务中注入IServiceProvider对象。不过反模式并不就等于是完全不能用的模式，有些情况下直接在服务构造函数中注入作为依赖注入容器的IServiceProvider对象可能是最快捷省事的解决方案。对于IServiceProvider对象的注入，有个细节大家可能忽略或者误解。&lt;/p&gt;
&lt;p&gt;读者朋友们可以试着思考这么一个问题：如果我们在某个服务中注入了IServiceProvider对象，当我们利用某个IServiceProvider对象来提供该服务实例的时候，注入的IServiceProvider对象是它自己吗？以如下所示的代码片段为例，我们定义了两个在构造函数中注入了IServiceProvider对象的服务类型SingletonService和ScopedService，并按照命名所示的生命周期进行了注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddSingleton&lt;/span&gt;&amp;lt;SingletonService&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;ScopedService&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; serviceProvider.CreateScope())
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; scope.ServiceProvider;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singletonService = child.GetRequiredService&amp;lt;SingletonService&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scopedService = child.GetRequiredService&amp;lt;ScopedService&amp;gt;&lt;span&gt;();

            Debug.Assert(ReferenceEquals(child, scopedService.RequestServices));
            Debug.Assert(ReferenceEquals(rootScope, singletonService.ApplicationServices));
        }
    }            

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingletonService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider ApplicationServices { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SingletonService(IServiceProvider serviceProvider) =&amp;gt; ApplicationServices =&lt;span&gt; serviceProvider;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScopedService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider RequestServices { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ScopedService(IServiceProvider serviceProvider) =&amp;gt; RequestServices =&lt;span&gt; serviceProvider;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们最终利用一个作为子容器的IServiceProvider对象（ServiceProviderEngineScope对象）来提供这来个服务类型的实例，并通过调试断言确定注入的IServiceProvider对象是否就是作为当前依赖注入容器的ServiceProviderEngineScope对象。如果在Debug模式下运行上述的测试代码，我们会发现&lt;span&gt;第一个断言是成立的，第二个则不成立&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再次回到两个服务类型的定义，SingletonService和ScopedService中通过注入IServiceProvider对象初始化的属性分别被命名为ApplicationServices和RequestServices，意味着它们希望注入的分别是针对当前应用程序的根容器和针对请求的子容器。当我们利用针对请求的子容器来提供针对这两个类型的服务实例时，如果注入的当前子容器的话，就与ApplicationServices的意图不符。所以在提供服务实例的注入的IServiceProvider对象取决于采用的生命周期模式，具体策略为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Singleton：注入的是ServiceProviderEngine的RootScope属性表示的ServiceProviderEngineScope对象。&lt;/li&gt;
&lt;li&gt;Scoped和Transient：如果当前IServiceProvider对象类型为ServiceProviderEngineScope，注入的就是它自己，如果是一个ServiceProvider对象，注入的还是ServiceProviderEngine的RootScope属性表示的ServiceProviderEngineScope对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于生命周期模式注入IServiceProvider对象的策略可以通过如下这个测试程序来验证。最后还有一点需要补充一下：我们将调用IServiceCollection集合的BuildServiceProvider扩展方法创建的ServiceProvider对象作为根容器，它对应的ServiceProviderEngine对象的RootScope属性返回作为根服务范围的ServiceProviderEngineScope对象，ServiceProvider、ServiceProviderEngine和ServiceProviderEngineScope这三个类型全部实现了IServiceProvider接口，这三个对象都可以视为根容器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddSingleton&lt;/span&gt;&amp;lt;SingletonService&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;ScopedService&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rootScope = serviceProvider.GetService&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; serviceProvider.CreateScope())
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; scope.ServiceProvider;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singletonService = child.GetRequiredService&amp;lt;SingletonService&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scopedService = child.GetRequiredService&amp;lt;ScopedService&amp;gt;&lt;span&gt;();

            Debug.Assert(ReferenceEquals(child, child.GetRequiredService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;()));
            Debug.Assert(ReferenceEquals(child, scopedService.RequestServices));
            Debug.Assert(ReferenceEquals(rootScope, singletonService.ApplicationServices));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Nov 2019 00:36:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>《服务注册》、《服务消费》和《生命周期》主要从实现原理的角度对.NET Core的依赖注入框架进行了介绍，接下来更进一步，看看该框架的总体设计和实现。在过去的多个版本更迭过程中，依赖注入框架的底层实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html</dc:identifier>
</item>
<item>
<title>详解Spring Security的HttpBasic登录验证模式 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11863910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11863910.html</guid>
<description>&lt;h2 id=&quot;一httpbasic模式的应用场景&quot;&gt;一、HttpBasic模式的应用场景&lt;/h2&gt;
&lt;p&gt;HttpBasic登录验证模式是Spring Security实现登录验证最简单的一种方式，也可以说是最简陋的一种方式。它的目的并不是保障登录验证的绝对安全，而是提供一种“防君子不防小人”的登录验证。&lt;/p&gt;
&lt;p&gt;就好像是我小时候写日记，都买一个带小锁头的日记本，实际上这个小锁头有什么用呢？如果真正想看的人用一根钉子都能撬开。它的作用就是：某天你的父母想偷看你的日记，拿出来一看还带把锁，那就算了吧，怪麻烦的。&lt;/p&gt;
&lt;p&gt;举一个我使用HttpBasic模式的进行登录验证的例子：我曾经在一个公司担任部门经理期间，开发了一套用于统计效率、分享知识、生成代码、导出报表的Http接口。纯粹是为了工作中提高效率，同时我又有一点点小私心，毕竟各部之间是有竞争的，所以我给这套接口加上了HttpBasic验证。公司里随便一个技术人员，最多只要给上一两个小时，就可以把这个验证破解了。说白了，这个工具的数据不那么重要，加一道锁的目的就是不让它成为公开数据。如果有心人破解了，真想看看这里面的数据，其实也无妨。这就是HttpBasic模式的典型应用场景。&lt;/p&gt;
&lt;h2 id=&quot;二spring-boot2.0整合spring-security&quot;&gt;二、spring boot2.0整合Spring security&lt;/h2&gt;
&lt;p&gt;spring boot 2,x版本maven方式引入Spring security坐标。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三httpbasic登录认证模式&quot;&gt;三、HttpBasic登录认证模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果使用的Spring Boot版本为1.X版本,依赖的Security 4.X版本，那么就无需任何配置，启动项目访问则会弹出默认的httpbasic认证.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在使用的是spring boot2.0版本（依赖Security 5.X版本），HttpBasic不再是默认的验证模式，在spring security 5.x默认的验证模式已经是表单模式。所以我们要使用Basic模式，需要自己调整一下。并且&lt;code&gt;security.basic.enabled&lt;/code&gt;已经过时了，所以我们需要自己去编码实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
   
   @Override
   protected void configure(HttpSecurity http) throws Exception {
      http.httpBasic()//开启httpbasic认证
      .and()
      .authorizeRequests()
      .anyRequest()
      .authenticated();//所有请求都需要登录认证才能访问
   }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目，在项目后台有这样的一串日志打印，冒号后面的就是默认密码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using generated security password: 0cc59a43-c2e7-4c21-a38c-0df8d1a6d624&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过浏览器进行登录验证，默认的用户名是user.（下面的登录框不是我们开发的，是HttpBasic模式自带的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191115075459495-1492743212.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我们也可以通过application.yml指定配置用户名密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
    security:
      user:
        name: admin
        password: admin&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四httpbasic模式的原理说明&quot;&gt;四、HttpBasic模式的原理说明&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191115075459768-330565523.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，HttpBasic模式要求传输的用户名密码使用Base64模式进行加密。如果用户名是 &lt;code&gt;&quot;admin&quot;&lt;/code&gt;  ，密码是“ admin”，则将字符串&lt;code&gt;&quot;admin:admin&quot; &lt;/code&gt;使用Base64编码算法加密。加密结果可能是：YWtaW46YWRtaW4=。&lt;/li&gt;
&lt;li&gt;然后，在Http请求中使用Authorization作为一个Header，“Basic YWtaW46YWRtaW4=“作为Header的值，发送给服务端。（注意这里使用Basic+空格+加密串）&lt;/li&gt;
&lt;li&gt;服务器在收到这样的请求时，到达BasicAuthenticationFilter过滤器，将提取“ Authorization”的Header值，并使用用于验证用户身份的相同算法Base64进行解码。&lt;/li&gt;
&lt;li&gt;解码结果与登录验证的用户名密码匹配，匹配成功则可以继续过滤器后续的访问。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，HttpBasic模式真的是非常简单又简陋的验证模式，Base64的加密算法是可逆的，你知道上面的原理，分分钟就破解掉。我们完全可以使用PostMan工具，发送Http请求进行登录验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191115075500041-575554383.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Thu, 14 Nov 2019 23:55:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、HttpBasic模式的应用场景 HttpBasic登录验证模式是Spring Security实现登录验证最简单的一种方式，也可以说是最简陋的一种方式。它的目的并不是保障登录验证的绝对安全，而是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11863910.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---Elasticsearch的基本概念及工作原理 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/11863898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/11863898.html</guid>
<description>&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;Elasticsearch有几个核心的概念，花几分钟时间了解一下，有助于后面章节的学习。&lt;/p&gt;
&lt;h5 id=&quot;nrt&quot;&gt;NRT&lt;/h5&gt;
&lt;p&gt;Near Realtime，近实时，有两个层面的含义，一是从写入一条数据到这条数据可以被搜索，有一段非常小的延迟（大约1秒左右），二是基于Elasticsearch的搜索和分析操作，耗时可以达到秒级。&lt;/p&gt;
&lt;h5 id=&quot;cluster&quot;&gt;Cluster&lt;/h5&gt;
&lt;p&gt;集群，对外提供索引和搜索的服务，包含一个或多个节点，每个节点属于哪个集群是通过集群名称来决定的（默认名称是elasticsearch），集群名称搞错了后果很严重。命名建议是研发、测试环境、准生产、生产环境用不同的名称增加区分度，例如研发使用es-dev，测试使用es-test，准生产使用es-stg，生产环境使用es-pro这样的名字来区分。如果是中小型应用，集群可以只有一个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201911/1834889-20191115073615083-212168071.png&quot; alt=&quot;Elasticsearch集群结构&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;node&quot;&gt;Node&lt;/h5&gt;
&lt;p&gt;单独一个Elasticsearch服务器实例称为一个node，node是集群的一部分，每个node有独立的名称，默认是启动时获取一个UUID作为名称，也可以自行配置，node名称特别重要，Elasticsearch集群是通过node名称进行管理和通信的，一个node只能加入一个Elasticsearch集群当中，集群提供完整的数据存储，索引和搜索的功能，它下面的每个node分摊上述功能（每条数据都会索引到node上）。&lt;/p&gt;
&lt;h5 id=&quot;shard&quot;&gt;shard&lt;/h5&gt;
&lt;p&gt;分片，是单个Lucene索引，由于单台机器的存储容量是有限的（如1TB），而Elasticsearch索引的数据可能特别大（PB级别，并且30GB/天的写入量），单台机器无法存储全部数据，就需要将索引中的数据切分为多个shard，分布在多台服务器上存储。利用shard可以很好地进行横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升集群整体的吞吐量和性能。&lt;br/&gt;shard在使用时比较简单，只需要在创建索引时指定shard的数量即可，剩下的都交给Elasticsearch来完成，只是创建索引时一旦指定shard数量，后期就不能再更改了。&lt;/p&gt;
&lt;h5 id=&quot;replica&quot;&gt;replica&lt;/h5&gt;
&lt;p&gt;索引副本，完全拷贝shard的内容，shard与replica的关系可以是一对多，同一个shard可以有一个或多个replica，并且同一个shard下的replica数据完全一样，replica作为shard的数据拷贝，承担以下三个任务：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;shard故障或宕机时，其中一个replica可以升级成shard。&lt;/li&gt;
&lt;li&gt;replica保证数据不丢失（冗余机制），保证高可用。&lt;/li&gt;
&lt;li&gt;replica可以分担搜索请求，提升整个集群的吞吐量和性能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;shard的全称叫primary shard，replica全称叫replica shard，primary shard数量在创建索引时指定，后期不能修改，replica shard后期可以修改。默认每个索引的primary shard值为5，replica shard值为1，含义是5个primary shard，5个replica shard，共10个shard。&lt;br/&gt;因此Elasticsearch最小的高可用配置是2台服务器。&lt;/p&gt;
&lt;h5 id=&quot;index&quot;&gt;Index&lt;/h5&gt;
&lt;p&gt;索引，具有相同结构的文档集合，类似于关系型数据库的数据库实例（6.0.0版本type废弃后，索引的概念下降到等同于数据库表的级别）。一个集群里可以定义多个索引，如客户信息索引、商品分类索引、商品索引、订单索引、评论索引等等，分别定义自己的数据结构。&lt;br/&gt;索引命名要求全部使用小写，建立索引、搜索、更新、删除操作都需要用到索引名称。&lt;/p&gt;
&lt;h5 id=&quot;type&quot;&gt;type&lt;/h5&gt;
&lt;p&gt;类型，原本是在索引(Index)内进行的逻辑细分，但后来发现企业研发为了增强可阅读性和可维护性，制订的规范约束，同一个索引下很少还会再使用type进行逻辑拆分（如同一个索引下既有订单数据，又有评论数据），因而在6.0.0版本之后，此定义废弃。&lt;/p&gt;
&lt;h5 id=&quot;document&quot;&gt;Document&lt;/h5&gt;
&lt;p&gt;文档，Elasticsearch最小的数据存储单元，JSON数据格式，类似于关系型数据库的表记录（一行数据），结构定义多样化，同一个索引下的document，结构尽可能相同。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;简单地了解一下Elasticsearch的工作原理。&lt;/p&gt;
&lt;h5 id=&quot;启动过程&quot;&gt;启动过程&lt;/h5&gt;
&lt;p&gt;当Elasticsearch的node启动时，默认使用广播寻找集群中的其他node，并与之建立连接，如果集群已经存在，其中一个节点角色特殊一些，叫coordinate node（协调者，也叫master节点），负责管理集群node的状态，有新的node加入时，会更新集群拓扑信息。如果当前集群不存在，那么启动的node就自己成为coordinate node。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201911/1834889-20191115073615238-1620969013.png&quot; alt=&quot;node加入集群过程&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;应用程序与集群通信过程&quot;&gt;应用程序与集群通信过程&lt;/h5&gt;
&lt;p&gt;虽然Elasticsearch设置了Coordinate Node用来管理集群，但这种设置对客户端（应用程序）来说是透明的，客户端可以请求任何一个它已知的node，如果该node是集群当前的Coordinate，那么它会将请求转发到相应的Node上进行处理，如果该node不是Coordinate，那么该node会先将请求转交给Coordinate Node，再由Coordinate进行转发，搓着各node返回的数据全部交由Coordinate Node进行汇总，最后返回给客户端。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201911/1834889-20191115073615396-1105568420.png&quot; alt=&quot;应用程序与Elasticsearch集群通信过程&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;集群内node有效性检测&quot;&gt;集群内node有效性检测&lt;/h5&gt;
&lt;p&gt;正常工作时，Coordinate Node会定期与拓扑结构中的Node进行通信，检测实例是否正常工作，如果在指定的时间周期内，Node无响应，那么集群会认为该Node已经宕机。集群会重新进行均衡：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重新分配宕机的Node，其他Node中有该Node的replica shard，选出一个replica shard，升级成为primary shard。&lt;/li&gt;
&lt;li&gt;重新安置新的shard。&lt;/li&gt;
&lt;li&gt;拓扑更新，分发给该Node的请求重新映射到目前正常的Node上。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇章简单的向大家介绍了一下Elasticsearch的基本概念和工作原理，让大家有个比较浅显的认识，后续会结合实际的例子，来了解一下Elasticsearch基本的用法。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201911/1834889-20191115073615558-936563185.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 23:36:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>Elasticsearch的基本概念和工作原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/11863898.html</dc:identifier>
</item>
<item>
<title>TensorFlow2.0（10）：加载自定义图片数据集到Dataset - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11863889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11863889.html</guid>
<description>&lt;p&gt;如果你已有数据集，那么，请将所有数据存放在同一目录下，然后将不同类别的图片分门别类地存放在不同的子目录下,目录树如下所示：&lt;/p&gt;
&lt;p&gt;$ tree flower_photos -L 1&lt;/p&gt;
&lt;p&gt;flower_photos&lt;br/&gt;├── daisy&lt;br/&gt;├── dandelion&lt;br/&gt;├── LICENSE.txt&lt;br/&gt;├── roses&lt;br/&gt;├── sunflowers&lt;br/&gt;└── tulips&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 23:25:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>前面的博客中我们说过，在加载数据和预处理数据时使用tf.data.Dataset对象将极大将我们从建模前的数据清理工作中释放出来，那么，怎么将自定义的数据集加载为DataSet对象呢？这对很多新手来说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11863889.html</dc:identifier>
</item>
<item>
<title>你真的会写单测吗？TDD初体验 - 李佳霖i</title>
<link>http://www.cnblogs.com/nedulee/p/11863605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nedulee/p/11863605.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　昨天读到了一篇文章，讲的是TDD，即Test-Driven Development，测试驱动开发。大体意思是，它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。&lt;/p&gt;
&lt;p&gt;　　初读之时，瞬间感受到了震撼，感觉和自己之前的开发流程全都不一样，之前是&lt;strong&gt;由始至终&lt;/strong&gt;，而这种思想确实&lt;strong&gt;以终为始&lt;/strong&gt;。后来一查这种思想早在前几年甚至前几十年就被提出了，进而被广泛运用到了敏捷开发中。看来是自己孤落寡闻了，于是我准备将这种思想用到今后的开发中，要做的第一件事，就是温习如何写用例。&lt;/p&gt;
&lt;h2&gt;为什么是温习？&lt;/h2&gt;
&lt;p&gt;　　早在实习的时候，我们研发组就有写用例的习惯，但是随着开发逐渐熟悉，这种习惯不知不觉就被丢弃了，有页面的点点点，没页面的看逻辑。相信有很多人也像我一样，不知不觉就把这项技能丢弃了，接下来就让我们一起，去重新捡起这项技能。&lt;/p&gt;
&lt;h2&gt;工具选择&lt;/h2&gt;
&lt;h3&gt;Junit&lt;/h3&gt;
&lt;p&gt;对于一个Java开发工程师来说，一提到&lt;span&gt;写单测，我&lt;/span&gt;们最先想到的，一定是Junit。下面是maven坐标&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用Junit我们可以快速的，简洁的用注解进行单元测试。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(locations &lt;/span&gt;= &quot;classpath:conf/core/*.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ObjTest {

  @Test
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testFunc(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo test          &lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里要注意的是&lt;span&gt;@ContextConfiguration注解中的路径是Spring配置文件的位置。测试的方法必须是public的，且没有返回值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;mockito&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;mockito是一个用于模拟对象的工具，我认为他也是测试工作中必不可少的一部分，详细的介绍我推荐可以看一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;人生苦短，我用Mockito&lt;/span&gt; &lt;/span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59275373&quot;&gt;https://zhuanlan.zhihu.com/p/59275373&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较不错的入门案例，它的maven坐标地址为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mockito&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mockito-all&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.9.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Mock这种测试方法， 对比传统的Junit测试，有如下好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;不用每次测试的是时候，都初始化Spring容器，采用Mock的方式模拟对象，效率高&lt;/li&gt;
&lt;li&gt;对象间的依赖关系，可以用Mock去表达，同时，我们不关心的部分，我们都可以用Mock的方式代替（比如对象A引用对象B的某某方法，但是我们不关系对象B方法实现，只想借助方法，这个时候就可以Mock）&lt;/li&gt;
&lt;li&gt;可以应对复杂的测试环境，比如方法调用顺序、方法调用次数等等。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是Mock的一个小案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RunWith(MockitoJUnitRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MockitoTest {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * mock对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Mock
    List&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; mockedList;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUp() {
        MockitoAnnotations.initMocks(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMock() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mock对象行为&lt;/span&gt;
        Mockito.when(mockedList.get(0)).thenReturn(&quot;one&quot;&lt;span&gt;);
        Assert.assertEquals(&lt;/span&gt;&quot;one&quot;, mockedList.get(0&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 仅仅是mock了对象的行为，实际上列表还是空的&lt;/span&gt;
        Assert.assertEquals(0&lt;span&gt;, mockedList.size());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证mock对象的get方法被调用过，且调用时的参数是0&lt;/span&gt;
        Mockito.verify(mockedList).get(0&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在使用@Mock的时候，必须事先调用&lt;span&gt;MockitoAnnotations.initMocks(this)，且使用&lt;/span&gt;&lt;span&gt;@RunWith(MockitoJUnitRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Jacoco&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;JaCoCo是一个开源的覆盖率工具，支持多种覆盖率的统计，其中包括：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;行覆盖率：度量被测程序的每行代码是否被执行，判断标准行中是否至少有一个指令被执行。&lt;/li&gt;
&lt;li&gt;类覆盖率：度量计算class类文件是否被执行。&lt;/li&gt;
&lt;li&gt;分支覆盖率：度量if和switch语句的分支覆盖情况，计算一个方法里面的总分支数，确定执行和不执行的 分支数量。&lt;/li&gt;
&lt;li&gt;方法覆盖率：度量被测程序的方法执行情况，是否执行取决于方法中是否有至少一个指令被执行。&lt;/li&gt;
&lt;li&gt;指令覆盖：计数单元是单个java二进制代码指令，指令覆盖率提供了代码是否被执行的信息，度量完全 独立源码格式。&lt;/li&gt;
&lt;li&gt;圈复杂度：在（线性）组合中，计算在一个方法里面所有可能路径的最小数目，缺失的复杂度同样表示测 试案例没有完全覆盖到这个模块。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面是它的maven坐标：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mockito&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mockito-all&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.9.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们用maven插件的方式，对jacoco进行配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.jacoco&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jacoco-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.8.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com/**/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; rules裏面指定覆蓋規則 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.jacoco.maven.RuleConfiguration&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;element&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BUNDLE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;element&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;limits&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;　　
               &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定方法覆蓋到50% &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;limit &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.jacoco.report.check.Limit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;METHOD&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;COVEREDRATIO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;minimum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.50&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;minimum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定分支覆蓋到50% &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;limit &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.jacoco.report.check.Limit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BRANCH&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;COVEREDRATIO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;minimum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.50&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;minimum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定類覆蓋到100%，不能遺失任何類 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;limit &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.jacoco.report.check.Limit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;CLASS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;counter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MISSEDCOUNT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;limit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;limits&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pre-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prepare-agent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;post-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;report&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里值得注意的是&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;com/**/*&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;span&gt;指的是class文件的位置。做完这些以后，我们就可以生成报表了。因为我们是用maven插件的方式进行配置的，所以如果我们使用idea进行开发的时候，就可以看到右侧maven一栏中出现了jacoco插件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114231959013-1810145725.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最常用的就是这两个，一个是检查配置是否正确，第二个是用来将exec文件，生成index.html用来进行观察覆盖率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先执行maven中的test指令，这时，我们在target中就可以看到一个jacoco.exec文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114232626728-300259343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了这个jacoco.exec文件，就可以使用jacoco的report方法，来生成文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114232735111-1936841231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 右键index.html文件，选择Reveal in Finder（Mac），windows也是类似，打开文件磁盘的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114232813764-471087563.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114233001282-1600814342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看到，由于这个项目之前没有几个单测，所以覆盖率特别低。点开之后，就可以看到具体的代码，非常的方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114233117297-629398543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 最后今天配置jacoco的时候，踩了2个坑：&lt;/h2&gt;
&lt;p&gt;1 用idea进行开发的同学。使用jacoco的时候，不要勾选这个按钮，它会跳过你测试阶段的代码执行，进而不会生成jacoco.exec文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1245470/201911/1245470-20191114233314173-1892675594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2 保证自己测试代码没有错误（尤其是项目中，由于代码更新，测试用例没有更新，导致的测试不可用）&lt;/p&gt;
&lt;p&gt;这里的现象是虽然可以生成jacoco.exec 文件，而且可以report成文档，但是打开之后发现，代码覆盖率都是0。&lt;/p&gt;
&lt;h2&gt;最后：&lt;/h2&gt;
&lt;p&gt;希望大家都可以保持写测试用例的好习惯，谢谢&lt;/p&gt;




</description>
<pubDate>Thu, 14 Nov 2019 15:40:00 +0000</pubDate>
<dc:creator>李佳霖i</dc:creator>
<og:description>前言： 昨天读到了一篇文章，讲的是TDD，即Test-Driven Development，测试驱动开发。大体意思是，它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nedulee/p/11863605.html</dc:identifier>
</item>
<item>
<title>003.Kubernetes二进制部署准备 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/11863568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/11863568.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一 前置准备&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.1 前置条件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;相应的充足资源的Linux服务器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置相应的主机名，参考命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; hostnamectl set-hostname k8smaster&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Mac及UUID唯一；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若未关闭防火墙则建议放通相应端口，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Master节点——&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
































&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;规则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;方向&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;端口范围&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;作用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;使用者&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;6443*&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Kubernetes API server&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;All&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;2379-2380&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;etcd server client API&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;kube-apiserver, etcd&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10250&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Kubelet API&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Self, Control plane&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10251&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;kube-scheduler&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Self&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10252&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;kube-controller-manager&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Self&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Worker 节点——&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;规则&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;方向&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;端口范围&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;作用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;使用者&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10250&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Kubelet API&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Self, Control plane&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Inbound&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;30000-32767&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;NodePort Services**&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;All&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;span&gt;其他更多前置准备见：&lt;a href=&quot;https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/&quot;&gt;https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/&lt;/a&gt;&lt;/span&gt;
&lt;h2&gt;二 主要组件&lt;/h2&gt;
&lt;h3&gt;2.1 核心组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;etcd：保存了整个集群的状态；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;controller manager：负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scheduler：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;kubelet：负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Container runtime：负责镜像管理以及Pod和容器的真正运行（CRI）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;kube-proxy：负责为Service提供cluster内部的服务发现和负载均衡。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.2 非核心组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;kube-dns：负责为整个集群提供DNS服务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Ingress Controller：为服务提供外网入口；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Heapster：提供资源监控；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Dashboard：提供GUI；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Federation：集群联邦提供跨可用区的集群；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Fluentd-elasticsearch：提供集群日志采集、存储与查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;延伸1：对master节点服务组件的理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191114232816283-2008092213.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;1489&quot; height=&quot;1226&quot; title=&quot;2018030821&quot; alt=&quot;2018030821&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191114232816498-1354372594.png&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Master节点上面主要由四个模块组成：APIServer，schedule,controller-manager,etcd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APIServer: APIServer负责对外提供RESTful的kubernetes API的服务，它是系统管理指令的统一接口，任何对资源的增删该查都要交给APIServer处理后再交给etcd，如架构图中所示，kubectl（Kubernetes提供的客户端工具，该工具内部就是对Kubernetes API的调用）是直接和APIServer交互的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;schedule: schedule负责调度Pod到合适的Node上，如果把scheduler看成一个黑匣子，那么它的输入是pod和由多个Node组成的列表，输出是Pod和一个Node的绑定,即将这个pod部署到这个Node上。Kubernetes目前提供了调度算法，但是同样也保留了接口，用户可以根据自己的需求定义自己的调度算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;controller manager: 如果APIServer做的是前台的工作的话，那么controller manager就是负责后台的。每一个资源都对应一个控制器。而control manager就是负责管理这些控制器的，比如我们通过APIServer创建了一个Pod，当这个Pod创建成功后，APIServer的任务就算完成了。而后面保证Pod的状态始终和我们预期的一样的重任就由controller manager去保证了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;etcd：etcd是一个高可用的键值存储系统，kubernetes使用它来存储各个资源的状态，从而实现了Restful的API。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;延伸2：对master节点服务组件的理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个Node节点主要由三个模板组成：kubelet、kube-proxy、runtime。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;runtime：runtime指的是容器运行环境，目前Kubernetes支持docker和rkt两种容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kube-proxy: 该模块实现了kubernetes中的服务发现和反向代理功能。kube-proxy支持TCP和UDP连接转发，默认基于Round Robin算法将客户端流量转发到与service对应的一组后端pod。服务发现方面，kube-proxy使用etcd的watch机制,监控集群中service和endpoint对象数据的动态变化，并且维护一个service到endpoint的映射关系，从而保证了后端pod的IP变化不会对访问者造成影响。另外，kube-proxy还支持session affinity。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kublet：kublet是Master在每个Node节点上面的agent，是Node节点上面最重要的模块，它负责维护和管理该Node上的所有容器，但是如果容器不是通过kubernetes创建的，它并不会管理。本质上，它负责使Pod的运行状态与期望的状态一致。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三 部署规划&lt;/h2&gt;
&lt;h3&gt;3.1 节点规划&lt;/h3&gt;
&lt;div yne-bulb-block=&quot;table&quot;&gt;

&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;92&quot;/&gt;&lt;col width=&quot;108&quot;/&gt;&lt;col width=&quot;162&quot;/&gt;&lt;col width=&quot;314&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-0-1&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-0-2&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-0-3&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;运行服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;k8smaster01&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;172.24.8.71&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kubernetes master节点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-1-3&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、kubectl、kubelet、kube-nginx、flannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;k8smaster02&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;172.24.8.72&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kubernetes master节点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-2-3&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、kubectl、&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;kubelet、kube-nginx、flannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;k8smaster03&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;172.24.8.73&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-3-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kubernetes master节点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-3-3&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、kubectl、&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;kubelet、kube-nginx、flannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;k8snode01&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-4-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;172.24.8.74&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-4-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kubernetes node节点1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-4-3&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker、etcd、kubelet、proxy、flannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-5-0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;k8snode03&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-5-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;172.24.8.75&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-5-2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kubernetes node节点2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;5539-1561296937448-cell-5-3&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;docker、etcd、kubelet、proxy、flannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;提示：本实验使用三节点master部署，从而实现master的高可用。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 组件及版本&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Kubernetes 1.14.2&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Docker 18.09.6-ce&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Etcd 3.3.13&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Flanneld 0.11.0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;插件：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Coredns&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Dashboard&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Metrics-server&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;EFK (elasticsearch、fluentd、kibana)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;镜像仓库：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;docker registry&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;harbor&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;3.3 组件策略&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;kube-apiserver：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用节点本地 nginx 4 层透明代理实现高可用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;关闭非安全端口 8080 和匿名访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在安全端口 6443 接收 https 请求；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;严格的认证和授权策略 (x509、token、RBAC)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开启 bootstrap token 认证，支持 kubelet TLS bootstrapping；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 https 访问 kubelet、etcd，加密通信；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;kube-controller-manager：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;3 节点高可用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;关闭非安全端口，在安全端口 10252 接收 https 请求；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 kubeconfig 访问 apiserver 的安全端口；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动 approve kubelet 证书签名请求 (CSR)，证书过期后自动轮转；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;各 controller 使用自己的 ServiceAccount 访问 apiserver；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;kube-scheduler：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;3 节点高可用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 kubeconfig 访问 apiserver 的安全端口；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;kubelet：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用 kubeadm 动态创建 bootstrap token，而不是在 apiserver 中静态配置；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 TLS bootstrap 机制自动生成 client 和 server 证书，过期后自动轮转；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在 KubeletConfiguration 类型的 JSON 文件配置主要参数；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;关闭只读端口，在安全端口 10250 接收 https 请求，对请求进行认证和授权，拒绝匿名访问和非授权访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 kubeconfig 访问 apiserver 的安全端口；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;kube-proxy：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用 kubeconfig 访问 apiserver 的安全端口；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在 KubeProxyConfiguration 类型的 JSON 文件配置主要参数；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 ipvs 代理模式；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;集群插件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;DNS：使用功能、性能更好的 coredns；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Dashboard：支持登录认证；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Metric：metrics-server，使用 https 访问 kubelet 安全端口；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Log：Elasticsearch、Fluend、Kibana；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Registry 镜像库：docker-registry、harbor。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;四 其他准备&lt;/h2&gt;
&lt;h3&gt;4.1 手动添加解析&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：以下4.1至4.7步骤可通过如下脚本快速实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# vi k8sinit.sh
&lt;span&gt;  2&lt;/span&gt; # Modify Author: xhy
&lt;span&gt;  3&lt;/span&gt; # Modify Date: 2019-06-23 22:19
&lt;span&gt;  4&lt;/span&gt; # Version:
&lt;span&gt;  5&lt;/span&gt; #***************************************************************#
&lt;span&gt;  6&lt;/span&gt; # Initialize the machine. This needs to be executed on every machine.
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; # Add host domain name.
&lt;span&gt;  9&lt;/span&gt; cat &amp;gt;&amp;gt; /etc/hosts &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; EOF
&lt;span&gt; 10&lt;/span&gt; 172.24.8.71 k8smaster01
&lt;span&gt; 11&lt;/span&gt; 172.24.8.72 k8smaster02
&lt;span&gt; 12&lt;/span&gt; 172.24.8.73 k8smaster03
&lt;span&gt; 13&lt;/span&gt; 172.24.8.74 k8snode01
&lt;span&gt; 14&lt;/span&gt; 172.24.8.75 k8snode02
&lt;span&gt; 15&lt;/span&gt; EOF
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; # Add docker user
&lt;span&gt; 18&lt;/span&gt; useradd -m docker
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt; # Disable the SELinux.
&lt;span&gt; 21&lt;/span&gt; sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; # Turn off and disable the firewalld.
&lt;span&gt; 24&lt;/span&gt; systemctl stop firewalld
&lt;span&gt; 25&lt;/span&gt; systemctl disable firewalld
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; # Modify related kernel parameters &amp;amp; Disable the swap.
&lt;span&gt; 28&lt;/span&gt; cat &lt;span&gt;&amp;gt;&lt;/span&gt; /etc/sysctl.d/k8s.conf &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; EOF
&lt;span&gt; 29&lt;/span&gt; net.ipv4.ip_forward = 1
&lt;span&gt; 30&lt;/span&gt; net.bridge.bridge-nf-call-ip6tables = 1
&lt;span&gt; 31&lt;/span&gt; net.bridge.bridge-nf-call-iptables = 1
&lt;span&gt; 32&lt;/span&gt; net.ipv4.tcp_tw_recycle = 0
&lt;span&gt; 33&lt;/span&gt; vm.swappiness = 0
&lt;span&gt; 34&lt;/span&gt; vm.overcommit_memory = 1
&lt;span&gt; 35&lt;/span&gt; vm.panic_on_oom = 0
&lt;span&gt; 36&lt;/span&gt; net.ipv6.conf.all.disable_ipv6 = 1
&lt;span&gt; 37&lt;/span&gt; EOF
&lt;span&gt; 38&lt;/span&gt; sysctl -p /etc/sysctl.d/k8s.conf &lt;span&gt;&amp;gt;&lt;/span&gt;&amp;amp;/dev/null
&lt;span&gt; 39&lt;/span&gt; swapoff -a
&lt;span&gt; 40&lt;/span&gt; sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
&lt;span&gt; 41&lt;/span&gt; modprobe br_netfilter
&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; # Add ipvs modules
&lt;span&gt; 44&lt;/span&gt; cat &amp;gt; /etc/sysconfig/modules/ipvs.modules &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;#!/bin/bash
 46 modprobe -- ip_vs
 47 modprobe -- ip_vs_rr
 48 modprobe -- ip_vs_wrr
 49 modprobe -- ip_vs_sh
 50 modprobe -- nf_conntrack_ipv4
 51 EOF
 52 chmod 755 /etc/sysconfig/modules/ipvs.modules
 53 bash /etc/sysconfig/modules/ipvs.modules
 54 
 55 # Install rpm
 56 yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget
 57 
 58 # Create k8s directory $$ Add system PATH
 59 mkdir -p  /opt/k8s/{bin,work} /etc/{kubernetes,etcd}/cert
 60 echo 'PATH=/opt/k8s/bin:$PATH' &amp;gt;&amp;gt;/root/.bashrc
 61 source /root/.bashrc
 62 
 63 # Reboot the machine.
 64 reboot&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cat &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&amp;gt; /etc/hosts
&lt;span&gt;  2&lt;/span&gt; 172.24.8.71 k8smaster01
&lt;span&gt;  3&lt;/span&gt; 172.24.8.72 k8smaster02
&lt;span&gt;  4&lt;/span&gt; 172.24.8.73 k8smaster03
&lt;span&gt;  5&lt;/span&gt; 172.24.8.74 k8snode01
&lt;span&gt;  6&lt;/span&gt; 172.24.8.75 k8snode02
&lt;span&gt;  7&lt;/span&gt; EOF
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：所有节点均建议如上操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2 添加docker账户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# useradd -m docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：所有节点均建议如上操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.3 关闭SELinux&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# setenforce 0
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.4 修正iptables&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# systemctl stop firewalld
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# systemctl disable firewalld                     #关闭防火墙
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 ~]# cat &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&amp;gt; /etc/sysctl.d/k8s.conf
&lt;span&gt;  4&lt;/span&gt; net.bridge.bridge-nf-call-ip6tables = 1
&lt;span&gt;  5&lt;/span&gt; net.bridge.bridge-nf-call-iptables = 1
&lt;span&gt;  6&lt;/span&gt; net.ipv4.ip_forward = 1
&lt;span&gt;  7&lt;/span&gt; EOF
&lt;span&gt;  8&lt;/span&gt; [root@k8smaster01 ~]# modprobe br_netfilter
&lt;span&gt;  9&lt;/span&gt; [root@k8smaster01 ~]# sysctl -p /etc/sysctl.d/k8s.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：所有节点均建议如上操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.5 关闭swap&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# echo &quot;vm.swappiness = 0&quot; &amp;gt;&amp;gt; /etc/sysctl.d/k8s.conf        #禁止使用 swap 空间，只有当系统 OOM 时才允许使用它
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 ~]# sysctl -p /etc/sysctl.d/k8s.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.6 其他调整&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cat &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&amp;gt; /etc/sysctl.d/k8s.conf
&lt;span&gt;  2&lt;/span&gt; vm.overcommit_memory = 1                                              # 不检查物理内存是否够用
&lt;span&gt;  3&lt;/span&gt; vm.panic_on_oom = 0                                                   # 开启 OOM
&lt;span&gt;  4&lt;/span&gt; net.ipv6.conf.all.disable_ipv6 = 1                                    # 关闭 IPV6
&lt;span&gt;  5&lt;/span&gt; EOF
&lt;span&gt;  6&lt;/span&gt; [root@k8smaster01 ~]# sysctl -p /etc/sysctl.d/k8s.conf
&lt;span&gt;  7&lt;/span&gt; [root@k8smaster01 ~]# mkdir -p  /opt/k8s/{bin,work} /etc/{kubernetes,etcd}/cert       #创建相应目录
&lt;span&gt;  8&lt;/span&gt; [root@k8smaster01 ~]# yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：必须关闭 tcp_tw_recycle，否则和 NAT 冲突，会导致服务不通；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关闭 IPV6，防止触发 docker BUG。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.7 加载IPVS&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;pod的负载均衡是用kube-proxy来实现的，实现方式有两种，一种是默认的iptables，一种是ipvs，相对iptables，ipvs有更好的性能。且当前ipvs已经加入到了内核的主干。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为kube-proxy开启ipvs的前提需要加载以下的内核模块：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ip_vs&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ip_vs_rr&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ip_vs_wrr&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ip_vs_sh&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;nf_conntrack_ipv4&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# cat &amp;gt; /etc/sysconfig/modules/ipvs.modules &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#!/bin/bash
  3 modprobe -- ip_vs
  4 modprobe -- ip_vs_rr
  5 modprobe -- ip_vs_wrr
  6 modprobe -- ip_vs_sh
  7 modprobe -- nf_conntrack_ipv4
  8 EOF
  9 [root@k8smaster01 ~]# chmod 755 /etc/sysconfig/modules/ipvs.modules
 10 [root@k8smaster01 ~]# bash /etc/sysconfig/modules/ipvs.modules
 11 [root@k8smaster01 ~]# lsmod | grep -e ip_vs -e nf_conntrack_ipv4
 12 [root@k8smaster01 ~]# yum -y install ipvsadm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191114232816727-1539822487.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;645&quot; height=&quot;343&quot; title=&quot;clipboard&quot; alt=&quot;clipboard&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201911/680719-20191114232816877-1920166872.png&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：所有节点均建议如上操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了更好的管理和查看ipvs，可安装相应的管理工具《002.LVS管理工具的安装与使用》。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;五 环境准备&lt;/h2&gt;
&lt;h3&gt;5.1 配置免秘钥&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了更方便远程分发文件和执行命令，本实验配置master节点到其它节点的 ssh 信任关系。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# ssh-keygen -f ~/.ssh/id_rsa -N ''
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8smaster01
&lt;span&gt;  3&lt;/span&gt; [root@k8smaster01 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8smaster02
&lt;span&gt;  4&lt;/span&gt; [root@k8smaster01 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8smaster03
&lt;span&gt;  5&lt;/span&gt; [root@k8smaster01 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8snode01
&lt;span&gt;  6&lt;/span&gt; [root@k8smaster01 ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@k8snode02
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：此操作仅需要在master节点操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.2 分发集群配置参数脚本&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;后续使用的环境变量都定义在文件 environment.sh 中，同时拷贝到所有节点的 /opt/k8s/bin 目录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #!/usr/bin/bash
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; # 生成 EncryptionConfig 所需的加密 key
&lt;span&gt;  4&lt;/span&gt; export ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; # 集群 MASTER 机器 IP 数组
&lt;span&gt;  7&lt;/span&gt; export MASTER_IPS=(172.24.8.71 172.24.8.72 172.24.8.73)
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; # 集群 MASTER IP 对应的主机名数组
&lt;span&gt; 10&lt;/span&gt; export MASTER_NAMES=(k8smaster01 k8smaster02 k8smaster03)
&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; # 集群 NODE 机器 IP 数组
&lt;span&gt; 13&lt;/span&gt; export NODE_IPS=(172.24.8.74 172.24.8.75)
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; # 集群 NODE IP 对应的主机名数组
&lt;span&gt; 16&lt;/span&gt; export NODE_NAMES=(k8snode01 k8snode02)
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; # 集群所有机器 IP 数组
&lt;span&gt; 19&lt;/span&gt; export ALL_IPS=(172.24.8.71 172.24.8.72 172.24.8.73 172.24.8.74 172.24.8.75)
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; # 集群所有IP 对应的主机名数组
&lt;span&gt; 22&lt;/span&gt; export ALL_NAMES=(k8smaster01 k8smaster02 k8smaster03 k8snode01 k8snode02)
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; # etcd 集群服务地址列表
&lt;span&gt; 25&lt;/span&gt; export ETCD_ENDPOINTS=&quot;https://172.24.8.71:2379,https://172.24.8.72:2379,https://172.24.8.73:2379&quot;
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; # etcd 集群间通信的 IP 和端口
&lt;span&gt; 28&lt;/span&gt; export ETCD_NODES=&quot;k8smaster01=https://172.24.8.71:2380,k8smaster02=https://172.24.8.72:2380,k8smaster03=https://172.24.8.73:2380&quot;
&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; # kube-apiserver 的反向代理(kube-nginx)地址端口
&lt;span&gt; 31&lt;/span&gt; export KUBE_APISERVER=&quot;https://127.0.0.1:8443&quot;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; # 节点间互联网络接口名称
&lt;span&gt; 34&lt;/span&gt; export IFACE=&quot;eth0&quot;
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; # etcd 数据目录
&lt;span&gt; 37&lt;/span&gt; export ETCD_DATA_DIR=&quot;/data/k8s/etcd/data&quot;
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; # etcd WAL 目录，建议是 SSD 磁盘分区，或者和 ETCD_DATA_DIR 不同的磁盘分区
&lt;span&gt; 40&lt;/span&gt; export ETCD_WAL_DIR=&quot;/data/k8s/etcd/wal&quot;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; # k8s 各组件数据目录
&lt;span&gt; 43&lt;/span&gt; export K8S_DIR=&quot;/data/k8s/k8s&quot;
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; # docker 数据目录
&lt;span&gt; 46&lt;/span&gt; export DOCKER_DIR=&quot;/data/k8s/docker&quot;
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; ## 以下参数一般不需要修改
&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; # TLS Bootstrapping 使用的 Token，可以使用命令 head -c 16 /dev/urandom | od -An -t x | tr -d ' ' 生成
&lt;span&gt; 51&lt;/span&gt; BOOTSTRAP_TOKEN=&quot;41f7e4ba8b7be874fcff18bf5cf41a7c&quot;
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; # 最好使用 当前未用的网段 来定义服务网段和 Pod 网段
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; # 服务网段，部署前路由不可达，部署后集群内路由可达(kube-proxy 保证)
&lt;span&gt; 56&lt;/span&gt; SERVICE_CIDR=&quot;10.254.0.0/16&quot;
&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; # Pod 网段，建议 /16 段地址，部署前路由不可达，部署后集群内路由可达(flanneld 保证)
&lt;span&gt; 59&lt;/span&gt; CLUSTER_CIDR=&quot;172.30.0.0/16&quot;
&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; # 服务端口范围 (NodePort Range)
&lt;span&gt; 62&lt;/span&gt; export NODE_PORT_RANGE=&quot;30000-32767&quot;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; # flanneld 网络配置前缀
&lt;span&gt; 65&lt;/span&gt; export FLANNEL_ETCD_PREFIX=&quot;/kubernetes/network&quot;
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; # kubernetes 服务 IP (一般是 SERVICE_CIDR 中第一个IP)
&lt;span&gt; 68&lt;/span&gt; export CLUSTER_KUBERNETES_SVC_IP=&quot;10.254.0.1&quot;
&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt; # 集群 DNS 服务 IP (从 SERVICE_CIDR 中预分配)
&lt;span&gt; 71&lt;/span&gt; export CLUSTER_DNS_SVC_IP=&quot;10.254.0.2&quot;
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; # 集群 DNS 域名（末尾不带点号）
&lt;span&gt; 74&lt;/span&gt; export CLUSTER_DNS_DOMAIN=&quot;cluster.local&quot;
&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; # 将二进制目录 /opt/k8s/bin 加到 PATH 中
&lt;span&gt; 77&lt;/span&gt; export PATH=/opt/k8s/bin:$PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@k8smaster01 ~]# source environment.sh
&lt;span&gt;  2&lt;/span&gt; [root@k8smaster01 ~]# for all_ip in ${ALL_IPS[@]}
&lt;span&gt;  3&lt;/span&gt;   do
&lt;span&gt;  4&lt;/span&gt;     echo &quot;&amp;gt;&amp;gt;&amp;gt; ${all_ip}&quot;
&lt;span&gt;  5&lt;/span&gt;     scp environment.sh root@${all_ip}:/opt/k8s/bin/
&lt;span&gt;  6&lt;/span&gt;     ssh root@${all_ip} &quot;chmod +x /opt/k8s/bin/*&quot;
&lt;span&gt;  7&lt;/span&gt;   done
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 14 Nov 2019 15:28:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 前置准备1.1 前置条件相应的充足资源的Linux服务器；设置相应的主机名，参考命令： 1 hostnamectl set-hostname k8smaster Mac及UUID唯一；若未关闭防火</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itzgr/p/11863568.html</dc:identifier>
</item>
<item>
<title>Abp vNext 自定义 Ef Core 仓储引发异常 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/11863489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/11863489.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;在使用自定义 Ef Core 仓储和 ABP vNext 注入的默认仓储时，通过两个 Repository 进行 Join 操作，提示 &lt;code&gt;Cannot use multiple DbContext instances within a single query execution. Ensure the query uses a single context instance.&lt;/code&gt; 。这个异常信息翻译成中文的大概意思就是，你不能使用两个 DbContext 里面的 DbSet 进行 Join 查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201911/1203160-20191114231236630-581114442.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201911/1203160-20191114231245823-1868362110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果将自定义仓储改为 &lt;code&gt;IRepository&amp;lt;TEntity,TKey&amp;gt;&lt;/code&gt; 进行注入，是可以与 &lt;code&gt;_courseRepostory&lt;/code&gt; 进行关联查询的。&lt;/p&gt;
&lt;p&gt;我在 &lt;code&gt;XXXEntityFrameworkCoreModule&lt;/code&gt; 的配置，以及自定义仓储 &lt;code&gt;EfCoreStudentRepository&lt;/code&gt; 代码如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;XXXEntityFrameworkCoreModule&lt;/code&gt;&lt;/strong&gt; 代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class XXXEntityFrameworkCoreModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        context.Services.AddAbpDbContext&amp;lt;XXXDbContext&amp;gt;(op =&amp;gt;
        {
            op.AddDefaultRepositories();
        });
        
        Configure&amp;lt;AbpDbContextOptions&amp;gt;(op =&amp;gt; op.UsePostgreSql());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;EfCoreStudentRepository&lt;/code&gt;&lt;/strong&gt; 代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class EfCoreStudentRepository : EfCoreRepository&amp;lt;IXXXDbContext, Student, long&amp;gt;, IStudentRepository
{
    public EfCoreStudentRepository(IDbContextProvider&amp;lt;IXXXDbContext&amp;gt; dbContextProvider) : base(dbContextProvider)
    {
    }

    public Task&amp;lt;int&amp;gt; GetCountWithStudentlIdAsync(long studentId)
    {
        return DbSet.CountAsync(x=&amp;gt;x.studentId == studentId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;原因在异常信息已经说得十分清楚了，这里我们需要了解两个问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么原因导致两个仓储内部的 DbContext 不一致？&lt;/li&gt;
&lt;li&gt;为什么 ABP vNext 自己实现的仓储能够进行关联查询呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先我们得知道，仓储内部的 &lt;code&gt;DbContext&lt;/code&gt;是怎么获取的。我们的自定义仓储都会继承 &lt;code&gt;EfCoreRepository&lt;/code&gt; ，而这个仓储是实现了 &lt;code&gt;IQuerable&amp;lt;T&amp;gt;&lt;/code&gt; 接口的，最终它会通过一个 &lt;code&gt;IDbContextProvider&amp;lt;TDbContext&amp;gt;&lt;/code&gt; 获得一个可用的 &lt;code&gt;DbContext&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class EfCoreRepository&amp;lt;TDbContext, TEntity&amp;gt; : RepositoryBase&amp;lt;TEntity&amp;gt;, IEfCoreRepository&amp;lt;TEntity&amp;gt;
    where TDbContext : IEfCoreDbContext
    where TEntity : class, IEntity
{
    public virtual DbSet&amp;lt;TEntity&amp;gt; DbSet =&amp;gt; DbContext.Set&amp;lt;TEntity&amp;gt;();

    DbContext IEfCoreRepository&amp;lt;TEntity&amp;gt;.DbContext =&amp;gt; DbContext.As&amp;lt;DbContext&amp;gt;();

    // 这里可以看到，是通过 IDbContextProvider 来获得 DbContext 的。
    protected virtual TDbContext DbContext =&amp;gt; _dbContextProvider.GetDbContext();

    protected virtual AbpEntityOptions&amp;lt;TEntity&amp;gt; AbpEntityOptions =&amp;gt; _entityOptionsLazy.Value;

    private readonly IDbContextProvider&amp;lt;TDbContext&amp;gt; _dbContextProvider;
    private readonly Lazy&amp;lt;AbpEntityOptions&amp;lt;TEntity&amp;gt;&amp;gt; _entityOptionsLazy;

    // ... 其他代码。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是 &lt;code&gt;IDbContextProvider&amp;lt;TDbContext&amp;gt;&lt;/code&gt; 内部的核心代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class UnitOfWorkDbContextProvider&amp;lt;TDbContext&amp;gt; : IDbContextProvider&amp;lt;TDbContext&amp;gt; where TDbContext : IEfCoreDbContext
{
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    private readonly IConnectionStringResolver _connectionStringResolver;

    // ... 其他代码。

    public TDbContext GetDbContext()
    {
        var unitOfWork = _unitOfWorkManager.Current;
        if (unitOfWork == null)
        {
            throw new AbpException(&quot;A DbContext can only be created inside a unit of work!&quot;);
        }

        var connectionStringName = ConnectionStringNameAttribute.GetConnStringName&amp;lt;TDbContext&amp;gt;();
        var connectionString = _connectionStringResolver.Resolve(connectionStringName);

        // 会构造一个 Key，而这个 Key 刚好是泛型类型的 FullName。
        var dbContextKey = $&quot;{typeof(TDbContext).FullName}_{connectionString}&quot;;

        // 内部是从一个字典当中，根据 dbContextKey 获取 DbContext。如果不存在的话则调用工厂方法创建一个新的 DbContext。
        var databaseApi = unitOfWork.GetOrAddDatabaseApi(
            dbContextKey,
            () =&amp;gt; new EfCoreDatabaseApi&amp;lt;TDbContext&amp;gt;(
                CreateDbContext(unitOfWork, connectionStringName, connectionString)
            ));

        return ((EfCoreDatabaseApi&amp;lt;TDbContext&amp;gt;)databaseApi).DbContext;
    }

    // ... 其他代码。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上代码我们就可以知道，ABP vNext 在仓储的内部是通过 &lt;code&gt;IDbContextProvider&amp;lt;TDbContext&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;TDbContext&lt;/code&gt; 泛型，来确定是否构建一个新的 &lt;code&gt;DbContext&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;不论是 ABP vNext 针对 &lt;code&gt;IRepository&amp;lt;TEntity,TKey&amp;gt;&lt;/code&gt; ，还是我们自己实现的自定义仓储，它们最终的实现都是基于 &lt;code&gt;EfCoreRepository&amp;lt;TDbContext,TEntity,TKey&amp;gt;&lt;/code&gt; 的。而我们 &lt;code&gt;IDbContextProvider&amp;lt;TDbContext&amp;gt;&lt;/code&gt; 的泛型，也是这个仓储基类提供的，后者的 &lt;code&gt;TDbContext&lt;/code&gt; 就是前者的泛型参数。&lt;/p&gt;
&lt;p&gt;所以当我们在模块添加 &lt;code&gt;DbContext&lt;/code&gt; 的过城中，只要调用了 &lt;code&gt;AddDefaultRepositories()&lt;/code&gt; 方法，ABP vNext 就会遍历你提供的 &lt;code&gt;TDbContext&lt;/code&gt; 所定义的实体，然后为这些实体建立默认的仓储。&lt;/p&gt;
&lt;p&gt;在注入仓储的时候，找到了获得默认仓储实现类型的方法，可以看到这里它使用的是 &lt;code&gt;DefaultRepositoryDbContextType&lt;/code&gt; 作为默认的 &lt;code&gt;TDbContext&lt;/code&gt; 类型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected virtual Type GetDefaultRepositoryImplementationType(Type entityType)
{
    var primaryKeyType = EntityHelper.FindPrimaryKeyType(entityType);

    // 重点在于构造仓储类型时，传递的 Options.DefaultRepositoryDbContextType 参数，这个参数就是后面 EfCoreRepository 的 TDbContext 泛型。
    if (primaryKeyType == null)
    {
        return Options.SpecifiedDefaultRepositoryTypes
            ? Options.DefaultRepositoryImplementationTypeWithoutKey.MakeGenericType(entityType)
            : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType);
    }

    return Options.SpecifiedDefaultRepositoryTypes
        ? Options.DefaultRepositoryImplementationType.MakeGenericType(entityType, primaryKeyType)
        : GetRepositoryType(Options.DefaultRepositoryDbContextType, entityType, primaryKeyType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我发现这个就是在模块调用 &lt;code&gt;AddAbpContext&amp;lt;TDbContext&amp;gt;&lt;/code&gt; 所提供的泛型参数。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class AbpCommonDbContextRegistrationOptions : IAbpCommonDbContextRegistrationOptionsBuilder
{
    // ... 其他代码

    protected AbpCommonDbContextRegistrationOptions(Type originalDbContextType, IServiceCollection services)
    {
        OriginalDbContextType = originalDbContextType;
        Services = services;
        DefaultRepositoryDbContextType = originalDbContextType;
        CustomRepositories = new Dictionary&amp;lt;Type, Type&amp;gt;();
        ReplacedDbContextTypes = new List&amp;lt;Type&amp;gt;();
    }

    // ... 其他代码
}

public class AbpDbContextRegistrationOptions : AbpCommonDbContextRegistrationOptions, IAbpDbContextRegistrationOptionsBuilder
{
    public Dictionary&amp;lt;Type, object&amp;gt; AbpEntityOptions { get; }

    public AbpDbContextRegistrationOptions(Type originalDbContextType, IServiceCollection services)
        : base(originalDbContextType, services) // 之类调用的就是上面的构造方法。
    {
        AbpEntityOptions = new Dictionary&amp;lt;Type, object&amp;gt;();
    }
}

public static class AbpEfCoreServiceCollectionExtensions
{
    public static IServiceCollection AddAbpDbContext&amp;lt;TDbContext&amp;gt;(
        this IServiceCollection services, 
        Action&amp;lt;IAbpDbContextRegistrationOptionsBuilder&amp;gt; optionsBuilder = null)
        where TDbContext : AbpDbContext&amp;lt;TDbContext&amp;gt;
    {
        // ... 其他代码。
        
        var options = new AbpDbContextRegistrationOptions(typeof(TDbContext), services);

        // ... 其他代码。

        return services;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们的默认仓储的 &lt;code&gt;dbContextKey&lt;/code&gt; 是 &lt;code&gt;XXXDbContext&lt;/code&gt;，我们的自定义仓储继承 &lt;code&gt;EfCoreRepository&amp;lt;IXXXDbContext,TEntity,TKey&amp;gt;&lt;/code&gt; ，所以它的 &lt;code&gt;dbContextKey&lt;/code&gt; 就是 &lt;code&gt;IXXXDbContext&lt;/code&gt; 。所以自定义仓储获取到的 &lt;code&gt;DbContext&lt;/code&gt; 就与自定义仓储的不一致了，从而提示上述异常。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;p&gt;找到自定自定义仓储的定义，修改它 &lt;code&gt;EfCoreReposiotry&amp;lt;TDbContext,TEntity,TKey&amp;gt;&lt;/code&gt; 的 &lt;code&gt;TDbContext&lt;/code&gt; 泛型参数，变更为 &lt;code&gt;XXXDbContext&lt;/code&gt; 即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class EfCoreStudentRepository : EfCoreRepository&amp;lt;XXXDbContext, Student, long&amp;gt;, IStudentRepository
{
    public EfCoreStudentRepository(IDbContextProvider&amp;lt;XXXDbContext&amp;gt; dbContextProvider) : base(dbContextProvider)
    {
    }

    public Task&amp;lt;int&amp;gt; GetCountWithStudentlIdAsync(long studentId)
    {
        return DbSet.CountAsync(x=&amp;gt;x.studentId == studentId);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Nov 2019 15:14:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>问题 在使用自定义 Ef Core 仓储和 ABP vNext 注入的默认仓储时，通过两个 Repository 进行 Join 操作，提示 。这个异常信息翻译成中文的大概意思就是，你不能使用两个 D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myzony/p/11863489.html</dc:identifier>
</item>
<item>
<title>MySQL系列：一句SQL，MySQL是怎么工作的？ - 杨小格子</title>
<link>http://www.cnblogs.com/imyanger/p/11863293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyanger/p/11863293.html</guid>
<description>&lt;p&gt;对于MySQL而言，其实分为客户端与服务端。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务端，就是MySQL应用，当我们使用net start mysql命令启动的服务，其实就是启动了MySQL的服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;客户端，负责发送请求到服务端并从服务端获取数据，客户端可以有多种形式，可以是我们通过mysql -uroot -p1234打开的黑窗口，也可以是我们使用的Nativecat、SQLyog等数据库连接工具，甚至我们的程序，也可以称作MySQL的客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而当我们在mysql窗口或者数据库连接工具中输入一句sql后，我们就可以获取到想要的数据，这中间MySQL到底是怎么工作的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191114225431130-1292591758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我们执行SQL后，例如一句简单的select * from user where name = ‘yanger’，客户端发送请求到服务端，请求到达Server层，会经过连接器、查询缓存、分析器、优化器、执行器等，最终通过存储引擎从文件系统获取数据或者插入数据到文件系统。&lt;/p&gt;
&lt;h4 id=&quot;连接器&quot;&gt;连接器&lt;/h4&gt;
&lt;p&gt;在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。&lt;/p&gt;
&lt;p&gt;连接命令大家都比较熟悉。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mysql -h$ip -P$port -u$user -p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输完命令之后，需要继续输入密码，密码也可以直接跟在 -p 后面，但这样可能会导致你的密码泄露，如果你连的是生产服务器，强烈建议你不要这么做。&lt;/p&gt;
&lt;p&gt;MySQL采用TCP作为服务器和客户端之间的网络通信协议，完成 TCP 握手后，连接器主要做密码校验和权限获取。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果用户名或密码不对，你就会收到一个&quot;Access denied for user&quot;的错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL的默认连接是8小时，由参数 wait_timeout 控制的，如果超过这个时间不使用，会自动断开，并在之后的操作中，抛出Lost connection to MySQL server during query的错误。&lt;/p&gt;
&lt;h4 id=&quot;查询缓存&quot;&gt;查询缓存&lt;/h4&gt;
&lt;p&gt;针对于查询语句，MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。如果命中缓存，将直接返回结果。如果不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。&lt;/p&gt;
&lt;p&gt;针对于更新语句，包含插入删除语句，MySQL 收到更新请求时，会把查询缓存中该表相关的缓存数据全部清空。&lt;/p&gt;
&lt;p&gt;我们可以看到，只要有更新，缓存就会失效，而对于正常的业务，更新其实是比较频繁的，也就是说，其实MySQL的查询缓存命中率并不会很高，所以建议一般不到开启。&lt;/p&gt;
&lt;p&gt;可以通过设置 query_cache_type 为 DEMAND 来关闭查询缓存功能。而事实上，在 MySQL 8.0 版本，更是直接移除了查询缓存这一个功能。&lt;/p&gt;
&lt;h4 id=&quot;分析器&quot;&gt;分析器&lt;/h4&gt;
&lt;p&gt;MySQL 首先需要对SQL语句进行分析，分析过程本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，通过分析MySQL知道自己要做什么。&lt;/p&gt;
&lt;p&gt;如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191114225431429-1401960647.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优化器&quot;&gt;优化器&lt;/h4&gt;
&lt;p&gt;面对分析器拿到的结果，MySQL会做一些优化处理，例如在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。&lt;/p&gt;
&lt;p&gt;优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用EXPLAIN语句来查看某个语句的执行计划。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191114225431601-1879759159.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里\G在命令窗口无法一行时，可以竖着展示结果，方便查看。&lt;/p&gt;
&lt;h4 id=&quot;执行器&quot;&gt;执行器&lt;/h4&gt;
&lt;p&gt;经过了分析器和优化器，就正式进行执行阶段了，不过执行之前，需要做权限验证，如果权限不足，就会抛出权限的错误。其实在查询缓存的时候，一样也会进行权限校验。&lt;/p&gt;
&lt;p&gt;如果通过验证，执行器就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/p&gt;
&lt;h4 id=&quot;存储引擎&quot;&gt;存储引擎&lt;/h4&gt;
&lt;p&gt;MySQL支持非常多种存储引擎，常用的是InnoDB和MyISAM，MySQL的默认存储引擎是InnoDB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669484/201911/1669484-20191114225431803-587008532.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如我们选择是InnoDB引擎，对于查询，那InnoDB 会取这个表的第一行来进行判断是不是符合要求，符合则存在结果集中，否则继续进行下一行，直到该表的最后一行。&lt;/p&gt;
&lt;p&gt;然后存储引擎将结果返回给执行器， 执行器拿着结果返回给客户端，这样一句SQL就执行完成了。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 14:55:00 +0000</pubDate>
<dc:creator>杨小格子</dc:creator>
<og:description>对于MySQL而言，其实分为客户端与服务端。 服务端，就是MySQL应用，当我们使用net start mysql命令启动的服务，其实就是启动了MySQL的服务端。 客户端，负责发送请求到服务端并从服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imyanger/p/11863293.html</dc:identifier>
</item>
<item>
<title>【故障公告】新版博客后台部署时的配置问题引发故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/11863251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/11863251.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/35695/201911/35695-20191114224753890-1417960149.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近，我们对新版博客后台（&lt;span class=&quot;sysInfo ng-star-inserted&quot;&gt;Angular 8.2.7 + .NET Core 3.0&lt;/span&gt;）进行了灰度发布，如果您访问博客后台时跳转到 &lt;a href=&quot;https://i-beta.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;https://i-beta.cnblogs.com/&lt;/a&gt; ，说明使用的就是新版博客后台。&lt;/p&gt;
&lt;p&gt;今天我们在一次基于 gitlab-ci 的自动化发布过程中，由于操作问题在发布前没有对 appsettings.Production.json 的修改进行保存，造成容器在启动时使用了旧版的配置文件，再加上容器的健康检查不能检查出这种不正常情况（这个地方的改进还没完成），最不该的是在发布后没有对关键功能进行测试验证以及值班人员没有及时处理用户反馈，从而造成 18:22~19:27 期间使用新版博客后的用户无法正常发布博文，非常抱歉由此给您带来了麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;我们会吸取教训，并采取以下改进措施：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更高优先级改进健康检查。一是容器的健康检查，二是阿里云云监控的健康检查。当关键功能不可用时，让健康检查失败（之前的健康检查没有对业务功能进行检查）。这样发布时如果出现问题，容器健康检查失败，docker swarm 就不会部署新容器。当正在运行的容器出现问题影响关键功能的使用时及时报警。&lt;/li&gt;
&lt;li&gt;尽可能实现在生产环境发布后用“机器人”对关键功能进行测试验证。&lt;/li&gt;
&lt;li&gt;每次自动化发布时在值班群发消息通知值班人员留意用户反馈。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 14 Nov 2019 14:55:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>最近，我们对新版博客后台（Angular 8.2.7 + .NET Core 3.0）进行了灰度发布，如果您访问博客后台时跳转到 https://i-beta.cnblogs.com/ ，说明使用的就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/11863251.html</dc:identifier>
</item>
<item>
<title>敲开通往架构师的门 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/11862917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/11862917.html</guid>
<description>&lt;p&gt;最近学习了一些关于架构设计的知识想分享给大家。俗话说得好，不想当架构师的程序员不是好厨子。那么如何成为一名架构师呢？接下来就聊一聊我的一些想法。&lt;/p&gt;
&lt;h3 id=&quot;什么是架构师&quot;&gt;什么是架构师&lt;/h3&gt;
&lt;p&gt;之前有同学问我，做了几年技术，应该转管理还是转架构师？对于这位同学，我给他的答案是，你要先踏踏实实做好现在的工作。因为就他提的问题来看，应该是刚入行不久或者是在校学生。&lt;/p&gt;
&lt;p&gt;专心做技术的，都想做架构师。但架构师并不是说技术做时间长了可以转的。随着你的知识深度和广度的增加，在工作中会扮演更重要的角色，承担更大的责任，最终自然而然就会接触到架构设计的工作。&lt;/p&gt;
&lt;p&gt;而架构师的主要工作，其实是利用架构设计知识以及丰富的工作经验，在设计架构时，结合实际情况，在不同的选项中做出取舍。&lt;/p&gt;
&lt;h3 id=&quot;架构设计的真正目的&quot;&gt;架构设计的真正目的？&lt;/h3&gt;
&lt;p&gt;为什么要进行架构设计？因为架构设计很重要？可是为什么重要呢？似乎说不清楚。&lt;/p&gt;
&lt;p&gt;因为可以提升开发效率吗？也不一定，因为只有简单的设计才会使开发效率更高。而架构设计出于多方面考虑，不得已会引入一些复杂度，因此架构设计并不一定能提升开发效率。&lt;/p&gt;
&lt;p&gt;是为了大多数口中的“高可用”、“高性能”、“可扩展”吗？其实也不是。我们的系统可能并不一定需要这些。&lt;/p&gt;
&lt;p&gt;那架构设计的真正目的是什么呢？我认为架构设计的真正目的是与系统复杂度做斗争。&lt;/p&gt;
&lt;p&gt;系统复杂度的来源有：&lt;strong&gt;高性能、高可用、可扩展性、低成本、安全、规模&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;前面我们聊到有些系统可能不需要高可用、高性能。有些同学可能不理解，这些难道不是软件开发最基本的要求吗？这样的说法是存在一定偏差的。我们举一个简单的例子说明一下。&lt;/p&gt;
&lt;p&gt;如果让你为一所学校设计一个学生信息管理系统。针对上述几个复杂度的来源，你会做出怎样的取舍？我们来逐条分析一下。&lt;/p&gt;
&lt;p&gt;首先是高性能，学校的学生最多也就几万人，而且平时也不可能几万人同时用系统。因此我们并不需要考虑高性能。数据的CRUD直接用关系型数据库就足够了。&lt;/p&gt;
&lt;p&gt;然后是高可用，对于学生系统而言，即使宕机几个小时，影响也不会太大。不过数据的可靠性还是要保证的，如果大量数据丢失而又没有备份的话，数据修复将会是一项繁重的工作。所以这里需要做一些数据高可靠的设计。&lt;/p&gt;
&lt;p&gt;接下来是可扩展性，学生管理系统一般比较稳定，不会出现需要扩展的情况。因此我们也不太需要考虑可扩展性。&lt;/p&gt;
&lt;p&gt;至此，我们在设计系统时习惯考虑的高可用、高性能和可扩展，在这个系统中都不需要过多关注了。我们再来看看剩下的几个复杂度来源。&lt;/p&gt;
&lt;p&gt;关于低成本，由于我们并不需要高可用和高性能的设计，所以几台服务器的成本对于学校来说也不足为虑。&lt;/p&gt;
&lt;p&gt;安全性而言，学生信息需要一定的安全保证，但也不必做到金融级安全。所以只需要做好数据库权限管理，登录密码管理就足够了。&lt;/p&gt;
&lt;p&gt;最后是系统规模，学生管理系统往往不会很复杂。也不会迭代出许多功能。因此规模是比较固定且比较小的，不会带来很多的复杂度。&lt;/p&gt;
&lt;p&gt;从我们的分析中可以看出，学生管理系统是一个并不复杂的系统，我们真正需要着重考虑的就只有数据高可靠和数据安全两方面。面对复杂的系统，我们也应该按照这个步骤来思考并设计出合理的架构。在合理的情况下，尽量减少系统的复杂度。&lt;/p&gt;
&lt;h3 id=&quot;架构设计原则&quot;&gt;架构设计原则&lt;/h3&gt;
&lt;p&gt;前面我们提到，架构师的工作其实就是在多种选项中做出合理的取舍，取舍没有对错之分，只有是否合适一说。为了更好的做出选择，架构设计应该遵循三个原则：&lt;strong&gt;合适原则、简单原则、演化原则&lt;/strong&gt;。下面我来一一介绍这三个原则。&lt;/p&gt;
&lt;h4 id=&quot;合适原则&quot;&gt;合适原则&lt;/h4&gt;
&lt;p&gt;我们一直在说，架构设计中架构师要做出取舍，选择合适的架构。之所以一直强调合适，是因为我们在架构设计过程中需要结合实际情况来考虑。&lt;/p&gt;
&lt;p&gt;那么脱离实际情况的设计通常是怎样发生的呢？不知道大家在开发时有没有遇到过这样的需求：“我们决定做一个电商网站，就按照淘宝做一个一模一样的吧。“这时作为开发的你一定是黑人问号脸，心里也会万马奔腾。&lt;/p&gt;
&lt;p&gt;在架构设计时也是一样，最忌讳的就是不顾实际情况，盲目的使用业界最优的架构设计。有同学可能不太理解，使用最优设计有什么错呢？&lt;/p&gt;
&lt;p&gt;这里我们所说的实际情况就是你的业务。试想如果你的业务刚刚起步，QPS刚过百，这时，你设计的架构是能支持1000QPS还是3000QPS对于系统来说没什么区别。但对于开发成本来说就提升了不止3倍。而对于这样的业务体量来说，开发团队一般只有十几人或几十人这样的规模。要让这样的团队来开发的话，大概率是无法完成的。&lt;/p&gt;
&lt;h4 id=&quot;演化原则&quot;&gt;演化原则&lt;/h4&gt;
&lt;p&gt;聊完了合适原则，我们再来聊一聊演化原则。就像北京的城市规划一样，它一定是先有二环，慢慢向外扩建，才逐渐有了三四五六环。而我们现在所使用的大多数软件，也都是经过了许多版本的迭代才有了现在的功能。&lt;/p&gt;
&lt;p&gt;对于一名合格的架构师来说，我们首先要遵循合适原则，然后再逐步演化。切不可想着一步到位，从而引起过度设计。当业务发展到一定阶段时，我们不可避免的会需要对架构进行扩展、重构甚至重写。在这一过程中，我们应该保留下好的设计，对不好的设计进行完善。就像淘宝的架构一样，它是经历了多次“双十一”之后，才有了现在这样能支撑每天上千亿成交额的架构。&lt;/p&gt;
&lt;p&gt;因此，我们在设计架构时要遵循的第二个原则就是循序渐进的演化原则，而不是追求一步到位。&lt;/p&gt;
&lt;h4 id=&quot;简单原则&quot;&gt;简单原则&lt;/h4&gt;
&lt;p&gt;最后再来说简单原则。前面我们也说了，架构设计其实是在和系统的复杂度做斗争。为什么要有简单原则？我认为原因主要有两点。&lt;/p&gt;
&lt;p&gt;第一，复杂的架构开发成本更高。在开发资源有限的情况下，如果我们的架构设计很复杂，势必会提升开发成本。而对于当今飞速发展的市场来说，时间就是生命。如果你设计的架构开发周期非常长，那么公司也许就会放弃这个项目，那么架构也就没有存在的意义了。&lt;/p&gt;
&lt;p&gt;第二，复杂的架构往往会带来更多的故障。举个栗子，电动牙刷和普通牙刷相比，坏的概率一定会高一点，电动牙刷可能出现刷头磨损，电路问题，充电故障等等，而普通牙刷只会出现刷头磨损的情况。也就是说，系统的组件越多，系统出现故障的概率也就越大。在此基础上还有一个问题就是，一旦出了故障，定位问题的速度而言，简单系统相较于复杂系统也有着很大的优势。&lt;/p&gt;
&lt;p&gt;至此，架构设计的三个原则我们都已经聊完了。细心的同学可能注意到了，我在详细介绍时的顺序和最开始提到的顺序并不一致。这不是我不注意细节。而是我在详细介绍时，对这三个原则的重要程度排了一个顺序。这也是作为架构师的一种取舍，当三种原则无法同时满足时，应该以哪个为重？这里我的答案是&lt;strong&gt;合适&amp;gt;演化&amp;gt;简单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于架构设计，我已经有了一个大体的认识，不知道在读完本文以后你是否也有同样的感觉。如果有任何困惑，欢迎和我一起讨论交流。&lt;/p&gt;
&lt;p&gt;最后，架构师是需要有很深的技术积累的，而我在这方面做得还不够。所以后面还是要以技术积累为主，同时也会尝试将架构设计的知识引入到日常工作中。后续有什么新的体会我会继续和大家分享。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Nov 2019 14:04:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>最近学习了一些关于架构设计的知识想分享给大家。俗话说得好，不想当架构师的程序员不是好厨子。那么如何成为一名架构师呢？接下来就聊一聊我的一些想法。 什么是架构师 之前有同学问我，做了几年技术，应该转管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/11862917.html</dc:identifier>
</item>
</channel>
</rss>