<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>完结撒花！129 集 21 个小时，松哥自制的 Spring Boot2 系列视频教程杀青啦！ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11427675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11427675.html</guid>
<description>&lt;p&gt;松哥的 Spring Boot 教程分为几个阶段。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;2016&lt;/h2&gt;
&lt;p&gt;松哥最早在 2016 年底的时候开始写 Spring Boot 系列的教程，记得当时在广州上班，年底那段时间在深圳出差，在深圳人生地不熟，下班回到酒店，就开始写博客，写 Spring Boot 教程。&lt;/p&gt;
&lt;p&gt;我写的 Spring Boot 教程，不敢说是顶呱呱，但是我相信对大家来说绝对是有用的。我在 CSDN 上写了 400 多篇原创干货，其中访问量最高的几篇竟然都是 Spring Boot 相关的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085616945-988214371.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 火爆程度可见一斑。不过这些都是基于这是基于早期的 Spring Boot 版本写的（1.4.x）。&lt;/p&gt;
&lt;p&gt;Spring Boot 也算是业界有名的版本帝，版本更新非常快，这也从侧面说明了 Spring Boot 发展速度之快。于是松哥的教程一直没有停。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;2017&lt;/h2&gt;
&lt;p&gt;我在 2017 年推出了两个 Spring Boot + Vue 前后端分离项目。目前在 GitHub 上 star 数分别超过 8.8k 和 2.8k（&lt;a href=&quot;https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ&quot;&gt;公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为什么这两个项目这么火呢？我也分析过原因，单纯的 Spring Boot 并不难，单纯的 Vue 也不难，相对于 React 和 Angular ，Vue 算是最容易上手的前端框架了。但是要把前后端结合起来，这就有难度了，对前端工程师而言，数据库、Java、Redis 等等，都要花时间去学习，对后端工程师而言，前端的 ES6、webpack、前端工程化、Vue 等等也都要花时间去研究。&lt;/p&gt;
&lt;p&gt;而我这两个开源项目，则打通了前后端，从一个 Java 工程师的角度，带领小伙伴既写后端接口，又写前端页面，快速实现一个常规的企业后台管理系统。&lt;/p&gt;
&lt;p&gt;时代变了，单兵作战、快速迭代才有未来。从这个角度来讲，每个人都不应只专注于后端的 CRUD，我觉得这是这两个开源项目受欢迎的原因。&lt;/p&gt;
&lt;h2 id=&quot;section-2&quot;&gt;2018&lt;/h2&gt;
&lt;p&gt;2018 年，应清华社夏老师的邀请，出版了 《Spring Boot + Vue 全栈开发实战》 一书。把 Spring Boot 开发中的知识点做了一番仔细的整理，同时也在自己脑海中将 Spring Boot 教程体系化。&lt;/p&gt;
&lt;p&gt;新书出版至今，已经加印多次，还被国内某一本大学选作教材（&lt;a href=&quot;https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ&quot;&gt;我的第一本书，被选作大学教材了！&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;加了很多读者的微信，也收到读者不少反馈。我发现一些很简单的知识点，大家照着书写还是有问题，虽然我也提供了很多配套案例，可是还是会收到不少小伙伴的求助，很多东西搞不定。&lt;/p&gt;
&lt;p&gt;于是，继续出教程....&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;2019&lt;/h2&gt;
&lt;p&gt;时间到了 2019 年，Spring Boot 又经过了好几次版本变更，我自己也写了不少新版教程：&lt;/p&gt;
&lt;p&gt;还利用业余时间整理了一个电子书出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085634618-23443923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以说，在 Spring Boot 布道的路上从未停止。&lt;/p&gt;
&lt;p&gt;除了这些图文教程之外，松哥最近也抽时间录制了一套 Spring Boot 视频教程，这套教程分为两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring Boot 精讲系列&lt;/li&gt;
&lt;li&gt;Spring Boot + Vue 项目实战系列&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前第一阶段的视频已经录制完毕，共 129 集 21 个小时，全程高能无废话，可以说是满满的干货，大家可以看一下目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085648362-1785903215.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 9 月份开始，我将开始录制第二阶段的内容，第二阶段我会手把手带领大家做一个 Spring Boot + Vue 的实战项目，具体的项目就是我在 GitHub 上的开源项目 vhr(&lt;a href=&quot;https://github.com/lenve/vhr&quot; class=&quot;uri&quot;&gt;https://github.com/lenve/vhr&lt;/a&gt;)，该项目目前已经超过 8.8k star。这个项目我会带领大家从头开始搭建 Spring Boot + Vue 前后端分离环境，权限设计，RESTful 接口设计等，预计两个月之内更新完毕。&lt;/p&gt;
&lt;p&gt;看过我博客的小伙伴应该知道，我的博客的思路清晰，小伙伴按照我博客的思路都能够做出来效果，我的视频教程和博客的风格一致，一样也是思路清晰条理清楚，这不是我的自夸，有小伙伴的评价为证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085705615-251037054.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085716706-100424773.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085727336-2144381316.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了这两个视频之外，后期也会录制其他视频教程，目前确定的有 Cloud 和 Redis，其他的还在规划中，不过可以确定的是，每个月都会发布我自己录制的视频教程。&lt;/p&gt;
&lt;p&gt;这些视频的录制，我花费了巨大的时间成本，很多时候我都是晚上十二点才到家，然后早上六点起来录视频,录到八点半，然后去上班：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085741909-899896691.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;晚上回到家，除了写博客，还要对录好的视频剪辑，去噪，这是一个细活：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085754289-2019112590.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085804952-66165243.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;巨大的时间付出，保证了视频的质量，当然也决定了这是一套付费视频。&lt;/p&gt;
&lt;p&gt;我自己还在网上搜集了很多别人录制的视频，这些视频对我来说没有多大成本，都是网络上找的，因此我都免费送给大家了，在我公众号底部菜单里有免费视频，这些免费视频大家都可以领取，我不会拿这些随处可见的视频来卖钱。&lt;/p&gt;
&lt;p&gt;如果大家想要试看视频，可以参考如下两篇文章：&lt;/p&gt;
&lt;p&gt;欢迎大家加入星球，一起学习进步！现在直接扫码加入星球需要 199，这里我提供另外一个优惠的方式，大家可以加我微信，发红包只要 119，然后我手动拉你进星球。星球上每有一个课程完结的时候，就会提升一次价格，早点加入就是优势。&lt;strong&gt;同时为了保证加入星球的小伙伴的权益，我可以向大家保证，你在其他地方不会看到一模一样的免费的整套视频教程，因为这些视频都是我自己录制的，全部都是加密之后发布的，所以请大家放心。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085824374-1099886994.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201908/747810-20190829085836716-1193467197.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感谢大家信任。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:59:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>松哥的 Spring Boot 教程分为几个阶段。 2016 松哥最早在 2016 年底的时候开始写 Spring Boot 系列的教程，记得当时在广州上班，年底那段时间在深圳出差，在深圳人生地不熟，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11427675.html</dc:identifier>
</item>
<item>
<title>UVA 10395 素数筛 - cautx</title>
<link>http://www.cnblogs.com/cautx/p/11427669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cautx/p/11427669.html</guid>
<description>&lt;h2&gt;Twin Primes&lt;/h2&gt;
&lt;p&gt;Twin primes are pairs of primes of the form (p; p + 2). The term \twin prime&quot; was coined by Paul&lt;br/&gt;Stckel (1892-1919). The rst few twin primes are (3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43).&lt;br/&gt;In this problem you are asked to nd out the S-th twin prime pair where S is an integer that will be&lt;br/&gt;given in the input.&lt;br/&gt;Input&lt;br/&gt;The input will contain less than 10001 lines of input. Each line contains an integers S (1 S 100000),&lt;br/&gt;which is the serial number of a twin prime pair. Input le is terminated by end of le.&lt;br/&gt;Output&lt;br/&gt;For each line of input you will have to produce one line of output which contains the S-th twin prime&lt;br/&gt;pair. The pair is printed in the form (p1,&amp;lt;space&amp;gt;p2). Here &amp;lt;space&amp;gt; means the space character (ASCII&lt;br/&gt;32) . You can safely assume that the primes in the 100000-th twin prime pair are less than 20000000.&lt;br/&gt;Sample Input&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;br/&gt;Sample Output&lt;br/&gt;(3, 5)&lt;br/&gt;(5, 7)&lt;br/&gt;(11, 13)&lt;br/&gt;(17, 19)Twin primes are pairs of primes of the form (p; p + 2). The term \twin prime&quot; was coined by Paul&lt;br/&gt;Stckel (1892-1919). The rst few twin primes are (3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43).&lt;br/&gt;In this problem you are asked to nd out the S-th twin prime pair where S is an integer that will be&lt;br/&gt;given in the input.&lt;br/&gt;Input&lt;br/&gt;The input will contain less than 10001 lines of input. Each line contains an integers S (1 S 100000),&lt;br/&gt;which is the serial number of a twin prime pair. Input le is terminated by end of le.&lt;br/&gt;Output&lt;br/&gt;For each line of input you will have to produce one line of output which contains the S-th twin prime&lt;br/&gt;pair. The pair is printed in the form (p1,&amp;lt;space&amp;gt;p2). Here &amp;lt;space&amp;gt; means the space character (ASCII&lt;br/&gt;32) . You can safely assume that the primes in the 100000-th twin prime pair are less than 20000000.&lt;br/&gt;Sample Input&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;br/&gt;Sample Output&lt;br/&gt;(3, 5)&lt;br/&gt;(5, 7)&lt;br/&gt;(11, 13)&lt;br/&gt;(17, 19)&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;定义双素数(p,p+2)，p,p+2都为素数。&lt;/p&gt;
&lt;p&gt;先输入若干个n，输出第n对双素数。&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;时间限制为3000ms，数据量为2e7，可以直接暴力求解。&lt;/p&gt;
&lt;p&gt;首先用欧拉筛筛出所有素数，然后暴力枚举所有素数，判断是否是双素数即可。&lt;/p&gt;
&lt;p&gt;AC code:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ad9d1eed-bbf0-4cc1-a15d-67856e3cf2e6')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_ad9d1eed-bbf0-4cc1-a15d-67856e3cf2e6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ad9d1eed-bbf0-4cc1-a15d-67856e3cf2e6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ad9d1eed-bbf0-4cc1-a15d-67856e3cf2e6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ad9d1eed-bbf0-4cc1-a15d-67856e3cf2e6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
typedef pair&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; P;
P p[&lt;/span&gt;&lt;span&gt;20000005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; u[&lt;span&gt;20000005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; su[&lt;span&gt;20000005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; olas()
{
    num&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    memset(u,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(u));
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=&lt;span&gt;20000000&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(u[i])    su[num++]=&lt;span&gt;i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;num;j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i*su[j]&amp;gt;&lt;span&gt;20000000&lt;/span&gt;)    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            u[i&lt;/span&gt;*su[j]]=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%su[j]==&lt;span&gt;0&lt;/span&gt;)    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    olas();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=&lt;span&gt;20000000&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(u[i]&amp;amp;&amp;amp;u[i+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;])
        {
            p[num&lt;/span&gt;++]=P(i,i+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n))
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(%d, %d)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p[n-&lt;span&gt;1&lt;/span&gt;].first,p[n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].second);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 29 Aug 2019 00:57:00 +0000</pubDate>
<dc:creator>cautx</dc:creator>
<og:description>Twin Primes Twin primes are pairs of primes of the form (p; p + 2). The term \twin prime&amp;quot; was c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cautx/p/11427669.html</dc:identifier>
</item>
<item>
<title>「每日五分钟，玩转JVM」：线程共享区 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/11427653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/11427653.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;上一篇中，我们了解了JVM中的线程独占区，这节课我们就来了解一下JVM中的线程共享区，JVM中的线程共享区是跟随JVM启动时一起创建的，包括堆（Heap）和方法区（）两部分，而线程独占区的程序计数器，虚拟机栈，本地方法栈的生命周期都是跟随线程的，随线程的创建而诞生，随线程的销毁而销毁。&lt;/p&gt;
&lt;h3 id=&quot;堆heap&quot;&gt;堆（Heap）&lt;/h3&gt;
&lt;p&gt;堆内存作为JVM管理的内存中最大的一块，用于存放我们的&lt;strong&gt;对象实例&lt;/strong&gt;，我们经常会把JVM的内存简单的分为堆内存和栈内存，这样说虽然有些片面，但是也有这么说的道理，这两块儿一个作为执行程序的，一个作为存放对象的，是JVM中最为重要的两块儿内存。所以，我们的垃圾收集一般是针对的用于存放对象的&lt;strong&gt;堆内存&lt;/strong&gt;，所以堆内存有时候也会被称为GC堆。&lt;/p&gt;
&lt;p&gt;从内存分配的角度上来说，堆内存中包含了新生代内存和老年代内存，而年轻代又分为Eden和Survivor区。Survivor区由From Survivor和To Survivor组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1，而且JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-13-143627.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样设计的原因是为了更方便的进行垃圾收集，我们会在后面垃圾收集的章节中去详细的讲解。&lt;/p&gt;
&lt;h3 id=&quot;tlab&quot;&gt;TLAB&lt;/h3&gt;
&lt;p&gt;TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个处于&lt;strong&gt;堆内存中线程私有&lt;/strong&gt;的内存分配区域，默认情况下这个区域就是开启的，当然我们也可以在启动时配置&lt;code&gt;XX:+UseTLAB&lt;/code&gt;去开启该区域，这个区域所占空间非常的小，默认情况下只占Eden区域的1%，我们也可以通过也&lt;code&gt;XX:TLABWasteTargetPercent&lt;/code&gt;设置TLAB空间所占用Eden空间的百分比大小。&lt;/p&gt;
&lt;h3 id=&quot;方法区&quot;&gt;方法区&lt;/h3&gt;
&lt;p&gt;方法区存储虚拟机加载的&lt;em&gt;类信息&lt;/em&gt;，&lt;em&gt;常量&lt;/em&gt;，&lt;em&gt;静态变量&lt;/em&gt;，即时编译器&lt;em&gt;编译后的代码&lt;/em&gt;等数据，在Java虚拟机的规范中，把方法区认为是堆内存的逻辑部分，但是实际上他们是完全隔离的。&lt;/p&gt;
&lt;p&gt;在JDK 8 之前，方法区被称为(或者可以说是被实现为)持久代，永久代（Perman Gen），而在 JDK 8 之后，取消了永久代的概念，取而代之的实现是元空间（MetaSpace），原本位于永久代中的运行时常量池和静态变量都存储到了堆中，而其余的内容则是移到了元空间。&lt;/p&gt;
&lt;p&gt;元空间的本质和永久代类似，都是对JVM规范中&lt;strong&gt;方法区的实现&lt;/strong&gt;，它们之间最大的区别在于：&lt;strong&gt;元空间并不在虚拟机中，而是使用本地内存&lt;/strong&gt;。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：&lt;code&gt;-XX:MetaspaceSize-XX:MaxMetaspaceSize&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以我们前几年JDK7盛行的时候OOM错误消息是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.OutOfMemoryError：PermGen space&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在近几年JDK8的使用中遇到的OOM是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.OutOfMemoryError：Metaspace&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行时常量池&quot;&gt;运行时常量池&lt;/h3&gt;
&lt;p&gt;运行时常量池位于元空间中，用于存储编译期生成的各种字面量和符号引用，而这里需要注意一点：&lt;strong&gt;字符串常量池&lt;/strong&gt;从JDK 7 之后就移到了堆内存中去管理，但是运行时常量是仍然位于方法区基于JDK 8 的新实现——元空间中。&lt;/p&gt;
&lt;p&gt;网上有部分声音说运行时常量池在JDK8移到了堆内存中，其实这种说法是错误的，真正移到堆内存的是字符串常量池，并且是在JDK7的更新中就已经移到了堆中。&lt;/p&gt;
&lt;p&gt;更详细的关于常量池的信息我们会在类结构中去学习。&lt;/p&gt;
&lt;h3 id=&quot;后话&quot;&gt;后话&lt;/h3&gt;
&lt;p&gt;每天五分钟，跟Vi玩转JVM！&lt;/p&gt;
&lt;p&gt;下篇解密一个对象的诞生！&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;本文首发于公众号，扫码关注即可获取最新文章&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1528535/201908/1528535-20190829085306943-757091202.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:53:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>前言 上一篇中，我们了解了JVM中的线程独占区，这节课我们就来了解一下JVM中的线程共享区，JVM中的线程共享区是跟随JVM启动时一起创建的，包括堆（Heap）和方法区（）两部分，而线程独占区的程序计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/11427653.html</dc:identifier>
</item>
<item>
<title>【阿里云IoT+YF3300】4.Alink物模型之事件触发 - 叶帆</title>
<link>http://www.cnblogs.com/yefanqiu/p/11427646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yefanqiu/p/11427646.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;名词解释：&lt;/strong&gt;设备的功能模型之一，设备运行时的事件，事件一般包含需要被外部感知和处理的通知信息，可包含多个输出参数。如，某项任务完成的信息，或者设备发生故障或告警时的温度等，事件可以被订阅和推送。&lt;/p&gt;
&lt;p&gt;      在工控领域，通信的实时性非常重要，所以有所谓的工业以太网（时间敏感网络TSN）。5G之所以成为未来物联网的基石，也是因为时延非常低（毫秒级），才能使无人驾驶落地成为可能。&lt;/p&gt;
&lt;p&gt;     不过在一些典型的物联网领域，其上传数据的频率却没有那么快，比如环境的温湿度，一般都是分钟级别上传。这就带来一个问题，如果上传的间隔比较大，有些需要及时处理的信息，就不会得到及时的处理。比如温度突然超标，负压突然异常，甚至更为紧急的停电报警。这个时候事件的作用就比较大了，出现异常，即时上传信息。通过YF3300和阿里云的事件示例，可更深刻的理解Alink物模型事件的机理。&lt;/p&gt;
&lt;h2&gt;一.云端配置&lt;/h2&gt;
&lt;p&gt;(1)          登陆阿里云物联网平台&lt;/p&gt;
&lt;p&gt;(2)          在&lt;strong&gt;设备管理&lt;/strong&gt;选项中&lt;strong&gt;创建产品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829083709905-1452337535.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(3)          查看相应的产品，进行物模型属性的创建。查看产品细节，选择&lt;strong&gt;功能定义&lt;/strong&gt;，进行自定义属性添加与自定义事件添加&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt; 自定义属性添加，添加两个自定义功能，创建模板请见下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084156692-1713896033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084216962-984921914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b. 自定义事件添加。事件分为三种，信息 告警 故障，事件的创建包括功能名称 标识符以及输出参数的定义。（根据YFIOs事件引擎定义规则：1.&lt;strong&gt;信息事件&lt;/strong&gt;的&lt;strong&gt;标识符&lt;/strong&gt;必须为&lt;strong&gt;Event_Info_Device&lt;/strong&gt;，&lt;strong&gt;告警事件&lt;/strong&gt;的&lt;strong&gt;标识符&lt;/strong&gt;必须为&lt;strong&gt;Event_Alert_Device&lt;/strong&gt;，&lt;strong&gt;故障事件&lt;/strong&gt;的&lt;strong&gt;标识符&lt;/strong&gt;为&lt;strong&gt;Event_Error_Device&lt;/strong&gt;。2.每个事件具有两个输出参数：&lt;strong&gt;状态码&lt;/strong&gt;和&lt;strong&gt;事件信息&lt;/strong&gt;。状态码为int32（整数型），取值范围为-100~100，步长为1，无单位，事件信息为text（字符串），数据长度为256字节。）创建模板请见下图&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829083854477-1912821521.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084241087-1854202010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084253784-237533309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     在新建的产品下，设备名称必须为Test，并保存相关的设备证书（即设备三元组Productkey 、DeviceName、 DeviceSecret）&lt;/p&gt;
&lt;h2&gt;二.设备连接&lt;/h2&gt;
&lt;p&gt;运行环境搭建：Win7系统请下载相关的设备驱动，下载地址为：，请安装VS2010/VS2015及拓展包&lt;/p&gt;
&lt;p&gt;准备材料：YF3300设备套装，组态key（购买产品时厂家会附赠一个月体验版）官方下载YFIOsManager组态管理软件。下载链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yfiot.com/content/downsort?current=1&amp;amp;title=1&quot;&gt;http://www.yfiot.com/content/downsort?current=1&amp;amp;title=1&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;设备连接：a.将组态key插入电脑，将附赠GPRS天线连接好，插入附赠的物联网卡(也可使用自己购买的物联网卡)&lt;/p&gt;
&lt;p&gt;                   b.将YF3300通过Type-C连入电脑。&lt;/p&gt;
&lt;p&gt; 设备配置：&lt;/p&gt;
&lt;p&gt;(1)   打开下载的&lt;strong&gt;YFIOsManager&lt;/strong&gt;软件，选择&lt;strong&gt;USB&lt;/strong&gt;连接方式，连接YF3300&lt;/p&gt;
&lt;p&gt;(2)   在&lt;strong&gt;用户设备&lt;/strong&gt;中新建设备&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084430406-162725255.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;点击&lt;strong&gt;新建&lt;/strong&gt;，在驱动支持中，选择&lt;strong&gt;other&lt;/strong&gt;系列中的&lt;strong&gt;YFSoft（叶帆科技）&lt;/strong&gt;中的YF3300官方驱动。&lt;strong&gt;设备名称&lt;/strong&gt;为云端的DeviceName（&lt;strong&gt;Test&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;(3) 在数据配置新建一个属性（Test:T）。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084539814-1334214237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(4)点击保存项目，保存自定义的组态工程。&lt;/p&gt;
&lt;p&gt; (5) 在&lt;strong&gt;策略列表&lt;/strong&gt;中新建策略，策略文件选择&lt;strong&gt;sys&lt;/strong&gt; &amp;gt;&lt;strong&gt;阿里云MQTT客户端（精简版）&lt;/strong&gt;。服务配置中在相应的地方填入设备三元组，填入产品密钥，服务地址会自动更改，扫描间隔可更改，变化上传可勾选&lt;/p&gt;
&lt;p&gt;(6) 在&lt;strong&gt;策略列表&lt;/strong&gt;中新建策略，策略文件选择&lt;strong&gt;sys&lt;/strong&gt; &amp;gt;&lt;strong&gt;阿里云事件触发（示例版）（该策略主要负责设备的事件逻辑处理）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分逻辑代码如图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084607763-264467730.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(7)在&lt;strong&gt;调试&lt;/strong&gt;选项中部署YFIOs系统，选择&lt;strong&gt;精简版(上云)&lt;/strong&gt;，部署完成之后， 点击&lt;strong&gt;部署&lt;/strong&gt;按钮，部署创建的驱动和策略，选择&lt;strong&gt;系统重启&lt;/strong&gt;，根据当地网络情况，等待5~10s，&lt;strong&gt;通信灯常亮&lt;/strong&gt;，设备与云端通信成功。也可以在YFIOsManager监控上云过程，出现&lt;strong&gt;MQTT Connect OK!!!&lt;/strong&gt;   ,证明设备与云端通信成功。&lt;/p&gt;
&lt;p&gt; 三.事件触发演示&lt;/p&gt;
&lt;p&gt;(1)           打开&lt;strong&gt;阿里云平台&lt;/strong&gt;，查看创建设备，点击&lt;strong&gt;事件管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(2)           打开YFIOsManager点击数据监控，根据事件触发条件触发相应的事件&lt;/p&gt;

&lt;p&gt;       事件触发条件：1.Test:Q1值的更改会触发信息事件&lt;/p&gt;
&lt;p&gt;                                2.温度（Test:T）高于30℃触发告警事件，温度值为-1时触发故障事件。&lt;/p&gt;
&lt;p&gt;        事件触发方法：在YFIOsManager中的数据监控中找到修改参数，双击该数值，即可进行修改，修改按Enter保存生效&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084731612-1436425930.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;对应的触发事件可在阿里云事件管理中看到。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/11611/201908/11611-20190829084749609-122712181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p align=&quot;left&quot;&gt;                         &lt;/p&gt;

</description>
<pubDate>Thu, 29 Aug 2019 00:51:00 +0000</pubDate>
<dc:creator>叶帆</dc:creator>
<og:description>在工控领域，通信的实时性非常重要，所以有所谓的工业以太网（时间敏感网络TSN）。5G之所以成为未来物联网的基石，也是因为时延非常低（毫秒级），才能使无人驾驶落地成为可能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yefanqiu/p/11427646.html</dc:identifier>
</item>
<item>
<title>跟我学SpringCloud | 第十六篇：微服务利剑之APM平台（二）Pinpoint - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11427623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11427623.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084528350-295567565.jpg&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Springboot: 2.1.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringCloud: Greenwich.SR2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pinpoint概述&quot;&gt;1. Pinpoint概述&lt;/h2&gt;
&lt;p&gt;Pinpoint是一个由韩国人编写的为大型分布式系统服务的链路跟踪平台，并提供大量链路跟踪数据分析汇总解决方案。自2012年7月开始开发，与2015年1月做为一个开源项目推出。&lt;/p&gt;
&lt;h2 id=&quot;pinpoint主要特性&quot;&gt;2. Pinpoint主要特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分布式事务跟踪，跟踪跨分布式应用的消息。&lt;/li&gt;
&lt;li&gt;自动检测应用拓扑，帮助你搞清楚应用的架构。&lt;/li&gt;
&lt;li&gt;水平扩展以便支持大规模服务器集群。&lt;/li&gt;
&lt;li&gt;提供代码级别的可见性以便轻松定位失败点和瓶颈。&lt;/li&gt;
&lt;li&gt;使用字节码增强技术，添加新功能而无需修改代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pinpoint优势&quot;&gt;3. Pinpoint优势&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;无入侵：采用字节码增强技术，新增功能无需修改代码。&lt;/li&gt;
&lt;li&gt;性能高：对性能的影响非常小（资源使用量最小仅增加3%），异步数据传输，采用UDP协议让出网络连接优先级。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pinpoint架构简介&quot;&gt;4. Pinpoint架构简介&lt;/h2&gt;
&lt;p&gt;先看一下官方提供的架构图，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084528538-1648131979.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pinpoint主要包含了4个组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pinpoint Agent：探针，附加到用于分析的Java服务&lt;/li&gt;
&lt;li&gt;Pinpoint Collector：数据收集组件，部署在Web容器上&lt;/li&gt;
&lt;li&gt;Pinpoint Web UI：数据展示组件，部署在Web容器上&lt;/li&gt;
&lt;li&gt;HBase Storage：数据存储组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;架构图从上往下看，首先是通过Agent组件收集需要的数据，通过UPD/TCP的方式将数据发送给Collector，由Collector将数据分析整理过后存入HBase，通过Web UI组件将分析好的数据从HBase中读出，展示在现代化的UI界面上。&lt;/p&gt;
&lt;h2 id=&quot;pinpoint数据结构简介&quot;&gt;5. Pinpoint数据结构简介&lt;/h2&gt;
&lt;p&gt;Pinpoint中，核心数据结构由Span, Trace, 和 TraceId组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Span: RPC (远程过程调用/remote procedure call)跟踪的基本单元; 当一个RPC调用到达时指示工作已经处理完成并包含跟踪数据。为了确保代码级别的可见性，Span拥有带SpanEvent标签的子结构作为数据结构。每个Span包含一个TraceId。&lt;/li&gt;
&lt;li&gt;Trace: 多个Span的集合; 由关联的RPC (Spans)组成. 在同一个trace中的span共享相同的TransactionId。Trace通过SpanId和ParentSpanId整理为继承树结构.&lt;/li&gt;
&lt;li&gt;TraceId: 由 TransactionId, SpanId, 和 ParentSpanId 组成的key的集合. TransactionId 指明消息ID，而SpanId 和 ParentSpanId 表示RPC的父-子关系。
&lt;ul&gt;&lt;li&gt;TransactionId (TxId): 在分布式系统间单个事务发送/接收的消息的ID; 必须跨整个服务器集群做到全局唯一.&lt;/li&gt;
&lt;li&gt;SpanId: 当收到RPC消息时处理的工作的ID; 在RPC请求到达节点时生成。&lt;/li&gt;
&lt;li&gt;ParentSpanId (pSpanId): 发起RPC调用的父span的SpanId. 如果节点是事务的起点，这里将没有父span - 对于这种情况， 使用值-1来表示这个span是事务的根span。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pinpoint版本依赖&quot;&gt;6. Pinpoint版本依赖&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Pinpoint所需要的Java版本兼容：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.0.x&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.1.x&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.5.x&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.6.x&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;td&gt;7-8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.7.x&lt;/td&gt;
&lt;td&gt;6-8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.8.0&lt;/td&gt;
&lt;td&gt;6-10&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.8.1+&lt;/td&gt;
&lt;td&gt;6-11&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;HBase所需要的版本兼容&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.0.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.1.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.5.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.6.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.7.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.8.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Pinpoint Version&lt;/td&gt;
&lt;td&gt;HBase 0.94.x&lt;/td&gt;
&lt;td&gt;HBase 0.98.x&lt;/td&gt;
&lt;td&gt;HBase 1.0.x&lt;/td&gt;
&lt;td&gt;HBase 1.2.x&lt;/td&gt;
&lt;td&gt;HBase 2.0.x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;Agent - Collector所需要的版本兼容&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.0.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.1.x&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.5.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.6.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;not tested&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.7.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.8.x&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Agent Version&lt;/td&gt;
&lt;td&gt;Collector 1.0.x&lt;/td&gt;
&lt;td&gt;Collector 1.1.x&lt;/td&gt;
&lt;td&gt;Collector 1.5.x&lt;/td&gt;
&lt;td&gt;Collector 1.6.x&lt;/td&gt;
&lt;td&gt;Collector 1.7.x&lt;/td&gt;
&lt;td&gt;Collector 1.8.x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;Flink所需要的版本兼容&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.7.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;1.7.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.8.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;1.8.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.9.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;1.9.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Pinpoint Version&lt;/td&gt;
&lt;td&gt;flink 1.3.X&lt;/td&gt;
&lt;td&gt;flink 1.4.X&lt;/td&gt;
&lt;td&gt;flink 1.5.X&lt;/td&gt;
&lt;td&gt;flink 1.6.X&lt;/td&gt;
&lt;td&gt;flink 1.7.X&lt;/td&gt;
&lt;td&gt;Pinpoint Version&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.7.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;1.7.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.8.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;1.8.x&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1.9.x&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;1.9.x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;spring-cloud与pinpoint实战&quot;&gt;7. Spring Cloud与Pinpoint实战&lt;/h2&gt;
&lt;p&gt;在介绍实战之前，我们先介绍一下Pinpoint部署构建。&lt;/p&gt;
&lt;p&gt;笔者构建的一些前置条件：&lt;/p&gt;
&lt;p&gt;java：1.8&lt;br/&gt;CentOS：7.6&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HBase部署&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;存储方式需要使用HBase1.2.x的版本，笔者这里选择的是HBase1.2.6，下载地址为Apache官网，推荐使用有端点续传功能的下载器下载（实在是有点慢），HBase全版本下载地址：&lt;a href=&quot;http://archive.apache.org/dist/hbase/&quot; class=&quot;uri&quot;&gt;http://archive.apache.org/dist/hbase/&lt;/a&gt; ，各位读者选择自己喜欢的版本下载。&lt;/p&gt;
&lt;p&gt;下载完成后，将HBase1.2.6放入CentOS的opt目录中，执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xvzf hbase-1.2.6-bin.tar.gz
mv hbase-1.2.6/ /data/service/hbase/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改hbase中config目录中的JAVA_HOME，将这里的JAVA_HOME修改为自己本地的路径，笔者这里修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/opt/jdk1.8.0_221&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成后就可以进入hbase的bin目录，启动hbase了，执行如下语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./start-hbase.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后，可以执行jps，如果看到有HMaster，可有证明启动成功，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;19263 HMaster&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以打开浏览器访问：&lt;a href=&quot;http://ip:16010/master-status&quot; class=&quot;uri&quot;&gt;http://ip:16010/master-status&lt;/a&gt; ，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084529655-852816662.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们先把Pinpoint的HBase的构建脚本导入，进入HBase的bin目录下执行如下语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./hbase shell /opt/hbase-create.hbase&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据导入成功我们在HBase的UI界面上可以看到，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084531755-277941762.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面的目录是笔者用来存放HBase初始化脚本的路径，各位读者可根据情况自行替换，至此，HBase环境准备完成，接下来开始部署Collector和Web UI。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Collector和Web UI部署&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;出于简单方便考虑，不推荐初学者自行编译代码进行部署，可以直接使用官方提供的发行版本进行部署。&lt;/p&gt;
&lt;p&gt;浏览器访问链接：&lt;a href=&quot;https://github.com/naver/pinpoint/releases/&quot; class=&quot;uri&quot;&gt;https://github.com/naver/pinpoint/releases/&lt;/a&gt; ，直接下载当前最新Release版本即可，笔者现在看到的最新版本是1.8.4，如图，需要下载的内容有&lt;code&gt;pinpoint-agent-1.8.4.tar.gz&lt;/code&gt;、&lt;code&gt;pinpoint-collector-1.8.4.war&lt;/code&gt;和&lt;code&gt;pinpoint-web-1.8.4.war&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084532537-1282929952.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先需要准备两个tomcat，笔者这里下载的tomcat8，解压两份后并重命名为&lt;code&gt;apache-tomcat-pinpoint-collector&lt;/code&gt;和&lt;code&gt;apache-tomcat-pinpoint-web&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;apache-tomcat-pinpoint-collector&lt;/code&gt;中的config中的server.xml进行修改。&lt;/p&gt;
&lt;p&gt;将8005改成18005，8080改成18080，8443改为18443，8009改为18009。&lt;/p&gt;
&lt;p&gt;同样也将&lt;code&gt;apache-tomcat-pinpoint-web&lt;/code&gt;中的config中的server.xml进行修改。&lt;/p&gt;
&lt;p&gt;将8005改成28005，8080改成28080，8443改为28443，8009改为28009。&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;apache-tomcat-pinpoint-collector&lt;/code&gt;中的&lt;code&gt;webapp/ROOT&lt;/code&gt;清空，将&lt;code&gt;pinpoint-collector-1.8.4.war&lt;/code&gt;放入并解压。解压完成后就可以进入bin目录使用&lt;code&gt;./startup.sh&lt;/code&gt;启动tomcat了，并且使用命令&lt;code&gt;tail -f ../logs/catalina.out&lt;/code&gt;观察启动日志是否启动成功。&lt;/p&gt;
&lt;p&gt;同样，将&lt;code&gt;apache-tomcat-pinpoint-web&lt;/code&gt;中的&lt;code&gt;webapp/ROOT&lt;/code&gt;清空，将&lt;code&gt;pinpoint-web-1.8.4.war&lt;/code&gt;放入并解压。解压完成后就可以进入bin目录使用&lt;code&gt;./startup.sh&lt;/code&gt;启动tomcat了，并且使用命令&lt;code&gt;tail -f ../logs/catalina.out&lt;/code&gt;观察启动日志是否启动成功。&lt;/p&gt;
&lt;p&gt;当Collector和Web UI都启动成功后，就可以使用打开浏览器访问：&lt;a href=&quot;http://ip:28080/#/main&quot; class=&quot;uri&quot;&gt;http://ip:28080/#/main&lt;/a&gt; ，初次访问如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084532732-2109216278.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Agent启用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实战案例，本实战案例和上一篇实战案例保持一致，同样是4个服务，包括Zuul-Service、Eureka-Service、Consumer-Service和Provider-Service。具体实现代码本章不再列出，各位读者可以参考上一篇或者Github仓库（&lt;a href=&quot;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter15&quot; class=&quot;uri&quot;&gt;https://github.com/meteor1993/SpringCloudLearning/tree/master/chapter15&lt;/a&gt;），下面我们介绍Spring Cloud是如何与Pinpoint整合使用的。&lt;/p&gt;
&lt;p&gt;接入方式和上一篇的Skywalking是一致的，都是使用探针技术接入应用程序，java -jar的方式来加载Agent探针。&lt;/p&gt;
&lt;p&gt;首先在工程的跟目录中执行&lt;code&gt;mvn install&lt;/code&gt;，而后在CentOS的opt中新建4个目录，分别存放4个打好包的工程。笔者这里创建的4个目录分别为&lt;code&gt;/opt/project/consumer_service&lt;/code&gt;，&lt;code&gt;/opt/project/eureka_service&lt;/code&gt;，&lt;code&gt;/opt/project/provider_service&lt;/code&gt;和&lt;code&gt;/opt/project/zuul_service&lt;/code&gt;，将4个jar包分别放入对应的目录中，并解压刚才我们下载好的&lt;code&gt;pinpoint-agent-1.8.4.tar.gz&lt;/code&gt;探针，我们将解压后的探针放在/opt的目录中，接下来，我们使用如下命令，顺次启动4个jar包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -javaagent:/opt/pinpoint-bootstrap-1.8.4.jar -Dpinpoint.agentId=consumer-service -Dpinpoint.applicationName=consumer-server -jar /opt/project/consumer_service/consumer-0.0.1-SNAPSHOT.jar

java -javaagent:/opt/pinpoint-bootstrap-1.8.4.jar -Dpinpoint.agentId=eureka-service -Dpinpoint.applicationName=eureka-server -jar /opt/project/eureka_service/eureka-0.0.1-SNAPSHOT.jar

java -javaagent:/opt/pinpoint-bootstrap-1.8.4.jar -Dpinpoint.agentId=provider-service -Dpinpoint.applicationName=provider-server -jar /opt/project/provider_service/provider-0.0.1-SNAPSHOT.jar

java -javaagent:/opt/pinpoint-bootstrap-1.8.4.jar -Dpinpoint.agentId=zuul-service -Dpinpoint.applicationName=zuul-server -jar /opt/project/zuul_service/zuul-0.0.1-SNAPSHOT.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述命令执行完成之后，再打开Web UI查看显示情况。&lt;/p&gt;
&lt;p&gt;首先打开浏览器访问：&lt;a href=&quot;http://192.168.44.129:8080/client/hello?name=spring&quot; class=&quot;uri&quot;&gt;http://192.168.44.129:8080/client/hello?name=spring&lt;/a&gt; ，页面正常显示Hello, name is spring，查看Pinpoint的Web UI，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084533572-140520700.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图清楚的显示了我们当前系统的拓扑结构，横线上面的数字代表了调用次数，右边部分，最上面显示的是成功和失败的情况，中间部分显示的是响应时间，下面显示的是加载所使用的时间。&lt;/p&gt;
&lt;p&gt;检查器（Inspector）：这里已Zuul-Service为例，Timeline显示的是请求的时间段，Information显示的是节点的一些当前信息，包含Application Name、Agent Id、Agent版本、JVM信息、开始时间等。&lt;/p&gt;
&lt;p&gt;Heap信息的使用情况，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084534212-1966353946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统CPU、活动线程、响应时间等信息如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201908/908359-20190829084534980-1611652110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多Pinpoint的信息，读者可以通过官方Demo（&lt;a href=&quot;http://125.209.240.10:10123/#/main&quot; class=&quot;uri&quot;&gt;http://125.209.240.10:10123/#/main&lt;/a&gt; ）或者自行构建试验来查看结果，这里不再一一赘述。至此，Spring Cloud和Pinpoint的使用介绍也就完成了。更多有关Pinpoint的信息各位读者可以前往Github的官网进行查阅，地址为：&lt;a href=&quot;https://github.com/naver/pinpoint&quot; class=&quot;uri&quot;&gt;https://github.com/naver/pinpoint&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;8. 小结&lt;/h2&gt;
&lt;p&gt;这里总结一下整个案例的启动顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动HBase&lt;/li&gt;
&lt;li&gt;启动collector&lt;/li&gt;
&lt;li&gt;启动Web-UI&lt;/li&gt;
&lt;li&gt;启动Agent（Eureka、provider、consumer、zuul）&lt;/li&gt;
&lt;li&gt;应用调用&lt;/li&gt;
&lt;li&gt;访问Web-UI查看统计信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同Skywalking一样，以上启动顺序供各位读者参考，请各位读者最好按照以上顺序启动，因为不同的组件之前其实是有相互依赖关系的，如果随意更改启动顺序可能会造成某些未知问题。至此，Spring Cloud和APM的相关操作就告一段落了。APM可以很好的帮我们理解系统行为，也是分析系统性能的工具，更是发生问题故障的时候利器，可以帮我们快速的定位查找问题。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>SpringCloud系列教程 | 第十六篇：微服务利剑之APM平台（二）Pinpoint Springboot: 2.1.7.RELEASE SpringCloud: Greenwich.SR2 [</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11427623.html</dc:identifier>
</item>
<item>
<title>vue-小爱ADMIN系列文章(二)：微信微博等分享，国际化，前端性能优化，nginx服务器部署 - 流浪的诗人</title>
<link>http://www.cnblogs.com/wdlhao/p/11427616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdlhao/p/11427616.html</guid>
<description>&lt;p&gt;最近在做我的小爱ADMIN后台管理系统，结合当前市场后台管理系统对相关功能的需求，我又开始新增了一些新的功能和组件，如分享功能组件，项目国际化功能；项目完成后，部署在nginx服务器，发现首次访问的速度特别慢，严重的影响了用户体验，因此，我又开始进行了一系列的前端性能优化;以及将优化后的项目部署到nginx服务器二级子目录的注意细节。&lt;/p&gt;

&lt;h2 id=&quot;背景说明&quot;&gt;背景说明&lt;/h2&gt;
&lt;p&gt;用微信，微博等做网站的第三方登录及用微信和支付宝进行支付，都需要注册开发者账号和添加网站应用，比较麻烦。另外，注册的信息如果在前端页面里面进行公开，缺乏安全性。第三方分享功能不需要注册开发者账号和添加网站应用，用户信息相对保密，使用方法也相对简单。&lt;/p&gt;
&lt;h2 id=&quot;前端ui呈现和分享渠道&quot;&gt;前端ui呈现和分享渠道&lt;/h2&gt;
&lt;p&gt;封装了8个常用的分享组件，包含仿简书网站的底部和侧栏分享组件、仿掘金网站分享组件、仿新浪网站分享组件和其他一些网站横向排列的分享组件。包含的分享渠道有：&lt;strong&gt;微信、微博、qq、qq空间、豆瓣&lt;/strong&gt;等。&lt;/p&gt;
&lt;h2 id=&quot;分享组件的封装和分享方法的集合&quot;&gt;分享组件的封装和分享方法的集合&lt;/h2&gt;
&lt;p&gt;分享效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd0b6711d1ff5c?w=1920&amp;amp;h=943&amp;amp;f=png&amp;amp;s=98709&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分享组件的封装：&lt;a href=&quot;https://github.com/wdlhao/vue2-element-touzi-admin/blob/dev-permission/src/page/share/index.vue&quot;&gt;share/index.vue&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;shareContainer&quot; ref=&quot;shareContainer&quot;&amp;gt;
        &amp;lt;el-row :gutter=&quot;20&quot;&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;heng-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/heng-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
               &amp;lt;invite-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/invite-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;jianshu-share @shareToWeixin=&quot;shareToWeixin&quot; @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/jianshu-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;jianshu-left-share @shareToWeixin=&quot;shareToWeixin&quot; @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/jianshu-left-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
        &amp;lt;/el-row&amp;gt;
        &amp;lt;el-row :gutter=&quot;20&quot;&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
               &amp;lt;info-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/info-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;juejin-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/juejin-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;sina-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/sina-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
            &amp;lt;el-col :span=&quot;6&quot;&amp;gt;
              &amp;lt;yan-share @shareToQQ=&quot;shareToQQ&quot; @shareToQQzone=&quot;shareToQQzone&quot; @shareToWeibo=&quot;shareToWeibo&quot; @shareToDouban=&quot;shareToDouban&quot;&amp;gt;&amp;lt;/yan-share&amp;gt;
            &amp;lt;/el-col&amp;gt;
        &amp;lt;/el-row&amp;gt;
        &amp;lt;wx-code-modal v-if=&quot;wxModal.show&quot; :wxModal=&quot;wxModal&quot; @hideWxCodeModal=&quot;hideWxCodeModal&quot;&amp;gt;&amp;lt;/wx-code-modal&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分享方法的集合:&lt;a href=&quot;https://github.com/wdlhao/vue2-element-touzi-admin/blob/dev-permission/src/utils/share.js&quot;&gt;utils/share.js&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { weibo,qq,qqZone,douban,shareUrl,shareTitle } from &quot;@/utils/env&quot;;
import * as mutils from &quot;@/utils/mUtils&quot;;

function getParamsUrl(obj){
    let paramsUrl = '';
    for(let key in obj){
        paramsUrl += key+'='+obj[key]+'&amp;amp;'
    }
    return paramsUrl;
}

export function shareConfig(type,obj){
    let baseUrl = '';
    if(mutils.isEmpty(obj)){
        obj = {};
    }
    switch(type){
        case 'weibo':
            const weiboData = {
                'url':shareUrl, // 内容链接，默认当前页面location
                'title':shareTitle, // 可选参数, 默认当前页title
                'pic':obj.pic || weibo.pic, // 分享图片的路径(可选)，多张图片通过&quot;||&quot;分开。
                'count':'y', /**是否显示分享数，y|n(可选)*/
                'searchPic':true // 是否要自动抓取页面上的图片。true|falsetrue:自动抓取,false:不自动抓取。
            }
            baseUrl = weibo.weiboUrl+'?appkey='+weibo.weiboAppkey+getParamsUrl(weiboData);
            window.open(baseUrl,'_blank');
            break;
        case 'qq':
            const qqData = {
                'url':shareUrl,
                'title':shareTitle,
                'pics':obj.pic || qq.pic,  //QZone接口暂不支持发送多张图片的能力，若传入多张图片，则会自动选入第一张图片作为预览图。
                'source':obj.source || qq.source, // 分享来源
                'desc':obj.desc || qq.desc, 
                'summary':obj.summary || qq.summary,
            }
            baseUrl = qq.baseUrl+'?'+getParamsUrl(qqData)
            window.open(baseUrl,'_blank');
            break;
        case 'qqZone':
            const qqZoneData = {
                'url':shareUrl,
                'title':shareTitle,
                'pics':obj.pic || (qqZone.pic).split(','), 
                'sharesource':obj.sharesource || qqZone.sharesource, // 分享来源
                'desc':obj.desc || qqZone.desc, 
                'summary':obj.summary || qqZone.summary,
            }
            baseUrl = qqZone.baseUrl+'?'+getParamsUrl(qqZoneData)
            window.open(baseUrl,'_blank');
            break;
        case 'douban':
            const doubanData = {
                'href':shareUrl,
                'name':shareTitle,
                'image':obj.pic || douban.pic,
            }
            baseUrl = douban.baseUrl+'?'+getParamsUrl(doubanData)
            window.open(baseUrl,'_blank');
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;微博分享后的效果,如图：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;br/&gt;&lt;img width=&quot;400&quot; height=&quot;300&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd0c2393116dc8?w=782&amp;amp;h=557&amp;amp;f=png&amp;amp;s=65550&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;p&gt;qq分享后的效果,如图：&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;img width=&quot;400&quot; height=&quot;300&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd0c4d3b28e303?w=934&amp;amp;h=671&amp;amp;f=png&amp;amp;s=112244&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;背景说明-1&quot;&gt;背景说明&lt;/h2&gt;
&lt;p&gt;由于本项目需要多语言的支持，我们需要做国际化。我们使用 vue-i18n 来实现多语言的界面。&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;使用步骤&lt;/h2&gt;
&lt;h3 id=&quot;安装vue-i18n&quot;&gt;1.安装vue-i18n&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;npm install vue-i18n --save&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于语言包，我们有几种方式:一种是每个语言包一个独立的js放到项目里;或者将语言的对照写在 .vue 文件里， 或者加载远程的JSON语言包&lt;br/&gt;我们的后台界面需要支持的语言通常不多，更新也不会非常的频繁，所以我们将语言包放在项目里，规划项目目录，增加 lang 目录来存放语言对照。&lt;/p&gt;
&lt;h3 id=&quot;新建lang文件夹用于存储语言包并导出&quot;&gt;2.新建lang文件夹,用于存储语言包并导出&lt;/h3&gt;
&lt;p&gt;中文语言包配置：src/lang/zh.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const zh = {
    // layout
    commons: {
      xiaoai: '小爱',
      admin: '管理员',
      editor: '赵晓编',
      quit: '退出',
      hi: '您好',
      index: '首页',
      userManage: '用户管理',
      share: '分享功能',
      infoManage: '信息管理',
      infoShow: '个人信息',
      infoShow1: '个人信息子菜单1',
      infoShow2: '个人信息子菜单2',
      infoShow3: '个人信息子菜单3',
      infoShow4: '个人信息子菜单4',
      infoShow5: '个人信息子菜单5',
      infoModify: '修改信息',
      infoModify1:'修改信息子菜单1',
      infoModify2:'修改信息子菜单2',
      infoModify3:'修改信息子菜单3',
      fundManage: '资金管理',
      fundList: '资金流水',
      chinaTabsList: '区域投资',
      fundData: '资金数据',
      fundPosition: '投资分布',
      typePosition: '项目分布',
      incomePayPosition: '收支分布',
      permission: '权限设置',
      pagePer: '页面权限',
      directivePer: '按钮权限',
      errorPage: '错误页面',
      page401:'401',
      page404:'404',
      wechatNumber: '微信号'
    },
    index:{
      yearLoss:'年度总盈亏',
      yearProfit:'年度收益率',
      potentialInvestor:'潜在投资人',
      intentionInvestor:'意向投资人',
      waitExamineInvestor:'待审投资人',
      examiningInvestor:'审核中投资人',
      tenMillion:'千万元',
      person:'人'
    }
  }
  
export default zh;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;英文语言包配置：src/lang/en.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const zh = {
    // layout
    commons: {
      xiaoai: 'Ai.',
      admin: 'Admin',
      editor: 'Editor',
      quit: 'Sign Out',
      hi: 'Hi',
      index: 'Dashboard',
      userManage: 'Users',
      share: 'Share',
      infoManage: 'Infos',
      infoShow: 'InfoShow',
      infoShow1: 'InfoShow1',
      infoShow2: 'InfoShow2',
      infoShow3: 'InfoShow3',
      infoShow4: 'InfoShow4',
      infoShow5: 'InfoShow5',
      infoModify: 'InfoModify',
      infoModify1:'InfoModify1',
      infoModify2:'InfoModify2',
      infoModify3:'InfoModify3',
      fundManage: 'Money',
      fundList: 'MoneyList',
      chinaTabsList: 'AreaList',
      fundData: 'FundData',
      fundPosition: 'FundPosition',
      typePosition: 'TypePosition',
      incomePayPosition: 'IncomePayPosition',
      permission: 'Permission',
      pagePer: 'PagePermission',
      directivePer: 'DirectivePermission',
      errorPage: 'ErrorPage',
      page401:'401',
      page404:'404',
      wechatNumber: 'wechat'
    },
    index:{
      yearLoss:'Year Loss',
      yearProfit:'Year Profit',
      potentialInvestor:'Potential Investor',
      intentionInvestor:'Intention Investor',
      waitExamineInvestor:'Wait Examine Investor',
      examiningInvestor:'Examining Investor',
      tenMillion:'Ten Million',
      person:'P'
    }
  }
  
export default zh;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导出配置：src/lang/index.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 引入i18n国际化插件
import { getToken} from '@/utils/auth'
import Vue from 'vue'
import VueI18n from 'vue-i18n'
process.env.NODE_ENV === &quot;development&quot; ? Vue.use(VueI18n) : null;

import enLocale from './en'
import zhLocale from './zh'
 
// 注册i18n实例并引入语言文件，文件格式等下解析
const i18n = new VueI18n({
  locale: getToken('lang') || 'en',
  messages: {
    zh: {
      ...zhLocale
    },
    en: {
      ...enLocale
    },
  }
});

export default i18n;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; locale: getToken('lang') || 'en',主要用来存储已经点击过的语言项，以便在项目刷新的时候，还能够拿到cookie中存储的语言类别。&lt;/p&gt;
&lt;h3 id=&quot;在项目入口文件main.js中引入i18n&quot;&gt;3.在项目入口文件main.js中引入i18n&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// i18n国际化
import i18n from &quot;@/lang&quot;;
new Vue({
  router,
  store,
  i18n,  // 便于可以直接在组件中通过this.$i18n使用，也可以按需引用
  render: h =&amp;gt; h(App),
}).$mount('#app')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;页面组件中使用方法t&quot;&gt;4.页面组件中使用方法$t()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class='welcome'&amp;gt;
    &amp;lt;span class=&quot;name&quot;&amp;gt;{{$t('commons.hi')}},&amp;lt;/span&amp;gt;
    &amp;lt;span class='name avatarname'&amp;gt; {{ $t(`commons.${name}`)}}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：$t('commons.hi'),这是直接导入的方法;$t(&lt;code&gt;commons.${name}&lt;/code&gt;),这是导入变量的方法。&lt;/p&gt;
&lt;h3 id=&quot;点击切换语言方法&quot;&gt;5.点击切换语言方法&lt;/h3&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd0dd929ccf3e8?w=266&amp;amp;h=186&amp;amp;f=png&amp;amp;s=10622&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;el-submenu index=&quot;1&quot; popper-class=&quot;langItem&quot;&amp;gt;
    &amp;lt;template slot=&quot;title&quot;&amp;gt;
        &amp;lt;img :src=&quot;langLogo&quot; class='langAvatar' alt=&quot;&quot;&amp;gt;
    &amp;lt;/template&amp;gt;
    &amp;lt;el-menu-item index=&quot;1-1&quot; @click=&quot;changeLocale('zh')&quot;&amp;gt;
        &amp;lt;img :src=&quot;chinaImg&quot; class='langAvatar' alt=&quot;&quot;&amp;gt;
        &amp;lt;span class=&quot;intro&quot;&amp;gt;中文&amp;lt;/span&amp;gt;
    &amp;lt;/el-menu-item&amp;gt;
    &amp;lt;el-menu-item index=&quot;1-2&quot; @click=&quot;changeLocale('en')&quot;&amp;gt;
        &amp;lt;img :src=&quot;americaImg&quot; class='langAvatar' alt=&quot;&quot;&amp;gt;
        &amp;lt;span class=&quot;intro&quot;&amp;gt;EngList&amp;lt;/span&amp;gt;
    &amp;lt;/el-menu-item&amp;gt;
&amp;lt;/el-submenu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; // 切换语言
changeLocale(type){
    setToken('lang',type);
    this.$i18n.locale = type;
    if(type === 'en'){
        this.langLogo = this.americaImg;
    }else{
        this.langLogo = this.chinaImg;
    }
    setToken('langLogo',this.langLogo);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;详细性能优化配置，请参考：&lt;a href=&quot;https://github.com/wdlhao/vue2-element-touzi-admin/blob/dev-permission/vue.config.js&quot;&gt;vue.config.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vue-cli 3.0 build包太大导致首屏加载过长，严重的影响了用户体验。因此，我们需要从以下方面提供相应的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;productionsourcemapfalse&quot;&gt;1.productionSourceMap：false&lt;/h2&gt;
&lt;p&gt;可以使得打包过后的文件不包含未压缩的.map文件，减少压缩后代码体积。&lt;/p&gt;
&lt;h2 id=&quot;项目中引入图片压缩图片在线免费压缩网站-httpswww.yasuotu.com或者将图片放到cdn上面进行引用&quot;&gt;2.项目中引入图片压缩（图片在线免费压缩网站 https://www.yasuotu.com/）或者将图片放到cdn上面进行引用。&lt;/h2&gt;
&lt;h2 id=&quot;路由懒加载&quot;&gt;3.路由懒加载&lt;/h2&gt;
&lt;p&gt;原因:“懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。”&lt;/p&gt;
&lt;h3 id=&quot;方法一resolve&quot;&gt;方法一：resolve&lt;/h3&gt;
&lt;p&gt;vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .&lt;br/&gt;但是,这种情况下一个组件生成一个js文件&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  path: '/login',
  name: 'login',
  component:function(resolve){
     require(['@/page/login.vue'],resolve)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法二官网方法-import&quot;&gt;方法二：官网方法 import()&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ 
    path: '/login',
    name: 'login',
    component:() =&amp;gt; import('@/page/login')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法三webpack的requireensure&quot;&gt;方法三：webpack的require,ensure()&lt;/h3&gt;
&lt;p&gt;这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  path: '/login',
  name: 'login',
  component: r =&amp;gt; require.ensure([], () =&amp;gt; r(require('@/page/login')), 'demo')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务器开启gzipcompression-webpack-plugin&quot;&gt;4. 服务器开启Gzip(compression-webpack-plugin)&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;); // gzip压缩,优化http请求,提高加载速度

configureWebpack:config =&amp;gt; {
    // 为生产环境修改配置...
    if (process.env.NODE_ENV === 'production') {
         // 开启gzip压缩
        config.plugins.push(new CompressionPlugin({
            algorithm: 'gzip',
            test: new RegExp(&quot;\\.(&quot; + [&quot;js&quot;, &quot;css&quot;].join(&quot;|&quot;) + &quot;)$&quot;), // 匹配文件扩展名
            // threshold: 10240, // 对超过10k的数据进行压缩
            threshold: 5120, // 对超过5k的数据进行压缩
            minRatio: 0.8, 
            cache: true, // 是否需要缓存
            deleteOriginalAssets:false  // true删除源文件(不建议);false不删除源文件
        }))
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：使用compression-webpack-plugin开启服务器Gzip,所以也需要在服务端进行配置，以便能够解析gzip文件；nginx端配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    gzip  on;
    gzip_comp_level 4;
    gzip_buffers  4 16k;   
    gzip_types text/plain  text/css application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript; 
    gzip_min_length 1k;
    gzip_http_version 1.1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成环境剔除debuger和consoleterserpluginuglifyjsplugin&quot;&gt;5. 生成环境剔除debuger和console(TerserPlugin/UglifyJsPlugin)&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;const TerserPlugin = require('terser-webpack-plugin')  

configureWebpack:config =&amp;gt; {
    // 为生产环境修改配置...
    if (process.env.NODE_ENV === 'production') {
      // 去除console来减少文件大小，效果同'UglifyJsPlugin'
      new TerserPlugin({
        cache: true,
        parallel: true,
        sourceMap: true, // Must be set to true if using source-maps in production
        terserOptions: {
          compress: {
            warnings: false,
            drop_console: true,
            drop_debugger: true,
            pure_funcs: ['console.log']
          }
        }
      })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启用cdn加速configurewebpackconfig.externals&quot;&gt;6. 启用CDN加速(configureWebpack,config.externals)&lt;/h2&gt;
&lt;p&gt;背景：在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首开的体验。&lt;/p&gt;
&lt;p&gt;解决方法：将引用的外部js、css文件剥离开来，不编译到vendor.js中，而是用资源的形式引用，这样浏览器可以使用多个线程异步将vendor.js、外部的js等加载下来，达到加速首开的目的。&lt;/p&gt;
&lt;p&gt;外部的库文件，可以使用CDN资源，或者别的服务器资源等。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;h3 id=&quot;配置要忽略的生产环境下被打包的文件&quot;&gt;(1).配置要忽略的生产环境下被打包的文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 忽略生产环境打包的文件
config.externals = {
    &quot;vue&quot;: &quot;Vue&quot;,
    &quot;vue-router&quot;: &quot;VueRouter&quot;,
    &quot;vuex&quot;: &quot;Vuex&quot;,
    &quot;vue-i18n&quot;: &quot;VueI18n&quot;,
    &quot;axios&quot;: &quot;axios&quot;,
    'element-ui': 'ELEMENT',
    'echarts':'echarts',
    'mockjs':'Mock',
    'nprogress':'NProgress',
    'js-cookie':'Cookies'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义不同环境下的cdn数据&quot;&gt;(2).定义不同环境下的cdn数据&lt;/h3&gt;
&lt;p&gt;具体cdn数据,请参考：https://www.bootcdn.cn/&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const cdn = {
  // 开发环境
  dev: {
      css: [],
      js: []
  },
  // 生产环境
  build: {
      css: [
        'https://cdn.bootcss.com/element-ui/2.11.1/theme-chalk/index.css',
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
      ],
      js: [
        'https://cdn.bootcss.com/vue/2.6.10/vue.min.js',
        'https://cdn.bootcss.com/vue-router/3.1.2/vue-router.min.js',
        'https://cdn.bootcss.com/vuex/2.3.1/vuex.min.js',
        'https://cdn.bootcss.com/axios/0.19.0/axios.min.js',
        'https://cdn.bootcss.com/vue-i18n/8.13.0/vue-i18n.min.js',
        'https://cdn.bootcss.com/element-ui/2.11.1/index.js',
        'https://cdn.bootcss.com/echarts/3.8.5/echarts.min.js',
        'https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock-min.js',
        'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js',
        'https://cdn.bootcss.com/js-cookie/2.2.0/js.cookie.min.js'
      ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加cdn参数到htmlwebpackplugin配置中&quot;&gt;(3).添加CDN参数到htmlWebpackPlugin配置中&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;config
.plugin('html')
.tap(args =&amp;gt; {
  if (process.env.NODE_ENV === 'production') {
      args[0].cdn = cdn.build
  }
  if (process.env.NODE_ENV === 'development') {
      args[0].cdn = cdn.dev
  }
  return args
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更改项目routervuexnprogressmockvuei18n等引入方式&quot;&gt;(4).更改项目Router,Vuex,nprogress,mock,VueI18n等引入方式&lt;/h3&gt;
&lt;p&gt;意思是只在开发环境引入相关的包，生产环境用cdn外链。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;process.env.NODE_ENV === &quot;development&quot; ? Vue.use(Router) : null;// router/index.js

process.env.NODE_ENV === &quot;development&quot; ? Vue.use(Vuex)  : null;// store/index.js

process.env.NODE_ENV === &quot;development&quot; &amp;amp;&amp;amp; import('nprogress/nprogress.css') // src/permission.js

process.env.NODE_ENV === &quot;development&quot; ? Vue.use(Mock) : null;//mockjs/index.js

process.env.NODE_ENV === &quot;development&quot; ? Vue.use(VueI18n) : null;//lang/index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;img width=&quot;400&quot; height=&quot;300&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd34a2cdb5fcc0?w=698&amp;amp;h=432&amp;amp;f=png&amp;amp;s=83880&quot;/&gt;&lt;/div&gt;
&lt;p&gt;注意：使用cdn外链，减少打包文件体积;更多适用于在生产环境，而在开发环境，我们还可以继续用以前的npm包。&lt;/p&gt;
&lt;h2 id=&quot;首屏加个loading小菊花动画&quot;&gt;7.首屏加个loading小菊花动画;&lt;/h2&gt;
&lt;p&gt;性能优化前后的数据对比：&lt;/p&gt;
&lt;p&gt;优化前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd393856c139ca?w=745&amp;amp;h=376&amp;amp;f=png&amp;amp;s=44348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优化后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd3962799663b8?w=751&amp;amp;h=379&amp;amp;f=png&amp;amp;s=50132&quot;/&gt;&lt;/p&gt;

&lt;p&gt;项目开发完成后，我们将进行服务器的部署；部署分为：部署在跟目录和部署在子目录，这两种情况，前端publicPath配置也是不一样的，否则，服务器资源会显示404，无法加载。&lt;/p&gt;
&lt;p&gt;注意：本项目服务器为 windows系统，所以以下配置为windows系统配置；如果你是linux系统服务器，请参考linux服务器部署配置。&lt;/p&gt;
&lt;p&gt;准备工作：&lt;/p&gt;
&lt;h2 id=&quot;下载nginx服务器&quot;&gt;下载nginx服务器;&lt;/h2&gt;
&lt;p&gt;下载网址：&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;请参考&lt;/a&gt;；选择该稳定版本下载；下载完成后，将该文件上传到你的服务器目录并解压。如图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd363f3915f5f8?w=617&amp;amp;h=280&amp;amp;f=png&amp;amp;s=17035&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行npm run build.将打包后的项目文件dist,复制到你的服务器目录(&lt;strong&gt;我的dist文件目标为:C:\ownprogram\vue\vue-touzi，我的nginx文件所在目标为：C:\ownprogram\nginx-1.8.1&lt;/strong&gt;)；接下来，开始对nginx-1.8.1/config/nginx.config文件进行配置。&lt;/p&gt;
&lt;h2 id=&quot;部署在跟目录&quot;&gt;部署在跟目录&lt;/h2&gt;
&lt;p&gt;本项目部署的跟目录为：C:\ownprogram\vue\vue-touzi\dist，默认为80端口；&lt;br/&gt;vue.config.js中publicPath配置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;./&quot; : &quot;/&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx.config，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
    include       mime.types;
    default_type  application/octet-stream;

    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Headers X-Requested-With;
    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
    
    gzip  on;
    gzip_comp_level 4;
    gzip_buffers  4 16k;   
    gzip_types text/plain  text/css application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript; 
    gzip_min_length 1k;
    gzip_http_version 1.1;

    server {
        listen       80;
        server_name  localhost;
        charset utf-8;

        #access_log  logs/host.access.log  main;
        
        location / {
            root  C:\ownprogram\vue\vue-touzi\dist\; 
            index  index.html index.htm;
            try_files $uri $uri/ /permission/index.html;
            proxy_set_header Accept-Encoding 'gzip';
       }

       location /permission {
            alias C:\ownprogram\vue\vue-touzi\dist\permission;
            index index.html;
            try_files $uri $uri/ /permission/index.html;
            proxy_set_header Accept-Encoding 'gzip';
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;部署在子目录&quot;&gt;部署在子目录&lt;/h2&gt;
&lt;p&gt;因为本项目C:\ownprogram\vue\vue-touzi\dist\默认为跟目录，属于dist/permission及为二级子目录；&lt;/p&gt;
&lt;p&gt;router/index.js配置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//注册路由
export default new Router({
    mode:'history', // 默认为'hash'模式
    base: '/permission/', // 添加跟目录,对应服务器部署子目录
    routes: constantRouterMap
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vue.config.js中publicPath配置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;/permission/&quot; : &quot;/&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx.config，新增location配置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; location /permission {
    alias C:\ownprogram\vue\vue-touzi\dist\permission;
    index index.html;
    try_files $uri $uri/ /permission/index.html;
    proxy_set_header Accept-Encoding 'gzip';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，保存文件；重启nginx即可进行正常访问；&lt;/p&gt;
&lt;h2 id=&quot;nginx常用命令如下&quot;&gt;nginx常用命令如下&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;启动服务：start nginx&lt;/li&gt;
&lt;li&gt;配置文件修改重启服务：nginx -s reload&lt;/li&gt;
&lt;li&gt;快速停止或关闭Nginx：nginx -s stop&lt;/li&gt;
&lt;li&gt;正常停止或关闭Nginx：nginx -s quit&lt;/li&gt;
&lt;li&gt;查看Nginx的版本号：nginx -V&lt;/li&gt;
&lt;li&gt;查看windows任务管理器下Nginx的进程命令：tasklist /fi &quot;imagename eq nginx.exe&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小爱ADMIN是完全开源免费的管理系统集成方案，可以直接应用于相关后台管理系统模板；很多重点地方都做了详细的注释和解释。如果你也一样喜欢前端开发，欢迎加入我们的讨论/学习群，群内可以提问答疑，分享学习资料； 欢迎加入答疑qq群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/27/16cd3864672883d4?w=552&amp;amp;h=257&amp;amp;f=jpeg&amp;amp;s=91376&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:43:00 +0000</pubDate>
<dc:creator>流浪的诗人</dc:creator>
<og:description>最近在做我的小爱ADMIN后台管理系统，结合当前市场后台管理系统对相关功能的需求，我又开始新增了一些新的功能和组件，如分享功能组件，项目国际化功能；项目完成后，部署在nginx服务器，发现首次访问的速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wdlhao/p/11427616.html</dc:identifier>
</item>
<item>
<title>JQuery $.ajax(); 异步访问完整参数 - 南栀、</title>
<link>http://www.cnblogs.com/Ferda/p/11427612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ferda/p/11427612.html</guid>
<description>&lt;h3 id=&quot;jquery中的ajax方法参数&quot;&gt;jquery中的ajax方法参数&lt;/h3&gt;
&lt;h4 id=&quot;url&quot;&gt;url:&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，（默认为当前页地址）发送请求的地址。&lt;/p&gt;
&lt;h4 id=&quot;type&quot;&gt;type:&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。&lt;/p&gt;
&lt;h4 id=&quot;timeout&quot;&gt;timeout:&lt;/h4&gt;
&lt;p&gt;要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。&lt;/p&gt;
&lt;h4 id=&quot;async&quot;&gt;async:&lt;/h4&gt;
&lt;p&gt;要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。&lt;/p&gt;
&lt;h4 id=&quot;cache&quot;&gt;cache:&lt;/h4&gt;
&lt;p&gt;要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。&lt;/p&gt;
&lt;h4 id=&quot;data&quot;&gt;data:&lt;/h4&gt;
&lt;p&gt;要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;{
    foo1:&lt;span class=&quot;hljs-string&quot;&gt;&quot;bar1&quot;,
    foo2:&lt;span class=&quot;hljs-string&quot;&gt;&quot;bar2&quot;
}

=&amp;gt;&amp;amp;foo1=bar1&amp;amp;foo2=bar2。

&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;datatype&quot;&gt;dataType:&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;xml：返回XML文档，可用JQuery处理。&lt;/li&gt;
&lt;li&gt;html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。&lt;/li&gt;
&lt;li&gt;script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。&lt;/li&gt;
&lt;li&gt;json：返回JSON数据。&lt;/li&gt;
&lt;li&gt;jsonp：JSONP格式。使用SONP形式调用函数时，&lt;br/&gt;例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。&lt;/li&gt;
&lt;li&gt;text：返回纯文本字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;beforesend&quot;&gt;beforeSend：&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;XMLHttpRequest){    
    &lt;span class=&quot;hljs-keyword&quot;&gt;this;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;complete&quot;&gt;complete：&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;XMLHttpRequest, textStatus){
    &lt;span class=&quot;hljs-keyword&quot;&gt;this;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;success&quot;&gt;success：&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。&lt;br/&gt;(1)由服务器返回，并根据dataType参数进行处理后的数据。&lt;br/&gt;(2)描述状态的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;data, textStatus){
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;error&quot;&gt;error:&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;XMLHttpRequest, textStatus, errorThrown){
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;contenttype&quot;&gt;contentType：&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为 &quot;application/x-www-form-urlencoded&quot; 。该默认值适合大多数应用场合。&lt;/p&gt;
&lt;h4 id=&quot;datafilter&quot;&gt;dataFilter：&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;data, type){
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;datafilter-1&quot;&gt;dataFilter：&lt;/h4&gt;
&lt;p&gt;要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;data, type){
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;global&quot;&gt;global：&lt;/h4&gt;
&lt;p&gt;要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。&lt;/p&gt;
&lt;h4 id=&quot;ifmodified&quot;&gt;ifModified：&lt;/h4&gt;
&lt;p&gt;要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。&lt;/p&gt;
&lt;h4 id=&quot;jsonp&quot;&gt;jsonp：&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，例如{jsonp:'onJsonPLoad'}会导致将&quot;onJsonPLoad=?&quot;传给服务器。&lt;/p&gt;
&lt;h4 id=&quot;username&quot;&gt;username：&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，用于响应HTTP访问认证请求的用户名。&lt;/p&gt;
&lt;h4 id=&quot;password&quot;&gt;password：&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，用于响应HTTP访问认证请求的密码。&lt;/p&gt;
&lt;h4 id=&quot;processdata&quot;&gt;processData：&lt;/h4&gt;
&lt;p&gt;要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型&quot;application/x-www-form-urlencoded&quot;。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。&lt;/p&gt;
&lt;h4 id=&quot;scriptcharset&quot;&gt;scriptCharset：&lt;/h4&gt;
&lt;p&gt;要求为String类型的参数，只有当请求时dataType为&quot;jsonp&quot;或者&quot;script&quot;，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;$(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;){
    $(&lt;span class=&quot;hljs-string&quot;&gt;'#send').click(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;){
        $.ajax({
         &lt;span class=&quot;hljs-attr&quot;&gt;type: &lt;span class=&quot;hljs-string&quot;&gt;&quot;GET&quot;,
         &lt;span class=&quot;hljs-attr&quot;&gt;url: &lt;span class=&quot;hljs-string&quot;&gt;&quot;test.json&quot;,
         &lt;span class=&quot;hljs-attr&quot;&gt;data: {&lt;span class=&quot;hljs-attr&quot;&gt;username:$(&lt;span class=&quot;hljs-string&quot;&gt;&quot;#username&quot;).val(), &lt;span class=&quot;hljs-attr&quot;&gt;content:$(&lt;span class=&quot;hljs-string&quot;&gt;&quot;#content&quot;).val()},
         &lt;span class=&quot;hljs-attr&quot;&gt;dataType: &lt;span class=&quot;hljs-string&quot;&gt;&quot;json&quot;,
         &lt;span class=&quot;hljs-attr&quot;&gt;success: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;data){
                    &lt;span class=&quot;hljs-built_in&quot;&gt;console.log(data);
                  }
        });
    });
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Aug 2019 00:42:00 +0000</pubDate>
<dc:creator>南栀、</dc:creator>
<og:description>$.ajax 完整参数 jquery中的ajax方法参数 url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。 type: 要求为String类型的参数，请求方式（post或g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Ferda/p/11427612.html</dc:identifier>
</item>
<item>
<title>第 11 篇：自动生成文章摘要 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/11425863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/11425863.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190828185611060-1211614569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;作者：HelloGitHub-&lt;strong&gt;追梦人物&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4027777777778&quot;&gt;
&lt;p&gt;文中涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;博客文章的模型有一个 &lt;code&gt;excerpt&lt;/code&gt; 字段，这个字段用于存储文章的摘要。目前为止，还只能在 django admin 后台手动为文章输入摘要。每次手动输入摘要比较麻烦，对有些文章来说，只要摘取正文的前 N 个字符作为摘要，以便提供文章预览就可以了。因此我们来实现如果文章没有输入摘要，则自动摘取正文的前 N 个字符作为摘要，这有两种实现方法。&lt;/p&gt;
&lt;h2 id=&quot;覆写-save-方法&quot;&gt;覆写 save 方法&lt;/h2&gt;
&lt;p&gt;第一种方法是通过覆写模型的 &lt;code&gt;save&lt;/code&gt; 方法，从正文字段摘取前 N 个字符保存到摘要字段。在 &lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/65/&quot;&gt;创作后台开启，请开始你的表演&lt;/a&gt; 中我们提到过 &lt;code&gt;save&lt;/code&gt; 方法中执行的是保存模型实例数据到数据库的逻辑，因此通过覆写 save 方法，在保存数据库前做一些事情，比如填充某个缺失字段的值。&lt;/p&gt;
&lt;p&gt;回顾一下博客文章模型代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;blog/models.py

class Post(models.Model):
    # 其它字段...
    body = models.TextField()
    excerpt = models.CharField(max_length=200, blank=True)
    
    def save(self, *args, **kwargs):
        self.modified_time = timezone.now()
        super().save(*args, **kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;body&lt;/code&gt; 字段存储的是正文，&lt;code&gt;excerpt&lt;/code&gt; 字段用于存储摘要。通过覆写模型的 save 方法，在数据被保存到数据库前，先从 &lt;code&gt;body&lt;/code&gt; 字段摘取 N 个字符保存到 &lt;code&gt;excerpt&lt;/code&gt; 字段中，从而实现自动摘要的目的。具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;blog/models.py

import markdown
from django.utils.html import strip_tags

class Post(models.Model):
    # 其它字段...
    body = models.TextField()
    excerpt = models.CharField(max_length=200, blank=True)
    
    # 其它方法...
    
    def save(self, *args, **kwargs):
        self.modified_time = timezone.now()

        # 首先实例化一个 Markdown 类，用于渲染 body 的文本。
        # 由于摘要并不需要生成文章目录，所以去掉了目录拓展。
        md = markdown.Markdown(extensions=[
            'markdown.extensions.extra',
            'markdown.extensions.codehilite',
        ])

        # 先将 Markdown 文本渲染成 HTML 文本
        # strip_tags 去掉 HTML 文本的全部 HTML 标签
        # 从文本摘取前 54 个字符赋给 excerpt
        self.excerpt = strip_tags(md.convert(self.body))[:54]

        super().save(*args, **kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里生成摘要的方案是，先将 &lt;code&gt;body&lt;/code&gt; 中的 Markdown 文本转为 HTML 文本，去掉 HTML 文本里的 HTML 标签，然后摘取文本的前 54 个字符作为摘要。去掉 HTML 标签的目的是防止前 54 个字符中存在块级 HTML 标签而使得摘要格式比较难看。可以看到很多网站都采用这样一种生成摘要的方式。&lt;/p&gt;
&lt;p&gt;然后在模板中适当的地方使用模板标签引用 &lt;code&gt;{{ post.excerpt }}&lt;/code&gt; 显示摘要的值即可：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;templates/blog/index.html

&amp;lt;article class=&quot;post post-{{ post.pk }}&quot;&amp;gt;
  ...
  &amp;lt;div class=&quot;entry-content clearfix&quot;&amp;gt;
      &amp;lt;p&amp;gt;{{ post.excerpt }}...&amp;lt;/p&amp;gt;
      &amp;lt;div class=&quot;read-more cl-effect-14&quot;&amp;gt;
          &amp;lt;a href=&quot;{{ post.get_absolute_url }}&quot; class=&quot;more-link&quot;&amp;gt;继续阅读 &amp;lt;span class=&quot;meta-nav&quot;&amp;gt;→&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/article&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新添加一篇文章（这样才能触发 save 方法，此前添加的文章不会自动生成摘要，要手动保存一下触发 save 方法），可以看到摘要效果了。&lt;/p&gt;
&lt;h2 id=&quot;使用-truncatechars-模板过滤器&quot;&gt;使用 truncatechars 模板过滤器&lt;/h2&gt;
&lt;p&gt;第二种方法是使用 &lt;code&gt;truncatechars&lt;/code&gt; 模板过滤器（Filter）。在 django 的模板系统中，模板过滤器的使用语法为 &lt;code&gt;{{ var | filter: arg }}&lt;/code&gt;。可以将模板过滤看做一个函数，它会作用于被它过滤的模板变量，从而改变模板变量的值。例如这里的 &lt;code&gt;truncatechars&lt;/code&gt; 过滤器可以截取模板变量值的前 N 个字符显示。关于模板过滤器，我们之前使用过 &lt;code&gt;safe&lt;/code&gt; 过滤器，可以参考 &lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/67/&quot;&gt;让博客支持 Markdown 语法和代码高亮&lt;/a&gt; 这篇文章中对模板过滤器的说明。&lt;/p&gt;
&lt;p&gt;例如摘要效果，需要显示 &lt;code&gt;post.body&lt;/code&gt; 的前 54 的字符，那么可以在模板中使用 &lt;code&gt;{{ post.body | truncatechars:54 }}&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;templates/blog/index.html

&amp;lt;article class=&quot;post post-{{ post.pk }}&quot;&amp;gt;
  ...
  &amp;lt;div class=&quot;entry-content clearfix&quot;&amp;gt;
      &amp;lt;p&amp;gt;{{ post.body|truncatechars:54 }}&amp;lt;/p&amp;gt;
      &amp;lt;div class=&quot;read-more cl-effect-14&quot;&amp;gt;
          &amp;lt;a href=&quot;{{ post.get_absolute_url }}&quot; class=&quot;more-link&quot;&amp;gt;继续阅读 &amp;lt;span class=&quot;meta-nav&quot;&amp;gt;→&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/article&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这种方法的一个缺点就是如果前 54 个字符含有块级 HTML 元素标签的话（比如一段代码块），会使摘要比较难看。所以推荐使用第一种方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190821112857020-927093944.png&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;欢迎关注 HelloGitHub 公众号，获取更多开源项目的资料和内容&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:33:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 追梦人物 文中涉及的示例代码，已同步更新到 'HelloGitHub Team 仓库' 博客文章的模型有一个 字段，这个字段用于存储文章的摘要。目前为止，还只能在 dja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/11425863.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之Jekins参数化构建(二) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11427566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11427566.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一节我们讲解了如何使用bat脚本或者powershell脚本自身的机制来达到参数化构建的目的,这在一定程序上增加了灵活性,然而缺点也相当明显:它只能适应一些相对比较固定的参数传入(比如像上一节讲到的,构建的环境分为(&lt;code&gt;development&lt;/code&gt;和&lt;code&gt;production&lt;/code&gt;)两种情况,对于一些相对较复杂的情况以上方法就会捉襟见肘,最为明显问题是外部的变化可能导致参数随之做必要更改,最常见的是文件的位置参数,我们指定归档文件的目录为&lt;code&gt;D&lt;/code&gt;盘下的一个文件夹,现在D盘满了需要指定为其它盘,则所有的脚本都需要更改,这样的结果就是可维护性差.我们可以把一些较为常用的参数定义为全局参数,比如常用工具的位置.&lt;/p&gt;
&lt;p&gt;本节我们将从项目级别,节点级别,全局级别来讲解Jenkins ci提供的参数配置方案&lt;/p&gt;
&lt;h2 id=&quot;项目级别参数&quot;&gt;项目级别参数&lt;/h2&gt;
&lt;p&gt;本节部分我们分为参数构建和在项目中定义项目级别参数来讲解.&lt;/p&gt;
&lt;h3 id=&quot;参数化构建项目.&quot;&gt;参数化构建项目.&lt;/h3&gt;
&lt;p&gt;在Jenkins里新建一个自由式项目,勾选&lt;code&gt;This project is parameterized&lt;/code&gt;会出现一个&lt;code&gt;Add Parameter&lt;/code&gt;按钮,点击会出现一个下拉框,选择最后一项'string paramter'创建一个字符串类型参数,在出现的对话框中输入名称(我用的是&lt;code&gt;buildenv&lt;/code&gt;)和默认值(默认值可以不输入),在构建栏里我们选择&lt;code&gt;Execute windows bat command&lt;/code&gt;,在出现的框中输入以下内容:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//buildenv为我们定义的参数名
echo %buildenv%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击&lt;code&gt;ok&lt;/code&gt;完成项目创建,此时&lt;code&gt;build now&lt;/code&gt;按钮变成了&lt;code&gt;Build with Parameters&lt;/code&gt;参数化构建,点击又会出现一步让输入值,有默认值可以直接点击'build',点击后我们查看控制台可以看到输出了我们定义的参数&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在以后的章节里也是一样,不管是Jenkins预置的参数还是我们自定义的,使用cmd时都是通过&lt;code&gt;%参数名%&lt;/code&gt;来获取.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果是powershell脚本,则需要使用&lt;code&gt;$env:参数名&lt;/code&gt;来接收参数,比如在powershell命令窗口输入&lt;code&gt;echo $env:buildenv&lt;/code&gt;就会达到和上面cmd一样的效果.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要指出的是,如果在jenkins里直接执行powershell命令,需要下载powershell插件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目级别参数-1&quot;&gt;项目级别参数&lt;/h3&gt;
&lt;p&gt;以上参数化构建适用于需要手动构建的,不是特别频繁但是参数又必须动态指定的情况,这种构建缺点也相当明显,因为每次需要手动指定参数.还有一种方法是指定项目级别的参数,这种方式比直接使用脚本自身参数要更容易管理,因为参数在单独的一块地方定义,并且可以添加描述,使得语义更加明确,并且参数在单独醒目地方出更容易引起关注.&lt;/p&gt;
&lt;p&gt;下面讲解一下如何在项目级别添加环境变量.&lt;/p&gt;
&lt;p&gt;新建一个自由式项目,名称随意,找到&lt;code&gt;Build Environment&lt;/code&gt;栏目,找到&lt;code&gt;Inject environment variables to the build process&lt;/code&gt;选项并勾选,此时会出现一些输入框让输入,&lt;code&gt;Properties File Path&lt;/code&gt;暂时忽略,在下面的&lt;code&gt;Properties Content&lt;/code&gt;里输入&lt;code&gt;buildenv=development&lt;/code&gt;就可以在bat,shell或者powershell脚本里使用它了.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果需要定义多个参数,换一行书写就行了,同样是name=value形式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;大家可能已经看到,选项里除了&lt;code&gt;Properties Content&lt;/code&gt;外,下面还有&lt;code&gt;Groovy Script&lt;/code&gt;选项,大家不要害怕,这里并不讲Groovy,这里可以使用一些简单的groovy语法来定义参数变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Groovy Script&lt;/code&gt;框里输入的选项如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;def str=&quot;hello,world&quot;
return [&quot;greeting&quot;:str,&quot;filename&quot;:&quot;jenkins.txt&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用 def关键字定义一个变量,下面return里的内容可以做为参数在构建时使用.比如在bat脚本里可以使用&lt;code&gt;%greeting%&lt;/code&gt;来获取键为greeting的参数的值.&lt;/p&gt;
&lt;h2 id=&quot;节点级别参数&quot;&gt;节点级别参数&lt;/h2&gt;
&lt;p&gt;有些参数在不同的节点上是不一样的,比如说某一个工具的位置,如果我们把它定义为项目级别,由工具在不同节点上安装的位置可能是不一样的,这样就会造成部分节点上的构建失败.这时候可以考虑把参数定义为节点级别.&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Manage Jenkins&amp;gt;Manage Nodes&lt;/code&gt;,进入管理页面便会看到我们已经创建好的Jenkins节点,点击某个基点后面的&lt;code&gt;齿轮&lt;/code&gt;图标,在出现的界面里找到&lt;code&gt;Node Properties&lt;/code&gt;,勾选&lt;code&gt;Environment variables&lt;/code&gt;此时便可以输入参数的名称和值,点击&lt;code&gt;Add&lt;/code&gt;按钮则可以添加多个参数.完成后点击&lt;code&gt;Save&lt;/code&gt;保存后便可以在脚本里使用刚定义的节点级别的变量了.&lt;/p&gt;
&lt;h2 id=&quot;全局变量&quot;&gt;全局变量&lt;/h2&gt;
&lt;p&gt;全局变量对所有节点都有效,当某些变量不会因为环境的改变而改变,比如说构建的版本只有development和production时,就可以定义为全局变量.这样不需要在每个项目里都重复定义了.&lt;/p&gt;
&lt;p&gt;全局变量的定义也非常简单,进入&lt;code&gt;Manage Jenkins&amp;gt;Configure System&lt;/code&gt;找到&lt;code&gt;Global properties&lt;/code&gt;并勾选&lt;code&gt;Environment variables&lt;/code&gt;出现的界面跟节点级别配置类似.&lt;/p&gt;
&lt;h2 id=&quot;使用文件参数&quot;&gt;使用文件参数&lt;/h2&gt;
&lt;p&gt;Jenkins提供了灵活的配置选项,我们除了可以在Jenkins内部配置参数外,还可以以外部文件的形式提供配置参数,配置参数为name=value键值对形式,必须符合java properties文件格式.&lt;/p&gt;
&lt;p&gt;下面讲解如何使用配置文件.&lt;/p&gt;
&lt;p&gt;我们新建一个自由式项目,滚动到&lt;code&gt;Build Environment&lt;/code&gt;栏,勾选&lt;code&gt;Inject environment variables to the build process&lt;/code&gt;,在&lt;code&gt;Properties File Path&lt;/code&gt;选项里输入配置文件路径,我放在了E盘里,路径为&lt;code&gt;E:\testenv.txt&lt;/code&gt;,这个文件很简单,里面就一行内容,如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;database=sqlserver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;往下流动到&lt;code&gt;Build&lt;/code&gt;栏,新建一个 &lt;code&gt;Execute windows bat command&lt;/code&gt;,输入以下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo %database%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后点击构建,可以看到控制台输入sqlserver&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:15:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 上一节我们讲解了如何使用bat脚本或者powershell脚本自身的机制来达到参数化构建的目的,这在一定程序上增加了灵活性,然而缺点也相当明显:它只能适应一些相对比较固定的参数传入(比如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11427566.html</dc:identifier>
</item>
<item>
<title>13张PPT带你了解主动式消息队列处理集群 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11426302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11426302.html</guid>
<description>&lt;p&gt;偷偷和你们说，我搞了一份内部资料，该内部资料共有13张PPT，据作者透露，该PPT至少花了整整1周时间才编写完成，其内容简洁明了，内容深度足够，易于初学者理解，也给深度开发人员分享了不一样的消息队列的玩法。特别重要的是，该架构目前已大面积的稳定应用于生产环境。&lt;/p&gt;
&lt;p&gt;PPT的内容我作了脱敏处理，经作者审核后分享给大家。&lt;/p&gt;

&lt;p&gt;该消息队列的主要特点是：主动式。其架构主要由3大部分组成，分别是：消息生产者、消息处理集群、消息消费者，该架构和一般的消费队列最大的区别就是：消息生产者和消费者不直接接触消息队列中间件，而是通过消息处理集群主动处理消息，什么意思呢，消息处理集群会主动的去探测消息生产者，探测到新消息的时候，将消息抓取并投入消息队列中，消息处理集群的消费端在接收MQ推送的消息后，再主动的推送给真正的消费者。&lt;/p&gt;
&lt;p&gt;消息处理集群还存储历史消息，消费者可以通过版本号等机制去拉取历史消息，实现重复消费的过程。&lt;/p&gt;
&lt;p&gt;这就是本次主动式消息队列处理集群的核心机制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202445708-662801703.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202452735-520650228.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202459426-792867477.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202505859-1405062745.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202511599-1929443797.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202519377-41466625.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202526642-366389107.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202532096-133460191.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202539921-1296209481.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202546756-1042847731.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202552596-728586228.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202559833-405326471.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190828202604706-1559949783.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出于版权考虑，其源文件我就不上传了，希望提供一个思路，以供参考&lt;/p&gt;
</description>
<pubDate>Thu, 29 Aug 2019 00:12:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>偷偷和你们说，我搞了一份内部资料，该内部资料共有13张PPT，据作者透露，该PPT至少花了整整1周时间才编写完成，其内容简洁明了，内容深度足够，易于初学者理解，也给深度开发人员分享了不一样的消息队列的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11426302.html</dc:identifier>
</item>
</channel>
</rss>