<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《RabbitMQ》如何保证消息的可靠性 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13437647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13437647.html</guid>
<description>&lt;p&gt;一条消费成功被消费经历了生产者-&amp;gt;MQ-&amp;gt;消费者，因此在这三个步骤中都有可能造成消息丢失。&lt;/p&gt;
&lt;h2 id=&quot;一-消息生产者没有把消息成功发送到mq&quot;&gt;一 消息生产者没有把消息成功发送到MQ&lt;/h2&gt;
&lt;h3 id=&quot;11-事务机制&quot;&gt;1.1 事务机制&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AMQP&lt;/code&gt;协议提供了事务机制，在投递消息时开启事务支持，如果消息投递失败，则回滚事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义事务管理器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class RabbitTranscation {
        
    @Bean
    public RabbitTransactionManager rabbitTransactionManager(ConnectionFactory connectionFactory){
        return new RabbitTransactionManager(connectionFactory);
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory){
        return new RabbitTemplate(connectionFactory);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  rabbitmq:
        # 消息在未被队列收到的情况下返回
    publisher-returns: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;开启事务支持&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rabbitTemplate.setChannelTransacted(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消息未接收时调用ReturnCallback&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rabbitTemplate.setMandatory(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;生产者投递消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class ProviderTranscation implements RabbitTemplate.ReturnCallback {

    @Autowired
    RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init(){
        // 设置channel开启事务
        rabbitTemplate.setChannelTransacted(true);
        rabbitTemplate.setReturnCallback(this);
    }
    
    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
        System.out.println(&quot;这条消息发送失败了&quot;+message+&quot;,请处理&quot;);
    }
    
    @Transactional(rollbackFor = Exception.class,transactionManager = &quot;rabbitTransactionManager&quot;)
    public void publishMessage(String message) throws Exception {
        rabbitTemplate.setMandatory(true);
        rabbitTemplate.convertAndSend(&quot;javatrip&quot;,message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，很少有人这么干，因为这是同步操作，一条消息发送之后会使发送端阻塞，以等待RabbitMQ-Server的回应，之后才能继续发送下一条消息，生产者生产消息的吞吐量和性能都会大大降低。&lt;/p&gt;
&lt;h3 id=&quot;12-发送方确认机制&quot;&gt;1.2 发送方确认机制&lt;/h3&gt;
&lt;p&gt;发送消息时将信道设置为&lt;code&gt;confirm&lt;/code&gt;模式，消息进入该信道后，都会被指派给一个唯一ID，一旦消息被投递到所匹配的队列后，&lt;code&gt;RabbitMQ&lt;/code&gt;就会发送给生产者一个确认。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开启消息确认机制&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  rabbitmq:
    # 消息在未被队列收到的情况下返回
    publisher-returns: true
    # 开启消息确认机制
    publisher-confirm-type: correlated
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消息未接收时调用ReturnCallback&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rabbitTemplate.setMandatory(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;生产者投递消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class ConfirmProvider implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnCallback {

    @Autowired
    RabbitTemplate rabbitTemplate;

    @PostConstruct
    public void init() {
        rabbitTemplate.setReturnCallback(this);
        rabbitTemplate.setConfirmCallback(this);
    }

    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        if(ack){
            System.out.println(&quot;确认了这条消息：&quot;+correlationData);
        }else{
            System.out.println(&quot;确认失败了：&quot;+correlationData+&quot;；出现异常：&quot;+cause);
        }
    }

    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
        System.out.println(&quot;这条消息发送失败了&quot;+message+&quot;,请处理&quot;);
    }

    public void publisMessage(String message){
        rabbitTemplate.setMandatory(true);
        rabbitTemplate.convertAndSend(&quot;javatrip&quot;,message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果消息确认失败后，我们可以进行消息补偿，也就是消息的重试机制。当未收到确认信息时进行消息的重新投递。设置如下配置即可完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  rabbitmq:
    # 支持消息发送失败后重返队列
    publisher-returns: true
    # 开启消息确认机制
    publisher-confirm-type: correlated
    listener:
      simple:
        retry:
          # 开启重试
          enabled: true
          # 最大重试次数
          max-attempts: 5
          # 重试时间间隔
          initial-interval: 3000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二-消息发送到mq后，mq宕机导致内存中的消息丢失&quot;&gt;二 消息发送到MQ后，MQ宕机导致内存中的消息丢失&lt;/h2&gt;
&lt;p&gt;消息在MQ中有可能发生丢失，这时候我们就需要将队列和消息都进行持久化。&lt;/p&gt;
&lt;p&gt;@Queue注解为我们提供了队列相关的一些属性，具体如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;name: 队列的名称；&lt;/li&gt;
&lt;li&gt;durable: 是否持久化；&lt;/li&gt;
&lt;li&gt;exclusive: 是否独享、排外的；&lt;/li&gt;
&lt;li&gt;autoDelete: 是否自动删除；&lt;/li&gt;
&lt;li&gt;arguments：队列的其他属性参数，有如下可选项，可参看图2的arguments：
&lt;ul&gt;&lt;li&gt;x-message-ttl：消息的过期时间，单位：毫秒；&lt;/li&gt;
&lt;li&gt;x-expires：队列过期时间，队列在多长时间未被访问将被删除，单位：毫秒；&lt;/li&gt;
&lt;li&gt;x-max-length：队列最大长度，超过该最大值，则将从队列头部开始删除消息；&lt;/li&gt;
&lt;li&gt;x-max-length-bytes：队列消息内容占用最大空间，受限于内存大小，超过该阈值则从队列头部开始删除消息；&lt;/li&gt;
&lt;li&gt;x-overflow：设置队列溢出行为。这决定了当达到队列的最大长度时消息会发生什么。有效值是drop-head、reject-publish或reject-publish-dlx。仲裁队列类型仅支持drop-head；&lt;/li&gt;
&lt;li&gt;x-dead-letter-exchange：死信交换器名称，过期或被删除（因队列长度超长或因空间超出阈值）的消息可指定发送到该交换器中；&lt;/li&gt;
&lt;li&gt;x-dead-letter-routing-key：死信消息路由键，在消息发送到死信交换器时会使用该路由键，如果不设置，则使用消息的原来的路由键值&lt;/li&gt;
&lt;li&gt;x-single-active-consumer：表示队列是否是单一活动消费者，true时，注册的消费组内只有一个消费者消费消息，其他被忽略，false时消息循环分发给所有消费者(默认false)&lt;/li&gt;
&lt;li&gt;x-max-priority：队列要支持的最大优先级数;如果未设置，队列将不支持消息优先级；&lt;/li&gt;
&lt;li&gt;x-queue-mode（Lazy mode）：将队列设置为延迟模式，在磁盘上保留尽可能多的消息，以减少RAM的使用;如果未设置，队列将保留内存缓存以尽可能快地传递消息；&lt;/li&gt;
&lt;li&gt;x-queue-master-locator：在集群模式下设置镜像队列的主节点信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;持久化队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建队列的时候将持久化属性durable设置为true，同时要将autoDelete设置为false&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Queue(value = &quot;javatrip&quot;,durable = &quot;false&quot;,autoDelete = &quot;false&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;持久化消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送消息的时候将消息的deliveryMode设置为2，在Spring Boot中消息默认就是持久化的。&lt;/p&gt;
&lt;h2 id=&quot;三-消费者消费消息的时候，未消费完毕就出现了异常&quot;&gt;三 消费者消费消息的时候，未消费完毕就出现了异常&lt;/h2&gt;
&lt;p&gt;消费者刚消费了消息，还没有处理业务，结果发生异常。这时候就需要关闭自动确认，改为手动确认消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改yml为手动签收模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  rabbitmq:
    listener:
      simple:
        # 手动签收模式
        acknowledge-mode: manual
        # 每次签收一条消息
        prefetch: 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消费者手动签收&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@RabbitListener(queuesToDeclare = @Queue(value = &quot;javatrip&quot;, durable = &quot;true&quot;))
public class Consumer {

    @RabbitHandler
    public void receive(String message, @Headers Map&amp;lt;String,Object&amp;gt; headers, Channel channel) throws Exception{

        System.out.println(message);
        // 唯一的消息ID
        Long deliverTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);
        // 确认该条消息
        if(...){
                channel.basicAck(deliverTag,false);
        }else{
            // 消费失败，消息重返队列
            channel.basicNack(deliverTag,false,true);
        }
      
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四-总结&quot;&gt;四 总结&lt;/h2&gt;
&lt;h4 id=&quot;消息丢失的原因？&quot;&gt;消息丢失的原因？&lt;/h4&gt;
&lt;p&gt;生产者、MQ、消费者都有可能造成消息丢失&lt;/p&gt;
&lt;h4 id=&quot;如何保证消息的可靠性？&quot;&gt;如何保证消息的可靠性？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;发送方采取发送者确认模式&lt;/li&gt;
&lt;li&gt;MQ进行队列及消息的持久化&lt;/li&gt;
&lt;li&gt;消费者消费成功后手动确认消息&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1719198/202008/1719198-20200805085140187-1316975328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 05 Aug 2020 00:52:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>一条消费成功被消费经历了生产者-&amp;amp;gt;MQ-&amp;amp;gt;消费者，因此在这三个步骤中都有可能造成消息丢失。 一 消息生产者没有把消息成功发送到MQ 1.1 事务机制 AMQP协议提供了事务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13437647.html</dc:identifier>
</item>
<item>
<title>Docker-compose实战 - 北漂码农有话说</title>
<link>http://www.cnblogs.com/triumph-wyp-com/p/13437600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/triumph-wyp-com/p/13437600.html</guid>
<description>
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位小伙伴们，我们前面的篇文章分享了、&lt;code&gt;docker&lt;/code&gt;的基础知识点、如何编写一个&lt;code&gt;Dockerfile&lt;/code&gt;、&lt;code&gt;docker&lt;/code&gt;网络是怎么回事、如何编写&lt;code&gt;docker-compose.yml&lt;/code&gt;文件。已经为本文做好了充分的铺垫。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这边文章就和小伙本们分享如何将你自己的微服务项目进行服务的编排。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;准备&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想编排项目，首先我们得有一个项目。不要着急，作者给大家准备了一个自己的&lt;code&gt;SpringCloud&lt;/code&gt;的项目，包含服务注册中心、服务的提供者、服务的消费者、配置中心等。本文我们会用到其中的三个服务来进行服务编排。&lt;a href=&quot;https://github.com/triumphxx/cloud-framework&quot;&gt;项目GitHub地址&lt;/a&gt;，项目结构如下图：&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/springcloud/cloud-product-tree.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说明：本次我们只会用到其中的三个服务,&lt;code&gt;eureka-server&lt;/code&gt;:服务注册中心,&lt;code&gt;order-server&lt;/code&gt;：订单服务,&lt;code&gt;order-client-feign&lt;/code&gt;：订单查询服务&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;开始&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进行服务编排以前，我们需要给要给要编排的服务编写&lt;code&gt;Dockerfile&lt;/code&gt;文件。首先来编写&lt;code&gt;eureka-server&lt;/code&gt;:服务注册中心的文件&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;创建&lt;code&gt;Dockerfile&lt;/code&gt;文件&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将项目&lt;code&gt;clone&lt;/code&gt;到你的本地，打开项目根目录，创建&lt;code&gt;Dockerfile&lt;/code&gt;文件，并为为项目编写&lt;code&gt;Dockerfile&lt;/code&gt;文件，至于&lt;code&gt;Dockerfile&lt;/code&gt;文件的每一行命令是什么意思，请参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NzM5MTU1Ng==&amp;amp;mid=2247484040&amp;amp;idx=1&amp;amp;sn=37b9d6bc739308e564d12fac94eda9f8&amp;amp;chksm=ebcf28a3dcb8a1b5a137f998a2a3fb6232f6a6128c3b415fc45938bc72515cc797f4b8259085&amp;amp;token=31369571&amp;amp;lang=zh_CN#rd&quot;&gt;Dockerfile你值得拥有&lt;/a&gt; 如下图：&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/docker-se-compostion/dockerfile-eureka.png&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;构建镜像&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小伙伴们还不知道如何构建镜像，请看这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NzM5MTU1Ng==&amp;amp;mid=2247484040&amp;amp;idx=1&amp;amp;sn=37b9d6bc739308e564d12fac94eda9f8&amp;amp;chksm=ebcf28a3dcb8a1b5a137f998a2a3fb6232f6a6128c3b415fc45938bc72515cc797f4b8259085&amp;amp;token=31369571&amp;amp;lang=zh_CN#rd&quot;&gt;Dockerfile你值得拥有&lt;/a&gt; ,在执行以下命令之前先将&lt;code&gt;jar&lt;/code&gt;包打出来。即&lt;code&gt;eureka-server-0.0.1-SNAPSHOT.jar&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行如下俩行命令&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 构建镜像&lt;/span&gt;&lt;br/&gt;docker build -f /Users/wangyupeng/IdeaProjects/cloud-framework/eureka-server/Dockerfile .&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 指定镜像仓库个tag&lt;/span&gt;&lt;br/&gt;docker build -t cloud-framework/eureka:1.0 .&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完命令后，我们执行&lt;code&gt;docker images&lt;/code&gt;，查看是否有我们的镜像生成，如下图&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/docker-se-composetion/docker-images-eureka.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，我们完成&lt;code&gt;order-server&lt;/code&gt;：订单服务,&lt;code&gt;order-client-feign&lt;/code&gt;：订单查询服务的镜像构建工作。镜像仓库和镜像&lt;code&gt;tag&lt;/code&gt;分别是&lt;code&gt;cloud-framework/order-client-feign:1.0&lt;/code&gt;和,&lt;code&gt;cloud-framework/order-server:1.0&lt;/code&gt;如下图,可见，我们自己构建的&lt;code&gt;docker&lt;/code&gt;镜像。&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/docker-se-composetion/docker-images.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.6989247311828&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里忘记了一件重要的事情，由于&lt;code&gt;docker&lt;/code&gt;默认的网络模式是&lt;code&gt;bridge&lt;/code&gt;参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NzM5MTU1Ng==&amp;amp;mid=2247484060&amp;amp;idx=1&amp;amp;sn=9acbfc76296b28a40fbf661d36041fd6&amp;amp;chksm=ebcf28b7dcb8a1a15137e6ca13cfab670e7dfa60d5bae7f3569a71ef6b86d1ad73929c91ea5b&amp;amp;token=31369571&amp;amp;lang=zh_CN#rd&quot;&gt;docker网络&lt;/a&gt;，各个容器的&lt;code&gt;IP&lt;/code&gt;都不相同，所以我们需要给&lt;code&gt;Eureka Server&lt;/code&gt; ，配置一个主机名：&lt;code&gt;EurekaServer&lt;/code&gt;，所有的微服务都使用主机名连接注册中心。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;修改配置&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先将注册中心的配置进行修改：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;eureka:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;instance:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;localhost&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  client:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    fetch-registry:&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    register-with-eureka:&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    service-url:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;      defaultZone:&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;http://${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;eureka:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  instance:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;EurekaServer&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  client:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    fetch-registry:&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    register-with-eureka:&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    service-url:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;      defaultZone:&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;http://${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将服务消费与提供者的配置修改如下&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;eureka:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  client:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    service-url:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;      defaultZone:&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;http://EurekaServer:8761/eureka&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;重新构建镜像&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按上面的构建镜像的步骤，分别生成新的镜像。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;编写&lt;code&gt;docker-compose.yml&lt;/code&gt;文件&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'3.8'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  eureka-server:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud-framework/eureka:1.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    container_name:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud_eureka&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    hostname:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;EurekaServer&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    ports:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8761:8761&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    networks:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloudnetwork&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  order-server:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud-framework/order-service:1.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    container_name:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud_order-server&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    ports:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8081:8081&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    links:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;      - eureka-server:&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;EurekaServer&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    networks:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloudnetwork&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    depends_on:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;eureka-server&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  order-client:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud-framework/order-client-feign:1.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    container_name:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloud_order-client&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    ports:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9001&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;:9001&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    links:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;      - eureka-server:&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;EurekaServer&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    networks:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;cloudnetwork&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    depends_on:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;      -&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;eureka-server&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-attr&quot;&gt;networks:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;  cloudnetwork:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;    driver:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;bridge&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上都是一些常规的配置，包括服务的名称，所用的镜像，容器的名称，端口的映射，使用的网络，其中&lt;code&gt;depends_on&lt;/code&gt;配置的意思是，本服务需要依赖&lt;code&gt;eureka-server&lt;/code&gt;,还有需要注意的一点是：由于&lt;code&gt;docker&lt;/code&gt;默认的网络模式&lt;code&gt;bridge&lt;/code&gt;,所以需要修改&lt;code&gt;eureka-server&lt;/code&gt;服务的配置&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 将hostname由变为localhost EurekaServer&lt;/span&gt;&lt;br/&gt;eureka:&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;  #&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 设置Eureka的hostname&lt;/span&gt;&lt;br/&gt;instance:&lt;br/&gt;hostname: EurekaServer&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;  #&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 设置不检索其他服务&lt;/span&gt;&lt;br/&gt;client:&lt;br/&gt;fetch-registry: false&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;  #&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 不注册自己&lt;/span&gt;&lt;br/&gt;register-with-eureka: false&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;  #&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 服务注册地址&lt;/span&gt;&lt;br/&gt;service-url:&lt;br/&gt;defaultZone: http://EurekaServer:${server.port}/eureka/&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的&lt;code&gt;order-service&lt;/code&gt;和&lt;code&gt;order-client-feign&lt;/code&gt;服务的配置也需要修改为如下配置：&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;eureka:&lt;br/&gt;client:&lt;br/&gt;service-url:&lt;br/&gt;defaultZone: http://EurekaServer:8761/eureka&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;启动&lt;code&gt;Compose&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入到&lt;code&gt;docker-compose.yml&lt;/code&gt;文件所在目录执行如下命令,然后浏览器输入&lt;code&gt;http://localhost:8761/&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;docker-compose up&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到如下画面，说明我们利用&lt;code&gt;docker-compose&lt;/code&gt;将&lt;code&gt;SpringCloud&lt;/code&gt;服务编排成功了&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/docker-compose/docker-se-up.png&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;验证&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们执行如下命令进入到&lt;code&gt;order-client-feign&lt;/code&gt;容器内部&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 首先执行，找到服务运行的容器&lt;/span&gt;&lt;br/&gt;docker ps&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;然后执行下面命令，进入到容器&lt;/span&gt;&lt;br/&gt;docker exec -it af01ed522b98  /bin/bash &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 然后访问服务提供者的接口&lt;/span&gt;&lt;br/&gt;curl -v http://localhost:9001/query&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现如下结果，表示在容器内部我们也能够访问到接口，并成功返回结果&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/docker-compose/docker-con-in.png&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，小伙伴们，本文我们讨论了，如何将自己的&lt;code&gt;SpringCloud&lt;/code&gt;微服务，使用&lt;code&gt;Dockerfile&lt;/code&gt;进行服务构建，并使用&lt;code&gt;docker-compose&lt;/code&gt;进行服务编排，并成功编排完成。相关代码案例以上传到 &lt;a href=&quot;https://github.com/triumphxx/cloud-framework&quot;&gt;GitHub&lt;/a&gt;，当然，作者只是编排了三个服务，小伙伴们可以自行拉取代码，将其他的服务一并进行编排试验。&lt;/p&gt;
&lt;img src=&quot;http://cdn.triumphxx.com.cn/img/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Wed, 05 Aug 2020 00:34:00 +0000</pubDate>
<dc:creator>北漂码农有话说</dc:creator>
<og:description>Docker-compose实战 各位小伙伴们，我们前面的篇文章分享了、docker的基础知识点、如何编写一个Dockerfile、docker网络是怎么回事、如何编写docker-compose.y</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/triumph-wyp-com/p/13437600.html</dc:identifier>
</item>
<item>
<title>趣讲 PowerJob 超强大的调度层，开始表演真正的技术了 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13435636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13435636.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804201146722-2098762237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;Salieri&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;写在前面的碎碎念：终于到了万众期待的调度层原理了。其实很早之前就想动笔把这部分好好给大家讲讲，因为问的人实在是太多了...大部分小伙伴进用户群的第一句话就是：“群猪，请问无锁化调度是怎么实现的？”，剩下的犀利点的小伙伴甚至直接问：“群猪，你这个性能强劲无上限体现在什么地方啊？”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可惜不巧的是，鄙人在 7 月初给自己安排了一个惊险刺激的大西北旅游，每天不是在坐车就是在前往坐车的路上，虽然感受到了祖国疆域之辽阔、风景之秀丽、文化之璀璨，人累个半死也是确有其事。文章嘛，自然也就是一路鸽到了现在...&lt;/p&gt;
&lt;p&gt;那么，是时候表演真正的技术了～&lt;/p&gt;
&lt;h2 id=&quot;一、调度层概览&quot;&gt;一、调度层概览&lt;/h2&gt;
&lt;p&gt;PowerJob 目前支持 4 种定时执行策略，分别是 CRON、固定频率、固定延迟 和 API。API 指的是通过 PowerJob 提供的客户端接口直接启动任务的方式，不需要 server 来支持调度，此处忽略。而剩下的 3 种调度策略，根据其执行频率的不同，可以划分为&lt;strong&gt;常规任务&lt;/strong&gt;和&lt;strong&gt;秒级任务&lt;/strong&gt;。我们先讲常规任务。&lt;/p&gt;
&lt;p&gt;常规任务指由 CRON 表达式指定定时策略的任务，这一类任务的特点是 &lt;strong&gt;执行频率不高。&lt;/strong&gt; 对于这类任务，PowerJob 采用基于数据库轮询的策略来进行调度，具体的原理图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200753351-487583823.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PowerJob 的任务表中，除了维护任务的基础元数据（如任务名称、定时策略、执行器信息等）之外，还会额外增加一个字段 &lt;strong&gt;next_trigger_time&lt;/strong&gt;，也就是&lt;strong&gt;下一次调度时间&lt;/strong&gt;，当任务被成功创建时，系统会使用 CRON 表达式去初始化该字段，保证每一个 CRON 任务都存在可用的&lt;strong&gt;下一次调度时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了这个字段，具体的调度就好办了。powerjob-server 会启用一个后台线程定期扫描任务表，查找那些&lt;strong&gt;由本机调度的&lt;/strong&gt;、即将执行（即下一次调度时间与当前时间的差值小于系统规定的阈值）的任务。&lt;/p&gt;
&lt;p&gt;（这里埋个小小的伏笔，“由本机调度”其实是实现无锁化调度的关键，将在下一篇文章为大家揭秘，本文主要讲述调度流程，因此直接以单机为例）&lt;/p&gt;
&lt;p&gt;一旦发现接下来的一段时间内有任务需要被调度执行，就会为这些任务生成执行记录并推入时间轮，最后完成任务的调度。&lt;/p&gt;
&lt;p&gt;听起来似乎很平淡无奇的一个流程，存在着那些精彩的设计与实现呢？请听我细细分解～&lt;/p&gt;
&lt;h2 id=&quot;二、高性能调度时间轮&quot;&gt;二、高性能调度——时间轮&lt;/h2&gt;
&lt;p&gt;假如，现在给你一个任务，要求 2 秒后执行，你会怎么解决的？&lt;/p&gt;
&lt;p&gt;最简单的方案，也就是利用休眠。1 秒后执行，那么我让当前线程 sleep 1 秒，不就达到目的了吗？没错，基于线程休眠的特性，可以用三行代码实现一个最简单的定时执行器，但是它的性能嘛...自然也是相当的拉垮...由于每一个任务都需要绑定一个单独的线程，当系统中存在大量任务时，这种方案消耗的资源极其庞大。&lt;/p&gt;
&lt;p&gt;那么如何实现高效的调度呢？&lt;/p&gt;
&lt;p&gt;也许，就和牛顿被苹果砸出万有引力引力一样，发明时间轮算法的大神，在为寻找高效调度方案而苦恼不已时，低头看了看自己的劳力士～觉得这个表如此的朴实无华的同时，似乎找到了那么一点点灵感～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200808893-156870632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据前面分析，线程休眠型调度器之所以低效，是因为它需要用到大量的线程资源，这浪费了大量的 CPU 和内存资源。那么有没有办法来避免这个消耗呢？看着这个表，有人找到了答案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200824957-2055135753.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器（一个线程）上面，使用这一个调度器来进行所有任务的管理，触发以及运行，能够高效的管理各种延时任务，周期任务，通知任务等等。&lt;/p&gt;
&lt;p&gt;时间轮的算法模型如上图所示，每个时间轮存在着 N 个槽，两个槽之间的间隔时间固定。每走一个时间间隔，指针就向前推进一格，然后开始处理当前槽内的所有任务。指针不断循环推进，直到时间轮中不存在任何任务。&lt;/p&gt;
&lt;p&gt;当新增调度任务时，可根据任务的调度时间和当前时间计算出具体的时间槽。为了能以时间复杂度 O(1) 的代价将任务放入指定位置，需要时间槽具有随机访问的能力，为此该部分使用循环数组实现。每一个时间槽对应的任务队列长度不确定，且只需要提供顺序访问能力，为此任务队列使用单向链表实现。&lt;/p&gt;
&lt;p&gt;每一个时间轮都有两个必备参数，时间间隔 tickDuration 和 刻度数量 ticksPerWheel。这两个参数也很好理解，时间间隔就是指针转动的频率，刻度数量就是这个表盘内任务槽的数量，拿现实中的手表来说，tickDuration 就是 1，ticksPerWheel 是 12。&lt;/p&gt;
&lt;p&gt;讲了那么多理论，这里举个具体的例子来帮助大家理解时间轮（其实时间轮的概念非常好理解，具体的实现也不算很难，可以说是一种性价比超高的数据结构了～）&lt;/p&gt;
&lt;p&gt;假如我现在有一个时间间隔为 1 秒，刻度数为 12 的时间轮，现在需要调度 3 个定时任务，分别在 1 秒、6 秒和 13 秒后执行，那么时间轮的工作流程是怎么样的呢？&lt;/p&gt;
&lt;p&gt;首先，第一步是任务的插入。由于表盘的设计是环形数据，通过 &lt;code&gt;（预计执行时间 - 时间轮启动时间）% 刻度数&lt;/code&gt; 这个公式便能算出该任务的插槽下标，即这些任务会分别被插入到 0、5 和 0 号槽对应的链表中。&lt;/p&gt;
&lt;p&gt;完成任务的插入后，接下来就等着调度线程取出任务并执行了。调度线程通过休眠 tickDuration 的方式，循环读取下一个槽中链表中的任务并执行。由于链表中的任务可能不是本轮需要调度的（就比如 13 秒后执行的任务，其实是下一个调度周期才需要执行），需要额外对任务的预计执行时间做判断，只有符合要求的任务才会被调度执行，并从链表中移除。&lt;/p&gt;
&lt;p&gt;这样就做到了 1 个线程完成大量任务的调度，兼备性能和效率。唯一的缺点是由于采取了 tickDuration，那么调度会存在着一定的误差。如果你对调度执行的时间精度要求极高，那时间轮可能不是你的菜，否则，还不赶紧抱走？&lt;/p&gt;
&lt;p&gt;时间轮的概念讲完了，接下来回归框架本身。PowerJob 所使用的时间轮设计整体参考 Netty，并在一些地方做了定制化处理，比如由于 PowerJob 调度后执行任务有一定的开销（涉及数据库操作），因此除了指针线程，还额外引入了处理线程池来保证调度的精度。源码一共 326 行，有兴趣的话，快去看吧，类名都给你准备好啦！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.github.kfcfans.powerjob.server.common.utils.timewheel.HashedWheelTimer
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、可靠调度wal&quot;&gt;三、可靠调度——WAL&lt;/h2&gt;
&lt;p&gt;可靠调度也是大家广为关注的一个问题，甚至还有同学在 GitHub Issue 留言告诉我他们自研的调度系统在生产环境中遇到的不可靠调度问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200842817-1523685651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么 PowerJob 存在着错过调度的问题吗？&lt;strong&gt;答案显然是否定的&lt;/strong&gt;。（作为一款一直强调极高可用性和稳定性的生产级调度中间件，要是这一点都做不到，那还有脸见人吗？&lt;/p&gt;
&lt;p&gt;那么问题又来了，这，又是如何实现的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200854173-573831862.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道大家有没有听说过 &lt;strong&gt;WAL（Write-Ahead Logging，预写式日志）&lt;/strong&gt;，这是主流关系型数据库（MS SQLServer、MySQL、Oracle）用来确保了事务原子性和持久性的关键技术。WAL 的核心思想是： &lt;strong&gt;在数据写入到数据库之前，先写入到日志中。&lt;/strong&gt; 这样，在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。&lt;/p&gt;
&lt;p&gt;PowerJob 为了实现任务的可靠调度，也借鉴了该思想。每一个任务被调度执行时，系统都会为其生成一条记录，这条记录包含了该任务实例（任务的一次运行叫任务实例）的预期调度时间。之后，PowerJob 会首先将该记录持久化到数据库中，只有持久化成功后，该任务才会被正式推入时间轮进行调度。&lt;/p&gt;
&lt;p&gt;一旦这一台 server 宕机，任务没有被准时执行。其他 server 就能根据已经写入数据库中的任务实例记录将其恢复，做到可靠调度～&lt;/p&gt;
&lt;p&gt;也就是说，只要你的系统中还有一台 powerjob-server 活着，就不会有缺失调度的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200909886-184340547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、秒级任务&quot;&gt;四、秒级任务&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;说够了常规任务的调度，让我们来侃侃秒级任务～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;秒级任务的特点是运行频率极高（吐槽：这不是废话吗），那么能不能用支持常规任务调度的这套方法来支撑秒级任务的调度呢？&lt;/p&gt;
&lt;p&gt;首先是任务的获取。emmm...“一定时间间隔扫描任务表获取待执行任务”，这...等你获取到任务，黄花菜都凉了...这不中啊...没错，使用传统调度方案，第一步就挂了。（我想到了路途艰难，但没想到居然那么难！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804200923146-1803040423.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过，比较聪明的同学可能想到了。既然秒级任务执行频率很高，那 server 获取这个任务后，可以将它保存起来，这样下一次调度就不需要单独查数据库了，而是选择内存遍历，要多快有多快，似乎就解决了这个问题。&lt;/p&gt;
&lt;p&gt;然而，这种方式仍不完美。俗话说得好，物以稀为贵，秒级任务的执行频率那么高，在大部分情况下，其实失败个一两次也没什么关系，毕竟立即就会有下一个任务补上。因此，传统任务那一套为了可靠调度而生的机制并不适用于秒级任务，秒级任务使用了那套机制后，也会对数据库产生较大的冲击，导致 PowerJob 整体的性能大幅度下降。那么出路究竟在何方呢？&lt;/p&gt;
&lt;p&gt;此时就不得不提解决计算机领域问题的终极神器了：分治。既然不强要求任务执行有非常高的可靠性，那么 powerjob-server 此时就可以放权了。&lt;/p&gt;
&lt;p&gt;每一个秒级任务，都会直接被投递到集群中的某一台 powerjob-worker 上，由 powerjob-worker 全权负责执行。而 powerjob-server 此时只需要负责故障恢复即可。&lt;/p&gt;
&lt;p&gt;这样一来，server 的压力进一步减轻，同时，由于秒级任务的调度与执行全部落在了 worker 身上，调度的精度也会上升（至少能省下通讯的网络延迟），可谓是一个完美至极的双赢方案。&lt;/p&gt;
&lt;h2 id=&quot;五、最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;那么以上就是本篇文章全部的内容啦～&lt;/p&gt;
&lt;p&gt;本篇文章讲述了 PowerJob 调度层的实现与其中一些精巧的设计。不过限于篇幅，整个调度层其实并没有完全呈现在大家眼前，目前还是犹抱琵琶半遮面的状态～大家最关心的多 server 下任务如何避免重复调度、多 server 如何实现水平的能力扩展本文都没有详细提及，只是简单说了几个字。具体的内容，就放在下一篇文章讲啦～提前剧透一下吧，核心就四个字：&lt;strong&gt;分组隔离&lt;/strong&gt;。等不及的话，自己去代码中寻找答案吧，少年～&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/KFCFans/PowerJob&quot;&gt;https://github.com/KFCFans/PowerJob&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200804201004703-1388448911.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Aug 2020 00:21:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 作者：HelloGitHub-Salieri HelloGitHub 推出的《讲解开源项目》系列。 写在前面的碎碎念：终于到了万众期待的调度层原理了。其实很早之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13435636.html</dc:identifier>
</item>
<item>
<title>重温四大基础数据结构：数组、链表、队列和栈 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13437554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13437554.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081813714-1550683399.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;4.0625&quot;&gt;
&lt;p&gt;本文收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;，点击解锁更多数据结构与算法的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。&lt;/p&gt;
&lt;p&gt;数组、链表、队列、栈，是数据结构中最基础的四大结构，数组和链表更是基础中的基础，后续所有复杂的数据结构都是在它们的基础上演变而来的。&lt;/p&gt;
&lt;p&gt;本节，我们就来重温这四大结构。&lt;/p&gt;

&lt;p&gt;关于数组，大家都比较熟悉了。&lt;/p&gt;
&lt;p&gt;它是一种线性数据结构，使用一组连续的内存空间存储一组具有相同类型的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081814116-225091817.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个概念中有三个关键词：线性、连续、相同类型。&lt;/p&gt;
&lt;p&gt;线性，表示没有分叉，任意元素的前后元素最多只有一个，同样是线性结构的还有链表、队列等。&lt;/p&gt;
&lt;p&gt;连续，它在内存空间中的存储是连续的，不间断的，前后两个元素紧挨着，不存在间隙。&lt;/p&gt;
&lt;p&gt;相同类型，数组中存储的元素的类型一定是相同的，当然，在Java中，你可以使用Object代表所有类型，本质上，它们依然是相同类型。&lt;/p&gt;
&lt;p&gt;正是有了上面三个特性，才使得数组具有了&lt;strong&gt;随机访问&lt;/strong&gt;的特性，那么，什么是随机访问呢？&lt;/p&gt;
&lt;p&gt;简单点说，你可以通过下标快速定位到数组中的元素，且时间复杂度是O(1)，它是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;我们知道，计算机中只有0和1，一切的一切都可以看作是0和1的各种组合，内存也是一样。&lt;/p&gt;
&lt;p&gt;当我们创建一个数组，比如&lt;code&gt;int[] array = new int[]{2, 5, 8, 7};&lt;/code&gt;时，它其实返回的是这个数组在内存中的位置（地址），我们知道，一个int类型占用4个字节，也就是32位的0或1，当我们访问数组下标为0的元素时，直接返回数组地址处取32位转成int即可，同样地，当我们访问数组下标为1的元素时，返回数组地址加上(32*1)的地址处取32位转成int，依此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081814468-1070089458.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也是大部分语言中数组下标从0开始的原因，试想如果下标从1开始，那么，计算内存地址的时候就变成了&lt;code&gt;address + 32 * (i - 1)&lt;/code&gt;，这显然会造成一定的性能损耗。&lt;/p&gt;

&lt;p&gt;链表，它也是一种线程数据结构，与数组不同的是，它在内存空间中不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081814789-1939003508.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是典型的单链表结构，在单链表中，只有一个指向下一个元素的指针。&lt;/p&gt;
&lt;p&gt;如果要用Java类来表示单链表中的元素节点的话，大概看起来像这样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Node {
    int value;
    Node next;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始（单链表），它的时间复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;上面我们说的是单链表，如果在单链表的基础上再增加一个前驱指针（指向前一个元素的指针），就变成了双向链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081815160-522831973.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java中的LinkedList就是典型的双向链表结构，双向链表既可以当作队列使用，又可以当作栈来使用，非常方便。&lt;/p&gt;
&lt;p&gt;如果在双向链表的基础上再增加HashMap的功能，就变成了LinkedHashMap了，咳咳，扯远了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;希望学习LinkedList和LinkedHashMap源码解析的同学，可以关注我的公号主“彤哥读源码”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里提到了队列，那么，什么是队列呢？&lt;/p&gt;

&lt;p&gt;所谓队列，其实跟现实中的排队是一样的，其中的元素从一端进入，从另一端出去，英文叫做：First In，First Out，简写FIFO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081815475-1469091068.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这张图，也可以看出来，实现队列最简单的方式就是使用链表，把上图中的箭头倒过来即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081815815-153399157.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入队时，将元素加入到链表尾端，出队时，将第一个元素删除并将头节点指向下一个节点即可。&lt;/p&gt;
&lt;p&gt;让我们来看看使用链表实现队列的简单代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinkedQueue {
    Node head;
    Node tail;

    void offer(Integer value) {
        if (value == null) {
            throw new NullPointerException();
        }
        Node node = new Node(value);
        if (head == null) {
            head = tail = node;
        } else {
            tail.next = node;
            tail = node;
        }
    }

    Integer poll() {
        Node first = head;
        if (first != null) {
            head = first.next;
            first.next = null;
            return first.value;
        } else {
            return null;
        }
    }

    static class Node {
        int value;
        Node next;

        public Node(int value) {
            this.value = value;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单呢？&lt;/p&gt;
&lt;p&gt;那么，数组能不能实现队列呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的，使用数组实现队列有很多种方式，其中一种是使用两个指针：入指针、出指针，它们分别指向下一个入队列和下一个出队列的位置。&lt;/p&gt;
&lt;p&gt;入队时，在入指针处放入元素，同时入指针后移。&lt;/p&gt;
&lt;p&gt;出队时，取出出指针处的元素返回，同时出指针后移。&lt;/p&gt;
&lt;p&gt;当指针到达数组末尾时，返回数组开始的位置。&lt;/p&gt;
&lt;p&gt;这样就形成了一个可以循环使用的数组，俗称环形数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081816271-1815493816.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们考虑一个问题，队列空和队列满时，两个指针都是指向同一个位置，似乎不太好处理。&lt;/p&gt;
&lt;p&gt;其实，很简单，引入一个size变量标识队列中有多少个元素即可。&lt;/p&gt;
&lt;p&gt;所以，这玩意儿要怎么实现呢？Show me the code!&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ArrayQueue {
    int[] array;
    int offerIndex;
    int pollIndex;
    int size;

    public ArrayQueue(int capacity) {
        this.array = new int[capacity];
        this.offerIndex = this.pollIndex = 0;
        this.size = 0;
    }

    boolean offer(Integer value) {
        if (value == null) {
            throw new NullPointerException();
        }

        if (size == array.length) {
            return false;
        }

        array[offerIndex] = value;
        offerIndex = (offerIndex + 1) % array.length;

        size++;

        return true;
    }

    Integer poll() {
        if (size == 0) {
            return null;
        }

        int value = array[pollIndex];
        pollIndex = (pollIndex + 1) % array.length;

        size--;

        return value;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，以上就是使用数组实现的队列，可以看到，与链表实现的队列相比，它需要指定容量，这叫做&lt;code&gt;有界队列&lt;/code&gt;，如果需要使用数组实现无界队列，则需要加入扩容的机制，有兴趣的同学可以自己实现看看。&lt;/p&gt;
&lt;p&gt;下面，我们再来看另一种基础的数据结构——栈。&lt;/p&gt;

&lt;p&gt;栈，它是与队列表现完全相反的数据结构，它的元素是先进的后出来，就像我们往一个杯子里面放东西一样，先放进去的放在最下面，只有把上面的东西拿出来后才能拿出下面压着的东西，这种行为用英文叫做：First In，Last Out，简称FILO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081816660-2134127047.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;栈，具有很多用处，计算机中很多处理都是通过栈这种数据结构来进行的，比如算术运算，准备两个栈，一个栈存储数字，一个栈存储符号，从头开始依次把字符压入到这两个栈中，当遇到符号优先级比栈顶元素低时，则取出栈顶符号，并从数字栈中取出两个数字进行运算，运算的结果再压回数字栈中，继续以此运行，当所有字符都放入栈之后，依次从数字栈中取出两个元素，并从符号栈中取出一个元素，进行计算，结果压回数字栈，继续以此运行，直到符号栈为空，或者数字栈只剩下一个元素为止，弹出这个数字即为最后的结果。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;3 + 2 * 4 -1&lt;/code&gt;为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200805081817094-1539083352.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，关于栈，我们就简单介绍到这里，后面，我们还会大量遇到这个数据结构。&lt;/p&gt;

&lt;p&gt;本节，我们一起重温了数组、链表、队列、栈这四种最基础的数据结构。&lt;/p&gt;
&lt;p&gt;说起数组，我们看到，内存本身就是一张大数组，它里面的元素就是0和1，那么，我们能不能直接操作这些0和1呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的。&lt;/p&gt;
&lt;p&gt;下一节，我们将介绍位运算，以及位图这种数据结构，彼时，我们将详细介绍如何使用&lt;code&gt;位图来实现12306的抢票逻辑&lt;/code&gt;，关注我，及时获取最新推文。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公号主“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Aug 2020 00:18:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 本文收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。 你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。 数组、链表、队列、栈，是数据结构中最基础的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13437554.html</dc:identifier>
</item>
<item>
<title>我还在生产玩 JDK7，JDK 15 却要来了!|新特性尝鲜 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13437509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13437509.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073515465-1087956696.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自从 JDK9 之后，每年 3 月与 9 月 JDK 都会发布一个新的版本，而2020 年 9 月即将引来 JDK15。&lt;/p&gt;
&lt;p&gt;恰巧 IDEA 每四五个月会升级一个较大的版本，每次升级之后都会支持最新版本 JDK 引入的新功能。&lt;/p&gt;
&lt;p&gt;这几天升级了 IDEA，顺便体验了一下 JDK15 的新特性。&lt;/p&gt;
&lt;p&gt;虽然我知道你们可能跟我一样JDK8 都还没用熟，但是无妨，看看新版本 JDK 来酸一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073515744-685675113.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;text-blocks-最终定板&quot;&gt;Text Blocks 最终定板&lt;/h2&gt;
&lt;p&gt;之前版本的 JDK，如果我们需要插入 &lt;strong&gt;HTML&lt;/strong&gt;，&lt;strong&gt;XML&lt;/strong&gt;，&lt;strong&gt;SQL&lt;/strong&gt; 或 &lt;strong&gt;JSON&lt;/strong&gt; 片段，非常麻烦，需要对里面符号进行各种转义。&lt;/p&gt;
&lt;p&gt;所以我每次都会在其他编辑器将 &lt;strong&gt;HTML&lt;/strong&gt; ,&lt;strong&gt;XML&lt;/strong&gt; 等编辑好，然后直接复制到 IDEA 中，IDEA 自动会对这些字符转义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073516164-2125141226.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次复制进去就变成上图的效果，如果上面字符再多点，阅读起来就会更难，并且难以维护。&lt;/p&gt;
&lt;p&gt;所幸 IDEA 提供了一个 &lt;strong&gt;Inject Language&lt;/strong&gt; 功能，我们可以在里面快速方便的编辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073516357-1063118793.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java 开发者也关注到这个问题，他们在 JDK13 引入的一个新的预览特性「&lt;strong&gt;Text Blocks&lt;/strong&gt;」，可以使用三引号将复杂的字符串赋值，从而让我们从各种转义中解脱出来，可以更加方便的编辑字符串。&lt;/p&gt;
&lt;p&gt;这个功能在其他语言还是比较常见的，比如 Python 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Text Blocks&lt;/strong&gt; 新功能在 JDK14 再次以预览功能引入，最终在 JDK15 成为新版本的正式功能。&lt;/p&gt;
&lt;p&gt;下面我们来对比一下使用 &lt;strong&gt;Text Blocks&lt;/strong&gt; 与之前区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073516547-1513648087.jpg&quot; alt=&quot;Html&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073516881-529596295.jpg&quot; alt=&quot;SQL&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073517333-839006147.jpg&quot; alt=&quot;JS&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;records-second-preview&quot;&gt;Records (Second Preview)&lt;/h2&gt;
&lt;p&gt;JDK14 引入一个新的预览特性 &lt;strong&gt;record&lt;/strong&gt; 语法，可以快速创建一个纯数据类，并且不用去生成 &lt;strong&gt;getter&lt;/strong&gt;，&lt;strong&gt;toString&lt;/strong&gt; 等。&lt;/p&gt;
&lt;p&gt;使用下面的语法就可以快速创建一个数据类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public record Point(int x,int y) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDK15 是 &lt;strong&gt;record&lt;/strong&gt; 这个语法的第二次预览，这个版本增加一个新的功能 「&lt;strong&gt;local record&lt;/strong&gt;」，可以在一个方法在快速创建一个类，以便于方法中业务逻辑计算。&lt;/p&gt;
&lt;p&gt;在以下示例中，使用本地记录 &lt;strong&gt;MerchantSales&lt;/strong&gt; 对商人和每月销售额的汇总进行建模，使用此记录可提高以下流操作的可读性：&lt;/p&gt;
&lt;p&gt;下面例子的中我们新建一个类 &lt;strong&gt;MerchantSales&lt;/strong&gt;，然后按照销售人员对每月的销售额汇总排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Merchant&amp;gt; findTopMerchants(List&amp;lt;Merchant&amp;gt; merchants, int month) {
    // Local record
    record MerchantSales(Merchant merchant, double sales) {}

    return merchants.stream()
        .map(merchant -&amp;gt; new MerchantSales(merchant, computeSales(merchant, month)))
        .sorted((m1, m2) -&amp;gt; Double.compare(m2.sales(), m1.sales()))
        .map(MerchantSales::merchant)
        .collect(toList());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原先如果需要使用这种功能，我们不得不创建一个内部类，后续可能再也不会用到，使用 &lt;strong&gt;local record&lt;/strong&gt;就解决这个尴尬的问题。&lt;/p&gt;
&lt;p&gt;除了 &lt;strong&gt;local record&lt;/strong&gt; 我们还可以创建 &lt;strong&gt;local enums&lt;/strong&gt; 以及 &lt;strong&gt;local interface&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// local enums
public void organisePeople(List&amp;lt;Person&amp;gt; people) {
    enum Role {
        Employee, Customer, Both, None
    }
    HashMap&amp;lt;Role, List&amp;lt;Person&amp;gt;&amp;gt; peopleByRole = new HashMap&amp;lt;&amp;gt;();
    people.stream()
            .filter(Person::isCustomer)
            .forEach(person -&amp;gt; peopleByRole.computeIfAbsent(Role.Customer, role -&amp;gt; new ArrayList&amp;lt;&amp;gt;())
                    .add(person));
    // 其他业务逻辑

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// local interface
public void localInterface() {
    interface MyInterface {
        void doSomething();
    }
    MyInterface testInterface = new MyInterface() {
        @Override
        public void doSomething() {
            System.out.println(&quot;Hello World!&quot;);
        }
    };
    // 其他业务逻辑

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后使用这个特性需要注意一点，&lt;strong&gt;local record&lt;/strong&gt; , &lt;strong&gt;local enums&lt;/strong&gt; ,&lt;strong&gt;local interface&lt;/strong&gt; 创建都是一个局部变量，是不能被传递其他方法引用。&lt;/p&gt;
&lt;h2 id=&quot;pattern-matching-for-instanceof-second-preview&quot;&gt;Pattern Matching for instanceof (Second Preview)&lt;/h2&gt;
&lt;p&gt;我们应该都看到过下面这种代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (obj instanceof String) {
    String str = (String) obj;
    // use str
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码意图非常简单，当 &lt;strong&gt;obj&lt;/strong&gt; 对象是 &lt;strong&gt;String&lt;/strong&gt; 类，就将其强制转换，然后进行其他业务操作。&lt;/p&gt;
&lt;p&gt;这种写法，类型转换还是比较繁琐，&lt;strong&gt;Pattern Matching for instanceof&lt;/strong&gt; 这个新语法特性，可以帮我们省略这种类型转换动作。这是一个在 JDK14 引入一个预览特性，JDK 15 开始第二次预览。&lt;/p&gt;
&lt;p&gt;上面的代码使用 &lt;strong&gt;pattern matcher&lt;/strong&gt;，就可以被修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (obj instanceof String s) {
    s.contains(&quot;T&quot;);
} else {
    // 编译错误
    //s.contains(&quot;T&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外如果在 IDEA 中还可以提示我们将代码转化成 &lt;strong&gt;pattern matcher&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073517849-1077149039.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家应该都看过 &lt;strong&gt;Effective Java&lt;/strong&gt; 这本神书吧，里面第八条关于 &lt;strong&gt;Equals&lt;/strong&gt; 有一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073518288-889639498.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;pattern matcher&lt;/strong&gt; 我们就可以使用下面更加清晰的代码代替：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073518599-2052107338.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sealed-classes-preview&quot;&gt;Sealed Classes (Preview)&lt;/h2&gt;
&lt;p&gt;Java 中一个正常普通类/接口允许被其他子类继承/实现，但是有时在日常开发中，我们可能希望只有特定的类才能继承扩展。&lt;/p&gt;
&lt;p&gt;现有的 Java 语法中存在一些方法，可以限制子类扩展，比如说：我们可以使用 &lt;strong&gt;final&lt;/strong&gt; 修饰类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class String
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这样之后，我们就没办法再继承这个类。&lt;/p&gt;
&lt;p&gt;其次我们可以限制的类的范围，比如说不使用 &lt;strong&gt;public&lt;/strong&gt; 修饰类/接口，即使用 &lt;strong&gt;default&lt;/strong&gt; 范围，这样只有同一个包才能继承/实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;interface DefaultExample {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过使用这种方式，又很尴尬，这个类就无法被其他包使用。&lt;/p&gt;
&lt;p&gt;为了解决上述问题，JDK 15 引入一个新的预览特性 &lt;strong&gt;Sealed Classes&lt;/strong&gt;，即可以限定类的扩展，也可以被外部使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public sealed class Shape
    permits Circle, Rectangle, Square {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;strong&gt;sealed&lt;/strong&gt; 修饰之后，&lt;code&gt;Shape&lt;/code&gt; 类只能被 &lt;code&gt;Circle&lt;/code&gt;，&lt;code&gt;Rectangle&lt;/code&gt;，&lt;code&gt;Square&lt;/code&gt;继承，再也不能被其他类继承。&lt;/p&gt;
&lt;p&gt;同时 &lt;strong&gt;Shape&lt;/strong&gt; 的子类存在一些限制，必须使用 &lt;strong&gt;final&lt;/strong&gt; 修饰，表明这个类无法再被扩展：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class Circle extends Shape {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者继续使用 &lt;strong&gt;sealed&lt;/strong&gt; 表示子类只能被指定类继承：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;public sealed class Rectangle extends Shape 
    permits TransparentRectangle, FilledRectangle {...}
public final class TransparentRectangle extends Rectangle {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又或者说使用 &lt;strong&gt;non-sealed&lt;/strong&gt; 表明这个子类不限制子类扩展，可以被其他任何类扩展实现。&lt;/p&gt;
&lt;p&gt;另外 &lt;strong&gt;sealed class&lt;/strong&gt; 还可以跟上述 &lt;strong&gt;record&lt;/strong&gt; 语法一起使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public sealed interface Expr
    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr {...}

public record ConstantExpr(int i)       implements Expr {...}
public record PlusExpr(Expr a, Expr b)  implements Expr {...}
public record TimesExpr(Expr a, Expr b) implements Expr {...}
public record NegExpr(Expr e)           implements Expr {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zgc&quot;&gt;ZGC&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ZGC(Z Garbage Collector)&lt;/strong&gt; 这是一款在 JDK11 引入的的具有实验性质的低延迟的 GC 收集器。&lt;/p&gt;
&lt;p&gt;这款 GC 收集器的希望在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小都可以把垃圾收集器的停顿时间限制在十毫秒以内的低延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ZGC&lt;/strong&gt; 经过这两三年的迭代优化，终于在 JDK15 中正式引入，标志着 &lt;strong&gt;ZGC&lt;/strong&gt; 可以正式应用于生产应用。&lt;/p&gt;
&lt;p&gt;JDK15 中默认虚拟机还是 &lt;strong&gt;G1&lt;/strong&gt;，如果需要使用 ZGC，需要在启动参数中加入如下参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;-XX:+UseZGC command-line 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本来这篇文章是准备写下 IDEA 2020.2 新版本特性，顺带介绍一下 JDK15 新特性的。&lt;/p&gt;
&lt;p&gt;可是没想到写着写着，JDK15 相关的篇幅就过长了，所以就单独拿出来了。&lt;/p&gt;
&lt;p&gt;最后，最后，JDK 都发布到 15 了，而我却还在用 JDK 7 ，真是个悲伤的故事，逃了逃了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200805073518782-282728987.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是楼下小黑哥，每天学习一点点，成长亿点点！！&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://openjdk.java.net/projects/jdk/15/&quot;&gt;https://openjdk.java.net/projects/jdk/15/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 04 Aug 2020 23:35:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>自从 JDK9 之后，每年 3 月与 9 月 JDK 都会发布一个新的版本，而2020 年 9 月即将引来 JDK15。 恰巧 IDEA 每四五个月会升级一个较大的版本，每次升级之后都会支持最新版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13437509.html</dc:identifier>
</item>
<item>
<title>【算法】排序04——代码简约而不简单的希尔排序（含代码实现） - 469の一方爬行</title>
<link>http://www.cnblogs.com/469Accelerator/p/13423937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/469Accelerator/p/13423937.html</guid>
<description>&lt;p&gt;希尔排序代码虽然少，但理解起来不一定就很简单，虽然性能不及快排、归并、堆排这些线性对数阶排序，但毕竟是第一批突破第二次时间屏障的算法，排序思路还是有一定复杂性。本文就带大家重温一下经典的希尔排序。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;200.5&quot;&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、希尔排序的效能简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希尔排序是插入排序的改进型，也因此，它的空间复杂度是O（1）。不过有趣的是，希尔排序的平均时间复杂度计与其增量有关，算起来较为复杂，dalao们的研究认为是O[n^(1.3 ~ 2)]之间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实相比于快排、归并、堆排这些平均之间复杂度为O [ nlog(n) ]的线性对数阶排序，希尔排序并不占优势（因为希排有亚二次时间界），但作为第一批突破第二次时间屏障的算法之一的存在，我jio得还是要重温一下经典（其实是面试爱考ORZ）。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、本文中的一些定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1——有序区与无序区&lt;/p&gt;
&lt;p&gt;在本文中，对于一个任意一个无序的的序列：&lt;/p&gt;
&lt;p&gt;如， [ 5, 6, 9, 8, 7, 4, 1, 2, 3 ]&lt;/p&gt;
&lt;p&gt;我们把这个序列从逻辑上分为有序区和无序区，并默认在开始排序前，第一个元素为有序区，其余为无序区。&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5,&lt;/span&gt; &lt;span&gt;6, 9, 8, 7, 4, 1, 2, 3&lt;/span&gt; ]  （绿色为有序区，红色为无序区）&lt;/p&gt;
&lt;p&gt;在我们对其逐渐有序化的时候，依次从无序区中取出其第一个元素并插入有序区：&lt;/p&gt;
&lt;p&gt;如， [&lt;span&gt; 5, 6,&lt;/span&gt; &lt;span&gt;9, 8, 7, 4, 1, 2, 3 &lt;/span&gt;]   （有序区会增加，无序区会减少，同时无序区第一个元素前的元素必然在有序区）&lt;/p&gt;
&lt;p&gt;2.2——按增量（gap）划分多个序列&lt;/p&gt;
&lt;p&gt;一个序列可以按增量（gap）在逻辑上划分为gap个序列（关于的gap的取值，第一次取序列长度一半，之后再取用gap前要除2）：&lt;/p&gt;
&lt;p&gt;如， [ 5, 6, 9, 8, 7, 4, 1, 2, 3 ]   gap = 9/2 = 4 ，即在逻辑上分成4组小序列，同一小序列内的、逻辑上相邻的元素，在序列中的小标差为gap：&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;span&gt;,&lt;/span&gt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; ]   比如红色小序列应该是[  5, 7, 3 ],它们在原序列中的小标为0、4、8，相差为gap&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、希尔排序的流程&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;第一步，在逻辑上按gap将序列划分为gap个小序列。（第一次时取增量（gap）为序列长度的一半）&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ] &lt;/p&gt;
&lt;p&gt;第二步，一个指针从序列的无序区（由各个小序列的无序区组成）由左向右遍历，遍历到的元素，将其插入对应小序列的有序区”&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5, 6, 9, 8&lt;/span&gt;,&lt;span&gt; 7, 4, 1, 2, 3&lt;/span&gt; ]  指针最开始指向序列无序区第一个即7，7在第一个小序列里，把它插入第一个小序列的有序区，&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5, 6, 9, 8, 7&lt;/span&gt;,&lt;span&gt; 4, 1, 2, 3&lt;/span&gt; ]  指针+1指向无序区新的第一个元素4，4在第二个小序列里， 把它插入第二个小序列的有序区，&lt;/p&gt;
&lt;p&gt;如， [ &lt;span&gt;5, 4, 9, 8, 7, 6&lt;/span&gt;, &lt;span&gt;1, 2, 3&lt;/span&gt; ]  注意，这里是插入到第二个小序列的有序区，所以4、6换位，然后指针+1。。。。操作同上&lt;/p&gt;
&lt;p&gt;第三步，gap/=2后若小于1就结束了，否则回调第一步。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shellSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制增量（gap），增量将不断/2直到小于1。（序列会在逻辑上按gap划分为gap个小序列）&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; gap = arr.length/2; gap &amp;gt;0; gap/=2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历无序区（最开始&amp;gt;=gap的下标都属于无序区）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量p_in_unorder始终指向当前序列的无序区的第一个元素的下标&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; p_in_unorder = gap; p_in_unorder &amp;lt; arr.length; p_in_unorder++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                *p_in_order是小序列有序区内的下标指针
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                *p_in_unorder - gap 是当前小序列有序区的最后一个
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                *把当前无序区第一个元素插入对应小序列有序区
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; p_in_order = p_in_unorder-gap ; p_in_order &amp;gt;= 0 ; p_in_order-=&lt;span&gt;gap) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(arr[p_in_order]&amp;gt;arr[p_in_order+&lt;span&gt;gap]){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         temp =&lt;span&gt; arr[p_in_order];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         arr[p_in_order] = arr[p_in_order+&lt;span&gt;gap];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                         arr[p_in_order+gap] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{5,6,9,8,7,4,1,2,3&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        shellSort(arr);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        System.out.println(Arrays.toString(arr));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，如果小伙伴觉得这篇博文对你有帮助的话，就点个推荐吧&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083829/202007/2083829-20200725231941840-1775389012.png&quot; alt=&quot;&quot; width=&quot;127&quot; height=&quot;111&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 04 Aug 2020 16:18:00 +0000</pubDate>
<dc:creator>469の一方爬行</dc:creator>
<og:description>希尔排序代码虽然少，但理解起来不一定就很简单，虽然性能不及快排、归并、堆排这些线性对数阶排序，但毕竟是第一批突破第二次时间屏障的算法，排序思路还是有一定复杂性。本文就带大家重温一下经典的希尔排序。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/469Accelerator/p/13423937.html</dc:identifier>
</item>
<item>
<title>Docker初探之Windows篇 - hapgaoyi</title>
<link>http://www.cnblogs.com/hapgaoyi/p/13423626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hapgaoyi/p/13423626.html</guid>
<description>&lt;p&gt;一、什么是Docker?&lt;/p&gt;
&lt;p&gt;Docker是一个开源的应用容器引擎，可以轻松地为任何应用创建一个轻量级、可移植、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括虚拟机和其他平台。&lt;/p&gt;
&lt;p&gt;我们可以将自己的应用以及依赖的环境一起打包到一个容器中，然后这个容器就可以很容易的放到其他机器上运行。而且非常易于装载、复制、移除。&lt;/p&gt;
&lt;p&gt;以前的部署方式就是每次部署应用的时候都需要在电脑上重复地走一下部署流程，比如下载安装环境、依赖框架、搭建服务等。但是有了Docker容器技术，我们无需重复的操作，只需要一次打包，处处运行，而且每个容器之间都是隔离的环境，互不影响。&lt;/p&gt;
&lt;p&gt;二、虚拟机和Docker对比&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804213541888-434857342.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;313&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在上图中，容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少，瞬间就能完成启动。&lt;/p&gt;
&lt;p&gt;虚拟机则是一个物理硬件层抽象，用于将一台服务器变成多台服务器，管理程序允许多个虚拟机在一台机器上运行，每个虚拟机都包含一个独立的操作系统、一个或多个应用、必要的二进制文件和资源库。因此占用大量空间，启动也十分缓慢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804214202277-304146144.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;288&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于容器所需要的资源要比虚拟机少（虚拟机需要一个完整的系统环境），所以它们易于部署且快速启动。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;特性&lt;/td&gt;
&lt;td&gt;容器&lt;/td&gt;
&lt;td&gt;虚拟机&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;启动速度&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;秒级&lt;/p&gt;
&lt;p&gt;几秒内就可以启动&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;分钟级&lt;/p&gt;
&lt;p&gt;有时候需要长达十几分钟才能启动，具体看环境安装资源大小而定&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;存储空间占用&lt;/td&gt;
&lt;td&gt;一般为MB为单位&lt;/td&gt;
&lt;td&gt;需要的空间至少G单位的空间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;接近原生，基本没有其他的消耗&lt;/td&gt;
&lt;td&gt;操作系统会占用较多的资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;系统支持量&lt;/td&gt;
&lt;td&gt;一台普通的服务器可以支持上千个容器&lt;/td&gt;
&lt;td&gt;一般最多支持几十个虚拟机，而且看电脑配置而定&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;三、抛开虚拟机面向Docker容器&lt;/p&gt;
&lt;p&gt;现在大应用不断增加，容器化是技术发的必然趋势，容器技术也会不断地进化，所以我们要把容器技术用起来，就从Docker开始！&lt;/p&gt;
&lt;p&gt;有很多小伙伴都觉得用这个有一定地门槛，安装太麻烦，当然，这也是误区。&lt;/p&gt;
&lt;p&gt;有些人认为用Docker很麻烦，只有大公司用，或者学习这个成本很高，认为对现有系统、架构改造太大，成本太高等等，这些都是误区。&lt;/p&gt;
&lt;p&gt;四、Docker的三个基本概念&lt;/p&gt;
&lt;p&gt;1、镜像&lt;/p&gt;
&lt;p&gt;　　Docker镜像是一个特殊的文件系统，除了提供容器运行时所需要的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数。镜像不包含任何动态数据，其内容在构建后也不会改变。&lt;/p&gt;
&lt;p&gt;我们可以简单的理解，镜像就像是一个什么环境、依赖资源、文件和你的应用程序都跟你打包的一个文件系统。就类似于操作系统一样，操作系统也是由C盘下的Windows文件夹和其他系统文件组成的一样，要运行操作系统，肯定是需要这些资源、文件、依赖都存在，你可以理解为这一整套文件系统就是镜像。&lt;/p&gt;
&lt;p&gt;2、容器&lt;/p&gt;
&lt;p&gt;　　容器和镜像的关系就像是面向对象程序中的实例和类一样，类是静态的，实例是通过类运行起来才有的。运行起来的程序才有进程。&lt;/p&gt;
&lt;p&gt;　　容器你可以理解为运行起来的镜像，比如，一套系统程序也是由很多个文件、资源、依赖组成，那么把它完整的一套说法类似叫镜像。如果系统程序没有运行起来，它其实也是放在硬盘上的系统文件而已。而容器，就是表示把系统程序运行起来，相当在电脑里开一个进程，运行起来的系统程序我们称之为容器。你可以这么想：针对同一套系统程序你可以运行多个，就是有多个进程。对于容器来说，你也可以同时运行多个同一个镜像的容器，这方便我们做集群。&lt;/p&gt;
&lt;p&gt;3、仓库&lt;/p&gt;
&lt;p&gt;　　镜像我们构建好后，可以很容易的在当前的操作系统上运行，但是如果需要在其他服务器上使用这个镜像，我们就需要一个集中存放、分发镜像的一个服务中心。&lt;/p&gt;
&lt;p&gt;       就类似于我们开发了一套程序，文件、依赖、资源都打包在一起了，这样很快的可以在本机运行，但是你要用，我是不是需要上传到一个软件管理服务网站，你下载就行了，对吧。如果另外一个人也有一套程序给你用，那么那个人也可以先上传到软件管理服务网站，然后你下载，那么这个软件管理服务网站，在Docker里叫做仓库服务中心，当然，上面举的例子不一定符合Docker概念，但可以作为理解仓库意思的参考，Docker里的仓库是放镜像的，与我们传统的还是有区别的。&lt;/p&gt;
&lt;p&gt;　　每个仓库可以包含多个标签，每个标签对应一个镜像，通常一个仓库包含同一个软件不同版本的镜像，而根据标签来区分软件的各个不同版本。如果我们要使用仓库里的镜像，一般都会指定一个标签用于指定软件版本，如果不指定标签则用最新的一个版本。&lt;/p&gt;
&lt;p&gt;五、下载安装和运行Docker（这里用Docker提供的Docker for Windows为例，Docker ToolBox适用于Windows 10以下的系统，我本人是Window 10）&lt;/p&gt;
&lt;p&gt;Docker 是一个应用容器引擎，肯定需要安装才能使用。&lt;/p&gt;
&lt;p&gt;Docker可以运行在Linux上，也可以运行在Windows上，在这里，目前以Windows环境为例，后面再说Linux上的Docker使用，一般在Linux上运用Docker居多。&lt;/p&gt;
&lt;p&gt;要在Windows上运行Docker，需要满足下面几个条件：&lt;/p&gt;
&lt;p&gt;1、Windows 10 64位：Pro、Enterprise或Education (Build 14393或更高版本)&lt;/p&gt;
&lt;p&gt;2、在BIOS中启用虚拟化。一般默认是启用的&lt;/p&gt;
&lt;p&gt;下载安装后需要重启电脑，如果运行遇到报错可以根据错误提示来进行修改环境，常见的如下：&lt;/p&gt;
&lt;p&gt;启用Hyper-V&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804231608728-1072390308.png&quot; alt=&quot;&quot; width=&quot;342&quot; height=&quot;348&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下载地址:&lt;a href=&quot;https://pan.baidu.com/s/12XeL11JHxsCVvOCxM3r5gA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/12XeL11JHxsCVvOCxM3r5gA&lt;/a&gt; 提取码: n3gw  (官方地址有点慢，这里就不放地址了，直接进入Docker官网即可，也可以用阿里云提供的：&lt;a class=&quot;tableInnerClick&quot; href=&quot;http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/?spm=5176.8351553.0.0.755819919FVhsv&quot; target=&quot;_blank&quot; data-spm-anchor-id=&quot;5176.8351553.0.0&quot;&gt;http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;安装成功后，桌面会有一个Docker图标：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804231953401-1166162868.png&quot; alt=&quot;&quot; width=&quot;132&quot; height=&quot;135&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 双击运行后，右下角会多出一个托管图标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804232135113-1833753682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 右键：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804232153316-984371437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 点击Settings进入设置面板：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804232313998-1207486615.png&quot; alt=&quot;&quot; width=&quot;851&quot; height=&quot;501&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;界面左下角有个绿色图标+Docker running，表示Docker已经正常运行起来了。 &lt;/p&gt;
&lt;p&gt;在后面的使用中，我们会用到很多不同的镜像，但是由于Docker 提供的镜像仓库中心是国外地址，下载镜像对于我们来说就很慢，我们可以通过修改Docker配置文件或图形化操作来添加了个镜像加速配置。我们国内的有很多大厂提供了容器加速地址，比如阿里云、腾讯等。&lt;/p&gt;
&lt;p&gt;在这里我用阿里云的：https://mtlxrshz.mirror.aliyuncs.com&lt;/p&gt;
&lt;p&gt;如果是Windows 10的用户则直接以下操作：修改registry-mirros节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804233323472-257153731.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;553&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修改后重启Docker服务即可。&lt;/p&gt;
&lt;p&gt;重启后我们可以小试一下：&lt;/p&gt;
&lt;p&gt;打开Windows PowerShell 工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804233439287-487310896.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;打开后，输出命令 docker Image ls 表示输出当前已经存在的镜像列表如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/133478/202008/133478-20200804233603653-1861777288.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这是我本机的，我上面装载了rabbitmq、mysql和redis常用的服务工具镜像。&lt;/p&gt;
&lt;p&gt;好了，后续我就接着为大家介绍Docker的常用命令、如何拉取镜像和运行容器等。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Aug 2020 15:42:00 +0000</pubDate>
<dc:creator>hapgaoyi</dc:creator>
<og:description>一、什么是Docker? Docker是一个开源的应用容器引擎，可以轻松地为任何应用创建一个轻量级、可移植、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括虚拟机和其他平</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hapgaoyi/p/13423626.html</dc:identifier>
</item>
<item>
<title>Elasticsearch从入门到放弃：瞎说Mapping - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/13436928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/13436928.html</guid>
<description>&lt;p&gt;前面我们聊了 Elasticsearch 的索引、搜索和分词器，今天再来聊另一个基础内容—— Mapping。&lt;/p&gt;
&lt;p&gt;Mapping 在 Elasticsearch 中的地位相当于关系型数据库中的 schema，它可以用来定义索引中字段的名字、定义字段的数据类型，还可以用来做一些字段的配置。从 Elasticsearch 7.0开始，Mapping 中不在乎需要定义 type 信息了，具体原因可以看&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html&quot;&gt;官方的解释&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;字段的数据类型&quot;&gt;字段的数据类型&lt;/h3&gt;
&lt;p&gt;我们刚刚提到 Mapping 中可以定义字段的数据类型，这可能是 Mapping 最常用的功能了，所以我们先来看看 Elasticsearch 都支持哪些数据类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单类型：text、keyword、date、long、double、boolean、ip&lt;/li&gt;
&lt;li&gt;复杂类型：对象类型、嵌套类型&lt;/li&gt;
&lt;li&gt;特殊类型：用于描述地理位置的 geo_point、geo_shape&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Elasticsearch 支持的数据类型远不止这些，由于篇幅原因，这里就不一一列举了。我找几个工作中常见的来介绍一下。&lt;/p&gt;
&lt;p&gt;首先就是字符串了，Elasticsearch 中的字符串有 text 和 keyword 两种。其中 text 类型的字符串是可以被全文检索的，它会被分词器作用，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;full_name&quot;: {
        &quot;type&quot;:  &quot;text&quot;
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在设置字段类型为 text 时，还可以利用一些参数对这个字段进行更进一步的定制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt;：标记这个字段是否能被搜索，默认是 true&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search_analyzer&lt;/code&gt;：被搜索时所使用的分词器，默认使用 setting 中设置的分词器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fielddata&lt;/code&gt;：字段是否允许在内存中进行排序、聚合，默认是 false&lt;/p&gt;
&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;：关于字段的一些元数据&lt;/p&gt;
&lt;p&gt;像一些id、邮箱、域名这样的字段，我们就需要使用 keyword 类型了。因为 keyword 类型可以支持排序、聚合，并且只能支持精确查询。&lt;/p&gt;
&lt;p&gt;有些同学可能会把 ID 设置为数字类型，这也是没问题的，数字类型和 keyword 各有各的好处，使用数字类型可以进行范围查找，而使用 keyword 类型则有更高的查询效率。具体用哪种还要看使用场景。&lt;/p&gt;
&lt;p&gt;日期类型在 Elasticsearch 中有三种表现形式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以格式化成日期类型的字符串，如&lt;code&gt;&quot;2020-07-26&quot;&lt;/code&gt;和&lt;code&gt;&quot;2015/01/01 12:10:30&quot;&lt;/code&gt;这样的&lt;/li&gt;
&lt;li&gt;毫秒级时间戳用 long 类型表示&lt;/li&gt;
&lt;li&gt;秒级时间戳用 integer 类型表示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 Elasticsearch 内部，日期类型是以 long 类型的毫秒级时间戳存储的，时区使用的是0时区。&lt;/p&gt;
&lt;p&gt;我们可以自定义时间格式，默认使用的是&lt;code&gt;strict_date_optional_time||epoch_millis&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strict_date_optional_time_nanos&lt;/strong&gt;是通用的日期格式解析，至少要包含年份，如果要包含时间，则用&lt;code&gt;T&lt;/code&gt;分隔，例如&lt;code&gt;yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ&lt;/code&gt;或 &lt;code&gt;yyyy-MM-dd&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果想要同时支持多种日期格式，可以使用&lt;code&gt;format&lt;/code&gt;字段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;date&quot;: {
        &quot;type&quot;:   &quot;date&quot;,
        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mapping参数&quot;&gt;Mapping参数&lt;/h3&gt;
&lt;p&gt;刚才我们提到配置 Mapping 的日期格式的参数&lt;code&gt;format&lt;/code&gt;，Mapping 还提供了很多其他的参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;analyzer&lt;/li&gt;
&lt;li&gt;boost&lt;/li&gt;
&lt;li&gt;coerce&lt;/li&gt;
&lt;li&gt;copy_to&lt;/li&gt;
&lt;li&gt;doc_values&lt;/li&gt;
&lt;li&gt;dynamic&lt;/li&gt;
&lt;li&gt;eager_global_ordinals&lt;/li&gt;
&lt;li&gt;enabled&lt;/li&gt;
&lt;li&gt;fielddata&lt;/li&gt;
&lt;li&gt;fields&lt;/li&gt;
&lt;li&gt;format&lt;/li&gt;
&lt;li&gt;ignore_above&lt;/li&gt;
&lt;li&gt;ignore_malformed&lt;/li&gt;
&lt;li&gt;index_options&lt;/li&gt;
&lt;li&gt;index_phrases&lt;/li&gt;
&lt;li&gt;index_prefixes&lt;/li&gt;
&lt;li&gt;index&lt;/li&gt;
&lt;li&gt;meta&lt;/li&gt;
&lt;li&gt;normalizer&lt;/li&gt;
&lt;li&gt;norms&lt;/li&gt;
&lt;li&gt;null_value&lt;/li&gt;
&lt;li&gt;position_increment_gap&lt;/li&gt;
&lt;li&gt;properties&lt;/li&gt;
&lt;li&gt;search_analyzer&lt;/li&gt;
&lt;li&gt;similarity&lt;/li&gt;
&lt;li&gt;store&lt;/li&gt;
&lt;li&gt;term_vector&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来介绍几个常用的字段。&lt;/p&gt;
&lt;h4 id=&quot;fields&quot;&gt;fields&lt;/h4&gt;
&lt;p&gt;首先是&lt;code&gt;fields&lt;/code&gt;，它可以使同一个字段通过不同的方式实现不同的目的。&lt;/p&gt;
&lt;p&gt;例如，我们可以对一个字符串字段设置为&lt;code&gt;text&lt;/code&gt;类型，用于全文检索，同时可以利用&lt;code&gt;fields&lt;/code&gt;设置为&lt;code&gt;keyword&lt;/code&gt;类型，用于排序和聚合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;city&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;fields&quot;: {
          &quot;raw&quot;: {
            &quot;type&quot;:  &quot;keyword&quot;
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询时我们就可以使用&lt;code&gt;city&lt;/code&gt;进行全文检索，使用&lt;code&gt;city.raw&lt;/code&gt;进行排序和聚合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;GET my-index-000001/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;city&quot;: &quot;york&quot; 
    }
  },
  &quot;sort&quot;: {
    &quot;city.raw&quot;: &quot;asc&quot; 
  },
  &quot;aggs&quot;: {
    &quot;Cities&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;city.raw&quot; 
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;enabled&quot;&gt;enabled&lt;/h4&gt;
&lt;p&gt;有些时候，我们只想把某个字段作为数据存储来使用，并不需要用来做搜索，这时，我们就可以将这个字段禁用掉，字段被禁用以后，它所保存的值也不受 mapping 指定的类型控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;user_id&quot;: {
        &quot;type&quot;:  &quot;keyword&quot;
      },
      &quot;last_updated&quot;: {
        &quot;type&quot;: &quot;date&quot;
      },
      &quot;session_data&quot;: { 
        &quot;type&quot;: &quot;object&quot;,
        &quot;enabled&quot;: false
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们禁用掉了 &lt;code&gt;session_data&lt;/code&gt; 这个字段，这时，你既可以往 &lt;code&gt;session_data&lt;/code&gt; 字段中存储 JSON 格式的数据，也可以存储非 JSON 格式的数据。&lt;/p&gt;
&lt;p&gt;除了针对于单个字段的禁用以外，我们还可以直接禁用掉整个 mapping。我们来重新创建一个index&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000002
{
  &quot;mappings&quot;: {
    &quot;enabled&quot;: false 
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，文档所有的字段都不会被索引，只是用来存储。&lt;/p&gt;
&lt;p&gt;需要注意的是，无论是具体字段中还是整个 mapping 的 enabled 属性都不可以被修改，因为一旦设置为 false，Elasticsearch 就不会对字段进行索引了，也不会校验数据的合法性，如果产生了脏数据以后再设置为 true，就会造成程序错误。&lt;/p&gt;
&lt;h4 id=&quot;null_value&quot;&gt;null_value&lt;/h4&gt;
&lt;p&gt;null 在 Elasticsearch 中是不可以被索引或搜索的，这里我们所说的 null 并不是狭义上某种语言的 null，而是所有的空值。例如所有值都是 null 的数组，总之，这里的定义就是没有值。&lt;/p&gt;
&lt;p&gt;对于有需要搜索空值的业务怎么办呢？Elasticsearch 为我们提供了 &lt;code&gt;null_value&lt;/code&gt; 这个参数，它可以指定一个值，搜索时使用这个值来替代空值。&lt;/p&gt;
&lt;p&gt;举个栗子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;status_code&quot;: {
        &quot;type&quot;:       &quot;keyword&quot;,
        &quot;null_value&quot;: &quot;NULL&quot; 
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们给 &lt;code&gt;status_code&lt;/code&gt; 字段设置了 &lt;code&gt;null_value&lt;/code&gt; 为 &lt;code&gt;&quot;NULL&quot;&lt;/code&gt;。这里需要注意， &lt;code&gt;null_value&lt;/code&gt; 的类型必须与要查找的数据类型相同，如果在这个例子中 &lt;code&gt;status_code&lt;/code&gt; 的类型是long，那么就不能把&lt;code&gt;null_value&lt;/code&gt; 设置为 &lt;code&gt;&quot;NULL&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dynamic&quot;&gt;dynamic&lt;/h4&gt;
&lt;p&gt;对于新增加的字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dynamic 设置为 true 时，一旦有新增字段的文档写入，Mapping 也会被更新&lt;/li&gt;
&lt;li&gt;dynamic 设置为 false 时，Mapping 不会被更新，新增字段无法被索引，但信息会出现在 &lt;code&gt;_source&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;dynamic 设置为 strict 时，文档写入失败&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于已有的字段，一旦已经有数据写入，就不再支持修改字段定义&lt;/p&gt;
&lt;h3 id=&quot;dynamic-mapping&quot;&gt;Dynamic Mapping&lt;/h3&gt;
&lt;p&gt;我们在创建索引时，可以不用手动写 Mappings， Elasticsearch 会帮我们自动识别出字段的类型。我们称之为 Dynamic Mapping。不过有时推算的可能不是很准确。&lt;/p&gt;
&lt;p&gt;Elasticsearch 自动识别类型是基于 JSON 的。数据类型的对应关系如下（表格来自 elastic 官网）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;JSON data type&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Elasticsearch data type&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.7222222222222&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;No field is added.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/boolean.html&quot;&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/a&gt; field&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;floating point number&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; field&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;integer&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt; field&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/object.html&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; field&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;Depends on the first non-&lt;code&gt;null&lt;/code&gt; value in the array.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.3529411764706&quot;&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;Either a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; field (if the value passes &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#date-detection&quot;&gt;date detection&lt;/a&gt;), a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt; field (if the value passes &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-field-mapping.html#numeric-detection&quot;&gt;numeric detection&lt;/a&gt;) or a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html&quot;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt; field, with a &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html&quot;&gt;&lt;code&gt;keyword&lt;/code&gt;&lt;/a&gt; sub-field.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Elasticsearch 支持的字段映射的数据类型在这个&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html&quot;&gt;文档&lt;/a&gt;中，除了这些，其他的类型映射都需要显示的指定了。&lt;/p&gt;
&lt;p&gt;关于日期类型，默认是可以映射的，但是 Elasticsearch 只能识别几种格式的日期&lt;code&gt;yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis&lt;/code&gt;。如果关掉了 &lt;code&gt;date_detection&lt;/code&gt; 开关，那么就只能识别为字符串了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;date_detection&quot;: false
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以根据需要自己指定要识别的日期格式，只需要使用 &lt;code&gt;dynamic_date_formats&lt;/code&gt; 参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;dynamic_date_formats&quot;: [&quot;MM/dd/yyyy&quot;]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Elasticsearch 还提供了一种把字符串型的数字识别为数字的能力，它是由 &lt;code&gt;numeric_detection&lt;/code&gt; 开关控制的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000005
{
  &quot;mappings&quot;: {
    &quot;numeric_detection&quot;: true
  }
}

PUT my-index-000005/_doc/1
{
  &quot;my_float&quot;:   &quot;1.0&quot;, 
  &quot;my_integer&quot;: &quot;1&quot; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;my_float&lt;/code&gt; 会被识别为 float 类型，而 &lt;code&gt;my_integer&lt;/code&gt; 会被识别为 long 类型。&lt;/p&gt;
&lt;h3 id=&quot;dynamic-template&quot;&gt;Dynamic template&lt;/h3&gt;
&lt;p&gt;dynamic template 允许我们自定义 mapping ，并应用到具体索引上。dynamic template 的定义一般是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;  &quot;dynamic_templates&quot;: [
    {
      &quot;my_template_name&quot;: { 
        ...  match conditions ... 
        &quot;mapping&quot;: { ... } 
      }
    },
    ...
  ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;my_template_name&lt;/code&gt; 可以是任意字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;match conditions&lt;/code&gt; 包括&lt;code&gt;match_mapping_type&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;match_pattern&lt;/code&gt;, &lt;code&gt;unmatch&lt;/code&gt;, &lt;code&gt;path_match&lt;/code&gt;, &lt;code&gt;path_unmatch&lt;/code&gt; 这几种。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mapping&lt;/code&gt; 就是指匹配到的字段应该使用怎样的 mapping。下面我们介绍几种 match conditions&lt;/p&gt;
&lt;h4 id=&quot;match_mapping_type&quot;&gt;match_mapping_type&lt;/h4&gt;
&lt;p&gt;我们先来看一个简单的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;dynamic_templates&quot;: [
      {
        &quot;integers&quot;: {
          &quot;match_mapping_type&quot;: &quot;long&quot;,
          &quot;mapping&quot;: {
            &quot;type&quot;: &quot;integer&quot;
          }
        }
      },
      {
        &quot;strings&quot;: {
          &quot;match_mapping_type&quot;: &quot;string&quot;,
          &quot;mapping&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;raw&quot;: {
                &quot;type&quot;:  &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们有两个模版，其一是使用 &lt;code&gt;integer&lt;/code&gt; 类型来代替 &lt;code&gt;long&lt;/code&gt; 类型，其二是将字符串类型映射为 &lt;code&gt;keyword&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;match-和-unmatch&quot;&gt;match 和 unmatch&lt;/h4&gt;
&lt;p&gt;这两个比较简单，match 是指匹配到模式的字段， unmatch 是表示不匹配的字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PUT my-index-000001
{
  &quot;mappings&quot;: {
    &quot;dynamic_templates&quot;: [
      {
        &quot;longs_as_strings&quot;: {
          &quot;match_mapping_type&quot;: &quot;string&quot;,
          &quot;match&quot;:   &quot;long_*&quot;,
          &quot;unmatch&quot;: &quot;*_text&quot;,
          &quot;mapping&quot;: {
            &quot;type&quot;: &quot;long&quot;
          }
        }
      }
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们需要的是 &lt;code&gt;long_&lt;/code&gt; 开头的字符串，不需要 &lt;code&gt;_text&lt;/code&gt;结尾的字符串字段。&lt;/p&gt;
&lt;p&gt;除了以上三种之外，其他的就是 &lt;code&gt;match_pattern&lt;/code&gt; 用来进行正则匹配，&lt;code&gt;path_match&lt;/code&gt; 和 &lt;code&gt;path_unmatch&lt;/code&gt; 则是表示字段所在路径的是否匹配。&lt;/p&gt;
&lt;p&gt;另外 dynamic template 还支持两种变量替换，分别是 &lt;code&gt;{name}&lt;/code&gt; 和 &lt;code&gt;{dynamic_type}&lt;/code&gt;。其实 name 就是字段名，dynamic_type 就是检测出的字段类型。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;关于 Elasticsearch 的 mapping 我们就先聊这些，我认为 mapping 的配置是一个需要经验的事情，当你处理的 case 越来越多之后，就能比较轻松的知道如何更好的配置 mapping 了。此外，mapping 的许多字段和参数文中都没有涉及，对于我而言，大部分都是用到了现查文档，不过也还是建议大家看一看文档，起码遇到问题时能知道大概查找文档的一个方向。这样就会比身边人强不少。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Aug 2020 15:05:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>前面我们聊了 Elasticsearch 的索引、搜索和分词器，今天再来聊另一个基础内容—— Mapping。 Mapping 在 Elasticsearch 中的地位相当于关系型数据库中的 sche</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/13436928.html</dc:identifier>
</item>
<item>
<title>synchronized 锁的原理 - 会说话的丶猫</title>
<link>http://www.cnblogs.com/talkingcat/p/13436911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkingcat/p/13436911.html</guid>
<description>&lt;h2&gt;synchronized 的基本认识&lt;/h2&gt;
&lt;p&gt;　　在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java SE 1.6 中为了减少获得锁和释放锁带来的性&lt;/p&gt;
&lt;p&gt;能消耗而引入的偏向锁和轻量级锁。这块在后续我们会慢慢展开&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;h3&gt;synchronized 的基本语法&lt;/h3&gt;
&lt;p&gt;　　synchronized 有三种方式来加锁，分别是&lt;/p&gt;
&lt;p&gt;　　1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁&lt;/p&gt;
&lt;p&gt;　　2. 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁&lt;/p&gt;
&lt;p&gt;　　3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。不同的修饰类型，代表锁的控制粒度&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;h3&gt;synchronized 的应用&lt;/h3&gt;
&lt;p&gt;　　修改前面的案例，使用 synchronized 关键字后，可以达到数据安全的效果&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;
&lt;pre readability=&quot;10&quot;&gt;
public class Demo {&lt;br/&gt;private static int count = 0;&lt;p&gt;public static void inc() {&lt;br/&gt;synchronized (Demo.class) {&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(1);&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;count++;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void main(String[] args)&lt;br/&gt;throws InterruptedException {&lt;br/&gt;for (int i = 0; i &amp;lt; 1000; i++) {&lt;br/&gt;new Thread(() -&amp;gt; Demo.inc()).start();&lt;br/&gt;}&lt;br/&gt;Thread.sleep(3000);&lt;br/&gt;System.out.println(&quot;运行结果&quot; + count);&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;思考锁是如何存储的&lt;/h2&gt;
&lt;p&gt;　　可以思考一下，要实现多线程的互斥特性，那这把锁需要哪些因素？&lt;/p&gt;
&lt;p&gt;　　1. 锁需要有一个东西来表示，比如获得锁是什么状态、无锁状态是什么状态&lt;/p&gt;
&lt;p&gt;　　2. 这个状态需要对多个线程共享那么我们来分析，synchronized 锁是如何存储的呢？观察synchronized 的整个语法发现，synchronized(lock)是基于lock 这个对象的生命周期来控制锁粒度的，那是不是锁的&lt;/p&gt;
&lt;p&gt;存储和这个 lock 对象有关系呢？于是我们以对象在 jvm 内存中是如何存储作为切入点，去看看对象里面有什么特性能够实现锁&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h2&gt;对象在内存中的布局&lt;/h2&gt;
&lt;p&gt;　　在 Hotspot 虚拟机中，对象在内存中的存储布局，可以分为三个区域:对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1444842/202008/1444842-20200804225447876-1762832658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1444842/202008/1444842-20200804225510687-1832134849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;synchronized 锁的升级&lt;/h2&gt;
&lt;p&gt;　　在分析 markword 时，提到了偏向锁、轻量级锁、重量级锁。在分析这几种锁的区别时，我们先来思考一个问题使用锁能够实现数据的安全性，但是会带来性能的下降。不使用锁能够基于线程并行提升程序性能，&lt;/p&gt;
&lt;p&gt;但是却不能保证线程安全性。这两者之间似乎是没有办法达到既能满足性能也能满足安全性的要求。hotspot 虚拟机的作者经过调查发现，大部分情况下，加锁的代码不仅仅不存在多线程竞争，而且总是由同一个线程&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;多次获得。所以基于这样一个概率，是的 synchronized 在JDK1.6 之后做了一些优化，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁、轻量级锁的概念。因此大家会发现在 synchronized 中，锁存在四种状态&lt;/p&gt;
&lt;p&gt;分别是：无锁、偏向锁、轻量级锁、重量级锁； 锁的状态根据竞争激烈的程度从低到高不断升级。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;h3&gt;偏向锁的基本原理&lt;/h3&gt;
&lt;p&gt;　　前面说过，大部分情况下，锁不仅仅不存在多线程竞争，而是总是由同一个线程多次获得，为了让线程获取锁的代价更低就引入了偏向锁的概念。怎么理解偏向锁呢？当一个线程访问加了同步锁的代码块时，会在对象头中存&lt;/p&gt;
&lt;p&gt;储当前线程的 ID，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了&lt;/p&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;h3&gt;偏向锁的获取和撤销逻辑&lt;/h3&gt;
&lt;p&gt;　　1. 首先获取锁 对象的 Markword，判断是否处于可偏向状态。（biased_lock=1、且 ThreadId 为空）&lt;/p&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;p&gt;　　2. 如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID写入到 MarkWord&lt;/p&gt;
&lt;p&gt;　　　　a) 如果 cas 成功，那么 markword 就会变成这样。表示已经获得了锁对象的偏向锁，接着执行同步代码块&lt;/p&gt;
&lt;p&gt;　　　　b) 如果 cas 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向&lt;/p&gt;
&lt;p&gt;　　　　　锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字&lt;/p&gt;
&lt;p&gt;　　　　　节码）才能执行&lt;/p&gt;
&lt;p&gt;　　3. 如果是已偏向状态，需要检查 markword 中存储的ThreadID 是否等于当前线程的 ThreadID&lt;/p&gt;
&lt;p&gt;　　　　a) 如果相等，不需要再次获得锁，可直接执行同步代码块&lt;/p&gt;
&lt;p&gt;　　　　b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;h3&gt;偏向锁的撤销&lt;/h3&gt;
&lt;p&gt;　　偏向锁的撤销并不是把对象恢复到无锁可偏向状态（因为偏向锁并不存在锁释放的概念），而是在获取偏向锁的过程中，发现 cas 失败也就是存在线程竞争时，直接把被偏向的锁对象升级到被加了轻量级锁的状态。&lt;/p&gt;
&lt;div readability=&quot;39.5&quot;&gt;
&lt;p&gt;对原持有偏向锁的线程进行撤销时，原获得偏向锁的线程&lt;/p&gt;
&lt;p&gt;　　有两种情况：&lt;/p&gt;
&lt;p&gt;　　1. 原获得偏向锁的线程如果已经退出了临界区，也就是同步代码块执行完了，那么这个时候会把对象头设置成无锁状态并且争抢锁的线程可以基于 CAS 重新偏向但前线程&lt;/p&gt;
&lt;p&gt;　　2. 如果原获得偏向锁的线程的同步代码块还没执行完，处于临界区之内，这个时候会把原获得偏向锁的线程升级为轻量级锁后继续执行同步代码块&lt;/p&gt;
&lt;p&gt;　　在我们的应用开发中，绝大部分情况下一定会存在 2 个以上的线程竞争，那么如果开启偏向锁，反而会提升获取锁的资源消耗。所以可以通过 jvm 参数UseBiasedLocking 来设置开启或关闭偏向锁&lt;/p&gt;
&lt;div readability=&quot;49.5&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1444842/202008/1444842-20200804225752340-1649466218.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;h2&gt;轻量级锁的基本原理&lt;/h2&gt;
&lt;h3&gt;轻量级锁的加锁和解锁逻辑&lt;/h3&gt;
&lt;p&gt;　　锁升级为轻量级锁之后，对象的 Markword 也会进行相应的的变化。升级为轻量级锁的过程：&lt;/p&gt;
&lt;p&gt;　　1. 线程在自己的栈桢中创建锁记录 LockRecord。&lt;/p&gt;
&lt;p&gt;　　2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。&lt;/p&gt;
&lt;p&gt;　　3. 将锁记录中的 Owner 指针指向锁对象。&lt;/p&gt;
&lt;p&gt;　　4. 将锁对象的对象头的 MarkWord替换为指向锁记录的指针。&lt;/p&gt;
&lt;h3&gt;自旋锁&lt;/h3&gt;
&lt;p&gt;　　轻量级锁在加锁过程中，用到了自旋锁所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个&lt;/p&gt;
&lt;p&gt;获得锁的线程释放锁之后，这个线程就可以马上获得锁的。注意，锁在原地循环的时候，是会消耗 cpu 的，就相当于在执行一个啥也没有的 for 循环。&lt;/p&gt;
&lt;p&gt;所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短的时间就能够获得锁了。自旋锁的使用，其实也是有一定的概率背景，在大部分同&lt;/p&gt;
&lt;p&gt;步代码块执行的时间都是很短的。所以通过看似无异议的循环反而能提升锁的性能。但是自旋必须要有一定的条件控制，否则如果一个线程执行同步代码块的时间很长，那么这个线程不断的循环反而&lt;/p&gt;
&lt;p&gt;会消耗 CPU 资源。默认情况下自旋的次数是 10 次，可以通过 preBlockSpin 来修改在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自&lt;/p&gt;
&lt;p&gt;旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相&lt;/p&gt;
&lt;p&gt;对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源&lt;/p&gt;
&lt;h3&gt;轻量级锁的解锁&lt;/h3&gt;
&lt;p&gt;　　轻量级锁的锁释放逻辑其实就是获得锁的逆向逻辑，通过CAS 操作把线程栈帧中的 LockRecord 替换回到锁对象的MarkWord 中，如果成功表示没有竞争。如果失败，表示&lt;/p&gt;
&lt;p&gt;当前锁存在竞争，那么轻量级锁就会膨胀成为重量级锁&lt;/p&gt;
&lt;div readability=&quot;14.5&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1444842/202008/1444842-20200804225910671-1550565448.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;
&lt;h3&gt;重量级锁的基本原理&lt;/h3&gt;
&lt;p&gt;　　当轻量级锁膨胀到重量级锁之后，意味着线程只能被挂起阻塞来等待被唤醒了。&lt;/p&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;h3&gt;重量级锁的 monitor&lt;/h3&gt;
&lt;p&gt;　　加了同步代码块以后，在字节码中会看到一个monitorenter 和 monitorexit。每一个 JAVA 对象都会与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被&lt;/p&gt;
&lt;p&gt;synchronized 修饰的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor。monitorenter 表示去获得一个对象监视器。monitorexit 表示释放 monitor 监视器的所有权，使得其他被阻塞的线程&lt;/p&gt;
&lt;p&gt;可以尝试去获得这个监视器monitor 依赖操作系统的 MutexLock(互斥锁)来实现的, 线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能&lt;/p&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;h3&gt;重量级锁的加锁的基本流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1444842/202008/1444842-20200804230044667-1236101559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　任意线程对 Object（Object 由 synchronized 保护）的访问，首先要获得 Object 的监视器。如果获取失败，线程进入同步队列，线程状态变为 BLOCKED。当访问 Object 的&lt;/p&gt;
&lt;p&gt;前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。&lt;/p&gt;
&lt;div readability=&quot;59.5&quot;&gt;
&lt;h3&gt;回顾线程的竞争机制&lt;/h3&gt;
&lt;p&gt;　　再来回顾一下线程的竞争机制对于锁升级这块的一些基本流程。方便大家更好的理解加入有这样一个同步代码块，存在 Thread#1、Thread#2 等多个线程&lt;/p&gt;
&lt;p&gt;　　synchronized (lock) {&lt;/p&gt;
&lt;p&gt;　　　　// do something&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　情况一：只有 Thread#1 会进入临界区；&lt;/p&gt;
&lt;p&gt;　　情况二：Thread#1 和 Thread#2 交替进入临界区,竞争不激烈；&lt;/p&gt;
&lt;p&gt;　　情况三：Thread#1/Thread#2/Thread3… 同时进入临界区，竞争激烈&lt;/p&gt;
&lt;h3&gt;偏向锁&lt;/h3&gt;
&lt;p&gt;　　此时当 Thread#1 进入临界区时，JVM 会将 lockObject 的对象头 Mark Word 的锁标志位设为“01”，同时会用 CAS 操作把 Thread#1 的线程 ID 记录到 Mark Word 中，此时进&lt;/p&gt;
&lt;p&gt;入偏向模式。所谓“偏向”，指的是这个锁会偏向于 Thread#1，若接下来没有其他线程进入临界区，则 Thread#1 再出入临界区无需再执行任何同步操作。也就是说，若只有&lt;/p&gt;
&lt;p&gt;Thread#1 会进入临界区，实际上只有 Thread#1 初次进入临界区时需要执行 CAS 操作，以后再出入临界区都不会有同步操作带来的开销。&lt;/p&gt;
&lt;h3&gt;轻量级锁&lt;/h3&gt;
&lt;p&gt;　　偏向锁的场景太过于理想化，更多的时候是 Thread#2 也会尝试进入临界区， 如果 Thread#2 也进入临界区但是Thread#1 还没有执行完同步代码块时，会暂停 Thread#1并且升&lt;/p&gt;
&lt;p&gt;级到轻量级锁。Thread#2 通过自旋再次尝试以轻量级锁的方式来获取锁&lt;/p&gt;
&lt;h3&gt;重量级锁&lt;/h3&gt;
&lt;p&gt;　　如果 Thread#1 和 Thread#2 正常交替执行，那么轻量级锁基本能够满足锁的需求。但是如果 Thread#1 和 Thread#2同时进入临界区，那么轻量级锁就会膨胀为重量级锁，意&lt;/p&gt;
&lt;p&gt;味着 Thread#1 线程获得了重量级锁的情况下，Thread#2就会被阻塞&lt;/p&gt;
&lt;div readability=&quot;40&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Synchronized 结合 Java Object 对象中的wait,notify,notifyAll&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;　　前面我们在讲 synchronized 的时候，发现被阻塞的线程什么时候被唤醒，取决于获得锁的线程什么时候执行完同步代码块并且释放锁。那怎么做到显示控制呢？我们就需要&lt;/p&gt;
&lt;p&gt;借 助 一 个 信 号 机 制 ： 在 Object 对 象 中 ， 提 供 了wait/notify/notifyall，可以用于控制线程的状态&lt;/p&gt;
&lt;h3&gt;wait/notify/notifyall 基本概念&lt;/h3&gt;
&lt;p&gt;　　wait：表示持有对象锁的线程 A 准备释放对象锁权限，释放 cpu 资源并进入等待状态。&lt;/p&gt;
&lt;p&gt;　　notify：表示持有对象锁的线程 A 准备释放对象锁权限，通知 jvm 唤 醒 某 个 竞 争 该 对 象 锁 的 线 程 X 。 线 程 Asynchronized 代码执行结束并且释放了锁之后，线程 X 直&lt;/p&gt;
&lt;p&gt;　　　　　接获得对象锁权限，其他竞争线程继续等待(即使线程 X 同步完毕，释放对象锁，其他竞争线程仍然等待，直至有新的 notify ,notifyAll 被调用)。&lt;/p&gt;
&lt;p&gt;　　notifyAll：notifyall 和 notify 的区别在于，notifyAll 会唤醒所有竞争同一个对象锁的所有线程，当已经获得锁的线程A 释放锁之后，所有被唤醒的线程都有可能获得对象锁权限&lt;/p&gt;
&lt;p&gt;　　需要注意的是：三个方法都必须在 synchronized 同步关键字 所 限 定 的 作 用 域 中 调 用 ， 否 则 会 报 错java.lang.IllegalMonitorStateException ，意思是因为没有同步，所以&lt;/p&gt;
&lt;p&gt;线程对对象锁的状态是不确定的，不能调用这些方法。另外，通过同步机制来确保线程从 wait 方法返回时能够感知到感知到 notify 线程对变量做出的修改&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 04 Aug 2020 15:03:00 +0000</pubDate>
<dc:creator>会说话的丶猫</dc:creator>
<og:description>synchronized 的基本认识 在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对synchronized 进行了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/talkingcat/p/13436911.html</dc:identifier>
</item>
<item>
<title>消息队列和事件循环（Event Loop） - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/13436877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/13436877.html</guid>
<description>&lt;h3 id=&quot;Wxs4i&quot; data-lake-id=&quot;ae333945fe003361048111b804af6910&quot;&gt; &lt;/h3&gt;
&lt;div id=&quot;Ql2UK&quot; class=&quot;lake-card-margin lake-selected&quot; data-card-type=&quot;block&quot; data-lake-card=&quot;mindmap&quot; data-card-value=&quot;data:%7B%22diagramData%22%3A%22x%C2%9C%C2%95V%5Ds%C3%93F%5Cu0014%C3%BD%2B%C2%8C%C3%BA%C2%9AeV%C3%92%C2%AE%C2%B4%C2%9B%C2%B7%C2%96%C3%A6%C2%81%C2%BE%C2%B43%3Cv%C3%BA%C2%B0%C3%9A%C2%95J%C2%A6!%C2%A1!0%C2%A5Lf%5Cf%C3%B92%241%5Cu0019HH%C3%88%C2%97IK%3EJKb%5Cn%C3%A3%3AVH%C3%BE%5Cu000b%C3%95J%C3%B6%5Cu0013%7F%C2%A1W%C2%96md%C3%80%C2%99%C3%A9%C3%98%C3%A3%C3%B1Zw%C3%AF%C2%9E%3D%C3%B7%C2%9Es%7D%C3%87%C2%B8%C3%AA%5Cu000be%5Cf%C3%9E1n%C3%B9%C3%A37%C2%86%C3%87F%C2%8DA%C3%83%C2%BA%C2%88%2Fbc%C3%80%C2%98%C2%B8%7D%C3%9D%C2%87%C3%A5%C2%B5%C3%A1QuM%5C%5C7%26%5Cu0007%5CfoL%C3%9D6%5Cu0006%C2%BF%C2%BFc%5Cf%C3%83%5Cu0016%C2%83%5Cb%C2%97p%C3%A9x%5Cu0010zu%C3%A2%C3%9A%5Cb%C3%BC%5Cu0012W%C2%8B%C3%B1%C3%9D%C2%A3%C3%A6ZY%5Cu0017W%C3%B5%C2%A3%5Cu0005%7D%C3%BA%5C%22)%C2%B5%C2%97%C3%AF%5Cn%C3%B3%C2%9F%C2%A6%5Cu001c0%C3%A4%C3%95%C3%A1%5Cu00115%C3%AE%C2%8F%C2%B6%C2%B2%C2%B6%C2%B3%40%C2%A8~%C2%B9%C2%A67%5Cu000f%C2%92%C3%B5%C3%A9%C3%A6%C3%AAa%C3%B3%C2%B75%5Cb%5Cu001c%5Cu0011%C2%B7%C3%87nN%C2%A4%40%7F%C2%BE)%C3%94%C2%B8%5Cu0018%C2%85%C3%AF%5Cu0016%40%C2%9A%5Cu0018%C3%B7%C3%BD!%C3%B5%C2%A3%C2%9F%3E%C2%B911%3E%C3%B6S%C2%9A%C3%BF%5Cu000b%C3%97%C2%BDd3'%C2%85%C3%9CBjc%C3%89)S%5Cu0016%C2%A2%C3%8C%C3%A7%C2%888%C3%92F%5E%C3%A0P%C3%A4%3A%C2%94%5Cn%C3%89%3D%5Bqq%5Cu000e%C2%98%C2%BD%7B%C3%91%C3%9B%5Cu0015%C3%BD%7C%3AY%C2%9Am%C3%BE%C2%B9%5Cu0016%C2%9D%C2%AC%C3%A9%C2%99bR%C3%9F%5Cu0007xQ%5Cu0018%C3%AA%5Cu0007%3B%C3%AFO%C3%8AF%C3%BB%24%C3%8AM%5B%5Cu0006%C3%94G%5Cu000e5)%5C%22Xq%C3%84%5C%5C%5C%22%5Cu0010%C2%B1-N%C2%B9%C2%8Fm%C2%8Ay%C3%BF%C2%93%C3%A2%7F%20%C3%9D%C2%B3%C2%A8%3E%C2%ABO%5Cu000f%C2%B3%C3%94%5Cu0019y%C3%B1%C3%96nc%C3%BFw%3D%C3%BB%C2%BAs%5Cf%C2%93Tz%C2%8E%23%C2%91m)%5Cu000f%5Cu0011A%7C%C3%84%5Cu0003W!%C3%87%C3%B1%2C%C2%81%5Cu0019%5CrLNz%C2%8F%C3%B9a%C3%80%C3%B8%C3%B5%C3%B2%C2%A8%C3%B2%7F1%5Cu0006Mk2%C2%BF2'%5Cu0007%3E%C2%BDmv%C2%9C%5E%5C%5C%C2%89j%2F2%24%C3%B1%C3%BD%C3%BD%C3%86%C3%8EB%C2%BCZm%C2%AE%C2%9C5%C3%8E%C3%A6%C2%A2%C3%A3%C2%99nyr%C3%B7g%C2%8A9%C2%81t%5Ct%5Cn%C2%A4%C2%B2%5Cu0011%C2%B1%5CbA%C3%9C%C3%B4%5Cu0015%5Cn%5Cu0002%C3%8F%5Cu0013%C3%8A%C3%A2%C3%82%5Ct%C2%BC%C3%BE%C3%B7%C3%BFF%C3%9C%5Cu0012W%C3%A4%C3%B8%C3%B0%C3%B5%C2%89%5Cu000b%C3%BA%C3%A1Q%5Cu0014%C3%AE6%5Cu000b%C3%ABp%C2%96%C3%9E%C3%98nT%C2%A6%C3%B4%C2%83rc%C3%AAm%C2%8B%C2%8A%C3%A9%C3%A6%5D%C3%80%C3%B04%C3%99_%C3%AC%5Cu0000X%C2%88%C2%8E%C3%8B%C2%BA%C3%B2*%5E%3Bj%5Cu001c%C3%BE%C3%91%C3%98%C2%BB%C2%9B%C2%A1%5Cu0005%C2%84%5Cu0017r9%C3%9B%5Cu0017%5Ct%C2%B7%C3%B5R)%5Cu000b%C3%B8%C2%B7p%C2%AF%C2%83%C3%9Cs1S2%C3%80H%C3%B8D!B%C2%99%40L%5Cu0012%C2%86%C2%A8cK%C3%9B%24.%C2%B6%5C%5C%C3%95%C2%9FR%C3%92C%C2%A9%C3%9D%C2%B3%C3%82%C2%BD%5Cu0004%7F%24%C2%92%C2%A8%3E%5Cu001f%C2%85%C3%95L*)%C2%A33%C2%8Bz%C2%A9%C3%B8%C2%BF%5Cu001b%C3%BE%C3%AB!f%5E%C3%BA%C3%90%C3%B0.%C2%A3%C2%8A%3B%C2%98!%C3%8F%C2%B40%5C%22%5CfzQ%5Cu0010!%C2%90%C3%B4%5C%5Cn1%C3%9BV%2C%5Cb%C3%BA%C2%97%5Cu0001%C3%9E%C2%8D%C3%B9%C3%9Dx%C3%B3%C2%BE%C2%9E%C2%A9F%C3%A1%C2%93%C3%86%C3%99Fr0%5Cu000f%C2%A5%C2%88%C3%8Evt%C3%B1it%C2%B2%C2%9E%C2%95%C3%A5%C3%B2w%C2%97%C2%A2Z%C3%A9%C3%B2%C2%B7I%C3%BD%5Cf%C2%9ECT%C3%9A%5Cu001f%C2%AD%C3%8BE'%C3%8F%C2%9A%C2%85G%C3%AFO6%C2%BA%C3%A4R%C2%8B%5Cu0012e2%C2%A4L%2C%C2%81%5C%5CP%C2%84%5Cu0010%C2%94!%C2%A9%C2%A8%2F%C2%89%C2%A2%C3%8At%C2%82%C2%BE%C3%A4%C2%BA%C2%BD%C3%BCu%5Cu000e%C2%8CK%C2%BB%C3%B1rU%5Cu0017%2By%C2%94p2%7C%C2%81%26%5Cu0001*3%2CPkh%C2%8F%5Cf%C2%B7%C2%AE%C3%8CBp%C2%A62%C3%98%C3%98S%C2%89%C3%8Ais%C3%AA%5Cu0000%20_%C3%A8%C2%B62%C2%B5M%C2%8C%5D%5Cu0017%C3%A1%5Cu0000%5Cu0007%C2%A01%5Cu0001%5Cu001c%C3%82-%C2%90%C3%80%C2%98%5Cu0006%3E44%C3%85%C3%BD5%C3%86%3E%C2%AAy%C3%AD%C3%AF%C2%B8%C3%BC8%C2%AA%C2%85%5Cu0019%C3%B4%C2%AC%C3%9Az%C2%B3%5Cu0012%C2%85%C2%A5%5Cu001e%5Cu0010%C3%8F%C3%9F%5Cu0000%C2%88%C2%A8%C3%B6%C2%B2q%5Cu0014%C3%AA%C2%87O%3A%C3%AE%C2%B2%C2%905kg%C3%99e%C3%95%25%C3%8A%C2%B6%5Cu001c%C2%93C%C3%8Bb%C2%B0%5Cu0018i%5Cu0003%C2%AB%5Cu0004%5C%5C%C3%8Et%7C%C3%97%C3%A7%C3%98%C3%A2%C2%A6%C3%A8%C2%8F%C2%90%C3%A7%7B%C3%94I%C3%A1f%C2%B7%C2%B61%C3%B3L%C2%8F%7F0%C3%B5%5Cb%C2%9Cn%C2%B9%C2%ACKe%C2%BD%C3%B1%C2%AC%C3%AD%C3%A2%C2%9Fm%C3%81%2F-%C3%A6%5Cu000e%C2%99i%5Cu000b%C3%B6S%C3%B7%5Cu0015%C2%90'%C3%B8%5Ct%C2%B8JFCZ%C2%97%C3%A7%C3%AB%C2%A0%C3%A2%C2%A8%5Cu0006M%C2%BF%C2%90%C2%BC%5Cn%C3%B5%C3%B6%7C%C3%97Ua%5Cu0000t%5Ct%5Cu0003J%C2%A0%5Cu001d%C3%A3%C2%AD%5Cu001d%C2%88L%C3%9E%3C%5Cu0000%C3%A62J%20%5Cu0003%C3%B8%5Cu0000%5Cb%C2%BF%C2%B9Y%5Cu0000%C3%95G%C2%B5%5Cu0002%C3%A4O%5E%C2%87IXN%7B%20%2C'%2F%C2%8FS%C3%AB%C2%A8%C3%AFAXT%C3%9F%C3%A82%C2%9A.!2%5Cu0017%C2%90%C3%AD%C3%8A%3C%C3%A4%3C%C2%89%C2%B6%C3%82r%C2%BE%C2%81M%C3%86%C3%92%3EA%5Cu001c%C2%83%C3%80%C2%88%C2%90%5Cu0018y%C2%9Eo%C3%83l%C2%81%C3%99%C3%88%5Ct%C2%93%60'%7D%C2%8B%C3%90c%5Cu0014V%C2%B7%5Cb%C3%98!%C3%9C%5Cnl%C3%B9%C3%B9%C3%89%C3%9A%C2%B7%5Cu0002C%C2%84%C3%81%C3%AB%C2%9C%5Cn%C3%A4%C2%B3%C2%B4jQ%5Cu0000%C3%B2%C3%A3%C2%95J%C2%BCx%C2%98%C2%84%C2%8F%C3%A3%C3%AD%C3%A9%C2%B4%5C%22-%C3%A3%C2%85%5Cu0001%5Cu001c%2F%C2%9F%C3%A6%C2%8D4%C2%A3%5Cu000e.%C2%AE%5Cu000f%C2%A7%C2%92%C2%BF%C3%B6%C3%80%C2%A4%3A%C2%83%7D%5Cu0013%C3%86!%C2%88%5Cu000e%3E%C3%B5%5C%5C%C3%BD%5Da%5Cu000b%C2%82%C2%93%C3%BB%C3%87%C3%89%C2%BD%C3%A3%5Cu001e%5B%3Ez%C2%93f%C3%8B%5Cu0006%5C%5C%2B%5Cu0015%C2%845%C2%8E%C2%B6%C3%92%C3%AE%C3%AE%C3%A81K%5Cb%C2%BFw%C3%85%5Cb%5B%40%5Cu0007%C2%90%C3%B6%C2%A3-%C2%A0%C2%9B%C2%BCbt)%C2%95K%C2%AE(%C2%BE%C2%A3%C2%B8%C3%A4L%5C%22%C3%93%C2%87YO%5Cu0004%C3%94%C2%83K%C3%97C%C2%98%C2%B8L%C2%9A%C2%AE%C3%87L%C3%A9%C3%B7-J%C2%AF%C2%97w%C2%8B%5Cu0012H%5C%22%C2%A9Ed%5E%5Cu0019%5Cu001f%C3%BA%C2%A2oQ%5Cu001c%C3%BE%C2%959t%5EQ%C3%92%3F%3Am%5Cu0007%5D%5Cu0002%C2%AA%C3%81X%C2%B3%C2%86O%C2%99%C3%89%2C%C3%AE%C2%B8%C3%9A%5Cu001e%C2%BEO*%C2%B9%C3%BF%5Cu001c%5Cu000b%C3%9D%C2%B6o%C3%8E%C3%8D%25%C3%8B%5Cu0007y4%C3%B1f%5D%5Cu0017%C2%AB9B%C2%88I%5Cu0004W%C2%92!%C3%8Ba0%5Cu0010%5Cu0002%C3%93E%C3%80%C2%81%40%5Cu0016%C3%A1%C3%82%C2%B5%5Cu0014a%C2%82%C3%92%C2%BE%C2%84%C3%90%3C!%C2%B8%C2%87%5Cu001dx4%C3%B9%5Cu001f%7B%5Cu0010%C3%9B%5Cu0016%22%2C%22margin%22%3Atrue%2C%22id%22%3A%22Ql2UK%22%2C%22viewportSetting%22%3A%7B%22zoom%22%3A1%2C%22scrollLeft%22%3A1000%2C%22scrollTop%22%3A453%2C%22viewBox%22%3A%5B-1513%2C-469%2C3026%2C938%5D%7D%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1596552963175-aa30181e-340b-4e14-b4b2-1537dc3107ef.png%22%2C%22search%22%3A%22%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E2%80%8B%20%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E2%80%8B%20%E2%80%8BJS%E6%98%AF%E4%B8%AA%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9C%89%E6%9D%A1%E4%B8%8D%E7%B4%8A%E5%9C%B0%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%BF%99%E5%B0%B1%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%9D%A5%E7%BB%9F%E7%AD%B9%E8%B0%83%E5%BA%A6%E8%BF%99%E4%BA%9B%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BB%9F%E7%AD%B9%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%B0%B1%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F%E3%80%82%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%E2%80%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%82%E5%AE%83%E7%AC%A6%E5%90%88%E9%98%9F%E5%88%97%E2%80%9C%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E2%80%9D%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E8%A6%81%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%98%9F%E5%88%97%E7%9A%84%E5%B0%BE%E9%83%A8%EF%BC%9B%E8%A6%81%E5%8F%96%E5%87%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AF%9D%EF%BC%8C%E4%BB%8E%E9%98%9F%E5%88%97%E5%A4%B4%E9%83%A8%E5%8E%BB%E5%8F%96%E3%80%82%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20%E2%80%8B%E5%9C%A8%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%8E%A5%E6%94%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E6%96%B0%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E9%87%87%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%82%20%E2%80%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%85%8D%E5%90%88%20%E2%80%8B%E2%80%8B%E8%8B%A5%E6%9C%89%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%88%99%E4%BC%9A%E9%80%9A%E8%BF%87IPC%E4%B8%8EIO%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%9B%20%E2%80%8BIO%E7%BA%BF%E7%A8%8B%E6%8E%A5%E6%94%B6%E5%88%B0%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BF%9B%E6%9D%A5%E7%9A%84%E6%B6%88%E6%81%AF%E5%90%8E%EF%BC%8C%E5%88%99%E4%BC%9A%E5%B0%86%E5%85%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8%EF%BC%9B%20%E2%80%8B%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E5%9C%B0%E4%BB%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A4%B4%E9%83%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%EF%BC%9B%20%E2%80%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%20%E2%80%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F%20%E2%80%8B%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%9D%A5%E8%A7%A3%E5%86%B3%20%E2%80%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF%E8%BF%87%E4%B9%85%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%20%E2%80%8BJavaScript%20%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%9B%9E%E8%B0%83%E5%8A%9F%E8%83%BD%E6%9D%A5%E8%A7%84%E9%81%BF%E8%BF%99%E7%A7%8D%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AE%A9%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%20JavaScript%20%E4%BB%BB%E5%8A%A1%E6%BB%9E%E5%90%8E%E6%89%A7%E8%A1%8C%E3%80%82%22%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1596552963175-aa30181e-340b-4e14-b4b2-1537dc3107ef.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;NVZVu&quot; data-lake-id=&quot;c9451e176a5a1131d8fae018cb56379f&quot;&gt;产生原因&lt;/h3&gt;
&lt;p data-lake-id=&quot;36bf6a630c98105b9b2be71111dc4dab&quot;&gt;为什么会有消息队列和事件循环呢？首先最关键的一点在于JS是个单线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。&lt;/p&gt;
&lt;h3 id=&quot;LGXWM&quot; data-lake-id=&quot;10c8f3d5c6af0151f58e900aa740d42c&quot;&gt;消息队列&lt;/h3&gt;
&lt;h4 id=&quot;Wy7gj&quot; data-lake-id=&quot;82bb97d923c224f05be5b189baf7bc98&quot;&gt;作用&lt;/h4&gt;
&lt;p data-lake-id=&quot;825b16e4739346b31a50eef3f16d05bc&quot;&gt;消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。&lt;/p&gt;
&lt;h3 id=&quot;2Ab6k&quot; data-lake-id=&quot;4238d189e1841813ce4939944b86557e&quot;&gt;事件循环&lt;/h3&gt;
&lt;h4 id=&quot;CcfEB&quot; data-lake-id=&quot;85c2ac72e130382385d50769d883cf26&quot;&gt;作用&lt;/h4&gt;
&lt;p data-lake-id=&quot;57b33a5148e5acb264183ec5f6d454bf&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;在线程运行过程中，接收并执行新的任务，就需要采用事件循环机制。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;bEdz6&quot; data-lake-id=&quot;38058a51da161004ff9d23abc3786c3c&quot;&gt;消息队列和事件循环的配合♻️&lt;/h3&gt;
&lt;p data-lake-id=&quot;3fea2ed84b66c850659bc2b1daa1763c&quot;&gt;                &lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F305942%2F1596548052271-341abd5f-cfaf-45ba-81d4-446117bcc29b.png%22%2C%22originWidth%22%3A1142%2C%22originHeight%22%3A834%2C%22name%22%3A%22image.png%22%2C%22size%22%3A229365%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A510.6253%2C%22y%22%3A62.323215%2C%22width%22%3A120.59765999999996%2C%22height%22%3A31.540825000000005%2C%22text%22%3A%22%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%22%7D%2C%7B%22x%22%3A84.19654%2C%22y%22%3A77.5953%2C%22width%22%3A25.880319999999998%2C%22height%22%3A25.880319999999998%2C%22text%22%3A%22%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%8A%22%7D%2C%7B%22x%22%3A982.1037%2C%22y%22%3A96.67659%2C%22width%22%3A96.82720000000006%2C%22height%22%3A21.88404%2C%22text%22%3A%22%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%22%7D%2C%7B%22x%22%3A66.42295%2C%22y%22%3A306.61328%2C%22width%22%3A26.819940000000003%2C%22height%22%3A26.819940000000003%2C%22text%22%3A%22%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%22%7D%2C%7B%22x%22%3A143.7631%2C%22y%22%3A331.14246%2C%22width%22%3A53.58543%2C%22height%22%3A23.313639999999964%2C%22text%22%3A%22%E6%B7%BB%E5%8A%A0%22%7D%2C%7B%22x%22%3A923.8093%2C%22y%22%3A331.61966%2C%22width%22%3A51.12639999999999%2C%22height%22%3A20.743799999999965%2C%22text%22%3A%22%E5%8F%96%E5%87%BA%22%7D%2C%7B%22x%22%3A603.1196%2C%22y%22%3A348.5145%2C%22width%22%3A61.235559999999964%2C%22height%22%3A23.68900000000002%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A13%22%7D%2C%7B%22x%22%3A800.52484%2C%22y%22%3A349.23892%2C%22width%22%3A63.504159999999956%2C%22height%22%3A24.973599999999976%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A11%22%7D%2C%7B%22x%22%3A433.2985%2C%22y%22%3A349.63974%2C%22width%22%3A60.90813000000003%2C%22height%22%3A22.387020000000007%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1n%22%7D%2C%7B%22x%22%3A321.06958%2C%22y%22%3A349.75357%2C%22width%22%3A82.30829%2C%22height%22%3A22.70621%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A1%E9%97%A8%2B1%22%7D%2C%7B%22x%22%3A699.6774%2C%22y%22%3A349.61194%2C%22width%22%3A65.84100000000001%2C%22height%22%3A22.72406000000001%2C%22text%22%3A%22%E4%BB%BB%E5%8A%A12%22%7D%2C%7B%22x%22%3A926.0548%2C%22y%22%3A367.81503%2C%22width%22%3A48.75117%2C%22height%22%3A24.57352000000003%2C%22text%22%3A%22%E5%8A%A1%22%7D%2C%7B%22x%22%3A144.53493%2C%22y%22%3A368.661%2C%22width%22%3A51.045559999999995%2C%22height%22%3A23.279729999999972%2C%22text%22%3A%22%E5%8A%A1%22%7D%2C%7B%22x%22%3A254.9725%2C%22y%22%3A420.55875%2C%22width%22%3A64.20284999999998%2C%22height%22%3A64.20284999999998%2C%22text%22%3A%22%E5%8A%A0%E6%9C%80%E6%88%90%22%7D%2C%7B%22x%22%3A448.51096%2C%22y%22%3A475.6825%2C%22width%22%3A22.223509999999976%2C%22height%22%3A22.223509999999976%2C%22text%22%3A%22%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%22%7D%2C%7B%22x%22%3A620.2753%2C%22y%22%3A476.15176%2C%22width%22%3A24.476%2C%22height%22%3A24.476%2C%22text%22%3A%22%E6%9E%97%E6%AF%9B%E8%85%A9%22%7D%2C%7B%22x%22%3A66.47126%2C%22y%22%3A586.5371%2C%22width%22%3A25.615579999999994%2C%22height%22%3A25.615579999999994%2C%22text%22%3A%22%E7%BA%BF%E7%A8%8B%22%7D%2C%7B%22x%22%3A361.9853%2C%22y%22%3A706.9296%2C%22width%22%3A138.55807%2C%22height%22%3A24.192499999999995%2C%22text%22%3A%22%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%22%7D%2C%7B%22x%22%3A294.90903%2C%22y%22%3A706.9865%2C%22width%22%3A48.468470000000025%2C%22height%22%3A23.97663%2C%22text%22%3A%22IpC%22%7D%2C%7B%22x%22%3A722.61053%2C%22y%22%3A707.3048%2C%22width%22%3A89.78346999999997%2C%22height%22%3A20.57826%2C%22text%22%3A%22%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%22%7D%2C%7B%22x%22%3A632.24146%2C%22y%22%3A708.4506%2C%22width%22%3A48.13458000000003%2C%22height%22%3A22.746599999999944%2C%22text%22%3A%22IPC%22%7D%2C%7B%22x%22%3A315.5184%2C%22y%22%3A768.0454%2C%22width%22%3A86.37817999999999%2C%22height%22%3A20.362100000000055%2C%22text%22%3A%22%E7%BD%91%E7%BB%9C%E8%BF%9B%E7%A8%8B%22%7D%2C%7B%22x%22%3A644.1382%2C%22y%22%3A768.23566%2C%22width%22%3A111.31650000000002%2C%22height%22%3A20.620339999999942%2C%22text%22%3A%22%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%20%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%8A%20%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%E6%B7%BB%E5%8A%A0%20%E5%8F%96%E5%87%BA%20%E4%BB%BB%E5%8A%A13%20%E4%BB%BB%E5%8A%A11%20%E4%BB%BB%E5%8A%A1n%20%E4%BB%BB%E5%8A%A1%E9%97%A8%2B1%20%E4%BB%BB%E5%8A%A12%20%E5%8A%A1%20%E5%8A%A1%20%E5%8A%A0%E6%9C%80%E6%88%90%20%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%20%E6%9E%97%E6%AF%9B%E8%85%A9%20%E7%BA%BF%E7%A8%8B%20%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%20IpC%20%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%20IPC%20%E7%BD%91%E7%BB%9C%E8%BF%9B%E7%A8%8B%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A571%2C%22height%22%3A417%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/305942/1596548052271-341abd5f-cfaf-45ba-81d4-446117bcc29b.png&quot; alt=&quot;image.png&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;gtzrV&quot; data-lake-id=&quot;af8a9d2f516c3bd1f808d624345eac24&quot;&gt;执行步骤&lt;/h4&gt;
&lt;ul data-lake-id=&quot;3d4c3e438b61d0dae9a6101101c36799&quot;&gt;&lt;li data-lake-id=&quot;f84c92a670aaeca766cbb1e912be0b0f&quot;&gt;若有其他进程通信则会通过IPC与IO线程进行消息传递，&lt;/li&gt;
&lt;li data-lake-id=&quot;15d88b47e9f015dafdbced805fab8207&quot;&gt;IO线程接收到其他进程传进来的消息后，则会将其添加到消息队列尾部；&lt;/li&gt;
&lt;li data-lake-id=&quot;3409e4d9d0c1226f484bb27e46a223f5&quot;&gt;渲染主线程循环地从消息队列头部中读取任务，执行任务；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tGjlf&quot; data-lake-id=&quot;f0b4c58f3cb5b0ee0523fb9fb093390e&quot;&gt;存在的问题&lt;/h3&gt;
&lt;h4 id=&quot;a6KhT&quot; data-lake-id=&quot;7357381f0bb53b9fbf95cc78feb06e26&quot;&gt;如何处理高优先级任务？&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p data-lake-id=&quot;8e216ba65f74d29cabf82badf039435d&quot;&gt;添加了微任务队列来解决，通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。&lt;/p&gt;
&lt;h4 id=&quot;Z2117&quot; data-lake-id=&quot;72a59c2f1f553d29e8c65ecb4ef6d4a8&quot;&gt;如何解决单个任务执行时长过久的问题？&lt;/h4&gt;
&lt;p data-lake-id=&quot;8e8cb74dafe68135cca4fb6cbb3d3ccf&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;8e8cb74dafe68135cca4fb6cbb3d3ccf&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-lake-id=&quot;9c19015fc0c4ee9395b36af180856ff0&quot;&gt;参考&lt;/p&gt;
&lt;p data-lake-id=&quot;00c22f2be9b175652d1ac7d72e56cd98&quot;&gt;浏览器工作原理与实践&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 04 Aug 2020 14:58:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>产生原因 为什么会有消息队列和事件循环呢？首先最关键的一点在于JS是个单线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/13436877.html</dc:identifier>
</item>
</channel>
</rss>