<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>CodeForces 379E  New Year Tree Decorations - sunyukai</title>
<link>http://www.cnblogs.com/sunyukai/p/10384124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunyukai/p/10384124.html</guid>
<description>&lt;h3 id=&quot;传送门&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/379/problem/E&quot;&gt;传送门&lt;/a&gt;&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;h2 id=&quot;题意&quot;&gt;题意&lt;/h2&gt;
&lt;p&gt;给你&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个在坐标系内下表面贴着&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;轴的多边形，求出每个多边形露出的面积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;正解-计算几何&quot;&gt;正解: 计算几何&lt;/h3&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h3 id=&quot;乱七八糟的解&quot;&gt;乱七八糟的解:&lt;/h3&gt;
&lt;p&gt;由于此题精度要求较小，故可以直接吧多边形暴力拆成&lt;span class=&quot;math inline&quot;&gt;\(1e6\)&lt;/span&gt;条梯形，又因为梯形宽度极小，故可近似当做长方形，若此长方形的长度比先前覆盖的长方形长度要长,求出它们的差值和，就为该多边形露出的面积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define double long double
using namespace std;
double t[5000005],h[5000005];
int main()
{
    int n,m;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    int nn=500000/m;
    for(int i=1;i&amp;lt;=n;i++)
    {
        cin&amp;gt;&amp;gt;t[0];
        double ans=0.0;
        for(int j=1;j&amp;lt;=m;j++)
        {
            cin&amp;gt;&amp;gt;t[j];
            double hh=(t[j]-t[j-1])/nn;
            for(int k=1;k&amp;lt;=nn;k++)
            {
                double x=t[j-1]+hh*k;
                if(x&amp;gt;h[(j-1)*nn+k])
                {
                    ans+=x-h[(j-1)*nn+k];
                    h[(j-1)*nn+k]=x;
                }
            }
        }
        cout&amp;lt;&amp;lt;ans/nn&amp;lt;&amp;lt;endl;
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 15 Feb 2019 07:57:00 +0000</pubDate>
<dc:creator>sunyukai</dc:creator>
<og:description>'传送门' 题意 给你$n$个在坐标系内下表面贴着$x$轴的多边形，求出每个多边形露出的面积。 思路 正解: 计算几何 乱七八糟的解: 由于此题精度要求较小，故可以直接吧多边形暴力拆成$1e6$条梯形</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunyukai/p/10384124.html</dc:identifier>
</item>
<item>
<title>python之isinstance内建函数 - BoomOoO</title>
<link>http://www.cnblogs.com/beiyi888/p/10384092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beiyi888/p/10384092.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;语句：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;isinstance（object，type）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　来判断一个对象是否是一个已知的类型。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;其第一个参数（object）为对象，第二个参数（type）为类型名(int...)或类型名的一个列表((int,list,float)是一个列表)。其返回值为布尔型（True or flase）。&lt;/p&gt;
&lt;p&gt;若对象的类型与参数二的类型相同则返回True。若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; a = 4&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance (a,int)&lt;br/&gt;True&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance (a,str)&lt;br/&gt;False&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance (a,(str,int,list))&lt;br/&gt;True&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;b&quot;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(a,str)&lt;br/&gt;True&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(a,int)&lt;br/&gt;False&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(a,(int,list,float))&lt;br/&gt;False&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(a,(int,list,float,str))&lt;br/&gt;True&lt;/p&gt;

</description>
<pubDate>Fri, 15 Feb 2019 07:54:00 +0000</pubDate>
<dc:creator>BoomOoO</dc:creator>
<og:description>语句： isinstance（object，type） 作用： 来判断一个对象是否是一个已知的类型。 解释： 其第一个参数（object）为对象，第二个参数（type）为类型名(int...)或类型名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/beiyi888/p/10384092.html</dc:identifier>
</item>
<item>
<title>目标检测之R-CNN系列 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/10384058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/10384058.html</guid>
<description>&lt;p&gt;Object Detection，在给定的图像中，找到目标图像的位置，并标注出来。 或者是，图像中有那些目标，目标的位置在那。这个目标，是限定在数据集中包含的目标种类，比如数据集中有两种目标:狗，猫。 就在图像找出来猫，狗的位置，并标注出来 是狗还是猫。&lt;/p&gt;
&lt;p&gt;这就涉及到两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;目标识别，识别出来目标是猫还是狗，Image Classification解决了图像的识别问题。&lt;/li&gt;
&lt;li&gt;定位，找出来猫狗的位置。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;r-cnn&quot;&gt;R-CNN&lt;/h2&gt;
&lt;p&gt;2012年AlexNet在ImageNet举办的ILSVRC中大放异彩，R-CNN作者受此启发，尝试将AlexNet在图像分类上的能力迁移到PASCAL VOC的目标检测上。这就要解决两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何利用卷积网络去目标定位&lt;/li&gt;
&lt;li&gt;如何在小规模的数据集上训练出较好的网络模型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于问题，R-CNN利用候选区域的方法（Region Proposal），这也是该网络被称为R-CNN的原因：Regions with CNN features。对于小规模数据集的问题，R-CNN使用了微调的方法，利用AlexNet在ImageNet上预训练好的模型。&lt;/p&gt;
&lt;p&gt;R-CNN目标检测的思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定一张图片，从图片中选出2000个独立的候选区域(Region Proposal)&lt;/li&gt;
&lt;li&gt;将每个候选区域输入到预训练好的AlexNet中，提取一个固定长度（4096）的特征向量&lt;/li&gt;
&lt;li&gt;对每个目标（类别）训练一SVM分类器，识别该区域是否包含目标&lt;/li&gt;
&lt;li&gt;训练一个回归器，修正候选区域中目标的位置：对于每个类，训练一个线性回归模型判断当前框是不是很完美。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图给出了，R-CNN的目标检测过程&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154413919-1830413148.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;训练&quot;&gt;训练&lt;/h3&gt;
&lt;p&gt;R-CNN进行目标检测的训练流程:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用区域生成算法，生成2000个候选区域，这里使用的是Selective search.&lt;/li&gt;
&lt;li&gt;对生成的2000个候选区域，使用预训练好的AlexNet网络进行特征提取。
&lt;ul&gt;&lt;li&gt;将候选区域变换到网络需要的尺寸(&lt;span class=&quot;math inline&quot;&gt;\(227 \times 227\)&lt;/span&gt;)。 在进行变换的时候，在每个区域的边缘添加&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;个像素，也就是手工的添加个边框，设置&lt;span class=&quot;math inline&quot;&gt;\(p = 16\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;改造预训练好的AlexNet网络，将其最后的全连接层去掉，并将类别设置为21（20个类别，另外一个类别代表背景）.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154441179-22402996.jpg&quot;/&gt;&lt;br/&gt;这样一个候选区域输入到网络中，最终得到一个&lt;span class=&quot;math inline&quot;&gt;\(4096 \times 21\)&lt;/span&gt;的特征。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用上面提取到的候选区域的特征，对每个类别训练一个SVM分类器（而分类）来判断，候选框里物体的类别，是给类别就是positive，不是就是negative。比如，下图针对狗的SVM分类器&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154458536-317991547.jpg&quot;/&gt;&lt;br/&gt;狗的SVM分类器，就要能判断出某个候选区域是不是包含狗，包含狗了那就是Positive；不包含就是Negative.这里有个问题是，假如候选区域只是框出来了某个类的一部分，那要怎么来标注这个区域呢。在R-CNN中，设定一个IOU的阈值，如果该区域与Ground truth的IOU低于该阈值，就将给区域设置为Negative。阈值设置为0.3。&lt;/li&gt;
&lt;li&gt;对于面只是得到了每个候选框是不是包含某个目标，其得到的区域位置不是很准确。这里需要再训练一个线性回归模型判断，候选区域框出的目标是不是完美。对于某个类别的SVM是Positive的候选区域，来判断其框的目标区域是不是很完美。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154517499-1574184182.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;从一张图片中提取2000个候选区域，将每个区域按照训练时候的方式进行处理，输入到SVM中进行正负样本的识别，并使用候选框回归器，计算出每个候选区域的分数。&lt;br/&gt;候选区域较多，有2000个，所有很多重叠的部分，就需要剔除掉重叠的部分。&lt;br/&gt;针对每个类，通过计算IOU,采取非最大值抑制的方法，以最高分的区域为基础，删掉重叠的区域。&lt;/p&gt;
&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;训练分为多个步骤，比较繁琐。 需要微调CNN网络提取特征，训练SVM进行正负样本分类，训练边框回归器得到正确的预测位置。&lt;/li&gt;
&lt;li&gt;训练耗时，中间要保持候选区域的特征，5000张的图片会生成几百G的特征文件。&lt;/li&gt;
&lt;li&gt;速度慢&lt;/li&gt;
&lt;li&gt;SVM分类器和边框回归器的训练过程，和CNN提取特征的过程是分开的，并不能进行特征的学些更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;fast-r-cnn&quot;&gt;Fast R-CNN&lt;/h2&gt;
&lt;p&gt;R-CNN虽然取得了不错的成绩，但是其缺点也很明显。Ross Girshick在15年推出Fast RCNN，构思精巧，流程更为紧凑，大幅提升了目标检测的速度。同样使用最大规模的网络，Fast RCNN和RCNN相比，训练时间从84小时减少为9.5小时，测试时间从47秒减少为0.32秒。在PASCAL VOC 2007上的准确率相差不大约在66%-67%之间。&lt;/p&gt;
&lt;p&gt;Fast RCNN主要是解决RCNN的问题的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试训练速度慢，主要是提取候选区域的特征慢&lt;br/&gt;R-CNN首先从测试图中提取2000个候选区域，然后将这2000个候选区域分别输入到预训练好的CNN中提取特征。由于候选区域有大量的重叠，这种提取特征的方法，就会重复的计算重叠区域的特征。在Fast-RCNN中，将整张图输入到CNN中提取特征，在邻接时在映射到每一个候选区域，这样只需要在末尾的少数层单独的处理每个候选框。&lt;/li&gt;
&lt;li&gt;训练需要额外的空间保存提取到的特征信息&lt;br/&gt;RCNN中需要将提取到的特征保存下来，用于为每个类训练单独的SVM分类器和边框回归器。在Fast-RCNN中，将类别判断和边框回归统一的使用CNN实现，不需要在额外的存储特征。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;fast-r-cnn的结构&quot;&gt;Fast R-CNN的结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154538355-1035897552.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入是整幅图像和多个感兴趣区域（ROI）的位置信息，在前面的网络层中并不会处理ROI信息，在后面的RoI pooling layer中，将每个RoI池化到固定大小的特征图中，然后通过全连接层提取特征。最后通过将提取的每个RoI特征输入到SoftMax分类器已经边框回归器中，完成目标定位的端到端的训练。&lt;br/&gt;Fast R-CNN网络将整个图像和一组候选框作为输入。网络首先使用几个卷积层（conv）和最大池化层来处理整个图像，以产生卷积特征图。然后，对于每个候选框，RoI池化层从特征图中提取固定长度的特征向量。每个特征向量被送入一系列全连接（fc）层中，其最终分支成两个同级输出层 ：一个输出个类别加上1个背景类别的Softmax概率估计，另一个为个类别的每一个类别输出四个实数值。每组4个值表示个类别的一个类别的检测框位置的修正。&lt;/p&gt;
&lt;h3 id=&quot;roi-池化层&quot;&gt;ROI 池化层&lt;/h3&gt;
&lt;p&gt;ROI池化层前面的网络层是对整幅图像提取特征得到多个Feature Map。ROI池化层的输入就是这多个Feature Map以及多个ROI（候选区域），这里的ROI是一个矩形框，由其左上角的坐标以及宽高组成的四元组&lt;span class=&quot;math inline&quot;&gt;\((r,c,h,w)\)&lt;/span&gt;定义。&lt;/p&gt;
&lt;p&gt;ROI池化层使用&lt;strong&gt;最大池化&lt;/strong&gt;将输入的Feature Map中的任意区域（ROI对应的区域）内的特征转化为固定的&lt;span class=&quot;math inline&quot;&gt;\(H \times W\)&lt;/span&gt;的特征图，其中&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;是超参数。 对于任意输入的&lt;span class=&quot;math inline&quot;&gt;\(h \times w\)&lt;/span&gt;的ROI，将其分割为&lt;span class=&quot;math inline&quot;&gt;\(H \times W\)&lt;/span&gt;的子网格，每个子网格的大小为&lt;span class=&quot;math inline&quot;&gt;\(\frac{h}{H} \times \frac{w}{W}\)&lt;/span&gt;。如下，取得&lt;span class=&quot;math inline&quot;&gt;\(2\times 2\)&lt;/span&gt;的特征图&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入的Feature Map&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154608245-707422795.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ROI投影到Feature Map上的左上角的坐标为&lt;span class=&quot;math inline&quot;&gt;\((0,3)\)&lt;/span&gt;,宽高为&lt;span class=&quot;math inline&quot;&gt;\((7,5)\)&lt;/span&gt;，在Feature Map上位置如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154555631-1520891776.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;对每个子网格做最大池化操作&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154630644-1304406778.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ROI池化层的池化操作同标准的池化操作是一样的，每个通道都单独执行。&lt;/p&gt;
&lt;h3 id=&quot;预训练网络&quot;&gt;预训练网络&lt;/h3&gt;
&lt;p&gt;通过ROI池化层可以从整幅图像的特征图中得到每个ROI的特征图（固定大小），而整幅图像的特征图则使用预训练的网络提取得到。对于预训练完成的网络要做如下的修改：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用ROI池化层代替预训练网络的最后的池化层，并将超参&lt;span class=&quot;math inline&quot;&gt;\(H,W\)&lt;/span&gt;设置为和网络第一个全连接兼容的值，例如VGG16，设&lt;span class=&quot;math inline&quot;&gt;\(H = W = 7\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;原网络的最后一个全连接层替换为两个同级层:&lt;span class=&quot;math inline&quot;&gt;\(K + 1\)&lt;/span&gt;个类别的SoftMax分类层和类别的边框回归层。&lt;/li&gt;
&lt;li&gt;网络的输入修改为两个：图像的列表以及相对应的ROI的列表&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;训练微调&quot;&gt;训练微调&lt;/h3&gt;
&lt;p&gt;R-CNN中的特征提取和检测部分是分开进行的，使用检测样本进行训练的时候无法更新特征提取部分的参数。SPPnet也不能更新金字塔层前面的卷积层权重，这是因为当批量训练的样本来自不同的图片时，，反向传播通过SPP层时十分低效。Fast R-CNN则可以使用反向传播的方法更新整个网络的参数。&lt;/p&gt;
&lt;p&gt;Fast R-CNN提出一个高效的训练方法，可以在训练过程中发挥特征共享的优势。在Fast R-CNN训练过程中随机梯度下降(SGD)的mini-batch是分层采样的，首先取&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;张图像，然后从每张图片采样&lt;span class=&quot;math inline&quot;&gt;\(\frac{R}{N}\)&lt;/span&gt;个RoI。来自同一张图片的RoI在前向和后向传播中共享计算和内存。这样就可以减少mini-batch的计算量。例如&lt;span class=&quot;math inline&quot;&gt;\(N=2，R=128\)&lt;/span&gt;，这个训练模式大概比从128个不同的图像采样1个RoI（这就是R-CNN和SPPnet的训练方式）要快64倍。&lt;/p&gt;
&lt;p&gt;该策略一个问题是会导致收敛起来比较慢，因为来自同一张图片的RoI是相关的。但它在实际中并没有成为一个问题，我们的使用&lt;span class=&quot;math inline&quot;&gt;\(N=2,R=128\)&lt;/span&gt;达到了很好的成绩，只用了比R-CNN还少的SGD迭代。&lt;/p&gt;
&lt;h3 id=&quot;multi-task-loss&quot;&gt;Multi-task Loss&lt;/h3&gt;
&lt;p&gt;Fast R-CNN有两种输出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类的Softmax输出，对于每个RoI输出一个概率，&lt;span class=&quot;math inline&quot;&gt;\(p = {p_0,p_1,\dots,p_k}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(k + 1\)&lt;/span&gt;个类，包括一个背景类别。&lt;/li&gt;
&lt;li&gt;边框回归：&lt;span class=&quot;math inline&quot;&gt;\(t^k = (t_x^k,t_y^k,t_w^k,t_h^k)\)&lt;/span&gt;。 其中，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;类别的索引，&lt;span class=&quot;math inline&quot;&gt;\(t_x^k,t_y^k\)&lt;/span&gt;是相对于候选区域尺度不变的平移，&lt;span class=&quot;math inline&quot;&gt;\(t_w^k,t_h^k\)&lt;/span&gt;相对于候选区域对数空间的位移。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上面的两个任务的需要色损失函数放在一起&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(p,u,t^u,v) = L_{cls}(p,u) + \lambda [u \ge 1]L_{Ioc}(t^u,v) \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(L_{cls}(p,u)\)&lt;/span&gt;是分类的损失函数，&lt;span class=&quot;math inline&quot;&gt;\(p_u\)&lt;/span&gt;是class u的真实分类的概率。这里，约定&lt;span class=&quot;math inline&quot;&gt;\(u = 0\)&lt;/span&gt;表示背景，不参与边框回归的损失计算。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L_{cls}(p,u) = -\log (p_u) \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(L_{Ioc}(t^u,v)\)&lt;/span&gt;是边框回归的损失函数，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} L_{Ioc}(t^u,v) &amp;amp;= \sum_{i \in {x,y,w,h}}smooth_{L_1}(t_i^u - v) \end{align*} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;表示类别，&lt;span class=&quot;math inline&quot;&gt;\(t^u\)&lt;/span&gt;表示预测边框的偏移量（也就是预测边框进行&lt;span class=&quot;math inline&quot;&gt;\(t^u\)&lt;/span&gt;偏移后，能够和真实边框最接近），&lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt;表示预测边框和实际边框之间真正的偏移量&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ smooth_{L_1}(x) = \left\{ \begin{array}{cc} 0.5 x^2 &amp;amp; if |x| &amp;lt; 1 \\ |x|-0.5 &amp;amp; otherwise\end{array}\right. \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里&lt;span class=&quot;math inline&quot;&gt;\(smooth_{L_1}(x)\)&lt;/span&gt;中的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为真实值和预测值坐标对应值的差值，该函数在&lt;span class=&quot;math inline&quot;&gt;\((-1,1)\)&lt;/span&gt;之间为二次函数，在其他位置为线性函数，Fast RCNN作者表示作者表示这种形式可以增强模型对异常数据的鲁棒性。其函数曲线如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154648050-875631303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于边框的修正后面单独详述。&lt;/p&gt;
&lt;h3 id=&quot;truncated-svd-for-faster-detection&quot;&gt;Truncated SVD for faster detection&lt;/h3&gt;
&lt;p&gt;在进行目标检测时，需要处理的RoI的个数较多，几乎一半的时间花费在全连接层的计算上。就Fast R-CNN而言，RoI池化层后的全连接层需要进行约2k次，因此在Fast R-CNN中可以采用SVD分解加速全连接层计算。&lt;br/&gt;设全连接层的输入为&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;，权值矩阵为&lt;span class=&quot;math inline&quot;&gt;\(W_{u\times v}\)&lt;/span&gt;，输出为&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;，则全连接层的实际上的计算是一个矩阵的乘法&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Y = W \cdot X \]&lt;/span&gt;&lt;br/&gt;可以将权值矩阵&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;进行奇异值分解（SVD分解），使用其前&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;个特征值近似代替该矩阵&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ W \approx U \Sigma_t V^T \]&lt;/span&gt;&lt;br/&gt;其中,&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(u \times t\)&lt;/span&gt;的左奇异矩阵，&lt;span class=&quot;math inline&quot;&gt;\(\Sigma_t\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(t \times t\)&lt;/span&gt;的对角矩阵，&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(v \times t\)&lt;/span&gt;的右奇异矩阵。&lt;br/&gt;截断SVD将参数量由原来的 &lt;span class=&quot;math inline&quot;&gt;\(u \times v\)&lt;/span&gt; 减少到 &lt;span class=&quot;math inline&quot;&gt;\(t \times (u + v)\)&lt;/span&gt;，当 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 远小于 &lt;span class=&quot;math inline&quot;&gt;\(min(u,v)\)&lt;/span&gt; 的时候降低了很大的计算量。&lt;br/&gt;在实现时，相当于把一个全连接层拆分为两个全连接层，第一个全连接层使用权值矩阵&lt;span class=&quot;math inline&quot;&gt;\(\Sigma_t V^T\)&lt;/span&gt;（不含偏置），第二个全连接层使用矩阵&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;（含偏置）.当RoI的数量大时，这种简单的压缩方法有很好的加速&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Fast R-CNN是对R-CNN的一种改进&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;卷积不再是对每个region proposal进行，而是直接对整张图像，这样减少了很多重复计算。原来RCNN是对每个region proposal分别做卷积，因为一张图像中有2000左右的region proposal，肯定相互之间的重叠率很高，因此产生重复计算。&lt;/li&gt;
&lt;li&gt;用ROI pooling进行特征的尺寸变换，因为全连接层的输入要求尺寸大小一样，因此不能直接把region proposal作为输入&lt;/li&gt;
&lt;li&gt;将regressor放进网络一起训练，每个类别对应一个regressor，同时用softmax的全连接层代替原来的SVM分类器。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;faster-r-cnn&quot;&gt;Faster R-CNN&lt;/h2&gt;
&lt;p&gt;在Fast R-CNN中使用的目标检测识别网络，在速度和精度上都有了不错的结果。不足的是，其候选区域提取方法耗时较长，而且和目标检测网络是分离的，并不是end-to-end的。在Faster R-CNN中提出了区域检测网络(Region Proposal Network,RPN)，将候选区域的提取和Fast R-CNN中的目标检测网络融合到一起，这样可以在同一个网络中实现目标检测。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154707230-1348683507.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Faster R-CNN的网络有4部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Conv Layers 一组基础的CNN层，由Conv + Relu + Pooling组成，用于提取输入图像的Feature Map。通常可以选择有5个卷积层的ZF网络或者有13个卷积层的VGG16。Conv Layers提取的Feature Map用于RNP网络生成候选区域以及用于分类和边框回归的全连接层。&lt;/li&gt;
&lt;li&gt;RPN，区域检测网络 输入的是前面卷积层提取的Feature Map，输出为一系列的候选区域。&lt;/li&gt;
&lt;li&gt;RoI池化层 输入的是卷积层提取的Feature Map 和 RPN生成的候选区域RoI，其作用是将Feature Map 中每一个RoI对应的区域转为为固定大小的&lt;span class=&quot;math inline&quot;&gt;\(H \times W\)&lt;/span&gt;的特征图，输入到后面的分类和边框回归的全连接层。&lt;/li&gt;
&lt;li&gt;分类和边框回归修正 输入的是RoI池化后RoI的&lt;span class=&quot;math inline&quot;&gt;\(H \times W\)&lt;/span&gt;的特征图，通过SoftMax判断每个RoI的类别，并对边框进行修正。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其整个工作流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将样本图像整个输入到Conv Layers中，最后得到Feature Map。&lt;/li&gt;
&lt;li&gt;将该Feature Map输入到RPN网络中，提取到一系列的候选区域&lt;/li&gt;
&lt;li&gt;然后由RoI池化层提取每个候选区域的特征图&lt;/li&gt;
&lt;li&gt;将候选区域的特征图输入到用于分类的Softmax层以及用于边框回归全连接层。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Faster R-CNN的4个组成部分，其中Conv Layers，RoI池化层以及分类和边框回归修正，和Fast R-CNN的区别不是很大，其重大改进就是使用RPN网络生成候选区域。&lt;/p&gt;
&lt;h3 id=&quot;卷积层-conv-layers&quot;&gt;卷积层 Conv Layers&lt;/h3&gt;
&lt;p&gt;前面的卷积层用于提取输入图像的特征，生成Feature Map。这里有VGG-16为例，Conv layers部分共有13个conv层，13个relu层，4个pooling层。在VGG中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的卷积层都使用&lt;span class=&quot;math inline&quot;&gt;\(3\times3\)&lt;/span&gt;的卷积核，步长为1，并对边缘做了填充&lt;span class=&quot;math inline&quot;&gt;\(padding=1\)&lt;/span&gt;。这样对于输入&lt;span class=&quot;math inline&quot;&gt;\(W \times W\)&lt;/span&gt;的图像，通过卷积后，其输出尺寸为&lt;span class=&quot;math inline&quot;&gt;\((W - 3 + 2 * padding) / 1 + 1 = W\)&lt;/span&gt;，也就是通过卷积层图像的尺寸并不会变小。&lt;/li&gt;
&lt;li&gt;池化层都是用&lt;span class=&quot;math inline&quot;&gt;\(2 \times 2\)&lt;/span&gt;的池化单元，步长为2。对于&lt;span class=&quot;math inline&quot;&gt;\(W \times W\)&lt;/span&gt;的图像，通过池化层后，其输出的尺寸为&lt;span class=&quot;math inline&quot;&gt;\((W - 2) / 2 + 1 = W / 2\)&lt;/span&gt;，也就是通过一个池化层图像的尺寸会变为输入前的$1 /2 $。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Conv Layers的13个conv层并不会改变图像的尺寸，而有4个池化层，每个池化层将输入缩小为原来的&lt;span class=&quot;math inline&quot;&gt;\(1/2\)&lt;/span&gt;,则对于&lt;span class=&quot;math inline&quot;&gt;\(W \times W\)&lt;/span&gt;的输入，Conv Layers输出的Feature Map的宽和高为&lt;span class=&quot;math inline&quot;&gt;\(W / 16 \times W /16\)&lt;/span&gt;，也就是输入尺寸的&lt;span class=&quot;math inline&quot;&gt;\(1/16\)&lt;/span&gt;。 有了这个Feature Map相对于原始输入图像的宽高比例，就可以计算出Feature Map中的每个点对应于原图的区域。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于池化层的降采样，Feature Map中的点映射回原图上，对应的不是某个像素点，而是矩形区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;区域检测网络-rpn&quot;&gt;区域检测网络 RPN&lt;/h3&gt;
&lt;p&gt;区域提议网络（RPN）以任意大小的图像作为输入，输出一组矩形的候选区域，并且给每个候选区域打上一个分数。如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154726728-635312781.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RPN输入的是前面Conv Layers提取图像的Feature Map，输出有两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;候选区域的位置信息（一个4维元组）&lt;/li&gt;
&lt;li&gt;候选区域对应的类别（二分类，背景还是前景）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了得到上述的两种输出，要从输入的Feature Map上得到两种信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;候选区域在原始输入图像的位置信息&lt;/li&gt;
&lt;li&gt;每个候选区域对应的Feature Map，用于分类。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;anchor&quot;&gt;Anchor&lt;/h4&gt;
&lt;p&gt;前面提到由于池化层的降采样，Feature Map中的点映射回原图上，对应的不是某个像素点，而是矩形区域。很简单的，可以将Feature Map中的每个点映射回原始图像，就可以得到一个候选区域，但是这样得到的区域太过于粗糙，显然是不行的。Faster R-CNN使用的是&lt;strong&gt;将每个Feature Map中的点映射到原图上，并以映射后的位置为中心，在原图取不同形状和不同面积的矩形区域，作为候选区域。&lt;/strong&gt; 论文中提出了&lt;strong&gt;Anchor&lt;/strong&gt;的概念来表示这种取候选区域的方法：一个&lt;strong&gt;Anchor&lt;/strong&gt;就是Feature Map中的一个点，并有一个相关的尺度和纵横比。说白了，&lt;strong&gt;Anchor&lt;/strong&gt;就是一个候选区域的参数化表示，有了中心点坐标，知道尺寸信息以及纵横比，很容易通过缩放比例在原图上找到对应的区域。&lt;/p&gt;
&lt;p&gt;在论文中为每个Anchor设计了3种不同的尺度&lt;span class=&quot;math inline&quot;&gt;\({128\times 128,256 \times 256,512 \times 512}\)&lt;/span&gt;,3种形状，也就是不同的长宽比&lt;span class=&quot;math inline&quot;&gt;\(W:H = {1:1,1:2,2:1}\)&lt;/span&gt;，这样Feature Map中的点就可以组合出来9个不同形状不同尺度的Anchor。下图展示的是这9个Anchor对应的候选区域：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154743256-544052396.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现假设输入到Conv Layers的图像尺寸为&lt;span class=&quot;math inline&quot;&gt;\(800 \times 600\)&lt;/span&gt;,通过VGG16的下采样缩小了16倍，则最终生成的Feature Map的尺寸为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ ceil(800/16) \times ceil(600 /16 ) = 50 \times 38 \]&lt;/span&gt;&lt;br/&gt;有Feature Map的一个点&lt;span class=&quot;math inline&quot;&gt;\((5,5)\)&lt;/span&gt;，以该点为Anchro，生成不同的候选区域&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先将该点映射回原图的坐标为&lt;span class=&quot;math inline&quot;&gt;\((5 \times 16,5 \times 16) = (90,90)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;选择一个形状和面积的组合，例如尺度为&lt;span class=&quot;math inline&quot;&gt;\(128 \times 128\)&lt;/span&gt;,形状为&lt;span class=&quot;math inline&quot;&gt;\(W:H = 1:1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在原图上以&lt;span class=&quot;math inline&quot;&gt;\((90,90)\)&lt;/span&gt;为中心，计算符合上述形状的区域的坐标&lt;span class=&quot;math inline&quot;&gt;\((x_1,y_1,x_2,y_2)=(36,36,154,154)\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} x_1 &amp;amp;= 90 - 128 / 2 = 90 - 64 = 36 \\ x_2 &amp;amp;= 90 + 128 / 2 = 90 + 64 = 154 \\ y_1 &amp;amp;= 90 - 128 / 2 = 90 - 64 = 36 \\ y_2 &amp;amp;= 90 + 128 / 2 = 90 + 64 = 154 \end{align*} \]&lt;/span&gt;&lt;br/&gt;上面就得到了位置为&lt;span class=&quot;math inline&quot;&gt;\((5,5)\)&lt;/span&gt;，尺度为&lt;span class=&quot;math inline&quot;&gt;\(128 \times 128\)&lt;/span&gt;,形状为&lt;span class=&quot;math inline&quot;&gt;\(W:H = 1:1\)&lt;/span&gt;的Anchor在原图上取得的候选区域。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有区域信息也不行啊，这些区域有可能是前景也有可能是背景，这就需要提取这些区域对应的特征信息，用于分类。对于VGG16，其最终生成的特征图有512个通道，也就是每个点都可以得到一个512维的特征，将这个特征作为该点为Anchor生成的区域特征，用于分类。 论文中，是在特征图上做一个&lt;span class=&quot;math inline&quot;&gt;\(3 \times 3\)&lt;/span&gt;的卷积，融合了周围的信息。&lt;/p&gt;
&lt;p&gt;设Feature Map的尺度为&lt;span class=&quot;math inline&quot;&gt;\(W \times H\)&lt;/span&gt;,每个点上生成k个Anchor(&lt;span class=&quot;math inline&quot;&gt;\(k = 9\)&lt;/span&gt;)，则总共可以得到&lt;span class=&quot;math inline&quot;&gt;\(WHk\)&lt;/span&gt;个Anchors。而每个Anchor即可能是前景也可能是背景，则需要Softmax层&lt;span class=&quot;math inline&quot;&gt;\(cls = 2k\)&lt;/span&gt; scores；并且每个anchor对应的候选区域相对于真实的边框有$(x,y,w,y)&lt;span class=&quot;math inline&quot;&gt;\(4个偏移量，这就需要边框回归层\)&lt;/span&gt;reg = 4k$ coordinates。&lt;/p&gt;
&lt;h4 id=&quot;训练-1&quot;&gt;训练&lt;/h4&gt;
&lt;p&gt;每个anchor即可能包含目标区域，也可能没有目标。 对于包含目标区域的anchor分为positive label，论文中规定，符合下面条件之一的即为positive样本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与任意GT区域的IoU大于0.7&lt;/li&gt;
&lt;li&gt;与GT（Groud Truth）区域的IoU最大的anchor（也许不到0.7)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;和任意GT的区域的IoU都小于0.3的anchor设为negative样本，对于既不是正标签也不是负标签的anchor，以及跨越图像边界的anchor就直接舍弃掉。&lt;/p&gt;
&lt;p&gt;由于一张图像能够得到&lt;span class=&quot;math inline&quot;&gt;\(WHk\)&lt;/span&gt;个Anchors，显然不能将所有的anchor都用于训练。在训练的时候从一幅图像中随机的选择256个anchor用于训练，其中positive样本128个，negative样本128个。&lt;/p&gt;
&lt;p&gt;关于边框回归的具体内容，由于本文内容过多，这里不再说明，单独另写。&lt;/p&gt;
&lt;h2 id=&quot;summary-1&quot;&gt;summary&lt;/h2&gt;
&lt;p&gt;本文就R-CNN的系列文章进行了一个大致的梳理，从R-CNN初次将CNN应用于目标检测，到最终的Faster R-CNN通过一个CNN网络完成整个目标检测的演变过程。下图总结下三个网络&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190215154756105-438665722.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.8627450980392&quot;&gt;
&lt;p&gt;上表格引用自 &lt;a href=&quot;https://blog.csdn.net/qq_17448289/article/details/52871461&quot; title=&quot;Faster R-CNN论文笔记——FR&quot;&gt;Faster R-CNN论文笔记——FR&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 15 Feb 2019 07:48:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<og:description>Object Detection，在给定的图像中，找到目标图像的位置，并标注出来。 或者是，图像中有那些目标，目标的位置在那。这个目标，是限定在数据集中包含的目标种类，比如数据集中有两种目标:狗，猫。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/10384058.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S2E5：浅谈四种API设计风格（RRC、REST、GraphQL、服务端驱动） - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10383756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10383756.html</guid>
<description>&lt;p&gt;Web API设计其实是一个挺重要的设计话题，许多公司都会有公司层面的Web API设计规范，几乎所有的项目在详细设计阶段都会进行API设计，项目开发后都会有一份API文档供测试和联调。本文尝试根据自己的理解总结一下目前常见的四种API设计风格以及设计考虑点。&lt;/p&gt;
&lt;h2 id=&quot;rpc&quot;&gt;RPC&lt;/h2&gt;
&lt;p&gt;这是最常见的方式，RPC说的是本地调用远程的方法，面向的是过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RPC形式的API组织形态是类和方法，或者说领域和行为。&lt;/li&gt;
&lt;li&gt;因此API的命名往往是一个动词，比如&lt;strong&gt;GetUserInfo,CreateUser&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因为URI会非常多而且往往没有一些约定规范，所以需要有详细的文档。&lt;/li&gt;
&lt;li&gt;也是因为无拘无束，HTTP方法基本只用GET和POST，设计起来比较简单。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里就不贴例子了，估计超过50%的API是这种分格的。&lt;/p&gt;
&lt;h2 id=&quot;rest&quot;&gt;REST&lt;/h2&gt;
&lt;p&gt;是一种架构风格，有四个级别的成熟度：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;级别 0：定义一个 URI，所有操作是对此 URI 发出的 POST 请求。&lt;/li&gt;
&lt;li&gt;级别 1：为各个资源单独创建 URI。&lt;/li&gt;
&lt;li&gt;级别 2：使用 HTTP 方法来定义对资源执行的操作。&lt;/li&gt;
&lt;li&gt;级别 3：使用超媒体（HATEOAS）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;级别0其实就是类RPC的风格，级别3是真正的REST，大多数号称REST的API在级别2。REST实现一些要点包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REST形式的API组织形态是资源和实体，一切围绕资源（级别1的要点）。设计流程包括：
&lt;ul&gt;&lt;li&gt;确定API提供的资源&lt;/li&gt;
&lt;li&gt;确定资源之间的关系&lt;/li&gt;
&lt;li&gt;根据资源类型和关系确定资源URI结构&lt;/li&gt;
&lt;li&gt;确定资源的结构体&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;会定义一些标准方法（级别2的要点），然后把标准方法映射到实现（比如HTTP Method）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168efee4614757b0?w=998&amp;amp;h=492&amp;amp;f=png&amp;amp;s=101227&quot;/&gt;&lt;ul&gt;&lt;li&gt;GET：获取资源详情或资源列表。对于collection类型的URI（比如&lt;strong&gt;/customers&lt;/strong&gt;）就是获取资源列表，对于item类型的URI（比如&lt;strong&gt;/customers/1&lt;/strong&gt;）就是获取一个资源。&lt;/li&gt;
&lt;li&gt;POST：创建资源，请求体是新资源的内容。往往POST是用于为集合新增资源。&lt;/li&gt;
&lt;li&gt;PUT：创建或修改资源，请求体是新资源的内容。往往PUT用于单个资源的新增或修改。实现上必须幂等。&lt;/li&gt;
&lt;li&gt;PATCH：部分修改资源，请求体是修改的那部分内容。PUT一般要求提交整个资源进行修改，而PATCH用于修改部分内容（比如某个属性）。&lt;/li&gt;
&lt;li&gt;DELETE：移除资源。和GET一样，对于collection类型的URI（比如&lt;strong&gt;/customers&lt;/strong&gt;）就是删除所有资源，对于item类型的URI（比如&lt;strong&gt;/customers/1&lt;/strong&gt;）就是删除一个资源。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需要考虑资源之间的导航（级别3的要点，比如使用HATEOAS，HATEOAS是Hypertext as the Engine of Application State的缩写）。有了资源导航，客户端甚至可能不需要参阅文档就可以找到更多对自己有用的资源，不过HATEOAS没有固定的标准，比如：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;{
    &quot;content&quot;: [ {
        &quot;price&quot;: 499.00,
        &quot;description&quot;: &quot;Apple tablet device&quot;,
        &quot;name&quot;: &quot;iPad&quot;,
        &quot;links&quot;: [ {
            &quot;rel&quot;: &quot;self&quot;,
            &quot;href&quot;: &quot;http://localhost:8080/product/1&quot;
        } ],
        &quot;attributes&quot;: {
            &quot;connector&quot;: &quot;socket&quot;
        }
    }, {
        &quot;price&quot;: 49.00,
        &quot;description&quot;: &quot;Dock for iPhone/iPad&quot;,
        &quot;name&quot;: &quot;Dock&quot;,
        &quot;links&quot;: [ {
            &quot;rel&quot;: &quot;self&quot;,
            &quot;href&quot;: &quot;http://localhost:8080/product/3&quot;
        } ],
        &quot;attributes&quot;: {
            &quot;connector&quot;: &quot;plug&quot;
        }
    } ],
    &quot;links&quot;: [ {
        &quot;rel&quot;: &quot;product.search&quot;,
        &quot;href&quot;: &quot;http://localhost:8080/product/search&quot;
    } ]
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring框架也提供了相应的支持：https://spring.io/projects/spring-hateoas，比如如下的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class GreetingController {

    private static final String TEMPLATE = &quot;Hello, %s!&quot;;

    @RequestMapping(&quot;/greeting&quot;)
    public HttpEntity&amp;lt;Greeting&amp;gt; greeting(
            @RequestParam(value = &quot;name&quot;, required = false, defaultValue = &quot;World&quot;) String name) {

        Greeting greeting = new Greeting(String.format(TEMPLATE, name));
        greeting.add(linkTo(methodOn(GreetingController.class).greeting(name)).withSelfRel());

        return new ResponseEntity&amp;lt;&amp;gt;(greeting, HttpStatus.OK);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;产生如下的结果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168efef0d4bff7a3?w=625&amp;amp;h=210&amp;amp;f=png&amp;amp;s=22800&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除了之前提到的几个要点，REST API的设计还有一些小点：
&lt;ul&gt;&lt;li&gt;必须无状态的，相互独立的，不区分顺序的&lt;/li&gt;
&lt;li&gt;API需要有一致的接口来解耦客户端和服务实现，如果基于HTTP那么务必使用HTTP的Method来操作资源，而且尽量使用HTTP响应码来处理错误&lt;/li&gt;
&lt;li&gt;需要尽量考虑缓存、版本控制、内容协商、部分响应等实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以说REST的API设计是需要设计感的，需要仔细来思考API的资源，资源之间的关系和导航，URI的定义等等。对于一套设计精良的REST API，其实客户端只要知道可用资源清单，往往就可以轻易根据约定俗成的规范以及导航探索出大部分API。比较讽刺的是，有很多网站给前端和客户端的接口是REST的，爬虫开发者可以轻易探索到所有接口，甚至一些内部接口，毕竟猜一下REST的接口比RPC的接口容易的多。&lt;/p&gt;
&lt;p&gt;作为补充，下面再列几个有关REST API设计大家争议讨论纠结的比较多的几个方面。&lt;/p&gt;
&lt;h3 id=&quot;创建资源使用put还是post&quot;&gt;创建资源使用PUT还是POST&lt;/h3&gt;
&lt;p&gt;比如 https://stackoverflow.com/questions/630453/put-vs-post-in-rest ，总的来说大家基本认同微软提到的三个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端决定资源名用PUT，服务端决定资源名用POST&lt;/li&gt;
&lt;li&gt;POST是把资源加入集合&lt;/li&gt;
&lt;li&gt;PUT实现需要幂等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，有些公司的规范是创建资源仅仅是POST，不支持PUT&lt;/p&gt;
&lt;h3 id=&quot;异常处理的http响应状态码&quot;&gt;异常处理的HTTP响应状态码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;REST的建议是应当考虑&lt;strong&gt;尽可能&lt;/strong&gt;使用匹配的Http状态码来对应到错误类型，比如删除用户的操作：
&lt;ul&gt;&lt;li&gt;用户找不到是404&lt;/li&gt;
&lt;li&gt;删除成功后是204&lt;/li&gt;
&lt;li&gt;用户因为有账户余额无法删除是409（客户端的问题是4xx）&lt;/li&gt;
&lt;li&gt;其它服务端异常是500（服务端的问题是5xx）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总体来说这个规范出发点是好的，实现起来落地比较困难，原因有下面几个：
&lt;ul&gt;&lt;li&gt;状态码对应各种错误类型的映射关系没有统一标准，工程师实现的时候五花八门&lt;/li&gt;
&lt;li&gt;实现起来可能需要在业务逻辑中耦合状态码，很难在GlobalExceptionHandler去做，除非事先先规范出十几种异常&lt;/li&gt;
&lt;li&gt;如果使用了不正确的响应状态可能会导致反向代理等触发错误的一些操作，而且出现问题的时候搞不清楚是哪个层面出错了&lt;/li&gt;
&lt;li&gt;各种Http Client对应非200状态码的处理方式不太一致&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有关这个问题的争议，各大平台的API实现有些遵从这个规范建议，有些是500甚至200打天下的，相关的国内外讨论有：
&lt;ul&gt;&lt;li&gt;https://stackoverflow.com/questions/27921537/returning-http-200-ok-with-error-within-response-body&lt;/li&gt;
&lt;li&gt;https://www.zhihu.com/question/268409269/&lt;/li&gt;
&lt;li&gt;https://www.zhihu.com/question/58686782&lt;/li&gt;
&lt;li&gt;https://blog.cloud-elements.com/error-handling-restful-api-design-part-iii&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;国内外的很多大厂对于这点的实现不尽相同，总的来说，我的建议是：
&lt;ul&gt;&lt;li&gt;如果我们明确API是REST的，而且API对外使用，应当使用合适的状态码来反映错误（建议控制在20个以内常用的），并且在文档中进行说明，而且出错后需要在响应体补充细化的error信息（包含code和message）&lt;/li&gt;
&lt;li&gt;如果REST API对内使用，那么在客户端和服务端商量好统一标准的情况下可以对响应码类型进行收敛到几个，实现起来也方便&lt;/li&gt;
&lt;li&gt;如果API是内部使用的RPC over HTTP形式，甚至可以退化到业务异常也使用200响应返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;返回数据是否需要包装&quot;&gt;返回数据是否需要包装&lt;/h3&gt;
&lt;p&gt;看到过许多文章都在说，REST还是建议返回的数据本身就是实体信息（或列表信息），而不建议把数据进行一层包装（Result）。如果需要有更多的信息来补充的话，可以放到HTTP Header中，比如https://developer.github.com/v3/projects/cards/的API：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /projects/columns/:column_id/cards

Status: 200 OK
Link: &amp;lt;https://api.github.com/resource?page=2&amp;gt;; rel=&quot;next&quot;,
      &amp;lt;https://api.github.com/resource?page=5&amp;gt;; rel=&quot;last&quot;
[
  {
    &quot;url&quot;: &quot;https://api.github.com/projects/columns/cards/1478&quot;,
    &quot;id&quot;: 1478,
    &quot;node_id&quot;: &quot;MDExOlByb2plY3RDYXJkMTQ3OA==&quot;,
    &quot;note&quot;: &quot;Add payload for delete Project column&quot;,
    &quot;created_at&quot;: &quot;2016-09-05T14:21:06Z&quot;,
    &quot;updated_at&quot;: &quot;2016-09-05T14:20:22Z&quot;,
    &quot;archived&quot;: false,
    &quot;column_url&quot;: &quot;https://api.github.com/projects/columns/367&quot;,
    &quot;content_url&quot;: &quot;https://api.github.com/repos/api-playground/projects-test/issues/3&quot;,
    &quot;project_url&quot;: &quot;https://api.github.com/projects/120&quot;
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前我们给出的HATEOAS的例子是在响应体中有&quot;content&quot;和&quot;links&quot;的层级，也就是响应体并不是资源本身，是有包装的，除了links，很多时候我们会直接以统一的格式来定义API响应结构体，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;code&quot; : &quot;&quot;,
    &quot;message&quot; : &quot;&quot;,
    &quot;path&quot; : &quot;&quot;
    &quot;time&quot; : &quot;&quot;,
    &quot;data&quot; : {},
    &quot;links&quot;: []
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我个人比较喜欢这种方式，不喜欢使用HTTP头，原因还是因为多变的部署和网络环境下，如果某些环节请求头被修改了或丢弃了会很麻烦（还有麻烦的Header Key大小写问题），响应体一般所有的代理都不会去动。&lt;/p&gt;
&lt;h3 id=&quot;uri的设计层级是否超过两层&quot;&gt;URI的设计层级是否超过两层&lt;/h3&gt;
&lt;p&gt;微软的API设计指南（文末有贴地址）中指出避免太复杂的层级资源，比如&lt;strong&gt;/customers/1/orders/99/products&lt;/strong&gt;过于复杂，可以退化为&lt;strong&gt;/customers/1/orders&lt;/strong&gt;和&lt;strong&gt;/orders/99/products&lt;/strong&gt;，不URI的复杂度不应该超过&lt;strong&gt;collection/item/collection&lt;/strong&gt;，Google的一些API会层级比较多，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;API service: spanner.googleapis.com
A collection of instances: projects/*/instances/*.
A collection of instance operations: projects/*/instances/*/operations/*.
A collection of databases: projects/*/instances/*/databases/*.
A collection of database operations: projects/*/instances/*/databases/*/operations/*.
A collection of database sessions: projects/*/instances/*/databases/*/sessions/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这点我比较赞同微软的规范，太深的层级在实现起来也不方便。&lt;/p&gt;
&lt;h2 id=&quot;graphql&quot;&gt;GraphQL&lt;/h2&gt;
&lt;p&gt;如果说RPC面向过程，REST面向资源，那么GraphQL就是面向数据查询了。“GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。”&lt;/p&gt;
&lt;p&gt;采用GraphQL，甚至不需要有任何的接口文档，在定义了Schema之后，服务端实现Schema，客户端可以查看Schema，然后构建出自己需要的查询请求来获得自己需要的数据。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168efefb85300b3c?w=625&amp;amp;h=210&amp;amp;f=png&amp;amp;s=22800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如定义如下的Schema：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#
# Schemas must have at least a query root type
#
schema {
    query: Query
}

type Query {
    characters(
        episode: Episode
    ) : [Character]

    human(
        # The id of the human you are interested in
        id : ID!
    ) : Human

    droid(
        # The non null id of the droid you are interested in
        id: ID!
    ): Droid
}

# One of the films in the Star Wars Trilogy
enum Episode {
    # Released in 1977
    NEWHOPE
    # Released in 1980.
    EMPIRE
    # Released in 1983.
    JEDI
}

# A character in the Star Wars Trilogy
interface Character {
    # The id of the character.
    id: ID!
    # The name of the character.
    name: String!
    # The friends of the character, or an empty list if they
    # have none.
    friends: [Character]
    # Which movies they appear in.
    appearsIn: [Episode]!
    # All secrets about their past.
    secretBackstory : String @deprecated(reason : &quot;We have decided that this is not canon&quot;)
}

# A humanoid creature in the Star Wars universe.
type Human implements Character {
    # The id of the human.
    id: ID!
    # The name of the human.
    name: String!
    # The friends of the human, or an empty list if they have none.
    friends: [Character]
    # Which movies they appear in.
    appearsIn: [Episode]!
    # The home planet of the human, or null if unknown.
    homePlanet: String
    # Where are they from and how they came to be who they are.
    secretBackstory : String @deprecated(reason : &quot;We have decided that this is not canon&quot;)
}

# A mechanical creature in the Star Wars universe.
type Droid implements Character {
    # The id of the droid.
    id: ID!
    # The name of the droid.
    name: String!
    # The friends of the droid, or an empty list if they have none.
    friends: [Character]
    # Which movies they appear in.
    appearsIn: [Episode]!
    # The primary function of the droid.
    primaryFunction: String
    # Construction date and the name of the designer.
    secretBackstory : String @deprecated(reason : &quot;We have decided that this is not canon&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采用GraphQL Playground（https://github.com/prisma/graphql-playground）来查看graphql端点可以看到所有支持的查询：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168eff0695efd3f3?w=1638&amp;amp;h=1027&amp;amp;f=png&amp;amp;s=189355&quot;/&gt;&lt;br/&gt;其实就是__schema：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168eff0a172e4db1?w=1638&amp;amp;h=1027&amp;amp;f=png&amp;amp;s=196276&quot;/&gt;&lt;br/&gt;然后我们可以根据客户端的UI需要自己来定义查询请求，服务端会根据客户端给的结构来返回数据：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168eff1127a58e69?w=1638&amp;amp;h=1027&amp;amp;f=png&amp;amp;s=156984&quot;/&gt;&lt;br/&gt;再来看看Github提供的GraphQL（更多参考https://developer.github.com/v4/guides/）：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168eff1b2089fd8c?w=1914&amp;amp;h=873&amp;amp;f=png&amp;amp;s=133415&quot;/&gt;&lt;br/&gt;查询出了最后的三个我的repo：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168eff20e57018fa?w=421&amp;amp;h=496&amp;amp;f=png&amp;amp;s=60505&quot;/&gt;&lt;br/&gt;GraphQL就是通过Schema来明确数据的能力，服务端提供统一的唯一的API入口，然后客户端来告诉服务端我要的具体数据结构（基本可以说不需要有API文档），有点客户端驱动服务端的意思。虽然客户端灵活了，但是GraphQL服务端的实现比较复杂和痛苦的，GraphQL不能替代其它几种设计风格，并不是传说中的REST 2.0。更多信息参见 https://github.com/chentsulin/awesome-graphql 。&lt;/p&gt;
&lt;h2 id=&quot;服务端驱动api&quot;&gt;服务端驱动API&lt;/h2&gt;
&lt;p&gt;没有高大上的英文缩写，因为这种模式或风格是我自己想出来的，那就是通过API让服务端来驱动客户端，在之前的一些项目中也有过实践。说白了，就是在API的返回结果中包含驱动客户端去怎么做的信息，两个层次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交互驱动：比如包含actionType和actionInfo，actionType可以是toast、alert、redirectView、redirectWebView等，actionInfo就是toast的信息、alert的信息、redirect的URL等。由服务端来明确客户端在请求API后的交互行为的好处是：
&lt;ul&gt;&lt;li&gt;灵活：在紧急的时候还可以通过redirect方式进行救急，比如遇到特殊情况需要紧急进行逻辑修改可以直接在不发版的情况下切换到H5实现，甚至我们可以提供后台让产品或运营来配置交互的方式和信息&lt;/li&gt;
&lt;li&gt;统一：有的时候会遇到不同的客户端，iOS、Android、前端对于交互的实现不统一的情况，如果API结果可以规定这部分内容可以彻底避免这个问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;行为驱动：更深一层的服务端驱动，可以实现一套API作为入口，让客户端进行调用，然后通过约定一套DSL告知客户端应该呈现什么，干什么。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之前有两个这样的项目采用了类似的API设计方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;贷款审核：我们知道贷款的信用审核逻辑往往会变动比较大，还涉及到客户端的一些授权（比如运营商爬虫），而且App的发布更新往往比较困难（苹果App Store以及安卓各大应用商店的审核问题）。如果采用服务端驱动的架构来告知客户端接下去应该呈现什么界面做什么，那么会有很大的灵活性。&lt;/li&gt;
&lt;li&gt;客户端爬虫：我们知道如果采用服务端做爬虫很多时候因为IP的问题会被封，所以需要找很多代理。某项目我们想出了客户端共享代理的概念，使用手机客户端来做分布式代理，由服务端驱动调度所有的客户端，那么这个时候客户端需要听从服务端的指示来做请求然后上报响应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般而言，对外的Web API是不会采用这种服务端驱动客户端的方式来设计API的。对于某些特殊类型的项目，我们可以考虑采用这种服务端驱动的方式来设计API，让客户端变为一个不含逻辑的执行者，执行的是UI和交互。&lt;/p&gt;
&lt;h2 id=&quot;选择哪个模式&quot;&gt;选择哪个模式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168efec1d4abf782?w=2116&amp;amp;h=2477&amp;amp;f=png&amp;amp;s=330097&quot;/&gt;&lt;br/&gt;https://user-gold-cdn.xitu.io/2019/2/15/168eff296f015115 此文给出了一个有关RPC、REST、GRAPHQL选择的决策方式可以参考，见上图。&lt;/p&gt;
&lt;p&gt;我觉得：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在下列情况考虑RPC风格的API或说是RPC：
&lt;ul&gt;&lt;li&gt;偏向内部的API&lt;/li&gt;
&lt;li&gt;没有太多的时间考虑API的设计或没有架构师&lt;/li&gt;
&lt;li&gt;提供的API很难进行资源、对象抽象&lt;/li&gt;
&lt;li&gt;对性能有高要求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在下列情况考虑REST风格：
&lt;ul&gt;&lt;li&gt;偏向外部API&lt;/li&gt;
&lt;li&gt;提供的API天生围绕资源、对象、管理展开&lt;/li&gt;
&lt;li&gt;不能耦合客户端实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在下列情况考虑GraphQL：
&lt;ul&gt;&lt;li&gt;客户端对于数据的需求多变&lt;/li&gt;
&lt;li&gt;数据具有图的特点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在下列情况考虑服务端驱动：
&lt;ul&gt;&lt;li&gt;客户端发版更新困难，需要极端的灵活性控制客户端&lt;/li&gt;
&lt;li&gt;仅限私有API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;更多需要考虑的设计点&quot;&gt;更多需要考虑的设计点&lt;/h2&gt;
&lt;p&gt;很多API设计指南都提到了下面这些设计考量点，也需要在设计的时候进行考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;版本控制，比如：
&lt;ul&gt;&lt;li&gt;通过URI Path进行版本控制，比如&lt;strong&gt;https://adventure-works.com/v2/customers/3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过QueryString进行版本控制，比如&lt;strong&gt;https://adventure-works.com/customers/3?version=2&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过Header进行版本控制，比如加一个请求头&lt;strong&gt;api-version=1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过Media Type进行版本控制，比如&lt;strong&gt;Accept: application/vnd.adventure-works.v1+json&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存策略，比如：
&lt;ul&gt;&lt;li&gt;响应使用Cache-Control告知客户端缓存时间（max-age）、策略（private、public）&lt;/li&gt;
&lt;li&gt;响应使用ETag来进行资源版本控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;部分响应：比如大的二进制文件需要考虑实现HEAD Method来表明资源允许分段下载，以及提供资源大小信息：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HEAD https://adventure-works.com/products/10?fields=productImage HTTP/1.1

HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后提供资源分段下载功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET https://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=0-2499

HTTP/1.1 206 Partial Content
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
[...]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;列表设计：需要在设计列表类型API的时候考虑分页、投影、排序、查询几点，值得注意的是列表API的额外功能比较多，尽量进行命名的统一化规范&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;微软API设计指南：https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design （英文版： https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-implementation ）&lt;/li&gt;
&lt;li&gt;Google Cloud API设计指南： https://google-cloud.gitbook.io/api-design-guide/ （英文版：https://cloud.google.com/apis/design/ ）&lt;/li&gt;
&lt;li&gt;Github API概览：https://developer.github.com/v3/&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 15 Feb 2019 07:05:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>Web API设计其实是一个挺重要的设计话题，许多公司都会有公司层面的Web API设计规范，几乎所有的项目在详细设计阶段都会进行API设计，项目开发后都会有一份API文档供测试和联调。本文尝试根据自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/10383756.html</dc:identifier>
</item>
<item>
<title>浅谈JavaWeb架构演变 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10376010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10376010.html</guid>
<description>&lt;p&gt;&lt;span&gt;一  JavaWeb架构演变&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;     在java架构模式中，我们可以将MVC架构模式抽象为如下结构：&lt;/p&gt;
&lt;p&gt;     1.View层。View层即UI层，可采用的技术如JSP,Structs,SpringMVC等&lt;/p&gt;
&lt;p&gt;     2.Controller层。Controller表示控制器层，可采用的技术，如Servlet/Filter,Spring等&lt;/p&gt;
&lt;p&gt;     3.Service层。Service层表示核心服务层，向架构上层提供服务&lt;/p&gt;
&lt;p&gt;     4.DAO层。DAO层表示数据访问层，可采用的技术如jdbc和ORM框架(如Spring JDBC,JPA,Hibernate,Mybatis等)&lt;/p&gt;
&lt;p&gt;     5.Model层。Model层即表示JavaBean对象&lt;/p&gt;
&lt;p&gt;     6.Utilities层。Utilities层表示公共工具层&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;需要注意的是，在该架构抽象模型中，并未涉及到其他技术，如SOA,Nosql(Redis，Mongodb等),MQ等，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外，基于Springboot+Cloud的微服务技术，也未涉及，因为这里只将基于MVC的架构模式演变，具体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的JavaWeb架构，将在以后的章节讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190215134419800-1367307662.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         基于如上的架构抽象模型，我们可以将该架构模式发展分为三个阶段：&lt;/p&gt;
&lt;p&gt;         阶段一：Servlet阶段&lt;/p&gt;
&lt;p&gt;         阶段二：SSH(Spring+Structs+Hibernate)阶段&lt;/p&gt;
&lt;p&gt;         阶段三：SSM阶段(Spring+SpringMVC+Mybatis)阶段&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;其实，还存在阶段四，即微服务阶段，本篇文章不讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     （一）阶段一：Servlet/Filter扮演控制器角色&lt;/p&gt;
&lt;p&gt;        1.在该阶段架构模式中，Servlet/Filter扮演Controller角色，JSP扮演View角色，JavaBean扮演Model角色&lt;/p&gt;
&lt;p&gt;        2.该阶段的数据库访问技术为具体DB的jdbc &lt;/p&gt;
&lt;p&gt;        该模式虽然实现了所谓的MVC模式，但却存在诸多问题：&lt;/p&gt;
&lt;p&gt;      （1）前后端分离不彻底。由于JSP技术前后端分离不彻底，开发人员往往会在JSP页面中嵌套Java代码，从而需要前端开发人员懂java技术&lt;/p&gt;
&lt;p&gt;      （2）JSP页面可读性差，编写效率低，尽管引入EL，JSTL等技术&lt;/p&gt;
&lt;p&gt;      （3）Sevlet/Filter作为控制器，面临的稳定性，安全性考验(Servlet是线程不安全的)等&lt;/p&gt;
&lt;p&gt;      （4）数据库访问技术采用传统的jdbc，造成过多的冗余代码&lt;/p&gt;
&lt;p&gt;         当然，还存在很多问题，这里不一一列举，为了解决这些问题，JavaWeb专家们提出了一种架构思想：&lt;span&gt;模块化，抽象化和专一化的思想。&lt;/span&gt;基于该思想&lt;/p&gt;
&lt;p&gt;，涌向出一批专业化开源框架，其中较为出名的组合框架便是SSH了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190215140316561-1997221910.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  （二）阶段二：SSH&lt;/p&gt;
&lt;p&gt;    1.在该架构模式中，Controller采用Spring框架技术，View采用Structs框架技术，DB访问技术采用Hibernate框架技术&lt;/p&gt;
&lt;p&gt;    2.从SSH中，很容易看出前后端出现了专业化，精细化分工，且朝框架演变，如前端框架采用Structs，后端框架采用Spring等&lt;/p&gt;
&lt;p&gt;        然而，SSH架构模式虽然解决了Servlet/Filter架构模式存在的问题，实现了专业化、精细化分工，实现了模块化和抽象化，&lt;/p&gt;
&lt;p&gt;但其却存在一个比较大的问题：&lt;span&gt;框架笨重不灵活。&lt;span&gt;如Hibernate虽然能满足业务需求，能解决业务，但其笨重不灵活，不能很好地&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实现可配置化的灵活方式，Structs也过于笨重。为了解决该问题，JavaWeb专家们又提出了另外一种架构模式，即SSM架构模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190215141916212-1462931065.png&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（三）阶段三：SSM&lt;/p&gt;
&lt;p&gt;      1.该模式中，Spring扮演Controller角色，SpringMVC扮演View角色(当然，小型系统，可直接采用SpringMVC即可)，Mybatis扮演DB访问技术&lt;/p&gt;
&lt;p&gt;      SSM架构模式，在当前的JavaEE中，算是比较流行的开发模式了，也是大都数企业的技术选型之一。当然，能与SSM相媲美的另一种设计&lt;/p&gt;
&lt;p&gt;思想，那就是微服务思想(SpringBoot+cloud技术等)，本篇文章不谈及微服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190215141951562-908414810.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 SSM核心框架概述&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;  （一）Spring框架&lt;/p&gt;
&lt;p&gt;   Spring框架目前是JavaWeb开发的主流框架，也可以说是诸多企业的必选框架，它大致包括六大模块。&lt;/p&gt;
&lt;p&gt;    1.Spring核心容器。该容器是Spring框架最核心部分，它管理着Spring运用中bean的创建、配置和管理等&lt;/p&gt;
&lt;p&gt;    2.Spring AOP。该模块为面向切面和DI(依赖注入)提供了很好的支持&lt;/p&gt;
&lt;p&gt;    3.数据库访问与集成模块&lt;/p&gt;
&lt;p&gt;    4.Web与远程调用技术&lt;/p&gt;
&lt;p&gt;    5.Instrument模块&lt;/p&gt;
&lt;p&gt;    6.Test模块&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190215094157773-1097007692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（二） Mybatis框架&lt;/p&gt;
&lt;p&gt;    1.根据Mybatis源码，将其抽象为三层：基础支持层，核心处理层和接口层&lt;/p&gt;
&lt;p&gt;    2.基础支持层包括：数据源、事务管理、日志、类型转换、缓存、Bind、解析器等&lt;/p&gt;
&lt;p&gt;    3.核心处理层包括：配置解析、配置映射、SQL解析、SQL执行、结果集映射、插件等&lt;/p&gt;
&lt;p&gt;    4.接口层主要提供JAVA API&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190214174543899-210640770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三 版权区&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;     感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/p&gt;
&lt;p&gt;     博主网址：http://www.cnblogs.com/wangjiming/。&lt;/p&gt;
&lt;p&gt;     极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/p&gt;
&lt;p&gt;     如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/p&gt;
&lt;p&gt;     可以转载该博客，但必须著名博客来源。&lt;/p&gt;

</description>
<pubDate>Fri, 15 Feb 2019 06:55:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>一 JavaWeb架构演变 在java架构模式中，我们可以将MVC架构模式抽象为如下结构： 1.View层。View层即UI层，可采用的技术如JSP,Structs,SpringMVC等 2.Cont</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10376010.html</dc:identifier>
</item>
<item>
<title>算法xio讲堂#1--01分数规划 - chhokmah</title>
<link>http://www.cnblogs.com/chhokmah/p/10356777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chhokmah/p/10356777.html</guid>
<description>&lt;p&gt;所谓01分数规划，看到这个名字，可能会想到01背包，其实长得差不多。&lt;br/&gt;这个算法就是要求“性价比”最高的解。sum(v)/sum(w)最高的解。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们给定两个数组，a[i]表示选取i的收益，b[i]表示选取i的代价。如果选取i，定义x[i]=1否则x[i]=0。每个物品只有选和不选的两种方案，求一个选择的方案使得R=sigma(a[i]&lt;em&gt;x[i])/sigma(b[i]&lt;/em&gt;x[i])，也就是选择物品的总收益/总代价最大或者最小。&lt;/p&gt;
&lt;p&gt;01分数规划问题主要包含以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般的01分数规划&lt;/li&gt;
&lt;li&gt;最优比率生成树&lt;/li&gt;
&lt;li&gt;最优比率环&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;F(L)=sigma(a[i]&lt;em&gt;x[i])-L&lt;/em&gt;sigma(b[i]&lt;em&gt;x[i])&lt;br/&gt;F(L)=sigma(a[i]&lt;/em&gt;x[i]-L&lt;em&gt;b[i]&lt;/em&gt;a[i])&lt;br/&gt;F(L)=sigma((a[i]-L&lt;em&gt;b[i])&lt;/em&gt;x[i])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们把a[i]-L*b[i]定义为d[i]，这样我们的算式就变成了以下算式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;F(L)=sigma(d[i]*x[i])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就把这个繁琐的算式变成了一个非常优美的算式。&lt;br/&gt;而01分数规划就是要枚举L在求最大值或最小值的F(L)。&lt;br/&gt;在实现程序的过程中，我们使用一个非常熟悉的老朋友，要求最大或最小，所以？？我们就要用&lt;strong&gt;二分&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;（个人看法）&lt;br/&gt;如果硬要贪心，那么就只有可能是算出每一个物品的性价比，在排序求出最大或者最小的性价比，在累加算出答案。&lt;/p&gt;
&lt;h2 id=&quot;一01分数规划算法&quot;&gt;一、01分数规划算法&lt;/h2&gt;
&lt;p&gt;先设置价值数组a[i]和代价数组b[i]，我们的答案为R。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R= \frac{\sum_{i=1}^{n}{a[i]*x[i]}}{\sum_{i=1}^{n}{b[i]*x[i]}}\]&lt;/span&gt;&lt;br/&gt;简单来说 &lt;span class=&quot;math display&quot;&gt;\[ R=\frac{\sum{valuei}}{\sum{weighti}} \]&lt;/span&gt;&lt;br/&gt;我们可以发现，R的大小与上下的总值有关。&lt;/p&gt;
&lt;h2 id=&quot;二贪心算法&quot;&gt;二、贪心算法&lt;/h2&gt;
&lt;p&gt;我们反观一下贪心算法，先算出每个物品的性价比&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ xi=\frac {valuei}{weighti}\]&lt;/span&gt;&lt;br/&gt;那么贪心得到的答案就是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R=\sum{xi}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;比较&quot;&gt;比较&lt;/h2&gt;
&lt;p&gt;我们可以很容易发现，01分数规划和贪心的得到的答案有明显的区别，一个是总价值/总代价，而贪心中只是单价值/单代价的累加，而不只是比值的大小，而取决于分母和分子的大小，所以这两个东西不相等&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;
&lt;p&gt;In a certain course, you take n tests. If you get ai out of bi questions correct on test i, your cumulative average is defined to be&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ 100*\frac{\sum_{i=1}^{n}{ai}}{\sum_{i=1}^{n}{ai}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Given your test scores and a positive integer k, determine how high you can make your cumulative average if you are allowed to drop any k of your test scores.&lt;/p&gt;
&lt;p&gt;Suppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is . However, if you drop the third test, your cumulative average becomes .&lt;br/&gt;Input&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ n ≤ 1000 and 0 ≤ k &amp;lt; n. The second line contains n integers indicating ai for all i. The third line contains n positive integers indicating bi for all i. It is guaranteed that 0 ≤ ai ≤ bi ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with n = k = 0 and should not be processed.&lt;br/&gt;Output&lt;/li&gt;
&lt;li&gt;For each test case, write a single line with the highest cumulative average possible after dropping k of the given test scores. The average should be rounded to the nearest integer.&lt;br/&gt;Sample Input&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3 1&lt;br/&gt;5 0 2&lt;br/&gt;5 1 6&lt;br/&gt;4 2&lt;br/&gt;1 2 7 9&lt;br/&gt;5 6 7 9&lt;br/&gt;0 0&lt;br/&gt;Sample Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;83&lt;br/&gt;100&lt;br/&gt;Analysis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;01分数规划的入门题，我们就认真讲解一下。&lt;br/&gt;首先我们要理解题目的意思，大意是：给你一个价值a[i]和代价b[i]，然后我们选举n-k个物品，使得总价值/总代价。&lt;br/&gt;理解了题目后，我们就是要用到了今天学习的01分数规划。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ R=\frac{\sum{ai*xi}}{\sum{bi*xi}}\]&lt;/span&gt;&lt;br/&gt;我们把这个算式进行一个变形：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[F(l)=\sum{ai*xi}-l*\sum{bi*xi}\]&lt;/span&gt;&lt;br/&gt;上文已经分析过如何进行移项便是以下的算式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[F(l)=\sum{(ai-l*bi)*xi}\]&lt;/span&gt;&lt;br/&gt;根据这个算式，因为a[i]和b[i]是已知的，所以我们就把$ ai-l&lt;em&gt;bi&lt;span class=&quot;math inline&quot;&gt;\(这个算式定义成\)&lt;/span&gt; di $&lt;br/&gt;所以原来的又长又臭的算式就可以成为$F(l)=\sum di&lt;/em&gt;xi $&lt;br/&gt;这样我们的算式中只有&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;是未知的，我们只需要用二分来枚举&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;在算出&lt;span class=&quot;math inline&quot;&gt;\(F(l)\)&lt;/span&gt;就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;cctype&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

#define ms(a,b) memset(a,b,sizeof(a))

typedef long long ll;

const double eps=1e-7;

int n,k;
double a[1010],b[1010],d[1010];

inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X&amp;lt;&amp;lt;3)+(X&amp;lt;&amp;lt;1)+(ch^48),ch=getchar();
    return w?-X:X;
}

int main()
{
    while (1)
    {
        n=read(),k=read();
        if (n==0 &amp;amp;&amp;amp; k==0) break;
        for (int i=1;i&amp;lt;=n;i++) scanf(&quot;%lf&quot;,&amp;amp;a[i]);
        for (int i=1;i&amp;lt;=n;i++) scanf(&quot;%lf&quot;,&amp;amp;b[i]);
        double l=0.0,r=1.0,mid;
        while (r-l&amp;gt;eps)
        {
            mid=(l+r)/2;
            for (int i=1;i&amp;lt;=n;i++) d[i]=a[i]-mid*b[i];
            sort(d+1,d+1+n);
            double sum=0.0;
            for (int i=k+1;i&amp;lt;=n;i++) sum+=d[i];
            if (sum&amp;gt;0) l=mid;
            else r=mid;
        }
        printf(&quot;%.0f\n&quot;,mid*100);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二51nod背包问题-v3&quot;&gt;二、&lt;a href=&quot;https://vjudge.net/problem/51Nod-1257&quot;&gt;51nod&lt;/a&gt;背包问题 V3&lt;/h2&gt;
&lt;h2 id=&quot;description-1&quot;&gt;Description&lt;/h2&gt;
&lt;p&gt;N个物品的体积为W1，W2......Wn（Wi为整数），与之相对应的价值为P1,P2......Pn（Pi为整数），从中选出K件物品（K &amp;lt;= N)，使得单位体积的价值最大。&lt;br/&gt;Input&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第1行：包括2个数N, K(1 &amp;lt;= K &amp;lt;= N &amp;lt;= 50000)&lt;br/&gt;第2 - N + 1行：每行2个数Wi, Pi（1 &amp;lt;= Wi, Pi &amp;lt;= 50000)&lt;br/&gt;Output&lt;/li&gt;
&lt;li&gt;输出单位体积的价值（用约分后的分数表示）。&lt;br/&gt;Sample Input&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3 2&lt;br/&gt;2 2&lt;br/&gt;5 3&lt;br/&gt;2 1&lt;br/&gt;Sample Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;3/4&lt;br/&gt;Analysis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;入门题，我们算出答案后，一个gcd就好了。&lt;br/&gt;Code&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;cctype&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

#define ms(a,b) memset(a,b,sizeof(a))

typedef long long ll;

const int maxn = 50005;

const double eps = 1e-9;

ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}

struct node
{
    int w,p;
    double val;
    bool operator &amp;lt; (const node&amp;amp; T) const{
        return val&amp;gt;T.val;
    }
}b[maxn];

double mid;
ll anss,ansx,tmps,tmpx;
int n,k;

bool check()
{
    int tot=0;
    for(int i=0;i&amp;lt;n;i++)b[i].val = 1.0*b[i].p-b[i].w*mid;
    sort(b,b+n);
    double sum=0;
    tmps=0,tmpx=0;
    for(int i=0;i&amp;lt;k;i++)sum+=b[i].val,tmps+=b[i].p,tmpx+=b[i].w; 
    if(sum-0&amp;gt;=eps)return true;
    return false;
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;k);
    for(int i=0;i&amp;lt;n;i++) scanf(&quot;%d%d&quot;,&amp;amp;b[i].w,&amp;amp;b[i].p);
    double l=0,r=500000;
    for(int i=0;i&amp;lt;100;i++)
    {
        mid=(l+r)/2;
        if(check())l=mid,anss=tmps,ansx=tmpx;
        else r=mid;
    }
    ll tmp=gcd(anss,ansx);
    anss/=tmp,ansx/=tmp;
    printf(&quot;%lld/%lld\n&quot;,anss,ansx);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;description-2&quot;&gt;Description&lt;/h2&gt;
&lt;p&gt;David the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.&lt;/p&gt;
&lt;p&gt;After days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.&lt;/p&gt;
&lt;p&gt;His engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can't share a lifter. Channels can intersect safely and no three villages are on the same line.&lt;/p&gt;
&lt;p&gt;As King David's prime scientist and programmer, you are asked to find out the best solution to build the channels.&lt;br/&gt;Input&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;There are several test cases. Each test case starts with a line containing a number N (2 &amp;lt;= N &amp;lt;= 1000), which is the number of villages. Each of the following N lines contains three integers, x, y and z (0 &amp;lt;= x, y &amp;lt; 10000, 0 &amp;lt;= z &amp;lt; 10000000). (x, y) is the position of the village and z is the altitude. The first village is the capital. A test case with N = 0 ends the input, and should not be processed.&lt;br/&gt;Output&lt;/li&gt;
&lt;li&gt;For each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point.&lt;br/&gt;Sample Input&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4&lt;br/&gt;0 0 0&lt;br/&gt;0 1 1&lt;br/&gt;1 1 2&lt;br/&gt;1 0 3&lt;br/&gt;0&lt;br/&gt;Sample Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;1.000&lt;br/&gt;Analysis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;大意：给定一张图，每条边有一个收益值和一个花费值， 求一个生成树，要求花费/收益最小，输出这个值&lt;br/&gt;分析：现在的限制就有点复杂了，要求解必须是一棵生成 树。而且这道题目要求的花费/收益最小，当然你求收益/ 花费最大然后反过来也是可以的，注意处理花费为0的情 况。如果求最小的，处理方法是也类似的，先求个D，然 后做一次最小生成树，显然得到的就是函数值。&lt;br/&gt;Code&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018080220203870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BoYW50b21fc3RhcnM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;四poj-3621sightseeing-cows&quot;&gt;四、&lt;a href=&quot;https://vjudge.net/problem/POJ-3621&quot;&gt;POJ-3621&lt;/a&gt;Sightseeing Cows&lt;/h2&gt;
&lt;h2 id=&quot;description-3&quot;&gt;Description&lt;/h2&gt;
&lt;p&gt;Farmer John has decided to reward his cows for their hard work by taking them on a tour of the big city! The cows must decide how best to spend their free time.&lt;/p&gt;
&lt;p&gt;Fortunately, they have a detailed city map showing the L (2 ≤ L ≤ 1000) major landmarks (conveniently numbered 1.. L) and the P (2 ≤ P ≤ 5000) unidirectional cow paths that join them. Farmer John will drive the cows to a starting landmark of their choice, from which they will walk along the cow paths to a series of other landmarks, ending back at their starting landmark where Farmer John will pick them up and take them back to the farm. Because space in the city is at a premium, the cow paths are very narrow and so travel along each cow path is only allowed in one fixed direction.&lt;/p&gt;
&lt;p&gt;While the cows may spend as much time as they like in the city, they do tend to get bored easily. Visiting each new landmark is fun, but walking between them takes time. The cows know the exact fun values Fi (1 ≤ Fi ≤ 1000) for each landmark i.&lt;/p&gt;
&lt;p&gt;The cows also know about the cowpaths. Cowpath i connects landmark L1i to L2i (in the direction L1i -&amp;gt; L2i ) and requires time Ti (1 ≤ Ti ≤ 1000) to traverse.&lt;/p&gt;
&lt;p&gt;In order to have the best possible day off, the cows want to maximize the average fun value per unit time of their trip. Of course, the landmarks are only fun the first time they are visited; the cows may pass through the landmark more than once, but they do not perceive its fun value again. Furthermore, Farmer John is making the cows visit at least two landmarks, so that they get some exercise during their day off.&lt;/p&gt;
&lt;p&gt;Help the cows find the maximum fun value per unit time that they can achieve.&lt;br/&gt;Input&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Line 1: Two space-separated integers: L and P&lt;/li&gt;
&lt;li&gt;Lines 2..L+1: Line i+1 contains a single one integer: Fi&lt;/li&gt;
&lt;li&gt;Lines L+2..L+P+1: Line L+i+1 describes cow path i with three space-separated integers: L1i , L2i , and Ti&lt;br/&gt;Output&lt;/li&gt;
&lt;li&gt;Line 1: A single number given to two decimal places (do not perform explicit rounding), the maximum possible average fun per unit time, or 0 if the cows cannot plan any trip at all in accordance with the above rules.&lt;br/&gt;Sample Input&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;5 7&lt;br/&gt;30&lt;br/&gt;10&lt;br/&gt;10&lt;br/&gt;5&lt;br/&gt;10&lt;br/&gt;1 2 3&lt;br/&gt;2 3 2&lt;br/&gt;3 4 5&lt;br/&gt;3 5 2&lt;br/&gt;4 5 5&lt;br/&gt;5 1 3&lt;br/&gt;5 2 2&lt;br/&gt;Sample Output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;6.00&lt;br/&gt;Analysis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;大意：给定一张图，边上有花费，点上有收益，点可以多 次经过，但是收益不叠加，边也可以多次经过，但是费用 叠加。求一个环使得收益和/花费和最大，输出这个比值。&lt;br/&gt;分析：比上面更加的恶心了。先不说环的问题，就是花费 和收益不在一处也令人蛋疼。这时候需要用到几个转化和 结论。&lt;br/&gt;首先的一个结论就是，不会存在环套环的问题，即最优的方 案一定是一个单独的环，而不是大环套着小环的形式。这个的 证明其实非常的简单，大家可以自己想一下（提示，将大环上 的收益和记为x1,花费为y1，小环上的为x2,y2。重叠部分的花 费为S。表示出来分类讨论即可）。有了这个结论，我们就可以 将花费和收益都转移到边上来了，因为答案最终一定是一个环， 所以我们将每一条边的收益规定为其终点的收益，这样一个环 上所有的花费和收益都能够被正确的统计。&lt;br/&gt;解决了蛋疼的问题之后，就是01分数规划的部分了，我们只 需要计算出D数组后找找有没有正权环即可，不过这样不太好， 不是我们熟悉的问题，将D数组全部取反之后，问题转换为查找 有没有负权环，用spfa或是bellman_ford都可以。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;code-1&quot;&gt;Code&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
#define N 100010
using namespace std;
const double eps=1e-5;
struct edge
{
    int v,nxt,w;
    double c;
} e[N&amp;lt;&amp;lt;1];
int head[N],f[N];
bool vis[N];
double dis[N];
int n,m,mct,u,v,w;
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c&amp;gt;'9'||c&amp;lt;'0'){if(c=='-')f=-1;c=getchar();}
    while(c&amp;gt;='0'&amp;amp;&amp;amp;c&amp;lt;='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
void add(int u,int v,int w)
{
    e[++mct].v=v;e[mct].nxt=head[u];e[mct].w=w;head[u]=mct;
}
bool spfa(int u)
{
    vis[u]=1;
    for(int i=head[u]; i; i=e[i].nxt)
    {
        int v=e[i].v;
        if(dis[v]&amp;gt;dis[u]+e[i].c)
        {
            dis[v]=dis[u]+e[i].c;
            if(vis[v] || spfa(v))
            {
                vis[v]=0;
                return 1;
            }
        }
    }vis[u]=0;return 0;
}
void judge(double r)
{
    for(int i=1; i&amp;lt;=mct; i++)
        e[i].c=(double)e[i].w*r-f[e[i].v];
    return;
}
bool check()
{
    for(int i=1; i&amp;lt;=n; i++)
        if(spfa(i))return 1;
    return 0;
}
int main()
{
    n=read();m=read();
    for(int i=1; i&amp;lt;=n; i++) f[i]=read();
    for(int i=1; i&amp;lt;=m; i++)
    {
        u=read();v=read();w=read();
        add(u,v,w);
    }
    double l=0,r=100000,ans;
    while(r-l&amp;gt;eps)
    {
        double mid=(l+r)/2;
        judge(mid);
        if(check())
        {
            ans=mid;l=mid;
        }
        else r=mid;
    }
    printf(&quot;%.2f\n&quot;,ans);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 15 Feb 2019 06:53:00 +0000</pubDate>
<dc:creator>chhokmah</dc:creator>
<og:description>浅谈01分数规划 ======== 所谓01分数规划，看到这个名字，可能会想到01背包，其实长得差不多。 这个算法就是要求“性价比”最高的解。sum(v)/sum(w)最高的解。 定义 == 我们给定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chhokmah/p/10356777.html</dc:identifier>
</item>
<item>
<title>面向对象的脚本语言的类的实现 - jin_hao_chen</title>
<link>http://www.cnblogs.com/megachen/p/10383643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/megachen/p/10383643.html</guid>
<description>&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 以Obj开头的一般为对象, 但是这里ObjHeader仅仅是一个对象头, 不是一个对象, 发现一个规律
// 在结构体中, 如果有定义一个什么type类型的, 则在该脚本语言中就不会定义成对象
typedef struct ObjHeader {
    ObjType type; // 对象类型
    bool isDark; // 是否可以到达, 如果可以到达, 则GC回收对象
    Class *class; // 指向类对象, 在类对象中保存着方法, 这样该对象就可以调用方法了:
    struct ObjHeader *next; // 用于链表
} ObjHeader;

// 对象类型
typedef enum ObjType {
    ObjTypeList,
    ObjTypeMap,
    ObjTypeModule,
    ObjTypeString,
    ObjTypeRange,
    ObjTypeFunction,
    ObjTypeThread,
    ObjTypeClass,
    ObjTypeInstance
} ObjType;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;value结构体value不是对象-他在脚本语言层面是一个引用-因为没有类型-但是在c语言中需要value保存属性&quot;&gt;Value结构体(Value不是对象, 他在脚本语言层面是一个引用, 因为没有类型, 但是在C语言中需要Value保存属性)&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
// 它类似于Python中的引用, 在栈中定义, 所以脚本语言模拟的栈就是Value数组, 对象在堆中创建
typedef struct Value {
    ValueType type;
    union {
        double num;
        ObjHeader *obj_header;
    };
} Value;

// 定义的类型是直接在引用右侧写出来的
// num, true, false这些都能在右侧直接写出来, 而不需要使用其他方法调用
typedef enum {
    ValueTypeUndefined,
    ValueTypeNull,
    ValueTypeObj,
    ValueTypeNum,
    ValueTypeTrue,
    ValueTypeFalse
} ValueType;

// 通过宏将ValueType与Value结构体直接的转换更快捷&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;class类对象结构体&quot;&gt;Class类对象结构体&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
好好想一下, 一个类中都有什么, 这与我们在Java和C++编程的类不同, 我们只找所有的类的共同点
1. 对象头
2. 字段个数
3. 方法对象区, 用于存方法
*/
typedef struct Class {
    ObjHeader obj_header;
    struct Class *superclass;
    int field_num;
    MethodBuffer methods;
    ObjString name;
} Class;


typedef struct Method {
    MethodType type;
    union {
        // C语言实现的方法
        Primitive prim_fn;
        // 脚本语言将代码编译成ObjClosure对象
        ObjClosure *obj;
    };
} Method;


typedef num MethodType {
    MethodTypeNull,
    MethodPrimitive,
    MethodScript,
    MethodCall // 用于重载
} MethodType;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在构建出上述一个类关系之后-首先应该定义字符串类objstring&quot;&gt;在构建出上述一个类关系之后, 首先应该定义字符串类(ObjString)&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 这里仅仅是定义了字符串对象, obj_header指向是ObjString类对象
typedef struct ObjString {
    ObjHeader obj_header;
    long hash_code; // 保存hash值
    int len;
    char *start[0];
} ObjString;

// 计算字符串的hashcode
int hash_string(const char *str, int length) {
    int hashcode = xxxxxxxx;
    int idx = 0;

    while (idx &amp;lt; length) {
        hashcode ^= str[idx++];
        hashcode *= yyyyyyyy;
    }
    return hashcode;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;元对象&quot;&gt;元对象&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
typedef struct {
    ObjHeader obj_header;
    StringBuffer module_var_name;
    ValueBuffer module_var_value;
    ObjString *name;
} ObjModule; // 模块不属于任何类, 所有它的obj_header中的class指着指向NULL


typedef struct {
    ObjHeader obj_header;
    Value field[0]; // 存储属性, 为引用, 这里是在内存中的样子
} ObjInstance;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在脚本中执行过程中最重要的就是代码存放逻辑的地方-函数-方法-模块中都是&quot;&gt;在脚本中执行过程中最重要的就是代码(存放逻辑的地方, 函数, 方法, 模块中都是)&lt;/h2&gt;
&lt;h2 id=&quot;注意-接下来的对象结构会比较复杂-请大致浏览一遍-在后面会总结他们的关系&quot;&gt;注意: 接下来的对象结构会比较复杂, 请大致浏览一遍, 在后面会总结他们的关系&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;统一使用ObjFunc表示还这些代码指令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
typedef struct ObjFunc {
    ObjHeader obj_header;
    ByteBuffer instr_stream; // 保存编译后的代码指令, 这是ObjFunc对象的核心功能
    ValueBuffer constants; // 常量, 在模块中会有
    Module *mod; // 属于哪个模块
    
    int max_stack_size; // 可用的最大栈个数
    int upvalue_num; // 用到外层函数变量的个数, 其中upvalue是一个闭包对象, 对在外层函数中栈中的被内层嵌套函数引用到的引用(Value)的封装[为什么? 因为对象在堆中, Value这种应用类型才在栈中:-)], 可以将upvalue看成一个容器, 里面维护着Value类型的值
    // 发现在ObjFunc中没有与其对应的upvalue产生联系, 在后面提到的ObjClosure对象中会进行关联
    int arg_num;
} ObjFunc;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;与ObjFunc对象相关的与闭包有关的对象结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
typedef struct ObjUpValue {
    ObjHeader obj_header;
    Value *ptr; // 指向在外层函数中栈中的局部变量
    Value closed_value; // 如果外层函数生命周期结束, 则会回收栈, 为了实现闭包, 将ptr指向的值拷贝到closed_value中即可
} ObjUpValue;

typedef struct ObjClosure {
    ObjHeader *obj_header;
    ObjFunc *func;
    // 在这里对func与他的upvalue进行了关联
    ObjUpvalue *upvalues[0];
} ObjClosure;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数要运行就需要一个环境-这个环境就是一个栈帧frame&quot;&gt;函数要运行就需要一个环境, 这个环境就是一个栈帧(Frame)&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// Frame就是一个函数调用框架, 就是一个栈, 但是又是有一点抽象的, 它通过start_stack来访问Value数组
typedef struct Frame {
    int *ip; // 模拟CPU的CS:IP
    Value *stack_start;
    /* 在上面我们提到了很多的结构体对象, 有ObjFunc, ObjUpvalue, ObjClosure, 那么到底那个才是接口, 这里Closure最大, 所以Closure是接口, 在Method结构体对象中可以看到, 在union中primitive与closure是并列的*/
    ObjClosure *closure; 
}Frame;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关系总结&quot;&gt;关系总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418650/201902/1418650-20190215144935432-769237184.png&quot; alt=&quot;闭包关系图&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Frame获取到ObjClosure, 得到ObjFunc中的intr_stream执行指令&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;提到了这么多的结构体-那么创建他们的顺序是怎样的呢&quot;&gt;提到了这么多的结构体, 那么创建他们的顺序是怎样的呢&lt;/h3&gt;
&lt;ul readability=&quot;26&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;创建vm目录&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;

typedef struct vm {
    Parser *cur_parser; // 当前vm使用的parser
    uint32_t allocated_bytes; // 记录已经分配的内存空间
    ObjHeader *all_objects; // 是所有ObjHeader连接成的链表的头
    StringTable all_method_names; // 存放方法的所有名称, 因为从用户中读取到一个对象要调用一个方法, 这个是字符串的层面, 我们需要构建出一张符号表, 通过查找该字符在表中的index, 对应的映射到methods中index调用方法
    ObjMap *allModules; // 通过map管理名称与模块
    ObjThread *cur_thread; // vm支持多线程, cur_thread表示当前的线程(用户态下就是协程)
    // 所有内置类的类对象指针都放在这里
    Class *class_class; // 指向类的类, 是所有元类的基类和元类, 这个需要记住, class_class的元类就是他自己
    Class *object_class; // 除了元类, 是所有类的基类, object_class也是class_class的基类, object_class没有基类
    Class *string_class;
    Class *list_class;
    Class *range_class;
    Class *thread_class;
    Class *map_class;
    /* 下面三个类他们的实现与其他不同, 他们会比较简单, 也没有必要通过复杂的对象来创建 */
    Class *num_class;
    Class *null_class;
    Class *bool_class;
} VM;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;创建object目录&lt;/li&gt;
&lt;li&gt;在obj_header.h中创建ObjType枚举, ObjHeader结构体, ValueType枚举, Value结构体&lt;/li&gt;
&lt;li readability=&quot;33&quot;&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;      // 对象类型
      typedef enum ObjType {
          ObjTypeList,
          ObjTypeMap,
          ObjTypeModule,
          ObjTypeString,
          ObjTypeRange,
          ObjTypeFunction,
          ObjTypeThread,
          ObjTypeClass,
          ObjTypeInstance
      } ObjType;

      typedef struct ObjHeader {
          ObjType type; // 对象类型
          bool isDark; // 是否可以到达, 如果可以到达, 则GC回收对象
          Class *class; // 指向类对象, 在类对象中保存着方法, 这样该对象就可以调用方法了:
          struct ObjHeader *next; // 用于链表
      } ObjHeader;     
  // 定义的类型是直接在引用右侧写出来的
  // num, true, false这些都能在右侧直接写出来, 而不需要使用其他方法调用
  typedef enum {
      ValueTypeUndefined,
      ValueTypeNull,
      ValueTypeObj,
      ValueTypeNum,
      ValueTypeTrue, // true和false主要用于map中的开放定制法
      ValueTypeFalse
  } ValueType;
  // 它类似于Python中的引用, 在栈中定义, 所以脚本语言模拟的栈就是Value数组, 对象在堆中创建
  typedef struct Value {
      ValueType type;
      union {
          double num;
          ObjHeader *obj_header; // obj_header的实体在对象中, 这里只需要指向对象头即可
      };
  } Value;
// 通过宏将ValueType与Value结构体直接的转换更快捷
// 此外还要定义Value之间比较的函数
valueIsEquals
  思路:
      Value的类型不同则false
      Value的类型相同且为数字, 则直接比较数字
      Value的类型相同都为Obj, 则比较里面的ObjHeader的类型, 如果相同则再看ObjHeader的类型是什么, 只能比较字符串, range和Class对象, 因为Class有类名属性, 就相当于比较字符串&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;紧接着创建类对象, 创建class.h文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;    /*
好好想一下, 一个类中都有什么, 这与我们在Java和C++编程的类不同, 我们只找所有的类的共同点
1. 对象头
2. 字段个数
3. 方法对象区, 用于存方法
*/
typedef struct Class {
    ObjHeader obj_header; // 类也是对象, 所以也会有ObjHeader, 但是其中的ObjHeader的class是指向元类的
    ObjString name; // 类名
    struct Class *superclass;
    uint32_t field_num;
    MethodBuffer methods; // 存储Method结构体, 主要封装了方法指针
} Class;

newVM的使用需要创建出核心模块coreModule, 并将其添加到allModules的map中


typedef num MethodType {
    MethodTypeNull,
    MethodPrimitive,
    MethodScript,
    MethodCall // 用于重载
} MethodType;

typedef struct Method {
    MethodType type;
    union {
        // C语言实现的方法
        Primitive prim_fn;
        // 脚本语言将代码编译成ObjClosure对象, ObjClosure包含ObjFunc对象, ObjFunc又有指令流
        ObjClosure *obj;
    };
} Method;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;在有了类, 对象头的基础上, 紧接着创建脚本语言第一个内置对象String, 在obj_string.h中&lt;/p&gt;
&lt;p&gt;```c&lt;/p&gt;
&lt;p&gt;// 这里仅仅是定义了字符串对象, obj_header指向是ObjString类对象&lt;br/&gt;typedef struct ObjString {&lt;br/&gt;ObjHeader obj_header;&lt;br/&gt;long hash_code; // 保存hash值&lt;br/&gt;int len;&lt;br/&gt;char *start[0];&lt;br/&gt;} ObjString;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;// 在创建字符串的时候, 传入const char *s, 使用memset拷贝过来, 不要直接用, 可能会有问题&lt;/p&gt;
&lt;p&gt;// 计算字符串的hashcode&lt;br/&gt;long hash_string(const char *str, int length) {&lt;br/&gt;int hashcode = xxxxxxxx;&lt;br/&gt;int idx = 0;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (idx &amp;lt; length) {
    hashcode ^= str[idx++];
    hashcode *= yyyyyyyy;
}
return hashcode;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;// 将计算的hash值保存到ObjString对象中&lt;br/&gt;void hashObjString(ObjString &amp;amp;objString) {&lt;br/&gt;objString-&amp;gt;hash_code = hash_string(objString-&amp;gt;start, objString-&amp;gt;len);&lt;br/&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;有了第一个ObjString对象之后, 紧接着考虑元对象的创建, 元对象包括ObjModule和ObjInstance, ObjModule不属于任何类, 同时需要执行一个modname, 所以需要ObjString对象, 这就是为什么需要先创建ObjString对象的原因&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
typedef struct objmodule {
    ObjHeader obj_header; // 因为mod不属于任何类, 所有它里面的ObjHeader中的cls为NULL
    StringBuffer module_names; // 与module_values的长度一样, 用于映射, 因为变量有名字和值
    ValueBuffer module_values;
    ObjString *modname;
} ObjModule;

typedef struct objinstance {
    ObjHeader *obj_header;
    Value fields[0]; // 存放属性的
} ObjInstance;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建复杂的函数有关的对象, 创建obj_func.h文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// Class对象为fnClass
typedef struct objfunc {
    ObjHeader obj_header;
    ByteBuffer inst_stream;
    ValueBuffer constants;
    int arg_num;
    int upvalue_num;
    int max_stack_size;
    ObjModule *mod;
} ObjFunc;


typedef struct objupvalue {
    ObjHeader obj_header;
    Value *local_var_ptr;
    Value closed_var;
    struct objupvalue *next;
} ObjUpvalue;

// class对象也为fnClass
typedef struct objclosure {
    ObjHeader obj_header;
    ObjFunc *func;
    ObjUpvalue *upvalue[0]; // 指向一个ObjUpvalue数组
} ObjClosure;

// 会让线程对象调用
typedef struct frame {  
    int ip;
    ObjClosure *obj_closure;
    Value *stack_start;
} Frame;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Value非常的重要, 在之后函数与方法的实现都是以Value为参数和返回值得, 可以类比于Python, 但是定义一个对象的时候就不需要了, 直接一个对象上去即可, 如ObjString *objString.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他类在后面的文章中提到&quot;&gt;其他类在后面的文章中提到&lt;/h2&gt;
</description>
<pubDate>Fri, 15 Feb 2019 06:50:00 +0000</pubDate>
<dc:creator>jin_hao_chen</dc:creator>
<og:description>2. 面向对象的脚本语言的类的实现 只要是一个对象就要有一个ObjHeader结构体, 该结构体位于该对象的开头 ObjHeader结构 Value结构体(Value不是对象, 他在脚本语言层面是一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/megachen/p/10383643.html</dc:identifier>
</item>
<item>
<title>KVO讲解 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/10272146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/10272146.html</guid>
<description>&lt;p&gt;最近一直在写swift项目，没有时间更新自己的技术博客，以前在博客里面写过KVO的底层原理，今天我们来看一下KVO的整个使用过程和使用场景（附有demo），大约花大家10-15分钟时间，希望大家看完博客之后对KVO的使用有更清醒的认识。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面我们按照以下提纲讲解KVO。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;KVO的基本使用&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;KVO的触发模式&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;KVO的属性依赖&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;KVO的原理探究&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;自定义KVO&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;KVO对容器类的监听&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一、KVO的基本使用&lt;/h2&gt;
&lt;h3&gt; 1.基本步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过addObserver:forKeyPath:options:context:注册观察者，观察者可以接收keyPath属性的变化事件。&lt;/li&gt;
&lt;li&gt;在观察者中实现observeValueForKeyPath：ofObject:change:context方法，当keyPath属性发生改变后，KVO会回调这个方法来通知观察者。&lt;/li&gt;
&lt;li&gt;当观察者不需要监听时，可以调用removeObserve：forKeyPath方法将KVO移除，需要注意的是，调用removeObserve需要在观察者消失之前，否则会导致Crash。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在注册观察者时，可以传入下列参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; Observer参数，观察者对象&lt;/li&gt;
&lt;li&gt;keyPath参数 需要观察者的属性，由于是字符串形式，如果传错格式，容易导致Crash。一旦利用系统的反射机制NSStringFromSelector(keyPath)&lt;/li&gt;
&lt;li&gt;options参数 参数是一个枚举类型&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;NSKeyValueObserveOptionNew 接收新值，默认为只接受新值&lt;/li&gt;
&lt;li&gt;NSKeyValueObserveOptionOld 接收旧值&lt;/li&gt;
&lt;li&gt;NSKeyValueObserveOptionInitial 在注册时接收一次回调，在改变时也会发送通知&lt;/li&gt;
&lt;li&gt;NSKeyValueObserveOptionPrior 改变之前发一次，改变之后发一次&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Context参数 传入任意类型的对象，在接收消息回调的代码中科院接收到这个对象，是KVO中的一种传值方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.案例操作&lt;/h3&gt;
&lt;h4&gt;2.1 新建项目叫：KVO的基本使用&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115163919463-1051350609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.2 demo代码&lt;/h4&gt;
&lt;p&gt;新增人-age属性，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;&lt;span&gt;

NS_ASSUME_NONNULL_BEGIN

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; Person : NSObject
&lt;strong&gt;@property (nonatomic,assign)&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;@end&lt;/span&gt;&lt;span&gt;

NS_ASSUME_NONNULL_END


&lt;/span&gt;&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; Person

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.3 在ViewController实现&lt;/h4&gt;
&lt;h5&gt;2.3.1 导入Person类，并创建类对象&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115170354704-649140269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2.3.2 在ViewDidLoad中创建类对象，并注册观察者&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115170840375-1265754463.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在下面观察属性值变化实现方法observeValueForKeyPath&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115171218306-63527901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后要移除观察者removeObserver&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115171352190-1124036850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们加入响应事件touchesBegan，每次点击页面，age都会自动加1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115171556119-801950815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是整个的代码ViewController的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
@property(nonatomic,strong) Person &lt;/span&gt;*&lt;span&gt; p;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    
    _p &lt;/span&gt;=&lt;span&gt; [[Person alloc]init];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册&lt;/span&gt;
&lt;span&gt;    [_p addObserver:self forKeyPath:NSStringFromSelector(@selector(age)) options:(NSKeyValueObservingOptionNew) context:nil];
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)observeValueForKeyPath:(NSString *)keyPath ofObject:(&lt;span&gt;id&lt;/span&gt;)&lt;span&gt;object&lt;/span&gt; change:(NSDictionary&amp;lt;NSKeyValueChangeKey,&lt;span&gt;id&lt;/span&gt;&amp;gt; *)change context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,change);
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)&lt;span&gt;event&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
    _p.age &lt;/span&gt;= a++&lt;span&gt;;
}


&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dealloc{
    [_p removeObserver:self forKeyPath:NSStringFromSelector(@selector(age))];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.4 代码测试&lt;/h4&gt;
&lt;p&gt;点击了界面三次，打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190115172243017-1085658196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现new值在不断地增加，满足了监听person的age属性的要求。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;拓展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面代码[p addObserver：self]，而在控制器中声明p对象用的属性修饰词是Strong，这其中中这里面有没有强引用关系？（p有没有强引用self）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在调用addObserver方法后，KVO并不会对观察者进行强引用，所以我们要注意观察者的生命周期，因为[p addObserver：self]中，一旦self（控制器）销毁的时候，p也就是拿不到self，那么剩下一个问题，p会不会调用&lt;/span&gt;&lt;/span&gt;observeValueForKeyPath呢，答案是仍然是会调用，而给已经释放的内存发送一个消息，接下来会发生crash。&lt;/p&gt;
&lt;p&gt;所以要在dealloc方法中，移除观察者。&lt;/p&gt;

&lt;h2&gt;二、KVO的触发模式&lt;/h2&gt;
&lt;p&gt;KVO在属性发生改变的时候调用是自动的，如果想要手动控制这个调用时机，或者自己实现KVO属性的调用，则可以通过KVO提供的方法进行调用。&lt;/p&gt;
&lt;p&gt;如果想手动控制，可以实现下面方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190116121011809-870493510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们再次点击屏幕，发现控制台无任何的打印结果。如果想要监听结果，需要在响应事件中加入willChangeValueForKey和didChangeValueForKey方法，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190116142555669-1984147574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过加入方法之后，控制台重新出现打印结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190116143132650-1020498811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;拓展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果没有改变age属性的值，还能触发KVO嘛，也就是注释掉&lt;/span&gt;&lt;/span&gt;&lt;span&gt;_p.age = a++;&lt;span&gt;（去掉setter方法）还能触发嘛？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190116143949444-1132964604.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们运行代码，发现还会执行&lt;/span&gt;（只要实现了willChangeValueForKey和didChangeValueForKey方法）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190116144413423-1971937509.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;三、KVO的属性依赖&lt;/h2&gt;
&lt;h3&gt;3.1 案例分析&lt;/h3&gt;
&lt;p&gt;如果新增一个类Dog，而Dog也新增一属性age，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118143241461-440867123.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时将Dog类作为Person的一个对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118143652033-1815488111.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Person并初始化Dog对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118143742638-1116572334.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ViewController中，&lt;span&gt;注册监听者不能使用NSStringFromSelector方法了&lt;/span&gt;，应该使用字符串了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118144900643-116616555.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击屏幕进行触摸事件点击&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118145034402-75299700.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制台进行打印结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118145208078-786210013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 案例拓展&lt;/h3&gt;
&lt;p&gt;新增一需求，如果Dog类属性特别多，我们有一个需求，只要Dog类的任一属性发生改变，就通知Dog类的观察者？&lt;/p&gt;
&lt;p&gt;在Dog类中加入level属性，只要Dog类的属性发生改变，通知观察者&lt;/p&gt;
&lt;p&gt;Dog类新增属性level等级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118154943713-205114432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在KVO本身的封装代码中，有一个方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;+ (NSSet&amp;lt;NSString *&amp;gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NSSet是一个集合，返回所有的属性，方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201901/1305302-20190118160817862-812616722.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、KVO原理探究&lt;/h2&gt;
&lt;p&gt;对于KVO的原理探究的文章，本人已经写好了，请看一下博客&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/guohai-stronger/p/9473551.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/guohai-stronger/p/9473551.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;五、自定义KVO&lt;/h2&gt;
&lt;p&gt;下面我们自己写KVO，在写之前，我们首先看一下苹果自身怎么实现的？比较关键的一个方法是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果查看源码发现，苹果是建立NSObject分类Category来实现KVO的 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214152607605-382598731.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们就自定义KVO。&lt;/p&gt;
&lt;h3&gt;5.1 创建分类XY_KVO&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214155149888-1629020550.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.1.1 自定义一个方法：&lt;/h4&gt;
&lt;p&gt;- (void)XY_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;&lt;/p&gt;
&lt;h4&gt;5.1.2 实现方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)XY_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建一个类&lt;/span&gt;
    NSString *oldClassName = NSStringFromClass(self.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    NSString &lt;/span&gt;*newClassName = [&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;XYKVO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; stringByAppendingString:oldClassName];
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*myClass的父类是person类&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class myClass &lt;/span&gt;= objc_allocateClassPair(self.&lt;span&gt;class&lt;/span&gt;, newClassName.UTF8String, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册类&lt;/span&gt;
&lt;span&gt;    objc_registerClassPair(myClass);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.重写set方法(所谓的重写是添加set方法，如果不重写set方法，子类是没有set方法的（父类是Person类），但子类是可以调用set方法的)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    class_addMethod(&amp;lt;#Class  _Nullable __unsafe_unretained cls#&amp;gt;, &amp;lt;#SEL  _Nonnull name#&amp;gt;, &amp;lt;#IMP  _Nonnull imp#&amp;gt;, &amp;lt;#const char * _Nullable types#&amp;gt;)&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     *Class 给那个类添加方法
     *SEL 方法编号
     *IMP 方法实现
     *types 返回值类型
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    
    &lt;span&gt;/**
     v@:@代表返回值为void，第一个参数@代表调用者，第二个:代表方法编号也就是方法名字，第三个代表传参（真正代表你传参的）
     */&lt;/span&gt;&lt;span&gt;
    class_addMethod(myClass, @selector(setAge:), (IMP)setAge, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v@:@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.修改isa指针！！isa指针指向子类&lt;/span&gt;
&lt;span&gt;    object_setClass(self, myClass);
    
}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;void setAge(id self,SEL _cmd,NSString *age){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    NSLog(@&quot;来了&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;拓展》》》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;class_addMethod(myClass, @selector(&lt;span&gt;setAge:&lt;/span&gt;), (IMP)setAge, &quot;&lt;span&gt;v@:@&lt;/span&gt;&quot;);中setAge:明明只有一个参数，为什么返回的要有三个参数如果不写，就会返回对象原因？&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;_p = [Person alloc];&lt;/p&gt;
&lt;p&gt;_p = [_p init];&lt;/p&gt;
&lt;p&gt;将init这句代码改为_p = objc_msgSend(_p,@selector(init))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(任何oc的方法调用都会变为objc_msgSend(_p,@selector(方法)))-消息发送，第一个参数是方法对象，第二个方法编号名字&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;5.1.3 测试过程&lt;/h4&gt;
&lt;h5&gt;1.导入类NSObject+XYKVO.h&lt;/h5&gt;
&lt;h5&gt;2.使用自定义的KVO&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214224748055-1878686973.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;3.触碰时改变age值&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214225308787-120484712.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;4.然后查看自定义KVO里面set方法，看是否打印出“来了”&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214230159146-1723346896.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果出现“来了”，说明自定义KVO实现监听啦&lt;/p&gt;

&lt;h3&gt;5.3 监听属性&lt;/h3&gt;
&lt;h4&gt;5.3.1 将观察者保存到当前对象&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190214234420917-901962477.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;126&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.3.2 发送监听通知&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; setAge(id self,SEL _cmd,NSString *&lt;span&gt;age){
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;来了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用父类的set方法&lt;/span&gt;
    Class &lt;span&gt;class&lt;/span&gt; = [self &lt;span&gt;class&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类当前类型&lt;/span&gt;
   object_setClass(self, &lt;span&gt;class&lt;/span&gt;.getSuperclass(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    objc_msgSend(self,@selector(setAge:),age)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到观察者之后，要发送通知&lt;/span&gt;
    id observer = objc_getAssociatedObject(self, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;observer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (observer) {
       objc_msgSend(observer,@selector(observeValueForKeyPath:ofObject:change:context:),&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,self,@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:age,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:@&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},nil);
    }
    object_setClass(self, &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过objc_msgSend(observer,@selector(observeValueForKeyPath:ofObject:change:context:),@&quot;age&quot;,self,@{@&quot;new&quot;:age,@&quot;kind&quot;:@1},nil);就可以实现监听在控制器中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)&lt;span&gt;object&lt;/span&gt; change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,change);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;六、 KVO对容器类的监听&lt;/h2&gt;
&lt;h3&gt;6.1 新增容器类属性并初始化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190215124921965-23669429.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;76&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190215125347483-69665009.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.2 对容器类添加监听&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190215125432559-154306957.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;109&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.3 触碰屏幕查看容器属性变化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190215130108058-1138939618.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果上面的容器使用注释的那行[_p.arr addObject:@&quot;11&quot;]，会触发KVO嘛？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是&lt;span&gt;不会&lt;/span&gt;，因为addObject不是set方法，KVO通过set方法来触发，而苹果专门给KVO提供个接口，通过mutableArrayValueForKey方法，来触发&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;6.4 结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305302/201902/1305302-20190215131014751-1602566582.jpg&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现tempArr是NSKeyValueNotifyingMutableArray，这个类是NSMutableArray的子类，我们可以联想到容器类监听和属性监听差不多，有着异曲同工之处。&lt;span&gt;请大家细细体会。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上面就是关于KVO的基本讲解，以后会慢慢的剖解更多OC的底层知识，供大家阅读。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 05:23:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>最近一直在写swift项目，没有时间更新自己的技术博客，以前在博客里面写过KVO的底层原理，今天我们来看一下KVO的整个使用过程和使用场景（附有demo），大约花大家10-15分钟时间，希望大家看完博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/10272146.html</dc:identifier>
</item>
<item>
<title>Object Pooling(对象池)实现 - Zhang_Xiang</title>
<link>http://www.cnblogs.com/Zhang-Xiang/p/10369667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zhang-Xiang/p/10369667.html</guid>
<description>&lt;p&gt;在文章开始之前首先要思考的问题是为什么要建立对象池。这和.NET垃圾回收机制有关，正如下面引用所说，内存不是无限的，垃圾回收器最终要回收对象，释放内存。尽管.NET为垃圾回收已经进行了大量优化，例如将托管堆划分为 3 Generations（代）并设定新建的对象回收的最快，新建的短生命周期对象将进入 Gen 0（新建对象大于或等于 85,000 字节将被看作大对象，直接进入 Gen 2），而 Gen 0 通常情况下分配比较小的内存，因此Gen 0 将回收的非常快。而高频率进行垃圾回收导致 CPU 使用率过高，当 Gen 2 包含大量对象时，回收垃圾也将产生性能问题。&lt;/p&gt;
&lt;blockquote readability=&quot;7.9194630872483&quot;&gt;
&lt;p&gt;.NET 的垃圾回收器管理应用程序的内存分配和释放。 每当有对象新建时，公共语言运行时都会从托管堆为对象分配内存。 只要托管堆中有地址空间，运行时就会继续为新对象分配空间。 不过，内存并不是无限的。 垃圾回收器最终必须执行垃圾回收来释放一些内存。 垃圾回收器的优化引擎会根据所执行的分配来确定执行回收的最佳时机。 执行回收时，垃圾回收器会在托管堆中检查应用程序不再使用的对象，然后执行必要的操作来回收其内存。&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构造对象池&quot;&gt;构造对象池&lt;/h2&gt;
&lt;p&gt;.Net Core 在（Base Class Library）基础类型中添加了 ArrayPool，但 ArrayPool 只适用于数组。针对自定义对象，&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-create-an-object-pool&quot;&gt;参考MSDN&lt;/a&gt;有一个实现，但没有初始化池大小，且从池里取对象的方式比较粗糙，完整的对象池应该包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;池大小&lt;/li&gt;
&lt;li&gt;初始化委托&lt;/li&gt;
&lt;li&gt;实例存取方式（FIFO、LIFO 等自定义方式，根据个人需求实现获取实例方式）&lt;/li&gt;
&lt;li&gt;获取实例策略&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定义对象存取接口以实现多种存取策略例如-fifolifo&quot;&gt;1. 定义对象存取接口，以实现多种存取策略，例如 FIFO、LIFO&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 对象存取方式
/// &amp;lt;/summary&amp;gt;
public interface IAccessMode&amp;lt;T&amp;gt;
{
    /// &amp;lt;summary&amp;gt;
    /// 租用对象
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    /// &amp;lt;exception cref=&quot;InvalidOperationException&quot;&amp;gt;&amp;lt;/exception&amp;gt;
    T Rent();
    
    /// &amp;lt;summary&amp;gt;
    /// 返回实例
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;item&quot;&amp;gt;&amp;lt;/param&amp;gt;
    void Return(T item);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;实现存取策略&quot;&gt;2. 实现存取策略&lt;/h4&gt;
&lt;h5 id=&quot;fifo&quot;&gt;FIFO&lt;/h5&gt;
&lt;p&gt;FIFO通过Queue实现，&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=netcore-2.2&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public sealed class FIFOAccessMode&amp;lt;T&amp;gt; : Queue&amp;lt;T&amp;gt;, IAccessMode&amp;lt;T&amp;gt;
{
    private readonly int _capacity;
    private readonly Func&amp;lt;T&amp;gt; _func;
    private int _count;

    public FIFOAccessMode(int capacity, Func&amp;lt;T&amp;gt; func) : base(capacity)
    {
        _capacity = capacity;
        _func = func;
        InitialQueue();
    }

    public T Rent()
    {
        Interlocked.Increment(ref _count);
        return _capacity &amp;lt; _count ? _func.Invoke() : Dequeue();
    }

    public void Return(T item)
    {
        if (_count &amp;gt; _capacity)
        {
            var disposable = (IDisposable)item;
            disposable.Dispose();
        }
        else
        {
            Enqueue(item);
        }
        Interlocked.Decrement(ref _count);
    }

    private void InitialQueue()
    {
        for (var i = 0; i &amp;lt; _capacity; i++)
        {
            Enqueue(_func.Invoke());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;lifo&quot;&gt;LIFO&lt;/h5&gt;
&lt;p&gt;在LIFO中借助Stack特性实现进栈出栈，因此该策略继承自Stack，&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1?view=netcore-2.2&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public sealed class LIFOAccessModel&amp;lt;T&amp;gt; : Stack&amp;lt;T&amp;gt;, IAccessMode&amp;lt;T&amp;gt;
{
    private readonly int _capacity;
    private readonly Func&amp;lt;T&amp;gt; _func;
    private int _count;

    public LIFOAccessModel(int capacity, Func&amp;lt;T&amp;gt; func) : base(capacity)
    {
        _capacity = capacity;
        _func = func;
        InitialStack();
    }

    public T Rent()
    {
        Interlocked.Increment(ref _count);
        return _capacity &amp;lt; _count ? _func.Invoke() : Pop();
    }

    public void Return(T item)
    {
        if (_count &amp;gt; _capacity)
        {
            var disposable = (IDisposable)item;
            disposable.Dispose();
        }
        else
        {
            Push(item);
        }
        Interlocked.Decrement(ref _count);
    }

    private void InitialStack()
    {
        for (var i = 0; i &amp;lt; _capacity; i++)
        {
            Push(_func.Invoke());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：以上两个实现都遵循池容量不变原则，但租用的实例可以超过对象池大小，返还时还将检测该实例直接释放还是进入池中。而如何控制池大小和并发将在下面说明。&lt;/p&gt;
&lt;h4 id=&quot;pool实现&quot;&gt;3.Pool实现&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Pool&amp;lt;T&amp;gt; : IDisposable where T : IDisposable
{
    private int _capacity;
    private IAccessMode&amp;lt;T&amp;gt; _accessMode;
    private readonly object _locker = new object();
    private readonly Semaphore _semaphore;

    public Pool(AccessModel accessModel, int capacity, Func&amp;lt;T&amp;gt; func)
    {
        _capacity = capacity;
        _semaphore = new Semaphore(capacity, capacity);
        InitialAccessMode(accessModel, capacity, func);
    }

    private void InitialAccessMode(AccessModel accessModel, int capacity, Func&amp;lt;T&amp;gt; func)
    {
        switch (accessModel)
        {
            case AccessModel.FIFO:
                _accessMode = new FIFOAccessMode&amp;lt;T&amp;gt;(capacity, func);
                break;
            case AccessModel.LIFO:
                _accessMode = new LIFOAccessModel&amp;lt;T&amp;gt;(capacity, func);
                break;
            default:
                throw new NotImplementedException();
        }
    }

    public T Rent()
    {
        _semaphore.WaitOne();
        return _accessMode.Rent();
    }

    public void Return(T item)
    {
        _accessMode.Return(item);
        _semaphore.Release();
    }

    public void Dispose()
    {
        if (!typeof(IDisposable).IsAssignableFrom(typeof(T))) return;

        lock (_locker)
        {
            while (_capacity &amp;gt; 0)
            {
                var disposable = (IDisposable)_accessMode.Rent();
                _capacity--;
                disposable.Dispose();
            }

            _semaphore.Dispose();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Pool中如何控制程序池并发，这里我们引入了 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphore?view=netcore-2.2&quot;&gt;Semaphore&lt;/a&gt; 以控制并发，这里将严格控制程序池大小，避免内存溢出。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;4.使用&lt;/h4&gt;
&lt;p&gt;Student 类用作测试&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Student : IDisposable
{
    public string Name { get; set; }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private bool _disposed;

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            Name = null;
             //Free any other managed objects here.
        }

        _disposed = true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void TestPool()
{
    Func&amp;lt;Student&amp;gt; func = NewStudent;
    var pool = new Pool&amp;lt;Student&amp;gt;(AccessModel.FIFO, 2, func);
    for (var i = 0; i &amp;lt; 3; i++)
    {
        Student temp = pool.Rent();
        //todo:Some operations
        pool.Return(temp);
    }

    Student temp1 = pool.Rent();

    pool.Return(temp1);

    pool.Dispose();
}

public Student NewStudent()
{
    return new Student();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：至此，一个完整的对象池建立完毕。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 04:49:00 +0000</pubDate>
<dc:creator>Zhang_Xiang</dc:creator>
<og:description>在文章开始之前首先要思考的问题是为什么要建立对象池。这和.NET垃圾回收机制有关，正如下面引用所说，内存不是无限的，垃圾回收器最终要回收对象，释放内存。尽管.NET为垃圾回收已经进行了大量优化，例如将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zhang-Xiang/p/10369667.html</dc:identifier>
</item>
<item>
<title>一文助您成为Java.Net双平台高手 - 莱布尼茨</title>
<link>http://www.cnblogs.com/newton/p/9866506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newton/p/9866506.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;写在前面：本文乃标题党，不是月经贴，侧重于Web开发差异，或细节或概述，若有不对之处，还请各位读者本着友好互助的心态批评指正。由于博客园中.Neter较多（个人感觉），因此本文也可以作为.Neter到Java开发的快速入门。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在.Net开发中，微软官方框架类可以很好的解决的大部分问题，开发人员可以心安理得的在一亩三分地腾挪躲闪出花来；偶有一些优（zhao）秀（chao）的开源库，各库的关注点也基本不会重样；所以.Neter只要按部就班即可。而Java喜欢定义各种规范，各路大神各自实现，因此一个概念常常会有很多的第三方库，虽然有Spring这种杀手级框架，不过基于IOC和AOP的设定，Spring家族也变得异常庞大，在编码时需要引入大量的annotation来织入逻辑；虽然貌似最大程度的解耦了各组件，但导致代码的可读性和可调试性非常不好，碎片化非常严重。不过也因为如此，Java社区成为设计思想的孕育地，并常常出现一些让人击节的设计模式。其中的概念传播到隔壁.Net圈，圈内小白往往一脸懵逼，而少数大佬不管不顾拿来套用，往往是用错了，或者让人不知所以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;笼统来说，.Net框架隐藏细节，简便清晰，套路单一，但常陷入知其然不知其所以然的懵逼境地；Java&amp;amp;Spring注解隐藏细节，概念繁多，没有方向感或有被绕晕的风险，但一旦破位而出，则纵横捭阖天地之大可任意施展至其它平台。不过两者差异随着.Net的开源以肉眼不可见的速度缓慢消失，特别是最近几年，.Net在语法层面已经超越了Java良多，Java虽然一时半会抹不开面子，但也一直在改进。到的本文撰写时分，借用不知名网友语：“C#语法已经达到Java20，用户量撑死Java7，生态Java1.4”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者竞争主要集中在Web开发领域。目前在该领域，Spring Boot已基本成为事实上Java平台的“官方框架”，我想大部分开发人员并不会在意背后的实现细节，从这个方面来讲，两个平台的开发模式有一定程度的相似。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据持久层&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为啥这节标题不是ORM呢？毕竟ORM现在是业界标准，很难想象这个时代还需要手写SQL，还需要手动操作JDBC/ADO；如果你打算这么干，一定会被年轻一辈打心眼里鄙视：）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORM：十多年前，Hibernate就开始兴起，它提供了半对象化的HQL和完全的面向对象QBC。之后也出现了其它一些ORM比如TopLink。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JPA：JDK5引入，是SUN公司为了统一目前众多ORM而提出的ORM规范（又犯了定义规范的瘾）。这个规范出来后，很多ORM表示支持，但以前的还得维护啊，所以像Hibernate就另外建了一个分支叫Hibernate JPA。网友&lt;a href=&quot;https://blog.csdn.net/benjaminlee1/article/details/53087351&quot; target=&quot;_blank&quot;&gt;benjaminlee1&lt;/a&gt;所言：“JPA的出现只是用于规范现有的ORM技术，它不能取代现有的Hibernate等ORM框架，相反，采用JPA开发时，我们仍将使用这些ORM框架，只是此时开发出来的应用不在依赖于某个持久化提供商。应用可以在不修改代码的情况下载任何JPA环境下运行，真正做到低耦合，可扩展的程序设计。类似于JDBC，在JDBC出现以前，我们的程序针对特性的数据库API进行编程，但是现在我们只需要针对JDBC API编程，这样能够在不改变代码的情况下就能换成其他的数据库。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring Data JPA：有了JPA，我们就可以不在意使用哪个ORM了，但是Spring Data JPA更进一步（为Spring家族添砖加瓦），按约定的方式自动给我们生成持久化代码，当然它底层还是要依赖各路ORM的。相关资料：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html&quot; target=&quot;_blank&quot;&gt;使用 Spring Data JPA 简化 JPA 开发&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mybatis：随着时间的流逝，Hibernate曾经带来的荣耀已经被臃肿丑陋的配置文件，无法优化的查询语句淹没。很多人开始怀念可一手掌控数据操作的时代，于是Mybatis出现了。Mybatis不是一个完整的ORM，它只完成了数据库返回结果到对象的映射，而存取逻辑仍为SQL，写在Mapper文件中，它提供的语法在一定程度上简化了SQL的编写，最后Mybatis将SQL逻辑映射到接口方法上（在Mapper文件中指定&amp;lt;mapper namespace=&quot;xxx&quot;&amp;gt;，其中xxx为映射的DAO接口）。针对每个表写通用增删改查的Mapper SQL既枯燥又易出错，所以出现了Mybatis-Generator之类的代码生成工具，它能基于数据表生成实体类、基本CRUD的Mapper文件、对应的DAOInterface。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://mp.baomidou.com/guide/&quot; target=&quot;_blank&quot;&gt;Mybatis-Plus&lt;/a&gt;：在Mybatis的基础上，提供了诸如分页、复杂条件查询等功能，基础CRUD操作不需要额外写SQL Mapper了，只要DAO接口继承BaseMapper接口即可。当然为了方便，它也提供了自己的代码生成器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.NET&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ORM：主流Entity Framework，除开ORM功能外，它还提供了Code first、DB first、T4代码生成等特性。性能上与Hibernate一个等级，但使用便捷性和功能全面性较好，更别说还有linq的加持。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;认证&amp;amp;授权&amp;amp;鉴权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;认证是检测用户/请求是否合法，授权是赋予合法用户相应权限，鉴权是鉴别用户是否有请求某项资源的权限（认证和授权一般是同时完成）。我们以web为例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;C#/Asp.net mvc&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提供了两个Filter：IAuthenticationFilter 和 AuthorizeAttribute，前者用于认证授权，后者用于鉴权。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_dccbcefa-d921-44ef-8be1-c9addf2e3ca2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dccbcefa-d921-44ef-8be1-c9addf2e3ca2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_dccbcefa-d921-44ef-8be1-c9addf2e3ca2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IAuthenticationFilter 认证，认证是否合法用户&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminAuthenticationFilter : ActionFilterAttribute, IAuthenticationFilter
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthentication(AuthenticationContext filterContext)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         IPrincipal user =&lt;span&gt; filterContext.Principal;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;user.Identity.IsAuthenticated)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             HttpCookie authCookie =&lt;span&gt; filterContext.HttpContext.Request.Cookies[FormsAuthentication.FormsCookieName];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (authCookie != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 FormsAuthenticationTicket ticket =&lt;span&gt; FormsAuthentication.Decrypt(authCookie.Value);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ticket != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ticket.UserData))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; userId =&lt;span&gt; Convert.ToInt32(ticket.UserData);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     user = EngineContext.Resolve&amp;lt;PFManagerService&amp;gt;&lt;span&gt;().GetManager(userId);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     filterContext.Principal = user; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后续会传递给HttpContext.Current.User&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthenticationChallenge(AuthenticationChallengeContext filterContext)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 认证失败执行&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;认证成功后，将user赋给filterContext.Principal（第17行），filterContext.Principal接收一个IPrincipal接口对象，该接口有个 bool IsInRole(string role) 方法，用于后续的鉴权过程。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_875a48eb-7c32-4f1d-8a4a-6f997a832eff&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_875a48eb-7c32-4f1d-8a4a-6f997a832eff&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_875a48eb-7c32-4f1d-8a4a-6f997a832eff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminAuthorizationFilter : AuthorizeAttribute
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{        
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;childaction不用授权&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.IsChildAction)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!filterContext.ActionDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;) &amp;amp;&amp;amp; !filterContext.ActionDescriptor.ControllerDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {           
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (filterContext.HttpContext.User != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; filterContext.HttpContext.User.Identity.IsAuthenticated)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; controllerName = filterContext.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString().ToLower();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; actionName = filterContext.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString().ToLower();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要登录，则都能访问工作台&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (controllerName.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; actionName.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.Roles = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; roleIds = EngineContext.Resolve&amp;lt;BEModuleService&amp;gt;&lt;span&gt;().GetRoleIdsHasModuleAuthorization(controllerName, actionName, MasonPlatformType.AdminPlatform);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (roleIds == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         filterContext.Result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpNotFoundResult();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将资源所需权限赋给成员变量Roles&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.Roles = &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, roleIds);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnAuthorization(filterContext);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意第27行，我们将拥有该资源的所有权限赋给Roles，之后AuthorizeAttribute会循环Roles，依次调用当前用户（上述的filterContext.Principal）的IsInRole方法，若其中一个返回true则表明用户有访问当前资源的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java/Spring Security&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也提供了两个类，一个Filter和一个Interceptor：AuthenticationProcessingFilter用于用户认证授权，AbstractSecurityInterceptor用于鉴权。Spring Security基于它们又封装了几个类，主要几个：WebSecurityConfigurerAdapter、FilterInvocationSecurityMetadataSource、AccessDecisionManager、UserDetailsService。另外还有各类注解如@EnableGlobalMethodSecurity等。（以下代码含有一点jwt逻辑）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebSecurityConfigurerAdapter：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_332080f6-6aec-4bf8-b2eb-69bbb3c451fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_332080f6-6aec-4bf8-b2eb-69bbb3c451fa&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_332080f6-6aec-4bf8-b2eb-69bbb3c451fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@EnableWebSecurity
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @EnableGlobalMethodSecurity(prePostEnabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebSecurityConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebSecurityConfigurerAdapter {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JwtAuthenticationEntryPoint unauthorizedHandler;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDetailsService userDetailsService;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomPostProcessor postProcessor;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configureAuthentication(AuthenticationManagerBuilder authenticationManagerBuilder) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        authenticationManagerBuilder
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 .userDetailsService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userDetailsService)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                .passwordEncoder(passwordEncoder());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PasswordEncoder passwordEncoder() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; JwtAuthenticationTokenFilter authenticationTokenFilterBean() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtAuthenticationTokenFilter();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(HttpSecurity httpSecurity) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        httpSecurity
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; we don't need CSRF because our token is invulnerable&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                .csrf().disable()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't create session&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                .authorizeRequests()
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 .antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;&lt;span&gt;).permitAll()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                .anyRequest().authenticated().withObjectPostProcessor(postProcessor);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Custom JWT based security filter&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        httpSecurity
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;主要关注两个方法configureAuthentication(AuthenticationManagerBuilder authenticationManagerBuilder)和configure(HttpSecurity httpSecurity)。configureAuthentication主要用于设置UserDetailsService，加载用户数据需要用到；configure用于设置资源的安全级别以及全局安全策略等。第41行withObjectPostProcessor，用于设置FilterInvocationSecurityMetadataSource和AccessDecisionManager，它们两个用于鉴权，下面会讲到。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_19c85bbc-3999-4c07-a9b9-410e0d8951e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_19c85bbc-3999-4c07-a9b9-410e0d8951e4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_19c85bbc-3999-4c07-a9b9-410e0d8951e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomPostProcessor &lt;span&gt;implements&lt;/span&gt; ObjectPostProcessor&amp;lt;FilterSecurityInterceptor&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomFilterSecurityMetadataSource customFilterSecurityMetadataSource;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomAccessDecisionManager customAccessDecisionManager;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T &lt;span&gt;extends&lt;/span&gt; FilterSecurityInterceptor&amp;gt;&lt;span&gt; T postProcess(T fsi) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         fsi.setSecurityMetadataSource(customFilterSecurityMetadataSource); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.路径（资源）拦截处理&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         fsi.setAccessDecisionManager(customAccessDecisionManager); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.权限决策处理类&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fsi;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;UserDetailService（此处从数据库获取）:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_d33484ec-3473-47c9-b28d-3de93fa36dd0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d33484ec-3473-47c9-b28d-3de93fa36dd0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_d33484ec-3473-47c9-b28d-3de93fa36dd0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JwtUserDetailsServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDetailsService {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserRepository userRepository;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; UserDetails loadUserByUsername(String username) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UsernameNotFoundException {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         User user =&lt;span&gt; userRepository.findByUsername(username);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UsernameNotFoundException(String.format(&quot;No user found with username '%s'.&quot;&lt;span&gt;, username));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JwtUserFactory.create(user);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意loadUserByUsername需要的参数名username是约定好的，在UsernamePasswordAuthenticationFilter中定义，value是从HttpServletRequest中获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FilterInvocationSecurityMetadataSource（用于获取当前请求资源所需的权限）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_cccb5b7b-0060-4f99-991f-e8c5a853158f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cccb5b7b-0060-4f99-991f-e8c5a853158f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_cccb5b7b-0060-4f99-991f-e8c5a853158f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 路径拦截处理类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 如果路径属于允许访问列表，则不做拦截，放开访问；
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 否则，获得路径访问所需角色，并返回；如果没有找到该路径所需角色，则拒绝访问。
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomFilterSecurityMetadataSource &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FilterInvocationSecurityMetadataSource {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ApiRepository apiRepository;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Collection&amp;lt;ConfigAttribute&amp;gt; getAttributes(Object object) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         FilterInvocation fi = (FilterInvocation) object; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前请求对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         List&amp;lt;ConfigAttribute&amp;gt; configAttributes = getMatcherConfigAttribute(fi.getRequestUrl(), fi.getRequest().getMethod()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得访问当前路径所需要的角色&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; configAttributes.size() &amp;gt; 0 ? configAttributes : deniedRequest(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前路径所需角色，如果路径没有对应角色，则拒绝访问&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Collection&amp;lt;ConfigAttribute&amp;gt;&lt;span&gt; getAllConfigAttributes() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; supports(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; FilterInvocation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(clazz);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     * 获取当前路径以及请求方式获得所需要的角色
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url 当前路径
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 所需角色集合
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;ConfigAttribute&amp;gt;&lt;span&gt; getMatcherConfigAttribute(String url, String method) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         Set&amp;lt;Authority&amp;gt; authorities = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.根据url的开头去数据库模糊查询相应的api&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         String prefix = url.substring(0, url.lastIndexOf(&quot;/&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         prefix = StringUtil.isEmpty(prefix) ? url : prefix + &quot;%&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         List&amp;lt;Api&amp;gt; apis =&lt;span&gt; apiRepository.findByUriLikeAndMethod(prefix, method);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.查找完全匹配的api，如果没有，比对pathMatcher是否有匹配的结果&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         apis.forEach(api -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             String pattern =&lt;span&gt; api.getUri();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AntPathMatcher().match(pattern, url)) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 List&amp;lt;Resource&amp;gt; resources =&lt;span&gt; api.getResources();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;                 resources.forEach(resource -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                    authorities.addAll(resource.getAuthorities());
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; authorities.stream().map(authority -&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecurityConfig(authority.getId().toString())).collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 默认拒绝访问配置
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;ConfigAttribute&amp;gt;&lt;span&gt; deniedRequest() {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Collections.singletonList(&lt;span&gt;new&lt;/span&gt; SecurityConfig(&quot;ROLE_DENIED&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;AccessDecisionManager：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_04711b0b-b781-44a9-b034-970b6827e413&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04711b0b-b781-44a9-b034-970b6827e413&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_04711b0b-b781-44a9-b034-970b6827e413&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 权限决策处理类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 判断用户的角色，如果为空，则拒绝访问；
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 判断用户所有的角色中是否有一个包含在 访问路径允许的角色集合中；
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 如果有，则放开；否则拒绝访问；
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomAccessDecisionManager &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccessDecisionManager {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decide(Authentication authentication, Object object, Collection&amp;lt;ConfigAttribute&amp;gt; configAttributes) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AccessDeniedException, InsufficientAuthenticationException {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (authentication == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AccessDeniedException(&quot;permission denied&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前用户拥有的角色集合&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         List&amp;lt;String&amp;gt; roleCodes =&lt;span&gt; authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问路径所需要的角色集合&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         List&amp;lt;String&amp;gt; configRoleCodes =&lt;span&gt; configAttributes.stream().map(ConfigAttribute::getAttribute).collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String roleCode : roleCodes) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (configRoleCodes.contains(roleCode)) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AccessDeniedException(&quot;permission denied&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supports(ConfigAttribute attribute) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; supports(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述第19行和第22行分别为UserDetailService处取到的用户拥有的权限和FilterInvocationSecurityMetadataSource取到的访问资源需要的权限，两者对比后即得出用户是否有访问该资源的权限。具体来说，鉴权的整个流程是：访问资源时，会通过AbstractSecurityInterceptor拦截器拦截，其中会调用FilterInvocationSecurityMetadataSource的方法来获取被拦截url所需的全部权限，再调用授权管理器AccessDecisionManager，这个授权管理器会通过spring的全局缓存SecurityContextHolder获取用户的权限信息，还会获取被拦截的url和被拦截url所需的全部权限，然后根据所配的策略（有：一票决定，一票否定，少数服从多数等），如果权限足够，则返回，权限不够则报错并调用权限不足页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;题外话，登录认证可以认为并非认证授权的一部分，而是将身份令牌颁发给客户端的过程，之后客户端拿着身份令牌过来请求资源的时候才进入上面的认证授权环节。不过Spring Secuity中涉及到的认证方法可以简化登录认证的代码编写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 final Authentication authentication = authenticationManager.authenticate(
2         new UsernamePasswordAuthenticationToken(username, password)
3 );
4 
5 SecurityContextHolder.getContext().setAuthentication(authentication);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中authenticationManager由框架提供，框架会根据上面说到的configureAuthentication提供合适的AuthenticationManager实例，认证失败时抛出异常，否则返回Authenticatio令牌并为用户相关的SecurityContext设置令牌。需要注意的是，SecurityContext是存放在ThreadLocal中的，而且在每次权限鉴定的时候都是从ThreadLocal中获取SecurityContext中对应的Authentication所拥有的权限，并且不同的request是不同的线程，为什么每次都可以从ThreadLocal中获取到当前用户对应的SecurityContext呢？在Web应用中这是通过SecurityContextPersistentFilter实现的，默认情况下其会在每次请求开始的时候从session中获取SecurityContext，然后把它设置给SecurityContextHolder，在请求结束后又会将该SecurityContext保存在session中，并且在SecurityContextHolder中清除。当用户第一次访问系统的时候，&lt;span&gt;该用户没有SecurityContext&lt;/span&gt;，待登录成功后，之后的每次请求就可以从session中获取到该SecurityContext并把它赋予给SecurityContextHolder了，由于SecurityContextHolder已经持有认证过的Authentication对象了，所以下次访问的时候也就不再需要进行登录认证了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而上文说到的jwt，却是cookie/session一生黑。它的机制是http请求头部的令牌认证。我们可以借助它在session过期后也能正常的认证授权，而不需要用户重新登录。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_640f5b8f-5fbd-41a9-9a7f-1ad01fa0530b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_640f5b8f-5fbd-41a9-9a7f-1ad01fa0530b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_640f5b8f-5fbd-41a9-9a7f-1ad01fa0530b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JwtAuthenticationTokenFilter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; OncePerRequestFilter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Log logger = LogFactory.getLog(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDetailsService userDetailsService;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JwtTokenUtil jwtTokenUtil;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     @Value(&quot;${jwt.header}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String tokenHeader;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; String requestHeader = request.getHeader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tokenHeader);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         String username = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         String authToken = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestHeader != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; requestHeader.startsWith(&quot;Bearer &quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             authToken = requestHeader.substring(7&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 username =&lt;span&gt; jwtTokenUtil.getUsernameFromToken(authToken);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 logger.error(&quot;an error occured during getting username from token&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e1) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                logger.error(e1.getMessage());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (username != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; SecurityContextHolder.getContext().getAuthentication() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; It is not compelling necessary to load the use details from the database. You could also store the information
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; in the token and read it from it. It's up to you ;)&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             UserDetails userDetails = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userDetailsService.loadUserByUsername(username);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For simple validation it is completely sufficient to just check the token integrity. You don't have to call
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the database compellingly. Again it's up to you ;)&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (jwtTokenUtil.validateToken(authToken, userDetails)) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 UsernamePasswordAuthenticationToken authentication = &lt;span&gt;new&lt;/span&gt; UsernamePasswordAuthenticationToken(userDetails, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, userDetails.getAuthorities());
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 authentication.setDetails(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebAuthenticationDetailsSource().buildDetails(request));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 logger.info(&quot;authenticated user &quot; + username + &quot;, setting security context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                SecurityContextHolder.getContext().setAuthentication(authentication);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然也可以不借助Spring Security，单纯的实现jwt，那样就需要自己实现认证和授权过程了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;在Spring Boot 1.5中，我们可以依靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器，消息转换器等；Spring Boot 2.0 后，该类被标记为@Deprecated。方式改为实现WebMvcConfigurer接口。在Java中，拦截器（Interceptor）和Filter有所不同，前者更贴近AOP概念，而后者只有前置执行。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比&lt;/strong&gt;：Asp.net mvc相对清晰，可控性高；Spring Security隐藏了逻辑顺序，涉及类较多，关键步骤散落各处，层级不清，容易让新手困惑。&lt;em&gt;还有其它的Java认证框架如Shiro，也很流行，此处按过不表。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;非阻塞编程&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在web开发领域，传统的实现异步的方式都比较复杂，比如 Java 中的 NIO，需要了解 channel，selector，buffer 这些概念，或者使用 netty 这样的网络框架。c/c++ 进行异步/非阻塞编程，则需要理解 select，poll，epoll 等概念，开发与维护门槛较高。而且这部分的开发与业务无关，那么封装底层机制，推出一套开发框架的必要性就显而易见了。概念上，.Net习惯称为异步编程（Asynchronous programming），Java称之为响应式编程（Reactive Programming）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.Net/Asynchronous programming&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.Net4.5（C#5.0，2012年）开始，引入async/await关键字，在语法层面上将异步编程变得如同同步处理般清晰流畅，并在短时内即推出了支持主流数据库的异步组件。从接收请求到数据操作，开发人员能很方便的将传统的同步代码迁移为异步模式。之后几年，如Python(3.5)、Nodejs(7.6)等纷纷效仿，成为事实上的语法标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java/Reactive Programming&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们得先从&lt;strong&gt;Stream&lt;/strong&gt;说起，Stream本身和响应式编程没关系，但之后的Reactive Streams在某种程度上继承了它的某些概念。Java 8 引入了Stream，方便集合的聚合操作，它也支持lambda表达式作为操作参数，可以将其看做Iterator。类似的语法在C#中也有，只是C#提供的是无侵入方式，集合本身就支持，更不用说Stream这个概念多么让人混淆。相关资料：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html&quot; target=&quot;_blank&quot;&gt;Java 8 中的 Streams API 详解&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Stream的映射操作有map和flatmap，类似C#中Select和SelectMany的区别。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Reactive Streams&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;历程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;响应式流从2013年开始，作为提供非阻塞背压的异步流处理标准的倡议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在2015年，出版了一个用于处理响应式流的规范和Java API。 Java API 中的响应式流由四个接口组成：Publisher&amp;lt;T&amp;gt;，Subscriber&amp;lt;T&amp;gt;，Subscription和Processor&amp;lt;T,R&amp;gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDK 9在java.util.concurrent包中提供了与响应式流兼容的API，它在java.base模块中。 API由两个类组成：Flow和SubmissionPublisher&amp;lt;T&amp;gt;。Flow类封装了响应式流Java API。 由响应式流Java API指定的四个接口作为嵌套静态接口包含在Flow类中：Flow.Processor&amp;lt;T,R&amp;gt;，Flow.Publisher&amp;lt;T&amp;gt;，Flow.Subscriber&amp;lt;T&amp;gt;和Flow.Subscription。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://projectreactor.io/docs/core/release/reference&quot; target=&quot;_blank&quot;&gt;Reactor&lt;/a&gt;是Reactive Streams的一个实现库。鄙人认为，Reactive Streams针对的场景是无边界数据的enumerate处理，无边界即数据/需求会被不停的生产出来，无法在事前确立循环规则（如循环次数）；另一方面，它又提供了单次处理的处理规则（如每次处理多少条数据/需求）。相关资料：&lt;a href=&quot;https://my.oschina.net/go4it/blog/1606898&quot; target=&quot;_blank&quot;&gt;聊聊reactive streams的backpressure&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring5.0开始提供响应式 Web 编程支持，框架为Spring WebFlux，区别于传统的Spring MVC同步模式。Spring WebFlux基于Reactor，其语法类似JS的Promise，并有一些灵活有用的特性如延时处理返回。具体用法可参看：&lt;a href=&quot;https://blog.csdn.net/get_set/article/details/79480233&quot; target=&quot;_blank&quot;&gt;（5）Spring WebFlux快速上手——响应式Spring的道法术器&lt;/a&gt; 。就文中所说，目前（本文书写时间）Spring Data对MongoDB、Redis、Apache Cassandra和CouchDB数据库提供了响应式数据访问支持，意即使用其它数据库的项目尚无法真正做到异步响应（最关键的IO环节仍为线程同步）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;在Java 7推出异步I/O库，以及Servlet3.1增加了对异步I/O的支持之后，Tomcat等Servlet容器也随后开始支持异步I/O，然后Spring WebMVC也增加了对Reactor库的支持，在Spring MVC3.2版本已经支持异步模式。至于Spring为何又推出一套WebFlux就不得而知了。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比&lt;/strong&gt;：非阻塞编程方面，Java推进速度慢，目前的程度尚不能与几年前的.Net相比，语法上，.Net的async/await相比类Promise语法更简洁，Spring WebFlux在请求响应处理上有一些亮点。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;几个月前（美国当地时间9月25日），Oracle官方宣布 Java 11 (18.9 LTS) 正式发布。Java目前的版本发布策略是半年一版，每三年发布一个长期支持版本，Java 11 是自 Java 8 后的首个长期支持版本。目测Java 8 开始的很多特性都参考了C#，比如异步编程、Lambda、Stream、var等等，这是一个好的现象，相互学习才能进步嘛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.Net的MVC模板引擎为默认为&lt;strong&gt;razor&lt;/strong&gt;，它是专一且多情的，依赖于后端代码。而Java平台常用的有很多，如&lt;strong&gt;FreeMarker&lt;/strong&gt;，它独立于任何框架，可以将它看作复杂版的string.format，用在mvc中就是string.format(v,m)，输出就是v模板绑定m数据后的html；还有Spring Boot自带的&lt;strong&gt;thymeleaf&lt;/strong&gt;，它由于使用了标签属性做为语法，模版页面直接用浏览器渲染，使得前端和后端可以并行开发，窃以为这是兼顾便捷与运行效率的最佳前后端分离开发利器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java8开始，可以在Interface中定义静态方法和默认方法。在接口中，增加default方法， 是为了既有的成千上万的Java类库的类增加新的功能， 且不必对这些类重新进行设计（类似于C#的扩展方法，但灵活度低，耦合度高）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java8的Optional有点类似于.NET的xxxx?，都是简化是否为空判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java ThreadLocal类似于.NET ThreadStaticAttribute，都是提供线程内的局部变量[副本]，这种变量在线程的生命周期内起作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Fork/Join&lt;/strong&gt;：Java 7 引入，方便我们将任务拆成子任务并行执行[并汇总结果后返回]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态引入：import static。导入静态方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用匿名内部类方式初始化对象：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ArrayList&amp;lt;Student&amp;gt; stuList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Student&amp;gt;&lt;span&gt;() {
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;student&quot; + i, random.nextInt(50) + 50&lt;span&gt;));
        }
    }
};&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可参看&lt;a href=&quot;https://www.cnblogs.com/dengyungao/p/7524981.html&quot; target=&quot;_blank&quot;&gt;Java：双括号初始化 /匿名内部类初始化法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java 9 开始支持Http/2，关于Http/2的特点以及它相较于1.0、1.1版本的改进可自行百度，总之效率上提升很大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring3.0引入了&lt;strong&gt;@Configuration&lt;/strong&gt;。Instead of using the XML files, we can use plain Java classes to annotate the configurations by using the @Configuration annotation. If you annotate a class with @Configuration annotation, it indicates that the class is used for defining the beans using the @Bean annotation. This is very much similar to the &amp;lt;bean/&amp;gt; element in the spring XML configurations.当然，xml配置和注解配置可以混用。我们若要复用它处定义的配置类，可使用&lt;strong&gt;@Import&lt;/strong&gt;注解，它的作用类似于将多个XML配置文件导入到单个文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring中的后置处理器&lt;span&gt;&lt;strong&gt;BeanPostProcessor&lt;/strong&gt;，用于在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。Spring Security中还有个&lt;strong&gt;ObjectPostProcessor&lt;/strong&gt;，可以用来修改或者替代通过Java方式配置创建的对象实例，可用在无法预先设置值如需要根据不同条件设置不同值的场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;@Value(&quot;#{}&quot;)与@Value(&quot;${}&quot;)&lt;/strong&gt;：前者用于赋予bean字段的值，后者用于赋予属性文件中定义的属性值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Servlet3.0开始，@WebServlet, @WebFilter, and @WebListener can be enabled by using @ServletComponentScan，不用在web.xml里面配置了。这无关Spring，而是Servlet容器特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Autowired是根据类型进行自动装配的。如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出BeanCreationException异常。我们可以使用@Qualifier指明要装配的类型名称来解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其它参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/icarusliu/article/details/78739006&quot; target=&quot;_blank&quot;&gt;基于注解的Spring Security原理解析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转载请注明本文出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 一文助您成为Java.Net双平台高手&quot; href=&quot;https://www.cnblogs.com/newton/p/9866506.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/newton/p/9866506.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Feb 2019 03:32:00 +0000</pubDate>
<dc:creator>莱布尼茨</dc:creator>
<og:description>写在前面：本文乃标题党，不是月经贴，侧重于Web开发差异，或细节或概述，若有不对之处，还请各位读者本着友好互助的心态批评指正。由于博客园中.Neter较多（个人感觉），因此本文也可以作为.Neter到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/newton/p/9866506.html</dc:identifier>
</item>
</channel>
</rss>