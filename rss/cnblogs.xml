<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程实战 03互斥锁 解决原子性问题 - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/12840672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/12840672.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QT44HS47l_ir08pCZeFU5Q&quot;&gt;Java并发编程实战 01并发编程的Bug源头&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Ryud9nizdqWI25CMLL3E_g&quot;&gt;Java并发编程实战 02Java如何解决可见性和有序性问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/Ryud9nizdqWI25CMLL3E_g&quot;&gt;02Java如何解决可见性和有序性问题&lt;/a&gt;当中，我们解决了可见性和有序性的问题，那么还有一个&lt;code&gt;原子性&lt;/code&gt;问题咱们还没解决。在第一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/QT44HS47l_ir08pCZeFU5Q&quot;&gt;01并发编程的Bug源头&lt;/a&gt;当中，讲到了&lt;strong&gt;把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性&lt;/strong&gt;，那么原子性的问题该如何解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一时刻只有一个线程执行&lt;/strong&gt;这个条件非常重要，我们称为&lt;strong&gt;互斥&lt;/strong&gt;，如果能保护对共享变量的修改时互斥的，那么就能保住原子性。&lt;/p&gt;

&lt;p&gt;我们把一段需要互斥执行的代码称为临界区，线程进入临界区之前，首先尝试获取加锁，若加锁成功则可以进入临界区执行代码，否则就等待，直到持有锁的线程执行了解锁&lt;code&gt;unlock()&lt;/code&gt;操作。如下图：&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/0d5c549f-ba67-4cc1-bc92-a7c6dff01743.jpg&quot; alt=&quot;互斥锁1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是有两个点要我们理解清楚：&lt;strong&gt;我们的锁是什么？要保护的又是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在并发编程世界中，锁和锁要保护的资源是有对应关系的。&lt;br/&gt;首先我们需要把临界区要保护的资源&lt;code&gt;R&lt;/code&gt;标记出来，然后需要创建一把该资源的锁&lt;code&gt;LR&lt;/code&gt;，最后针对这把锁，我们需要在进出临界区时添加加锁&lt;code&gt;lock(LR)&lt;/code&gt;操作和解锁&lt;code&gt;unlock(LR)&lt;/code&gt;操作。如下：&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/d1f11c56-82cd-416a-bb6c-35603efa3e65.jpg&quot; alt=&quot;互斥锁2.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java语言提供的锁技术：synchronized&quot;&gt;Java语言提供的锁技术：synchronized&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;可修饰方法和代码块。加锁&lt;code&gt;lock()&lt;/code&gt;和解锁&lt;code&gt;unlock()&lt;/code&gt;都会在&lt;code&gt;synchronized&lt;/code&gt;修饰的方法或代码块前后自动加上加锁&lt;code&gt;lock()&lt;/code&gt;和解锁&lt;code&gt;unlock()&lt;/code&gt;操作。这样做的好处就是加锁和解锁操作会成对出现，毕竟忘了执行解锁&lt;code&gt;unlock()&lt;/code&gt;操作可是会让其他线程死等下去。&lt;br/&gt;那我们怎么去锁住需要保护的资源呢？在下面的代码中，&lt;code&gt;add1()&lt;/code&gt;非静态方法锁定的是&lt;code&gt;this&lt;/code&gt;对象（当前实例对象），&lt;code&gt;add2()&lt;/code&gt;静态方法锁定的是&lt;code&gt;X.class&lt;/code&gt;(当前类的Class对象)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class X {
    public synchronized void add1() {
        // 临界区
    }
    public synchronized static void add2() {
        // 临界区
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码可以理解为这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class X {
    public synchronized(this) void add() {
        // 临界区
    }
    public synchronized(X.class) static void add2() {
        // 临界区
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/QT44HS47l_ir08pCZeFU5Q&quot;&gt;01 并发编程的Bug源头&lt;/a&gt;文章当中，我们提到过count += 1 存在的并发问题，现在我们尝试使用&lt;code&gt;synchronized&lt;/code&gt;解决该问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Calc {
    private int value = 0;
    public synchronized int get() {
        return value;
    }
    public synchronized void addOne() {
        value += 1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;addOne()&lt;/code&gt;方法被&lt;code&gt;synchronized&lt;/code&gt;修饰后，只有一个线程能执行，所以一定能保证原子性，那么可见性问题呢？在上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/Ryud9nizdqWI25CMLL3E_g&quot;&gt;02 Java如何解决可见性和有序性问题&lt;/a&gt;当中，提到了&lt;strong&gt;管程中的锁规则&lt;/strong&gt;，一个锁的解锁 Happens-Before 于后续对这个锁的加锁。管程，在这里就是&lt;code&gt;synchronized&lt;/code&gt;(管程的在后续的文章中介绍)。根据这个规则，前一个线程执行了&lt;code&gt;value += 1&lt;/code&gt;操作是对后续线程可见的。而查看&lt;code&gt;get()&lt;/code&gt;方法也必须加上&lt;code&gt;synchronized&lt;/code&gt;修饰，否则也没法保证其可见性。&lt;br/&gt;上面这个例子如下图：&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/eb9e54d0-b045-4adb-9f1c-e3e3874056bc.jpg&quot; alt=&quot;互斥锁3.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么可以使用多个锁保护一个资源吗，修改一下上面的例子后，&lt;code&gt;get()&lt;/code&gt;方法使用&lt;code&gt;this&lt;/code&gt;对象锁来保护资源&lt;code&gt;value&lt;/code&gt;，&lt;code&gt;addOne()&lt;/code&gt;方法使用&lt;code&gt;Calc.class&lt;/code&gt;类对象来保护资源&lt;code&gt;value&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Calc {
    private static int value = 0;
    public synchronized int get() {
        return value;
    }
    public static synchronized void addOne() {
        value += 1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子用图来表示：&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/cd2573bd-ed93-4392-a406-5d4e0c8c4237.jpg&quot; alt=&quot;互斥锁4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个例子当中，&lt;code&gt;get()&lt;/code&gt;方法使用的是&lt;code&gt;this&lt;/code&gt;锁，&lt;code&gt;addOne()&lt;/code&gt;方法使用的是&lt;code&gt;Calc.class&lt;/code&gt;锁，因此这两个临界区（方法）并没有互斥性，&lt;code&gt;addOne()&lt;/code&gt;方法的修改对&lt;code&gt;get()&lt;/code&gt;方法是不可见的，所以就会导致并发问题。&lt;br/&gt;&lt;strong&gt;结论：不可使用多把锁保护一个资源，但能使用一把锁保护多个资源&lt;/strong&gt;（这里没写例子，只写了一把锁保护一个资源）&lt;/p&gt;

&lt;p&gt;在银行的业务当中，修改密码和取款是两个再经常不过的操作了，修改密码操作和取款操作是没有关联关系的，没有关联关系的资源我们可以使用不同的互斥锁来解决并发问题。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Account {
    // 保护密码的锁
    private final Object pwLock = new Object();
    // 密码
    private String password;

    // 保护余额的锁
    private final Object moneyLock = new Object();
    // 余额
    private Long money;

    public void updatePassword(String password) {
        synchronized (pwLock) {
            // 修改密码
        }
    }

    public void withdrawals(Long money) {
        synchronized (moneyLock) {
            // 取款
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别使用&lt;code&gt;pwLock&lt;/code&gt;和&lt;code&gt;moneyLock&lt;/code&gt;来保护密码和余额，这样修改密码和修改余额就可以并行了。&lt;strong&gt;使用不同的锁对受保护的资源进行进行更细化管理，能够提升性能，这种锁叫做细粒度锁。&lt;/strong&gt;&lt;br/&gt;在这个例子当中，你可能发现我使用了&lt;code&gt;final Object&lt;/code&gt;来当成一把锁，这里解释一下：&lt;strong&gt;使用锁必须是不可变对象，若把可变对象作为锁，当可变对象被修改时相当于换锁&lt;/strong&gt;，而且使用&lt;code&gt;Long&lt;/code&gt;或&lt;code&gt;Integer&lt;/code&gt;作为锁时，在&lt;code&gt;-128到127&lt;/code&gt;之间时，会使用缓存，详情可查看他们的&lt;code&gt;valueOf()&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;在银行业务当中，除了修改密码和取款的操作比较多之外，还有一个操作比较多的功能就是转账。账户 A 转账给 账户B 100元，账户A的余额减少100元，账户B的余额增加100元，那么这两个账户就是有关联关系的。在没有理解互斥锁之前，写出的代码可能如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Account {
    // 余额
    private Long money;
    public synchronized void transfer(Account target, Long money) {
        this.money -= money;
        if (this.money &amp;lt; 0) {
            // throw exception
        }
        target.money += money;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在转账&lt;code&gt;transfer&lt;/code&gt;方法当中，锁定的是&lt;code&gt;this&lt;/code&gt;对象（用户A），那么这里的目标用户&lt;code&gt;target&lt;/code&gt;（用户B）的能被锁定吗？当然不能。这两个对象是没有关联关系的。正确的操作应该是获取&lt;code&gt;this&lt;/code&gt;锁和&lt;code&gt;target&lt;/code&gt;锁才能去进行转账操作，正确的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Account {
    // 余额
    private Long money;
    public synchronized void transfer(Account target, Long money) {
        synchronized(this) {
            synchronized (target) {
                this.money -= money;
                if (this.money &amp;lt; 0) {
                    // throw exception
                }
                target.money += money;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子当中，&lt;strong&gt;我们需要清晰的明白要保护的资源是什么，只要我们的锁能覆盖所有受保护的资源就可以了&lt;/strong&gt;。&lt;br/&gt;但是你以为这个例子很完美？那就错了，这里面很有可能会发生&lt;strong&gt;死锁&lt;/strong&gt;。你看出来了吗？下一篇文章我就用这个例子来聊聊死锁。&lt;/p&gt;

&lt;p&gt;使用互斥锁最最重要的是：&lt;strong&gt;我们的锁是什么？锁要保护的资源是什么？&lt;/strong&gt;，要理清楚这两点就好下手了。而且锁必须为&lt;strong&gt;不可变对象&lt;/strong&gt;。使用不同的锁保护不同的资源，可以细化管理，提升性能，称为&lt;strong&gt;细粒度锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;br/&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/84344&quot;&gt;极客时间：Java并发编程实战 03互斥锁（上）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/84601&quot;&gt;极客时间：Java并发编程实战 04互斥锁（下）&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.6190476190476&quot;&gt;
&lt;p&gt;个人博客网址： &lt;a href=&quot;https://colablog.cn/&quot;&gt;https://colablog.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我的文章帮助到您，可以关注我的微信公众号，第一时间分享文章给您&lt;br/&gt;&lt;img src=&quot;http://qiniuyun.colablog.cn/%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 00:33:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<og:description>文章系列 &amp;quot;Java并发编程实战 01并发编程的Bug源头&amp;quot; &amp;quot;Java并发编程实战 02Java如何解决可见性和有序性问题&amp;quot; 摘要 在上一篇文章 &amp;quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johnson-lin/p/12840672.html</dc:identifier>
</item>
<item>
<title>垃圾回收技术 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/12840671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/12840671.html</guid>
<description>&lt;p data-lake-id=&quot;b80178130a52a1aea54a2d24ffdfc769&quot;&gt;2011 年，V8 从 stop-the-world 标记切换到增量标志。&lt;/p&gt;
&lt;p data-lake-id=&quot;07c348feb66bdf10c7a42ba61959b08f&quot;&gt;2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。在Chrome 64和Node.js v10中已启用。他将标记时间缩短了60%~70%。还有「Parallel Scavenger」技术，它将新生代的垃圾回收时间缩短了20%~50%。&lt;/p&gt;
&lt;p data-lake-id=&quot;07c348feb66bdf10c7a42ba61959b08f&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;AS555&quot; data-lake-id=&quot;5b80c2c869f66f568192e00f22cdd1db&quot;&gt;&lt;span&gt;全停顿（Stop The World）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;5cd9dac78c781822220a0c10d9cff302&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;特点：&lt;/strong&gt;应用逻辑暂停，全力执行垃圾回收&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;fd3b44c5edea2eb0e1e505e403875d19&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;描述：&lt;/strong&gt;垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）。例如，如果一次GC需要100ms，应用逻辑就会暂停100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d5588a6d08a7f151c4769086e30f51e0&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;全停顿的策略导致垃圾回收中不能及时响应用户的输入，而且如果有动画会造成动画效果的卡顿&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d5588a6d08a7f151c4769086e30f51e0&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;bB7kW&quot; data-lake-id=&quot;2155f067747473e608faad5fbc6e8fcf&quot;&gt;&lt;span&gt;增量垃圾回收（Incremental）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;a2e9490fa2c47b2228d6392b04f30e55&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;特点：&lt;/strong&gt;垃圾回收任务和JS逻辑交错的进入主线程执行&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;b683de78ad19afe82f61c3dc58781741&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;描述：&lt;/strong&gt;增量式垃圾回收是主线程间歇性的去做少量的垃圾回收的方式。不会在增量式垃圾回收的时候执行整个垃圾回收的过程，只是整个垃圾回收过程中的一小部分工作。做这样的工作是极其困难的，因为 JavaScript 也在做增量式垃圾回收的时候同时执行，这意味着堆的状态已经发生了变化，这有可能会导致之前的增量回收工作完全无效。从图中可以看出并没有减少主线程暂停的时间（事实上，通常会略微增加），只会随着时间的推移而增长。但这仍然是解决问题的的好方法，通过 JavaScript 间歇性的执行，同时也间歇性的去做垃圾回收工作，JavaScript 的执行仍然可以在用户输入或者执行动画的时候得到及时的响应。如果直接进行长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将全停顿标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;8b127323e4773ea41d3b490c7343b065&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;1.并没有减少主线程暂停的时间（事实上，通常会略微增加）。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;fa3d6b9bcffa46de1842b16b1caab0db&quot;&gt;        2.由于写入屏障(Write-barrier )机制的成本，增量标记可能会降低应用程序的吞吐量。&lt;/p&gt;
&lt;p data-lake-id=&quot;6e0160b26e29817fb45a404e5d7b4ead&quot;&gt; &lt;/p&gt;
&lt;p data-lake-id=&quot;514994c4c3d855b95078581b7087d3c8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F305942%2F1588728535548-c96542f1-4508-4fda-9432-2695afa60508.jpeg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A244%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A746%2C%22height%22%3A253%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728535548-c96542f1-4508-4fda-9432-2695afa60508.jpeg&quot; alt=&quot;&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728535548-c96542f1-4508-4fda-9432-2695afa60508.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;978da54b4b23e5d9265f630e629daa1a&quot;&gt; &lt;/p&gt;
&lt;p data-lake-id=&quot;ea2e36bf30612c7ef617d9a071c9e0f9&quot;&gt;由于写入屏障(Write-barrier )机制的成本，增量标记可能会降低应用程序的吞吐量。但通过使用额外的工作线程可以提高吞吐量和暂停时间。以下两种方法可以在工作线程上进行标记：并行标记和并发标记。&lt;/p&gt;
&lt;p data-lake-id=&quot;bed03cedd2f478b0411cbd4becd6839d&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;56kUx&quot; data-lake-id=&quot;c06a2433a920388ce76d55dae749391c&quot;&gt;&lt;span&gt;并行标记（Parallel）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;990102d81886ba87b7a337c4dd2b7cc3&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;特点：&lt;/strong&gt;主线程和协助线程在一时间做同样的任务&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;700c1a39ebcd7258b929e6dd2c0f6f4d&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;描述：&lt;/strong&gt;并行是主线程和协助线程同时执行同样的工作，但是这仍然是一种 ‘stop-the-world’ 的垃圾回收方式，但是垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。因为没有 JavaScript 的执行，因此只要确保同时只有一个协助线程在访问对象就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;596d808cf3fcdb9bb3257fde6d94a5e0&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F305942%2F1588728536011-7ec8558d-ff07-409a-9e10-545dd136ee32.jpeg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A223%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A1400%2C%22height%22%3A434%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728536011-7ec8558d-ff07-409a-9e10-545dd136ee32.jpeg&quot; alt=&quot;&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728536011-7ec8558d-ff07-409a-9e10-545dd136ee32.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;596d808cf3fcdb9bb3257fde6d94a5e0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F305942%2F1588728536011-7ec8558d-ff07-409a-9e10-545dd136ee32.jpeg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A223%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A1400%2C%22height%22%3A434%7D&quot;&gt;并发标记（Concurrent）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d406d3875e7385addd3df239e48220dc&quot;&gt;&lt;strong&gt;特点：&lt;/strong&gt;垃圾回收任务完全发生在后台，主线程可以自由的执行JavaScript。&lt;/p&gt;
&lt;p data-lake-id=&quot;30243a2ad1599ce096a9bfd9663a1597&quot;&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;&lt;strong&gt;描述：&lt;/strong&gt;并发是主线程一直执行 JavaScript，而辅助线程在后台完全的执行垃圾回收。这种方式是这三种技术中最难的一种，JavaScript 堆里面的内容随时都有可能发生变化，从而使之前做的工作完全无效。最重要的是，现在有读/写竞争（read/write races），主线程和辅助线程极有可能在同一时间去更改同一个对象。这种方式的优势也非常明显，主线程不会被挂起，JavaScript 可以自由地执行 ，尽管为了保证同一对象同一时间只有一个辅助线程在修改而带来的一些同步开销。&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;7225e2ec1eeb73c1f94b129377f3266e&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fjpeg%2F305942%2F1588728535511-c1791ac9-20fc-43b2-98db-5c546637056c.jpeg%22%2C%22originWidth%22%3A720%2C%22originHeight%22%3A288%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A1300%2C%22height%22%3A520%7D&quot;&gt;&lt;img class=&quot;image lake-drag-image&quot; src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728535511-c1791ac9-20fc-43b2-98db-5c546637056c.jpeg&quot; alt=&quot;&quot; data-role=&quot;image&quot; data-raw-src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/305942/1588728535511-c1791ac9-20fc-43b2-98db-5c546637056c.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;pgplG&quot; data-lake-id=&quot;401ba17271e5e730f0642ee07e7f359f&quot;&gt;&lt;span&gt;Chrome当前使用的技术&lt;/span&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;73d0b5ebba8e93c409cb3dc329d59d74&quot;&gt;现今，V8 在新生代垃圾回收中使用&lt;strong&gt;并行标记&lt;/strong&gt;，每个协助线程会将所有的活动对象都移动到 ‘To-Space’。在每一次尝试将活动对象移动到 ‘To-Space’ 的时候必须通确保原子化的读和写以及比较和交换操作。不同的协助线程都有可能通过不同的路径找到相同的对象，并尝试将这个对象移动到 ‘To-Space’；无论哪个协助线程成功移动对象到 ‘To-Space’，都必须更新这个对象的指针，并且去维护移动这个活动对象所留下的转发地址。以便于其他协助线程可以找到该活动对象更新后的指针。为了快速的给幸存下来的活动对象分配内存，清理任务会使用线程局部分配缓冲区。&lt;/p&gt;
&lt;p data-lake-id=&quot;b90bebbc068fddbc9750409bfc31bd4e&quot;&gt;V8 中的主垃圾回收器主要使用&lt;strong&gt;并发标记&lt;/strong&gt;，一旦堆的动态分配接近极限的时候，将启动并发标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用。在 JavaScript 执行的时候，并发标记在后台进行。写入屏障（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dl.acm.org/citation.cfm%3Fid%3D2025255&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;write barriers&lt;/a&gt;）技术在辅助线程在进行并发标记的时候会一直追踪每一个 JavaScript 对象的新引用。当并发标记完成或者动态分配到达极限的时候，主线程会执行最终的快速标记步骤；在这个阶段主线程会被暂停，这段时间也就是主垃圾回收器执行的所有时间。在这个阶段主线程会再一次的扫描根集以确保所有的对象都完成了标记；然后辅助线程就会去做更新指针和整理内存的工作。并非所有的内存页都会被整理，加入到空闲列表的内存页就不会被整理。在暂停的时候主线程会启动并发清理的任务，这些任务都是并发执行的，并不会影响并行内存页的整理工作和 JavaScript 的执行。&lt;/p&gt;
&lt;h3 id=&quot;gdoJy&quot; data-lake-id=&quot;0e92c2697f2a337824efc94ee24d7a0e&quot;&gt;&lt;span&gt;名词解析&lt;/span&gt;&lt;/h3&gt;
&lt;p data-lake-id=&quot;1c145f20bed24e2a4147fa448d7e757d&quot;&gt;&lt;strong&gt;写入屏障（&lt;/strong&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//dl.acm.org/citation.cfm%3Fid%3D2025255&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;write barriers&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;）&lt;/strong&gt;: &lt;strong&gt;内存屏障（英语：Memory barrier）&lt;/strong&gt;，也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行&lt;/p&gt;
&lt;h3 id=&quot;P34Xc&quot; data-lake-id=&quot;24365ffe74bcb80d4bde859f239d3957&quot;&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;0.1701030927835&quot;&gt;
&lt;p data-lake-id=&quot;95bcc9ee5ee05487d2b3e76b33e821d0&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_33724059/article/details/86720543&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/weixin_33724059/article/details/86720543&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e3298726e01196fbc412e149055e293d&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/b8ed21e8a4fb&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/b8ed21e8a4fb&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;5c585786983fc0ede08bf315eb14863e&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55917130&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/55917130&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;168ff93a448f9d1ee5d9e0337315d83d&quot;&gt;&lt;a href=&quot;https://www.oschina.net/translate/v8-javascript-engine&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.oschina.net/translate/v8-javascript-engine&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 07 May 2020 00:33:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>发展史 2011 年，V8 从 stop-the-world 标记切换到增量标志。 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。在Chrome 64和Node.js v10中已启</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/12840671.html</dc:identifier>
</item>
<item>
<title>详解十大经典数据挖掘算法之——Apriori - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12840498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12840498.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;机器学习专题的第19篇&lt;/strong&gt;文章，我们来看经典的Apriori算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apriori算法号称是&lt;strong&gt;十大数据挖掘算法之一&lt;/strong&gt;，在大数据时代威风无两，哪怕是没有听说过这个算法的人，对于那个著名的啤酒与尿布的故事也耳熟能详。但遗憾的是，随着时代的演进，大数据这个概念很快被机器学习、深度学习以及人工智能取代。即使是拉拢投资人的创业者也很少会讲到这个故事了，虽然时代的变迁令人唏嘘，但是这并不妨碍它是一个优秀的算法。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/6/171e9b1b87996a80?w=1064&amp;amp;h=665&amp;amp;f=jpeg&amp;amp;s=148902&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来简单回顾一下这个故事，据说在美国的沃尔玛超市当中，啤酒和尿布经常被摆放在同一个货架当中。如果你仔细观察就会觉得很奇怪，啤酒和尿布无论是从应用场景还是商品本身的属性来分都不应该被放在一起，为什么超市要这么摆放呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;看似不合理的现象背后往往都有更深层次的原因&lt;/strong&gt;，据说是沃尔玛引进了一种全新的算法，它分析了所有顾客在超市消费的记录，然后计算商品之间的关联性，发现这两件商品的关联性非常高。也就是说有大量的顾客会同时购买啤酒和尿布这两种商品，所以经过数据的分析，沃尔玛下令将这两个商品放在同一个货架上进行销售。果然这么一搞之后，&lt;strong&gt;两种商品的销量都提升了&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个在背后分析数据，出谋划策充当军师一样决策的算法就是Apriori算法。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;关联分析与条件概率&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先把这个故事的真假放在一边，先来分析一下故事背后折射出来的信息。我们把问题进行抽象，沃尔玛超市当中的商品种类大概有数万种，我们的算法做的其实是根据售卖数据计算分析这些种类之间的相关性。专业术语叫做&lt;strong&gt;关联分析&lt;/strong&gt;，这个从字面上很好理解。但从关联分析这个角度出发，我们会有些不一样的洞见。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前都学过条件概率，我们是不是可以用&lt;strong&gt;条件概率&lt;/strong&gt;来反应两个物品之间的关联性呢？比如，我们用A表示一种商品，B表示另外一种商品，我们完全可以根据所有订单的情况计算出P(A|B)和P(B|A)，也就是说用户在购买了A的情况下会购买B的概率以及在购买B的情况下会购买A的概率。这样做看起来也很科学啊，为什么不这样做呢，还要引入什么新的算法呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就是算法必要性问题，这个问题解决不了，我们好像会很难说服自己去学习一门新的算法。其实回答这个问题很简单，就是&lt;strong&gt;成本&lt;/strong&gt;。大型超市当中的商品一般都有几万种，而这几万种商品的销量&lt;strong&gt;差异巨大&lt;/strong&gt;。一些热门商品比如水果、蔬菜的销量可能是冷门商品，比如冰箱、洗衣机的上千倍甚至是上万倍。如果我们要计算两两商品之间的相关性显然是一个巨大的开销，因为对于每两个商品的组合，我们都需要遍历一遍整个数据集，拿到商品之间共同销售的记录，从而计算条件概率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设商品的种类数是一万，超市的订单量也是一万好了，那么两两商品之间的组合就有一亿条，如果再乘上每次计算需要遍历一次整个数据集，那么整个运算的复杂度大概会是一万亿。如果再考虑多个商品的组合，那这个数字更加可怕。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际上一个大型超市订单量肯定不是万级别的，至少也是十万或者是百万量级甚至更多。所以这个计算的复杂度是非常庞大的，如果考虑计算带来的开销，这个问题&lt;strong&gt;在商业上就是不可解的&lt;/strong&gt;。因为即使算出来结果带来的收益也远远无法负担付出的计算代价，这个计算代价可能比很多人想得大得多，即使是使用现成的云计算服务，也会带来极为昂贵的开销。如果考虑数据安全，不能使用其他公司的计算服务的话，那么自己维护这些数据和人工带来的消耗也是常人难以想象的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要得出切实可行的结果，那么优化算法一定是必须的，否则可能没有一家超市愿意付出这样的代价。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍Apriori算法之前，我们可以先试着自己思考一下这个问题的解法。我真的试着想过，但是我没有得到很好的答案，对比一下Apriori算法我才发现，这并非是我个人的问题，而是因为我们的思维有误区。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你做过LeetCode，学过算法导论和数据结构，那么你在思考问题的时候，&lt;strong&gt;往往会情不自禁地从最优解以及最佳解的方向出发&lt;/strong&gt;。反应在这个问题当中，你可能会倾向于找到所有高关联商品，或者是计算出所有商品对之间的关联性。但是在这个问题当中，前提可能就是错的。因为答案的完备性和复杂度之间往往是挂钩的，找出所有的答案必然会带来更多的开销，而且落实在实际当中，牺牲一些完备性也是有道理的。因为对于超市而言，更加关注高销量的商品，比如电冰箱和洗衣机，即使得出结论它们和某些商品关联性很高对超市来说也没有太大意义，因为电冰箱和洗衣机一天总共也卖不出多少台。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你仔细思考就会发现这个问题和算法的背景比我们一开始想的和理解的要深刻得多，所以让我们带着一点点敬畏之心来看看这个算法的详细吧。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;频繁项集与关联规则&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们具体了解算法的原理之前，我们先来熟悉两个术语。第一个属于叫做&lt;strong&gt;频繁项集&lt;/strong&gt;，英文是frequent item sets。这个翻译很接地气，我们直接看字面意思应该就能理解。意思是经常会出现在一起的物品的集合。第二个属于叫做&lt;strong&gt;关联规则&lt;/strong&gt;，也就是两个物品之间可能存在很强的关联关系。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用啤酒和尿布的故事举个例子，比如很多人经常一起购买啤酒和尿布，那么啤酒和尿布就经常出现在人们的购物单当中。所以啤酒和尿布就属于同一个频繁项集，而一个人买了啤酒很有可能还会购买尿布，啤酒和尿布之间就存在一个关联规则。表示它们之间存在很强的内在联系。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了频繁项集和关联规则我们会做什么事情？很简单会去计算它们的&lt;strong&gt;概率&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个集合而言，我们要考虑的是整个集合出现的概率。在这个问题场景当中，它的计算非常简单。即用集合当中所有元素一起出现的次数，除以所有的数据条数。这个概率也有一个术语，叫做&lt;strong&gt;支持度&lt;/strong&gt;，英文称作support。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个关联规则而言，它指的是A物品和B物品之间的内在关系，其实也就是条件概率。所以A-&amp;gt;B关联规则的概率就是P(AB)/P(A)和条件概率的公式一样，不过在这个问题场景当中，也有一个术语，叫做&lt;strong&gt;置信度&lt;/strong&gt;，英文是confidence。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实confidence也好，support也罢，我们都可以简单地理解成出现的概率。&lt;strong&gt;这是一个计算概率的模型&lt;/strong&gt;，可以认为是条件概率运算的优化。其中关联规则是基于频繁项集的，所以我们可以先把关联规则先放一放，先来主要看频繁项集的求解过程。既然频繁项集的支持度本质上也是一个概率，那么我们就可以使用一个阈值来进行限制了。比如我们规定一个阈值是0.5，那么凡是支持度小于0.5的集合就不用考虑了。我们先用这个支持度过一遍全体数据，找出满足支持度限制的单个元素的集合。之后当我们寻找两个元素的频繁项集的时候，它的候选集就不再是全体商品了，而只有那些包含单个元素的频繁项集。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，如果我们要寻找三项的频繁项集，它的候选集就是含有两项元素的频繁项集，以此类推。表面上看，我们是把候选的范围限制在了频繁项集内从而简化了运算。其实它背后有一个很深刻的逻辑，即&lt;strong&gt;不是频繁项集的集合，一定不可能构成其他的频繁项集&lt;/strong&gt;。比如电冰箱每天的销量很低，它和任何商品都不可能构成频繁项集。这样我们就可以排除掉所有那些不是频繁项集的所有情况，大大减少了运算量。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/6/171e9b1b9a033e8c?w=750&amp;amp;h=720&amp;amp;f=jpeg&amp;amp;s=57193&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图当中的23不是频繁项集，那么对应的123和023显然也都不是频繁项集。其实我们把这些非频繁的项集去掉，剩下的就是频繁项集。所以我们从正面或者是反面理解都可以，逻辑的内核是一样的。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Apriori算法及实现&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实Apriori的算法精髓就在上面的表述当中，也就是&lt;strong&gt;根据频繁项集寻找新的频繁项集&lt;/strong&gt;。我们整理一下整个算法的流程，然后一点点用代码来实现它，对照代码和流程很容易就搞清楚了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们来创建一批假的数据用来测试：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;create_dataset&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们要生成只有一个项的所有集合。这一步很好理解，我们需要对所有有交易的商品生成一个清单，也就是&lt;strong&gt;将所有交易记录中的商品购买记录进行去重&lt;/strong&gt;。由于我们生成的结果在后序会作为dict的key，并且我们知道set也是可变对象，也是不可以作为dict中的key的。所以我们要做一点转换，将它转换成&lt;strong&gt;frozenset&lt;/strong&gt;，它可以认为是不可以修改的set。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;individual_components&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(dataset)&lt;/span&gt;:&lt;/span&gt;
    ret = []
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; data &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dataset:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; data:
            ret.append((i))
    
    ret = set(ret)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [frozenset((i, )) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; ret]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行过后，我们会得到这样一个序列：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;[frozenset({&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}), frozenset({&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}), frozenset({&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}), frozenset({&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;}), frozenset({&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;})]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个序列是长度为1的所有集合，我们称它为C1，这里的C就是component，也就是集合的意思。下面我们要生成的f1，也就是&lt;strong&gt;长度为1的频繁集合&lt;/strong&gt;。频繁集合的选取是根据最小支持度过滤的，所以我们下面要实现的就是计算Ck中每一个集合的支持度，然后过滤掉那些支持度不满足要求的集合。这个应该也很好理解：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;filter_components_with_min_support&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(dataset, components, min_support)&lt;/span&gt;:&lt;/span&gt;
    
    
    dataset = list(map(set, dataset))
    
    components_dict = defaultdict(int)

    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; data &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dataset:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; components:
            
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i &amp;lt;= data:
                components_dict[i] += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;rows = len(dataset)
frequent_components = []
supports = {}
&amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;for&amp;lt;/span&amp;gt; k,v &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;in&amp;lt;/span&amp;gt; components_dict.items():
    &amp;lt;span class=&quot;hljs-comment&quot; style=&quot;color: #998; font-style: italic; line-height: 26px;&quot;&amp;gt;# 支持度就是集合在数据集中的出现次数除以数据总数&amp;lt;/span&amp;gt;
    support = v / rows
    &amp;lt;span class=&quot;hljs-comment&quot; style=&quot;color: #998; font-style: italic; line-height: 26px;&quot;&amp;gt;# 保留满足支持度要求的数据&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;if&amp;lt;/span&amp;gt; support &amp;amp;gt;= min_support:
        frequent_components.append(k)
    supports[k] = support
&amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;return&amp;lt;/span&amp;gt; frequent_components, supports
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;br/&gt;&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将支持度设置成0.5来执行一下，会得到以下结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/6/171e9b1ba352b045?w=1682&amp;amp;h=350&amp;amp;f=jpeg&amp;amp;s=60363&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现数据中的4被过滤了，因为它只出现了1次，支持度是0.25，达不到我们设置的阈值，和我们的预期一致。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们有了方法创建长度为1的项集，也有了方法根据支持度过滤非频繁的项集，接下来要做的已经很明显了，我们&lt;strong&gt;要根据长度为1的频繁项集生成长度为2的候选集&lt;/strong&gt;，然后再利用上面的方法过滤得到长度为2的频繁项集，再通过长度为2的频繁项集生成长度为3的候选集，如此往复，直到所有的频繁项集都被挖掘出来为止。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这个思路，我们接下来还有两个方法要做，一个是根据长度为n的频繁项集生成长度n+1候选集的方法，另一个方法是利用这些方法挖掘所有频繁项集的方法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看根据长度为n的项集生成n+1候选集的方法，这个也很好实现，我们只需要用所有元素依次加入现有的集合当中即可。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;generate_next_componets&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(components)&lt;/span&gt;:&lt;/span&gt;
    
    individuals = individual_components(components)
    storage = set()
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; individuals:
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; components:
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i &amp;lt;= c:
                &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;
            cur = i | c
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; cur &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; storage:
                storage.add(cur)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;return&amp;lt;/span&amp;gt; list(storage)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;br/&gt;&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些方法都有了之后，剩下的就很好办了，我们只需要重复调用上面的方法，直到找不到更长的频繁项集为止。我们直接来看代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;apriori&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(dataset, min_support)&lt;/span&gt;:&lt;/span&gt;
    
    individuals = individual_components(dataset)
    
    f1, support_dict = filter_components_with_min_support(dataset, individuals, min_support)
    frequent = [f1]
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:
        
        next_components = generate_next_componets(frequent[&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;])
        
        components, new_dict = filter_components_with_min_support(dataset, next_components, min_support)
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; len(components) == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
        
        support_dict.update(new_dict)
        frequent.append(components)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; frequent, support_dict
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们运行一下这个方法查看一下结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/6/171e9b1bad257f46?w=1780&amp;amp;h=632&amp;amp;f=jpeg&amp;amp;s=126051&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色框中就是我们从数据集合当中挖掘出的频繁项集了。在一些场景当中我们除了想要知道频繁项集之外，可能还会想要知道关联规则，看看哪些商品之间存在隐形的强关联。我们根据类似的思路可以设计出算法来实现关联规则的挖掘。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;关联规则&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了频繁项集的概念之后再来算关联规则就简单了，我们首先来看一个很简单的变形。由于我们需要计算频繁项集之间的置信度，也就是条件概率。我们都知道P(A|B) = P(AB) / P(B)，这个是条件概率的基本公式。这里的P(A) = 出现A的数据条数/ 总条数，其实也就是&lt;strong&gt;A的支持度&lt;/strong&gt;。所以我们可以&lt;strong&gt;用支持度来计算置信度&lt;/strong&gt;，由于刚刚我们在计算频繁项集的时候算出了所有频繁项集的支持度，所以我们可以用这份数据来计算置信度，这样会简单很多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来写出置信度的计算公式，它非常简单：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;calculate_confidence&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(comp, subset, support_dict)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; float(support_dict[comp]) / support_dict[comp-subset]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的comp表示集合，subset表示我们要推断的项。也就是我们挖掘的是comp-item这个集合与subset集合之间的置信度。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们来看候选规则的生成方法，它和前面生成候选集合的逻辑差不多。我们拿到频繁项集之后，扣除其中的一个子集，将它作为一个候选的规则。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;generate_rules&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(components, subset)&lt;/span&gt;:&lt;/span&gt;
    all_set = []
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; st &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; subset:
        all_set += st
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;rules = []
&amp;lt;span class=&quot;hljs-comment&quot; style=&quot;color: #998; font-style: italic; line-height: 26px;&quot;&amp;gt;# 遍历所有子集&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;for&amp;lt;/span&amp;gt; i &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;in&amp;lt;/span&amp;gt; all_set:
    &amp;lt;span class=&quot;hljs-comment&quot; style=&quot;color: #998; font-style: italic; line-height: 26px;&quot;&amp;gt;# 遍历频繁项集&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;for&amp;lt;/span&amp;gt; comp &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;in&amp;lt;/span&amp;gt; components:
        &amp;lt;span class=&quot;hljs-comment&quot; style=&quot;color: #998; font-style: italic; line-height: 26px;&quot;&amp;gt;# 如果子集关系成立，则生成了一条候选规则&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;if&amp;lt;/span&amp;gt; i &amp;amp;lt;= comp:
            rules.append((comp, i))
&amp;lt;span class=&quot;hljs-keyword&quot; style=&quot;color: #333; font-weight: bold; line-height: 26px;&quot;&amp;gt;return&amp;lt;/span&amp;gt; rules
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;br/&gt;&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们把上面两个方法串联在一起，先生成所有的候选规则，再根据置信度过滤掉符合条件的关联规则。利用之前频繁项集时候生成的数据，很容易实现这点。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mine_rules&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(frequent, support_dict, min_confidence)&lt;/span&gt;:&lt;/span&gt;
    rules = []
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, len(frequent)):
        
        candidate_rules = generate_rules(frequent[i], frequent[:i])
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; comp, item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; candidate_rules:
            confidence = calculate_confidence(comp, item, support_dict)
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; confidence &amp;gt;= min_confidence:
                  rules.append([comp-item, item, confidence])
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; rules
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们运行一下这个方法，看一下结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/6/171e9b1bb0a458c0?w=1500&amp;amp;h=510&amp;amp;f=jpeg&amp;amp;s=142418&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果来看还不错，我们挖掘出了所有的关联规则。要注意一点&lt;strong&gt;A-&amp;gt;B和B-&amp;gt;A是两条不同的规则&lt;/strong&gt;，这并不重复。举个简单的例子，买乒乓拍的人往往都会买乒乓球，但是买乒乓球的人却并不一定会买乒乓拍，因为乒乓拍比乒乓球贵得多。而且乒乓球是消耗品，乒乓拍不是。所以乒乓拍可以关联乒乓球，但反之不一定成立。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;结尾、升华&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Apriori算法和它的应用场景就讲完了。这个算法的原理并不复杂，代码也不困难，没有什么高深的推导或者是晦涩的运算，但是算法背后的逻辑并不简单。怎么样为一个复杂的场景涉及简单的指标？怎么样缩小我们计算的范围？怎么样衡量数据的价值？其实这些并不是空穴来风，显然算法的设计者是付出了大量思考的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们顺着解法出发去试着&lt;strong&gt;倒推当时设计者的思考过程&lt;/strong&gt;，你会发现看似简单的问题背后其实并不简单，看似自然而然的道理，也并不自然，这些看似寻常的背后都隐藏着逻辑，这些背后的思考和逻辑，才是算法真正宝贵的部分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，原创不易，需要你的&lt;strong&gt;一个关注&lt;/strong&gt;，你的举手之劳对我来说很重要。&lt;/p&gt;
</description>
<pubDate>Thu, 07 May 2020 00:13:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是机器学习专题的第19篇文章，我们来看经典的Apriori算法。 Apriori算法号称是十大数据挖掘算法之一，在大数据时代威风无两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12840498.html</dc:identifier>
</item>
<item>
<title>编程坑太多，Map 集合怎么也有这么多坑？一不小心又踩了好几个！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12840460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12840460.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453031-2140795803.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.125&quot;&gt;
&lt;p&gt;点赞再看，养成习惯，微信搜索『&lt;strong&gt;程序通事&lt;/strong&gt;』,关注就完事了！&lt;br/&gt;&lt;a href=&quot;https://sourl.cn/aRByt3&quot;&gt;点击查看更多历史文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/q6ui4gL96Oa0hDbAeJwz-Q&quot;&gt;List 踩坑文章&lt;/a&gt;中，我们提到几个比较容易踩坑的点。作为 List 集合好兄弟 Map，我们也是天天都在使用，一不小心也会踩坑。&lt;/p&gt;
&lt;p&gt;今天我就来总结这些常见的坑，再捞自己一手，防止后续同学再继续踩坑。&lt;/p&gt;
&lt;p&gt;本文设计知识点如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453235-89975577.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不是所有的-map-都能包含--null&quot;&gt;不是所有的 Map 都能包含 null&lt;/h2&gt;
&lt;p&gt;这个踩坑经历还是发生在实习的时候，那时候有这样一段业务代码，功能很简单，从 XML 中读取相关配置，存入 Map 中。&lt;/p&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453411-172961324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那时候正好有个小需求，需要改动一下这段业务代码。改动的过程中，突然想到 &lt;code&gt;HashMap&lt;/code&gt; 并发过程可能导致死锁的问题。&lt;/p&gt;
&lt;p&gt;于是改动了一下这段代码，将 &lt;code&gt;HashMap&lt;/code&gt; 修改成了 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;美滋滋提交了代码，然后当天上线的时候，就发现炸了。。。&lt;/p&gt;
&lt;p&gt;应用启动过程发生 &lt;strong&gt;NPE&lt;/strong&gt; 问题，导致应用启动失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453568-1896430510.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据异常日志，很快就定位到了问题原因。由于 XML 某一项配置问题，导致读取元素为 null，然后元素置入到 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 中，抛出了空指针异常。&lt;/p&gt;
&lt;p&gt;这不科学啊！ 之前 &lt;code&gt;HashMap&lt;/code&gt; 都没问题，都可以存在 &lt;strong&gt;null&lt;/strong&gt;，为什么它老弟 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 就不可以？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453682-1453744095.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻阅了一下 &lt;code&gt;ConcurrentHashMap#put&lt;/code&gt; 方法的源码，开头就看到了对 KV 的判空校验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453804-1878382814.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，不知道你有没有疑惑，为什么 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 与 &lt;code&gt;HashMap&lt;/code&gt; 设计的判断逻辑不一样？&lt;/p&gt;
&lt;p&gt;求助了下万能的 Google，找到 &lt;strong&gt;Doug Lea&lt;/strong&gt; 老爷子的回答：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074453989-1612828950.jpg&quot; alt=&quot;来源:http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;null 会引起歧义，如果 value 为 null，我们无法得知是值为 null，还是 key 未映射具体值？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doug Lea&lt;/strong&gt; 并不喜欢 null，认为 null 就是个隐藏的炸弹。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到 &lt;strong&gt;Josh Bloch&lt;/strong&gt; 正是 &lt;code&gt;HashMap&lt;/code&gt; 作者，他与 &lt;strong&gt;Doug Lea&lt;/strong&gt; 在 null 问题意见并不一致。&lt;/p&gt;
&lt;p&gt;也许正是因为这些原因，从而导致 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 与 &lt;code&gt;HashMap&lt;/code&gt; 对于 null 处理并不一样。&lt;/p&gt;
&lt;p&gt;最后贴一下常用 Map 子类集合对于 null 存储情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454124-572637654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的实现类约束，都太不一样，有点不好记忆。其实只要我们在加入元素之前，主动去做空指针判断，不要在 Map 中存入 null，就可以从容避免上面问题。&lt;/p&gt;
&lt;h2 id=&quot;自定义对象为-key&quot;&gt;自定义对象为 key&lt;/h2&gt;
&lt;p&gt;先来看个简单的例子，我们自定义一个 &lt;code&gt;Goods&lt;/code&gt; 商品类，将其作为 Key 存在 Map 中。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454358-1698753993.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码中，第二次我们加入一个相同的商品，原本我们期望新加入的值将会替换原来旧值。但是实际上这里并没有替换成功，反而又加入一对键值。&lt;/p&gt;
&lt;p&gt;翻看一下 &lt;code&gt;HashMap#put&lt;/code&gt; 的源码：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下代码基于 JDK1.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454567-216911391.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里首先判断 &lt;code&gt;hashCode&lt;/code&gt; 计算产生的 hash，如果相等，再判断 &lt;code&gt;equals&lt;/code&gt; 的结果。但是由于 &lt;code&gt;Goods&lt;/code&gt;对象未重写的&lt;code&gt;hashCode&lt;/code&gt; 与 &lt;code&gt;equals&lt;/code&gt; 方法，默认情况下 &lt;code&gt;hashCode&lt;/code&gt; 将会使用父类对象 Object 方法逻辑。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;Object#hashCode&lt;/code&gt; 是一个 &lt;strong&gt;native&lt;/strong&gt; 方法，默认将会为每一个对象生成不同 &lt;strong&gt;hashcode&lt;/strong&gt;（&lt;strong&gt;与内存地址有关&lt;/strong&gt;），这就导致上面的情况。&lt;/p&gt;
&lt;p&gt;所以如果需要使用自定义对象做为 Map 集合的 key，那么一定记得&lt;strong&gt;重写&lt;/strong&gt;&lt;code&gt;hashCode&lt;/code&gt; 与 &lt;code&gt;equals&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;然后当你为自定义对象重写上面两个方法，接下去又可能踩坑另外一个坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454793-151018771.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用 lombok 的 &lt;code&gt;EqualsAndHashCode&lt;/code&gt; 自动重写 &lt;code&gt;hashCode&lt;/code&gt; 与 &lt;code&gt;equals&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码中，当 Map 中置入自定义对象后，接着修改了商品金额。然后当我们想根据同一个对象取出 Map 中存的值时，却发现取不出来了。&lt;/p&gt;
&lt;p&gt;上面的问题主要是因为 &lt;code&gt;get&lt;/code&gt; 方法是根据对象 的 hashcode 计算产生的 hash 值取定位内部存储位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074454913-1230171073.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们修改了金额字段后，导致 &lt;code&gt;Goods&lt;/code&gt; 对象 hashcode 产生的了变化，从而导致 get 方法无法获取到值。&lt;/p&gt;
&lt;p&gt;通过上面两种情况，可以看到使用自定义对象作为 Map 集合 key，还是挺容易踩坑的。&lt;/p&gt;
&lt;p&gt;所以尽量避免使用自定义对象作为 Map 集合 key，如果一定要使用，记得重写 &lt;code&gt;hashCode&lt;/code&gt; 与 &lt;code&gt;equals&lt;/code&gt; 方法。另外还要保证这是一个不可变对象，即对象创建之后，无法再修改里面字段值。&lt;/p&gt;
&lt;h2 id=&quot;错用-concurrenthashmap-导致线程不安全&quot;&gt;错用 ConcurrentHashMap 导致线程不安全&lt;/h2&gt;
&lt;p&gt;之前的文章『&lt;a href=&quot;https://mp.weixin.qq.com/s/vI7XXvRbKmuGc7IVV6E1ww&quot;&gt;每天都在用 Map，这些核心技术你知道吗？&lt;/a&gt;』我们说过 &lt;code&gt;HashMap&lt;/code&gt; 是一个线程不安全的容器，多线程环境为了线程安全，我们需要使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;代替。&lt;/p&gt;
&lt;p&gt;但是不要认为使用了 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 一定就能保证线程安全，在某些错误的使用场景下，依然会造成线程不安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074455127-1146121068.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面示例代码，我们原本期望输出 &lt;strong&gt;1001&lt;/strong&gt;，但是运行几次，得到结果都是小于 &lt;strong&gt;1001&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;深入分析这个问题原因，实际上是因为第一步与第二步是一个组合逻辑，不是一个原子操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 只能保证这两步单的操作是个原子操作，线程安全。但是并不能保证两个组合逻辑线程安全，很有可能 A 线程刚通过 get 方法取到值，还未来得及加 1，线程发生了切换，B 线程也进来取到同样的值。&lt;/p&gt;
&lt;p&gt;这个问题同样也发生在其他线程安全的容器，比如 &lt;code&gt;Vector&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;上面的问题解决办法也很简单，加锁就可以解决，不过这样就会使性能大打折扣，所以不太推荐。&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;AtomicInteger&lt;/code&gt; 解决以上的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074455236-2023056527.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;list-集合这些坑，map-中也有&quot;&gt;List 集合这些坑，Map 中也有&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/q6ui4gL96Oa0hDbAeJwz-Q&quot;&gt;上一篇文章&lt;/a&gt;中我们提过，&lt;code&gt;Arrays#asList&lt;/code&gt; 与 &lt;code&gt;List#subList&lt;/code&gt; 返回 List 将会与原集合互相影响，且可能并不支持 &lt;code&gt;add&lt;/code&gt; 等方法。同样的，这些坑爹的特性在 Map 中也存在，一不小心，将会再次掉坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074455378-1781373568.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Map 接口除了支持增删改查功能以外，还有三个特有的方法，能返回所有 key，返回所有的 value，返回所有 kv 键值对。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 返回 key 的 set 视图
Set&amp;lt;K&amp;gt; keySet()；
// 返回所有 value   Collection 视图
Collection&amp;lt;V&amp;gt; values();
// 返回 key-value 的 set 视图
Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个方法创建返回新集合，底层其实都依赖的原有 Map 中数据，所以一旦 Map 中元素变动，就会同步影响返回的集合。&lt;/p&gt;
&lt;p&gt;另外这三个方法返回新集合，是不支持的新增以及修改操作的，但是却支持 &lt;code&gt;clear、remove&lt;/code&gt; 等操作。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200507074455519-1517876651.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以如果需要对外返回 Map 这三个方法产生的集合，建议再来个套娃。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;new ArrayList&amp;lt;&amp;gt;(map.values());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再简单提一下，使用 &lt;code&gt;foreach&lt;/code&gt; 方式遍历新增/删除 Map 中元素，也将会和 List 集合一样，抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;从上面文章可以看到不管是 List 提供的方法返回集合，还是 Map 中方法返回集合，底层实际还是使用原有集合的元素，这就导致两者将会被互相影响。所以如果需要对外返回，请使用套娃大法，这样让别人用的也安心。&lt;/p&gt;
&lt;p&gt;第二， Map 各个实现类对于 null 的约束都不太一样，这里建议在 Map 中加入元素之前，主动进行空指针判断，提前发现问题。&lt;/p&gt;
&lt;p&gt;第三，慎用自定义对象作为 Map 中的 key，如果需要使用，一定要重写 &lt;code&gt;hashCode&lt;/code&gt; 与 &lt;code&gt;equals&lt;/code&gt; 方法，并且还要保证这是个不可变对象。&lt;/p&gt;
&lt;p&gt;第三，&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是线程安全的容器，但是不要思维定势，不要片面认为使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 就会线程安全。&lt;/p&gt;
&lt;h2 id=&quot;最后（关注，点赞，转发三连）&quot;&gt;最后（关注，点赞，转发三连）&lt;/h2&gt;
&lt;p&gt;你在使用 Map 的过程还踩过什么坑，欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;我是楼下小黑哥，我们下篇文章再见~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;记住我们的约定，微信搜索『程序通事』，快来关注哦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 May 2020 23:45:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>编程坑太多系列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12840460.html</dc:identifier>
</item>
<item>
<title>经典卷积神经网络算法(1)：LeNet-5 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12840434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12840434.html</guid>
<description>&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;net_layers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 卷积部分网络&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 第一个卷积层：5*5*6&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 这个padding在最初的LeNet-5网络中是没有的，那时候还没有padding的概念，为了使这一层输出与元素LeNet-5网络保持一致，所以这里添加padding操作&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kernel_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 6个5*5的卷积核，进行padding&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 池化层&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxPool2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pool_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 池化层大小2*2，步长2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     layers.ReLU()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 第二个池化层：5*5*16&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kernel_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'valid'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 池化层&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxPool2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pool_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     layers.ReLU()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 展平成一维数组&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 全连接层&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;84&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'softmax'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 06 May 2020 23:18:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>LeNet-5科学家Yann LeCun在1998年发表论文《Gradient based learning applied to document-recognition》上提出的一个神经网络模型，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12840434.html</dc:identifier>
</item>
<item>
<title>【Java新特性】Lambda表达式典型案例，你想要的的都在这儿了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12840047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12840047.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不得不说，有些小伙伴的学习热情真高，学完了Lambda表达式的语法，想来几个典型案例再强化下。于是问冰河能否给几个Lambda表达式的典型使用示例。于是乎，便有了这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;案例一&quot;&gt;案例一&lt;/h2&gt;
&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;调用Collections.sort()方法，通过定制排序比较两个Employee（先比较年龄，年龄相同按姓名比较），使用Lambda表达式作为参数传递。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;这里，我们先创建一个Employee类，为了满足需求，我们在Employee类中定义了姓名、年龄和工资三个字段，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@Builder
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable {
    private static final long serialVersionUID = -9079722457749166858L;
    private String name;
    private Integer age;
    private Double salary;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在TestLambda类中定义一个成员变量employees，employees变量是一个List集合，存储了Employee的一个列表，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected List&amp;lt;Employee&amp;gt; employees = Arrays.asList(
    new Employee(&quot;张三&quot;, 18, 9999.99),
    new Employee(&quot;李四&quot;, 38, 5555.55),
    new Employee(&quot;王五&quot;, 60, 6666.66),
    new Employee(&quot;赵六&quot;, 8, 7777.77),
    new Employee(&quot;田七&quot;, 58, 3333.33)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前期的准备工作完成了，接下来，我们就可以实现具体的业务逻辑了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1(){
    Collections.sort(employees, (e1, e2) -&amp;gt; {
        if(e1.getAge() == e2.getAge()){
            return e1.getName().compareTo(e2.getName());
        }
        return Integer.compare(e1.getAge(), e2.getAge());
    });
    employees.stream().forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码比较简单，我就不赘述具体逻辑了。运行test1方法，得出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Employee(name=赵六, age=8, salary=7777.77)
Employee(name=张三, age=18, salary=9999.99)
Employee(name=李四, age=38, salary=5555.55)
Employee(name=田七, age=58, salary=3333.33)
Employee(name=王五, age=60, salary=6666.66)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想倒叙输出如何处理呢，只需要在将&lt;code&gt;return Integer.compare(e1.getAge(), e2.getAge());&lt;/code&gt;修改成&lt;code&gt;-return Integer.compare(e1.getAge(), e2.getAge());&lt;/code&gt;即可，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1(){
    Collections.sort(employees, (e1, e2) -&amp;gt; {
        if(e1.getAge() == e2.getAge()){
            return e1.getName().compareTo(e2.getName());
        }
        return -Integer.compare(e1.getAge(), e2.getAge());
    });
    employees.stream().forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行test1方法，得出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Employee(name=王五, age=60, salary=6666.66)
Employee(name=田七, age=58, salary=3333.33)
Employee(name=李四, age=38, salary=5555.55)
Employee(name=张三, age=18, salary=9999.99)
Employee(name=赵六, age=8, salary=7777.77)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果符合我们的需求。&lt;/p&gt;
&lt;h2 id=&quot;案例二&quot;&gt;案例二&lt;/h2&gt;
&lt;h3 id=&quot;需求-2&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;1.声明函数式接口，接口中声明抽象方法&lt;code&gt;public String getValue(String str);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.声明类TestLambda，类中编写方法使用接口作为参数，将一个字符串转换为大写，并作为方法的返回值。&lt;/p&gt;
&lt;p&gt;3.再将一个字符串的第2个和第4个索引位置进行截取子串。&lt;/p&gt;
&lt;h3 id=&quot;实现-2&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;首先，创建一个函数式接口MyFunction，在MyFunction接口上加上注解@FunctionalInterface标识接口是一个函数式接口。如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface MyFunction {
    public String getValue(String str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在TestLambda类中声明stringHandler方法，参数分别为待处理的字符串和函数式接口的实例，方法中的逻辑就是调用函数式接口的方法来处理字符串，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String stringHandler(String str, MyFunction myFunction){
    return myFunction.getValue(str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们实现将一个字符串转换为大写的逻辑，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test2(){
    String value = stringHandler(&quot;binghe&quot;, (s) -&amp;gt; s.toUpperCase());
    System.out.println(value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行test2方法，得出如下的结果信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;BINGHE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来实现字符串截取的操作，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test3(){
    String value = stringHandler(&quot;binghe&quot;, (s) -&amp;gt; s.substring(1, 3));
    System.out.println(value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：需求中是按照第2个和第4个索引位置进行截取子串，字符串的下标是从0开始的，所以这里截取字符串时使用的是substring(1, 3)，而不是substring(2, 4)，这也是很多小伙伴容易犯的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，使用上述Lambda表达式形式，可以实现字符串的任意处理，并返回处理后的新字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行test3方法，结果如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;in
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;案例三&quot;&gt;案例三&lt;/h2&gt;
&lt;h3 id=&quot;需求-3&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;1.声明一个带两个泛型的函数式接口，泛型类型为&amp;lt;T, R&amp;gt;，其中，T作为参数的类型，R作为返回值的类型。&lt;/p&gt;
&lt;p&gt;2.接口中声明对象的抽象方法。&lt;/p&gt;
&lt;p&gt;3.在TestLambda类中声明方法。使用接口作为参数计算两个long型参数的和。&lt;/p&gt;
&lt;p&gt;4.再就按两个long型参数的乘积。&lt;/p&gt;
&lt;h3 id=&quot;实现-3&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;首先，我们按照需求定义函数式接口MyFunc，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface MyFunc&amp;lt;T, R&amp;gt; {

    R getValue(T t1, T t2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在TestLambda类中创建一个处理两个long型数据的方法，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void operate(Long num1, Long num2, MyFunc&amp;lt;Long, Long&amp;gt; myFunc){
    System.out.println(myFunc.getValue(num1, num2));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用下面的方法来完成两个long型参数的和。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test4(){
    operate(100L, 200L, (x, y) -&amp;gt; x + y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行test4方法，结果如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;300
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现两个long型数据的乘积，也很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test5(){
    operate(100L, 200L, (x, y) -&amp;gt; x * y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行test5方法，结果如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;20000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，我相信很多小伙伴已经对Lambda表达式有了更深层次的理解。只要多多练习，就能够更好的掌握Lambda表达式的精髓。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Java8新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上Java8新特性核心知识图，祝大家在学习Java8新特性时少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202005/1729473-20200506235808974-1316995656.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 May 2020 15:59:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 不得不说，有些小伙伴的学习热情真高，学完了Lambda表达式的语法，想来几个典型案例再强化下。于是问冰河能否给几个Lambda表达式的典型使用示例。于是乎，便有了这篇文章。 案例一 需求 调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12840047.html</dc:identifier>
</item>
<item>
<title>编译原理词法分析：从正则表达式到生成代码 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12832989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12832989.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;最近在学&lt;a href=&quot;https://mooc.study.163.com/course/1000002001?tid=1000003000&quot; target=&quot;_blank&quot;&gt;编译原理&lt;/a&gt;，一门理论与实践结合的课程，我把作业发到博客里，希望能与大家交流分享。&lt;/p&gt;
&lt;p&gt;词法分析一章有一道比较复杂的作业题如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8.9507494646681&quot;&gt;
&lt;p&gt;本题是一个编程问题，在本题目中，你将完整的实现Thompson算法、子集构造算法和Hopcroft算法。为了帮助你开始，请下载如下链接中的代码并根据代码运行时的提示将缺少的代码补充完整。（注意，我们给出了正则表达式和NFA的数据结构和Thompson算法的框架，其它的数据结构和算法需要你自行补充完整。）&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&quot;http://staff.ustc.edu.cn/~bjhua/mooc/thompson.rar&quot;&gt;http://staff.ustc.edu.cn/~bjhua/mooc/thompson.rar&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于我写起C来就跟Cfront一样，我还是写C++吧。为了增加一点难度，我把原题的3步扩展为5步：构造正则表达式、Thompson构造法、子集构造算法、Hopcroft算法、生成C++代码。&lt;/p&gt;
&lt;p&gt;虽然属于词法分析部分，这道题的目标是实现词法分析器生成器，已经有点语法分析的意味，不过上下文无关文法换成了正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/jerry-fuyi/regex.7z&quot; target=&quot;_blank&quot;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造正则表达式&quot;&gt;构造正则表达式&lt;/h3&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;为所有可能字符构成的集合。正则表达式（Regular Expression/regex/RE）是一串定义搜索样式的字符，用于匹配由取自&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;中的字符组成的字符串。RE的定义是递归的：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;空串&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;是RE；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\forall c \in \Sigma\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;是RE；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;都是RE，则以下都是RE：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(MN\)&lt;/span&gt;，表示&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;后跟&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(M|N\)&lt;/span&gt;，表示&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;或&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(M*\)&lt;/span&gt;，表示&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;或若干个&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，称为&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的Kleene闭包；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是最基本的RE，诸如&lt;code&gt;[0-9]&lt;/code&gt;和&lt;code&gt;e+&lt;/code&gt;之类都属于语法糖，我的实现中不涉及。&lt;/p&gt;
&lt;p&gt;首先定义正则表达式类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class Regex
{
public:
    Regex();
    Regex(const Regex&amp;amp;) = delete;
    virtual ~Regex() = 0;
};

class Regexvarepsilon : public Regex
{
public:
    virtual ~Regexvarepsilon() override;
    Regexvarepsilon();
};

class RegexChar : public Regex
{
public:
    virtual ~RegexChar() override;
    RegexChar(char);
    char c;
};

class RegexConcat : public Regex
{
public:
    virtual ~RegexConcat() override;
    RegexConcat(Regex*, Regex*);
    Regex* re0;
    Regex* re1;
};

class RegexAlter : public Regex
{
public:
    virtual ~RegexAlter() override;
    RegexAlter(Regex*, Regex*);
    Regex* re0;
    Regex* re1;
};

class RegexClosure : public Regex
{
public:
    virtual ~RegexClosure() override;
    RegexClosure(Regex* re);
    Regex* re;
};

Regex::Regex() = default;

Regex::~Regex() = default;

Regexvarepsilon::~Regexvarepsilon() = default;

Regexvarepsilon::Regexvarepsilon() = default;

RegexChar::~RegexChar() = default;

RegexChar::RegexChar(char c)
    : c(c)
{
    ;
}

RegexConcat::~RegexConcat()
{
    delete re0;
    delete re1;
}

RegexConcat::RegexConcat(Regex* re0, Regex* re1)
    : re0(re0), re1(re1)
{
    ;
}

RegexAlter::~RegexAlter()
{
    delete re0;
    delete re1;
}

RegexAlter::RegexAlter(Regex* re0, Regex* re1)
    : re0(re0), re1(re1)
{

}

RegexClosure::~RegexClosure()
{
    delete re;
}

RegexClosure::RegexClosure(Regex* re)
    : re(re)
{
    ;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Regex&lt;/code&gt;和它的子类们把&lt;code&gt;new&lt;/code&gt;的任务交给客户，析构函数负责&lt;code&gt;delete&lt;/code&gt;。如果&lt;code&gt;Regex&lt;/code&gt;要拷贝的话需要递归深拷贝，很容易实现，但我不需要，所以写&lt;code&gt;= delete&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stringToRegex&lt;/code&gt;函数用于把字符串转换为&lt;code&gt;Regex*&lt;/code&gt;，实现思路如下：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果输入是&lt;code&gt;(...)&lt;/code&gt;但不是&lt;code&gt;(...)...(...)&lt;/code&gt;样式的字符串，去掉两边的圆括号，因为它们没有用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果&lt;code&gt;|&lt;/code&gt;存在于最外层（即&lt;code&gt;...(...|...)...&lt;/code&gt;不算），对&lt;code&gt;|&lt;/code&gt;分割的每一个子RE递归调用该函数，然后用&lt;code&gt;RegexAlter&lt;/code&gt;连接起来；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;否则，对于每一个带括号的子RE递归调用，对于字符直接构造&lt;code&gt;RegexChar&lt;/code&gt;，把空格当做&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;（这两个是递归出口），都放到栈中（实现中用&lt;code&gt;std::vector&lt;/code&gt;），遇到&lt;code&gt;*&lt;/code&gt;时弹出栈顶，套上&lt;code&gt;RegexClosure&lt;/code&gt;并放回。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;static Regex* stringToRegex(std::string::const_iterator begin, decltype(begin) end)
{
    return stringToRegex(std::string{ begin, end });
}

Regex* stringToRegex(const std::string&amp;amp; string)
{
    auto begin = string.begin();
    auto end = string.end();
    while (1)
    {
        if (begin == end)
            return makeRegex&amp;lt;Regexvarepsilon&amp;gt;();
        if (*begin != '(')
            break;
        int level = 0;
        bool bk = false;
        for (auto iter = begin, e = end - 1; iter != e; ++iter)
            if (*iter == '(')
                ++level;
            else if (*iter == ')' &amp;amp;&amp;amp; --level == 0)
                bk = true;
        if (bk)
            break;
        ++begin;
        --end;
    }
    std::vector&amp;lt;std::string::const_iterator&amp;gt; alts;
    int level = 0;
    for (auto iter = begin; iter != end; ++iter)
        switch (*iter)
        {
        case '(':
            ++level;
            break;
        case ')':
            --level;
            break;
        case '|':
            if (level == 0)
                alts.push_back(iter);
            break;
        }
    if (alts.empty())
    {
        std::vector&amp;lt;Regex*&amp;gt; cons;
        for (auto iter = begin; iter != end; ++iter)
        {
            switch (*iter)
            {
            case ' ':
                cons.push_back(makeRegex&amp;lt;Regexvarepsilon&amp;gt;());
                break;
            case '*':
            {
                auto back = cons.back();
                cons.pop_back();
                cons.push_back(makeRegex&amp;lt;RegexClosure&amp;gt;(back));
                break;
            }
            case '(':
            {
                int level = 0;
                auto begin = iter;
                for (; ; ++iter)
                    if (*iter == '(')
                        ++level;
                    else if (*iter == ')' &amp;amp;&amp;amp; --level == 0)
                        break;
                cons.push_back(stringToRegex(begin, iter + 1));
                break;
            }
            default:
                cons.push_back(makeRegex&amp;lt;RegexChar&amp;gt;(*iter));
                break;
            }
        }
        auto regex = cons.front();
        for (auto iter = cons.begin() + 1; iter != cons.end(); ++iter)
            regex = makeRegex&amp;lt;RegexConcat&amp;gt;(regex, *iter);
        return regex;
    }
    else
    {
        auto size = alts.size();
        alts.push_back(end);
        auto regex = stringToRegex(begin, alts.front());
        for (decltype(size) i = 0; i != size; ++i)
            regex = makeRegex&amp;lt;RegexAlter&amp;gt;(regex, stringToRegex(alts[i] + 1, alts[i + 1]));
        return regex;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以&lt;code&gt;(a|b)(c|d)*&lt;/code&gt;为例，构造出的Regex树如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506173142526-1256141863.png&quot; width=&quot;350&quot;/&gt;&lt;p&gt;BTW，可否写个RE来匹配所有RE？&lt;/p&gt;
&lt;h3 id=&quot;thompson构造法&quot;&gt;Thompson构造法&lt;/h3&gt;
&lt;p&gt;Thompson构造法可以把正则表达式转换为非确定性有限自动机（nondeterministic finite automaton，NFA），“非确定性”指的是状态和状态之间可以用&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;来转移。&lt;/p&gt;
&lt;p&gt;首先给出&lt;code&gt;Nfa&lt;/code&gt;的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class NfaNode
{
public:
    std::vector&amp;lt;NfaNode*&amp;gt; eps;
    std::map&amp;lt;char, NfaNode*&amp;gt; map;
    bool accept = false;
};

class Nfa
{
public:
    explicit Nfa(const Regex*);
    Nfa(const Nfa&amp;amp;) = delete;
    Nfa&amp;amp; operator=(const Nfa&amp;amp;) = delete;
    Nfa(Nfa&amp;amp;&amp;amp;) noexcept;
    Nfa&amp;amp; operator=(Nfa&amp;amp;&amp;amp;) noexcept;
    ~Nfa();
    NfaNode* begin = nullptr;
    NfaNode* end = nullptr;
private:
    std::vector&amp;lt;NfaNode*&amp;gt; nodes;
    NfaNode* makeNode();
    Nfa makeSubNfa(const Regex*);
};

Nfa::Nfa(Nfa&amp;amp;&amp;amp;) noexcept = default;

Nfa&amp;amp; Nfa::operator=(Nfa&amp;amp;&amp;amp; other) noexcept
{
    begin = other.begin;
    end = other.end;
    nodes.swap(other.nodes);
    return *this;
}

Nfa::~Nfa()
{
    for (auto&amp;amp;&amp;amp; p : nodes)
        delete p;
}

NfaNode* Nfa::makeNode()
{
    auto ptr = new NfaNode;
    nodes.push_back(ptr);
    return ptr;
}

Nfa Nfa::makeSubNfa(const Regex* regex)
{
    auto temp = regexToNfa(regex);
    nodes.insert(nodes.end(), temp.nodes.begin(), temp.nodes.end());
    temp.nodes.clear();
    return temp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NfaNode&lt;/code&gt;表示NFA中的状态：&lt;code&gt;eps&lt;/code&gt;为该状态可以通过&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;转移到的状态的集合；&lt;code&gt;map&lt;/code&gt;为&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;中字符到对应目标状态的映射；&lt;code&gt;accept&lt;/code&gt;指示该状态是否为接受状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nfa&lt;/code&gt;表示NFA：用&lt;code&gt;nodes&lt;/code&gt;保存由&lt;code&gt;makeNode&lt;/code&gt;创建的&lt;code&gt;Nfa&lt;/code&gt;指针，在析构函数中统一销毁；&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;表示起始和接受状态。NFA是图，拷贝要复杂得多，由于不需要（其实是我懒），故&lt;code&gt;= delete&lt;/code&gt;之。Nfa要作为参数传递，移动构造还是需要的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;C++新手小课堂：&lt;/p&gt;
&lt;p&gt;问：&lt;code&gt;std::vector&lt;/code&gt;中元素的迭代器和指针不是会失效吗？为什么可以让&lt;code&gt;NfaNode&lt;/code&gt;保存&lt;code&gt;NfaNode*&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;答：因为&lt;code&gt;std::vector&lt;/code&gt;的模板参数是&lt;code&gt;NfaNode*&lt;/code&gt;而非&lt;code&gt;NfaNode&lt;/code&gt;，&lt;code&gt;NfaNode*&lt;/code&gt;是存储的值，不会失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RE是递归的，Thompson构造法亦是。为了方便递归，需要对产生的NFA作一些规约：&lt;/p&gt;
&lt;p&gt;然后就可以递归地构造了：&lt;/p&gt;
&lt;p&gt;我对Thompson构造法的定义与标准的略有不同：我去掉了NFA起始状态不能作为转移目标状态的要求，于是对闭包的构造减少了一个节点；同时对连接的构造增加了一个节点，不过这也有以上数据结构不方便删除一个节点的考虑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;Nfa::Nfa(const Regex* regex)
{
    if (dynamic_cast&amp;lt;const Regexvarepsilon*&amp;gt;(regex))
    {
        begin = makeNode();
        end = begin;
        end-&amp;gt;accept = true;
    }
    else if (dynamic_cast&amp;lt;const RegexChar*&amp;gt;(regex))
    {
        auto r = static_cast&amp;lt;const RegexChar*&amp;gt;(regex);
        begin = makeNode();
        end = makeNode();
        end-&amp;gt;accept = true;
        begin-&amp;gt;map[r-&amp;gt;c] = end;
    }
    else if (dynamic_cast&amp;lt;const RegexConcat*&amp;gt;(regex))
    {
        auto r = static_cast&amp;lt;const RegexConcat*&amp;gt;(regex);
        begin = makeNode();
        auto nfa0 = makeSubNfa(r-&amp;gt;re0);
        auto nfa1 = makeSubNfa(r-&amp;gt;re1);
        begin-&amp;gt;eps.push_back(nfa0.begin);
        nfa0.end-&amp;gt;eps.push_back(nfa1.begin);
        nfa0.end-&amp;gt;accept = false;
        end = nfa1.end;
    }
    else if (dynamic_cast&amp;lt;const RegexAlter*&amp;gt;(regex))
    {
        auto r = static_cast&amp;lt;const RegexAlter*&amp;gt;(regex);
        begin = makeNode();
        end = makeNode();
        auto nfa0 = makeSubNfa(r-&amp;gt;re0);
        auto nfa1 = makeSubNfa(r-&amp;gt;re1);
        begin-&amp;gt;eps.push_back(nfa0.begin);
        nfa0.end-&amp;gt;eps.push_back(end);
        nfa0.end-&amp;gt;accept = false;
        begin-&amp;gt;eps.push_back(nfa1.begin);
        nfa1.end-&amp;gt;eps.push_back(end);
        nfa1.end-&amp;gt;accept = false;
        end-&amp;gt;accept = true;
    }
    else if (dynamic_cast&amp;lt;const RegexClosure*&amp;gt;(regex))
    {
        auto r = static_cast&amp;lt;const RegexClosure*&amp;gt;(regex);
        begin = makeNode();
        end = makeNode();
        auto nfa = makeSubNfa(r-&amp;gt;re);
        begin-&amp;gt;eps.push_back(end);
        begin-&amp;gt;eps.push_back(nfa.begin);
        nfa.end-&amp;gt;accept = false;
        nfa.end-&amp;gt;eps.push_back(begin);
        end-&amp;gt;accept = true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仍以&lt;code&gt;(a|b)(c|d)*&lt;/code&gt;为例，构造出的NFA如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506173656840-1489111108.png&quot; width=&quot;725&quot;/&gt;&lt;h3 id=&quot;子集构造算法&quot;&gt;子集构造算法&lt;/h3&gt;
&lt;p&gt;NFA是不确定的，尽管有算法可以用NFA来匹配字符串，但是DFA（deterministic finite automaton，确定性有限自动机）更加简单、直观，因为它没有&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;转移，并且每个状态每个字符有唯一的转移目标（用Thompson构造法构造出的NFA也符合这一点）。&lt;/p&gt;
&lt;p&gt;子集构造算法可以从NFA构造DFA。先给出DFA的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class SimpDfa;

class DfaNode
{
public:
    std::map&amp;lt;char, std::size_t&amp;gt; map;
    bool accept = false;
};

class Dfa
{
public:
    Dfa();
    Dfa(const Dfa&amp;amp;) = delete;
    Dfa&amp;amp; operator=(const Dfa&amp;amp;) = delete;
    Dfa(Dfa&amp;amp;&amp;amp;) noexcept;
    Dfa&amp;amp; operator=(Dfa&amp;amp;&amp;amp;) noexcept;
    ~Dfa();
    DfaNode* getNode(std::size_t);
private:
    std::vector&amp;lt;DfaNode*&amp;gt; nodes;
    using SubsetMap = std::map&amp;lt;std::set&amp;lt;NfaNode*&amp;gt;, std::size_t&amp;gt;;
    SubsetMap subsetMap;
    std::pair&amp;lt;SubsetMap::iterator, bool&amp;gt; makeNode(const std::set&amp;lt;NfaNode*&amp;gt;&amp;amp;, bool);
    friend Dfa nfaToDfa(const Nfa&amp;amp; nfa);
    friend SimpDfa simplifyDfa(const Dfa&amp;amp; dfa);
};

Dfa::Dfa() = default;

Dfa::Dfa(Dfa&amp;amp;&amp;amp; other) noexcept
    : nodes(std::move(other.nodes))
{
    ;
}

Dfa&amp;amp; Dfa::operator=(Dfa&amp;amp;&amp;amp; other) noexcept
{
    nodes.swap(other.nodes);
    return *this;
}

Dfa::~Dfa()
{
    for (auto&amp;amp;&amp;amp; p : nodes)
        delete p;
}

DfaNode* Dfa::getNode(std::size_t index)
{
    return nodes[index];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回&lt;code&gt;DfaNode&lt;/code&gt;不再维护&lt;code&gt;DfaNode&lt;/code&gt;指针而是&lt;code&gt;std::size_t&lt;/code&gt;数组下标，其中数组指的是&lt;code&gt;Dfa&lt;/code&gt;中的&lt;code&gt;nodes&lt;/code&gt;。这使&lt;code&gt;Dfa&lt;/code&gt;的拷贝变得十分平凡，但还是改变不了我的懒惰——拷贝依然是&lt;code&gt;= delete&lt;/code&gt;。&lt;code&gt;makeNode&lt;/code&gt;功能上还是创建&lt;code&gt;DfaNode&lt;/code&gt;，但是参数非常诡异，后面再讲。&lt;/p&gt;
&lt;p&gt;子集是幂集的元素，极端情况下子集构造算法的复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(2^n)\)&lt;/span&gt;，因此子集（subset）构造算法又称幂集（powerset）构造算法。&lt;/p&gt;
&lt;p&gt;之前提到，NFA中状态之间可以用&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;转移，它们看起来像是相同的状态，这就是子集构造算法的核心想法。&lt;/p&gt;
&lt;p&gt;在详述算法之前，先下个定义：一个状态的&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;闭包为能从该状态通过&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;转移到的所有状态的集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;static void epsClosure(NfaNode* node, std::set&amp;lt;NfaNode*&amp;gt;&amp;amp; set, bool&amp;amp; accept)
{
    if (set.find(node) != set.end())
        return;
    set.insert(node);
    if (node-&amp;gt;accept)
        accept = true;
    for (auto&amp;amp;&amp;amp; n : node-&amp;gt;eps)
        epsClosure(n, set, accept);
}

static std::pair&amp;lt;std::set&amp;lt;NfaNode*&amp;gt;, bool&amp;gt; epsClosure(NfaNode* node)
{
    std::set&amp;lt;NfaNode*&amp;gt; set;
    bool accept = false;
    epsClosure(node, set, accept);
    return { set, accept };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;makeNode&lt;/code&gt;的第一个参数，正是&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;闭包这样的状态集合；&lt;code&gt;subsetMap&lt;/code&gt;为状态集合到&lt;code&gt;DfaNode&lt;/code&gt;指针的映射；&lt;code&gt;makeNode&lt;/code&gt;的返回值为&lt;code&gt;std::map::insert&lt;/code&gt;的返回值，其中的&lt;code&gt;bool&lt;/code&gt;表示是否有新键插入，这个值后面有用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;std::pair&amp;lt;Dfa::SubsetMap::iterator, bool&amp;gt; Dfa::makeNode(const std::set&amp;lt;NfaNode*&amp;gt;&amp;amp; set, bool accept)
{
    auto found = subsetMap.find(set);
    if (found != subsetMap.end())
        return { found, false };
    auto ptr = new DfaNode;
    auto index = nodes.size();
    nodes.push_back(ptr);
    ptr-&amp;gt;accept = accept;
    return subsetMap.insert({ set, index });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子集构造算法的过程为：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;求出起始状态的&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;闭包，该NFA状态集合对应一个DFA状态，接受属性取决于闭包中是否有接受状态，入队；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;取出队列首元素，是一个状态集合，对于&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;中的每一个字符，求出 集合中每一个状态 通过该字母转移到的状态 的&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;闭包 的并集，对应一个DFA状态，接受属性取决于并集中是否有接受状态（思考：为什么是&lt;code&gt;||&lt;/code&gt;的关系？），如果该集合未被处理过，则入队；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果队列非空，回到2，否则结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;Dfa nfaToDfa(const Nfa&amp;amp; nfa)
{
    Dfa dfa;
    auto ret = epsClosure(nfa.begin);
    dfa.makeNode(ret.first, ret.second);
    auto start = dfa.subsetMap.begin();
    std::queue&amp;lt;decltype(start)&amp;gt; queue;
    queue.push(start);
    while (!queue.empty())
    {
        auto iter = queue.front();
        queue.pop();
        std::set&amp;lt;char&amp;gt; sigma;
        for (auto&amp;amp;&amp;amp; node : iter-&amp;gt;first)
            for (auto&amp;amp;&amp;amp; kv : node-&amp;gt;map)
                sigma.insert(kv.first);
        for (auto&amp;amp;&amp;amp; c : sigma)
        {
            std::set&amp;lt;NfaNode*&amp;gt; set;
            bool accept = false;
            for (auto&amp;amp;&amp;amp; node : iter-&amp;gt;first)
            {
                auto found = node-&amp;gt;map.find(c);
                if (found == node-&amp;gt;map.end())
                    continue;
                auto ret = epsClosure(found-&amp;gt;second);
                set.insert(ret.first.begin(), ret.first.end());
                accept = accept || ret.second;
            }
            auto pair = dfa.makeNode(set, accept);
            dfa.nodes[iter-&amp;gt;second]-&amp;gt;map[c] = pair.first-&amp;gt;second;
            if (pair.second)
                queue.push(pair.first);
        }
    }
    return dfa;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一个NFA构造出的DFA如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506221153370-1028592631.png&quot; width=&quot;300&quot;/&gt;&lt;p&gt;已经很复杂了，不是吗？不要慌，后面还有更复杂的。&lt;/p&gt;
&lt;h3 id=&quot;hopcroft算法&quot;&gt;Hopcroft算法&lt;/h3&gt;
&lt;p&gt;通过子集构造算法获得的DFA不是最简的。化简一个DFA的手段有删掉不可到达的状态和合并不可区分的状态，上面这个子集构造算法的实现不会产生不可到达的状态，因此只需用Hopcroft算法化简即可（呵，说得轻巧）。&lt;/p&gt;
&lt;p&gt;Hopcroft算法的输入与输出都是DFA，输出用&lt;code&gt;Dfa&lt;/code&gt;即可表示，但我定义了一个类似的新的数据结构，方便后续优化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class SimpNode
{
public:
    std::map&amp;lt;char, std::size_t&amp;gt; map;
    bool accept = false;
};

class SimpDfa
{
public:
    SimpDfa();
    SimpDfa(const SimpDfa&amp;amp;) = delete;
    SimpDfa&amp;amp; operator=(const SimpDfa&amp;amp;) = delete;
    SimpDfa(SimpDfa&amp;amp;&amp;amp;) noexcept;
    SimpDfa&amp;amp; operator=(SimpDfa&amp;amp;&amp;amp;) noexcept;
    ~SimpDfa();
    std::size_t begin = 0;
    SimpNode* getNode(std::size_t);
private:
    std::vector&amp;lt;SimpNode*&amp;gt; nodes;
    std::size_t makeNode();
    friend SimpDfa simplifyDfa(const Dfa&amp;amp; dfa);
    friend void generateCode(std::ostream&amp;amp;, const std::string&amp;amp;, const SimpDfa&amp;amp;);
};

SimpDfa::SimpDfa() = default;

SimpDfa::SimpDfa(SimpDfa&amp;amp;&amp;amp; other) noexcept
    : nodes(std::move(other.nodes)), begin(other.begin)
{
    ;
}

SimpDfa&amp;amp; SimpDfa::operator=(SimpDfa&amp;amp;&amp;amp; other) noexcept
{
    nodes.swap(other.nodes);
    begin = other.begin;
    return *this;
}

SimpDfa::~SimpDfa()
{
    for (auto&amp;amp;&amp;amp; p : nodes)
        delete p;
}

SimpNode* SimpDfa::getNode(std::size_t index)
{
    return nodes[index];
}

std::size_t SimpDfa::makeNode()
{
    auto ptr = new SimpNode;
    auto index = nodes.size();
    nodes.push_back(ptr);
    return index;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hopcroft算法的核心是集合划分：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始状态为两个集合，接受状态组成的集合与非接受状态组成的集合；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于每一个集合，我们要考察其中的各个状态是否是不可区分的：对集合中的每一个状态，求出其转移到的状态所在的集合，集合中的所有状态的这一信息必须完全相同——字符与字符对应的集合都相同——才能认为该集合不可划分；否则就根据这一信息来划分，相同的划分为一个新的集合；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果这一步中集合被划分，那么先前被认为是不可划分的集合可能会变得可以划分，需要重新遍历集合的集合，直到一次遍历中没有划分操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最后，每个集合对应一个化简后DFA的状态，接受属性只需任取集合中一个元素看——很容易证明集合中各状态的接受属性相同；然后根据原DFA的转移计算出新DFA的转移。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个算法的实现非常猥琐。我们知道并查集（可并集），初始时每个元素都是独立的集合，然后可以把两个集合并起来，时间复杂度接近&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。那么有没有所谓“可分集”呢？&lt;/p&gt;
&lt;p&gt;我用的是笨办法，用&lt;code&gt;std::list&lt;/code&gt;保存各个集合，包括原DFA与新DFA中的状态，在原DFA中维护指向&lt;code&gt;std::list&lt;/code&gt;中元素的迭代器，这样原DFA中的状态与集合可以互相知晓。原DFA中的状态是只读的（为什么不去掉&lt;code&gt;const&lt;/code&gt;或者加&lt;code&gt;mutable&lt;/code&gt;呢？因为不优雅），无法在其中维护迭代器，因此新开一个&lt;code&gt;std::vector&lt;/code&gt;，与&lt;code&gt;nodes&lt;/code&gt;中的元素一一对应，这也是&lt;code&gt;DfaNode&lt;/code&gt;中用数组下标而不像&lt;code&gt;NfaNode&lt;/code&gt;那样用指针的原因（显然，最初的实现是用指针的，后来才改成数组下标）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;struct ListItem
{
    ListItem() = default;
    ListItem(std::set&amp;lt;std::size_t&amp;gt;&amp;amp;&amp;amp; set)
        : indices(std::move(set)) { }
    std::set&amp;lt;std::size_t&amp;gt; indices;
    std::size_t node = 0;
};

struct ItemRef
{
    std::list&amp;lt;ListItem&amp;gt;::iterator iterator;
};

SimpDfa simplifyDfa(const Dfa&amp;amp; dfa)
{
    auto size = dfa.nodes.size();
    std::vector&amp;lt;ItemRef&amp;gt; helper(size);
    std::list&amp;lt;ListItem&amp;gt; list;
    {
        list.emplace_back();
        list.emplace_back();
        auto yes = list.begin();
        auto no = ++list.begin();
        for (decltype(size) i = 0; i != dfa.nodes.size(); ++i)
            if (dfa.nodes[i]-&amp;gt;accept)
            {
                yes-&amp;gt;indices.insert(i);
                helper[i].iterator = yes;
            }
            else
            {
                no-&amp;gt;indices.insert(i);
                helper[i].iterator = no;
            }
        if (no-&amp;gt;indices.empty())
            list.erase(no);
    }
    while (1)
    {
        bool ok = true;
        for (auto iter = list.begin(); iter != list.end(); )
        {

            std::map&amp;lt;std::map&amp;lt;char, ListItem*&amp;gt;, std::set&amp;lt;std::size_t&amp;gt;&amp;gt; map;
            for (auto&amp;amp;&amp;amp; i : iter-&amp;gt;indices)
            {
                std::map&amp;lt;char, ListItem*&amp;gt; key;
                for (auto&amp;amp;&amp;amp; kv : dfa.nodes[i]-&amp;gt;map)
                    key.insert({ kv.first, &amp;amp;*helper[kv.second].iterator });
                map[key].insert(i);
            }
            if (map.size() == 1)
            {
                ++iter;
                continue;
            }
            ok = false;
            for (auto&amp;amp;&amp;amp; pair : map)
            {
                auto&amp;amp; set = pair.second;
                list.emplace_back(std::move(set));
                auto iter = --list.end();
                for (auto&amp;amp;&amp;amp; i : iter-&amp;gt;indices)
                    helper[i].iterator = iter;
            }
            iter = list.erase(iter);
        }
        if (ok)
            break;
    }
    SimpDfa result;
    for (auto&amp;amp;&amp;amp; item : list)
    {
        item.node = result.makeNode();
        result.nodes[item.node]-&amp;gt;accept = dfa.nodes[*item.indices.begin()]-&amp;gt;accept;
    }
    for (decltype(size) i = 0; i != size; ++i)
    {
        auto&amp;amp; map = result.nodes[helper[i].iterator-&amp;gt;node]-&amp;gt;map;
        for (auto&amp;amp;&amp;amp; kv : dfa.nodes[i]-&amp;gt;map)
            map.insert({ kv.first, helper[kv.second].iterator-&amp;gt;node });
    }
    result.begin = helper[0].iterator-&amp;gt;node;
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一个DFA化简得DFA如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506221206862-304514631.png&quot; width=&quot;200&quot;/&gt;&lt;p&gt;这个例子没有涉及到集合划分的过程，我们换一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Thompson%27s_construction#Application_of_the_algorithm&quot; target=&quot;_blank&quot;&gt;wikipedia&lt;/a&gt;上的例子：&lt;code&gt;(0|(1(01*(00)*0)*1)*)*&lt;/code&gt;，匹配所有能被&lt;code&gt;3&lt;/code&gt;整除的二进制数。这里不探讨它的正确性，我更不知道该如何写出这样的正则表达式，只管拿来用就是了。该RE被转换为：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506221222958-1537175304.png&quot; width=&quot;300&quot;/&gt;&lt;h3 id=&quot;生成c代码&quot;&gt;生成C++代码&lt;/h3&gt;
&lt;p&gt;既然是用C++写的，那就生成C++的代码吧！想起曾经读过的《设计模式》，State模式完全就是为自动状态机而生，趁机实践一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;

class Automaton
{
public:
    ~Automaton()
    {
        for (auto&amp;amp;&amp;amp; p : states)
            delete p;
    }
    bool operator()(const std::string&amp;amp; s)
    {
        index = 0;
        for (auto&amp;amp;&amp;amp; c : s)
            (*states[index])(c);
        return states[index]-&amp;gt;accept();
    }
private:
    struct State
    {
        Automaton* ptr;
        State(Automaton* ptr)
            : ptr(ptr) { }
        virtual ~State() = default;
        virtual bool accept() = 0;
        virtual void operator()(char) = 0;
    };
    struct StateAccept : State
    {
        using State::State;
        virtual ~StateAccept() override = default;
        virtual bool accept() override final
        {
            return true;
        }
        virtual void operator()(char) override = 0;
    };
    struct StateReject : State
    {
        using State::State;
        virtual ~StateReject() override = default;
        virtual bool accept() override final
        {
            return false;
        }
        virtual void operator()(char) override = 0;
    };
    struct StateError : StateReject
    {
        using StateReject::StateReject;
        virtual ~StateError() override = default;
        virtual void operator()(char c) override final
        {
            ;
        }
    };
    struct State0 : StateAccept 
    {
        using StateAccept::StateAccept;
        virtual ~State0() override = default;
        virtual void operator()(char c) override final
        {
            switch (c)
            {
            case '0':
                ptr-&amp;gt;index = 0;
                break;
            case '1':
                ptr-&amp;gt;index = 1;
                break;
            default:
                ptr-&amp;gt;index = 3;
                break;
            }
        }
    };
    struct State1 : StateReject 
    {
        using StateReject::StateReject;
        virtual ~State1() override = default;
        virtual void operator()(char c) override final
        {
            switch (c)
            {
            case '0':
                ptr-&amp;gt;index = 2;
                break;
            case '1':
                ptr-&amp;gt;index = 0;
                break;
            default:
                ptr-&amp;gt;index = 3;
                break;
            }
        }
    };
    struct State2 : StateReject 
    {
        using StateReject::StateReject;
        virtual ~State2() override = default;
        virtual void operator()(char c) override final
        {
            switch (c)
            {
            case '0':
                ptr-&amp;gt;index = 1;
                break;
            case '1':
                ptr-&amp;gt;index = 2;
                break;
            default:
                ptr-&amp;gt;index = 3;
                break;
            }
        }
    };
    State* states[4] = {
        new State0{this},
        new State1{this},
        new State2{this},
        new StateError{this},
    };
    std::size_t index;
};

int main()
{
    std::cout &amp;lt;&amp;lt; std::boolalpha;
    Automaton a;
    std::string input;
    while (std::getline(std::cin, input))
        std::cout &amp;lt;&amp;lt; a(input) &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是上面最后一张图的代码实现，用作生成代码的模板。&lt;code&gt;State&lt;/code&gt;及其子类的关系如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202005/1734552-20200506224559220-1636416744.png&quot; width=&quot;725&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void generateCode(std::ostream&amp;amp; os, const std::string&amp;amp; name, const SimpDfa&amp;amp; dfa)
{
    const char* indent = &quot;    &quot;;
    os &amp;lt;&amp;lt; &quot;#include &amp;lt;iostream&amp;gt;\n&quot;
        &amp;lt;&amp;lt; &quot;\n&quot;
        &amp;lt;&amp;lt; &quot;class &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;\n&quot;
        &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; &quot;public:\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;~&quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;()\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;for (auto&amp;amp;&amp;amp; p : states)\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;delete p;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;bool operator()(const std::string&amp;amp; s)\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;index = &quot; &amp;lt;&amp;lt; dfa.begin &amp;lt;&amp;lt; &quot;;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;for (auto&amp;amp;&amp;amp; c : s)\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;(*states[index])(c);\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;return states[index]-&amp;gt;accept();\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
        &amp;lt;&amp;lt; &quot;private:\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;struct State\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;* ptr;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;State(&quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;* ptr)\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;: ptr(ptr) { }\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual ~State() = default;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual bool accept() = 0;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual void operator()(char) = 0;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;struct StateAccept : State\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;using State::State;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual ~StateAccept() override = default;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual bool accept() override final\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;return true;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual void operator()(char) override = 0;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;struct StateReject : State\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;using State::State;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual ~StateReject() override = default;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual bool accept() override final\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;return false;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual void operator()(char) override = 0;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;struct StateError : StateReject\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;using StateReject::StateReject;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual ~StateError() override = default;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual void operator()(char c) override final\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;;
    auto size = dfa.nodes.size();
    for (decltype(size) i = 0; i != size; ++i)
    {
        using namespace std::string_literals;
        auto&amp;amp; node = *dfa.nodes[i];
        auto className = &quot;State&quot; + std::to_string(i);
        auto baseName = &quot;State&quot;s + (node.accept ? &quot;Accept&quot; : &quot;Reject&quot;);
        os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;struct &quot; &amp;lt;&amp;lt; className &amp;lt;&amp;lt; &quot; : &quot; &amp;lt;&amp;lt; baseName &amp;lt;&amp;lt; &quot; \n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;using &quot; &amp;lt;&amp;lt; baseName &amp;lt;&amp;lt; &quot;::&quot; &amp;lt;&amp;lt; baseName &amp;lt;&amp;lt; &quot;;\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual ~&quot; &amp;lt;&amp;lt; className &amp;lt;&amp;lt; &quot;() override = default;\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;virtual void operator()(char c) override final\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;switch (c)\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;{\n&quot;;
        for (auto&amp;amp;&amp;amp; kv : node.map)
            os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;case '&quot; &amp;lt;&amp;lt; kv.first &amp;lt;&amp;lt; &quot;':\n&quot;
                &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;ptr-&amp;gt;index = &quot; &amp;lt;&amp;lt; kv.second &amp;lt;&amp;lt; &quot;;\n&quot;
                &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;break;\n&quot;;
        os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;default:\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;ptr-&amp;gt;index = &quot; &amp;lt;&amp;lt; size &amp;lt;&amp;lt; &quot;;\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;break;\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;}\n&quot;
            &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;;
    }
    os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;State* states[&quot; &amp;lt;&amp;lt; size + 1 &amp;lt;&amp;lt; &quot;] = {\n&quot;;
    for (decltype(size) i = 0; i != size; ++i)
        os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;new State&quot; &amp;lt;&amp;lt; std::to_string(i) &amp;lt;&amp;lt; &quot;{this},\n&quot;;
    os &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;new StateError{this},\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;};\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;std::size_t index;\n&quot;
        &amp;lt;&amp;lt; &quot;};\n&quot;
        &amp;lt;&amp;lt; &quot;\n&quot;
        &amp;lt;&amp;lt; &quot;int main()\n&quot;
        &amp;lt;&amp;lt; &quot;{\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;std::cout &amp;lt;&amp;lt; std::boolalpha;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;Automaton a;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;std::string input;\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;while (std::getline(std::cin, input))\n&quot;
        &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; indent &amp;lt;&amp;lt; &quot;std::cout &amp;lt;&amp;lt; a(input) &amp;lt;&amp;lt; std::endl;\n&quot;
        &amp;lt;&amp;lt; &quot;}\n&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码当然不是手敲的，先在编辑器中替换，再把要更改的部分换成变量即可。&lt;/p&gt;
&lt;p&gt;至此，从正则表达式到C++代码的转换终于实现了。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;本文介绍的算法大多涉及比较复杂的数据结构，复杂程度刷新了我的记录，以致于我一直在思考是不是我的想法太复杂了？其实有时想得简单也会导致问题变得复杂，比如我一开始把子集构造算法中状态集合的转移误认为对每一个转移求闭包而不取并集（网课没有讲清楚是一方面），然后&lt;code&gt;std::map&lt;/code&gt;的值类型就从&lt;code&gt;T&lt;/code&gt;变为&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt;或&lt;code&gt;std::set&amp;lt;T&amp;gt;&lt;/code&gt;，实现更加复杂，而且出现了错误！如果一个状态对一个字符有多条转移，DFA的“D”体现在哪了呢——写一个算法发现不对劲的时候，也许是对前导算法的理解有误。&lt;/p&gt;
&lt;p&gt;最好的办法是对每一个算法加以严谨的证明，顺便求出最坏和平均复杂度，然而与算法有关的数学我都不太懂，本文也没有那么远大的目标。如果想了解详情，还请参考专业资料。&lt;/p&gt;
&lt;p&gt;以上实现还有很多改进空间。比如，&lt;code&gt;NfaNode&lt;/code&gt;中的&lt;code&gt;accept&lt;/code&gt;是不必要的，可以以数组下标的形式放入&lt;code&gt;Nfa&lt;/code&gt;中，为每个&lt;code&gt;NfaNode&lt;/code&gt;对象节省4字节空间。Thompson构造法的实现也可以优化，减少NFA状态与&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;转移的数量有助于减少&lt;code&gt;epsClosure&lt;/code&gt;的递归深度，增加一些代码来换取运行时性能还是值得的，只不过我又一次犯懒了。&lt;/p&gt;
&lt;p&gt;这一套算法的正则表达式输入部分，或许可以称为“前端”，可以增加对RE语法糖的支持，使算法能处理通用的、友好的RE，这是可扩展性的体现；然而局限也十分明显，生成代码只能对输入字符串回答是否接受，而不能给出匹配的具体信息，从而无法作为通用的编程工具。C++11引入了regex库，有机会去学习学习。&lt;/p&gt;
</description>
<pubDate>Wed, 06 May 2020 15:16:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>引言 最近在学编译原理，一门理论与实践结合的课程，我把作业发到博客里，希望能与大家交流分享。 词法分析一章有一道比较复杂的作业题如下： 本题是一个编程问题，在本题目中，你将完整的实现Thompson算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12832989.html</dc:identifier>
</item>
<item>
<title>新人程序员必须知道的，不然等你回过神来的时候，一切已晚矣。 - 左潇龙</title>
<link>http://www.cnblogs.com/zuoxiaolong/p/12834121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoxiaolong/p/12834121.html</guid>
<description>&lt;h3&gt;引言&lt;/h3&gt;

&lt;p&gt;　　看到这个标题的时候，相信大部分人的第一反应一定是：卧槽！标题党来了！&lt;/p&gt;
&lt;p&gt;　　是的，你猜对了，-_-。&lt;/p&gt;
&lt;p&gt;　　其实之所以写这篇文章，是因为有一个读者，遇到了人生中一次比较重要的抉择，因而来咨询LZ，而LZ恰好无事，因此就十分耐心的给这个读者谈了谈自己的一些想法，而这个读者事后也表示茅厕顿开。&lt;/p&gt;
&lt;p&gt;　　后来LZ觉得这次谈话内容，或许对不少人也有帮助和警醒的作用，因此就决定索性用文字的形式记录下来，这就是这篇文章出处了。&lt;/p&gt;
&lt;p&gt;　　当然了，是否对所有人都有用，LZ也不做任何担保，现在毕竟是信息爆炸时代，所有人都需要具备两项最基本的技能：信息筛选和自我判断能力。&lt;/p&gt;
&lt;p&gt;　　不然的话，你早晚会被淹没在网络的信息海洋里。&lt;/p&gt;
&lt;p&gt;　　好了，接下来言归正传，咱们先来简单聊聊这位读者，面临着怎样的困惑。&lt;/p&gt;

&lt;h3&gt;是否该跳槽&lt;/h3&gt;

&lt;p&gt;　　是的，这个读者当时问的，就是这个问题。&lt;/p&gt;
&lt;p&gt;　　看到这个问题，应该算是老生常谈了，是否该跳槽这个疑惑，相信绝大多数，甚至可以说是所有人都面临过这个问题。&lt;/p&gt;
&lt;p&gt;　　而这个问题的每一次抉择，或许都会改变你以后的职场轨迹，因此这个问题的选择就显得格外重要。&lt;/p&gt;
&lt;p&gt;　　事实上，不止本文提到的这一个读者问过LZ这个问题，很多人都咨询过这个问题，而LZ对此类问题的统一回答是：该不该跳槽，你说了不算，市场说了算。&lt;/p&gt;
&lt;p&gt;　　说人话就是：&lt;strong&gt;你得出去找找看，能找到更好的就该跳，否则......从哪里来，回哪里去，老老实实继续提升自己才是正道。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　之所以会有这样的回答，其实这里面核心的逻辑有两点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一点就是围城现象&lt;/strong&gt;，当你产生了跳槽的想法的时候，说明你的心里其实已经开始躁动了，这种情况下，如果你不出去试试看的话，很可能会造成你对当前的工作也无法尽心尽力，这个时候，你就必须出去看一看，否则你的心态会长时间处于一种对工作厌烦的状态，这对你没有任何好处。&lt;/p&gt;
&lt;p&gt;　　而你出去试一下就不同了，如果你能找到更好的，那自然皆大欢喜，哪怕你找不到更好的，你也会知道外面的世界并没有你想象的那么美好，你最起码可以踏实在当前的工作岗位好好工作。&lt;/p&gt;
&lt;p&gt;　　所以，围城现象，是LZ提出这个建议的第一个核心逻辑。&lt;/p&gt;
&lt;p&gt;　　而第二个逻辑，其实是打破信息不对称，或者说信息最大化，说白了就是，&lt;strong&gt;当你遇到一件事不知道如何判断的时候，那就尽可能搜集更多的信息，来帮助你判断，这样你做出错误选择的可能性就会大大降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　这其实也很容易理解，如果你明确的知道了，你出去是什么样的后果，你自然会更加容易判断你该不该跳槽。&lt;/p&gt;
&lt;p&gt;　　就好比你现在有A和B两个女生都想和你结婚，而你不知道选A当老婆好，还是选B当老婆好，最好的办法当然是掌握A和B更多的信息，比如她们的家境、性格、爱好，甚至是三围，这样你才好去判断到底选哪个好，选错的概率自然也会大大降低。&lt;/p&gt;
&lt;p&gt;　　当然了，这只是个举个例子，LZ知道作为单身狗的你，是不会面临这种选择的，-_-。&lt;/p&gt;
&lt;p&gt;　　说回正题，事实上，当这位读者问这个问题的时候，因为LZ和这位读者聊的比较投机，因此在谈的时候，LZ其实不仅仅谈了跳槽这个问题，而是谈到了程序员的发展路线。&lt;/p&gt;
&lt;p&gt;　　毕竟跳槽在某种程度上，会极大的影响到你未来的发展路线，因此聊跳槽聊的深了，不可避免的就会谈到发展路线，这也是本文重点要谈的一个话题，也是为何LZ觉得值得记录下来的一点。&lt;/p&gt;
&lt;p&gt;　　其实关于程序员的发展路线，LZ以前也聊过，但都比较零碎，这次LZ准备系统的来谈一谈这个问题。&lt;/p&gt;
&lt;p&gt;　　话不多说，接下来就进入主题。&lt;/p&gt;

&lt;h3&gt;发展路线是什么？&lt;/h3&gt;

&lt;p&gt;　　在正式谈这个话题之前，LZ先要说一下，发展路线到底是什么？&lt;/p&gt;
&lt;p&gt;　　其实发展路线本身的定义很简单，无非是规划自己未来几年到底要达到哪种高度，然后为了这个目标而去努力。&lt;/p&gt;
&lt;p&gt;　　而大部分人在规划自己的职业发展路线时，都是几年当上项目经理，几年当上架构师之类的，包括之前的LZ自己，也是这么给自己定目标的。&lt;/p&gt;
&lt;p&gt;　　但LZ相信，大部分人规划完以后，都会比较迷茫，特别是当上了公司所为的“项目经理”和“架构师”，完成了自己的目标时，反而更会有一种心里茫然的感觉，总觉得哪里不对，又说不上来到底是哪里不对。&lt;/p&gt;
&lt;p&gt;　　事实上，之所以会有这样的感觉，其实是&lt;strong&gt;目标价值不够清晰&lt;/strong&gt;所导致的。&lt;/p&gt;
&lt;p&gt;　　上面这句话，是LZ基于自己的理解所总结的，可能不太好理解，接下来LZ举个例子，相信大家就很容易明白了。&lt;/p&gt;
&lt;p&gt;　　比如很早的时候，那时候还没有货币，大家都是以物换物，因此那时候，每个东西的价值，是很难具体衡量的，可能你觉得比较贵的东西，别人觉得很廉价，反之亦然。&lt;/p&gt;
&lt;p&gt;　　后来，货币出现了，大家对于物品的价值有了直观的感受，拿现在的人民币来举例，每个东西到底值多少钱，是非常具体的一个数字。&lt;/p&gt;
&lt;p&gt;　　因此，在这个时候，价值就很清晰了。&lt;/p&gt;
&lt;p&gt;　　回到刚才的话题，很多人之所以对自己的职业规划茫然，其实本质是因为，“项目经理”、“架构师”这样的称呼，就和之前以物换物时代的物品一样，它的价值是不固定的，当你以一个不固定价值的东西为目标时，就很难衡量你是否达到了目标，你自然就会很迷茫。&lt;/p&gt;
&lt;p&gt;　　因为你根本不知道，你到底有没有达到目标，毕竟你的目标价值本身就很难衡量。&lt;/p&gt;
&lt;p&gt;　　这也是为什么定目标的时候，要强调目标一定要清晰，因为一个无法衡量的目标，很容易让一个人产生迷茫的情绪，也很容易失去斗志。&lt;/p&gt;
&lt;p&gt;　　就比如LZ在工作2年的时候，就坐上了项目经理的位置，管理一个将近20人的团队，看似已经达到了最初LZ给自己定的“项目经理”的目标，但LZ当时却一度十分茫然，因为LZ总觉得此“项目经理”非彼“项目经理”，但又说不上哪里不对，毕竟LZ心目中的那个“项目经理”的价值，根本就无从判断，因此LZ也不知道到底达没达到目标，也不知道到底离真正的目标到底有多远。&lt;/p&gt;
&lt;p&gt;　　再比如有些人，工作几年就当上了某某公司“架构师”甚至是“CTO”，但这个“架构师”和“CTO”的价值到底有多大，其实很难去衡量，因为有的公司可能“CTO”的工资还不如一个大厂的普通资深程序员。&lt;/p&gt;
&lt;p&gt;　　所以，在规划自己的职业发展路线时，给自己定下的目标必须要足够清晰，且可以客观的去衡量，不然你努力之后，压根就不知道自己有没有达标。&lt;/p&gt;
&lt;p&gt;　　那么，说了这么多，重点要来了，到底以什么为目标能满足以上条件呢，答案其实很简单，那就是一个字——“钱”。&lt;/p&gt;
&lt;p&gt;　　很多读者看到这里可能会说了，“你扯了这么半天，就得出这么一个简单的结论，有点太小题大做了吧，这个我早就知道了，我就是这么给自己定目标的，而且我已经达到了目标。”&lt;/p&gt;
&lt;p&gt;　　关于这点，LZ只能说，会者不难难者不会，至少当初的LZ，曾经就被这个问题困扰过。&lt;/p&gt;
&lt;p&gt;　　所以，LZ还是希望借这个文章，专门提醒一下那些还陷于迷茫的程序员们，给自己定目标的时候，千万不要定什么“项目经理”、“架构师”这些虚头巴脑的目标，这只会把你引向迷茫的深渊。&lt;/p&gt;
&lt;p&gt;　　你的一切目标，只能由一个字来判断——“钱”。&lt;/p&gt;

&lt;h3&gt;此“钱”非彼“钱”　　&lt;/h3&gt;

&lt;p&gt;　　有的读者会注意到，LZ给钱加了个双引号，这就意味着，这个标准不仅仅是指的人民币，某些时候，也可以用一些其它的来代替。&lt;/p&gt;
&lt;p&gt;　　但大体上可以分为两种，一种是真正的钱，也就是所谓的人民币，一种则是等级。&lt;/p&gt;
&lt;p&gt;　　而对于等级这种标准，主要是针对大厂程序员来说的，因为从某种程度上来说，大厂程序员的等级，也算是程序员圈子里，比较通用的一种“货币”，因为它也有其比较固定的价值。&lt;/p&gt;
&lt;p&gt;　　而普通厂子里所谓的“高级程序员”、“项目经理”、“架构师”、“CTO”、“技术总监”等等，就不存在任何固定价值了，也无法作为程序员圈子里的“货币”进行流通，就比如你是某小厂的“架构师”，到了大厂里以后，指不定是什么等级，甚至可能你连进都进不去。&lt;/p&gt;
&lt;p&gt;　　因此，这些小厂的title统统没有太多的参考价值，就像卖理财的都叫理财顾问，卖房子的都叫置业顾问一样，这些都只是个title，唯一衡量它们的标准，就是真正的人民币。&lt;/p&gt;
&lt;p&gt;　　好了，说了这么多，接下来要进入正题了。&lt;/p&gt;
&lt;p&gt;　　其实前面说清楚了，真正说发展路线反倒比较简单，LZ无非就是给出一个相对比较中等（偏上）的标准，然后让大家来参考，以此来衡量自己到底达到了什么水平，这样就不容易迷茫。&lt;/p&gt;
&lt;p&gt;　　这就好像你高考前准备考试一样，你可能学完以后老会感觉心里没底，但如果你知道了大家都是什么水平以后，你或许心里就会淡定许多了。&lt;/p&gt;
&lt;p&gt;　　而LZ给出这个标准，就是这么个道理，让你知道大多数程序员，他们的水平大概是什么样的，这样你对比自己以后，就会心里有点X数了，这样就不至于太迷茫。&lt;/p&gt;
&lt;p&gt;　　同时，考虑到很多人的起步不同，因此LZ大致分成了两种路线来说，接下来咱们就一一来看下。&lt;/p&gt;

&lt;h3&gt;大厂（高端）程序员发展路线&lt;/h3&gt;

&lt;p&gt;　　先来谈一谈大厂程序员发展路线，这一部分，主要说的是那些应届就进入大厂的程序员们，也就是起点比较高的这批人，LZ也称这部分人为高端程序员。&lt;/p&gt;
&lt;p&gt;　　其实这些人的发展路线，一般都是比较固定的，无非就是各个大厂之间来回穿梭，而大厂之间一般都有个等级的折算，因此这批人的发展路线很容易规划，就按照等级来规划就可以了。&lt;/p&gt;
&lt;p&gt;　　根据LZ以往的经验，总结一下就是，头几年234，后面看老天。&lt;/p&gt;
&lt;p&gt;　　翻译一下就是，第一次晋升2年，第二次晋升3年，第三次晋升4年，后面就看情况吧。&lt;/p&gt;
&lt;p&gt;　　拿某里应届生来举例，入厂一般是P5，那么比较合理的发展路线就是，2年升P6，再过3年升P7，再过4年升P8，后面的就交给老天吧。&lt;/p&gt;
&lt;p&gt;　　当然了，LZ给的这个路线，只是作为参考，毕竟LZ自己不属于高端程序员这个群体，因此也不能很确定的给出一个十分官方的标准。&lt;/p&gt;
&lt;p&gt;　　而且不管你是高端程序员，还是接下来LZ要谈的低端程序员，你还有一个可以对比的群体，那就是你的同学，特别是科班出身的同学，同学大多也都是干这个的，那么横向对比之下，你就很容易知道你是否掉队。&lt;/p&gt;
&lt;p&gt;　　而像LZ这种数学专业毕业的就比较悲剧了，同学都是当数学老师的，也没什么可以对比的对象。&lt;/p&gt;

&lt;h3&gt;非大厂（低端）程序员发展路线&lt;/h3&gt;

&lt;p&gt;　　和高端程序员相反，低端程序员自然就是指的，那些没能一开始就进入大厂的程序员。&lt;/p&gt;
&lt;p&gt;　　这部分程序员中还有一大批和LZ一样从培训班出来的，这部分人往往做了一段时间，体会了高工资所带来的少许快感之后，就容易产生迷茫，因为他们往往不知道自己现在是什么水平，达到了什么程度，以及达到什么程度才算达标。&lt;/p&gt;
&lt;p&gt;　　因为这部分程序员大多混迹于各种不知名的公司，而很多公司并没有大厂那种明确的等级制度，薪资也往往不是和职称直接挂钩的，就比如LZ之前做项目经理的那家公司，升职到项目经理之后，其实薪资并没有什么太大的涨幅，这就容易让人越做越迷茫。&lt;/p&gt;
&lt;p&gt;　　在这里，LZ再次郑重的描述一下，此类低端程序员的发展路线（LZ也属于这一类，培训出身），到底到一定年限应该达到什么样的水平。&lt;/p&gt;
&lt;p&gt;　　一线城市以北京为例，应届生目前基本在年薪10-15W左右，3年基本在年薪30-35W左右，而5年则基本在年薪50W左右。&lt;/p&gt;
&lt;p&gt;　　二线城市则以杭州为例，应届生目前基本年薪在5-10W左右，3年基本在25W左右，而5年则基本在40-45W左右。&lt;/p&gt;
&lt;p&gt;　　LZ给出的这个标准，是中等偏上的水平，因此如果你能跟上，那么你基本上已经超越了大部分人。&lt;/p&gt;
&lt;p&gt;　　另外，还有一种情况需要说一下，那就是低端程序员有的时候，也会进入大厂，而进入大厂之后，可以继续参考上面大厂程序员的路线。&lt;/p&gt;
&lt;p&gt;　　比如某小A四年工作经验时进了某里，职级P6，那么他大体应该在3年内升P7，4年内升P8，同样的，到了P8之后，就看老天了。&lt;/p&gt;
&lt;p&gt;　　按照这样的标准，你就可以随时审视自己，看自己走到了哪一步，看看自己掉队了多少，又或者是领先了多少。&lt;/p&gt;

&lt;h3&gt;再谈发展路线&lt;/h3&gt;

&lt;p&gt;　　看完上面的内容后，有的同学可能会比较受打击，觉得自己离这个标准太远，这也是为什么LZ把标题起为“否则一切已晚矣”的原因。&lt;/p&gt;
&lt;p&gt;　　因为LZ想告诉新人们，如果你觉得你受打击了，那么说明你已经掉队了，那你就得努力跟上，不然你会离队伍越来越远。&lt;/p&gt;
&lt;p&gt;　　这就像当初有个读者问LZ，“我看我回老家的那些同学生活的也很好，而我在北京反而生活的紧巴巴，感觉生活条件还不如在老家，这样在北京漂着真的值得吗？”&lt;/p&gt;
&lt;p&gt;　　LZ当时的回答是，当他回老家的那一刻，其实你们的差距就已经产生了，只不过短时间内体现不出来而已。&lt;/p&gt;
&lt;p&gt;　　试想一下，假设他在老家年薪10W，你在北京年薪30W，那么一年以后你们的资产就差20W，10年之后，20年之后呢？&lt;/p&gt;
&lt;p&gt;　　这还没算两者涨薪的差距，更何况很多人的老家根本达不到年薪10W，而很多在北京的人也不止年薪30W。&lt;/p&gt;
&lt;p&gt;　　所以，这就是所谓的，一旦掉队，就会掉队的越来越厉害，甚至到最后，你根本就追不上了。&lt;/p&gt;
&lt;p&gt;　　之所以有这样的感慨，其实也是因为LZ自身的经历所致。&lt;/p&gt;
&lt;p&gt;　　在众多读者的眼里，LZ一直扮演着一个还算比较成功的程序员，事实上LZ自己也觉得自己确实已经很幸运了，通过自己的努力，拥有了稳定的生活，作为一个老百姓来说，这其实已经算是很成功了。&lt;/p&gt;
&lt;p&gt;　　但其实从上面那个标准来说，LZ其实也掉队了，而掉队的原因，就是因为LZ之前压根就没有意识到这一点，甚至因为LZ是培训班出身，当时LZ觉得自己反而已经是走在了很多人的前面。&lt;/p&gt;
&lt;p&gt;　　事实上也确实如此，如果按照当时培训班的同学水平来说，LZ确实是走在了很多人，甚至是绝大多数人的前面。&lt;/p&gt;
&lt;p&gt;　　但进了大厂之后，LZ就发现，因为你的起点比较低，其实你已经无形当中落后了很多，而你必须抓紧时间追赶，才能跟上脚步，而如果你没有及时领会到这一点，你就可能失去追赶的机会。&lt;/p&gt;
&lt;p&gt;　　而当一个人满足于现状的时候，是很容易失去这种紧迫感的，因此结局很简单，LZ掉队了。&lt;/p&gt;
&lt;p&gt;　　当然了，这其中其实也有一部分生活的原因，如果LZ是孑身一人，或许LZ当初根本不会来杭州，就算要去大厂，或许也会留在北京，那可能就又是另外一番景象了。&lt;/p&gt;
&lt;p&gt;　　但是，人生无悔，LZ从来不后悔自己做的任何一个决定，所以，感慨归感慨，但LZ从来无悔。&lt;/p&gt;
&lt;p&gt;　　不过，如果可能的话，LZ希望可以警醒一部分新人，&lt;strong&gt;一定要让自己保持不掉队，特别是头5年，十分的重要，如果你前面5年掉队了，那么，后面你追赶的代价，将会是以前的数倍，因为，你在进步的同时，别人也在进步，甚至比你还快，而且别人更早的上位后，会拥有更多的机会，如此恶性循环，你失去的，不仅仅是那一点点掉队的距离，还有前方无数的机会，都会被别人捷足先登&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　比如某里有两个P6，其中一个先一步升了P7，结果后来团队扩张，需要人来带团队，那么谁来带？肯定是P7来带。&lt;/p&gt;
&lt;p&gt;　　后来，因为团队的扩展，P7可能很快又升P8了，而那个P6，可能还是那个P6，他依旧还在那里，不骄不躁。&lt;/p&gt;
&lt;p&gt;　　这就是典型的，一步差，步步差。&lt;/p&gt;
&lt;p&gt;　　所以，请不要给自己留遗憾，在该奋斗的年纪，做该做的事，杜绝温水煮青蛙，你的未来，原本可以更精彩。&lt;/p&gt;

&lt;h3&gt;再谈生活发展路线&lt;/h3&gt;

&lt;p&gt;　　说完了工作，咱们来谈谈生活。&lt;/p&gt;
&lt;p&gt;　　生活发展路线是什么？&lt;/p&gt;
&lt;p&gt;　　这个绝大多数人都是一样的，谈恋爱、买房、结婚、生子，不排除部分不婚主义者和丁克一族，但这些毕竟是少数，千百年来形成的人类发展路线，个人其实很难抗衡，如果你要抗衡，你就要面对来自外界异样的眼光和批判，甚至也包括家人的阻拦。&lt;/p&gt;
&lt;p&gt;　　大部分人，最终依旧会选择妥协，但其实妥协的时候，往往只会更加痛苦。&lt;/p&gt;
&lt;p&gt;　　该恋爱的年纪没谈恋爱，该结婚的年纪没结婚，该生孩子的年纪没生孩子，该买房的年纪没买房，到时候，只会留下一地的感慨和遗憾。&lt;/p&gt;
&lt;p&gt;　　当然了，每个人的情况都不同，到底什么时候该做什么，无法一概而论，但和职场一样，LZ也希望警醒一部分人，不要和工作一样，温水煮青蛙，总是被动的等待着，不主动去争取，总觉得该来的总是会来的，就像当初的LZ总觉得该晋升的时候，自然就会晋升的。&lt;/p&gt;
&lt;p&gt;　　事实证明，该来的不会自己来，只会越走越远，你必须要自己主动想办法。&lt;/p&gt;
&lt;p&gt;　　相信大多数人，在年轻时都产生过此生不结婚，此生不生子的想法，但其实这些想法，最终都会被现实打败。&lt;/p&gt;
&lt;p&gt;　　俗话说退一步海阔天空，其实有时候你退一步看一看，你会发现，其实结婚生子这些俗套的东西，并没有你想象中的那么无趣，反而会让你觉得生活更加精彩。&lt;/p&gt;
&lt;p&gt;　　一个人的精彩，终究是要落幕的，但一家人的精彩，却可以永世传承。&lt;/p&gt;
&lt;p&gt;　　所以，LZ奉劝部分年轻人，放弃掉这些不切实际的想法，这么多人走过的路线，不说一定是正确的，但至少不会是错误的，就算是错误的，参考围城逻辑，你也要走一遍，才能走出这个围城，去真正的享受一个人的精彩。&lt;/p&gt;
&lt;p&gt;　　有些南墙，终究是要去撞一撞的。&lt;/p&gt;

&lt;h3&gt;结语&lt;/h3&gt;

&lt;p&gt;　　好了，到这里，文章想表达的内容LZ基本上讲完了。&lt;/p&gt;
&lt;p&gt;　　不知道各位读者看完的感受是什么，或许是亚历山大，或许是恍然大悟，或许是一番感慨，也或许是嗤之以鼻。&lt;/p&gt;
&lt;p&gt;　　但无论是什么，工作是你的，生活是你的，自己的选择，自己来负责。&lt;/p&gt;

&lt;h3&gt;结尾彩蛋&lt;/h3&gt;

&lt;p&gt;　　文末，送上彩蛋一张（自从有了孩子，就有了彩蛋，-_-），抖音说孩子们带上口罩，其实一直在舔，这事是真的，/捂脸。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/558323/202005/558323-20200506230158237-1605309549.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;776&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 May 2020 15:14:00 +0000</pubDate>
<dc:creator>左潇龙</dc:creator>
<og:description>引言 看到这个标题的时候，相信大部分人的第一反应一定是：卧槽！标题党来了！ 是的，你猜对了，-_-。 其实之所以写这篇文章，是因为有一个读者，遇到了人生中一次比较重要的抉择，因而来咨询LZ，而LZ恰好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zuoxiaolong/p/12834121.html</dc:identifier>
</item>
<item>
<title>C# 9.0 新特性预览 - 类型推导的 new - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-target-typed-new.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/csharp-9-0-preview-target-typed-new.html</guid>
<description>&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;138.58646616541&quot;&gt;


&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;http://cnblogs.com/Rwing/csharp-9-0-preview-target-typed-new.html&quot;&gt;C# 9.0 新特性预览 - 类型推导的 new&lt;/a&gt;]&lt;br/&gt;[C# 9.0 新特性预览 - Lambda 中的弃元]&lt;br/&gt;[C# 9.0 新特性预览 - 更简便的空参数检查]&lt;br/&gt;[C# 9.0 新特性预览 - Record 类型]&lt;br/&gt;[C# 9.0 新特性预览 - 模式匹配的改善]&lt;br/&gt;[C# 9.0 新特性预览 - 其他小的变化]&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;具有类型推导的-new-表达式-target-typed-new-expressions&quot;&gt;具有类型推导的 new 表达式 (Target-typed new expressions)&lt;/h3&gt;
&lt;p&gt;这是一个本应随着 C# 8.0 发布的语言特性，但因种种原因在发布 C# 8.0 的最后关头，它被移出了最终的发布版本，下面我们来认识认识它。&lt;br/&gt;大家都知道，C# 在3.0中新增 var 关键字来做隐式类型声明，把繁重的声明语法简化了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt; field = new Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt;()
// 可以简化为
var field = new Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt;()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;var 关键字的基本原理不再复述，简单说就是编译器可以根据等号后面的类型推导出 var 的类型，那么是不是也可以反过来，我们先声明类型，接下来的 new 关键字后面就不用写类型了呢？于是本文介绍的特性来了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt; field = new Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt;()
// C# 9.0 中可以写成
Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt; field = new()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上代码可以看出语法很简单，即省略了繁琐的可以推导出的类型。&lt;br/&gt;其语法 Spec 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'new' '(' argument_list? ')' object_or_collection_initializer?
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搭配初始化器，我们可以进一步简化带有初始值的初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Dictionary&amp;lt;string, List&amp;lt;int&amp;gt;&amp;gt; field = new() {
    { &quot;item1&quot;, new() { 1, 2, 3 } }
};
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;进一步展示该语法在各种情况下的使用&quot;&gt;进一步展示该语法在各种情况下的使用&lt;/h4&gt;
&lt;p&gt;在所有可以推导出类型的上下文中，都可以使用，例如：&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;XmlReader.Create(reader, new() { IgnoreWhitespace = true });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;带有参数的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class C {
    C(params int[] p) {}
}

C c = new(1, 2, 3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方法时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class A {}
static void M(A a) {};

M(a: new());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合对象初始化器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;X x = new() { field = 42 };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;泛型的类型推导，需要注意，要有一个显示类型声明才能正确推导：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void M&amp;lt;T&amp;gt;(T t1, T t2) {}

M(new X(), new());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似的，数组的声明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var arr = new[] {new X(), new()};
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;不适用此特性的场景&quot;&gt;不适用此特性的场景&lt;/h4&gt;
&lt;p&gt;值类型的初始化，可以使用 default 替代&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int x = new(); // ERROR
Struct y = new(); // ERROR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 as 操作时无法正确推导&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Console.Write(new() as X); // ERROR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自然，使用 var 时也无法推导&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var x = new(); // ERROR
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有歧义的重载&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void M(object a, X b) =&amp;gt; Console.Write($&quot;{a} {b}&quot;);
void M(X a, object b) =&amp;gt; Console.Write($&quot;{a} {b}&quot;);

M(new(), new()); // ERROR
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;&quot;/&gt;

&lt;h4 id=&quot;需要注意的地方&quot;&gt;需要注意的地方&lt;/h4&gt;
&lt;p&gt;这个新语法 &lt;em&gt;new()&lt;/em&gt;，比较容易与匿名类型语法混淆 &lt;em&gt;new{}&lt;/em&gt;，它们两个是完全不同的东西，需要注意一下。&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;[&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/proposals/target-typed-new.md&quot;&gt;Proposal: Target-typed new expressions&lt;/a&gt;]&lt;br/&gt;[&lt;a href=&quot;https://github.com/alrz/roslyn/blob/b1ef1749807de388eedeb2b28962cc3c28f2be95/src/Compilers/CSharp/Test/Semantic/Semantics/TargetTypedNewTests.cs&quot;&gt;Unit test: TargetTypedNewTests.cs&lt;/a&gt;]&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 06 May 2020 14:48:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>随着 .NET 5 发布日期的日益临近，其对应的 C# 新版本已确定为 C# 9.0，其中新增加的特性（或语法糖）也已基本锁定，本系列文章将向大家展示它们。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rwing/p/csharp-9-0-preview-target-typed-new.html</dc:identifier>
</item>
<item>
<title> abp(net core)+easyui+efcore实现仓储管理系统——入库管理之十一(四十七)  - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/12839212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/12839212.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;   入库单的每一条明细数据，会对应一个或多个库位。这就要求能够对某一行的数据进行子表嵌套。在这里通过采用&lt;/span&gt;easyui的datagrid-detailview.js&lt;span&gt;插件&lt;/span&gt;&lt;span&gt;创建子表格，大致的效果图如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;script src=&quot;~/lib/easyui-1.8/datagrid-detailview.js&quot; asp-append-version=&quot;true&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;      2. 在Visual Studio 2017的“解决方案资源管理器”中，找到&lt;span&gt;表示&lt;/span&gt;&lt;span&gt;层&lt;/span&gt;“ABP.TPLMS.Web.Mvc”项目中的wwwroot\view-resources\InStock&lt;span&gt;目录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       3. 在InStock&lt;span&gt;目录中找到&lt;/span&gt;Index.js文件。&lt;span&gt;在此文件的头部&lt;/span&gt;&lt;span&gt;我们要定义两个变量&lt;/span&gt;mainIndex与editIndex&lt;span&gt;，用来定位当前我们选中了哪一行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; editIndex =&lt;span&gt; undefined;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mainIndex = undefined;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;       4. &lt;span&gt;我们在此文件中的&lt;/span&gt;showDetail(no)方法中找到datagrid组件，并修改此组件的onClickRow事件中的相关代码。&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;209&quot;&gt;
&lt;pre&gt;
 
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ShowDetail(no) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; lastIndex;
    $(&lt;/span&gt;&quot;#dgINOD&quot;&lt;span&gt;).datagrid({
        url: &lt;/span&gt;&quot;/InStock/GetDetail?no=&quot; +&lt;span&gt; no,
        title: &lt;/span&gt;&quot;入库单明细&quot;&lt;span&gt;,
        pagination: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,     

        fit: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        loadMsg: &lt;/span&gt;&quot;正在加载入库单明细信息...&quot;&lt;span&gt;,
        toolbar: [
            { text: &lt;/span&gt;'添加明细', iconCls: 'icon-add', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { ShowCargoInfo(); } },
            { text: &lt;/span&gt;'添加库位', iconCls: 'icon-edit', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { SubGridAddRow(); } },
            { text: &lt;/span&gt;'删除', iconCls: 'icon-remove', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { deviceInfoDeleteClick(); } },
            &lt;/span&gt;'-'&lt;span&gt;

        ],

        nowarp: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        border: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        idField: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortName: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortOrder: &lt;/span&gt;&quot;asc&quot;&lt;span&gt;,
        singleSelect: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        iconCls: &lt;/span&gt;'icon-edit'&lt;span&gt;,      

        columns: [[
            { title: &lt;/span&gt;&quot;编号&quot;, field: &quot;SeqNo&quot;, width: 50, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;入库单号&quot;, field: &quot;InStockNo&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;HSCode&quot;, field: &quot;HSCode&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货物代码&quot;, field: &quot;CargoCode&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货物名称&quot;, field: &quot;CargoName&quot;, width: 160, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;规格型号&quot;, field: &quot;Spcf&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;数量&quot;, field: &quot;Qty&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 4&lt;span&gt;

                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;长&quot;, field: &quot;Length&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;宽&quot;, field: &quot;Width&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;高&quot;, field: &quot;Height&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }

            },

            { title: &lt;/span&gt;&quot;产销国&quot;, field: &quot;Country&quot;, width: 70, align: 'center'&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;单价&quot;, field: &quot;Price&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },       

            {
                title: &lt;/span&gt;&quot;总价&quot;, field: &quot;TotalAmt&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },

            { title: &lt;/span&gt;&quot;包装&quot;, field: &quot;Package&quot;, width: 70, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;&quot;计量单位&quot;, field: &quot;Unit&quot;, width: 70, align: 'center'&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;总体积&quot;, field: &quot;Vol&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {
                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {

                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 4&lt;span&gt;
                    }
                }
            },
           { title: &lt;/span&gt;&quot;品牌&quot;, field: &quot;Brand&quot;, width: 70, align: 'center'&lt;span&gt; }

        ]],
        view: detailview,

        detailFormatter: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, row) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '&amp;lt;div style=&quot;padding:2px&quot;&amp;gt;&amp;lt;table id=&quot;dgINODItem-' + index + '&quot;&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;;
        },

        onExpandRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, row) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ddv = $('#dgINODItem-' +&lt;span&gt; index);
            ddv.datagrid({
                url: &lt;/span&gt;'/InStock/GetLocs?Id=' +&lt;span&gt; row.Id,
                fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

                singleSelect: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                rownumbers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

                loadMsg: &lt;/span&gt;''&lt;span&gt;,
                height: &lt;/span&gt;'auto'&lt;span&gt;,
                columns: [[
                    { field: &lt;/span&gt;'SeqNo', title: '序号', width: 50&lt;span&gt; },
                    {
                        field: &lt;/span&gt;'Qty', title: '数量', width: 120&lt;span&gt;, editor: {
                            type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                                required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                            }
                        }
                    },
                    {
                        field: &lt;/span&gt;'Loc', title: '库位', width: 150&lt;span&gt;, editor: {

                            type: &lt;/span&gt;'text'&lt;span&gt;, options: {
                                required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                            }
                        }
                    },

                    { field: &lt;/span&gt;'CreationTime', title: '创建时间', hidden: 'true'&lt;span&gt; },

                    { field: &lt;/span&gt;'Id', title: 'Id', width: 50, hidden: 'true'&lt;span&gt; },
                    { field: &lt;/span&gt;'InStockOrderDetailId', title: 'InodId', width: 50, hidden: 'true'&lt;span&gt; }
                ]],

                onResize: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);
                },
                onLoadSuccess: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);

                    }, &lt;/span&gt;0&lt;span&gt;);
                    editIndex &lt;/span&gt;= undefined;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主网格换行&lt;/span&gt;
&lt;span&gt;                },
                onAfterEdit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (rowIndex, rowData, changes) {
                    editIndex &lt;/span&gt;=&lt;span&gt; undefined;
                },

                onClickRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index1, row1) {

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editIndex !=&lt;span&gt; index1) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (endEditing(ddv)) {
                            ddv.datagrid(&lt;/span&gt;'selectRow', index1).datagrid('beginEdit'&lt;span&gt;, index1);
                            editIndex &lt;/span&gt;=&lt;span&gt; index1;

                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { ddv.datagrid('selectRow'&lt;span&gt;, editIndex); }
                    }
                }
            });
            $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);
        }, 

        onClickRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, rowData) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainIndex!=&lt;span&gt;undefined) {
                $(&lt;/span&gt;'#dgINOD').datagrid('collapseRow'&lt;span&gt;, mainIndex);

            }           

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastIndex !=&lt;span&gt; index) {
                $(&lt;/span&gt;'#dgINOD').datagrid('endEdit'&lt;span&gt;, lastIndex);
                editrow(index);
            }
            lastIndex &lt;/span&gt;=&lt;span&gt; index;
            mainIndex &lt;/span&gt;=&lt;span&gt; index;
        },       

        onBeginEdit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (rowIndex, rowData) {  
            setEditing(rowIndex);
        }
    });
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;5. 除了要修改上面的函数之外，我们还需要添加一些函数方法。下面就给出Index.js的全部代码：&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;475&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------------------系统管理--&amp;gt;入库单管理-----------------------//&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; editIndex =&lt;span&gt; undefined;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mainIndex =&lt;span&gt; undefined;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新数据&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initable() {
    $(&lt;/span&gt;&quot;#dgINSO&quot;&lt;span&gt;).datagrid({
        url: &lt;/span&gt;&quot;/InStock/List&quot;&lt;span&gt;,
        title: &lt;/span&gt;&quot;入库单管理&quot;&lt;span&gt;,
        pagination: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        pageSize: &lt;/span&gt;10&lt;span&gt;,
        pageList: [&lt;/span&gt;10, 20, 30&lt;span&gt;],
        fit: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

        loadMsg: &lt;/span&gt;&quot;正在加载入库单信息...&quot;&lt;span&gt;,

        nowarp: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        border: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        idField: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortName: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortOrder: &lt;/span&gt;&quot;asc&quot;&lt;span&gt;,

        frozenColumns: [[&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冻结列&lt;/span&gt;
            { field: &quot;ck&quot;, checkbox: &lt;span&gt;true&lt;/span&gt;, align: &quot;left&quot;, width: 50&lt;span&gt; }           

        ]],
        columns: [[
            { title: &lt;/span&gt;&quot;编号&quot;, field: &quot;Id&quot;, width: 50, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;入库单号&quot;, field: &quot;No&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },           

            {title: &lt;/span&gt;&quot;状态&quot;, field: &quot;Status&quot;, width: 50&lt;span&gt;            },
            { title: &lt;/span&gt;'到货日期', field: 'ReceiveTime',  width: 100, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货主&quot;, field: &quot;OwnerCode&quot;, width: 150, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;预计到货时间&quot;, field: &quot;PreDeliveryTime&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;'客户', field: 'CustomerName', width: 120, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;'收货人',field: 'Oper', width: 100, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;'审核人',field: 'Checker', width: 120, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;'件数', field: 'PackageQty', width: 100, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;'创建时间', field: 'CreationTime', width: 100, align: 'center'&lt;span&gt; }
        ]]
    }); 

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示送货单数据&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ShowCargo() {
    abp.log.warn(&lt;/span&gt;'货物信息列表日志...'&lt;span&gt;);

    $(&lt;/span&gt;&quot;#dgCargo&quot;&lt;span&gt;).datagrid({
        url: &lt;/span&gt;&quot;/Cargo/List&quot;&lt;span&gt;,
        title: &lt;/span&gt;&quot;货物管理管理&quot;&lt;span&gt;,
        pagination: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        pageSize: &lt;/span&gt;10&lt;span&gt;,
        pageList: [&lt;/span&gt;10, 20, 30&lt;span&gt;],

        fit: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        loadMsg: &lt;/span&gt;&quot;正在加载货物信息...&quot;&lt;span&gt;,
        nowarp: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        border: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

        idField: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortName: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,
        sortOrder: &lt;/span&gt;&quot;asc&quot;&lt;span&gt;,

        frozenColumns: [[&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冻结列&lt;/span&gt;
            { field: &quot;ck&quot;, checkbox: &lt;span&gt;true&lt;/span&gt;, align: &quot;left&quot;, width: 50&lt;span&gt; }
        ]],

        columns: [[
            { title: &lt;/span&gt;&quot;编号&quot;, field: &quot;Id&quot;, width: 50, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;供应商&quot;, field: &quot;SupplierId&quot;, width: 80, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;HSCode&quot;, field: &quot;HSCode&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },

            { title: &lt;/span&gt;&quot;货物代码&quot;, field: &quot;CargoCode&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货物名称&quot;, field: &quot;CargoName&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },

            { title: &lt;/span&gt;&quot;规格型号&quot;, field: &quot;Spcf&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;产销国&quot;, field: &quot;Country&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;计量单位&quot;, field: &quot;Unit&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;包装&quot;, field: &quot;Package&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;单价&quot;, field: &quot;Price&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;币制&quot;, field: &quot;Curr&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;长宽高&quot;, field: &quot;Length&quot;, width: 100, sortable: &lt;span&gt;false&lt;/span&gt;, formatter: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value, row, index) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; row.Length + '*' + row.Width + '*' +&lt;span&gt; row.Height;
                }
            },
            { title: &lt;/span&gt;&quot;体积&quot;, field: &quot;Vol&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;备注&quot;, field: &quot;Remark&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;'创建时间', field: 'CreationTime', width: 100, align: 'center'&lt;span&gt; }

        ]]
    });

    abp.log.warn(&lt;/span&gt;'3货物信息列表日志...'&lt;span&gt;);
} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ShowCargoInfo() {  
    $(&lt;/span&gt;&quot;#divImportCargo&quot;&lt;span&gt;).dialog({
            closed: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            title: &lt;/span&gt;&quot;选择货物信息&quot;&lt;span&gt;,
            modal: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            width: &lt;/span&gt;820&lt;span&gt;,
            height: &lt;/span&gt;550&lt;span&gt;,
            collapsible: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            minimizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            maximizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            resizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        });
       ShowCargo();
       $(&lt;/span&gt;&quot;#dgCargo&quot;).datagrid(&quot;clearChecked&quot;&lt;span&gt;);
       $(&lt;/span&gt;&quot;#dgCargo&quot;).datagrid(&quot;clearSelections&quot;&lt;span&gt;);
} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; reloaded() {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;reload&lt;/span&gt;
    $(&quot;#reload&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;        $('#dgINSO').datagrid('reload'&lt;span&gt;);
    });}
 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改点击按钮事件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updInSOInfo() {  
    $(&lt;/span&gt;&quot;#edit&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {      

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断选择的中&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; row = $(&quot;#dgINSO&quot;).datagrid('getSelected'&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (row) {         
            $.messager.confirm(&lt;/span&gt;'编辑', '您想要编辑吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r) {                

                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开对话框编辑&lt;/span&gt;
                    $(&quot;#divAddUpdINO&quot;&lt;span&gt;).dialog({
                        closed: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                        title: &lt;/span&gt;&quot;修改入库单&quot;&lt;span&gt;,
                        modal: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        width: &lt;/span&gt;820&lt;span&gt;,
                        height: &lt;/span&gt;550&lt;span&gt;,
                        collapsible: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        minimizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        maximizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        resizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

                    });    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先绑定                  &lt;/span&gt;
&lt;span&gt;
                    showINO(row);
                    defaultTab();
                    ShowDetail(row.No);
                }               

            });

            SetEnabled(row.Status);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            $.messager.alert(&lt;/span&gt;'提示', ' 请选择要编辑的行！', 'warning'&lt;span&gt;);
        }
    });   
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; deleteInSO() {
    $(&lt;/span&gt;&quot;#del&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = $(&quot;#dgINSO&quot;).datagrid(&quot;getSelections&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows.length &amp;gt; 0&lt;span&gt;) {
            $.messager.confirm(&lt;/span&gt;&quot;提示&quot;, &quot;确定要删除吗?&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; codes = []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要不是{}&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {
                        codes.push(rows[i].Id);
                    }

                    $.post(&lt;/span&gt;&quot;/InStock/Delete&quot;, { &quot;ids&quot;: codes.join(',') }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data == &quot;OK&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;删除成功！&quot;&lt;span&gt;);
                            $(&lt;/span&gt;&quot;#dgINSO&quot;).datagrid(&quot;clearChecked&quot;&lt;span&gt;);
                            $(&lt;/span&gt;&quot;#dgINSO&quot;).datagrid(&quot;clearSelections&quot;&lt;span&gt;);
                            $(&lt;/span&gt;&quot;#dgINSO&quot;).datagrid(&quot;load&quot;&lt;span&gt;, {});
                        }                       
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data == &quot;NO&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;删除失败！&quot;&lt;span&gt;);

                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                    });
                }
            });
        }
    })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空文本框&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; clearAll() {    
    $(&lt;/span&gt;&quot;#divAddUpdINO input&quot;).each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).val(&quot;&quot;&lt;span&gt;);

        });
    $(&lt;/span&gt;&quot;#PreDeliveryTimeUpdate&quot;&lt;span&gt;).val(getNowFormatDate());    

    $(&lt;/span&gt;&quot;#StatusUpdate&quot;).val(&quot;0&quot;&lt;span&gt;);
    $(&lt;/span&gt;&quot;#NwtUpdate&quot;).val(&quot;0&quot;&lt;span&gt;); 

    $(&lt;/span&gt;&quot;#GwtUpdate&quot;).val(&quot;0&quot;&lt;span&gt;);
    $(&lt;/span&gt;&quot;#PackageQtyUpdate&quot;).val(&quot;0&quot;&lt;span&gt;);
  

}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetNo() {
    $.get(abp.appPath &lt;/span&gt;+ &quot;api/services/app/InStockOrder/GetNo&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        $(&lt;/span&gt;&quot;#UpdNO&quot;&lt;span&gt;).val(data);
    });

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前时间，格式YYYY-MM-DD&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getNowFormatDate() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; date = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; seperator1 = &quot;-&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year =&lt;span&gt; date.getFullYear();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; month = date.getMonth() + 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strDate =&lt;span&gt; date.getDate();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (month &amp;gt;= 1 &amp;amp;&amp;amp; month &amp;lt;= 9&lt;span&gt;) {
        month &lt;/span&gt;= &quot;0&quot; +&lt;span&gt; month;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strDate &amp;gt;= 0 &amp;amp;&amp;amp; strDate &amp;lt;= 9&lt;span&gt;) {
        strDate &lt;/span&gt;= &quot;0&quot; +&lt;span&gt; strDate;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentdate = year + seperator1 + month + seperator1 +&lt;span&gt; strDate;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentdate;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将表单数据转为json&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; form2Json(id) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = $(&quot;#&quot; +&lt;span&gt; id).serializeArray()

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jsonStr = &quot;&quot;&lt;span&gt;; 

    jsonStr &lt;/span&gt;+= '{'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
        jsonStr &lt;/span&gt;+= '&quot;' + arr[i].name + '&quot;:&quot;' + arr[i].value + '&quot;,'&lt;span&gt;

    }
    jsonStr &lt;/span&gt;= jsonStr.substring(0, (jsonStr.length - 1&lt;span&gt;));

    jsonStr &lt;/span&gt;+= '}' 

    &lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JSON.parse(jsonStr)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; json

} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetEnabled(status) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (status == &quot;提交&quot;&lt;span&gt;) {
        $(&lt;/span&gt;&quot;#btnSave&quot;).prop('disabled', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        $(&lt;/span&gt;&quot;#btnSave&quot;).removeAttr(&quot;disabled&quot;&lt;span&gt;);

    }
}
 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; defaultTab() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认显示第一个tab&lt;/span&gt;
    $('#box').tabs('select', &quot;入库单&quot;&lt;span&gt;);

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出 导入送货单的的对话框&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showInSODialog() {
    $(&lt;/span&gt;&quot;#add&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {     

            $.messager.confirm(&lt;/span&gt;'编辑', '您想要创建入库单吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开对话框编辑&lt;/span&gt;
                    $(&quot;#divAddUpdINO&quot;&lt;span&gt;).dialog({
                        closed: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                        title: &lt;/span&gt;&quot;新增入库单&quot;&lt;span&gt;,
                        modal: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        width: &lt;/span&gt;820&lt;span&gt;,
                        height: &lt;/span&gt;550&lt;span&gt;,
                        collapsible: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        minimizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        maximizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        resizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

                    });                  

                }
                defaultTab();
                GetNo();
                clearAll();
                ShowDetail(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
            });       

    });  

    $(&lt;/span&gt;&quot;#btnSave&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {    

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; id = $(&quot;#IDUpdate&quot;&lt;span&gt;).val();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == &quot;&quot; || id ==&lt;span&gt; undefined) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证&lt;/span&gt;
            $.messager.confirm('确认', '您确认要保存吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r) {                   

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; GetINO();                    

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (postData.No == &quot;&quot; || postData.CustomerCode == &quot;&quot; || postData.CustomerName==&quot;&quot; || postData.OwnerName==&quot;&quot;&lt;span&gt;) {
                        $.messager.alert(&lt;/span&gt;'提示', ' 请填写相关必填项！', 'warning'&lt;span&gt;);

                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }                   

                    $.post(&lt;/span&gt;&quot;/InStock/Add&quot;, postData, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data == &quot;OK&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;保存成功！&quot;&lt;span&gt;);

                            initable();
                            collapseRows();
                        }

                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data == &quot;NO&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;保存失败！&quot;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                        }

                    });
                }
            })
        }

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            saveDetail();
            initable();
            collapseRows();

        }

    });
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加明细&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ShowDetail(no) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; lastIndex;
    $(&lt;/span&gt;&quot;#dgINOD&quot;&lt;span&gt;).datagrid({
        url: &lt;/span&gt;&quot;/InStock/GetDetail?no=&quot; +&lt;span&gt; no,
        title: &lt;/span&gt;&quot;入库单明细&quot;&lt;span&gt;,
        pagination: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,      
        fit: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

        fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        loadMsg: &lt;/span&gt;&quot;正在加载入库单明细信息...&quot;&lt;span&gt;,
        toolbar: [
            { text: &lt;/span&gt;'添加明细', iconCls: 'icon-add', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { ShowCargoInfo(); } },
            { text: &lt;/span&gt;'添加库位', iconCls: 'icon-edit', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { SubGridAddRow(); } },
            { text: &lt;/span&gt;'删除', iconCls: 'icon-remove', handler: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { deviceInfoDeleteClick(); } },
            &lt;/span&gt;'-'&lt;span&gt;
        ],

        nowarp: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

        border: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,

        idField: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,

        sortName: &lt;/span&gt;&quot;Id&quot;&lt;span&gt;,

        sortOrder: &lt;/span&gt;&quot;asc&quot;&lt;span&gt;,
        singleSelect: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        iconCls: &lt;/span&gt;'icon-edit'&lt;span&gt;,      

        columns: [[
            { title: &lt;/span&gt;&quot;编号&quot;, field: &quot;SeqNo&quot;, width: 50, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;入库单号&quot;, field: &quot;InStockNo&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },

            { title: &lt;/span&gt;&quot;HSCode&quot;, field: &quot;HSCode&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货物代码&quot;, field: &quot;CargoCode&quot;, width: 100, sortable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;货物名称&quot;, field: &quot;CargoName&quot;, width: 160, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            { title: &lt;/span&gt;&quot;规格型号&quot;, field: &quot;Spcf&quot;, width: 80, sortable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;数量&quot;, field: &quot;Qty&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {
                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 4&lt;span&gt;
                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;长&quot;, field: &quot;Length&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {
                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;宽&quot;, field: &quot;Width&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            {
                title: &lt;/span&gt;&quot;高&quot;, field: &quot;Height&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            { title: &lt;/span&gt;&quot;产销国&quot;, field: &quot;Country&quot;, width: 70, align: 'center'&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;单价&quot;, field: &quot;Price&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;

                    }
                }
            },       

            {
                title: &lt;/span&gt;&quot;总价&quot;, field: &quot;TotalAmt&quot;, width: 100, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                    }
                }
            },
            { title: &lt;/span&gt;&quot;包装&quot;, field: &quot;Package&quot;, width: 70, align: 'center'&lt;span&gt; },
            { title: &lt;/span&gt;&quot;计量单位&quot;, field: &quot;Unit&quot;, width: 70, align: 'center'&lt;span&gt; },
            {
                title: &lt;/span&gt;&quot;总体积&quot;, field: &quot;Vol&quot;, width: 70, align: 'center'&lt;span&gt;, editor: {

                    type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                        required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 4&lt;span&gt;

                    }
                }
            },
            { title: &lt;/span&gt;&quot;品牌&quot;, field: &quot;Brand&quot;, width: 70, align: 'center'&lt;span&gt; }

        ]],

        view: detailview,

        detailFormatter: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, row) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '&amp;lt;div style=&quot;padding:2px&quot;&amp;gt;&amp;lt;table id=&quot;dgINODItem-' + index + '&quot;&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;;

        },

        onExpandRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, row) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ddv = $('#dgINODItem-' +&lt;span&gt; index);
            ddv.datagrid({
                url: &lt;/span&gt;'/InStock/GetLocs?Id=' +&lt;span&gt; row.Id,
                fitColumns: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                singleSelect: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                rownumbers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                loadMsg: &lt;/span&gt;''&lt;span&gt;,
                height: &lt;/span&gt;'auto'&lt;span&gt;,
                columns: [[                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[{&quot;InStockOrderDetailId&quot;:24,&quot;SeqNo&quot;:1,&quot;Loc&quot;:&quot;A121&quot;,&quot;Qty&quot;:121.00,&quot;CreationTime&quot;:&quot;2020-02-17 16:37:05&quot;,&quot;Id&quot;:1}]&lt;/span&gt;
                    { field: 'SeqNo', title: '序号', width: 50&lt;span&gt; },
                    {
                        field: &lt;/span&gt;'Qty', title: '数量', width: 120&lt;span&gt;, editor: {
                            type: &lt;/span&gt;'numberbox'&lt;span&gt;, options: {
                                required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, min: 0, precision: 2&lt;span&gt;
                            }
                        }
                    },
                    {
                        field: &lt;/span&gt;'Loc', title: '库位', width: 150&lt;span&gt;, editor: {
                            type: &lt;/span&gt;'text'&lt;span&gt;, options: {
                                required: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                            }
                        }
                    },

                    { field: &lt;/span&gt;'CreationTime', title: '创建时间', hidden: 'true'&lt;span&gt; }, 

                    { field: &lt;/span&gt;'Id', title: 'Id', width: 50, hidden: 'true'&lt;span&gt; },
                    { field: &lt;/span&gt;'InStockOrderDetailId', title: 'InodId', width: 50, hidden: 'true'&lt;span&gt; }
                ]],

                onResize: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);
                },

                onLoadSuccess: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);

                    }, &lt;/span&gt;0&lt;span&gt;);
                    editIndex &lt;/span&gt;= undefined;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主网格换行&lt;/span&gt;
&lt;span&gt;                },
                onAfterEdit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (rowIndex, rowData, changes) {

                    editIndex &lt;/span&gt;=&lt;span&gt; undefined;
                },

                onClickRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index1, row1) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editIndex !=&lt;span&gt; index1) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (endEditing(ddv)) {
                       ddv.datagrid(&lt;/span&gt;'selectRow', index1).datagrid('beginEdit'&lt;span&gt;, index1);
                            editIndex &lt;/span&gt;=&lt;span&gt; index1;

                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { ddv.datagrid('selectRow'&lt;span&gt;, editIndex); }

                    }
                }
            });
            $(&lt;/span&gt;'#dgINOD').datagrid('fixDetailRowHeight'&lt;span&gt;, index);

        },

        onClickRow: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (index, rowData) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainIndex!=&lt;span&gt;undefined) {
                $(&lt;/span&gt;'#dgINOD').datagrid('collapseRow'&lt;span&gt;, mainIndex);

            }          

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastIndex !=&lt;span&gt; index) {
                $(&lt;/span&gt;'#dgINOD').datagrid('endEdit'&lt;span&gt;, lastIndex);
                editrow(index);
            }

            lastIndex &lt;/span&gt;=&lt;span&gt; index;
            mainIndex &lt;/span&gt;=&lt;span&gt; index;
        },        

        onBeginEdit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (rowIndex, rowData) { 
            setEditing(rowIndex);
        }
    });
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算报价小计&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setEditing(rowIndex) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; editors = $('#dgINOD').datagrid('getEditors'&lt;span&gt;, rowIndex);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; priceEditor = editors[4&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; qtyEditor = editors[0&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lengthEditor = editors[1&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; widthEditor = editors[2&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; heightEditor = editors[3&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; totalVolEditor = editors[6&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; totalAmtEditor = editors[5&lt;span&gt;];
    priceEditor.target.numberbox({
        onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { calculate();}

    });

    qtyEditor.target.numberbox({
        onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            calculate();
            calculateVol();
        }

    });

    lengthEditor.target.numberbox({
        onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { calculateVol(); }
    });

    widthEditor.target.numberbox({
        onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { calculateVol(); }

    });

    heightEditor.target.numberbox({
        onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { calculateVol(); }
    });

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; calculate() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cost = (priceEditor.target.val()) *&lt;span&gt; (qtyEditor.target.val());

        console.log(cost);
        totalAmtEditor.target.numberbox(&lt;/span&gt;&quot;setValue&quot;&lt;span&gt;, cost);
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; calculateVol() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vol = (lengthEditor.target.val() / 100.0) * (widthEditor.target.val() / 100.0) * (heightEditor.target.val() / 100.0)*&lt;br/&gt;&lt;span&gt; (qtyEditor.target.val());
        console.log(vol);
        totalVolEditor.target.numberbox(&lt;/span&gt;&quot;setValue&quot;&lt;span&gt;, vol);
    }

}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; editrow(index) {
    $(&lt;/span&gt;'#dgINOD').datagrid('selectRow'&lt;span&gt;, index)
        .datagrid(&lt;/span&gt;'beginEdit'&lt;span&gt;, index);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; endEdit() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = $('#dgINOD').datagrid('getRows'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows==&lt;span&gt;undefined) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {

        $(&lt;/span&gt;'#dgINOD').datagrid('endEdit'&lt;span&gt;, i);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取入库单明细的库位数据&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setSubGridLoc(effectRow) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ddv = $('#dgINODItem-' +&lt;span&gt; mainIndex);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dgcnt =&lt;span&gt; ddv.datagrid().length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainIndex != undefined &amp;amp;&amp;amp; dgcnt&amp;gt;0&lt;span&gt;) {

        endEditSub(ddv);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; changes = ddv.datagrid('getChanges'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (changes.length) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insed = ddv.datagrid('getChanges', &quot;inserted&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deled = ddv.datagrid('getChanges', &quot;deleted&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; upded = ddv.datagrid('getChanges', &quot;updated&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (insed.length) {
                effectRow[&lt;/span&gt;&quot;locsInserted&quot;] =&lt;span&gt; JSON.stringify(insed);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deled.length) {
                effectRow[&lt;/span&gt;&quot;locsDeleted&quot;] =&lt;span&gt; JSON.stringify(deled);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (upded.length) {
                effectRow[&lt;/span&gt;&quot;locsUpdated&quot;] =&lt;span&gt; JSON.stringify(upded);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; effectRow;

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置入库单明细数据&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setGridDetail(effectRow) { 

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($('#dgINOD').datagrid('getChanges'&lt;span&gt;).length) { 

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inserted = $('#dgINOD').datagrid('getChanges', &quot;inserted&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deleted = $('#dgINOD').datagrid('getChanges', &quot;deleted&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; updated = $('#dgINOD').datagrid('getChanges', &quot;updated&quot;&lt;span&gt;);      

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inserted.length) {
            effectRow[&lt;/span&gt;&quot;inserted&quot;] =&lt;span&gt; JSON.stringify(inserted);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deleted.length) {
            effectRow[&lt;/span&gt;&quot;deleted&quot;] =&lt;span&gt; JSON.stringify(deleted);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (updated.length) {
            effectRow[&lt;/span&gt;&quot;updated&quot;] =&lt;span&gt; JSON.stringify(updated);
        }
     }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; effectRow;

}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; endEditSub(ddv) {    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainIndex !=&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = ddv.datagrid('getRows'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows!=&lt;span&gt;undefined) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {
                ddv.datagrid(&lt;/span&gt;'endEdit'&lt;span&gt;, i);
            }  
        }          

    }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; saveDetail() {
    endEdit();
    $.messager.confirm(&lt;/span&gt;'确认', '您确认要修改吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; effectRow = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; GetINO();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (postData.Id) {
            effectRow[&lt;/span&gt;&quot;postdata&quot;] =&lt;span&gt; JSON.stringify(postData);
        }

        effectRow &lt;/span&gt;=&lt;span&gt; setSubGridLoc(effectRow);
        effectRow &lt;/span&gt;=&lt;span&gt; setGridDetail(effectRow);
        $.post(&lt;/span&gt;&quot;/InStock/Update&quot;, effectRow, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  alert(data);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.success) {
                $.messager.alert(&lt;/span&gt;&quot;提示&quot;&lt;span&gt;, data.result);
                $(&lt;/span&gt;'#dgINOD').datagrid('acceptChanges'&lt;span&gt;);
               }

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                $.messager.alert(&lt;/span&gt;&quot;提示&quot;&lt;span&gt;, data.result);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

        }, &lt;/span&gt;&quot;JSON&quot;&lt;span&gt;) ;      

        })    

}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; init() {
    $(&lt;/span&gt;&quot;#PreDeliveryTimeUpdate&quot;&lt;span&gt;).val(getNowFormatDate());
    $(&lt;/span&gt;&quot;#CreationTimeUpdate&quot;&lt;span&gt;).val(getNowFormatDate());
    $(&lt;/span&gt;&quot;#btnCancle&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {      
        $(&lt;/span&gt;&quot;#divAddUpdINO&quot;).dialog(&quot;close&quot;&lt;span&gt;);  
        $(&lt;/span&gt;'#dgINSO').datagrid('reload'&lt;span&gt;);

    });

    $(&lt;/span&gt;&quot;#btnCancleDO&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;&quot;#divImportCargo&quot;).dialog(&quot;close&quot;&lt;span&gt;);
        $(&lt;/span&gt;'#dgINSO').datagrid('reload'&lt;span&gt;);

    });

 

    $(&lt;/span&gt;&quot;#btnImportDO&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; rows = $('#dgCargo').datagrid('getSelections'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows.length &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证&lt;/span&gt;
            $.messager.confirm('确认', '您确认要保存所选择的货物信息吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r) {

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj_No = $(&quot;#UpdNO&quot;&lt;span&gt;).val();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ids = [];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要不是{}&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {
                        ids.push(rows[i].Id);
                    }

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; {
                        &lt;/span&gt;&quot;Ids&quot;: ids.join(','&lt;span&gt;),
                        &lt;/span&gt;&quot;No&quot;&lt;span&gt;: obj_No
                    };

                    $.post(&lt;/span&gt;&quot;/InStock/ImportCargo&quot;, postData, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data == &quot;OK&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;保存货物信息成功！&quot;&lt;span&gt;);
                            ShowDetail(obj_No);
                        }

                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data == &quot;NO&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;保存货物信息失败！&quot;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                    }); 

                }
            })
        } 

    });

    $(&lt;/span&gt;&quot;#btnSubmit&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; id = $(&quot;#IDUpdate&quot;&lt;span&gt;).val();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == &quot;&quot; || id ==&lt;span&gt; undefined) {
            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;入库单没有保存，请先保存！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证&lt;/span&gt;
            $.messager.confirm('确认', '您确认要提交入库单吗？', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (r) {                  
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; {
                        &lt;/span&gt;&quot;Id&quot;&lt;span&gt;: id                       

                    };

                    $.post(&lt;/span&gt;&quot;/InStock/Submit&quot;, postData, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data == &quot;OK&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;入库单已经提交成功！&quot;&lt;span&gt;);                          

                            $(&lt;/span&gt;&quot;#StatusUpdate&quot;).val(&quot;提交&quot;&lt;span&gt;);
                            SetEnabled(&lt;/span&gt;&quot;提交&quot;&lt;span&gt;);
                        }

                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data == &quot;NO&quot;&lt;span&gt;) {
                            $.messager.alert(&lt;/span&gt;&quot;提示&quot;, &quot;入库单提交失败！&quot;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                    });
                }
            })
    });
}
 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubGridAddRow() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ddv = $('#dgINODItem-' +&lt;span&gt; mainIndex);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = $('#dgINOD').datagrid('getSelected'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mainIndex != undefined &amp;amp;&amp;amp; editIndex!=&lt;span&gt;undefined) {

        ddv.datagrid(&lt;/span&gt;'endEdit'&lt;span&gt;, editIndex);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editIndex ==&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; seqno = ddv.datagrid(&quot;getRows&quot;).length + 1&lt;span&gt;;
        ddv.datagrid(&lt;/span&gt;'insertRow'&lt;span&gt;, {
            index: &lt;/span&gt;0&lt;span&gt;,
            row: { InStockOrderDetailId: row.Id, SeqNo: seqno}
        });
        ddv.datagrid(&lt;/span&gt;'beginEdit', 0&lt;span&gt;);
        editIndex &lt;/span&gt;= 0&lt;span&gt;;
    }

}
 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; endEditing(ddv) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; changes = ddv.datagrid('getChanges'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editIndex == undefined) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ddv.datagrid('validateRow'&lt;span&gt;, editIndex)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证前一行&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回编辑器，结束编辑&lt;/span&gt;
        ddv.datagrid('endEdit'&lt;span&gt;, editIndex);
        editIndex &lt;/span&gt;=&lt;span&gt; undefined;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; }
}
 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; collapseRows() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = $('#dgINOD').datagrid('getRows'&lt;span&gt;);
    $.each(rows, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i, k) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前所有展开的子网格&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; expander = $('#dgINOD').datagrid('getExpander'&lt;span&gt;, i);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expander.length &amp;amp;&amp;amp; expander.hasClass('datagrid-row-collapse'&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k.id !=&lt;span&gt; row.id) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折叠上一次展开的子网格&lt;/span&gt;
                $('#dgINOD').datagrid('collapseRow'&lt;span&gt;, i);
            }
        }
    });

} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetINO() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; {
        &lt;/span&gt;&quot;No&quot;: $(&quot;#UpdNO&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;DeliveryNo&quot;: &quot;&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;PreDeliveryTime&quot;: $(&quot;#PreDeliveryTimeUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;CustomerCode&quot;: $(&quot;#CustomerCodeUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;OwnerName&quot;: $(&quot;#OwnerNameUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;OwnerCode&quot;: $(&quot;#OwnerCodeUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;CustomerName&quot;: $(&quot;#CustomerNameUpdate&quot;&lt;span&gt;).val(),

        &lt;/span&gt;&quot;CreationTime&quot;: $(&quot;#CreationTimeUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;CheckTime&quot;: $(&quot;#CheckTimeUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;WarehouseType&quot;: $(&quot;#WarehouseTypeUpdate&quot;&lt;span&gt;).val(),

        &lt;/span&gt;&quot;WarehouseNo&quot;: $(&quot;#WarehouseNoUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;Oper&quot;: $(&quot;#OperUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;Receiver&quot;: $(&quot;#ReceiverUpdate&quot;&lt;span&gt;).val(),

        &lt;/span&gt;&quot;Nwt&quot;: $(&quot;#NwtUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;Remark&quot;: $(&quot;#RemarkUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;ReceiveTime&quot;: $(&quot;#ReceiveTimeUpdate&quot;&lt;span&gt;).val(),      

        &lt;/span&gt;&quot;Status&quot;: $(&quot;#StatusUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;Gwt&quot;: $(&quot;#GwtUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;Checker&quot;: $(&quot;#CheckerUpdate&quot;&lt;span&gt;).val(),
        &lt;/span&gt;&quot;PackageQty&quot;: $(&quot;#PackageQtyUpdate&quot;&lt;span&gt;).val(),

        &lt;/span&gt;&quot;LastUpdateTime&quot;: &quot;&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;LastOper&quot;:&quot;&quot;&lt;span&gt;

    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = $(&quot;#IDUpdate&quot;&lt;span&gt;).val();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(id==&quot;&quot; || id==&lt;span&gt;undefined)) {
        postData.Id &lt;/span&gt;=&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; postData;

} 

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showINO(row) {     

    $(&lt;/span&gt;&quot;#IDUpdate&quot;&lt;span&gt;).val(row.Id);
    $(&lt;/span&gt;&quot;#UpdNO&quot;&lt;span&gt;).val(row.No);
    $(&lt;/span&gt;&quot;#PreDeliveryTimeUpdate&quot;&lt;span&gt;).val(row.PreDeliveryTime);
    $(&lt;/span&gt;&quot;#CustomerCodeUpdate&quot;&lt;span&gt;).val(row.CustomerCode);

    $(&lt;/span&gt;&quot;#PackageQtyUpdate&quot;&lt;span&gt;).val(row.PackageQty);
    $(&lt;/span&gt;&quot;#CustomerNameUpdate&quot;&lt;span&gt;).val(row.CustomerName);
    $(&lt;/span&gt;&quot;#OwnerCodeUpdate&quot;&lt;span&gt;).val(row.OwnerCode);
    $(&lt;/span&gt;&quot;#OwnerNameUpdate&quot;&lt;span&gt;).val(row.OwnerName);

    $(&lt;/span&gt;&quot;#CreationTimeUpdate&quot;&lt;span&gt;).val(row.CreationTime);
    $(&lt;/span&gt;&quot;#CheckTimeUpdate&quot;&lt;span&gt;).val(row.CheckTime);
    $(&lt;/span&gt;&quot;#WarehouseTypeUpdate&quot;&lt;span&gt;).val(row.WarehouseType);

    $(&lt;/span&gt;&quot;#WarehouseNoUpdate&quot;&lt;span&gt;).val(row.WarehouseNo);
    $(&lt;/span&gt;&quot;#OperUpdate&quot;&lt;span&gt;).val(row.Oper);

    $(&lt;/span&gt;&quot;#ReceiverUpdate&quot;&lt;span&gt;).val(row.Receiver);
    $(&lt;/span&gt;&quot;#NwtUpdate&quot;&lt;span&gt;).val(row.Nwt);

    $(&lt;/span&gt;&quot;#RemarkUpdate&quot;&lt;span&gt;).val(row.Remark);
    $(&lt;/span&gt;&quot;#ReceiveTimeUpdate&quot;&lt;span&gt;).val(row.ReceiveTime);
    $(&lt;/span&gt;&quot;#StatusUpdate&quot;&lt;span&gt;).val(row.Status);   

    $(&lt;/span&gt;&quot;#GwtUpdate&quot;&lt;span&gt;).val(row.Gwt);
    $(&lt;/span&gt;&quot;#CheckerUpdate&quot;&lt;span&gt;).val(row.Checker);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------系统管理--&amp;gt;入库单管理结束------------------------//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Wed, 06 May 2020 13:58:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>在上面文章abp(net core)+easyui+efcore实现仓储管理系统——入库管理之十(四十六) 的学习之后，我们已经实现了入库单的基本功能，增加，删除，修改。接下来，我们实现添加库位的功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chillsrc/p/12839212.html</dc:identifier>
</item>
</channel>
</rss>